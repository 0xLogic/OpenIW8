/*
==============
CG_KillstreakSlotDown
==============
*/

void __fastcall CG_KillstreakSlotDown(LocalClientNum_t localClientNum, int bindingIndex)
{
  ?CG_KillstreakSlotDown@@YAXW4LocalClientNum_t@@H@Z(localClientNum, bindingIndex);
}

/*
==============
CG_NightVisionViewModelGogglesShouldBeAttached
==============
*/

bool __fastcall CG_NightVisionViewModelGogglesShouldBeAttached(LocalClientNum_t localClientNum)
{
  return ?CG_NightVisionViewModelGogglesShouldBeAttached@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CgWeaponSystem::IsPlayerWeaponLaserOn
==============
*/

bool __fastcall CgWeaponSystem::IsPlayerWeaponLaserOn(CgWeaponSystem *this, const Weapon *r_weapon)
{
  return ?IsPlayerWeaponLaserOn@CgWeaponSystem@@UEBA_NAEBUWeapon@@@Z(this, r_weapon);
}

/*
==============
CG_SelectWeapon
==============
*/

bool __fastcall CG_SelectWeapon(LocalClientNum_t localClientNum, const Weapon *weapon, int useAltMode)
{
  return ?CG_SelectWeapon@@YA_NW4LocalClientNum_t@@AEBUWeapon@@H@Z(localClientNum, weapon, useAltMode);
}

/*
==============
CgWeaponSystem::ChargedWeaponUpdateRumbleAndSound
==============
*/

void __fastcall CgWeaponSystem::ChargedWeaponUpdateRumbleAndSound(CgWeaponSystem *this, const playerState_s *ps, centity_t *cent, const Weapon *weapon, bool isAlternate, int bViewModel)
{
  ?ChargedWeaponUpdateRumbleAndSound@CgWeaponSystem@@IEBAXPEBUplayerState_s@@PEAUcentity_t@@AEBUWeapon@@_NH@Z(this, ps, cent, weapon, isAlternate, bViewModel);
}

/*
==============
CG_SaveViewModelAnimTrees
==============
*/

void __fastcall CG_SaveViewModelAnimTrees(MemoryFile *memFile, const playerState_s *ps, LocalClientNum_t localClientNum)
{
  ?CG_SaveViewModelAnimTrees@@YAXPEAUMemoryFile@@PEBUplayerState_s@@W4LocalClientNum_t@@@Z(memFile, ps, localClientNum);
}

/*
==============
CG_Weapons_GetEntityHitId
==============
*/

unsigned __int16 __fastcall CG_Weapons_GetEntityHitId(const trace_t *trace)
{
  return ?CG_Weapons_GetEntityHitId@@YAGPEBUtrace_t@@@Z(trace);
}

/*
==============
CG_AddViewWeapon
==============
*/

void __fastcall CG_AddViewWeapon(LocalClientNum_t localClientNum)
{
  ?CG_AddViewWeapon@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CgWeaponSystem::ChargedWeaponUpdateClientOnlyChargeAmountOverride
==============
*/

void __fastcall CgWeaponSystem::ChargedWeaponUpdateClientOnlyChargeAmountOverride(CgWeaponSystem *this, const playerState_s *ps, centity_t *cent, const PlayerHandIndex hand, const Weapon *weapon, bool isAlternate)
{
  ?ChargedWeaponUpdateClientOnlyChargeAmountOverride@CgWeaponSystem@@IEBAXPEBUplayerState_s@@PEAUcentity_t@@W4PlayerHandIndex@@AEBUWeapon@@_N@Z(this, ps, cent, hand, weapon, isAlternate);
}

/*
==============
CG_Weapons_RebuildWeaponsArray
==============
*/

void __fastcall CG_Weapons_RebuildWeaponsArray(LocalClientNum_t localClientNum)
{
  ?CG_Weapons_RebuildWeaponsArray@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_UpdateWeaponViewmodels
==============
*/

void __fastcall CG_UpdateWeaponViewmodels(LocalClientNum_t localClientNum)
{
  ?CG_UpdateWeaponViewmodels@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_CycleNeedsToWaitForHoldTime
==============
*/

bool __fastcall CG_CycleNeedsToWaitForHoldTime(LocalClientNum_t localClientNum)
{
  return ?CG_CycleNeedsToWaitForHoldTime@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_Weapons_GetStowedOffsetModel
==============
*/

XModel *__fastcall CG_Weapons_GetStowedOffsetModel(const WeaponDef *weapDef)
{
  return ?CG_Weapons_GetStowedOffsetModel@@YAPEAUXModel@@PEBUWeaponDef@@@Z(weapDef);
}

/*
==============
CG_Weapons_GetVisibilityBoneIndex
==============
*/

int __fastcall CG_Weapons_GetVisibilityBoneIndex(const DObj *obj, const characterInfo_t *ci, const Weapon *r_weapon, const bool isAlternate, PlayerHandIndex hand, bool *outUseWeaponTag)
{
  return ?CG_Weapons_GetVisibilityBoneIndex@@YAHPEBUDObj@@PEBUcharacterInfo_t@@AEBUWeapon@@_NW4PlayerHandIndex@@PEA_N@Z(obj, ci, r_weapon, isAlternate, hand, outUseWeaponTag);
}

/*
==============
CG_NightVisionGetExposureAdjustTimings
==============
*/

void __fastcall CG_NightVisionGetExposureAdjustTimings(const int NVGToggleTime, int *outExposureStartBlendInTime, int *outExposureStartBlendOutTime, int *outExposureInDuration, int *outExposureOutDuration)
{
  ?CG_NightVisionGetExposureAdjustTimings@@YAXHPEAH000@Z(NVGToggleTime, outExposureStartBlendInTime, outExposureStartBlendOutTime, outExposureInDuration, outExposureOutDuration);
}

/*
==============
CG_Weapons_CurrentWeaponCanAltToggle
==============
*/

bool __fastcall CG_Weapons_CurrentWeaponCanAltToggle(LocalClientNum_t localClientNum)
{
  return ?CG_Weapons_CurrentWeaponCanAltToggle@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CgWeaponSystem::TrySpawnTracer
==============
*/

void __fastcall CgWeaponSystem::TrySpawnTracer(CgWeaponSystem *this, const int bulletId, bool needsDeferring, bool blendFromViewmodel, const int inflictorEntNum, const bitarray<64> *r_inflictorPerks, PlayerHandIndex hand, const TagPair sourceTagPair, const vec3_t *tracerStart, const vec3_t *tracerEnd, const Weapon *r_weapon, bool isAlternate, int spawnDelay)
{
  ?TrySpawnTracer@CgWeaponSystem@@QEBAXH_N0HAEBV?$bitarray@$0EA@@@W4PlayerHandIndex@@VTagPair@@AEBTvec3_t@@4AEBUWeapon@@0H@Z(this, bulletId, needsDeferring, blendFromViewmodel, inflictorEntNum, r_inflictorPerks, hand, sourceTagPair, tracerStart, tracerEnd, r_weapon, isAlternate, spawnDelay);
}

/*
==============
CG_ExplosiveImpactOnShieldEvent
==============
*/

void __fastcall CG_ExplosiveImpactOnShieldEvent(LocalClientNum_t localClientNum)
{
  ?CG_ExplosiveImpactOnShieldEvent@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_OffhandGestureWeaponHideParts
==============
*/

void __fastcall CG_OffhandGestureWeaponHideParts(LocalClientNum_t localClientNum, const PlayerHandIndex hand)
{
  ?CG_OffhandGestureWeaponHideParts@@YAXW4LocalClientNum_t@@W4PlayerHandIndex@@@Z(localClientNum, hand);
}

/*
==============
CG_FireWeaponWithHighPrecisionData
==============
*/

void __fastcall CG_FireWeaponWithHighPrecisionData(LocalClientNum_t localClientNum, centity_t *cent, int event, int knownHitClientNum, const TagPair weaponFlashTagPair, const Weapon *weapon, bool isAlternate, PlayerHandIndex hand, bool isPlayerView, bool isDualWield, bool bNoTracer, const CgFireEventHighPrecisionData *highPrecisionFireData)
{
  ?CG_FireWeaponWithHighPrecisionData@@YAXW4LocalClientNum_t@@PEAUcentity_t@@HHVTagPair@@AEBUWeapon@@_NW4PlayerHandIndex@@444PEBUCgFireEventHighPrecisionData@@@Z(localClientNum, cent, event, knownHitClientNum, weaponFlashTagPair, weapon, isAlternate, hand, isPlayerView, isDualWield, bNoTracer, highPrecisionFireData);
}

/*
==============
CG_OffhandShield_CheckViewModelUpdate
==============
*/

bool __fastcall CG_OffhandShield_CheckViewModelUpdate(const LocalClientNum_t localClientNum)
{
  return ?CG_OffhandShield_CheckViewModelUpdate@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
MovementAnimState::GetCycleAnimation
==============
*/

weapAnimFiles_t __fastcall MovementAnimState::GetCycleAnimation(MovementAnimState *this, const MovementAnimState::State state)
{
  return ?GetCycleAnimation@MovementAnimState@@AEBA?AW4weapAnimFiles_t@@W4State@1@@Z(this, state);
}

/*
==============
CG_ShouldTriggerOffhandShield
==============
*/

bool __fastcall CG_ShouldTriggerOffhandShield(LocalClientNum_t localClientNum, int sourceEntityNum)
{
  return ?CG_ShouldTriggerOffhandShield@@YA_NW4LocalClientNum_t@@H@Z(localClientNum, sourceEntityNum);
}

/*
==============
CgWeaponSystem::GetIconDimsForPlayer
==============
*/

int __fastcall CgWeaponSystem::GetIconDimsForPlayer(CgWeaponSystem *this, const centity_t *cent, float *x, float *y, float *w, float *h, bool forceCheck)
{
  return ?GetIconDimsForPlayer@CgWeaponSystem@@QEBAHPEBUcentity_t@@PEAM111_N@Z(this, cent, x, y, w, h, forceCheck);
}

/*
==============
MovementAnimState::GetTransitionAnimation
==============
*/

weapAnimFiles_t __fastcall MovementAnimState::GetTransitionAnimation(MovementAnimState *this, MovementAnimState::State prevState, const MovementAnimState::State nextState)
{
  return ?GetTransitionAnimation@MovementAnimState@@AEBA?AW4weapAnimFiles_t@@W4State@1@W431@@Z(this, prevState, nextState);
}

/*
==============
CAssistTarget::GetEntNum
==============
*/

int __fastcall CAssistTarget::GetEntNum(CAssistTarget *this)
{
  return ?GetEntNum@CAssistTarget@@UEBAHXZ(this);
}

/*
==============
CgWeaponSystem::ChargedWeaponUpdateChargeStateForLocalPlayer
==============
*/

void __fastcall CgWeaponSystem::ChargedWeaponUpdateChargeStateForLocalPlayer(CgWeaponSystem *this, const playerState_s *ps)
{
  ?ChargedWeaponUpdateChargeStateForLocalPlayer@CgWeaponSystem@@IEBAXPEBUplayerState_s@@@Z(this, ps);
}

/*
==============
CG_DebugBulletFireLog_ShouldLog
==============
*/

bool __fastcall CG_DebugBulletFireLog_ShouldLog(const int entNum)
{
  return ?CG_DebugBulletFireLog_ShouldLog@@YA_NH@Z(entNum);
}

/*
==============
CG_SndUpdateSubmix
==============
*/

void __fastcall CG_SndUpdateSubmix(LocalClientNum_t localClientNum)
{
  ?CG_SndUpdateSubmix@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CgWeaponSystem::DrawDebugBulletLines
==============
*/

void __fastcall CgWeaponSystem::DrawDebugBulletLines(CgWeaponSystem *this)
{
  ?DrawDebugBulletLines@CgWeaponSystem@@QEAAXXZ(this);
}

/*
==============
CG_Weapons_ToggleWeaponAltMode
==============
*/

bool __fastcall CG_Weapons_ToggleWeaponAltMode(LocalClientNum_t localClientNum)
{
  return ?CG_Weapons_ToggleWeaponAltMode@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_Weapons_IsBulletWeapon
==============
*/

int __fastcall CG_Weapons_IsBulletWeapon(const Weapon *weapon, bool isAlternate)
{
  return ?CG_Weapons_IsBulletWeapon@@YAHAEBUWeapon@@_N@Z(weapon, isAlternate);
}

/*
==============
CG_GetImpactEffectForWeapon
==============
*/

void __fastcall CG_GetImpactEffectForWeapon(LocalClientNum_t localClientNum, const int sourceEntityNum, const int targetEntityNum, const bool filterByContents, const int hitContents, const Weapon *weapon, bool isAlternate, const int surfType, const unsigned int impactFlags, SndHitArmorType hitArmorType, FXRegisteredDef *outFx, const SndAliasList **outSnd, bool *outIsSfxExplosion)
{
  ?CG_GetImpactEffectForWeapon@@YAXW4LocalClientNum_t@@HH_NHAEBUWeapon@@_NHIW4SndHitArmorType@@QEAVFXRegisteredDef@@PEAPEBUSndAliasList@@PEA_N@Z(localClientNum, sourceEntityNum, targetEntityNum, filterByContents, hitContents, weapon, isAlternate, surfType, impactFlags, hitArmorType, outFx, outSnd, outIsSfxExplosion);
}

/*
==============
CG_GetWeaponZoom
==============
*/

double __fastcall CG_GetWeaponZoom(const cg_t *cgameGlob, const Weapon *weapon, const float weapPosFrac, const CG_FovSpace fovSpace)
{
  double result; 

  *(float *)&result = ?CG_GetWeaponZoom@@YAMPEBVcg_t@@AEBUWeapon@@MW4CG_FovSpace@@@Z(cgameGlob, weapon, weapPosFrac, fovSpace);
  return result;
}

/*
==============
CgWeaponSystem::ShouldWeaponPing
==============
*/

int __fastcall CgWeaponSystem::ShouldWeaponPing(CgWeaponSystem *this, const centity_t *cent, const Weapon *weapon, const bool isAlternate, const vec3_t *origin)
{
  return ?ShouldWeaponPing@CgWeaponSystem@@UEBAHPEBUcentity_t@@AEBUWeapon@@_NAEBTvec3_t@@@Z(this, cent, weapon, isAlternate, origin);
}

/*
==============
CG_Weapons_CreateRiotShieldPhysics
==============
*/

void __fastcall CG_Weapons_CreateRiotShieldPhysics(LocalClientNum_t localClientNum, const DObj *obj, const XModel *model, int entityNum)
{
  ?CG_Weapons_CreateRiotShieldPhysics@@YAXW4LocalClientNum_t@@PEBUDObj@@PEBUXModel@@H@Z(localClientNum, obj, model, entityNum);
}

/*
==============
CgWeaponSystem::AddDebugBulletLine
==============
*/

void __fastcall CgWeaponSystem::AddDebugBulletLine(CgWeaponSystem *this, const vec3_t *start, const vec3_t *end)
{
  ?AddDebugBulletLine@CgWeaponSystem@@QEAAXAEBTvec3_t@@0@Z(this, start, end);
}

/*
==============
CG_GetLocalClientGlobalsForEnt
==============
*/

cg_t *__fastcall CG_GetLocalClientGlobalsForEnt(int entityNum)
{
  return ?CG_GetLocalClientGlobalsForEnt@@YAPEAVcg_t@@H@Z(entityNum);
}

/*
==============
CgWeaponSystem::PlayPullbackSound
==============
*/

void __fastcall CgWeaponSystem::PlayPullbackSound(CgWeaponSystem *this, const int entNum, const bool isPlayerView, const Weapon *r_weapon, const bool isAlternate)
{
  ?PlayPullbackSound@CgWeaponSystem@@QEBAXH_NAEBUWeapon@@0@Z(this, entNum, isPlayerView, r_weapon, isAlternate);
}

/*
==============
CG_IsJogging
==============
*/

bool __fastcall CG_IsJogging(LocalClientNum_t localClientNum)
{
  return ?CG_IsJogging@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_IsAutoSimFiring
==============
*/

bool __fastcall CG_IsAutoSimFiring(cg_t *cgameGlob)
{
  return ?CG_IsAutoSimFiring@@YA_NPEAVcg_t@@@Z(cgameGlob);
}

/*
==============
CG_GetWeaponDisplayName
==============
*/

const char *__fastcall CG_GetWeaponDisplayName(const Weapon *weapon, bool isAlternate, char *outputBuffer, unsigned __int64 bufferLen, bool isNewlineSpacer)
{
  return ?CG_GetWeaponDisplayName@@YAPEBDAEBUWeapon@@_NPEAD_K1@Z(weapon, isAlternate, outputBuffer, bufferLen, isNewlineSpacer);
}

/*
==============
CG_Weapons_ToggleEquip
==============
*/

void __fastcall CG_Weapons_ToggleEquip(LocalClientNum_t localClientNum)
{
  ?CG_Weapons_ToggleEquip@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CgWeaponSystem::SimulateBulletFire_DoBulletPathSim
==============
*/

bool __fastcall CgWeaponSystem::SimulateBulletFire_DoBulletPathSim(CgWeaponSystem *this, BulletFireParams *bp, const int bulletId, const Weapon *weapon, bool isAlternate, centity_t *inflictorEnt, const bitarray<64> *r_attackerPerks, const int knownHitClientNum, const int autoTargetedEntNum, const scr_string_t autoTargetedEntTag, const vec3_t *tracerStart, float aimSpreadAmount, bool isPlayerWeaponView, PlayerHandIndex hand, const TagPair tagPair, const int shotIndex, bool shouldSpawnTracer, bool shouldSpawnExitTracers, bool shouldDeferEvents, bool forceClientSideImpactFx, vec3_t *outLastBulletPos)
{
  return ?SimulateBulletFire_DoBulletPathSim@CgWeaponSystem@@QEAA_NPEAUBulletFireParams@@HAEBUWeapon@@_NPEAUcentity_t@@AEBV?$bitarray@$0EA@@@HHW4scr_string_t@@AEBTvec3_t@@M2W4PlayerHandIndex@@VTagPair@@H2222AEAT7@@Z(this, bp, bulletId, weapon, isAlternate, inflictorEnt, r_attackerPerks, knownHitClientNum, autoTargetedEntNum, autoTargetedEntTag, tracerStart, aimSpreadAmount, isPlayerWeaponView, hand, tagPair, shotIndex, shouldSpawnTracer, shouldSpawnExitTracers, shouldDeferEvents, forceClientSideImpactFx, outLastBulletPos);
}

/*
==============
CG_GetAirburstMarkDistance
==============
*/

int __fastcall CG_GetAirburstMarkDistance(LocalClientNum_t localClientNum, playerState_s *ps, unsigned __int64 buttons, unsigned int *outDistance)
{
  return ?CG_GetAirburstMarkDistance@@YAHW4LocalClientNum_t@@PEAUplayerState_s@@_KPEAI@Z(localClientNum, ps, buttons, outDistance);
}

/*
==============
MovementAnimState::UpdateInternal
==============
*/

void __fastcall MovementAnimState::UpdateInternal(MovementAnimState *this, const LocalClientNum_t localClientNum, const PlayerHandIndex hand, const playerState_s *ps, const MovementAnimState::State newGoal)
{
  ?UpdateInternal@MovementAnimState@@AEAAXW4LocalClientNum_t@@W4PlayerHandIndex@@PEBUplayerState_s@@W4State@1@@Z(this, localClientNum, hand, ps, newGoal);
}

/*
==============
CG_DebugBulletFireLog_AddServerEntry
==============
*/

void __fastcall CG_DebugBulletFireLog_AddServerEntry(const int entNum, const int serverTime, const vec3_t *bulletOrigin, const vec3_t *bulletDir)
{
  ?CG_DebugBulletFireLog_AddServerEntry@@YAXHHAEBTvec3_t@@0@Z(entNum, serverTime, bulletOrigin, bulletDir);
}

/*
==============
CgWeaponSystem::OffhandWeaponVmFxTryStart
==============
*/

void __fastcall CgWeaponSystem::OffhandWeaponVmFxTryStart(CgWeaponSystem *this)
{
  ?OffhandWeaponVmFxTryStart@CgWeaponSystem@@IEBAXXZ(this);
}

/*
==============
CG_ValidateWeaponAnimGroupsUniqueness
==============
*/

void CG_ValidateWeaponAnimGroupsUniqueness(void)
{
  ?CG_ValidateWeaponAnimGroupsUniqueness@@YAXXZ();
}

/*
==============
CgWeaponSystem::ChargedWeaponOnBeginCharging
==============
*/

void __fastcall CgWeaponSystem::ChargedWeaponOnBeginCharging(CgWeaponSystem *this, const playerState_s *ps, const centity_t *cent, const Weapon *weapon, bool isAlternate, bool isPlayerView, ClientChargeWeaponSoundRumbleInfo *soundRumbleInfo)
{
  ?ChargedWeaponOnBeginCharging@CgWeaponSystem@@IEBAXPEBUplayerState_s@@PEBUcentity_t@@AEBUWeapon@@_N3PEAUClientChargeWeaponSoundRumbleInfo@@@Z(this, ps, cent, weapon, isAlternate, isPlayerView, soundRumbleInfo);
}

/*
==============
CgWeaponSystem::BloodSplatterOnShield
==============
*/

void __fastcall CgWeaponSystem::BloodSplatterOnShield(CgWeaponSystem *this, int entityNum)
{
  ?BloodSplatterOnShield@CgWeaponSystem@@IEBAXH@Z(this, entityNum);
}

/*
==============
CG_RegisterWeapon
==============
*/

bool __fastcall CG_RegisterWeapon(LocalClientNum_t localClientNum, const playerState_s *ps, const GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64> prevWeaponFlags, const Weapon *weapon, ClientPlayerWeaponInfo *weapInfo)
{
  return ?CG_RegisterWeapon@@YA_NW4LocalClientNum_t@@PEBUplayerState_s@@V?$GameModeFlagContainer@W4PWeaponFlagsCommon@@W4PWeaponFlagsSP@@W4PWeaponFlagsMP@@$0EA@@@AEBUWeapon@@PEAUClientPlayerWeaponInfo@@@Z(localClientNum, ps, prevWeaponFlags, weapon, weapInfo);
}

/*
==============
CG_FireWeaponWithLodAndHighPrecisionData
==============
*/

void __fastcall CG_FireWeaponWithLodAndHighPrecisionData(LocalClientNum_t localClientNum, centity_t *cent, int event, int knownHitClientNum, const TagPair weaponFlashTagPair, const Weapon *weapon, bool isAlternate, PlayerHandIndex hand, bool isPlayerView, bool isDualWield, bool bNoTracer, const CgEventLodData *eventLodData, const CgFireEventHighPrecisionData *highPrecisionFireData)
{
  ?CG_FireWeaponWithLodAndHighPrecisionData@@YAXW4LocalClientNum_t@@PEAUcentity_t@@HHVTagPair@@AEBUWeapon@@_NW4PlayerHandIndex@@444AEBUCgEventLodData@@PEBUCgFireEventHighPrecisionData@@@Z(localClientNum, cent, event, knownHitClientNum, weaponFlashTagPair, weapon, isAlternate, hand, isPlayerView, isDualWield, bNoTracer, eventLodData, highPrecisionFireData);
}

/*
==============
CAssistTarget::GetTarget
==============
*/

const centity_t *__fastcall CAssistTarget::GetTarget(CAssistTarget *this)
{
  return ?GetTarget@CAssistTarget@@QEBAPEBUcentity_t@@XZ(this);
}

/*
==============
CG_FireWeapon
==============
*/

void __fastcall CG_FireWeapon(LocalClientNum_t localClientNum, centity_t *cent, int event, int knownHitClientNum, const TagPair weaponFlashTagPair, const Weapon *weapon, bool isAlternate, PlayerHandIndex hand, bool isPlayerView, bool isDualWield, bool bNoTracer)
{
  ?CG_FireWeapon@@YAXW4LocalClientNum_t@@PEAUcentity_t@@HHVTagPair@@AEBUWeapon@@_NW4PlayerHandIndex@@444@Z(localClientNum, cent, event, knownHitClientNum, weaponFlashTagPair, weapon, isAlternate, hand, isPlayerView, isDualWield, bNoTracer);
}

/*
==============
CG_GetViewModelPoseForHand
==============
*/

cpose_t *__fastcall CG_GetViewModelPoseForHand(LocalClientNum_t localClientNum, PlayerHandIndex hand)
{
  return ?CG_GetViewModelPoseForHand@@YAPEAUcpose_t@@W4LocalClientNum_t@@W4PlayerHandIndex@@@Z(localClientNum, hand);
}

/*
==============
CgWeaponSystem::ChargedWeaponStopAllSoundsAndRumble
==============
*/

void __fastcall CgWeaponSystem::ChargedWeaponStopAllSoundsAndRumble(CgWeaponSystem *this, const int entNum, ClientChargeWeaponSoundRumbleInfo *soundRumbleInfo)
{
  ?ChargedWeaponStopAllSoundsAndRumble@CgWeaponSystem@@IEBAXHPEAUClientChargeWeaponSoundRumbleInfo@@@Z(this, entNum, soundRumbleInfo);
}

/*
==============
CG_UpdateViewModelPose
==============
*/

void __fastcall CG_UpdateViewModelPose(const DObj *obj, LocalClientNum_t localClientNum)
{
  ?CG_UpdateViewModelPose@@YAXPEBUDObj@@W4LocalClientNum_t@@@Z(obj, localClientNum);
}

/*
==============
CgWeaponSystem::ChargeWeaponOnRespawn
==============
*/

void __fastcall CgWeaponSystem::ChargeWeaponOnRespawn(CgWeaponSystem *this, const playerState_s *ps)
{
  ?ChargeWeaponOnRespawn@CgWeaponSystem@@QEAAXPEBUplayerState_s@@@Z(this, ps);
}

/*
==============
CG_DebugBulletFireLog_AddClientEntry
==============
*/

void __fastcall CG_DebugBulletFireLog_AddClientEntry(const int entNum, const int serverTime, const vec3_t *bulletOrigin, const vec3_t *bulletDir)
{
  ?CG_DebugBulletFireLog_AddClientEntry@@YAXHHAEBTvec3_t@@0@Z(entNum, serverTime, bulletOrigin, bulletDir);
}

/*
==============
CG_Weapons_HoldBreathInit
==============
*/

void __fastcall CG_Weapons_HoldBreathInit(cg_t *cgameGlob)
{
  ?CG_Weapons_HoldBreathInit@@YAXPEAVcg_t@@@Z(cgameGlob);
}

/*
==============
CG_ForceSwitchToValidWeapon
==============
*/

int __fastcall CG_ForceSwitchToValidWeapon(LocalClientNum_t localClientNum)
{
  return ?CG_ForceSwitchToValidWeapon@@YAHW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_ExplosiveSplashOnShieldEvent
==============
*/

void __fastcall CG_ExplosiveSplashOnShieldEvent(LocalClientNum_t localClientNum, int originalDamage)
{
  ?CG_ExplosiveSplashOnShieldEvent@@YAXW4LocalClientNum_t@@H@Z(localClientNum, originalDamage);
}

/*
==============
CG_DisplayViewmodelAnim
==============
*/

void __fastcall CG_DisplayViewmodelAnim(LocalClientNum_t localClientNum)
{
  ?CG_DisplayViewmodelAnim@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CgWeaponSystem::ClientViewLockedOnTurret
==============
*/

int __fastcall CgWeaponSystem::ClientViewLockedOnTurret(CgWeaponSystem *this, int entnum)
{
  return ?ClientViewLockedOnTurret@CgWeaponSystem@@QEBAHH@Z(this, entnum);
}

/*
==============
CG_LoadViewModelAnimTrees
==============
*/

void __fastcall CG_LoadViewModelAnimTrees(SaveGame *save, const playerState_s *ps, LocalClientNum_t localClientNum)
{
  ?CG_LoadViewModelAnimTrees@@YAXPEAUSaveGame@@PEBUplayerState_s@@W4LocalClientNum_t@@@Z(save, ps, localClientNum);
}

/*
==============
CG_GetImpactEffectList
==============
*/

void __fastcall CG_GetImpactEffectList(int impactType, int surfaceType, bool isFlesh, bool isExit, bool isNoImpact, FXRegisteredDef *outFx)
{
  ?CG_GetImpactEffectList@@YAXHH_N00QEAVFXRegisteredDef@@@Z(impactType, surfaceType, isFlesh, isExit, isNoImpact, outFx);
}

/*
==============
MovementAnimState::GetOffsetAnimation
==============
*/

weapAnimFiles_t __fastcall MovementAnimState::GetOffsetAnimation(MovementAnimState *this, const MovementAnimState::State state)
{
  return ?GetOffsetAnimation@MovementAnimState@@AEBA?AW4weapAnimFiles_t@@W4State@1@@Z(this, state);
}

/*
==============
CG_PlayerUsingOutlineEnemiesTurret
==============
*/

bool __fastcall CG_PlayerUsingOutlineEnemiesTurret(LocalClientNum_t localClientNum)
{
  return ?CG_PlayerUsingOutlineEnemiesTurret@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_NightVisionIsAvailable
==============
*/

bool __fastcall CG_NightVisionIsAvailable(LocalClientNum_t localClientNum)
{
  return ?CG_NightVisionIsAvailable@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CgWeaponSystem::ChargedWeaponOnMaxCharge
==============
*/

void __fastcall CgWeaponSystem::ChargedWeaponOnMaxCharge(CgWeaponSystem *this, const playerState_s *ps, const centity_t *cent, const Weapon *weapon, bool isAlternate, bool isPlayerView, ClientChargeWeaponSoundRumbleInfo *soundRumbleInfo)
{
  ?ChargedWeaponOnMaxCharge@CgWeaponSystem@@IEBAXPEBUplayerState_s@@PEBUcentity_t@@AEBUWeapon@@_N3PEAUClientChargeWeaponSoundRumbleInfo@@@Z(this, ps, cent, weapon, isAlternate, isPlayerView, soundRumbleInfo);
}

/*
==============
CG_FireWeaponRicochet
==============
*/

void __fastcall CG_FireWeaponRicochet(LocalClientNum_t localClientNum, centity_t *attackerEnt, centity_t *shieldEnt, const vec3_t *firePos, const vec3_t *fireDir, int ricochetCount, float travelDistance, const Weapon *weapon, bool isAlternate, PlayerHandIndex hand, bool isPlayerView, bool isDualWield)
{
  ?CG_FireWeaponRicochet@@YAXW4LocalClientNum_t@@PEAUcentity_t@@1AEBTvec3_t@@2HMAEBUWeapon@@_NW4PlayerHandIndex@@44@Z(localClientNum, attackerEnt, shieldEnt, firePos, fireDir, ricochetCount, travelDistance, weapon, isAlternate, hand, isPlayerView, isDualWield);
}

/*
==============
CG_BulletHitClientShieldEvent
==============
*/

void __fastcall CG_BulletHitClientShieldEvent(LocalClientNum_t localClientNum, int sourceEntityNum, const Weapon *weapon, bool isAlternate, int surfType, int event, unsigned int eventParm)
{
  ?CG_BulletHitClientShieldEvent@@YAXW4LocalClientNum_t@@HAEBUWeapon@@_NHHI@Z(localClientNum, sourceEntityNum, weapon, isAlternate, surfType, event, eventParm);
}

/*
==============
CG_GetEntWeapon
==============
*/

const Weapon *__fastcall CG_GetEntWeapon(LocalClientNum_t localClientNum, const centity_t *cent)
{
  return ?CG_GetEntWeapon@@YAAEBUWeapon@@W4LocalClientNum_t@@PEBUcentity_t@@@Z(localClientNum, cent);
}

/*
==============
CG_BinocularsADS
==============
*/

bool __fastcall CG_BinocularsADS(LocalClientNum_t localClientNum)
{
  return ?CG_BinocularsADS@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CgWeaponSystem::ChargedWeaponOnStopCharging
==============
*/

void __fastcall CgWeaponSystem::ChargedWeaponOnStopCharging(CgWeaponSystem *this, const playerState_s *ps, const centity_t *cent, const Weapon *weapon, bool isAlternate, bool isPlayerView, ClientChargeWeaponSoundRumbleInfo *soundRumbleInfo)
{
  ?ChargedWeaponOnStopCharging@CgWeaponSystem@@IEBAXPEBUplayerState_s@@PEBUcentity_t@@AEBUWeapon@@_N3PEAUClientChargeWeaponSoundRumbleInfo@@@Z(this, ps, cent, weapon, isAlternate, isPlayerView, soundRumbleInfo);
}

/*
==============
CG_CycleWeapon
==============
*/

void __fastcall CG_CycleWeapon(LocalClientNum_t localClientNum, int cycleSlot, int cycleForward)
{
  ?CG_CycleWeapon@@YAXW4LocalClientNum_t@@HH@Z(localClientNum, cycleSlot, cycleForward);
}

/*
==============
CgWeaponSystem::OffhandWeaponVmFxUpdate
==============
*/

void __fastcall CgWeaponSystem::OffhandWeaponVmFxUpdate(CgWeaponSystem *this, const Weapon *currWeap, bool isAlternate)
{
  ?OffhandWeaponVmFxUpdate@CgWeaponSystem@@QEBAXAEBUWeapon@@_N@Z(this, currWeap, isAlternate);
}

/*
==============
CG_Weapons_EntityHasShield
==============
*/

bool __fastcall CG_Weapons_EntityHasShield(const LocalClientNum_t localClientNum, const centity_t *const cent)
{
  return ?CG_Weapons_EntityHasShield@@YA_NW4LocalClientNum_t@@QEBUcentity_t@@@Z(localClientNum, cent);
}

/*
==============
CgWeaponSystem::BulletScriptableImpact
==============
*/

void __fastcall CgWeaponSystem::BulletScriptableImpact(CgWeaponSystem *this, const unsigned int inflictorEntNum, const unsigned int targetEntityNum, const Weapon *weapon, bool isAlternate, const meansOfDeath_t mod, const vec3_t *start, const vec3_t *hitPos, const scr_string_t hitPartName)
{
  ?BulletScriptableImpact@CgWeaponSystem@@QEBAXIIAEBUWeapon@@_NW4meansOfDeath_t@@AEBTvec3_t@@3W4scr_string_t@@@Z(this, inflictorEntNum, targetEntityNum, weapon, isAlternate, mod, start, hitPos, hitPartName);
}

/*
==============
CG_OffhandShield_DamageFeedback
==============
*/

void __fastcall CG_OffhandShield_DamageFeedback(LocalClientNum_t localClientNum, int sourceEntityNum, unsigned int eventParm, bool damaged)
{
  ?CG_OffhandShield_DamageFeedback@@YAXW4LocalClientNum_t@@HI_N@Z(localClientNum, sourceEntityNum, eventParm, damaged);
}

/*
==============
CG_Weapons_GetScriptableHitId
==============
*/

unsigned int __fastcall CG_Weapons_GetScriptableHitId(const trace_t *trace)
{
  return ?CG_Weapons_GetScriptableHitId@@YAIPEBUtrace_t@@@Z(trace);
}

/*
==============
CG_Entity_HasWeapon
==============
*/

bool __fastcall CG_Entity_HasWeapon(LocalClientNum_t localClientNum, centity_t *cent)
{
  return ?CG_Entity_HasWeapon@@YA_NW4LocalClientNum_t@@PEAUcentity_t@@@Z(localClientNum, cent);
}

/*
==============
CG_JavelinADS
==============
*/

bool __fastcall CG_JavelinADS(LocalClientNum_t localClientNum)
{
  return ?CG_JavelinADS@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_OnOffhandKeyDown
==============
*/

void __fastcall CG_OnOffhandKeyDown(LocalClientNum_t localClientNum, unsigned __int64 offhandButton)
{
  ?CG_OnOffhandKeyDown@@YAXW4LocalClientNum_t@@_K@Z(localClientNum, offhandButton);
}

/*
==============
CgWeaponSystem::ProcessDeferredTracer
==============
*/

void __fastcall CgWeaponSystem::ProcessDeferredTracer(CgWeaponSystem *this)
{
  ?ProcessDeferredTracer@CgWeaponSystem@@QEBAXXZ(this);
}

/*
==============
CgWeaponSystem::DrawTargetBox
==============
*/

void __fastcall CgWeaponSystem::DrawTargetBox(CgWeaponSystem *this, float x, float y, float w, float h, Material *icon, float alpha)
{
  ?DrawTargetBox@CgWeaponSystem@@QEBAXMMMMPEAUMaterial@@M@Z(this, x, y, w, h, icon, alpha);
}

/*
==============
CG_UpdateViewWeaponAnim
==============
*/

void __fastcall CG_UpdateViewWeaponAnim(LocalClientNum_t localClientNum)
{
  ?CG_UpdateViewWeaponAnim@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_Weapons_ClearAutoComplete
==============
*/

void CG_Weapons_ClearAutoComplete(void)
{
  ?CG_Weapons_ClearAutoComplete@@YAXXZ();
}

/*
==============
CgWeaponSystem::CalculateTagOffset
==============
*/

bool __fastcall CgWeaponSystem::CalculateTagOffset(CgWeaponSystem *this, const int entNum, scr_string_t tagName, const vec3_t *worldPos, vec3_t *outTagOffset)
{
  return ?CalculateTagOffset@CgWeaponSystem@@QEBA_NHW4scr_string_t@@AEBTvec3_t@@AEAT3@@Z(this, entNum, tagName, worldPos, outTagOffset);
}

/*
==============
CgWeaponSystem::SimulateBulletFire_HitEffect
==============
*/

void __fastcall CgWeaponSystem::SimulateBulletFire_HitEffect(CgWeaponSystem *this, int sourceEntityNum, int targetEntityNum, unsigned int targetScriptableIndex, const int knownHitClientNum, const Weapon *weapon, bool isAlternate, const vec3_t *initialShootingPos, const vec3_t *startPos, const vec3_t *position, const vec3_t *normal, int surfType, unsigned int meansOfDeath, unsigned int impactEffects, int hitContents, const bool forceClientSideHandling)
{
  ?SimulateBulletFire_HitEffect@CgWeaponSystem@@MEBAXHHIHAEBUWeapon@@_NAEBTvec3_t@@222HIIH_N@Z(this, sourceEntityNum, targetEntityNum, targetScriptableIndex, knownHitClientNum, weapon, isAlternate, initialShootingPos, startPos, position, normal, surfType, meansOfDeath, impactEffects, hitContents, forceClientSideHandling);
}

/*
==============
CG_Weapon_FreeViewModelDobjHand
==============
*/

void __fastcall CG_Weapon_FreeViewModelDobjHand(const LocalClientNum_t localClientNum, const PlayerHandIndex hand)
{
  ?CG_Weapon_FreeViewModelDobjHand@@YAXW4LocalClientNum_t@@W4PlayerHandIndex@@@Z(localClientNum, hand);
}

/*
==============
CgWeaponSystem::ChargedWeaponSetChargeAmountOverride
==============
*/

void __fastcall CgWeaponSystem::ChargedWeaponSetChargeAmountOverride(CgWeaponSystem *this, const centity_t *cent, const PlayerHandIndex hand, const int chargeAmount)
{
  ?ChargedWeaponSetChargeAmountOverride@CgWeaponSystem@@QEAAXPEBUcentity_t@@W4PlayerHandIndex@@H@Z(this, cent, hand, chargeAmount);
}

/*
==============
CG_Weapons_DestroyRiotShieldPhysics
==============
*/

void __fastcall CG_Weapons_DestroyRiotShieldPhysics(LocalClientNum_t localClientNum, int entityNum)
{
  ?CG_Weapons_DestroyRiotShieldPhysics@@YAXW4LocalClientNum_t@@H@Z(localClientNum, entityNum);
}

/*
==============
CG_BinocularsGetZoomLevel
==============
*/

int __fastcall CG_BinocularsGetZoomLevel(LocalClientNum_t localClientNum)
{
  return ?CG_BinocularsGetZoomLevel@@YAHW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_GetViewDirection
==============
*/

bool __fastcall CG_GetViewDirection(LocalClientNum_t localClientNum, int entityNum, vec3_t *outForward, vec3_t *outRight, vec3_t *outUp)
{
  return ?CG_GetViewDirection@@YA_NW4LocalClientNum_t@@HAEATvec3_t@@11@Z(localClientNum, entityNum, outForward, outRight, outUp);
}

/*
==============
CG_DebugBulletFireLog_GetEntry
==============
*/

const DebugBulletFireInfoEntry *__fastcall CG_DebugBulletFireLog_GetEntry(int entryIndex)
{
  return ?CG_DebugBulletFireLog_GetEntry@@YAPEBUDebugBulletFireInfoEntry@@H@Z(entryIndex);
}

/*
==============
CConeTargetEvaluator::EvaluateTarget
==============
*/

bool __fastcall CConeTargetEvaluator::EvaluateTarget(CConeTargetEvaluator *this, LocalClientNum_t localClientNum, const CAssistTarget *assistTarget, const vec3_t *bulletStart, float range, vec3_t *outBulletEnd, vec3_t *outBulletDir)
{
  return ?EvaluateTarget@CConeTargetEvaluator@@UEBA_NW4LocalClientNum_t@@PEBVCAssistTarget@@AEBTvec3_t@@MAEAT4@3@Z(this, localClientNum, assistTarget, bulletStart, range, outBulletEnd, outBulletDir);
}

/*
==============
CG_Weapon_FreeViewModelDobj
==============
*/

void __fastcall CG_Weapon_FreeViewModelDobj(const LocalClientNum_t localClientNum)
{
  ?CG_Weapon_FreeViewModelDobj@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CgWeaponSystem::TryCG_TrackingLaserBeamAdd
==============
*/

void __fastcall CgWeaponSystem::TryCG_TrackingLaserBeamAdd(CgWeaponSystem *this, bool needsDeferring, const LocalClientNum_t localClientNum, const vec3_t *start, const vec3_t *end, const centity_t *owner, const Weapon *weapon, const bool isAlternate, const int shotIndex, const int trackedEntNum, const scr_string_t autoTargetEntTag, const vec3_t *tagOffset, const float aimSpreadAmount)
{
  ?TryCG_TrackingLaserBeamAdd@CgWeaponSystem@@QEBAX_NW4LocalClientNum_t@@AEBTvec3_t@@2PEBUcentity_t@@AEBUWeapon@@_NHHW4scr_string_t@@2M@Z(this, needsDeferring, localClientNum, start, end, owner, weapon, isAlternate, shotIndex, trackedEntNum, autoTargetEntTag, tagOffset, aimSpreadAmount);
}

/*
==============
CG_SmoothOutWeaponPosFracForMispredictionErrors
==============
*/

void __fastcall CG_SmoothOutWeaponPosFracForMispredictionErrors(const LocalClientNum_t localClientNum)
{
  ?CG_SmoothOutWeaponPosFracForMispredictionErrors@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_EjectWeaponBrass
==============
*/

void __fastcall CG_EjectWeaponBrass(LocalClientNum_t localClientNum, const entityState_t *ent, int event, bool isAlternate)
{
  ?CG_EjectWeaponBrass@@YAXW4LocalClientNum_t@@PEBUentityState_t@@H_N@Z(localClientNum, ent, event, isAlternate);
}

/*
==============
CgWeaponSystem::ShouldSpawnTracer
==============
*/

bool __fastcall CgWeaponSystem::ShouldSpawnTracer(CgWeaponSystem *this, const int attackerEntNum, const bitarray<64> *r_perks, const PlayerHandIndex hand, const Weapon *weapon, bool isAlternate, const bool isMainBulletSimulation)
{
  return ?ShouldSpawnTracer@CgWeaponSystem@@QEBA_NHAEBV?$bitarray@$0EA@@@W4PlayerHandIndex@@AEBUWeapon@@_N_N@Z(this, attackerEntNum, r_perks, hand, weapon, isAlternate, isMainBulletSimulation);
}

/*
==============
MovementAnimState::IsOffsetAnimationTransition
==============
*/

bool __fastcall MovementAnimState::IsOffsetAnimationTransition(MovementAnimState *this, const weapAnimFiles_t animIndex)
{
  return ?IsOffsetAnimationTransition@MovementAnimState@@AEBA_NW4weapAnimFiles_t@@@Z(this, animIndex);
}

/*
==============
CgWeaponSystem::ChargedWeaponStartRumble
==============
*/

void __fastcall CgWeaponSystem::ChargedWeaponStartRumble(CgWeaponSystem *this, const Weapon *weapon, bool isAlternate, ClientChargeWeaponSoundRumbleInfo *soundRumbleInfo)
{
  ?ChargedWeaponStartRumble@CgWeaponSystem@@IEBAXAEBUWeapon@@_NPEAUClientChargeWeaponSoundRumbleInfo@@@Z(this, weapon, isAlternate, soundRumbleInfo);
}

/*
==============
CgWeaponSystem::ChargedWeaponUpdateChargeStateFromSnapshot
==============
*/

void __fastcall CgWeaponSystem::ChargedWeaponUpdateChargeStateFromSnapshot(CgWeaponSystem *this, const int entityNum, const CharacterChargedWeaponInfo *characterChargedWeaponInfo)
{
  ?ChargedWeaponUpdateChargeStateFromSnapshot@CgWeaponSystem@@QEAAXHPEBUCharacterChargedWeaponInfo@@@Z(this, entityNum, characterChargedWeaponInfo);
}

/*
==============
CgWeaponSystem::TryCG_Glass_BreakGlass
==============
*/

void __fastcall CgWeaponSystem::TryCG_Glass_BreakGlass(CgWeaponSystem *this, bool needsDeferring, LocalClientNum_t localClientNum, const vec3_t *cameraPosition, unsigned __int16 glassPieceIndex, const vec3_t *hitPosition, const vec3_t *hitDirection)
{
  ?TryCG_Glass_BreakGlass@CgWeaponSystem@@QEBAX_NW4LocalClientNum_t@@AEBTvec3_t@@G22@Z(this, needsDeferring, localClientNum, cameraPosition, glassPieceIndex, hitPosition, hitDirection);
}

/*
==============
CG_FireWeaponWithLod
==============
*/

void __fastcall CG_FireWeaponWithLod(LocalClientNum_t localClientNum, centity_t *cent, int event, int knownHitClientNum, const TagPair weaponFlashTagPair, const Weapon *weapon, bool isAlternate, PlayerHandIndex hand, bool isPlayerView, bool isDualWield, bool bNoTracer, const CgEventLodData *eventLodData)
{
  ?CG_FireWeaponWithLod@@YAXW4LocalClientNum_t@@PEAUcentity_t@@HHVTagPair@@AEBUWeapon@@_NW4PlayerHandIndex@@444AEBUCgEventLodData@@@Z(localClientNum, cent, event, knownHitClientNum, weaponFlashTagPair, weapon, isAlternate, hand, isPlayerView, isDualWield, bNoTracer, eventLodData);
}

/*
==============
CG_IsWeaponInspectOnAltToggle
==============
*/

bool __fastcall CG_IsWeaponInspectOnAltToggle(LocalClientNum_t localClientNum)
{
  return ?CG_IsWeaponInspectOnAltToggle@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_Weapons_GetSFXImpactType
==============
*/

int __fastcall CG_Weapons_GetSFXImpactType(LocalClientNum_t localClientNum, const int sourceEntityNum, const Weapon *inWeapon, bool isAlternate)
{
  return ?CG_Weapons_GetSFXImpactType@@YAHW4LocalClientNum_t@@HAEBUWeapon@@_N@Z(localClientNum, sourceEntityNum, inWeapon, isAlternate);
}

/*
==============
CG_PlayerUsingThermalTurret
==============
*/

bool __fastcall CG_PlayerUsingThermalTurret(LocalClientNum_t localClientNum)
{
  return ?CG_PlayerUsingThermalTurret@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CgWeaponSystem::StopPullbackSound
==============
*/

void __fastcall CgWeaponSystem::StopPullbackSound(CgWeaponSystem *this, const int entNum)
{
  ?StopPullbackSound@CgWeaponSystem@@QEBAXH@Z(this, entNum);
}

/*
==============
CG_PlayerUsingScopedTurret
==============
*/

bool __fastcall CG_PlayerUsingScopedTurret(LocalClientNum_t localClientNum)
{
  return ?CG_PlayerUsingScopedTurret@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_Weapons_GetSFXWhizbyType
==============
*/

unsigned int __fastcall CG_Weapons_GetSFXWhizbyType(const Weapon *inWeapon, bool isAlternate)
{
  return ?CG_Weapons_GetSFXWhizbyType@@YAIAEBUWeapon@@_N@Z(inWeapon, isAlternate);
}

/*
==============
CG_CanCycleWeapon
==============
*/

bool __fastcall CG_CanCycleWeapon(LocalClientNum_t localClientNum)
{
  return ?CG_CanCycleWeapon@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_WeaponInspect_IsUIHidden
==============
*/

bool __fastcall CG_WeaponInspect_IsUIHidden(LocalClientNum_t localClientNum)
{
  return ?CG_WeaponInspect_IsUIHidden@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CgWeaponSystem::ChargedWeaponClearClientOnlyChargeAmountOverride
==============
*/

void __fastcall CgWeaponSystem::ChargedWeaponClearClientOnlyChargeAmountOverride(CgWeaponSystem *this, const playerState_s *ps)
{
  ?ChargedWeaponClearClientOnlyChargeAmountOverride@CgWeaponSystem@@QEBAXPEBUplayerState_s@@@Z(this, ps);
}

/*
==============
CG_BulletHitClientEvent
==============
*/

void __fastcall CG_BulletHitClientEvent(LocalClientNum_t localClientNum, int sourceEntityNum, const Weapon *weapon, bool isAlternate, const vec3_t *startPos, const vec3_t *position, int surfType, int event, unsigned int impactEffects, SndHitArmorType hitArmorType)
{
  ?CG_BulletHitClientEvent@@YAXW4LocalClientNum_t@@HAEBUWeapon@@_NAEBTvec3_t@@3HHIW4SndHitArmorType@@@Z(localClientNum, sourceEntityNum, weapon, isAlternate, startPos, position, surfType, event, impactEffects, hitArmorType);
}

/*
==============
CG_NightVisionDown
==============
*/

void __fastcall CG_NightVisionDown(LocalClientNum_t localClientNum)
{
  ?CG_NightVisionDown@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CgWeaponSystem::ChargedWeaponGetChargeAmount
==============
*/

int __fastcall CgWeaponSystem::ChargedWeaponGetChargeAmount(CgWeaponSystem *this, const playerState_s *ps, const PlayerHandIndex hand)
{
  return ?ChargedWeaponGetChargeAmount@CgWeaponSystem@@QEBAHPEBUplayerState_s@@W4PlayerHandIndex@@@Z(this, ps, hand);
}

/*
==============
CG_Weapons_ActionSlotUsageAllowed
==============
*/

bool __fastcall CG_Weapons_ActionSlotUsageAllowed(const cg_t *const cgameGlob, const int slot)
{
  return ?CG_Weapons_ActionSlotUsageAllowed@@YA_NQEBVcg_t@@H@Z(cgameGlob, slot);
}

/*
==============
CG_DebugBulletFireLog_GetNumEntries
==============
*/

int __fastcall CG_DebugBulletFireLog_GetNumEntries()
{
  return ?CG_DebugBulletFireLog_GetNumEntries@@YAHXZ();
}

/*
==============
CG_BinocularsThermalEnabled
==============
*/

bool __fastcall CG_BinocularsThermalEnabled(LocalClientNum_t localClientNum)
{
  return ?CG_BinocularsThermalEnabled@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_GetWeaponAnimTime
==============
*/

double __fastcall CG_GetWeaponAnimTime(LocalClientNum_t localClientNum, PlayerHandIndex handIndex, weapAnimFiles_t animFile)
{
  double result; 

  *(float *)&result = ?CG_GetWeaponAnimTime@@YAMW4LocalClientNum_t@@W4PlayerHandIndex@@W4weapAnimFiles_t@@@Z(localClientNum, handIndex, animFile);
  return result;
}

/*
==============
CgWeaponSystem::ChargedWeaponPlaySound
==============
*/

SndAliasLookup __fastcall CgWeaponSystem::ChargedWeaponPlaySound(CgWeaponSystem *this, const int entNum, SndAliasLookup sndAliasLookup)
{
  return ?ChargedWeaponPlaySound@CgWeaponSystem@@IEBA?AUSndAliasLookup@@HU2@@Z(this, entNum, sndAliasLookup);
}

/*
==============
CConeTargetEvaluator::FindTargets
==============
*/

int __fastcall CConeTargetEvaluator::FindTargets(CConeTargetEvaluator *this, LocalClientNum_t localClientNum, const Weapon *r_weapon, const bool isAlternate, const centity_t *attacker, const vec3_t *bulletStart, const vec3_t *bulletDir, float range, float spread, int maxTargets, const bool isBeamWeapon, const unsigned int hitLocMask, const int gameTime, const bool isFiring, ntl::fixed_array<CAssistTarget,20> *outTargetArray)
{
  return ?FindTargets@CConeTargetEvaluator@@UEAAHW4LocalClientNum_t@@AEBUWeapon@@_NPEBUcentity_t@@AEBTvec3_t@@4MMH2IH2PEAV?$fixed_array@VCAssistTarget@@$0BE@@ntl@@@Z(this, localClientNum, r_weapon, isAlternate, attacker, bulletStart, bulletDir, range, spread, maxTargets, isBeamWeapon, hitLocMask, gameTime, isFiring, outTargetArray);
}

/*
==============
CgWeaponSystem::OffhandWeaponVmFxStopAll
==============
*/

void __fastcall CgWeaponSystem::OffhandWeaponVmFxStopAll(CgWeaponSystem *this)
{
  ?OffhandWeaponVmFxStopAll@CgWeaponSystem@@QEBAXXZ(this);
}

/*
==============
CG_GetCurrentWeaponSlot
==============
*/

WeaponSlot __fastcall CG_GetCurrentWeaponSlot(LocalClientNum_t localClientNum)
{
  return ?CG_GetCurrentWeaponSlot@@YA?AW4WeaponSlot@@W4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_Weapons_ScopeIsOverlayed
==============
*/

bool __fastcall CG_Weapons_ScopeIsOverlayed(LocalClientNum_t localClientNum)
{
  return ?CG_Weapons_ScopeIsOverlayed@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_AddPlayerExecutionProp
==============
*/

void __fastcall CG_AddPlayerExecutionProp(LocalClientNum_t localClientNum, centity_t *cent)
{
  ?CG_AddPlayerExecutionProp@@YAXW4LocalClientNum_t@@PEAUcentity_t@@@Z(localClientNum, cent);
}

/*
==============
CgWeaponSystem::SimulateBulletFire_Ricochet
==============
*/

void __fastcall CgWeaponSystem::SimulateBulletFire_Ricochet(CgWeaponSystem *this, BulletFireParams *bp, const int bulletId, const Weapon *weapon, bool isAlternate, centity_t *inflictorEnt, const bitarray<64> *r_attackerPerks, bool isPlayerWeaponView, PlayerHandIndex hand, const TagPair tagPair, float bulletRange, int ricochetCount, bool shouldSpawnTracer, bool shouldDeferEvents)
{
  ?SimulateBulletFire_Ricochet@CgWeaponSystem@@QEAAXPEAUBulletFireParams@@HAEBUWeapon@@_NPEAUcentity_t@@AEBV?$bitarray@$0EA@@@2W4PlayerHandIndex@@VTagPair@@MH22@Z(this, bp, bulletId, weapon, isAlternate, inflictorEnt, r_attackerPerks, isPlayerWeaponView, hand, tagPair, bulletRange, ricochetCount, shouldSpawnTracer, shouldDeferEvents);
}

/*
==============
CG_Weapons_Init
==============
*/

void __fastcall CG_Weapons_Init(LocalClientNum_t localClientNum, bool isFirstInitizingClient)
{
  ?CG_Weapons_Init@@YAXW4LocalClientNum_t@@_N@Z(localClientNum, isFirstInitizingClient);
}

/*
==============
CG_PlayBulletImpactEffect
==============
*/

void __fastcall CG_PlayBulletImpactEffect(const LocalClientNum_t localClientNum, const int sourceEntityNum, const int targetEntityNum, unsigned int targetScriptableIndex, const unsigned __int8 boneIndex, const vec3_t *position, const vec3_t *normal, const int surfType, const unsigned int impactFlags, FXRegisteredDef hitFx, const bool dismembermentAllowed)
{
  ?CG_PlayBulletImpactEffect@@YAXW4LocalClientNum_t@@HHIEAEBTvec3_t@@1HIVFXRegisteredDef@@_N@Z(localClientNum, sourceEntityNum, targetEntityNum, targetScriptableIndex, boneIndex, position, normal, surfType, impactFlags, hitFx, dismembermentAllowed);
}

/*
==============
CG_DebugBulletFireLog_Compact
==============
*/

void __fastcall CG_DebugBulletFireLog_Compact(const int serverTime)
{
  ?CG_DebugBulletFireLog_Compact@@YAXH@Z(serverTime);
}

/*
==============
CgWeaponSystem::CullBulletHitEffect
==============
*/

int __fastcall CgWeaponSystem::CullBulletHitEffect(CgWeaponSystem *this, int eventType, const vec3_t *position, const vec3_t *up, int sourceEntityNum, int targetEntityNum, unsigned int impactFlags)
{
  return ?CullBulletHitEffect@CgWeaponSystem@@IEBAHHAEBTvec3_t@@0HHI@Z(this, eventType, position, up, sourceEntityNum, targetEntityNum, impactFlags);
}

/*
==============
CG_ActionSlotDown
==============
*/

void __fastcall CG_ActionSlotDown(LocalClientNum_t localClientNum, int slot)
{
  ?CG_ActionSlotDown@@YAXW4LocalClientNum_t@@H@Z(localClientNum, slot);
}

/*
==============
CG_UpdateRecoilState
==============
*/

void __fastcall CG_UpdateRecoilState(LocalClientNum_t localClientNum, const PlayerHandIndex hand)
{
  ?CG_UpdateRecoilState@@YAXW4LocalClientNum_t@@W4PlayerHandIndex@@@Z(localClientNum, hand);
}

/*
==============
CgWeaponSystem::ChargedWeaponGetInfoStruct
==============
*/

ClientChargeWeaponInfo *__fastcall CgWeaponSystem::ChargedWeaponGetInfoStruct(CgWeaponSystem *this, const int entNum)
{
  return ?ChargedWeaponGetInfoStruct@CgWeaponSystem@@IEBAPEAUClientChargeWeaponInfo@@H@Z(this, entNum);
}

/*
==============
CG_SndAutoSimEntLastBurst
==============
*/

void __fastcall CG_SndAutoSimEntLastBurst(const centity_t *ent, const PlayerHandIndex hand)
{
  ?CG_SndAutoSimEntLastBurst@@YAXPEBUcentity_t@@W4PlayerHandIndex@@@Z(ent, hand);
}

/*
==============
CG_ViewWeaponCleanUp
==============
*/

void __fastcall CG_ViewWeaponCleanUp(const LocalClientNum_t localClientNum)
{
  ?CG_ViewWeaponCleanUp@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_Weapons_SimulateBulletFire_EndPos
==============
*/

void __fastcall CG_Weapons_SimulateBulletFire_EndPos(unsigned int *randSeed, const float spreadInner, const float spreadOuter, const vec3_t *start, vec3_t *end, vec3_t *dir, const float angleMin, const float angleMax, const vec3_t *forwardDir, const vec3_t *rightDir, const vec3_t *upDir, const float maxRange)
{
  ?CG_Weapons_SimulateBulletFire_EndPos@@YAXPEAIMMAEBTvec3_t@@AEAT1@2MM111M@Z(randSeed, spreadInner, spreadOuter, start, end, dir, angleMin, angleMax, forwardDir, rightDir, upDir, maxRange);
}

/*
==============
CG_NightVisionBloomDisabled
==============
*/

bool __fastcall CG_NightVisionBloomDisabled()
{
  return ?CG_NightVisionBloomDisabled@@YA_NXZ();
}

/*
==============
MovementAnimState::GetTransitionDuration
==============
*/

void __fastcall MovementAnimState::GetTransitionDuration(MovementAnimState *this, const LocalClientNum_t localClientNum, const playerState_s *ps, const MovementAnimState::State prevState, const MovementAnimState::State nextState, float *outTransDurationSec, float *outCycleTransDurationSec)
{
  ?GetTransitionDuration@MovementAnimState@@AEBAXW4LocalClientNum_t@@PEBUplayerState_s@@W4State@1@2PEAM3@Z(this, localClientNum, ps, prevState, nextState, outTransDurationSec, outCycleTransDurationSec);
}

/*
==============
CG_Weapons_DevWeaponReport
==============
*/

void CG_Weapons_DevWeaponReport(void)
{
  ?CG_Weapons_DevWeaponReport@@YAXXZ();
}

/*
==============
CG_CanChangeZoomLevel
==============
*/

bool __fastcall CG_CanChangeZoomLevel(LocalClientNum_t localClientNum)
{
  return ?CG_CanChangeZoomLevel@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_AddPlayerWeapon
==============
*/

void __fastcall CG_AddPlayerWeapon(LocalClientNum_t localClientNum, const vec3_t *weapOrigin, const vec4_t *weapOrient, const playerState_s *ps, const vec3_t *localPlayerGunAngles, centity_t *cent, int bDrawGun, const CgEventLodData *optionalEventLodData)
{
  ?CG_AddPlayerWeapon@@YAXW4LocalClientNum_t@@AEBTvec3_t@@AEBTvec4_t@@PEBUplayerState_s@@PEBT2@PEAUcentity_t@@HPEBUCgEventLodData@@@Z(localClientNum, weapOrigin, weapOrient, ps, localPlayerGunAngles, cent, bDrawGun, optionalEventLodData);
}

/*
==============
MovementAnimState::PlayerActionForcesWalk
==============
*/

bool __fastcall MovementAnimState::PlayerActionForcesWalk(const LocalClientNum_t localClientNum, const playerState_s *ps)
{
  return ?PlayerActionForcesWalk@MovementAnimState@@CA_NW4LocalClientNum_t@@PEBUplayerState_s@@@Z(localClientNum, ps);
}

/*
==============
CgWeaponSystem::SimulateBulletFirePellet
==============
*/

void __fastcall CgWeaponSystem::SimulateBulletFirePellet(CgWeaponSystem *this, SimulateBulletFirePelletData *pelletFireData, bool shouldDeferEvents)
{
  ?SimulateBulletFirePellet@CgWeaponSystem@@QEAAXPEAUSimulateBulletFirePelletData@@_N@Z(this, pelletFireData, shouldDeferEvents);
}

/*
==============
CG_SndAutoSimReset
==============
*/

void CG_SndAutoSimReset(void)
{
  ?CG_SndAutoSimReset@@YAXXZ();
}

/*
==============
CG_Weapons_IsPlayerSprinting
==============
*/

bool __fastcall CG_Weapons_IsPlayerSprinting(const characterInfo_t *ci, const centity_t *cent)
{
  return ?CG_Weapons_IsPlayerSprinting@@YA_NPEBUcharacterInfo_t@@PEBUcentity_t@@@Z(ci, cent);
}

/*
==============
CgWeaponSystem::ChargedWeaponStopSound
==============
*/

void __fastcall CgWeaponSystem::ChargedWeaponStopSound(CgWeaponSystem *this, const int entNum, SndAliasLookup *sndAliasLookup)
{
  ?ChargedWeaponStopSound@CgWeaponSystem@@IEBAXHPEAUSndAliasLookup@@@Z(this, entNum, sndAliasLookup);
}

/*
==============
CG_Weapons_SetupAutoComplete
==============
*/

void CG_Weapons_SetupAutoComplete(void)
{
  ?CG_Weapons_SetupAutoComplete@@YAXXZ();
}

/*
==============
CG_UpdateViewModelPoseForHand
==============
*/

void __fastcall CG_UpdateViewModelPoseForHand(DObj *obj, LocalClientNum_t localClientNum, PlayerHandIndex hand, const bool sendingToRenderer)
{
  ?CG_UpdateViewModelPoseForHand@@YAXPEAUDObj@@W4LocalClientNum_t@@W4PlayerHandIndex@@_N@Z(obj, localClientNum, hand, sendingToRenderer);
}

/*
==============
CG_Weapon_PlayADSSettleAnim
==============
*/

void __fastcall CG_Weapon_PlayADSSettleAnim(const LocalClientNum_t localClientNum, const playerState_s *const ps, float weaponPosFrac, DObj *obj, PlayerHandIndex hand, float settleAnimWeight)
{
  ?CG_Weapon_PlayADSSettleAnim@@YAXW4LocalClientNum_t@@QEBUplayerState_s@@MPEAUDObj@@W4PlayerHandIndex@@M@Z(localClientNum, ps, weaponPosFrac, obj, hand, settleAnimWeight);
}

/*
==============
CgWeaponSystem::ChargedWeaponStopRumble
==============
*/

void __fastcall CgWeaponSystem::ChargedWeaponStopRumble(CgWeaponSystem *this, ClientChargeWeaponSoundRumbleInfo *soundRumbleInfo)
{
  ?ChargedWeaponStopRumble@CgWeaponSystem@@IEBAXPEAUClientChargeWeaponSoundRumbleInfo@@@Z(this, soundRumbleInfo);
}

/*
==============
CG_MissileTrajectoryEvent
==============
*/

void __fastcall CG_MissileTrajectoryEvent(LocalClientNum_t localClientNum, centity_t *cent)
{
  ?CG_MissileTrajectoryEvent@@YAXW4LocalClientNum_t@@PEAUcentity_t@@@Z(localClientNum, cent);
}

/*
==============
CgWeaponSystem::DebugDrawBulletHitLocation
==============
*/

void __fastcall CgWeaponSystem::DebugDrawBulletHitLocation(CgWeaponSystem *this)
{
  ?DebugDrawBulletHitLocation@CgWeaponSystem@@QEBAXXZ(this);
}

/*
==============
CgWeaponSystem::OutOfAmmoChange
==============
*/

void __fastcall CgWeaponSystem::OutOfAmmoChange(CgWeaponSystem *this, bool clipOnly)
{
  ?OutOfAmmoChange@CgWeaponSystem@@QEBAX_N@Z(this, clipOnly);
}

/*
==============
CG_SelectNthPrimaryWeapon
==============
*/

void __fastcall CG_SelectNthPrimaryWeapon(LocalClientNum_t localClientNum, int nthIndex)
{
  ?CG_SelectNthPrimaryWeapon@@YAXW4LocalClientNum_t@@H@Z(localClientNum, nthIndex);
}

/*
==============
CG_Weapons_ThermalScopeIsOverlayed
==============
*/

bool __fastcall CG_Weapons_ThermalScopeIsOverlayed(LocalClientNum_t localClientNum)
{
  return ?CG_Weapons_ThermalScopeIsOverlayed@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
MovementAnimState::Update
==============
*/

void __fastcall MovementAnimState::Update(MovementAnimState *this, const LocalClientNum_t localClientNum, const PlayerHandIndex hand, const playerState_s *ps)
{
  ?Update@MovementAnimState@@QEAAXW4LocalClientNum_t@@W4PlayerHandIndex@@PEBUplayerState_s@@@Z(this, localClientNum, hand, ps);
}

/*
==============
CG_Weapons_CalculateMovement
==============
*/

void __fastcall CG_Weapons_CalculateMovement(cg_t *cgameGlob, PlayerViewValues *viewValues, const tmat43_t<vec3_t> *viewTransform, vec3_t *outGunOffset, vec3_t *outGunAngles, vec3_t *outWeapOrigin, vec4_t *outWeapOrient)
{
  ?CG_Weapons_CalculateMovement@@YAXPEAVcg_t@@AEAUPlayerViewValues@@AEBT?$tmat43_t@Tvec3_t@@@@AEATvec3_t@@33AEATvec4_t@@@Z(cgameGlob, viewValues, viewTransform, outGunOffset, outGunAngles, outWeapOrigin, outWeapOrient);
}

/*
==============
CG_WeaponInspect
==============
*/

void __fastcall CG_WeaponInspect(LocalClientNum_t localClientNum)
{
  ?CG_WeaponInspect@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_PlayMissileProjectedConeSound
==============
*/

void __fastcall CG_PlayMissileProjectedConeSound(LocalClientNum_t localClientNum, centity_t *cent)
{
  ?CG_PlayMissileProjectedConeSound@@YAXW4LocalClientNum_t@@PEAUcentity_t@@@Z(localClientNum, cent);
}

/*
==============
CgWeaponSystem::TryBulletScriptableImpact
==============
*/

void __fastcall CgWeaponSystem::TryBulletScriptableImpact(CgWeaponSystem *this, const int triggerTime, bool needsDeferring, const unsigned int inflictorEntNum, const unsigned int targetEntityNum, const Weapon *weapon, bool isAlternate, const meansOfDeath_t mod, const vec3_t *start, const vec3_t *hitPos, const scr_string_t hitPartName)
{
  ?TryBulletScriptableImpact@CgWeaponSystem@@QEBAXH_NIIAEBUWeapon@@0W4meansOfDeath_t@@AEBTvec3_t@@3W4scr_string_t@@@Z(this, triggerTime, needsDeferring, inflictorEntNum, targetEntityNum, weapon, isAlternate, mod, start, hitPos, hitPartName);
}

/*
==============
CgWeaponSystem::GetIconDims
==============
*/

int __fastcall CgWeaponSystem::GetIconDims(CgWeaponSystem *this, const vec3_t *targetPos, float *x, float *y, float *w, float *h)
{
  return ?GetIconDims@CgWeaponSystem@@QEBAHAEBTvec3_t@@PEAM111@Z(this, targetPos, x, y, w, h);
}

/*
==============
CG_Weapons_ActionSlotTypeUsageAllowed
==============
*/

bool __fastcall CG_Weapons_ActionSlotTypeUsageAllowed(const cg_t *const cgameGlob, const ActionSlotType type)
{
  return ?CG_Weapons_ActionSlotTypeUsageAllowed@@YA_NQEBVcg_t@@W4ActionSlotType@@@Z(cgameGlob, type);
}

/*
==============
CG_SndKillAutoSimEntNum
==============
*/

void __fastcall CG_SndKillAutoSimEntNum(int entityNum, bool bKillAggressively)
{
  ?CG_SndKillAutoSimEntNum@@YAXH_N@Z(entityNum, bKillAggressively);
}

/*
==============
CG_Weapon_GetRecoilAnims
==============
*/

void __fastcall CG_Weapon_GetRecoilAnims(const LocalClientNum_t localClientNum, const playerState_s *const ps, weapAnimFiles_t *outRootAnim, weapAnimFiles_t *outRecoilAnim, bool *outIsAdditive)
{
  ?CG_Weapon_GetRecoilAnims@@YAXW4LocalClientNum_t@@QEBUplayerState_s@@PEAW4weapAnimFiles_t@@2PEA_N@Z(localClientNum, ps, outRootAnim, outRecoilAnim, outIsAdditive);
}

/*
==============
CG_Weapons_CurrentWeaponCanHoldBreath
==============
*/

bool __fastcall CG_Weapons_CurrentWeaponCanHoldBreath(LocalClientNum_t localClientNum)
{
  return ?CG_Weapons_CurrentWeaponCanHoldBreath@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_Weapons_GetWeaponForName
==============
*/

Weapon *__fastcall CG_Weapons_GetWeaponForName(Weapon *result, const char *weaponName)
{
  return ?CG_Weapons_GetWeaponForName@@YA?AUWeapon@@PEBD@Z(result, weaponName);
}

/*
==============
CG_UpdateViewModelPreviousPositionForHand
==============
*/

void __fastcall CG_UpdateViewModelPreviousPositionForHand(LocalClientNum_t localClientNum, PlayerHandIndex hand)
{
  ?CG_UpdateViewModelPreviousPositionForHand@@YAXW4LocalClientNum_t@@W4PlayerHandIndex@@@Z(localClientNum, hand);
}

/*
==============
CgWeaponSystem::BulletClientAuthPhysicsImpact
==============
*/

void __fastcall CgWeaponSystem::BulletClientAuthPhysicsImpact(CgWeaponSystem *this, const unsigned int inflictorEntNum, const Weapon *weapon, bool isAlternate, const bool hasBulletExploded, const meansOfDeath_t mod, const vec3_t *start, const vec3_t *hitPos)
{
  ?BulletClientAuthPhysicsImpact@CgWeaponSystem@@IEBAXIAEBUWeapon@@_N_NW4meansOfDeath_t@@AEBTvec3_t@@4@Z(this, inflictorEntNum, weapon, isAlternate, hasBulletExploded, mod, start, hitPos);
}

/*
==============
MovementAnimState::ShouldApplyQuickDescendTransition
==============
*/

bool __fastcall MovementAnimState::ShouldApplyQuickDescendTransition(const LocalClientNum_t localClientNum, const playerState_s *ps, const MovementAnimState::State prevState, const MovementAnimState::State nextState, float *outTransDurationSec, float *outCycleTransDurationSec)
{
  return ?ShouldApplyQuickDescendTransition@MovementAnimState@@CA_NW4LocalClientNum_t@@PEBUplayerState_s@@W4State@1@2AEAM3@Z(localClientNum, ps, prevState, nextState, outTransDurationSec, outCycleTransDurationSec);
}

/*
==============
CgWeaponSystem::TrySimulateBulletFire_MissEffect
==============
*/

void __fastcall CgWeaponSystem::TrySimulateBulletFire_MissEffect(CgWeaponSystem *this, const int triggerTime, bool needsDeferring, int sourceEntityNum, const Weapon *weapon, bool isAlternate, const vec3_t *initialShootingPos, const vec3_t *startPos, const vec3_t *position, int surfType)
{
  ?TrySimulateBulletFire_MissEffect@CgWeaponSystem@@QEBAXH_NHAEBUWeapon@@0AEBTvec3_t@@22H@Z(this, triggerTime, needsDeferring, sourceEntityNum, weapon, isAlternate, initialShootingPos, startPos, position, surfType);
}

/*
==============
CG_NightVisionShouldHideGoggles
==============
*/

bool __fastcall CG_NightVisionShouldHideGoggles(LocalClientNum_t localClientNum, const PlayerHandIndex hand)
{
  return ?CG_NightVisionShouldHideGoggles@@YA_NW4LocalClientNum_t@@W4PlayerHandIndex@@@Z(localClientNum, hand);
}

/*
==============
CAssistTarget::SetTarget
==============
*/

void __fastcall CAssistTarget::SetTarget(CAssistTarget *this, const centity_t *target)
{
  ?SetTarget@CAssistTarget@@QEAAXPEBUcentity_t@@@Z(this, target);
}

/*
==============
CgWeaponSystem::ShouldSpawnTracerFromEvent
==============
*/

bool __fastcall CgWeaponSystem::ShouldSpawnTracerFromEvent(CgWeaponSystem *this, const int eventId, const centity_t *hitEventEnt, const int attackerEntNum, const bitarray<64> *r_attackerPerks, const Weapon *weapon, bool isAlternate)
{
  return ?ShouldSpawnTracerFromEvent@CgWeaponSystem@@QEBA_NHPEBUcentity_t@@HAEBV?$bitarray@$0EA@@@AEBUWeapon@@_N@Z(this, eventId, hitEventEnt, attackerEntNum, r_attackerPerks, weapon, isAlternate);
}

/*
==============
CG_Weapons_GetWeaponViewRoughOriginIfValid
==============
*/

bool __fastcall CG_Weapons_GetWeaponViewRoughOriginIfValid(LocalClientNum_t localClientNum, const playerState_s *ps, vec3_t *result)
{
  return ?CG_Weapons_GetWeaponViewRoughOriginIfValid@@YA_NW4LocalClientNum_t@@PEBUplayerState_s@@AEATvec3_t@@@Z(localClientNum, ps, result);
}

/*
==============
CG_Weapons_BuildDObj
==============
*/

void __fastcall CG_Weapons_BuildDObj(const PlayerHandIndex hand, const Weapon *r_weapon, const bool useViewModel, const bool useStowedModel, const bool useDefaultModel, const bool useDualWielding, scr_string_t attachBoneName, const unsigned int maxDObjModels, DObjModel *outDObjModels, unsigned __int16 *outModelIndex, XAnimWeaponIKModelsContainer *outWeaponIKModels)
{
  ?CG_Weapons_BuildDObj@@YAXW4PlayerHandIndex@@AEBUWeapon@@_N222W4scr_string_t@@IPEAUDObjModel@@PEAGPEAVXAnimWeaponIKModelsContainer@@@Z(hand, r_weapon, useViewModel, useStowedModel, useDefaultModel, useDualWielding, attachBoneName, maxDObjModels, outDObjModels, outModelIndex, outWeaponIKModels);
}

/*
==============
CgWeaponSystem::ChargedWeaponUpdateViewModelFX
==============
*/

void __fastcall CgWeaponSystem::ChargedWeaponUpdateViewModelFX(CgWeaponSystem *this, const playerState_s *ps, centity_t *cent, const Weapon *weapon, bool isAlternate)
{
  ?ChargedWeaponUpdateViewModelFX@CgWeaponSystem@@IEBAXPEBUplayerState_s@@PEAUcentity_t@@AEBUWeapon@@_N@Z(this, ps, cent, weapon, isAlternate);
}

/*
==============
CgWeaponSystem::ChargedWeaponClearViewModelFX
==============
*/

void __fastcall CgWeaponSystem::ChargedWeaponClearViewModelFX(CgWeaponSystem *this, const centity_t *cent)
{
  ?ChargedWeaponClearViewModelFX@CgWeaponSystem@@IEBAXPEBUcentity_t@@@Z(this, cent);
}

/*
==============
MovementAnimState::Reset
==============
*/

void __fastcall MovementAnimState::Reset(MovementAnimState *this, const LocalClientNum_t localClientNum, const PlayerHandIndex hand)
{
  ?Reset@MovementAnimState@@QEAAXW4LocalClientNum_t@@W4PlayerHandIndex@@@Z(this, localClientNum, hand);
}

/*
==============
CG_SndUpdateAutoSim
==============
*/

void CG_SndUpdateAutoSim(void)
{
  ?CG_SndUpdateAutoSim@@YAXXZ();
}

/*
==============
CG_ActionSlotUp
==============
*/

void __fastcall CG_ActionSlotUp(LocalClientNum_t localClientNum, int slot, bool mustRelease)
{
  ?CG_ActionSlotUp@@YAXW4LocalClientNum_t@@H_N@Z(localClientNum, slot, mustRelease);
}

/*
==============
CgWeaponSystem::OffhandWeaponVmFxValidate
==============
*/

void __fastcall CgWeaponSystem::OffhandWeaponVmFxValidate(CgWeaponSystem *this)
{
  ?OffhandWeaponVmFxValidate@CgWeaponSystem@@QEBAXXZ(this);
}

/*
==============
CgWeaponSystem::ClaimBulletId
==============
*/

int __fastcall CgWeaponSystem::ClaimBulletId(CgWeaponSystem *this)
{
  return ?ClaimBulletId@CgWeaponSystem@@QEAAHXZ(this);
}

/*
==============
MovementAnimState::GetGoalState
==============
*/

MovementAnimState::State __fastcall MovementAnimState::GetGoalState(MovementAnimState *this, const LocalClientNum_t localClientNum, const playerState_s *ps)
{
  return ?GetGoalState@MovementAnimState@@AEBA?AW4State@1@W4LocalClientNum_t@@PEBUplayerState_s@@@Z(this, localClientNum, ps);
}

/*
==============
CgWeaponSystem::SimulateBulletFire_MissEffect
==============
*/

void __fastcall CgWeaponSystem::SimulateBulletFire_MissEffect(CgWeaponSystem *this, int sourceEntityNum, const Weapon *weapon, bool isAlternate, const vec3_t *initialShootingPos, const vec3_t *startPos, const vec3_t *position, int surfType)
{
  ?SimulateBulletFire_MissEffect@CgWeaponSystem@@MEBAXHAEBUWeapon@@_NAEBTvec3_t@@22H@Z(this, sourceEntityNum, weapon, isAlternate, initialShootingPos, startPos, position, surfType);
}

/*
==============
CG_ViewmodelShieldHitsProcess
==============
*/

void __fastcall CG_ViewmodelShieldHitsProcess(LocalClientNum_t localClientNum)
{
  ?CG_ViewmodelShieldHitsProcess@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_Weapons_GetVFXImpactType
==============
*/

int __fastcall CG_Weapons_GetVFXImpactType(LocalClientNum_t localClientNum, const int sourceEntityNum, const Weapon *inWeapon, bool isAlternate)
{
  return ?CG_Weapons_GetVFXImpactType@@YAHW4LocalClientNum_t@@HAEBUWeapon@@_N@Z(localClientNum, sourceEntityNum, inWeapon, isAlternate);
}

/*
==============
CgWeaponSystem::GetTargetEvaluator
==============
*/

CTargetEvaluator *__fastcall CgWeaponSystem::GetTargetEvaluator(targetAssistType_t assistType)
{
  return ?GetTargetEvaluator@CgWeaponSystem@@SAPEAVCTargetEvaluator@@W4targetAssistType_t@@@Z(assistType);
}

/*
==============
CgWeaponSystem::SpawnTracer
==============
*/

void __fastcall CgWeaponSystem::SpawnTracer(CgWeaponSystem *this, const int bulletId, bool blendFromViewmodel, const int inflictorEntNum, const bitarray<64> *r_inflictorPerks, PlayerHandIndex hand, const TagPair sourceTagPair, const vec3_t *tracerStart, const vec3_t *tracerEnd, const Weapon *r_weapon, bool isAlternate, int spawnDelay)
{
  ?SpawnTracer@CgWeaponSystem@@QEBAXH_NHAEBV?$bitarray@$0EA@@@W4PlayerHandIndex@@VTagPair@@AEBTvec3_t@@4AEBUWeapon@@0H@Z(this, bulletId, blendFromViewmodel, inflictorEntNum, r_inflictorPerks, hand, sourceTagPair, tracerStart, tracerEnd, r_weapon, isAlternate, spawnDelay);
}

/*
==============
CgWeaponSystem::TryCG_LaserBeamAdd
==============
*/

void __fastcall CgWeaponSystem::TryCG_LaserBeamAdd(CgWeaponSystem *this, bool needsDeferring, const LocalClientNum_t localClientNum, const vec3_t *start, const vec3_t *end, const centity_t *owner, const Weapon *weapon, const bool isAlternate)
{
  ?TryCG_LaserBeamAdd@CgWeaponSystem@@QEBAX_NW4LocalClientNum_t@@AEBTvec3_t@@2PEBUcentity_t@@AEBUWeapon@@_N@Z(this, needsDeferring, localClientNum, start, end, owner, weapon, isAlternate);
}

/*
==============
CgWeaponSystem::ChargedWeaponOnEmptyCharge
==============
*/

void __fastcall CgWeaponSystem::ChargedWeaponOnEmptyCharge(CgWeaponSystem *this, const centity_t *cent, const Weapon *weapon, bool isAlternate, ClientChargeWeaponSoundRumbleInfo *soundRumbleInfo)
{
  ?ChargedWeaponOnEmptyCharge@CgWeaponSystem@@IEBAXPEBUcentity_t@@AEBUWeapon@@_NPEAUClientChargeWeaponSoundRumbleInfo@@@Z(this, cent, weapon, isAlternate, soundRumbleInfo);
}

/*
==============
CG_OffhandGestureWeapon_SetVisibilityState
==============
*/

void __fastcall CG_OffhandGestureWeapon_SetVisibilityState(LocalClientNum_t localClientNum, const PlayerHandIndex hand)
{
  ?CG_OffhandGestureWeapon_SetVisibilityState@@YAXW4LocalClientNum_t@@W4PlayerHandIndex@@@Z(localClientNum, hand);
}

/*
==============
CgWeaponSystem::ChargedWeaponUpdate
==============
*/

void __fastcall CgWeaponSystem::ChargedWeaponUpdate(CgWeaponSystem *this, const playerState_s *ps, centity_t *cent, const Weapon *weapon, bool isAlternate, int bViewModel, int bDrawGun)
{
  ?ChargedWeaponUpdate@CgWeaponSystem@@QEBAXPEBUplayerState_s@@PEAUcentity_t@@AEBUWeapon@@_NHH@Z(this, ps, cent, weapon, isAlternate, bViewModel, bDrawGun);
}

/*
==============
MovementAnimState::CalcOffsetTransitionParams
==============
*/

void __fastcall MovementAnimState::CalcOffsetTransitionParams(MovementAnimState *this, const LocalClientNum_t localClientNum, const XAnimTree *const animTree, const XAnimParts *const *const animArray, const MovementAnimState::State prev, const MovementAnimState::State next, const weapAnimFiles_t prevAnim, weapAnimFiles_t *outNextAnim, float *outBlendTime, float *outPrevRate, float *outNextRate)
{
  ?CalcOffsetTransitionParams@MovementAnimState@@AEBAXW4LocalClientNum_t@@QEBUXAnimTree@@QEBQEBUXAnimParts@@W4State@1@3W4weapAnimFiles_t@@AEAW46@AEAM66@Z(this, localClientNum, animTree, animArray, prev, next, prevAnim, outNextAnim, outBlendTime, outPrevRate, outNextRate);
}

/*
==============
CG_GetFleshImpactAxis
==============
*/

void __fastcall CG_GetFleshImpactAxis(const LocalClientNum_t localClientNum, const int sourceEntityNum, const int boneIndex, const vec3_t *position, tmat33_t<vec3_t> *outAxis)
{
  ?CG_GetFleshImpactAxis@@YAXW4LocalClientNum_t@@HHAEBTvec3_t@@AEAT?$tmat33_t@Tvec3_t@@@@@Z(localClientNum, sourceEntityNum, boneIndex, position, outAxis);
}

/*
==============
CgWeaponSystem::IsWeaponLaserOn
==============
*/

bool __fastcall CgWeaponSystem::IsWeaponLaserOn(CgWeaponSystem *this, const Weapon *r_weapon, const playerState_s *ps, const centity_t *cent)
{
  return ?IsWeaponLaserOn@CgWeaponSystem@@UEBA_NAEBUWeapon@@PEBUplayerState_s@@PEBUcentity_t@@@Z(this, r_weapon, ps, cent);
}

/*
==============
CG_GetTracerSpeed
==============
*/

double __fastcall CG_GetTracerSpeed(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate)
{
  double result; 

  *(float *)&result = ?CG_GetTracerSpeed@@YAMV?$bitarray@$0EA@@@AEBUWeapon@@_N@Z(perks, r_weapon, isAlternate);
  return result;
}

/*
==============
CG_Weapons_ToggleEquip_OnOffhandEnd
==============
*/

void __fastcall CG_Weapons_ToggleEquip_OnOffhandEnd(LocalClientNum_t localClientNum)
{
  ?CG_Weapons_ToggleEquip_OnOffhandEnd@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_NextSlotHasWeapons
==============
*/

bool __fastcall CG_NextSlotHasWeapons(LocalClientNum_t localClientNum)
{
  return ?CG_NextSlotHasWeapons@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_Weapons_GetVehicleViewOrigin
==============
*/

bool __fastcall CG_Weapons_GetVehicleViewOrigin(const LocalClientNum_t localClientNum, const playerState_s *ps, vec3_t *outOrigin)
{
  return ?CG_Weapons_GetVehicleViewOrigin@@YA_NW4LocalClientNum_t@@PEBUplayerState_s@@AEATvec3_t@@@Z(localClientNum, ps, outOrigin);
}

/*
==============
CgWeaponSystem::SimulateImpactEffectForBeamWeapons
==============
*/

void __fastcall CgWeaponSystem::SimulateImpactEffectForBeamWeapons(CgWeaponSystem *this, const int attackerEntNum, const Weapon *r_weapon, const bool isAlternate, const centity_t *victimEnt, const BulletFireParams *bp, const vec3_t *bulletEndPos, const bool shouldDeferEvents, vec3_t *outImpactPos)
{
  ?SimulateImpactEffectForBeamWeapons@CgWeaponSystem@@QEBAXHAEBUWeapon@@_NPEBUcentity_t@@PEBUBulletFireParams@@AEBTvec3_t@@1AEAT5@@Z(this, attackerEntNum, r_weapon, isAlternate, victimEnt, bp, bulletEndPos, shouldDeferEvents, outImpactPos);
}

/*
==============
CG_UpdateHandViewmodels
==============
*/

void __fastcall CG_UpdateHandViewmodels(LocalClientNum_t localClientNum, XModel *handModel)
{
  ?CG_UpdateHandViewmodels@@YAXW4LocalClientNum_t@@PEAUXModel@@@Z(localClientNum, handModel);
}

/*
==============
CG_SndKillAutoSimEnt
==============
*/

void __fastcall CG_SndKillAutoSimEnt(centity_t *ent, bool bKillAggressively)
{
  ?CG_SndKillAutoSimEnt@@YAXPEAUcentity_t@@_N@Z(ent, bKillAggressively);
}

/*
==============
CG_Weapons_CurrentWeaponCanHybridToggle
==============
*/

bool __fastcall CG_Weapons_CurrentWeaponCanHybridToggle(LocalClientNum_t localClientNum)
{
  return ?CG_Weapons_CurrentWeaponCanHybridToggle@@YA_NW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CgWeaponSystem::DrawFriendOrFoeTargetBoxes
==============
*/

void __fastcall CgWeaponSystem::DrawFriendOrFoeTargetBoxes(CgWeaponSystem *this)
{
  ?DrawFriendOrFoeTargetBoxes@CgWeaponSystem@@UEBAXXZ(this);
}

/*
==============
CG_MeleeBloodEvent
==============
*/

void __fastcall CG_MeleeBloodEvent(LocalClientNum_t localClientNum, int attackerEntityNum)
{
  ?CG_MeleeBloodEvent@@YAXW4LocalClientNum_t@@H@Z(localClientNum, attackerEntityNum);
}

/*
==============
CgWeaponSystem::ChargedWeaponStopAllEffects
==============
*/

void __fastcall CgWeaponSystem::ChargedWeaponStopAllEffects(CgWeaponSystem *this, const centity_t *cent)
{
  ?ChargedWeaponStopAllEffects@CgWeaponSystem@@QEBAXPEBUcentity_t@@@Z(this, cent);
}

/*
==============
CgWeaponSystem::ChargedWeaponUpdateWeaponType
==============
*/

void __fastcall CgWeaponSystem::ChargedWeaponUpdateWeaponType(CgWeaponSystem *this, const centity_t *cent, const Weapon *weapon, bool isAlternate, int bViewModel)
{
  ?ChargedWeaponUpdateWeaponType@CgWeaponSystem@@IEBAXPEBUcentity_t@@AEBUWeapon@@_NH@Z(this, cent, weapon, isAlternate, bViewModel);
}

/*
==============
CG_Weapons_BuildStickerSlotList
==============
*/

DObjStickerSlotList *__fastcall CG_Weapons_BuildStickerSlotList(DObjStickerSlotList *result, const LocalClientNum_t localClientNum, const CharacterModelType *modelTypesToApply, const int modelTypesToApplyCount, const Weapon *weapon)
{
  return ?CG_Weapons_BuildStickerSlotList@@YA?AUDObjStickerSlotList@@W4LocalClientNum_t@@QEBW4CharacterModelType@@HAEBUWeapon@@@Z(result, localClientNum, modelTypesToApply, modelTypesToApplyCount, weapon);
}

/*
==============
CG_Weapons_CreateWeaponPhysics
==============
*/

void __fastcall CG_Weapons_CreateWeaponPhysics(LocalClientNum_t localClientNum, int clientNum)
{
  ?CG_Weapons_CreateWeaponPhysics@@YAXW4LocalClientNum_t@@H@Z(localClientNum, clientNum);
}

/*
==============
CgWeaponSystem::BulletWhizbySound
==============
*/

void __fastcall CgWeaponSystem::BulletWhizbySound(CgWeaponSystem *this, const Weapon *weapon, bool isAlternate, const vec3_t *start, const vec3_t *end)
{
  ?BulletWhizbySound@CgWeaponSystem@@QEBAXAEBUWeapon@@_NAEBTvec3_t@@2@Z(this, weapon, isAlternate, start, end);
}

/*
==============
CgWeaponSystem::SimulateBulletFire
==============
*/

void __fastcall CgWeaponSystem::SimulateBulletFire(CgWeaponSystem *this, int eventId, centity_t *inflictorEnt, const int knownHitClientNum, const Weapon *weapon, bool isAlternate, const TagPair tagPair, bool isPlayerView, bool isPlayerWeaponView, PlayerHandIndex hand, const int fireSequenceIndex, const CgEventLodData *optionalEventLod, const CgFireEventHighPrecisionData *highPrecisionFireData)
{
  ?SimulateBulletFire@CgWeaponSystem@@IEAAXHPEAUcentity_t@@HAEBUWeapon@@_NVTagPair@@22W4PlayerHandIndex@@HPEBUCgEventLodData@@PEBUCgFireEventHighPrecisionData@@@Z(this, eventId, inflictorEnt, knownHitClientNum, weapon, isAlternate, tagPair, isPlayerView, isPlayerWeaponView, hand, fireSequenceIndex, optionalEventLod, highPrecisionFireData);
}

/*
==============
CG_Weapons_PrecacheMedia
==============
*/

void CG_Weapons_PrecacheMedia(void)
{
  ?CG_Weapons_PrecacheMedia@@YAXXZ();
}

/*
==============
CgWeaponSystem::TrySimulateBulletFire_HitEffect
==============
*/

void __fastcall CgWeaponSystem::TrySimulateBulletFire_HitEffect(CgWeaponSystem *this, const int triggerTime, bool needsDeferring, int sourceEntityNum, int targetEntityNum, unsigned int targetScriptableIndex, const int knownHitClientNum, const Weapon *weapon, bool isAlternate, const vec3_t *initialShootingPos, const vec3_t *startPos, const vec3_t *position, const vec3_t *normal, int surfType, unsigned int meansOfDeath, unsigned int impactEffects, int hitContents, const bool forceClientSideHandling)
{
  ?TrySimulateBulletFire_HitEffect@CgWeaponSystem@@QEBAXH_NHHIHAEBUWeapon@@0AEBTvec3_t@@222HIIH_N@Z(this, triggerTime, needsDeferring, sourceEntityNum, targetEntityNum, targetScriptableIndex, knownHitClientNum, weapon, isAlternate, initialShootingPos, startPos, position, normal, surfType, meansOfDeath, impactEffects, hitContents, forceClientSideHandling);
}

/*
==============
CG_NightVisionGetBloomTimings
==============
*/

void __fastcall CG_NightVisionGetBloomTimings(const int NVGToggleTime, const bool isOn, const bool isInstant, int *outBloomStartBlendInTime, int *outBloomStartBlendOutTime, int *outBlendInDuration, int *outBlendOutDuration)
{
  ?CG_NightVisionGetBloomTimings@@YAXH_N0PEAH111@Z(NVGToggleTime, isOn, isInstant, outBloomStartBlendInTime, outBloomStartBlendOutTime, outBlendInDuration, outBlendOutDuration);
}

/*
==============
CG_GetTransitionToThrowBlendTime
==============
*/
void CG_GetTransitionToThrowBlendTime(const LocalClientNum_t localClientNum, const Weapon *r_weapon, const playerState_s *const ps, const WeaponAnimNumber blendOutAnim, const unsigned int blendOutAnimIndex, const WeaponAnimNumber blendInAnim, const unsigned int blendInAnimIndex, float *blendOutTime, float *blendInTime)
{
  cg_t *LocalClientGlobals; 
  int v19; 
  char v20; 
  char v21; 
  unsigned __int16 WeaponFieldTime; 
  const DObj *viewModelDObj; 
  const XAnimTree *Tree; 
  __int128 v52; 
  char v55; 

  __asm
  {
    vmovaps [rsp+78h+var_28], xmm6
    vmovaps [rsp+78h+var_38], xmm7
    vmovaps [rsp+78h+var_48], xmm8
  }
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( blendOutAnim == WEAP_ALTSWITCHTO )
  {
    BG_GetWeaponFieldTime(ps, r_weapon, 0, 0, 350i64);
    BG_GetWeaponFieldTime(ps, r_weapon, 0, 0, 348i64);
    v19 = BG_AltRaiseTime(ps, r_weapon, 0, 0);
    WeaponFieldTime = BG_GetWeaponFieldTime(ps, r_weapon, 0, 0, 334i64);
  }
  else
  {
    BG_GetWeaponFieldTime(ps, r_weapon, 0, 0, 346i64);
    BG_GetWeaponFieldTime(ps, r_weapon, 0, 0, 344i64);
    v19 = BG_GetWeaponFieldTime(ps, r_weapon, 0, 0, 16i64);
    WeaponFieldTime = BG_GetWeaponFieldTime(ps, r_weapon, 0, 0, 342i64);
  }
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, r15d
    vmulss  xmm8, xmm0, cs:__real@3a83126f
    vxorps  xmm7, xmm7, xmm7
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm7, xmm7, ebx
    vxorps  xmm2, xmm2, xmm2
    vcomiss xmm7, xmm2
    vcvtsi2ss xmm0, xmm0, r14d
    vmulss  xmm6, xmm0, cs:__real@3a83126f
  }
  if ( v20 | v21 || WeaponFieldTime > v19 )
  {
    _RAX = blendOutTime;
    __asm { vmovss  dword ptr [rax], xmm2 }
    _RAX = blendInTime;
    __asm { vmovss  dword ptr [rax], xmm2 }
  }
  else
  {
    if ( !LocalClientGlobals->m_weaponHand[0].viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1462, ASSERT_TYPE_ASSERT, "(weapHand->viewModelDObj)", (const char *)&queryFormat, "weapHand->viewModelDObj", v52) )
      __debugbreak();
    viewModelDObj = LocalClientGlobals->m_weaponHand[0].viewModelDObj;
    if ( !viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1465, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
      __debugbreak();
    Tree = DObjGetTree(viewModelDObj);
    if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1468, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
      __debugbreak();
    *(double *)&_XMM0 = XAnimGetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, blendOutAnimIndex);
    __asm
    {
      vxorps  xmm1, xmm1, xmm1
      vcvtsi2ss xmm1, xmm1, esi
      vdivss  xmm3, xmm1, xmm7
      vcomiss xmm0, xmm3
    }
    if ( !(v20 | v21) )
    {
      __asm
      {
        vmovss  xmm2, cs:__real@3f800000
        vsubss  xmm1, xmm0, xmm3
        vsubss  xmm0, xmm2, xmm3
        vdivss  xmm1, xmm1, xmm0
        vsubss  xmm0, xmm6, xmm8
        vsubss  xmm2, xmm2, xmm1
        vmulss  xmm1, xmm2, xmm0
        vaddss  xmm6, xmm1, xmm8
      }
    }
    _RAX = blendOutTime;
    __asm { vmovss  dword ptr [rax], xmm6 }
    _RAX = blendInTime;
    __asm { vmovss  dword ptr [rax], xmm6 }
  }
  __asm { vmovaps xmm6, [rsp+78h+var_28] }
  _R11 = &v55;
  __asm
  {
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm7, [rsp+78h+var_38]
  }
}

/*
==============
CConeTargetEvaluator::FindTargets
==============
*/
int CConeTargetEvaluator::FindTargets(CConeTargetEvaluator *this, LocalClientNum_t localClientNum, const Weapon *r_weapon, const bool isAlternate, const centity_t *attacker, const vec3_t *bulletStart, const vec3_t *bulletDir, float range, float spread, int maxTargets, const bool isBeamWeapon, const unsigned int hitLocMask, const int gameTime, const bool isFiring, ntl::fixed_array<CAssistTarget,20> *outTargetArray)
{
  __int64 v20; 
  const centity_t *v21; 
  int v25; 
  CgTargetAssist *Instance; 
  __int64 v27; 
  __int64 v28; 
  unsigned __int64 v29; 
  const centity_t **p_m_target; 
  __int64 v33; 
  CgEntitySystem *v34; 
  __int64 v35; 
  unsigned int v36; 
  unsigned int v37; 
  unsigned int v38; 
  DObj *v39; 
  void (__fastcall *FunctionPointer_origin)(const vec4_t *, vec3_t *); 
  __int64 v71; 
  __int64 v81; 
  cg_t *LocalClientGlobals; 
  GHandler *Handler; 
  tmat33_t<vec3_t> *p_m_axis; 
  __int16 attackerEntNum; 
  CgHandler *v91; 
  int result; 
  char *fmt; 
  __int64 targetCount; 
  tmat33_t<vec3_t> *bulletAxis; 
  int v101; 
  __int64 v102[2]; 
  const centity_t *v103; 
  unsigned int v104; 
  vec3_t *forward; 
  BgTargetAssist *v106; 
  vec3_t *v107; 
  ntl::fixed_array<CAssistTarget,20> *inOutTargetArray; 
  Weapon *r_weapona; 
  __int64 v110; 
  char v111[840]; 
  BGConeTargetBoneSearchParam searchParam; 
  WorldUpReferenceFrame axis; 
  tmat33_t<vec3_t> outAxis; 
  ConeTargetHitResults outSearchResults; 
  char v116; 
  void *retaddr; 

  _RAX = &retaddr;
  v110 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
  }
  r_weapona = (Weapon *)r_weapon;
  v20 = localClientNum;
  v21 = attacker;
  v103 = attacker;
  v107 = (vec3_t *)bulletStart;
  forward = (vec3_t *)bulletDir;
  inOutTargetArray = outTargetArray;
  if ( !attacker && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25686, ASSERT_TYPE_ASSERT, "( attacker )", (const char *)&queryFormat, "attacker") )
    __debugbreak();
  __asm
  {
    vmovss  xmm0, [rbp+780h+spread]
    vmulss  xmm0, xmm0, cs:__real@3c8efa35; X
  }
  *(float *)&_XMM0 = cosf_0(*(float *)&_XMM0);
  __asm { vmovaps xmm7, xmm0 }
  v25 = 0;
  Instance = CgTargetAssist::GetInstance((const LocalClientNum_t)v20);
  v106 = Instance;
  v27 = 0xFFFFFFFFi64;
  LOWORD(v101) = 2047;
  v28 = v20;
  v29 = 0i64;
  p_m_target = &outTargetArray->m_data[0].m_target;
  __asm
  {
    vmovss  xmm8, [rbp+780h+range]
    vmovsd  xmm6, cs:__real@3f30000000000000
  }
  while ( 1 )
  {
    LODWORD(fmt) = gameTime;
    v104 = Instance->FindNextTarget(Instance, (const LocalClientNum_t)v20, v21->nextState.number, v27, (const int)fmt, (__int16 *)&v101);
    if ( v104 == 0x7FFFFFFF )
      break;
    v33 = (__int16)v101;
    if ( !(_BYTE)CgEntitySystem::ms_allocatedType )
    {
      LODWORD(bulletAxis) = v20;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 288, ASSERT_TYPE_ASSERT, "(ms_allocatedType != GameModeType::NONE)", "%s\n\tTrying to access the entity system for localClientNum %d but the entity system type is not known\n", "ms_allocatedType != GameModeType::NONE", bulletAxis) )
        __debugbreak();
    }
    if ( (unsigned int)v20 >= CgEntitySystem::ms_allocatedCount )
    {
      LODWORD(bulletAxis) = CgEntitySystem::ms_allocatedCount;
      LODWORD(targetCount) = v20;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 289, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( ms_allocatedCount )", "localClientNum doesn't index ms_allocatedCount\n\t%i not in [0, %i)", targetCount, bulletAxis) )
        __debugbreak();
    }
    if ( !CgEntitySystem::ms_entitySystemArray[v28] )
    {
      LODWORD(bulletAxis) = v20;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 290, ASSERT_TYPE_ASSERT, "(ms_entitySystemArray[localClientNum])", "%s\n\tTrying to access unallocated entity system for localClientNum %d\n", "ms_entitySystemArray[localClientNum]", bulletAxis) )
        __debugbreak();
    }
    v34 = CgEntitySystem::ms_entitySystemArray[v28];
    if ( (unsigned int)v33 >= 0x800 )
    {
      LODWORD(bulletAxis) = 2048;
      LODWORD(targetCount) = v33;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 518, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( (( 2048 ) + 0) )", "entityIndex doesn't index MAX_LOCAL_CENTITIES\n\t%i not in [0, %i)", targetCount, bulletAxis) )
        __debugbreak();
    }
    v35 = (__int64)&v34->m_entities[v33];
    if ( (*(_BYTE *)(v35 + 648) & 1) != 0 )
    {
      v36 = *(__int16 *)(v35 + 400);
      if ( v36 > 0x9E4 )
      {
        LODWORD(bulletAxis) = *(__int16 *)(v35 + 400);
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\dobj_management.h", 55, ASSERT_TYPE_ASSERT, "( ( handle >= 0 && handle < ((((((((((((( 2048 ) + 0)) + NUM_WEAPON_HANDS) + 64 - 1) + 1) + 1) + 1) + 1) + CLIENT_MODEL_MAX_COUNT - 1) + 1) + ( 32 ) - 1) + 1) ) )", "%s\n\t( handle ) = %i", "( handle >= 0 && handle < ((((((((((((( 2048 ) + 0)) + NUM_WEAPON_HANDS) + 64 - 1) + 1) + 1) + 1) + 1) + CLIENT_MODEL_MAX_COUNT - 1) + 1) + ( 32 ) - 1) + 1) )", bulletAxis) )
          __debugbreak();
      }
      if ( (unsigned int)v20 >= 2 )
      {
        LODWORD(bulletAxis) = 2;
        LODWORD(targetCount) = v20;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\dobj_management.h", 58, ASSERT_TYPE_ASSERT, "(unsigned)( localClientIndex ) < (unsigned)( (2) )", "localClientIndex doesn't index MAX_DOBJ_CLIENTS\n\t%i not in [0, %i)", targetCount, bulletAxis) )
          __debugbreak();
      }
      v37 = 2533 * v20 + v36;
      if ( v37 >= 0x13CA )
      {
        LODWORD(bulletAxis) = v37;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\dobj_management.h", 62, ASSERT_TYPE_ASSERT, "( ( (unsigned)handle < ( sizeof( *array_counter( clientObjMap ) ) + 0 ) ) )", "%s\n\t( handle ) = %i", "( (unsigned)handle < ( sizeof( *array_counter( clientObjMap ) ) + 0 ) )", bulletAxis) )
          __debugbreak();
      }
      v38 = clientObjMap[v37];
      if ( v38 )
      {
        if ( v38 >= (unsigned int)s_objCount )
        {
          LODWORD(bulletAxis) = v38;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\dobj_management.h", 64, ASSERT_TYPE_ASSERT, "( ( !objIndex || ( (unsigned)objIndex < s_objCount ) ) )", "%s\n\t( objIndex ) = %i", "( !objIndex || ( (unsigned)objIndex < s_objCount ) )", bulletAxis) )
            __debugbreak();
        }
        v39 = (DObj *)s_objBuf[v38];
        if ( v39 && DObjGetFirstModel(v39) )
        {
          AnglesToAxis((const vec3_t *)(v35 + 72), (tmat33_t<vec3_t> *)&axis);
          if ( !*(_QWORD *)(v35 + 48) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_pose.h", 380, ASSERT_TYPE_ASSERT, "(pose->origin.Get_origin)", (const char *)&queryFormat, "pose->origin.Get_origin") )
            __debugbreak();
          FunctionPointer_origin = ObfuscateGetFunctionPointer_origin(*(void (__fastcall *const *)(const vec4_t *, vec3_t *))(v35 + 48), (const cpose_t *)v35);
          FunctionPointer_origin((const vec4_t *)(v35 + 56), (vec3_t *)v102);
          if ( *(_BYTE *)(v35 + 2) )
          {
            __asm
            {
              vmovd   xmm0, [rsp+880h+var_818]
              vcvtdq2pd xmm0, xmm0
              vmulsd  xmm1, xmm0, xmm6
              vcvtsd2ss xmm3, xmm1, xmm1
              vmovd   xmm2, [rsp+880h+var_814]
              vcvtdq2pd xmm2, xmm2
              vmulsd  xmm0, xmm2, xmm6
              vcvtsd2ss xmm4, xmm0, xmm0
              vmovd   xmm1, dword ptr [rsp+880h+var_810]
              vcvtdq2pd xmm1, xmm1
              vmulsd  xmm2, xmm1, xmm6
              vcvtsd2ss xmm5, xmm2, xmm2
            }
          }
          else
          {
            __asm
            {
              vmovss  xmm5, dword ptr [rsp+880h+var_810]
              vmovss  xmm4, [rsp+880h+var_814]
              vmovss  xmm3, [rsp+880h+var_818]
            }
          }
          __asm
          {
            vcvttss2si eax, xmm3
            vxorps  xmm0, xmm0, xmm0
            vcvtsi2ss xmm0, xmm0, eax
            vmovss  [rsp+880h+var_818], xmm0
            vcvttss2si eax, xmm4
            vxorps  xmm1, xmm1, xmm1
            vcvtsi2ss xmm1, xmm1, eax
            vmovss  [rsp+880h+var_814], xmm1
            vcvttss2si eax, xmm5
            vxorps  xmm0, xmm0, xmm0
            vcvtsi2ss xmm0, xmm0, eax
            vmovss  dword ptr [rsp+880h+var_810], xmm0
          }
          memset_0(&searchParam, 0, sizeof(searchParam));
          searchParam.pmoveHandler = CgHandler::getHandler((LocalClientNum_t)v20);
          searchParam.es = (const entityState_t *)(v35 + 400);
          searchParam.entityDobj = v39;
          __asm
          {
            vmovss  xmm0, [rsp+880h+var_818]
            vmovss  dword ptr [rbp+780h+searchParam.entityOrigin], xmm0
            vmovss  xmm1, [rsp+880h+var_814]
            vmovss  dword ptr [rbp+780h+searchParam.entityOrigin+4], xmm1
            vmovss  xmm0, dword ptr [rsp+880h+var_810]
            vmovss  dword ptr [rbp+780h+searchParam.entityOrigin+8], xmm0
          }
          AxisCopy((const tmat33_t<vec3_t> *)&axis, &searchParam.entityAxis);
          searchParam.pmoveHandler = CgHandler::getHandler((LocalClientNum_t)v20);
          _RAX = v107;
          __asm
          {
            vmovss  xmm0, dword ptr [rax]
            vmovss  dword ptr [rbp+780h+searchParam.bulletStart], xmm0
            vmovss  xmm1, dword ptr [rax+4]
            vmovss  dword ptr [rbp+780h+searchParam.bulletStart+4], xmm1
            vmovss  xmm0, dword ptr [rax+8]
            vmovss  dword ptr [rbp+780h+searchParam.bulletStart+8], xmm0
          }
          _RAX = forward;
          __asm
          {
            vmovss  xmm1, dword ptr [rax]
            vmovss  dword ptr [rbp+780h+searchParam.bulletDir], xmm1
            vmovss  xmm0, dword ptr [rax+4]
            vmovss  dword ptr [rbp+780h+searchParam.bulletDir+4], xmm0
            vmovss  xmm1, dword ptr [rax+8]
            vmovss  dword ptr [rbp+780h+searchParam.bulletDir+8], xmm1
            vmovss  [rbp+780h+searchParam.bulletRange], xmm8
            vmovss  [rbp+780h+searchParam.maxDot], xmm7
          }
          searchParam.hitLocMask = hitLocMask;
          searchParam.localClientNum = v20;
          searchParam.isFiring = isFiring;
          if ( BgTargetAssist::FindBonesWithinCone(v106, &searchParam, &outSearchResults) )
          {
            _RCX = v111;
            _RDX = &outSearchResults;
            v71 = 6i64;
            do
            {
              __asm
              {
                vmovups ymm0, ymmword ptr [rdx]
                vmovups ymmword ptr [rcx], ymm0
                vmovups ymm0, ymmword ptr [rdx+20h]
                vmovups ymmword ptr [rcx+20h], ymm0
                vmovups ymm0, ymmword ptr [rdx+40h]
                vmovups ymmword ptr [rcx+40h], ymm0
                vmovups xmm0, xmmword ptr [rdx+60h]
                vmovups xmmword ptr [rcx+60h], xmm0
              }
              _RCX += 128;
              __asm
              {
                vmovups xmm1, xmmword ptr [rdx+70h]
                vmovups xmmword ptr [rcx-10h], xmm1
              }
              _RDX = (ConeTargetHitResults *)((char *)_RDX + 128);
              --v71;
            }
            while ( v71 );
            __asm
            {
              vmovups ymm0, ymmword ptr [rdx]
              vmovups ymmword ptr [rcx], ymm0
              vmovups xmm0, xmmword ptr [rdx+20h]
              vmovups xmmword ptr [rcx+20h], xmm0
            }
            *((_QWORD *)_RCX + 6) = *(_QWORD *)&_RDX->hits[0].tagName;
            *((_DWORD *)_RCX + 14) = _RDX->hits[0].modelIndex;
            if ( (unsigned __int64)v25 >= 0x14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\array\\fixed_array.h", 87, ASSERT_TYPE_ASSERT, "( index < size() )", (const char *)&queryFormat, "index < size()") )
              __debugbreak();
            _RCX = ConeTargetInfo::GetHitResults(&inOutTargetArray->m_data[v25]);
            _RDX = v111;
            v81 = 6i64;
            do
            {
              __asm
              {
                vmovups ymm0, ymmword ptr [rdx]
                vmovups ymmword ptr [rcx], ymm0
                vmovups ymm0, ymmword ptr [rdx+20h]
                vmovups ymmword ptr [rcx+20h], ymm0
                vmovups ymm0, ymmword ptr [rdx+40h]
                vmovups ymmword ptr [rcx+40h], ymm0
                vmovups xmm0, xmmword ptr [rdx+60h]
                vmovups xmmword ptr [rcx+60h], xmm0
              }
              _RCX = (ConeTargetHitResults *)((char *)_RCX + 128);
              __asm
              {
                vmovups xmm1, xmmword ptr [rdx+70h]
                vmovups xmmword ptr [rcx-10h], xmm1
              }
              _RDX += 128;
              --v81;
            }
            while ( v81 );
            __asm
            {
              vmovups ymm0, ymmword ptr [rdx]
              vmovups ymmword ptr [rcx], ymm0
              vmovups xmm0, xmmword ptr [rdx+20h]
              vmovups xmmword ptr [rcx+20h], xmm0
            }
            *(_QWORD *)&_RCX->hits[0].tagName = *((_QWORD *)_RDX + 6);
            _RCX->hits[0].modelIndex = *((_DWORD *)_RDX + 14);
            if ( v29 >= 0x14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\array\\fixed_array.h", 87, ASSERT_TYPE_ASSERT, "( index < size() )", (const char *)&queryFormat, "index < size()") )
              __debugbreak();
            *p_m_target = (const centity_t *)v35;
            ++v25;
            ++v29;
            p_m_target += 106;
          }
          memset(v102, 0, 0xCui64);
        }
      }
      v21 = v103;
    }
    v27 = v104;
    v28 = v20;
    if ( (unsigned int)v25 >= 0x14 )
      break;
    Instance = (CgTargetAssist *)v106;
  }
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v20);
  if ( LocalClientGlobals->predictedPlayerState.clientNum == v21->nextState.number )
  {
    Handler = GHandler::getHandler();
    WorldUpReferenceFrame::WorldUpReferenceFrame(&axis, &LocalClientGlobals->predictedPlayerState, Handler);
    p_m_axis = &axis.m_axis;
  }
  else
  {
    MatrixIdentity33((tmat33_t<vec3_t> *)&axis);
    p_m_axis = (tmat33_t<vec3_t> *)&axis;
  }
  GenerateAxisFromForwardVector(forward, p_m_axis, &outAxis);
  attackerEntNum = v21->nextState.number;
  v91 = CgHandler::getHandler((LocalClientNum_t)v20);
  result = BgTargetAssist::EvaluateTargetsWithinCone<CAssistTarget>(v106, v91, r_weapona, isAlternate, inOutTargetArray, v25, &outAxis, v107, maxTargets, attackerEntNum, (const Physics_WorldId)(3 * v20 + 4), isFiring);
  _R11 = &v116;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
  }
  return result;
}

/*
==============
CConeTargetEvaluator::EvaluateTarget
==============
*/
bool CConeTargetEvaluator::EvaluateTarget(CConeTargetEvaluator *this, LocalClientNum_t localClientNum, const CAssistTarget *assistTarget, const vec3_t *bulletStart, float range, vec3_t *outBulletEnd, vec3_t *outBulletDir)
{
  ConeTargetHitResults *HitResults; 
  ConeTargetHitResults *v14; 

  _RBP = outBulletEnd;
  _RSI = outBulletDir;
  if ( !assistTarget && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25773, ASSERT_TYPE_ASSERT, "(assistTarget)", (const char *)&queryFormat, "assistTarget") )
    __debugbreak();
  HitResults = (ConeTargetHitResults *)ConeTargetInfo::GetHitResults(&assistTarget->ConeTargetInfo);
  _RAX = ConeTargetHitResults::GetFirstVisibleHit(HitResults);
  if ( _RAX )
  {
    __asm
    {
      vmovaps [rsp+58h+var_18], xmm6
      vmovaps [rsp+58h+var_28], xmm7
    }
    v14 = (ConeTargetHitResults *)ConeTargetInfo::GetHitResults(&assistTarget->ConeTargetInfo);
    _RAX = ConeTargetHitResults::GetFirstVisibleHit(v14);
    __asm
    {
      vmovss  xmm0, dword ptr [rax]
      vsubss  xmm5, xmm0, dword ptr [rdi]
      vmovss  xmm1, dword ptr [rax+4]
      vsubss  xmm6, xmm1, dword ptr [rdi+4]
      vmovss  xmm0, dword ptr [rax+8]
      vsubss  xmm7, xmm0, dword ptr [rdi+8]
      vmulss  xmm0, xmm7, xmm7
      vmulss  xmm2, xmm6, xmm6
      vmulss  xmm1, xmm5, xmm5
      vaddss  xmm3, xmm2, xmm1
      vmovss  xmm1, cs:__real@3f800000
      vaddss  xmm2, xmm3, xmm0
      vsqrtss xmm4, xmm2, xmm2
      vcmpless xmm0, xmm4, cs:__real@80000000
      vblendvps xmm0, xmm4, xmm1, xmm0
      vmovss  xmm4, [rsp+58h+range]
      vdivss  xmm2, xmm1, xmm0
      vmulss  xmm0, xmm2, xmm6
      vmovaps xmm6, [rsp+58h+var_18]
    }
    LOBYTE(_RAX) = 1;
    __asm
    {
      vmovss  dword ptr [rsi+4], xmm0
      vmulss  xmm1, xmm2, xmm7
      vmovaps xmm7, [rsp+58h+var_28]
      vmovss  dword ptr [rsi+8], xmm1
      vmulss  xmm3, xmm2, xmm5
      vmovss  dword ptr [rsi], xmm3
      vmulss  xmm0, xmm3, xmm4
      vaddss  xmm1, xmm0, dword ptr [rdi]
      vmovss  dword ptr [rbp+0], xmm1
      vmulss  xmm0, xmm4, dword ptr [rsi+4]
      vaddss  xmm1, xmm0, dword ptr [rdi+4]
      vmovss  dword ptr [rbp+4], xmm1
      vmulss  xmm0, xmm4, dword ptr [rsi+8]
      vaddss  xmm1, xmm0, dword ptr [rdi+8]
      vmovss  dword ptr [rbp+8], xmm1
    }
  }
  return (char)_RAX;
}

/*
==============
CgWeaponSystem::AddDebugBulletLine
==============
*/
void CgWeaponSystem::AddDebugBulletLine(CgWeaponSystem *this, const vec3_t *start, const vec3_t *end)
{
  volatile int *p_m_numBulletDebugLines; 
  __int64 v7; 
  int v8; 
  __int64 v9; 
  __int64 v10; 
  __int64 v11; 

  p_m_numBulletDebugLines = &this->m_numBulletDebugLines;
  v7 = ((_BYTE)this - 52) & 3;
  if ( (((_BYTE)this - 52) & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &this->m_numBulletDebugLines) )
    __debugbreak();
  v8 = _InterlockedExchangeAdd(p_m_numBulletDebugLines, 1u);
  if ( v8 < 200 )
  {
    v9 = 2 * v8;
    v10 = 3 * v9 + 3;
    *((_DWORD *)&this->__vftable + v10) = LODWORD(start->v[0]);
    *((_DWORD *)&this->__vftable + v10 + 1) = LODWORD(start->v[1]);
    *((_DWORD *)&this->m_localClientNum + v10) = LODWORD(start->v[2]);
    v11 = 3 * v9 + 6;
    *((_DWORD *)&this->__vftable + v11) = LODWORD(end->v[0]);
    *((_DWORD *)&this->__vftable + v11 + 1) = LODWORD(end->v[1]);
    *((_DWORD *)&this->m_localClientNum + v11) = LODWORD(end->v[2]);
  }
  else
  {
    if ( v7 )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 44, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", (const void *)p_m_numBulletDebugLines) )
        __debugbreak();
    }
    _InterlockedDecrement(p_m_numBulletDebugLines);
  }
}

/*
==============
BlendViewModelAnimIfPlaying
==============
*/

void __fastcall BlendViewModelAnimIfPlaying(DObj *obj, weapAnimFiles_t blendOutAnim, weapAnimFiles_t blendInAnim, double blendOutTime, float blendInTime)
{
  const dvar_t *v8; 
  const XAnimTree *Tree; 
  char v15; 
  char v16; 
  float fmt; 
  float fmta; 
  float goalTime; 
  float goalTimea; 
  float rate; 
  float ratea; 

  v8 = DCONST_DVARBOOL_cg_viewmodelAnimBlending;
  __asm
  {
    vmovaps [rsp+88h+var_28], xmm7
    vmovaps xmm7, xmm3
  }
  if ( !DCONST_DVARBOOL_cg_viewmodelAnimBlending && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmodelAnimBlending") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v8);
  if ( v8->current.enabled )
  {
    __asm { vmovaps [rsp+88h+var_18], xmm6 }
    if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3252, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
      __debugbreak();
    Tree = DObjGetTree(obj);
    *(double *)&_XMM0 = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, blendOutAnim);
    __asm
    {
      vxorps  xmm6, xmm6, xmm6
      vcomiss xmm0, xmm6
    }
    if ( !(v15 | v16) )
    {
      *(double *)&_XMM0 = XAnimGetGoalTime(Tree, 0, XANIM_SUBTREE_DEFAULT, blendOutAnim);
      __asm { vucomiss xmm0, xmm6 }
      if ( v16 )
      {
        __asm
        {
          vmovss  [rsp+88h+rate], xmm6
          vmovss  [rsp+88h+goalTime], xmm7
          vmovss  dword ptr [rsp+88h+fmt], xmm6
        }
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, blendOutAnim, fmt, goalTime, rate, (scr_string_t)0, 0, 0, LINEAR, NULL);
        __asm
        {
          vmovss  xmm0, [rsp+88h+blendInTime]
          vmovss  xmm1, cs:__real@3f800000
          vmovss  [rsp+88h+rate], xmm6
          vmovss  [rsp+88h+goalTime], xmm0
          vmovss  dword ptr [rsp+88h+fmt], xmm1
        }
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, blendInAnim, fmta, goalTimea, ratea, (scr_string_t)0, 1u, 1, LINEAR, NULL);
      }
    }
    __asm { vmovaps xmm6, [rsp+88h+var_18] }
  }
  __asm { vmovaps xmm7, [rsp+88h+var_28] }
}

/*
==============
CgWeaponSystem::BloodSplatterOnShield
==============
*/
void CgWeaponSystem::BloodSplatterOnShield(CgWeaponSystem *this, int entityNum)
{
  centity_t *Entity; 
  centity_t *v5; 
  LocalClientNum_t m_localClientNum; 
  const DObj *ClientDObj; 
  LocalClientNum_t v22; 
  const Material *markMaterialOverride; 
  cg_t *LocalClientGlobals; 
  vec3_t outOrigin; 
  tmat33_t<vec3_t> axis; 
  tmat33_t<vec3_t> forward; 
  vec3_t outPos; 

  if ( (unsigned int)(entityNum - 2046) > 1 )
  {
    if ( cgMedia.fxBloodOnRiotshield.m_particleSystemDef )
    {
      Entity = CG_GetEntity((const LocalClientNum_t)this->m_localClientNum, entityNum);
      v5 = Entity;
      if ( (Entity->flags & 1) != 0 )
      {
        AnglesToAxis(&Entity->pose.angles, &axis);
        __asm
        {
          vmovss  xmm3, dword ptr cs:__xmm@80000000800000008000000080000000
          vmovss  xmm0, dword ptr [rsp+0E8h+axis]
          vmovss  xmm2, dword ptr [rsp+0E8h+axis+4]
          vxorps  xmm1, xmm0, xmm3
          vxorps  xmm0, xmm2, xmm3
          vmovss  dword ptr [rsp+0E8h+forward], xmm1
          vmovss  xmm1, dword ptr [rsp+0E8h+axis+8]
          vxorps  xmm2, xmm1, xmm3
          vmovss  dword ptr [rsp+0E8h+forward+8], xmm2
          vmovss  dword ptr [rsp+0E8h+forward+4], xmm0
        }
        AxisRandomAroundForward(forward.m, &forward.m[1], &forward.m[2]);
        CG_GetPoseOrigin(&v5->pose, &outOrigin);
        m_localClientNum = this->m_localClientNum;
        if ( (v5->flags & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20503, ASSERT_TYPE_ASSERT, "(CENextValid( targetEnt ))", (const char *)&queryFormat, "CENextValid( targetEnt )") )
          __debugbreak();
        ClientDObj = Com_GetClientDObj(v5->nextState.number, m_localClientNum);
        if ( ClientDObj && CG_DObjGetWorldTagPos(&v5->pose, ClientDObj, scr_const.tag_weapon_left, &outPos) )
          __asm { vmovss  xmm5, dword ptr [rsp+0E8h+outPos+8] }
        else
          __asm { vmovss  xmm5, cs:__real@42200000 }
        __asm
        {
          vmovss  xmm4, cs:__real@41200000
          vmulss  xmm2, xmm4, dword ptr [rsp+0E8h+axis]
          vaddss  xmm2, xmm2, dword ptr [rsp+0E8h+outOrigin]
          vmulss  xmm3, xmm4, dword ptr [rsp+0E8h+axis+4]
          vmulss  xmm1, xmm4, dword ptr [rsp+0E8h+axis+8]
        }
        v22 = this->m_localClientNum;
        markMaterialOverride = MARK_MATERIAL_OVERRIDE_NONE_2;
        __asm
        {
          vmovss  dword ptr [rsp+0E8h+outOrigin], xmm2
          vaddss  xmm2, xmm3, dword ptr [rsp+0E8h+outOrigin+4]
          vmovss  dword ptr [rsp+0E8h+outOrigin+4], xmm2
          vaddss  xmm2, xmm1, xmm5
          vmovss  dword ptr [rsp+0E8h+outOrigin+8], xmm2
        }
        LocalClientGlobals = CG_GetLocalClientGlobals(v22);
        FX_PlayOrientedEffectWithMarkEntity(this->m_localClientNum, &cgMedia.fxBloodOnRiotshield, LocalClientGlobals->time, &outOrigin, &forward, 0, entityNum, 1, 0xFEu, markMaterialOverride);
      }
    }
  }
}

/*
==============
CgWeaponSystem::BulletClientAuthPhysicsImpact
==============
*/
void CgWeaponSystem::BulletClientAuthPhysicsImpact(CgWeaponSystem *this, const unsigned int inflictorEntNum, const Weapon *weapon, bool isAlternate, const bool hasBulletExploded, const meansOfDeath_t mod, const vec3_t *start, const vec3_t *hitPos)
{
  cg_t *LocalClientGlobals; 
  float isMelee; 
  float weapona; 
  float effectCallback; 
  char v34; 

  __asm { vmovaps [rsp+88h+var_38], xmm8 }
  if ( hasBulletExploded )
  {
    *(double *)&_XMM0 = BG_WeaponBulletFire_GetExplDmg(weapon, isAlternate);
    __asm { vmovaps xmm8, xmm0 }
  }
  else
  {
    BG_GetDamage(WEAP_DMG_CALC_TYPE_DEFAULT, weapon, isAlternate);
    __asm
    {
      vxorps  xmm8, xmm8, xmm8
      vcvtsi2ss xmm8, xmm8, eax
    }
  }
  Physics_AddDeferredBulletForce((const Physics_WorldId)(3 * this->m_localClientNum + 3), start, hitPos, inflictorEntNum, 0, weapon, isAlternate, mod, CG_BulletHitEffectCallback);
  if ( hasBulletExploded )
  {
    __asm
    {
      vmovaps [rsp+88h+var_18], xmm6
      vmovaps [rsp+88h+var_28], xmm7
    }
    *(double *)&_XMM0 = BG_WeaponBulletFire_GetExplRadius(weapon, isAlternate);
    __asm { vmovaps xmm7, xmm0 }
    *(double *)&_XMM0 = BG_WeaponBulletFire_GetExplDmgMin(weapon, isAlternate);
    __asm { vmovaps xmm6, xmm0 }
    LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
    *(double *)&_XMM0 = BG_ExplosionForceScalar(weapon, isAlternate);
    __asm
    {
      vmovss  [rsp+88h+effectCallback], xmm0
      vxorps  xmm0, xmm0, xmm0
      vmovss  dword ptr [rsp+88h+weapon], xmm0
      vmovaps xmm3, xmm8; innerDamage
      vmovaps xmm2, xmm7; radius
      vmovss  dword ptr [rsp+88h+isMelee], xmm6
    }
    Physics_AddDeferredRadiusForce((const Physics_WorldId)(3 * this->m_localClientNum + 3), hitPos, *(const float *)&_XMM2, *(const float *)&_XMM3, isMelee, weapona, &vec3_origin, LocalClientGlobals->time, effectCallback);
    __asm
    {
      vmovaps xmm7, [rsp+88h+var_28]
      vmovaps xmm6, [rsp+88h+var_18]
    }
  }
  _R11 = &v34;
  __asm { vmovaps xmm8, xmmword ptr [r11-30h] }
}

/*
==============
BulletHitClientEventSound
==============
*/
void BulletHitClientEventSound(LocalClientNum_t localClientNum, int sourceEntityNum, const Weapon *weapon, bool isAlternate, const vec3_t *hitPosition, int surfType, int event, unsigned int impactEffects, SndHitArmorType hitArmorType)
{
  __int64 ImpactSoundHitLocation; 
  WeaponSFXPackage *SfxPackage; 
  SfxImpactGroup *p_npcImpactSounds; 
  SndAliasList *bulletExplodeSound; 
  bool v23; 
  const dvar_t *v28; 
  meansOfDeath_t MethodOfDeath; 
  bool ShouldRicochet; 
  bool v32; 
  centity_t *Entity; 
  char v45; 
  CgSoundSystem *SoundSystem; 
  int v66; 
  int v67; 
  int fxImpactType; 
  vec3_t outOrg; 
  unsigned int clientNum; 
  vec3_t outOrigin; 
  __int64 v73; 
  int v74; 
  bitarray<64> outPerks; 
  char v78; 
  void *retaddr; 

  _RAX = &retaddr;
  v73 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-58h], xmm6
    vmovaps xmmword ptr [rax-68h], xmm7
    vmovaps xmmword ptr [rax-78h], xmm8
    vmovaps xmmword ptr [rax-88h], xmm9
  }
  if ( (unsigned int)surfType > 0x3F && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20559, ASSERT_TYPE_ASSERT, "(surfType >= 0 && surfType < 64)", (const char *)&queryFormat, "surfType >= 0 && surfType < SURF_TYPECOUNT") )
    __debugbreak();
  _R14 = CG_GetLocalClientGlobals(localClientNum);
  if ( !_R14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20562, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  clientNum = _R14->predictedPlayerState.clientNum;
  ImpactSoundHitLocation = CG_GetImpactSoundHitLocation(localClientNum, clientNum, impactEffects);
  SfxPackage = BG_GetSfxPackage(weapon, isAlternate);
  fxImpactType = CG_Main_RegisteredImpactTypeToImpactType(UNKNOWN);
  if ( SfxPackage )
    fxImpactType = SfxPackage->sfxImpactType;
  CG_OverrideImpactEffectType(localClientNum, sourceEntityNum, &fxImpactType);
  p_npcImpactSounds = &cgMedia.npcImpactSounds;
  if ( CG_IsPlayerEntityNumber(&_R14->predictedPlayerState, sourceEntityNum) )
    p_npcImpactSounds = &cgMedia.playerImpactSounds;
  switch ( CG_Main_ImpactTypeToRegisteredImpactType(fxImpactType) )
  {
    case 1:
    case 2:
      bulletExplodeSound = cgMedia.fleshBulletSmall.player[ImpactSoundHitLocation][hitArmorType];
      goto LABEL_36;
    case 3:
    case 4:
      bulletExplodeSound = cgMedia.fleshBulletLarge.player[ImpactSoundHitLocation][hitArmorType];
      goto LABEL_36;
    case 5:
      bulletExplodeSound = cgMedia.fleshBulletExplode.player[ImpactSoundHitLocation][hitArmorType];
      goto LABEL_36;
    case 6:
      bulletExplodeSound = cgMedia.fleshShotgun.player[ImpactSoundHitLocation][hitArmorType];
      goto LABEL_36;
    case 7:
      bulletExplodeSound = p_npcImpactSounds->bulletExplodeSound;
      goto LABEL_36;
    case 10:
      bulletExplodeSound = cgMedia.grenadeExplodeSound;
      goto LABEL_36;
    case 12:
      bulletExplodeSound = cgMedia.rocketExplodeSound;
      goto LABEL_36;
    case 13:
      bulletExplodeSound = cgMedia.rocketExplodeSoundSmall;
      goto LABEL_36;
    case 14:
      v23 = isAlternate;
      bulletExplodeSound = (SndAliasList *)BG_ProjDudSound(weapon, isAlternate);
      goto LABEL_37;
    case 15:
      bulletExplodeSound = cgMedia.fleshVehBullet.player[ImpactSoundHitLocation][hitArmorType];
      goto LABEL_36;
    case 16:
      bulletExplodeSound = cgMedia.fleshVehBulletExplode.player[ImpactSoundHitLocation][hitArmorType];
      goto LABEL_36;
    case 17:
      bulletExplodeSound = cgMedia.vehMissileExplodeSound;
      goto LABEL_36;
    case 19:
      bulletExplodeSound = cgMedia.fleshArcaneRed.player[ImpactSoundHitLocation][hitArmorType];
      goto LABEL_36;
    case 21:
      bulletExplodeSound = cgMedia.fleshArcaneYellow.player[ImpactSoundHitLocation][hitArmorType];
      goto LABEL_36;
    case 22:
      bulletExplodeSound = cgMedia.fleshArcanePink.player[ImpactSoundHitLocation][hitArmorType];
      goto LABEL_36;
    case 23:
      bulletExplodeSound = cgMedia.fleshArcaneBlue.player[ImpactSoundHitLocation][hitArmorType];
      goto LABEL_36;
    case 25:
      bulletExplodeSound = cgMedia.fleshRock1.player[ImpactSoundHitLocation][hitArmorType];
      goto LABEL_36;
    case 26:
      bulletExplodeSound = cgMedia.fleshRock2.player[ImpactSoundHitLocation][hitArmorType];
      goto LABEL_36;
    case 27:
      bulletExplodeSound = cgMedia.fleshRock3.player[ImpactSoundHitLocation][hitArmorType];
      goto LABEL_36;
    case 28:
      bulletExplodeSound = cgMedia.fleshRock4.player[ImpactSoundHitLocation][hitArmorType];
      goto LABEL_36;
    case 29:
      bulletExplodeSound = cgMedia.fleshDLC1.player[ImpactSoundHitLocation][hitArmorType];
      goto LABEL_36;
    case 30:
      bulletExplodeSound = cgMedia.fleshDLC2.player[ImpactSoundHitLocation][hitArmorType];
      goto LABEL_36;
    case 31:
      bulletExplodeSound = cgMedia.fleshDLC3.player[ImpactSoundHitLocation][hitArmorType];
      goto LABEL_36;
    case 32:
      bulletExplodeSound = cgMedia.fleshDLC4.player[ImpactSoundHitLocation][hitArmorType];
LABEL_36:
      v23 = isAlternate;
LABEL_37:
      _RAX = hitPosition;
      __asm
      {
        vmovss  xmm0, dword ptr [rax]
        vmovss  [rbp+3Fh+var_A8], xmm0
        vmovss  xmm1, dword ptr [rax+4]
        vmovss  [rbp+3Fh+var_A4], xmm1
        vmovss  xmm0, dword ptr [rax+8]
        vmovss  [rbp+3Fh+var_A0], xmm0
      }
      v28 = DCONST_DVARMPBOOL_cg_adjustClientImpactSound;
      if ( !DCONST_DVARMPBOOL_cg_adjustClientImpactSound && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_adjustClientImpactSound") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v28);
      __asm { vmovss  xmm6, cs:__real@3f800000 }
      if ( v28->current.enabled )
      {
        CG_GetPerks(localClientNum, sourceEntityNum, &outPerks);
        MethodOfDeath = BG_WeaponBulletFire_GetMethodOfDeath(outPerks, weapon, v23);
        ShouldRicochet = BG_WeaponBulletFire_ShouldRicochet(outPerks, weapon, v23);
        v32 = ((MethodOfDeath - 1) & 0xFFFFFFF6) == 0 && MethodOfDeath != MOD_MELEE_DOG;
        if ( !ShouldRicochet && (unsigned int)sourceEntityNum < 0x7FF && v32 )
        {
          Entity = CG_GetEntity(localClientNum, sourceEntityNum);
          if ( Entity )
          {
            if ( (Entity->flags & 1) != 0 )
            {
              CG_GetPoseOrigin(&Entity->pose, &outOrigin);
              RefdefView_GetOrg(&_R14->refdef.view, &outOrg);
              __asm
              {
                vmovss  xmm0, dword ptr [rsp+120h+outOrigin]
                vsubss  xmm3, xmm0, dword ptr [rsp+120h+outOrg]
                vmovss  xmm1, dword ptr [rbp+3Fh+outOrigin+4]
                vsubss  xmm4, xmm1, dword ptr [rsp+120h+outOrg+4]
                vmovss  xmm0, dword ptr [rbp+3Fh+outOrigin+8]
                vsubss  xmm5, xmm0, dword ptr [rsp+120h+outOrg+8]
                vmulss  xmm1, xmm4, xmm4
                vmulss  xmm0, xmm3, xmm3
                vaddss  xmm2, xmm1, xmm0
                vmulss  xmm1, xmm5, xmm5
                vaddss  xmm0, xmm2, xmm1
                vcomiss xmm0, cs:__real@3a83126f
              }
              if ( v45 )
              {
                __asm
                {
                  vmovss  xmm7, dword ptr [r14+6944h]
                  vmovss  xmm8, dword ptr [r14+6948h]
                  vmovss  xmm9, dword ptr [r14+694Ch]
                }
              }
              else
              {
                __asm
                {
                  vsqrtss xmm1, xmm0, xmm0
                  vcmpless xmm0, xmm1, cs:__real@80000000
                  vblendvps xmm1, xmm1, xmm6, xmm0
                  vdivss  xmm0, xmm6, xmm1
                  vmulss  xmm7, xmm3, xmm0
                  vmulss  xmm8, xmm4, xmm0
                  vmulss  xmm9, xmm5, xmm0
                }
              }
              *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_cg_adjustClientImpactSoundDistance, "cg_adjustClientImpactSoundDistance");
              __asm
              {
                vmulss  xmm1, xmm0, xmm7
                vaddss  xmm2, xmm1, dword ptr [rsp+120h+outOrg]
                vmovss  [rbp+3Fh+var_A8], xmm2
                vmulss  xmm3, xmm0, xmm8
                vaddss  xmm1, xmm3, dword ptr [rsp+120h+outOrg+4]
                vmovss  [rbp+3Fh+var_A4], xmm1
                vmulss  xmm0, xmm9, xmm0
                vaddss  xmm2, xmm0, dword ptr [rsp+120h+outOrg+8]
                vmovss  [rbp+3Fh+var_A0], xmm2
              }
              memset(&outOrg, 0, sizeof(outOrg));
              memset(&outOrigin, 0, sizeof(outOrigin));
            }
          }
        }
      }
      SoundSystem = CgSoundSystem::GetSoundSystem(localClientNum);
      __asm
      {
        vmovss  [rsp+120h+var_F0], xmm6
        vmovss  dword ptr [rsp+120h+var_F8], xmm6
      }
      ((void (__fastcall *)(CgSoundSystem *, _QWORD, int *, SndAliasList *, int, int, int, _DWORD))SoundSystem->PlaySurfaceSound)(SoundSystem, clientNum, &v74, bulletExplodeSound, surfType, v66, v67, 0);
      break;
    default:
      break;
  }
  _R11 = &v78;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-18h]
    vmovaps xmm7, xmmword ptr [r11-28h]
    vmovaps xmm8, xmmword ptr [r11-38h]
    vmovaps xmm9, xmmword ptr [r11-48h]
  }
}

/*
==============
CgWeaponSystem::BulletScriptableImpact
==============
*/
void CgWeaponSystem::BulletScriptableImpact(CgWeaponSystem *this, const unsigned int inflictorEntNum, const unsigned int targetEntityNum, const Weapon *weapon, bool isAlternate, const meansOfDeath_t mod, const vec3_t *start, const vec3_t *hitPos, const scr_string_t hitPartName)
{
  centity_t *Entity; 
  unsigned int scriptableIndex; 

  if ( targetEntityNum < 0x7FE )
  {
    Entity = CG_GetEntity((const LocalClientNum_t)this->m_localClientNum, targetEntityNum);
    if ( (Entity->flags & 1) != 0 && ScriptableCl_GetIndexForEntity((const LocalClientNum_t)this->m_localClientNum, Entity, &scriptableIndex) )
      ScriptableCl_EntityBulletHitEvent((const LocalClientNum_t)this->m_localClientNum, scriptableIndex, inflictorEntNum, start, hitPos, mod, weapon, isAlternate, hitPartName);
  }
}

/*
==============
CgWeaponSystem::BulletWhizbySound
==============
*/
void CgWeaponSystem::BulletWhizbySound(CgWeaponSystem *this, const Weapon *weapon, bool isAlternate, const vec3_t *start, const vec3_t *end)
{
  LocalClientNum_t m_localClientNum; 
  CgSoundSystem *SoundSystem; 
  _BOOL8 v10; 
  bool v11; 
  char v12; 
  __int64 v13; 

  m_localClientNum = this->m_localClientNum;
  v13 = 0i64;
  SoundSystem = CgSoundSystem::GetSoundSystem(m_localClientNum);
  LOBYTE(v10) = 1;
  v11 = isAlternate;
  SoundSystem->PlayWhizbyAndImpactSfx(SoundSystem, (const CgSfxImpactInfo *)&v12, v10, 2046, start, start, end, -1, weapon, v11, -1, SND_HITMARKER_TYPE_STANDARD);
}

/*
==============
CG_ActionSlotDown
==============
*/
void CG_ActionSlotDown(LocalClientNum_t localClientNum, int slot)
{
  __int64 v2; 
  __int64 v3; 
  cg_t *LocalClientGlobals; 
  const playerState_s *p_predictedPlayerState; 
  CgWeaponMap *v6; 
  ActionSlotType *v7; 
  cg_t *v8; 
  const Weapon *v9; 
  bool v10; 
  const Weapon *CurrentWeaponForPlayer; 
  const Weapon *Weapon; 
  const PlayerEquippedWeaponState *EquippedWeaponState; 
  const Weapon *p_weaponLatestPrimary; 
  __int64 forceWrapAround; 
  __int64 v16; 

  v2 = localClientNum;
  v3 = slot;
  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_ui_active_client.h", 158, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, 2) )
    __debugbreak();
  if ( (clientUIActives[v2].frontEndSceneState[0] || !clientUIActives[v2].cgameInitialized) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18187, ASSERT_TYPE_ASSERT, "(CL_IsGameClientActive( localClientNum ))", (const char *)&queryFormat, "CL_IsGameClientActive( localClientNum )") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v2);
  p_predictedPlayerState = &LocalClientGlobals->predictedPlayerState;
  if ( !CgWeaponMap::ms_instance[v2] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v6 = CgWeaponMap::ms_instance[v2];
  if ( CG_Weapons_ActionSlotUsageAllowed(LocalClientGlobals, v3) )
  {
    v7 = &p_predictedPlayerState->actionSlotType[v3];
    if ( *v7 == ACTIONSLOTTYPE_SPECIFYWEAPON )
    {
      CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(v6, p_predictedPlayerState);
      if ( !v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1026, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
        __debugbreak();
      if ( LocalClientGlobals == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1027, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
        __debugbreak();
      if ( (unsigned int)v3 >= 7 )
      {
        LODWORD(v16) = 7;
        LODWORD(forceWrapAround) = v3;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1028, ASSERT_TYPE_ASSERT, "(unsigned)( actionSlotIndex ) < (unsigned)( 7 )", "actionSlotIndex doesn't index ACTIONSLOTS_COUNT_STATIC\n\t%i not in [0, %i)", forceWrapAround, v16) )
          __debugbreak();
      }
      if ( !BG_ActionSlotIsWeaponType(p_predictedPlayerState, v3) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1029, ASSERT_TYPE_ASSERT, "(BG_ActionSlotIsWeaponType( ps, actionSlotIndex ))", (const char *)&queryFormat, "BG_ActionSlotIsWeaponType( ps, actionSlotIndex )") )
        __debugbreak();
      Weapon = BgWeaponMap::GetWeapon(v6, p_predictedPlayerState->actionSlotParam[v3].specifyWeapon.weaponHandle);
      if ( BG_WeaponDef(CurrentWeaponForPlayer, 0)->inventoryType != WEAPINVENTORY_EXCLUSIVE )
      {
        if ( !memcmp_0(Weapon, &LocalClientGlobals->weaponSelect, 0x3Cui64) )
        {
          if ( !memcmp_0(Weapon, &LocalClientGlobals->weaponLatestPrimary, 0x3Cui64) || !BG_PlayerHasWeapon(v6, p_predictedPlayerState, &LocalClientGlobals->weaponLatestPrimary) )
          {
            v10 = CycleWeapPrimary((LocalClientNum_t)v2, 0, 1, 0, 0, 0);
            goto LABEL_54;
          }
          EquippedWeaponState = BG_GetEquippedWeaponState(v6, p_predictedPlayerState, &LocalClientGlobals->weaponLatestPrimary);
          if ( EquippedWeaponState )
            LOBYTE(EquippedWeaponState) = EquippedWeaponState->inAltMode;
          p_weaponLatestPrimary = &LocalClientGlobals->weaponLatestPrimary;
        }
        else
        {
          if ( !BG_PlayerHasWeapon(v6, p_predictedPlayerState, Weapon) || !memcmp_0(CurrentWeaponForPlayer, Weapon, 0x3Cui64) )
            return;
          EquippedWeaponState = BG_GetEquippedWeaponState(v6, p_predictedPlayerState, Weapon);
          if ( EquippedWeaponState )
            LOBYTE(EquippedWeaponState) = EquippedWeaponState->inAltMode;
          p_weaponLatestPrimary = Weapon;
        }
        CG_SelectWeapon((LocalClientNum_t)v2, p_weaponLatestPrimary, (unsigned __int8)EquippedWeaponState);
LABEL_62:
        if ( Com_GameMode_SupportsFeature(WEAPON_SCOPE_TOGGLE_OFF|WEAPON_LADDER_AIM) && BG_IsTurretActive(p_predictedPlayerState) && *v7 == ACTIONSLOTTYPE_SPECIFYWEAPON )
          LocalClientGlobals->extraButtons |= 0x20ui64;
      }
    }
    else
    {
      if ( *v7 != ACTIONSLOTTYPE_ALTWEAPONTOGGLE )
      {
        if ( *v7 == ACTIONSLOTTYPE_NIGHTVISION )
        {
          if ( !CL_Input_IsGamepadEnabled((LocalClientNum_t)v2) )
            return;
          LocalClientGlobals->extraButtons |= 0x10000ui64;
        }
        else
        {
          if ( *v7 != ACTIONSLOTTYPE_TAUNT )
            return;
          LocalClientGlobals->extraButtons |= 0x80000000ui64;
        }
        goto LABEL_62;
      }
      if ( CL_Input_IsGamepadEnabled((LocalClientNum_t)v2) && !CG_IsWeaponInspectOnAltToggle((LocalClientNum_t)v2) && Dvar_GetBool_Internal_DebugName(DVARBOOL_bg_underbarrelWeaponEnabled, "bg_underbarrelWeaponEnabled") )
      {
        v8 = CG_GetLocalClientGlobals((const LocalClientNum_t)v2);
        if ( !CgWeaponMap::ms_instance[v2] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
          __debugbreak();
        v9 = BG_GetCurrentWeaponForPlayer(CgWeaponMap::ms_instance[v2], &v8->predictedPlayerState);
        if ( !BG_IsThrowingAxe(v9) && BG_HasUnderbarrelAmmo(v9) && !BG_UseLeftTriggerAltFireMode(v9) )
        {
          if ( BG_OffhandIsUnderbarrelWeapon(v6, p_predictedPlayerState, 0x3000ui64) )
          {
            if ( !Com_GameMode_SupportsFeature(WEAPON_INSPECT|WEAPON_LADDER_AIM) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18236, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::WEAPON_OFFHAND_UNDERBARREL ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::WEAPON_OFFHAND_UNDERBARREL )") )
              __debugbreak();
            return;
          }
          v10 = CG_Weapons_ToggleWeaponAltMode((LocalClientNum_t)v2);
LABEL_54:
          if ( !v10 )
            return;
          goto LABEL_62;
        }
      }
    }
  }
}

/*
==============
CG_ActionSlotUp
==============
*/
void CG_ActionSlotUp(LocalClientNum_t localClientNum, int slot, bool mustRelease)
{
  __int64 v3; 
  __int64 v5; 
  const cg_t *LocalClientGlobals; 

  v3 = localClientNum;
  v5 = slot;
  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_ui_active_client.h", 158, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, 2) )
    __debugbreak();
  if ( (clientUIActives[v3].frontEndSceneState[0] || !clientUIActives[v3].cgameInitialized) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18314, ASSERT_TYPE_ASSERT, "(CL_IsGameClientActive( localClientNum ))", (const char *)&queryFormat, "CL_IsGameClientActive( localClientNum )") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v3);
  if ( CG_Weapons_ActionSlotUsageAllowed(LocalClientGlobals, v5) && LocalClientGlobals->predictedPlayerState.actionSlotType[v5] == ACTIONSLOTTYPE_ALTWEAPONTOGGLE && CG_IsWeaponInspectOnAltToggle((LocalClientNum_t)v3) && !mustRelease )
    CG_Weapons_ToggleWeaponAltMode((LocalClientNum_t)v3);
}

/*
==============
CG_AddPlayerExecutionProp
==============
*/
void CG_AddPlayerExecutionProp(LocalClientNum_t localClientNum, centity_t *cent)
{
  const BgWeaponMap **v4; 
  cg_t *LocalClientGlobals; 
  unsigned int number; 
  const cg_t *v7; 
  const characterInfo_t *CharacterInfo; 
  Weapon *p_dobjExecutionWeapon; 
  CgWeaponSystem *WeaponSystem; 

  v4 = (const BgWeaponMap **)&CgWeaponMap::ms_instance[localClientNum];
  if ( !*v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  if ( !BG_GetWeaponForEntity(*v4, &cent->nextState)->weaponIdx )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    number = cent->nextState.number;
    v7 = LocalClientGlobals;
    if ( LocalClientGlobals->HasCharacterInfo(LocalClientGlobals, number) )
    {
      CharacterInfo = CG_GetCharacterInfo(v7, number);
      if ( CharacterInfo )
      {
        p_dobjExecutionWeapon = &CharacterInfo->dobjExecutionWeapon;
        if ( CharacterInfo->dobjExecutionWeapon.weaponIdx )
        {
          WeaponSystem = CgWeaponSystem::GetWeaponSystem(localClientNum);
          WeaponSystem->AddWeaponLaserForCharacter(WeaponSystem, p_dobjExecutionWeapon, cent);
          WeaponSystem->UpdateMuzzleFlash(WeaponSystem, cent, p_dobjExecutionWeapon, 0, 0, 1, NULL);
        }
      }
    }
  }
}

/*
==============
CG_AddPlayerWeapon
==============
*/
void CG_AddPlayerWeapon(LocalClientNum_t localClientNum, const vec3_t *weapOrigin, const vec4_t *weapOrient, const playerState_s *ps, const vec3_t *localPlayerGunAngles, centity_t *cent, int bDrawGun, const CgEventLodData *optionalEventLodData)
{
  __int64 v21; 
  BgWeaponMap *v24; 
  bool inAltWeaponMode; 
  const dvar_t *v30; 
  const dvar_t *v31; 
  unsigned int v32; 
  const dvar_t *v33; 
  const dvar_t *v34; 
  CgViewSystem *ViewSystem; 
  char v51; 
  int WeaponHandForViewWeapon; 
  unsigned int v87; 
  PlayerHandIndex v88; 
  WeaponHand *ViewModelHand; 
  cg_t *LocalClientGlobals; 
  __int64 v93; 
  vec3_t *p_inOrigin; 
  bool v102; 
  bool v103; 
  void (__fastcall *v109)(const vec3_t *, vec4_t *); 
  __int64 v112; 
  void (__fastcall *v123)(const vec4_t *, vec3_t *); 
  int v131; 
  CgHandler *Handler; 
  PlayerHandIndex v137; 
  const DObj **v138; 
  cg_t *v140; 
  __int64 v141; 
  const dvar_t *v142; 
  CgMLGSpectator *MLGSpectator; 
  const characterInfo_t *CharacterInfo; 
  CgGlobalsMP *v154; 
  CgStatic *LocalClientStatics; 
  int v156; 
  const HudOutlineDef *HudOutlineDef; 
  int outlineWidth; 
  centity_t *v159; 
  CgGlobalsMP *v164; 
  int clientNum; 
  unsigned int v168; 
  BgWeaponMap *v169; 
  const Weapon *OffhandGestureWeapon; 
  CgHandler *v172; 
  const DObj *v173; 
  unsigned int v174; 
  void (__fastcall **p_FunctionPointer_prevOrigin)(const vec4_t *, vec3_t *); 
  CgHandler *v185; 
  const DObj *v194; 
  unsigned int v195; 
  scr_string_t *v196; 
  CgHandler *v197; 
  const WeaponHeat *v198; 
  cpose_t *v201; 
  bool v202; 
  int pm_type; 
  CgWeaponSystem *v204; 
  __int64 weaponIdx; 
  char v214; 
  CgHandler *v217; 
  cpose_t *p_viewModelPose; 
  scr_string_t tag_attachment_focus; 
  const DObj **p_viewModelDObj; 
  __int64 v247; 
  CgWeaponSystem *v248; 
  centity_t *v249; 
  int v250; 
  float fmt; 
  float fmta; 
  float fmtb; 
  BgHybridScopeFraction *hybridScopeFraction; 
  BgHybridScopeFraction *hybridScopeFractiona; 
  GfxScopeInfo *settingOut; 
  GfxScopeInfo *settingOuta; 
  Weapon *weapon; 
  double isAlternate; 
  float isAlternatea; 
  double v271; 
  bool v272; 
  unsigned int outRenderFlags; 
  __int64 v274; 
  centity_t *v275; 
  vec3_t pose; 
  StreamImageMip streamMip; 
  int v278; 
  vec3_t outOrigin; 
  vec3_t inOrigin; 
  BgWeaponMap *weaponMap; 
  vec3_t v282; 
  float characterEVOffset; 
  CgWeaponSystem *WeaponSystem; 
  const playerState_s *v285; 
  CgViewSystem *laserInfo; 
  const WeaponDef *v287; 
  void (__fastcall *FunctionPointer_prevOrigin)(const vec4_t *, vec3_t *); 
  __m256i v289; 
  int bViewModel; 
  vec3_t *v291; 
  const CgEventLodData *v292; 
  __int64 v293; 
  GfxSceneHudOutlineInfo v294; 
  shaderOverride_t v295; 
  char v296[172]; 
  char v297; 
  char v298; 
  char v301; 
  float dofPhysicalFocusDistance; 
  vec3_t functionPointer; 
  vec3_t right; 
  vec3_t outlinedEntityOrigin; 
  vec3_t vec; 
  vec3_t playerViewOrigin; 
  Weapon r_weapon; 
  tmat33_t<vec3_t> axis; 
  vec3_t outOrg; 
  __m256i v312; 
  float v313; 
  GfxScopeInfo scope; 
  WorldUpReferenceFrame v315; 
  int v316[6]; 
  char v317; 
  void *retaddr; 

  _RAX = &retaddr;
  v293 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-58h], xmm6
    vmovaps xmmword ptr [rax-68h], xmm7
    vmovaps xmmword ptr [rax-78h], xmm8
    vmovaps xmmword ptr [rax-88h], xmm9
    vmovaps xmmword ptr [rax-98h], xmm10
    vmovaps xmmword ptr [rax-0A8h], xmm11
    vmovaps xmmword ptr [rax-0B8h], xmm12
    vmovaps xmmword ptr [rax-0C8h], xmm13
    vmovaps xmmword ptr [rax-0D8h], xmm14
  }
  _R14 = ps;
  v285 = ps;
  _RBX = weapOrient;
  v21 = localClientNum;
  LODWORD(v274) = localClientNum;
  v291 = (vec3_t *)localPlayerGunAngles;
  v275 = cent;
  v292 = optionalEventLodData;
  if ( ps && !localPlayerGunAngles && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 15059, ASSERT_TYPE_ASSERT, "(!ps || localPlayerGunAngles)", (const char *)&queryFormat, "!ps || localPlayerGunAngles") )
    __debugbreak();
  __asm
  {
    vmovups ymm0, ymmword ptr cs:NULL_HUDOUTLINE_INFO_7.color
    vmovups ymmword ptr [rbp+450h+var_458], ymm0
  }
  characterEVOffset = NULL_HUDOUTLINE_INFO_7.characterEVOffset;
  _R15 = CG_GetLocalClientGlobals((const LocalClientNum_t)v21);
  if ( !CgWeaponMap::ms_instance[v21] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  weaponMap = CgWeaponMap::ms_instance[v21];
  bViewModel = _R14 != NULL;
  if ( cent == (centity_t *)-400i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2088, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
    __debugbreak();
  if ( BG_IsTurretActiveFlags(&cent->nextState.lerp.eFlags) )
    goto LABEL_207;
  if ( cent == (centity_t *)-400i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2032, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
    __debugbreak();
  if ( GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&cent->nextState.lerp.eFlags, ACTIVE, 0xBu) )
  {
LABEL_207:
    if ( !_R14 )
      goto LABEL_202;
    v24 = weaponMap;
    if ( !BG_IsUsingTurretViewarms(weaponMap, _R14) )
      goto LABEL_202;
  }
  else
  {
    v24 = weaponMap;
  }
  if ( _R14 || CG_MainMP_IsPrematchCountdown((const LocalClientNum_t)v21) )
  {
    streamMip = 4 - CL_TransientsWorldMP_UseLowAlwaysloadedFlagging();
    if ( _R14 )
    {
      _RAX = BG_GetViewmodelWeapon(v24, _R14);
      goto LABEL_26;
    }
  }
  else
  {
    streamMip = !CL_TransientsWorldMP_UseLowAlwaysloadedFlagging();
  }
  _RAX = BG_GetWeaponForEntity(weaponMap, &cent->nextState);
LABEL_26:
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovups ymmword ptr [rbp+450h+r_weapon.weaponIdx], ymm0
    vmovups xmm1, xmmword ptr [rax+20h]
    vmovups xmmword ptr [rbp+450h+r_weapon.attachmentVariationIndices+5], xmm1
    vmovsd  xmm0, qword ptr [rax+30h]
    vmovsd  qword ptr [rbp+450h+r_weapon.attachmentVariationIndices+15h], xmm0
  }
  *(_DWORD *)&r_weapon.weaponCamo = *(_DWORD *)&_RAX->weaponCamo;
  if ( _R14 )
    inAltWeaponMode = BG_UsingAlternate(_R14);
  else
    inAltWeaponMode = v275->nextState.inAltWeaponMode;
  v272 = inAltWeaponMode;
  if ( r_weapon.weaponIdx )
  {
    WeaponSystem = CgWeaponSystem::GetWeaponSystem((const LocalClientNum_t)v21);
    v287 = BG_WeaponDef(&r_weapon, inAltWeaponMode);
    if ( !v287 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 15109, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
      __debugbreak();
    outRenderFlags = 1033;
    v30 = DVARBOOL_depthSortViewmodel;
    if ( !DVARBOOL_depthSortViewmodel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "depthSortViewmodel") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v30);
    if ( v30->current.enabled )
      outRenderFlags &= ~1u;
    v31 = DVARBOOL_viewModelHacks;
    if ( !DVARBOOL_viewModelHacks && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "viewModelHacks") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v31);
    v32 = outRenderFlags;
    if ( !v31->current.enabled )
      v32 = 0;
    outRenderFlags = v32;
    v33 = DCONST_DVARBOOL_duckedRotationPivotDebug;
    if ( !DCONST_DVARBOOL_duckedRotationPivotDebug && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "duckedRotationPivotDebug") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v33);
    if ( v33->current.enabled )
      outRenderFlags &= ~1u;
    v34 = DCONST_DVARBOOL_advancedSwayDebug;
    if ( !DCONST_DVARBOOL_advancedSwayDebug && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "advancedSwayDebug") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v34);
    if ( v34->current.enabled )
      outRenderFlags &= ~1u;
    if ( !_R14 )
    {
      v131 = bDrawGun;
      if ( bDrawGun )
      {
        v248 = WeaponSystem;
        v249 = v275;
        WeaponSystem->AddWeaponLaserForCharacter(WeaponSystem, &r_weapon, v275);
        goto LABEL_201;
      }
LABEL_200:
      v248 = WeaponSystem;
      v249 = v275;
LABEL_201:
      v250 = bViewModel;
      CgWeaponSystem::ChargedWeaponUpdate(v248, _R14, v249, &r_weapon, v272, bViewModel, v131);
      v248->UpdateMuzzleFlash(v248, v249, &r_weapon, v272, v250, v131, v292);
      CG_PlayContinuousFireSounds((const LocalClientNum_t)v21, _R14, v249);
      CG_PlayADSSounds((const LocalClientNum_t)v21, &r_weapon, v272, _R14, v249);
      goto LABEL_202;
    }
    ViewSystem = CgViewSystem::GetViewSystem((const LocalClientNum_t)v21);
    laserInfo = ViewSystem;
    if ( !ViewSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 15140, ASSERT_TYPE_ASSERT, "(view)", (const char *)&queryFormat, "view") )
      __debugbreak();
    ViewSystem->CalcLinkedToPlayerViewTags(ViewSystem, VM_PRE_MOTION);
    __asm
    {
      vxorps  xmm13, xmm13, xmm13
      vmovss  dword ptr [rbp+450h+right], xmm13
      vmovss  dword ptr [rbp+450h+right+4], xmm13
      vmovss  dword ptr [rbp+450h+right+8], xmm13
      vmovss  dword ptr [rbp+450h+outOrigin], xmm13
      vmovss  dword ptr [rbp+450h+outOrigin+4], xmm13
      vmovss  dword ptr [rbp+450h+outOrigin+8], xmm13
      vmovss  xmm4, dword ptr [rbx+4]
      vmovss  xmm5, dword ptr [rbx]
      vmovss  xmm6, dword ptr [rbx+8]
      vmovss  xmm7, dword ptr [rbx+0Ch]
      vmulss  xmm1, xmm5, xmm5
      vmulss  xmm0, xmm4, xmm4
      vaddss  xmm2, xmm1, xmm0
      vmulss  xmm1, xmm6, xmm6
      vaddss  xmm3, xmm2, xmm1
      vmulss  xmm0, xmm7, xmm7
      vaddss  xmm2, xmm3, xmm0
      vmovss  xmm14, cs:__real@3f800000
      vsubss  xmm1, xmm2, xmm14
      vandps  xmm1, xmm1, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
      vcomiss xmm1, cs:__real@3b03126f
    }
    if ( !v51 )
    {
      __asm
      {
        vsqrtss xmm0, xmm2, xmm2
        vcvtss2sd xmm1, xmm0, xmm0
        vcvtss2sd xmm2, xmm7, xmm7
        vcvtss2sd xmm3, xmm6, xmm6
        vcvtss2sd xmm0, xmm4, xmm4
        vcvtss2sd xmm4, xmm5, xmm5
        vmovsd  [rsp+550h+var_508], xmm1
        vmovsd  qword ptr [rsp+550h+isAlternate], xmm2
        vmovsd  [rsp+550h+weapon], xmm3
        vmovsd  [rsp+550h+settingOut], xmm0
        vmovsd  [rsp+550h+hybridScopeFraction], xmm4
      }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_math.h", 770, ASSERT_TYPE_ASSERT, "( Vec4IsNormalized( quat ) )", "(%g, %g, %g, %g) len: %g", *(double *)&hybridScopeFractiona, *(double *)&settingOuta, *(double *)&weapon, isAlternate, v271) )
        __debugbreak();
    }
    __asm
    {
      vmovss  xmm5, cs:__real@40000000
      vmulss  xmm1, xmm5, dword ptr [rbx]
      vmulss  xmm12, xmm1, dword ptr [rbx]
      vmovss  xmm2, dword ptr [rbx+4]
      vmulss  xmm6, xmm1, xmm2
      vmovss  xmm4, dword ptr [rbx+8]
      vmulss  xmm9, xmm1, xmm4
      vmovss  xmm3, dword ptr [rbx+0Ch]
      vmulss  xmm10, xmm1, xmm3
      vmulss  xmm0, xmm2, xmm5
      vmulss  xmm11, xmm0, xmm2
      vmulss  xmm8, xmm0, xmm4
      vmulss  xmm7, xmm0, xmm3
      vmulss  xmm0, xmm4, xmm5
      vmulss  xmm2, xmm0, xmm3
      vmulss  xmm5, xmm0, xmm4
      vaddss  xmm1, xmm5, xmm11
      vsubss  xmm0, xmm14, xmm1
      vmovss  dword ptr [rbp+450h+axis], xmm0
      vaddss  xmm1, xmm2, xmm6
      vmovss  dword ptr [rbp+450h+axis+4], xmm1
      vsubss  xmm0, xmm9, xmm7
      vmovss  dword ptr [rbp+450h+axis+8], xmm0
      vsubss  xmm1, xmm6, xmm2
      vmovss  dword ptr [rbp+450h+axis+0Ch], xmm1
      vaddss  xmm0, xmm5, xmm12
      vsubss  xmm0, xmm14, xmm0
      vmovss  dword ptr [rbp+450h+axis+10h], xmm0
      vaddss  xmm1, xmm8, xmm10
      vmovss  dword ptr [rbp+450h+axis+14h], xmm1
      vaddss  xmm0, xmm7, xmm9
      vmovss  dword ptr [rbp+450h+axis+18h], xmm0
      vsubss  xmm1, xmm8, xmm10
      vmovss  dword ptr [rbp+450h+axis+1Ch], xmm1
      vaddss  xmm0, xmm11, xmm12
      vsubss  xmm0, xmm14, xmm0
      vmovss  dword ptr [rbp+450h+axis+20h], xmm0
    }
    cg_t::SetViewModelTransform(_R15, &axis, weapOrigin);
    WeaponHandForViewWeapon = BG_PlayerLastWeaponHandForViewWeapon(weaponMap, _R14);
    v278 = WeaponHandForViewWeapon;
    v87 = 0;
    v88 = WEAPON_HAND_DEFAULT;
    if ( WeaponHandForViewWeapon >= 0 )
    {
      __asm { vmovss  xmm8, cs:__real@bfd9999a }
      _R12 = v287;
      while ( 1 )
      {
        ViewModelHand = cg_t::GetViewModelHand(_R15, v88);
        if ( !ViewModelHand->viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 15157, ASSERT_TYPE_ASSERT, "(weapHand->viewModelDObj)", (const char *)&queryFormat, "weapHand->viewModelDObj") )
          __debugbreak();
        CG_UpdateViewModelPoseForHand(ViewModelHand->viewModelDObj, (LocalClientNum_t)v21, v88, 1);
        CG_Ladder_ResetHandInterpolation((LocalClientNum_t)v21, _R14, v88);
        if ( BG_HasLadderHand(_R14) )
        {
          LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v21);
          v93 = 303328i64;
          if ( v88 )
            v93 = 303616i64;
          CG_Ladder_InterpolateHand((LocalClientNum_t)v21, _R14, v88, (cpose_t *)((char *)LocalClientGlobals + v93));
          goto LABEL_87;
        }
        if ( v88 )
          break;
        if ( BG_PlayerDualWieldingWeapon(weaponMap, _R14, &r_weapon) )
        {
          CG_GetPoseOrigin(&_R15->viewModelPose, &outOrigin);
          AngleVectors(&_R14->viewangles, NULL, &right, NULL);
          __asm
          {
            vmovss  xmm3, dword ptr [r12+6A0h]
            vmulss  xmm1, xmm3, dword ptr [rbp+450h+right]
            vaddss  xmm2, xmm1, dword ptr [rbp+450h+outOrigin]
            vmovss  dword ptr [rbp+450h+inOrigin], xmm2
            vmulss  xmm1, xmm3, dword ptr [rbp+450h+right+4]
            vaddss  xmm2, xmm1, dword ptr [rbp+450h+outOrigin+4]
            vmovss  dword ptr [rbp+450h+inOrigin+4], xmm2
            vmulss  xmm1, xmm3, dword ptr [rbp+450h+right+8]
            vaddss  xmm2, xmm1, dword ptr [rbp+450h+outOrigin+8]
            vmovss  dword ptr [rbp+450h+inOrigin+8], xmm2
          }
          CG_SetPoseOrigin(&_R15->viewModelPose, &inOrigin);
          p_inOrigin = &inOrigin;
LABEL_86:
          memset(p_inOrigin, 0, sizeof(vec3_t));
        }
LABEL_87:
        if ( ++v88 > WeaponHandForViewWeapon )
        {
          ViewSystem = laserInfo;
          v87 = 0;
          goto LABEL_89;
        }
      }
      v102 = v88 == WEAPON_HAND_LEFT;
      if ( v88 != WEAPON_HAND_LEFT )
      {
        v103 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 15183, ASSERT_TYPE_ASSERT, "(hand == WEAPON_HAND_LEFT)", (const char *)&queryFormat, "hand == WEAPON_HAND_LEFT");
        v102 = !v103;
        if ( v103 )
          __debugbreak();
      }
      __asm
      {
        vmovss  xmm0, dword ptr [rbp+450h+right]
        vucomiss xmm0, dword ptr cs:?vec3_origin@@3Tvec3_t@@B; vec3_t const vec3_origin
      }
      if ( v102 )
      {
        __asm
        {
          vmovss  xmm0, dword ptr [rbp+450h+right+4]
          vucomiss xmm0, dword ptr cs:?vec3_origin@@3Tvec3_t@@B+4; vec3_t const vec3_origin
        }
        if ( v102 )
        {
          __asm
          {
            vmovss  xmm0, dword ptr [rbp+450h+right+8]
            vucomiss xmm0, dword ptr cs:?vec3_origin@@3Tvec3_t@@B+8; vec3_t const vec3_origin
          }
          if ( v102 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 15184, ASSERT_TYPE_ASSERT, "(!Vec3Compare( vRight, vec3_origin ))", (const char *)&queryFormat, "!Vec3Compare( vRight, vec3_origin )") )
            __debugbreak();
        }
      }
      __asm
      {
        vmovups xmm6, xmmword ptr [r15+4A284h]
        vmovsd  xmm7, qword ptr [r15+4A294h]
      }
      v109 = ObfuscateSetFunctionPointer_origin(_R15->viewModelPoseLeftHand.origin.Set_origin, &_R15->viewModelPoseLeftHand);
      *(_QWORD *)functionPointer.v = ObfuscateGetFunctionPointer_origin(_R15->viewModelPoseLeftHand.origin.Get_origin, &_R15->viewModelPoseLeftHand);
      *(_QWORD *)pose.v = ObfuscateSetFunctionPointer_prevOrigin(_R15->viewModelPoseLeftHand.prevOrigin.Set_prevOrigin, &_R15->viewModelPoseLeftHand);
      FunctionPointer_prevOrigin = ObfuscateGetFunctionPointer_prevOrigin(_R15->viewModelPoseLeftHand.prevOrigin.Get_prevOrigin, &_R15->viewModelPoseLeftHand);
      _RCX = &_R15->viewModelPoseLeftHand;
      _RDX = &_R15->viewModelPose;
      v112 = 2i64;
      do
      {
        __asm
        {
          vmovups xmm0, xmmword ptr [rdx]
          vmovups xmmword ptr [rcx], xmm0
          vmovups xmm1, xmmword ptr [rdx+10h]
          vmovups xmmword ptr [rcx+10h], xmm1
          vmovups xmm0, xmmword ptr [rdx+20h]
          vmovups xmmword ptr [rcx+20h], xmm0
          vmovups xmm1, xmmword ptr [rdx+30h]
          vmovups xmmword ptr [rcx+30h], xmm1
          vmovups xmm0, xmmword ptr [rdx+40h]
          vmovups xmmword ptr [rcx+40h], xmm0
          vmovups xmm1, xmmword ptr [rdx+50h]
          vmovups xmmword ptr [rcx+50h], xmm1
          vmovups xmm0, xmmword ptr [rdx+60h]
          vmovups xmmword ptr [rcx+60h], xmm0
        }
        _RCX = (cpose_t *)((char *)_RCX + 128);
        __asm
        {
          vmovups xmm1, xmmword ptr [rdx+70h]
          vmovups xmmword ptr [rcx-10h], xmm1
        }
        _RDX = (cpose_t *)((char *)_RDX + 128);
        --v112;
      }
      while ( v112 );
      __asm
      {
        vmovups xmm0, xmmword ptr [rdx]
        vmovups xmmword ptr [rcx], xmm0
        vmovups xmm1, xmmword ptr [rdx+10h]
        vmovups xmmword ptr [rcx+10h], xmm1
      }
      _R15->viewModelPoseLeftHand.origin.Set_origin = NULL;
      _R15->viewModelPoseLeftHand.origin.Get_origin = NULL;
      _R15->viewModelPoseLeftHand.prevOrigin.Set_prevOrigin = NULL;
      _R15->viewModelPoseLeftHand.prevOrigin.Get_prevOrigin = NULL;
      _R15->viewModelPoseLeftHand.origin.Set_origin = ObfuscateSetFunctionPointer_origin(v109, &_R15->viewModelPoseLeftHand);
      _R15->viewModelPoseLeftHand.origin.Get_origin = ObfuscateGetFunctionPointer_origin(*(void (__fastcall *const *)(const vec4_t *, vec3_t *))functionPointer.v, &_R15->viewModelPoseLeftHand);
      _R15->viewModelPoseLeftHand.prevOrigin.Set_prevOrigin = ObfuscateSetFunctionPointer_prevOrigin(*(void (__fastcall *const *)(const vec3_t *, vec4_t *))pose.v, &_R15->viewModelPoseLeftHand);
      _R15->viewModelPoseLeftHand.prevOrigin.Get_prevOrigin = ObfuscateGetFunctionPointer_prevOrigin(FunctionPointer_prevOrigin, &_R15->viewModelPoseLeftHand);
      CG_GetPoseOrigin(&_R15->viewModelPose, &v282);
      CG_SetPoseOrigin(&_R15->viewModelPoseLeftHand, &v282);
      if ( _R15->viewModelPose.prevOrigin.Get_prevOrigin == (void (__fastcall *)(const vec4_t *, vec3_t *))(unsigned __int8)v112 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_pose.h", 568, ASSERT_TYPE_ASSERT, "(pose->prevOrigin.Get_prevOrigin)", (const char *)&queryFormat, "pose->prevOrigin.Get_prevOrigin") )
        __debugbreak();
      v123 = ObfuscateGetFunctionPointer_prevOrigin(_R15->viewModelPose.prevOrigin.Get_prevOrigin, &_R15->viewModelPose);
      v123(&_R15->viewModelPose.prevOrigin.prevOrigin, &v282);
      CG_SetPrevPoseOrigin(&_R15->viewModelPoseLeftHand, &v282);
      memset(&v282, 0, sizeof(v282));
      __asm
      {
        vmovups xmmword ptr [r15+4A284h], xmm6
        vmovsd  qword ptr [r15+4A294h], xmm7
        vmulss  xmm3, xmm8, dword ptr [rax+6A0h]
        vmulss  xmm1, xmm3, dword ptr [rbp+450h+right]
        vaddss  xmm2, xmm1, dword ptr [rbp+450h+outOrigin]
        vmovss  dword ptr [rbp+450h+outlinedEntityOrigin], xmm2
        vmulss  xmm1, xmm3, dword ptr [rbp+450h+right+4]
        vaddss  xmm2, xmm1, dword ptr [rbp+450h+outOrigin+4]
        vmovss  dword ptr [rbp+450h+outlinedEntityOrigin+4], xmm2
        vmulss  xmm1, xmm3, dword ptr [rbp+450h+right+8]
        vaddss  xmm2, xmm1, dword ptr [rbp+450h+outOrigin+8]
        vmovss  dword ptr [rbp+450h+outlinedEntityOrigin+8], xmm2
      }
      CG_SetPoseOrigin(&_R15->viewModelPoseLeftHand, &outlinedEntityOrigin);
      p_inOrigin = &outlinedEntityOrigin;
      LODWORD(v21) = v274;
      WeaponHandForViewWeapon = v278;
      _R12 = v287;
      goto LABEL_86;
    }
LABEL_89:
    ViewSystem->CalcLinkedToPlayerViewTags(ViewSystem, VM_POST_MOTION);
    *(_QWORD *)functionPointer.v = WeaponHandForViewWeapon;
    v131 = bDrawGun;
    if ( !bDrawGun )
    {
      if ( WeaponHandForViewWeapon < 0i64 )
      {
LABEL_199:
        HoldBreathUpdate((LocalClientNum_t)v21);
        memset(&outOrigin, 0, sizeof(outOrigin));
        goto LABEL_200;
      }
      p_viewModelDObj = (const DObj **)&_R15->m_weaponHand[0].viewModelDObj;
      v247 = WeaponHandForViewWeapon + 1i64;
      do
      {
        if ( v87 >= 2 )
        {
          LODWORD(settingOut) = 2;
          LODWORD(hybridScopeFraction) = v87;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", hybridScopeFraction, settingOut) )
            __debugbreak();
        }
        if ( !*p_viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 15473, ASSERT_TYPE_ASSERT, "(weapHand->viewModelDObj)", (const char *)&queryFormat, "weapHand->viewModelDObj") )
          __debugbreak();
        Stream_TouchDObj(*p_viewModelDObj, streamMip);
        ++v87;
        p_viewModelDObj += 5;
        --v247;
      }
      while ( v247 );
      _R14 = v285;
      LODWORD(v21) = v274;
LABEL_198:
      v131 = bDrawGun;
      goto LABEL_199;
    }
    memset_0(v296, 0, 0xC4ui64);
    Handler = CgHandler::getHandler((LocalClientNum_t)v21);
    WorldUpReferenceFrame::WorldUpReferenceFrame(&v315, _R14, Handler);
    __asm
    {
      vmovss  xmm0, dword ptr [r14+30h]
      vmovss  dword ptr [rbp+450h+vec], xmm0
      vmovss  xmm1, dword ptr [r14+34h]
      vmovss  dword ptr [rbp+450h+vec+4], xmm1
      vmovss  xmm0, dword ptr [r14+38h]
      vmovss  dword ptr [rbp+450h+vec+8], xmm0
      vmovss  xmm1, dword ptr [r14+1E8h]; height
    }
    WorldUpReferenceFrame::AddUpContribution(&v315, *(float *)&_XMM1, &vec);
    v137 = WEAPON_HAND_DEFAULT;
    LODWORD(v274) = 0;
    if ( WeaponHandForViewWeapon >= 0i64 )
    {
      v285 = NULL;
      laserInfo = (CgViewSystem *)_R15->laserInfo;
      v138 = (const DObj **)&_R15->m_weaponHand[0].viewModelDObj;
      *(_QWORD *)v282.v = _R15->m_weaponHand;
      __asm { vmovss  xmm8, cs:__real@3fc00000 }
      while ( 1 )
      {
        if ( (unsigned int)v137 >= NUM_WEAPON_HANDS )
        {
          LODWORD(settingOut) = 2;
          LODWORD(hybridScopeFraction) = v137;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", hybridScopeFraction, settingOut) )
            __debugbreak();
        }
        if ( !*v138 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 15219, ASSERT_TYPE_ASSERT, "(weapHand->viewModelDObj)", (const char *)&queryFormat, "weapHand->viewModelDObj") )
          __debugbreak();
        v140 = CG_GetLocalClientGlobals((const LocalClientNum_t)v21);
        v141 = 303328i64;
        if ( v137 )
          v141 = 303616i64;
        *(_QWORD *)pose.v = (char *)v140 + v141;
        v278 = (v137 != WEAPON_HAND_DEFAULT) + 2048;
        v142 = DCONST_DVARBOOL_cg_defaultWeaponHidesViewmodel;
        if ( !DCONST_DVARBOOL_cg_defaultWeaponHidesViewmodel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_defaultWeaponHidesViewmodel") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v142);
        if ( v142->current.enabled && _R15->playerWeaponInfo.isWeaponDefault )
          goto LABEL_160;
        Stream_TouchDObj(*v138, streamMip);
        if ( GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&_R14->otherFlags, ACTIVE, 0x20u) )
        {
          _RAX = (__int64)_R15->nextSnap->GetPlayerState(_R15->nextSnap, (unsigned int)v21);
          _RDI = *(cpose_t **)pose.v;
          *(_DWORD *)(*(_QWORD *)pose.v + 72i64) = *(_DWORD *)(_RAX + 472);
          __asm
          {
            vmovss  xmm0, dword ptr [rax+1DCh]
            vmovss  dword ptr [rdi+4Ch], xmm0
            vmovss  xmm1, dword ptr [rax+1E0h]
            vmovss  dword ptr [rdi+50h], xmm1
            vmovss  xmm0, dword ptr [rax+30h]
            vmovss  dword ptr [rbp+450h+inOrigin], xmm0
            vmovss  xmm1, dword ptr [rax+34h]
            vmovss  dword ptr [rbp+450h+inOrigin+4], xmm1
            vmovss  xmm0, dword ptr [rax+38h]
            vmovss  dword ptr [rbp+450h+inOrigin+8], xmm0
            vaddss  xmm0, xmm0, dword ptr [rax+1E8h]
            vmovss  dword ptr [rbp+450h+inOrigin+8], xmm0
          }
          CG_SetPoseOrigin(_RDI, &inOrigin);
          memset(&inOrigin, 0, sizeof(inOrigin));
        }
        *(double *)&_XMM0 = ((double (__fastcall *)(CgWeaponSystem *))WeaponSystem->GetWeaponUVAnimOverride)(WeaponSystem);
        __asm { vmovaps xmm7, xmm0 }
        MLGSpectator = NULL;
        CharacterInfo = NULL;
        if ( MLG_IsCoDCasterEnabled() && cg_t::ms_allocatedType == GLOB_TYPE_MP )
        {
          v154 = CgGlobalsMP::GetLocalClientGlobals((const LocalClientNum_t)v21);
          if ( v154 )
          {
            if ( v154->m_isMLGSpectator )
            {
              MLGSpectator = CgMLGSpectator::GetMLGSpectator((const LocalClientNum_t)v21);
              LocalClientStatics = CgStatic::GetLocalClientStatics((const LocalClientNum_t)v21);
              CharacterInfo = CgStatic::GetCharacterInfo(LocalClientStatics, v275->nextState.clientNum);
            }
          }
        }
        if ( (*(_DWORD *)&_R14->outlineData.viewmodel & 0x3F) != 0 )
        {
          v156 = _R15->time - _R15->predictedPlayerState.deltaTime;
          HudOutlineDef = BG_GetHudOutlineDef(*(_DWORD *)&_R14->outlineData.viewmodel & 0x3F);
          __asm
          {
            vmovss  dword ptr [rbp+450h+outlinedEntityOrigin], xmm13
            vmovss  dword ptr [rbp+450h+outlinedEntityOrigin+4], xmm13
            vmovss  dword ptr [rbp+450h+outlinedEntityOrigin+8], xmm13
            vmovss  dword ptr [rbp+450h+playerViewOrigin], xmm13
            vmovss  dword ptr [rbp+450h+playerViewOrigin+4], xmm13
            vmovss  dword ptr [rbp+450h+playerViewOrigin+8], xmm13
          }
          v289.m256i_i32[0] = BG_HudOutline_GetColor(HudOutlineDef, _R15->hudOutlineStartTime, v156, &playerViewOrigin, &outlinedEntityOrigin);
          v289.m256i_i8[8] = HudOutlineDef->drawOccludedPixels;
          v289.m256i_i8[9] = HudOutlineDef->drawNonOccludedPixels;
          outlineWidth = HudOutlineDef->outlineWidth;
          if ( (outlineWidth < 0 || (unsigned int)outlineWidth > 0xFF) && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned char __cdecl truncate_cast_impl<unsigned char,int>(int)", "unsigned", (unsigned __int8)outlineWidth, "signed", outlineWidth) )
            __debugbreak();
          v289.m256i_i8[15] = outlineWidth;
          v289.m256i_i8[14] = HudOutlineDef->outlineType;
          v289.m256i_i8[10] = HudOutlineDef->drawFill;
        }
        else if ( MLGSpectator && CharacterInfo && CgMLGSpectator::GetOutlineViewmodel(MLGSpectator) )
        {
          v159 = v275;
          v275->currentHudOutlineIndex = 0;
          __asm
          {
            vmulss  xmm1, xmm8, dword ptr [r14+730h]
            vsubss  xmm0, xmm14, xmm1; val
            vmovaps xmm2, xmm14; max
            vmovaps xmm1, xmm13; min
          }
          *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
          __asm { vmovaps xmm6, xmm0 }
          v164 = CgGlobalsMP::GetLocalClientGlobals((const LocalClientNum_t)v21);
          clientNum = v159->nextState.clientNum;
          __asm { vmovss  dword ptr [rsp+550h+fmt], xmm6 }
          v289.m256i_i32[0] = CG_Utils_GetHudOutlineTeamColor(v164, (const LocalClientNum_t)v21, (const team_t)CharacterInfo->team, 1, fmt);
          if ( v289.m256i_i32[0] )
          {
            v289.m256i_i8[12] = 1;
            v289.m256i_i16[4] = 257;
            *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DVARFLT_r_hudOutlineWidth, "r_hudOutlineWidth");
            __asm { vcvttss2si eax, xmm0 }
            v289.m256i_i8[15] = _EAX;
            v289.m256i_i8[14] = 0;
            v289.m256i_i8[13] = CgMLGSpectator::IsClientSpecialActive(MLGSpectator, clientNum) != 0;
          }
          else
          {
            __asm
            {
              vmovups ymm0, ymmword ptr cs:NULL_HUDOUTLINE_INFO_7.color
              vmovups ymmword ptr [rbp+450h+var_458], ymm0
            }
            characterEVOffset = NULL_HUDOUTLINE_INFO_7.characterEVOffset;
          }
          v137 = (int)v274;
        }
        else if ( (*(_BYTE *)&_R14->outlineData.viewmodel & 0x3F) == 0 )
        {
          v275->currentHudOutlineIndex = 0;
        }
        v168 = outRenderFlags & 0xFFFFFBFF;
        outRenderFlags = v168;
        if ( (v168 & 1) != 0 && _R15->dualViewScope )
          outRenderFlags = v168 | 0x4000;
        _R15->GetShaderOverrideData(_R15, (shaderOverride_t *)&v312, _R14->clientNum, &r_weapon);
        if ( v285 == *(const playerState_s **)functionPointer.v )
        {
          v169 = weaponMap;
          if ( BG_IsUsingOffhandGestureWeaponADSSupport(weaponMap, _R14) )
            break;
        }
        if ( v137 == WEAPON_HAND_DEFAULT )
        {
          __asm { vmovss  xmm6, dword ptr [r14+730h] }
          v185 = CgHandler::getHandler((LocalClientNum_t)v21);
          __asm { vmovss  dword ptr [rsp+550h+fmt], xmm6 }
          BG_GetScopeLensSettings(v185, _R14, &r_weapon, v272, fmtb, &_R15->scopeToggleInfo.fractionInfo, &scope);
          if ( scope.dofOverride != (_BYTE)v137 )
          {
            _RCX = v296;
            _RAX = &scope;
            __asm
            {
              vmovups ymm0, ymmword ptr [rax]
              vmovups ymmword ptr [rcx], ymm0
              vmovups ymm0, ymmword ptr [rax+20h]
              vmovups ymmword ptr [rcx+20h], ymm0
              vmovups ymm0, ymmword ptr [rax+40h]
              vmovups ymmword ptr [rcx+40h], ymm0
              vmovups ymm0, ymmword ptr [rax+60h]
              vmovups ymmword ptr [rcx+60h], ymm0
              vmovups ymm0, ymmword ptr [rax+80h]
              vmovups ymmword ptr [rcx+80h], ymm0
              vmovups ymm0, ymmword ptr [rax+0A0h]
              vmovups ymmword ptr [rcx+0A0h], ymm0
            }
            dofPhysicalFocusDistance = scope.dofPhysicalFocusDistance;
          }
          v194 = **(const DObj ***)v282.v;
          Sys_ProfBeginNamedEvent(0xFFFAEBD7, "CG_GetScopePosition");
          v316[0] = scr_const.tag_front_lens;
          v316[1] = scr_const.tag_reticle_attach;
          v316[2] = scr_const.tag_reticle_attach2;
          v195 = 0;
          v196 = (scr_string_t *)v316;
          while ( !CG_DObjGetWorldTagMatrix(&_R15->viewModelPose, v194, *v196, &scope.scopeLensAxis, &scope.scopeLensPos) )
          {
            ++v195;
            ++v196;
            if ( v195 >= 3 )
            {
              RefdefView_GetOrg(&_R15->refdef.view, &scope.scopeLensPos);
              MatrixCopy33(&_R15->refdef.view.axis, &scope.scopeLensAxis);
              Sys_ProfEndNamedEvent();
              goto LABEL_147;
            }
          }
          Sys_ProfEndNamedEvent();
          goto LABEL_147;
        }
LABEL_148:
        CG_Ladder_SetRenderFlagsForHand((LocalClientNum_t)v21, _R14, v137, &outRenderFlags);
        v197 = CgHandler::getHandler((LocalClientNum_t)v21);
        v198 = v197->GetPlayerWeaponHeat(v197, _R14, &r_weapon, v137);
        *(double *)&_XMM0 = BG_Heat_GetHeat(v198, &r_weapon, v272, _R14->serverTime);
        __asm { vmovss  dword ptr [rbp+450h+var_458+18h], xmm13 }
        v289.m256i_i8[16] = 1;
        __asm
        {
          vmovss  dword ptr [rbp+450h+var_458+1Ch], xmm0
          vmovups ymm0, ymmword ptr [rbp+450h+var_458]
          vmovups [rbp+450h+var_410], ymm0
        }
        v294.characterEVOffset = characterEVOffset;
        __asm
        {
          vmovups ymm0, [rbp+450h+var_218]
          vmovups [rbp+450h+var_3E0], ymm0
        }
        v295.atlasTime = v313;
        __asm { vmovss  dword ptr [rsp+550h+isAlternate], xmm7 }
        v201 = *(cpose_t **)pose.v;
        v138 = *(const DObj ***)v282.v;
        CG_Entity_AddViewmodelDObjToScene((const LocalClientNum_t)v21, **(const DObj ***)v282.v, *(const cpose_t **)pose.v, v278, outRenderFlags, &v295, &v294, &vec, isAlternatea, 0, v287->markableViewmodel);
        if ( WeaponSystem->IsPlayerWeaponLaserOn(WeaponSystem, &r_weapon) )
        {
          if ( !v291 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 15384, ASSERT_TYPE_ASSERT, "(localPlayerGunAngles)", (const char *)&queryFormat, "localPlayerGunAngles") )
            __debugbreak();
          RefdefView_GetOrg(&_R15->refdef.view, &outOrg);
          if ( CG_LaserShouldDeferLocalPlayerDraw() )
          {
            CG_LaserAddDeferredDrawPlayerRequest((LocalClientNum_t)v21, v137, _R14, v291, v275, &outOrg, LASER_LIGHT_ON, &r_weapon, v272);
          }
          else
          {
            v202 = CG_LaserDrawPlayer((LocalClientNum_t)v21, _R14, v291, v275, (DObj *)*v138, v201, &outOrg, LASER_LIGHT_ON, &r_weapon, v272);
            LOBYTE(laserInfo->__vftable) = v202;
          }
          FX_Beam_SetPlayerLaser();
        }
        if ( v137 == WEAPON_HAND_DEFAULT )
        {
          pm_type = _R14->pm_type;
          v204 = CgWeaponSystem::GetWeaponSystem((const LocalClientNum_t)v21);
          if ( pm_type < 7 )
          {
            CgWeaponSystem::OffhandWeaponVmFxUpdate(v204, &r_weapon, v272);
          }
          else
          {
            CgWeaponSystem::OffhandWeaponVmFxStopAll(v204);
            _RAX = CG_GetLocalClientGlobals((const LocalClientNum_t)v21);
            __asm
            {
              vmovups ymm0, ymmword ptr cs:?NULL_WEAPON@@3UWeapon@@B.weaponIdx; Weapon const NULL_WEAPON
              vmovups ymmword ptr [rax+77E60h], ymm0
              vmovups xmm1, xmmword ptr cs:?NULL_WEAPON@@3UWeapon@@B.attachmentVariationIndices+5; Weapon const NULL_WEAPON
              vmovups xmmword ptr [rax+77E80h], xmm1
              vmovsd  xmm0, qword ptr cs:?NULL_WEAPON@@3UWeapon@@B.attachmentVariationIndices+15h; Weapon const NULL_WEAPON
              vmovsd  qword ptr [rax+77E90h], xmm0
            }
            *(_DWORD *)&_RAX->offhandWeaponVmFxInfo.weapon.weaponCamo = *(_DWORD *)&NULL_WEAPON.weaponCamo;
            _RAX->offhandWeaponVmFxInfo.currentWeaponIsAlt = 0;
          }
        }
LABEL_160:
        LODWORD(v274) = ++v137;
        v285 = (const playerState_s *)((char *)v285 + 1);
        v138 += 5;
        *(_QWORD *)v282.v = v138;
        laserInfo = (CgViewSystem *)((char *)laserInfo + 12);
        if ( (__int64)v285 > *(__int64 *)functionPointer.v )
          goto LABEL_161;
      }
      *(double *)&_XMM0 = BG_GetOffhandAdsFrac(_R14);
      __asm { vmovaps xmm6, xmm0 }
      OffhandGestureWeapon = BG_GetOffhandGestureWeapon(v169, _R14);
      v172 = CgHandler::getHandler((LocalClientNum_t)v21);
      __asm { vmovss  dword ptr [rsp+550h+fmt], xmm6 }
      BG_GetScopeLensSettings(v172, _R14, OffhandGestureWeapon, 0, fmta, &_R15->scopeToggleInfo.fractionInfo, &scope);
      v173 = **(const DObj ***)v282.v;
      Sys_ProfBeginNamedEvent(0xFFFAEBD7, "CG_GetScopePositionForOffhand");
      FunctionPointer_prevOrigin = *(void (__fastcall **)(const vec4_t *, vec3_t *))&scr_const.tag_front_lens_offhand;
      v174 = 0;
      p_FunctionPointer_prevOrigin = &FunctionPointer_prevOrigin;
      while ( !CG_DObjGetWorldTagMatrix(&_R15->viewModelPose, v173, *(scr_string_t *)p_FunctionPointer_prevOrigin, &scope.scopeLensAxis, &scope.scopeLensPos) )
      {
        ++v174;
        p_FunctionPointer_prevOrigin = (void (__fastcall **)(const vec4_t *, vec3_t *))((char *)p_FunctionPointer_prevOrigin + 4);
        if ( v174 >= 2 )
        {
          RefdefView_GetOrg(&_R15->refdef.view, &scope.scopeLensPos);
          MatrixCopy33(&_R15->refdef.view.axis, &scope.scopeLensAxis);
          Sys_ProfEndNamedEvent();
          goto LABEL_137;
        }
      }
      Sys_ProfEndNamedEvent();
LABEL_137:
      if ( scope.dofOverride )
      {
        _RCX = v296;
        _RAX = &scope;
        __asm
        {
          vmovups ymm0, ymmword ptr [rax]
          vmovups ymmword ptr [rcx], ymm0
          vmovups ymm0, ymmword ptr [rax+20h]
          vmovups ymmword ptr [rcx+20h], ymm0
          vmovups ymm0, ymmword ptr [rax+40h]
          vmovups ymmword ptr [rcx+40h], ymm0
          vmovups ymm0, ymmword ptr [rax+60h]
          vmovups ymmword ptr [rcx+60h], ymm0
          vmovups ymm0, ymmword ptr [rax+80h]
          vmovups ymmword ptr [rcx+80h], ymm0
          vmovups ymm0, ymmword ptr [rax+0A0h]
          vmovups ymmword ptr [rcx+0A0h], ymm0
        }
        dofPhysicalFocusDistance = scope.dofPhysicalFocusDistance;
      }
LABEL_147:
      R_SceneSetupWeaponScope(&scope);
      v137 = (int)v274;
      goto LABEL_148;
    }
LABEL_161:
    _R15->refdef.weaponOverridesSceneDoF = 0;
    weaponIdx = r_weapon.weaponIdx;
    if ( r_weapon.weaponIdx > bg_lastParsedWeaponIndex )
    {
      LODWORD(settingOut) = bg_lastParsedWeaponIndex;
      LODWORD(hybridScopeFraction) = r_weapon.weaponIdx;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1218, ASSERT_TYPE_ASSERT, "( weaponIndex ) <= ( bg_lastParsedWeaponIndex )", "weaponIndex not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", hybridScopeFraction, settingOut) )
        __debugbreak();
    }
    if ( !bg_weaponCompleteDefs[weaponIdx] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1219, ASSERT_TYPE_ASSERT, "(bg_weaponCompleteDefs[weaponIndex])", (const char *)&queryFormat, "bg_weaponCompleteDefs[weaponIndex]") )
      __debugbreak();
    _RDI = bg_weaponCompleteDefs[weaponIdx];
    if ( _RDI && _RDI->useSceneDof )
    {
      _R15->refdef.dofPhysical.viewModelFocusDistance = _R15->refdef.dofPhysical.focusDistance;
      _R15->refdef.dofPhysical.viewModelFstop = _R15->refdef.dofPhysical.fstop;
      goto LABEL_198;
    }
    __asm
    {
      vmovss  xmm8, dword ptr [r14+1224h]
      vmovss  xmm9, dword ptr [r14+1220h]
      vmovss  xmm6, dword ptr [rdi+214h]
      vmovss  xmm7, dword ptr [rdi+210h]
    }
    v214 = v297;
    if ( v297 )
    {
      __asm
      {
        vmovss  xmm6, [rbp+450h+var_2FC]
        vmovss  xmm7, [rbp+450h+var_300]
      }
    }
    v217 = CgHandler::getHandler((LocalClientNum_t)v21);
    if ( !BG_PlayerUsesNVGHalfADS(_R14, v217) && v298 )
    {
      _R15->refdef.weaponOverridesSceneDoF = 1;
      __asm
      {
        vmovss  xmm0, [rbp+450h+var_2F0]
        vmovss  dword ptr [r15+69C4h], xmm0
        vmovss  xmm1, [rbp+450h+var_2F4]
        vmovss  dword ptr [r15+69C8h], xmm1
      }
    }
    __asm
    {
      vmovss  xmm1, dword ptr [r14+730h]
      vcomiss xmm1, xmm13
    }
    if ( (unsigned int)(_R14->weapState[0].weaponState - 18) <= 3 )
    {
LABEL_187:
      __asm
      {
        vsubss  xmm0, xmm14, xmm1
        vmulss  xmm2, xmm0, xmm8
        vmulss  xmm1, xmm1, xmm6
        vaddss  xmm2, xmm2, xmm1
        vmovss  dword ptr [r15+6BC8h], xmm2
        vmovss  xmm3, dword ptr [r14+730h]
        vsubss  xmm0, xmm14, xmm3
        vmulss  xmm2, xmm0, xmm9
        vmulss  xmm1, xmm3, xmm7
        vaddss  xmm0, xmm2, xmm1; val
        vmovss  xmm2, cs:__real@41f00000; max
        vmovss  xmm1, cs:__real@3e000000; min
      }
      *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
      __asm { vmovss  dword ptr [r15+6BC4h], xmm0 }
      goto LABEL_198;
    }
    p_viewModelPose = &CG_GetLocalClientGlobals((const LocalClientNum_t)v21)->viewModelPose;
    if ( !_R15->m_weaponHand[0].viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 15443, ASSERT_TYPE_ASSERT, "(weapHand->viewModelDObj)", (const char *)&queryFormat, "weapHand->viewModelDObj") )
      __debugbreak();
    RefdefView_GetOrg(&_R15->refdef.view, &pose);
    if ( v214 )
    {
      if ( v301 )
      {
        tag_attachment_focus = scr_const.tag_attachment_focus;
        goto LABEL_184;
      }
    }
    else if ( _RDI->adsDofPhysicalFocalTag )
    {
      tag_attachment_focus = scr_const.tag_weapon_focus;
LABEL_184:
      if ( CG_DObjGetWorldTagPos(p_viewModelPose, _R15->m_weaponHand[0].viewModelDObj, tag_attachment_focus, &functionPointer) )
      {
        __asm
        {
          vmovss  xmm0, dword ptr [rsp+550h+pose]
          vsubss  xmm3, xmm0, dword ptr [rbp+450h+functionPointer]
          vmovss  xmm1, dword ptr [rsp+550h+pose+4]
          vmovss  xmm0, [rbp+450h+var_4D0]
          vsubss  xmm2, xmm1, dword ptr [rbp+450h+functionPointer+4]
          vsubss  xmm4, xmm0, [rbp+450h+var_2D8]
          vmulss  xmm1, xmm3, xmm3
          vmulss  xmm2, xmm2, xmm2
          vmulss  xmm0, xmm4, xmm4
          vaddss  xmm3, xmm2, xmm1
          vaddss  xmm2, xmm3, xmm0
          vsqrtss xmm6, xmm2, xmm2
        }
      }
    }
    memset(&pose, 0, sizeof(pose));
    __asm { vmovss  xmm1, dword ptr [r14+730h] }
    goto LABEL_187;
  }
LABEL_202:
  _R11 = &v317;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-18h]
    vmovaps xmm7, xmmword ptr [r11-28h]
    vmovaps xmm8, xmmword ptr [r11-38h]
    vmovaps xmm9, xmmword ptr [r11-48h]
    vmovaps xmm10, xmmword ptr [r11-58h]
    vmovaps xmm11, xmmword ptr [r11-68h]
    vmovaps xmm12, xmmword ptr [r11-78h]
    vmovaps xmm13, xmmword ptr [r11-88h]
    vmovaps xmm14, xmmword ptr [r11-98h]
  }
}

/*
==============
CG_AddViewWeapon
==============
*/
void CG_AddViewWeapon(LocalClientNum_t localClientNum)
{
  __int64 v5; 
  CgWeaponMap *v8; 
  const Weapon *ViewmodelWeapon; 
  CgWeaponSystem *WeaponSystem; 
  const dvar_t *v11; 
  const dvar_t *v12; 
  cg_t *LocalClientGlobals; 
  const playerState_s *p_predictedPlayerState; 
  CgWeaponMap *Instance; 
  int v16; 
  bool hideViewModel; 
  bool v18; 
  __int64 v19; 
  bool v24; 
  const tmat43_t<vec3_t> *ViewModelTransform; 
  int v28; 
  CgViewSystem *ViewSystem; 
  vec3_t outGunAngles; 
  vec3_t outGunOffset; 
  vec3_t weapOrigin; 
  Weapon v48; 
  vec4_t weapOrient; 
  char v50; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm6
    vmovaps xmmword ptr [rax-48h], xmm7
    vmovaps xmmword ptr [rax-58h], xmm8
  }
  v5 = localClientNum;
  Sys_ProfBeginNamedEvent(0xFF000000, "CG_AddViewWeapon");
  _RDI = CG_GetLocalClientGlobals((const LocalClientNum_t)v5);
  _RDI->laserInfo[0].drawnLaserThisFrame = 0;
  _RDI->laserInfo[1].drawnLaserThisFrame = 0;
  CG_LaserClearDeferredDrawPlayerRequests((LocalClientNum_t)v5);
  _RDI->nvgInfo.nvgAreaLightFXProcessedThisFrame = 0;
  _RSI = &_RDI->predictedPlayerState;
  if ( !CgWeaponMap::ms_instance[v5] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v8 = CgWeaponMap::ms_instance[v5];
  ViewmodelWeapon = BG_GetViewmodelWeapon(v8, &_RDI->predictedPlayerState);
  *(_QWORD *)outGunOffset.v = ViewmodelWeapon;
  WeaponSystem = CgWeaponSystem::GetWeaponSystem((const LocalClientNum_t)v5);
  WeaponSystem->TouchHandModel(WeaponSystem);
  if ( ViewmodelWeapon->weaponIdx )
  {
    if ( !v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1105, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    if ( _RDI == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1106, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    v11 = DVARBOOL_bg_giveAll;
    if ( !DVARBOOL_bg_giveAll || (Dvar_CheckFrontendServerThread(DVARBOOL_bg_giveAll), !v11->current.enabled) )
    {
      if ( !BG_GetEquippedWeaponStateConst(v8, &_RDI->predictedPlayerState, ViewmodelWeapon) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 15855, ASSERT_TYPE_ASSERT, "(BG_PlayerHasWeapon( weaponMap, ps, r_weapon ))", (const char *)&queryFormat, "BG_PlayerHasWeapon( weaponMap, ps, r_weapon )") )
        __debugbreak();
    }
    CG_TouchViewModel((const LocalClientNum_t)v5, ViewmodelWeapon, _RDI->playerWeaponInfo.isWeaponDefault, &_RDI->predictedPlayerState);
  }
  if ( _RDI->predictedPlayerState.accessoryIndex != 127 )
  {
    BG_Accessory_GetWeapon(v8, &_RDI->predictedPlayerState, &v48);
    if ( !v48.weaponIdx && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 15865, ASSERT_TYPE_ASSERT, "(!BG_IsNullWeapon( accessoryWeapon ))", (const char *)&queryFormat, "!BG_IsNullWeapon( accessoryWeapon )") )
      __debugbreak();
    if ( !v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1105, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    v12 = DVARBOOL_bg_giveAll;
    if ( !DVARBOOL_bg_giveAll || (Dvar_CheckFrontendServerThread(DVARBOOL_bg_giveAll), !v12->current.enabled) )
    {
      if ( !BG_GetEquippedWeaponStateConst(v8, &_RDI->predictedPlayerState, &v48) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 15866, ASSERT_TYPE_ASSERT, "(BG_PlayerHasWeapon( weaponMap, ps, accessoryWeapon ))", (const char *)&queryFormat, "BG_PlayerHasWeapon( weaponMap, ps, accessoryWeapon )") )
        __debugbreak();
    }
    CG_TouchViewModel((const LocalClientNum_t)v5, &v48, _RDI->playerWeaponInfo.isAccessoryDefault, &_RDI->predictedPlayerState);
  }
  if ( cgMedia.nightVisionGoggles )
    Stream_TouchXModel(cgMedia.nightVisionGoggles, MIP3);
  _RDI->refdef.dofPhysical.viewModelFocusDistance = 29.301001;
  _RDI->refdef.dofPhysical.viewModelFstop = 22.0;
  CgWeaponSystem::OffHandWeaponsUpdate(WeaponSystem, &_RDI->predictedPlayerState);
  if ( (unsigned int)(_RDI->predictedPlayerState.pm_type - 5) > 1 )
  {
    CG_NightVisionProcessLightFX((LocalClientNum_t)v5, &_RDI->predictedPlayerState, NULL, WEAPON_HAND_DEFAULT);
    LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v5);
    if ( !LocalClientGlobals->renderingThirdPerson )
    {
      p_predictedPlayerState = &LocalClientGlobals->predictedPlayerState;
      Instance = CgWeaponMap::GetInstance((const LocalClientNum_t)v5);
      if ( !BG_IsThirdPersonMode(Instance, p_predictedPlayerState) && !CG_Camera_Transition_IsHidingViewmodel((LocalClientNum_t)v5) && WeaponSystem->DrawUFOViewModel(WeaponSystem, &_RDI->predictedPlayerState) && _RDI->predictedPlayerState.pm_type != 4 )
      {
        if ( _RDI->cubemapShot || !Dvar_GetBool_Internal_DebugName(DVARBOOL_cg_drawGun, "cg_drawGun") || (v16 = 1, CG_GetWeapReticleZoom(_RDI, NULL)) && !BG_HasDualFOVEquipped(v8, &_RDI->predictedPlayerState) )
          v16 = 0;
        hideViewModel = _RDI->hideViewModel;
        if ( !BG_IsTurretActive(&_RDI->predictedPlayerState) && !BG_IsVehicleActive(&_RDI->predictedPlayerState) || BG_IsUsingTurretViewarms(v8, &_RDI->predictedPlayerState) )
        {
          if ( (_RDI->predictedPlayerState.linkFlags.m_flags[0] & 4) != 0 || (v18 = GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&_RDI->predictedPlayerState.otherFlags, ACTIVE, 1u)) )
            v18 = 1;
          if ( **(_WORD **)outGunOffset.v && !v18 && _RDI->playerWeaponInfo.handModel )
          {
            v19 = _RDI->localClientNum;
            if ( !CgWeaponMap::ms_instance[v19] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
              __debugbreak();
            _RAX = BG_GetViewmodelWeapon(CgWeaponMap::ms_instance[v19], &_RDI->predictedPlayerState);
            __asm
            {
              vmovups ymm0, ymmword ptr [rax]
              vmovups ymmword ptr [rsp+78h], ymm0
              vmovups xmm1, xmmword ptr [rax+20h]
              vmovups xmmword ptr [rbp-68h], xmm1
              vmovsd  xmm0, qword ptr [rax+30h]
              vmovsd  qword ptr [rbp-58h], xmm0
            }
            *(_DWORD *)&v48.weaponCamo = *(_DWORD *)&_RAX->weaponCamo;
            v24 = BG_UsingAlternate(&_RDI->predictedPlayerState);
            if ( BG_IsAimDownSight(&v48, v24) )
            {
              __asm
              {
                vmovss  xmm1, dword ptr [rsi+730h]
                vucomiss xmm1, cs:__real@3f800000
                vxorps  xmm0, xmm0, xmm0
                vucomiss xmm1, xmm0
              }
            }
            ViewModelTransform = cg_t::GetViewModelTransform(_RDI);
            CG_Weapons_CalculateMovement(_RDI, &_RDI->playerViewValues, ViewModelTransform, &outGunOffset, &outGunAngles, &weapOrigin, &weapOrient);
            v28 = 0;
            if ( !hideViewModel )
              v28 = v16;
            CG_AddPlayerWeapon((LocalClientNum_t)v5, &weapOrigin, &weapOrient, &_RDI->predictedPlayerState, &outGunAngles, _RDI->predictedPlayerEntity, v28, NULL);
            __asm
            {
              vmovss  xmm6, dword ptr [rsp+130h+outGunOffset+8]
              vmovss  xmm7, dword ptr [rsp+130h+outGunOffset+4]
              vmovss  xmm8, dword ptr [rsp+130h+outGunOffset]
            }
          }
          else
          {
            __asm
            {
              vmovss  xmm1, dword ptr [rdi+178C4h]
              vmovss  xmm0, dword ptr [rdi+178C0h]
              vmovss  dword ptr [rsp+130h+outGunAngles], xmm0
              vmovss  dword ptr [rsp+130h+outGunAngles+4], xmm1
              vxorps  xmm6, xmm6, xmm6
              vmovss  dword ptr [rsp+130h+outGunAngles+8], xmm6
              vxorps  xmm8, xmm8, xmm8
              vxorps  xmm7, xmm7, xmm7
            }
            ViewSystem = CgViewSystem::GetViewSystem((const LocalClientNum_t)v5);
            if ( !ViewSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 15959, ASSERT_TYPE_ASSERT, "(view)", (const char *)&queryFormat, "view") )
              __debugbreak();
            ViewSystem->CalcLinkedToPlayerViewTags(ViewSystem, VM_NONE);
          }
          if ( _RDI->originPredicted || _RDI->originInterpolated )
          {
            __asm
            {
              vmovss  dword ptr [rdi+49DE4h], xmm8
              vmovss  dword ptr [rdi+49DE8h], xmm7
              vmovss  dword ptr [rdi+49DECh], xmm6
              vmovss  xmm0, dword ptr [rsp+130h+outGunAngles]
              vmovss  dword ptr [rdi+49DF0h], xmm0
              vmovss  xmm1, dword ptr [rsp+130h+outGunAngles+4]
              vmovss  dword ptr [rdi+49DF4h], xmm1
              vmovss  xmm0, dword ptr [rsp+130h+outGunAngles+8]
              vmovss  dword ptr [rdi+49DF8h], xmm0
            }
          }
          __asm
          {
            vmovss  xmm0, dword ptr [rsp+130h+outGunAngles]
            vmovss  dword ptr [rdi+49DFCh], xmm0
            vmovss  xmm1, dword ptr [rsp+130h+outGunAngles+4]
            vmovss  dword ptr [rdi+49E00h], xmm1
            vmovss  xmm0, dword ptr [rsp+130h+outGunAngles+8]
            vmovss  dword ptr [rdi+49E04h], xmm0
          }
        }
      }
    }
  }
  Sys_ProfEndNamedEvent();
  _R11 = &v50;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
  }
}

/*
==============
CG_AppendNameToBuffer
==============
*/
void CG_AppendNameToBuffer(const char *delimiter, const char *newName, unsigned __int64 *outputLen, unsigned __int64 bufferLen, char *outputBuffer)
{
  const char *v8; 
  unsigned __int64 v9; 
  unsigned __int64 v10; 
  char i; 
  char j; 

  v8 = delimiter;
  if ( !delimiter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22332, ASSERT_TYPE_ASSERT, "(delimiter)", (const char *)&queryFormat, "delimiter") )
    __debugbreak();
  if ( !outputLen && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22333, ASSERT_TYPE_ASSERT, "(outputLen)", (const char *)&queryFormat, "outputLen") )
    __debugbreak();
  if ( !outputBuffer && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22334, ASSERT_TYPE_ASSERT, "(outputBuffer)", (const char *)&queryFormat, "outputBuffer") )
    __debugbreak();
  v9 = *outputLen;
  v10 = *outputLen;
  if ( *outputLen )
  {
    for ( i = *v8; *v8; i = *v8 )
    {
      v10 = v9;
      if ( v9 >= bufferLen - 1 )
        break;
      outputBuffer[v9] = i;
      ++v8;
      v10 = *outputLen + 1;
      *outputLen = v10;
      v9 = v10;
    }
  }
  if ( newName )
  {
    for ( j = *newName; *newName; j = *newName )
    {
      if ( v10 >= bufferLen - 1 )
        break;
      outputBuffer[v10] = j;
      ++newName;
      v10 = ++*outputLen;
    }
  }
}

/*
==============
CG_BinocularsADS
==============
*/
bool CG_BinocularsADS(LocalClientNum_t localClientNum)
{
  cg_t *LocalClientGlobals; 
  bool result; 
  CgWeaponMap *Instance; 
  const Weapon *OffhandGestureWeapon; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  result = BG_IsUsingOffhandGestureWeaponADSActive(&LocalClientGlobals->predictedPlayerState);
  if ( result )
  {
    Instance = CgWeaponMap::GetInstance(localClientNum);
    OffhandGestureWeapon = BG_GetOffhandGestureWeapon(Instance, &LocalClientGlobals->predictedPlayerState);
    return BG_WeaponDef(OffhandGestureWeapon, 0)->overlayInterface == WEAPOVERLAYINTERFACE_BINOCULARS;
  }
  return result;
}

/*
==============
CG_BinocularsGetZoomLevel
==============
*/
int CG_BinocularsGetZoomLevel(LocalClientNum_t localClientNum)
{
  cg_t *LocalClientGlobals; 
  CgWeaponMap *Instance; 
  const Weapon *OffhandGestureWeapon; 
  cg_t *v5; 
  CgWeaponMap *v6; 
  const Weapon *v7; 
  BgHybridScopeFraction hybridScopeFractionInfo; 
  BgAdsZoomInfo outZoomInfo; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !BG_IsUsingOffhandGestureWeaponADSActive(&LocalClientGlobals->predictedPlayerState) )
    return 0;
  Instance = CgWeaponMap::GetInstance(localClientNum);
  OffhandGestureWeapon = BG_GetOffhandGestureWeapon(Instance, &LocalClientGlobals->predictedPlayerState);
  if ( BG_WeaponDef(OffhandGestureWeapon, 0)->overlayInterface != WEAPOVERLAYINTERFACE_BINOCULARS )
    return 0;
  v5 = CG_GetLocalClientGlobals(localClientNum);
  v6 = CgWeaponMap::GetInstance(localClientNum);
  v7 = BG_GetOffhandGestureWeapon(v6, &v5->predictedPlayerState);
  memset(&outZoomInfo, 0, sizeof(outZoomInfo));
  hybridScopeFractionInfo = 0i64;
  BG_GetADSZoomInfo(v6, v7, 0, &hybridScopeFractionInfo, &outZoomInfo);
  return BG_GetADSZoomLevel(v6, &v5->predictedPlayerState, v7, outZoomInfo.zoomCount);
}

/*
==============
CG_BinocularsThermalEnabled
==============
*/
bool CG_BinocularsThermalEnabled(LocalClientNum_t localClientNum)
{
  cg_t *LocalClientGlobals; 
  CgWeaponMap *Instance; 
  const Weapon *OffhandGestureWeapon; 
  cg_t *v5; 
  CgWeaponMap *v6; 
  const Weapon *v7; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !BG_IsUsingOffhandGestureWeaponADSActive(&LocalClientGlobals->predictedPlayerState) )
    return 0;
  Instance = CgWeaponMap::GetInstance(localClientNum);
  OffhandGestureWeapon = BG_GetOffhandGestureWeapon(Instance, &LocalClientGlobals->predictedPlayerState);
  if ( BG_WeaponDef(OffhandGestureWeapon, 0)->overlayInterface != WEAPOVERLAYINTERFACE_BINOCULARS )
    return 0;
  v5 = CG_GetLocalClientGlobals(localClientNum);
  v6 = CgWeaponMap::GetInstance(localClientNum);
  v7 = BG_GetOffhandGestureWeapon(v6, &v5->predictedPlayerState);
  return BG_IsThermalEnabled(v6, v7, &v5->predictedPlayerState);
}

/*
==============
CG_BulletHitClientEvent
==============
*/
void CG_BulletHitClientEvent(LocalClientNum_t localClientNum, int sourceEntityNum, const Weapon *weapon, bool isAlternate, const vec3_t *startPos, const vec3_t *position, int surfType, int event, unsigned int impactEffects, SndHitArmorType hitArmorType)
{
  CgWeaponSystem *WeaponSystem; 

  if ( sourceEntityNum < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20697, ASSERT_TYPE_ASSERT, "(sourceEntityNum >= 0)", (const char *)&queryFormat, "sourceEntityNum >= 0") )
    __debugbreak();
  if ( sourceEntityNum == 2047 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20698, ASSERT_TYPE_ASSERT, "(sourceEntityNum != ENTITYNUM_NONE)", (const char *)&queryFormat, "sourceEntityNum != ENTITYNUM_NONE") )
    __debugbreak();
  if ( (unsigned int)surfType > 0x3F && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20699, ASSERT_TYPE_ASSERT, "(surfType >= 0 && surfType < 64)", (const char *)&queryFormat, "surfType >= 0 && surfType < SURF_TYPECOUNT") )
    __debugbreak();
  Sys_ProfBeginNamedEvent(0xFF008080, "CG_BulletHitClientEvent");
  BulletHitClientEventSound(localClientNum, sourceEntityNum, weapon, isAlternate, position, surfType, event, impactEffects, hitArmorType);
  if ( (impactEffects & 4) == 0 )
  {
    WeaponSystem = CgWeaponSystem::GetWeaponSystem(localClientNum);
    WeaponSystem->BulletTrajectoryEffects(WeaponSystem, sourceEntityNum, weapon, isAlternate, startPos, position, surfType, event);
  }
  CG_Rumble_PlayOnPositionByName(localClientNum, "damage_bullet", startPos);
  Sys_ProfEndNamedEvent();
}

/*
==============
CG_BulletHitClientShieldEvent
==============
*/
void CG_BulletHitClientShieldEvent(LocalClientNum_t localClientNum, int sourceEntityNum, const Weapon *weapon, bool isAlternate, int surfType, int event, unsigned int eventParm)
{
  const dvar_t *v49; 
  int integer; 
  bool v54; 
  cg_t *LocalClientGlobals; 
  __int64 delayedShieldHitEventsCount; 
  float fmt; 
  bool resultHitFront; 
  vec3_t outOrg; 
  __int64 v66; 
  vec3_t result; 
  char v68; 
  void *retaddr; 

  _RAX = &retaddr;
  v66 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-58h], xmm6
    vmovaps xmmword ptr [rax-68h], xmm7
    vmovaps xmmword ptr [rax-78h], xmm8
    vmovaps xmmword ptr [rax-88h], xmm9
    vmovaps xmmword ptr [rax-98h], xmm10
  }
  if ( sourceEntityNum < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21088, ASSERT_TYPE_ASSERT, "(sourceEntityNum >= 0)", (const char *)&queryFormat, "sourceEntityNum >= 0") )
    __debugbreak();
  if ( sourceEntityNum == 2047 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21089, ASSERT_TYPE_ASSERT, "(sourceEntityNum != ENTITYNUM_NONE)", (const char *)&queryFormat, "sourceEntityNum != ENTITYNUM_NONE") )
    __debugbreak();
  if ( (unsigned int)surfType > 0x3F && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21090, ASSERT_TYPE_ASSERT, "(surfType >= 0 && surfType < 64)", (const char *)&queryFormat, "surfType >= 0 && surfType < SURF_TYPECOUNT") )
    __debugbreak();
  _RDI = CG_GetLocalClientGlobals(localClientNum);
  BG_ShieldHitDecode((unsigned __int8)eventParm, &result, &resultHitFront);
  __asm
  {
    vmovss  xmm8, dword ptr [rdi+6944h]
    vmovss  xmm9, dword ptr [rdi+6948h]
    vmovss  xmm10, dword ptr [rdi+694Ch]
    vmovss  xmm6, dword ptr [rsp+128h+result]
    vmulss  xmm1, xmm6, xmm8
    vmovss  xmm3, dword ptr [rsp+128h+result+4]
    vmulss  xmm0, xmm3, dword ptr [rdi+6950h]
    vaddss  xmm2, xmm1, xmm0
    vmovss  xmm4, dword ptr [rsp+128h+result+8]
    vmulss  xmm1, xmm4, dword ptr [rdi+695Ch]
    vaddss  xmm0, xmm2, xmm1
    vaddss  xmm7, xmm0, dword ptr [rdi+699Ch]
    vmulss  xmm1, xmm3, dword ptr [rdi+6954h]
    vmulss  xmm0, xmm6, xmm9
    vaddss  xmm2, xmm1, xmm0
    vmulss  xmm1, xmm4, dword ptr [rdi+6960h]
    vaddss  xmm0, xmm2, xmm1
    vaddss  xmm5, xmm0, dword ptr [rdi+69A0h]
    vmulss  xmm1, xmm3, dword ptr [rdi+6958h]
    vmulss  xmm0, xmm6, xmm10
    vaddss  xmm2, xmm1, xmm0
    vmulss  xmm1, xmm4, dword ptr [rdi+6964h]
    vaddss  xmm0, xmm2, xmm1
    vaddss  xmm4, xmm0, dword ptr [rdi+69A4h]
    vmovss  xmm3, cs:__real@41200000
    vmulss  xmm1, xmm8, xmm3
    vaddss  xmm0, xmm1, xmm7
    vmovss  dword ptr [rsp+128h+result], xmm0
    vmulss  xmm2, xmm9, xmm3
    vaddss  xmm1, xmm2, xmm5
    vmovss  dword ptr [rsp+128h+result+4], xmm1
    vmulss  xmm0, xmm10, xmm3
    vaddss  xmm2, xmm0, xmm4
    vmovss  dword ptr [rsp+128h+result+8], xmm2
  }
  CG_Rumble_PlayOnClientSafeByName(localClientNum, "riotshield_impact");
  RefdefView_GetOrg(&_RDI->refdef.view, &outOrg);
  v49 = DVARINT_shieldImpactBulletShakeDuration;
  if ( !DVARINT_shieldImpactBulletShakeDuration && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "shieldImpactBulletShakeDuration") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v49);
  integer = v49->current.integer;
  _RDI = DVARFLT_shieldImpactBulletShakeScale;
  if ( !DVARFLT_shieldImpactBulletShakeScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "shieldImpactBulletShakeScale") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RDI);
  __asm
  {
    vmovss  xmm0, cs:__real@42c80000
    vmovss  dword ptr [rsp+128h+fmt], xmm0
    vmovss  xmm1, dword ptr [rdi+28h]; scale
  }
  CG_StartShakeCamera(localClientNum, *(float *)&_XMM1, integer, &outOrg, fmt);
  BulletHitClientEventSound(localClientNum, sourceEntityNum, weapon, isAlternate, &result, surfType, event, 0x80u, SND_HIT_ARMOR_TYPE_NONE);
  v54 = resultHitFront;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  delayedShieldHitEventsCount = LocalClientGlobals->delayedShieldHitEventsCount;
  if ( (int)delayedShieldHitEventsCount < 2 )
  {
    LocalClientGlobals->delayedShieldHitEvents[delayedShieldHitEventsCount].eventParm = eventParm;
    LocalClientGlobals->delayedShieldHitEvents[LocalClientGlobals->delayedShieldHitEventsCount++].damaged = v54;
  }
  CG_OffhandShield_DamageFeedback(localClientNum, sourceEntityNum, eventParm, resultHitFront);
  memset(&outOrg, 0, sizeof(outOrg));
  _R11 = &v68;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-18h]
    vmovaps xmm7, xmmword ptr [r11-28h]
    vmovaps xmm8, xmmword ptr [r11-38h]
    vmovaps xmm9, xmmword ptr [r11-48h]
    vmovaps xmm10, xmmword ptr [r11-58h]
  }
}

/*
==============
CG_BulletHitEffectCallback
==============
*/
void CG_BulletHitEffectCallback(const LocalClientNum_t localClientNum, unsigned int hitBody, unsigned int shapeKey, const vec3_t *start, const vec3_t *hitPos, const int hitSurfaceFlags, const vec3_t *hitNormal, const scr_string_t *partName, const unsigned int inflictorEntNum, const Weapon *weapon, bool isAlternate, int mod)
{
  cg_t *LocalClientGlobals; 
  __int64 *p_npcImpactSounds; 
  int VFXImpactType; 
  RegisteredImpactType v19; 
  RegisteredImpactType v20; 
  FXRegisteredDef *v21; 
  __int64 v22; 
  __int64 v23; 
  __int64 v25; 
  const ParticleSystemDef *particleSystemDef; 
  int Ref; 
  Physics_WorldId RefSystem; 
  __int64 v29; 
  unsigned __int8 IsBoneDismembered; 
  int EntityNum; 
  const DObj *ClientDObj; 
  const DObj *v33; 
  scr_string_t v34; 
  FXRegisteredDef *v36; 
  unsigned int v37; 
  __int64 v40; 
  CgSoundSystem *SoundSystem; 
  vec3_t *v44; 
  const DynEntityDef *v45; 
  unsigned int runtimeInstanceCount; 
  unsigned int v47; 
  unsigned int RefSubSystem; 
  unsigned int RefId; 
  vec3_t *worldOrigin; 
  int worldOrigina; 
  tmat33_t<vec3_t> *worldAxis; 
  int worldAxisa; 
  unsigned __int8 inOutIndex; 
  DynEntityBasis basisOut; 
  vec3_t *origin; 
  int impactType; 
  unsigned int bodyId; 
  Physics_WorldId worldId; 
  unsigned int dynEntIdOut; 
  __int64 v61; 
  int sourceEntityNum; 
  const scr_string_t *v63; 
  FXRegisteredDef def[2]; 
  unsigned int shapeKeya; 
  __int64 v66; 
  FXRegisteredDef *v67; 
  Weapon *r_weapon; 
  vec3_t *starta; 

  origin = (vec3_t *)hitPos;
  bodyId = hitBody;
  v63 = partName;
  starta = (vec3_t *)start;
  shapeKeya = shapeKey;
  sourceEntityNum = inflictorEntNum;
  r_weapon = (Weapon *)weapon;
  Sys_ProfBeginNamedEvent(0xFF008008, "CG_BulletHitEffectCallback");
  worldId = 3 * localClientNum + 3;
  if ( !Physics_IsRigidBodyValid(worldId, hitBody) || !cgMedia.impactFx )
    goto LABEL_75;
  __asm { vmovaps [rsp+150h+var_50], xmm6 }
  dynEntIdOut = (hitSurfaceFlags >> 19) & 0x3F;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 14705, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  p_npcImpactSounds = (__int64 *)&cgMedia.npcImpactSounds;
  if ( CG_IsPlayerEntityNumber(&LocalClientGlobals->predictedPlayerState, inflictorEntNum) )
    p_npcImpactSounds = (__int64 *)&cgMedia.playerImpactSounds;
  Sys_ProfBeginNamedEvent(0xFF008008, "Calculate FX");
  VFXImpactType = CG_Weapons_GetVFXImpactType(localClientNum, inflictorEntNum, weapon, isAlternate);
  impactType = CG_Weapons_GetSFXImpactType(localClientNum, sourceEntityNum, weapon, isAlternate);
  v19 = CG_Main_ImpactTypeToRegisteredImpactType(VFXImpactType);
  if ( v19 != -1 )
  {
    switch ( v19 )
    {
      case 5:
        v20 = 4;
        break;
      case 7:
        v20 = 6;
        break;
      case 16:
        v20 = 15;
        break;
      default:
        goto LABEL_16;
    }
    VFXImpactType = CG_Main_RegisteredImpactTypeToImpactType(v20);
  }
LABEL_16:
  v21 = def;
  v22 = 2i64;
  do
  {
    FXRegisteredDef::FXRegisteredDef(v21++);
    --v22;
  }
  while ( v22 );
  v23 = 0i64;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovdqu xmmword ptr [rbp+50h+def.m_particleSystemDef], xmm0
  }
  if ( VFXImpactType >= 0 && (hitSurfaceFlags & 0x10) == 0 && cgMedia.impactFx )
  {
    if ( !cgMedia.impactFx->table && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20022, ASSERT_TYPE_ASSERT, "(cgMedia.impactFx->table)", (const char *)&queryFormat, "cgMedia.impactFx->table") )
      __debugbreak();
    v25 = (hitSurfaceFlags >> 19) & 0x3F;
    do
    {
      if ( VFXImpactType >= cgMedia.impactFx->impactTypeCount )
      {
        LODWORD(worldAxis) = cgMedia.impactFx->impactTypeCount;
        LODWORD(worldOrigin) = VFXImpactType;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20025, ASSERT_TYPE_ASSERT, "(unsigned)( impactType ) < (unsigned)( cgMedia.impactFx->impactTypeCount )", "impactType doesn't index cgMedia.impactFx->impactTypeCount\n\t%i not in [0, %i)", worldOrigin, worldAxis) )
          __debugbreak();
      }
      particleSystemDef = cgMedia.impactFx->table[VFXImpactType].normal->nonflesh[v25].particleSystemDef;
      v25 += 87i64;
      def[v23++].m_particleSystemDef = particleSystemDef;
    }
    while ( v23 < 2 );
  }
  Sys_ProfEndNamedEvent();
  Sys_ProfBeginNamedEvent(0xFF008008, "Calculate Sound");
  v61 = 0i64;
  switch ( CG_Main_ImpactTypeToRegisteredImpactType(impactType) )
  {
    case 1:
    case 2:
      v61 = p_npcImpactSounds[2];
      break;
    case 3:
    case 4:
      v61 = p_npcImpactSounds[1];
      break;
    case 5:
      v61 = *p_npcImpactSounds;
      break;
    case 6:
    case 7:
      v61 = p_npcImpactSounds[3];
      break;
    case 15:
    case 16:
      v61 = p_npcImpactSounds[4];
      break;
    default:
      break;
  }
  Sys_ProfEndNamedEvent();
  Ref = Physics_GetRef(worldId, bodyId);
  RefSystem = Physics_GetRefSystem(Ref);
  v29 = RefSystem;
  IsBoneDismembered = 0;
  worldId = RefSystem;
  inOutIndex = 0;
  if ( RefSystem == PHYSICS_WORLD_ID_CLIENT1_AUTHORITATIVE )
  {
    EntityNum = Physics_GetEntityNum(Ref);
    if ( Dvar_GetBool_Internal_DebugName(DVARBOOL_corpseImpactEffectsEnabled, "corpseImpactEffectsEnabled") )
    {
      inOutIndex = CG_CorpseFade_CullImpactEffects(localClientNum, EntityNum);
      IsBoneDismembered = inOutIndex;
      if ( !inOutIndex )
      {
        if ( v63 )
        {
          if ( *v63 )
          {
            if ( FX_Dismemberment_EntryExists(localClientNum, EntityNum) )
            {
              ClientDObj = Com_GetClientDObj(EntityNum, localClientNum);
              v33 = ClientDObj;
              if ( ClientDObj )
              {
                v34 = *v63;
                inOutIndex = -2;
                DObjGetBoneIndexInternal_66(ClientDObj, v34, &inOutIndex, (int *)&bodyId);
                IsBoneDismembered = FX_Dismemberment_IsBoneDismembered(localClientNum, v33, inOutIndex, 0);
                inOutIndex = IsBoneDismembered;
              }
            }
          }
        }
      }
    }
    else
    {
      IsBoneDismembered = 1;
      inOutIndex = 1;
    }
  }
  Sys_ProfBeginNamedEvent(0xFF008008, "Play FX");
  _R12 = hitNormal;
  v66 = v29;
  v36 = def;
  v37 = 0;
  v67 = def;
  __asm { vxorps  xmm6, xmm6, xmm6 }
  do
  {
    if ( v36->m_particleSystemDef && !IsBoneDismembered )
    {
      __asm
      {
        vmovss  xmm0, dword ptr [r12]
        vucomiss xmm0, xmm6
        vucomiss xmm6, dword ptr [r12+4]
        vucomiss xmm6, dword ptr [r12+8]
      }
    }
    IsBoneDismembered = inOutIndex;
    ++v36;
    ++v37;
    v67 = v36;
  }
  while ( v37 < 2 );
  Sys_ProfEndNamedEvent();
  v40 = v61;
  __asm { vmovaps xmm6, [rsp+150h+var_50] }
  if ( !v61 || IsBoneDismembered )
  {
    v44 = origin;
  }
  else
  {
    Sys_ProfBeginNamedEvent(0xFF008008, "Play Sound");
    SoundSystem = CgSoundSystem::GetSoundSystem(localClientNum);
    __asm { vmovss  xmm0, cs:__real@3f800000 }
    v44 = origin;
    __asm
    {
      vmovss  dword ptr [rsp+150h+worldAxis], xmm0
      vmovss  dword ptr [rsp+150h+worldOrigin], xmm0
    }
    ((void (__fastcall *)(CgSoundSystem *, __int64, vec3_t *, __int64, unsigned int, int, int, _DWORD))SoundSystem->PlaySurfaceSound)(SoundSystem, 2046i64, origin, v40, dynEntIdOut, worldOrigina, worldAxisa, 0);
    Sys_ProfEndNamedEvent();
  }
  if ( worldId == PHYSICS_WORLD_ID_SERVER_DETAIL )
  {
    Sys_ProfBeginNamedEvent(0xFF008008, "Scriptable Damage Check");
    DynEnt_GetBasisAndDynEntId(Ref, localClientNum, &basisOut, &dynEntIdOut);
    v45 = DynEnt_GetDef(dynEntIdOut, basisOut);
    if ( !v45 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 14904, ASSERT_TYPE_ASSERT, "(dynEntDef)", (const char *)&queryFormat, "dynEntDef") )
      __debugbreak();
    if ( v45->type == DYNENT_TYPE_SCRIPTABLEINST )
    {
      if ( !cm.mapEnts && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\scriptable\\scriptable_common_utility.h", 113, ASSERT_TYPE_ASSERT, "( cm.mapEnts != nullptr )", (const char *)&queryFormat, "cm.mapEnts != nullptr") )
        __debugbreak();
      if ( v45->scriptableMapIndex >= cm.mapEnts->scriptableMapEnts.mapInstanceCount )
      {
        LODWORD(worldAxis) = cm.mapEnts->scriptableMapEnts.mapInstanceCount;
        LODWORD(worldOrigin) = v45->scriptableMapIndex;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 14910, ASSERT_TYPE_ASSERT, "(unsigned)( dynEntDef->scriptableMapIndex ) < (unsigned)( ScriptableCommon_GetMapInstanceCount() )", "dynEntDef->scriptableMapIndex doesn't index ScriptableCommon_GetMapInstanceCount()\n\t%i not in [0, %i)", worldOrigin, worldAxis) )
          __debugbreak();
      }
      ScriptableCommon_AssertCountsInitialized();
      runtimeInstanceCount = g_scriptableWorldCounts.runtimeInstanceCount;
      if ( !cm.mapEnts && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\scriptable\\scriptable_common_utility.h", 106, ASSERT_TYPE_ASSERT, "( cm.mapEnts != nullptr )", (const char *)&queryFormat, "cm.mapEnts != nullptr") )
        __debugbreak();
      v47 = runtimeInstanceCount + cm.mapEnts->scriptableMapEnts.lootInstanceCount + v45->scriptableMapIndex;
      ScriptableCommon_AssertCountsInitialized();
      if ( v47 >= g_scriptableWorldCounts.totalInstanceCount )
      {
        ScriptableCommon_AssertCountsInitialized();
        LODWORD(worldAxis) = g_scriptableWorldCounts.totalInstanceCount;
        LODWORD(worldOrigin) = v47;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 14913, ASSERT_TYPE_ASSERT, "(unsigned)( scriptableIndex ) < (unsigned)( ScriptableCommon_GetTotalInstanceCount() )", "scriptableIndex doesn't index ScriptableCommon_GetTotalInstanceCount()\n\t%i not in [0, %i)", worldOrigin, worldAxis) )
          __debugbreak();
      }
      ScriptableCl_EntityBulletHitEvent(localClientNum, v47, sourceEntityNum, starta, v44, mod, r_weapon, isAlternate, *v63);
    }
    Sys_ProfEndNamedEvent();
  }
  else if ( worldId == (PHYSICS_WORLD_ID_COUNT|PHYSICS_WORLD_ID_CLIENT0_AUTHORITATIVE) )
  {
    RefSubSystem = Physics_GetRefSubSystem(Ref);
    RefId = Physics_GetRefId(Ref);
    if ( Cloth_IsInstanceInUse(localClientNum, RefId) )
      Cloth_Update_ApplyBulletImpact(localClientNum, RefId, RefSubSystem, shapeKeya, starta, v44);
  }
LABEL_75:
  Sys_ProfEndNamedEvent();
}

/*
==============
CG_CalcBallisticBulletEffectTime
==============
*/

int __fastcall CG_CalcBallisticBulletEffectTime(const cg_t *cgameGlob, const vec3_t *initialBulletPos, double fullTraceLength, const vec3_t *effectPos, const bool isBallisticRound)
{
  const dvar_t *v10; 
  const dvar_t *v29; 
  int result; 

  __asm { vmovaps [rsp+78h+var_28], xmm6 }
  _RSI = effectPos;
  __asm { vmovaps xmm6, xmm2 }
  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24330, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  v10 = DCONST_DVARBOOL_bg_ballisticsSyncImpactFx;
  if ( !DCONST_DVARBOOL_bg_ballisticsSyncImpactFx && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_ballisticsSyncImpactFx") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v10);
  if ( v10->current.enabled && isBallisticRound )
  {
    __asm
    {
      vcvtss2sd xmm0, xmm6, xmm6
      vcomisd xmm0, cs:__real@3eb0c6f7a0b5ed8d
      vmovss  xmm0, dword ptr [rsi]
      vsubss  xmm3, xmm0, dword ptr [rbp+0]
      vmovss  xmm1, dword ptr [rsi+4]
      vsubss  xmm2, xmm1, dword ptr [rbp+4]
      vmovss  xmm0, dword ptr [rsi+8]
      vsubss  xmm4, xmm0, dword ptr [rbp+8]
      vmulss  xmm2, xmm2, xmm2
      vmulss  xmm1, xmm3, xmm3
      vaddss  xmm3, xmm2, xmm1
      vmulss  xmm0, xmm4, xmm4
      vaddss  xmm2, xmm3, xmm0
      vsqrtss xmm1, xmm2, xmm2
      vmovaps [rsp+78h+var_38], xmm7
      vmovss  xmm7, cs:__real@3f800000
      vdivss  xmm0, xmm7, xmm6
      vmulss  xmm0, xmm1, xmm0; val
      vxorps  xmm1, xmm1, xmm1; min
      vmovaps xmm2, xmm7; max
    }
    *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
    v29 = DCONST_DVARINT_bg_ballisticsSimTimeStepMs;
    __asm { vmovaps xmm6, xmm0 }
    if ( !DCONST_DVARINT_bg_ballisticsSimTimeStepMs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_ballisticsSimTimeStepMs") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v29);
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, eax
      vmulss  xmm2, xmm0, xmm6
      vsubss  xmm1, xmm7, xmm6
      vmovaps xmm7, [rsp+78h+var_38]
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, [rsp+78h+ballisticSimStartTime]
      vmulss  xmm1, xmm1, xmm0
      vaddss  xmm2, xmm2, xmm1
      vcvttss2si eax, xmm2
    }
  }
  else
  {
    result = cgameGlob->time;
  }
  __asm { vmovaps xmm6, [rsp+78h+var_28] }
  return result;
}

/*
==============
CG_CalculateWeaponMovement_CalcAngles
==============
*/
void CG_CalculateWeaponMovement_CalcAngles(const cg_t *cgameGlob, const PlayerViewValues *viewValues, const vec3_t *weapOrigin, const vec3_t *weapAngles, const vec3_t *springTiltAngles, const float springTiltOffset, vec3_t *outGunAngles, vec3_t *outWeapOrigin, vec4_t *outWeapOrient)
{
  const dvar_t *v21; 
  LocalClientNum_t localClientNum; 
  __int64 v27; 
  CgWeaponMap *v28; 
  PlayerHandIndex v29; 
  int *p_weaponState; 
  __int64 v31; 
  unsigned __int64 v32; 
  PlayerHandIndex WeaponHand; 
  const dvar_t *v92; 
  const dvar_t *v116; 
  const dvar_t *v117; 
  CgWeaponMap *Instance; 
  const Weapon *CurrentWeaponForPlayer; 
  bool v143; 
  bool enabled; 
  vec4_t v147; 
  vec3_t pivotPoint; 
  vec3_t dst; 
  vec3_t center; 
  tmat33_t<vec3_t> axis; 
  vec4_t quat; 
  vec4_t result; 
  vec3_t angles; 
  vec3_t v155; 
  vec3_t v156; 
  vec3_t v157; 
  vec3_t v158; 
  vec3_t v159; 
  tmat33_t<vec3_t> rotation; 
  vec3_t localGunAngles; 
  tmat33_t<vec3_t> in1; 
  tmat33_t<vec3_t> out; 
  tmat33_t<vec3_t> v164; 
  tmat33_t<vec3_t> v165; 

  __asm { vmovaps [rsp+270h+var_50], xmm7 }
  _RDI = outWeapOrigin;
  _RBX = weapAngles;
  _R13 = weapOrigin;
  *(_QWORD *)pivotPoint.v = springTiltAngles;
  _RSI = viewValues;
  *(_QWORD *)center.v = outWeapOrigin;
  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 14146, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  AnglesToAxis(&cgameGlob->baseGunAngles, &axis);
  __asm
  {
    vmovsd  xmm0, qword ptr [r13+0]
    vmovss  xmm7, cs:__real@3f800000
    vmovsd  qword ptr [rdi], xmm0
  }
  outWeapOrigin->v[2] = _R13->v[2];
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vmovss  xmm1, dword ptr [rbx+4]
    vmovss  dword ptr [rbp+170h+angles], xmm0
    vmovss  xmm0, dword ptr [rbx+8]
  }
  v21 = DVARBOOL_cg_gun_motion_enable_fov_compensation;
  __asm
  {
    vmovss  dword ptr [rbp+170h+angles+4], xmm1
    vmovss  dword ptr [rbp+170h+angles+8], xmm0
  }
  if ( !DVARBOOL_cg_gun_motion_enable_fov_compensation && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_gun_motion_enable_fov_compensation") )
    __debugbreak();
  __asm { vmovaps [rsp+270h+var_40], xmm6 }
  Dvar_CheckFrontendServerThread(v21);
  enabled = v21->current.enabled;
  if ( enabled )
  {
    if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 14110, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
      __debugbreak();
    localClientNum = cgameGlob->localClientNum;
    _RAX = CG_GetViewFovBySpace((ClientFov *)&result, localClientNum, CG_FovSpace_Scene, 0);
    __asm { vmovsd  xmm6, qword ptr [rax] }
    v147.v[2] = _RAX->baseFovAdjustment;
    __asm { vmovsd  qword ptr [rsp+270h+var_220], xmm6 }
    if ( CG_View_ShouldRenderGunAtDifferentFov(cgameGlob, &cgameGlob->predictedPlayerState) )
    {
      _RAX = CG_GetViewFovBySpace((ClientFov *)&v147, localClientNum, CG_FovSpace_DepthHack, 0);
      __asm { vmovsd  xmm0, qword ptr [rax] }
      v147.v[2] = _RAX->baseFovAdjustment;
      __asm { vmovsd  qword ptr [rsp+270h+var_220], xmm0 }
    }
    else
    {
      __asm { vmovaps xmm0, xmm6 }
    }
    __asm { vdivss  xmm7, xmm0, xmm6 }
    AnglesToQuat(&angles, &v147);
    __asm { vmovaps xmm2, xmm7; frac }
    QuatSlerp(&quat_identity, &v147, *(float *)&_XMM2, &result);
    QuatToAngles(&result, &angles);
  }
  AnglesToAxis(&angles, &in1);
  MatrixMultiply(&in1, &axis, &out);
  AxisToQuat(&out, outWeapOrient);
  v27 = cgameGlob->localClientNum;
  if ( !CgWeaponMap::ms_instance[v27] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v28 = CgWeaponMap::ms_instance[v27];
  v29 = WEAPON_HAND_DEFAULT;
  if ( BG_PlayerLastWeaponHand(v28, &cgameGlob->predictedPlayerState) < WEAPON_HAND_DEFAULT )
  {
LABEL_23:
    __asm
    {
      vxorps  xmm6, xmm6, xmm6
      vmovss  dword ptr [rsp+270h+dst], xmm6
      vmovss  dword ptr [rsp+270h+dst+4], xmm6
      vmovss  dword ptr [rsp+270h+dst+8], xmm6
    }
    if ( enabled )
    {
      AnglesToQuat(&_RSI->weapMoveAnglesCategorized[1], &v147);
      __asm { vmovaps xmm2, xmm7; frac }
      QuatSlerp(&quat_identity, &v147, *(float *)&_XMM2, &quat);
      QuatToAngles(&quat, &v155);
      AnglesToQuat(&_RSI->weapMoveAnglesCategorized[2], &quat);
      __asm { vmovaps xmm2, xmm7; frac }
      QuatSlerp(&quat_identity, &quat, *(float *)&_XMM2, &v147);
      QuatToAngles(&v147, &v156);
      AnglesToQuat(&_RSI->weapMoveAnglesCategorized[9], &quat);
      __asm { vmovaps xmm2, xmm7; frac }
      QuatSlerp(&quat_identity, &quat, *(float *)&_XMM2, &v147);
      QuatToAngles(&v147, &v157);
      AnglesToQuat(&_RSI->weapMoveAnglesCategorized[11], &quat);
      __asm { vmovaps xmm2, xmm7; frac }
      QuatSlerp(&quat_identity, &quat, *(float *)&_XMM2, &v147);
      QuatToAngles(&v147, &v158);
      AnglesToQuat(&_RSI->weapMoveAnglesCategorized[16], &quat);
      __asm { vmovaps xmm2, xmm7; frac }
      QuatSlerp(&quat_identity, &quat, *(float *)&_XMM2, &v147);
      QuatToAngles(&v147, (vec3_t *)&result);
      AnglesToQuat(*(const vec3_t **)pivotPoint.v, &quat);
      __asm { vmovaps xmm2, xmm7; frac }
      QuatSlerp(&quat_identity, &quat, *(float *)&_XMM2, &v147);
      QuatToAngles(&v147, &v159);
    }
    else
    {
      _RAX = *(_QWORD *)pivotPoint.v;
      __asm
      {
        vmovss  xmm0, dword ptr [rsi+30h]
        vmovss  xmm1, dword ptr [rsi+34h]
        vmovss  dword ptr [rbp+170h+var_188], xmm0
        vmovss  xmm0, dword ptr [rsi+38h]
        vmovss  dword ptr [rbp+170h+var_188+4], xmm1
        vmovss  xmm1, dword ptr [rsi+3Ch]
        vmovss  dword ptr [rbp+170h+var_188+8], xmm0
        vmovss  xmm0, dword ptr [rsi+40h]
        vmovss  dword ptr [rbp+170h+var_178], xmm1
        vmovss  xmm1, dword ptr [rsi+44h]
        vmovss  dword ptr [rbp+170h+var_178+4], xmm0
        vmovss  xmm0, dword ptr [rsi+90h]
        vmovss  dword ptr [rbp+170h+var_178+8], xmm1
        vmovss  xmm1, dword ptr [rsi+94h]
        vmovss  dword ptr [rbp+170h+var_168], xmm0
        vmovss  xmm0, dword ptr [rsi+98h]
        vmovss  dword ptr [rbp+170h+var_168+4], xmm1
        vmovss  xmm1, dword ptr [rsi+0A8h]
        vmovss  dword ptr [rbp+170h+var_168+8], xmm0
        vmovss  xmm0, dword ptr [rsi+0ACh]
        vmovss  dword ptr [rbp+170h+var_158], xmm1
        vmovss  xmm1, dword ptr [rsi+0B0h]
        vmovss  dword ptr [rbp+170h+var_158+4], xmm0
        vmovss  xmm0, dword ptr [rsi+0E4h]
        vmovss  dword ptr [rbp+170h+var_158+8], xmm1
        vmovss  xmm1, dword ptr [rsi+0E8h]
        vmovss  dword ptr [rbp+170h+result], xmm0
        vmovss  xmm0, dword ptr [rsi+0ECh]
        vmovss  dword ptr [rbp+170h+result+4], xmm1
        vmovss  xmm1, dword ptr [rax]
        vmovss  dword ptr [rbp+170h+result+8], xmm0
        vmovss  xmm0, dword ptr [rax+4]
        vmovss  dword ptr [rbp+170h+var_148], xmm1
        vmovss  xmm1, dword ptr [rax+8]
        vmovss  dword ptr [rbp+170h+var_148+4], xmm0
        vmovss  dword ptr [rbp+170h+var_148+8], xmm1
      }
    }
    __asm
    {
      vmovss  xmm7, cs:__real@358637bd
      vmovaps xmm2, xmm7; epsilon
      vmovss  dword ptr [rsp+270h+pivotPoint], xmm6
      vmovss  dword ptr [rsp+270h+pivotPoint+4], xmm6
      vmovss  dword ptr [rsp+270h+pivotPoint+8], xmm6
    }
    if ( !VecNCompareCustomEpsilon(v155.v, pivotPoint.v, *(float *)&_XMM2, 3) )
    {
      AnglesToAxis(&v155, &rotation);
      RotatePointAroundPoint(&dst, &dst, &_RSI->weapStandAnglesPivotOffset, &rotation);
    }
    __asm
    {
      vmovaps xmm2, xmm7; epsilon
      vmovss  dword ptr [rsp+270h+pivotPoint], xmm6
      vmovss  dword ptr [rsp+270h+pivotPoint+4], xmm6
      vmovss  dword ptr [rsp+270h+pivotPoint+8], xmm6
    }
    if ( !VecNCompareCustomEpsilon(v156.v, pivotPoint.v, *(float *)&_XMM2, 3) )
    {
      AnglesToAxis(&v156, &rotation);
      RotatePointAroundPoint(&dst, &dst, &_RSI->weapDuckedAnglesPivotOffset, &rotation);
    }
    __asm
    {
      vmovss  xmm0, dword ptr [rsi+18Ch]
      vmovaps xmm2, xmm7; epsilon
      vmovss  dword ptr [rsp+270h+var_220], xmm0
      vmovss  dword ptr [rsp+270h+var_220+4], xmm6
      vmovss  dword ptr [rsp+270h+var_220+8], xmm6
      vmovss  dword ptr [rsp+270h+pivotPoint], xmm6
      vmovss  dword ptr [rsp+270h+pivotPoint+4], xmm6
      vmovss  dword ptr [rsp+270h+pivotPoint+8], xmm6
    }
    if ( !VecNCompareCustomEpsilon(v157.v, pivotPoint.v, *(float *)&_XMM2, 3) )
    {
      AnglesToAxis(&v157, &rotation);
      RotatePointAroundPoint(&dst, &dst, (const vec3_t *)&v147, &rotation);
    }
    __asm
    {
      vmovss  xmm0, dword ptr [rsi+190h]
      vmovaps xmm2, xmm7; epsilon
      vmovss  dword ptr [rsp+270h+pivotPoint], xmm0
      vmovss  dword ptr [rsp+270h+pivotPoint+4], xmm6
      vmovss  dword ptr [rsp+270h+pivotPoint+8], xmm6
      vmovss  dword ptr [rsp+270h+var_220], xmm6
      vmovss  dword ptr [rsp+270h+var_220+4], xmm6
      vmovss  dword ptr [rsp+270h+var_220+8], xmm6
    }
    if ( !VecNCompareCustomEpsilon(v158.v, v147.v, *(float *)&_XMM2, 3) )
    {
      AnglesToAxis(&v158, &rotation);
      RotatePointAroundPoint(&dst, &dst, &pivotPoint, &rotation);
    }
    __asm
    {
      vmovss  xmm0, [rbp+170h+springTiltOffset]
      vmovaps xmm2, xmm7; epsilon
      vmovss  dword ptr [rsp+270h+pivotPoint], xmm0
      vmovss  dword ptr [rsp+270h+pivotPoint+4], xmm6
      vmovss  dword ptr [rsp+270h+pivotPoint+8], xmm6
      vmovss  dword ptr [rsp+270h+var_220], xmm6
      vmovss  dword ptr [rsp+270h+var_220+4], xmm6
      vmovss  dword ptr [rsp+270h+var_220+8], xmm6
    }
    if ( !VecNCompareCustomEpsilon(v159.v, v147.v, *(float *)&_XMM2, 3) )
    {
      AnglesToAxis(&v159, &rotation);
      RotatePointAroundPoint(&dst, &dst, &pivotPoint, &rotation);
    }
    __asm
    {
      vmovaps xmm2, xmm7; epsilon
      vmovss  dword ptr [rsp+270h+var_220], xmm6
      vmovss  dword ptr [rsp+270h+var_220+4], xmm6
      vmovss  dword ptr [rsp+270h+var_220+8], xmm6
    }
    if ( !VecNCompareCustomEpsilon(result.v, v147.v, *(float *)&_XMM2, 3) )
    {
      AnglesToAxis((const vec3_t *)&result, &rotation);
      RotatePointAroundPoint(&dst, &dst, &_RSI->weapVmMotionPivotOffset, &rotation);
    }
    __asm
    {
      vmovss  xmm7, dword ptr [rsp+270h+dst+4]
      vmovss  xmm6, dword ptr [rsp+270h+dst]
      vmovss  xmm5, dword ptr [rsp+270h+dst+8]
    }
    _RAX = *(_QWORD *)center.v;
    __asm
    {
      vmulss  xmm2, xmm7, dword ptr [rbp+170h+axis+0Ch]
      vmulss  xmm0, xmm6, dword ptr [rbp+170h+axis]
      vmulss  xmm1, xmm5, dword ptr [rbp+170h+axis+1Ch]
      vaddss  xmm3, xmm2, xmm0
      vmulss  xmm0, xmm5, dword ptr [rbp+170h+axis+18h]
      vaddss  xmm2, xmm3, xmm0
      vaddss  xmm3, xmm2, dword ptr [r13+0]
      vmulss  xmm2, xmm6, dword ptr [rbp+170h+axis+4]
      vmovss  dword ptr [rax], xmm3
      vmulss  xmm3, xmm7, dword ptr [rbp+170h+axis+10h]
      vaddss  xmm4, xmm3, xmm2
      vaddss  xmm2, xmm4, xmm1
      vaddss  xmm3, xmm2, dword ptr [r13+4]
      vmulss  xmm2, xmm6, dword ptr [rbp+170h+axis+8]
      vmulss  xmm1, xmm5, dword ptr [rbp+170h+axis+20h]
      vmovss  dword ptr [rax+4], xmm3
      vmulss  xmm3, xmm7, dword ptr [rbp+170h+axis+14h]
      vaddss  xmm4, xmm3, xmm2
      vaddss  xmm2, xmm4, xmm1
      vaddss  xmm3, xmm2, dword ptr [r13+8]
      vmovss  dword ptr [rax+8], xmm3
    }
    v92 = DCONST_DVARBOOL_duckedRotationPivotDebug;
    if ( !DCONST_DVARBOOL_duckedRotationPivotDebug && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "duckedRotationPivotDebug") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v92);
    if ( v92->current.enabled )
    {
      _RBX = &_RSI->weapDuckedAnglesPivotOffset;
      if ( &_RSI->weapDuckedAnglesPivotOffset == &center && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_math.h", 470, ASSERT_TYPE_SANITY, "( &in1 != &out )", (const char *)&queryFormat, "&in1 != &out") )
        __debugbreak();
      __asm
      {
        vmovss  xmm6, dword ptr [rbx+4]
        vmovss  xmm5, dword ptr [rbx]
        vmovss  xmm7, dword ptr [rbx+8]
        vmulss  xmm3, xmm5, dword ptr [rbp+170h+axis]
        vmulss  xmm2, xmm6, dword ptr [rbp+170h+axis+0Ch]
        vmulss  xmm1, xmm7, dword ptr [rbp+170h+axis+18h]
        vaddss  xmm4, xmm3, xmm2
        vaddss  xmm2, xmm4, xmm1
        vaddss  xmm3, xmm2, dword ptr [r13+0]
        vmulss  xmm2, xmm6, dword ptr [rbp+170h+axis+10h]
        vmulss  xmm4, xmm5, dword ptr [rbp+170h+axis+4]
        vmulss  xmm1, xmm7, dword ptr [rbp+170h+axis+1Ch]
        vmovss  dword ptr [rbp+170h+center], xmm3
        vaddss  xmm3, xmm4, xmm2
        vmulss  xmm4, xmm5, dword ptr [rbp+170h+axis+8]
        vaddss  xmm2, xmm3, xmm1
        vaddss  xmm3, xmm2, dword ptr [r13+4]
        vmulss  xmm2, xmm6, dword ptr [rbp+170h+axis+14h]
        vmulss  xmm1, xmm7, dword ptr [rbp+170h+axis+20h]
        vmovss  dword ptr [rbp+170h+center+4], xmm3
        vaddss  xmm3, xmm4, xmm2
        vaddss  xmm2, xmm3, xmm1
        vaddss  xmm3, xmm2, dword ptr [r13+8]
        vmovss  xmm1, cs:dword_147FA82CC; radius
        vmovss  dword ptr [rbp+170h+center+8], xmm3
      }
      CG_DebugSphere(&center, *(float *)&_XMM1, &colorRed, 1, 0);
    }
    v116 = DCONST_DVARBOOL_advancedSwayDebug;
    if ( !DCONST_DVARBOOL_advancedSwayDebug && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "advancedSwayDebug") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v116);
    if ( v116->current.enabled )
    {
      v117 = DCONST_DVARBOOL_advancedSwayGunDirEnabled;
      if ( !DCONST_DVARBOOL_advancedSwayGunDirEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "advancedSwayGunDirEnabled") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v117);
      if ( v117->current.enabled )
      {
        _RBX = &_RSI->weapVmMotionPivotOffset;
        if ( &_RSI->weapVmMotionPivotOffset == &center && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_math.h", 470, ASSERT_TYPE_SANITY, "( &in1 != &out )", (const char *)&queryFormat, "&in1 != &out") )
          __debugbreak();
        __asm
        {
          vmovss  xmm6, dword ptr [rbx+4]
          vmovss  xmm5, dword ptr [rbx]
          vmovss  xmm7, dword ptr [rbx+8]
          vmulss  xmm3, xmm5, dword ptr [rbp+170h+axis]
          vmulss  xmm2, xmm6, dword ptr [rbp+170h+axis+0Ch]
          vmulss  xmm1, xmm7, dword ptr [rbp+170h+axis+18h]
          vaddss  xmm4, xmm3, xmm2
          vaddss  xmm2, xmm4, xmm1
          vaddss  xmm3, xmm2, dword ptr [r13+0]
          vmulss  xmm2, xmm6, dword ptr [rbp+170h+axis+10h]
          vmulss  xmm4, xmm5, dword ptr [rbp+170h+axis+4]
          vmulss  xmm1, xmm7, dword ptr [rbp+170h+axis+1Ch]
          vmovss  dword ptr [rbp+170h+center], xmm3
          vaddss  xmm3, xmm4, xmm2
          vmulss  xmm4, xmm5, dword ptr [rbp+170h+axis+8]
          vaddss  xmm2, xmm3, xmm1
          vaddss  xmm3, xmm2, dword ptr [r13+4]
          vmulss  xmm2, xmm6, dword ptr [rbp+170h+axis+14h]
          vmulss  xmm1, xmm7, dword ptr [rbp+170h+axis+20h]
          vmovss  dword ptr [rbp+170h+center+4], xmm3
          vaddss  xmm3, xmm4, xmm2
          vaddss  xmm2, xmm3, xmm1
          vaddss  xmm3, xmm2, dword ptr [r13+8]
          vmovss  xmm1, cs:dword_147FA82CC; radius
          vmovss  dword ptr [rbp+170h+center+8], xmm3
        }
        CG_DebugSphere(&center, *(float *)&_XMM1, &colorBlue, 1, 0);
      }
    }
  }
  else
  {
    p_weaponState = &cgameGlob->predictedPlayerState.weapState[0].weaponState;
    v31 = 0x800000001020i64;
    while ( 1 )
    {
      v32 = *p_weaponState;
      if ( (unsigned int)v32 <= 0x2F )
      {
        if ( _bittest64(&v31, v32) )
          break;
      }
      ++v29;
      p_weaponState += 20;
      WeaponHand = BG_PlayerLastWeaponHand(v28, &cgameGlob->predictedPlayerState);
      v31 = 0x800000001020i64;
      if ( v29 > WeaponHand )
        goto LABEL_23;
    }
  }
  Instance = CgWeaponMap::GetInstance((const LocalClientNum_t)cgameGlob->localClientNum);
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(Instance, &cgameGlob->predictedPlayerState);
  v143 = BG_UsingAlternate(&cgameGlob->predictedPlayerState);
  BG_GetWeaponAnglesForShootingDirection(Instance, &cgameGlob->predictedPlayerState, CurrentWeaponForPlayer, v143, (const vec3_t (*)[30])_RSI->weapMoveAnglesCategorized, &localGunAngles);
  AnglesToAxis(&localGunAngles, &v164);
  MatrixMultiply(&v164, &axis, &v165);
  AxisToAngles(&v165, outGunAngles);
  CG_Weapons_PrintWeaponShootingAngles(cgameGlob, &cgameGlob->baseGunAngles, &localGunAngles, outGunAngles);
  __asm
  {
    vmovaps xmm6, [rsp+270h+var_40]
    vmovaps xmm7, [rsp+270h+var_50]
  }
}

/*
==============
CG_CalculateWeaponMovement_FovCompensation
==============
*/
void CG_CalculateWeaponMovement_FovCompensation(const cg_t *cgameGlob, vec3_t *origin)
{
  const dvar_t *v8; 
  const CameraDef *Def; 
  const dvar_t *v10; 
  const dvar_t *v13; 
  const dvar_t *v15; 

  _RSI = origin;
  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13735, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  v8 = DVARBOOL_cg_disable_fov_comp;
  if ( !DVARBOOL_cg_disable_fov_comp && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_disable_fov_comp") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v8);
  if ( !v8->current.enabled )
  {
    Def = CG_Camera_Active_TryGetDef(cgameGlob->localClientNum);
    if ( !Def || Def->profile || !Def->firstPerson.disableFOVWeaponOffset )
    {
      __asm
      {
        vmovaps [rsp+78h+var_18], xmm6
        vmovaps [rsp+78h+var_28], xmm7
        vmovaps [rsp+78h+var_38], xmm8
      }
      *(double *)&_XMM0 = CG_View_CalcFovCompensation(cgameGlob);
      v10 = DCONST_DVARFLT_cg_gun_fovcomp_x;
      __asm { vmovaps xmm6, xmm0 }
      if ( !DCONST_DVARFLT_cg_gun_fovcomp_x && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_gun_fovcomp_x") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v10);
      __asm { vmulss  xmm8, xmm6, dword ptr [rbx+28h] }
      v13 = DCONST_DVARFLT_cg_gun_fovcomp_y;
      if ( !DCONST_DVARFLT_cg_gun_fovcomp_y && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_gun_fovcomp_y") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v13);
      __asm { vmulss  xmm7, xmm6, dword ptr [rbx+28h] }
      v15 = DCONST_DVARFLT_cg_gun_fovcomp_z;
      if ( !DCONST_DVARFLT_cg_gun_fovcomp_z && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_gun_fovcomp_z") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v15);
      __asm { vmulss  xmm6, xmm6, dword ptr [rbx+28h] }
      cg_t::GetViewModelTransform((cg_t *)cgameGlob);
      __asm
      {
        vmulss  xmm0, xmm8, dword ptr [rax]
        vaddss  xmm2, xmm0, dword ptr [rsi]
        vmovss  dword ptr [rsi], xmm2
        vmulss  xmm0, xmm8, dword ptr [rax+4]
        vaddss  xmm3, xmm0, dword ptr [rsi+4]
        vmovss  dword ptr [rsi+4], xmm3
        vmulss  xmm0, xmm8, dword ptr [rax+8]
        vaddss  xmm1, xmm0, dword ptr [rsi+8]
        vmovaps xmm8, [rsp+78h+var_38]
        vmovss  dword ptr [rsi+8], xmm1
        vmulss  xmm0, xmm7, dword ptr [rax+0Ch]
        vaddss  xmm2, xmm0, xmm2
        vmovss  dword ptr [rsi], xmm2
        vmulss  xmm0, xmm7, dword ptr [rax+10h]
        vaddss  xmm3, xmm0, xmm3
        vmovss  dword ptr [rsi+4], xmm3
        vmulss  xmm0, xmm7, dword ptr [rax+14h]
        vmovaps xmm7, [rsp+78h+var_28]
        vaddss  xmm4, xmm0, xmm1
        vmovss  dword ptr [rsi+8], xmm4
        vmulss  xmm0, xmm6, dword ptr [rax+18h]
        vaddss  xmm1, xmm0, xmm2
        vmovss  dword ptr [rsi], xmm1
        vmulss  xmm0, xmm6, dword ptr [rax+1Ch]
        vaddss  xmm1, xmm0, xmm3
        vmovss  dword ptr [rsi+4], xmm1
        vmulss  xmm0, xmm6, dword ptr [rax+20h]
        vmovaps xmm6, [rsp+78h+var_18]
        vaddss  xmm1, xmm0, xmm4
        vmovss  dword ptr [rsi+8], xmm1
      }
    }
  }
}

/*
==============
CG_CalculateWeaponMovement_GetAdsOffset
==============
*/
void CG_CalculateWeaponMovement_GetAdsOffset(const cg_t *cgameGlob, const vec4_t *orient, bool isAlternate, vec3_t *offset)
{
  __int64 localClientNum; 
  CgWeaponMap *v14; 
  char v18; 
  char v19; 
  bool AdsAlign; 
  const DObj *viewModelDObj; 
  unsigned __int8 v112; 
  unsigned __int8 inOutIndex; 
  unsigned __int8 v114; 
  bool outDisableTagAlignX; 
  int modelIndex; 
  AdsOffsetInterpolationType lerpType; 
  AdsOffsetInterpolationType outAlignmentLerpType; 
  tmat33_t<vec3_t> axis; 
  vec3_t outAdsAlignOffset; 
  DObjAnimMat v121; 
  Weapon r_weapon; 
  DObjAnimMat v123; 
  DObjAnimMat outMat; 

  __asm { vmovaps [rsp+1D0h+var_50], xmm6 }
  _R14 = cgameGlob;
  _RSI = offset;
  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13765, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  *(_QWORD *)_RSI->v = 0i64;
  _RSI->v[2] = 0.0;
  localClientNum = _R14->localClientNum;
  if ( !CgWeaponMap::ms_instance[localClientNum] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v14 = CgWeaponMap::ms_instance[localClientNum];
  __asm
  {
    vmovss  xmm6, dword ptr [r14+738h]
    vmovaps [rsp+1D0h+var_70], xmm9
  }
  if ( BG_IsUsingOffhandGestureWeaponADSSupport(v14, &_R14->predictedPlayerState) )
  {
    *(double *)&_XMM0 = BG_GetOffhandAdsFrac(&_R14->predictedPlayerState);
    __asm
    {
      vxorps  xmm9, xmm9, xmm9
      vcomiss xmm0, xmm9
      vmovaps xmm6, xmm0
    }
    if ( !(v18 | v19) )
    {
      _RAX = BG_GetOffhandGestureWeapon(v14, &_R14->predictedPlayerState);
      __asm
      {
        vmovups ymm1, ymmword ptr [rax]
        vmovups ymmword ptr [rbp+0D0h+r_weapon.weaponIdx], ymm1
        vmovups xmm2, xmmword ptr [rax+20h]
        vmovups xmmword ptr [rbp+0D0h+r_weapon.attachmentVariationIndices+5], xmm2
        vmovsd  xmm0, qword ptr [rax+30h]
        vmovsd  qword ptr [rbp+0D0h+r_weapon.attachmentVariationIndices+15h], xmm0
      }
      *(_DWORD *)&r_weapon.weaponCamo = *(_DWORD *)&_RAX->weaponCamo;
      _R13 = &_R14->scopeToggleInfo.fractionInfo;
      __asm
      {
        vmovaps [rsp+1D0h+var_60], xmm8
        vmovaps [rsp+1D0h+var_80], xmm10
      }
      outDisableTagAlignX = 0;
      AdsAlign = BG_GetAdsAlign(v14, &_R14->predictedPlayerState, &r_weapon, isAlternate, &_R14->scopeToggleInfo.fractionInfo, &outAdsAlignOffset, &lerpType, &outAlignmentLerpType, &outDisableTagAlignX);
      __asm { vmovaps xmm0, xmm6; weaponPosFrac }
      *(double *)&_XMM0 = BG_CalculateEaseMotionFactor(*(const float *)&_XMM0, lerpType);
      __asm
      {
        vmovaps xmm8, xmm0
        vmovaps xmm0, xmm6; weaponPosFrac
      }
      *(double *)&_XMM0 = BG_CalculateEaseMotionFactor(*(const float *)&_XMM0, outAlignmentLerpType);
      __asm { vmovaps xmm10, xmm0 }
      QuatToAxis(orient, &axis);
      __asm
      {
        vmovss  xmm6, dword ptr [rbp+0D0h+var_148+4]
        vmovss  xmm5, dword ptr [rbp+0D0h+var_148+8]
        vmovss  xmm1, dword ptr [rsp+1D0h+axis]
        vmulss  xmm3, xmm1, dword ptr [rbp+0D0h+var_148]
        vmulss  xmm1, xmm6, dword ptr [rsp+1D0h+axis+0Ch]
        vmulss  xmm2, xmm5, dword ptr [rsp+1D0h+axis+18h]
        vmovss  xmm0, dword ptr [rsp+1D0h+axis+4]
        vmulss  xmm4, xmm0, dword ptr [rbp+0D0h+var_148]
        vmovss  xmm0, dword ptr [rsp+1D0h+axis+8]
        vaddss  xmm3, xmm3, xmm1
        vaddss  xmm1, xmm3, xmm2
        vmulss  xmm2, xmm6, dword ptr [rsp+1D0h+axis+10h]
        vmulss  xmm3, xmm1, xmm8
        vmulss  xmm1, xmm5, dword ptr [rsp+1D0h+axis+1Ch]
        vmovss  dword ptr [rsi], xmm3
        vaddss  xmm3, xmm4, xmm2
        vmulss  xmm4, xmm0, dword ptr [rbp+0D0h+var_148]
        vaddss  xmm2, xmm3, xmm1
        vmulss  xmm1, xmm5, dword ptr [rbp+0D0h+axis+20h]
        vmulss  xmm3, xmm2, xmm8
        vmulss  xmm2, xmm6, dword ptr [rsp+1D0h+axis+14h]
        vmovss  dword ptr [rsi+4], xmm3
        vaddss  xmm3, xmm4, xmm2
        vaddss  xmm2, xmm3, xmm1
        vmulss  xmm3, xmm2, xmm8
        vmovaps xmm8, [rsp+1D0h+var_60]
        vmovss  dword ptr [rsi+8], xmm3
      }
      if ( AdsAlign )
      {
        viewModelDObj = _R14->m_weaponHand[0].viewModelDObj;
        if ( !viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13827, ASSERT_TYPE_ASSERT, "(viewModelDobj)", (const char *)&queryFormat, "viewModelDobj") )
          __debugbreak();
        inOutIndex = -2;
        DObjGetBoneIndexInternal_66(viewModelDObj, scr_const.tag_align_gun, &inOutIndex, &modelIndex);
        if ( inOutIndex <= 0xFDu )
        {
          v112 = -2;
          v114 = -2;
          DObjGetBoneIndexInternal_66(viewModelDObj, scr_const.tag_reticle_attach, &v112, &modelIndex);
          if ( BG_CanHybridToggle(&_R14->predictedPlayerState, &r_weapon, isAlternate) )
            DObjGetBoneIndexInternal_66(viewModelDObj, scr_const.tag_reticle_attach2, &v114, &modelIndex);
          if ( v112 <= 0xFDu )
          {
            DObjGetBasePoseMatrix(viewModelDObj, inOutIndex, &outMat);
            if ( v114 > 0xFDu )
            {
              DObjGetBasePoseMatrix(viewModelDObj, v112, &v121);
              __asm
              {
                vmovss  xmm5, dword ptr [rbp+0D0h+var_130.trans]
                vmovss  xmm4, dword ptr [rbp+0D0h+var_130.trans+4]
                vmovss  xmm2, dword ptr [rbp+0D0h+var_130.trans+8]
              }
            }
            else
            {
              __asm
              {
                vmovss  xmm0, dword ptr [r13+0]
                vsubss  xmm0, xmm0, cs:__real@3f000000
                vmulss  xmm0, xmm0, cs:__real@40490fdb; X
              }
              *(float *)&_XMM0 = sinf_0(*(float *)&_XMM0);
              __asm
              {
                vaddss  xmm1, xmm0, cs:__real@3f800000
                vmulss  xmm6, xmm1, cs:__real@3f000000
              }
              DObjGetBasePoseMatrix(viewModelDObj, v112, &v123);
              DObjGetBasePoseMatrix(viewModelDObj, v114, &v121);
              __asm
              {
                vmovss  xmm0, dword ptr [rbp+0D0h+var_130.trans]
                vsubss  xmm1, xmm0, dword ptr [rbp+0D0h+var_D0.trans]
                vmovss  xmm0, dword ptr [rbp+0D0h+var_130.trans+4]
                vmulss  xmm2, xmm1, xmm6
                vsubss  xmm1, xmm0, dword ptr [rbp+0D0h+var_D0.trans+4]
                vaddss  xmm5, xmm2, dword ptr [rbp+0D0h+var_D0.trans]
                vmovss  xmm0, dword ptr [rbp+0D0h+var_130.trans+8]
                vmulss  xmm2, xmm1, xmm6
                vaddss  xmm4, xmm2, dword ptr [rbp+0D0h+var_D0.trans+4]
                vsubss  xmm1, xmm0, dword ptr [rbp+0D0h+var_D0.trans+8]
                vmulss  xmm2, xmm1, xmm6
                vaddss  xmm2, xmm2, dword ptr [rbp+0D0h+var_D0.trans+8]
              }
            }
            __asm
            {
              vmovss  xmm0, dword ptr [rbp+0D0h+outMat.trans]
              vmovss  xmm1, dword ptr [rbp+0D0h+outMat.trans+4]
              vsubss  xmm3, xmm0, xmm5
              vmovss  xmm0, dword ptr [rbp+0D0h+outMat.trans+8]
              vsubss  xmm6, xmm0, xmm2
              vsubss  xmm5, xmm1, xmm4
            }
            _EAX = 0;
            __asm { vmovd   xmm1, eax }
            _EAX = outDisableTagAlignX;
            __asm
            {
              vmovd   xmm0, eax
              vpcmpeqd xmm2, xmm0, xmm1
              vmulss  xmm0, xmm5, dword ptr [rsp+1D0h+axis+0Ch]
              vblendvps xmm4, xmm9, xmm3, xmm2
              vmulss  xmm1, xmm4, dword ptr [rsp+1D0h+axis]
              vaddss  xmm2, xmm1, xmm0
              vmulss  xmm1, xmm6, dword ptr [rsp+1D0h+axis+18h]
              vaddss  xmm2, xmm2, xmm1
              vmulss  xmm1, xmm4, dword ptr [rsp+1D0h+axis+4]
              vmulss  xmm0, xmm2, xmm10
              vaddss  xmm3, xmm0, dword ptr [rsi]
              vmulss  xmm0, xmm5, dword ptr [rsp+1D0h+axis+10h]
              vaddss  xmm2, xmm1, xmm0
              vmulss  xmm1, xmm6, dword ptr [rsp+1D0h+axis+1Ch]
              vaddss  xmm2, xmm2, xmm1
              vmulss  xmm1, xmm4, dword ptr [rsp+1D0h+axis+8]
              vmulss  xmm0, xmm2, xmm10
              vmovss  dword ptr [rsi], xmm3
              vaddss  xmm3, xmm0, dword ptr [rsi+4]
              vmulss  xmm0, xmm5, dword ptr [rsp+1D0h+axis+14h]
              vaddss  xmm2, xmm1, xmm0
              vmulss  xmm1, xmm6, dword ptr [rbp+0D0h+axis+20h]
              vaddss  xmm2, xmm2, xmm1
              vmulss  xmm0, xmm2, xmm10
              vmovss  dword ptr [rsi+4], xmm3
              vaddss  xmm3, xmm0, dword ptr [rsi+8]
              vmovss  dword ptr [rsi+8], xmm3
            }
          }
        }
      }
      __asm { vmovaps xmm10, [rsp+1D0h+var_80] }
    }
  }
  else
  {
    __asm
    {
      vxorps  xmm9, xmm9, xmm9
      vcomiss xmm6, xmm9
    }
  }
  __asm
  {
    vmovaps xmm9, [rsp+1D0h+var_70]
    vmovaps xmm6, [rsp+1D0h+var_50]
  }
}

/*
==============
CG_CalculateWeaponMovement_GetFOVXOffset
==============
*/

float __fastcall CG_CalculateWeaponMovement_GetFOVXOffset(const cg_t *cgameGlob, double _XMM1_8)
{
  __int64 localClientNum; 
  CgWeaponMap *v12; 
  const Weapon *ViewmodelOrOffhandADSSupportWeapon; 
  const Weapon *v15; 
  bool IsUsingOffhandGestureWeaponADSSupport; 
  char v17; 
  bool v18; 
  CgWeaponMap *Instance; 
  bool v23; 
  bool v29; 
  CgHandler *Handler; 
  bool outIsAlternate; 
  float adsZoomInFrac; 
  float adsZoomOutFrac; 
  BgAdsZoomInfo outZoomInfo; 
  char v59; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-28h], xmm6
    vmovaps xmmword ptr [rax-38h], xmm7
  }
  _RSI = cgameGlob;
  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13927, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  localClientNum = _RSI->localClientNum;
  if ( !CgWeaponMap::ms_instance[localClientNum] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v12 = CgWeaponMap::ms_instance[localClientNum];
  ViewmodelOrOffhandADSSupportWeapon = BG_GetViewmodelOrOffhandADSSupportWeapon(v12, &_RSI->predictedPlayerState, &outIsAlternate);
  __asm { vmovss  xmm7, dword ptr [rsi+7C64Ch] }
  v15 = ViewmodelOrOffhandADSSupportWeapon;
  IsUsingOffhandGestureWeaponADSSupport = BG_IsUsingOffhandGestureWeaponADSSupport(v12, &_RSI->predictedPlayerState);
  v17 = 0;
  v18 = !IsUsingOffhandGestureWeaponADSSupport;
  if ( IsUsingOffhandGestureWeaponADSSupport )
  {
    *(double *)&_XMM0 = BG_GetOffhandAdsFrac(&_RSI->predictedPlayerState);
    __asm { vmovaps xmm7, xmm0 }
  }
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vcomiss xmm7, xmm6
    vmovaps [rsp+118h+var_48], xmm8
    vmovaps [rsp+118h+var_58], xmm9
  }
  if ( v17 | v18 )
    goto LABEL_28;
  __asm
  {
    vmovss  xmm8, cs:__real@3f800000
    vcomiss xmm7, xmm8
  }
  if ( v17 )
  {
    Instance = CgWeaponMap::GetInstance((const LocalClientNum_t)_RSI->localClientNum);
    if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_STILL_LAND|WEAPON_FIRING) || !BG_IsThirdPersonMode(Instance, &_RSI->predictedPlayerState) || BG_UsingSniperScope(Instance, &_RSI->predictedPlayerState) )
    {
      v23 = BG_UsingAlternate(&_RSI->predictedPlayerState);
      BG_GetADSZoomInFracs(Instance, &_RSI->predictedPlayerState, v15, v23, 1, &adsZoomInFrac, &adsZoomOutFrac);
      if ( _RSI->playerEntity.bPositionToADS )
        __asm { vmovss  xmm2, [rsp+118h+var_D4] }
      else
        __asm { vmovss  xmm2, [rsp+118h+var_D0] }
      __asm { vcomiss xmm2, xmm6 }
      if ( !_RSI->playerEntity.bPositionToADS )
        goto LABEL_28;
      __asm
      {
        vsubss  xmm0, xmm8, xmm2
        vsubss  xmm1, xmm7, xmm0
        vdivss  xmm7, xmm1, xmm2
      }
    }
    __asm
    {
      vmovaps xmm2, xmm8; max
      vxorps  xmm1, xmm1, xmm1; min
      vmovaps xmm0, xmm7; val
    }
    *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
    __asm
    {
      vcomiss xmm0, xmm6
      vmovaps xmm9, xmm0
    }
    if ( !(v17 | v18) )
      goto LABEL_21;
LABEL_28:
    __asm { vxorps  xmm0, xmm0, xmm0 }
    goto LABEL_29;
  }
  __asm { vmovaps xmm9, xmm8 }
LABEL_21:
  __asm
  {
    vmovaps [rsp+118h+var_68], xmm10
    vmovaps [rsp+118h+var_78], xmm11
  }
  if ( BG_ADSReloadEnabled(v12, &_RSI->predictedPlayerState, v15, outIsAlternate) )
  {
    *(double *)&_XMM0 = BG_WeaponReloadingFraction(v12, &_RSI->predictedPlayerState);
    __asm { vmovaps xmm10, xmm0 }
  }
  else
  {
    __asm { vxorps  xmm10, xmm10, xmm10 }
  }
  v29 = outIsAlternate;
  Handler = CgHandler::getHandler(_RSI->localClientNum);
  *(double *)&_XMM0 = BG_ADSReloadFovXOffset(Handler, &_RSI->predictedPlayerState, v15, v29);
  memset(&outZoomInfo, 0, sizeof(outZoomInfo));
  __asm { vmovaps xmm11, xmm0 }
  BG_GetADSZoomInfo(v12, v15, outIsAlternate, &_RSI->scopeToggleInfo.fractionInfo, &outZoomInfo);
  __asm { vcomiss xmm6, dword ptr [rsi+0BA144h] }
  if ( v17 )
  {
    *(double *)&_XMM0 = BG_GetADSNVGFOVXOffset(v15, outIsAlternate);
    __asm { vmovaps xmm7, xmm0 }
  }
  else
  {
    __asm { vmovss  xmm7, [rsp+118h+outZoomInfo.zoomFovXOffset] }
  }
  __asm { vmovaps xmm0, xmm10; weaponPosFrac }
  *(double *)&_XMM0 = BG_CalculateEaseMotionFactor(*(const float *)&_XMM0, outZoomInfo.depthHackZoomLerpType);
  __asm
  {
    vmovaps xmm6, xmm0
    vmovaps xmm0, xmm9; weaponPosFrac
  }
  *(double *)&_XMM0 = BG_CalculateEaseMotionFactor(*(const float *)&_XMM0, outZoomInfo.depthHackZoomLerpType);
  __asm
  {
    vmovaps xmm10, [rsp+118h+var_68]
    vmovaps xmm3, xmm0
    vsubss  xmm0, xmm8, xmm6
    vmulss  xmm2, xmm0, xmm7
    vmulss  xmm1, xmm6, xmm11
    vmovaps xmm11, [rsp+118h+var_78]
    vaddss  xmm2, xmm2, xmm1
    vmulss  xmm0, xmm3, xmm2
  }
LABEL_29:
  __asm
  {
    vmovaps xmm9, [rsp+118h+var_58]
    vmovaps xmm8, [rsp+118h+var_48]
  }
  _R11 = &v59;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
  }
  return *(float *)&_XMM0;
}

/*
==============
CG_CalculateWeaponMovement_ProceduralAdsMovement
==============
*/
void CG_CalculateWeaponMovement_ProceduralAdsMovement(const cg_t *cgameGlob, const tmat43_t<vec3_t> *viewTransfrom, vec3_t *outOrigin, vec3_t *outAngles)
{
  __int64 localClientNum; 
  CgWeaponMap *v17; 
  const Weapon *ViewmodelWeapon; 
  bool v19; 
  const WeaponAttachment *HybridScopeEnablerAttachment; 
  __int64 WeaponAttachments; 
  char v27; 
  WeaponAttachment **v31; 
  WeaponAttachment *v32; 
  AttAdsMovement *adsMovement; 
  WeaponAttachment *outDataAttachment; 
  vec3_t *v85; 
  const tmat43_t<vec3_t> *v86; 
  playerState_s *p_predictedPlayerState; 
  vec3_t *v88; 
  WeaponAttachment *attachments[30]; 
  char v92; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
    vmovaps xmmword ptr [rax-88h], xmm10
    vmovaps xmmword ptr [rax-98h], xmm11
    vmovaps xmmword ptr [rax-0A8h], xmm12
    vmovaps xmmword ptr [rax-0B8h], xmm13
    vmovaps xmmword ptr [rax-0C8h], xmm14
  }
  _R13 = cgameGlob;
  v88 = outAngles;
  v85 = outOrigin;
  _R12 = outOrigin;
  v86 = viewTransfrom;
  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 14312, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  localClientNum = _R13->localClientNum;
  if ( !CgWeaponMap::ms_instance[localClientNum] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v17 = CgWeaponMap::ms_instance[localClientNum];
  p_predictedPlayerState = &_R13->predictedPlayerState;
  ViewmodelWeapon = BG_GetViewmodelWeapon(v17, &_R13->predictedPlayerState);
  v19 = BG_UsingAlternate(&_R13->predictedPlayerState);
  LOBYTE(v17) = BG_CanEquipWeapon(v17, &_R13->predictedPlayerState, ViewmodelWeapon);
  _RAX = BG_WeaponDef(ViewmodelWeapon, v19);
  __asm
  {
    vmovss  xmm12, dword ptr [rax+31Ch]
    vmovss  xmm13, dword ptr [rax+320h]
  }
  HybridScopeEnablerAttachment = NULL;
  WeaponAttachments = BG_GetWeaponAttachments(ViewmodelWeapon, v19, (const WeaponAttachment **)attachments);
  outDataAttachment = NULL;
  if ( (_BYTE)v17 )
    HybridScopeEnablerAttachment = BG_GetHybridScopeEnablerAttachment(ViewmodelWeapon, v19, (const WeaponAttachment **)&outDataAttachment);
  __asm
  {
    vmovss  xmm10, cs:__real@3f000000
    vmovss  xmm14, cs:__real@40490fdb
  }
  v27 = 0;
  __asm
  {
    vxorps  xmm11, xmm11, xmm11
    vxorps  xmm8, xmm8, xmm8
    vxorps  xmm9, xmm9, xmm9
  }
  if ( (_DWORD)WeaponAttachments )
  {
    __asm { vmovaps [rsp+228h+var_48], xmm6 }
    v31 = attachments;
    __asm { vmovaps [rsp+228h+var_58], xmm7 }
    do
    {
      v32 = *v31;
      if ( !*v31 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 14342, ASSERT_TYPE_ASSERT, "(weaponAttachment)", (const char *)&queryFormat, "weaponAttachment") )
        __debugbreak();
      _RAX = v32->adsMovement;
      if ( _RAX )
      {
        if ( v32 == HybridScopeEnablerAttachment && outDataAttachment && (adsMovement = outDataAttachment->adsMovement) != NULL )
        {
          __asm
          {
            vmovss  xmm0, dword ptr [r13+78064h]
            vcomiss xmm0, xmm11
            vsubss  xmm0, xmm0, xmm10
            vmulss  xmm0, xmm0, xmm14; X
          }
          *(float *)&_XMM0 = sinf_0(*(float *)&_XMM0);
          __asm
          {
            vmulss  xmm7, xmm0, xmm10
            vaddss  xmm6, xmm7, xmm10
          }
          if ( adsMovement->isOverride != HybridScopeEnablerAttachment->adsMovement->isOverride && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 14357, ASSERT_TYPE_ASSERT, "( hybridScopeReferenceAttachment->adsMovement->isOverride == hybridScopeEnablerAttachment->adsMovement->isOverride )", "ADS movement override/add flags must match between the hybrid enabling attachment and the referenced data attachment.") )
            __debugbreak();
          if ( v32->adsMovement->isOverride )
          {
            if ( !v27 )
            {
              v27 = 1;
              __asm
              {
                vsubss  xmm2, xmm10, xmm7
                vmulss  xmm1, xmm2, dword ptr [rdx]
                vmulss  xmm2, xmm2, dword ptr [rdx+4]
                vmulss  xmm0, xmm6, dword ptr [rcx]
                vaddss  xmm12, xmm1, xmm0
                vmulss  xmm0, xmm6, dword ptr [rcx+4]
                vaddss  xmm13, xmm2, xmm0
              }
            }
          }
          else
          {
            __asm
            {
              vsubss  xmm2, xmm10, xmm7
              vmulss  xmm1, xmm2, dword ptr [rdx]
              vmulss  xmm2, xmm2, dword ptr [rdx+4]
              vmulss  xmm0, xmm6, dword ptr [rcx]
              vaddss  xmm1, xmm1, xmm0
              vmulss  xmm0, xmm6, dword ptr [rcx+4]
              vaddss  xmm8, xmm8, xmm1
              vaddss  xmm1, xmm2, xmm0
              vaddss  xmm9, xmm9, xmm1
            }
          }
        }
        else if ( _RAX->isOverride )
        {
          if ( !v27 )
          {
            __asm
            {
              vmovss  xmm12, dword ptr [rax]
              vmovss  xmm13, dword ptr [rax+4]
            }
            v27 = 1;
          }
        }
        else
        {
          __asm
          {
            vaddss  xmm8, xmm8, dword ptr [rax]
            vaddss  xmm9, xmm9, dword ptr [rax+4]
          }
        }
      }
      ++v31;
      --WeaponAttachments;
    }
    while ( WeaponAttachments );
    _R12 = v85;
    __asm
    {
      vmovaps xmm7, [rsp+228h+var_58]
      vmovaps xmm6, [rsp+228h+var_48]
    }
  }
  _RAX = (__int64)p_predictedPlayerState;
  __asm
  {
    vmovss  xmm0, dword ptr [rax+730h]
    vsubss  xmm1, xmm0, xmm10
    vmulss  xmm0, xmm1, xmm14; X
  }
  *(float *)&_XMM0 = sinf_0(*(float *)&_XMM0);
  __asm { vaddss  xmm1, xmm0, cs:__real@3f800000 }
  _RAX = v88;
  __asm
  {
    vmulss  xmm4, xmm1, xmm10
    vaddss  xmm2, xmm8, xmm12
    vmulss  xmm3, xmm2, xmm4
    vmulss  xmm0, xmm3, dword ptr [r14]
    vaddss  xmm1, xmm0, dword ptr [r12]
    vmovss  dword ptr [r12], xmm1
    vmulss  xmm0, xmm3, dword ptr [r14+4]
    vaddss  xmm1, xmm0, dword ptr [r12+4]
    vmovss  dword ptr [r12+4], xmm1
    vmulss  xmm0, xmm3, dword ptr [r14+8]
    vaddss  xmm1, xmm0, dword ptr [r12+8]
    vmovss  dword ptr [r12+8], xmm1
    vaddss  xmm0, xmm9, xmm13
    vmulss  xmm1, xmm0, xmm4
    vaddss  xmm2, xmm1, dword ptr [rax+8]
    vmovss  dword ptr [rax+8], xmm2
  }
  _R11 = &v92;
  __asm
  {
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
    vmovaps xmm13, xmmword ptr [r11-80h]
    vmovaps xmm14, xmmword ptr [r11-90h]
  }
}

/*
==============
CG_CanChangeZoomLevel
==============
*/
bool CG_CanChangeZoomLevel(LocalClientNum_t localClientNum)
{
  cg_t *LocalClientGlobals; 
  const playerState_s *p_predictedPlayerState; 
  __int64 v3; 
  CgWeaponMap *v4; 
  const Weapon *ViewmodelOrOffhandADSWeapon; 
  int v7; 
  int v8; 
  bool outIsAlternate; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16367, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  p_predictedPlayerState = &LocalClientGlobals->predictedPlayerState;
  if ( !BG_InADS(&LocalClientGlobals->predictedPlayerState) && !BG_IsUsingOffhandGestureWeaponADSActive(&LocalClientGlobals->predictedPlayerState) )
    return 0;
  v3 = LocalClientGlobals->localClientNum;
  if ( !CgWeaponMap::ms_instance[v3] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v4 = CgWeaponMap::ms_instance[v3];
  ViewmodelOrOffhandADSWeapon = BG_GetViewmodelOrOffhandADSWeapon(v4, p_predictedPlayerState, &outIsAlternate);
  if ( !BG_GetEquippedWeaponState(v4, p_predictedPlayerState, ViewmodelOrOffhandADSWeapon) )
    return 0;
  v7 = BG_ADSZoomCount(v4, p_predictedPlayerState, ViewmodelOrOffhandADSWeapon, outIsAlternate);
  v8 = v7;
  if ( v7 > 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16389, ASSERT_TYPE_ASSERT, "( adsZoomCount ) <= ( 3 )", "%s <= %s\n\t%i, %i", "adsZoomCount", "WEAPON_VZSCOPE_MAXFOVS", v7, 3) )
    __debugbreak();
  return v8 > 1;
}

/*
==============
CG_CanCycleWeapon
==============
*/
bool CG_CanCycleWeapon(LocalClientNum_t localClientNum)
{
  cg_t *LocalClientGlobals; 
  cg_t *v3; 
  const playerState_s *p_predictedPlayerState; 
  bool IsUsingOffhandGestureWeapon; 
  CgWeaponMap *Instance; 
  const Weapon *Weapon; 
  bool v8; 
  bool v9; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v3 = LocalClientGlobals;
  if ( !LocalClientGlobals->nextSnap )
    return 0;
  p_predictedPlayerState = &LocalClientGlobals->predictedPlayerState;
  IsUsingOffhandGestureWeapon = BG_IsUsingOffhandGestureWeapon(&LocalClientGlobals->predictedPlayerState);
  if ( IsUsingOffhandGestureWeapon || (unsigned int)(p_predictedPlayerState->weapState[0].weaponState - 26) <= 3 )
  {
    Instance = CgWeaponMap::GetInstance((const LocalClientNum_t)v3->localClientNum);
    if ( !Instance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 916, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    if ( !p_predictedPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 917, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    Weapon = BgWeaponMap::GetWeapon(Instance, p_predictedPlayerState->weapCommon.offHandHandle);
    if ( BG_WeaponDef(Weapon, 0)->offhandHoldIsCancelable || (v8 = BG_PWF_UseAlternateAsOffhand(p_predictedPlayerState)) )
      v8 = 1;
    v9 = 0;
    if ( !p_predictedPlayerState->throwbackGrenadeTimeLeft )
      v9 = v8;
    if ( v9 && (!IsUsingOffhandGestureWeapon || BG_CanCancelOffhandGestureWeapon(p_predictedPlayerState)) )
    {
      v3->extraButtons |= 0x80000ui64;
      return 0;
    }
  }
  if ( v3->localClientNum != localClientNum && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16342, ASSERT_TYPE_ASSERT, "( cgameGlob->localClientNum ) == ( localClientNum )", "%s == %s\n\t%i, %i", "cgameGlob->localClientNum", "localClientNum", v3->localClientNum, localClientNum) )
    __debugbreak();
  return WeaponCycleAllowed(v3);
}

/*
==============
CG_CanModifyAnimWeight
==============
*/
bool CG_CanModifyAnimWeight(const playerState_s *ps, weapAnimFiles_t anim)
{
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2397, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  return anim == WEAP_ANIM_SKYDIVE_PARACHUTE_DETACH || anim <= WEAP_ANIM_GRENADE_PRIME_READY_TO_THROW || anim >= WEAP_ANIM_MELEE_FIRST;
}

/*
==============
CG_CreateWeaponViewModelAdditiveAnims
==============
*/
void CG_CreateWeaponViewModelAdditiveAnims(XAnimParts *const *animArray, WeaponXAnim *pAnims)
{
  weapAnimFiles_t *p_additiveChildStart; 
  signed int v5; 
  int i; 
  XAnimParts *WeaponAnim; 
  int v8; 
  __int64 flags; 
  __int64 syncGroup; 
  __int64 allowAllocs; 
  __int64 v12; 

  p_additiveChildStart = &s_additiveAnims[0].additiveChildStart;
  do
  {
    if ( (unsigned int)(*((_DWORD *)p_additiveChildStart - 1) - 28) > 0xCF )
    {
      LODWORD(allowAllocs) = 235;
      LODWORD(syncGroup) = 28;
      SLODWORD(flags) = *(p_additiveChildStart - 1);
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9120, ASSERT_TYPE_ASSERT, "( WEAP_ANIM_ADDITIVE_START ) <= ( additiveInfo->additiveRoot ) && ( additiveInfo->additiveRoot ) <= ( WEAP_ANIM_ADDITIVE_END )", "additiveInfo->additiveRoot not in [WEAP_ANIM_ADDITIVE_START, WEAP_ANIM_ADDITIVE_END]\n\t%i not in [%i, %i]", flags, syncGroup, allowAllocs) )
        __debugbreak();
    }
    if ( (unsigned int)(*p_additiveChildStart - 28) > 0xCF )
    {
      LODWORD(allowAllocs) = 235;
      LODWORD(syncGroup) = 28;
      SLODWORD(flags) = *p_additiveChildStart;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9121, ASSERT_TYPE_ASSERT, "( WEAP_ANIM_ADDITIVE_START ) <= ( additiveInfo->additiveChildStart ) && ( additiveInfo->additiveChildStart ) <= ( WEAP_ANIM_ADDITIVE_END )", "additiveInfo->additiveChildStart not in [WEAP_ANIM_ADDITIVE_START, WEAP_ANIM_ADDITIVE_END]\n\t%i not in [%i, %i]", flags, syncGroup, allowAllocs) )
        __debugbreak();
    }
    if ( (unsigned int)(*((_DWORD *)p_additiveChildStart + 1) - 28) > 0xCF )
    {
      LODWORD(allowAllocs) = 235;
      LODWORD(syncGroup) = 28;
      SLODWORD(flags) = p_additiveChildStart[1];
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9122, ASSERT_TYPE_ASSERT, "( WEAP_ANIM_ADDITIVE_START ) <= ( additiveInfo->additiveChildEnd ) && ( additiveInfo->additiveChildEnd ) <= ( WEAP_ANIM_ADDITIVE_END )", "additiveInfo->additiveChildEnd not in [WEAP_ANIM_ADDITIVE_START, WEAP_ANIM_ADDITIVE_END]\n\t%i not in [%i, %i]", flags, syncGroup, allowAllocs) )
        __debugbreak();
    }
    if ( *p_additiveChildStart > *((_DWORD *)p_additiveChildStart + 1) )
    {
      SLODWORD(v12) = p_additiveChildStart[1];
      SLODWORD(allowAllocs) = *p_additiveChildStart;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9123, ASSERT_TYPE_ASSERT, "( additiveInfo->additiveChildStart ) <= ( additiveInfo->additiveChildEnd )", "%s <= %s\n\t%i, %i", "additiveInfo->additiveChildStart", "additiveInfo->additiveChildEnd", allowAllocs, v12) )
        __debugbreak();
    }
    v5 = *p_additiveChildStart;
    for ( i = 0; v5 <= *((_DWORD *)p_additiveChildStart + 1); ++v5 )
    {
      WeaponAnim = CG_GetWeaponAnim(animArray, v5);
      if ( !WeaponAnim && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9130, ASSERT_TYPE_ASSERT, "(additiveAnim)", (const char *)&queryFormat, "additiveAnim") )
        __debugbreak();
      if ( !i )
      {
        v8 = 16;
        if ( *((_BYTE *)p_additiveChildStart + 8) )
          v8 = 512;
        LOBYTE(syncGroup) = 4;
        XAnimBlend(&pAnims->xanim, *((_DWORD *)p_additiveChildStart - 1), *(const char **)(p_additiveChildStart - 3), *p_additiveChildStart, *((_DWORD *)p_additiveChildStart + 1) - *p_additiveChildStart + 1, *((_DWORD *)p_additiveChildStart + 3) | v8, (const XAnimSyncGroupID)syncGroup, 0);
        i = 1;
      }
      BG_CreateXAnimFromParts(&pAnims->xanim, v5, WeaponAnim, 0);
    }
    p_additiveChildStart += 8;
  }
  while ( (__int64)p_additiveChildStart < (__int64)&s_blendSpaceNodes[0].rootName + 4 );
}

/*
==============
CG_CreateWeaponViewModelBlendSpaceNodes
==============
*/
void CG_CreateWeaponViewModelBlendSpaceNodes(XAnimParts *const *animArray, const BlendSpace2DDef **blendSpaces, WeaponXAnim *pAnims)
{
  WeaponAnimParameter *p_yParam; 
  const BlendSpace2DDef **v6; 
  __int64 v7; 
  const BlendSpace2DDef *v8; 
  unsigned int numAnimEntries; 
  unsigned int v10; 
  unsigned int v11; 
  unsigned int v12; 
  int v13; 
  __int64 v14; 
  __int64 v15; 
  unsigned int v16; 
  scr_string_t StringOfSize; 
  unsigned int numTriangleCoords; 
  int v19; 
  __int64 v20; 
  unsigned int v21; 
  scr_string_t v22; 
  int v23; 
  scr_string_t xanimBlendSpace2DValueX; 
  int v25; 
  scr_string_t xanimBlendSpace2DValueY; 
  unsigned int v27; 
  XAnimParts *WeaponAnim; 
  XAnimFieldType fmt; 
  XAnimFieldType fmta; 
  __int64 num; 
  __int64 flags; 
  XAnimSyncGroupID syncGroup; 
  WeaponAnimParameter *v35; 
  char str[4]; 
  int v37[195]; 
  char v38[4]; 
  int v39[195]; 

  p_yParam = &s_blendSpaceNodes[0].yParam;
  v35 = &s_blendSpaceNodes[0].yParam;
  v6 = blendSpaces;
  do
  {
    if ( *((_DWORD *)p_yParam - 6) >= 8u )
    {
      LODWORD(flags) = 8;
      SLODWORD(num) = *(p_yParam - 6);
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9168, ASSERT_TYPE_ASSERT, "(unsigned)( blendSpaceNodeInfo->blendSpaceType ) < (unsigned)( WEAPON_BLEND_SPACE_COUNT )", "blendSpaceNodeInfo->blendSpaceType doesn't index WEAPON_BLEND_SPACE_COUNT\n\t%i not in [0, %i)", num, flags) )
        __debugbreak();
    }
    v7 = *((int *)p_yParam - 6);
    v8 = v6[v7];
    if ( v8 )
    {
      numAnimEntries = v8->numAnimEntries;
      if ( numAnimEntries )
      {
        v10 = 20 * v7 + 448;
        v11 = v7 + 397;
        LOBYTE(syncGroup) = 4;
        XAnimCustomNode(scr_const.xanimBlendSpace2D, &pAnims->xanim, v7 + 397, *((const char **)p_yParam - 2), v10, numAnimEntries, *((_DWORD *)p_yParam - 2), syncGroup, 0);
        XAnimBindVec2ToNodeParameter(&pAnims->xanim, v11, scr_const.xanimBlendSpace2DAxisXRange, &v8->rangeX);
        XAnimBindVec2ToNodeParameter(&pAnims->xanim, v11, scr_const.xanimBlendSpace2DAxisYRange, &v8->rangeY);
        XAnimBindUInt32ToNodeParameter(&pAnims->xanim, v11, scr_const.xanimBlendSpaceBlendTime, v8->blendTimeMs);
        XAnimBindBoolToNodeParameter(&pAnims->xanim, v11, scr_const.xanimBlendSpaceAllAnimsNotify, v8->allAnimsNotify);
        v12 = 0;
        v13 = 2 * LOBYTE(v8->numAnimEntries);
        *(_DWORD *)str = v13;
        if ( v8->numAnimEntries )
        {
          do
          {
            v14 = 2 * v12;
            v15 = (__int64)&v8->animEntries[v12++];
            v37[v14] = *(_DWORD *)(v15 + 8);
            v37[(unsigned int)(v14 + 1)] = *(_DWORD *)(v15 + 12);
          }
          while ( v12 < v8->numAnimEntries );
          v13 = *(_DWORD *)str;
        }
        v16 = 4 * v13 + 4;
        if ( 4 * v13 == -4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\xanim\\xanim_node_api.h", 297, ASSERT_TYPE_ASSERT, "(fieldSize > 0)", (const char *)&queryFormat, "fieldSize > 0") )
          __debugbreak();
        StringOfSize = j_SL_GetStringOfSize(str, 0, v16, 4);
        XAnimRegisterConstString(StringOfSize, v16);
        SL_RemoveRefToString(StringOfSize);
        LOWORD(fmt) = 18;
        XAnimBindArrayToNodeParameter(&pAnims->xanim, v11, scr_const.xanimBlendSpaceCoords, StringOfSize, fmt);
        numTriangleCoords = v8->numTriangleCoords;
        if ( numTriangleCoords > 0xFF && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned char __cdecl truncate_cast_impl<unsigned char,unsigned int>(unsigned int)", "unsigned", (unsigned __int8)numTriangleCoords, "unsigned", v8->numTriangleCoords) )
          __debugbreak();
        v19 = (unsigned __int8)numTriangleCoords;
        v20 = 0i64;
        *(_DWORD *)v38 = (unsigned __int8)numTriangleCoords;
        if ( v8->numTriangleCoords )
        {
          do
          {
            v39[v20] = v8->triangleCoords[v20];
            v20 = (unsigned int)(v20 + 1);
          }
          while ( (unsigned int)v20 < v8->numTriangleCoords );
          v19 = *(_DWORD *)v38;
        }
        v21 = 4 * v19 + 4;
        if ( 4 * v19 == -4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\xanim\\xanim_node_api.h", 297, ASSERT_TYPE_ASSERT, "(fieldSize > 0)", (const char *)&queryFormat, "fieldSize > 0") )
          __debugbreak();
        v22 = j_SL_GetStringOfSize(v38, 0, v21, 4);
        XAnimRegisterConstString(v22, v21);
        SL_RemoveRefToString(v22);
        LOWORD(fmta) = 14;
        XAnimBindArrayToNodeParameter(&pAnims->xanim, v11, scr_const.xanimBlendSpace2DEdges, v22, fmta);
        v23 = *((_DWORD *)p_yParam - 1);
        xanimBlendSpace2DValueX = scr_const.xanimBlendSpace2DValueX;
        if ( (v23 < 0 || (unsigned int)v23 > 0xFFFF) && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned short __cdecl truncate_cast_impl<unsigned short,enum WeaponAnimParameter>(enum WeaponAnimParameter)", "unsigned", (unsigned __int16)v23, "signed", v23) )
          __debugbreak();
        XAnimBindGameParameterToNodeParameterByIndex(&pAnims->xanim, v11, v23, xanimBlendSpace2DValueX);
        v25 = *p_yParam;
        xanimBlendSpace2DValueY = scr_const.xanimBlendSpace2DValueY;
        if ( (*(int *)p_yParam < 0 || (unsigned int)v25 > 0xFFFF) && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned short __cdecl truncate_cast_impl<unsigned short,enum WeaponAnimParameter>(enum WeaponAnimParameter)", "unsigned", (unsigned __int16)v25, "signed", v25) )
          __debugbreak();
        XAnimBindGameParameterToNodeParameterByIndex(&pAnims->xanim, v11, v25, xanimBlendSpace2DValueY);
        v27 = v10;
        if ( v10 < v10 + v8->numAnimEntries )
        {
          do
          {
            WeaponAnim = CG_GetWeaponAnim(animArray, v27);
            if ( !WeaponAnim && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9225, ASSERT_TYPE_ASSERT, "(blendSpaceAnim)", (const char *)&queryFormat, "blendSpaceAnim") )
              __debugbreak();
            BG_CreateXAnimFromParts(&pAnims->xanim, v27++, WeaponAnim, 0);
          }
          while ( v27 < v10 + v8->numAnimEntries );
          p_yParam = v35;
        }
        v6 = blendSpaces;
      }
    }
    p_yParam += 8;
    v35 = p_yParam;
  }
  while ( (__int64)p_yParam < (__int64)&s_skydiveParachuteAdditiveGroups[0].scrub1DTimeRange.y );
}

/*
==============
CG_CreateWeaponViewModelRelativeAnims
==============
*/
void CG_CreateWeaponViewModelRelativeAnims(XAnimParts *const *animArray, WeaponXAnim *pAnims, const int startIndex, const int numAnims)
{
  __int64 v4; 
  __int64 v6; 
  __int64 v8; 
  XAnimParts **v9; 
  XAnimParts *GameDefaultWeaponAnim; 
  __int64 v11; 
  __int64 v12; 

  v4 = numAnims;
  v6 = startIndex;
  if ( !animArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9235, ASSERT_TYPE_ASSERT, "(animArray)", (const char *)&queryFormat, "animArray") )
    __debugbreak();
  if ( !pAnims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9236, ASSERT_TYPE_ASSERT, "(pAnims)", (const char *)&queryFormat, "pAnims") )
    __debugbreak();
  v8 = v4;
  if ( (int)v4 > 0 )
  {
    v9 = (XAnimParts **)&animArray[v6];
    do
    {
      if ( (unsigned int)v6 >= 0x260 )
      {
        LODWORD(v12) = 608;
        LODWORD(v11) = v6;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9088, ASSERT_TYPE_ASSERT, "(unsigned)( animIndex ) < (unsigned)( NUM_WEAP_VIEWMODEL_ANIMS )", "animIndex doesn't index NUM_WEAP_VIEWMODEL_ANIMS\n\t%i not in [0, %i)", v11, v12) )
          __debugbreak();
      }
      GameDefaultWeaponAnim = *v9;
      if ( !*v9 )
      {
        GameDefaultWeaponAnim = BG_GetGameDefaultWeaponAnim(v6);
        if ( !GameDefaultWeaponAnim )
        {
          if ( !*((_QWORD *)animArray + 236) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9098, ASSERT_TYPE_ASSERT, "(animArray[WEAP_ANIM_IDLE])", (const char *)&queryFormat, "animArray[WEAP_ANIM_IDLE]") )
            __debugbreak();
          GameDefaultWeaponAnim = (XAnimParts *)*((_QWORD *)animArray + 236);
        }
        if ( !GameDefaultWeaponAnim && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9242, ASSERT_TYPE_ASSERT, "(xanim)", (const char *)&queryFormat, "xanim") )
          __debugbreak();
      }
      BG_CreateXAnimFromParts(&pAnims->xanim, v6, GameDefaultWeaponAnim, 0);
      LODWORD(v6) = v6 + 1;
      ++v9;
      --v8;
    }
    while ( v8 );
  }
}

/*
==============
CG_CreateWeaponViewModelSkydiveAdditiveAnims
==============
*/
void CG_CreateWeaponViewModelSkydiveAdditiveAnims(XAnimParts *const *animArray, WeaponXAnim *pAnims)
{
  unsigned int v5; 
  int v6; 
  scr_string_t xanimScrubTimeValue; 
  int v8; 
  scr_string_t xanimBlendSpace1DValue; 
  int v11; 
  scr_string_t StringOfSize; 
  unsigned int i; 
  XAnimParts *WeaponAnim; 
  const char **p_scrub1DRootName; 
  int v16; 
  scr_string_t v17; 
  unsigned int j; 
  XAnimParts *v19; 
  XAnimParts *GameDefaultWeaponAnim; 
  XAnimParts *v21; 
  signed int num; 
  XAnimSyncGroupID syncGroup; 
  XAnimSyncGroupID syncGroupa; 
  XAnimSyncGroupID syncGroupb; 
  XAnimSyncGroupID allowAllocs; 
  char str[4]; 
  int v29; 

  LOBYTE(syncGroup) = 4;
  XAnimBlend(&pAnims->xanim, 0xC5u, "skydive_root", 0xC6u, 2u, 0x10u, syncGroup, 0);
  LOBYTE(syncGroupa) = 4;
  XAnimBlend(&pAnims->xanim, 0xC6u, "skydive_freefall_root", 0xC8u, 6u, 0x20u, syncGroupa, 0);
  LOBYTE(syncGroupb) = 4;
  XAnimBlend(&pAnims->xanim, 0xC7u, "skydive_parachute_root", 0xE1u, 6u, 0x20u, syncGroupb, 0);
  _RDI = &s_skydiveFreefallAdditiveGroups[0].scrub1DRootName;
  do
  {
    v5 = *((_DWORD *)_RDI - 2);
    if ( v5 )
    {
      LOBYTE(allowAllocs) = 4;
      XAnimCustomNode(scr_const.xanimScrub1D, &pAnims->xanim, v5, *_RDI, *((_DWORD *)_RDI + 6), 1u, *((_DWORD *)_RDI + 2), allowAllocs, 0);
      XAnimBindVec2ToNodeParameter(&pAnims->xanim, *((_DWORD *)_RDI - 2), scr_const.xanimScrubTimeRange, (const vec2_t *)((char *)_RDI + 12));
      v6 = *((_DWORD *)_RDI + 5);
      xanimScrubTimeValue = scr_const.xanimScrubTimeValue;
      if ( (v6 < 0 || (unsigned int)v6 > 0xFFFF) && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned short __cdecl truncate_cast_impl<unsigned short,enum WeaponAnimParameter>(enum WeaponAnimParameter)", "unsigned", (unsigned __int16)v6, "signed", v6) )
        __debugbreak();
      XAnimBindGameParameterToNodeParameterByIndex(&pAnims->xanim, *((_DWORD *)_RDI - 2), v6, xanimScrubTimeValue);
    }
    LOBYTE(allowAllocs) = 4;
    XAnimCustomNode(scr_const.xanimBlendSpace1D, &pAnims->xanim, *((_DWORD *)_RDI + 6), _RDI[4], *((_DWORD *)_RDI + 17), *((_DWORD *)_RDI + 18) - *((_DWORD *)_RDI + 17) + 1, *((_DWORD *)_RDI + 10), allowAllocs, 0);
    XAnimBindVec2ToNodeParameter(&pAnims->xanim, *((_DWORD *)_RDI + 6), scr_const.xanimBlendSpace1DRange, (const vec2_t *)((char *)_RDI + 44));
    v8 = *((_DWORD *)_RDI + 13);
    xanimBlendSpace1DValue = scr_const.xanimBlendSpace1DValue;
    if ( (v8 < 0 || (unsigned int)v8 > 0xFFFF) && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned short __cdecl truncate_cast_impl<unsigned short,enum WeaponAnimParameter>(enum WeaponAnimParameter)", "unsigned", (unsigned __int16)v8, "signed", v8) )
      __debugbreak();
    XAnimBindGameParameterToNodeParameterByIndex(&pAnims->xanim, *((_DWORD *)_RDI + 6), v8, xanimBlendSpace1DValue);
    __asm { vmovsd  xmm0, qword ptr [rdi+38h] }
    v11 = *((_DWORD *)_RDI + 16);
    *(_DWORD *)str = 3;
    __asm { vmovsd  [rsp+3A8h+var_354], xmm0 }
    v29 = v11;
    StringOfSize = j_SL_GetStringOfSize(str, 0, 0x10ui64, 4);
    XAnimRegisterConstString(StringOfSize, 0x10u);
    SL_RemoveRefToString(StringOfSize);
    LOWORD(num) = 18;
    XAnimBindArrayToNodeParameter(&pAnims->xanim, *((_DWORD *)_RDI + 6), scr_const.xanimBlendSpaceCoords, StringOfSize, (const XAnimFieldType)num);
    for ( i = *((_DWORD *)_RDI + 17); i <= *((_DWORD *)_RDI + 18); ++i )
    {
      WeaponAnim = CG_GetWeaponAnim(animArray, i);
      if ( !WeaponAnim && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9327, ASSERT_TYPE_ASSERT, "(anim)", (const char *)&queryFormat, "anim") )
        __debugbreak();
      BG_CreateXAnimFromParts(&pAnims->xanim, i, WeaponAnim, 0);
    }
    _RDI += 11;
  }
  while ( (__int64)_RDI < (__int64)s_blendAnimStates );
  p_scrub1DRootName = &s_skydiveParachuteAdditiveGroups[0].scrub1DRootName;
  do
  {
    LOBYTE(allowAllocs) = 4;
    XAnimCustomNode(scr_const.xanimScrub1D, &pAnims->xanim, *((_DWORD *)p_scrub1DRootName - 2), *p_scrub1DRootName, *((_DWORD *)p_scrub1DRootName + 6), *((_DWORD *)p_scrub1DRootName + 7) - *((_DWORD *)p_scrub1DRootName + 6) + 1, *((_DWORD *)p_scrub1DRootName + 2), allowAllocs, 0);
    XAnimBindVec2ToNodeParameter(&pAnims->xanim, *((_DWORD *)p_scrub1DRootName - 2), scr_const.xanimScrubTimeRange, (const vec2_t *)((char *)p_scrub1DRootName + 12));
    v16 = *((_DWORD *)p_scrub1DRootName + 5);
    v17 = scr_const.xanimScrubTimeValue;
    if ( (v16 < 0 || (unsigned int)v16 > 0xFFFF) && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned short __cdecl truncate_cast_impl<unsigned short,enum WeaponAnimParameter>(enum WeaponAnimParameter)", "unsigned", (unsigned __int16)v16, "signed", v16) )
      __debugbreak();
    XAnimBindGameParameterToNodeParameterByIndex(&pAnims->xanim, *((_DWORD *)p_scrub1DRootName - 2), v16, v17);
    for ( j = *((_DWORD *)p_scrub1DRootName + 6); j <= *((_DWORD *)p_scrub1DRootName + 7); ++j )
    {
      v19 = CG_GetWeaponAnim(animArray, j);
      if ( !v19 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9349, ASSERT_TYPE_ASSERT, "(anim)", (const char *)&queryFormat, "anim") )
        __debugbreak();
      BG_CreateXAnimFromParts(&pAnims->xanim, j, v19, 0);
    }
    p_scrub1DRootName += 5;
  }
  while ( (__int64)p_scrub1DRootName < (__int64)s_skydiveFreefallAdditiveGroups );
  GameDefaultWeaponAnim = (XAnimParts *)*((_QWORD *)animArray + 230);
  if ( !GameDefaultWeaponAnim )
  {
    GameDefaultWeaponAnim = BG_GetGameDefaultWeaponAnim(230);
    if ( !GameDefaultWeaponAnim )
    {
      if ( !*((_QWORD *)animArray + 236) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9098, ASSERT_TYPE_ASSERT, "(animArray[WEAP_ANIM_IDLE])", (const char *)&queryFormat, "animArray[WEAP_ANIM_IDLE]") )
        __debugbreak();
      GameDefaultWeaponAnim = (XAnimParts *)*((_QWORD *)animArray + 236);
    }
    if ( !GameDefaultWeaponAnim && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9356, ASSERT_TYPE_ASSERT, "(anim)", (const char *)&queryFormat, "anim") )
      __debugbreak();
  }
  BG_CreateXAnimFromParts(&pAnims->xanim, 0xE6u, GameDefaultWeaponAnim, 0);
  v21 = (XAnimParts *)*((_QWORD *)animArray + 205);
  if ( !v21 )
  {
    v21 = BG_GetGameDefaultWeaponAnim(205);
    if ( !v21 )
    {
      if ( !*((_QWORD *)animArray + 236) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9098, ASSERT_TYPE_ASSERT, "(animArray[WEAP_ANIM_IDLE])", (const char *)&queryFormat, "animArray[WEAP_ANIM_IDLE]") )
        __debugbreak();
      v21 = (XAnimParts *)*((_QWORD *)animArray + 236);
    }
    if ( !v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9361, ASSERT_TYPE_ASSERT, "(axietyAnim)", (const char *)&queryFormat, "axietyAnim") )
      __debugbreak();
  }
  BG_CreateXAnimFromParts(&pAnims->xanim, 0xCDu, v21, 0);
}

/*
==============
CG_CreateWeaponViewModelXAnim
==============
*/
void CG_CreateWeaponViewModelXAnim(LocalClientNum_t localClientNum, const playerState_s *ps, XAnimParts *const *animArray, const BlendSpace2DDef **blendSpaces, WeaponXAnim *pAnims, const PlayerHandIndex hand, const bool isDualWield)
{
  WeaponXAnim *v7; 
  __int64 v12; 
  char **debugAnimNames; 
  char (*debugNames)[36]; 
  bool v17; 
  unsigned int animIndex; 
  const char *v19; 
  XAnimSyncGroupID bindingArrayMemory; 
  XAnimSyncGroupID bindingArrayMemorya; 
  XAnimSyncGroupID bindingArrayMemoryb; 
  XAnimSyncGroupID bindingArrayMemoryc; 
  int maxPublicNodes; 
  int maxPublicNodesa; 
  int maxPublicNodesb; 
  int maxPublicNodesc; 

  v7 = pAnims;
  if ( !pAnims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9375, ASSERT_TYPE_ASSERT, "(pAnims)", (const char *)&queryFormat, "pAnims") )
    __debugbreak();
  XAnimCreateAnimsInPlaceWithParameters(XANIM_SUBTREE_DEFAULT, &v7->xanim, 609, 36, NULL, 160, v7->bindings, 1, weaponXanimPublicNodes);
  XAnimSetNumGameParameters(&v7->xanim, 0x24u);
  v12 = 608i64;
  v7->xanim.debugName = v7->debugName;
  debugAnimNames = v7->debugAnimNames;
  debugNames = v7->debugNames;
  do
  {
    *debugAnimNames++ = (char *)debugNames++;
    --v12;
  }
  while ( v12 );
  _RCX = v7->xanim.debugName;
  v7->xanim.debugAnimNames = v7->debugAnimNames;
  __asm
  {
    vmovsd  xmm0, qword ptr cs:aViewmodel_1; "VIEWMODEL"
    vmovsd  qword ptr [rcx], xmm0
  }
  strcpy(_RCX + 8, "L");
  LOBYTE(bindingArrayMemory) = 4;
  XAnimBlend(&v7->xanim, 0, "root", 1u, 0xBu, 0, bindingArrayMemory, 0);
  LOBYTE(bindingArrayMemorya) = 4;
  XAnimBlend(&v7->xanim, 1u, "inner_root", 0xEu, 0xDEu, 0, bindingArrayMemorya, 0);
  LOBYTE(bindingArrayMemoryb) = 4;
  XAnimBlend(&v7->xanim, 0xEu, "relative_root", 0xECu, 0xD4u, 0, bindingArrayMemoryb, 0);
  if ( !*((_QWORD *)animArray + 236) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9397, ASSERT_TYPE_ASSERT, "(animArray[WEAP_ANIM_IDLE])", (const char *)&queryFormat, "animArray[WEAP_ANIM_IDLE]") )
    __debugbreak();
  CG_CreateWeaponViewModelAdditiveAnims(animArray, v7);
  CG_CreateWeaponViewModelSkydiveAdditiveAnims(animArray, v7);
  v17 = isDualWield;
  CG_Gesture_CreateTree(localClientNum, ps, v7, hand, isDualWield, 1);
  CG_CreateWeaponViewModelRelativeAnims(animArray, v7, 15, 13);
  CG_CreateWeaponViewModelRelativeAnims(animArray, v7, 236, 212);
  LOBYTE(maxPublicNodes) = 4;
  XAnimCustomNode(scr_const.xanimScrub1D, &v7->xanim, 0xF6u, "skydive_freefall_idle_root", 0xF7u, 1u, 0, (const XAnimSyncGroupID)maxPublicNodes, 0);
  XAnimBindVec2ToNodeParameter(&v7->xanim, 0xF6u, scr_const.xanimScrubTimeRange, &stru_1442DD4F0);
  XAnimBindGameParameterToNodeParameterByIndex(&v7->xanim, 0xF6u, 0x22u, scr_const.xanimScrubTimeValue);
  LOBYTE(bindingArrayMemoryc) = 4;
  XAnimBlend(&v7->xanim, 0x103u, "toggle_scope", 0x104u, 2u, 0, bindingArrayMemoryc, 0);
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9252, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  animIndex = ps->viewModelAnimScripted.animIndex;
  if ( animIndex )
  {
    NetConstStrings_GetNameFromIndexPlusOne(NETCONSTSTRINGTYPE_ANIM, animIndex, (const char **)&pAnims);
    if ( !pAnims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9259, ASSERT_TYPE_ASSERT, "(animName)", (const char *)&queryFormat, "animName") )
      __debugbreak();
    v19 = (const char *)pAnims;
  }
  else
  {
    v19 = "void";
  }
  BG_CreateXAnim(&v7->xanim, 0x17Cu, v19, 0);
  CG_Gesture_CreateTree(localClientNum, ps, v7, hand, v17, 0);
  CG_CreateWeaponViewModelBlendSpaceNodes(animArray, blendSpaces, v7);
  LOBYTE(maxPublicNodesa) = 4;
  XAnimCustomNode(scr_const.xanimAnalogClock, &v7->xanim, 8u, "analog_clock", 9u, 1u, 0x40u, (const XAnimSyncGroupID)maxPublicNodesa, 0);
  XAnimBindGameParameterToNodeParameterByIndex(&v7->xanim, 8u, 0x1Bu, scr_const.clockHourAngle);
  XAnimBindGameParameterToNodeParameterByIndex(&v7->xanim, 8u, 0x1Cu, scr_const.clockMinuteAngle);
  XAnimBindGameParameterToNodeParameterByIndex(&v7->xanim, 8u, 0x1Du, scr_const.clockSecondAngle);
  XAnimBindGameParameterToNodeParameterByIndex(&v7->xanim, 8u, 0x23u, scr_const.clockOscillationFraction);
  LOBYTE(maxPublicNodesb) = 4;
  XAnimCustomNode(scr_const.ik_node, &v7->xanim, 0xAu, "ik_node", 0xCu, 1u, 0, (const XAnimSyncGroupID)maxPublicNodesb, 0);
  LOBYTE(maxPublicNodesc) = 4;
  XAnimCustomNode(scr_const.proc_node, &v7->xanim, 0xBu, "proc_node", 0xDu, 1u, 0x2000u, (const XAnimSyncGroupID)maxPublicNodesc, 0);
  XAnimAddPublicNode(&v7->xanim, scr_const.proc_node, 0xBu);
  CG_Ladder_CreateAnims(v7);
  XAnimSetupBindingIndexes(&v7->xanim);
}

/*
==============
CG_CreateWeaponViewModelXAnimDefs
==============
*/
__int64 CG_CreateWeaponViewModelXAnimDefs(LocalClientNum_t localClientNum, const playerState_s *ps, const Weapon *weapon, ClientPlayerWeaponInfo *weapInfo)
{
  unsigned __int8 v8; 
  int i; 
  WeaponXAnim *p_animsTwoHanded; 
  const WeaponDef *v11; 
  const WeaponDef *v12; 
  WeaponAnimPackage *szXAnims; 
  int *p_fontScaleTime; 
  bool v15; 
  bool v16; 
  const dvar_t *v17; 
  CgHandler *Handler; 
  char *WeaponName; 
  playerState_s *psa; 
  playerState_s *psb; 
  RawWeaponAnimArrays outAnimArrays; 
  char output[1024]; 

  RawWeaponAnimArrays::RawWeaponAnimArrays(&outAnimArrays);
  v8 = 0;
  if ( !weapInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9459, ASSERT_TYPE_ASSERT, "(weapInfo)", (const char *)&queryFormat, "weapInfo") )
    __debugbreak();
  psa = (playerState_s *)CG_GetLocalClientGlobals(localClientNum);
  if ( !psa && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9462, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( !memcmp_0(&psa[4].hud.current[6].height, weapon, 0x3Cui64) )
  {
    p_animsTwoHanded = &weapInfo->animsTwoHanded;
  }
  else
  {
    for ( i = 0; i < 2; ++i )
      CG_Weapons_FreeAnimTreeHand(localClientNum, (const PlayerHandIndex)i);
    p_animsTwoHanded = &weapInfo->animsTwoHanded;
    memset_0(&weapInfo->animsTwoHanded, 0, sizeof(weapInfo->animsTwoHanded));
    memset_0(&weapInfo->animsTwoHandedAltMode, 0, sizeof(weapInfo->animsTwoHandedAltMode));
    memset_0(&weapInfo->animsRightHanded, 0, sizeof(weapInfo->animsRightHanded));
    memset_0(&weapInfo->animsLeftHanded, 0, sizeof(weapInfo->animsLeftHanded));
    v8 = 1;
  }
  v11 = BG_WeaponDef(weapon, 0);
  v12 = v11;
  szXAnims = v11->szXAnims;
  if ( szXAnims && *((_QWORD *)szXAnims->anims + 236) )
  {
    BG_Suit_GetOverriddenAnims(ps, weapon, &outAnimArrays);
    CG_CreateWeaponViewModelXAnim(localClientNum, ps, outAnimArrays.xAnims, outAnimArrays.blendSpaces, p_animsTwoHanded, WEAPON_HAND_DEFAULT, 0);
    if ( BG_OneHandedViewModelAnimsValid(v12) )
    {
      CG_CreateWeaponViewModelXAnim(localClientNum, ps, outAnimArrays.xAnimsRightHanded, outAnimArrays.blendSpacesRightHanded, &weapInfo->animsRightHanded, WEAPON_HAND_DEFAULT, 1);
      CG_CreateWeaponViewModelXAnim(localClientNum, ps, outAnimArrays.xAnimsLeftHanded, outAnimArrays.blendSpacesLeftHanded, &weapInfo->animsLeftHanded, WEAPON_HAND_LEFT, 1);
    }
    p_fontScaleTime = &psa[36].hud.archival[12].fontScaleTime;
    if ( psa == (playerState_s *)-790760i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9514, ASSERT_TYPE_ASSERT, "(weaponAnimArrays)", (const char *)&queryFormat, "weaponAnimArrays") )
      __debugbreak();
    memset_0(p_fontScaleTime, 0, 0x1330ui64);
    memset_0(&psa[37].weapCommon.ammoInClip[6].clipIndex.weapon.attachmentVariationIndices[5], 0, 0x1330ui64);
    *(_QWORD *)&psa[37].weapCommon.ammoInClip[5].clipIndex.weapon.weaponCamo = 0i64;
    *(_QWORD *)psa[37].weapCommon.ammoInClip[5].chamberedCount = 0i64;
    *(_QWORD *)psa[37].weapCommon.ammoInClip[5].shotsSinceRechamber = 0i64;
    *(_QWORD *)psa[37].weapCommon.ammoInClip[5].ammoCount = 0i64;
    *(_QWORD *)&psa[37].weapCommon.ammoInClip[6].clipIndex.weapon.weaponIdx = 0i64;
    *(_QWORD *)&psa[37].weapCommon.ammoInClip[6].clipIndex.weapon.stickerIndices[3] = 0i64;
    *(_QWORD *)&psa[37].weapCommon.ammoInClip[6].clipIndex.weapon.weaponAttachments[2] = 0i64;
    *(_QWORD *)&psa[37].weapCommon.ammoInClip[6].clipIndex.weapon.weaponAttachments[10] = 0i64;
    *(_QWORD *)&psa[37].objectives[21].origin[3].y = 0i64;
    *(_QWORD *)psa[37].objectives[21].origin[4].v = 0i64;
    *(_QWORD *)&psa[37].objectives[21].origin[4].z = 0i64;
    *(_QWORD *)&psa[37].objectives[21].origin[5].y = 0i64;
    *(_QWORD *)psa[37].objectives[21].origin[6].v = 0i64;
    *(_QWORD *)&psa[37].objectives[21].origin[6].z = 0i64;
    *(_QWORD *)&psa[37].objectives[21].origin[7].y = 0i64;
    *(_QWORD *)&psa[37].objectives[21].validLocations = 0i64;
    psb = (playerState_s *)&psa->inputTime;
    v15 = BG_PlayerDualWielding(psb) != 0;
    v16 = BG_UsingAlternate(ps);
    if ( !BG_BuildWeaponAnimArrays(psb, weapon, v15, v16, &outAnimArrays, (XAnimParts **)p_fontScaleTime, (const BlendSpace2DDef **)p_fontScaleTime + 614, (XAnimParts **)p_fontScaleTime + 622, (const BlendSpace2DDef **)p_fontScaleTime + 1236, (FootstepAnim *)(p_fontScaleTime + 2488), WEAP_ANIM_ROOT, 608) || (CG_CreateWeaponViewModelXAnim(localClientNum, ps, (XAnimParts *const *)p_fontScaleTime, (const BlendSpace2DDef **)p_fontScaleTime + 614, &weapInfo->animsTwoHanded, WEAPON_HAND_DEFAULT, 0), BG_HasUnderbarrelAmmo(weapon)) )
      CG_CreateWeaponViewModelXAnim(localClientNum, ps, (XAnimParts *const *)p_fontScaleTime + 622, (const BlendSpace2DDef **)p_fontScaleTime + 1236, &weapInfo->animsTwoHandedAltMode, WEAPON_HAND_DEFAULT, 0);
    v17 = DCONST_DVARBOOL_cg_viewmodelAnimatedJumps;
    if ( !DCONST_DVARBOOL_cg_viewmodelAnimatedJumps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmodelAnimatedJumps") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v17);
    if ( v17->current.enabled )
    {
      Handler = CgHandler::getHandler(localClientNum);
      if ( !BG_ViewModelAnimExists(psb, WEAP_ANIM_ADDITIVE_JUMP_LAND, WEAPON_HAND_DEFAULT, Handler) )
        Com_PrintWarning(19, "cg_viewmodelAnimatedJumps enabled, but jump land anim is not set\n");
    }
  }
  else if ( v11->gunXModel && v11->handXModel )
  {
    WeaponName = BG_GetWeaponName(weapon, output, 0x400u);
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1442DD5F0, 604i64, WeaponName);
  }
  return v8;
}

/*
==============
CG_CycleNeedsToWaitForHoldTime
==============
*/
bool CG_CycleNeedsToWaitForHoldTime(LocalClientNum_t localClientNum)
{
  CG_GetLocalClientGlobals(localClientNum);
  return CG_GetCurrentWeaponSlot(localClientNum) == WEAPON_SLOT_PRIMARY;
}

/*
==============
CG_CycleWeapon
==============
*/
void CG_CycleWeapon(LocalClientNum_t localClientNum, int cycleSlot, int cycleForward)
{
  cg_t *LocalClientGlobals; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  LocalClientGlobals->weaponSelectTime = LocalClientGlobals->time;
  CycleWeapPrimary(localClientNum, cycleSlot, cycleForward, 0, 0, 0);
}

/*
==============
CG_DebugBulletFireLog_AddClientEntry
==============
*/
void CG_DebugBulletFireLog_AddClientEntry(const int entNum, const int serverTime, const vec3_t *bulletOrigin, const vec3_t *bulletDir)
{
  cg_t *LocalClientGlobals; 
  DebugBulletFireInfoLog *v10; 
  bool v11; 

  if ( CG_DebugBulletFireLog_ShouldLog(entNum) )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals(LOCAL_CLIENT_0);
    Sys_EnterCriticalSection(CRITSECT_DEBUG_BULLET_FIRE_LOG);
    _RBX = NULL;
    if ( s_debugBulletFireInfoLog.entryCount == 50 )
    {
      _RBX = &s_debugBulletFireInfoLog.entries[49];
    }
    else
    {
      v10 = &s_debugBulletFireInfoLog;
      while ( v10->entries[0].isUsed )
      {
        v10 = (DebugBulletFireInfoLog *)((char *)v10 + 160);
        if ( (__int64)v10 >= (__int64)&s_debugBulletFireInfoLog.entryCount )
          goto LABEL_9;
      }
      _RBX = (DebugBulletFireInfoEntry *)v10;
      ++s_debugBulletFireInfoLog.entryCount;
    }
LABEL_9:
    v11 = CgWeaponMap::ms_instance[0] == NULL;
    _RBX->isUsed = 1;
    _RBX->serverTime = serverTime;
    _RBX->clientGunPitch = LocalClientGlobals->gunAngles.v[0];
    _RBX->clientGunYaw = LocalClientGlobals->gunAngles.v[1];
    _RBX->clientViewAngles.v[0] = LocalClientGlobals->predictedPlayerState.viewangles.v[0];
    _RBX->clientViewAngles.v[1] = LocalClientGlobals->predictedPlayerState.viewangles.v[1];
    _RBX->clientViewAngles.v[2] = LocalClientGlobals->predictedPlayerState.viewangles.v[2];
    _RBX->clientDeltaAngles.v[0] = LocalClientGlobals->predictedPlayerState.delta_angles.v[0];
    _RBX->clientDeltaAngles.v[1] = LocalClientGlobals->predictedPlayerState.delta_angles.v[1];
    _RBX->clientDeltaAngles.v[2] = LocalClientGlobals->predictedPlayerState.delta_angles.v[2];
    _RBX->clientAdsStartTime = LocalClientGlobals->predictedPlayerState.weapCommon.adsStartTime;
    _RBX->clientAdsFraction = LocalClientGlobals->predictedPlayerState.weapCommon.fWeaponPosFrac;
    if ( v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
      __debugbreak();
    *(double *)&_XMM0 = BG_WeaponADSFractionAffectedByReload(CgWeaponMap::ms_instance[0], &LocalClientGlobals->predictedPlayerState);
    __asm { vmovss  dword ptr [rbx+2Ch], xmm0 }
    _RBX->clientIdleTimer1 = LocalClientGlobals->predictedPlayerState.weapCommon.weaponIdleTime;
    _RBX->clientIdleTimer2 = LocalClientGlobals->predictedPlayerState.weapCommon.weaponIdleTime2;
    _RBX->clientBulletOrigin.v[0] = bulletOrigin->v[0];
    _RBX->clientBulletOrigin.v[1] = bulletOrigin->v[1];
    _RBX->clientBulletOrigin.v[2] = bulletOrigin->v[2];
    _RBX->clientBulletDir.v[0] = bulletDir->v[0];
    _RBX->clientBulletDir.v[1] = bulletDir->v[1];
    _RBX->clientBulletDir.v[2] = bulletDir->v[2];
    _RBX->serverBulletEntryAdded = 0;
    *(_QWORD *)_RBX->serverBulletOrigin.v = 0i64;
    *(_QWORD *)&_RBX->serverBulletOrigin.z = 0i64;
    *(_QWORD *)&_RBX->serverBulletDir.y = 0i64;
    std::_Sort_unchecked<DebugBulletFireInfoEntry *,bool (*)(DebugBulletFireInfoEntry &,DebugBulletFireInfoEntry &)>(s_debugBulletFireInfoLog.entries, (DebugBulletFireInfoEntry *)&s_debugBulletFireInfoLog.entryCount, 50i64, CG_DebugBulletFireLog_Sorter);
    Sys_LeaveCriticalSection(CRITSECT_DEBUG_BULLET_FIRE_LOG);
  }
}

/*
==============
CG_DebugBulletFireLog_AddServerEntry
==============
*/
void CG_DebugBulletFireLog_AddServerEntry(const int entNum, const int serverTime, const vec3_t *bulletOrigin, const vec3_t *bulletDir)
{
  __int64 v11; 
  gentity_s *v16; 
  bool v17; 
  gclient_s *client; 
  bool v20; 
  bool v22; 
  bool v23; 
  char *fmt; 
  char *fmta; 
  double v82; 
  __int64 v83; 
  double v84; 
  __int64 v85; 
  double v86; 
  __int64 v87; 
  double v88; 
  __int64 v89; 
  double v90; 
  __int64 v91; 
  double v92; 
  __int64 v93; 
  double v94; 
  __int64 v95; 
  double v96; 
  __int64 v97; 
  double v98; 
  __int64 v99; 
  double v100; 
  __int64 v101; 

  v11 = entNum;
  if ( CG_DebugBulletFireLog_ShouldLog(entNum) )
  {
    Sys_EnterCriticalSection(CRITSECT_DEBUG_BULLET_FIRE_LOG);
    _RDI = &s_debugBulletFireInfoLog;
    while ( !_RDI->entries[0].isUsed || _RDI->entries[0].serverTime != serverTime )
    {
      _RDI = (DebugBulletFireInfoLog *)((char *)_RDI + 160);
      if ( (__int64)_RDI >= (__int64)&s_debugBulletFireInfoLog.entryCount )
        goto LABEL_15;
    }
    v16 = &g_entities[v11];
    v17 = CgWeaponMap::ms_instance[0] == NULL;
    __asm { vmovaps [rsp+0F8h+var_28], xmm6 }
    client = v16->client;
    _RDI->entries[0].serverBulletEntryAdded = 1;
    _RDI->entries[0].serverBulletOrigin.v[0] = bulletOrigin->v[0];
    _RDI->entries[0].serverBulletOrigin.v[1] = bulletOrigin->v[1];
    _RDI->entries[0].serverBulletOrigin.v[2] = bulletOrigin->v[2];
    _RDI->entries[0].serverBulletDir.v[0] = bulletDir->v[0];
    _RDI->entries[0].serverBulletDir.v[1] = bulletDir->v[1];
    _RDI->entries[0].serverBulletDir.v[2] = bulletDir->v[2];
    _RDI->entries[0].serverGunPitch = v16->client->fGunPitch;
    _RDI->entries[0].serverGunYaw = v16->client->fGunYaw;
    _RDI->entries[0].serverViewAngles.v[0] = client->ps.viewangles.v[0];
    _RDI->entries[0].serverViewAngles.v[1] = client->ps.viewangles.v[1];
    _RDI->entries[0].serverViewAngles.v[2] = client->ps.viewangles.v[2];
    _RDI->entries[0].serverDeltaAngles.v[0] = client->ps.delta_angles.v[0];
    _RDI->entries[0].serverDeltaAngles.v[1] = client->ps.delta_angles.v[1];
    _RDI->entries[0].serverDeltaAngles.v[2] = client->ps.delta_angles.v[2];
    _RDI->entries[0].serverAdsStartTime = client->ps.weapCommon.adsStartTime;
    _RDI->entries[0].serverAdsFraction = client->ps.weapCommon.fWeaponPosFrac;
    if ( v17 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
      __debugbreak();
    __asm
    {
      vmovaps [rsp+0F8h+var_38], xmm7
      vmovaps [rsp+0F8h+var_48], xmm8
      vmovaps [rsp+0F8h+var_58], xmm9
      vmovaps [rsp+0F8h+var_68], xmm10
      vmovaps [rsp+0F8h+var_78], xmm11
    }
    *(double *)&_XMM0 = BG_WeaponADSFractionAffectedByReload(CgWeaponMap::ms_instance[0], &client->ps);
    __asm
    {
      vmovss  xmm2, cs:__real@3a83126f; epsilon
      vmovss  dword ptr [rdi+78h], xmm0
    }
    _RDI->entries[0].serverIdleTimer1 = client->ps.weapCommon.weaponIdleTime;
    _RDI->entries[0].serverIdleTimer2 = client->ps.weapCommon.weaponIdleTime2;
    v20 = VecNCompareCustomEpsilon(_RDI->entries[0].clientBulletOrigin.v, _RDI->entries[0].serverBulletOrigin.v, *(float *)&_XMM2, 3);
    __asm { vmovss  xmm2, cs:__real@3a83126f; epsilon }
    v22 = v20;
    v23 = VecNCompareCustomEpsilon(_RDI->entries[0].clientBulletDir.v, _RDI->entries[0].serverBulletDir.v, *(float *)&_XMM2, 3);
    if ( v22 && v23 )
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rdi+98h]
        vmovss  xmm1, dword ptr [rdi+94h]
        vmovss  xmm2, dword ptr [rdi+90h]
        vmovss  xmm4, dword ptr [rdi+4Ch]
        vmovss  xmm5, dword ptr [rdi+48h]
        vmovss  xmm6, dword ptr [rdi+44h]
        vmovss  xmm7, dword ptr [rdi+8Ch]
        vmovss  xmm8, dword ptr [rdi+88h]
        vmovss  xmm9, dword ptr [rdi+84h]
        vmovss  xmm10, dword ptr [rdi+40h]
        vmovss  xmm3, dword ptr [rdi+38h]
        vmovss  xmm11, dword ptr [rdi+3Ch]
        vcvtss2sd xmm0, xmm0, xmm0
        vmovsd  [rsp+0F8h+var_88], xmm0
        vcvtss2sd xmm1, xmm1, xmm1
        vmovsd  [rsp+0F8h+var_90], xmm1
        vcvtss2sd xmm2, xmm2, xmm2
        vmovsd  [rsp+0F8h+var_98], xmm2
        vcvtss2sd xmm4, xmm4, xmm4
        vmovsd  [rsp+0F8h+var_A0], xmm4
        vcvtss2sd xmm5, xmm5, xmm5
        vmovsd  [rsp+0F8h+var_A8], xmm5
        vcvtss2sd xmm3, xmm3, xmm3
        vcvtss2sd xmm6, xmm6, xmm6
        vmovsd  [rsp+0F8h+var_B0], xmm6
        vcvtss2sd xmm7, xmm7, xmm7
        vmovsd  [rsp+0F8h+var_B8], xmm7
        vcvtss2sd xmm8, xmm8, xmm8
        vmovsd  [rsp+0F8h+var_C0], xmm8
        vcvtss2sd xmm9, xmm9, xmm9
        vmovsd  [rsp+0F8h+var_C8], xmm9
        vcvtss2sd xmm10, xmm10, xmm10
        vcvtss2sd xmm11, xmm11, xmm11
        vmovsd  [rsp+0F8h+var_D0], xmm10
        vmovq   r9, xmm3
        vmovsd  [rsp+0F8h+fmt], xmm11
      }
      Com_Printf(17, "Bullet fire matched. Time: %d CL Origin[%.4f, %.4f, %.4f] SV Origin[%.4f, %.4f, %.4f] CL Dir[%.4f, %.4f, %.4f] SV Dir[%.4f, %.4f, %.4f]\n", (unsigned int)serverTime, *(double *)&_XMM3, *(double *)&fmt, v82, v84, v86, v88, v90, v92, v94, v96, v98, v100);
    }
    else
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rdi+98h]
        vmovss  xmm1, dword ptr [rdi+94h]
        vmovss  xmm2, dword ptr [rdi+90h]
        vmovss  xmm4, dword ptr [rdi+4Ch]
        vmovss  xmm5, dword ptr [rdi+48h]
        vmovss  xmm6, dword ptr [rdi+44h]
        vmovss  xmm7, dword ptr [rdi+8Ch]
        vmovss  xmm8, dword ptr [rdi+88h]
        vmovss  xmm9, dword ptr [rdi+84h]
        vmovss  xmm10, dword ptr [rdi+40h]
        vmovss  xmm3, dword ptr [rdi+38h]
        vmovss  xmm11, dword ptr [rdi+3Ch]
        vcvtss2sd xmm0, xmm0, xmm0
        vmovsd  [rsp+0F8h+var_88], xmm0
        vcvtss2sd xmm1, xmm1, xmm1
        vmovsd  [rsp+0F8h+var_90], xmm1
        vcvtss2sd xmm2, xmm2, xmm2
        vmovsd  [rsp+0F8h+var_98], xmm2
        vcvtss2sd xmm4, xmm4, xmm4
        vmovsd  [rsp+0F8h+var_A0], xmm4
        vcvtss2sd xmm5, xmm5, xmm5
        vmovsd  [rsp+0F8h+var_A8], xmm5
        vcvtss2sd xmm3, xmm3, xmm3
        vcvtss2sd xmm6, xmm6, xmm6
        vmovsd  [rsp+0F8h+var_B0], xmm6
        vcvtss2sd xmm7, xmm7, xmm7
        vmovsd  [rsp+0F8h+var_B8], xmm7
        vcvtss2sd xmm8, xmm8, xmm8
        vmovsd  [rsp+0F8h+var_C0], xmm8
        vcvtss2sd xmm9, xmm9, xmm9
        vmovsd  [rsp+0F8h+var_C8], xmm9
        vcvtss2sd xmm10, xmm10, xmm10
        vcvtss2sd xmm11, xmm11, xmm11
        vmovsd  [rsp+0F8h+var_D0], xmm10
        vmovq   r9, xmm3
        vmovsd  [rsp+0F8h+fmt], xmm11
      }
      Com_PrintWarning(17, "Bullet fire mismatch. Time: %d CL Origin[%.4f, %.4f, %.4f] SV Origin[%.4f, %.4f, %.4f] CL Dir[%.4f, %.4f, %.4f] SV Dir[%.4f, %.4f, %.4f]\n", (unsigned int)serverTime, _R9, fmta, v83, v85, v87, v89, v91, v93, v95, v97, v99, v101);
    }
    __asm
    {
      vmovaps xmm10, [rsp+0F8h+var_68]
      vmovaps xmm9, [rsp+0F8h+var_58]
      vmovaps xmm8, [rsp+0F8h+var_48]
      vmovaps xmm7, [rsp+0F8h+var_38]
      vmovaps xmm11, [rsp+0F8h+var_78]
      vmovaps xmm6, [rsp+0F8h+var_28]
    }
LABEL_15:
    Sys_LeaveCriticalSection(CRITSECT_DEBUG_BULLET_FIRE_LOG);
  }
}

/*
==============
CG_DebugBulletFireLog_Compact
==============
*/
void CG_DebugBulletFireLog_Compact(const int serverTime)
{
  char v2; 
  bool *p_isUsed; 
  int v4; 
  int v5; 
  int v6; 
  int v7; 
  int v8; 
  int v9; 
  int v10; 
  int v11; 
  int v12; 
  int v13; 

  Sys_EnterCriticalSection(CRITSECT_DEBUG_BULLET_FIRE_LOG);
  v2 = 0;
  p_isUsed = &s_debugBulletFireInfoLog.entries[2].isUsed;
  do
  {
    if ( *(p_isUsed - 320) )
    {
      v4 = *((_DWORD *)p_isUsed - 119);
      if ( v4 > serverTime || serverTime - v4 > 120000 )
      {
        memset_0(p_isUsed - 476, 0, 0xA0ui64);
        --s_debugBulletFireInfoLog.entryCount;
        v2 = 1;
      }
    }
    if ( *(p_isUsed - 160) )
    {
      v5 = *((_DWORD *)p_isUsed - 79);
      if ( v5 > serverTime || serverTime - v5 > 120000 )
      {
        memset_0(p_isUsed - 316, 0, 0xA0ui64);
        --s_debugBulletFireInfoLog.entryCount;
        v2 = 1;
      }
    }
    if ( *p_isUsed )
    {
      v6 = *((_DWORD *)p_isUsed - 39);
      if ( v6 > serverTime || serverTime - v6 > 120000 )
      {
        memset_0(p_isUsed - 156, 0, 0xA0ui64);
        --s_debugBulletFireInfoLog.entryCount;
        v2 = 1;
      }
    }
    if ( p_isUsed[160] )
    {
      v7 = *((_DWORD *)p_isUsed + 1);
      if ( v7 > serverTime || serverTime - v7 > 120000 )
      {
        memset_0(p_isUsed + 4, 0, 0xA0ui64);
        --s_debugBulletFireInfoLog.entryCount;
        v2 = 1;
      }
    }
    if ( p_isUsed[320] )
    {
      v8 = *((_DWORD *)p_isUsed + 41);
      if ( v8 > serverTime || serverTime - v8 > 120000 )
      {
        memset_0(p_isUsed + 164, 0, 0xA0ui64);
        --s_debugBulletFireInfoLog.entryCount;
        v2 = 1;
      }
    }
    if ( p_isUsed[480] )
    {
      v9 = *((_DWORD *)p_isUsed + 81);
      if ( v9 > serverTime || serverTime - v9 > 120000 )
      {
        memset_0(p_isUsed + 324, 0, 0xA0ui64);
        --s_debugBulletFireInfoLog.entryCount;
        v2 = 1;
      }
    }
    if ( p_isUsed[640] )
    {
      v10 = *((_DWORD *)p_isUsed + 121);
      if ( v10 > serverTime || serverTime - v10 > 120000 )
      {
        memset_0(p_isUsed + 484, 0, 0xA0ui64);
        --s_debugBulletFireInfoLog.entryCount;
        v2 = 1;
      }
    }
    if ( p_isUsed[800] )
    {
      v11 = *((_DWORD *)p_isUsed + 161);
      if ( v11 > serverTime || serverTime - v11 > 120000 )
      {
        memset_0(p_isUsed + 644, 0, 0xA0ui64);
        --s_debugBulletFireInfoLog.entryCount;
        v2 = 1;
      }
    }
    if ( p_isUsed[960] )
    {
      v12 = *((_DWORD *)p_isUsed + 201);
      if ( v12 > serverTime || serverTime - v12 > 120000 )
      {
        memset_0(p_isUsed + 804, 0, 0xA0ui64);
        --s_debugBulletFireInfoLog.entryCount;
        v2 = 1;
      }
    }
    if ( p_isUsed[1120] )
    {
      v13 = *((_DWORD *)p_isUsed + 241);
      if ( v13 > serverTime || serverTime - v13 > 120000 )
      {
        memset_0(p_isUsed + 964, 0, 0xA0ui64);
        --s_debugBulletFireInfoLog.entryCount;
        v2 = 1;
      }
    }
    p_isUsed += 1600;
  }
  while ( (__int64)p_isUsed < (__int64)&unk_1512FCD8C );
  if ( v2 )
    std::_Sort_unchecked<DebugBulletFireInfoEntry *,bool (*)(DebugBulletFireInfoEntry &,DebugBulletFireInfoEntry &)>(s_debugBulletFireInfoLog.entries, (DebugBulletFireInfoEntry *)&s_debugBulletFireInfoLog.entryCount, 50i64, CG_DebugBulletFireLog_Sorter);
  Sys_LeaveCriticalSection(CRITSECT_DEBUG_BULLET_FIRE_LOG);
}

/*
==============
CG_DebugBulletFireLog_GetEntry
==============
*/
const DebugBulletFireInfoEntry *CG_DebugBulletFireLog_GetEntry(int entryIndex)
{
  __int64 v1; 
  int entryCount; 

  v1 = entryIndex;
  if ( (unsigned int)entryIndex >= s_debugBulletFireInfoLog.entryCount )
  {
    entryCount = s_debugBulletFireInfoLog.entryCount;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1317, ASSERT_TYPE_ASSERT, "(unsigned)( entryIndex ) < (unsigned)( s_debugBulletFireInfoLog.entryCount )", "entryIndex doesn't index s_debugBulletFireInfoLog.entryCount\n\t%i not in [0, %i)", entryIndex, entryCount) )
      __debugbreak();
  }
  return (const DebugBulletFireInfoEntry *)((char *)&s_debugBulletFireInfoLog + 160 * v1);
}

/*
==============
CG_DebugBulletFireLog_GetNumEntries
==============
*/
__int64 CG_DebugBulletFireLog_GetNumEntries()
{
  return (unsigned int)s_debugBulletFireInfoLog.entryCount;
}

/*
==============
CG_DebugBulletFireLog_ShouldLog
==============
*/
bool CG_DebugBulletFireLog_ShouldLog(const int entNum)
{
  const dvar_t *v1; 
  cg_t *LocalClientGlobals; 
  bool result; 

  v1 = DVARINT_debugOverlay;
  if ( !DVARINT_debugOverlay && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "debugOverlay") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  result = 0;
  if ( v1->current.integer == 10 )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals(LOCAL_CLIENT_0);
    if ( LocalClientGlobals->predictedPlayerState.clientNum == entNum && !LocalClientGlobals->inKillCam && !GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&LocalClientGlobals->predictedPlayerState.otherFlags, GameModeFlagValues::ms_mpValue, 0x21u) )
      return 1;
  }
  return result;
}

/*
==============
CG_DebugBulletFireLog_Sorter
==============
*/
bool CG_DebugBulletFireLog_Sorter(DebugBulletFireInfoEntry *sortItem1, DebugBulletFireInfoEntry *sortItem2)
{
  return sortItem1->isUsed && !sortItem2->isUsed || sortItem1->serverTime > sortItem2->serverTime;
}

/*
==============
CG_DisplayViewmodelAnim
==============
*/
void CG_DisplayViewmodelAnim(LocalClientNum_t localClientNum)
{
  cg_t *LocalClientGlobals; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  DObjDisplayAnim(LocalClientGlobals->m_weaponHand[0].viewModelDObj, (const char *)&queryFormat.fmt + 3);
}

/*
==============
CG_EjectWeaponBrass
==============
*/
void CG_EjectWeaponBrass(LocalClientNum_t localClientNum, const entityState_t *ent, int event, bool isAlternate)
{
  const dvar_t *v8; 
  CgWeaponMap *Instance; 
  const Weapon *WeaponForEntity; 
  cg_t *LocalClientGlobals; 
  int number; 
  playerState_s *p_predictedPlayerState; 
  bool v14; 
  bool v15; 
  FxCombinedDef v16; 
  const ParticleSystemDef *particleSystemDef; 
  FxCombinedDef v18; 
  PlayerHandIndex HandFromWeaponEvent; 
  int v20; 
  FXRegisteredDef fxDef; 
  __int64 v22; 

  v22 = -2i64;
  v8 = DVARBOOL_cg_brass;
  if ( !DVARBOOL_cg_brass && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_brass") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v8);
  if ( v8->current.enabled && ent->eType < ET_EVENTS )
  {
    Instance = CgWeaponMap::GetInstance(localClientNum);
    WeaponForEntity = BG_GetWeaponForEntity(Instance, ent);
    if ( WeaponForEntity->weaponIdx )
    {
      if ( WeaponForEntity->weaponIdx < BG_GetNumWeapons() )
      {
        Sys_ProfBeginNamedEvent(0xFFFFFFFF, "CG_EjectWeaponBrass");
        LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
        number = ent->number;
        p_predictedPlayerState = &LocalClientGlobals->predictedPlayerState;
        if ( LocalClientGlobals == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_local.h", 120, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
          __debugbreak();
        v14 = number == p_predictedPlayerState->clientNum || p_predictedPlayerState->viewlocked && p_predictedPlayerState->viewlocked_entNum == number;
        v15 = (BG_IsPlayer(p_predictedPlayerState) || BG_IsAgent(p_predictedPlayerState) || BG_IsSpectating(p_predictedPlayerState)) && v14;
        BG_WeaponDef(WeaponForEntity, isAlternate);
        if ( v15 )
          v16.particleSystemDef = BG_ViewShellEjectEffect(WeaponForEntity, isAlternate).particleSystemDef;
        else
          v16.particleSystemDef = BG_WorldShellEjectEffect(WeaponForEntity, isAlternate).particleSystemDef;
        particleSystemDef = v16.particleSystemDef;
        if ( BG_IsLastShotWeaponEvent(event) )
        {
          v18.particleSystemDef = v15 ? BG_ViewLastShotEjectEffect(WeaponForEntity, isAlternate).particleSystemDef : BG_WorldLastShotEjectEffect(WeaponForEntity, isAlternate).particleSystemDef;
          if ( v18.particleSystemDef )
            particleSystemDef = v18.particleSystemDef;
        }
        if ( particleSystemDef )
        {
          fxDef.m_particleSystemDef = particleSystemDef;
          HandFromWeaponEvent = BG_GetHandFromWeaponEvent(event);
          if ( CG_IsPlayerEntityNumber(p_predictedPlayerState, ent->number) )
            v20 = HandFromWeaponEvent + 2048;
          else
            v20 = ent->number;
          CG_PlayBoltedEffect(localClientNum, &fxDef, v20, scr_const.tag_brass);
          CG_PlayBoltedEffect(localClientNum, &fxDef, v20, scr_const.tag_brass_2);
        }
        Sys_ProfEndNamedEvent();
      }
      else
      {
        Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1442DFC60, 616i64);
      }
    }
  }
}

/*
==============
CG_Entity_HasWeapon
==============
*/
bool CG_Entity_HasWeapon(LocalClientNum_t localClientNum, centity_t *cent)
{
  CgStatic *LocalClientStatics; 
  const characterInfo_t *CharacterInfo; 

  if ( (cent->flags & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 19041, ASSERT_TYPE_ASSERT, "(CENextValid( cent ))", (const char *)&queryFormat, "CENextValid( cent )") )
    __debugbreak();
  if ( !ComCharacterLimits::ms_isGameDataValid && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_character_limits.h", 123, ASSERT_TYPE_ASSERT, "(ms_isGameDataValid)", (const char *)&queryFormat, "ms_isGameDataValid") )
    __debugbreak();
  if ( cent->nextState.number >= (int)ComCharacterLimits::ms_gameData.m_characterCount )
    return cent->nextState.weaponHandle.m_mapEntryId != 0;
  LocalClientStatics = CgStatic::GetLocalClientStatics(localClientNum);
  if ( !LocalClientStatics && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 19045, ASSERT_TYPE_ASSERT, "( ( cgameStatic != nullptr ) )", "( cgameStatic ) = %p", NULL) )
    __debugbreak();
  if ( !LocalClientStatics->HasCharacterInfo(LocalClientStatics, cent->nextState.number) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 19047, ASSERT_TYPE_ASSERT, "(cgameStatic->HasCharacterInfo( cent->nextState.number ))", (const char *)&queryFormat, "cgameStatic->HasCharacterInfo( cent->nextState.number )") )
    __debugbreak();
  CharacterInfo = CgStatic::GetCharacterInfo(LocalClientStatics, cent->nextState.number);
  if ( !CharacterInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 19050, ASSERT_TYPE_ASSERT, "( ( ci != nullptr ) )", "( ci ) = %p", NULL) )
    __debugbreak();
  return CharacterInfo->dobjHeldWeapon.weaponIdx || CharacterInfo->dobjStowedWeapon.weaponIdx || CharacterInfo->dobjThrownWeapon.weaponIdx || CharacterInfo->dobjTurretWeapon.weaponIdx || CharacterInfo->dobjExecutionWeapon.weaponIdx || CharacterInfo->dobjAccessoryWeapon.weaponIdx;
}

/*
==============
CG_ExplosiveImpactOnShieldEvent
==============
*/
void CG_ExplosiveImpactOnShieldEvent(LocalClientNum_t localClientNum)
{
  cg_t *LocalClientGlobals; 
  const dvar_t *v3; 
  int integer; 
  float fmt; 
  vec3_t outOrg; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  RefdefView_GetOrg(&LocalClientGlobals->refdef.view, &outOrg);
  v3 = DVARINT_shieldImpactMissileShakeDuration;
  if ( !DVARINT_shieldImpactMissileShakeDuration && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "shieldImpactMissileShakeDuration") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v3);
  integer = v3->current.integer;
  _RDI = DVARFLT_shieldImpactMissileShakeScale;
  if ( !DVARFLT_shieldImpactMissileShakeScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "shieldImpactMissileShakeScale") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RDI);
  __asm
  {
    vmovss  xmm0, cs:__real@42c80000
    vmovss  dword ptr [rsp+68h+fmt], xmm0
    vmovss  xmm1, dword ptr [rdi+28h]; scale
  }
  CG_StartShakeCamera(localClientNum, *(float *)&_XMM1, integer, &outOrg, fmt);
  CG_Rumble_PlayOnClientSafeByName(localClientNum, "riotshield_impact");
  memset(&outOrg, 0, sizeof(outOrg));
}

/*
==============
CG_ExplosiveSplashOnShieldEvent
==============
*/
void CG_ExplosiveSplashOnShieldEvent(LocalClientNum_t localClientNum, int originalDamage)
{
  const dvar_t *v5; 
  const dvar_t *v8; 
  const char *v9; 
  int integer; 
  cg_t *LocalClientGlobals; 
  float fmt; 
  vec3_t outOrg; 

  __asm { vmovaps [rsp+78h+var_18], xmm6 }
  v5 = DVARINT_shieldImpactExplosionThreshold;
  if ( !DVARINT_shieldImpactExplosionThreshold && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "shieldImpactExplosionThreshold") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v5);
  if ( originalDamage <= v5->current.integer )
  {
    _RDI = DVARFLT_shieldImpactExplosionLowShakeScale;
    if ( !DVARFLT_shieldImpactExplosionLowShakeScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "shieldImpactExplosionLowShakeScale") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RDI);
    __asm { vmovss  xmm6, dword ptr [rdi+28h] }
    v8 = DVARINT_shieldImpactExplosionLowShakeDuration;
    if ( !DVARINT_shieldImpactExplosionLowShakeDuration )
    {
      v9 = "shieldImpactExplosionLowShakeDuration";
LABEL_15:
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", v9) )
        __debugbreak();
    }
  }
  else
  {
    _RDI = DVARFLT_shieldImpactExplosionHighShakeScale;
    if ( !DVARFLT_shieldImpactExplosionHighShakeScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "shieldImpactExplosionHighShakeScale") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RDI);
    __asm { vmovss  xmm6, dword ptr [rdi+28h] }
    v8 = DVARINT_shieldImpactExplosionHighShakeDuration;
    if ( !DVARINT_shieldImpactExplosionHighShakeDuration )
    {
      v9 = "shieldImpactExplosionHighShakeDuration";
      goto LABEL_15;
    }
  }
  Dvar_CheckFrontendServerThread(v8);
  integer = v8->current.integer;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  RefdefView_GetOrg(&LocalClientGlobals->refdef.view, &outOrg);
  __asm
  {
    vmovss  xmm0, cs:__real@42c80000
    vmovss  dword ptr [rsp+78h+fmt], xmm0
    vmovaps xmm1, xmm6; scale
  }
  CG_StartShakeCamera(localClientNum, *(float *)&_XMM1, integer, &outOrg, fmt);
  CG_Rumble_PlayOnClientSafeByName(localClientNum, "riotshield_impact");
  memset(&outOrg, 0, sizeof(outOrg));
  __asm { vmovaps xmm6, [rsp+78h+var_18] }
}

/*
==============
CG_FireWeapSound
==============
*/
void CG_FireWeapSound(const LocalClientNum_t localClientNum, centity_t *cent, const Weapon *weapon, const scr_string_t tagName, bool isPlayerView, bool isAlternate, bool isPlayerHeli, bool isDualWield, bool useLastFireSound, PlayerHandIndex hand, const int autoSimId, const __int64 autoSimTimeStamp, const float autoSimDistSq, const SndWeapShotCountId shotCount, const GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64> *pm_flags)
{
  float v19; 
  vec3_t origin; 

  CG_FireWeaponSound_CalcOrigin(localClientNum, cent, weapon, tagName, isPlayerView, hand, &origin);
  __asm
  {
    vmovss  xmm0, [rsp+0A8h+autoSimDistSq]
    vmovss  [rsp+0A8h+var_50], xmm0
  }
  CG_FireWeapSound_KnownOrigin(localClientNum, cent, weapon, isPlayerView, isAlternate, isPlayerHeli, isDualWield, useLastFireSound, hand, autoSimId, autoSimTimeStamp, v19, shotCount, pm_flags, &origin);
  memset(&origin, 0, sizeof(origin));
}

/*
==============
CG_FireWeapSound_KnownOrigin
==============
*/
void CG_FireWeapSound_KnownOrigin(const LocalClientNum_t localClientNum, centity_t *cent, const Weapon *weapon, bool isPlayerView, bool isAlternate, bool isPlayerHeli, bool isDualWield, bool useLastFireSound, PlayerHandIndex hand, const int autoSimId, const __int64 autoSimTimeStamp, const float autoSimDistSq, const SndWeapShotCountId shotCount, const GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64> *pm_flags, const vec3_t *origin)
{
  CgSoundSystem *SoundSystem; 
  bool v21; 
  const HyperBurstInfo *HyperBurstInfo; 
  const SndAliasList *WeapHyperBurstFireSound; 
  bool v25; 
  CgWeaponSystem *WeaponSystem; 
  PlayerHandIndex v28; 
  PlayerHandIndex v29; 
  SndWeapShotCountId v30; 
  SndWeapShotCountId v31; 
  int v32; 
  int v33; 
  int v34; 
  int v35; 
  const SndAliasList *WeapFireSound; 
  WeaponSFXPackage *sfxPackage; 

  Sys_ProfBeginNamedEvent(0xFF008080, "CG_FireWeapSound");
  sfxPackage = BG_GetSfxPackage(weapon, isAlternate);
  WeapFireSound = CG_GetWeapFireSound(sfxPackage, isPlayerView, isPlayerHeli, isDualWield, useLastFireSound, hand, shotCount);
  if ( WeapFireSound )
  {
    __asm { vmovaps [rsp+0C8h+var_38], xmm6 }
    SoundSystem = CgSoundSystem::GetSoundSystem(localClientNum);
    Sys_ProfBeginNamedEvent(0xFF008080, "PlayWeaponSound");
    v21 = isPlayerView || isPlayerHeli;
    __asm
    {
      vmovss  xmm6, [rsp+0C8h+autoSimDistSq]
      vmovss  [rsp+0C8h+var_80], xmm6
    }
    LOBYTE(v30) = v21;
    LOBYTE(v28) = isAlternate;
    ((void (__fastcall *)(CgSoundSystem *, _QWORD, const vec3_t *, const SndAliasList *, const Weapon *, PlayerHandIndex, SndWeapShotCountId, const int, const __int64, int, const SndWeapShotCountId, const GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64> *, bool, PlayerHandIndex, _BYTE))SoundSystem->PlayWeaponSound)(SoundSystem, (unsigned int)cent->nextState.number, origin, WeapFireSound, weapon, v28, v30, autoSimId, autoSimTimeStamp, v32, shotCount, pm_flags, isDualWield, hand, 0);
    Sys_ProfEndNamedEvent();
    if ( !useLastFireSound && shotCount == SND_WEAP_SHOT_FIRST )
    {
      HyperBurstInfo = BG_GetHyperBurstInfo(weapon, isAlternate);
      if ( !HyperBurstInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18838, ASSERT_TYPE_ASSERT, "(hyperBurstInfo)", (const char *)&queryFormat, "hyperBurstInfo") )
        __debugbreak();
      if ( HyperBurstInfo->enabled )
      {
        WeapHyperBurstFireSound = CG_GetWeapHyperBurstFireSound(sfxPackage, isPlayerView, isDualWield, hand);
        if ( WeapHyperBurstFireSound )
        {
          Sys_ProfBeginNamedEvent(0xFF008080, "PlayWeaponSound");
          v25 = isPlayerView || isPlayerHeli;
          LOBYTE(v35) = 1;
          LOBYTE(v34) = isDualWield;
          __asm { vmovss  [rsp+0C8h+var_80], xmm6 }
          LOBYTE(v31) = v25;
          LOBYTE(v29) = isAlternate;
          ((void (__fastcall *)(CgSoundSystem *, _QWORD, const vec3_t *, const SndAliasList *, const Weapon *, PlayerHandIndex, SndWeapShotCountId, const int, const __int64, int, int, const GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64> *, int, PlayerHandIndex, int))SoundSystem->PlayWeaponSound)(SoundSystem, (unsigned int)cent->nextState.number, origin, WeapHyperBurstFireSound, weapon, v29, v31, autoSimId, autoSimTimeStamp, v33, 1, pm_flags, v34, hand, v35);
          Sys_ProfEndNamedEvent();
        }
      }
    }
    __asm { vmovaps xmm6, [rsp+0C8h+var_38] }
    if ( BG_IsCharacterEntity(&cent->nextState) )
    {
      WeaponSystem = CgWeaponSystem::GetWeaponSystem(localClientNum);
      if ( WeaponSystem->ShouldWeaponPing(WeaponSystem, cent, weapon, isAlternate, origin) )
        CG_SndPingCompass(localClientNum, cent, weapon, isAlternate, origin);
    }
  }
  Sys_ProfEndNamedEvent();
}

/*
==============
CG_FireWeapon
==============
*/
void CG_FireWeapon(LocalClientNum_t localClientNum, centity_t *cent, int event, int knownHitClientNum, const TagPair weaponFlashTagPair, const Weapon *weapon, bool isAlternate, PlayerHandIndex hand, bool isPlayerView, bool isDualWield, bool bNoTracer)
{
  CG_FireWeapon_Internal(localClientNum, cent, event, knownHitClientNum, weaponFlashTagPair, weapon, isAlternate, hand, isPlayerView, isDualWield, bNoTracer, 0, NULL, NULL);
}

/*
==============
CG_FireWeaponRicochet
==============
*/
void CG_FireWeaponRicochet(LocalClientNum_t localClientNum, centity_t *attackerEnt, centity_t *shieldEnt, const vec3_t *firePos, const vec3_t *fireDir, int ricochetCount, float travelDistance, const Weapon *weapon, bool isAlternate, PlayerHandIndex hand, bool isPlayerView)
{
  playerState_s *p_predictedPlayerState; 
  entityState_t *p_nextState; 
  CgStatic *LocalClientStatics; 
  const characterInfo_t *CharacterInfo; 
  CgWeaponMap *Instance; 
  CgBallistics *System; 
  __int64 p_perks; 
  PlayerHandIndex v40; 
  meansOfDeath_t MethodOfDeath; 
  CgWeaponSystem *WeaponSystem; 
  bool shouldSpawnTracer; 
  TagPair *v65; 
  TagPair tagPair; 
  int v67; 
  float v69; 
  TagPair v70; 
  const vec3_t *v71; 
  bitarray<64> perks; 
  BulletFireParams v73; 

  v71 = firePos;
  v70 = (TagPair)shieldEnt;
  if ( !attackerEnt && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 19327, ASSERT_TYPE_ASSERT, "(attackerEnt)", (const char *)&queryFormat, "attackerEnt") )
    __debugbreak();
  if ( (attackerEnt->flags & 1) != 0 )
  {
    p_predictedPlayerState = NULL;
    p_nextState = &attackerEnt->nextState;
    __asm
    {
      vmovaps [rsp+1E0h+var_40], xmm6
      vmovaps [rsp+1E0h+var_50], xmm7
      vmovaps [rsp+1E0h+var_60], xmm8
      vmovaps [rsp+1E0h+var_70], xmm9
      vmovaps [rsp+1E0h+var_80], xmm10
      vmovaps [rsp+1E0h+var_90], xmm11
      vmovaps [rsp+1E0h+var_A0], xmm12
    }
    perks = 0i64;
    if ( BG_IsCharacterEntity(&attackerEnt->nextState) )
    {
      LocalClientStatics = CgStatic::GetLocalClientStatics(localClientNum);
      CharacterInfo = CgStatic::GetCharacterInfo(LocalClientStatics, p_nextState->number);
      if ( CharacterInfo )
      {
        if ( CharacterInfo->infoValid )
          perks = CharacterInfo->perks;
      }
    }
    if ( !BG_WeaponBulletFire_ShouldRicochet(perks, weapon, isAlternate) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 19347, ASSERT_TYPE_ASSERT, "(BG_WeaponBulletFire_ShouldRicochet( attackerPerks, weapon, isAlternate ))", (const char *)&queryFormat, "BG_WeaponBulletFire_ShouldRicochet( attackerPerks, weapon, isAlternate )") )
      __debugbreak();
    Instance = CgWeaponMap::GetInstance(localClientNum);
    if ( isPlayerView )
      p_predictedPlayerState = &CG_GetLocalClientGlobals(localClientNum)->predictedPlayerState;
    System = CgBallistics::GetSystem(localClientNum);
    *(double *)&_XMM0 = BG_GetBulletRange<CgBallisticInstance>(Instance, System, p_predictedPlayerState, &attackerEnt->nextState, &perks, weapon, isAlternate);
    __asm
    {
      vmovss  xmm11, [rbp+0E0h+travelDistance]
      vsubss  xmm2, xmm0, xmm11
      vxorps  xmm1, xmm1, xmm1
      vmaxss  xmm9, xmm2, xmm1
      vmovaps xmm10, xmm0
    }
    *(double *)&_XMM0 = BG_GetADSDamageRangeScale(Instance, p_predictedPlayerState, weapon, isAlternate);
    __asm
    {
      vmovss  xmm7, cs:__real@3f800000
      vmovaps xmm12, xmm0
    }
    if ( p_predictedPlayerState )
    {
      p_perks = (__int64)&p_predictedPlayerState->perks;
      if ( BG_HasPerk(&p_predictedPlayerState->perks, 0x18u) )
      {
        _RSI = DCONST_DVARFLT_perk_longerRangeScale;
        if ( !DCONST_DVARFLT_perk_longerRangeScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "perk_longerRangeScale") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(_RSI);
        __asm { vmovss  xmm8, dword ptr [rsi+28h] }
        p_nextState = &attackerEnt->nextState;
        goto LABEL_22;
      }
    }
    else
    {
      p_perks = 4464i64;
    }
    __asm { vmovaps xmm8, xmm7 }
LABEL_22:
    if ( p_predictedPlayerState && BG_HasPerk((const bitarray<64> *)p_perks, 0x1Cu) )
    {
      _RDI = DVARFLT_perk_bulletPenetrationMultiplier;
      if ( !DVARFLT_perk_bulletPenetrationMultiplier && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "perk_bulletPenetrationMultiplier") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(_RDI);
      __asm { vmovss  xmm6, dword ptr [rdi+28h] }
    }
    else
    {
      __asm { vmovaps xmm6, xmm7 }
    }
    if ( p_predictedPlayerState )
    {
      v40 = hand;
      if ( p_predictedPlayerState->weapState[hand].weaponFiredAtMaxCharge && BG_IsChargeShotWeapon(weapon, isAlternate) )
      {
        *(double *)&_XMM0 = BG_WeaponCharge_GetFireAtMaxDamageMultiplier(weapon, isAlternate);
        __asm { vmovaps xmm7, xmm0 }
      }
    }
    else
    {
      v40 = hand;
    }
    memset_0(&v73, 0, sizeof(v73));
    v73.weaponEntIndex = p_nextState->number;
    _RAX = v71;
    __asm
    {
      vmulss  xmm0, xmm8, xmm12
      vmovss  [rbp+0E0h+var_150.rangeScale], xmm0
      vmovss  [rbp+0E0h+var_150.penetrationMultiplier], xmm6
      vmovss  xmm1, dword ptr [rax]
      vmovss  xmm4, dword ptr [rax+4]
      vmovss  xmm5, dword ptr [rax+8]
    }
    _RAX = fireDir;
    __asm
    {
      vmovss  dword ptr [rbp+0E0h+var_150.start], xmm1
      vmovss  [rbp+0E0h+var_150.chargedDamageMultiplier], xmm7
      vmovss  dword ptr [rbp+0E0h+var_150.start+4], xmm4
      vmovss  xmm0, dword ptr [rax]
      vmovss  xmm2, dword ptr [rax+4]
      vmovss  xmm3, dword ptr [rax+8]
      vmovss  dword ptr [rbp+0E0h+var_150.dir], xmm0
      vmulss  xmm0, xmm0, xmm9
      vaddss  xmm1, xmm0, xmm1
      vmovss  dword ptr [rbp+0E0h+var_150.dir+4], xmm2
      vmulss  xmm2, xmm2, xmm9
      vaddss  xmm0, xmm2, xmm4
      vmovss  dword ptr [rbp+0E0h+var_150.end], xmm1
      vmulss  xmm1, xmm3, xmm9
      vaddss  xmm2, xmm1, xmm5
      vmovss  dword ptr [rbp+0E0h+var_150.end+8], xmm2
      vmovss  dword ptr [rbp+0E0h+var_150.start+8], xmm5
      vmovss  dword ptr [rbp+0E0h+var_150.dir+8], xmm3
      vmovss  [rbp+0E0h+var_150.travelDistance], xmm11
      vmovss  dword ptr [rbp+0E0h+var_150.end+4], xmm0
    }
    MethodOfDeath = BG_WeaponBulletFire_GetMethodOfDeath(perks, weapon, isAlternate);
    __asm
    {
      vmovaps xmm12, [rsp+1E0h+var_A0]
      vmovaps xmm11, [rsp+1E0h+var_90]
      vmovaps xmm9, [rsp+1E0h+var_70]
      vmovaps xmm8, [rsp+1E0h+var_60]
      vmovaps xmm7, [rsp+1E0h+var_50]
      vmovaps xmm6, [rsp+1E0h+var_40]
    }
    v73.methodOfDeath = MethodOfDeath;
    if ( v70 )
    {
      if ( (*(_BYTE *)(*(_QWORD *)&v70 + 648i64) & 1) != 0 )
        BG_AddIgnoreEntToBP(&v73, *(__int16 *)(*(_QWORD *)&v70 + 400i64));
    }
    WeaponSystem = CgWeaponSystem::GetWeaponSystem(localClientNum);
    shouldSpawnTracer = CgWeaponSystem::ShouldSpawnTracer(WeaponSystem, attackerEnt->nextState.number, &perks, v40, weapon, isAlternate, 1);
    TagPair::TagPair(&v70);
    tagPair = *v65;
    v67 = CgWeaponSystem::ClaimBulletId(WeaponSystem);
    __asm { vmovss  [rsp+1E0h+var_190], xmm10 }
    CgWeaponSystem::SimulateBulletFire_Ricochet(WeaponSystem, &v73, v67, weapon, isAlternate, attackerEnt, &perks, isPlayerView, hand, tagPair, v69, ricochetCount, shouldSpawnTracer, 0);
    __asm { vmovaps xmm10, [rsp+1E0h+var_80] }
  }
}

/*
==============
CG_FireWeaponSound_CalcOrigin
==============
*/
void CG_FireWeaponSound_CalcOrigin(const LocalClientNum_t localClientNum, const centity_t *const cent, const Weapon *weapon, const scr_string_t tagName, bool isPlayerView, const PlayerHandIndex hand, vec3_t *outOrigin)
{
  cg_t *LocalClientGlobals; 
  char v12; 
  cg_t *v13; 
  DObj *viewModelDObj; 
  clientLinkInfo_t clientLinkInfo; 
  DObj *ClientDObj; 
  vec3_t *v17; 
  int time; 
  centity_t *Entity; 
  scr_string_t tag_player; 
  const centity_t *v21; 
  CgTrajectory v22; 

  if ( !cent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18746, ASSERT_TYPE_ASSERT, "(cent)", (const char *)&queryFormat, "cent") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v12 = 0;
  v13 = LocalClientGlobals;
  if ( !isPlayerView || cent->nextState.eType == ET_TURRET )
  {
    clientLinkInfo = cent->nextState.clientLinkInfo;
    if ( (*(_DWORD *)&clientLinkInfo & 0x200000) != 0 )
    {
      if ( (*(_WORD *)&clientLinkInfo & 0x7FF) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18763, ASSERT_TYPE_ASSERT, "(ent->clientLinkInfo.parentId)", (const char *)&queryFormat, "ent->clientLinkInfo.parentId") )
        __debugbreak();
      ClientDObj = Com_GetClientDObj((*(_DWORD *)&cent->nextState.clientLinkInfo & 0x7FFu) - 1, localClientNum);
      v12 = 1;
    }
    else
    {
      if ( (cent->flags & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18769, ASSERT_TYPE_ASSERT, "(CENextValid( cent ))", "%s\n\tCG_FireWeapSound invalid entity %d, eType %d, flags %d, weaponIdx %d", "CENextValid( cent )", cent->nextState.number, cent->nextState.eType, cent->flags, weapon->weaponIdx) )
        __debugbreak();
      if ( !tagName )
      {
        viewModelDObj = NULL;
        goto LABEL_19;
      }
      ClientDObj = Com_GetClientDObj(cent->nextState.number, localClientNum);
    }
    viewModelDObj = ClientDObj;
    goto LABEL_19;
  }
  viewModelDObj = cg_t::GetViewModelHand(LocalClientGlobals, hand)->viewModelDObj;
  CG_UpdateViewModelPoseForHand(viewModelDObj, localClientNum, hand, 0);
LABEL_19:
  CgTrajectory::CgTrajectory(&v22, localClientNum, cent, &cent->nextState.lerp);
  if ( !isPlayerView || cent->nextState.eType == ET_TURRET )
  {
    if ( v12 )
    {
      Entity = CG_GetEntity(localClientNum, (*(_DWORD *)&cent->nextState.clientLinkInfo & 0x7FFu) - 1);
      v17 = outOrigin;
      if ( viewModelDObj && Entity )
      {
        tag_player = scr_const.tag_player;
        v21 = Entity;
        goto LABEL_30;
      }
    }
    else
    {
      v17 = outOrigin;
      if ( viewModelDObj )
      {
        tag_player = tagName;
        v21 = cent;
LABEL_30:
        if ( CG_DObjGetWorldTagPos(&v21->pose, viewModelDObj, tag_player, v17) )
          return;
      }
    }
    time = CG_GetLocalClientGlobals(localClientNum)->time;
    goto LABEL_32;
  }
  v17 = outOrigin;
  if ( !viewModelDObj || !CG_DObjGetWorldTagPos(&v13->viewModelPose, viewModelDObj, tagName, outOrigin) )
  {
    time = v13->time;
LABEL_32:
    BgTrajectory::EvaluatePosTrajectory(&v22, time, v17);
  }
}

/*
==============
CG_FireWeaponWithHighPrecisionData
==============
*/
void CG_FireWeaponWithHighPrecisionData(LocalClientNum_t localClientNum, centity_t *cent, int event, int knownHitClientNum, const TagPair weaponFlashTagPair, const Weapon *weapon, bool isAlternate, PlayerHandIndex hand, bool isPlayerView, bool isDualWield, bool bNoTracer, const CgFireEventHighPrecisionData *highPrecisionFireData)
{
  CG_FireWeapon_Internal(localClientNum, cent, event, knownHitClientNum, weaponFlashTagPair, weapon, isAlternate, hand, isPlayerView, isDualWield, bNoTracer, 0, NULL, highPrecisionFireData);
}

/*
==============
CG_FireWeaponWithLod
==============
*/
void CG_FireWeaponWithLod(LocalClientNum_t localClientNum, centity_t *cent, int event, int knownHitClientNum, const TagPair weaponFlashTagPair, const Weapon *weapon, bool isAlternate, PlayerHandIndex hand, bool isPlayerView, bool isDualWield, bool bNoTracer, const CgEventLodData *eventLodData)
{
  CG_FireWeapon_Internal(localClientNum, cent, event, knownHitClientNum, weaponFlashTagPair, weapon, isAlternate, hand, isPlayerView, isDualWield, bNoTracer, 0, eventLodData, NULL);
}

/*
==============
CG_FireWeaponWithLodAndHighPrecisionData
==============
*/
void CG_FireWeaponWithLodAndHighPrecisionData(LocalClientNum_t localClientNum, centity_t *cent, int event, int knownHitClientNum, const TagPair weaponFlashTagPair, const Weapon *weapon, bool isAlternate, PlayerHandIndex hand, bool isPlayerView, bool isDualWield, bool bNoTracer, const CgEventLodData *eventLodData, const CgFireEventHighPrecisionData *highPrecisionFireData)
{
  CG_FireWeapon_Internal(localClientNum, cent, event, knownHitClientNum, weaponFlashTagPair, weapon, isAlternate, hand, isPlayerView, isDualWield, bNoTracer, 0, eventLodData, highPrecisionFireData);
}

/*
==============
CG_FireWeapon_FireSound
==============
*/
void CG_FireWeapon_FireSound(LocalClientNum_t localClientNum, centity_t *cent, int event, const scr_string_t tagName, DObj *obj, const Weapon *weapon, bool isAlternate, bool isPlayerView, bool isDualWield, PlayerHandIndex hand)
{
  __int64 v16; 
  cg_t *LocalClientGlobals; 
  GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64> *v18; 
  entityType_s eType; 
  bool v21; 
  const VehicleClient *Client; 
  const VehicleDef *ClientDef; 
  const WeaponCompleteDef *PointerToWeaponCompleteDefConst; 
  const WeaponDef *v25; 
  bool useLastFireSound; 
  bool v28; 
  GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64> *pm_flags; 
  const dvar_t *v33; 
  __int64 v39; 
  vec3_t *outOrigin; 
  float v41; 
  vec3_t origin; 
  Weapon v44; 
  char v45; 
  void *retaddr; 
  bool weapona; 
  int isPlayerViewa; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm6
    vmovaps xmmword ptr [rax-48h], xmm7
  }
  v16 = localClientNum;
  if ( !cent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18935, ASSERT_TYPE_ASSERT, "(cent)", (const char *)&queryFormat, "cent") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v16);
  v18 = (GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64> *)LocalClientGlobals;
  eType = cent->nextState.eType;
  _RSI = weapon;
  if ( eType == ET_HELICOPTER )
  {
    if ( (LocalClientGlobals->predictedPlayerState.linkFlags.m_flags[0] & 4) != 0 && LocalClientGlobals->predictedPlayerState.linkEnt == cent->nextState.number )
    {
      weapona = 1;
      v21 = 0;
    }
    else
    {
      weapona = 0;
      v21 = 0;
    }
  }
  else
  {
    weapona = 0;
    v21 = 0;
    if ( eType == ET_VEHICLE )
    {
      if ( _RSI->weaponIdx )
      {
        if ( !(_BYTE)CgVehicleSystem::ms_allocatedType && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_vehicle.h", 406, ASSERT_TYPE_ASSERT, "(ms_allocatedType != GameModeType::NONE)", "%s\n\tTrying to access the vehicle system for localClientNum %d but the vehicle system type is not known\n", "ms_allocatedType != GameModeType::NONE", v16) )
          __debugbreak();
        if ( (unsigned int)v16 >= CgVehicleSystem::ms_allocatedCount )
        {
          LODWORD(outOrigin) = CgVehicleSystem::ms_allocatedCount;
          LODWORD(v39) = v16;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_vehicle.h", 407, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( ms_allocatedCount )", "localClientNum doesn't index ms_allocatedCount\n\t%i not in [0, %i)", v39, outOrigin) )
            __debugbreak();
        }
        if ( !CgVehicleSystem::ms_vehicleSystemArray[v16] )
        {
          LODWORD(outOrigin) = v16;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_vehicle.h", 408, ASSERT_TYPE_ASSERT, "(ms_vehicleSystemArray[localClientNum])", "%s\n\tTrying to access unallocated vehicle system for localClientNum %d\n", "ms_vehicleSystemArray[localClientNum]", outOrigin) )
            __debugbreak();
        }
        Client = CgVehicleSystem::GetClient(CgVehicleSystem::ms_vehicleSystemArray[v16], cent);
        ClientDef = CgVehicleSystem::GetClientDef(Client);
        PointerToWeaponCompleteDefConst = BG_GetPointerToWeaponCompleteDefConst(_RSI->weaponIdx);
        if ( !PointerToWeaponCompleteDefConst && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18960, ASSERT_TYPE_ASSERT, "(weapCompleteDef)", (const char *)&queryFormat, "weapCompleteDef") )
          __debugbreak();
        if ( ClientDef->turretWeapon == PointerToWeaponCompleteDefConst && ClientDef->turretFireType == VEH_TURRET_ALT_FIRE )
          v21 = 1;
      }
    }
    else if ( eType == ET_TURRET && _RSI->weaponIdx )
    {
      v25 = BG_WeaponDef(_RSI, 0);
      if ( !v25 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18970, ASSERT_TYPE_ASSERT, "(weaponDef)", (const char *)&queryFormat, "weaponDef") )
        __debugbreak();
      v21 = v25->turretFireType == TURRET_ALTERNATE_FIRE;
    }
  }
  useLastFireSound = BG_IsLastShotWeaponEvent(event);
  if ( !useLastFireSound && isPlayerView )
    useLastFireSound = GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(v18 + 230, ACTIVE, 0xCu);
  v28 = Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_OPEN_PARACHUTE|WEAPON_LADDER_AIM) && !useLastFireSound && event == 204;
  pm_flags = (GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64> *)((char *)&v18[3] + 4);
  if ( isPlayerView )
    GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(pm_flags, ACTIVE, 9u);
  __asm
  {
    vmovups ymm0, ymmword ptr [rsi]
    vmovups [rsp+148h+var_A8], ymm0
    vmovups ymmword ptr [rsp+148h+var_88.weaponIdx], ymm0
    vmovups xmm6, xmmword ptr [rsi+20h]
    vmovups xmmword ptr [rsp+148h+var_88.attachmentVariationIndices+5], xmm6
    vmovsd  xmm7, qword ptr [rsi+30h]
    vmovsd  qword ptr [rsp+148h+var_88.attachmentVariationIndices+15h], xmm7
  }
  isPlayerViewa = *(_DWORD *)&_RSI->weaponCamo;
  *(_DWORD *)&v44.weaponCamo = isPlayerViewa;
  if ( isPlayerView && cent->nextState.number == (_DWORD)v16 )
    CG_SND_PlayerBreathsSetShooting((LocalClientNum_t)v16);
  v33 = DCONST_DVARBOOL_snd_autoSim;
  if ( !DCONST_DVARBOOL_snd_autoSim && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_autoSim") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v33);
  if ( v33->current.enabled )
  {
    __asm
    {
      vmovups ymm0, [rsp+148h+var_A8]
      vmovups ymmword ptr [rsp+148h+var_88.weaponIdx], ymm0
      vmovups xmmword ptr [rsp+148h+var_88.attachmentVariationIndices+5], xmm6
      vmovsd  qword ptr [rsp+148h+var_88.attachmentVariationIndices+15h], xmm7
    }
    *(_DWORD *)&v44.weaponCamo = isPlayerViewa;
    CG_SndPingAutoSim((LocalClientNum_t)v16, cent, &v44, tagName, isPlayerView, isAlternate, weapona, isDualWield, useLastFireSound, v21, hand, v28, pm_flags);
  }
  else
  {
    CG_FireWeaponSound_CalcOrigin((const LocalClientNum_t)v16, cent, &v44, tagName, isPlayerView, hand, &origin);
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vmovss  [rsp+148h+var_F0], xmm0
    }
    CG_FireWeapSound_KnownOrigin((const LocalClientNum_t)v16, cent, &v44, isPlayerView, isAlternate, weapona, isDualWield, useLastFireSound, hand, -1, 0i64, v41, SND_WEAP_SHOT_UNCOUNTED, pm_flags, &origin);
    memset(&origin, 0, sizeof(origin));
  }
  _R11 = &v45;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
  }
}

/*
==============
CG_FireWeapon_Internal
==============
*/
void CG_FireWeapon_Internal(LocalClientNum_t localClientNum, centity_t *cent, int event, int knownHitClientNum, const TagPair weaponFlashTagPair, const Weapon *weapon, bool isAlternate, PlayerHandIndex hand, bool isPlayerView, bool isDualWield, bool bNoTracer, const int fireSequenceIndex, const CgEventLodData *optionalEventLodData, const CgFireEventHighPrecisionData *highPrecisionFireData)
{
  const Weapon *v19; 
  PlayerHandIndex v20; 
  entityState_t *p_nextState; 
  cg_t *LocalClientGlobals; 
  CgWeaponSystem *WeaponSystem; 
  bool v24; 
  __int16 number; 
  cg_t *v26; 
  playerState_s *p_predictedPlayerState; 
  bool v28; 
  const DObj *ClientDObj; 
  DObj *viewModelDObj; 
  bool v31; 
  CgWeaponMap *Instance; 
  CgHandler *Handler; 
  WeaponHeat *v39; 
  Weapon *v40; 
  bool v41; 
  centity_t *v42; 
  int flags; 
  int v44; 
  int v45; 
  int v46; 
  const characterInfo_t *CharacterInfo; 
  bool v48; 
  int v49; 
  bool v50; 
  const RumbleInfo *v51; 
  cg_t *v52; 
  CgWeaponSystem *v53; 
  int v54; 
  BOOL v55; 
  int ControllerFromClient; 
  unsigned __int16 ModelForController; 
  unsigned __int16 ModelFromPath; 
  LUIModelDataType DataType; 
  unsigned __int16 v60; 
  int v61; 
  float fmta; 
  BOOL fmt; 
  BOOL gunKickAngles; 
  BOOL outGunKickAVel; 
  BOOL outGunNeedsToCrossCenter; 
  PlayerHandIndex outViewKickAVel; 
  bool IsKillCamEntityView; 
  bool v71; 
  bool v72; 
  bool v73; 
  __int16 v74; 
  unsigned __int8 outBoneIndex[4]; 
  scr_string_t outTagName; 
  unsigned int v77; 
  PlayerHandIndex v78; 
  Weapon *r_weapon; 
  playerState_s *ps; 
  unsigned int v81; 
  centity_t *centa; 
  CgEventLodData *lodData; 
  CgWeaponSystem *v84; 
  cg_t *v85; 
  SecureVec3 inData; 
  const CgFireEventHighPrecisionData *v87; 
  __int64 v88; 
  bitarray<64> outPerks; 
  SecureVec3 outData; 
  void *retaddr; 

  _RAX = &retaddr;
  v88 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-58h], xmm6
    vmovaps xmmword ptr [rax-68h], xmm7
  }
  v81 = knownHitClientNum;
  v77 = event;
  centa = cent;
  v19 = weapon;
  r_weapon = (Weapon *)weapon;
  v20 = hand;
  v78 = hand;
  lodData = (CgEventLodData *)optionalEventLodData;
  v87 = highPrecisionFireData;
  p_nextState = &cent->nextState;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v85 = LocalClientGlobals;
  WeaponSystem = CgWeaponSystem::GetWeaponSystem(localClientNum);
  v84 = WeaponSystem;
  if ( !v19->weaponIdx )
    goto LABEL_85;
  if ( v19->weaponIdx >= BG_GetNumWeapons() )
  {
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1442DFE40, 617i64);
    goto LABEL_85;
  }
  IsKillCamEntityView = CG_View_IsKillCamEntityView(localClientNum);
  v74 = 0;
  if ( event == 41 )
  {
    HIBYTE(v74) = p_nextState->number == LocalClientGlobals->predictedPlayerState.clientNum;
    if ( p_nextState->number == LocalClientGlobals->predictedPlayerState.clientNum )
      goto LABEL_14;
    if ( LocalClientGlobals == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2510, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    if ( !GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&LocalClientGlobals->predictedPlayerState.otherFlags, GameModeFlagValues::ms_mpValue, 0x38u) )
      goto LABEL_14;
    if ( !Com_GameMode_SupportsFeature(WEAPON_LADDER_CLIMB|0x80) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2514, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::MELEE_EXECUTION ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::MELEE_EXECUTION )") )
      __debugbreak();
    LOBYTE(v74) = 1;
    if ( LocalClientGlobals->predictedPlayerState.activeExecutionPartnerEntNum != p_nextState->number )
LABEL_14:
      LOBYTE(v74) = 0;
  }
  v24 = isPlayerView;
  v72 = isPlayerView;
  if ( p_nextState->eType == ET_TURRET )
  {
    number = p_nextState->number;
    v26 = CG_GetLocalClientGlobals((const LocalClientNum_t)WeaponSystem->m_localClientNum);
    p_predictedPlayerState = &v26->predictedPlayerState;
    if ( v26 == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2152, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    if ( !BG_IsTurretActiveFlags(&p_predictedPlayerState->eFlags) )
      goto LABEL_24;
    v28 = p_predictedPlayerState->viewlocked_entNum == (unsigned __int16)number;
  }
  else
  {
    if ( !BG_IsVehicleEntity(p_nextState) )
    {
      if ( v24 )
        goto LABEL_35;
LABEL_25:
      ps = NULL;
      if ( !CG_Entity_CanUseDObj(localClientNum, p_nextState->number) || (ClientDObj = Com_GetClientDObj(p_nextState->number, localClientNum), (viewModelDObj = (DObj *)ClientDObj) != NULL) && !DObjVerifyNumBones(ClientDObj) )
        viewModelDObj = NULL;
      v31 = isAlternate;
      v71 = isAlternate;
      goto LABEL_30;
    }
    v28 = LocalClientGlobals->predictedPlayerState.vehicleState.entity == p_nextState->number;
  }
  if ( !v28 || IsKillCamEntityView )
  {
LABEL_24:
    v24 = 0;
    goto LABEL_25;
  }
  v24 = 1;
LABEL_35:
  ps = &LocalClientGlobals->predictedPlayerState;
  viewModelDObj = cg_t::GetViewModelHand(LocalClientGlobals, v20)->viewModelDObj;
  CG_UpdateViewModelPoseForHand(viewModelDObj, localClientNum, v20, 0);
  v31 = BG_UsingAlternate(&LocalClientGlobals->predictedPlayerState);
  v71 = v31;
LABEL_30:
  if ( v72 )
  {
    __asm
    {
      vxorps  xmm7, xmm7, xmm7
      vcvtsi2ss xmm7, xmm7, eax
      vxorps  xmm6, xmm6, xmm6
      vcvtsi2ss xmm6, xmm6, eax
    }
    secure_uint32_3_t::secureInt32_3_Get(&LocalClientGlobals->kickAngles, &outData);
    secure_uint32_3_t::secureInt32_3_Get(&LocalClientGlobals->kickAVel, &inData);
    Instance = CgWeaponMap::GetInstance(localClientNum);
    __asm
    {
      vmovss  dword ptr [rsp+160h+fmt], xmm6
      vmovaps xmm3, xmm7; pitchMove
    }
    BG_WeaponFireRecoil(Instance, ps, v78, *(const float *)&_XMM3, fmta, (const vec2_t *)&v85->predictedViewState.weapMoveState.recoilAngles, (const vec2_t *)&outData, (vec2_t *)&LocalClientGlobals->predictedViewState.weapMoveState.recoilSpeed, &LocalClientGlobals->predictedViewState.weapMoveState.recoilNeedsToCrossCenter, (vec3_t *)&inData, &LocalClientGlobals->kickNeedsToCrossCenter);
    secure_uint32_3_t::secureInt32_3_Set(&LocalClientGlobals->kickAngles, &outData);
    secure_uint32_3_t::secureInt32_3_Set(&LocalClientGlobals->kickAVel, &inData);
    memset(&inData, 0, sizeof(inData));
    memset(&outData, 0, sizeof(outData));
    Handler = CgHandler::getHandler(localClientNum);
    v20 = v78;
    v39 = Handler->GetPlayerWeaponHeat(Handler, ps, r_weapon, v78);
    v31 = v71;
    v40 = r_weapon;
    BG_Heat_ApplyFireHeat(v39, r_weapon, v71, ps->serverTime);
  }
  else
  {
    v40 = r_weapon;
  }
  CG_Heat_FireWeapon(localClientNum, p_nextState, v20);
  CG_GetPerks(localClientNum, p_nextState->number, &outPerks);
  Tracer_AdvanceDrawCounter(localClientNum, &outPerks, v20, v40, v31, p_nextState->number);
  if ( !bNoTracer )
  {
    LOBYTE(outGunNeedsToCrossCenter) = v72;
    LOBYTE(outGunKickAVel) = v24;
    LOBYTE(gunKickAngles) = v31;
    v84->UpdateBulletFire(v84, v77, centa, v81, r_weapon, gunKickAngles, weaponFlashTagPair, outGunKickAVel, outGunNeedsToCrossCenter, v20, fireSequenceIndex, lodData, v87);
    v40 = r_weapon;
  }
  v41 = Tracer_IsFirstInBurst(localClientNum, v20, p_nextState->number) == 1;
  v73 = v41;
  if ( v20 >= NUM_WEAPON_HANDS )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 625, ASSERT_TYPE_ASSERT, "(hand < NUM_WEAPON_HANDS)", (const char *)&queryFormat, "hand < NUM_WEAPON_HANDS") )
      __debugbreak();
    v41 = v73;
  }
  v42 = centa;
  flags = centa->flags;
  if ( (flags & 0x40) != 0 )
    flags &= 0xFFFFFF83;
  v44 = 16;
  if ( v20 == WEAPON_HAND_DEFAULT )
    v44 = 4;
  v45 = flags | v44;
  centa->flags = v45;
  if ( v41 )
  {
    v46 = 32;
    if ( v20 == WEAPON_HAND_DEFAULT )
      v46 = 8;
    v42->flags = v45 | v46;
  }
  LOBYTE(gunKickAngles) = v24;
  LOBYTE(fmt) = v31;
  v84->UpdateMuzzleFlashNonPlayer(v84, p_nextState, weaponFlashTagPair, v40, fmt, gunKickAngles);
  Sys_ProfBeginNamedEvent(0xFFFFFFFF, "CG_FireWeapon_FireSound");
  outBoneIndex[0] = -2;
  outTagName = 0;
  if ( viewModelDObj && CG_EventLod_ShouldPerformEvent(localClientNum, CG_EVENT_LOD_TYPE_FIRE_WEAPON_EXACT_WEAPON_SOUND_ORIGIN, lodData) )
  {
    CharacterInfo = cg_t::TryGetCharacterInfo(v85, (unsigned int)viewModelDObj->entnum - 1);
    if ( CharacterInfo )
    {
      *(_QWORD *)&outData.x = 0xD0000000Ci64;
      LODWORD(outData.z) = 11;
      TagPair::GetTagNameAndBoneIndexForCharacter((TagPair *)&weaponFlashTagPair, viewModelDObj, CharacterInfo, (const CharacterModelType *)&outData, 3, &outTagName, outBoneIndex);
    }
    else
    {
      TagPair::GetTagNameAndBoneIndex((TagPair *)&weaponFlashTagPair, viewModelDObj, &outTagName, outBoneIndex);
    }
  }
  v48 = v24 || v74;
  outViewKickAVel = v20;
  v49 = v77;
  CG_FireWeapon_FireSound(localClientNum, centa, v77, outTagName, viewModelDObj, v40, v31, v48, isDualWield, outViewKickAVel);
  Sys_ProfEndNamedEvent();
  if ( !BG_IsBoltAction(v40, v31) && CG_EventLod_ShouldPerformEvent(localClientNum, CG_EVENT_LOD_TYPE_EJECT_BRASS, lodData) )
    CG_EjectWeaponBrass(localClientNum, p_nextState, v49, v31);
  v50 = v24 || HIBYTE(v74);
  v51 = BG_FireRumble(v40, v31);
  if ( v51 )
  {
    v52 = CG_GetLocalClientGlobals(localClientNum);
    v53 = CgWeaponSystem::GetWeaponSystem(localClientNum);
    v54 = v53->IsPlayerUsingVehicleWeapon(v53, &v52->predictedPlayerState, p_nextState);
    v55 = p_nextState->eType == ET_TURRET && (v52->predictedPlayerState.linkFlags.m_flags[0] & 4) != 0 && v52->predictedPlayerState.viewlocked_entNum == p_nextState->number;
    if ( v50 || v54 || v55 )
      CG_Rumble_PlayOnClient(localClientNum, v51);
  }
  if ( v24 )
    v84->UpdateWeaponPossession(v84, ps);
  if ( v77 != 41 && v85->predictedPlayerState.clientNum == p_nextState->number )
  {
    ControllerFromClient = CL_Mgr_GetControllerFromClient(localClientNum);
    ModelForController = LUI_Model_GetModelForController(ControllerFromClient);
    ModelFromPath = LUI_Model_CreateModelFromPath(ModelForController, "cg.player.currentWeapon.shotCounter");
    DataType = LUI_Model_GetDataType(ModelFromPath);
    v60 = ModelFromPath;
    if ( DataType == LUI_MODEL_DT_INT )
    {
      v61 = LUI_Model_GetInt(ModelFromPath) + 1;
      v60 = ModelFromPath;
    }
    else
    {
      v61 = 1;
    }
    LUI_Model_SetInt(v60, v61);
  }
LABEL_85:
  __asm
  {
    vmovaps xmm6, xmmword ptr [rsp+160h+var_58+8]
    vmovaps xmm7, [rsp+160h+var_68+8]
  }
}

/*
==============
CG_ForceSwitchToValidWeapon
==============
*/
_BOOL8 CG_ForceSwitchToValidWeapon(LocalClientNum_t localClientNum)
{
  cg_t *LocalClientGlobals; 
  cg_t *v3; 
  CgWeaponMap *Instance; 
  const Weapon *CurrentWeaponForPlayer; 
  const Weapon *v6; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v3 = LocalClientGlobals;
  if ( !LocalClientGlobals->nextSnap )
    return 0i64;
  if ( LocalClientGlobals->demoType == HALF )
    return 0i64;
  if ( CG_View_IsKillCamView(localClientNum) )
    return 0i64;
  if ( v3->predictedPlayerState.pm_type >= 7 )
    return 0i64;
  Instance = CgWeaponMap::GetInstance(localClientNum);
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(Instance, &v3->predictedPlayerState);
  v6 = CurrentWeaponForPlayer;
  return CurrentWeaponForPlayer->weaponIdx && !BG_IsWeaponUsableInState(&v3->predictedPlayerState, CurrentWeaponForPlayer) && (!memcmp_0(v6, &v3->weaponSelect, 0x3Cui64) || !BG_IsWeaponUsableInState(&v3->predictedPlayerState, &v3->weaponSelect)) && CycleWeapPrimary(localClientNum, 0, 1, 0, 1, 1);
}

/*
==============
CG_GetAirburstMarkDistance
==============
*/
__int64 CG_GetAirburstMarkDistance(LocalClientNum_t localClientNum, playerState_s *ps, unsigned __int64 buttons, unsigned int *outDistance)
{
  __int16 v5; 
  cg_t *LocalClientGlobals; 
  bool breathPressedLastFrame; 
  bool v10; 
  bool v11; 
  bool v13; 
  CgWeaponMap *Instance; 
  const Weapon *CurrentWeaponForPlayer; 
  int iProjectileActivateDist; 
  __int64 result; 

  v5 = buttons;
  _RSI = ps;
  if ( !outDistance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22160, ASSERT_TYPE_ASSERT, "(outDistance)", (const char *)&queryFormat, "outDistance") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22163, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  breathPressedLastFrame = LocalClientGlobals->breathPressedLastFrame;
  LocalClientGlobals->breathPressedLastFrame = (v5 & 0x800) != 0i64;
  if ( (v5 & 0x800) == 0 || breathPressedLastFrame )
    return 0i64;
  v10 = _RSI == NULL;
  if ( !_RSI )
  {
    v11 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22170, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps");
    v10 = !v11;
    if ( v11 )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, cs:__real@3f800000
    vucomiss xmm0, dword ptr [rsi+730h]
  }
  v13 = v10;
  Instance = CgWeaponMap::GetInstance(localClientNum);
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(Instance, _RSI);
  if ( !v13 || !Com_GameMode_SupportsFeature(WEAPON_INSPECT|WEAPON_OFFHAND_END) || !BG_WeaponDef(CurrentWeaponForPlayer, 0)->isAirburstWeapon )
    return 0i64;
  if ( !Com_GameMode_SupportsFeature(WEAPON_INSPECT|WEAPON_OFFHAND_END) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22176, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::WEAPON_AIRBURST ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::WEAPON_AIRBURST )") )
    __debugbreak();
  iProjectileActivateDist = 0;
  if ( LocalClientGlobals->crosshairTraceDistance )
  {
    iProjectileActivateDist = BG_WeaponDef(CurrentWeaponForPlayer, 0)->iProjectileActivateDist;
    if ( (signed int)LocalClientGlobals->crosshairTraceDistance > iProjectileActivateDist )
      iProjectileActivateDist = LocalClientGlobals->crosshairTraceDistance;
  }
  _RSI->airburstMarkDistance = truncate_cast<unsigned short,unsigned int>(iProjectileActivateDist);
  result = 1i64;
  *outDistance = iProjectileActivateDist;
  return result;
}

/*
==============
CG_GetBlendedNVGFraction
==============
*/
float CG_GetBlendedNVGFraction(const cg_t *cgameGlob, const ClientNVGInfoWeightedBlind *weightedBlindInfo)
{
  bool blendingIn; 
  const dvar_t *v7; 
  const dvar_t *v8; 
  const char *v9; 
  const dvar_t *v10; 

  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13166, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  blendingIn = weightedBlindInfo->blendingIn;
  if ( blendingIn )
  {
    v7 = DCONST_DVARMPINT_NVG_ScriptBlindWeighted_BlendInDelay;
    if ( !DCONST_DVARMPINT_NVG_ScriptBlindWeighted_BlendInDelay && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_ScriptBlindWeighted_BlendInDelay") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v7);
    v8 = DCONST_DVARMPINT_NVG_ScriptBlindWeighted_BlendInDuration;
    if ( !DCONST_DVARMPINT_NVG_ScriptBlindWeighted_BlendInDuration )
    {
      v9 = "NVG_ScriptBlindWeighted_BlendInDuration";
      goto LABEL_15;
    }
  }
  else
  {
    v10 = DCONST_DVARMPINT_NVG_ScriptBlindWeighted_BlendOutDelay;
    if ( !DCONST_DVARMPINT_NVG_ScriptBlindWeighted_BlendOutDelay && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_ScriptBlindWeighted_BlendOutDelay") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v10);
    v8 = DCONST_DVARMPINT_NVG_ScriptBlindWeighted_BlendOutDuration;
    if ( !DCONST_DVARMPINT_NVG_ScriptBlindWeighted_BlendOutDuration )
    {
      v9 = "NVG_ScriptBlindWeighted_BlendOutDuration";
LABEL_15:
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", v9) )
        __debugbreak();
    }
  }
  Dvar_CheckFrontendServerThread(v8);
  __asm
  {
    vmovaps [rsp+68h+var_28], xmm6
    vmovss  xmm6, cs:__real@3f800000
  }
  if ( v8->current.integer > 0 )
  {
    __asm
    {
      vxorps  xmm1, xmm1, xmm1
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm1, xmm1, eax
      vcvtsi2ss xmm0, xmm0, ecx
      vdivss  xmm0, xmm1, xmm0; val
      vxorps  xmm1, xmm1, xmm1; min
      vmovaps xmm2, xmm6; max
    }
    *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  }
  else
  {
    __asm { vmovaps xmm0, xmm6 }
  }
  if ( !blendingIn )
    __asm { vsubss  xmm0, xmm6, xmm0 }
  __asm { vmovaps xmm6, [rsp+68h+var_28] }
  return *(float *)&_XMM0;
}

/*
==============
CG_GetCurrentWeaponSlot
==============
*/

WeaponSlot __fastcall CG_GetCurrentWeaponSlot(LocalClientNum_t localClientNum, __int64 a2, double _XMM2_8)
{
  cg_t *LocalClientGlobals; 
  const playerState_s *p_predictedPlayerState; 
  CgWeaponMap *Instance; 
  int v11; 
  const WeaponDef *v12; 
  Weapon r_weapon; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !LocalClientGlobals->nextSnap )
    return 0;
  p_predictedPlayerState = &LocalClientGlobals->predictedPlayerState;
  if ( !BG_IsPlayer(&LocalClientGlobals->predictedPlayerState) )
    return 0;
  Instance = CgWeaponMap::GetInstance(localClientNum);
  _RAX = BG_GetCurrentWeaponForPlayer(Instance, p_predictedPlayerState);
  __asm
  {
    vmovups ymm2, ymmword ptr [rax]
    vmovups ymmword ptr [rsp+78h+r_weapon.weaponIdx], ymm2
    vmovups xmm0, xmmword ptr [rax+20h]
    vmovups xmmword ptr [rsp+78h+r_weapon.attachmentVariationIndices+5], xmm0
    vmovsd  xmm1, qword ptr [rax+30h]
    vmovsd  qword ptr [rsp+78h+r_weapon.attachmentVariationIndices+15h], xmm1
  }
  v11 = *(_DWORD *)&_RAX->weaponCamo;
  __asm { vmovd   eax, xmm2 }
  *(_DWORD *)&r_weapon.weaponCamo = v11;
  if ( !(_WORD)_RAX )
    return 0;
  v12 = BG_WeaponDef(&r_weapon, 0);
  if ( v12 && v12->inventoryType == WEAPINVENTORY_PRIMARY )
    return BG_PlayerWeaponGetEquippedSlot(Instance, p_predictedPlayerState, &r_weapon);
  else
    return 0;
}

/*
==============
CG_GetEntWeapon
==============
*/
const Weapon *CG_GetEntWeapon(LocalClientNum_t localClientNum, const centity_t *cent)
{
  const BgWeaponMap **v3; 

  v3 = (const BgWeaponMap **)&CgWeaponMap::ms_instance[localClientNum];
  if ( !*v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  return BG_GetWeaponForEntity(*v3, &cent->nextState);
}

/*
==============
CG_GetFastADSBlendTimes
==============
*/
bool CG_GetFastADSBlendTimes(LocalClientNum_t localClientNum, const playerState_s *ps, const Weapon *weapon, const WeaponAnimNumber anim, const WeaponAnimNumber prevAnim, float *blendInTime, float *blendOutTime)
{
  cg_t *LocalClientGlobals; 
  const WeaponAnimNumber *v16; 
  unsigned int v17; 
  bool result; 
  CgWeaponMap *Instance; 
  bool v20; 
  float outAdsTransInSpeedMs; 

  _R14 = blendInTime;
  if ( !blendInTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2355, ASSERT_TYPE_ASSERT, "(blendInTime)", (const char *)&queryFormat, "blendInTime") )
    __debugbreak();
  _RBP = blendOutTime;
  if ( !blendOutTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2356, ASSERT_TYPE_ASSERT, "(blendOutTime)", (const char *)&queryFormat, "blendOutTime") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2359, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( anim != WEAP_FORCE_IDLE || !LocalClientGlobals->fastADSTransActive )
    return 0;
  v16 = s_fastADSBlendAnimStates;
  v17 = 0;
  while ( prevAnim != *v16 )
  {
    ++v17;
    ++v16;
    if ( v17 >= 0xE )
      return 0;
  }
  __asm { vmovaps [rsp+68h+var_38], xmm6 }
  Instance = CgWeaponMap::GetInstance(localClientNum);
  if ( !Instance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2376, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  v20 = BG_UsingAlternate(ps);
  BG_GetADSTransTimes(Instance, ps, weapon, v20, &outAdsTransInSpeedMs, (float *)&blendInTime);
  __asm
  {
    vmovss  xmm0, cs:__real@3a83126f
    vdivss  xmm6, xmm0, [rsp+68h+outAdsTransInSpeedMs]
  }
  BG_WeaponADSFractionAffectedByReload(Instance, ps);
  __asm
  {
    vmovss  xmm2, cs:__real@3f800000; max
    vsubss  xmm0, xmm2, xmm0; val
    vxorps  xmm1, xmm1, xmm1; min
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm
  {
    vmulss  xmm1, xmm0, xmm6
    vmulss  xmm2, xmm1, cs:__real@3f333333
    vmovaps xmm6, [rsp+68h+var_38]
  }
  result = 1;
  __asm
  {
    vmovss  dword ptr [r14], xmm2
    vmovss  dword ptr [rbp+0], xmm2
  }
  return result;
}

/*
==============
CG_GetFleshImpactAxis
==============
*/
void CG_GetFleshImpactAxis(const LocalClientNum_t localClientNum, const int sourceEntityNum, const int boneIndex, const vec3_t *position, tmat33_t<vec3_t> *outAxis)
{
  centity_t *Entity; 
  centity_t *v13; 
  const DObj *ClientDObj; 
  vec3_t n; 
  orientation_t orient; 

  _RBP = position;
  Entity = CG_GetEntity(localClientNum, sourceEntityNum);
  v13 = Entity;
  if ( (Entity->flags & 1) != 0 )
  {
    ClientDObj = Com_GetClientDObj(Entity->nextState.number, localClientNum);
    if ( ClientDObj )
    {
      if ( DObjIsValidBoneIndex(ClientDObj, boneIndex) && CG_Entity_GetBoneOrientation(localClientNum, v13->nextState.number, boneIndex, &orient) )
      {
        __asm
        {
          vmovss  xmm0, dword ptr [rbp+0]
          vmovss  xmm1, dword ptr [rbp+4]
          vmovaps [rsp+0D8h+var_38], xmm6
          vmovaps [rsp+0D8h+var_48], xmm7
          vsubss  xmm7, xmm0, dword ptr [rsp+0D8h+orient.origin]
          vmovss  xmm0, dword ptr [rbp+8]
          vmovaps [rsp+0D8h+var_58], xmm8
          vsubss  xmm8, xmm1, dword ptr [rsp+0D8h+orient.origin+4]
          vmulss  xmm1, xmm8, dword ptr [rsp+0D8h+orient.axis+4]
          vmovaps [rsp+0D8h+var_68], xmm9
          vsubss  xmm9, xmm0, dword ptr [rsp+0D8h+orient.origin+8]
          vmulss  xmm0, xmm7, dword ptr [rsp+0D8h+orient.axis]
          vaddss  xmm2, xmm1, xmm0
          vmulss  xmm1, xmm9, dword ptr [rsp+0D8h+orient.axis+8]
          vaddss  xmm3, xmm2, xmm1
          vmulss  xmm0, xmm3, dword ptr [rsp+0D8h+orient.axis]
          vmulss  xmm1, xmm3, dword ptr [rsp+0D8h+orient.axis+4]
          vsubss  xmm7, xmm7, xmm0
          vmulss  xmm0, xmm3, dword ptr [rsp+0D8h+orient.axis+8]
          vsubss  xmm5, xmm9, xmm0
          vsubss  xmm6, xmm8, xmm1
          vmulss  xmm0, xmm5, xmm5
          vmulss  xmm2, xmm6, xmm6
          vmulss  xmm1, xmm7, xmm7
          vaddss  xmm3, xmm2, xmm1
          vmovss  xmm1, cs:__real@3f800000
          vaddss  xmm2, xmm3, xmm0
          vsqrtss xmm4, xmm2, xmm2
          vcmpless xmm0, xmm4, cs:__real@80000000
          vblendvps xmm0, xmm4, xmm1, xmm0
          vdivss  xmm2, xmm1, xmm0
          vmulss  xmm0, xmm7, xmm2
          vmovss  dword ptr [rsp+0D8h+n], xmm0
          vmulss  xmm0, xmm5, xmm2
          vmulss  xmm1, xmm6, xmm2
          vmovss  dword ptr [rsp+0D8h+n+8], xmm0
          vmovss  dword ptr [rsp+0D8h+n+4], xmm1
        }
        OrthonormalBasis(&n, outAxis);
        __asm
        {
          vmovaps xmm9, [rsp+0D8h+var_68]
          vmovaps xmm8, [rsp+0D8h+var_58]
          vmovaps xmm7, [rsp+0D8h+var_48]
          vmovaps xmm6, [rsp+0D8h+var_38]
        }
      }
    }
  }
}

/*
==============
CG_GetImpactEffectForWeapon
==============
*/
void CG_GetImpactEffectForWeapon(LocalClientNum_t localClientNum, const int sourceEntityNum, const int targetEntityNum, const bool filterByContents, const int hitContents, const Weapon *weapon, bool isAlternate, const int surfType, const unsigned int impactFlags, SndHitArmorType hitArmorType, FXRegisteredDef *outFx, const SndAliasList **outSnd, bool *outIsSfxExplosion)
{
  cg_t *LocalClientGlobals; 
  CgHandler *Handler; 
  __int64 v17; 
  const playerState_s *p_predictedPlayerState; 
  __int16 *v19; 
  bool v20; 
  SfxImpactGroup *p_npcImpactSounds; 
  WeaponSFXPackage *SfxPackage; 
  const SndAliasList *v23; 
  bool v24; 
  SndHitType ImpactSoundHitLocation; 
  bool v26; 
  const SndAliasList *bulletExitSmallSound; 
  const SndAliasList *bulletExitLargeSound; 
  const SndAliasList *shotgunExitSound; 
  WeaponSFXPackage *v30; 
  bool v31; 
  const Weapon *v32; 
  const SndAliasList *vehBulletExitMediumSound; 
  const SndAliasList *WeaponSoundWithFallback; 
  bool v35; 
  unsigned int v36; 
  int v37; 
  FXRegisteredDef *v38; 
  __int64 v39; 
  int fxImpactType; 
  int targetEntityNuma; 
  FX_FleshType ImpactEffectHitLocation; 
  int impactType; 
  unsigned int v44; 
  FXRegisteredDef *v45; 
  const WeaponDef *v46; 
  playerState_s *ps; 
  char output[1024]; 

  v45 = outFx;
  targetEntityNuma = targetEntityNum;
  v44 = sourceEntityNum;
  outFx->m_particleSystemDef = NULL;
  outFx[1].m_particleSystemDef = NULL;
  *outSnd = NULL;
  *outIsSfxExplosion = 0;
  if ( (impactFlags & 0x18) != 24 && (!filterByContents || targetEntityNum != 2047 && (hitContents & 0x800) == 0) )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20091, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
      __debugbreak();
    Handler = CgHandler::getHandler(localClientNum);
    ps = &LocalClientGlobals->predictedPlayerState;
    v17 = (__int64)Handler->PlayerTurretEnt(Handler, &LocalClientGlobals->predictedPlayerState);
    p_predictedPlayerState = &LocalClientGlobals->predictedPlayerState;
    v19 = (__int16 *)v17;
    v20 = CG_IsPlayerEntityNumber(p_predictedPlayerState, sourceEntityNum) || v19 && *v19 == sourceEntityNum;
    p_npcImpactSounds = &cgMedia.npcImpactSounds;
    if ( v20 )
      p_npcImpactSounds = &cgMedia.playerImpactSounds;
    v46 = BG_WeaponDef(weapon, isAlternate);
    *outSnd = NULL;
    impactType = CG_Weapons_GetVFXImpactType(localClientNum, sourceEntityNum, weapon, isAlternate);
    SfxPackage = BG_GetSfxPackage(weapon, isAlternate);
    fxImpactType = CG_Main_RegisteredImpactTypeToImpactType(UNKNOWN);
    if ( SfxPackage )
      fxImpactType = SfxPackage->sfxImpactType;
    CG_OverrideImpactEffectType(localClientNum, sourceEntityNum, &fxImpactType);
    v23 = NULL;
    v24 = !v20;
    ImpactSoundHitLocation = SND_NPC_HITLOC_HM_BODY;
    ImpactEffectHitLocation = FX_FLESHTYPE_BODY_NONFATAL;
    if ( surfType == 7 )
    {
      ImpactEffectHitLocation = CG_GetImpactEffectHitLocation(localClientNum, targetEntityNuma, impactFlags);
      ImpactSoundHitLocation = CG_GetImpactSoundHitLocation(localClientNum, targetEntityNuma, impactFlags);
    }
    switch ( CG_Main_ImpactTypeToRegisteredImpactType(fxImpactType) )
    {
      case 1:
      case 2:
      case 18:
        v26 = (impactFlags & 4) != 0;
        if ( (impactFlags & 4) != 0 )
          bulletExitSmallSound = p_npcImpactSounds->bulletExitSmallSound;
        else
          bulletExitSmallSound = p_npcImpactSounds->bulletHitSmallSound;
        *outSnd = bulletExitSmallSound;
        v23 = cgMedia.fleshBulletSmall.npc[ImpactSoundHitLocation][v24][hitArmorType];
        goto LABEL_61;
      case 3:
      case 4:
        v26 = (impactFlags & 4) != 0;
        if ( (impactFlags & 4) != 0 )
          bulletExitLargeSound = p_npcImpactSounds->bulletExitLargeSound;
        else
          bulletExitLargeSound = p_npcImpactSounds->bulletHitLargeSound;
        *outSnd = bulletExitLargeSound;
        v23 = cgMedia.fleshBulletLarge.npc[ImpactSoundHitLocation][v24][hitArmorType];
        goto LABEL_61;
      case 5:
        *outSnd = p_npcImpactSounds->bulletExplodeSound;
        v23 = cgMedia.fleshBulletExplode.npc[ImpactSoundHitLocation][v24][hitArmorType];
        *outIsSfxExplosion = 1;
        goto LABEL_60;
      case 6:
        v26 = (impactFlags & 4) != 0;
        if ( (impactFlags & 4) != 0 )
          shotgunExitSound = p_npcImpactSounds->shotgunExitSound;
        else
          shotgunExitSound = p_npcImpactSounds->shotgunHitSound;
        *outSnd = shotgunExitSound;
        v23 = cgMedia.fleshShotgun.npc[ImpactSoundHitLocation][v24][hitArmorType];
        goto LABEL_61;
      case 7:
        *outSnd = p_npcImpactSounds->bulletExplodeSound;
        *outIsSfxExplosion = 1;
        goto LABEL_60;
      case 9:
        v30 = v46->sfxPackage;
        if ( v30 )
          *outSnd = SND_FindAlias(v30->sounds->bounceSound.name);
        goto LABEL_60;
      case 10:
        *outSnd = cgMedia.grenadeExplodeSound;
        *outIsSfxExplosion = 1;
        goto LABEL_60;
      case 11:
        *outSnd = cgMedia.grenadeExplodeSoundSmall;
        goto LABEL_60;
      case 12:
        *outSnd = cgMedia.rocketExplodeSound;
        *outIsSfxExplosion = 1;
        goto LABEL_60;
      case 13:
        *outSnd = cgMedia.rocketExplodeSoundSmall;
        goto LABEL_60;
      case 14:
        v31 = isAlternate;
        v32 = weapon;
        v26 = (impactFlags & 4) != 0;
        *outSnd = BG_ProjDudSound(weapon, isAlternate);
        goto LABEL_62;
      case 15:
        v26 = (impactFlags & 4) != 0;
        if ( (impactFlags & 4) != 0 )
          vehBulletExitMediumSound = p_npcImpactSounds->vehBulletExitMediumSound;
        else
          vehBulletExitMediumSound = p_npcImpactSounds->vehBulletHitMediumSound;
        *outSnd = vehBulletExitMediumSound;
        v23 = cgMedia.fleshVehBullet.npc[ImpactSoundHitLocation][v24][hitArmorType];
        goto LABEL_61;
      case 16:
        *outSnd = p_npcImpactSounds->vehBulletExplodeSound;
        v23 = cgMedia.fleshVehBulletExplode.npc[ImpactSoundHitLocation][v24][hitArmorType];
        *outIsSfxExplosion = 1;
        goto LABEL_60;
      case 17:
        *outSnd = cgMedia.vehMissileExplodeSound;
        *outIsSfxExplosion = 1;
        goto LABEL_60;
      case 19:
        *outSnd = p_npcImpactSounds->arcaneRedSound;
        v23 = cgMedia.fleshArcaneRed.npc[ImpactSoundHitLocation][v24][hitArmorType];
        goto LABEL_60;
      case 21:
        *outSnd = p_npcImpactSounds->arcaneYellowSound;
        v23 = cgMedia.fleshArcaneYellow.npc[ImpactSoundHitLocation][v24][hitArmorType];
        goto LABEL_60;
      case 22:
        *outSnd = p_npcImpactSounds->arcanePinkSound;
        v23 = cgMedia.fleshArcanePink.npc[ImpactSoundHitLocation][v24][hitArmorType];
        goto LABEL_60;
      case 23:
        *outSnd = p_npcImpactSounds->arcaneBlueSound;
        v23 = cgMedia.fleshArcaneBlue.npc[ImpactSoundHitLocation][v24][hitArmorType];
        goto LABEL_60;
      case 24:
        *outSnd = cgMedia.waterSound;
        goto LABEL_60;
      case 25:
        *outSnd = p_npcImpactSounds->rock1Sound;
        v23 = cgMedia.fleshRock1.npc[ImpactSoundHitLocation][v24][hitArmorType];
        goto LABEL_60;
      case 26:
        *outSnd = p_npcImpactSounds->rock2Sound;
        v23 = cgMedia.fleshRock2.npc[ImpactSoundHitLocation][v24][hitArmorType];
        goto LABEL_60;
      case 27:
        *outSnd = p_npcImpactSounds->rock3Sound;
        v23 = cgMedia.fleshRock3.npc[ImpactSoundHitLocation][v24][hitArmorType];
        goto LABEL_60;
      case 28:
        *outSnd = p_npcImpactSounds->rock4Sound;
        v23 = cgMedia.fleshRock4.npc[ImpactSoundHitLocation][v24][hitArmorType];
        goto LABEL_60;
      case 29:
        *outSnd = p_npcImpactSounds->dlc1Sound;
        v23 = cgMedia.fleshDLC1.npc[ImpactSoundHitLocation][v24][hitArmorType];
        goto LABEL_60;
      case 30:
        *outSnd = p_npcImpactSounds->dlc2Sound;
        v23 = cgMedia.fleshDLC2.npc[ImpactSoundHitLocation][v24][hitArmorType];
        goto LABEL_60;
      case 31:
        *outSnd = p_npcImpactSounds->dlc3Sound;
        v23 = cgMedia.fleshDLC3.npc[ImpactSoundHitLocation][v24][hitArmorType];
        goto LABEL_60;
      case 32:
        *outSnd = p_npcImpactSounds->dlc4Sound;
        v23 = cgMedia.fleshDLC4.npc[ImpactSoundHitLocation][v24][hitArmorType];
        goto LABEL_60;
      default:
LABEL_60:
        v26 = (impactFlags & 4) != 0;
LABEL_61:
        v32 = weapon;
        v31 = isAlternate;
LABEL_62:
        if ( (impactFlags & 0x800) != 0 )
        {
          WeaponSoundWithFallback = BG_GetWeaponSoundWithFallback(v32, v31, 624i64);
          *outSnd = WeaponSoundWithFallback;
          if ( !WeaponSoundWithFallback )
          {
            BG_GetWeaponNameComplete(v32, v31, output, 0x400u);
            Com_PrintError(9, "Ricochet Impact sound alias not defined for weapon '%s'\n", output);
          }
        }
        if ( (impactFlags & 0x10) != 0 )
        {
          *outSnd = NULL;
        }
        else
        {
          v35 = surfType == 7;
          if ( surfType != 7 )
            goto LABEL_80;
          if ( v23 )
          {
            if ( !v26 )
            {
              v36 = targetEntityNuma;
              if ( targetEntityNuma != 2047 )
              {
                if ( v44 >= 0x800 )
                {
                  LODWORD(v38) = v44;
                  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20255, ASSERT_TYPE_ASSERT, "(unsigned)( sourceEntityNum ) < (unsigned)( ( 2048 ) )", "sourceEntityNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v38, 2048) )
                    __debugbreak();
                }
                if ( v36 >= 0x800 )
                {
                  LODWORD(v39) = 2048;
                  LODWORD(v38) = v36;
                  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20256, ASSERT_TYPE_ASSERT, "(unsigned)( targetEntityNum ) < (unsigned)( ( 2048 ) )", "targetEntityNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v38, v39) )
                    __debugbreak();
                }
                if ( !CG_IsPlayerEntityNumber(ps, v36) )
                  *outSnd = v23;
              }
            }
          }
        }
        v35 = surfType == 7;
LABEL_80:
        v37 = ImpactEffectHitLocation;
        if ( surfType != 7 )
          v37 = surfType;
        CG_GetImpactEffectList(impactType, v37, v35, v26, (impactFlags & 8) != 0, v45);
        break;
    }
  }
}

/*
==============
CG_GetImpactEffectHitLocation
==============
*/
__int64 CG_GetImpactEffectHitLocation(LocalClientNum_t localClientNum, const int targetEntityNum, const int impactFlags)
{
  centity_t *Entity; 
  const entityState_t *p_nextState; 
  const DObj *ClientDObj; 
  const XModel *Model; 
  ImpactEffectType impactType; 
  __int64 result; 
  int v12; 
  int v13; 
  int v14; 
  unsigned int v15; 

  Entity = CG_GetEntity(localClientNum, targetEntityNum);
  if ( (Entity->flags & 1) == 0 )
    goto LABEL_31;
  p_nextState = &Entity->nextState;
  if ( !BG_IsCharacterEntity(&Entity->nextState) && !BG_IsPlayerOrAgentCorpseEntity(p_nextState) )
    goto LABEL_31;
  ClientDObj = Com_GetClientDObj(targetEntityNum, localClientNum);
  if ( !ClientDObj )
    goto LABEL_31;
  Model = DObjGetModel(ClientDObj, 0);
  if ( !Model && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 19798, ASSERT_TYPE_ASSERT, "(model)", (const char *)&queryFormat, "model") )
    __debugbreak();
  impactType = Model->impactType;
  switch ( impactType )
  {
    case IMPACT_EFFECT_TYPE_SMALL_ROBOT:
      if ( (impactFlags & 0x80u) != 0 )
        return 15i64;
      v12 = 0;
      v13 = impactFlags & 2;
      if ( (impactFlags & 1) != 0 )
      {
        LOBYTE(v12) = v13 != 0;
        return (unsigned int)(v12 + 9);
      }
      else
      {
        LOBYTE(v12) = v13 != 0;
        if ( (impactFlags & 0x40) != 0 )
          return (unsigned int)(v12 + 11);
        else
          return (unsigned int)(v12 + 13);
      }
    case IMPACT_EFFECT_TYPE_LARGE_ROBOT:
      if ( (impactFlags & 0x80u) != 0 )
        return 22i64;
      v14 = impactFlags & 2;
      if ( (impactFlags & 1) != 0 )
        return (v14 | 0x20u) >> 1;
      if ( (impactFlags & 0x40) != 0 )
        v15 = v14 | 0x24;
      else
        v15 = v14 | 0x28;
      return v15 >> 1;
    case IMPACT_EFFECT_TYPE_ALIEN:
      if ( (impactFlags & 2) != 0 )
      {
        return 7i64;
      }
      else
      {
        result = 6i64;
        if ( (impactFlags & 0x20) != 0 )
          return 8i64;
      }
      break;
    default:
LABEL_31:
      if ( (impactFlags & 0x400) != 0 )
      {
        return (impactFlags & 2 | 8u) >> 1;
      }
      else if ( (impactFlags & 1) != 0 )
      {
        return (impactFlags & 2 | 4u) >> 1;
      }
      else
      {
        result = ((unsigned int)impactFlags >> 1) & 1;
        if ( (impactFlags & 0x20) != 0 )
          return 8i64;
      }
      break;
  }
  return result;
}

/*
==============
CG_GetImpactEffectList
==============
*/
void CG_GetImpactEffectList(int impactType, int surfaceType, bool isFlesh, bool isExit, bool isNoImpact, FXRegisteredDef *outFx)
{
  __int64 v6; 
  __int64 v7; 
  bool v8; 
  __int64 v9; 
  __int64 v11; 
  __int64 v12; 
  const ParticleSystemDef *particleSystemDef; 
  FxImpactPack *exit; 
  __int64 v15; 
  __int64 v16; 

  v6 = 0i64;
  v7 = surfaceType;
  v8 = isExit;
  v9 = impactType;
  outFx->m_particleSystemDef = NULL;
  outFx[1].m_particleSystemDef = NULL;
  if ( impactType >= 0 && !isNoImpact && cgMedia.impactFx )
  {
    if ( !cgMedia.impactFx->table && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20022, ASSERT_TYPE_ASSERT, "(cgMedia.impactFx->table)", (const char *)&queryFormat, "cgMedia.impactFx->table") )
      __debugbreak();
    v11 = v7;
    do
    {
      if ( (unsigned int)v9 >= cgMedia.impactFx->impactTypeCount )
      {
        LODWORD(v16) = cgMedia.impactFx->impactTypeCount;
        LODWORD(v15) = v9;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20025, ASSERT_TYPE_ASSERT, "(unsigned)( impactType ) < (unsigned)( cgMedia.impactFx->impactTypeCount )", "impactType doesn't index cgMedia.impactFx->impactTypeCount\n\t%i not in [0, %i)", v15, v16) )
          __debugbreak();
      }
      if ( v8 && (v12 = v9, cgMedia.impactFx->table[v9].exit) )
      {
        if ( isFlesh )
        {
          if ( (unsigned int)v7 >= 0x17 )
          {
            LODWORD(v16) = 23;
            LODWORD(v15) = v7;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20030, ASSERT_TYPE_ASSERT, "(unsigned)( surfaceType ) < (unsigned)( FX_FLESHTYPE_COUNT )", "surfaceType doesn't index FX_FLESHTYPE_COUNT\n\t%i not in [0, %i)", v15, v16) )
              __debugbreak();
          }
          particleSystemDef = cgMedia.impactFx->table[v12].exit->flesh[v11].particleSystemDef;
          goto LABEL_32;
        }
        if ( (unsigned int)v7 >= 0x40 )
        {
          LODWORD(v16) = 64;
          LODWORD(v15) = v7;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20035, ASSERT_TYPE_ASSERT, "(unsigned)( surfaceType ) < (unsigned)( 64 )", "surfaceType doesn't index SURF_TYPECOUNT\n\t%i not in [0, %i)", v15, v16) )
            __debugbreak();
        }
        exit = cgMedia.impactFx->table[v12].exit;
      }
      else
      {
        if ( isFlesh )
        {
          if ( (unsigned int)v7 >= 0x17 )
          {
            LODWORD(v16) = 23;
            LODWORD(v15) = v7;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20043, ASSERT_TYPE_ASSERT, "(unsigned)( surfaceType ) < (unsigned)( FX_FLESHTYPE_COUNT )", "surfaceType doesn't index FX_FLESHTYPE_COUNT\n\t%i not in [0, %i)", v15, v16) )
              __debugbreak();
          }
          particleSystemDef = cgMedia.impactFx->table[v9].normal->flesh[v11].particleSystemDef;
          goto LABEL_32;
        }
        if ( (unsigned int)v7 >= 0x40 )
        {
          LODWORD(v16) = 64;
          LODWORD(v15) = v7;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20048, ASSERT_TYPE_ASSERT, "(unsigned)( surfaceType ) < (unsigned)( 64 )", "surfaceType doesn't index SURF_TYPECOUNT\n\t%i not in [0, %i)", v15, v16) )
            __debugbreak();
        }
        exit = cgMedia.impactFx->table[v9].normal;
      }
      particleSystemDef = exit->nonflesh[v11].particleSystemDef;
LABEL_32:
      outFx[v6].m_particleSystemDef = particleSystemDef;
      v8 = isExit;
      ++v6;
      v11 += 87i64;
    }
    while ( v6 < 2 );
  }
}

/*
==============
CG_GetImpactSoundHitLocation
==============
*/
int CG_GetImpactSoundHitLocation(LocalClientNum_t localClientNum, const int targetEntityNum, const unsigned int impactFlags)
{
  centity_t *Entity; 
  const entityState_t *p_nextState; 
  const DObj *ClientDObj; 
  const XModel *Model; 
  ImpactEffectType impactType; 
  int v11; 

  Entity = CG_GetEntity(localClientNum, targetEntityNum);
  if ( (Entity->flags & 1) != 0 )
  {
    p_nextState = &Entity->nextState;
    if ( BG_IsCharacterEntity(&Entity->nextState) || BG_IsPlayerOrAgentCorpseEntity(p_nextState) )
    {
      ClientDObj = Com_GetClientDObj(targetEntityNum, localClientNum);
      if ( ClientDObj )
      {
        Model = DObjGetModel(ClientDObj, 0);
        if ( !Model && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 19701, ASSERT_TYPE_ASSERT, "(model)", (const char *)&queryFormat, "model") )
          __debugbreak();
        impactType = Model->impactType;
        switch ( impactType )
        {
          case IMPACT_EFFECT_TYPE_SMALL_ROBOT:
            if ( (impactFlags & 0x80u) == 0 )
            {
              if ( (impactFlags & 1) != 0 )
                v11 = 7;
              else
                v11 = ((impactFlags & 0x40) != 0) + 5;
            }
            else
            {
              v11 = 8;
            }
            return CG_GameInterface_GetImpactSoundHitLocation(localClientNum, targetEntityNum, impactFlags, v11);
          case IMPACT_EFFECT_TYPE_LARGE_ROBOT:
            if ( (impactFlags & 0x80u) == 0 )
            {
              if ( (impactFlags & 1) != 0 )
                v11 = 11;
              else
                v11 = ((impactFlags & 0x40) != 0) + 9;
            }
            else
            {
              v11 = 12;
            }
            return CG_GameInterface_GetImpactSoundHitLocation(localClientNum, targetEntityNum, impactFlags, v11);
          case IMPACT_EFFECT_TYPE_ALIEN:
            v11 = 0;
            return CG_GameInterface_GetImpactSoundHitLocation(localClientNum, targetEntityNum, impactFlags, v11);
        }
      }
    }
  }
  if ( (impactFlags & 0x80u) == 0 )
  {
    if ( (impactFlags & 0x400) != 0 )
    {
      v11 = 2;
    }
    else if ( (impactFlags & 1) != 0 )
    {
      v11 = 3;
    }
    else
    {
      v11 = ((unsigned __int8)impactFlags >> 6) & 1;
    }
  }
  else
  {
    v11 = 4;
  }
  return CG_GameInterface_GetImpactSoundHitLocation(localClientNum, targetEntityNum, impactFlags, v11);
}

/*
==============
CG_GetLocalClientGlobalsForEnt
==============
*/
cg_t *CG_GetLocalClientGlobalsForEnt(int entityNum)
{
  unsigned int v1; 
  cg_t **v3; 
  connstate_t *i; 
  cg_t *v5; 
  const playerState_s *p_predictedPlayerState; 
  __int64 v8; 
  __int64 v9; 

  v1 = 0;
  if ( SLODWORD(cl_maxLocalClients) <= 0 )
    return 0i64;
  v3 = cg_t::ms_cgArray;
  for ( i = &clientUIActives[0].connectionState; ; i += 110 )
  {
    if ( v1 >= 2 )
    {
      LODWORD(v9) = 2;
      LODWORD(v8) = v1;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_ui_active_client.h", 174, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v8, v9) )
        __debugbreak();
    }
    if ( *i == CA_ACTIVE )
    {
      if ( v1 >= cg_t::ms_allocatedCount )
      {
        LODWORD(v9) = cg_t::ms_allocatedCount;
        LODWORD(v8) = v1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1166, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( cg_t::ms_allocatedCount )", "localClientNum doesn't index cg_t::ms_allocatedCount\n\t%i not in [0, %i)", v8, v9) )
          __debugbreak();
      }
      if ( !*v3 )
      {
        LODWORD(v9) = v1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1167, ASSERT_TYPE_ASSERT, "(cg_t::ms_cgArray[localClientNum])", "%s\n\tTrying to access unallocated client globals for localClientNum %d\n", "cg_t::ms_cgArray[localClientNum]", v9) )
          __debugbreak();
      }
      if ( cg_t::ms_allocatedType == GLOB_TYPE_UNKNOWN )
      {
        LODWORD(v9) = v1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1168, ASSERT_TYPE_ASSERT, "(cg_t::ms_allocatedType != CgGlobalsType::GLOB_TYPE_UNKNOWN)", "%s\n\tTrying to access client globals for localClientNum %d but the client global type is not known\n", "cg_t::ms_allocatedType != CgGlobalsType::GLOB_TYPE_UNKNOWN", v9) )
          __debugbreak();
      }
      v5 = *v3;
      p_predictedPlayerState = &(*v3)->predictedPlayerState;
      if ( *v3 == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_local.h", 128, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
        __debugbreak();
      if ( (BG_IsPlayer(p_predictedPlayerState) || BG_IsAgent(p_predictedPlayerState) || BG_IsSpectating(p_predictedPlayerState)) && entityNum == p_predictedPlayerState->clientNum )
        break;
    }
    ++v1;
    ++v3;
    if ( (int)v1 >= SLODWORD(cl_maxLocalClients) )
      return 0i64;
  }
  return v5;
}

/*
==============
CG_GetTracerSpeed
==============
*/
float CG_GetTracerSpeed(const bitarray<64> perks, const Weapon *r_weapon, bool isAlternate)
{
  _RBX = BG_TracerType(perks, r_weapon, isAlternate);
  if ( !_RBX )
  {
    _RBX = cgMedia.tracerDefault;
    if ( !cgMedia.tracerDefault && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 19987, ASSERT_TYPE_ASSERT, "(tracerDef)", (const char *)&queryFormat, "tracerDef") )
      __debugbreak();
  }
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm0, dword ptr [rbx+1Ch]
  }
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 19988, ASSERT_TYPE_ASSERT, "(tracerDef->speed > 0.0f)", (const char *)&queryFormat, "tracerDef->speed > 0.0f") )
    __debugbreak();
  if ( _RBX->fadeOverTime )
    __asm { vmovss  xmm0, cs:__real@7f7fffff }
  else
    __asm { vmovss  xmm0, dword ptr [rbx+1Ch] }
  return *(float *)&_XMM0;
}

/*
==============
CG_GetViewDirection
==============
*/
char CG_GetViewDirection(LocalClientNum_t localClientNum, int entityNum, vec3_t *outForward, vec3_t *outRight, vec3_t *outUp)
{
  vec3_t *v5; 
  unsigned int v6; 
  cg_t **v10; 
  connstate_t *p_connectionState; 
  cg_t *v12; 
  const playerState_s *p_predictedPlayerState; 
  CgStatic *LocalClientStatics; 
  CgHandler *Handler; 
  __int64 ignoreArbitraryUp; 
  __int64 v18; 
  vec3_t angles; 

  v5 = outUp;
  v6 = 0;
  if ( SLODWORD(cl_maxLocalClients) <= 0 )
  {
LABEL_25:
    LocalClientStatics = CgStatic::GetLocalClientStatics(localClientNum);
    if ( LocalClientStatics->GetCharacterAngles(LocalClientStatics, entityNum, &angles) )
    {
      AngleVectors(&angles, outForward, outRight, v5);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    v10 = cg_t::ms_cgArray;
    p_connectionState = &clientUIActives[0].connectionState;
    while ( 1 )
    {
      if ( v6 >= 2 )
      {
        LODWORD(v18) = 2;
        LODWORD(ignoreArbitraryUp) = v6;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_ui_active_client.h", 174, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", ignoreArbitraryUp, v18) )
          __debugbreak();
      }
      if ( *p_connectionState == CA_ACTIVE )
      {
        if ( v6 >= cg_t::ms_allocatedCount )
        {
          LODWORD(v18) = cg_t::ms_allocatedCount;
          LODWORD(ignoreArbitraryUp) = v6;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1166, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( cg_t::ms_allocatedCount )", "localClientNum doesn't index cg_t::ms_allocatedCount\n\t%i not in [0, %i)", ignoreArbitraryUp, v18) )
            __debugbreak();
        }
        if ( !*v10 )
        {
          LODWORD(v18) = v6;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1167, ASSERT_TYPE_ASSERT, "(cg_t::ms_cgArray[localClientNum])", "%s\n\tTrying to access unallocated client globals for localClientNum %d\n", "cg_t::ms_cgArray[localClientNum]", v18) )
            __debugbreak();
        }
        if ( cg_t::ms_allocatedType == GLOB_TYPE_UNKNOWN )
        {
          LODWORD(v18) = v6;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1168, ASSERT_TYPE_ASSERT, "(cg_t::ms_allocatedType != CgGlobalsType::GLOB_TYPE_UNKNOWN)", "%s\n\tTrying to access client globals for localClientNum %d but the client global type is not known\n", "cg_t::ms_allocatedType != CgGlobalsType::GLOB_TYPE_UNKNOWN", v18) )
            __debugbreak();
        }
        v12 = *v10;
        p_predictedPlayerState = &(*v10)->predictedPlayerState;
        if ( *v10 == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_local.h", 128, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
          __debugbreak();
        if ( (BG_IsPlayer(p_predictedPlayerState) || BG_IsAgent(p_predictedPlayerState) || BG_IsSpectating(p_predictedPlayerState)) && entityNum == p_predictedPlayerState->clientNum )
          break;
      }
      ++v6;
      p_connectionState += 110;
      ++v10;
      if ( (int)v6 >= SLODWORD(cl_maxLocalClients) )
        goto LABEL_24;
    }
    if ( !v12 )
    {
LABEL_24:
      v5 = outUp;
      goto LABEL_25;
    }
    Handler = CgHandler::getHandler(localClientNum);
    BG_GetPlayerViewDirection(p_predictedPlayerState, outForward, outRight, outUp, Handler, 0);
    return 1;
  }
}

/*
==============
CG_GetViewModelPoseForHand
==============
*/
cpose_t *CG_GetViewModelPoseForHand(LocalClientNum_t localClientNum, PlayerHandIndex hand)
{
  cg_t *LocalClientGlobals; 
  __int64 v4; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v4 = 303328i64;
  if ( hand )
    v4 = 303616i64;
  return (cpose_t *)((char *)LocalClientGlobals + v4);
}

/*
==============
CG_GetWeapFireSound
==============
*/
SndAliasList *CG_GetWeapFireSound(const WeaponSFXPackage *sfxPackage, bool isPlayerView, bool isPlayerHeli, bool isDualWield, bool useLastFireSound, PlayerHandIndex hand, const SndWeapShotCountId shotCount)
{
  WeaponSFXPackageSounds *sounds; 
  const char *name; 
  const char *v12; 
  __int64 v13; 
  const char *v14; 
  const char *v15; 
  __int64 v16; 
  const char *v17; 
  const char *v18; 
  __int64 v19; 
  const char *v20; 
  SndAliasList *result; 
  const dvar_t *v22; 

  if ( !sfxPackage )
    return 0i64;
  sounds = sfxPackage->sounds;
  name = sounds->fireSound.name;
  if ( isPlayerView || isPlayerHeli )
  {
    v12 = sounds->fireSoundPlayer.name;
    if ( !v12 )
      v12 = sounds->fireSound.name;
    name = v12;
    if ( isDualWield )
    {
      v13 = 112i64;
      if ( hand != WEAPON_HAND_LEFT )
        v13 = 120i64;
      v14 = *(const char **)((char *)&sounds->name + v13);
      if ( v14 )
        name = v14;
    }
  }
  if ( useLastFireSound )
  {
    v15 = (const char *)*((_QWORD *)&sounds->fireLastSound.name + isPlayerView);
    if ( !v15 )
      v15 = name;
    name = v15;
    if ( isPlayerView && isDualWield )
    {
      v16 = 288i64;
      if ( hand != WEAPON_HAND_LEFT )
        v16 = 296i64;
      v17 = *(const char **)((char *)&sounds->name + v16);
      if ( v17 )
        name = v17;
    }
  }
  else if ( shotCount == SND_WEAP_SHOT_FIRST )
  {
    v18 = (const char *)*((_QWORD *)&sounds->fireFirstSound.name + isPlayerView);
    if ( !v18 )
      v18 = name;
    name = v18;
    if ( isPlayerView && isDualWield )
    {
      v19 = 224i64;
      if ( hand != WEAPON_HAND_LEFT )
        v19 = 232i64;
      v20 = *(const char **)((char *)&sounds->name + v19);
      if ( v20 )
        name = v20;
    }
  }
  if ( !name )
    return 0i64;
  result = SND_TryFindAlias(name);
  if ( !result )
  {
    v22 = DCONST_DVARBOOL_snd_bankDetailStreamingFallback;
    if ( !DCONST_DVARBOOL_snd_bankDetailStreamingFallback && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_bankDetailStreamingFallback") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v22);
    if ( v22->current.enabled )
    {
      if ( sfxPackage->transientFallbackPackage == sfxPackage && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18726, ASSERT_TYPE_ASSERT, "(sfxPackage->transientFallbackPackage != sfxPackage)", (const char *)&queryFormat, "sfxPackage->transientFallbackPackage != sfxPackage") )
        __debugbreak();
      return (SndAliasList *)CG_GetWeapFireSound(sfxPackage->transientFallbackPackage, isPlayerView, isPlayerHeli, isDualWield, useLastFireSound, hand, shotCount);
    }
    else
    {
      SND_Missing(name);
      return 0i64;
    }
  }
  return result;
}

/*
==============
CG_GetWeapHyperBurstFireSound
==============
*/
SndAliasList *CG_GetWeapHyperBurstFireSound(const WeaponSFXPackage *sfxPackage, bool isPlayerView, bool isDualWield, PlayerHandIndex hand)
{
  WeaponSFXPackageSounds *sounds; 
  const char *name; 
  __int64 v10; 
  const char *v11; 
  SndAliasList *result; 
  const dvar_t *v13; 

  if ( !sfxPackage )
    return 0i64;
  sounds = sfxPackage->sounds;
  if ( isPlayerView )
  {
    name = sounds->fireHyperBurstSoundPlayer.name;
    if ( isDualWield )
    {
      v10 = 256i64;
      if ( hand != WEAPON_HAND_LEFT )
        v10 = 264i64;
      v11 = *(const char **)((char *)&sounds->name + v10);
      if ( v11 )
        name = v11;
    }
  }
  else
  {
    name = sounds->fireHyperBurstSound.name;
  }
  if ( !name )
    return 0i64;
  result = SND_TryFindAlias(name);
  if ( !result )
  {
    v13 = DCONST_DVARBOOL_snd_bankDetailStreamingFallback;
    if ( !DCONST_DVARBOOL_snd_bankDetailStreamingFallback && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_bankDetailStreamingFallback") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v13);
    if ( v13->current.enabled )
    {
      if ( sfxPackage->transientFallbackPackage == sfxPackage && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18633, ASSERT_TYPE_ASSERT, "(sfxPackage->transientFallbackPackage != sfxPackage)", (const char *)&queryFormat, "sfxPackage->transientFallbackPackage != sfxPackage") )
        __debugbreak();
      return (SndAliasList *)CG_GetWeapHyperBurstFireSound(sfxPackage->transientFallbackPackage, isPlayerView, isDualWield, hand);
    }
    else
    {
      SND_Missing(name);
      return 0i64;
    }
  }
  return result;
}

/*
==============
CG_GetWeaponAnim
==============
*/
XAnimParts *CG_GetWeaponAnim(XAnimParts *const *animArray, int animIndex)
{
  __int64 v2; 
  XAnimParts *result; 

  v2 = animIndex;
  if ( (unsigned int)animIndex >= 0x260 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9088, ASSERT_TYPE_ASSERT, "(unsigned)( animIndex ) < (unsigned)( NUM_WEAP_VIEWMODEL_ANIMS )", "animIndex doesn't index NUM_WEAP_VIEWMODEL_ANIMS\n\t%i not in [0, %i)", animIndex, 608) )
    __debugbreak();
  result = animArray[v2];
  if ( !result )
  {
    result = BG_GetGameDefaultWeaponAnim(v2);
    if ( !result )
    {
      if ( !*((_QWORD *)animArray + 236) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9098, ASSERT_TYPE_ASSERT, "(animArray[WEAP_ANIM_IDLE])", (const char *)&queryFormat, "animArray[WEAP_ANIM_IDLE]") )
        __debugbreak();
      return (XAnimParts *)*((_QWORD *)animArray + 236);
    }
  }
  return result;
}

/*
==============
CG_GetWeaponAnimTime
==============
*/
double CG_GetWeaponAnimTime(LocalClientNum_t localClientNum, PlayerHandIndex handIndex, weapAnimFiles_t animFile)
{
  __int64 v6; 
  cg_t *LocalClientGlobals; 
  const DObj **p_viewModelDObj; 
  const DObj *v9; 
  const XAnimTree *Tree; 
  char v12; 

  v6 = handIndex;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( (unsigned int)v6 >= 2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v6, 2) )
    __debugbreak();
  p_viewModelDObj = (const DObj **)&LocalClientGlobals->m_weaponHand[v6].viewModelDObj;
  if ( !p_viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 15581, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
    __debugbreak();
  v9 = *p_viewModelDObj;
  if ( !v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 15583, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  Tree = DObjGetTree(v9);
  if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 15586, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
    __debugbreak();
  *(double *)&_XMM0 = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, animFile);
  __asm
  {
    vxorps  xmm1, xmm1, xmm1
    vucomiss xmm0, xmm1
  }
  if ( !v12 )
    return XAnimGetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, animFile);
  __asm { vmovss  xmm0, cs:__real@bf800000 }
  return *(double *)&_XMM0;
}

/*
==============
CG_GetWeaponAnimTimeRemaining
==============
*/
float CG_GetWeaponAnimTimeRemaining(XAnimTree *animTree, weapAnimFiles_t weaponAnimFile)
{
  char v8; 
  char v9; 

  __asm { vmovaps [rsp+58h+var_28], xmm7 }
  if ( !animTree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6376, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
    __debugbreak();
  __asm { vxorps  xmm7, xmm7, xmm7 }
  if ( XAnimIsLooped(animTree->anims, weaponAnimFile) )
    goto LABEL_7;
  *(double *)&_XMM0 = XAnimGetWeight(animTree, 0, XANIM_SUBTREE_DEFAULT, weaponAnimFile);
  __asm { vcomiss xmm0, xmm7 }
  if ( v8 | v9 )
  {
LABEL_7:
    __asm
    {
      vmovaps xmm7, [rsp+58h+var_28]
      vxorps  xmm0, xmm0, xmm0
    }
  }
  else
  {
    __asm { vmovaps [rsp+58h+var_18], xmm6 }
    *(double *)&_XMM0 = XAnimGetLength(animTree->anims, weaponAnimFile);
    __asm { vmovaps xmm6, xmm0 }
    *(double *)&_XMM0 = XAnimGetRate(animTree, 0, XANIM_SUBTREE_DEFAULT, weaponAnimFile);
    __asm { vmulss  xmm6, xmm0, xmm6 }
    *(double *)&_XMM0 = XAnimGetTime(animTree, 0, XANIM_SUBTREE_DEFAULT, weaponAnimFile);
    __asm
    {
      vmovaps xmm1, xmm0
      vmovss  xmm0, cs:__real@3f800000
      vsubss  xmm1, xmm0, xmm1
      vmulss  xmm2, xmm1, xmm6
      vmovaps xmm6, [rsp+58h+var_18]
      vmaxss  xmm0, xmm2, xmm7
      vmovaps xmm7, [rsp+58h+var_28]
    }
  }
  return *(float *)&_XMM0;
}

/*
==============
CG_GetWeaponDisplayName
==============
*/
char *CG_GetWeaponDisplayName(const Weapon *weapon, bool isAlternate, char *outputBuffer, unsigned __int64 bufferLen, bool isNewlineSpacer)
{
  Weapon *AltWeapon; 
  unsigned __int8 weaponLootId; 
  unsigned __int64 v12; 
  unsigned int v13; 
  bool v14; 
  bool v15; 
  unsigned int AllWeaponAttachments; 
  unsigned int v17; 
  unsigned int v18; 
  WeaponAttachment **v19; 
  WeaponAttachment *v20; 
  const char *szDisplayName; 
  AttAddOns *addOns; 
  AttSight *sight; 
  AttADSSettings *adsSettings; 
  AttADSSettings *adsSettingsMain; 
  const dvar_t *v26; 
  unsigned int unsignedInt; 
  const char *v28; 
  const char *LootVariantDisplayName; 
  Weapon *v30; 
  const WeaponCompleteDef *v31; 
  const dvar_t *v32; 
  const dvar_t *v33; 
  unsigned int v34; 
  WeaponAttachment **v35; 
  const char *v36; 
  const char *String; 
  const char *v38; 
  const char *v39; 
  char *v40; 
  const char *v41; 
  WeaponAttachment **v42; 
  unsigned __int64 v43; 
  __int64 v44; 
  const char *v45; 
  __int64 v46; 
  const char *v47; 
  char v48; 
  int IsRightToLeft; 
  unsigned __int64 v50; 
  unsigned __int64 v51; 
  const char *v52; 
  char *v53; 
  char *v54; 
  unsigned __int64 v55; 
  char v56; 
  __int64 v57; 
  bool v58; 
  AttachmentSlot slot[2]; 
  bool v60; 
  unsigned __int64 destsize; 
  unsigned int v62; 
  char *dest; 
  Weapon *r_weapon; 
  WeaponAttachment *attachments[30]; 
  char text[1024]; 

  v60 = isNewlineSpacer;
  destsize = bufferLen;
  dest = outputBuffer;
  if ( !outputBuffer && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22358, ASSERT_TYPE_ASSERT, "(outputBuffer)", (const char *)&queryFormat, "outputBuffer") )
    __debugbreak();
  if ( !bufferLen && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22359, ASSERT_TYPE_ASSERT, "(bufferLen > 0)", (const char *)&queryFormat, "bufferLen > 0") )
    __debugbreak();
  if ( !weapon->weaponIdx )
  {
    *outputBuffer = 0;
    return outputBuffer;
  }
  if ( isAlternate )
    AltWeapon = (Weapon *)BG_GetAltWeapon(weapon);
  else
    AltWeapon = (Weapon *)weapon;
  weaponLootId = AltWeapon->weaponLootId;
  v12 = 0i64;
  r_weapon = AltWeapon;
  if ( weaponLootId )
  {
    v13 = weaponLootId - 1;
    v62 = v13;
  }
  else
  {
    v13 = 0;
    v62 = 0;
  }
  v58 = v13 != 0;
  v14 = 0;
  if ( !isAlternate )
  {
    slot[0] = ATT_SLOT_UNDERBARREL;
    if ( BG_Weapon_GetPrimaryAttachmentIndex(weapon, slot) )
      v14 = 1;
  }
  slot[0] = ATT_SLOT_SCOPE;
  v15 = BG_Weapon_GetPrimaryAttachmentIndex(AltWeapon, slot) != 0;
  AllWeaponAttachments = BG_GetAllWeaponAttachments(weapon, (const WeaponAttachment **)attachments);
  v17 = AllWeaponAttachments;
  if ( AllWeaponAttachments > 0x1D )
  {
    LODWORD(v57) = AllWeaponAttachments;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22246, ASSERT_TYPE_ASSERT, "( attachmentCount ) <= ( (1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 16 + 1 + 1 + 1 + 1) )", "attachmentCount not in [0, MAX_NUM_WEAPON_ATTACHMENTS]\n\t%u not in [0, %u]", v57, 29) )
      __debugbreak();
  }
  v18 = 0;
  if ( v17 )
  {
    do
    {
      v19 = &attachments[v18];
      if ( !*v19 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22253, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      v20 = *v19;
      szDisplayName = (*v19)->szDisplayName;
      if ( !szDisplayName || !*szDisplayName || v14 && v20->type == ATTACHMENT_UNDERBARREL && (addOns = v20->addOns) != NULL && addOns->silenced || v15 && (sight = v20->sight) != NULL && sight->hideRailWithThisScope && ((adsSettings = v20->adsSettings) == NULL || adsSettings->zoomSettings.scene.adsZoomCount <= 1) && ((adsSettingsMain = v20->adsSettingsMain) == NULL || adsSettingsMain->zoomSettings.scene.adsZoomCount <= 1) )
        v17 = CG_RemoveAttachmentFromList(v18, (const WeaponAttachment **)attachments, v17);
      else
        ++v18;
    }
    while ( v18 < v17 );
    v13 = v62;
    v12 = 0i64;
    AltWeapon = r_weapon;
  }
  v26 = DCONST_DVARMPSPINT_cg_maxAttachmentDisplays;
  if ( !DCONST_DVARMPSPINT_cg_maxAttachmentDisplays && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_maxAttachmentDisplays") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v26);
  unsignedInt = v26->current.unsignedInt;
  if ( v58 )
  {
    LootVariantDisplayName = CG_Weapons_GetLootVariantDisplayName(AltWeapon, v13);
    *(_QWORD *)slot = LootVariantDisplayName;
  }
  else
  {
    v34 = 0;
    if ( !v17 )
      goto LABEL_49;
    v35 = attachments;
    while ( 1 )
    {
      if ( (*v35)->overrideDisplayName )
      {
        if ( !*v35 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22395, ASSERT_TYPE_ASSERT, "(attachments[i])", (const char *)&queryFormat, "attachments[i]") )
          __debugbreak();
        v36 = (*v35)->szDisplayName;
        if ( !v36 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22397, ASSERT_TYPE_ASSERT, "(attachmentNameRef)", (const char *)&queryFormat, "attachmentNameRef") )
          __debugbreak();
        if ( !*v36 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22398, ASSERT_TYPE_ASSERT, "(attachmentNameRef[0])", (const char *)&queryFormat, "attachmentNameRef[0]") )
          __debugbreak();
        String = SEH_StringEd_GetString(v36);
        *(_QWORD *)slot = String;
        LootVariantDisplayName = String;
        if ( String )
        {
          if ( *String )
            break;
        }
      }
      ++v34;
      ++v35;
      if ( v34 >= v17 )
        goto LABEL_49;
    }
  }
  if ( LootVariantDisplayName )
    goto LABEL_82;
LABEL_49:
  v30 = r_weapon;
  v31 = BG_WeaponCompleteDef(r_weapon, 0);
  *(_QWORD *)slot = SEH_StringEd_GetString(v31->szDisplayName);
  LootVariantDisplayName = *(const char **)slot;
  if ( *(_QWORD *)slot )
  {
LABEL_79:
    if ( !LootVariantDisplayName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22415, ASSERT_TYPE_ASSERT, "(baseWeaponName)", (const char *)&queryFormat, "baseWeaponName") )
      __debugbreak();
    goto LABEL_82;
  }
  v32 = DCONST_DVARBOOL_loc_warnings;
  if ( !DCONST_DVARBOOL_loc_warnings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "loc_warnings") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v32);
  if ( v32->current.enabled )
  {
    v33 = DCONST_DVARBOOL_loc_warningsAsErrors;
    if ( !DCONST_DVARBOOL_loc_warningsAsErrors && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "loc_warningsAsErrors") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v33);
    if ( v33->current.enabled )
      Com_Error_impl(ERR_LOCALIZATION, (const ObfuscateErrorText)&stru_1442E0B10, 618i64, v30->weaponIdx, v31->szDisplayName);
    else
      Com_PrintWarning(17, "WARNING: Weapon %d: Could not translate display name \"%s\"\n", v30->weaponIdx, v31->szDisplayName);
  }
  LootVariantDisplayName = v31->szDisplayName;
  *(_QWORD *)slot = LootVariantDisplayName;
  if ( !LootVariantDisplayName )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22213, ASSERT_TYPE_ASSERT, (const char *)&stru_143C9A1A4.m_end, (const char *)&queryFormat, &stru_143C9A1A4) )
      __debugbreak();
    goto LABEL_79;
  }
LABEL_82:
  if ( v17 <= unsignedInt )
  {
    v41 = " ";
    if ( v60 )
      v41 = "\n";
    if ( v58 || !v17 )
    {
      v48 = 0;
    }
    else
    {
      v42 = attachments;
      v43 = 0i64;
      v44 = v17;
      do
      {
        if ( !(*v42)->overrideDisplayName )
        {
          if ( !*v42 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22444, ASSERT_TYPE_ASSERT, "(attachments[i])", (const char *)&queryFormat, "attachments[i]") )
            __debugbreak();
          v45 = (*v42)->szDisplayName;
          if ( !v45 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22446, ASSERT_TYPE_ASSERT, "(attachmentNameRef)", (const char *)&queryFormat, "attachmentNameRef") )
            __debugbreak();
          if ( !*v45 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22447, ASSERT_TYPE_ASSERT, "(attachmentNameRef[0])", (const char *)&queryFormat, "attachmentNameRef[0]") )
            __debugbreak();
          v28 = SEH_StringEd_GetString(v45);
          if ( v28 )
          {
            v46 = -1i64;
            do
              ++v46;
            while ( v28[v46] );
            if ( v46 )
            {
              if ( v43 && *v41 )
              {
                v47 = &v41[-v43];
                do
                {
                  if ( v43 >= 0x3FF )
                    break;
                  text[v43] = v47[v43];
                  ++v43;
                }
                while ( v47[v43] );
              }
              if ( *v28 )
              {
                v28 -= v43;
                do
                {
                  if ( v43 >= 0x3FF )
                    break;
                  text[v43] = v28[v43];
                  ++v43;
                }
                while ( v28[v43] );
              }
            }
          }
        }
        ++v42;
        --v44;
      }
      while ( v44 );
      LootVariantDisplayName = *(const char **)slot;
      v12 = 0i64;
      if ( v43 >= 0x400 )
      {
        j___report_rangecheckfailure(v28);
        JUMPOUT(0x141DD92A7i64);
      }
      text[v43] = 0;
      v48 = 1;
      R_TextValidatePrintable(text);
    }
    *(_QWORD *)slot = 0i64;
    IsRightToLeft = Language_IsRightToLeft();
    v40 = dest;
    if ( IsRightToLeft )
    {
      if ( v48 )
      {
        v54 = text;
        if ( dest || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22334, ASSERT_TYPE_ASSERT, "(outputBuffer)", (const char *)&queryFormat, "outputBuffer") )
        {
          v55 = destsize;
        }
        else
        {
          __debugbreak();
          v55 = destsize;
        }
        if ( text[0] )
        {
          do
          {
            if ( v12 >= v55 - 1 )
              break;
            v56 = *v54++;
            v40[v12++] = v56;
            *(_QWORD *)slot = v12;
          }
          while ( *v54 );
        }
      }
      else
      {
        v55 = destsize;
      }
      CG_AppendNameToBuffer(v41, LootVariantDisplayName, (unsigned __int64 *)slot, v55, v40);
    }
    else
    {
      v50 = destsize;
      CG_AppendNameToBuffer(v41, LootVariantDisplayName, (unsigned __int64 *)slot, destsize, dest);
      if ( v48 )
      {
        if ( !v40 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22334, ASSERT_TYPE_ASSERT, "(outputBuffer)", (const char *)&queryFormat, "outputBuffer") )
          __debugbreak();
        v51 = *(_QWORD *)slot;
        if ( *(_QWORD *)slot && *v41 )
        {
          v52 = &v41[-*(_QWORD *)slot];
          do
          {
            if ( v51 >= v50 - 1 )
              break;
            v40[v51] = v52[v51];
            ++v51;
          }
          while ( v52[v51] );
        }
        if ( text[0] )
        {
          v53 = &text[-v51];
          do
          {
            if ( v51 >= v50 - 1 )
              break;
            v40[v51] = v53[v51];
            ++v51;
          }
          while ( v53[v51] );
        }
        goto LABEL_143;
      }
    }
    v51 = *(_QWORD *)slot;
LABEL_143:
    v40[v51] = 0;
    goto LABEL_144;
  }
  v38 = SEH_StringEd_GetString("WEAPON/CUSTOM_ATTACHMENT");
  v39 = UI_ReplaceConversionString(v38, LootVariantDisplayName);
  v40 = dest;
  Core_strcpy(dest, destsize, v39);
LABEL_144:
  R_TextValidatePrintable(v40);
  return v40;
}

/*
==============
CG_GetWeaponZoom
==============
*/

float __fastcall CG_GetWeaponZoom(const cg_t *cgameGlob, const Weapon *weapon, double weapPosFrac, const CG_FovSpace fovSpace)
{
  char v19; 

  __asm
  {
    vmovaps [rsp+88h+var_28], xmm6
    vmovaps [rsp+88h+var_38], xmm7
    vxorps  xmm7, xmm7, xmm7
    vcomiss xmm2, xmm7
    vmovaps [rsp+88h+var_48], xmm8
    vmovaps xmm8, xmm2
    vmovss  xmm6, cs:__real@3f800000
    vcomiss xmm2, xmm6
    vmovaps xmm0, xmm6
    vmovaps xmm6, [rsp+88h+var_28]
  }
  _R11 = &v19;
  __asm
  {
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm7, [rsp+88h+var_38]
  }
  return *(float *)&_XMM0;
}

/*
==============
CG_HasRecoilAnim
==============
*/
_BOOL8 CG_HasRecoilAnim(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex hand)
{
  cg_t *LocalClientGlobals; 
  PlayerWeaponAnimArrays *p_m_weaponAnimArrays; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6946, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6949, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( &LocalClientGlobals->predictedPlayerState != ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6950, ASSERT_TYPE_ASSERT, "(&cgameGlob->predictedPlayerState == ps)", "%s\n\tInvalid player state in client weapon processing. Expected predicted player state.\n", "&cgameGlob->predictedPlayerState == ps") )
    __debugbreak();
  p_m_weaponAnimArrays = &LocalClientGlobals->m_weaponAnimArrays;
  if ( !p_m_weaponAnimArrays && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6953, ASSERT_TYPE_ASSERT, "(weaponAnimArrays)", (const char *)&queryFormat, "weaponAnimArrays") )
    __debugbreak();
  if ( BG_UsingAlternate(ps) )
    p_m_weaponAnimArrays = (PlayerWeaponAnimArrays *)((char *)p_m_weaponAnimArrays + 4976);
  return (p_m_weaponAnimArrays->normalAnimArray[412] || p_m_weaponAnimArrays->normalAnimArray[176]) && p_m_weaponAnimArrays->normalAnimArray[373];
}

/*
==============
CG_IsAutoSimFiring
==============
*/
char CG_IsAutoSimFiring(cg_t *cgameGlob)
{
  int v1; 
  int *i; 

  v1 = 0;
  for ( i = &s_snd_autosims[0].shot.entNum; !i[42] || cgameGlob->predictedPlayerState.clientNum != *i; i += 48 )
  {
    if ( (unsigned int)++v1 >= 0x40 )
      return 0;
  }
  return 1;
}

/*
==============
CG_IsJogging
==============
*/
bool CG_IsJogging(LocalClientNum_t localClientNum)
{
  __int64 v3; 
  cg_t *LocalClientGlobals; 
  const char *v21; 
  char v22; 
  char v23; 
  const char *v27; 
  bool result; 

  v3 = localClientNum;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !CgWeaponMap::ms_instance[v3] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  __asm
  {
    vmovaps [rsp+68h+var_18], xmm6
    vmovaps [rsp+68h+var_28], xmm7
  }
  if ( !BG_CanJog(CgWeaponMap::ms_instance[v3], &LocalClientGlobals->predictedPlayerState) )
    goto LABEL_23;
  BG_CmdScale_CalcCmdScale(LocalClientGlobals->predictedPlayerState.lastInput.forwardmove, LocalClientGlobals->predictedPlayerState.lastInput.rightmove);
  _EAX = LocalClientGlobals->predictedPlayerState.lastInput.forwardmove;
  __asm { vmovd   xmm1, eax }
  _EAX = LocalClientGlobals->predictedPlayerState.lastInput.rightmove;
  __asm
  {
    vcvtdq2ps xmm1, xmm1
    vmulss  xmm2, xmm1, cs:__real@3c010204
    vmulss  xmm7, xmm2, xmm0
    vmovd   xmm3, eax
    vcvtdq2ps xmm3, xmm3
    vmulss  xmm1, xmm3, cs:__real@38820610
    vmulss  xmm2, xmm1, xmm0
    vmulss  xmm3, xmm2, xmm3
    vmulss  xmm4, xmm3, xmm0
    vmulss  xmm0, xmm7, xmm7
    vaddss  xmm1, xmm4, xmm0
    vsqrtss xmm6, xmm1, xmm1
  }
  if ( LocalClientGlobals->isJogging )
  {
    _RBX = DCONST_DVARFLT_jogStickMinDeflectionMaintain;
    if ( DCONST_DVARFLT_jogStickMinDeflectionMaintain )
      goto LABEL_12;
    v21 = "jogStickMinDeflectionMaintain";
  }
  else
  {
    _RBX = DCONST_DVARFLT_jogStickMinDeflectionStart;
    if ( DCONST_DVARFLT_jogStickMinDeflectionStart )
      goto LABEL_12;
    v21 = "jogStickMinDeflectionStart";
  }
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", v21) )
    __debugbreak();
LABEL_12:
  Dvar_CheckFrontendServerThread(_RBX);
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+28h]
    vcomiss xmm0, xmm6
  }
  if ( !(v22 | v23) )
    goto LABEL_23;
  __asm
  {
    vcvtss2sd xmm0, xmm6, xmm6
    vcomisd xmm0, cs:__real@3eb0c6f7a0b5ed8d
  }
  if ( v22 | v23 )
    goto LABEL_23;
  if ( LocalClientGlobals->isJogging )
  {
    _RBX = DCONST_DVARFLT_jogStickMinAngleMaintain;
    if ( DCONST_DVARFLT_jogStickMinAngleMaintain )
      goto LABEL_21;
    v27 = "jogStickMinAngleMaintain";
  }
  else
  {
    _RBX = DCONST_DVARFLT_jogStickMinAngleStart;
    if ( DCONST_DVARFLT_jogStickMinAngleStart )
      goto LABEL_21;
    v27 = "jogStickMinAngleStart";
  }
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", v27) )
    __debugbreak();
LABEL_21:
  Dvar_CheckFrontendServerThread(_RBX);
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+28h]
    vmulss  xmm0, xmm0, cs:__real@3c8efa35; X
  }
  *(float *)&_XMM0 = cosf_0(*(float *)&_XMM0);
  __asm { vcomiss xmm0, xmm7 }
  if ( !(v22 | v23) )
  {
LABEL_23:
    result = 0;
    goto LABEL_24;
  }
  result = 1;
LABEL_24:
  __asm
  {
    vmovaps xmm7, [rsp+68h+var_28]
    vmovaps xmm6, [rsp+68h+var_18]
  }
  return result;
}

/*
==============
CG_IsWeaponInspectOnAltToggle
==============
*/
char CG_IsWeaponInspectOnAltToggle(LocalClientNum_t localClientNum)
{
  const dvar_t *v2; 
  const dvar_t *v3; 
  cg_t *LocalClientGlobals; 
  CgWeaponMap *Instance; 
  const Weapon *CurrentWeaponForPlayer; 
  bool v7; 

  if ( !Com_GameMode_SupportsFeature(WEAPON_LEAP_OUT|0x80) || !CL_Input_IsGamepadEnabled(localClientNum) )
    return 0;
  v2 = DVARBOOL_killswitch_weapon_inspect_enabled;
  if ( !DVARBOOL_killswitch_weapon_inspect_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_weapon_inspect_enabled") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  if ( !v2->current.enabled )
    return 0;
  v3 = DVARBOOL_killswitch_weapon_inspect_on_alt_switch_hold_enabled;
  if ( !DVARBOOL_killswitch_weapon_inspect_on_alt_switch_hold_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_weapon_inspect_on_alt_switch_hold_enabled") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v3);
  if ( v3->current.enabled && (LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum), Instance = CgWeaponMap::GetInstance(localClientNum), CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(Instance, &LocalClientGlobals->predictedPlayerState), v7 = BG_UsingAlternate(&LocalClientGlobals->predictedPlayerState), BG_GetWeaponInspectEnabled(CurrentWeaponForPlayer, v7)) )
    return 1;
  else
    return 0;
}

/*
==============
CG_JavelinADS
==============
*/

bool __fastcall CG_JavelinADS(LocalClientNum_t localClientNum, __int64 a2, double _XMM2_8)
{
  cg_t *LocalClientGlobals; 
  const playerState_s *p_predictedPlayerState; 
  CgWeaponMap *Instance; 
  int v11; 
  char v12; 
  Weapon r_weapon; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  p_predictedPlayerState = &LocalClientGlobals->predictedPlayerState;
  if ( LocalClientGlobals == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2152, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( BG_IsTurretActiveFlags(&p_predictedPlayerState->eFlags) )
    return 0;
  Instance = CgWeaponMap::GetInstance(localClientNum);
  _RAX = BG_GetViewmodelWeapon(Instance, p_predictedPlayerState);
  __asm
  {
    vmovups ymm2, ymmword ptr [rax]
    vmovups xmm0, xmmword ptr [rax+20h]
    vmovsd  xmm1, qword ptr [rax+30h]
  }
  v11 = *(_DWORD *)&_RAX->weaponCamo;
  __asm { vmovd   eax, xmm2 }
  *(_DWORD *)&r_weapon.weaponCamo = v11;
  __asm
  {
    vmovups ymmword ptr [rsp+78h+r_weapon.weaponIdx], ymm2
    vmovups xmmword ptr [rsp+78h+r_weapon.attachmentVariationIndices+5], xmm0
    vmovsd  qword ptr [rsp+78h+r_weapon.attachmentVariationIndices+15h], xmm1
  }
  if ( !(_WORD)_RAX )
    return 0;
  *(double *)&_XMM0 = BG_WeaponADSFractionAffectedByReload(Instance, p_predictedPlayerState);
  __asm { vucomiss xmm0, cs:__real@3f800000 }
  if ( !v12 )
    return 0;
  return BG_WeaponDef(&r_weapon, 0)->overlayInterface == WEAPOVERLAYINTERFACE_JAVELIN;
}

/*
==============
CG_KillstreakSlotDown
==============
*/
void CG_KillstreakSlotDown(LocalClientNum_t localClientNum, int bindingIndex)
{
  __int64 v2; 
  int v5; 
  const char *v6; 
  unsigned int v8; 
  const char *v9; 
  int result; 
  int notifyData[4]; 

  v2 = bindingIndex;
  if ( !CL_Input_IsGamepadEnabled(localClientNum) )
  {
    if ( (unsigned __int8)Com_GameMode_GetActiveGameMode() == LONG )
    {
      __asm
      {
        vmovdqu xmm0, cs:__xmm@00000003000000020000000100000000
        vmovdqu xmmword ptr [rsp+58h+notifyData], xmm0
      }
      v5 = notifyData[v2];
      v6 = "radial_menu_munition";
LABEL_7:
      CG_ServerCmd_NotifyServer(localClientNum, v6, v5);
      return;
    }
    __asm
    {
      vmovdqu xmm0, cs:__xmm@00000000000000030000000200000001
      vmovdqu xmmword ptr [rsp+58h+notifyData], xmm0
    }
    v8 = notifyData[v2];
    v9 = j_va("ui_score_streak_available_%i", v8);
    if ( CG_GetOmnvar_IntegerByName(localClientNum, v9, &result, NULL, NULL) && result == 1 )
    {
      v5 = v8;
      v6 = "streak_select";
      goto LABEL_7;
    }
  }
}

/*
==============
CG_LoadViewModelAnimIndexFixup
==============
*/
__int64 CG_LoadViewModelAnimIndexFixup(unsigned int savedAnimIndex, unsigned __int8 savedVersion, unsigned __int8 currentVersion)
{
  unsigned int v3; 

  v3 = savedAnimIndex;
  if ( savedVersion || currentVersion != 1 )
  {
    if ( savedVersion != currentVersion )
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1442DEBF0, 6441i64, savedVersion);
  }
  else if ( savedAnimIndex >= 0xB5 )
  {
    v3 = savedAnimIndex + 16;
    if ( savedAnimIndex + 16 >= 0x260 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13540, ASSERT_TYPE_ASSERT, "(animIndex < NUM_WEAP_VIEWMODEL_ANIMS)", (const char *)&queryFormat, "animIndex < NUM_WEAP_VIEWMODEL_ANIMS") )
    {
      __debugbreak();
      return v3;
    }
  }
  return v3;
}

/*
==============
CG_LoadViewModelAnimTrees
==============
*/
void CG_LoadViewModelAnimTrees(SaveGame *save, const playerState_s *ps, LocalClientNum_t localClientNum)
{
  __int64 v3; 
  MemoryFile *MemoryFile; 
  const Weapon *ViewmodelWeapon; 
  cg_t *LocalClientGlobals; 
  int v9; 
  bool v10; 
  WeaponHand *m_weaponHand; 
  DObj *viewModelDObj; 
  __int64 v13; 
  __int64 v14; 

  v3 = localClientNum;
  if ( !save && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13558, ASSERT_TYPE_ASSERT, "(save)", (const char *)&queryFormat, "save") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13559, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  MemoryFile = SaveMemory_GetMemoryFile(save);
  if ( !CgWeaponMap::ms_instance[v3] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  ViewmodelWeapon = BG_GetViewmodelWeapon(CgWeaponMap::ms_instance[v3], ps);
  if ( ViewmodelWeapon->weaponIdx )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v3);
    v9 = 0;
    v10 = 1;
    m_weaponHand = LocalClientGlobals->m_weaponHand;
    do
    {
      if ( !v10 )
      {
        LODWORD(v14) = 2;
        LODWORD(v13) = v9;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v13, v14) )
          __debugbreak();
      }
      if ( m_weaponHand->hasAnimTree )
      {
        CG_Weapons_LoadViewModelDObj((const LocalClientNum_t)v3, ps, ViewmodelWeapon, (const PlayerHandIndex)v9);
        viewModelDObj = m_weaponHand->viewModelDObj;
        if ( !m_weaponHand->viewModelDObj )
        {
          Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1442DEC60, 614i64);
          viewModelDObj = m_weaponHand->viewModelDObj;
        }
        if ( m_weaponHand->tree )
        {
          XAnimClearTree(viewModelDObj);
          viewModelDObj = m_weaponHand->viewModelDObj;
        }
        XAnimLoadAnimTreeWithVersion(viewModelDObj, MemoryFile, 1u, (unsigned int (__fastcall *)(unsigned int, unsigned __int8, unsigned __int8))CG_LoadViewModelAnimIndexFixup);
      }
      ++v9;
      ++m_weaponHand;
      v10 = (unsigned int)v9 < 2;
    }
    while ( v9 < 2 );
  }
}

/*
==============
CG_MeleeBloodEvent
==============
*/
void CG_MeleeBloodEvent(LocalClientNum_t localClientNum, int attackerEntityNum)
{
  const dvar_t *v3; 
  FXRegisteredDef *p_fxKnifeBlood; 

  if ( CG_GetLocalClientGlobals(localClientNum)->predictedPlayerState.clientNum == attackerEntityNum && useBlood )
  {
    v3 = DVARBOOL_cg_blood;
    if ( !DVARBOOL_cg_blood && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_blood") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v3);
    p_fxKnifeBlood = &cgMedia.fxKnifeBlood;
    if ( !v3->current.enabled )
      p_fxKnifeBlood = &cgMedia.fxKnifeNoBlood;
    CG_PlayBoltedEffect(localClientNum, p_fxKnifeBlood, 2048, scr_const.tag_knife_fx);
  }
}

/*
==============
CG_MissileTrajectoryEvent
==============
*/
void CG_MissileTrajectoryEvent(LocalClientNum_t localClientNum, centity_t *cent)
{
  __int64 v3; 
  const BgWeaponMap **v4; 
  const Weapon *weapon; 
  bool isAlternate; 
  CgWeaponSystem *WeaponSystem; 
  CgSoundSystem *SoundSystem; 
  __int64 v9; 
  unsigned int groundEntityNum; 
  bool v11; 
  vec3_t outOrigin; 
  char v13[8]; 
  __int64 v14; 

  v3 = localClientNum;
  if ( !Com_GameMode_SupportsFeature(WEAPON_OFFHAND_HOLD_PRIMED) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22125, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::EVENT_MISSILE_TRAJECTORY ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::EVENT_MISSILE_TRAJECTORY )") )
    __debugbreak();
  v4 = (const BgWeaponMap **)&CgWeaponMap::ms_instance[v3];
  if ( !*v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  weapon = BG_GetWeaponForEntity(*v4, &cent->nextState);
  isAlternate = cent->nextState.inAltWeaponMode;
  CG_GetLocalClientGlobals((const LocalClientNum_t)v3);
  WeaponSystem = CgWeaponSystem::GetWeaponSystem((const LocalClientNum_t)v3);
  CG_GetPoseOrigin(&cent->pose, &outOrigin);
  Physics_AddDeferredBulletForce((const Physics_WorldId)(3 * v3 + 3), (const vec3_t *)&cent->nextState.lerp.u, &outOrigin, cent->nextState.otherEntityNum, 0, weapon, isAlternate, 0, CG_BulletHitEffectCallback);
  if ( BG_ProjWhizByEnabled(weapon, isAlternate) )
  {
    v14 = 0i64;
    SoundSystem = CgSoundSystem::GetSoundSystem((const LocalClientNum_t)WeaponSystem->m_localClientNum);
    v11 = isAlternate;
    LOBYTE(v9) = 1;
    ((void (__fastcall *)(CgSoundSystem *, char *, __int64, __int64, LerpEntityStateTypeUnion *, LerpEntityStateTypeUnion *, vec3_t *, int, const Weapon *, bool, int, _DWORD, __int64))SoundSystem->PlayWhizbyAndImpactSfx)(SoundSystem, v13, v9, 2046i64, &cent->nextState.lerp.u, &cent->nextState.lerp.u, &outOrigin, -1, weapon, v11, -1, 0, -2i64);
  }
  groundEntityNum = cent->nextState.groundEntityNum;
  if ( groundEntityNum < 0x7FE )
    CgWeaponSystem::BulletScriptableImpact(WeaponSystem, cent->nextState.otherEntityNum, groundEntityNum, weapon, isAlternate, MOD_UNKNOWN, (const vec3_t *)&cent->nextState.lerp.u, &outOrigin, (const scr_string_t)cent->nextState.lerp.u.event.bulletHitSP.partName);
  memset(&outOrigin, 0, sizeof(outOrigin));
}

/*
==============
CG_NextSlotHasWeapons
==============
*/
bool CG_NextSlotHasWeapons(LocalClientNum_t localClientNum)
{
  WeaponSlot CurrentWeaponSlot; 
  WeaponSlot v3; 
  cg_t *LocalClientGlobals; 
  CgWeaponMap *Instance; 
  WeaponSlot CycleSlot; 

  CurrentWeaponSlot = CG_GetCurrentWeaponSlot(localClientNum);
  v3 = CurrentWeaponSlot;
  if ( CurrentWeaponSlot )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    Instance = CgWeaponMap::GetInstance(localClientNum);
    CycleSlot = BG_PlayerWeaponGetCycleSlot(v3, 1);
    LOBYTE(CurrentWeaponSlot) = BG_PlayerWeaponCountWeaponsBySlot(Instance, &LocalClientGlobals->predictedPlayerState, CycleSlot) != 0;
  }
  return CurrentWeaponSlot;
}

/*
==============
CG_NightVisionBloomDisabled
==============
*/
__int64 CG_NightVisionBloomDisabled()
{
  const dvar_t *v0; 

  v0 = DCONST_DVARMPBOOL_NVG_DisableBloom;
  if ( !DCONST_DVARMPBOOL_NVG_DisableBloom && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_DisableBloom") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v0);
  return v0->current.color[0];
}

/*
==============
CG_NightVisionDown
==============
*/
void CG_NightVisionDown(LocalClientNum_t localClientNum)
{
  __int64 v1; 
  __int64 v2; 
  cg_t *LocalClientGlobals; 
  cg_t *v4; 
  __int64 v5; 
  cg_t *v6; 
  bool v7; 
  unsigned int v8; 
  __int64 v9; 
  __int64 v11; 
  int v12; 

  v1 = localClientNum;
  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT )
  {
    v12 = 2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_ui_active_client.h", 158, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, v12) )
      __debugbreak();
  }
  v2 = v1;
  if ( (clientUIActives[v1].frontEndSceneState[0] || !clientUIActives[v2].cgameInitialized) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18400, ASSERT_TYPE_ASSERT, "(CL_IsGameClientActive( localClientNum ))", (const char *)&queryFormat, "CL_IsGameClientActive( localClientNum )") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v1);
  if ( CG_Weapons_ActionSlotTypeUsageAllowed(LocalClientGlobals, ACTIONSLOTTYPE_NIGHTVISION) )
  {
    if ( (unsigned int)v1 >= 2 )
    {
      LODWORD(v11) = 2;
      LODWORD(v9) = v1;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_ui_active_client.h", 158, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v9, v11) )
        __debugbreak();
    }
    if ( (clientUIActives[v2].frontEndSceneState[0] || !clientUIActives[v2].cgameInitialized) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18384, ASSERT_TYPE_ASSERT, "(CL_IsGameClientActive( localClientNum ))", (const char *)&queryFormat, "CL_IsGameClientActive( localClientNum )") )
      __debugbreak();
    v4 = CG_GetLocalClientGlobals((const LocalClientNum_t)v1);
    v5 = 0i64;
    v6 = v4;
    while ( 1 )
    {
      v7 = Com_GameMode_SupportsFeature(WEAPON_DROPPING_QUICK);
      v8 = 4;
      if ( v7 )
        v8 = 7;
      if ( (unsigned int)v5 >= v8 )
        break;
      if ( v6->predictedPlayerState.actionSlotType[v5] == ACTIONSLOTTYPE_NIGHTVISION )
      {
        LocalClientGlobals->extraButtons |= 0x10000ui64;
        return;
      }
      v5 = (unsigned int)(v5 + 1);
    }
  }
}

/*
==============
CG_NightVisionGetBloomTimings
==============
*/
void CG_NightVisionGetBloomTimings(const int NVGToggleTime, const bool isOn, const bool isInstant, int *outBloomStartBlendInTime, int *outBloomStartBlendOutTime, int *outBlendInDuration, int *outBlendOutDuration)
{
  const dvar_t *v9; 
  const char *v10; 
  int v11; 
  const dvar_t *v12; 
  const char *v13; 
  const dvar_t *v14; 
  const char *v15; 
  int integer; 
  const dvar_t *v17; 
  const char *v18; 
  const dvar_t *v19; 
  const char *v20; 
  const dvar_t *v21; 
  const char *v22; 

  if ( !outBloomStartBlendInTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12754, ASSERT_TYPE_ASSERT, "(outBloomStartBlendInTime)", (const char *)&queryFormat, "outBloomStartBlendInTime") )
    __debugbreak();
  if ( !outBloomStartBlendOutTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12755, ASSERT_TYPE_ASSERT, "(outBloomStartBlendOutTime)", (const char *)&queryFormat, "outBloomStartBlendOutTime") )
    __debugbreak();
  if ( !outBlendInDuration && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12756, ASSERT_TYPE_ASSERT, "(outBlendInDuration)", (const char *)&queryFormat, "outBlendInDuration") )
    __debugbreak();
  if ( !outBlendOutDuration && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12757, ASSERT_TYPE_ASSERT, "(outBlendOutDuration)", (const char *)&queryFormat, "outBlendOutDuration") )
    __debugbreak();
  if ( isInstant )
  {
    v11 = 0;
    if ( isOn )
    {
      v19 = DCONST_DVARMPINT_NVG_ON_Instant_BloomBlendInDurationMS;
      if ( DCONST_DVARMPINT_NVG_ON_Instant_BloomBlendInDurationMS )
        goto LABEL_47;
      v20 = "NVG_ON_Instant_BloomBlendInDurationMS";
    }
    else
    {
      v19 = DCONST_DVARMPINT_NVG_OFF_Instant_BloomBlendInDurationMS;
      if ( DCONST_DVARMPINT_NVG_OFF_Instant_BloomBlendInDurationMS )
        goto LABEL_47;
      v20 = "NVG_OFF_Instant_BloomBlendInDurationMS";
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", v20) )
      __debugbreak();
LABEL_47:
    Dvar_CheckFrontendServerThread(v19);
    *outBlendInDuration = v19->current.integer;
    if ( isOn )
    {
      v21 = DCONST_DVARMPINT_NVG_ON_Instant_BloomEndOffsetMS;
      if ( DCONST_DVARMPINT_NVG_ON_Instant_BloomEndOffsetMS )
        goto LABEL_54;
      v22 = "NVG_ON_Instant_BloomEndOffsetMS";
    }
    else
    {
      v21 = DCONST_DVARMPINT_NVG_OFF_Instant_BloomEndOffsetMS;
      if ( DCONST_DVARMPINT_NVG_OFF_Instant_BloomEndOffsetMS )
        goto LABEL_54;
      v22 = "NVG_OFF_Instant_BloomEndOffsetMS";
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", v22) )
      __debugbreak();
LABEL_54:
    Dvar_CheckFrontendServerThread(v21);
    integer = v21->current.integer;
    if ( isOn )
    {
      v17 = DCONST_DVARMPINT_NVG_ON_Instant_BloomBlendOutDurationMS;
      if ( DCONST_DVARMPINT_NVG_ON_Instant_BloomBlendOutDurationMS )
        goto LABEL_61;
      v18 = "NVG_ON_Instant_BloomBlendOutDurationMS";
    }
    else
    {
      v17 = DCONST_DVARMPINT_NVG_OFF_Instant_BloomBlendOutDurationMS;
      if ( DCONST_DVARMPINT_NVG_OFF_Instant_BloomBlendOutDurationMS )
        goto LABEL_61;
      v18 = "NVG_OFF_Instant_BloomBlendOutDurationMS";
    }
    goto LABEL_59;
  }
  if ( isOn )
  {
    v9 = DCONST_DVARMPINT_NVG_ON_BloomStartOffsetMS;
    if ( DCONST_DVARMPINT_NVG_ON_BloomStartOffsetMS )
      goto LABEL_21;
    v10 = "NVG_ON_BloomStartOffsetMS";
  }
  else
  {
    v9 = DCONST_DVARMPINT_NVG_OFF_BloomStartOffsetMS;
    if ( DCONST_DVARMPINT_NVG_OFF_BloomStartOffsetMS )
      goto LABEL_21;
    v10 = "NVG_OFF_BloomStartOffsetMS";
  }
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", v10) )
    __debugbreak();
LABEL_21:
  Dvar_CheckFrontendServerThread(v9);
  v11 = v9->current.integer;
  if ( isOn )
  {
    v12 = DCONST_DVARMPINT_NVG_ON_BloomBlendInDurationMS;
    if ( DCONST_DVARMPINT_NVG_ON_BloomBlendInDurationMS )
      goto LABEL_28;
    v13 = "NVG_ON_BloomBlendInDurationMS";
  }
  else
  {
    v12 = DCONST_DVARMPINT_NVG_OFF_BloomBlendInDurationMS;
    if ( DCONST_DVARMPINT_NVG_OFF_BloomBlendInDurationMS )
      goto LABEL_28;
    v13 = "NVG_OFF_BloomBlendInDurationMS";
  }
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", v13) )
    __debugbreak();
LABEL_28:
  Dvar_CheckFrontendServerThread(v12);
  *outBlendInDuration = v12->current.integer;
  if ( isOn )
  {
    v14 = DCONST_DVARMPINT_NVG_ON_BloomEndOffsetMS;
    if ( DCONST_DVARMPINT_NVG_ON_BloomEndOffsetMS )
      goto LABEL_35;
    v15 = "NVG_ON_BloomEndOffsetMS";
  }
  else
  {
    v14 = DCONST_DVARMPINT_NVG_OFF_BloomEndOffsetMS;
    if ( DCONST_DVARMPINT_NVG_OFF_BloomEndOffsetMS )
      goto LABEL_35;
    v15 = "NVG_OFF_BloomEndOffsetMS";
  }
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", v15) )
    __debugbreak();
LABEL_35:
  Dvar_CheckFrontendServerThread(v14);
  integer = v14->current.integer;
  if ( isOn )
  {
    v17 = DCONST_DVARMPINT_NVG_ON_BloomBlendOutDurationMS;
    if ( DCONST_DVARMPINT_NVG_ON_BloomBlendOutDurationMS )
      goto LABEL_61;
    v18 = "NVG_ON_BloomBlendOutDurationMS";
  }
  else
  {
    v17 = DCONST_DVARMPINT_NVG_OFF_BloomBlendOutDurationMS;
    if ( DCONST_DVARMPINT_NVG_OFF_BloomBlendOutDurationMS )
      goto LABEL_61;
    v18 = "NVG_OFF_BloomBlendOutDurationMS";
  }
LABEL_59:
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", v18) )
    __debugbreak();
LABEL_61:
  Dvar_CheckFrontendServerThread(v17);
  *outBlendOutDuration = v17->current.integer;
  *outBloomStartBlendInTime = NVGToggleTime - v11;
  *outBloomStartBlendOutTime = integer + NVGToggleTime;
}

/*
==============
CG_NightVisionGetExposureAdjustTimings
==============
*/
void CG_NightVisionGetExposureAdjustTimings(const int NVGToggleTime, int *outExposureStartBlendInTime, int *outExposureStartBlendOutTime, int *outExposureInDuration, int *outExposureOutDuration)
{
  const dvar_t *v9; 
  int integer; 
  const dvar_t *v11; 
  const dvar_t *v12; 
  int v13; 
  const dvar_t *v14; 

  if ( !outExposureStartBlendInTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12783, ASSERT_TYPE_ASSERT, "(outExposureStartBlendInTime)", (const char *)&queryFormat, "outExposureStartBlendInTime") )
    __debugbreak();
  if ( !outExposureStartBlendOutTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12784, ASSERT_TYPE_ASSERT, "(outExposureStartBlendOutTime)", (const char *)&queryFormat, "outExposureStartBlendOutTime") )
    __debugbreak();
  if ( !outExposureInDuration && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12785, ASSERT_TYPE_ASSERT, "(outExposureInDuration)", (const char *)&queryFormat, "outExposureInDuration") )
    __debugbreak();
  if ( !outExposureOutDuration && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12786, ASSERT_TYPE_ASSERT, "(outExposureOutDuration)", (const char *)&queryFormat, "outExposureOutDuration") )
    __debugbreak();
  v9 = DCONST_DVARMPINT_NVG_OFF_ExposureStartOffsetMS;
  if ( !DCONST_DVARMPINT_NVG_OFF_ExposureStartOffsetMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_OFF_ExposureStartOffsetMS") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v9);
  integer = v9->current.integer;
  v11 = DCONST_DVARMPINT_NVG_OFF_ExposureBlendInDurationMS;
  if ( !DCONST_DVARMPINT_NVG_OFF_ExposureBlendInDurationMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_OFF_ExposureBlendInDurationMS") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v11);
  *outExposureInDuration = v11->current.integer;
  v12 = DCONST_DVARMPINT_NVG_OFF_ExposureEndOffsetMS;
  if ( !DCONST_DVARMPINT_NVG_OFF_ExposureEndOffsetMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_OFF_ExposureEndOffsetMS") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v12);
  v13 = v12->current.integer;
  v14 = DCONST_DVARMPINT_NVG_OFF_ExposureBlendOutDurationMS;
  if ( !DCONST_DVARMPINT_NVG_OFF_ExposureBlendOutDurationMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_OFF_ExposureBlendOutDurationMS") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v14);
  *outExposureOutDuration = v14->current.integer;
  *outExposureStartBlendInTime = NVGToggleTime - integer;
  *outExposureStartBlendOutTime = v13 + NVGToggleTime;
}

/*
==============
CG_NightVisionIsAvailable
==============
*/
char CG_NightVisionIsAvailable(LocalClientNum_t localClientNum)
{
  __int64 v1; 
  cg_t *LocalClientGlobals; 
  __int64 v3; 
  cg_t *v4; 
  bool v5; 
  unsigned int v6; 
  int v9; 

  v1 = localClientNum;
  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT )
  {
    v9 = 2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_ui_active_client.h", 158, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, v9) )
      __debugbreak();
  }
  if ( (clientUIActives[v1].frontEndSceneState[0] || !clientUIActives[v1].cgameInitialized) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18384, ASSERT_TYPE_ASSERT, "(CL_IsGameClientActive( localClientNum ))", (const char *)&queryFormat, "CL_IsGameClientActive( localClientNum )") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v1);
  v3 = 0i64;
  v4 = LocalClientGlobals;
  while ( 1 )
  {
    v5 = Com_GameMode_SupportsFeature(WEAPON_DROPPING_QUICK);
    v6 = 4;
    if ( v5 )
      v6 = 7;
    if ( (unsigned int)v3 >= v6 )
      break;
    if ( v4->predictedPlayerState.actionSlotType[v3] == ACTIONSLOTTYPE_NIGHTVISION )
      return 1;
    v3 = (unsigned int)(v3 + 1);
  }
  return 0;
}

/*
==============
CG_NightVisionProcessLightFX
==============
*/
void CG_NightVisionProcessLightFX(LocalClientNum_t localClientNum, const playerState_s *ps, DObj *dObj, const PlayerHandIndex hand)
{
  __int64 v7; 
  int *LocalClientGlobals; 
  const dvar_t *v10; 
  CgWeaponMap *Instance; 
  FXRegisteredDef *p_fxNightVisionAreaLightAlt; 
  unsigned __int8 v14; 
  cg_t *v15; 
  ParticleManager *ParticleManager; 
  ParticleSystemHandle killcamThirdpersonAreaLightFx; 
  cg_t *v19; 
  unsigned int v20; 
  __int64 v21; 
  const float4 *v40; 
  vector3 *v41; 
  ParticleManager *v56; 
  unsigned __int16 boneIndex; 
  vec3_t outOrg; 
  float4 normal[2]; 
  float4 v61[2]; 
  __int64 v62; 
  vec4_t out; 
  tmat33_t<vec3_t> axis; 

  v62 = -2i64;
  __asm { vmovaps [rsp+148h+var_48], xmm6 }
  v7 = localClientNum;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12898, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( Com_GameMode_SupportsFeature(WEAPON_SPRINT_COMBAT_IDLE_COOLDOWN) && hand == WEAPON_HAND_DEFAULT )
  {
    _RDI = CG_GetLocalClientGlobals((const LocalClientNum_t)v7);
    if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12912, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
      __debugbreak();
    _RDI->nvgInfo.nvgAreaLightFXProcessedThisFrame = 1;
    CG_NightVisionValidateFXHandles(_RDI);
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12812, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    LocalClientGlobals = (int *)CG_GetLocalClientGlobals((const LocalClientNum_t)v7);
    v10 = DCONST_DVARMPBOOL_NVG_DisableAreaLight;
    if ( !DCONST_DVARMPBOOL_NVG_DisableAreaLight && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_DisableAreaLight") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v10);
    _RSI = NULL;
    if ( v10->current.enabled || LocalClientGlobals[185398] && LocalClientGlobals[185399] || LocalClientGlobals[5] >= 7 )
      goto LABEL_53;
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2245, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    if ( !GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&ps->weapCommon.weapFlags, ACTIVE, 7u) || GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&ps->weapCommon.weapFlags, ACTIVE, 9u) || LocalClientGlobals[128194] || (Instance = CgWeaponMap::GetInstance((const LocalClientNum_t)v7), BG_IsThirdPersonMode(Instance, ps)) )
    {
LABEL_53:
      if ( _RDI->nvgInfo.nightVisionAreaLightFx )
      {
        ParticleManager = ParticleManager::GetParticleManager((LocalClientNum_t)v7);
        ParticleManager::KillSystem(ParticleManager, _RDI->nvgInfo.nightVisionAreaLightFx);
        _RDI->nvgInfo.nightVisionAreaLightFx = PARTICLE_SYSTEM_INVALID_HANDLE;
      }
    }
    else
    {
      p_fxNightVisionAreaLightAlt = &cgMedia.fxNightVisionAreaLightAlt;
      if ( GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&ps->weapCommon.weapFlags, ACTIVE, 8u) )
        p_fxNightVisionAreaLightAlt = &cgMedia.fxNightVisionAreaLight;
      if ( _RDI->nvgInfo.nightVisionAreaLightFx == PARTICLE_SYSTEM_INVALID_HANDLE && p_fxNightVisionAreaLightAlt->m_particleSystemDef )
      {
        boneIndex = 254;
        CG_GetBoneIndex((LocalClientNum_t)v7, 2048, scr_const.tag_view, &boneIndex);
        v14 = boneIndex;
        if ( boneIndex > 0xFFu && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned char __cdecl truncate_cast_impl<unsigned char,unsigned short>(unsigned short)", "unsigned", (unsigned __int8)boneIndex, "unsigned", boneIndex) )
          __debugbreak();
        if ( v14 != 0xFE )
        {
          v15 = CG_GetLocalClientGlobals((const LocalClientNum_t)v7);
          _RDI->nvgInfo.nightVisionAreaLightFx = FX_PlayBoltedEffect((LocalClientNum_t)v7, p_fxNightVisionAreaLightAlt, v15->time, 2048, v14, 0);
        }
      }
    }
    if ( CG_NightVisionShouldDrawKillcamLightFX((LocalClientNum_t)v7) )
    {
      RefdefView_GetOrg(&_RDI->refdef.view, &outOrg);
      __asm
      {
        vmovups ymm0, ymmword ptr [rdi+6944h]
        vmovups ymmword ptr [rsp+148h+axis], ymm0
      }
      axis.m[2].v[2] = _RDI->refdef.view.axis.m[2].v[2];
      killcamThirdpersonAreaLightFx = _RDI->nvgInfo.killcamThirdpersonAreaLightFx;
      if ( killcamThirdpersonAreaLightFx )
      {
        v20 = 0;
        if ( g_particleSystemsGeneration[4096 * v7 + (killcamThirdpersonAreaLightFx & 0xFFF)].__all32 == killcamThirdpersonAreaLightFx )
          v20 = _RDI->nvgInfo.killcamThirdpersonAreaLightFx & 0xFFF;
        v21 = (v7 << 12) + v20;
        if ( g_particleSystems[0][v21] >= (ParticleSystem *)0x1000 )
          _RSI = g_particleSystems[0][v21];
        if ( _RSI )
        {
          __asm { vmovss  xmm0, dword ptr [rsp+148h+outOrg] }
          out.v[3] = 0.0;
          __asm
          {
            vmovups xmm3, xmmword ptr [rsp+0C0h]
            vmovss  xmm3, xmm3, xmm0
            vinsertps xmm3, xmm3, dword ptr [rsp+148h+outOrg+4], 10h
            vinsertps xmm3, xmm3, dword ptr [rsp+148h+outOrg+8], 20h
            vmovups xmmword ptr [rsp+0C0h], xmm3
            vmovups xmmword ptr [rsi+30h], xmm3
            vmovups xmm2, xmmword ptr [rsi]
            vshufps xmm6, xmm2, xmmword ptr [rsi+10h], 44h ; 'D'
            vmovups xmm0, xmmword ptr [rsi+20h]
            vshufps xmm4, xmm0, xmm3, 44h ; 'D'
            vshufps xmm2, xmm2, xmmword ptr [rsi+10h], 0EEh ; ''
            vshufps xmm5, xmm0, xmm3, 0EEh ; ''
            vshufps xmm0, xmm6, xmm4, 88h ; ''
            vmovups xmmword ptr [rsp+148h+normal.v], xmm0
            vshufps xmm1, xmm6, xmm4, 0DDh ; ''
            vmovups xmmword ptr [rsp+148h+normal.v+10h], xmm1
            vshufps xmm0, xmm2, xmm5, 88h ; ''
            vmovups xmmword ptr [rsp+148h+var_B8.v], xmm0
            vshufps xmm1, xmm2, xmm5, 0DDh ; ''
            vmovups xmmword ptr [rsp+148h+var_B8.v+10h], xmm1
            vmovups ymm0, ymmword ptr [rsp+148h+normal.v]
            vmovups ymmword ptr [rsi+40h], ymm0
            vmovups ymm1, ymmword ptr [rsp+148h+var_B8.v]
            vmovups ymmword ptr [rsi+60h], ymm1
          }
          AxisToQuat(&axis, &out);
          __asm { vmovups xmm0, xmmword ptr [rsp+148h+out] }
          Float4UnitQuatToAxis(v41, v40);
          __asm
          {
            vmovups xmmword ptr [rsp+148h+normal.v+10h], xmm1
            vmovups xmmword ptr [rsp+148h+normal.v], xmm0
            vmovups ymm3, ymmword ptr [rsp+148h+normal.v]
            vmovups ymmword ptr [rsp+148h+normal.v], ymm3
            vmovups xmmword ptr [rsp+148h+var_B8.v], xmm2
          }
          Particle_AssertFloat4IsNormalized(normal);
          Particle_AssertFloat4IsNormalized(&normal[1]);
          Particle_AssertFloat4IsNormalized(v61);
          __asm
          {
            vmovups xmm4, xmmword ptr [rsp+148h+normal.v]
            vmovups xmm3, xmmword ptr [rsp+148h+normal.v+10h]
            vmovups xmm0, xmmword ptr [rsp+148h+var_B8.v]
            vmovups xmmword ptr [rsi+20h], xmm0
            vmovups xmmword ptr [rsi+10h], xmm3
            vmovups xmmword ptr [rsi], xmm4
            vshufps xmm5, xmm4, xmm3, 44h ; 'D'
            vshufps xmm2, xmm0, xmmword ptr [rsi+30h], 44h ; 'D'
            vshufps xmm4, xmm4, xmm3, 0EEh ; ''
            vshufps xmm3, xmm0, xmmword ptr [rsi+30h], 0EEh ; ''
            vshufps xmm0, xmm5, xmm2, 88h ; ''
            vmovups xmmword ptr [rsp+148h+normal.v], xmm0
            vshufps xmm1, xmm5, xmm2, 0DDh ; ''
            vmovups xmmword ptr [rsp+148h+normal.v+10h], xmm1
            vshufps xmm0, xmm4, xmm3, 88h ; ''
            vmovups xmmword ptr [rsp+148h+var_B8.v], xmm0
            vshufps xmm1, xmm4, xmm3, 0DDh ; ''
            vmovups xmmword ptr [rsp+148h+var_B8.v+10h], xmm1
            vmovups ymm0, ymmword ptr [rsp+148h+normal.v]
            vmovups ymmword ptr [rsi+40h], ymm0
            vmovups ymm1, ymmword ptr [rsp+148h+var_B8.v]
            vmovups ymmword ptr [rsi+60h], ymm1
          }
        }
      }
      else if ( cgMedia.fxKillcamAreaLight.m_particleSystemDef )
      {
        v19 = CG_GetLocalClientGlobals((const LocalClientNum_t)v7);
        _RDI->nvgInfo.killcamThirdpersonAreaLightFx = FX_PlayOrientedEffect((LocalClientNum_t)v7, &cgMedia.fxKillcamAreaLight, v19->time, &outOrg, &axis);
      }
      memset(&outOrg, 0, sizeof(outOrg));
    }
    else if ( _RDI->nvgInfo.killcamThirdpersonAreaLightFx )
    {
      v56 = ParticleManager::GetParticleManager((LocalClientNum_t)v7);
      ParticleManager::KillSystem(v56, _RDI->nvgInfo.killcamThirdpersonAreaLightFx);
      _RDI->nvgInfo.killcamThirdpersonAreaLightFx = PARTICLE_SYSTEM_INVALID_HANDLE;
    }
  }
  __asm { vmovaps xmm6, [rsp+148h+var_48] }
}

/*
==============
CG_NightVisionProcessNoteTracks
==============
*/
void CG_NightVisionProcessNoteTracks(LocalClientNum_t localClientNum, const playerState_s *predictedPlayerState, DObj *dObj, const PlayerHandIndex hand)
{
  __int64 v7; 
  bool v10; 
  bool v11; 
  Gesture *v16; 
  bool IsUsingNightVision; 
  unsigned __int8 v18; 
  bool v19; 
  const char *v22; 
  ClientVisionSetData *p_cvsData; 
  char v34; 
  char v35; 
  const dvar_t *v36; 
  const XAnimParts *v39; 
  int v43; 
  const dvar_t *v44; 
  int integer; 
  const dvar_t *v46; 
  int v47; 
  const dvar_t *v48; 
  const dvar_t *v49; 
  NVGAnimBloomState nvgAnimBloomState; 
  const dvar_t *v51; 
  int NVGVisionStartTime; 
  int v53; 
  const dvar_t *v54; 
  int v55; 
  const dvar_t *v56; 
  int v57; 
  const dvar_t *v58; 
  int v59; 
  Gesture *v60; 
  const XAnimParts *v61; 
  int v66; 
  const dvar_t *v67; 
  int v68; 
  const dvar_t *v69; 
  int v70; 
  const dvar_t *v71; 
  const dvar_t *v72; 
  const dvar_t *v73; 
  int v74; 
  const dvar_t *v75; 
  int v76; 
  const dvar_t *v77; 
  const dvar_t *v78; 
  const dvar_t *v81; 
  int v82; 
  int v83; 
  const dvar_t *v84; 
  int v85; 
  const dvar_t *v86; 
  int v87; 
  const dvar_t *v88; 
  int v89; 
  const dvar_t *v90; 
  int v91; 
  int v92; 
  const dvar_t *v93; 
  int v94; 
  const dvar_t *v95; 
  int v96; 
  const dvar_t *v97; 
  int v98; 
  bool v100; 
  bool IsPlaying; 
  int v102; 
  unsigned int outSlot; 
  unsigned int v104; 
  Gesture *gesture; 
  Weapon r_weapon; 

  v7 = localClientNum;
  _RDI = CG_GetLocalClientGlobals(localClientNum);
  v10 = BG_UsingAlternate(&_RDI->predictedPlayerState);
  v11 = BG_PlayerDualWielding(&_RDI->predictedPlayerState) == 1;
  if ( !CgWeaponMap::ms_instance[v7] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  _RAX = BG_GetViewmodelWeapon(CgWeaponMap::ms_instance[v7], &_RDI->predictedPlayerState);
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovups ymmword ptr [rsp+108h+r_weapon.weaponIdx], ymm0
    vmovups xmm1, xmmword ptr [rax+20h]
    vmovups xmmword ptr [rsp+108h+r_weapon.attachmentVariationIndices+5], xmm1
    vmovsd  xmm0, qword ptr [rax+30h]
    vmovsd  qword ptr [rsp+108h+r_weapon.attachmentVariationIndices+15h], xmm0
  }
  *(_DWORD *)&r_weapon.weaponCamo = *(_DWORD *)&_RAX->weaponCamo;
  CG_GetLocalClientGlobals((const LocalClientNum_t)v7);
  if ( hand )
  {
    if ( hand == WEAPON_HAND_LEFT && !v11 )
      return;
  }
  else if ( v11 )
  {
    return;
  }
  __asm { vmovaps [rsp+108h+var_38], xmm6 }
  outSlot = 2;
  v16 = BG_Suit_GetGesture(&_RDI->predictedPlayerState, WEAPON_HAND_DEFAULT, &r_weapon, v10, v11, GESTUREANIMTYPE_NVG_ON);
  IsPlaying = BG_NightVisionGestureIsPlaying(&_RDI->predictedPlayerState, v16, &outSlot, NULL);
  v104 = 2;
  gesture = BG_Suit_GetGesture(&_RDI->predictedPlayerState, WEAPON_HAND_DEFAULT, &r_weapon, v10, v11, GESTUREANIMTYPE_NVG_OFF);
  v100 = BG_NightVisionGestureIsPlaying(&_RDI->predictedPlayerState, gesture, &v104, NULL);
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13209, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  IsUsingNightVision = BG_IsUsingNightVision(&_RDI->predictedPlayerState);
  v18 = IsPlaying || IsUsingNightVision && !v100;
  v19 = v18 <= (unsigned int)_RDI->nvgInfo.weightedBlind.prevNVGOn;
  if ( v18 != _RDI->nvgInfo.weightedBlind.prevNVGOn )
  {
    _RDI->nvgInfo.weightedBlind.blendStartTime = _RDI->time;
    _RDI->nvgInfo.weightedBlind.blendingIn = v18;
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+77DFCh]
    vcomiss xmm0, dword ptr [rdi+77E00h]
  }
  if ( v19 )
  {
    _R15 = DCONST_DVARMPFLT_NVG_ScriptBlindWeighted_ScriptValueBlendOutSpeed;
    if ( !DCONST_DVARMPFLT_NVG_ScriptBlindWeighted_ScriptValueBlendOutSpeed )
    {
      v22 = "NVG_ScriptBlindWeighted_ScriptValueBlendOutSpeed";
LABEL_24:
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", v22) )
        __debugbreak();
    }
  }
  else
  {
    _R15 = DCONST_DVARMPFLT_NVG_ScriptBlindWeighted_ScriptValueBlendInSpeed;
    if ( !DCONST_DVARMPFLT_NVG_ScriptBlindWeighted_ScriptValueBlendInSpeed )
    {
      v22 = "NVG_ScriptBlindWeighted_ScriptValueBlendInSpeed";
      goto LABEL_24;
    }
  }
  Dvar_CheckFrontendServerThread(_R15);
  __asm
  {
    vmovss  xmm2, dword ptr [r15+28h]; rate
    vmovss  xmm1, dword ptr [rdi+77E00h]; cur
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, dword ptr [rdi+65E4h]
    vmulss  xmm3, xmm0, cs:__real@3a83126f; deltaTime
    vmovss  xmm0, dword ptr [rdi+77DFCh]; tgt
  }
  *(double *)&_XMM0 = DiffTrack(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3);
  __asm
  {
    vmovss  xmm2, cs:__real@3f800000; max
    vxorps  xmm1, xmm1, xmm1; min
    vxorps  xmm6, xmm6, xmm6
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm { vmovss  dword ptr [rdi+77E00h], xmm0 }
  *(float *)&_XMM0 = CG_GetBlendedNVGFraction(_RDI, &_RDI->nvgInfo.weightedBlind);
  __asm
  {
    vmulss  xmm2, xmm0, dword ptr [rdi+77E00h]; lerp
    vcomiss xmm2, xmm6
  }
  p_cvsData = &_RDI->cvsData;
  if ( v34 | v35 )
    CG_VisionSetSetBlendOff(p_cvsData, VISIONSET_BLENDTYPE_NVG_BLIND_WEIGHTED);
  else
    CG_VisionSetSetBlendPush(p_cvsData, VISIONSET_BLENDTYPE_NVG_BLIND_WEIGHTED, *(const float *)&_XMM2);
  _RDI->nvgInfo.weightedBlind.prevNVGOn = v18;
  v36 = DCONST_DVARMPBOOL_NVG_DisableBloom;
  if ( !DCONST_DVARMPBOOL_NVG_DisableBloom && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_DisableBloom") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v36);
  if ( v36->current.enabled )
  {
    CG_VisionSetSetBlendOff(&_RDI->cvsData, VISIONSET_BLENDTYPE_NVG_FADE);
  }
  else
  {
    __asm
    {
      vmovaps [rsp+108h+var_48], xmm7
      vmovss  xmm7, cs:__real@bf800000
      vmovaps [rsp+108h+var_58], xmm8
      vmovss  xmm8, cs:__real@c47a0000
    }
    if ( IsPlaying && _RDI->nvgInfo.nvgAnimBloomState == INACTIVE )
    {
      if ( !*v16->anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13301, ASSERT_TYPE_ASSERT, "(nvgOnGesture->anims[GESTURE_ASSET_LEFT_CENTER])", (const char *)&queryFormat, "nvgOnGesture->anims[GESTURE_CENTER_ANIM_INDEX]") )
        __debugbreak();
      v39 = *v16->anims;
      if ( v39 )
      {
        *(double *)&_XMM0 = XAnimGetNotetrackTimeFromParts(v39, scr_const.night_vision_on);
        __asm
        {
          vucomiss xmm0, xmm7
          vmovaps xmm6, xmm0
        }
        if ( !v35 )
        {
          *(double *)&_XMM0 = BG_Gesture_GetAnimLengthInSeconds(v16);
          __asm
          {
            vmulss  xmm1, xmm0, xmm8
            vmulss  xmm0, xmm1, xmm6
            vcvttss2si eax, xmm0
          }
          v43 = _RDI->predictedPlayerState.gestureState.gestures[outSlot].startTime - _EAX;
          _RDI->NVGVisionStartTime = v43;
          _RDI->nvgInfo.nvgAnimBloomState = ACTIVE;
          v44 = DCONST_DVARMPINT_NVG_ON_BloomStartOffsetMS;
          if ( !DCONST_DVARMPINT_NVG_ON_BloomStartOffsetMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_ON_BloomStartOffsetMS") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v44);
          integer = v44->current.integer;
          v46 = DCONST_DVARMPINT_NVG_ON_BloomBlendInDurationMS;
          v102 = integer;
          if ( !DCONST_DVARMPINT_NVG_ON_BloomBlendInDurationMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_ON_BloomBlendInDurationMS") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v46);
          v47 = v46->current.integer;
          v48 = DCONST_DVARMPINT_NVG_ON_BloomEndOffsetMS;
          if ( !DCONST_DVARMPINT_NVG_ON_BloomEndOffsetMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_ON_BloomEndOffsetMS") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v48);
          v49 = DCONST_DVARMPINT_NVG_ON_BloomBlendOutDurationMS;
          if ( !DCONST_DVARMPINT_NVG_ON_BloomBlendOutDurationMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_ON_BloomBlendOutDurationMS") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v49);
          CG_VisionSetRegisterBlendStart(&_RDI->cvsData, VISIONSET_BLENDTYPE_NVG_FADE, v43 - v102, v47, 1, VISIONSETLERP_SMOOTH);
        }
      }
    }
    nvgAnimBloomState = _RDI->nvgInfo.nvgAnimBloomState;
    if ( nvgAnimBloomState == ACTIVE )
    {
      v51 = DCONST_DVARMPINT_NVG_ON_BloomStartOffsetMS;
      NVGVisionStartTime = _RDI->NVGVisionStartTime;
      if ( !DCONST_DVARMPINT_NVG_ON_BloomStartOffsetMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_ON_BloomStartOffsetMS") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v51);
      v53 = v51->current.integer;
      v54 = DCONST_DVARMPINT_NVG_ON_BloomBlendInDurationMS;
      if ( !DCONST_DVARMPINT_NVG_ON_BloomBlendInDurationMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_ON_BloomBlendInDurationMS") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v54);
      v55 = v54->current.integer;
      v56 = DCONST_DVARMPINT_NVG_ON_BloomEndOffsetMS;
      if ( !DCONST_DVARMPINT_NVG_ON_BloomEndOffsetMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_ON_BloomEndOffsetMS") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v56);
      v57 = v56->current.integer;
      v58 = DCONST_DVARMPINT_NVG_ON_BloomBlendOutDurationMS;
      if ( !DCONST_DVARMPINT_NVG_ON_BloomBlendOutDurationMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_ON_BloomBlendOutDurationMS") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v58);
      v59 = v58->current.integer;
      if ( _RDI->time >= v55 + NVGVisionStartTime - v53 )
      {
        _RDI->nvgInfo.nvgAnimBloomState = INACTIVE;
        CG_VisionSetRegisterBlendStart(&_RDI->cvsData, VISIONSET_BLENDTYPE_NVG_FADE, v57 + NVGVisionStartTime, v59, 0, VISIONSETLERP_SMOOTH);
      }
    }
    else if ( v100 && nvgAnimBloomState == INACTIVE )
    {
      v60 = gesture;
      if ( !*gesture->anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13337, ASSERT_TYPE_ASSERT, "(nvgOffGesture->anims[GESTURE_ASSET_LEFT_CENTER])", (const char *)&queryFormat, "nvgOffGesture->anims[GESTURE_CENTER_ANIM_INDEX]") )
        __debugbreak();
      v61 = *v60->anims;
      if ( v61 )
      {
        *(double *)&_XMM0 = XAnimGetNotetrackTimeFromParts(v61, scr_const.night_vision_off);
        __asm
        {
          vucomiss xmm0, xmm7
          vmovaps xmm6, xmm0
        }
        if ( !v35 )
        {
          *(double *)&_XMM0 = BG_Gesture_GetAnimLengthInSeconds(v60);
          __asm
          {
            vmulss  xmm1, xmm0, xmm8
            vmulss  xmm0, xmm1, xmm6
            vcvttss2si eax, xmm0
          }
          v66 = _RDI->predictedPlayerState.gestureState.gestures[v104].startTime - _EAX;
          _RDI->NVGVisionStartTime = v66;
          _RDI->nvgInfo.nvgAnimBloomState = 2;
          _RDI->NVGExposureToggleState = 2;
          v67 = DCONST_DVARMPINT_NVG_OFF_BloomStartOffsetMS;
          if ( !DCONST_DVARMPINT_NVG_OFF_BloomStartOffsetMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_OFF_BloomStartOffsetMS") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v67);
          v68 = v67->current.integer;
          v69 = DCONST_DVARMPINT_NVG_OFF_BloomBlendInDurationMS;
          if ( !DCONST_DVARMPINT_NVG_OFF_BloomBlendInDurationMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_OFF_BloomBlendInDurationMS") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v69);
          v70 = v69->current.integer;
          v71 = DCONST_DVARMPINT_NVG_OFF_BloomEndOffsetMS;
          if ( !DCONST_DVARMPINT_NVG_OFF_BloomEndOffsetMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_OFF_BloomEndOffsetMS") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v71);
          v72 = DCONST_DVARMPINT_NVG_OFF_BloomBlendOutDurationMS;
          if ( !DCONST_DVARMPINT_NVG_OFF_BloomBlendOutDurationMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_OFF_BloomBlendOutDurationMS") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v72);
          CG_VisionSetRegisterBlendStart(&_RDI->cvsData, VISIONSET_BLENDTYPE_NVG_FADE, v66 - v68, v70, 1, VISIONSETLERP_SMOOTH);
          v73 = DCONST_DVARMPINT_NVG_OFF_ExposureStartOffsetMS;
          if ( !DCONST_DVARMPINT_NVG_OFF_ExposureStartOffsetMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_OFF_ExposureStartOffsetMS") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v73);
          v74 = v73->current.integer;
          v75 = DCONST_DVARMPINT_NVG_OFF_ExposureBlendInDurationMS;
          if ( !DCONST_DVARMPINT_NVG_OFF_ExposureBlendInDurationMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_OFF_ExposureBlendInDurationMS") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v75);
          v76 = v75->current.integer;
          v77 = DCONST_DVARMPINT_NVG_OFF_ExposureEndOffsetMS;
          if ( !DCONST_DVARMPINT_NVG_OFF_ExposureEndOffsetMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_OFF_ExposureEndOffsetMS") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v77);
          v78 = DCONST_DVARMPINT_NVG_OFF_ExposureBlendOutDurationMS;
          if ( !DCONST_DVARMPINT_NVG_OFF_ExposureBlendOutDurationMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_OFF_ExposureBlendOutDurationMS") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v78);
          CG_VisionSetRegisterBlendStart(&_RDI->cvsData, VISIONSET_BLENDTYPE_NVG_EXPOSURE, v66 - v74, v76, 1, VISIONSETLERP_SMOOTH);
        }
      }
    }
    __asm
    {
      vmovaps xmm8, [rsp+108h+var_58]
      vmovaps xmm7, [rsp+108h+var_48]
    }
    if ( _RDI->nvgInfo.nvgAnimBloomState == 2 )
    {
      v81 = DCONST_DVARMPINT_NVG_OFF_BloomStartOffsetMS;
      v82 = _RDI->NVGVisionStartTime;
      if ( !DCONST_DVARMPINT_NVG_OFF_BloomStartOffsetMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_OFF_BloomStartOffsetMS") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v81);
      v83 = v81->current.integer;
      v84 = DCONST_DVARMPINT_NVG_OFF_BloomBlendInDurationMS;
      if ( !DCONST_DVARMPINT_NVG_OFF_BloomBlendInDurationMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_OFF_BloomBlendInDurationMS") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v84);
      v85 = v84->current.integer;
      v86 = DCONST_DVARMPINT_NVG_OFF_BloomEndOffsetMS;
      if ( !DCONST_DVARMPINT_NVG_OFF_BloomEndOffsetMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_OFF_BloomEndOffsetMS") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v86);
      v87 = v86->current.integer;
      v88 = DCONST_DVARMPINT_NVG_OFF_BloomBlendOutDurationMS;
      if ( !DCONST_DVARMPINT_NVG_OFF_BloomBlendOutDurationMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_OFF_BloomBlendOutDurationMS") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v88);
      v89 = v88->current.integer;
      if ( _RDI->time >= v85 + v82 - v83 )
      {
        _RDI->nvgInfo.nvgAnimBloomState = INACTIVE;
        CG_VisionSetRegisterBlendStart(&_RDI->cvsData, VISIONSET_BLENDTYPE_NVG_FADE, v87 + v82, v89, 0, VISIONSETLERP_SMOOTH);
      }
    }
    if ( _RDI->NVGExposureToggleState == 2 )
    {
      v90 = DCONST_DVARMPINT_NVG_OFF_ExposureStartOffsetMS;
      v91 = _RDI->NVGVisionStartTime;
      if ( !DCONST_DVARMPINT_NVG_OFF_ExposureStartOffsetMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_OFF_ExposureStartOffsetMS") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v90);
      v92 = v90->current.integer;
      v93 = DCONST_DVARMPINT_NVG_OFF_ExposureBlendInDurationMS;
      if ( !DCONST_DVARMPINT_NVG_OFF_ExposureBlendInDurationMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_OFF_ExposureBlendInDurationMS") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v93);
      v94 = v93->current.integer;
      v95 = DCONST_DVARMPINT_NVG_OFF_ExposureEndOffsetMS;
      if ( !DCONST_DVARMPINT_NVG_OFF_ExposureEndOffsetMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_OFF_ExposureEndOffsetMS") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v95);
      v96 = v95->current.integer;
      v97 = DCONST_DVARMPINT_NVG_OFF_ExposureBlendOutDurationMS;
      if ( !DCONST_DVARMPINT_NVG_OFF_ExposureBlendOutDurationMS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_OFF_ExposureBlendOutDurationMS") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v97);
      v98 = v97->current.integer;
      if ( _RDI->time >= v94 + v91 - v92 )
      {
        _RDI->NVGExposureToggleState = 0;
        CG_VisionSetRegisterBlendStart(&_RDI->cvsData, VISIONSET_BLENDTYPE_NVG_EXPOSURE, v96 + v91, v98, 0, VISIONSETLERP_SMOOTH);
      }
    }
    CG_NightVision_UpdateScriptBlind(_RDI, IsPlaying, v100);
  }
  __asm { vmovaps xmm6, [rsp+108h+var_38] }
}

/*
==============
CG_NightVisionShouldDrawKillcamLightFX
==============
*/
bool CG_NightVisionShouldDrawKillcamLightFX(LocalClientNum_t localClientNum)
{
  cg_t *LocalClientGlobals; 
  cg_t *v2; 
  const dvar_t *v3; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v2 = LocalClientGlobals;
  if ( !LocalClientGlobals->inKillCam || LocalClientGlobals->killCamEntityType == KC_NO_ENTITY )
    return 0;
  v3 = DCONST_DVARMPBOOL_NVG_DisableAreaLight;
  if ( !DCONST_DVARMPBOOL_NVG_DisableAreaLight && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_DisableAreaLight") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v3);
  return !v3->current.enabled && v2->hasKillcamThirdpersonVisionSet;
}

/*
==============
CG_NightVisionShouldHideGoggles
==============
*/
__int64 CG_NightVisionShouldHideGoggles(LocalClientNum_t localClientNum, const PlayerHandIndex hand)
{
  __int64 v7; 
  cg_t *LocalClientGlobals; 
  unsigned __int8 v10; 
  const Weapon *CurrentWeaponForPlayer; 
  bool v12; 
  int v13; 
  bool v14; 
  Gesture *Gesture; 
  Gesture *v16; 
  const XAnimParts *v18; 
  char v21; 
  __int64 result; 
  unsigned int outSlot; 
  unsigned int slot; 

  v7 = localClientNum;
  __asm { vmovaps [rsp+0A8h+var_48], xmm6 }
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9617, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( LocalClientGlobals == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9620, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v10 = 1;
  if ( !CgWeaponMap::ms_instance[v7] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  __asm
  {
    vmovaps [rsp+0A8h+var_58], xmm7
    vmovaps [rsp+0A8h+var_68], xmm8
    vmovaps [rsp+0A8h+var_78], xmm9
  }
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(CgWeaponMap::ms_instance[v7], &LocalClientGlobals->predictedPlayerState);
  v12 = BG_UsingAlternate(&LocalClientGlobals->predictedPlayerState);
  v13 = BG_PlayerDualWielding(&LocalClientGlobals->predictedPlayerState);
  outSlot = 2;
  v14 = v13 != 0;
  slot = 2;
  Gesture = BG_Suit_GetGesture(&LocalClientGlobals->predictedPlayerState, hand, CurrentWeaponForPlayer, v12, v13 != 0, GESTUREANIMTYPE_NVG_ON);
  v16 = BG_Suit_GetGesture(&LocalClientGlobals->predictedPlayerState, hand, CurrentWeaponForPlayer, v12, v14, GESTUREANIMTYPE_NVG_OFF);
  __asm { vxorps  xmm6, xmm6, xmm6 }
  if ( BG_NightVisionGestureIsPlaying(&LocalClientGlobals->predictedPlayerState, Gesture, &outSlot, NULL) )
  {
    if ( !*Gesture->anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9636, ASSERT_TYPE_ASSERT, "(nvgOnGesture->anims[GESTURE_ASSET_LEFT_CENTER])", (const char *)&queryFormat, "nvgOnGesture->anims[GESTURE_CENTER_ANIM_INDEX]") )
      __debugbreak();
    v18 = *Gesture->anims;
    if ( v18 )
    {
      *(double *)&_XMM0 = XAnimGetNotetrackTimeFromParts(v18, scr_const.show_nvg_goggles);
      __asm { vmovaps xmm9, xmm0 }
      *(double *)&_XMM0 = XAnimGetNotetrackTimeFromParts(*(const XAnimParts **)Gesture->anims, scr_const.hide_nvg_goggles);
      __asm
      {
        vcomiss xmm9, xmm6
        vmovaps xmm7, xmm0
      }
      if ( !v21 )
      {
        __asm { vcomiss xmm0, xmm6 }
        *(double *)&_XMM0 = BG_Gesture_GetElapsedTime(&LocalClientGlobals->predictedPlayerState, outSlot, LocalClientGlobals->time);
        __asm { vmovaps xmm8, xmm0 }
        *(double *)&_XMM0 = BG_Gesture_GetAnimLengthInSeconds(Gesture);
        __asm
        {
          vmulss  xmm1, xmm0, xmm9
          vcomiss xmm8, xmm1
        }
        if ( !v21 )
        {
          __asm
          {
            vmulss  xmm1, xmm0, xmm7
            vcomiss xmm1, xmm8
          }
          v10 = 0;
        }
      }
    }
  }
  __asm { vmovaps xmm9, [rsp+0A8h+var_78] }
  if ( !BG_NightVisionGestureIsPlaying(&LocalClientGlobals->predictedPlayerState, v16, &slot, NULL) )
    goto LABEL_31;
  if ( !*Gesture->anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9659, ASSERT_TYPE_ASSERT, "(nvgOnGesture->anims[GESTURE_ASSET_LEFT_CENTER])", (const char *)&queryFormat, "nvgOnGesture->anims[GESTURE_CENTER_ANIM_INDEX]") )
    __debugbreak();
  if ( !*Gesture->anims )
    goto LABEL_31;
  *(double *)&_XMM0 = XAnimGetNotetrackTimeFromParts(*(const XAnimParts **)v16->anims, scr_const.show_nvg_goggles);
  __asm { vmovaps xmm8, xmm0 }
  *(double *)&_XMM0 = XAnimGetNotetrackTimeFromParts(*(const XAnimParts **)v16->anims, scr_const.hide_nvg_goggles);
  __asm
  {
    vcomiss xmm8, xmm6
    vmovaps xmm7, xmm0
  }
  if ( v21 )
    goto LABEL_31;
  __asm { vcomiss xmm0, xmm6 }
  *(double *)&_XMM0 = BG_Gesture_GetElapsedTime(&LocalClientGlobals->predictedPlayerState, slot, LocalClientGlobals->time);
  __asm { vmovaps xmm6, xmm0 }
  *(double *)&_XMM0 = BG_Gesture_GetAnimLengthInSeconds(v16);
  __asm
  {
    vmulss  xmm1, xmm0, xmm8
    vcomiss xmm6, xmm1
  }
  if ( v21 )
  {
LABEL_31:
    result = v10;
  }
  else
  {
    __asm
    {
      vmulss  xmm1, xmm0, xmm7
      vcomiss xmm1, xmm6
    }
    result = 0i64;
  }
  __asm
  {
    vmovaps xmm8, [rsp+0A8h+var_68]
    vmovaps xmm7, [rsp+0A8h+var_58]
    vmovaps xmm6, [rsp+0A8h+var_48]
  }
  return result;
}

/*
==============
CG_NightVisionValidateFXHandles
==============
*/
void CG_NightVisionValidateFXHandles(cg_t *cgameGlob)
{
  ParticleSystemHandle nightVisionAreaLightFx; 
  __int64 localClientNum; 
  __int64 v4; 
  ParticleSystemHandle killcamThirdpersonAreaLightFx; 
  __int64 v6; 

  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12876, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  nightVisionAreaLightFx = cgameGlob->nvgInfo.nightVisionAreaLightFx;
  localClientNum = cgameGlob->localClientNum;
  if ( nightVisionAreaLightFx )
  {
    v4 = (localClientNum << 12) + (nightVisionAreaLightFx & 0xFFF);
    if ( g_particleSystemsGeneration[v4].__all32 != nightVisionAreaLightFx || g_particleSystems[0][v4] < (ParticleSystem *)0x1000 )
      cgameGlob->nvgInfo.nightVisionAreaLightFx = PARTICLE_SYSTEM_INVALID_HANDLE;
  }
  killcamThirdpersonAreaLightFx = cgameGlob->nvgInfo.killcamThirdpersonAreaLightFx;
  if ( killcamThirdpersonAreaLightFx )
  {
    v6 = (localClientNum << 12) + (killcamThirdpersonAreaLightFx & 0xFFF);
    if ( g_particleSystemsGeneration[v6].__all32 != killcamThirdpersonAreaLightFx || g_particleSystems[0][v6] < (ParticleSystem *)0x1000 )
      cgameGlob->nvgInfo.killcamThirdpersonAreaLightFx = PARTICLE_SYSTEM_INVALID_HANDLE;
  }
}

/*
==============
CG_NightVisionViewModelGogglesShouldBeAttached
==============
*/

bool __fastcall CG_NightVisionViewModelGogglesShouldBeAttached(LocalClientNum_t localClientNum, __int64 a2, double _XMM2_8)
{
  __int64 v3; 
  playerState_s *p_predictedPlayerState; 
  bool v5; 
  bool v6; 
  Gesture *Gesture; 
  Gesture *v13; 
  bool result; 
  __int64 gestureAnimType; 
  Weapon r_weapon; 

  v3 = localClientNum;
  p_predictedPlayerState = &CG_GetLocalClientGlobals(localClientNum)->predictedPlayerState;
  v5 = BG_UsingAlternate(p_predictedPlayerState);
  v6 = BG_PlayerDualWielding(p_predictedPlayerState) == 1;
  if ( !CgWeaponMap::ms_instance[v3] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  _RAX = BG_GetViewmodelWeapon(CgWeaponMap::ms_instance[v3], p_predictedPlayerState);
  __asm
  {
    vmovups ymm2, ymmword ptr [rax]
    vmovups ymmword ptr [rsp+0A8h+r_weapon.weaponIdx], ymm2
    vmovups xmm0, xmmword ptr [rax+20h]
    vmovups xmmword ptr [rsp+0A8h+r_weapon.attachmentVariationIndices+5], xmm0
    vmovsd  xmm1, qword ptr [rax+30h]
    vmovsd  qword ptr [rsp+0A8h+r_weapon.attachmentVariationIndices+15h], xmm1
    vmovd   ebx, xmm2
  }
  *(_DWORD *)&r_weapon.weaponCamo = *(_DWORD *)&_RAX->weaponCamo;
  if ( (unsigned __int16)_EBX > bg_lastParsedWeaponIndex )
  {
    LODWORD(gestureAnimType) = (unsigned __int16)_EBX;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1203, ASSERT_TYPE_ASSERT, "( weaponIdx ) <= ( bg_lastParsedWeaponIndex )", "weaponIdx not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", gestureAnimType, bg_lastParsedWeaponIndex) )
      __debugbreak();
  }
  if ( !bg_weaponDefs[(unsigned __int16)_EBX] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1204, ASSERT_TYPE_ASSERT, "(bg_weaponDefs[weaponIdx])", (const char *)&queryFormat, "bg_weaponDefs[weaponIdx]") )
    __debugbreak();
  Gesture = BG_Suit_GetGesture(p_predictedPlayerState, WEAPON_HAND_DEFAULT, &r_weapon, v5, v6, GESTUREANIMTYPE_NVG_ON);
  v13 = BG_Suit_GetGesture(p_predictedPlayerState, WEAPON_HAND_DEFAULT, &r_weapon, v5, v6, GESTUREANIMTYPE_NVG_OFF);
  LOBYTE(Gesture) = BG_NightVisionGestureIsPlaying(p_predictedPlayerState, Gesture, NULL, NULL);
  result = BG_NightVisionGestureIsPlaying(p_predictedPlayerState, v13, NULL, NULL);
  if ( (_BYTE)Gesture || result )
    return 1;
  return result;
}

/*
==============
CG_NightVision_UpdateScriptBlind
==============
*/
void CG_NightVision_UpdateScriptBlind(cg_t *cgameGlob, const bool nvgAnimatingOn, const bool nvgAnimatingOff)
{
  int time; 
  const dvar_t *v7; 
  const SuitDef *SuitDef; 
  const char *name; 
  const SndAliasList *Alias; 
  CgSoundSystem *SoundSystem; 
  const dvar_t *v12; 
  int v13; 
  const dvar_t *v14; 
  const dvar_t *v15; 

  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13069, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  time = cgameGlob->time;
  if ( cgameGlob->nvgInfo.activateBlindNow )
  {
    if ( !BG_IsUsingNightVision(&cgameGlob->predictedPlayerState) && !nvgAnimatingOn || nvgAnimatingOff || cgameGlob->nvgInfo.nvgAnimBloomState == 2 )
    {
      cgameGlob->nvgInfo.scriptBlindState = INACTIVE;
      cgameGlob->nvgInfo.scriptBlindStateStartTime = time;
    }
    else
    {
      if ( cgameGlob->nvgInfo.scriptBlindState == 4 && CG_VisionSetIsBlending(&cgameGlob->cvsData, VISIONSET_BLENDTYPE_NVG_BLIND, time) )
        CG_VisionSetSetBlendStop(&cgameGlob->cvsData, VISIONSET_BLENDTYPE_NVG_BLIND, time);
      cgameGlob->nvgInfo.scriptBlindState = ACTIVE;
      cgameGlob->nvgInfo.scriptBlindStateStartTime = time;
      v7 = DCONST_DVARMPINT_NVG_ScriptBlind_BlendIn;
      if ( !DCONST_DVARMPINT_NVG_ScriptBlind_BlendIn && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_ScriptBlind_BlendIn") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v7);
      CG_VisionSetRegisterBlendStart(&cgameGlob->cvsData, VISIONSET_BLENDTYPE_NVG_BLIND, time, v7->current.integer, 1, VISIONSETLERP_SMOOTH);
      SuitDef = BG_GetSuitDef(cgameGlob->predictedPlayerState.suitIndex);
      if ( !SuitDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13041, ASSERT_TYPE_ASSERT, "(suit)", (const char *)&queryFormat, "suit") )
        __debugbreak();
      name = SuitDef->nvg_blindSound.name;
      if ( name )
      {
        Alias = SND_TryFindAlias(name);
        if ( Alias )
        {
          SoundSystem = CgSoundSystem::GetSoundSystem((const LocalClientNum_t)cgameGlob->localClientNum);
          CgSoundSystem::PlayClientSoundAlias(SoundSystem, Alias);
        }
      }
    }
    cgameGlob->nvgInfo.activateBlindNow = 0;
  }
  if ( cgameGlob->nvgInfo.scriptBlindState == ACTIVE )
  {
    if ( !CG_VisionSetIsComplete(&cgameGlob->cvsData, VISIONSET_BLENDTYPE_NVG_BLIND, time) )
      goto LABEL_42;
    cgameGlob->nvgInfo.scriptBlindState = 2;
    goto LABEL_41;
  }
  if ( cgameGlob->nvgInfo.scriptBlindState == 2 )
  {
    v12 = DCONST_DVARMPINT_NVG_ScriptBlind_Hold;
    v13 = time - cgameGlob->nvgInfo.scriptBlindStateStartTime;
    if ( v13 < 0 )
      v13 = 0;
    if ( !DCONST_DVARMPINT_NVG_ScriptBlind_Hold && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_ScriptBlind_Hold") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v12);
    if ( v13 >= v12->current.integer )
    {
      cgameGlob->nvgInfo.scriptBlindState = 3;
      cgameGlob->nvgInfo.scriptBlindStateStartTime = time;
      v14 = DCONST_DVARMPINT_NVG_ScriptBlind_BlendOut;
      if ( !DCONST_DVARMPINT_NVG_ScriptBlind_BlendOut && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_ScriptBlind_BlendOut") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v14);
      CG_VisionSetRegisterBlendStart(&cgameGlob->cvsData, VISIONSET_BLENDTYPE_NVG_BLIND, time, v14->current.integer, 0, VISIONSETLERP_SMOOTH);
    }
  }
  else if ( (cgameGlob->nvgInfo.scriptBlindState == 3 || cgameGlob->nvgInfo.scriptBlindState == 4) && CG_VisionSetIsComplete(&cgameGlob->cvsData, VISIONSET_BLENDTYPE_NVG_BLIND, time) )
  {
    cgameGlob->nvgInfo.scriptBlindState = INACTIVE;
LABEL_41:
    cgameGlob->nvgInfo.scriptBlindStateStartTime = time;
  }
LABEL_42:
  if ( nvgAnimatingOff )
  {
    if ( !cgameGlob->NVGVisionStartTime )
      goto LABEL_51;
    v15 = DCONST_DVARMPINT_NVG_ScriptBlind_InterruptOffset;
    if ( !DCONST_DVARMPINT_NVG_ScriptBlind_InterruptOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "NVG_ScriptBlind_InterruptOffset") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v15);
    if ( time >= cgameGlob->NVGVisionStartTime + v15->current.integer )
      goto LABEL_51;
  }
  else if ( !nvgAnimatingOn && !BG_IsUsingNightVision(&cgameGlob->predictedPlayerState) )
  {
LABEL_51:
    if ( cgameGlob->nvgInfo.scriptBlindState )
    {
      cgameGlob->nvgInfo.scriptBlindState = INACTIVE;
      cgameGlob->nvgInfo.scriptBlindStateStartTime = time;
      CG_VisionSetSetBlendOff(&cgameGlob->cvsData, VISIONSET_BLENDTYPE_NVG_BLIND);
    }
  }
}

/*
==============
CG_OffhandGestureWeaponHideParts
==============
*/
void CG_OffhandGestureWeaponHideParts(LocalClientNum_t localClientNum, const PlayerHandIndex hand)
{
  cg_t *LocalClientGlobals; 
  WeaponHand *ViewModelHand; 
  CgWeaponMap *Instance; 
  bool v7; 
  WeaponHand *v8; 
  DObj *viewModelDObj; 
  const XModel *gestureWeapModel; 
  int ModelIndex; 
  scr_string_t v12; 
  DObjPartBits *p_hidePartBits; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11197, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( LocalClientGlobals->gestureWeapInfo.offhandGestureWeapon.weaponIdx )
  {
    ViewModelHand = cg_t::GetViewModelHand(LocalClientGlobals, hand);
    if ( !ViewModelHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11205, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
      __debugbreak();
    if ( ViewModelHand->tree )
    {
      Instance = CgWeaponMap::GetInstance(localClientNum);
      v7 = BG_PlayerOrEntityDualWielding(Instance, &LocalClientGlobals->predictedPlayerState, NULL, NULL);
      if ( hand )
      {
        if ( hand == WEAPON_HAND_LEFT && !v7 )
          return;
      }
      else if ( v7 )
      {
        return;
      }
      CG_OffhandGestureWeapon_SetVisibilityState(localClientNum, hand);
      if ( LocalClientGlobals->gestureWeapInfo.shouldBeVisible != LocalClientGlobals->gestureWeapInfo.isGestureWeapVisible )
      {
        v8 = cg_t::GetViewModelHand(LocalClientGlobals, hand);
        viewModelDObj = v8->viewModelDObj;
        if ( v8->viewModelDObj )
        {
          gestureWeapModel = LocalClientGlobals->gestureWeapInfo.gestureWeapModel;
          if ( gestureWeapModel )
          {
            ModelIndex = DObjGetModelIndex(v8->viewModelDObj, gestureWeapModel);
            v12 = *LocalClientGlobals->gestureWeapInfo.gestureWeapModel->boneNames;
            if ( v12 )
            {
              p_hidePartBits = &viewModelDObj->hidePartBits;
              if ( LocalClientGlobals->gestureWeapInfo.shouldBeVisible )
              {
                BG_ShowBone(v12, viewModelDObj, p_hidePartBits, ModelIndex);
                LocalClientGlobals->gestureWeapInfo.isGestureWeapVisible = 1;
              }
              else
              {
                BG_HideBone(v12, viewModelDObj, p_hidePartBits, ModelIndex);
                LocalClientGlobals->gestureWeapInfo.isGestureWeapVisible = 0;
              }
            }
          }
        }
      }
    }
  }
}

/*
==============
CG_OffhandGestureWeapon_IsInvisible
==============
*/
bool CG_OffhandGestureWeapon_IsInvisible(const LocalClientNum_t localClientNum, const cg_t *cgameGlob, const playerState_s *ps, const PlayerHandIndex hand, const int offhandGesturesPlayingCount, const bool performingScriptedWeapon, const unsigned int scriptWeaponIdx, const unsigned int scriptWeaponSlot)
{
  unsigned int AvailableSlotCount; 
  bool v17; 
  const Gesture *AssetFromIndex; 
  unsigned int v19; 
  GestureAnimationState AnimationState; 
  int LastTreeRebuildTime; 
  GestureAnimationSettings *AnimationSettings; 
  CgWeaponMap *Instance; 
  bool v25; 
  unsigned int v26; 
  const WeaponHand *ViewModelHand; 
  const XAnimTree *tree; 
  char v30; 
  char v31; 
  const XAnimTree *v32; 
  weapAnimFiles_t outOutAnimation[4]; 
  weapAnimFiles_t outMainAnimation; 
  weapAnimFiles_t outInAnimation; 

  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10889, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10890, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  AvailableSlotCount = BG_Gesture_GetAvailableSlotCount(ps);
  v17 = GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&ps->weapCommon.weapFlags, ACTIVE, 0xFu) && !AvailableSlotCount && offhandGesturesPlayingCount != 2;
  if ( cgameGlob->time - ps->weapCommon.offhandUseTime <= 99 || v17 )
    return 1;
  if ( !GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&ps->otherFlags, GameModeFlagValues::ms_mpValue, 0x21u) && !cgameGlob->inKillCam || !performingScriptedWeapon )
    return 0;
  AssetFromIndex = BG_Gesture_GetAssetFromIndex(scriptWeaponIdx);
  if ( !AssetFromIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10914, ASSERT_TYPE_ASSERT, "(gesture)", (const char *)&queryFormat, "gesture") )
    __debugbreak();
  if ( AssetFromIndex->looping )
    return 0;
  v19 = scriptWeaponSlot;
  AnimationState = CG_Gesture_GetAnimationState(localClientNum, scriptWeaponSlot, hand);
  if ( AnimationState == GESTURE_ANIM_STATE_OFF )
    return 1;
  LastTreeRebuildTime = CG_Gesture_GetLastTreeRebuildTime(localClientNum, v19, hand);
  if ( LastTreeRebuildTime != BG_Gesture_GetStartTime(ps, v19) && AnimationState == GESTURE_ANIM_STATE_OUT )
    return 1;
  AnimationSettings = BG_Gesture_GetAnimationSettings(AssetFromIndex);
  if ( AnimationSettings->hasTransitions && AnimationState != GESTURE_ANIM_STATE_IN )
    return 0;
  Instance = CgWeaponMap::GetInstance(localClientNum);
  v25 = BG_PlayerOrEntityDualWielding(Instance, ps, NULL, NULL);
  outMainAnimation = WEAP_ANIM_ROOT;
  outInAnimation = WEAP_ANIM_ROOT;
  outOutAnimation[0] = WEAP_ANIM_ROOT;
  CG_Gesture_GetWeaponAnims(AssetFromIndex, v19, hand, v25, &outMainAnimation, &outInAnimation, outOutAnimation);
  v26 = outMainAnimation;
  if ( AnimationSettings->hasTransitions )
    v26 = outInAnimation;
  ViewModelHand = cg_t::GetViewModelHand((cg_t *)cgameGlob, hand);
  if ( !ViewModelHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10961, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
    __debugbreak();
  tree = ViewModelHand->tree;
  if ( !tree )
    return 1;
  *(double *)&_XMM0 = XAnimGetWeight(tree, 0, XANIM_SUBTREE_DEFAULT, v26);
  __asm
  {
    vxorps  xmm1, xmm1, xmm1
    vcomiss xmm0, xmm1
  }
  if ( v30 | v31 )
    return 0;
  v32 = ViewModelHand->tree;
  __asm
  {
    vmovaps [rsp+0A8h+var_48], xmm6
    vmovaps [rsp+0A8h+var_58], xmm7
  }
  *(double *)&_XMM0 = XAnimGetTime(v32, 0, XANIM_SUBTREE_DEFAULT, v26);
  __asm { vmovaps xmm7, xmm0 }
  *(double *)&_XMM0 = XAnimGetRate(ViewModelHand->tree, 0, XANIM_SUBTREE_DEFAULT, v26);
  __asm
  {
    vmovaps xmm6, xmm0
    vcvtss2sd xmm1, xmm6, xmm0
    vcomisd xmm1, cs:__real@3eb0c6f7a0b5ed8d
  }
  if ( v30 | v31 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10973, ASSERT_TYPE_ASSERT, "(animRate > 1.0E-6)", (const char *)&queryFormat, "animRate > ZERO_EPSILON") )
      __debugbreak();
  }
  *(double *)&_XMM0 = XAnimGetLength(ViewModelHand->tree->anims, v26);
  __asm
  {
    vmulss  xmm1, xmm0, xmm7
    vmovaps xmm7, [rsp+0A8h+var_58]
    vdivss  xmm2, xmm1, xmm6
    vmulss  xmm3, xmm2, cs:__real@447a0000
    vmovaps xmm6, [rsp+0A8h+var_48]
    vcvttss2si eax, xmm3
  }
  return _EAX <= 99;
}

/*
==============
CG_OffhandGestureWeapon_SetVisibilityState
==============
*/
void CG_OffhandGestureWeapon_SetVisibilityState(LocalClientNum_t localClientNum, const PlayerHandIndex hand)
{
  __int64 v6; 
  cg_t *LocalClientGlobals; 
  CgWeaponMap *v8; 
  unsigned int v9; 
  int v10; 
  unsigned int scriptWeaponIdx; 
  bool v12; 
  bool performingScriptedWeapon; 
  bool v14; 
  const Gesture *AssetFromIndex; 
  const Gesture *v16; 
  const XAnimParts *v17; 
  bool v20; 
  const Gesture *v23; 
  bool IsStoppingByIndex; 
  const Gesture *v29; 
  const Gesture *v47; 
  unsigned int v54; 
  unsigned int gestureIndex; 
  unsigned int GestureIdxForWeapon; 
  unsigned int outSlot; 
  unsigned int v58[4]; 
  bool IsPlayingByIndex; 
  bool v63; 
  unsigned int slot; 

  v6 = localClientNum;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10993, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( LocalClientGlobals == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10996, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !LocalClientGlobals->gestureWeapInfo.offhandGestureWeapon.weaponIdx && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10998, ASSERT_TYPE_ASSERT, "(cgameGlob->gestureWeapInfo.offhandGestureWeapon.weaponIdx != 0)", (const char *)&queryFormat, "cgameGlob->gestureWeapInfo.offhandGestureWeapon.weaponIdx != WP_NONE") )
    __debugbreak();
  if ( !CgWeaponMap::ms_instance[v6] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v8 = CgWeaponMap::ms_instance[v6];
  if ( !v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11006, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  GestureIdxForWeapon = BG_Offhand_GetGestureIdxForWeapon(&LocalClientGlobals->predictedPlayerState, v8, &LocalClientGlobals->gestureWeapInfo.offhandGestureWeapon, 0, OHGT_THROW);
  v9 = BG_Offhand_GetGestureIdxForWeapon(&LocalClientGlobals->predictedPlayerState, v8, &LocalClientGlobals->gestureWeapInfo.offhandGestureWeapon, 0, OHGT_PULLBACK);
  v10 = 0;
  gestureIndex = BG_Offhand_GetGestureIdxForWeapon(&LocalClientGlobals->predictedPlayerState, v8, &LocalClientGlobals->gestureWeapInfo.offhandGestureWeapon, 0, OHGT_DETONATE);
  scriptWeaponIdx = BG_Offhand_GetGestureIdxForWeapon(&LocalClientGlobals->predictedPlayerState, v8, &LocalClientGlobals->gestureWeapInfo.offhandGestureWeapon, 0, OHGT_WEAPON);
  IsPlayingByIndex = BG_Gesture_IsPlayingByIndex(&LocalClientGlobals->predictedPlayerState, GestureIdxForWeapon, &outSlot);
  v63 = BG_Gesture_IsPlayingByIndex(&LocalClientGlobals->predictedPlayerState, v9, &v54);
  v12 = BG_Gesture_IsPlayingByIndex(&LocalClientGlobals->predictedPlayerState, gestureIndex, v58);
  performingScriptedWeapon = BG_Gesture_IsPlayingByIndex(&LocalClientGlobals->predictedPlayerState, scriptWeaponIdx, &slot);
  if ( IsPlayingByIndex )
    v10 = 1;
  if ( v63 )
    ++v10;
  if ( v12 )
    ++v10;
  if ( !CG_OffhandGestureWeapon_IsInvisible((const LocalClientNum_t)v6, LocalClientGlobals, &LocalClientGlobals->predictedPlayerState, hand, v10, performingScriptedWeapon, scriptWeaponIdx, slot) )
  {
    __asm
    {
      vmovaps [rsp+0C8h+var_58], xmm6
      vmovaps [rsp+0C8h+var_68], xmm7
    }
    if ( performingScriptedWeapon )
    {
      AssetFromIndex = BG_Gesture_GetAssetFromIndex(scriptWeaponIdx);
      v16 = AssetFromIndex;
      if ( AssetFromIndex->looping )
        goto LABEL_45;
      v17 = *AssetFromIndex->anims;
      if ( v17 )
      {
        *(double *)&_XMM0 = XAnimGetNotetrackTimeFromParts(v17, scr_const.hide);
        __asm
        {
          vxorps  xmm1, xmm1, xmm1
          vcomiss xmm0, xmm1
          vmovaps xmm7, xmm0
        }
        if ( !v20 )
        {
          *(double *)&_XMM0 = BG_Gesture_GetElapsedTime(&LocalClientGlobals->predictedPlayerState, slot, LocalClientGlobals->time);
          __asm { vmovaps xmm6, xmm0 }
          *(double *)&_XMM0 = BG_Gesture_GetAnimLengthInSeconds(v16);
          __asm
          {
            vmulss  xmm1, xmm0, xmm7
            vcomiss xmm6, xmm1
          }
          v14 = v20;
LABEL_46:
          __asm
          {
            vmovaps xmm6, [rsp+0C8h+var_58]
            vmovaps xmm7, [rsp+0C8h+var_68]
          }
          goto LABEL_47;
        }
      }
    }
    else if ( IsPlayingByIndex )
    {
      v23 = BG_Gesture_GetAssetFromIndex(GestureIdxForWeapon);
      *(double *)&_XMM0 = XAnimGetNotetrackTimeFromParts(*(const XAnimParts **)v23->anims, scr_const.hide);
      __asm
      {
        vxorps  xmm1, xmm1, xmm1
        vcomiss xmm0, xmm1
        vmovaps xmm7, xmm0
      }
      if ( !v20 )
      {
        *(double *)&_XMM0 = BG_Gesture_GetElapsedTime(&LocalClientGlobals->predictedPlayerState, outSlot, LocalClientGlobals->time);
        __asm { vmovaps xmm6, xmm0 }
        *(double *)&_XMM0 = BG_Gesture_GetAnimLengthInSeconds(v23);
        __asm
        {
          vmulss  xmm1, xmm0, xmm7
          vcomiss xmm6, xmm1
        }
        v14 = v20;
        goto LABEL_46;
      }
    }
    else if ( v63 )
    {
      IsStoppingByIndex = BG_Gesture_IsStoppingByIndex(&LocalClientGlobals->predictedPlayerState, v9);
      v29 = BG_Gesture_GetAssetFromIndex(v9);
      BG_Gesture_GetAnimationSettings(v29);
      if ( IsStoppingByIndex && (LocalClientGlobals->predictedPlayerState.weapCommon.offhandGestureFlags & 0x10) != 0 )
      {
        *(double *)&_XMM0 = XAnimGetNotetrackTimeFromParts(*((const XAnimParts **)v29->anims + 11), scr_const.hide);
        __asm
        {
          vxorps  xmm1, xmm1, xmm1
          vcomiss xmm0, xmm1
          vmovaps xmm6, xmm0
        }
        if ( !v20 )
        {
          BG_Gesture_GetRemainingTime(&LocalClientGlobals->predictedPlayerState, v54, LocalClientGlobals->time);
          __asm
          {
            vmovss  xmm0, cs:__real@3f800000
            vxorps  xmm1, xmm1, xmm1
            vcvtsi2ss xmm1, xmm1, eax
            vmulss  xmm4, xmm1, cs:__real@3a83126f
            vxorps  xmm1, xmm1, xmm1
            vcvtsi2ss xmm1, xmm1, dword ptr [r14+8]
            vmulss  xmm3, xmm1, cs:__real@3a83126f
            vsubss  xmm2, xmm0, xmm6
            vmulss  xmm1, xmm3, xmm2
            vcomiss xmm1, xmm4
          }
          v14 = v20;
          goto LABEL_46;
        }
      }
      else
      {
        *(double *)&_XMM0 = XAnimGetNotetrackTimeFromParts(*((const XAnimParts **)v29->anims + 10), scr_const.show);
        __asm
        {
          vxorps  xmm1, xmm1, xmm1
          vcomiss xmm0, xmm1
          vmovaps xmm6, xmm0
        }
        if ( !v20 )
        {
          *(double *)&_XMM0 = BG_Gesture_GetElapsedTime(&LocalClientGlobals->predictedPlayerState, v54, LocalClientGlobals->time);
          __asm
          {
            vxorps  xmm1, xmm1, xmm1
            vcvtsi2ss xmm1, xmm1, dword ptr [r14+4]
            vmulss  xmm2, xmm1, cs:__real@3a83126f
            vmulss  xmm3, xmm2, xmm6
            vcomiss xmm0, xmm3
          }
          v14 = !v20;
          goto LABEL_46;
        }
      }
    }
    else if ( v12 )
    {
      v47 = BG_Gesture_GetAssetFromIndex(gestureIndex);
      *(double *)&_XMM0 = XAnimGetNotetrackTimeFromParts(*(const XAnimParts **)v47->anims, scr_const.hide);
      __asm
      {
        vxorps  xmm1, xmm1, xmm1
        vcomiss xmm0, xmm1
        vmovaps xmm7, xmm0
      }
      if ( !v20 )
      {
        *(double *)&_XMM0 = BG_Gesture_GetElapsedTime(&LocalClientGlobals->predictedPlayerState, v58[0], LocalClientGlobals->time);
        __asm { vmovaps xmm6, xmm0 }
        *(double *)&_XMM0 = BG_Gesture_GetAnimLengthInSeconds(v47);
        __asm
        {
          vmulss  xmm1, xmm0, xmm7
          vcomiss xmm6, xmm1
        }
        v14 = v20;
        goto LABEL_46;
      }
    }
    if ( (LocalClientGlobals->predictedPlayerState.weapCommon.offhandGestureFlags & 4) == 0 && !LocalClientGlobals->predictedPlayerState.weapCommon.offhandGestureFireTime )
    {
      v14 = 0;
      goto LABEL_46;
    }
LABEL_45:
    v14 = 1;
    goto LABEL_46;
  }
  v14 = 0;
LABEL_47:
  LocalClientGlobals->gestureWeapInfo.shouldBeVisible = v14;
}

/*
==============
CG_OffhandShield_CheckViewModelUpdate
==============
*/
bool CG_OffhandShield_CheckViewModelUpdate(const LocalClientNum_t localClientNum)
{
  return 0;
}

/*
==============
CG_OffhandShield_DamageFeedback
==============
*/
void CG_OffhandShield_DamageFeedback(LocalClientNum_t localClientNum, int sourceEntityNum, unsigned int eventParm, bool damaged)
{
  int v8; 
  unsigned int v9; 
  cg_t *LocalClientGlobals; 
  const dvar_t *v19; 
  cg_t *v23; 
  CgHandler *Handler; 
  int clientNum; 
  CgHandler *v26; 
  team_t team; 
  CgStatic *LocalClientStatics; 
  cg_t *v29; 
  const cg_t *v31; 
  const characterInfo_t *CharacterInfo; 
  int v36; 
  int v37; 
  vec3_t angles; 
  vec3_t forward; 

  v8 = BYTE2(eventParm);
  v9 = eventParm >> 8;
  if ( v8 || (_BYTE)v9 )
  {
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, ecx
      vmovaps [rsp+0B8h+var_48], xmm6
      vmulss  xmm6, xmm0, cs:__real@3fb4b4b5
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, eax
      vmulss  xmm1, xmm0, cs:__real@3fb4b4b5
      vxorps  xmm0, xmm0, xmm0
      vmovss  dword ptr [rsp+0B8h+angles+8], xmm0
      vmovss  dword ptr [rsp+0B8h+angles], xmm1
      vmovss  dword ptr [rsp+0B8h+angles+4], xmm6
    }
    AngleVectors(&angles, &forward, NULL, NULL);
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    _RDI = CG_PlayerState_FindLruDamageSlot(LocalClientGlobals);
    _RDI->time = LocalClientGlobals->snap->serverTime;
    v19 = DVARINT_cg_hudShieldDamageIconTime;
    if ( !DVARINT_cg_hudShieldDamageIconTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_hudShieldDamageIconTime") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v19);
    _RDI->duration = v19->current.integer;
    *(double *)&_XMM0 = I_random();
    __asm
    {
      vsubss  xmm1, xmm0, cs:__real@3f000000
      vmulss  xmm2, xmm1, cs:__real@41a00000
      vaddss  xmm0, xmm2, xmm6; angle
    }
    *(double *)&_XMM0 = AngleNormalize360(*(const float *)&_XMM0);
    _RDI->inVehicle = 0;
    __asm { vmovss  dword ptr [rdi+14h], xmm0 }
    _RDI->type = 4;
    v23 = CG_GetLocalClientGlobals(localClientNum);
    Handler = CgHandler::getHandler(localClientNum);
    clientNum = v23->clientNum;
    v26 = Handler;
    team = TEAM_ZERO;
    LocalClientStatics = CgStatic::GetLocalClientStatics((const LocalClientNum_t)Handler->m_localClientNum);
    v29 = CG_GetLocalClientGlobals((const LocalClientNum_t)LocalClientStatics->m_localClientNum);
    __asm { vmovaps xmm6, [rsp+0B8h+var_48] }
    v31 = v29;
    if ( !v29 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_static_inline.h", 33, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
      __debugbreak();
    CharacterInfo = CG_GetCharacterInfo(v31, clientNum);
    if ( CharacterInfo )
      team = CharacterInfo->team;
    v36 = 0;
    v37 = sourceEntityNum;
    v26->GetEntityTeam(v26, (team_t *)&v36, sourceEntityNum, (unsigned int *)&v37);
    if ( team == v36 )
    {
      if ( team )
        _RDI->type = 5;
    }
    __asm
    {
      vmovss  xmm0, dword ptr [rsp+0B8h+forward]
      vmovss  dword ptr [rdi+8], xmm0
      vmovss  xmm1, dword ptr [rsp+0B8h+forward+4]
      vmovss  dword ptr [rdi+0Ch], xmm1
      vmovss  xmm0, dword ptr [rsp+0B8h+forward+8]
      vmovss  dword ptr [rdi+10h], xmm0
    }
    AxisCopy(&LocalClientGlobals->refdef.view.axis, &_RDI->playerDir);
    *(double *)&_XMM0 = vectoyaw((const vec2_t *)&LocalClientGlobals->refdef.view.axis);
    __asm { vmovss  dword ptr [rdi+18h], xmm0 }
  }
}

/*
==============
CG_OnOffhandKeyDown
==============
*/
void CG_OnOffhandKeyDown(LocalClientNum_t localClientNum, unsigned __int64 offhandButton)
{
  __int64 v2; 
  cg_t *LocalClientGlobals; 
  CgWeaponMap *v5; 
  CgHandler *Handler; 
  const Weapon *ViewmodelWeapon; 
  int v9; 

  v2 = localClientNum;
  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT )
  {
    v9 = 2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_ui_active_client.h", 158, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, v9) )
      __debugbreak();
  }
  if ( (clientUIActives[v2].frontEndSceneState[0] || !clientUIActives[v2].cgameInitialized) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18417, ASSERT_TYPE_ASSERT, "(CL_IsGameClientActive( localClientNum ))", (const char *)&queryFormat, "CL_IsGameClientActive( localClientNum )") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v2);
  if ( !LocalClientGlobals->nextSnap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18427, ASSERT_TYPE_ASSERT, "(cgameGlob->nextSnap)", (const char *)&queryFormat, "cgameGlob->nextSnap") )
    __debugbreak();
  if ( !CgWeaponMap::ms_instance[v2] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v5 = CgWeaponMap::ms_instance[v2];
  if ( !GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&LocalClientGlobals->predictedPlayerState.pm_flags, ACTIVE, 0x1Du) || (Handler = CgHandler::getHandler((LocalClientNum_t)v2), PM_Weapon_IsInInterruptibleState(v5, &LocalClientGlobals->predictedPlayerState, WEAPON_HAND_DEFAULT, Handler)) )
  {
    if ( BG_OffhandUnderbarrelInitAllowed(&LocalClientGlobals->predictedPlayerState) && (unsigned int)(LocalClientGlobals->predictedPlayerState.weapState[0].weaponState - 26) > 6 && BG_OffhandIsUnderbarrelWeapon(v5, &LocalClientGlobals->predictedPlayerState, offhandButton) )
    {
      if ( !Com_GameMode_SupportsFeature(WEAPON_INSPECT|WEAPON_LADDER_AIM) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18442, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::WEAPON_OFFHAND_UNDERBARREL ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::WEAPON_OFFHAND_UNDERBARREL )") )
        __debugbreak();
      LocalClientGlobals->weaponSelectInAlt = 1;
      ViewmodelWeapon = BG_GetViewmodelWeapon(v5, &LocalClientGlobals->predictedPlayerState);
      if ( !BG_HasUnderbarrelWeapon(ViewmodelWeapon) )
      {
        if ( !BG_AnyUnderbarrelWeaponEquipped(v5, &LocalClientGlobals->predictedPlayerState) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18448, ASSERT_TYPE_ASSERT, "(BG_AnyUnderbarrelWeaponEquipped( weaponMap, ps ))", "%s\n\tAttempting to use offhand underbarrel weapon while none of the equipped weapons have an underbarrel weapon attachment.", "BG_AnyUnderbarrelWeaponEquipped( weaponMap, ps )") )
          __debugbreak();
        CG_Weapons_ToggleWeaponAltMode((LocalClientNum_t)v2);
      }
    }
  }
}

/*
==============
CG_OverrideImpactEffectType
==============
*/
void CG_OverrideImpactEffectType(const LocalClientNum_t localClientNum, const int sourceEntityNum, int *fxImpactType)
{
  centity_t *Entity; 
  CgStatic *LocalClientStatics; 
  const characterInfo_t *CharacterInfo; 
  const dvar_t *v9; 
  int PerkNetworkPriorityIndex; 
  unsigned __int64 v11; 
  int v12; 
  unsigned __int64 v13; 
  __int64 v14; 
  __int64 v15; 
  bitarray<64> perks; 

  if ( (unsigned int)sourceEntityNum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 19644, ASSERT_TYPE_ASSERT, "(unsigned)( sourceEntityNum ) < (unsigned)( ( 2048 ) )", "sourceEntityNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", sourceEntityNum, 2048) )
    __debugbreak();
  if ( !fxImpactType && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 19645, ASSERT_TYPE_ASSERT, "(fxImpactType)", (const char *)&queryFormat, "fxImpactType") )
    __debugbreak();
  Entity = CG_GetEntity(localClientNum, sourceEntityNum);
  LocalClientStatics = CgStatic::GetLocalClientStatics(localClientNum);
  if ( (Entity->flags & 1) != 0 && BG_IsCharacterEntity(&Entity->nextState) && (CharacterInfo = CgStatic::GetCharacterInfo(LocalClientStatics, Entity->nextState.number)) != NULL && CharacterInfo->infoValid )
    perks = CharacterInfo->perks;
  else
    perks = 0i64;
  v9 = DVARBOOL_bg_forceExplosiveBullets;
  if ( !DVARBOOL_bg_forceExplosiveBullets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_forceExplosiveBullets") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v9);
  if ( v9->current.enabled )
    *fxImpactType = CG_Main_RegisteredImpactTypeToImpactType((RegisteredImpactType)5);
  PerkNetworkPriorityIndex = BG_GetPerkNetworkPriorityIndex(0x22u);
  v11 = (unsigned int)PerkNetworkPriorityIndex;
  if ( PerkNetworkPriorityIndex >= 0 )
  {
    if ( (unsigned int)PerkNetworkPriorityIndex >= 0x40 )
    {
      LODWORD(v15) = 64;
      LODWORD(v14) = PerkNetworkPriorityIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v14, v15) )
        __debugbreak();
    }
    if ( ((0x80000000 >> (v11 & 0x1F)) & perks.array[v11 >> 5]) != 0 )
      *fxImpactType = CG_Main_RegisteredImpactTypeToImpactType((RegisteredImpactType)5);
  }
  v12 = BG_GetPerkNetworkPriorityIndex(0x1Cu);
  v13 = (unsigned int)v12;
  if ( v12 >= 0 )
  {
    if ( (unsigned int)v12 >= 0x40 )
    {
      LODWORD(v15) = 64;
      LODWORD(v14) = v12;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v14, v15) )
        __debugbreak();
    }
    if ( ((0x80000000 >> (v13 & 0x1F)) & perks.array[v13 >> 5]) != 0 )
      *fxImpactType = CG_Main_RegisteredImpactTypeToImpactType((RegisteredImpactType)4);
  }
}

/*
==============
CG_PlayBulletImpactEffect
==============
*/
void CG_PlayBulletImpactEffect(const LocalClientNum_t localClientNum, const int sourceEntityNum, const int targetEntityNum, unsigned int targetScriptableIndex, const unsigned __int8 boneIndex, const vec3_t *position, const vec3_t *normal, const int surfType, const unsigned int impactFlags, FXRegisteredDef hitFx, const bool dismembermentAllowed)
{
  cg_t *LocalClientGlobals; 
  bool v21; 
  const char *Name; 
  centity_t *Entity; 
  centity_t *v31; 
  const DObj *ClientDObj; 
  const Material *markMaterialOverride; 
  unsigned int markEntnum; 
  centity_t *v72; 
  centity_t *v73; 
  const DObj *v74; 
  int ShouldDynamicBoltBullet; 
  vec3_t halfSize; 
  tmat33_t<vec3_t> left; 
  orientation_t orient; 

  _RSI = position;
  __asm { vmovaps [rsp+160h+var_80], xmm10 }
  ShouldDynamicBoltBullet = CGMovingPlatforms::ShouldDynamicBoltBullet(localClientNum, targetEntityNum);
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v21 = surfType == 7 && (impactFlags & 4) == 0;
  _RAX = normal;
  __asm
  {
    vmovss  xmm0, dword ptr [rax]
    vmovss  xmm1, dword ptr [rax+4]
    vmovss  dword ptr [rbp+60h+forward], xmm0
    vmovss  xmm0, dword ptr [rax+8]
    vmovss  dword ptr [rbp+60h+forward+8], xmm0
    vmovss  dword ptr [rbp+60h+forward+4], xmm1
  }
  AxisRandomAroundForward(&left.m[2], left.m, &left.m[1]);
  __asm { vmovss  xmm10, cs:__real@3f800000 }
  if ( R_DecalVolumesMarks_DebugEnabled() )
  {
    __asm
    {
      vmovss  xmm0, cs:__real@3f000000
      vmovss  xmm1, cs:__real@3fc00000
      vmovss  dword ptr [rsp+160h+halfSize], xmm0
      vmovss  dword ptr [rsp+160h+halfSize+4], xmm1
      vmovss  dword ptr [rsp+160h+halfSize+8], xmm10
    }
    R_DecalVolumesMarks_DebugAdd(position, &halfSize, &left, &colorCyan);
    Name = FXRegisteredDef::GetName(&hitFx);
    Com_Printf(21, "D+ CG mark: vfx: %s\n", Name);
  }
  if ( v21 )
  {
    Entity = CG_GetEntity(localClientNum, targetEntityNum);
    v31 = Entity;
    if ( (Entity->flags & 1) != 0 )
    {
      ClientDObj = Com_GetClientDObj(Entity->nextState.number, localClientNum);
      if ( ClientDObj )
      {
        if ( DObjIsValidBoneIndex(ClientDObj, boneIndex) && CG_Entity_GetBoneOrientation(localClientNum, v31->nextState.number, boneIndex, &orient) )
        {
          __asm
          {
            vmovss  xmm0, dword ptr [rsi]
            vmovss  xmm1, dword ptr [rsi+4]
            vmovaps [rsp+160h+var_40], xmm6
            vmovaps [rsp+160h+var_50], xmm7
            vsubss  xmm7, xmm0, dword ptr [rbp+60h+orient.origin]
            vmovss  xmm0, dword ptr [rsi+8]
            vmovaps [rsp+160h+var_60], xmm8
            vsubss  xmm8, xmm1, dword ptr [rbp+60h+orient.origin+4]
            vmulss  xmm1, xmm8, dword ptr [rbp+60h+orient.axis+4]
            vmovaps [rsp+160h+var_70], xmm9
            vsubss  xmm9, xmm0, dword ptr [rbp+60h+orient.origin+8]
            vmulss  xmm0, xmm7, dword ptr [rbp+60h+orient.axis]
            vaddss  xmm2, xmm1, xmm0
            vmulss  xmm1, xmm9, dword ptr [rbp+60h+orient.axis+8]
            vaddss  xmm3, xmm2, xmm1
            vmulss  xmm0, xmm3, dword ptr [rbp+60h+orient.axis]
            vmulss  xmm1, xmm3, dword ptr [rbp+60h+orient.axis+4]
            vsubss  xmm4, xmm7, xmm0
            vmulss  xmm0, xmm3, dword ptr [rbp+60h+orient.axis+8]
            vsubss  xmm5, xmm9, xmm0
            vsubss  xmm6, xmm8, xmm1
            vmulss  xmm0, xmm5, xmm5
            vmulss  xmm2, xmm6, xmm6
            vmulss  xmm1, xmm4, xmm4
            vaddss  xmm3, xmm2, xmm1
            vaddss  xmm2, xmm3, xmm0
            vsqrtss xmm1, xmm2, xmm2
            vcmpless xmm0, xmm1, cs:__real@80000000
            vblendvps xmm0, xmm1, xmm10, xmm0
            vdivss  xmm2, xmm10, xmm0
            vmulss  xmm0, xmm4, xmm2
            vmovss  dword ptr [rsp+160h+halfSize], xmm0
            vmulss  xmm0, xmm5, xmm2
            vmulss  xmm1, xmm6, xmm2
            vmovss  dword ptr [rsp+160h+halfSize+8], xmm0
            vmovss  dword ptr [rsp+160h+halfSize+4], xmm1
          }
          OrthonormalBasis(&halfSize, &left);
          __asm
          {
            vmovaps xmm9, [rsp+160h+var_70]
            vmovaps xmm8, [rsp+160h+var_60]
            vmovaps xmm7, [rsp+160h+var_50]
            vmovaps xmm6, [rsp+160h+var_40]
          }
        }
      }
    }
    if ( R_DecalVolumesMarks_DebugEnabled() )
    {
      __asm
      {
        vmovss  xmm0, cs:__real@3f200000
        vmovss  xmm1, cs:__real@40000000
        vmovss  dword ptr [rsp+160h+halfSize], xmm0
        vmovss  xmm0, cs:__real@3fa00000
        vmovss  dword ptr [rsp+160h+halfSize+8], xmm0
        vmovss  dword ptr [rsp+160h+halfSize+4], xmm1
      }
      R_DecalVolumesMarks_DebugAdd(position, &halfSize, &left, &colorOrange);
    }
  }
  markMaterialOverride = MARK_MATERIAL_OVERRIDE_NONE_2;
  __asm { vmovaps xmm10, [rsp+160h+var_80] }
  if ( targetScriptableIndex == -1 || !ScriptableCl_GetLinkTypeEquals(localClientNum, targetScriptableIndex, SCRIPTABLE_LINK_DYNENT) || (markEntnum = ScriptableCl_GetLinkObject(localClientNum, targetScriptableIndex), markEntnum == -1) )
  {
    if ( ShouldDynamicBoltBullet )
    {
      FX_PlayDynamicBoltedEffect(localClientNum, &hitFx, LocalClientGlobals->time, targetEntityNum, position, &left, targetEntityNum, 1, 0, markMaterialOverride);
    }
    else
    {
      v72 = CG_GetEntity(localClientNum, targetEntityNum);
      v73 = v72;
      if ( (v72->flags & 1) != 0 && (v74 = Com_GetClientDObj(v72->nextState.number, localClientNum)) != NULL && DObjIsValidBoneIndex(v74, boneIndex) )
        FX_PlayBoltedOffsetEffectWithMarkEntity(localClientNum, &hitFx, LocalClientGlobals->time, v73->nextState.number, boneIndex, position, &left, !dismembermentAllowed << 7, targetEntityNum, 0, boneIndex, markMaterialOverride);
      else
        FX_PlayOrientedEffectWithMarkEntity(localClientNum, &hitFx, LocalClientGlobals->time, position, &left, 0, targetEntityNum, 0, boneIndex, markMaterialOverride);
    }
  }
  else
  {
    FX_PlayOrientedEffectWithMarkEntity(localClientNum, &hitFx, LocalClientGlobals->time, position, &left, 2u, markEntnum, 1, 0xFEu, markMaterialOverride);
  }
}

/*
==============
CG_PlayMissileProjectedConeSound
==============
*/
void CG_PlayMissileProjectedConeSound(LocalClientNum_t localClientNum, centity_t *cent)
{
  const dvar_t *v9; 
  cg_t *LocalClientGlobals; 
  SndAliasList *Alias; 
  SndAliasList *v27; 
  const SndAliasList *v28; 
  SndAlias *head; 
  unsigned int assetId; 
  bool v35; 
  bool v36; 
  const SndAliasList *v42; 
  float fmt; 
  float fmta; 
  float volumeScale; 
  int v63; 
  float result_missile; 
  float result_line; 
  vec3_t outOrg; 
  __int64 v67; 
  MissileConeSoundVars mcv; 
  char v69; 
  void *retaddr; 

  _RAX = &retaddr;
  v67 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm6
    vmovaps xmmword ptr [rax-48h], xmm7
    vmovaps xmmword ptr [rax-58h], xmm8
    vmovaps xmmword ptr [rax-68h], xmm10
  }
  if ( !cent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22009, ASSERT_TYPE_ASSERT, "(cent)", (const char *)&queryFormat, "cent") )
    __debugbreak();
  if ( (cent->flags & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22010, ASSERT_TYPE_ASSERT, "(CENextValid( cent ))", (const char *)&queryFormat, "CENextValid( cent )") )
    __debugbreak();
  if ( cent->nextState.eType != ET_MISSILE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22011, ASSERT_TYPE_ASSERT, "(cent->nextState.eType == ET_MISSILE)", (const char *)&queryFormat, "cent->nextState.eType == ET_MISSILE") )
    __debugbreak();
  if ( CG_SetupAndValidateConeVars(localClientNum, cent, &mcv) )
  {
    if ( !mcv.alias && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22019, ASSERT_TYPE_ASSERT, "(mcv.alias)", (const char *)&queryFormat, "mcv.alias") )
      __debugbreak();
    v9 = DCONST_DVARBOOL_bg_missileDebugDraw;
    if ( DCONST_DVARBOOL_bg_missileDebugDraw )
    {
      Dvar_CheckFrontendServerThread(DCONST_DVARBOOL_bg_missileDebugDraw);
      if ( v9->current.enabled )
        DebugDrawMissileProjectedSound(&mcv);
    }
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    if ( (!GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&LocalClientGlobals->predictedPlayerState.otherFlags, ACTIVE, 1u) || LocalClientGlobals->predictedPlayerState.remoteEyesEnt != cent->nextState.number) && (LocalClientGlobals->predictedPlayerState.linkFlags.m_flags[0] & 4) == 0 )
    {
      RefdefView_GetOrg(&LocalClientGlobals->refdef.view, &outOrg);
      if ( !CalcDistanceFactors(&outOrg, &mcv, &result_line, &result_missile) )
        goto LABEL_43;
      __asm
      {
        vmovss  xmm8, cs:__real@3f800000
        vmovaps xmm2, xmm8; max
        vmovss  xmm1, [rbp+40h+mcv.volumescaleCoreSize]; min
        vmovss  xmm0, [rsp+140h+result_line]; original
      }
      NormalizeForMinMax(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
      __asm
      {
        vmovss  xmm1, [rbp+40h+mcv.volumescaleAtEdge]
        vsubss  xmm2, xmm1, [rbp+40h+mcv.volumescaleAtCore]
        vmulss  xmm0, xmm2, xmm0
        vaddss  xmm10, xmm0, [rbp+40h+mcv.volumescaleAtCore]
      }
      if ( mcv.pitchshiftEnabled )
      {
        __asm
        {
          vsubss  xmm2, xmm8, [rbp+40h+mcv.pitchBottomSize]; max
          vmovss  xmm1, [rbp+40h+mcv.pitchTopSize]; min
          vmovss  xmm0, [rsp+140h+result_missile]; original
        }
        NormalizeForMinMax(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
        __asm
        {
          vmovss  xmm1, [rbp+40h+mcv.pitchAtBottom]
          vsubss  xmm2, xmm1, [rbp+40h+mcv.pitchAtTop]
          vmulss  xmm0, xmm2, xmm0
          vaddss  xmm7, xmm0, [rbp+40h+mcv.pitchAtTop]
        }
      }
      else
      {
        __asm { vmovaps xmm7, xmm8 }
      }
      Alias = SND_FindAlias(mcv.alias);
      v27 = SND_FindAlias(mcv.aliasAtBase);
      v28 = v27;
      if ( !Alias || !v27 )
      {
LABEL_43:
        memset(&outOrg, 0, sizeof(outOrg));
        goto LABEL_44;
      }
      if ( mcv.crossfadeEnabled )
      {
        if ( !mcv.aliasAtBase && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22073, ASSERT_TYPE_ASSERT, "(mcv.aliasAtBase)", (const char *)&queryFormat, "mcv.aliasAtBase") )
          __debugbreak();
        __asm
        {
          vsubss  xmm2, xmm8, [rbp+40h+mcv.crossfadeBottomSize]; max
          vmovss  xmm1, [rbp+40h+mcv.crossfadeTopSize]; min
          vmovss  xmm0, [rsp+140h+result_missile]; original
        }
        *(float *)&_XMM0 = NormalizeForMinMax(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
        __asm { vmovaps xmm6, xmm0 }
        head = Alias->head;
        assetId = v28->head->assetId;
        v35 = head->assetId < assetId;
        v36 = head->assetId == assetId;
        if ( head->assetId == assetId )
        {
          __asm
          {
            vmovss  [rsp+140h+var_110], xmm7
            vmovss  [rsp+140h+volumeScale], xmm10
            vmovaps xmm2, xmm0; lerp
          }
          SND_PlayBlendedSoundAliasAsync(Alias, v28, *(const float *)&_XMM2, localClientNum, cent->nextState.number, volumeScale, *(float *)&v63, &mcv.start, 0, SASYS_CGAME);
LABEL_38:
          if ( DVARBOOL_missileDebugText && Dvar_GetBool_Internal_DebugName(DVARBOOL_missileDebugText, "missileDebugText") )
          {
            __asm
            {
              vmovss  xmm3, [rsp+140h+result_missile]
              vcvtss2sd xmm3, xmm3, xmm3
              vmovss  xmm2, [rsp+140h+result_line]
              vcvtss2sd xmm2, xmm2, xmm2
              vmovq   r9, xmm3
              vmovq   r8, xmm2
            }
            Com_Printf(0, "Line:%.2f, Misl:%.2f  |  ", *(double *)&_XMM2, *(double *)&_XMM3);
            __asm
            {
              vcvtss2sd xmm3, xmm7, xmm7
              vcvtss2sd xmm2, xmm10, xmm10
              vmovq   r9, xmm3
              vmovq   r8, xmm2
            }
            Com_Printf(0, "Vol:%.2f, Pitch:%.2f", *(double *)&_XMM2, *(double *)&_XMM3);
            if ( mcv.crossfadeEnabled )
            {
              __asm
              {
                vcvtss2sd xmm2, xmm6, xmm6
                vmovq   r8, xmm2
              }
              Com_Printf(0, ", XFade:%.2f", *(double *)&_XMM2);
            }
            Com_Printf(0, "\n");
          }
          goto LABEL_43;
        }
        __asm
        {
          vsubss  xmm0, xmm8, xmm6
          vmulss  xmm3, xmm0, xmm10; volumeScale
          vmulss  xmm8, xmm6, xmm10
          vcomiss xmm3, cs:__real@3a83126f
        }
        if ( head->assetId > assetId )
        {
          __asm { vmovss  dword ptr [rsp+140h+fmt], xmm7 }
          SND_PlayScaledSoundAliasAsync(Alias, localClientNum, cent->nextState.number, *(float *)&_XMM3, fmt, &mcv.start, 0, SASYS_CGAME);
        }
        __asm { vcomiss xmm8, cs:__real@3a83126f }
        if ( v35 || v36 )
          goto LABEL_38;
        __asm { vmovaps xmm3, xmm8 }
        v42 = v28;
      }
      else
      {
        __asm
        {
          vxorps  xmm6, xmm6, xmm6
          vmovaps xmm3, xmm10; volumeScale
        }
        v42 = Alias;
      }
      __asm { vmovss  dword ptr [rsp+140h+fmt], xmm7 }
      SND_PlayScaledSoundAliasAsync(v42, localClientNum, cent->nextState.number, *(float *)&_XMM3, fmta, &mcv.start, 0, SASYS_CGAME);
      goto LABEL_38;
    }
  }
LABEL_44:
  _R11 = &v69;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm10, xmmword ptr [r11-40h]
  }
}

/*
==============
CG_PlayerUsingOutlineEnemiesTurret
==============
*/

bool __fastcall CG_PlayerUsingOutlineEnemiesTurret(LocalClientNum_t localClientNum, __int64 a2, double _XMM2_8)
{
  cg_t *LocalClientGlobals; 
  CgHandler *Handler; 
  Weapon r_weapon; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21515, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  Handler = CgHandler::getHandler(localClientNum);
  _RAX = (__int64)Handler->PlayerTurret(Handler, &LocalClientGlobals->predictedPlayerState);
  __asm
  {
    vmovups ymm2, ymmword ptr [rax]
    vmovups ymmword ptr [rsp+88h+r_weapon.weaponIdx], ymm2
    vmovups xmm0, xmmword ptr [rax+20h]
    vmovups xmmword ptr [rsp+88h+r_weapon.attachmentVariationIndices+5], xmm0
    vmovsd  xmm1, qword ptr [rax+30h]
    vmovsd  qword ptr [rsp+88h+r_weapon.attachmentVariationIndices+15h], xmm1
  }
  *(_DWORD *)&r_weapon.weaponCamo = *(_DWORD *)(_RAX + 56);
  __asm { vmovd   eax, xmm2 }
  if ( (_WORD)_EAX )
    LOBYTE(_EAX) = BG_ScopeOutlinesEnemies(&r_weapon, 0);
  return _EAX;
}

/*
==============
CG_PlayerUsingScopedTurret
==============
*/

bool __fastcall CG_PlayerUsingScopedTurret(LocalClientNum_t localClientNum, __int64 a2, double _XMM2_8)
{
  cg_t *LocalClientGlobals; 
  CgHandler *Handler; 
  bool v12; 
  WeaponDef **v13; 
  WeaponDef *v14; 
  __int64 v15; 
  Weapon r_weapon; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21472, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  Handler = CgHandler::getHandler(localClientNum);
  _RAX = (__int64)Handler->PlayerTurret(Handler, &LocalClientGlobals->predictedPlayerState);
  __asm
  {
    vmovups ymm2, ymmword ptr [rax]
    vmovups ymmword ptr [rsp+98h+r_weapon.weaponIdx], ymm2
    vmovups xmm0, xmmword ptr [rax+20h]
    vmovups xmmword ptr [rsp+98h+r_weapon.attachmentVariationIndices+5], xmm0
    vmovsd  xmm1, qword ptr [rax+30h]
    vmovd   ebx, xmm2
    vmovsd  qword ptr [rsp+98h+r_weapon.attachmentVariationIndices+15h], xmm1
  }
  *(_DWORD *)&r_weapon.weaponCamo = *(_DWORD *)(_RAX + 56);
  if ( !(_WORD)_EBX )
    return 0;
  if ( (unsigned __int16)_EBX > bg_lastParsedWeaponIndex )
  {
    LODWORD(v15) = (unsigned __int16)_EBX;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1203, ASSERT_TYPE_ASSERT, "( weaponIdx ) <= ( bg_lastParsedWeaponIndex )", "weaponIdx not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", v15, bg_lastParsedWeaponIndex) )
      __debugbreak();
  }
  v12 = bg_weaponDefs[(unsigned __int16)_EBX] == NULL;
  v13 = &bg_weaponDefs[(unsigned __int16)_EBX];
  if ( v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1204, ASSERT_TYPE_ASSERT, "(bg_weaponDefs[weaponIdx])", (const char *)&queryFormat, "bg_weaponDefs[weaponIdx]") )
    __debugbreak();
  v14 = *v13;
  return BG_GetOverlay(&r_weapon, 0)->shaderMat || v14->overlayInterface == WEAPOVERLAYINTERFACE_TURRETSCOPE;
}

/*
==============
CG_PlayerUsingThermalTurret
==============
*/

bool __fastcall CG_PlayerUsingThermalTurret(LocalClientNum_t localClientNum, __int64 a2, double _XMM2_8)
{
  cg_t *LocalClientGlobals; 
  CgHandler *Handler; 
  Weapon r_weapon; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21496, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  Handler = CgHandler::getHandler(localClientNum);
  _RAX = (__int64)Handler->PlayerTurret(Handler, &LocalClientGlobals->predictedPlayerState);
  __asm
  {
    vmovups ymm2, ymmword ptr [rax]
    vmovups ymmword ptr [rsp+88h+r_weapon.weaponIdx], ymm2
    vmovups xmm0, xmmword ptr [rax+20h]
    vmovups xmmword ptr [rsp+88h+r_weapon.attachmentVariationIndices+5], xmm0
    vmovsd  xmm1, qword ptr [rax+30h]
    vmovsd  qword ptr [rsp+88h+r_weapon.attachmentVariationIndices+15h], xmm1
  }
  *(_DWORD *)&r_weapon.weaponCamo = *(_DWORD *)(_RAX + 56);
  __asm { vmovd   eax, xmm2 }
  if ( (_WORD)_EAX )
    LOBYTE(_EAX) = BG_HasThermalScope(&LocalClientGlobals->predictedPlayerState, &r_weapon, 0);
  return _EAX;
}

/*
==============
CG_ProcessWeaponOnAltChange
==============
*/
void CG_ProcessWeaponOnAltChange(const LocalClientNum_t localClientNum, bool isAlternate)
{
  __int64 v2; 
  CgWeaponMap *v4; 
  cg_t *LocalClientGlobals; 
  int v6; 
  cg_t *v7; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool v13; 
  DObj **p_viewModelDObj; 
  int *p_weapAnim; 
  int v16; 
  CgHandler *pmoveHandler; 
  weapAnimFiles_t v18; 
  bool v19; 
  __int64 bIsAlternate; 
  __int64 handIndex; 
  bool CanHybridToggle; 
  BgWeaponMap *weaponMap; 
  Weapon r_weapon; 

  v2 = localClientNum;
  if ( !CgWeaponMap::ms_instance[localClientNum] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v4 = CgWeaponMap::ms_instance[v2];
  weaponMap = v4;
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v2);
  v6 = 0;
  LocalClientGlobals->adsSettlePending = 0;
  LocalClientGlobals->adsSettleMaxADSFraction = 0.0;
  v7 = CG_GetLocalClientGlobals((const LocalClientNum_t)v2);
  _RAX = BG_GetViewmodelWeapon(v4, &v7->predictedPlayerState);
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovups ymmword ptr [rsp+0D8h+r_weapon.weaponIdx], ymm0
    vmovups xmm1, xmmword ptr [rax+20h]
    vmovups xmmword ptr [rsp+0D8h+r_weapon.attachmentVariationIndices+5], xmm1
    vmovsd  xmm0, qword ptr [rax+30h]
    vmovsd  qword ptr [rsp+0D8h+r_weapon.attachmentVariationIndices+15h], xmm0
  }
  *(_DWORD *)&r_weapon.weaponCamo = *(_DWORD *)&_RAX->weaponCamo;
  CanHybridToggle = BG_CanHybridToggle(&v7->predictedPlayerState, &r_weapon, isAlternate);
  EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(v4, &v7->predictedPlayerState, &r_weapon);
  v13 = !EquippedWeaponStateConst || !EquippedWeaponStateConst->hybridScope;
  p_viewModelDObj = &v7->m_weaponHand[0].viewModelDObj;
  p_weapAnim = &v7->predictedPlayerState.weapState[0].weapAnim;
  do
  {
    v16 = *p_weapAnim & 0xFFFFFF7F;
    pmoveHandler = CgHandler::getHandler((LocalClientNum_t)v2);
    v18 = BG_MapWeaponAnimStateToAnimIndex(weaponMap, &v7->predictedPlayerState, v16, 0, &r_weapon, isAlternate, (PlayerHandIndex)v6, pmoveHandler);
    v19 = !isAlternate && (unsigned int)(v18 - 326) <= 5;
    if ( (unsigned int)v6 >= 2 )
    {
      LODWORD(handIndex) = 2;
      LODWORD(bIsAlternate) = v6;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", bIsAlternate, handIndex) )
        __debugbreak();
    }
    if ( *p_viewModelDObj )
      BG_ShowHideTagsBasedOnAltMode(&r_weapon, *p_viewModelDObj, isAlternate, v19, v7->playerWeaponInfo.hideReticle, CanHybridToggle, v13);
    ++v6;
    p_weapAnim += 20;
    p_viewModelDObj += 5;
  }
  while ( v6 < 2 );
}

/*
==============
CG_RegisterWeapon
==============
*/
char CG_RegisterWeapon(LocalClientNum_t localClientNum, const playerState_s *ps, const GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64> prevWeaponFlags, const Weapon *weapon, ClientPlayerWeaponInfo *weapInfo)
{
  bool v11; 
  cg_t *LocalClientGlobals; 
  CgWeaponMap *Instance; 
  bool v14; 
  SkydiveViewmodelState ViewmodelState; 
  int prevDualWielding; 
  bool v17; 
  bool v18; 
  const snapshot_t *snap; 
  __int64 v20; 
  char v21; 
  const char *WeaponName; 
  cg_t *v26; 
  char WeaponViewModelXAnimDefs; 
  unsigned int NumWeapons; 
  bool v29; 
  bool v30; 
  bool v31; 
  int v32; 
  DualWieldType dualWieldType; 
  unsigned int v34; 
  unsigned int carryObjectIndex; 
  const WeaponDef *v36; 
  char output[1024]; 

  _RDI = weapon;
  _R15 = weapInfo;
  if ( !weapon->weaponIdx )
    return 0;
  if ( weapon->weaponIdx >= BG_GetNumWeapons() )
  {
    NumWeapons = BG_GetNumWeapons();
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9953, ASSERT_TYPE_ASSERT, "(unsigned)( weapon.weaponIdx ) < (unsigned)( BG_GetNumWeapons() )", "weapon.weaponIdx doesn't index BG_GetNumWeapons()\n\t%i not in [0, %i)", _RDI->weaponIdx, NumWeapons) )
      __debugbreak();
  }
  v11 = !memcmp_0(&weapInfo->weapon, _RDI, 0x3Cui64) || BG_WeaponsDifferOnlyInVariantForInstantSwitch(ps, prevWeaponFlags, &weapInfo->weapon, _RDI);
  v36 = BG_WeaponDef(_RDI, 0);
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  Instance = CgWeaponMap::GetInstance(localClientNum);
  v32 = BG_PlayerDualWieldingWeapon(Instance, ps, _RDI);
  dualWieldType = v36->dualWieldType;
  v29 = weapInfo->isAlternate != BG_UsingAlternate(ps);
  v14 = !memcmp_0(&weapInfo->weapon, _RDI, 0x3Cui64) && weapInfo->meleeComboSeqIdx != ps->weapCommon.meleeComboSeqIdx;
  v30 = ViewModelScriptedStateChanged(localClientNum, ps);
  carryObjectIndex = weapInfo->carryObjectIndex;
  v34 = ps->carryState.carryObjectIndex;
  ViewmodelState = CG_Skydive_GetViewmodelState(localClientNum);
  prevDualWielding = LocalClientGlobals->prevDualWielding;
  v31 = ViewmodelState != weapInfo->skydiveViewmodelState;
  v17 = !prevDualWielding && LocalClientGlobals->prevLadderHand && v32;
  if ( prevDualWielding != v32 || v17 )
    v11 = 0;
  if ( dualWieldType == DUAL_WIELD_TYPE_ALT_MODE && v29 )
    v11 = 0;
  v18 = CG_Gesture_SetRebuildTree(localClientNum, ps, _RDI);
  if ( !v11 || v14 || v18 || Com_GameMode_SupportsFeature(WEAPON_SPRINT_DROP|0x80) && (snap = CG_GetLocalClientGlobals(localClientNum)->snap) != NULL && (v20 = (__int64)snap->GetPlayerState(snap, (const LocalClientNum_t)localClientNum)) != 0 && *(_DWORD *)(v20 + 1124) != ps->demeanorState.targetState || v30 || carryObjectIndex != v34 || v31 )
  {
    v26 = CG_GetLocalClientGlobals(localClientNum);
    v26->adsSettlePending = 0;
    v26->adsSettleMaxADSFraction = 0.0;
    WeaponViewModelXAnimDefs = CG_CreateWeaponViewModelXAnimDefs(localClientNum, ps, _RDI, weapInfo);
    v21 = WeaponViewModelXAnimDefs;
    if ( v14 || WeaponViewModelXAnimDefs )
      CG_Gesture_ForceRestoreAnims(localClientNum, ps, _RDI);
  }
  else
  {
    if ( v29 )
      CG_Gesture_ForceRestoreAnims(localClientNum, ps, _RDI);
    v21 = 0;
  }
  if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_TO_IDLE|WEAPON_LADDER_AIM) && !v36->handXModel && BG_GetWeaponClass(_RDI, 0) != WEAPCLASS_NON_PLAYER && BG_GetWeaponClass(_RDI, 0) != WEAPCLASS_TURRET )
  {
    WeaponName = BG_GetWeaponName(_RDI, output, 0x400u);
    Com_PrintError(17, "Weapon \"%s\" has no default view hands set.\n", WeaponName);
  }
  if ( !weapInfo->handModel || !v11 )
    weapInfo->handModel = v36->handXModel;
  __asm
  {
    vmovups ymm0, ymmword ptr [rdi]
    vmovups ymmword ptr [r15+10h], ymm0
    vmovups xmm1, xmmword ptr [rdi+20h]
    vmovups xmmword ptr [r15+30h], xmm1
    vmovsd  xmm0, qword ptr [rdi+30h]
    vmovsd  qword ptr [r15+40h], xmm0
  }
  *(_DWORD *)&weapInfo->weapon.weaponCamo = *(_DWORD *)&_RDI->weaponCamo;
  return v21;
}

/*
==============
CG_RemoveAttachmentFromList
==============
*/
__int64 CG_RemoveAttachmentFromList(unsigned int attachmentIndex, const WeaponAttachment **attachments, unsigned int attachmentCount)
{
  __int64 v6; 
  const WeaponAttachment **v7; 
  const WeaponAttachment *v8; 
  __int64 v9; 
  __int64 v11; 
  __int64 v12; 

  if ( attachmentCount > 0x1D && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22223, ASSERT_TYPE_ASSERT, "( attachmentCount ) <= ( (1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 16 + 1 + 1 + 1 + 1) )", "attachmentCount not in [0, MAX_NUM_WEAPON_ATTACHMENTS]\n\t%u not in [0, %u]", attachmentCount, 29) )
    __debugbreak();
  if ( attachmentIndex >= attachmentCount )
  {
    LODWORD(v12) = attachmentCount;
    LODWORD(v11) = attachmentIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22224, ASSERT_TYPE_ASSERT, "(unsigned)( attachmentIndex ) < (unsigned)( attachmentCount )", "attachmentIndex doesn't index attachmentCount\n\t%i not in [0, %i)", v11, v12) )
      __debugbreak();
  }
  if ( !attachments && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22225, ASSERT_TYPE_ASSERT, "(attachments)", (const char *)&queryFormat, "attachments") )
    __debugbreak();
  v6 = attachmentIndex + 1;
  if ( (unsigned int)v6 < attachmentCount )
  {
    v7 = &attachments[v6];
    do
    {
      if ( !*v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22231, ASSERT_TYPE_ASSERT, "(attachments[nextAttachIndex])", (const char *)&queryFormat, "attachments[nextAttachIndex]") )
        __debugbreak();
      v8 = *v7++;
      v9 = attachmentIndex;
      attachmentIndex = v6;
      LODWORD(v6) = v6 + 1;
      attachments[v9] = v8;
    }
    while ( (unsigned int)v6 < attachmentCount );
  }
  if ( attachmentIndex >= attachmentCount )
  {
    LODWORD(v12) = attachmentCount;
    LODWORD(v11) = attachmentIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22235, ASSERT_TYPE_ASSERT, "(unsigned)( prevAttachIndex ) < (unsigned)( attachmentCount )", "prevAttachIndex doesn't index attachmentCount\n\t%i not in [0, %i)", v11, v12) )
      __debugbreak();
  }
  attachments[attachmentIndex] = NULL;
  return attachmentCount - 1;
}

/*
==============
CG_SaveViewModelAnimTrees
==============
*/
void CG_SaveViewModelAnimTrees(MemoryFile *memFile, const playerState_s *ps, LocalClientNum_t localClientNum)
{
  __int64 v3; 
  cg_t *LocalClientGlobals; 
  int v7; 
  bool v8; 
  WeaponHand *m_weaponHand; 
  const DObj *viewModelDObj; 
  __int64 v11; 
  __int64 v12; 

  v3 = localClientNum;
  if ( !memFile && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13493, ASSERT_TYPE_ASSERT, "(memFile)", (const char *)&queryFormat, "memFile") )
    __debugbreak();
  if ( (unsigned int)v3 >= 2 )
  {
    LODWORD(v11) = v3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13494, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v11, 2) )
      __debugbreak();
  }
  if ( !CgWeaponMap::ms_instance[v3] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  if ( BG_GetViewmodelWeapon(CgWeaponMap::ms_instance[v3], ps)->weaponIdx )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v3);
    v7 = 0;
    v8 = 1;
    m_weaponHand = LocalClientGlobals->m_weaponHand;
    do
    {
      if ( !v8 )
      {
        LODWORD(v12) = 2;
        LODWORD(v11) = v7;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v11, v12) )
          __debugbreak();
      }
      if ( m_weaponHand->hasAnimTree )
      {
        viewModelDObj = m_weaponHand->viewModelDObj;
        if ( !m_weaponHand->viewModelDObj )
        {
          Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1442DEBA0, 613i64);
          viewModelDObj = m_weaponHand->viewModelDObj;
        }
        XAnimSaveAnimTreeWithVersion(viewModelDObj, memFile, 1u);
      }
      ++v7;
      ++m_weaponHand;
      v8 = (unsigned int)v7 < 2;
    }
    while ( v7 < 2 );
  }
}

/*
==============
CG_SelectNthPrimaryWeapon
==============
*/

void __fastcall CG_SelectNthPrimaryWeapon(LocalClientNum_t localClientNum, int nthIndex, double _XMM2_8)
{
  int v3; 
  cg_t *LocalClientGlobals; 
  cg_t *v6; 
  const playerState_s *p_predictedPlayerState; 
  CgWeaponMap *Instance; 
  int i; 
  __int64 v14; 
  Weapon r_weapon; 

  v3 = nthIndex;
  if ( nthIndex < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21310, ASSERT_TYPE_ASSERT, "( nthIndex ) >= ( 0 )", "%s >= %s\n\t%i, %i", "nthIndex", "0", nthIndex, 0i64) )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v6 = LocalClientGlobals;
  if ( LocalClientGlobals->nextSnap )
  {
    if ( WeaponCycleAllowed(LocalClientGlobals) )
    {
      p_predictedPlayerState = &v6->predictedPlayerState;
      if ( BG_IsPlayer(p_predictedPlayerState) && p_predictedPlayerState->pm_type < 7 && BG_GetNumWeapons() >= 2 )
      {
        Instance = CgWeaponMap::GetInstance(localClientNum);
        for ( i = 0; i < 15; ++i )
        {
          _RAX = BG_GetEquippedWeaponForPlayer(Instance, p_predictedPlayerState, i);
          __asm
          {
            vmovups ymm2, ymmword ptr [rax]
            vmovups ymmword ptr [rsp+0C8h+r_weapon.weaponIdx], ymm2
            vmovups xmm0, xmmword ptr [rax+20h]
            vmovups xmmword ptr [rsp+0C8h+r_weapon.attachmentVariationIndices+5], xmm0
            vmovsd  xmm1, qword ptr [rax+30h]
            vmovsd  qword ptr [rsp+0C8h+r_weapon.attachmentVariationIndices+15h], xmm1
          }
          *(_DWORD *)&r_weapon.weaponCamo = *(_DWORD *)&_RAX->weaponCamo;
          __asm { vmovd   eax, xmm2 }
          if ( (_WORD)_RAX && BG_WeaponDef(&r_weapon, 0)->inventoryType == WEAPINVENTORY_PRIMARY && BG_GetEquippedWeaponState(Instance, p_predictedPlayerState, &r_weapon)->slot == WEAPON_SLOT_PRIMARY )
          {
            if ( v3 <= 0 )
            {
              if ( v3 )
              {
                LODWORD(v14) = v3;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21358, ASSERT_TYPE_ASSERT, "( nthIndex ) == ( 0 )", "%s == %s\n\t%i, %i", "nthIndex", "0", v14, 0i64) )
                  __debugbreak();
              }
              if ( BG_IsWeaponUsableInState(p_predictedPlayerState, &r_weapon) )
                CG_SelectWeapon(localClientNum, &r_weapon, 0);
              return;
            }
            --v3;
          }
        }
      }
    }
  }
}

/*
==============
CG_SelectWeapon
==============
*/
char CG_SelectWeapon(LocalClientNum_t localClientNum, const Weapon *weapon, int useAltMode)
{
  __int64 v4; 
  CgWeaponMap *v8; 
  playerState_s *p_predictedPlayerState; 
  const dvar_t *v10; 
  const Weapon *v11; 
  const WeaponCompleteDef *v12; 
  const char *szInternalName; 
  const WeaponCompleteDef *v15; 
  bool v16; 
  int EquippedWeaponIndex; 
  __int64 v18; 
  bool v19; 
  unsigned int v20; 
  int v27; 
  int v31; 
  int ControllerFromClient; 
  unsigned __int16 ModelForController; 
  unsigned __int16 ModelFromPath; 
  bool v36; 
  char outHexString[128]; 

  v4 = localClientNum;
  _RDI = weapon;
  _RSI = CG_GetLocalClientGlobals(localClientNum);
  if ( !CgWeaponMap::ms_instance[v4] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v8 = CgWeaponMap::ms_instance[v4];
  p_predictedPlayerState = &_RSI->predictedPlayerState;
  if ( CG_HighPriorityWeapon_IsWeaponSwitchAllowed(v8, &_RSI->predictedPlayerState, _RDI) )
  {
    _RSI->weaponSelectTime = _RSI->time;
    v16 = memcmp_0(&_RSI->weaponSelect, _RDI, 0x3Cui64) != 0;
    v36 = v16;
    if ( !BG_HasUnderbarrelAmmo(_RDI) )
      useAltMode = 0;
    if ( v16 )
    {
      if ( BG_HasUnderbarrelAmmo(_RDI) )
      {
        if ( !v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1076, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
          __debugbreak();
        if ( _RSI == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1077, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
          __debugbreak();
        EquippedWeaponIndex = BG_GetEquippedWeaponIndex(v8, &_RSI->predictedPlayerState, _RDI);
        useAltMode = 0;
        if ( EquippedWeaponIndex >= 0 )
        {
          v18 = EquippedWeaponIndex;
          if ( (playerState_s *)((char *)p_predictedPlayerState + 4 * v18) != (playerState_s *)-1540i64 && p_predictedPlayerState->weapEquippedData[v18].inAltMode )
            useAltMode = 1;
        }
      }
    }
    else if ( _RSI->weaponSelectInAlt == useAltMode )
    {
      return 1;
    }
    if ( _RSI == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1384, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    v19 = BG_UsingAlternate(&_RSI->predictedPlayerState);
    if ( BG_WeaponDef(_RDI, v19)->disableSwitchToWhenEmpty && !BG_WeaponAmmo(v8, &_RSI->predictedPlayerState, _RDI, v19) )
      return 0;
    if ( DVARBOOL_bg_giveAll && Dvar_GetBool_Internal_DebugName(DVARBOOL_bg_giveAll, "bg_giveAll") )
    {
      do
      {
        do
        {
          v20 = ((unsigned int)_RSI->weaponSelect.weaponIdx + 1) % BG_GetNumWeapons();
          _RSI->weaponSelect.weaponIdx = v20;
        }
        while ( !(_WORD)v20 );
      }
      while ( BG_WeaponDef(&_RSI->weaponSelect, 0)->inventoryType );
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rdi]
        vmovups ymmword ptr [rsi+18114h], ymm0
        vmovups xmm1, xmmword ptr [rdi+20h]
        vmovups xmmword ptr [rsi+18134h], xmm1
        vmovsd  xmm0, qword ptr [rdi+30h]
        vmovsd  qword ptr [rsi+18144h], xmm0
      }
      *(_DWORD *)&_RSI->weaponSelect.weaponCamo = *(_DWORD *)&_RDI->weaponCamo;
    }
    if ( _RDI->weaponIdx && BG_WeaponDef(_RDI, 0)->inventoryType )
    {
      __asm
      {
        vmovups ymm2, ymmword ptr cs:?NULL_WEAPON@@3UWeapon@@B.weaponIdx; Weapon const NULL_WEAPON
        vmovups xmm3, xmmword ptr cs:?NULL_WEAPON@@3UWeapon@@B.attachmentVariationIndices+5; Weapon const NULL_WEAPON
        vmovsd  xmm4, qword ptr cs:?NULL_WEAPON@@3UWeapon@@B.attachmentVariationIndices+15h; Weapon const NULL_WEAPON
      }
      v27 = *(_DWORD *)&NULL_WEAPON.weaponCamo;
    }
    else
    {
      __asm
      {
        vmovups ymm2, ymmword ptr [rdi]
        vmovups xmm3, xmmword ptr [rdi+20h]
        vmovsd  xmm4, qword ptr [rdi+30h]
      }
      v27 = *(_DWORD *)&_RDI->weaponCamo;
    }
    __asm { vmovd   eax, xmm2 }
    if ( (_WORD)_EAX )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsi+1815Ch]
        vmovups xmm1, xmmword ptr [rsi+1817Ch]
      }
      v31 = *(_DWORD *)&_RSI->weaponLatestPrimary.weaponCamo;
      __asm
      {
        vmovups ymmword ptr [rsi+18198h], ymm0
        vmovsd  xmm0, qword ptr [rsi+1818Ch]
        vmovups ymmword ptr [rsi+1815Ch], ymm2
        vmovups xmmword ptr [rsi+1817Ch], xmm3
        vmovups xmmword ptr [rsi+181B8h], xmm1
        vmovsd  qword ptr [rsi+1818Ch], xmm4
        vmovsd  qword ptr [rsi+181C8h], xmm0
      }
      *(_DWORD *)&_RSI->weaponLatestPrimary.weaponCamo = v27;
      *(_DWORD *)&_RSI->weaponPrevPrimary.weaponCamo = v31;
    }
    ControllerFromClient = CL_Mgr_GetControllerFromClient((LocalClientNum_t)v4);
    ModelForController = LUI_Model_GetModelForController(ControllerFromClient);
    ModelFromPath = LUI_Model_CreateModelFromPath(ModelForController, "cg.player.currentWeapon.shotCounter");
    LUI_Model_SetInt(ModelFromPath, 0);
    if ( !BG_HasUnderbarrelAmmo(&_RSI->weaponSelect) )
      useAltMode = 0;
    _RSI->weaponSelectInAlt = useAltMode;
    BG_ConvertWeaponToHexString(&_RSI->weaponSelect, outHexString, 121);
    Com_Printf(17, "CG_SelectWeapon: cgameGlob->weaponSelect is set to %s. Alt mode is %d\n", outHexString, (unsigned int)_RSI->weaponSelectInAlt);
    if ( v36 || !BG_IsAimDownSight(&_RSI->weaponSelect, _RSI->weaponSelectInAlt != 0) )
      CL_SetADS((LocalClientNum_t)v4, 0);
    return 1;
  }
  v10 = DVARBOOL_bg_highPriorityWeaponDebugPrint;
  if ( !DVARBOOL_bg_highPriorityWeaponDebugPrint && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_highPriorityWeaponDebugPrint") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v10);
  if ( !v10->current.enabled )
    return 0;
  v11 = BG_HighPriorityWeapon_Get(v8, &_RSI->predictedPlayerState);
  if ( v11->weaponIdx )
  {
    szInternalName = BG_WeaponCompleteDef(v11, 0)->szInternalName;
    v15 = BG_WeaponCompleteDef(_RDI, 0);
    Com_Printf(17, "HighPriorityDebug - CG_SelectWeapon: SelectWeapon for %s failed, CG_HighPriorityWeapon_IsWeaponSwitchAllowed returned false, highPriorityWeapon is %s\n", v15->szInternalName, szInternalName);
  }
  else
  {
    v12 = BG_WeaponCompleteDef(_RDI, 0);
    Com_Printf(17, "HighPriorityDebug - CG_SelectWeapon: SelectWeapon for %s failed, CG_HighPriorityWeapon_IsWeaponSwitchAllowed returned false, and highPriorityWeapon is null.\n", v12->szInternalName);
  }
  return 0;
}

/*
==============
CG_SetADSAltSwitchGlobals
==============
*/
void CG_SetADSAltSwitchGlobals(LocalClientNum_t localClientNum, const playerState_s *ps, const WeaponHand *weapHand, const Weapon *weapon, const bool isAlternate, cg_t *cgameGlob)
{
  int weaponState; 
  bool v18; 
  unsigned int v19; 
  bool v21; 
  char v22; 
  char v23; 
  bool v24; 
  bool v25; 
  bool v27; 
  int v28; 
  const WeaponAttachment *UnderbarrelAttachment; 
  bool adsAltSwitchIsMainToAlt; 
  char v36; 
  bool v37; 
  CgWeaponMap *Instance; 
  bool cgameGloba; 

  __asm { vmovaps [rsp+0B8h+var_78], xmm9 }
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8028, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  weaponState = ps->weapState[0].weaponState;
  v18 = weaponState == 3 || weaponState == 10;
  *(double *)&_XMM0 = XAnimGetWeight(weapHand->tree, 0, XANIM_SUBTREE_DEFAULT, 0x14Au);
  v19 = 327;
  __asm
  {
    vxorps  xmm9, xmm9, xmm9
    vcomiss xmm0, xmm9
  }
  v21 = !(v22 | v23);
  *(double *)&_XMM0 = XAnimGetWeight(weapHand->tree, 0, XANIM_SUBTREE_DEFAULT, 0x147u);
  __asm { vcomiss xmm0, xmm9 }
  v24 = !(v22 | v23);
  v25 = weaponState && (v21 || !(v22 | v23) || v18);
  _RSI = cgameGlob;
  cgameGloba = cgameGlob->adsAltSwitchInProgress;
  if ( v25 )
  {
    v27 = _RSI->playerWeaponInfo.isAlternate;
    __asm
    {
      vmovaps [rsp+0B8h+var_48], xmm6
      vmovaps [rsp+0B8h+var_68], xmm8
      vmovaps [rsp+0B8h+var_88], xmm10
    }
    if ( v21 || !(v22 | v23) )
    {
      if ( v27 )
      {
        if ( v22 | v23 )
          v19 = 330;
      }
      else if ( v21 )
      {
        v24 = 1;
        v19 = 330;
      }
      else
      {
        v24 = 0;
      }
      v21 = 1;
    }
    else
    {
      v28 = ps->weapState[0].weaponState;
      if ( v27 )
      {
        v24 = v28 == 3;
        if ( v28 != 3 )
          v19 = 330;
      }
      else
      {
        if ( v28 == 10 )
        {
          v24 = 1;
          v19 = 330;
        }
        else
        {
          v24 = 0;
        }
        v21 = 0;
      }
    }
    UnderbarrelAttachment = BG_GetUnderbarrelAttachment(weapon);
    if ( !UnderbarrelAttachment && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8124, ASSERT_TYPE_ASSERT, "(underBarrelAttachment)", (const char *)&queryFormat, "underBarrelAttachment") )
      __debugbreak();
    if ( !UnderbarrelAttachment->adsAltSwitch && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8125, ASSERT_TYPE_ASSERT, "(underBarrelAttachment->adsAltSwitch)", (const char *)&queryFormat, "underBarrelAttachment->adsAltSwitch") )
      __debugbreak();
    adsAltSwitchIsMainToAlt = _RSI->adsAltSwitchIsMainToAlt;
    __asm { vmovaps [rsp+0B8h+var_58], xmm7 }
    if ( v24 )
    {
      _RSI->adsAltSwitchIsMainToAlt = 1;
      _RAX = UnderbarrelAttachment->adsAltSwitch;
      __asm
      {
        vmovss  xmm7, dword ptr [rax]
        vmovss  xmm8, dword ptr [rax+4]
      }
    }
    else
    {
      _RSI->adsAltSwitchIsMainToAlt = 0;
      _RAX = UnderbarrelAttachment->adsAltSwitch;
      __asm
      {
        vmovss  xmm7, dword ptr [rax+10h]
        vmovss  xmm8, dword ptr [rax+14h]
      }
    }
    if ( v21 )
    {
      *(double *)&_XMM0 = XAnimGetTime(weapHand->tree, 0, XANIM_SUBTREE_DEFAULT, v19);
      __asm { vmovaps xmm10, xmm0 }
    }
    else
    {
      __asm { vxorps  xmm10, xmm10, xmm10 }
    }
    v36 = 0;
    v37 = !v21;
    if ( v21 )
    {
      *(double *)&_XMM0 = XAnimGetRate(weapHand->tree, 0, XANIM_SUBTREE_DEFAULT, v19);
      __asm { vmovaps xmm6, xmm0 }
      *(double *)&_XMM0 = XAnimGetLength(weapHand->tree->anims, v19);
      __asm
      {
        vmulss  xmm1, xmm0, xmm10
        vdivss  xmm2, xmm1, xmm6
      }
    }
    else
    {
      __asm { vxorps  xmm2, xmm2, xmm2 }
    }
    __asm
    {
      vcomiss xmm2, xmm8
      vmovss  xmm6, cs:__real@3f800000
    }
    if ( v36 | v37 )
    {
      __asm { vxorps  xmm0, xmm0, xmm0 }
    }
    else
    {
      __asm
      {
        vcomiss xmm7, xmm9
        vsubss  xmm0, xmm2, xmm8
        vminss  xmm1, xmm0, xmm7
      }
      if ( v36 | v37 )
        __asm { vmovaps xmm0, xmm6 }
      else
        __asm { vdivss  xmm0, xmm1, xmm7 }
    }
    __asm
    {
      vmovss  dword ptr [rsi+18278h], xmm0
      vmovaps xmm8, [rsp+0B8h+var_68]
    }
    _ER14 = 0;
    __asm { vmovaps xmm7, [rsp+0B8h+var_58] }
    if ( !cgameGloba || adsAltSwitchIsMainToAlt != _RSI->adsAltSwitchIsMainToAlt )
    {
      Instance = CgWeaponMap::GetInstance(localClientNum);
      _RSI->adsAltSwitchCurrentWeaponIsDualFOV = BG_HasDualFOV(Instance, ps, weapon, !v24);
      _RSI->adsAltSwitchNextWeaponIsDualFOV = BG_HasDualFOV(Instance, ps, weapon, v24);
      *(double *)&_XMM0 = CG_View_GetEffectiveFOVForWeapon(localClientNum, CG_FovSpace_Scene, weapon, !v24, 0, NULL);
      __asm { vmovss  dword ptr [rsi+18274h], xmm0 }
    }
    _EAX = v24;
    __asm
    {
      vmovd   xmm0, eax
      vmovd   xmm3, r14d
      vpcmpeqd xmm4, xmm0, xmm3
      vsubss  xmm5, xmm6, xmm10
      vblendvps xmm0, xmm10, xmm5, xmm4; val
      vmovaps xmm2, xmm6; max
      vxorps  xmm1, xmm1, xmm1; min
    }
    _RSI->adsAltSwitchInProgress = 1;
    *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
    __asm
    {
      vmovss  dword ptr [rsi+18270h], xmm0
      vmovaps xmm10, [rsp+0B8h+var_88]
      vmovaps xmm6, [rsp+0B8h+var_48]
    }
  }
  else
  {
    _ER14 = 0;
    *(_WORD *)&_RSI->adsAltSwitchNextWeaponIsDualFOV = 0;
    *(_QWORD *)&_RSI->adsAltSwitchBaseFOV = 0i64;
    _RSI->adsAltSwitchCurrentWeaponIsDualFOV = 0;
    _RSI->adsAltSwitchIsMainToAlt = 0;
    __asm { vmovd   xmm1, r14d }
    _EAX = BG_UsingAlternate(ps);
    __asm
    {
      vmovd   xmm0, eax
      vpcmpeqd xmm2, xmm0, xmm1
      vmovss  xmm1, cs:__real@3f800000
      vblendvps xmm0, xmm1, xmm9, xmm2
      vmovss  dword ptr [rsi+18270h], xmm0
    }
  }
  __asm { vmovaps xmm9, [rsp+0B8h+var_78] }
}

/*
==============
CG_SetViewModelPose
==============
*/
void CG_SetViewModelPose(const cg_t *cgameGlob, const bool sendingToRenderer, cpose_t *pose)
{
  const tmat33_t<vec3_t> *ViewModelTransform; 
  const dvar_t *v7; 
  void (__fastcall *v33)(const vec3_t *, vec4_t *); 
  vec3_t outOrg; 
  __int64 v38; 
  int v39; 
  int v40; 
  int v41; 

  v38 = -2i64;
  _RDI = pose;
  _RSI = (cg_t *)cgameGlob;
  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 14552, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 14553, ASSERT_TYPE_ASSERT, "(pose)", (const char *)&queryFormat, "pose") )
    __debugbreak();
  ViewModelTransform = (const tmat33_t<vec3_t> *)cg_t::GetViewModelTransform(_RSI);
  AxisToAngles(ViewModelTransform, &_RDI->angles);
  v7 = DVARBOOL_cg_enableViewModelMotionPrecisionFix;
  if ( !DVARBOOL_cg_enableViewModelMotionPrecisionFix && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_enableViewModelMotionPrecisionFix") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v7);
  if ( sendingToRenderer && v7->current.enabled )
  {
    RefdefView_GetOrg(&_RSI->refdef.view, &outOrg);
    __asm
    {
      vmovss  xmm0, dword ptr [rsp+98h+outOrg]
      vcvtss2sd xmm0, xmm0, xmm0
      vmovss  xmm1, dword ptr [rsp+98h+outOrg+4]
      vcvtss2sd xmm1, xmm1, xmm1
      vmovss  xmm2, dword ptr [rsp+98h+outOrg+8]
      vcvtss2sd xmm2, xmm2, xmm2
      vaddsd  xmm3, xmm0, qword ptr [rsi+4A320h]
      vaddsd  xmm4, xmm1, qword ptr [rsi+4A328h]
      vaddsd  xmm5, xmm2, qword ptr [rsi+4A330h]
      vmovss  xmm0, dword ptr [rsi+4A338h]
      vcvtss2sd xmm0, xmm0, xmm0
      vmovss  xmm1, dword ptr [rsi+4A33Ch]
      vcvtss2sd xmm1, xmm1, xmm1
      vmovss  xmm2, dword ptr [rsi+4A340h]
      vcvtss2sd xmm2, xmm2, xmm2
      vaddsd  xmm3, xmm0, xmm3
      vaddsd  xmm4, xmm1, xmm4
      vaddsd  xmm5, xmm2, xmm5
      vmovsd  xmm2, cs:__real@40b0000000000000
      vmulsd  xmm0, xmm3, xmm2
      vcvttsd2si eax, xmm0
    }
    v39 = _EAX;
    __asm
    {
      vmulsd  xmm1, xmm4, xmm2
      vcvttsd2si eax, xmm1
    }
    v40 = _EAX;
    __asm
    {
      vmulsd  xmm0, xmm5, xmm2
      vcvttsd2si eax, xmm0
    }
    v41 = _EAX;
    _RDI->isPosePrecise = 1;
    if ( !_RDI->origin.Set_origin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_pose.h", 494, ASSERT_TYPE_ASSERT, "(pose->origin.Set_origin)", (const char *)&queryFormat, "pose->origin.Set_origin") )
      __debugbreak();
    if ( !_RDI->isPosePrecise && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_pose.h", 495, ASSERT_TYPE_ASSERT, "(pose->isPosePrecise != 0)", (const char *)&queryFormat, "pose->isPosePrecise != 0") )
      __debugbreak();
    if ( _RDI->isEntityPose )
    {
      CG_Pose_ValidateSetEntityPoseOrigin(_RDI);
      _RDI->entOriginSet = 1;
      _RDI->hasStaleEntityPose = 1;
    }
    v33 = ObfuscateSetFunctionPointer_origin(_RDI->origin.Set_origin, _RDI);
    v33((const vec3_t *)&v39, &_RDI->origin.origin.origin);
    __asm
    {
      vmovss  xmm0, [rsp+98h+var_40]
      vmovss  dword ptr [rdi+1Ch], xmm0
      vmovss  xmm1, [rsp+98h+var_3C]
      vmovss  dword ptr [rdi+20h], xmm1
      vmovss  xmm0, [rsp+98h+var_38]
      vmovss  dword ptr [rdi+24h], xmm0
    }
    memset(&outOrg, 0, sizeof(outOrg));
  }
  else
  {
    _RDI->isPosePrecise = 0;
    CG_SetPoseOrigin(_RDI, ViewModelTransform[1].m);
  }
}

/*
==============
CG_SetupAndValidateConeVars
==============
*/
__int64 CG_SetupAndValidateConeVars(const LocalClientNum_t localClientNum, const centity_t *cent, MissileConeSoundVars *mcv)
{
  __int64 v8; 
  const Weapon *WeaponForEntity; 
  const char *name; 
  bool missileConeSoundCrossfadeEnabled; 
  bool v24; 
  const char *WeaponName; 
  const char *v33; 
  bool v34; 
  const char *v39; 
  const char *v40; 
  unsigned __int8 v41; 
  const char *v42; 
  __int64 result; 
  vec3_t outOrigin; 
  __int64 v48; 
  tmat33_t<vec3_t> axis; 
  char output[1024]; 
  char v51; 
  void *retaddr; 

  _RAX = &retaddr;
  v48 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm6
    vmovaps xmmword ptr [rax-48h], xmm7
  }
  _RDI = mcv;
  v8 = localClientNum;
  if ( !cent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21818, ASSERT_TYPE_ASSERT, "(cent)", (const char *)&queryFormat, "cent") )
    __debugbreak();
  if ( (cent->flags & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21819, ASSERT_TYPE_ASSERT, "(CENextValid( cent ))", (const char *)&queryFormat, "CENextValid( cent )") )
    __debugbreak();
  if ( cent->nextState.eType != ET_MISSILE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21820, ASSERT_TYPE_ASSERT, "(cent->nextState.eType == ET_MISSILE)", (const char *)&queryFormat, "cent->nextState.eType == ET_MISSILE") )
    __debugbreak();
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21821, ASSERT_TYPE_ASSERT, "(mcv)", (const char *)&queryFormat, "mcv") )
    __debugbreak();
  if ( !CgWeaponMap::ms_instance[v8] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  WeaponForEntity = BG_GetWeaponForEntity(CgWeaponMap::ms_instance[v8], &cent->nextState);
  _RBP = BG_WeaponDef(WeaponForEntity, 0);
  if ( !_RBP->missileConeSoundEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21825, ASSERT_TYPE_ASSERT, "(weapDef->missileConeSoundEnabled)", (const char *)&queryFormat, "weapDef->missileConeSoundEnabled") )
    __debugbreak();
  AnglesToAxis(&cent->pose.angles, &axis);
  __asm
  {
    vmovss  xmm0, dword ptr [rsp+4C8h+axis]
    vmovss  dword ptr [rdi+0Ch], xmm0
    vmovss  xmm1, dword ptr [rsp+4C8h+axis+4]
    vmovss  dword ptr [rdi+10h], xmm1
    vmovss  xmm0, dword ptr [rsp+4C8h+axis+8]
    vmovss  dword ptr [rdi+14h], xmm0
  }
  CG_GetPoseOrigin(&cent->pose, &outOrigin);
  __asm
  {
    vmovss  xmm3, dword ptr [rbp+0E5Ch]
    vmulss  xmm0, xmm3, dword ptr [rsp+4C8h+axis]
    vaddss  xmm1, xmm0, dword ptr [rsp+4C8h+outOrigin]
    vmovss  dword ptr [rdi], xmm1
    vmulss  xmm2, xmm3, dword ptr [rsp+4C8h+axis+4]
    vaddss  xmm0, xmm2, dword ptr [rsp+4C8h+outOrigin+4]
    vmovss  dword ptr [rdi+4], xmm0
    vmulss  xmm1, xmm3, dword ptr [rsp+4C8h+axis+8]
    vaddss  xmm2, xmm1, dword ptr [rsp+4C8h+outOrigin+8]
    vmovss  dword ptr [rdi+8], xmm2
  }
  SND_FindAlias(_RBP->missileConeSoundAlias.name);
  SND_FindAlias(_RBP->missileConeSoundAliasAtBase.name);
  _RDI->alias = _RBP->missileConeSoundAlias.name;
  name = _RBP->missileConeSoundAliasAtBase.name;
  _RDI->aliasAtBase = name;
  _RDI->radiusAtTop = _RBP->missileConeSoundRadiusAtTop;
  _RDI->radiusAtBase = _RBP->missileConeSoundRadiusAtBase;
  _RDI->height = _RBP->missileConeSoundHeight;
  _RDI->volumescaleAtCore = _RBP->missileConeSoundVolumescaleAtCore;
  _RDI->volumescaleAtEdge = _RBP->missileConeSoundVolumescaleAtEdge;
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+0E68h]
    vmovss  dword ptr [rdi+3Ch], xmm0
  }
  _RDI->pitchshiftEnabled = _RBP->missileConeSoundPitchshiftEnabled;
  _RDI->pitchAtTop = _RBP->missileConeSoundPitchAtTop;
  _RDI->pitchAtBottom = _RBP->missileConeSoundPitchAtBottom;
  _RDI->pitchTopSize = _RBP->missileConeSoundPitchTopSize;
  _RDI->pitchBottomSize = _RBP->missileConeSoundPitchBottomSize;
  missileConeSoundCrossfadeEnabled = _RBP->missileConeSoundCrossfadeEnabled;
  v24 = missileConeSoundCrossfadeEnabled;
  _RDI->crossfadeEnabled = missileConeSoundCrossfadeEnabled;
  _RDI->crossfadeTopSize = _RBP->missileConeSoundCrossfadeTopSize;
  _RDI->crossfadeBottomSize = _RBP->missileConeSoundCrossfadeBottomSize;
  if ( missileConeSoundCrossfadeEnabled && !name )
  {
    WeaponName = BG_GetWeaponName(WeaponForEntity, output, 0x400u);
    Com_PrintWarning(14, "Weapon \"%s\" has invalid missile cone crossfade settings.  Crossfade is enabled, but no second sound was given.\n", WeaponName);
    _RDI->crossfadeEnabled = 0;
    __asm { vmovss  xmm0, dword ptr [rdi+3Ch] }
    v24 = 0;
  }
  __asm
  {
    vxorps  xmm7, xmm7, xmm7
    vmovss  xmm6, cs:__real@3f800000
    vcomiss xmm0, xmm7
    vcomiss xmm0, xmm6
  }
  if ( v24 )
  {
    __asm
    {
      vmovss  xmm1, dword ptr [rdi+58h]
      vcomiss xmm1, xmm7
      vcomiss xmm1, xmm6
    }
    _RDI->crossfadeTopSize = 1.0;
    __asm
    {
      vmovaps xmm1, xmm6
      vmovss  xmm0, dword ptr [rdi+5Ch]
      vcomiss xmm0, xmm7
      vcomiss xmm0, xmm6
    }
    _RDI->crossfadeBottomSize = 1.0;
    __asm
    {
      vmovaps xmm0, xmm6
      vaddss  xmm0, xmm0, xmm1
      vcomiss xmm0, xmm6
    }
    v33 = BG_GetWeaponName(WeaponForEntity, output, 0x400u);
    Com_PrintWarning(14, "Weapon \"%s\" has invalid missile cone crossfade settings.  The top/bottom regions would overlap.\n", v33);
    _RDI->crossfadeEnabled = 0;
    *(_QWORD *)&_RDI->crossfadeTopSize = 0i64;
  }
  v34 = !_RDI->pitchshiftEnabled;
  if ( _RDI->pitchshiftEnabled )
  {
    __asm
    {
      vmovss  xmm1, dword ptr [rdi+4Ch]
      vcomiss xmm1, xmm7
      vcomiss xmm1, xmm6
    }
    if ( _RDI->pitchshiftEnabled )
    {
      _RDI->pitchTopSize = 1.0;
      __asm { vmovaps xmm1, xmm6 }
    }
    __asm
    {
      vmovss  xmm0, dword ptr [rdi+50h]
      vcomiss xmm0, xmm7
      vcomiss xmm0, xmm6
    }
    if ( !v34 )
    {
      _RDI->pitchBottomSize = 1.0;
      __asm { vmovaps xmm0, xmm6 }
    }
    __asm
    {
      vaddss  xmm0, xmm0, xmm1
      vcomiss xmm0, xmm6
    }
    if ( !v34 )
    {
      v39 = BG_GetWeaponName(WeaponForEntity, output, 0x400u);
      Com_PrintWarning(14, "Weapon \"%s\" has invalid missile cone pitch-shift settings.  The top/bottom regions would overlap.\n", v39);
      _RDI->pitchshiftEnabled = 0;
      *(_QWORD *)&_RDI->crossfadeTopSize = 0i64;
    }
  }
  if ( _RDI->alias )
  {
    __asm { vucomiss xmm7, dword ptr [rdi+30h] }
    if ( _RDI->alias )
    {
      v41 = 1;
    }
    else
    {
      v42 = BG_GetWeaponName(WeaponForEntity, output, 0x400u);
      Com_PrintWarning(14, "Weapon \"%s\" has invalid missile cone height settings.  Zero height is invalid.\n", v42);
      v41 = 0;
    }
  }
  else
  {
    v40 = BG_GetWeaponName(WeaponForEntity, output, 0x400u);
    Com_PrintWarning(14, "Weapon \"%s\" has invalid missile cone height settings.  No sound is available to play.\n", v40);
    v41 = 0;
  }
  memset(&outOrigin, 0, sizeof(outOrigin));
  result = v41;
  _R11 = &v51;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
  }
  return result;
}

/*
==============
CG_ShouldClearAnim
==============
*/
bool CG_ShouldClearAnim(LocalClientNum_t localClientNum, const playerState_s *ps, weapAnimFiles_t anim)
{
  cg_t *LocalClientGlobals; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2426, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  return (unsigned int)(anim - 175) > 1 && CG_CanModifyAnimWeight(ps, anim) && ((unsigned int)(anim - 15) > 0xC && (unsigned int)(anim - 123) > 0x27 && (unsigned int)(anim - 2) > 3 || !BG_Gesture_IsPlaying(ps, LocalClientGlobals->time, 0));
}

/*
==============
CG_ShouldTriggerOffhandShield
==============
*/
bool CG_ShouldTriggerOffhandShield(LocalClientNum_t localClientNum, int sourceEntityNum)
{
  cg_t *LocalClientGlobals; 
  CgHandler *Handler; 
  int clientNum; 
  CgHandler *v7; 
  team_t team; 
  CgStatic *LocalClientStatics; 
  const cg_t *v10; 
  const characterInfo_t *CharacterInfo; 
  int v13; 
  int v14; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  Handler = CgHandler::getHandler(localClientNum);
  clientNum = LocalClientGlobals->clientNum;
  v7 = Handler;
  team = TEAM_ZERO;
  LocalClientStatics = CgStatic::GetLocalClientStatics((const LocalClientNum_t)Handler->m_localClientNum);
  v10 = CG_GetLocalClientGlobals((const LocalClientNum_t)LocalClientStatics->m_localClientNum);
  if ( !v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_static_inline.h", 33, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  CharacterInfo = CG_GetCharacterInfo(v10, clientNum);
  if ( CharacterInfo )
    team = CharacterInfo->team;
  v13 = 0;
  v14 = sourceEntityNum;
  v7->GetEntityTeam(v7, (team_t *)&v13, sourceEntityNum, (unsigned int *)&v14);
  return team == v13 && team;
}

/*
==============
CG_SmoothOutWeaponPos
==============
*/

void __fastcall CG_SmoothOutWeaponPos(const int time, double weaponPosFrac, WeaponPosFracAnimationData *const weaponPosFracAnimData, const bool isReloading, const bool isAdsUp)
{
  const dvar_t *v8; 
  char v23; 

  v8 = DCONST_DVARMODEBOOL_adsPredictionSmoothingEnabled;
  __asm { vmovaps [rsp+78h+var_18], xmm6 }
  _RBX = weaponPosFracAnimData;
  __asm { vmovaps xmm6, xmm1 }
  if ( !DCONST_DVARMODEBOOL_adsPredictionSmoothingEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "adsPredictionSmoothingEnabled") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v8);
  if ( v8->current.enabled )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rbx]
      vcomiss xmm0, cs:MIN_ADS_FRAC_FOR_CORRECTION
      vmovaps [rsp+78h+var_28], xmm7
    }
    if ( _RBX->wasAdsUp && !_RBX->interpStartTime && isReloading && !isAdsUp )
    {
      __asm
      {
        vsubss  xmm0, xmm0, xmm6
        vmovss  dword ptr [rbx+0Ch], xmm0
      }
      _RBX->interpStartTime = time;
    }
    __asm { vmovaps xmm7, xmm6 }
    if ( _RBX->interpStartTime > 0 )
    {
      __asm
      {
        vxorps  xmm1, xmm1, xmm1
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm0, xmm0, cs:ADS_FRAC_CATCH_UP_TIME
        vmovaps [rsp+78h+var_38], xmm8
        vmovss  xmm8, cs:__real@3f800000
        vcvtsi2ss xmm1, xmm1, esi
        vdivss  xmm0, xmm1, xmm0; val
        vxorps  xmm1, xmm1, xmm1; min
        vmovaps xmm2, xmm8; max
      }
      *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
      __asm { vucomiss xmm0, xmm8 }
      if ( v23 )
      {
        _RBX->interpStartTime = 0;
      }
      else
      {
        __asm
        {
          vsubss  xmm0, xmm8, xmm0
          vmulss  xmm3, xmm0, dword ptr [rbx+0Ch]
          vaddss  xmm0, xmm3, xmm6; val
          vmovaps xmm2, xmm8; max
          vxorps  xmm1, xmm1, xmm1; min
        }
        *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
        __asm { vmovaps xmm7, xmm0 }
      }
      __asm { vmovaps xmm8, [rsp+78h+var_38] }
    }
    __asm { vmovss  dword ptr [rbx], xmm6 }
    _RBX->wasAdsUp = isAdsUp;
    __asm
    {
      vmovss  dword ptr [rbx+4], xmm7
      vmovaps xmm7, [rsp+78h+var_28]
    }
  }
  else
  {
    __asm { vmovss  dword ptr [rbx+4], xmm6 }
  }
  __asm { vmovaps xmm6, [rsp+78h+var_18] }
}

/*
==============
CG_SmoothOutWeaponPosFracForMispredictionErrors
==============
*/
void CG_SmoothOutWeaponPosFracForMispredictionErrors(const LocalClientNum_t localClientNum)
{
  __int64 v2; 
  CgWeaponMap *v4; 
  const Weapon *ViewmodelWeapon; 
  bool v6; 
  bool v7; 
  bool v8; 
  bool v9; 
  bool v10; 
  bool v12; 

  v2 = localClientNum;
  _RSI = CG_GetLocalClientGlobals(localClientNum);
  if ( !_RSI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8522, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( !CgWeaponMap::ms_instance[v2] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v4 = CgWeaponMap::ms_instance[v2];
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8527, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  ViewmodelWeapon = BG_GetViewmodelWeapon(v4, &_RSI->predictedPlayerState);
  v6 = BG_UsingAlternate(&_RSI->predictedPlayerState);
  v7 = (unsigned int)(_RSI->predictedPlayerState.weapState[0].weaponState - 18) <= 3;
  v8 = v6;
  v9 = CG_Weapons_IsInAds((const LocalClientNum_t)v2, v4, &_RSI->predictedPlayerState, ViewmodelWeapon, v6, WEAPON_HAND_DEFAULT);
  v10 = BG_ADSReloadEnabled(v4, &_RSI->predictedPlayerState, ViewmodelWeapon, v8);
  __asm { vmovss  xmm1, dword ptr [rsi+738h]; weaponPosFrac }
  v12 = v10;
  CG_SmoothOutWeaponPos(_RSI->time, *(double *)&_XMM1, &_RSI->weaponPosFracAnimData, v7, v9);
  *(double *)&_XMM0 = BG_WeaponADSFractionAffectedByReload(v4, &_RSI->predictedPlayerState);
  if ( v12 )
  {
    __asm { vmovss  dword ptr [rsi+7C660h], xmm0 }
  }
  else
  {
    __asm { vmovaps xmm1, xmm0; weaponPosFrac }
    CG_SmoothOutWeaponPos(_RSI->time, *(double *)&_XMM1, &_RSI->weaponPosFracNotReloadingAnimData, v7, v9);
  }
}

/*
==============
CG_SndAutoSimEntLastBurst
==============
*/
void CG_SndAutoSimEntLastBurst(const centity_t *ent, const PlayerHandIndex hand)
{
  int *p_entNum; 
  __int64 v5; 

  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22992, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  p_entNum = &s_snd_autosims[0].shot.entNum;
  v5 = 0i64;
  while ( !p_entNum[42] || *p_entNum != ent->nextState.number || p_entNum[23] != hand || p_entNum[45] != 2 )
  {
    v5 = (unsigned int)(v5 + 1);
    p_entNum += 48;
    if ( (unsigned int)v5 >= 0x40 )
      return;
  }
  s_snd_autosims[v5].shot.isLastBurst = 1;
}

/*
==============
CG_SndAutoSimReset
==============
*/
void CG_SndAutoSimReset(void)
{
  memset_0(s_snd_autosims, 0, sizeof(s_snd_autosims));
  s_autosim_time = Sys_Microseconds();
}

/*
==============
CG_SndKillAutoSimEnt
==============
*/
void CG_SndKillAutoSimEnt(centity_t *ent, bool bKillAggressively)
{
  int number; 
  int *p_used; 
  unsigned int i; 

  number = ent->nextState.number;
  p_used = &s_snd_autosims[0].used;
  for ( i = 0; i < 0x40; ++i )
  {
    if ( *p_used && *(p_used - 42) == number )
    {
      *((_BYTE *)p_used + 17) = 1;
      if ( bKillAggressively )
      {
        *p_used = 0;
        SND_StopAutoSim(i);
      }
    }
    p_used += 48;
  }
}

/*
==============
CG_SndKillAutoSimEntNum
==============
*/
void CG_SndKillAutoSimEntNum(int entityNum, bool bKillAggressively)
{
  int *p_used; 
  unsigned int i; 

  p_used = &s_snd_autosims[0].used;
  for ( i = 0; i < 0x40; ++i )
  {
    if ( *p_used && *(p_used - 42) == entityNum )
    {
      *((_BYTE *)p_used + 17) = 1;
      if ( bKillAggressively )
      {
        *p_used = 0;
        SND_StopAutoSim(i);
      }
    }
    p_used += 48;
  }
}

/*
==============
CG_SndPingAutoSim
==============
*/
void CG_SndPingAutoSim(LocalClientNum_t localClientNum, centity_t *cent, Weapon *weapon, const scr_string_t tagName, bool isPlayerView, bool isAlternate, bool isPlayerHeli, bool isDualWield, bool useLastFireSound, bool isAlternatingFire, PlayerHandIndex hand, bool fireContinuously, const GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64> *pm_flags)
{
  __int64 v18; 
  unsigned int v20; 
  entityState_t *p_nextState; 
  bool *p_kill; 
  unsigned __int16 weaponIdx; 
  __int64 v24; 
  bool v25; 
  bool v26; 
  const WeaponCompleteDef *PointerToWeaponCompleteDefConst; 
  playerState_s *p_predictedPlayerState; 
  int shotCount; 
  bool v30; 
  const HyperBurstInfo *HyperBurstInfo; 
  unsigned __int8 v32; 
  unsigned int AllWeaponAttachments; 
  unsigned int v34; 
  WeaponAttachment **v35; 
  AttAmmoGeneral *ammogeneral; 
  bool v37; 
  snd_autosim *v38; 
  bool *p_isHyperBurst; 
  bool v40; 
  weapFireType_t fireType; 
  const HyperBurstInfo *v42; 
  bool v43; 
  __int64 v50; 
  const WeaponSFXPackage *SfxPackage; 
  int v61; 
  const centity_t *v62; 
  LocalClientNum_t v63; 
  CgWeaponSystem *WeaponSystem; 
  const centity_t *v65; 
  scr_string_t secondTagName; 
  PlayerHandIndex secondHand; 
  float v74; 
  float v75; 
  int index; 
  int fireTime; 
  snd_autosim *v80; 
  cpose_t *pose; 
  vec3_t outOrigin; 
  GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64> *v83; 
  vec3_t from; 
  unsigned __int64 v85; 
  int fireDelay; 
  __int64 v87; 
  WeaponAttachment *attachments[30]; 

  v87 = -2i64;
  __asm { vmovaps [rsp+248h+var_58], xmm6 }
  _R12 = weapon;
  pose = &cent->pose;
  v18 = localClientNum;
  v83 = (GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64> *)pm_flags;
  if ( !cent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22711, ASSERT_TYPE_ASSERT, "(cent)", (const char *)&queryFormat, "cent") )
    __debugbreak();
  if ( (cent->flags & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22712, ASSERT_TYPE_ASSERT, "(CENextValid( cent ))", (const char *)&queryFormat, "CENextValid( cent )") )
    __debugbreak();
  _RSI = NULL;
  v80 = NULL;
  index = -1;
  v20 = 0;
  p_nextState = &cent->nextState;
  p_kill = &s_snd_autosims[0].kill;
  while ( 1 )
  {
    if ( !*(_DWORD *)(p_kill - 17) )
    {
      if ( !_RSI )
      {
        _RSI = &s_snd_autosims[v20];
        index = v20;
      }
      goto LABEL_26;
    }
    if ( isAlternatingFire )
      break;
    if ( !*p_kill && *(_DWORD *)(p_kill - 185) == p_nextState->number && *(_WORD *)(p_kill - 181) == _R12->weaponIdx && *(_DWORD *)(p_kill - 97) == tagName && *(_DWORD *)(p_kill - 93) == hand && *(_DWORD *)(p_kill - 189) == (_DWORD)v18 )
    {
      v80 = &s_snd_autosims[v20];
      goto LABEL_41;
    }
LABEL_26:
    ++v20;
    p_kill += 192;
    if ( v20 >= 0x40 )
      goto LABEL_42;
  }
  if ( *p_kill )
    goto LABEL_26;
  if ( *(_DWORD *)(p_kill - 185) != p_nextState->number )
    goto LABEL_26;
  weaponIdx = _R12->weaponIdx;
  if ( *(_WORD *)(p_kill - 181) != _R12->weaponIdx || *(_DWORD *)(p_kill - 189) != (_DWORD)v18 || !*(p_kill - 75) )
    goto LABEL_26;
  v24 = v20;
  v80 = &s_snd_autosims[v24];
  v25 = s_snd_autosims[v24].shot.tagName == tagName && s_snd_autosims[v24].shot.hand == hand;
  v26 = s_snd_autosims[v24].shot.secondTagName == tagName && s_snd_autosims[v24].shot.secondHand == hand;
  if ( !v25 && !v26 )
  {
    PointerToWeaponCompleteDefConst = BG_GetPointerToWeaponCompleteDefConst(weaponIdx);
    if ( (s_snd_autosims[v24].shot.secondTagName || s_snd_autosims[v24].shot.secondHand != NUM_WEAPON_HANDS) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22747, ASSERT_TYPE_ASSERT, "((shot->secondTagName == ( static_cast< scr_string_t >( 0 ) ) && shot->secondHand == NUM_WEAPON_HANDS))", "%s\n\tEntity (%i) weapon (%s) configured to use turret alternating fire mode, but more than two muzzle tags were used.", "(shot->secondTagName == NULL_SCR_STRING && shot->secondHand == NUM_WEAPON_HANDS)", p_nextState->number, PointerToWeaponCompleteDefConst->szInternalName) )
      __debugbreak();
    s_snd_autosims[v24].shot.secondTagName = tagName;
    s_snd_autosims[v24].shot.secondHand = hand;
  }
LABEL_41:
  index = v20;
LABEL_42:
  p_predictedPlayerState = NULL;
  shotCount = 0;
  v30 = isPlayerView;
  if ( isPlayerView )
  {
    p_predictedPlayerState = &CG_GetLocalClientGlobals((const LocalClientNum_t)v18)->predictedPlayerState;
    shotCount = p_predictedPlayerState->weapState[hand].weaponShotCount;
  }
  if ( !CgWeaponMap::ms_instance[v18] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  BG_GetFireTime(CgWeaponMap::ms_instance[v18], p_predictedPlayerState, _R12, isAlternate, 0, shotCount, &fireTime, &fireDelay);
  v85 = 1000 * fireTime;
  HyperBurstInfo = BG_GetHyperBurstInfo(_R12, isAlternate);
  if ( !HyperBurstInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22659, ASSERT_TYPE_ASSERT, "(hyperBurstInfo)", (const char *)&queryFormat, "hyperBurstInfo") )
    __debugbreak();
  if ( HyperBurstInfo->enabled || (BG_WeaponDef(_R12, isAlternate)->fireType & 0xFFFFFFFD) == 0 )
  {
    v32 = 1;
  }
  else
  {
    v32 = 0;
    AllWeaponAttachments = BG_GetAllWeaponAttachments(_R12, (const WeaponAttachment **)attachments);
    v34 = 0;
    if ( AllWeaponAttachments )
    {
      v35 = attachments;
      while ( 1 )
      {
        if ( !*v35 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22674, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
          __debugbreak();
        ammogeneral = (*v35)->ammogeneral;
        if ( ammogeneral )
        {
          if ( (ammogeneral->fireType & 0xFFFFFFFD) == 0 )
            break;
        }
        ++v34;
        ++v35;
        v32 = 0;
        if ( v34 >= AllWeaponAttachments )
          goto LABEL_63;
      }
      v32 = 1;
    }
LABEL_63:
    LODWORD(v18) = localClientNum;
  }
  v37 = fireContinuously;
  v38 = v80;
  if ( v80 )
  {
    if ( !v80->used && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22795, ASSERT_TYPE_ASSERT, "(found_sim->used)", (const char *)&queryFormat, "found_sim->used") )
      __debugbreak();
    _RSI = v38;
    p_isHyperBurst = &v38->isHyperBurst;
    if ( v38->isHyperBurst && !v38->processedHyperBurstRound )
    {
      v38->processedHyperBurstRound = 1;
      goto LABEL_122;
    }
    v63 = localClientNum;
  }
  else
  {
    if ( !_RSI )
    {
      Com_Printf(9, "WARNING: ran out of automatic sims??? (max %d)\n", 64i64);
      __asm
      {
        vxorps  xmm0, xmm0, xmm0
        vmovss  [rsp+248h+var_1E8], xmm0
      }
      CG_FireWeapSound((const LocalClientNum_t)v18, (centity_t *)pose, _R12, tagName, isPlayerView, isAlternate, isPlayerHeli, isDualWield, useLastFireSound, hand, -1, 0i64, v75, (const SndWeapShotCountId)v32, v83);
      goto LABEL_122;
    }
    if ( _RSI->used && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22809, ASSERT_TYPE_ASSERT, "(!free_sim->used)", (const char *)&queryFormat, "!free_sim->used") )
      __debugbreak();
    _RSI->fireType = BG_GetWeaponFireType(_R12, isAlternate);
    if ( isPlayerView || Com_GameMode_SupportsFeature(WEAPON_INSPECT|0x80) )
    {
      fireType = _RSI->fireType;
      v40 = ((fireType - 1) & 0xFFFFFFFC) == 0 && fireType != WEAPON_FIRETYPE_BURST;
    }
    else
    {
      v40 = !fireContinuously;
    }
    v42 = BG_GetHyperBurstInfo(_R12, isAlternate);
    if ( !v42 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22825, ASSERT_TYPE_ASSERT, "(hyperBurstInfo)", (const char *)&queryFormat, "hyperBurstInfo") )
      __debugbreak();
    if ( v40 && !v42->enabled || v85 >= 0x493E0 || !fireTime )
    {
      __asm
      {
        vxorps  xmm0, xmm0, xmm0
        vmovss  [rsp+248h+var_1E8], xmm0
      }
      CG_FireWeapSound((const LocalClientNum_t)v18, (centity_t *)pose, _R12, tagName, isPlayerView, isAlternate, isPlayerHeli, isDualWield, useLastFireSound, hand, -1, 0i64, v74, (const SndWeapShotCountId)v32, v83);
      goto LABEL_122;
    }
    v43 = _RSI->fireType == WEAPON_FIRETYPE_FULLAUTO && !useLastFireSound;
    _RDI = DCONST_DVARFLT_snd_autoSim_predictWindowMs;
    if ( !DCONST_DVARFLT_snd_autoSim_predictWindowMs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_autoSim_predictWindowMs") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RDI);
    __asm
    {
      vmovss  xmm0, dword ptr [rdi+28h]
      vmulss  xmm1, xmm0, cs:__real@447a0000
      vmovss  xmm2, cs:__real@5f000000
      vcomiss xmm1, xmm2
      vsubss  xmm1, xmm1, xmm2
      vcomiss xmm1, xmm2
      vcvttss2si rbx, xmm1
    }
    v50 = 2 * _RBX;
    if ( !v43 )
      v50 = 0i64;
    if ( isPlayerView || isPlayerHeli )
    {
      __asm { vxorps  xmm6, xmm6, xmm6 }
    }
    else
    {
      CG_GetPoseOrigin(pose, &outOrigin);
      *(double *)&_XMM0 = SND_DistSqToNearestListener(&outOrigin);
      __asm { vmovaps xmm6, xmm0 }
      SfxPackage = BG_GetSfxPackage(_R12, isAlternate);
      _RAX = SND_GetWhizby(SfxPackage);
      __asm { vxorps  xmm2, xmm2, xmm2 }
      if ( _RAX )
        __asm { vmovss  xmm1, dword ptr [rax+80h] }
      else
        __asm { vxorps  xmm1, xmm1, xmm1 }
      __asm { vcomiss xmm1, xmm2 }
      if ( _RAX )
      {
        __asm
        {
          vsqrtss xmm2, xmm6, xmm6
          vmovss  xmm0, cs:__real@49742400
          vdivss  xmm1, xmm0, xmm1
          vmulss  xmm2, xmm2, xmm1
          vcvttss2si eax, xmm2
        }
        v50 += _EAX;
      }
      memset(&outOrigin, 0, sizeof(outOrigin));
    }
    _RSI->time = 0i64;
    _RSI->nextStamp = v50;
    __asm { vmovss  dword ptr [rsi+0A8h], xmm6 }
    _RSI->used = 1;
    *(_QWORD *)&_RSI->shotCount = 0i64;
    v61 = s_snd_autosim_next_id++;
    _RSI->autoSimId = SND_CreateAutoSimId(index, v61);
    _RSI->countShots = v32;
    p_isHyperBurst = &_RSI->isHyperBurst;
    _RSI->isHyperBurst = v42->enabled;
    _RSI->processedHyperBurstRound = 0;
    _RSI->kill = 0;
    _RSI->shot.tagName = tagName;
    _RSI->shot.hand = hand;
    _RSI->shot.fireSecondTag = 0;
    _RSI->shot.secondTagName = 0;
    _RSI->shot.secondHand = NUM_WEAPON_HANDS;
    *(_WORD *)&_RSI->shot.isLastBurst = 0;
    v62 = (const centity_t *)pose;
    v63 = localClientNum;
    if ( BG_IsCharacterEntity((const entityState_t *)&pose[1].prevOrigin.prevOrigin.xyz.z) )
    {
      WeaponSystem = CgWeaponSystem::GetWeaponSystem(localClientNum);
      CG_GetPoseOrigin(&v62->pose, &outOrigin);
      if ( WeaponSystem->ShouldWeaponPing(WeaponSystem, v62, _R12, isAlternate, &outOrigin) )
        CG_SndPingCompass(localClientNum, v62, _R12, isAlternate, &outOrigin);
      memset(&outOrigin, 0, sizeof(outOrigin));
    }
    v37 = fireContinuously;
    v30 = isPlayerView;
    v38 = v80;
  }
  if ( !*p_isHyperBurst || !v38 || _RSI->processedHyperBurstRound )
  {
    _RSI->lastPing = 0i64;
    _RSI->fireContinuously = v37;
    _RSI->fireTime = v85;
    ++_RSI->requestedShotCount;
    _RSI->shot.localClientNum = v63;
    v65 = (const centity_t *)pose;
    _RSI->shot.entNum = SLOWORD(pose[1].prevOrigin.prevOrigin.xyz.z);
    __asm
    {
      vmovups ymm0, ymmword ptr [r12]
      vmovups ymmword ptr [rsi+8], ymm0
      vmovups xmm1, xmmword ptr [r12+20h]
      vmovups xmmword ptr [rsi+28h], xmm1
      vmovsd  xmm0, qword ptr [r12+30h]
      vmovsd  qword ptr [rsi+38h], xmm0
    }
    *(_DWORD *)&_RSI->shot.weapon.weaponCamo = *(_DWORD *)&_R12->weaponCamo;
    _RSI->shot.isPlayerView = v30;
    _RSI->shot.isAlternate = isAlternate;
    _RSI->shot.isPlayerHeli = isPlayerHeli;
    _RSI->shot.isDualWield = isDualWield;
    _RSI->shot.useLastFireSound = useLastFireSound;
    _RSI->shot.isAlternatingFire = isAlternatingFire;
    _RSI->shot.pm_flags = *v83;
    CG_FireWeaponSound_CalcOrigin(v63, v65, _R12, (const scr_string_t)_RSI->shot.tagName, v30, (const PlayerHandIndex)_RSI->shot.hand, &from);
    SndWeaponShotSetSecureOrigin(&from, &_RSI->shot.origin.origin);
    secondTagName = _RSI->shot.secondTagName;
    if ( secondTagName )
    {
      secondHand = _RSI->shot.secondHand;
      if ( secondHand != NUM_WEAPON_HANDS )
      {
        CG_FireWeaponSound_CalcOrigin(v63, v65, _R12, secondTagName, v30, secondHand, &from);
        SndWeaponShotSetSecureOrigin(&from, &_RSI->shot.secondShotOrigin.origin);
        _RSI->shot.secondShotOriginValid = 1;
      }
    }
    memset(&from, 0, sizeof(from));
  }
LABEL_122:
  __asm { vmovaps xmm6, [rsp+248h+var_58] }
}

/*
==============
CG_SndPingCompass
==============
*/
void CG_SndPingCompass(LocalClientNum_t localClientNum, const centity_t *cent, const Weapon *weapon, bool isAlternate, const vec3_t *origin)
{
  const char *v11; 
  CgCompassSystem *CompassSystem; 

  __asm { vmovaps [rsp+58h+var_18], xmm6 }
  if ( !cent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18581, ASSERT_TYPE_ASSERT, "(cent)", (const char *)&queryFormat, "cent") )
    __debugbreak();
  if ( (cent->flags & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 18582, ASSERT_TYPE_ASSERT, "(CENextValid( cent ))", (const char *)&queryFormat, "CENextValid( cent )") )
    __debugbreak();
  if ( BG_IsSilenced(weapon, isAlternate) )
  {
    _RBX = DCONST_DVARFLT_compassSilencedSoundPingDuration;
    if ( DCONST_DVARFLT_compassSilencedSoundPingDuration )
      goto LABEL_14;
    v11 = "compassSilencedSoundPingDuration";
  }
  else
  {
    _RBX = DCONST_DVARMPSPFLT_compassSoundPingDuration;
    if ( DCONST_DVARMPSPFLT_compassSoundPingDuration )
      goto LABEL_14;
    v11 = "compassSoundPingDuration";
  }
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", v11) )
    __debugbreak();
LABEL_14:
  Dvar_CheckFrontendServerThread(_RBX);
  __asm { vmovss  xmm6, dword ptr [rbx+28h] }
  CompassSystem = CgCompassSystem::GetCompassSystem(localClientNum);
  __asm
  {
    vmulss  xmm0, xmm6, cs:__real@447a0000
    vcvttss2si r9d, xmm0
    vmovaps xmm6, [rsp+58h+var_18]
  }
  CompassSystem->AddWeaponPingInfo(CompassSystem, cent, origin, _R9);
}

/*
==============
CG_SndUpdateAutoSim
==============
*/

void __fastcall CG_SndUpdateAutoSim(double _XMM0_8, double _XMM1_8)
{
  unsigned __int64 v2; 
  unsigned __int64 v3; 
  int i; 

  v2 = Sys_Microseconds();
  Sys_ProfBeginNamedEvent(0xFFFAEBD7, "CG_SndUpdateAutoSim");
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23030, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  if ( cg_maxLocalClients )
  {
    v3 = s_autosim_time;
    if ( v2 < s_autosim_time )
      v3 = v2;
    s_autosim_time = v3;
    _XMM0_8 = Com_GetTimeScale();
    __asm
    {
      vxorps  xmm1, xmm1, xmm1
      vcvtsi2ss xmm1, xmm1, rax
    }
    if ( (__int64)(v2 - s_autosim_time) < 0 )
      __asm { vaddss  xmm1, xmm1, cs:__real@5f800000 }
    __asm
    {
      vmulss  xmm0, xmm0, xmm1
      vmovss  xmm1, cs:__real@5f000000
      vcomiss xmm0, xmm1
      vsubss  xmm0, xmm0, xmm1
      vcomiss xmm0, xmm1
      vcvttss2si rdi, xmm0
    }
    s_autosim_time = v2;
    if ( !CL_Pause_IsGamePaused() )
    {
      for ( i = 0; i < 64; ++i )
        CG_SndUpdateSingleAutoSim(i, _RDI);
    }
  }
  Sys_ProfEndNamedEvent();
}

/*
==============
CG_SndUpdateSingleAutoSim
==============
*/
void CG_SndUpdateSingleAutoSim(int autosimIndex, unsigned __int64 dt)
{
  unsigned __int64 time; 
  unsigned __int64 nextStamp; 
  centity_t *Entity; 
  weapFireType_t WeaponFireType; 
  weapFireType_t v14; 
  int WeaponBurstCount; 
  SndWeapShotCountId shotCount; 
  unsigned int v17; 
  unsigned int v18; 
  char v19; 
  const vec3_t *p_origin; 
  bool useLastFireSound; 
  PlayerHandIndex hand; 
  unsigned __int64 fireTime; 
  unsigned __int64 v25; 
  float v26; 
  vec3_t to; 

  _RBX = &s_snd_autosims[autosimIndex];
  if ( _RBX->used )
  {
    _RBX->lastPing += dt;
    if ( _RBX->lastPing > 0x493E0 || _RBX->shot.isPlayerView && (unsigned int)(CG_GetLocalClientGlobals((const LocalClientNum_t)_RBX->shot.localClientNum)->predictedPlayerState.weapState[_RBX->shot.hand].weaponState - 18) <= 3 )
      _RBX->kill = 1;
    if ( _RBX->kill && _RBX->shotCount >= _RBX->requestedShotCount )
      goto LABEL_8;
    _RBX->time += dt;
    _RDI = DCONST_DVARFLT_snd_autoSim_predictWindowMs;
    if ( !DCONST_DVARFLT_snd_autoSim_predictWindowMs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "snd_autoSim_predictWindowMs") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RDI);
    __asm
    {
      vmovss  xmm0, dword ptr [rdi+28h]
      vmulss  xmm1, xmm0, cs:__real@447a0000
      vmovss  xmm2, cs:__real@5f000000
      vcomiss xmm1, xmm2
      vsubss  xmm1, xmm1, xmm2
      vcomiss xmm1, xmm2
      vcvttss2si rcx, xmm1
    }
    time = _RBX->time;
    nextStamp = _RBX->nextStamp;
    if ( time > nextStamp || nextStamp - time <= _RCX )
    {
      Entity = CG_GetEntity((const LocalClientNum_t)_RBX->shot.localClientNum, _RBX->shot.entNum);
      WeaponFireType = BG_GetWeaponFireType(&_RBX->shot.weapon, _RBX->shot.isAlternate);
      v14 = WeaponFireType;
      if ( !_RBX->fireContinuously && WeaponFireType == WEAPON_FIRETYPE_BURST && _RBX->shotCount >= BG_GetWeaponBurstCount(&_RBX->shot.weapon, _RBX->shot.isAlternate) || _RBX->isHyperBurst && ((v14 - 1) & 0xFFFFFFFC) == 0 && v14 != WEAPON_FIRETYPE_BURST && _RBX->shotCount && (_RBX->shot.useLastFireSound || _RBX->processedHyperBurstRound) )
      {
LABEL_8:
        _RBX->used = 0;
        return;
      }
      if ( (Entity->flags & 1) != 0 )
      {
        WeaponBurstCount = 0;
        shotCount = SND_WEAP_SHOT_UNCOUNTED;
        if ( _RBX->countShots )
        {
          v17 = _RBX->shotCount;
          if ( v17 )
          {
            v18 = v17 - 1;
            if ( v18 )
            {
              if ( v18 == 1 )
                shotCount = SND_WEAP_SHOT_THIRD;
            }
            else
            {
              shotCount = SND_WEAP_SHOT_SECOND;
            }
          }
          else
          {
            shotCount = SND_WEAP_SHOT_FIRST;
          }
        }
        if ( _RBX->shot.fireSecondTag && _RBX->shot.secondShotOriginValid )
        {
          v19 = 1;
          if ( _RBX->shot.secondHand == NUM_WEAPON_HANDS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22599, ASSERT_TYPE_ASSERT, "(pShot->secondHand != NUM_WEAPON_HANDS)", (const char *)&queryFormat, "pShot->secondHand != NUM_WEAPON_HANDS") )
            __debugbreak();
          if ( !_RBX->shot.secondTagName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22600, ASSERT_TYPE_ASSERT, "(pShot->secondTagName != ( static_cast< scr_string_t >( 0 ) ))", (const char *)&queryFormat, "pShot->secondTagName != NULL_SCR_STRING") )
            __debugbreak();
          if ( !_RBX->shot.secondShotOriginValid && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1411, ASSERT_TYPE_ASSERT, "(shot->secondShotOriginValid)", (const char *)&queryFormat, "shot->secondShotOriginValid") )
            __debugbreak();
          p_origin = &_RBX->shot.secondShotOrigin.origin;
        }
        else
        {
          v19 = 0;
          p_origin = &_RBX->shot.origin.origin;
        }
        SndWeaponShotGetSecureOrigin(p_origin, &to);
        useLastFireSound = _RBX->shot.useLastFireSound && _RBX->shotCount >= _RBX->requestedShotCount - 1;
        if ( _RBX->shot.isLastBurst && Dvar_GetBool_Internal_DebugName(DVARBOOL_killswitch_burst_fire_lastshot_enabled, "killswitch_burst_fire_lastshot_enabled") )
        {
          if ( v14 == WEAPON_FIRETYPE_BURST )
            WeaponBurstCount = BG_GetWeaponBurstCount(&_RBX->shot.weapon, _RBX->shot.isAlternate);
          if ( WeaponBurstCount <= (signed int)(_RBX->shotCount + 1) )
            useLastFireSound = 1;
        }
        __asm { vmovss  xmm0, dword ptr [rbx+0A8h] }
        if ( v19 )
          hand = _RBX->shot.secondHand;
        else
          hand = _RBX->shot.hand;
        __asm { vmovss  [rsp+0C8h+var_70], xmm0 }
        CG_FireWeapSound_KnownOrigin((const LocalClientNum_t)_RBX->shot.localClientNum, Entity, &_RBX->shot.weapon, _RBX->shot.isPlayerView, _RBX->shot.isAlternate, _RBX->shot.isPlayerHeli, _RBX->shot.isDualWield, useLastFireSound, hand, _RBX->autoSimId, _RBX->nextStamp, v26, shotCount, &_RBX->shot.pm_flags, &to);
        if ( _RBX->shot.isAlternatingFire )
          _RBX->shot.fireSecondTag = !_RBX->shot.fireSecondTag;
        if ( useLastFireSound )
          _RBX->kill = 1;
        memset(&to, 0, sizeof(to));
      }
      fireTime = _RBX->fireTime;
      v25 = _RBX->time;
      do
        _RBX->nextStamp += fireTime;
      while ( _RBX->nextStamp < v25 && fireTime );
      ++_RBX->shotCount;
    }
  }
}

/*
==============
CG_SndUpdateSubmix
==============
*/

void __fastcall CG_SndUpdateSubmix(LocalClientNum_t localClientNum, __int64 a2, double _XMM2_8)
{
  cg_t *LocalClientGlobals; 
  bool v5; 
  const char *ActionCamSubmixName; 
  const char *v7; 
  char v8; 
  unsigned int v9; 
  char v10; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v5 = !CL_IsRenderingSplitScreen() && CG_Utils_IsActionCamActive(localClientNum);
  if ( v5 != LocalClientGlobals->firstPersonHelmetSubmixActive )
  {
    ActionCamSubmixName = BG_GetActionCamSubmixName();
    v7 = ActionCamSubmixName;
    if ( ActionCamSubmixName && (v8 = *ActionCamSubmixName) != 0 )
    {
      v9 = 5381;
      do
      {
        ++v7;
        v10 = v8 | 0x20;
        if ( (unsigned int)(v8 - 65) >= 0x1A )
          v10 = v8;
        v9 = 65599 * v9 + v10;
        v8 = *v7;
      }
      while ( *v7 );
      if ( !v9 )
        v9 = 1;
    }
    else
    {
      v9 = 0;
    }
    __asm { vxorps  xmm2, xmm2, xmm2; fadeTimeSec }
    if ( v5 )
    {
      __asm { vmovss  xmm3, cs:__real@3f800000; scale }
      SND_SubmixAddFromSource(SND_SUBMIX_TYPE_GAMECODE, v9, *(float *)&_XMM2, *(float *)&_XMM3);
      LocalClientGlobals->firstPersonHelmetSubmixActive = v5;
    }
    else
    {
      SND_SubmixClearFromSource(SND_SUBMIX_TYPE_GAMECODE, v9, *(float *)&_XMM2);
      LocalClientGlobals->firstPersonHelmetSubmixActive = 0;
    }
  }
}

/*
==============
CG_StartSprintAdditive
==============
*/
void CG_StartSprintAdditive(LocalClientNum_t localClientNum, const playerState_s *ps, DObj *obj, const Weapon *weapon, const WeaponHand *weaponHand, const PlayerHandIndex handIndex, const WeaponAnimNumber prevAnim, const weapAnimFiles_t prevAnimIndex, const WeaponAnimNumber anim, const weapAnimFiles_t animIndex)
{
  const WeaponHand *v24; 
  XAnim_s *v25; 
  signed int v26; 
  WeaponAnimNumber v27; 
  char v29; 
  char v30; 
  const XAnimTree *v31; 
  unsigned int v32; 
  unsigned int *v33; 
  char v34; 
  char v35; 
  PlayerHandIndex v36; 
  Weapon *v37; 
  const XAnimTree *v38; 
  CgHandler *v41; 
  const dvar_t *v43; 
  CgHandler *v44; 
  const XAnimTree *Tree; 
  CgHandler *Handler; 
  PlayerHandIndex v50; 
  CgHandler *v53; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float fmtc; 
  float fmtd; 
  float fmte; 
  float fmtf; 
  float fmtg; 
  float fmth; 
  float fmti; 
  float fmtj; 
  float fmtk; 
  float blendInAnim; 
  float blendInAnima; 
  float blendInAnimb; 
  float blendInAnimc; 
  float blendInAnimd; 
  float blendInAnime; 
  float blendInAnimf; 
  float blendInAnimg; 
  float blendInAnimh; 
  float blendInAnimi; 
  float blendInAnimj; 
  float blendInAnimk; 
  float blendInAnimIndex; 
  float blendInAnimIndexa; 
  float blendInAnimIndexb; 
  float blendInAnimIndexc; 
  float blendInAnimIndexd; 
  float blendInAnimIndexe; 
  float blendInAnimIndexf; 
  float blendInAnimIndexg; 
  float blendInAnimIndexh; 
  float blendInAnimIndexi; 
  float blendInAnimIndexj; 
  float blendInAnimIndexk; 
  float blendOutTime; 
  XAnim_s *anims; 
  char v102; 
  void *retaddr; 
  float blendInTime; 
  float v105; 
  Weapon *weapona; 

  _RAX = &retaddr;
  weapona = (Weapon *)weapon;
  __asm
  {
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps [rsp+0F8h+var_88], xmm10
    vmovss  xmm8, cs:__real@3f800000
    vxorps  xmm7, xmm7, xmm7
    vmovaps xmm10, xmm8
    vmovss  dword ptr [rax+18h], xmm7
    vmovss  dword ptr [rax+10h], xmm7
  }
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8229, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8230, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  v24 = weaponHand;
  if ( !weaponHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8231, ASSERT_TYPE_ASSERT, "(weaponHand)", (const char *)&queryFormat, "weaponHand") )
    __debugbreak();
  v25 = XAnimGetAnims(v24->tree);
  v26 = animIndex;
  v27 = anim;
  anims = v25;
  LODWORD(weaponHand) = GetAnimBlendTimes(localClientNum, weapon, ps, prevAnim, prevAnimIndex, anim, animIndex, &v105, &blendInTime);
  if ( !BG_IsSuperSprinting(ps) )
  {
    __asm { vmovaps [rsp+0F8h+var_48], xmm6 }
    if ( v27 != WEAP_SPRINT_IN )
    {
      Tree = DObjGetTree(obj);
      if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8302, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
        __debugbreak();
      *(double *)&_XMM0 = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0xECu);
      __asm
      {
        vcomiss xmm0, xmm7
        vmovaps [rsp+0F8h+var_78], xmm9
        vmovss  xmm9, [rsp+0F8h+arg_8]
        vxorps  xmm6, xmm6, xmm6
      }
      *(double *)&_XMM0 = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x154u);
      __asm { vcomiss xmm0, xmm7 }
      if ( !(v34 | v29) )
      {
        *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_superSprintBlendTime, "superSprintBlendTime");
        __asm { vmovaps xmm6, xmm0 }
        *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_superSprintBlendTime, "superSprintBlendTime");
        __asm { vmovaps xmm9, xmm0 }
      }
      __asm
      {
        vmovss  [rsp+0F8h+blendInAnimIndex], xmm8
        vmovss  [rsp+0F8h+blendInAnim], xmm6
        vmovss  dword ptr [rsp+0F8h+fmt], xmm8
      }
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xECu, fmtf, blendInAnimf, blendInAnimIndexf, (scr_string_t)0, 1u, 1, LINEAR, NULL);
      __asm
      {
        vmovss  [rsp+0F8h+blendInAnimIndex], xmm8
        vmovss  [rsp+0F8h+blendInAnim], xmm9
        vmovss  dword ptr [rsp+0F8h+fmt], xmm8
      }
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x5Du, fmtg, blendInAnimg, blendInAnimIndexg, (scr_string_t)0, 1u, 1, LINEAR, NULL);
      __asm { vmovaps xmm9, [rsp+0F8h+var_78] }
      if ( (_DWORD)weaponHand )
      {
        *(double *)&_XMM0 = XAnimGetRate(Tree, 0, XANIM_SUBTREE_DEFAULT, prevAnimIndex);
        __asm { vmovaps xmm10, xmm0 }
      }
      if ( (unsigned int)(prevAnimIndex - 93) <= 6 )
      {
        __asm
        {
          vmovss  xmm0, [rsp+0F8h+arg_10]
          vmovss  [rsp+0F8h+blendInAnimIndex], xmm10
          vmovss  [rsp+0F8h+blendInAnim], xmm0
          vmovss  dword ptr [rsp+0F8h+fmt], xmm7
        }
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, prevAnimIndex, fmth, blendInAnimh, blendInAnimIndexh, (scr_string_t)0, 0, 0, LINEAR, NULL);
      }
      Handler = CgHandler::getHandler(localClientNum);
      v50 = handIndex;
      if ( BG_ViewModelAnimExists(ps, (weapAnimFiles_t)v26, handIndex, Handler) )
      {
        __asm { vxorps  xmm0, xmm0, xmm0 }
        if ( v26 == 97 )
        {
          CG_Weapons_StoreSprintAnimLength(localClientNum, WEAP_ANIM_ADDITIVE_SPRINT_OUT, v50);
          *(float *)&_XMM0 = CG_Weapons_GetWeaponStateModifiedAnimRate(localClientNum, ps, weapona, v50, anims, WEAP_ANIM_ADDITIVE_SPRINT_OUT);
        }
        __asm
        {
          vmovss  [rsp+0F8h+blendInAnimIndex], xmm0
          vmovss  xmm0, [rsp+0F8h+arg_8]
          vmovss  [rsp+0F8h+blendInAnim], xmm0
          vmovss  dword ptr [rsp+0F8h+fmt], xmm8
        }
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, v26, fmti, blendInAnimi, blendInAnimIndexi, (scr_string_t)0, 1u, 1, LINEAR, NULL);
      }
      else
      {
        Com_PrintWarning(19, "CG_StartSprintAdditive(): additive Sprint LOOP/OUT animation not found.\n");
      }
      if ( v27 == WEAP_SPRINT_OUT )
      {
        v53 = CgHandler::getHandler(localClientNum);
        if ( BG_ViewModelAnimExists(ps, WEAP_ANIM_ADDITIVE_SPRINT_OFFSET, v50, v53) )
        {
          __asm
          {
            vmovss  xmm0, [rsp+0F8h+arg_8]
            vmovss  [rsp+0F8h+blendInAnimIndex], xmm8
            vmovss  [rsp+0F8h+blendInAnim], xmm0
            vmovss  dword ptr [rsp+0F8h+fmt], xmm7
          }
          XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x62u, fmtj, blendInAnimj, blendInAnimIndexj, (scr_string_t)0, 0, 0, LINEAR, NULL);
          __asm
          {
            vmovss  xmm0, [rsp+0F8h+arg_8]
            vmovss  [rsp+0F8h+blendInAnimIndex], xmm8
            vmovss  [rsp+0F8h+blendInAnim], xmm0
            vmovss  dword ptr [rsp+0F8h+fmt], xmm7
          }
          XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x63u, fmtk, blendInAnimk, blendInAnimIndexk, (scr_string_t)0, 0, 0, LINEAR, NULL);
        }
      }
LABEL_60:
      __asm { vmovaps xmm6, [rsp+0F8h+var_48] }
      goto LABEL_61;
    }
    __asm
    {
      vmovss  xmm6, cs:__real@3c23d70a
      vmovss  [rsp+0F8h+blendInAnimIndex], xmm8
      vmovss  [rsp+0F8h+blendInAnim], xmm6
      vmovss  dword ptr [rsp+0F8h+fmt], xmm7
    }
    XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, v27 + 63, fmt, blendInAnim, blendInAnimIndex, (scr_string_t)0, 0, 0, LINEAR, NULL);
    __asm
    {
      vmovss  [rsp+0F8h+blendInAnimIndex], xmm8
      vmovss  [rsp+0F8h+blendInAnim], xmm6
      vmovss  dword ptr [rsp+0F8h+fmt], xmm7
    }
    XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, v27 + 65, fmta, blendInAnima, blendInAnimIndexa, (scr_string_t)0, 0, 0, LINEAR, NULL);
    *(double *)&_XMM0 = XAnimGetWeight(v24->tree, 0, XANIM_SUBTREE_DEFAULT, 0xECu);
    __asm { vucomiss xmm0, xmm8 }
    if ( v29 )
    {
      LOBYTE(weaponHand) = 0;
    }
    else
    {
      v38 = v24->tree;
      LOBYTE(weaponHand) = 1;
      *(double *)&_XMM0 = XAnimGetGoalWeight(v38, 0, XANIM_SUBTREE_DEFAULT, 0xECu);
      __asm { vucomiss xmm0, xmm8 }
      if ( v29 )
      {
        v30 = 1;
        goto LABEL_15;
      }
    }
    v30 = 0;
LABEL_15:
    v31 = v24->tree;
    if ( !v31 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8198, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
      __debugbreak();
    v32 = 0;
    v33 = (unsigned int *)&unk_1442DCC50;
    while ( 1 )
    {
      *(double *)&_XMM0 = XAnimGetWeight(v31, 0, XANIM_SUBTREE_DEFAULT, *v33);
      __asm { vcomiss xmm0, xmm7 }
      if ( !(v34 | v29) )
      {
        *(double *)&_XMM0 = XAnimGetGoalWeight(v31, 0, XANIM_SUBTREE_DEFAULT, *v33);
        __asm { vucomiss xmm0, xmm7 }
        if ( v29 )
          break;
      }
      ++v32;
      ++v33;
      if ( v32 >= 5 )
      {
        v35 = 0;
        goto LABEL_23;
      }
    }
    v35 = 1;
LABEL_23:
    v36 = handIndex;
    if ( v30 && v35 )
    {
      v37 = weapona;
    }
    else
    {
      v37 = weapona;
      if ( (_BYTE)weaponHand )
      {
        __asm
        {
          vmovss  xmm0, [rsp+0F8h+arg_10]
          vmovss  dword ptr [rsp+0F8h+blendOutTime], xmm0
        }
        CG_Weapons_StartWeaponAnim(localClientNum, weapona, handIndex, WEAP_IDLE, WEAP_ANIM_IDLE, prevAnim, prevAnimIndex, blendOutTime, 0);
      }
    }
    CG_Weapons_StoreSprintAnimLength(localClientNum, WEAP_ANIM_ADDITIVE_SPRINT_IN, v36);
    *(float *)&_XMM0 = CG_Weapons_GetWeaponStateModifiedAnimRate(localClientNum, ps, v37, v36, anims, WEAP_ANIM_ADDITIVE_SPRINT_IN);
    __asm
    {
      vmovss  xmm1, [rsp+0F8h+arg_8]
      vmovss  [rsp+0F8h+blendInAnimIndex], xmm8
      vmovss  [rsp+0F8h+blendInAnim], xmm1
      vmovss  dword ptr [rsp+0F8h+fmt], xmm8
      vmovaps xmm6, xmm0
    }
    XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x5Du, fmtb, blendInAnimb, blendInAnimIndexb, (scr_string_t)0, 1u, 1, LINEAR, NULL);
    v41 = CgHandler::getHandler(localClientNum);
    if ( BG_ViewModelAnimExists(ps, WEAP_ANIM_ADDITIVE_SPRINT_IN, v36, v41) )
    {
      __asm
      {
        vmovss  xmm0, [rsp+0F8h+arg_8]
        vmovss  [rsp+0F8h+blendInAnimIndex], xmm6
        vmovss  [rsp+0F8h+blendInAnim], xmm0
        vmovss  dword ptr [rsp+0F8h+fmt], xmm8
      }
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x5Eu, fmtc, blendInAnimc, blendInAnimIndexc, (scr_string_t)0, 1u, 1, LINEAR, NULL);
      __asm { vucomiss xmm6, xmm7 }
      if ( v29 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8281, ASSERT_TYPE_ASSERT, "(rate)", (const char *)&queryFormat, "rate") )
        __debugbreak();
      *(double *)&_XMM0 = XAnimGetLength(anims, 0x5Eu);
      __asm { vdivss  xmm7, xmm0, xmm6 }
    }
    else
    {
      Com_PrintWarning(19, "CG_StartSprintAdditive(): additive Sprint IN animation not found.\n");
    }
    v43 = DCONST_DVARBOOL_cg_viewmodelSprintOffset;
    if ( !DCONST_DVARBOOL_cg_viewmodelSprintOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmodelSprintOffset") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v43);
    if ( v43->current.enabled )
    {
      v44 = CgHandler::getHandler(localClientNum);
      if ( BG_ViewModelAnimExists(ps, WEAP_ANIM_ADDITIVE_SPRINT_OFFSET, v36, v44) )
      {
        __asm
        {
          vmovss  [rsp+0F8h+blendInAnimIndex], xmm8
          vmovss  [rsp+0F8h+blendInAnim], xmm7
          vmovss  dword ptr [rsp+0F8h+fmt], xmm8
        }
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x62u, fmtd, blendInAnimd, blendInAnimIndexd, (scr_string_t)0, 1u, 1, LINEAR, NULL);
        __asm
        {
          vmovss  [rsp+0F8h+blendInAnimIndex], xmm8
          vmovss  [rsp+0F8h+blendInAnim], xmm7
          vmovss  dword ptr [rsp+0F8h+fmt], xmm8
        }
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x63u, fmte, blendInAnime, blendInAnimIndexe, (scr_string_t)0, 1u, 1, LINEAR, NULL);
      }
    }
    goto LABEL_60;
  }
LABEL_61:
  _R11 = &v102;
  __asm
  {
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm10, xmmword ptr [r11-50h]
  }
}

/*
==============
CG_StopSprintAdditives
==============
*/

void __fastcall CG_StopSprintAdditives(const playerState_s *ps, DObj *obj, const WeaponHand *weaponHand, double blendOutTime)
{
  const XAnimTree *Tree; 
  char v14; 
  char v15; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float fmtc; 
  float fmtd; 
  float fmte; 
  float goalTime; 
  float goalTimea; 
  float goalTimeb; 
  float goalTimec; 
  float goalTimed; 
  float goalTimee; 
  float v33; 
  float v34; 
  float v35; 
  float v36; 
  float v37; 
  float v38; 
  char v40; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-18h], xmm6
    vmovaps xmmword ptr [rax-28h], xmm7
    vmovaps xmmword ptr [rax-38h], xmm8
    vmovaps xmm7, xmm3
  }
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2264, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2265, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  if ( !weaponHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2266, ASSERT_TYPE_ASSERT, "(weaponHand)", (const char *)&queryFormat, "weaponHand") )
    __debugbreak();
  XAnimGetAnims(weaponHand->tree);
  Tree = DObjGetTree(obj);
  *(double *)&_XMM0 = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x5Fu);
  __asm
  {
    vxorps  xmm8, xmm8, xmm8
    vcomiss xmm0, xmm8
  }
  if ( !(v14 | v15) )
  {
    *(double *)&_XMM0 = XAnimGetGoalTime(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x5Fu);
    __asm { vmovaps xmm7, xmm0 }
  }
  __asm
  {
    vmovss  xmm6, cs:__real@3f800000
    vmovss  [rsp+98h+var_68], xmm6
    vmovss  [rsp+98h+goalTime], xmm7
    vmovss  dword ptr [rsp+98h+fmt], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x5Du, fmt, goalTime, v33, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+98h+var_68], xmm6
    vmovss  [rsp+98h+goalTime], xmm7
    vmovss  dword ptr [rsp+98h+fmt], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x5Eu, fmta, goalTimea, v34, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+98h+var_68], xmm6
    vmovss  [rsp+98h+goalTime], xmm7
    vmovss  dword ptr [rsp+98h+fmt], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x5Fu, fmtb, goalTimeb, v35, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+98h+var_68], xmm6
    vmovss  [rsp+98h+goalTime], xmm7
    vmovss  dword ptr [rsp+98h+fmt], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x61u, fmtc, goalTimec, v36, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+98h+var_68], xmm6
    vmovss  [rsp+98h+goalTime], xmm7
    vmovss  dword ptr [rsp+98h+fmt], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x62u, fmtd, goalTimed, v37, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+98h+var_68], xmm6
    vmovss  [rsp+98h+goalTime], xmm7
    vmovss  dword ptr [rsp+98h+fmt], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x63u, fmte, goalTimee, v38, (scr_string_t)0, 0, 0, LINEAR, NULL);
  _R11 = &v40;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, [rsp+98h+var_28]
    vmovaps xmm8, xmmword ptr [r11-30h]
  }
}

/*
==============
CG_TouchViewModel
==============
*/
void CG_TouchViewModel(const LocalClientNum_t localClientNum, const Weapon *r_weapon, bool isDefault, const playerState_s *ps)
{
  const BgWeaponMap **v6; 
  bool v9; 
  CgWeaponSystem *WeaponSystem; 
  const WeaponDef *v11; 
  int i; 
  const XModel *WeaponModels; 
  const XModel *rocketModel; 
  unsigned int AllWeaponAttachmentsWithIds; 
  unsigned __int8 *v16; 
  __int64 v17; 
  WeaponAttachment **v18; 
  const WeaponAttachment *v19; 
  const XModel *AttachmentModel; 
  __int64 isUsingDetonator; 
  unsigned int isUsingCensorshipWorldModel; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  v6 = (const BgWeaponMap **)&CgWeaponMap::ms_instance[localClientNum];
  if ( !*v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v9 = BG_PlayerOrEntityDualWielding(*v6, ps, NULL, NULL);
  if ( !r_weapon->weaponIdx && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12062, ASSERT_TYPE_ASSERT, "(r_weapon.weaponIdx != 0)", (const char *)&queryFormat, "r_weapon.weaponIdx != WP_NONE") )
    __debugbreak();
  if ( r_weapon->weaponIdx >= BG_GetNumWeapons() )
  {
    isUsingCensorshipWorldModel = BG_GetNumWeapons();
    LODWORD(isUsingDetonator) = r_weapon->weaponIdx;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12063, ASSERT_TYPE_ASSERT, "(unsigned)( r_weapon.weaponIdx ) < (unsigned)( BG_GetNumWeapons() )", "r_weapon.weaponIdx doesn't index BG_GetNumWeapons()\n\t%i not in [0, %i)", isUsingDetonator, isUsingCensorshipWorldModel) )
      __debugbreak();
  }
  CG_GetLocalClientGlobals(localClientNum);
  WeaponSystem = CgWeaponSystem::GetWeaponSystem(localClientNum);
  v11 = BG_WeaponDef(r_weapon, 0);
  BG_WeaponCompleteDef(r_weapon, 0);
  for ( i = 0; i < 2; ++i )
  {
    if ( v9 || !i )
    {
      WeaponModels = BG_GetWeaponModels((const PlayerHandIndex)i, r_weapon, 1, isDefault, v9, 0, 0);
      if ( WeaponModels )
        Stream_TouchXModel(WeaponModels, MIP3);
    }
  }
  rocketModel = v11->rocketModel;
  if ( rocketModel )
    Stream_TouchXModel(rocketModel, MIP3);
  WeaponSystem->TouchWeaponAttachModels(WeaponSystem);
  AllWeaponAttachmentsWithIds = BG_GetAllWeaponAttachmentsWithIds(r_weapon, (const WeaponAttachment **)attachments, attachmentIds);
  if ( AllWeaponAttachmentsWithIds )
  {
    v16 = attachmentIds;
    v17 = AllWeaponAttachmentsWithIds;
    v18 = attachments;
    do
    {
      v19 = *v18;
      if ( !*v18 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12093, ASSERT_TYPE_ASSERT, "(attachment)", (const char *)&queryFormat, "attachment") )
        __debugbreak();
      AttachmentModel = BG_GetAttachmentModel(v19, r_weapon->attachmentVariationIndices[*v16], 1);
      if ( AttachmentModel )
        Stream_TouchXModel(AttachmentModel, MIP3);
      ++v18;
      ++v16;
      --v17;
    }
    while ( v17 );
  }
}

/*
==============
CG_UpdateHandViewmodels
==============
*/
void CG_UpdateHandViewmodels(LocalClientNum_t localClientNum, XModel *handModel)
{
  __int64 v2; 
  cg_t *LocalClientGlobals; 
  const Weapon *ViewmodelWeapon; 
  const Weapon *v6; 

  v2 = localClientNum;
  if ( !handModel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12481, ASSERT_TYPE_ASSERT, "(handModel)", (const char *)&queryFormat, "handModel") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v2);
  if ( !CgWeaponMap::ms_instance[v2] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  ViewmodelWeapon = BG_GetViewmodelWeapon(CgWeaponMap::ms_instance[v2], &LocalClientGlobals->predictedPlayerState);
  v6 = ViewmodelWeapon;
  if ( ViewmodelWeapon->weaponIdx )
  {
    if ( LocalClientGlobals->playerWeaponInfo.handModel != handModel )
    {
      CG_Weapon_ChangeViewmodelDobj((LocalClientNum_t)v2, &LocalClientGlobals->predictedPlayerState, ViewmodelWeapon, handModel, 1, 0, 0, 1);
      CG_Gesture_ForceRestoreAnims((LocalClientNum_t)v2, &LocalClientGlobals->predictedPlayerState, v6);
    }
  }
}

/*
==============
CG_UpdateRecoilState
==============
*/
void CG_UpdateRecoilState(LocalClientNum_t localClientNum, const PlayerHandIndex hand)
{
  __int64 v2; 
  cg_t *LocalClientGlobals; 
  unsigned int v4; 

  v2 = hand;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&LocalClientGlobals->predictedPlayerState.pm_flags, ACTIVE, 0x10u) || BG_IsPlayerFireDisabledForHand(&LocalClientGlobals->predictedPlayerState, (const PlayerHandIndex)v2) )
    goto LABEL_8;
  v4 = LocalClientGlobals->predictedPlayerState.weapState[v2].weapAnim & 0xFFFFFF7F;
  if ( v4 == 3 )
  {
    if ( LocalClientGlobals->weaponRecoilTime[v2] <= 0 )
      LocalClientGlobals->weaponRecoilTime[v2] = LocalClientGlobals->time;
    return;
  }
  if ( v4 || LocalClientGlobals->weaponRecoilTime[v2] > 0 )
LABEL_8:
    LocalClientGlobals->weaponRecoilTime[v2] = 0;
}

/*
==============
CG_UpdateViewModelHidePartBits_EMP
==============
*/
void CG_UpdateViewModelHidePartBits_EMP(const LocalClientNum_t localClientNum, DObj *obj)
{
  cg_t *LocalClientGlobals; 
  ClientPlayerWeaponInfo *p_playerWeaponInfo; 
  unsigned __int8 inOutIndex[4]; 
  int modelIndex; 
  DObjPartBits partBits; 

  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9565, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  p_playerWeaponInfo = &LocalClientGlobals->playerWeaponInfo;
  if ( LocalClientGlobals == (cg_t *)-98976i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9570, ASSERT_TYPE_SANITY, "( weapInfo )", (const char *)&queryFormat, "weapInfo") )
    __debugbreak();
  if ( p_playerWeaponInfo->hideReticle )
  {
    DObjGetHidePartBits(obj, &partBits);
    inOutIndex[0] = -2;
    if ( DObjGetBoneIndexInternal_66(obj, scr_const.tag_reticle_acog, inOutIndex, &modelIndex) )
      partBits.array[(unsigned __int64)inOutIndex[0] >> 5] |= 0x80000000 >> (inOutIndex[0] & 0x1F);
    inOutIndex[0] = -2;
    if ( DObjGetBoneIndexInternal_66(obj, scr_const.tag_reticle_red_dot, inOutIndex, &modelIndex) )
      partBits.array[(unsigned __int64)inOutIndex[0] >> 5] |= 0x80000000 >> (inOutIndex[0] & 0x1F);
    inOutIndex[0] = -2;
    if ( DObjGetBoneIndexInternal_66(obj, scr_const.tag_eotech_reticle, inOutIndex, &modelIndex) )
      partBits.array[(unsigned __int64)inOutIndex[0] >> 5] |= 0x80000000 >> (inOutIndex[0] & 0x1F);
    inOutIndex[0] = -2;
    if ( DObjGetBoneIndexInternal_66(obj, scr_const.tag_magnifier_eotech_reticle, inOutIndex, &modelIndex) )
      partBits.array[(unsigned __int64)inOutIndex[0] >> 5] |= 0x80000000 >> (inOutIndex[0] & 0x1F);
    inOutIndex[0] = -2;
    if ( DObjGetBoneIndexInternal_66(obj, scr_const.tag_reticle_tavor_scope, inOutIndex, &modelIndex) )
      partBits.array[(unsigned __int64)inOutIndex[0] >> 5] |= 0x80000000 >> (inOutIndex[0] & 0x1F);
    inOutIndex[0] = -2;
    if ( DObjGetBoneIndexInternal_66(obj, scr_const.tag_reticle_thermal_scope, inOutIndex, &modelIndex) )
      partBits.array[(unsigned __int64)inOutIndex[0] >> 5] |= 0x80000000 >> (inOutIndex[0] & 0x1F);
    DObjSetHidePartBits(obj, &partBits);
  }
}

/*
==============
CG_UpdateViewModelHidePartBits_NightVisionGoggles
==============
*/
void CG_UpdateViewModelHidePartBits_NightVisionGoggles(LocalClientNum_t localClientNum, const PlayerHandIndex hand)
{
  cg_t *LocalClientGlobals; 
  CgWeaponMap *Instance; 
  bool v6; 
  bool ShouldHideGoggles; 
  WeaponHand *ViewModelHand; 
  DObj *viewModelDObj; 
  int ModelIndex; 
  DObjPartBits *p_hidePartBits; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9687, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( LocalClientGlobals == (cg_t *)-98976i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9690, ASSERT_TYPE_ASSERT, "(weapInfo)", (const char *)&queryFormat, "weapInfo") )
    __debugbreak();
  if ( LocalClientGlobals->playerWeaponInfo.gogglesModel )
  {
    Instance = CgWeaponMap::GetInstance(localClientNum);
    v6 = BG_PlayerOrEntityDualWielding(Instance, &LocalClientGlobals->predictedPlayerState, NULL, NULL);
    if ( hand )
    {
      if ( hand == WEAPON_HAND_LEFT && !v6 )
        return;
    }
    else if ( v6 )
    {
      return;
    }
    ShouldHideGoggles = CG_NightVisionShouldHideGoggles(localClientNum, hand);
    if ( ShouldHideGoggles != LocalClientGlobals->playerWeaponInfo.gogglesAreHidden )
    {
      ViewModelHand = cg_t::GetViewModelHand(LocalClientGlobals, hand);
      viewModelDObj = ViewModelHand->viewModelDObj;
      if ( ViewModelHand->viewModelDObj )
      {
        ModelIndex = DObjGetModelIndex(ViewModelHand->viewModelDObj, LocalClientGlobals->playerWeaponInfo.gogglesModel);
        p_hidePartBits = &viewModelDObj->hidePartBits;
        if ( ShouldHideGoggles )
        {
          BG_HideBone((const scr_string_t)scr_const.tag_accessory, viewModelDObj, p_hidePartBits, ModelIndex);
          LocalClientGlobals->playerWeaponInfo.gogglesAreHidden = 1;
        }
        else
        {
          BG_ShowBone((const scr_string_t)scr_const.tag_accessory, viewModelDObj, p_hidePartBits, ModelIndex);
          LocalClientGlobals->playerWeaponInfo.gogglesAreHidden = 0;
        }
      }
    }
  }
}

/*
==============
CG_UpdateViewModelPose
==============
*/
void CG_UpdateViewModelPose(const DObj *obj, LocalClientNum_t localClientNum)
{
  const tmat43_t<vec3_t> *ViewModelTransform; 
  vec3_t outOrigin; 

  if ( obj )
    DObjClearSkel(obj);
  _RSI = CG_GetLocalClientGlobals(localClientNum);
  CG_GetPoseOrigin(&_RSI->viewModelPose, &outOrigin);
  CG_SetPrevPoseOrigin(&_RSI->viewModelPose, &outOrigin);
  _RSI->viewModelPose.prevAngles.v[0] = _RSI->viewModelPose.angles.v[0];
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+4A12Ch]
    vmovss  dword ptr [rsi+4A15Ch], xmm0
    vmovss  xmm1, dword ptr [rsi+4A130h]
    vmovss  dword ptr [rsi+4A160h], xmm1
  }
  CG_SetViewModelPose(_RSI, 0, &_RSI->viewModelPose);
  if ( obj )
  {
    ViewModelTransform = cg_t::GetViewModelTransform(_RSI);
    XAnimBonePhysicsSetDObjMatrix(obj, &ViewModelTransform->m[3], &_RSI->viewModelPose.angles);
  }
  memset(&outOrigin, 0, sizeof(outOrigin));
}

/*
==============
CG_UpdateViewModelPoseForHand
==============
*/
void CG_UpdateViewModelPoseForHand(DObj *obj, LocalClientNum_t localClientNum, PlayerHandIndex hand, const bool sendingToRenderer)
{
  cg_t *LocalClientGlobals; 
  __int64 v9; 
  const vec3_t *v10; 
  const tmat43_t<vec3_t> *ViewModelTransform; 

  if ( obj )
    DObjClearSkel(obj);
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v9 = 303328i64;
  if ( hand )
    v9 = 303616i64;
  v10 = (const vec3_t *)((char *)LocalClientGlobals + v9);
  CG_SetViewModelPose(LocalClientGlobals, sendingToRenderer, (cpose_t *)((char *)LocalClientGlobals + v9));
  if ( obj )
  {
    ViewModelTransform = cg_t::GetViewModelTransform(LocalClientGlobals);
    XAnimBonePhysicsSetDObjMatrix(obj, &ViewModelTransform->m[3], v10 + 6);
  }
  CG_WristWatch_CalcXAnimParameters(obj, localClientNum, &LocalClientGlobals->predictedPlayerState, 0x1Bu, 0x1Cu, 0x1Du, 0x23u);
}

/*
==============
CG_UpdateViewModelPreviousPositionForHand
==============
*/
void CG_UpdateViewModelPreviousPositionForHand(LocalClientNum_t localClientNum, PlayerHandIndex hand)
{
  cg_t *LocalClientGlobals; 
  __int64 v4; 
  vec3_t outOrigin; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v4 = 303328i64;
  if ( hand )
    v4 = 303616i64;
  _RDI = (cpose_t *)((char *)LocalClientGlobals + v4);
  CG_GetPoseOrigin((const cpose_t *)((char *)LocalClientGlobals + v4), &outOrigin);
  CG_SetPrevPoseOrigin(_RDI, &outOrigin);
  _RDI->prevAngles.v[0] = _RDI->angles.v[0];
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+4Ch]
    vmovss  dword ptr [rdi+7Ch], xmm0
    vmovss  xmm1, dword ptr [rdi+50h]
    vmovss  dword ptr [rdi+80h], xmm1
  }
  memset(&outOrigin, 0, sizeof(outOrigin));
}

/*
==============
CG_UpdateViewWeaponAnim
==============
*/

void __fastcall CG_UpdateViewWeaponAnim(LocalClientNum_t localClientNum, double _XMM1_8)
{
  __int64 v4; 
  __int64 v5; 
  CgWeaponMap *v6; 
  cg_t *LocalClientGlobals; 
  cg_t *v8; 
  const Weapon *ViewmodelWeapon; 
  bool v10; 
  bool v11; 
  bool HasLadderHand; 
  __int64 v13; 
  int v14; 
  __int64 v15; 
  char v16; 
  _QWORD *v17; 
  PlayerHandIndex v18; 
  bool v19; 
  const dvar_t *v20; 
  cg_t *v21; 
  const WeaponHand *ViewModelHand; 
  const DObj *viewModelDObj; 
  int v25; 
  const char *BoneName; 
  bool v40; 
  __int64 v41; 
  const Weapon *v42; 
  const playerState_s *v43; 
  DObj **v45; 
  PlayerHandIndex v46; 
  __int64 v47; 
  XAnimTree *v48; 
  char *WeaponName; 
  const char *v50; 
  cg_t *v51; 
  unsigned int v52; 
  bool v53; 
  int v54; 
  __int64 entity; 
  CgEntitySystem *v58; 
  unsigned int AudioEventList; 
  __int64 v60; 
  cg_t *v61; 
  CgSoundSystem *SoundSystem; 
  unsigned int *v63; 
  const tmat43_t<vec3_t> *ViewModelTransform; 
  int v65; 
  char *fmt; 
  __int64 recreateAnimTrees; 
  double recreateAnimTreesa; 
  __int64 refreshOverridesOnly; 
  double refreshOverridesOnlya; 
  double tryClearOffset; 
  double v73; 
  double v74; 
  double v75; 
  bool outTryClearOffset; 
  DObj obj; 
  char buffer[4096]; 

  v4 = localClientNum;
  *(_QWORD *)&obj.ignoreCollision.array[2] = CG_GetLocalClientGlobals(localClientNum);
  v5 = *(_QWORD *)&obj.ignoreCollision.array[2];
  if ( !CgWeaponMap::ms_instance[v4] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v6 = CgWeaponMap::ms_instance[v4];
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v4);
  LocalClientGlobals->isJogging = CG_IsJogging((LocalClientNum_t)v4);
  if ( *(int *)(v5 + 20) < 7 )
    goto LABEL_13;
  if ( (unsigned int)v4 >= LODWORD(cl_maxLocalClients) )
  {
    LODWORD(recreateAnimTrees) = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7686, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( (cl_maxLocalClients) )", "localClientNum doesn't index MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", recreateAnimTrees, cl_maxLocalClients) )
      __debugbreak();
  }
  v8 = CG_GetLocalClientGlobals((const LocalClientNum_t)v4);
  if ( !v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7689, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  memset_0(&v8->scopeToggleInfo, 0, sizeof(v8->scopeToggleInfo));
  if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_FREEFALL_RAISE|WEAPON_LADDER_AIM) )
  {
    ResetWeaponAnimTrees((LocalClientNum_t)v4, (const playerState_s *)(v5 + 8));
  }
  else
  {
LABEL_13:
    ViewmodelWeapon = BG_GetViewmodelWeapon(v6, (const playerState_s *)(v5 + 8));
    *(_QWORD *)&obj.ignoreCollision.array[4] = ViewmodelWeapon;
    if ( ViewmodelWeapon->weaponIdx )
    {
      Sys_ProfBeginNamedEvent(0xFFFFFFFF, "view anim - CG_RegisterWeapon");
      v10 = CG_RegisterWeapon((LocalClientNum_t)v4, (const playerState_s *)(v5 + 8), *(const GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64> *)(v5 + 98840), ViewmodelWeapon, (ClientPlayerWeaponInfo *)(v5 + 98976));
      LOBYTE(obj.tree) = v10;
      Sys_ProfEndNamedEvent();
      *(_DWORD *)(v5 + 98848) = BG_PlayerDualWieldingWeapon(v6, (const playerState_s *)(v5 + 8), ViewmodelWeapon);
      if ( *(_QWORD *)(v5 + 98976) )
      {
        __asm { vmovaps [rsp+1548h+var_38], xmm6 }
        v11 = v10 || memcmp_0((const void *)(v5 + 98778), ViewmodelWeapon, 0x3Cui64) || *(_DWORD *)(v5 + 98848) != BG_PlayerDualWieldingWeapon(v6, (const playerState_s *)(v5 + 8), ViewmodelWeapon);
        HasLadderHand = BG_HasLadderHand((const playerState_s *)(v5 + 8));
        if ( *(_DWORD *)(v5 + 98848) || HasLadderHand )
        {
          *(_DWORD *)&obj.entnum = 2;
          v13 = 1i64;
        }
        else
        {
          v13 = 0i64;
          *(_DWORD *)&obj.entnum = 1;
        }
        v14 = *(_DWORD *)(v5 + 896);
        v15 = v13 + 1;
        v16 = v11;
        if ( *(_DWORD *)(v5 + 98924) != v14 )
          v16 = 1;
        *(_DWORD *)(v5 + 98924) = v14;
        v17 = (_QWORD *)(v5 + 807496);
        *(_QWORD *)&obj.ignoreCollision.array[6] = v13 + 1;
        v18 = WEAPON_HAND_DEFAULT;
        *(_QWORD *)obj.ignoreCollision.array = v17;
        v19 = 1;
        *(XAnimTree **)((char *)&obj.tree + 4) = (XAnimTree *)(v13 + 1);
        do
        {
          v20 = DVARBOOL_cg_enableViewModelBoneAndAnimDump;
          if ( !DVARBOOL_cg_enableViewModelBoneAndAnimDump && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_enableViewModelBoneAndAnimDump") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v20);
          if ( v20->current.enabled )
          {
            v21 = CG_GetLocalClientGlobals((const LocalClientNum_t)v4);
            ViewModelHand = cg_t::GetViewModelHand(v21, v18);
            if ( !ViewModelHand->viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2455, ASSERT_TYPE_ASSERT, "(weapHand->viewModelDObj)", (const char *)&queryFormat, "weapHand->viewModelDObj") )
              __debugbreak();
            viewModelDObj = ViewModelHand->viewModelDObj;
            if ( viewModelDObj->skel.mat )
            {
              DObjDisplayAnimToBuffer(viewModelDObj, (const char *)&queryFormat.fmt + 3, buffer, 4096);
              Com_Printf(19, "%s\n", buffer);
              _RBX = 0i64;
              v25 = 0;
              if ( viewModelDObj->numBones )
              {
                do
                {
                  BoneName = DObjGetBoneName(viewModelDObj, v25);
                  _RCX = viewModelDObj->skel.mat;
                  __asm
                  {
                    vmovss  xmm0, dword ptr [rcx+rbx+0Ch]
                    vmovss  xmm1, dword ptr [rcx+rbx+8]
                    vmovss  xmm2, dword ptr [rcx+rbx+4]
                    vmovss  xmm3, dword ptr [rcx+rbx]
                    vmovss  xmm4, dword ptr [rcx+rbx+18h]
                    vmovss  xmm5, dword ptr [rcx+rbx+14h]
                    vmovss  xmm6, dword ptr [rcx+rbx+10h]
                    vcvtss2sd xmm0, xmm0, xmm0
                    vmovsd  [rsp+1548h+var_14F8], xmm0
                    vcvtss2sd xmm1, xmm1, xmm1
                    vmovsd  [rsp+1548h+var_1500], xmm1
                    vcvtss2sd xmm2, xmm2, xmm2
                    vmovsd  [rsp+1548h+var_1508], xmm2
                    vcvtss2sd xmm3, xmm3, xmm3
                    vmovsd  qword ptr [rsp+1548h+tryClearOffset], xmm3
                    vcvtss2sd xmm4, xmm4, xmm4
                    vmovsd  qword ptr [rsp+1548h+refreshOverridesOnly], xmm4
                    vcvtss2sd xmm5, xmm5, xmm5
                    vmovsd  qword ptr [rsp+1548h+recreateAnimTrees], xmm5
                    vcvtss2sd xmm6, xmm6, xmm6
                    vmovsd  [rsp+1548h+fmt], xmm6
                  }
                  Com_Printf(19, "Bone[%d] %s: trans[%.2f, %.2f, %.2f] rot[%.2f, %.2f, %.2f, %.2f]\n", (unsigned int)v25, BoneName, *(double *)&fmt, recreateAnimTreesa, refreshOverridesOnlya, tryClearOffset, v73, v74, v75);
                  _RBX += 32i64;
                  ++v25;
                }
                while ( v25 < viewModelDObj->numBones );
                v15 = *(__int64 *)((char *)&obj.tree + 4);
              }
              else
              {
                v15 = *(__int64 *)((char *)&obj.tree + 4);
              }
            }
            else
            {
              v15 = *(__int64 *)((char *)&obj.tree + 4);
            }
          }
          if ( (unsigned int)v18 >= NUM_WEAPON_HANDS )
          {
            LODWORD(refreshOverridesOnly) = 2;
            LODWORD(recreateAnimTrees) = v18;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", recreateAnimTrees, refreshOverridesOnly) )
              __debugbreak();
          }
          v40 = *v17 == 0i64;
          outTryClearOffset = 1;
          if ( v40 )
            v16 = 1;
          v16 |= CG_UpdateViewmodelAttachments((LocalClientNum_t)v4, v18, &outTryClearOffset);
          if ( !outTryClearOffset )
            v19 = 0;
          ++v18;
          v17 += 5;
          *(XAnimTree **)((char *)&obj.tree + 4) = (XAnimTree *)--v15;
        }
        while ( v15 );
        v41 = *(_QWORD *)&obj.ignoreCollision.array[2];
        v42 = *(const Weapon **)&obj.ignoreCollision.array[4];
        v43 = (const playerState_s *)(*(_QWORD *)&obj.ignoreCollision.array[2] + 8i64);
        if ( (unsigned __int8)v16 | CG_Weapon_UpdateWeaponVisibility((const LocalClientNum_t)v4, (const playerState_s *)(*(_QWORD *)&obj.ignoreCollision.array[2] + 8i64), *(const Weapon **)&obj.ignoreCollision.array[4], 0) )
        {
          Sys_ProfBeginNamedEvent(0xFFFFFFFF, "view anim - CG_Weapon_ChangeViewmodelDobj");
          CG_Weapon_ChangeViewmodelDobj((LocalClientNum_t)v4, v43, v42, *(XModel **)(v41 + 98976), 0, (bool)obj.tree, 0, v19);
          Sys_ProfEndNamedEvent();
        }
        Sys_ProfBeginNamedEvent(0xFFFFFFFF, "view anim - update hands");
        __asm { vmovss  xmm6, cs:__real@3a83126f }
        v45 = *(DObj ***)obj.ignoreCollision.array;
        v46 = WEAPON_HAND_DEFAULT;
        v47 = 98948i64;
        v48 = NULL;
        *(XAnimTree **)((char *)&obj.tree + 4) = NULL;
        do
        {
          if ( (unsigned int)v46 >= NUM_WEAPON_HANDS )
          {
            LODWORD(refreshOverridesOnly) = 2;
            LODWORD(recreateAnimTrees) = v46;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", recreateAnimTrees, refreshOverridesOnly) )
              __debugbreak();
          }
          if ( *v45 )
          {
            v51 = CG_GetLocalClientGlobals((const LocalClientNum_t)v4);
            if ( GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&v51->predictedPlayerState.pm_flags, ACTIVE, 0x10u) || BG_IsPlayerFireDisabledForHand(&v51->predictedPlayerState, v46) )
            {
              *(_DWORD *)((char *)&v51->__vftable + v47) = 0;
            }
            else
            {
              v52 = *(int *)((_BYTE *)&v51->predictedPlayerState.weapState[0].weapAnim + (_QWORD)v48) & 0xFFFFFF7F;
              if ( v52 == 3 )
              {
                if ( *(int *)((char *)&v51->__vftable + v47) <= 0 )
                  *(_DWORD *)((char *)&v51->__vftable + v47) = v51->time;
              }
              else if ( v52 )
              {
                *(_DWORD *)((char *)&v51->__vftable + v47) = 0;
              }
              else if ( *(int *)((char *)&v51->__vftable + v47) > 0 )
              {
                *(_DWORD *)((char *)&v51->__vftable + v47) = 0;
              }
            }
            WeaponRunXModelAnims((LocalClientNum_t)v4, v43, v46);
            DObjResetClientNotifyList();
            LOBYTE(v54) = !BG_Ladder_IsActive(v43) || v46 == WEAPON_HAND_LEFT;
            __asm
            {
              vxorps  xmm0, xmm0, xmm0
              vcvtsi2ss xmm0, xmm0, dword ptr [rax+65E4h]
              vmulss  xmm2, xmm0, xmm6
            }
            DObjUpdateClientInfo(&obj, *(float *)&_XMM1_8, v53, v54);
            entity = v43->vehicleState.entity;
            if ( (_DWORD)entity == 2047 )
              goto LABEL_88;
            if ( !(_BYTE)CgEntitySystem::ms_allocatedType )
            {
              LODWORD(refreshOverridesOnly) = v4;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 288, ASSERT_TYPE_ASSERT, "(ms_allocatedType != GameModeType::NONE)", "%s\n\tTrying to access the entity system for localClientNum %d but the entity system type is not known\n", "ms_allocatedType != GameModeType::NONE", refreshOverridesOnly) )
                __debugbreak();
            }
            if ( (unsigned int)v4 >= CgEntitySystem::ms_allocatedCount )
            {
              LODWORD(refreshOverridesOnly) = CgEntitySystem::ms_allocatedCount;
              LODWORD(recreateAnimTrees) = v4;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 289, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( ms_allocatedCount )", "localClientNum doesn't index ms_allocatedCount\n\t%i not in [0, %i)", recreateAnimTrees, refreshOverridesOnly) )
                __debugbreak();
            }
            if ( !CgEntitySystem::ms_entitySystemArray[v4] )
            {
              LODWORD(refreshOverridesOnly) = v4;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 290, ASSERT_TYPE_ASSERT, "(ms_entitySystemArray[localClientNum])", "%s\n\tTrying to access unallocated entity system for localClientNum %d\n", "ms_entitySystemArray[localClientNum]", refreshOverridesOnly) )
                __debugbreak();
            }
            v58 = CgEntitySystem::ms_entitySystemArray[v4];
            if ( (unsigned int)entity >= 0x800 )
            {
              LODWORD(refreshOverridesOnly) = 2048;
              LODWORD(recreateAnimTrees) = entity;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 518, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( (( 2048 ) + 0) )", "entityIndex doesn't index MAX_LOCAL_CENTITIES\n\t%i not in [0, %i)", recreateAnimTrees, refreshOverridesOnly) )
                __debugbreak();
            }
            if ( (v58->m_entities[entity].flags & 1) == 0 || !BG_IsVehicleEntity(&v58->m_entities[entity].nextState) )
            {
LABEL_88:
              CG_Weapons_ProcessWeaponNoteTracks((LocalClientNum_t)v4, v43, *v45, v46, (const XAnimNotifyHandle)obj.tree);
              AudioEventList = XAnimBonePhysicsGetAudioEventList(*v45, (XAnimBonePhysicsAudioEvent *)&obj.skel.partBits.anim.array[5], 3u);
              v60 = AudioEventList;
              if ( AudioEventList )
              {
                v61 = CG_GetLocalClientGlobals((const LocalClientNum_t)v4);
                SoundSystem = CgSoundSystem::GetSoundSystem((const LocalClientNum_t)v4);
                v63 = &obj.skel.partBits.anim.array[5];
                do
                {
                  ViewModelTransform = cg_t::GetViewModelTransform(v61);
                  MatrixTransformVector43((const vec3_t *)(v63 + 2), ViewModelTransform, (vec3_t *)&obj.locked);
                  CgSoundSystem::PlaySoundAliasByLookup(SoundSystem, v61->predictedPlayerState.clientNum, (const vec3_t *)&obj.locked, *(SndAliasLookup *)v63);
                  v63 += 6;
                  --v60;
                }
                while ( v60 );
                v45 = *(DObj ***)obj.ignoreCollision.array;
              }
              v48 = *(XAnimTree **)((char *)&obj.tree + 4);
            }
            CG_NightVisionProcessNoteTracks((LocalClientNum_t)v4, v43, *v45, v46);
            v42 = *(const Weapon **)&obj.ignoreCollision.array[4];
          }
          else
          {
            WeaponName = BG_GetWeaponName(v42, (char *)&obj.skel.partBits.skel.array[1], 0x400u);
            v50 = "left";
            if ( v46 == WEAPON_HAND_DEFAULT )
              v50 = "right";
            Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1442DF120, 615i64, (unsigned int)v4, WeaponName, v50);
          }
          v45 += 5;
          v48 = (XAnimTree *)((char *)v48 + 80);
          ++v46;
          *(_QWORD *)obj.ignoreCollision.array = v45;
          v47 += 4i64;
          *(XAnimTree **)((char *)&obj.tree + 4) = v48;
          --*(_QWORD *)&obj.ignoreCollision.array[6];
        }
        while ( *(_QWORD *)&obj.ignoreCollision.array[6] );
        v65 = *(_DWORD *)&obj.entnum;
        __asm { vmovaps xmm6, [rsp+1548h+var_38] }
        if ( *(_DWORD *)&obj.entnum < 2u )
        {
          do
            CG_Gesture_ShutdownSlots((LocalClientNum_t)v4, (const PlayerHandIndex)v65++);
          while ( v65 < 2 );
        }
        Sys_ProfEndNamedEvent();
      }
      else
      {
        CG_Weapon_ViewModelDobj_CleanUp((const LocalClientNum_t)v4);
      }
    }
  }
}

/*
==============
CG_UpdateViewmodelAttachments
==============
*/
char CG_UpdateViewmodelAttachments(LocalClientNum_t localClientNum, PlayerHandIndex hand, bool *outTryClearOffset)
{
  __int64 v4; 
  __int64 v6; 
  __int64 rocketModel; 
  CgWeaponSystem *WeaponSystem; 
  int v10; 
  int v11; 
  WeaponDef **v14; 
  WeaponDef *v15; 
  playerState_s *p_predictedPlayerState; 
  bool v17; 
  const BgWeaponMap **v18; 
  Gesture *Gesture; 
  Gesture *v25; 
  bool IsPlaying; 
  bool v27; 
  playerState_s *v28; 
  CgWeaponMap *Instance; 
  const Weapon *CurrentWeaponForPlayer; 
  __int64 v31; 
  int ammoInClipBeforeReload; 
  CgHandler *Handler; 
  int v34; 
  bool IsEMPJammed; 
  __int64 gestureAnimType; 
  __int64 ammoInClip; 
  bool hasFastReloadOverride; 
  bool v40; 
  PlayerHandIndex handa; 
  __int64 v42; 
  XModel *nightVisionGoggles; 
  CgWeaponSystem *v44; 
  bool *v45; 
  __int64 v46; 
  Weapon r_weapon; 

  v4 = hand;
  handa = hand;
  v45 = outTryClearOffset;
  v6 = localClientNum;
  if ( !outTryClearOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11988, ASSERT_TYPE_ASSERT, "(outTryClearOffset)", (const char *)&queryFormat, "outTryClearOffset") )
    __debugbreak();
  nightVisionGoggles = NULL;
  rocketModel = 0i64;
  v42 = 0i64;
  _RSI = CG_GetLocalClientGlobals((const LocalClientNum_t)v6);
  WeaponSystem = CgWeaponSystem::GetWeaponSystem((const LocalClientNum_t)v6);
  v10 = *(_DWORD *)&_RSI->playerWeaponInfo.weapon.weaponCamo;
  v11 = *(_DWORD *)&_RSI->playerWeaponInfo.weapon.weaponIdx;
  __asm
  {
    vmovups xmm0, xmmword ptr [rsi+182D0h]
    vmovsd  xmm1, qword ptr [rsi+182E0h]
  }
  v44 = WeaponSystem;
  *(_DWORD *)&r_weapon.weaponCamo = v10;
  __asm
  {
    vmovups xmmword ptr [rsp+0F8h+r_weapon.attachmentVariationIndices+5], xmm0
    vmovsd  qword ptr [rsp+0F8h+r_weapon.attachmentVariationIndices+15h], xmm1
  }
  if ( (unsigned __int16)v11 > bg_lastParsedWeaponIndex )
  {
    LODWORD(gestureAnimType) = (unsigned __int16)v11;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1203, ASSERT_TYPE_ASSERT, "( weaponIdx ) <= ( bg_lastParsedWeaponIndex )", "weaponIdx not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", gestureAnimType, bg_lastParsedWeaponIndex) )
      __debugbreak();
  }
  v14 = &bg_weaponDefs[(unsigned __int16)v11];
  if ( !*v14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1204, ASSERT_TYPE_ASSERT, "(bg_weaponDefs[weaponIdx])", (const char *)&queryFormat, "bg_weaponDefs[weaponIdx]") )
    __debugbreak();
  v15 = *v14;
  if ( (unsigned int)v4 >= 2 )
  {
    LODWORD(ammoInClip) = 2;
    LODWORD(gestureAnimType) = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", gestureAnimType, ammoInClip) )
      __debugbreak();
  }
  *outTryClearOffset = 1;
  v46 = (__int64)_RSI + 40 * v4;
  p_predictedPlayerState = &CG_GetLocalClientGlobals((const LocalClientNum_t)v6)->predictedPlayerState;
  v17 = BG_UsingAlternate(p_predictedPlayerState);
  v18 = (const BgWeaponMap **)&CgWeaponMap::ms_instance[v6];
  hasFastReloadOverride = BG_PlayerDualWielding(p_predictedPlayerState) == 1;
  if ( !*v18 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  _RAX = BG_GetViewmodelWeapon(*v18, p_predictedPlayerState);
  __asm
  {
    vmovups ymm2, ymmword ptr [rax]
    vmovups ymmword ptr [rsp+0F8h+r_weapon.weaponIdx], ymm2
    vmovups xmm0, xmmword ptr [rax+20h]
    vmovups xmmword ptr [rsp+0F8h+r_weapon.attachmentVariationIndices+5], xmm0
    vmovsd  xmm1, qword ptr [rax+30h]
    vmovsd  qword ptr [rsp+0F8h+r_weapon.attachmentVariationIndices+15h], xmm1
    vmovd   ebx, xmm2
  }
  *(_DWORD *)&r_weapon.weaponCamo = *(_DWORD *)&_RAX->weaponCamo;
  if ( (unsigned __int16)_EBX > bg_lastParsedWeaponIndex )
  {
    LODWORD(ammoInClip) = bg_lastParsedWeaponIndex;
    LODWORD(gestureAnimType) = (unsigned __int16)_EBX;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1203, ASSERT_TYPE_ASSERT, "( weaponIdx ) <= ( bg_lastParsedWeaponIndex )", "weaponIdx not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", gestureAnimType, ammoInClip) )
      __debugbreak();
  }
  if ( !bg_weaponDefs[(unsigned __int16)_EBX] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1204, ASSERT_TYPE_ASSERT, "(bg_weaponDefs[weaponIdx])", (const char *)&queryFormat, "bg_weaponDefs[weaponIdx]") )
    __debugbreak();
  Gesture = BG_Suit_GetGesture(p_predictedPlayerState, WEAPON_HAND_DEFAULT, &r_weapon, v17, hasFastReloadOverride, GESTUREANIMTYPE_NVG_ON);
  v25 = BG_Suit_GetGesture(p_predictedPlayerState, WEAPON_HAND_DEFAULT, &r_weapon, v17, hasFastReloadOverride, GESTUREANIMTYPE_NVG_OFF);
  LOBYTE(Gesture) = BG_NightVisionGestureIsPlaying(p_predictedPlayerState, Gesture, NULL, NULL);
  IsPlaying = BG_NightVisionGestureIsPlaying(p_predictedPlayerState, v25, NULL, NULL);
  if ( (_BYTE)Gesture || IsPlaying )
    nightVisionGoggles = cgMedia.nightVisionGoggles;
  v27 = v44->UpdateWeaponAttachModels(v44) != 0;
  if ( !v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11925, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  if ( v15->rocketModel )
  {
    v28 = &CG_GetLocalClientGlobals((const LocalClientNum_t)v6)->predictedPlayerState;
    v40 = BG_UsingAlternate(v28);
    Instance = CgWeaponMap::GetInstance((const LocalClientNum_t)v6);
    CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(Instance, v28);
    if ( BG_GetAmmoInClip(v28, CurrentWeaponForPlayer, v40, (PlayerHandIndex)v4) || (v31 = v4, (unsigned int)(v28->weapState[v31].weaponState - 18) <= 3) && (ammoInClipBeforeReload = v28->weapState[v31].ammoInClipBeforeReload, hasFastReloadOverride = 0, Handler = CgHandler::getHandler((LocalClientNum_t)v6), v34 = BG_ReloadTime(v28, Handler, handa, CurrentWeaponForPlayer, v40, 0, ammoInClipBeforeReload, &hasFastReloadOverride) - v28->weapState[v31].weaponTime, v34 > BG_GetWeaponFieldTime(v28, CurrentWeaponForPlayer, 0, 0, 74i64)) )
      rocketModel = (__int64)v15->rocketModel;
    else
      rocketModel = v42;
  }
  if ( nightVisionGoggles != _RSI->playerWeaponInfo.gogglesModel )
  {
    _RSI->playerWeaponInfo.gogglesModel = nightVisionGoggles;
    v27 = 1;
    *v45 = 0;
  }
  if ( rocketModel != *(_QWORD *)(v46 + 807512) )
  {
    *(_QWORD *)(v46 + 807512) = rocketModel;
    v27 = 1;
  }
  IsEMPJammed = CG_View_IsEMPJammed((const LocalClientNum_t)v6);
  if ( IsEMPJammed == _RSI->playerWeaponInfo.hideReticle )
    return v27;
  _RSI->playerWeaponInfo.hideReticle = IsEMPJammed;
  return 1;
}

/*
==============
CG_UpdateWeaponViewmodels
==============
*/
void CG_UpdateWeaponViewmodels(LocalClientNum_t localClientNum)
{
  __int64 v4; 
  CgWeaponMap *v7; 
  unsigned int i; 
  const Weapon *Weapon; 
  CgHandler *Handler; 
  const Weapon *ViewmodelWeapon; 
  bool v15; 
  int v20; 
  int v23; 
  bool v25; 
  bool HasLadderHand; 
  char prevLadderHand; 
  char v28; 
  bool updated; 
  char v30; 
  char v31; 
  bool dualViewScopeRefreshDobj; 
  char v33; 
  bool v34; 
  char v35; 
  bool v36; 
  char v37; 
  char v38; 
  char v43; 
  char v44; 
  CgWeaponSystem *WeaponSystem; 
  cg_t *LocalClientGlobals; 
  char v47; 
  char v50; 
  char v51; 
  CgWeaponSystem *v52; 
  const centity_t *predictedPlayerEntity; 
  ClientChargeWeaponInfo *InfoStruct; 
  bool v55; 
  bool v59; 
  int weaponState; 
  cg_t *v61; 
  DObj *const *p_viewModelDObj; 
  int v63; 
  __int64 v64; 
  cg_t *v66; 
  __int64 v67; 
  bool v68; 
  DObj *v69; 
  const XModel *gestureWeapModel; 
  int ModelIndex; 
  scr_string_t v72; 
  DObjPartBits *p_hidePartBits; 
  char v74; 
  bool v75; 
  bool v77; 
  CgHandler *v78; 
  CgHandler *v86; 
  bool v87; 
  const dvar_t *v88; 
  float fmt; 
  __int64 recreateAnimTrees; 
  __int64 refreshOverridesOnly; 
  bool refreshViewmodelMaterialOverride; 
  bool v103; 
  bool v104; 
  bool CanHybridToggle; 
  char v106; 
  Weapon *r_weapon; 
  cg_t *v108; 
  BgWeaponMap *weaponMap; 
  Weapon outAccessoryWeapon; 
  __m256i Buf2; 
  int v115; 
  GfxScopeInfo settingOut; 
  char v117; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm6
    vmovaps xmmword ptr [rax-48h], xmm7
  }
  v4 = localClientNum;
  _R15 = CG_GetLocalClientGlobals(localClientNum);
  v108 = _R15;
  _RSI = &_R15->predictedPlayerState;
  refreshViewmodelMaterialOverride = _R15->refreshViewmodelMaterialOverride;
  if ( !CgWeaponMap::ms_instance[v4] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v7 = CgWeaponMap::ms_instance[v4];
  weaponMap = v7;
  for ( i = 0; i < 0xF; ++i )
  {
    if ( !v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 839, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    if ( _R15 == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 840, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    Weapon = BgWeaponMap::GetWeapon(v7, _RSI->weaponsEquipped[i]);
    if ( Weapon->weaponIdx )
      CG_TouchViewModel((const LocalClientNum_t)v4, Weapon, _R15->playerWeaponInfo.isWeaponDefault, _RSI);
  }
  Handler = CgHandler::getHandler((LocalClientNum_t)v4);
  if ( !CgWeaponMap::ms_instance[v4] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  BG_UpdateWeaponAnimArrays(CgWeaponMap::ms_instance[v4], _RSI, Handler);
  __asm
  {
    vmovups ymm0, ymmword ptr cs:?NULL_WEAPON@@3UWeapon@@B.weaponIdx; Weapon const NULL_WEAPON
    vmovups xmm1, xmmword ptr cs:?NULL_WEAPON@@3UWeapon@@B.attachmentVariationIndices+5; Weapon const NULL_WEAPON
  }
  ViewmodelWeapon = BG_GetViewmodelWeapon(v7, _RSI);
  __asm
  {
    vmovups ymmword ptr [rbp+130h+outAccessoryWeapon.weaponIdx], ymm0
    vmovsd  xmm0, qword ptr cs:?NULL_WEAPON@@3UWeapon@@B.attachmentVariationIndices+15h; Weapon const NULL_WEAPON
    vmovsd  qword ptr [rbp+130h+outAccessoryWeapon.attachmentVariationIndices+15h], xmm0
    vmovups xmmword ptr [rbp+130h+outAccessoryWeapon.attachmentVariationIndices+5], xmm1
  }
  *(_DWORD *)&outAccessoryWeapon.weaponCamo = *(_DWORD *)&NULL_WEAPON.weaponCamo;
  r_weapon = (Weapon *)ViewmodelWeapon;
  if ( _R15->predictedPlayerState.accessoryIndex != 127 )
    BG_Accessory_GetWeapon(v7, _RSI, &outAccessoryWeapon);
  v15 = ViewmodelWeapon->weaponIdx && BG_UsingAlternate(_RSI) != _R15->playerWeaponInfo.isAlternate;
  _RAX = BG_GetOffhandGestureWeapon(v7, _RSI);
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovups xmm6, xmmword ptr [rax+20h]
    vmovsd  xmm7, qword ptr [rax+30h]
  }
  v20 = *(_DWORD *)&_RAX->weaponCamo;
  __asm { vmovd   eax, xmm0 }
  v115 = v20;
  __asm
  {
    vmovups [rsp+230h+var_1C8+8], ymm0
    vmovups [rbp+130h+Buf2], ymm0
    vmovups [rbp+130h+var_140], xmm6
    vmovsd  [rbp+130h+var_130], xmm7
  }
  if ( !(_WORD)_RAX )
  {
    _RAX = BG_GetOffhandScriptWeapon(v7, _RSI);
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovups xmm6, xmmword ptr [rax+20h]
      vmovsd  xmm7, qword ptr [rax+30h]
    }
    v20 = *(_DWORD *)&_RAX->weaponCamo;
    __asm
    {
      vmovups [rsp+230h+var_1C8+8], ymm0
      vmovups [rbp+130h+Buf2], ymm0
      vmovups [rbp+130h+var_140], xmm6
      vmovsd  [rbp+130h+var_130], xmm7
    }
    v115 = v20;
  }
  v23 = memcmp_0(&_R15->gestureWeapInfo, &Buf2, 0x3Cui64);
  __asm
  {
    vmovups ymm0, [rsp+230h+var_1C8+8]
    vmovups ymmword ptr [r15+77E10h], ymm0
    vmovups xmmword ptr [r15+77E30h], xmm6
    vmovsd  qword ptr [r15+77E40h], xmm7
  }
  v25 = v23 != 0;
  *(_DWORD *)&_R15->gestureWeapInfo.offhandGestureWeapon.weaponCamo = v20;
  v104 = v23 != 0;
  HasLadderHand = BG_HasLadderHand(_RSI);
  prevLadderHand = _R15->prevLadderHand;
  v28 = HasLadderHand;
  _R15->prevLadderHand = BG_HasLadderHand(_RSI);
  updated = CG_Weapon_UpdateWeaponVisibility((const LocalClientNum_t)v4, _RSI, r_weapon, 0);
  v30 = v15;
  if ( prevLadderHand != v28 )
    v30 = 1;
  v31 = v25 | v30 | updated;
  dualViewScopeRefreshDobj = _R15->dualViewScopeRefreshDobj;
  v106 = v31;
  v33 = dualViewScopeRefreshDobj | (memcmp_0(&_R15->playerWeaponInfo.weapon, r_weapon, 0x3Cui64) != 0);
  v34 = !memcmp_0(&_R15->playerWeaponInfo.weapon, r_weapon, 0x3Cui64) && _R15->playerWeaponInfo.meleeComboSeqIdx != _R15->predictedPlayerState.weapCommon.meleeComboSeqIdx;
  v35 = v34 | ViewModelScriptedStateChanged((LocalClientNum_t)v4, _RSI);
  v36 = CG_Skydive_GetViewmodelState((const LocalClientNum_t)v4) == _R15->playerWeaponInfo.skydiveViewmodelState;
  v37 = v106;
  if ( !v36 )
    v35 = 1;
  if ( _R15->predictedPlayerState.carryState.carryObjectIndex != _R15->playerWeaponInfo.carryObjectIndex )
    v37 = 1;
  v38 = v33 | v37 | v35;
  _RDI = CG_GetLocalClientGlobals((const LocalClientNum_t)v4);
  if ( memcmp_0(&outAccessoryWeapon, &_RDI->playerWeaponInfo.accessoryWeapon, 0x3Cui64) )
  {
    *(_WORD *)&_RDI->playerWeaponInfo.isAccessoryHidden = 257;
    __asm
    {
      vmovups ymm0, ymmword ptr [rbp+130h+outAccessoryWeapon.weaponIdx]
      vmovups ymmword ptr [rdi+18328h], ymm0
      vmovups xmm1, xmmword ptr [rbp+130h+outAccessoryWeapon.attachmentVariationIndices+5]
      vmovups xmmword ptr [rdi+18348h], xmm1
      vmovsd  xmm0, qword ptr [rbp+130h+outAccessoryWeapon.attachmentVariationIndices+15h]
      vmovsd  qword ptr [rdi+18358h], xmm0
    }
    v38 = dualViewScopeRefreshDobj | 1;
    *(_DWORD *)&_RDI->playerWeaponInfo.accessoryWeapon.weaponCamo = *(_DWORD *)&outAccessoryWeapon.weaponCamo;
  }
  v43 = 0;
  v44 = 0;
  WeaponSystem = CgWeaponSystem::GetWeaponSystem((const LocalClientNum_t)v4);
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v4);
  if ( !WeaponSystem->IsWeaponViewModelLoaded(WeaponSystem, &outAccessoryWeapon) )
  {
    if ( BG_HasDefaultViewModel(&outAccessoryWeapon) )
      v43 = 1;
    else
      v44 = 1;
  }
  if ( v44 == LocalClientGlobals->playerWeaponInfo.isAccessoryHidden )
  {
    v47 = 0;
  }
  else
  {
    LocalClientGlobals->playerWeaponInfo.isAccessoryHidden = v44;
    v47 = 1;
  }
  if ( v43 != LocalClientGlobals->playerWeaponInfo.isAccessoryDefault )
  {
    LocalClientGlobals->playerWeaponInfo.isAccessoryDefault = v43;
    v47 = 1;
  }
  _R15 = r_weapon;
  _R12 = v108;
  v50 = v47;
  if ( v108->prevDualWielding != BG_PlayerDualWieldingWeapon(weaponMap, _RSI, r_weapon) )
    v50 = 1;
  v51 = v38 | v50;
  if ( v51 || refreshViewmodelMaterialOverride )
  {
    v52 = CgWeaponSystem::GetWeaponSystem((const LocalClientNum_t)v4);
    if ( !v52 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12352, ASSERT_TYPE_ASSERT, "(weaponSystem)", (const char *)&queryFormat, "weaponSystem") )
      __debugbreak();
    predictedPlayerEntity = v108->predictedPlayerEntity;
    InfoStruct = CgWeaponSystem::ChargedWeaponGetInfoStruct(v52, predictedPlayerEntity->nextState.number);
    if ( InfoStruct && InfoStruct->currentWeapon.weaponIdx )
      CgWeaponSystem::ChargedWeaponClearViewModelFX(v52, predictedPlayerEntity);
    CgWeaponSystem::ChargedWeaponClearClientOnlyChargeAmountOverride(v52, _RSI);
    CgWeaponSystem::OffhandWeaponVmFxStopAll(v52);
    v55 = refreshViewmodelMaterialOverride && !v51;
    CG_Weapon_ChangeViewmodelDobj((LocalClientNum_t)v4, _RSI, r_weapon, v108->playerWeaponInfo.handModel, 1, 0, v55, !v104);
    v108->refreshViewmodelMaterialOverride = 0;
    v108->dualViewScopeRefreshDobj = 0;
    v108->playerWeaponInfo.meleeComboSeqIdx = _RSI->weapCommon.meleeComboSeqIdx;
    v108->playerWeaponInfo.skydiveViewmodelState = CG_Skydive_GetViewmodelState((const LocalClientNum_t)v4);
    if ( r_weapon->weaponIdx )
    {
      v108->playerWeaponInfo.isAlternate = BG_UsingAlternate(_RSI);
      v108->playerWeaponInfo.carryObjectIndex = _RSI->carryState.carryObjectIndex;
    }
    else
    {
      v108->playerWeaponInfo.isAlternate = 0;
      __asm
      {
        vmovups ymm0, ymmword ptr [r15]
        vmovups ymmword ptr [r12+181DAh], ymm0
        vmovups xmm1, xmmword ptr [r15+20h]
        vmovups xmmword ptr [r12+181FAh], xmm1
        vmovsd  xmm0, qword ptr [r15+30h]
        vmovsd  qword ptr [r12+1820Ah], xmm0
      }
      *(_DWORD *)&v108->prevViewmodelWeapon.weaponCamo = *(_DWORD *)&r_weapon->weaponCamo;
      v108->playerWeaponInfo.carryObjectIndex = 64;
    }
  }
  if ( (unsigned int)(v108->lastWeaponState - 2) > 2 || (unsigned int)(_RSI->weapState[0].weaponState - 2) <= 2 )
  {
    weaponState = _RSI->weapState[0].weaponState;
    if ( (unsigned int)(weaponState - 2) > 1 && weaponState != 4 )
      goto LABEL_70;
    v59 = !v108->playerWeaponInfo.isAlternate;
  }
  else
  {
    v59 = BG_UsingAlternate(_RSI);
  }
  CG_ProcessWeaponOnAltChange((const LocalClientNum_t)v4, v59);
  weaponState = _RSI->weapState[0].weaponState;
LABEL_70:
  v108->lastWeaponState = weaponState;
  v61 = CG_GetLocalClientGlobals((const LocalClientNum_t)v4);
  if ( !v61 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9893, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  p_viewModelDObj = &v108->m_weaponHand[0].viewModelDObj;
  v63 = 0;
  v61->viewModelAnimScriptedInfo.lastScriptedAnimStartTime = _RSI->viewModelAnimScripted.animStartTime;
  v64 = -807496i64 - (_QWORD)v108;
  v61->viewModelAnimScriptedInfo.lastAnimIndex = _RSI->viewModelAnimScripted.animIndex;
  __asm { vxorps  xmm7, xmm7, xmm7 }
  do
  {
    v66 = CG_GetLocalClientGlobals((const LocalClientNum_t)v4);
    if ( !v66 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11197, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
      __debugbreak();
    if ( v66->gestureWeapInfo.offhandGestureWeapon.weaponIdx )
    {
      if ( (unsigned int)v63 >= 2 )
      {
        LODWORD(refreshOverridesOnly) = 2;
        LODWORD(recreateAnimTrees) = v63;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", recreateAnimTrees, refreshOverridesOnly) )
          __debugbreak();
      }
      v67 = (__int64)v66->m_weaponHand + (_QWORD)p_viewModelDObj + v64;
      if ( !v67 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11205, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
        __debugbreak();
      if ( *(_QWORD *)(v67 + 8) )
      {
        if ( !CgWeaponMap::ms_instance[v4] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
          __debugbreak();
        v68 = BG_PlayerOrEntityDualWielding(CgWeaponMap::ms_instance[v4], &v66->predictedPlayerState, NULL, NULL);
        if ( v63 )
        {
          if ( v63 == 1 && !v68 )
            goto LABEL_103;
        }
        else if ( v68 )
        {
          goto LABEL_103;
        }
        CG_OffhandGestureWeapon_SetVisibilityState((LocalClientNum_t)v4, (const PlayerHandIndex)v63);
        if ( v66->gestureWeapInfo.shouldBeVisible != v66->gestureWeapInfo.isGestureWeapVisible )
        {
          if ( (unsigned int)v63 >= 2 )
          {
            LODWORD(refreshOverridesOnly) = 2;
            LODWORD(recreateAnimTrees) = v63;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", recreateAnimTrees, refreshOverridesOnly) )
              __debugbreak();
          }
          v69 = *(DObj **)v67;
          if ( v69 )
          {
            gestureWeapModel = v66->gestureWeapInfo.gestureWeapModel;
            if ( gestureWeapModel )
            {
              ModelIndex = DObjGetModelIndex(v69, gestureWeapModel);
              v72 = *v66->gestureWeapInfo.gestureWeapModel->boneNames;
              if ( v72 )
              {
                p_hidePartBits = &v69->hidePartBits;
                if ( v66->gestureWeapInfo.shouldBeVisible )
                {
                  BG_ShowBone(v72, v69, p_hidePartBits, ModelIndex);
                  v66->gestureWeapInfo.isGestureWeapVisible = 1;
                }
                else
                {
                  BG_HideBone(v72, v69, p_hidePartBits, ModelIndex);
                  v66->gestureWeapInfo.isGestureWeapVisible = 0;
                }
              }
            }
          }
        }
      }
    }
LABEL_103:
    CG_UpdateViewModelHidePartBits_NightVisionGoggles((LocalClientNum_t)v4, (const PlayerHandIndex)v63);
    if ( (unsigned int)v63 >= 2 )
    {
      LODWORD(refreshOverridesOnly) = 2;
      LODWORD(recreateAnimTrees) = v63;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", recreateAnimTrees, refreshOverridesOnly) )
        __debugbreak();
    }
    if ( *p_viewModelDObj )
    {
      v74 = 1;
      if ( GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&_RSI->weapCommon.weapFlags, ACTIVE, 0x22u) || !GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&_RSI->weapCommon.weapFlags, ACTIVE, 0x11u) && !GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&_RSI->weapCommon.weapFlags, ACTIVE, 0x1Bu) )
        v74 = 0;
      CanHybridToggle = BG_CanHybridToggle(_RSI, r_weapon, v74);
      v75 = BG_WeaponAttachmentAdsSmoothFade(r_weapon, v74);
      __asm { vmovss  xmm6, dword ptr [rsi+730h] }
      v77 = v75;
      v78 = CgHandler::getHandler((LocalClientNum_t)v4);
      __asm { vmovss  dword ptr [rsp+230h+fmt], xmm6 }
      BG_GetScopeLensSettings(v78, _RSI, r_weapon, v74, fmt, &v108->scopeToggleInfo.fractionInfo, &settingOut);
      __asm { vmovaps xmm0, xmm6 }
      if ( v77 )
      {
        __asm { vmovss  xmm6, [rbp+130h+settingOut.scopeFadeInfo.fadeInFrac] }
        _EAX = 0;
        __asm { vmovd   xmm1, eax }
        _EAX = CanHybridToggle;
        __asm
        {
          vmovd   xmm0, eax
          vpcmpeqd xmm2, xmm0, xmm1
          vmovss  xmm1, [rbp+130h+settingOut.scopeFadeInfo.fadeInFrac+8]
          vblendvps xmm0, xmm1, xmm6, xmm2; adsFrac
        }
      }
      BG_UpdateWeaponGlass(*(const float *)&_XMM0, *p_viewModelDObj, v77);
      CG_GameInterface_UpdateWeaponViewmodelHand((LocalClientNum_t)v4, (PlayerHandIndex)v63);
      if ( BG_CurrentWeaponSupportsDualFOV(weaponMap, _RSI) )
      {
        v86 = CgHandler::getHandler((LocalClientNum_t)v4);
        v87 = BG_PlayerUsesNVGHalfADS(_RSI, v86);
        v88 = DCONST_DVARBOOL_bg_debugSniperScene;
        v103 = v87;
        if ( !DCONST_DVARBOOL_bg_debugSniperScene && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_debugSniperScene") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v88);
        if ( v88->current.enabled )
        {
          __asm { vmovaps xmm3, xmm6; frac }
          BG_DebugSniperScene(r_weapon, v74, *p_viewModelDObj, *(float *)&_XMM3);
        }
        else if ( v77 )
        {
          _EAX = 0;
          __asm { vmovd   xmm1, eax }
          _EAX = v103;
          __asm
          {
            vmovd   xmm0, eax
            vpcmpeqd xmm2, xmm0, xmm1
            vblendvps xmm3, xmm7, xmm6, xmm2; adsFrac
          }
          BG_SmoothFadeSniperScene(r_weapon, v74, *p_viewModelDObj, *(float *)&_XMM3);
        }
        else if ( CG_View_IsUsingDualFOV((const LocalClientNum_t)v4) && v108->dualViewScope && !v103 )
        {
          BG_ShowSniperScene(r_weapon, v74, *p_viewModelDObj);
        }
        else
        {
          BG_HideSniperScene(r_weapon, *p_viewModelDObj);
        }
      }
    }
    v64 = -807496i64 - (_QWORD)v108;
    ++v63;
    p_viewModelDObj += 5;
  }
  while ( v63 < 2 );
  _R11 = &v117;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
  }
}

/*
==============
CG_ValidateWeaponAnimGroupsUniqueness
==============
*/
void CG_ValidateWeaponAnimGroupsUniqueness(void)
{
  unsigned __int64 v0; 
  const WeapAnimGroup (*v1)[7]; 
  unsigned __int64 v2; 
  const WeapAnimGroup (*v3)[7]; 
  __int64 v4; 
  __int64 v5; 
  char v6[624]; 

  if ( !validationExecuted )
  {
    validationExecuted = 1;
    memset_0(v6, 0, 0x266ui64);
    v0 = 0i64;
    if ( g_weapAnimGroupCount )
    {
      v1 = g_weapAnimGroups;
      while ( 2 )
      {
        v2 = 0i64;
        v3 = v1;
        do
        {
          if ( !*(_DWORD *)v3 )
            break;
          if ( *(_DWORD *)v3 >= 0x266u )
          {
            LODWORD(v5) = 614;
            LODWORD(v4) = *(_DWORD *)v3;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2777, ASSERT_TYPE_ASSERT, "(unsigned)( groupEntry->animIndex ) < (unsigned)( NUM_WEAP_ANIMS )", "groupEntry->animIndex doesn't index NUM_WEAP_ANIMS\n\t%i not in [0, %i)", v4, v5) )
              __debugbreak();
          }
          if ( v6[*(_DWORD *)v3] )
          {
            Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1442DB330, 603i64);
            return;
          }
          ++v2;
          v6[*(_DWORD *)v3] = 1;
          v3 = (const WeapAnimGroup (*)[7])((char *)v3 + 16);
        }
        while ( v2 < 7 );
        ++v0;
        ++v1;
        if ( v0 < g_weapAnimGroupCount )
          continue;
        break;
      }
    }
  }
}

/*
==============
CG_ViewWeaponCleanUp
==============
*/
void CG_ViewWeaponCleanUp(const LocalClientNum_t localClientNum)
{
  __int64 v1; 
  cg_t *LocalClientGlobals; 
  int v3; 
  ParticleSystemHandle *p_endEffect; 
  bool ShouldDeferLocalPlayerDraw; 
  ParticleSystemHandle v6; 
  __int64 v7; 
  __int64 v8; 

  v1 = localClientNum;
  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 15981, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, 2) )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v1);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 15984, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  v3 = 0;
  p_endEffect = &LocalClientGlobals->laserInfo[0].endEffect;
  ShouldDeferLocalPlayerDraw = CG_LaserShouldDeferLocalPlayerDraw();
  do
  {
    if ( ShouldDeferLocalPlayerDraw )
      *((_BYTE *)p_endEffect - 8) = CG_LaserDrawPlayerDeferredResult((LocalClientNum_t)v1, (const PlayerHandIndex)v3);
    if ( !*((_BYTE *)p_endEffect - 8) || LocalClientGlobals->predictedPlayerState.pm_type >= 7 )
    {
      if ( (unsigned int)v1 >= 2 )
      {
        LODWORD(v8) = 2;
        LODWORD(v7) = v1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemanager.h", 866, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v7, v8) )
          __debugbreak();
      }
      v6 = *((_DWORD *)p_endEffect - 1);
      if ( v6 )
      {
        ParticleManager::KillSystem(&g_particleManager[v1], v6);
        *((_DWORD *)p_endEffect - 1) = 0;
      }
      if ( *p_endEffect )
      {
        ParticleManager::KillSystem(&g_particleManager[v1], *p_endEffect);
        *p_endEffect = PARTICLE_SYSTEM_INVALID_HANDLE;
      }
    }
    ++v3;
    p_endEffect += 3;
  }
  while ( v3 < 2 );
  CG_NightVisionValidateFXHandles(LocalClientGlobals);
  if ( LocalClientGlobals->nvgInfo.nightVisionAreaLightFx && (LocalClientGlobals->predictedPlayerState.pm_type >= 7 || !LocalClientGlobals->nvgInfo.nvgAreaLightFXProcessedThisFrame) )
  {
    if ( (unsigned int)v1 >= 2 )
    {
      LODWORD(v8) = 2;
      LODWORD(v7) = v1;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemanager.h", 866, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v7, v8) )
        __debugbreak();
    }
    ParticleManager::KillSystem(&g_particleManager[v1], LocalClientGlobals->nvgInfo.nightVisionAreaLightFx);
    LocalClientGlobals->nvgInfo.nightVisionAreaLightFx = PARTICLE_SYSTEM_INVALID_HANDLE;
  }
  if ( LocalClientGlobals->nvgInfo.killcamThirdpersonAreaLightFx && (LocalClientGlobals->predictedPlayerState.pm_type >= 7 || !LocalClientGlobals->nvgInfo.nvgAreaLightFXProcessedThisFrame) && !CG_NightVisionShouldDrawKillcamLightFX((LocalClientNum_t)v1) )
  {
    if ( (unsigned int)v1 >= 2 )
    {
      LODWORD(v8) = 2;
      LODWORD(v7) = v1;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\vfx\\particles\\particlemanager.h", 866, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v7, v8) )
        __debugbreak();
    }
    ParticleManager::KillSystem(&g_particleManager[v1], LocalClientGlobals->nvgInfo.killcamThirdpersonAreaLightFx);
    LocalClientGlobals->nvgInfo.killcamThirdpersonAreaLightFx = PARTICLE_SYSTEM_INVALID_HANDLE;
  }
}

/*
==============
CG_ViewmodelShieldHitsProcess
==============
*/
void CG_ViewmodelShieldHitsProcess(LocalClientNum_t localClientNum)
{
  cg_t *LocalClientGlobals; 
  cg_t *v7; 
  centity_t *Entity; 
  int v9; 
  ShieldHitDelayedEvent *delayedShieldHitEvents; 
  FXRegisteredDef *p_fxRiotShieldImpact; 
  const dvar_t *v18; 
  const char *Name; 
  unsigned __int8 markBoneIndex; 
  unsigned __int8 inOutIndex[4]; 
  int startMsec; 
  int modelIndex; 
  __int64 v28; 
  vec3_t resultNormal; 
  vec3_t halfSize; 
  vec3_t resultPos; 
  tmat33_t<vec3_t> left; 
  char v33; 
  void *retaddr; 

  _RAX = &retaddr;
  v28 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm6
    vmovaps xmmword ptr [rax-48h], xmm7
    vmovaps xmmword ptr [rax-58h], xmm8
  }
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v7 = LocalClientGlobals;
  if ( LocalClientGlobals->predictedPlayerState.pm_type < 7 )
  {
    Entity = CG_GetEntity(localClientNum, LocalClientGlobals->clientNum);
    if ( Entity && (Entity->flags & 1) != 0 )
    {
      Sys_ProfBeginNamedEvent(0xFF000000, "CG_ViewmodelShieldHitsProcess");
      if ( v7->delayedShieldHitEventsCount > 2u && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20932, ASSERT_TYPE_ASSERT, "( 0 ) <= ( cgameGlob->delayedShieldHitEventsCount ) && ( cgameGlob->delayedShieldHitEventsCount ) <= ( 2 )", "cgameGlob->delayedShieldHitEventsCount not in [0, MAX_DELAYED_SHIELD_HIT_EVENTS]\n\t%i not in [%i, %i]", v7->delayedShieldHitEventsCount, 0i64, 2) )
        __debugbreak();
      v9 = 0;
      if ( v7->delayedShieldHitEventsCount > 0 )
      {
        delayedShieldHitEvents = v7->delayedShieldHitEvents;
        __asm
        {
          vmovss  xmm6, cs:__real@3f800000
          vmovss  xmm7, cs:__real@3fc00000
          vmovss  xmm8, cs:__real@40000000
        }
        do
        {
          if ( CalcViewmodelHitPos(localClientNum, delayedShieldHitEvents->eventParm, &resultPos, &resultNormal) )
          {
            if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_CUT_CHUTE_LOW|WEAPON_LADDER_AIM) || (p_fxRiotShieldImpact = &cgMedia.fxRiotShieldDamagedImpact, !delayedShieldHitEvents->damaged) )
              p_fxRiotShieldImpact = &cgMedia.fxRiotShieldImpact;
            if ( p_fxRiotShieldImpact->m_particleSystemDef )
            {
              __asm
              {
                vmovss  xmm0, dword ptr [rbp+57h+resultNormal]
                vmovss  dword ptr [rbp+57h+forward], xmm0
                vmovss  xmm1, dword ptr [rbp+57h+resultNormal+4]
                vmovss  dword ptr [rbp+57h+forward+4], xmm1
                vmovss  xmm0, dword ptr [rbp+57h+resultNormal+8]
                vmovss  dword ptr [rbp+57h+forward+8], xmm0
              }
              AxisRandomAroundForward(&left.m[2], left.m, &left.m[1]);
              startMsec = CG_GetLocalClientGlobals(localClientNum)->time;
              v18 = DVARBOOL_cg_riotshield_decalfix_enable;
              if ( !DVARBOOL_cg_riotshield_decalfix_enable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_riotshield_decalfix_enable") )
                __debugbreak();
              Dvar_CheckFrontendServerThread(v18);
              if ( v18->current.enabled )
              {
                if ( R_DecalVolumesMarks_DebugEnabled() )
                {
                  __asm
                  {
                    vmovss  dword ptr [rbp+57h+halfSize], xmm6
                    vmovss  dword ptr [rbp+57h+halfSize+4], xmm7
                    vmovss  dword ptr [rbp+57h+halfSize+8], xmm8
                  }
                  R_DecalVolumesMarks_DebugAdd(&resultPos, &halfSize, &left, &colorPink);
                  Name = FXRegisteredDef::GetName(p_fxRiotShieldImpact);
                  Com_Printf(21, "D+ CG mark viewmodel: vfx: %s\n", Name);
                }
                inOutIndex[0] = -2;
                DObjGetBoneIndexInternal_66(v7->m_weaponHand[0].viewModelDObj, scr_const.j_riotshield_offset, inOutIndex, &modelIndex);
                markBoneIndex = inOutIndex[0];
                if ( inOutIndex[0] == 0xFF )
                  markBoneIndex = -2;
                inOutIndex[0] = markBoneIndex;
                FX_PlayOrientedEffectWithMarkViewmodel(localClientNum, p_fxRiotShieldImpact, startMsec, &resultPos, &left, markBoneIndex, MARK_MATERIAL_OVERRIDE_NONE_2);
              }
              else
              {
                FX_PlayOrientedEffectWithMarkViewmodel(localClientNum, p_fxRiotShieldImpact, startMsec, &resultPos, &left, 0xFEu, MARK_MATERIAL_OVERRIDE_NONE_2);
              }
            }
          }
          ++v9;
          ++delayedShieldHitEvents;
        }
        while ( v9 < v7->delayedShieldHitEventsCount );
      }
      v7->delayedShieldHitEventsCount = 0;
      Sys_ProfEndNamedEvent();
    }
    else
    {
      v7->delayedShieldHitEventsCount = 0;
    }
  }
  else
  {
    LocalClientGlobals->delayedShieldHitEventsCount = 0;
  }
  _R11 = &v33;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
  }
}

/*
==============
CG_WeaponAnimGroup_BlendIn
==============
*/

void __fastcall CG_WeaponAnimGroup_BlendIn(double blendInDuration, const weapAnimFiles_t animIndex, const PlayerHandIndex handIndex, double animRate, cg_t *const cgameGlob)
{
  __asm
  {
    vmovaps [rsp+78h+var_18], xmm6
    vxorps  xmm1, xmm1, xmm1
    vcomiss xmm3, xmm1
    vmovaps [rsp+78h+var_28], xmm7
    vmovaps xmm6, xmm3
    vmovaps xmm7, xmm0
  }
  _RDX = cgameGlob;
  __asm
  {
    vmulss  xmm0, xmm7, cs:__real@447a0000
    vmovaps xmm7, [rsp+78h+var_28]
  }
  _RCX = handIndex;
  __asm
  {
    vmovss  dword ptr [rdx+rcx*8+7CFD8h], xmm6
    vmovaps xmm6, [rsp+78h+var_18]
  }
  cgameGlob->animGroupBlend[_RCX].animIndex = animIndex;
  cgameGlob->animGroupBlend[_RCX].startTimeMs = cgameGlob->time;
  __asm { vcvttss2si ecx, xmm0 }
  cgameGlob->animGroupBlend[handIndex].durationMs = _RCX * 2;
}

/*
==============
CG_WeaponAnimGroup_CalcFireAnimWeights
==============
*/
void CG_WeaponAnimGroup_CalcFireAnimWeights(const cg_t *const cgameGlob, const XAnimTree *animTree, const WeapAnimGroup *const animGroup, const weapAnimFiles_t initialAnimIndex, const Weapon *weapon, const bool isAlternate, float *outWeights)
{
  const playerState_s *p_predictedPlayerState; 
  CgHandler *Handler; 
  const BgHandler *v25; 
  int v30; 
  unsigned int v32; 
  weapAnimFiles_t AdsLastShotAnim; 
  XAnim_s *Anims; 
  int LengthMsec; 
  const XAnim_s *v36; 
  int v37; 
  weapAnimFiles_t animIndex; 
  const dvar_t *v40; 
  const char *AnimName; 
  const char *v42; 
  __int64 v46; 
  char output[1024]; 
  char v48; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
  }
  _R14 = outWeights;
  _RBP = cgameGlob;
  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2519, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( !animGroup && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2520, ASSERT_TYPE_ASSERT, "(animGroup)", (const char *)&queryFormat, "animGroup") )
    __debugbreak();
  if ( !outWeights && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2521, ASSERT_TYPE_ASSERT, "(outWeights)", (const char *)&queryFormat, "outWeights") )
    __debugbreak();
  p_predictedPlayerState = &_RBP->predictedPlayerState;
  Handler = CgHandler::getHandler(_RBP->localClientNum);
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+7C64Ch]
    vmovss  xmm6, cs:__real@3f800000
    vsubss  xmm1, xmm0, xmm6
    vmulss  xmm0, xmm1, xmm1
    vmulss  xmm1, xmm0, xmm1
    vxorps  xmm0, xmm1, cs:__xmm@80000000800000008000000080000000; val
    vxorps  xmm1, xmm1, xmm1; min
    vmovaps xmm2, xmm6; max
  }
  v25 = Handler;
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm
  {
    vmovaps xmm7, xmm0
    vsubss  xmm0, xmm6, xmm0; val
    vmovaps xmm2, xmm6; max
    vxorps  xmm1, xmm1, xmm1; min
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  v30 = 241;
  __asm { vmovaps xmm6, xmm0 }
  if ( initialAnimIndex == WEAP_ANIM_FIRE || initialAnimIndex == WEAP_ANIM_LASTSHOT )
  {
    v32 = initialAnimIndex;
    if ( initialAnimIndex == WEAP_ANIM_LASTSHOT )
      AdsLastShotAnim = BG_GetAdsLastShotAnim(p_predictedPlayerState, v25);
    else
      AdsLastShotAnim = BG_GetAdsFireAnim(p_predictedPlayerState, v25);
    initialAnimIndex = AdsLastShotAnim;
  }
  else
  {
    if ( (unsigned int)(initialAnimIndex - 348) > 1 )
      v30 = 239;
    v32 = v30;
  }
  if ( initialAnimIndex == WEAP_ANIM_ROOT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2561, ASSERT_TYPE_ASSERT, "(adsAnim != WEAP_ANIM_ROOT)", (const char *)&queryFormat, "adsAnim != WEAP_ANIM_ROOT") )
    __debugbreak();
  Anims = XAnimGetAnims(animTree);
  LengthMsec = -1;
  v36 = Anims;
  v37 = -1;
  for ( _RBX = 0i64; _RBX < 7; ++_RBX )
  {
    animIndex = animGroup->animIndex;
    if ( animGroup->animIndex == WEAP_ANIM_ROOT )
      break;
    if ( animIndex == v32 )
    {
      __asm { vmovss  dword ptr [r14+rbx], xmm7 }
      LengthMsec = XAnimGetLengthMsec(v36, v32);
    }
    else if ( animIndex == initialAnimIndex )
    {
      __asm { vmovss  dword ptr [r14+rbx], xmm6 }
      v37 = XAnimGetLengthMsec(v36, initialAnimIndex);
    }
    else
    {
      outWeights[_RBX] = 0.0;
    }
    ++animGroup;
  }
  v40 = DCONST_DVARBOOL_cg_validateAdsHipFireAnimTimes;
  if ( !DCONST_DVARBOOL_cg_validateAdsHipFireAnimTimes && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_validateAdsHipFireAnimTimes") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v40);
  if ( v40->current.enabled && LengthMsec != v37 )
  {
    BG_GetWeaponNameComplete(weapon, isAlternate, output, 0x400u);
    AnimName = XAnimGetAnimName(v36, initialAnimIndex);
    v42 = XAnimGetAnimName(v36, v32);
    LODWORD(v46) = LengthMsec;
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1442DAF80, 602i64, output, v42, v46, AnimName, LengthMsec);
  }
  _R11 = &v48;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
  }
}

/*
==============
CG_WeaponAnimGroup_CalcHipAdsAnimWeights
==============
*/
void CG_WeaponAnimGroup_CalcHipAdsAnimWeights(const cg_t *const cgameGlob, const XAnimTree *animTree, const WeapAnimGroup *const animGroup, const weapAnimFiles_t initialAnimIndex, const Weapon *weapon, const bool isAlternate, const float hipWeight, const float adsWeight, float *outWeights)
{
  CgHandler *Handler; 
  int v15; 
  CgHandler *v16; 
  bool v17; 
  CgHandler *v18; 
  bool v19; 

  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2616, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( !animGroup && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2617, ASSERT_TYPE_ASSERT, "(animGroup)", (const char *)&queryFormat, "animGroup") )
    __debugbreak();
  _RDI = outWeights;
  if ( !outWeights && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2618, ASSERT_TYPE_ASSERT, "(outWeights)", (const char *)&queryFormat, "outWeights") )
    __debugbreak();
  if ( animGroup->animIndex == WEAP_ANIM_ROOT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2627, ASSERT_TYPE_ASSERT, "(animGroup[0].animIndex != WEAP_ANIM_ROOT)", (const char *)&queryFormat, "animGroup[0].animIndex != WEAP_ANIM_ROOT") )
    __debugbreak();
  if ( animGroup[1].animIndex == WEAP_ANIM_ROOT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2628, ASSERT_TYPE_ASSERT, "(animGroup[1].animIndex != WEAP_ANIM_ROOT)", (const char *)&queryFormat, "animGroup[1].animIndex != WEAP_ANIM_ROOT") )
    __debugbreak();
  if ( animGroup[2].animIndex == WEAP_ANIM_ROOT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2629, ASSERT_TYPE_ASSERT, "(animGroup[2].animIndex != WEAP_ANIM_ROOT)", (const char *)&queryFormat, "animGroup[2].animIndex != WEAP_ANIM_ROOT") )
    __debugbreak();
  __asm
  {
    vmovss  xmm0, [rsp+48h+hipWeight]
    vmovss  dword ptr [rdi], xmm0
  }
  Handler = CgHandler::getHandler(cgameGlob->localClientNum);
  v15 = BG_ViewModelAnimExists(&cgameGlob->predictedPlayerState, animGroup[1].animIndex, WEAPON_HAND_DEFAULT, Handler);
  v16 = CgHandler::getHandler(cgameGlob->localClientNum);
  v17 = BG_ViewModelAnimExists(&cgameGlob->predictedPlayerState, animGroup[2].animIndex, WEAPON_HAND_DEFAULT, v16) != 0;
  v18 = CgHandler::getHandler(cgameGlob->localClientNum);
  v19 = BG_PlayerUsesNVGHalfADS(&cgameGlob->predictedPlayerState, v18);
  __asm
  {
    vmovss  xmm2, [rsp+48h+adsWeight]
    vxorps  xmm1, xmm1, xmm1
  }
  if ( !v15 || v19 && v17 )
    __asm { vxorps  xmm0, xmm0, xmm0 }
  else
    __asm { vmovaps xmm0, xmm2 }
  __asm { vmovss  dword ptr [rdi+4], xmm0 }
  if ( v17 && (v19 || !v15) )
    __asm { vmovss  dword ptr [rdi+8], xmm2 }
  else
    __asm { vmovss  dword ptr [rdi+8], xmm1 }
}

/*
==============
CG_WeaponAnimGroup_CalcWeights
==============
*/
void CG_WeaponAnimGroup_CalcWeights(const cg_t *const cgameGlob, const XAnimTree *animTree, const WeapAnimGroup *const animGroup, const weapAnimFiles_t initialAnimIndex, const Weapon *weapon, const bool isAlternate, float *outWeights)
{
  __int64 localClientNum; 
  __int64 v26; 
  float v27; 
  float v28; 
  float v29; 
  float v30; 

  __asm
  {
    vmovaps [rsp+98h+var_38], xmm6
    vmovaps [rsp+98h+var_48], xmm7
  }
  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2645, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( !animGroup && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2646, ASSERT_TYPE_ASSERT, "(animGroup)", (const char *)&queryFormat, "animGroup") )
    __debugbreak();
  if ( !outWeights && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2647, ASSERT_TYPE_ASSERT, "(outWeights)", (const char *)&queryFormat, "outWeights") )
    __debugbreak();
  __asm { vmovss  xmm6, cs:__real@3f800000 }
  *(_QWORD *)outWeights = 1065353216i64;
  *((_QWORD *)outWeights + 1) = 0i64;
  *((_QWORD *)outWeights + 2) = 0i64;
  outWeights[6] = 0.0;
  __asm
  {
    vsubss  xmm0, xmm6, dword ptr [rdi+7C64Ch]; val
    vmovaps xmm2, xmm6; max
    vxorps  xmm1, xmm1, xmm1; min
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm
  {
    vmovaps xmm7, xmm0
    vsubss  xmm0, xmm6, xmm0; val
    vmovaps xmm2, xmm6; max
    vxorps  xmm1, xmm1, xmm1; min
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm { vmovaps xmm6, xmm0 }
  if ( g_weapAnimGroupCount != 14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2659, ASSERT_TYPE_ASSERT, "(g_weapAnimGroupCount == 14)", "%s\n\tMust update switch statement in CG_Weapons_GetAnimationGroupWeights.", "g_weapAnimGroupCount == 14") )
    __debugbreak();
  switch ( animGroup->animIndex )
  {
    case WEAP_ANIM_FIRE:
    case WEAP_ANIM_LASTSHOT:
    case WEAP_ANIM_ADS_FIRE:
    case WEAP_ANIM_ADS_FIRE_NVG:
    case WEAP_ANIM_ADS_LASTSHOT:
    case WEAP_ANIM_ADS_LASTSHOT_NVG:
      CG_WeaponAnimGroup_CalcFireAnimWeights(cgameGlob, animTree, animGroup, initialAnimIndex, weapon, isAlternate, outWeights);
      break;
    case WEAP_ANIM_RECHAMBER:
      if ( BG_RechamberWhileADS(weapon, isAlternate) )
      {
        __asm
        {
          vmovss  [rsp+98h+var_60], xmm6
          vmovss  dword ptr [rsp+98h+var_68], xmm7
        }
        CG_WeaponAnimGroup_CalcHipAdsAnimWeights(cgameGlob, animTree, animGroup, initialAnimIndex, weapon, isAlternate, v28, v30, outWeights);
      }
      break;
    case WEAP_ANIM_ALT_MELEE_LAST:
    case WEAP_ANIM_RELOAD_EMPTY:
    case WEAP_ANIM_RELOAD_START:
    case WEAP_ANIM_RELOAD_START_TWO:
    case WEAP_ANIM_RELOAD_END:
    case WEAP_ANIM_RELOAD_END_RECHAMBER:
    case WEAP_ANIM_FAST_RELOAD_FIRST:
    case WEAP_ANIM_FAST_RELOAD_EMPTY:
    case WEAP_ANIM_FAST_RELOAD_START:
    case WEAP_ANIM_FAST_RELOAD_START_TWO:
    case WEAP_ANIM_FAST_RELOAD_END:
    case WEAP_ANIM_FAST_RELOAD_END_RECHAMBER:
      localClientNum = cgameGlob->localClientNum;
      if ( !CgWeaponMap::ms_instance[localClientNum] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
        __debugbreak();
      if ( BG_ADSReloadEnabled(CgWeaponMap::ms_instance[localClientNum], &cgameGlob->predictedPlayerState, weapon, isAlternate) )
      {
        __asm
        {
          vmovss  [rsp+98h+var_60], xmm6
          vmovss  dword ptr [rsp+98h+var_68], xmm7
        }
        CG_WeaponAnimGroup_CalcHipAdsAnimWeights(cgameGlob, animTree, animGroup, initialAnimIndex, weapon, isAlternate, v27, v29, outWeights);
      }
      break;
    default:
      LODWORD(v26) = animGroup->animIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2712, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "CG_Weapons_GetAnimationGroupWeights: unrecognized anim group base %i", v26) )
        __debugbreak();
      break;
  }
  __asm
  {
    vmovaps xmm6, [rsp+98h+var_38]
    vmovaps xmm7, [rsp+98h+var_48]
  }
}

/*
==============
CG_WeaponAnimGroup_Update
==============
*/
void CG_WeaponAnimGroup_Update(const weapAnimFiles_t animIndex, cg_t *const cgameGlob, const PlayerHandIndex handIndex, const Weapon *weapon, const bool isAlternate, XAnimTree *animTree, DObj *obj)
{
  const WeapAnimGroup (*v14)[7]; 
  const Weapon *v15; 
  PlayerHandIndex v16; 
  unsigned __int64 v19; 
  unsigned __int64 v20; 
  const WeapAnimGroup (*v21)[7]; 
  unsigned __int64 v22; 
  const WeapAnimGroup (*v23)[7]; 
  const WeapAnimGroup *v24; 
  int v25; 
  const WeapAnimGroup (*v26)[7]; 
  weapAnimFiles_t v27; 
  const XAnim_s *Anims; 
  char v30; 
  bool v31; 
  bool v37; 
  unsigned __int64 i; 
  char v57; 
  char v58; 
  float fmt; 
  float fmta; 
  __int64 goalTime; 
  float goalTimea; 
  float *outWeights; 
  float outWeightsa; 
  double notifyName; 
  double notifyNamea; 
  double notifyType; 
  double notifyTypea; 
  float rate[10]; 
  char v78[624]; 

  v14 = g_weapAnimGroups;
  v15 = weapon;
  v16 = handIndex;
  _R13 = cgameGlob;
  if ( validationExecuted )
  {
    v19 = g_weapAnimGroupCount;
  }
  else
  {
    validationExecuted = 1;
    memset_0(v78, 0, 0x266ui64);
    v19 = g_weapAnimGroupCount;
    v20 = 0i64;
    if ( g_weapAnimGroupCount )
    {
      v21 = g_weapAnimGroups;
      while ( 2 )
      {
        v22 = 0i64;
        v23 = v21;
        do
        {
          if ( !*(_DWORD *)v23 )
            break;
          if ( *(_DWORD *)v23 >= 0x266u )
          {
            LODWORD(outWeights) = 614;
            LODWORD(goalTime) = *(_DWORD *)v23;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2777, ASSERT_TYPE_ASSERT, "(unsigned)( groupEntry->animIndex ) < (unsigned)( NUM_WEAP_ANIMS )", "groupEntry->animIndex doesn't index NUM_WEAP_ANIMS\n\t%i not in [0, %i)", goalTime, outWeights) )
              __debugbreak();
          }
          if ( v78[*(_DWORD *)v23] )
          {
            Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1442DB330, 603i64);
            v19 = g_weapAnimGroupCount;
            goto LABEL_12;
          }
          ++v22;
          v78[*(_DWORD *)v23] = 1;
          v23 = (const WeapAnimGroup (*)[7])((char *)v23 + 16);
        }
        while ( v22 < 7 );
        v19 = g_weapAnimGroupCount;
        ++v20;
        ++v21;
        if ( v20 < g_weapAnimGroupCount )
          continue;
        break;
      }
LABEL_12:
      v16 = handIndex;
    }
    v15 = weapon;
  }
  v24 = NULL;
  if ( v19 )
  {
    do
    {
      v25 = 0;
      v26 = v14;
      while ( *(_DWORD *)v26 )
      {
        if ( *(_DWORD *)v26 == animIndex )
        {
          v24 = (const WeapAnimGroup *)v14;
          break;
        }
        ++v25;
        v26 = (const WeapAnimGroup (*)[7])((char *)v26 + 16);
        if ( v25 >= 7 )
          break;
      }
      ++v14;
      --v19;
    }
    while ( v19 );
    if ( v24 )
    {
      if ( !_R13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2730, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
        __debugbreak();
      v27 = v24->animIndex;
      if ( v24->animIndex != WEAP_ANIM_FIRE && v27 != WEAP_ANIM_LASTSHOT && (unsigned int)(v27 - 346) > 3 || BG_ShouldBlendFireAnims(v15, isAlternate) )
      {
        _RSI = v16;
        if ( _R13->animGroupBlend[v16].animIndex == animIndex )
        {
          __asm
          {
            vmovaps [rsp+3C8h+var_58], xmm6
            vmovaps [rsp+3C8h+var_68], xmm7
            vmovaps [rsp+3C8h+var_78], xmm8
            vmovaps [rsp+3C8h+var_88], xmm9
            vmovaps [rsp+3C8h+var_98], xmm10
          }
          Anims = XAnimGetAnims(animTree);
          if ( !Anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2819, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
            __debugbreak();
          XAnimGetLengthMsec(Anims, animIndex);
          __asm
          {
            vmovss  xmm0, dword ptr [r13+rsi*8+7CFD8h]
            vxorps  xmm10, xmm10, xmm10
            vcomiss xmm0, xmm10
            vxorps  xmm6, xmm6, xmm6
            vcvtsi2ss xmm6, xmm6, eax
            vxorpd  xmm7, xmm7, xmm7
          }
          if ( v30 | v31 )
          {
            __asm
            {
              vcvtss2sd xmm0, xmm0, xmm0
              vmovsd  qword ptr [rsp+3C8h+notifyType], xmm0
              vmovsd  qword ptr [rsp+3C8h+notifyName], xmm7
            }
            v37 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2821, ASSERT_TYPE_ASSERT, "( 0.0f ) < ( animGroupBlend->animRate )", "%s < %s\n\t%g, %g", "0.0f", "animGroupBlend->animRate", notifyName, notifyType);
            v30 = 0;
            v31 = !v37;
            if ( v37 )
              __debugbreak();
          }
          __asm
          {
            vdivss  xmm6, xmm6, dword ptr [r13+rsi*8+7CFD8h]
            vcomiss xmm6, xmm10
          }
          if ( v30 | v31 )
          {
            __asm
            {
              vcvtss2sd xmm0, xmm6, xmm6
              vmovsd  qword ptr [rsp+3C8h+notifyType], xmm0
              vmovsd  qword ptr [rsp+3C8h+notifyName], xmm7
            }
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2823, ASSERT_TYPE_ASSERT, "( 0.0f ) < ( animDurationMs )", "%s < %s\n\t%g, %g", "0.0f", "animDurationMs", notifyNamea, notifyTypea) )
              __debugbreak();
          }
          __asm
          {
            vmovss  xmm2, cs:__real@3f7fbe77; max
            vxorps  xmm0, xmm0, xmm0
            vcvtsi2ss xmm0, xmm0, eax
            vdivss  xmm0, xmm0, xmm6; val
            vxorps  xmm1, xmm1, xmm1; min
            vmovaps [rsp+3C8h+var_A8], xmm11
          }
          *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
          __asm { vmovaps xmm9, xmm0 }
          CG_WeaponAnimGroup_CalcWeights(_R13, animTree, v24, (const weapAnimFiles_t)_R13->animGroupBlend[_RSI].animIndex, v15, isAlternate, rate);
          __asm { vmovss  xmm8, cs:__real@3a83126f }
          if ( _R13->animGroupBlend[_RSI].durationMs > 0 )
          {
            __asm
            {
              vmovss  xmm2, cs:__real@3f800000; max
              vxorps  xmm1, xmm1, xmm1
              vxorps  xmm0, xmm0, xmm0
              vcvtsi2ss xmm1, xmm1, eax
              vcvtsi2ss xmm0, xmm0, ecx
              vdivss  xmm0, xmm1, xmm0; val
              vmovaps xmm1, xmm8; min
            }
            *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
            __asm { vmovaps xmm11, xmm0 }
          }
          else
          {
            __asm { vmovss  xmm11, cs:__real@3f800000 }
          }
          for ( i = 0i64; i < 7; ++i )
          {
            if ( v24->animIndex == WEAP_ANIM_ROOT )
              break;
            __asm { vmulss  xmm7, xmm11, [rsp+rdi*4+3C8h+rate] }
            *(double *)&_XMM0 = XAnimGetWeight(animTree, 0, XANIM_SUBTREE_DEFAULT, v24->animIndex);
            __asm
            {
              vmovss  xmm1, dword ptr [r13+rsi*8+7CFD8h]
              vcomiss xmm7, xmm10
              vmovaps xmm6, xmm0
              vmovss  dword ptr [rsp+3C8h+outWeights], xmm1
              vmovss  [rsp+3C8h+goalTime], xmm10
              vmovss  dword ptr [rsp+3C8h+fmt], xmm7
            }
            XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, v24->animIndex, fmt, goalTimea, outWeightsa, (scr_string_t)0, !(v30 | v31), 0, LINEAR, NULL);
            __asm { vcomiss xmm6, xmm8 }
            if ( v57 | v58 )
            {
              __asm { vcomiss xmm7, xmm8 }
              if ( !(v57 | v58) )
              {
                __asm { vmovss  dword ptr [rsp+3C8h+fmt], xmm9 }
                XAnimSetTime(animTree, 0, XANIM_SUBTREE_DEFAULT, v24->animIndex, fmta);
              }
            }
            ++v24;
          }
          __asm
          {
            vmovaps xmm11, [rsp+3C8h+var_A8]
            vmovaps xmm9, [rsp+3C8h+var_88]
            vmovaps xmm8, [rsp+3C8h+var_78]
            vmovaps xmm7, [rsp+3C8h+var_68]
            vmovaps xmm6, [rsp+3C8h+var_58]
            vmovaps xmm10, [rsp+3C8h+var_98]
          }
        }
      }
    }
  }
}

/*
==============
CG_WeaponInspect
==============
*/
void CG_WeaponInspect(LocalClientNum_t localClientNum)
{
  cg_t *LocalClientGlobals; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  LocalClientGlobals->extraButtons |= 0x100000000000ui64;
}

/*
==============
CG_WeaponInspect_IsUIHidden
==============
*/
bool CG_WeaponInspect_IsUIHidden(LocalClientNum_t localClientNum)
{
  cg_t *LocalClientGlobals; 
  const dvar_t *v2; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( LocalClientGlobals->predictedPlayerState.weapState[0].weaponState != 78 )
    return 0;
  v2 = DCONST_DVARINT_bg_weapon_inspect_dof_off_time_ms;
  if ( !DCONST_DVARINT_bg_weapon_inspect_dof_off_time_ms && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_weapon_inspect_dof_off_time_ms") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  return LocalClientGlobals->predictedPlayerState.weapState[0].weaponTime - v2->current.integer > 0;
}

/*
==============
CG_Weapon_AddViewmodelAccessory
==============
*/
unsigned __int16 CG_Weapon_AddViewmodelAccessory(const LocalClientNum_t localClientNum, const PlayerHandIndex hand, bool isDualWield, const playerState_s *const ps, DObjModel *dobjModels, unsigned __int16 modelCount)
{
  unsigned int accessoryIndex; 
  const AccessoryDef *Def; 
  unsigned __int16 result; 
  CgWeaponMap *Instance; 
  cg_t *LocalClientGlobals; 
  const XModel *WeaponModels; 
  const DObjCamoParams *camoParams; 
  __int64 isUsingDetonator; 
  __int64 isUsingCensorshipWorldModel; 
  unsigned __int16 numModels; 
  DObjCamoParams outLocalParams; 
  Weapon outAccessoryWeapon; 

  numModels = modelCount;
  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10734, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, 2) )
    __debugbreak();
  if ( (unsigned int)hand >= NUM_WEAPON_HANDS )
  {
    LODWORD(isUsingCensorshipWorldModel) = 2;
    LODWORD(isUsingDetonator) = hand;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10735, ASSERT_TYPE_ASSERT, "(unsigned)( hand ) < (unsigned)( NUM_WEAPON_HANDS )", "hand doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", isUsingDetonator, isUsingCensorshipWorldModel) )
      __debugbreak();
  }
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10736, ASSERT_TYPE_ASSERT, "( ps ) != ( nullptr )", "%s != %s\n\t%p, %p", "ps", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( !dobjModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10737, ASSERT_TYPE_ASSERT, "( dobjModels ) != ( nullptr )", "%s != %s\n\t%p, %p", "dobjModels", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( numModels >= 0x20u )
  {
    LODWORD(isUsingCensorshipWorldModel) = 32;
    LODWORD(isUsingDetonator) = numModels;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10738, ASSERT_TYPE_ASSERT, "(unsigned)( modelCount ) < (unsigned)( ( 32 ) )", "modelCount doesn't index DOBJ_MAX_CHARACTER_SUBMODELS\n\t%i not in [0, %i)", isUsingDetonator, isUsingCensorshipWorldModel) )
      __debugbreak();
  }
  accessoryIndex = ps->accessoryIndex;
  if ( accessoryIndex >= 0x80 )
  {
    LODWORD(isUsingCensorshipWorldModel) = 128;
    LODWORD(isUsingDetonator) = ps->accessoryIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10742, ASSERT_TYPE_ASSERT, "(unsigned)( accessoryIndex ) < (unsigned)( (1<<7) )", "accessoryIndex doesn't index MAX_ACCESSORY_DEFS\n\t%i not in [0, %i)", isUsingDetonator, isUsingCensorshipWorldModel) )
      __debugbreak();
  }
  if ( accessoryIndex >= 0x7F )
    return numModels;
  Def = BG_Accessory_GetDef(accessoryIndex);
  if ( !Def && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10748, ASSERT_TYPE_ASSERT, "( accDef ) != ( nullptr )", "%s != %s\n\t%p, %p", "accDef", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( isDualWield )
  {
    if ( hand == WEAPON_HAND_LEFT )
    {
      if ( Def->VMAttachRightHand )
        return numModels;
    }
    else if ( hand == WEAPON_HAND_DEFAULT && !Def->VMAttachRightHand )
    {
      return numModels;
    }
  }
  Instance = CgWeaponMap::GetInstance(localClientNum);
  BG_Accessory_GetWeapon(Instance, ps, &outAccessoryWeapon);
  if ( !outAccessoryWeapon.weaponIdx )
    return numModels;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( LocalClientGlobals->playerWeaponInfo.isAccessoryHidden )
    return numModels;
  if ( numModels >= 0x20u )
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1442DE010, 5842i64);
  WeaponModels = BG_GetWeaponModels(hand, &outAccessoryWeapon, 1, LocalClientGlobals->playerWeaponInfo.isAccessoryDefault, isDualWield, 0, 0);
  if ( !WeaponModels )
    return numModels;
  camoParams = BG_Camo_GetWeaponDObjCamoParams(&outAccessoryWeapon, 1, &outLocalParams);
  DObjInitModel(WeaponModels, Def->VMAttachBone, 0, 0, camoParams, &dobjModels[numModels]);
  result = ++numModels;
  if ( !LocalClientGlobals->playerWeaponInfo.isAccessoryDefault )
  {
    BG_AddWeaponAttachmentModels(&outAccessoryWeapon, hand, isDualWield, 1, 0, 0, dobjModels, 0x20u, &numModels, NULL, camoParams);
    return numModels;
  }
  return result;
}

/*
==============
CG_Weapon_AddViewmodelHand
==============
*/
unsigned __int16 CG_Weapon_AddViewmodelHand(const LocalClientNum_t localClientNum, const playerState_s *ps, const PlayerHandIndex hand, const Weapon *r_weapon, const bool isAlternate, DObjModel *dobjModels, unsigned __int16 modelCount, unsigned __int16 *weaponIndex)
{
  XModel *WeaponModels; 
  __int64 v10; 
  __int64 v11; 
  cg_t *LocalClientGlobals; 
  bool v13; 
  bool v14; 
  unsigned __int16 v15; 
  unsigned __int16 v16; 
  cg_t *v17; 
  const XModel **p_rocketModel; 
  const XModel *v19; 
  unsigned __int16 v20; 
  const SuitDef *SuitDef; 
  const XModel *skydive_parachuteViewModel; 
  __int64 isUsingDetonator; 
  __int64 isUsingDetonatora; 
  __int64 isUsingCensorshipWorldModel; 
  __int64 isUsingCensorshipWorldModela; 
  XAnimWeaponIKModelsContainer weaponIKModels; 

  WeaponModels = NULL;
  v10 = localClientNum;
  v11 = hand;
  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11433, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, 2) )
    __debugbreak();
  if ( !dobjModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11434, ASSERT_TYPE_ASSERT, "(dobjModels)", (const char *)&queryFormat, "dobjModels") )
    __debugbreak();
  if ( modelCount >= 0x20u )
  {
    LODWORD(isUsingCensorshipWorldModel) = 32;
    LODWORD(isUsingDetonator) = modelCount;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11435, ASSERT_TYPE_ASSERT, "(unsigned)( modelCount ) < (unsigned)( ( 32 ) )", "modelCount doesn't index DOBJ_MAX_CHARACTER_SUBMODELS\n\t%i not in [0, %i)", isUsingDetonator, isUsingCensorshipWorldModel) )
      __debugbreak();
  }
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v10);
  if ( !CgWeaponMap::ms_instance[v10] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v13 = BG_PlayerOrEntityDualWielding(CgWeaponMap::ms_instance[v10], ps, NULL, NULL);
  v14 = BG_HasLadderHand(ps) && !v13 && (_DWORD)v11 == 1;
  CG_Weapon_UpdateWeaponVisibility((const LocalClientNum_t)v10, ps, r_weapon, isAlternate);
  XAnimWeaponIKModelsContainer::XAnimWeaponIKModelsContainer(&weaponIKModels);
  if ( !v14 )
    WeaponModels = BG_GetWeaponModels((const PlayerHandIndex)v11, r_weapon, 1, LocalClientGlobals->playerWeaponInfo.isWeaponDefault, v13, 0, 0);
  v15 = CG_Weapon_AddViewmodelWeapon((const LocalClientNum_t)v10, (const PlayerHandIndex)v11, v13, r_weapon, isAlternate, WeaponModels, dobjModels, modelCount, weaponIndex, &weaponIKModels);
  v16 = CG_Weapon_AddViewmodelAccessory((const LocalClientNum_t)v10, (const PlayerHandIndex)v11, v13, ps, dobjModels, v15);
  if ( (unsigned int)v10 >= 2 )
  {
    LODWORD(isUsingCensorshipWorldModela) = 2;
    LODWORD(isUsingDetonatora) = v10;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10811, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", isUsingDetonatora, isUsingCensorshipWorldModela) )
      __debugbreak();
  }
  if ( !dobjModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10812, ASSERT_TYPE_ASSERT, "(dobjModels)", (const char *)&queryFormat, "dobjModels") )
    __debugbreak();
  if ( v16 >= 0x20u )
  {
    LODWORD(isUsingCensorshipWorldModela) = 32;
    LODWORD(isUsingDetonatora) = v16;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10813, ASSERT_TYPE_ASSERT, "(unsigned)( modelCount ) < (unsigned)( ( 32 ) )", "modelCount doesn't index DOBJ_MAX_CHARACTER_SUBMODELS\n\t%i not in [0, %i)", isUsingDetonatora, isUsingCensorshipWorldModela) )
      __debugbreak();
  }
  v17 = CG_GetLocalClientGlobals((const LocalClientNum_t)v10);
  if ( (unsigned int)v11 >= 2 )
  {
    LODWORD(isUsingCensorshipWorldModela) = 2;
    LODWORD(isUsingDetonatora) = v11;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", isUsingDetonatora, isUsingCensorshipWorldModela) )
      __debugbreak();
  }
  p_rocketModel = (const XModel **)&v17->m_weaponHand[v11].rocketModel;
  v19 = *p_rocketModel;
  if ( *p_rocketModel )
  {
    if ( v16 >= 0x20u )
    {
      XModelGetName(*p_rocketModel);
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1442DE080, 610i64);
      v19 = *p_rocketModel;
    }
    DObjInitModel(v19, scr_const.tag_clip, 0, 0, NULL, &dobjModels[v16++]);
  }
  v20 = CG_Weapon_AddViewmodelOffhandGesture((const LocalClientNum_t)v10, (PlayerHandIndex)v11, dobjModels, v16);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10648, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( !dobjModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10649, ASSERT_TYPE_ASSERT, "(dobjModels)", (const char *)&queryFormat, "dobjModels") )
    __debugbreak();
  if ( v20 >= 0x20u )
  {
    LODWORD(isUsingCensorshipWorldModela) = 32;
    LODWORD(isUsingDetonatora) = v20;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10650, ASSERT_TYPE_ASSERT, "(unsigned)( modelCount ) < (unsigned)( ( 32 ) )", "modelCount doesn't index DOBJ_MAX_CHARACTER_SUBMODELS\n\t%i not in [0, %i)", isUsingDetonatora, isUsingCensorshipWorldModela) )
      __debugbreak();
  }
  if ( CG_Skydive_GetViewmodelState((const LocalClientNum_t)LocalClientGlobals->localClientNum) == PhaseSpace )
  {
    SuitDef = BG_GetSuitDef(LocalClientGlobals->predictedPlayerState.suitIndex);
    if ( !SuitDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10633, ASSERT_TYPE_ASSERT, "(suitDef)", (const char *)&queryFormat, "suitDef") )
      __debugbreak();
    skydive_parachuteViewModel = SuitDef->skydive_parachuteViewModel;
    if ( skydive_parachuteViewModel )
    {
      if ( v20 >= 0x20u )
      {
        XModelGetName(skydive_parachuteViewModel);
        Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1442DDEC0, 5841i64);
      }
      DObjInitModel(skydive_parachuteViewModel, scr_const.tag_weapon, 0, 0, NULL, &dobjModels[v20++]);
      XAnimWeaponIKModelsContainer::Reset(&weaponIKModels);
      XAnimWeaponIKModelsContainer::AddXModel(&weaponIKModels, WEAPON_HAND_DEFAULT, skydive_parachuteViewModel);
    }
  }
  if ( isAlternate && BG_IsThrowingAxe(r_weapon) )
    return v20;
  else
    return CG_Weapon_AddViewmodelIK((const LocalClientNum_t)v10, (const PlayerHandIndex)v11, ps, r_weapon, &weaponIKModels, dobjModels, v20);
}

/*
==============
CG_Weapon_AddViewmodelHeldModels
==============
*/
void CG_Weapon_AddViewmodelHeldModels(const LocalClientNum_t localClientNum, const playerState_s *ps, const Weapon *r_weapon, const bool recreateAnimTrees, const bool preserveAnimState, const bool updateClientInfo, DObjModel *dobjModels, unsigned __int16 commonModelCount, bool refreshOverridesOnly)
{
  DObjModel *v11; 
  __int64 v12; 
  cg_t *v15; 
  int v23; 
  bool HasLadderHand; 
  bool v25; 
  WeaponHand *v26; 
  int v28; 
  bool v29; 
  bool v30; 
  unsigned int v32; 
  const XAnimTree *tree; 
  const XAnimTree *v34; 
  const XAnimTree *v35; 
  unsigned __int16 v36; 
  unsigned __int16 v37; 
  DObj *v38; 
  unsigned __int16 v39; 
  signed __int64 v40; 
  char *v41; 
  unsigned __int64 i; 
  unsigned __int16 v43; 
  unsigned __int16 v44; 
  Material *v45; 
  Material *v46; 
  DObj *viewModelDObj; 
  bool v53; 
  const dvar_t *v54; 
  cg_t *LocalClientGlobals; 
  DObj *v56; 
  DObjModel *v60; 
  __int64 modelCount; 
  bool v62; 
  bool v63; 
  bool HandAnimTree; 
  bool v65; 
  bool v66; 
  unsigned __int16 weaponIndex[2]; 
  PlayerHandIndex hand; 
  DObjModel *v70; 
  char obj[416]; 
  float outAnimTimes[4]; 
  float outAnimWeights[4]; 
  XAnimParts *outShieldXParts[4]; 
  float animGoalTimes[56]; 
  float animGoalWeights[56]; 
  float animTimes[56]; 
  float animWeights[56]; 

  __asm { vmovaps [rsp+630h+var_40], xmm6 }
  v11 = dobjModels;
  v12 = localClientNum;
  _RSI = r_weapon;
  *(_QWORD *)&obj[16] = r_weapon;
  *(_QWORD *)&obj[32] = ps;
  v70 = dobjModels;
  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11543, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, 2) )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11544, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !dobjModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11545, ASSERT_TYPE_ASSERT, "(dobjModels)", (const char *)&queryFormat, "dobjModels") )
    __debugbreak();
  if ( commonModelCount > 0x20u )
  {
    LODWORD(modelCount) = 32;
    LODWORD(v60) = commonModelCount;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11546, ASSERT_TYPE_ASSERT, "( commonModelCount ) <= ( ( 32 ) )", "commonModelCount not in [0, DOBJ_MAX_CHARACTER_SUBMODELS]\n\t%u not in [0, %u]", v60, modelCount) )
      __debugbreak();
  }
  *(_QWORD *)&obj[8] = CG_GetLocalClientGlobals((const LocalClientNum_t)v12);
  v15 = *(cg_t **)&obj[8];
  v63 = BG_UsingAlternate(ps);
  if ( v63 )
    _RAX = BG_GetAltWeapon(_RSI);
  else
    _RAX = _RSI;
  __asm
  {
    vmovups ymm2, ymmword ptr [rax]
    vmovups ymmword ptr [rbp+530h+obj+0C8h], ymm2
    vmovups xmm0, xmmword ptr [rax+20h]
    vmovups xmmword ptr [rbp+530h+obj+0E8h], xmm0
    vmovsd  xmm1, qword ptr [rax+30h]
    vmovsd  qword ptr [rbp+530h+obj+0F8h], xmm1
  }
  *(_DWORD *)&obj[256] = *(_DWORD *)&_RAX->weaponCamo;
  __asm { vmovd   eax, xmm2 }
  if ( !(_WORD)_EAX )
  {
    __asm
    {
      vmovups ymm0, ymmword ptr [rsi]
      vmovups xmm1, xmmword ptr [rsi+20h]
    }
    v23 = *(_DWORD *)&_RSI->weaponCamo;
    __asm
    {
      vmovups ymmword ptr [rbp+530h+obj+0C8h], ymm0
      vmovsd  xmm0, qword ptr [rsi+30h]
      vmovsd  qword ptr [rbp+530h+obj+0F8h], xmm0
      vmovups xmmword ptr [rbp+530h+obj+0E8h], xmm1
    }
    *(_DWORD *)&obj[256] = v23;
  }
  if ( !CgWeaponMap::ms_instance[v12] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v62 = BG_PlayerDualWieldingWeapon(CgWeaponMap::ms_instance[v12], ps, (const Weapon *)&obj[200]) != 0;
  HasLadderHand = BG_HasLadderHand(ps);
  v25 = refreshOverridesOnly;
  v26 = (WeaponHand *)(*(_QWORD *)&obj[8] + 807496i64);
  __asm { vmovss  xmm6, cs:__real@3a83126f }
  v66 = HasLadderHand;
  v28 = 0;
  *(_QWORD *)&obj[24] = *(_QWORD *)&obj[8] + 511988i64;
  hand = WEAPON_HAND_DEFAULT;
  *(_QWORD *)&obj[40] = -807496i64 - *(_QWORD *)&obj[8];
  v29 = 1;
  do
  {
    if ( !v29 )
    {
      LODWORD(modelCount) = 2;
      LODWORD(v60) = v28;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v60, modelCount) )
        __debugbreak();
    }
    if ( !v26 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11566, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
      __debugbreak();
    v30 = preserveAnimState && v26->tree;
    v65 = v30;
    HandAnimTree = 0;
    if ( v62 || v66 || !v28 )
    {
      if ( !v25 )
      {
        if ( v30 )
        {
          if ( !v26 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10054, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
            __debugbreak();
          for ( _RDI = 0i64; _RDI < 53; ++_RDI )
          {
            v32 = s_persistentAnims[_RDI];
            *(double *)&_XMM0 = XAnimGetWeight(v26->tree, 0, XANIM_SUBTREE_DEFAULT, v32);
            tree = v26->tree;
            __asm { vmovss  [rbp+rdi+530h+animWeights], xmm0 }
            *(double *)&_XMM0 = XAnimGetGoalWeight(tree, 0, XANIM_SUBTREE_DEFAULT, v32);
            v34 = v26->tree;
            __asm { vmovss  [rbp+rdi+530h+animGoalWeights], xmm0 }
            *(double *)&_XMM0 = XAnimGetGoalTime(v34, 0, XANIM_SUBTREE_DEFAULT, v32);
            v35 = v26->tree;
            __asm { vmovss  [rbp+rdi+530h+animGoalTimes], xmm0 }
            *(double *)&_XMM0 = XAnimGetTime(v35, 0, XANIM_SUBTREE_DEFAULT, v32);
            __asm { vmovss  [rbp+rdi+530h+animTimes], xmm0 }
          }
          v15 = *(cg_t **)&obj[8];
          v11 = v70;
          v25 = refreshOverridesOnly;
        }
        StoreShieldPersistentAnims(v26, outAnimWeights, outAnimTimes, (const XAnimParts **)outShieldXParts);
        if ( recreateAnimTrees )
          CG_Weapons_FreeAnimTreeHand((const LocalClientNum_t)v12, (const PlayerHandIndex)v28);
        HandAnimTree = CG_Weapon_CreateHandAnimTree(v15, (const PlayerHandIndex)v28, _RSI, v63, v62);
      }
      weaponIndex[0] = 255;
      v36 = CG_Weapon_AddViewmodelHand((const LocalClientNum_t)v12, *(const playerState_s **)&obj[32], (const PlayerHandIndex)v28, _RSI, v63, v11, commonModelCount, weaponIndex);
      v37 = v36;
      if ( v36 > 0x20u )
      {
        LODWORD(modelCount) = 32;
        LODWORD(v60) = v36;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11602, ASSERT_TYPE_ASSERT, "( handModelCount ) <= ( ( 32 ) )", "handModelCount not in [0, DOBJ_MAX_CHARACTER_SUBMODELS]\n\t%u not in [0, %u]", v60, modelCount) )
          __debugbreak();
      }
      if ( v25 && v26->viewModelDObj )
      {
        DObjFreeMaterialOverrides(v26->viewModelDObj);
        DObjFreeMaterialData(v26->viewModelDObj);
      }
      else
      {
        v38 = Com_ClientDObjCreate(v11, v37, v26->tree, v28 + 2048, (LocalClientNum_t)v12, 1, (unsigned int)(v28 != 0) + 2048);
        v39 = weaponIndex[0];
        v26->viewModelDObj = v38;
        CG_Weapon_SetViewmodelWeaponFade((const LocalClientNum_t)v12, (v28 != 0) + 2048, v39, v38);
      }
      DObjSetCamoMaterialOverride(v26->viewModelDObj, v11, v37);
      if ( (unsigned int)v12 >= 2 )
      {
        LODWORD(modelCount) = 2;
        LODWORD(v60) = v12;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 19937, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v60, modelCount) )
          __debugbreak();
      }
      memset_0(&obj[48], 0, 0x98ui64);
      v40 = (char *)_RSI - (char *)cg_defaultWeaponStickerMaterialIndices;
      v41 = &obj[136];
      for ( i = 0i64; i < 4; ++i )
      {
        v43 = *(unsigned __int16 *)((char *)&cg_defaultWeaponStickerMaterialIndices[i + 1] + v40);
        if ( v43 )
        {
          v44 = cg_defaultWeaponStickerMaterialIndices[i];
          if ( v44 )
          {
            v45 = CG_Draw_StickerMaterialHandleForIndex((LocalClientNum_t)v12, v44);
            v46 = CG_Draw_StickerMaterialHandleForIndex((LocalClientNum_t)v12, v43);
            if ( v45 )
            {
              if ( v46 )
              {
                *(_QWORD *)v41 = v45;
                *((_QWORD *)v41 + 1) = v46;
              }
            }
          }
        }
        v41 += 16;
      }
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+530h+obj+30h]
        vmovups ymm1, ymmword ptr [rbp+530h+obj+50h]
      }
      viewModelDObj = v26->viewModelDObj;
      __asm
      {
        vmovups ymmword ptr [rbp+530h+obj+108h], ymm0
        vmovups ymm0, ymmword ptr [rbp-18h]
        vmovups ymmword ptr [rbp+530h+obj+128h], ymm1
        vmovups ymm1, ymmword ptr [rbp+530h+obj+90h]
        vmovups ymmword ptr [rbp+530h+obj+148h], ymm0
        vmovups xmm0, xmmword ptr [rbp+530h+obj+0B0h]
        vmovups ymmword ptr [rbp+530h+obj+168h], ymm1
        vmovsd  xmm1, qword ptr [rbp+530h+obj+0C0h]
        vmovups xmmword ptr [rbp+530h+obj+188h], xmm0
        vmovsd  qword ptr [rbp+530h+obj+198h], xmm1
      }
      DObjSetStickerMaterialOverrides(viewModelDObj, NULL, (const DObjStickerSlotList *)&obj[264]);
      v25 = refreshOverridesOnly;
      v28 = hand;
      if ( refreshOverridesOnly )
      {
        v15 = *(cg_t **)&obj[8];
      }
      else
      {
        if ( HandAnimTree )
        {
          CG_Weapon_InitHandAnimTree((const LocalClientNum_t)v12, *(const playerState_s **)&obj[32], v26, v65, animWeights, animTimes, animGoalWeights, animGoalTimes, outAnimWeights, outAnimTimes, (const XAnimParts **)outShieldXParts);
          if ( !v65 )
          {
            v54 = DVARBOOL_killswitch_viewmodel_locomotion_state_reset_enabled;
            if ( !DVARBOOL_killswitch_viewmodel_locomotion_state_reset_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_viewmodel_locomotion_state_reset_enabled") )
              __debugbreak();
            Dvar_CheckFrontendServerThread(v54);
            if ( v54->current.enabled )
              MovementAnimState::Reset(*(MovementAnimState **)&obj[24], (const LocalClientNum_t)v12, (const PlayerHandIndex)v28);
          }
        }
        v15 = *(cg_t **)&obj[8];
        if ( !*(_BYTE *)(*(_QWORD *)&obj[8] + 99178i64) && !*(_BYTE *)(*(_QWORD *)&obj[8] + 99179i64) )
        {
          LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v12);
          if ( (unsigned int)v28 >= 2 )
          {
            LODWORD(modelCount) = 2;
            LODWORD(v60) = v28;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v60, modelCount) )
              __debugbreak();
          }
          v56 = *(DObj **)((char *)&v26[20187].rocketModel + (_QWORD)LocalClientGlobals + *(_QWORD *)&obj[40]);
          BG_UpdateWeaponHidePartBitsForDObj(v56, (const Weapon *)&obj[200], 1, 0);
          CG_UpdateViewModelHidePartBits_EMP((const LocalClientNum_t)v12, v56);
          CG_UpdateViewModelHidePartBits_NightVisionGoggles((LocalClientNum_t)v12, (const PlayerHandIndex)v28);
          BG_UpdatedWeaponBones((const Weapon *)&obj[200], v26->viewModelDObj, 0);
        }
        if ( updateClientInfo )
        {
          __asm
          {
            vxorps  xmm0, xmm0, xmm0
            vcvtsi2ss xmm0, xmm0, dword ptr [rdi+65E4h]
            vmulss  xmm2, xmm0, xmm6
          }
          DObjUpdateClientInfo((DObj *)obj, *(float *)&_XMM1, v53, 0);
        }
        v25 = 0;
      }
      _RSI = *(const Weapon **)&obj[16];
      v11 = v70;
    }
    else
    {
      CG_Weapons_FreeAnimTreeHand((const LocalClientNum_t)v12, (const PlayerHandIndex)v28);
      CG_Weapon_FreeViewModelDobjHand((const LocalClientNum_t)v12, (const PlayerHandIndex)v28);
    }
    *(_QWORD *)&obj[24] += 16i64;
    ++v28;
    ++v26;
    hand = v28;
    v29 = (unsigned int)v28 < 2;
  }
  while ( v28 < 2 );
  __asm { vmovaps xmm6, [rsp+630h+var_40] }
}

/*
==============
CG_Weapon_AddViewmodelIK
==============
*/
__int64 CG_Weapon_AddViewmodelIK(const LocalClientNum_t localClientNum, const PlayerHandIndex hand, const playerState_s *ps, const Weapon *r_weapon, const XAnimWeaponIKModelsContainer *weaponIKModels, DObjModel *dobjModels, unsigned __int16 modelCount)
{
  const dvar_t *v10; 
  bool v11; 
  int v14; 
  cg_t *LocalClientGlobals; 
  char v17; 
  const SuitDef *SuitDef; 
  bool v22; 
  Weapon weapon; 
  XAnimIKTagRequest tagRequest; 
  XAnimIKTagRequest result[2]; 

  _R15 = r_weapon;
  if ( weaponIKModels )
  {
    v10 = DCONST_DVARBOOL_cg_viewmodelRoboticIK;
    if ( !DCONST_DVARBOOL_cg_viewmodelRoboticIK && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmodelRoboticIK") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v10);
    v11 = v10->current.enabled && BG_Suit_IsRoboticIKEnabled(ps->suitIndex);
    __asm
    {
      vmovups ymm0, ymmword ptr [r15]
      vmovups xmm1, xmmword ptr [r15+20h]
    }
    v14 = *(_DWORD *)&_R15->weaponCamo;
    __asm
    {
      vmovups ymmword ptr [rsp+1A0h+weapon.weaponIdx], ymm0
      vmovsd  xmm0, qword ptr [r15+30h]
      vmovsd  qword ptr [rbp+0A0h+weapon.attachmentVariationIndices+15h], xmm0
      vmovups xmmword ptr [rsp+1A0h+weapon.attachmentVariationIndices+5], xmm1
    }
    *(_DWORD *)&weapon.weaponCamo = v14;
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    if ( CG_Skydive_GetViewmodelState((const LocalClientNum_t)LocalClientGlobals->localClientNum) == PhaseSpace )
    {
      SuitDef = BG_GetSuitDef(LocalClientGlobals->predictedPlayerState.suitIndex);
      if ( !SuitDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10633, ASSERT_TYPE_ASSERT, "(suitDef)", (const char *)&queryFormat, "suitDef") )
        __debugbreak();
      if ( SuitDef->skydive_parachuteViewModel )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr cs:?NULL_WEAPON@@3UWeapon@@B.weaponIdx; Weapon const NULL_WEAPON
          vmovups xmm1, xmmword ptr cs:?NULL_WEAPON@@3UWeapon@@B.attachmentVariationIndices+5; Weapon const NULL_WEAPON
        }
        v17 = 1;
        __asm
        {
          vmovups ymmword ptr [rsp+1A0h+weapon.weaponIdx], ymm0
          vmovsd  xmm0, qword ptr cs:?NULL_WEAPON@@3UWeapon@@B.attachmentVariationIndices+15h; Weapon const NULL_WEAPON
          vmovsd  qword ptr [rbp+0A0h+weapon.attachmentVariationIndices+15h], xmm0
          vmovups xmmword ptr [rsp+1A0h+weapon.attachmentVariationIndices+5], xmm1
        }
        *(_DWORD *)&weapon.weaponCamo = *(_DWORD *)&NULL_WEAPON.weaponCamo;
      }
      else
      {
        v17 = 0;
      }
    }
    else
    {
      v17 = 0;
    }
    v22 = BG_UsingAlternate(ps);
    _RAX = XAnimIKSetupTagRequest(result, &weapon, v22, v11, 0, 0);
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovups ymmword ptr [rbp+0A0h+tagRequest.weapon.weaponIdx], ymm0
      vmovups ymm1, ymmword ptr [rax+20h]
      vmovups ymmword ptr [rbp+0A0h+tagRequest.weapon.attachmentVariationIndices+5], ymm1
    }
    if ( v17 || !BG_HasLadderHand(ps) )
    {
      if ( XAnimWeaponIKModelsContainer::GetXModelCount((XAnimWeaponIKModelsContainer *)weaponIKModels) > 0 )
      {
        memset_0(result, 0, sizeof(result));
        XAnimIKAttachTargetToWeapon(XANIM_IK_ACTOR_LEFT_HAND, cg_tagIKTargetModelLeft, weaponIKModels, &tagRequest, dobjModels, &modelCount, (CharacterModelType (*)[32])result);
        XAnimIKAttachTargetToWeapon(XANIM_IK_ACTOR_RIGHT_HAND, cg_tagIKTargetModelRight, weaponIKModels, &tagRequest, dobjModels, &modelCount, (CharacterModelType (*)[32])result);
      }
    }
    else
    {
      CG_Ladder_AttachIKMarkers(hand, localClientNum, weaponIKModels, &tagRequest, dobjModels, &modelCount);
    }
  }
  return modelCount;
}

/*
==============
CG_Weapon_AddViewmodelOffhandGesture
==============
*/
__int64 CG_Weapon_AddViewmodelOffhandGesture(const LocalClientNum_t localClientNum, PlayerHandIndex hand, DObjModel *dobjModels, unsigned __int16 modelCount)
{
  __int64 v4; 
  __int64 v8; 
  cg_t *LocalClientGlobals; 
  bool v10; 
  const WeaponDef *v11; 
  const XModel *gunXModel; 
  const char *Name; 
  DObjModel *outDObjModel; 
  __int64 v16; 

  v4 = localClientNum;
  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11326, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, 2) )
    __debugbreak();
  if ( !dobjModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11327, ASSERT_TYPE_ASSERT, "(dobjModels)", (const char *)&queryFormat, "dobjModels") )
    __debugbreak();
  if ( modelCount >= 0x20u )
  {
    LODWORD(v16) = 32;
    LODWORD(outDObjModel) = modelCount;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11328, ASSERT_TYPE_ASSERT, "(unsigned)( modelCount ) < (unsigned)( ( 32 ) )", "modelCount doesn't index DOBJ_MAX_CHARACTER_SUBMODELS\n\t%i not in [0, %i)", outDObjModel, v16) )
      __debugbreak();
  }
  v8 = v4;
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v4);
  if ( !CgWeaponMap::ms_instance[v4] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v10 = BG_PlayerOrEntityDualWielding(CgWeaponMap::ms_instance[v8], &LocalClientGlobals->predictedPlayerState, NULL, NULL);
  if ( hand )
  {
    if ( hand == WEAPON_HAND_LEFT && !v10 )
      return modelCount;
  }
  else if ( v10 )
  {
    return modelCount;
  }
  LocalClientGlobals->gestureWeapInfo.gestureWeapModel = NULL;
  if ( LocalClientGlobals->gestureWeapInfo.offhandGestureWeapon.weaponIdx )
  {
    v11 = BG_WeaponDef(&LocalClientGlobals->gestureWeapInfo.offhandGestureWeapon, 0);
    gunXModel = v11->gunXModel;
    if ( gunXModel )
    {
      if ( modelCount >= 0x20u )
      {
        Name = XModelGetName(gunXModel);
        Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1442DE1E0, 612i64, 32i64, Name);
      }
      if ( CgWeaponSystem::ms_allocatedType == WEAPONS_TYPE_NONE )
      {
        LODWORD(v16) = v4;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.h", 530, ASSERT_TYPE_ASSERT, "(ms_allocatedType != CgWeaponsType::WEAPONS_TYPE_NONE)", "%s\n\tTrying to access the weapon system for localClientNum %d but the weapon system type is not known\n", "ms_allocatedType != CgWeaponsType::WEAPONS_TYPE_NONE", v16) )
          __debugbreak();
      }
      if ( (unsigned int)v4 >= CgWeaponSystem::ms_allocatedCount )
      {
        LODWORD(v16) = CgWeaponSystem::ms_allocatedCount;
        LODWORD(outDObjModel) = v4;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.h", 531, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( ms_allocatedCount )", "localClientNum doesn't index ms_allocatedCount\n\t%i not in [0, %i)", outDObjModel, v16) )
          __debugbreak();
      }
      if ( !CgWeaponSystem::ms_weaponSystemArray[v8] )
      {
        LODWORD(v16) = v4;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.h", 532, ASSERT_TYPE_ASSERT, "(ms_weaponSystemArray[localClientNum])", "%s\n\tTrying to access unallocated weapon system for localClientNum %d\n", "ms_weaponSystemArray[localClientNum]", v16) )
          __debugbreak();
      }
      if ( !CgWeaponSystem::ms_weaponSystemArray[v8]->IsWeaponViewModelLoaded(CgWeaponSystem::ms_weaponSystemArray[v8], (const Weapon *)&LocalClientGlobals->gestureWeapInfo) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11353, ASSERT_TYPE_ASSERT, "(CgWeaponSystem::GetWeaponSystem( localClientNum )->IsWeaponViewModelLoaded( cgameGlob->gestureWeapInfo.offhandGestureWeapon ))", (const char *)&queryFormat, "CgWeaponSystem::GetWeaponSystem( localClientNum )->IsWeaponViewModelLoaded( cgameGlob->gestureWeapInfo.offhandGestureWeapon )") )
        __debugbreak();
      DObjInitModel(v11->gunXModel, scr_const.tag_accessory_left, 0, 0, NULL, &dobjModels[modelCount++]);
      LocalClientGlobals->gestureWeapInfo.gestureWeapModel = v11->gunXModel;
      LocalClientGlobals->gestureWeapInfo.isGestureWeapVisible = 1;
    }
  }
  return modelCount;
}

/*
==============
CG_Weapon_AddViewmodelWeapon
==============
*/
__int64 CG_Weapon_AddViewmodelWeapon(const LocalClientNum_t localClientNum, const PlayerHandIndex hand, bool isDualWield, const Weapon *r_weapon, const bool isAlternate, XModel *weaponModel, DObjModel *dobjModels, unsigned __int16 modelCount, unsigned __int16 *weaponIndex, XAnimWeaponIKModelsContainer *outWeaponIKModels)
{
  cg_t *LocalClientGlobals; 
  const char *WeaponName; 
  const DObjCamoParams *camoParams; 
  unsigned __int16 v16; 
  bool v17; 
  const dvar_t *v18; 
  DObjModel *outDObjModel; 
  DObjModel *v21; 
  unsigned __int16 numModels; 
  bool v23; 
  DObjCamoParams outLocalParams; 
  char output[1024]; 

  numModels = modelCount;
  v23 = isDualWield;
  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10679, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, 2) )
    __debugbreak();
  if ( !dobjModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10680, ASSERT_TYPE_ASSERT, "(dobjModels)", (const char *)&queryFormat, "dobjModels") )
    __debugbreak();
  if ( numModels >= 0x20u )
  {
    LODWORD(v21) = 32;
    LODWORD(outDObjModel) = numModels;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10681, ASSERT_TYPE_ASSERT, "(unsigned)( modelCount ) < (unsigned)( ( 32 ) )", "modelCount doesn't index DOBJ_MAX_CHARACTER_SUBMODELS\n\t%i not in [0, %i)", outDObjModel, v21) )
      __debugbreak();
  }
  if ( (unsigned int)hand >= NUM_WEAPON_HANDS )
  {
    LODWORD(v21) = 2;
    LODWORD(outDObjModel) = hand;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10682, ASSERT_TYPE_ASSERT, "(unsigned)( hand ) < (unsigned)( NUM_WEAPON_HANDS )", "hand doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", outDObjModel, v21) )
      __debugbreak();
  }
  if ( !outWeaponIKModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10683, ASSERT_TYPE_ASSERT, "(outWeaponIKModels)", (const char *)&queryFormat, "outWeaponIKModels") )
    __debugbreak();
  if ( weaponModel )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    if ( !LocalClientGlobals->playerWeaponInfo.isWeaponHidden )
    {
      if ( !XAnimWeaponIKModelsContainer::AddXModel(outWeaponIKModels, hand, weaponModel) )
      {
        WeaponName = BG_GetWeaponName(r_weapon, output, 0x400u);
        LODWORD(v21) = 12;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10700, ASSERT_TYPE_ASSERT, "(modelAdded)", "%s\n\tFailed to add IK target in xmodel because we reached the maximum number of %d for weapon %s", "modelAdded", v21, WeaponName) )
          __debugbreak();
      }
      if ( numModels >= 0x20u )
      {
        XModelGetName(weaponModel);
        Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1442DDF40, 609i64);
      }
      camoParams = BG_Camo_GetWeaponDObjCamoParams(r_weapon, 1, &outLocalParams);
      DObjInitModel(weaponModel, scr_const.tag_weapon, 0, 0, camoParams, &dobjModels[numModels]);
      v16 = numModels;
      *weaponIndex = numModels;
      numModels = v16 + 1;
      v17 = !LocalClientGlobals->playerWeaponInfo.isWeaponDefault && !LocalClientGlobals->playerWeaponInfo.hideReticle && Dvar_GetBool_Internal_DebugName(DVARBOOL_cg_lui_scope_reticles, "cg_lui_scope_reticles");
      LocalClientGlobals->shouldShowLUIScopeReticle = v17;
      if ( !LocalClientGlobals->playerWeaponInfo.isWeaponDefault )
        goto LABEL_33;
      v18 = DVARBOOL_cg_weapAllowDefaultModelAttachments;
      if ( !DVARBOOL_cg_weapAllowDefaultModelAttachments && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_weapAllowDefaultModelAttachments") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v18);
      if ( v18->current.enabled )
LABEL_33:
        BG_AddWeaponAttachmentModels(r_weapon, hand, v23, 1, 0, 0, dobjModels, 0x20u, &numModels, outWeaponIKModels, camoParams);
    }
  }
  return numModels;
}

/*
==============
CG_Weapon_ChangeViewmodelDobj
==============
*/
void CG_Weapon_ChangeViewmodelDobj(LocalClientNum_t localClientNum, const playerState_s *ps, const Weapon *r_weapon, XModel *newArms, bool updateClientInfo, bool recreateAnimTrees, bool refreshOverridesOnly, bool tryClearOffset)
{
  XAnimBonePhysicsStateBuffer *p_outStateBuffer; 
  LocalClientNum_t v11; 
  __int64 v12; 
  CgWeaponMap *Instance; 
  char v14; 
  const WeaponDef *v15; 
  int prevDualWielding; 
  int v17; 
  char isAlternate; 
  char v19; 
  Weapon *p_prevViewmodelWeapon; 
  bool v21; 
  ClientPlayerWeaponInfo *p_playerWeaponInfo; 
  bool v23; 
  cg_t *v24; 
  cg_t *v25; 
  playerState_s *v26; 
  int lastAnimIndex; 
  unsigned int animIndex; 
  cg_t *v29; 
  bool v30; 
  XModel *v31; 
  const Weapon *v32; 
  int v33; 
  cg_t *v34; 
  bool v35; 
  char v36; 
  XModel *hiddenViewArms; 
  bool v38; 
  int v39; 
  scr_string_t *v40; 
  XModel *v41; 
  XAnimBonePhysicsStateBuffer *v42; 
  void **v43; 
  DObjPartBits *p_dstParts; 
  WeaponHand *ViewModelHand; 
  void *SkelRecord; 
  int v47; 
  unsigned int NumModels; 
  LocalClientNum_t v49; 
  __int64 v50; 
  int i; 
  cg_t *v52; 
  unsigned __int16 v53; 
  XModel *gogglesModel; 
  const CarryObjectDef *PlayerCarryObjectDef; 
  unsigned __int16 commonModelCount; 
  bool v57; 
  playerState_s *v58; 
  bool v59; 
  scr_string_t *v60; 
  _DWORD *v61; 
  XAnimBonePhysicsStateBuffer *v62; 
  const DObj **p_viewModelDObj; 
  int v64; 
  void **v65; 
  bool v66; 
  int v67; 
  XModel *v68; 
  unsigned int v69; 
  const dvar_t *v70; 
  bool v71; 
  const dvar_t *v72; 
  void *skelRecord0; 
  DObjModel *outDObjModel; 
  DObjModel *outDObjModela; 
  DObjModel *dobjModels; 
  unsigned int dobjModelsb; 
  DObjModel *dobjModelsa; 
  char v84; 
  bool v85; 
  char v86; 
  char v87; 
  bool v88; 
  bool v89; 
  int outModelIndex; 
  char v91; 
  unsigned int carryObjectIndex; 
  LocalClientNum_t localClientNuma; 
  void *Buf2; 
  XModel *model; 
  playerState_s *psa; 
  cg_t *LocalClientGlobals; 
  XAnimBonePhysicsStateBuffer *v98; 
  scr_string_t *v99; 
  XModel *handModel; 
  void *v101; 
  void *skelRecord1; 
  CgWeaponSystem *WeaponSystem; 
  DObjPartBits dstParts; 
  DObjPartBits srcParts1; 
  scr_string_t srcPartNames0[254]; 
  scr_string_t srcPartNames1[254]; 
  scr_string_t dstPartNames[508]; 
  DObjModel v109; 
  DObjModel v110; 
  XModel *srcModels0[254]; 
  XModel *srcModels1; 
  XModel *dstModels[508]; 
  XAnimBonePhysicsStateBuffer outStateBuffer; 

  model = newArms;
  p_outStateBuffer = &outStateBuffer;
  Buf2 = (void *)r_weapon;
  psa = (playerState_s *)ps;
  v11 = localClientNum;
  localClientNuma = localClientNum;
  v12 = 2i64;
  do
  {
    XAnimBonePhysicsStateBuffer::XAnimBonePhysicsStateBuffer(p_outStateBuffer++);
    --v12;
  }
  while ( v12 );
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11708, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( r_weapon->weaponIdx >= BG_GetNumWeapons() )
  {
    dobjModelsb = BG_GetNumWeapons();
    LODWORD(outDObjModel) = r_weapon->weaponIdx;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11709, ASSERT_TYPE_ASSERT, "(unsigned)( r_weapon.weaponIdx ) < (unsigned)( BG_GetNumWeapons() )", "r_weapon.weaponIdx doesn't index BG_GetNumWeapons()\n\t%i not in [0, %i)", outDObjModel, dobjModelsb) )
      __debugbreak();
  }
  memset_0(srcModels0, 0, 0xFE0ui64);
  memset_0(dstModels, 0, sizeof(dstModels));
  if ( !r_weapon->weaponIdx )
    goto LABEL_129;
  LocalClientGlobals = CG_GetLocalClientGlobals(v11);
  Instance = CgWeaponMap::GetInstance(v11);
  WeaponSystem = CgWeaponSystem::GetWeaponSystem(v11);
  v14 = BG_UsingAlternate(ps);
  v15 = BG_WeaponDef(r_weapon, v14);
  prevDualWielding = LocalClientGlobals->prevDualWielding;
  v99 = (scr_string_t *)v15;
  v84 = prevDualWielding != 0;
  v17 = BG_PlayerDualWieldingWeapon(Instance, ps, r_weapon);
  isAlternate = LocalClientGlobals->playerWeaponInfo.isAlternate;
  v19 = v17 != 0;
  v91 = v17 != 0;
  if ( prevDualWielding || v17 || (p_prevViewmodelWeapon = &LocalClientGlobals->prevViewmodelWeapon, memcmp_0(&LocalClientGlobals->prevViewmodelWeapon, Buf2, 0x3Cui64)) || isAlternate == v14 )
  {
    v86 = 0;
    p_prevViewmodelWeapon = &LocalClientGlobals->prevViewmodelWeapon;
  }
  else
  {
    v86 = 1;
  }
  v21 = BG_WeaponsDifferOnlyInVariantForInstantSwitch(psa, LocalClientGlobals->prevWeaponFlags, p_prevViewmodelWeapon, (const Weapon *)Buf2) && LocalClientGlobals->playerWeaponInfo.isAlternate == v14;
  p_playerWeaponInfo = &LocalClientGlobals->playerWeaponInfo;
  handModel = LocalClientGlobals->playerWeaponInfo.handModel;
  v23 = (!memcmp_0(p_prevViewmodelWeapon, Buf2, 0x3Cui64) || v21) && isAlternate == v14 && v84 == v19;
  outModelIndex = LocalClientGlobals->playerWeaponInfo.carryObjectIndex;
  carryObjectIndex = psa->carryState.carryObjectIndex;
  v89 = CG_Skydive_GetViewmodelState(localClientNuma) != LocalClientGlobals->playerWeaponInfo.skydiveViewmodelState;
  if ( !BG_WeaponIsDualWield((const Weapon *)Buf2) || (v87 = 1, *((_DWORD *)v99 + 997) != 1) )
    v87 = 0;
  v24 = CG_GetLocalClientGlobals(localClientNuma);
  v88 = !CG_View_IsUsingDualFOV(localClientNuma) || !v24->dualViewScope || BG_ShowViewModelInDualFOV((const Weapon *)Buf2, v14);
  v25 = CG_GetLocalClientGlobals(localClientNuma);
  if ( !v25 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9904, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  v26 = psa;
  lastAnimIndex = v25->viewModelAnimScriptedInfo.lastAnimIndex;
  animIndex = psa->viewModelAnimScripted.animIndex;
  if ( tryClearOffset && !v87 && !v86 && !v21 && !refreshOverridesOnly )
  {
    v29 = LocalClientGlobals;
    *(_QWORD *)LocalClientGlobals->predictedViewState.weapMoveState.baseAngles.v = 0i64;
    *(_QWORD *)&v29->predictedViewState.weapMoveState.baseAngles.z = 0i64;
    *(_QWORD *)&v29->predictedViewState.weapMoveState.baseAnglesPivotStand.y = 0i64;
    *(_QWORD *)v29->predictedViewState.weapMoveState.baseAnglesPivotCrouch.v = 0i64;
    *(_QWORD *)&v29->predictedViewState.weapMoveState.baseAnglesPivotCrouch.z = 0i64;
    *(_QWORD *)&v29->predictedViewState.weapMoveState.baseOrigin.y = 0i64;
  }
  v30 = CG_RegisterWeapon(localClientNuma, v26, LocalClientGlobals->prevWeaponFlags, (const Weapon *)Buf2, p_playerWeaponInfo);
  v31 = model;
  if ( v30 || recreateAnimTrees || handModel != model )
    refreshOverridesOnly = 0;
  p_playerWeaponInfo->handModel = model;
  if ( !v31 )
  {
    v11 = localClientNuma;
LABEL_129:
    CG_Weapon_ViewModelDobj_CleanUp(v11);
    return;
  }
  v32 = (const Weapon *)Buf2;
  v33 = memcmp_0(p_prevViewmodelWeapon, Buf2, 0x3Cui64);
  v34 = LocalClientGlobals;
  v35 = !v33 && LocalClientGlobals->playerWeaponInfo.meleeComboSeqIdx != psa->weapCommon.meleeComboSeqIdx;
  if ( !v23 || v35 || recreateAnimTrees || lastAnimIndex != animIndex || v30 || outModelIndex != carryObjectIndex || v89 || (v36 = v84, v85 = 0, v36 != v91) )
    v85 = 1;
  hiddenViewArms = model;
  if ( !v88 )
    hiddenViewArms = cgMedia.hiddenViewArms;
  v38 = refreshOverridesOnly;
  model = hiddenViewArms;
  if ( refreshOverridesOnly )
  {
    v49 = localClientNuma;
    v50 = 0i64;
  }
  else
  {
    v39 = 0;
    v40 = srcPartNames0;
    v41 = (XModel *)srcModels0;
    carryObjectIndex = 0;
    v42 = &outStateBuffer;
    v99 = srcPartNames0;
    handModel = (XModel *)srcModels0;
    v43 = &v101;
    v98 = &outStateBuffer;
    p_dstParts = &dstParts;
    do
    {
      ViewModelHand = cg_t::GetViewModelHand(v34, (const PlayerHandIndex)v39);
      XAnimBonePhysicsSaveState(ViewModelHand->viewModelDObj, v42);
      if ( ViewModelHand->viewModelDObj )
      {
        SkelRecord = Com_GetSkelRecord(ViewModelHand->viewModelDObj);
        *v43 = SkelRecord;
        DObjTransferSkinningSkelRecordBits(p_dstParts, SkelRecord);
        v47 = 0;
        if ( DObjGetNumBones(ViewModelHand->viewModelDObj) > 0 )
        {
          do
          {
            *v40 = DObjGetBoneNameScriptStringAndModelIndex(ViewModelHand->viewModelDObj, v47, &outModelIndex);
            NumModels = DObjGetNumModels(ViewModelHand->viewModelDObj);
            if ( outModelIndex >= NumModels )
            {
              LODWORD(dobjModels) = DObjGetNumModels(ViewModelHand->viewModelDObj);
              LODWORD(outDObjModel) = outModelIndex;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11806, ASSERT_TYPE_ASSERT, "(unsigned)( boneModelIndex ) < (unsigned)( DObjGetNumModels( weapHand->viewModelDObj ) )", "boneModelIndex doesn't index DObjGetNumModels( weapHand->viewModelDObj )\n\t%i not in [0, %i)", outDObjModel, dobjModels) )
                __debugbreak();
            }
            v41->name = (const char *)DObjGetModel(ViewModelHand->viewModelDObj, outModelIndex);
            ++v47;
            ++v40;
            v41 = (XModel *)((char *)v41 + 8);
          }
          while ( v47 < DObjGetNumBones(ViewModelHand->viewModelDObj) );
          v39 = carryObjectIndex;
          v40 = v99;
          v41 = handModel;
        }
        v42 = v98;
      }
      else
      {
        *v43 = NULL;
        bitarray_simd<256,bitarray_traits_simd128<bitarray_memory_traits_simd128u>>::resetAllBits(p_dstParts);
      }
      v34 = LocalClientGlobals;
      ++v39;
      ++v42;
      carryObjectIndex = v39;
      v41 = (XModel *)((char *)v41 + 2032);
      v98 = v42;
      v40 += 254;
      handModel = v41;
      ++p_dstParts;
      v99 = v40;
      ++v43;
    }
    while ( v39 < 2 );
    v49 = localClientNuma;
    v50 = 0i64;
    for ( i = 0; i < 2; ++i )
      CG_Weapon_FreeViewModelDobjHand(v49, (const PlayerHandIndex)i);
    v32 = (const Weapon *)Buf2;
    v38 = 0;
    hiddenViewArms = model;
  }
  if ( !hiddenViewArms && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10553, ASSERT_TYPE_ASSERT, "(viewHands)", (const char *)&queryFormat, "viewHands") )
    __debugbreak();
  DObjInitModel(hiddenViewArms, (scr_string_t)0, 0, 0, NULL, &v109);
  v52 = LocalClientGlobals;
  v53 = 1;
  gogglesModel = LocalClientGlobals->playerWeaponInfo.gogglesModel;
  if ( gogglesModel )
  {
    DObjInitModel(gogglesModel, scr_const.tag_playerhelmet, 0, 0, NULL, &v110);
    v52->playerWeaponInfo.gogglesAreHidden = 0;
    v53 = 2;
  }
  if ( BG_CarryObject_IsActive(&v52->predictedPlayerState) )
  {
    PlayerCarryObjectDef = BG_GetPlayerCarryObjectDef(&v52->predictedPlayerState);
    if ( !PlayerCarryObjectDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10599, ASSERT_TYPE_ASSERT, "(carryObjectDef)", (const char *)&queryFormat, "carryObjectDef") )
      __debugbreak();
    if ( PlayerCarryObjectDef->carryViewModel )
      DObjInitModel(PlayerCarryObjectDef->carryViewModel, PlayerCarryObjectDef->attachTag, 0, 0, NULL, &v109 + v53++);
  }
  commonModelCount = WeaponSystem->GetWeaponAttachModels(WeaponSystem, v53, &v109);
  v57 = v86 || v89;
  v58 = psa;
  CG_Weapon_AddViewmodelHeldModels(v49, psa, v32, v85, v57, updateClientInfo, &v109, commonModelCount, v38);
  if ( !v38 )
  {
    v59 = BG_UsingAlternate(v58);
    CG_ProcessWeaponOnAltChange(v49, v59);
    carryObjectIndex = 0;
    v60 = NULL;
    model = (XModel *)dstModels;
    v99 = NULL;
    v61 = dstPartNames;
    psa = (playerState_s *)&dstParts;
    v62 = &outStateBuffer;
    Buf2 = dstPartNames;
    p_viewModelDObj = (const DObj **)&v52->m_weaponHand[0].viewModelDObj;
    v98 = &outStateBuffer;
    v64 = 0;
    v65 = &v101;
    v66 = 1;
    do
    {
      if ( !v66 )
      {
        LODWORD(dobjModelsa) = 2;
        LODWORD(outDObjModela) = v64;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", outDObjModela, dobjModelsa) )
          __debugbreak();
      }
      XAnimBonePhysicsRestoreState(*p_viewModelDObj, v62);
      if ( *p_viewModelDObj )
      {
        v67 = 0;
        if ( DObjGetNumBones(*p_viewModelDObj) > 0 )
        {
          v68 = model;
          do
          {
            *v61 = DObjGetBoneNameScriptStringAndModelIndex(*p_viewModelDObj, v67, &outModelIndex);
            v69 = DObjGetNumModels(*p_viewModelDObj);
            if ( outModelIndex >= v69 )
            {
              LODWORD(dobjModelsa) = DObjGetNumModels(*p_viewModelDObj);
              LODWORD(outDObjModela) = outModelIndex;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11856, ASSERT_TYPE_ASSERT, "(unsigned)( boneModelIndex ) < (unsigned)( DObjGetNumModels( weapHand->viewModelDObj ) )", "boneModelIndex doesn't index DObjGetNumModels( weapHand->viewModelDObj )\n\t%i not in [0, %i)", outDObjModela, dobjModelsa) )
                __debugbreak();
            }
            v68->name = (const char *)DObjGetModel(*p_viewModelDObj, outModelIndex);
            ++v67;
            ++v61;
            v68 = (XModel *)((char *)v68 + 8);
          }
          while ( v67 < DObjGetNumBones(*p_viewModelDObj) );
          v64 = carryObjectIndex;
          v60 = v99;
          v61 = Buf2;
        }
        v70 = DVARBOOL_cg_enableSkinningSkelRecordTransferAkimboFix;
        if ( !DVARBOOL_cg_enableSkinningSkelRecordTransferAkimboFix && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_enableSkinningSkelRecordTransferAkimboFix") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v70);
        v71 = !v70->current.enabled;
        v72 = DVARBOOL_cg_enableSkinningSkelRecordTransferFix;
        if ( v71 )
        {
          if ( !DVARBOOL_cg_enableSkinningSkelRecordTransferFix && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_enableSkinningSkelRecordTransferFix") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v72);
          DObjTransferAndMergeSkinningSkelRecords(*p_viewModelDObj, v72->current.enabled, &dstPartNames[v50], (const XModel **)((char *)dstModels + (_QWORD)v60), (const XModel **)srcModels0, (const XModel **)&srcModels1, srcPartNames0, srcPartNames1, &dstParts, &srcParts1, v101, skelRecord1);
        }
        else
        {
          skelRecord0 = *v65;
          if ( !DVARBOOL_cg_enableSkinningSkelRecordTransferFix && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_enableSkinningSkelRecordTransferFix") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v72);
          DObjTransferAndMergeSkinningSkelRecords(*p_viewModelDObj, v72->current.enabled, &dstPartNames[v50], (const XModel **)((char *)dstModels + (_QWORD)v60), (const XModel **)((char *)srcModels0 + (_QWORD)v60), NULL, &srcPartNames0[v50], NULL, (const DObjPartBits *)psa, NULL, skelRecord0, NULL);
          v61 = Buf2;
        }
        v62 = v98;
      }
      psa = (playerState_s *)((char *)psa + 32);
      model = (XModel *)((char *)model + 2032);
      ++v64;
      ++v62;
      carryObjectIndex = v64;
      v60 += 508;
      v98 = v62;
      v61 += 254;
      v99 = v60;
      v50 += 254i64;
      Buf2 = v61;
      p_viewModelDObj += 5;
      ++v65;
      v66 = (unsigned int)v64 < 2;
    }
    while ( v64 < 2 );
    _R15 = LocalClientGlobals;
    if ( v87 && v85 )
    {
      if ( v101 && skelRecord1 )
      {
        if ( LocalClientGlobals->viewModelPose.skinCacheEntry.numSkinnedVerts == LocalClientGlobals->viewModelPoseLeftHand.skinCacheEntry.numSkinnedVerts )
        {
          __asm
          {
            vmovups xmm0, xmmword ptr [r15+4A284h]
            vmovups xmmword ptr [r15+4A164h], xmm0
            vmovsd  xmm1, qword ptr [r15+4A294h]
            vmovsd  qword ptr [r15+4A174h], xmm1
          }
        }
      }
      else if ( LocalClientGlobals->viewModelPose.skinCacheEntry.numSkinnedVerts == LocalClientGlobals->viewModelPoseLeftHand.skinCacheEntry.numSkinnedVerts )
      {
        __asm
        {
          vmovups xmm0, xmmword ptr [r15+4A164h]
          vmovups xmmword ptr [r15+4A284h], xmm0
          vmovsd  xmm1, qword ptr [r15+4A174h]
          vmovsd  qword ptr [r15+4A294h], xmm1
        }
      }
    }
  }
}

/*
==============
CG_Weapon_CreateHandAnimTree
==============
*/
char CG_Weapon_CreateHandAnimTree(cg_t *cgameGlob, const PlayerHandIndex hand, const Weapon *r_weapon, const bool isAlternate, const bool isDualWielding)
{
  __int64 v5; 
  XAnimTree *tree; 
  const WeaponDef *v10; 
  XAnimOwner v11; 
  WeaponXAnim *p_animsTwoHanded; 
  const WeaponDef *v13; 
  WeaponAnimPackage *szXAnims; 
  const WeaponCompleteDef *v15; 
  XAnimTree *SmallTree; 
  XAnim_s *anims; 
  __int64 v19; 
  __int64 v20; 
  __int64 v21; 

  v5 = hand;
  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10271, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( (unsigned int)v5 >= 2 )
  {
    LODWORD(v19) = v5;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10272, ASSERT_TYPE_ASSERT, "(unsigned)( hand ) < (unsigned)( NUM_WEAPON_HANDS )", "hand doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v19, 2) )
      __debugbreak();
    LODWORD(v21) = 2;
    LODWORD(v20) = v5;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v20, v21) )
      __debugbreak();
  }
  if ( (cg_t *)((char *)cgameGlob + 40 * v5) == (cg_t *)-807496i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10275, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
    __debugbreak();
  tree = cgameGlob->m_weaponHand[v5].tree;
  if ( tree )
  {
    if ( !tree->anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10313, ASSERT_TYPE_ASSERT, "(weapHand->tree->anims)", (const char *)&queryFormat, "weapHand->tree->anims") )
      __debugbreak();
    if ( !cgameGlob->m_weaponHand[v5].tree->anims->initialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10314, ASSERT_TYPE_ASSERT, "(weapHand->tree->anims->initialized)", (const char *)&queryFormat, "weapHand->tree->anims->initialized") )
      __debugbreak();
    anims = cgameGlob->m_weaponHand[v5].tree->anims;
    if ( !anims )
    {
      CrashReport_TriggerNow();
      anims = cgameGlob->m_weaponHand[v5].tree->anims;
    }
    if ( !anims->initialized )
      CrashReport_TriggerNow();
    return 0;
  }
  else
  {
    v10 = BG_WeaponDef(r_weapon, isAlternate);
    p_animsTwoHanded = &cgameGlob->playerWeaponInfo.animsTwoHanded;
    v13 = v10;
    if ( !cgameGlob->playerWeaponInfo.animsTwoHanded.xanim.size )
    {
      szXAnims = v10->szXAnims;
      if ( szXAnims && *((_QWORD *)szXAnims->anims + 236) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10284, ASSERT_TYPE_ASSERT, "(weapDef->szXAnims == 0 || weapDef->szXAnims->anims[WEAP_ANIM_IDLE] == 0)", (const char *)&queryFormat, "weapDef->szXAnims == NULL || weapDef->szXAnims->anims[WEAP_ANIM_IDLE] == NULL") )
        __debugbreak();
      if ( v13->gunXModel && v13->handXModel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10285, ASSERT_TYPE_ASSERT, "(!weapDef->gunXModel || !weapDef->handXModel)", (const char *)&queryFormat, "!weapDef->gunXModel || !weapDef->handXModel") )
        __debugbreak();
      v15 = BG_WeaponCompleteDef(r_weapon, isAlternate);
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1442DDA40, 605i64, v15->szInternalName);
    }
    if ( isDualWielding && BG_OneHandedViewModelAnimsValid(v13) )
    {
      if ( (_DWORD)v5 )
        p_animsTwoHanded = &cgameGlob->playerWeaponInfo.animsLeftHanded;
      else
        p_animsTwoHanded = &cgameGlob->playerWeaponInfo.animsRightHanded;
    }
    else if ( isAlternate )
    {
      p_animsTwoHanded = &cgameGlob->playerWeaponInfo.animsTwoHandedAltMode;
    }
    if ( !p_animsTwoHanded && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10302, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
      __debugbreak();
    if ( !p_animsTwoHanded->xanim.initialized )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10303, ASSERT_TYPE_ASSERT, "(anims->initialized)", (const char *)&queryFormat, "anims->initialized") )
        __debugbreak();
      if ( !p_animsTwoHanded->xanim.initialized )
        CrashReport_TriggerNow();
    }
    LOBYTE(v11) = 1;
    SmallTree = Com_XAnimCreateSmallTree(&p_animsTwoHanded->xanim, v11);
    if ( !SmallTree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9552, ASSERT_TYPE_ASSERT, "(pAnimTree)", (const char *)&queryFormat, "pAnimTree") )
      __debugbreak();
    cgameGlob->m_weaponHand[v5].tree = SmallTree;
    if ( !SmallTree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10307, ASSERT_TYPE_ASSERT, "(weapHand->tree)", (const char *)&queryFormat, "weapHand->tree") )
      __debugbreak();
    return 1;
  }
}

/*
==============
CG_Weapon_FreeViewModelDobj
==============
*/
void CG_Weapon_FreeViewModelDobj(const LocalClientNum_t localClientNum)
{
  int v1; 
  bool v2; 
  __int64 v4; 
  cg_t *LocalClientGlobals; 
  __int64 v6; 
  __int64 v7; 

  v1 = 0;
  v2 = 1;
  v4 = 0i64;
  do
  {
    if ( !v2 )
    {
      LODWORD(v7) = 2;
      LODWORD(v6) = v1;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10224, ASSERT_TYPE_ASSERT, "(unsigned)( hand ) < (unsigned)( NUM_WEAPON_HANDS )", "hand doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v6, v7) )
        __debugbreak();
    }
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    if ( (unsigned int)v1 >= 2 )
    {
      LODWORD(v7) = 2;
      LODWORD(v6) = v1;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v6, v7) )
        __debugbreak();
    }
    if ( LocalClientGlobals->m_weaponHand[v4].viewModelDObj )
    {
      Com_SafeClientDObjFree(v1 + 2048, localClientNum);
      LocalClientGlobals->m_weaponHand[v4].viewModelDObj = NULL;
    }
    ++v1;
    ++v4;
    v2 = (unsigned int)v1 < 2;
  }
  while ( v1 < 2 );
}

/*
==============
CG_Weapon_FreeViewModelDobjHand
==============
*/
void CG_Weapon_FreeViewModelDobjHand(const LocalClientNum_t localClientNum, const PlayerHandIndex hand)
{
  __int64 v2; 
  int v4; 
  cg_t *LocalClientGlobals; 
  WeaponHand *v6; 
  __int64 v7; 
  __int64 v9; 
  int v10; 

  v2 = hand;
  if ( (unsigned int)hand >= NUM_WEAPON_HANDS )
  {
    v10 = 2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10224, ASSERT_TYPE_ASSERT, "(unsigned)( hand ) < (unsigned)( NUM_WEAPON_HANDS )", "hand doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", hand, v10) )
      __debugbreak();
  }
  v4 = v2 + 2048;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( (unsigned int)v2 >= 2 )
  {
    LODWORD(v9) = 2;
    LODWORD(v7) = v2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v7, v9) )
      __debugbreak();
  }
  v6 = &LocalClientGlobals->m_weaponHand[v2];
  if ( v6->viewModelDObj )
  {
    Com_SafeClientDObjFree(v4, localClientNum);
    v6->viewModelDObj = NULL;
  }
}

/*
==============
CG_Weapon_GetRecoilAnims
==============
*/
void CG_Weapon_GetRecoilAnims(const LocalClientNum_t localClientNum, const playerState_s *const ps, weapAnimFiles_t *outRootAnim, weapAnimFiles_t *outRecoilAnim, bool *outIsAdditive)
{
  cg_t *LocalClientGlobals; 
  PlayerWeaponAnimArrays *p_m_weaponAnimArrays; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5970, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !outRootAnim && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5971, ASSERT_TYPE_ASSERT, "(outRootAnim)", (const char *)&queryFormat, "outRootAnim") )
    __debugbreak();
  if ( !outRecoilAnim && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5972, ASSERT_TYPE_ASSERT, "(outRecoilAnim)", (const char *)&queryFormat, "outRecoilAnim") )
    __debugbreak();
  if ( !outIsAdditive && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5973, ASSERT_TYPE_ASSERT, "(outIsAdditive)", (const char *)&queryFormat, "outIsAdditive") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5976, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( &LocalClientGlobals->predictedPlayerState != ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5977, ASSERT_TYPE_ASSERT, "(&cgameGlob->predictedPlayerState == ps)", "%s\n\tInvalid player state in client weapon processing. Expected predicted player state.\n", "&cgameGlob->predictedPlayerState == ps") )
    __debugbreak();
  p_m_weaponAnimArrays = &LocalClientGlobals->m_weaponAnimArrays;
  if ( !p_m_weaponAnimArrays && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5980, ASSERT_TYPE_ASSERT, "(weaponAnimArrays)", (const char *)&queryFormat, "weaponAnimArrays") )
    __debugbreak();
  if ( BG_UsingAlternate(ps) )
    p_m_weaponAnimArrays = (PlayerWeaponAnimArrays *)((char *)p_m_weaponAnimArrays + 4976);
  *outIsAdditive = 0;
  *outRootAnim = WEAP_ANIM_RECOIL;
  *outRecoilAnim = WEAP_ANIM_RECOIL;
  if ( p_m_weaponAnimArrays->normalAnimArray[176] )
  {
    *outIsAdditive = 1;
    *outRootAnim = WEAP_ANIM_ADDITIVE_RECOIL_ROOT;
    *outRecoilAnim = WEAP_ANIM_ADDITIVE_RECOIL;
  }
}

/*
==============
CG_Weapon_InitHandAnimTree
==============
*/
void CG_Weapon_InitHandAnimTree(const LocalClientNum_t localClientNum, const playerState_s *ps, WeaponHand *weapHand, const bool restoreAnimState, const float *animWeights, const float *animTimes, const float *animGoalWeights, const float *animGoalTimes, const float *shieldAnimWeights, const float *shieldAnimTimes, const XAnimParts **shieldXAnimParts)
{
  XAnimTree *tree; 
  CgHandler *Handler; 
  unsigned int AdsDownAnim; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float fmtc; 
  float fmtd; 
  float fmte; 
  float fmtf; 
  float fmtg; 
  float fmth; 
  float fmti; 
  int forceBlendTime; 
  int forceBlendTimea; 
  int forceBlendTimeb; 
  int forceBlendTimec; 
  int forceBlendTimed; 
  int forceBlendTimee; 
  int forceBlendTimef; 
  int forceBlendTimeg; 
  DObj *objID; 
  float objIDa; 
  float objIDb; 
  float objIDc; 
  float objIDd; 
  float objIDe; 
  float objIDf; 
  float objIDg; 
  float objIDh; 

  __asm
  {
    vmovaps [rsp+88h+var_18], xmm6
    vmovaps [rsp+88h+var_28], xmm7
  }
  if ( !weapHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10326, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
    __debugbreak();
  if ( !animWeights && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10327, ASSERT_TYPE_ASSERT, "(animWeights)", (const char *)&queryFormat, "animWeights") )
    __debugbreak();
  if ( !animTimes && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10328, ASSERT_TYPE_ASSERT, "(animTimes)", (const char *)&queryFormat, "animTimes") )
    __debugbreak();
  if ( !animGoalWeights && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10329, ASSERT_TYPE_ASSERT, "(animGoalWeights)", (const char *)&queryFormat, "animGoalWeights") )
    __debugbreak();
  if ( !animGoalTimes && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10330, ASSERT_TYPE_ASSERT, "(animGoalTimes)", (const char *)&queryFormat, "animGoalTimes") )
    __debugbreak();
  tree = weapHand->tree;
  objID = weapHand->viewModelDObj;
  __asm
  {
    vxorps  xmm7, xmm7, xmm7
    vmovss  dword ptr [rsp+88h+fmt], xmm7
  }
  weapHand->iPrevAnim = -1;
  XAnimClearTreeGoalWeights(tree, 0, XANIM_SUBTREE_DEFAULT, 0, fmt, 1, objID, LINEAR);
  __asm
  {
    vmovss  xmm6, cs:__real@3f800000
    vmovss  dword ptr [rsp+88h+objID], xmm6
    vmovss  [rsp+88h+forceBlendTime], xmm7
    vmovss  dword ptr [rsp+88h+fmt], xmm6
  }
  XAnimSetGoalWeight(weapHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0, fmta, *(float *)&forceBlendTime, objIDa, (scr_string_t)0, 1u, 0, LINEAR, NULL);
  __asm
  {
    vmovss  dword ptr [rsp+88h+objID], xmm6
    vmovss  [rsp+88h+forceBlendTime], xmm7
    vmovss  dword ptr [rsp+88h+fmt], xmm6
  }
  XAnimSetGoalWeight(weapHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 1u, fmtb, *(float *)&forceBlendTimea, objIDb, (scr_string_t)0, 1u, 0, LINEAR, NULL);
  __asm
  {
    vmovss  dword ptr [rsp+88h+objID], xmm6
    vmovss  [rsp+88h+forceBlendTime], xmm7
    vmovss  dword ptr [rsp+88h+fmt], xmm6
  }
  XAnimSetGoalWeight(weapHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0xEu, fmtc, *(float *)&forceBlendTimeb, objIDc, (scr_string_t)0, 1u, 0, LINEAR, NULL);
  __asm
  {
    vmovss  dword ptr [rsp+88h+objID], xmm6
    vmovss  [rsp+88h+forceBlendTime], xmm7
    vmovss  dword ptr [rsp+88h+fmt], xmm6
  }
  XAnimSetGoalWeight(weapHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0xECu, fmtd, *(float *)&forceBlendTimec, objIDd, (scr_string_t)0, 1u, 0, LINEAR, NULL);
  __asm
  {
    vmovss  dword ptr [rsp+88h+objID], xmm6
    vmovss  [rsp+88h+forceBlendTime], xmm7
    vmovss  dword ptr [rsp+88h+fmt], xmm6
  }
  XAnimSetGoalWeight(weapHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 8u, fmte, *(float *)&forceBlendTimed, objIDe, (scr_string_t)0, 1u, 0, LINEAR, NULL);
  __asm
  {
    vmovss  dword ptr [rsp+88h+objID], xmm6
    vmovss  [rsp+88h+forceBlendTime], xmm7
    vmovss  dword ptr [rsp+88h+fmt], xmm6
  }
  XAnimSetGoalWeight(weapHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0xAu, fmtf, *(float *)&forceBlendTimee, objIDf, (scr_string_t)0, 1u, 0, LINEAR, NULL);
  __asm
  {
    vmovss  dword ptr [rsp+88h+objID], xmm6
    vmovss  [rsp+88h+forceBlendTime], xmm7
    vmovss  dword ptr [rsp+88h+fmt], xmm6
  }
  XAnimSetGoalWeight(weapHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0xBu, fmtg, *(float *)&forceBlendTimef, objIDg, (scr_string_t)0, 1u, 0, LINEAR, NULL);
  Handler = CgHandler::getHandler(localClientNum);
  AdsDownAnim = BG_GetAdsDownAnim(ps, Handler);
  if ( weapHand->tree->anims->entries[AdsDownAnim].parts != *(XAnimParts **)&weapHand->tree->anims[40].numGameParameters )
  {
    __asm
    {
      vmovss  dword ptr [rsp+88h+objID], xmm7
      vmovss  [rsp+88h+forceBlendTime], xmm7
      vmovss  dword ptr [rsp+88h+fmt], xmm6
    }
    XAnimSetGoalWeight(weapHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, AdsDownAnim, fmth, *(float *)&forceBlendTimeg, objIDh, (scr_string_t)0, 1u, 0, LINEAR, NULL);
    __asm { vmovss  dword ptr [rsp+88h+fmt], xmm6 }
    XAnimSetTime(weapHand->tree, 0, XANIM_SUBTREE_DEFAULT, AdsDownAnim, fmti);
  }
  if ( restoreAnimState )
    RestorePersistentAnims(weapHand, animWeights, animTimes, animGoalWeights, animGoalTimes);
  __asm
  {
    vmovaps xmm6, [rsp+88h+var_18]
    vmovaps xmm7, [rsp+88h+var_28]
  }
  RestoreShieldPersistentAnims(weapHand, shieldAnimWeights, shieldAnimTimes, shieldXAnimParts);
}

/*
==============
CG_Weapon_PlayADSSettleAnim
==============
*/

void __fastcall CG_Weapon_PlayADSSettleAnim(const LocalClientNum_t localClientNum, const playerState_s *const ps, double weaponPosFrac, DObj *obj, PlayerHandIndex hand, float settleAnimWeight)
{
  CgHandler *Handler; 
  signed int AdsSettleAnim; 
  CgWeaponMap *Instance; 
  const Weapon *CurrentWeaponForPlayer; 
  unsigned int OtherAdsSettleAnim; 
  char v28; 
  char v29; 
  float v39; 
  float v40; 
  float v41; 
  float v42; 
  float v43; 
  float v44; 
  float v45; 
  float v46; 
  float v47; 
  float v48; 
  float v49; 
  float v50; 
  float v51; 
  float v52; 
  float v53; 
  float v54; 
  float v55; 
  float v56; 
  float v57; 
  float v58; 
  float v59; 
  float v60; 
  char v66; 

  __asm
  {
    vmovaps [rsp+0C8h+var_28], xmm6
    vmovss  xmm6, [rsp+0C8h+settleAnimWeight]
    vmovss  [rsp+0C8h+var_A0], xmm6
    vmovaps [rsp+0C8h+var_58], xmm9
    vmovaps xmm9, xmm2
  }
  if ( CG_GameInterface_PlayADSSettleAnim(localClientNum, ps, *(float *)&weaponPosFrac, obj, hand, v46) )
    goto LABEL_17;
  Handler = CgHandler::getHandler(localClientNum);
  _RDI = CG_GetLocalClientGlobals(localClientNum);
  AdsSettleAnim = BG_GetAdsSettleAnim(ps, hand, Handler);
  if ( !AdsSettleAnim )
    goto LABEL_17;
  Instance = CgWeaponMap::GetInstance(localClientNum);
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(Instance, ps);
  if ( BG_PlayerDualWieldingWeapon(Instance, ps, CurrentWeaponForPlayer) )
    goto LABEL_17;
  __asm
  {
    vmovaps [rsp+0C8h+var_38], xmm7
    vmovaps [rsp+0C8h+var_48], xmm8
    vmovaps [rsp+0C8h+var_68], xmm10
    vmovss  xmm8, cs:__real@3f800000
  }
  OtherAdsSettleAnim = BG_GetOtherAdsSettleAnim((const weapAnimFiles_t)AdsSettleAnim);
  __asm { vxorps  xmm7, xmm7, xmm7 }
  if ( _RDI->adsSettlePending )
  {
    __asm { vcomiss xmm9, xmm7 }
    if ( !_RDI->adsSettlePending )
    {
      __asm
      {
        vmovss  [rsp+0C8h+var_98], xmm8
        vmovss  [rsp+0C8h+var_A0], xmm7
        vmovss  [rsp+0C8h+var_A8], xmm8
      }
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xA3u, v39, v47, v54, (scr_string_t)0, 0, 0, LINEAR, NULL);
      __asm
      {
        vmovss  [rsp+0C8h+var_98], xmm8
        vmovss  [rsp+0C8h+var_A0], xmm7
        vmovss  [rsp+0C8h+var_A8], xmm6
      }
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, AdsSettleAnim, v40, v48, v55, (scr_string_t)0, 0, 1, LINEAR, NULL);
      if ( OtherAdsSettleAnim )
      {
        __asm
        {
          vmovss  [rsp+0C8h+var_98], xmm7
          vmovss  [rsp+0C8h+var_A0], xmm7
          vmovss  [rsp+0C8h+var_A8], xmm7
        }
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, OtherAdsSettleAnim, v41, v49, v56, (scr_string_t)0, 0, 0, LINEAR, NULL);
      }
      _RDI->adsSettlePending = 0;
      _RDI->adsSettleMaxADSFraction = 0.0;
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  __asm { vcomiss xmm9, xmm7 }
  if ( _RDI->adsSettlePending )
  {
LABEL_10:
    __asm
    {
      vmovss  xmm0, dword ptr [rdi+18290h]
      vmaxss  xmm1, xmm0, xmm9
      vmovss  dword ptr [rdi+18290h], xmm1
    }
    _RDI->adsSettlePending = 1;
  }
LABEL_11:
  *(double *)&_XMM0 = XAnimGetGoalWeight(obj->tree, 0, XANIM_SUBTREE_DEFAULT, 0xA3u);
  __asm { vmovaps xmm10, xmm0 }
  *(double *)&_XMM0 = XAnimGetTime(obj->tree, 0, XANIM_SUBTREE_DEFAULT, AdsSettleAnim);
  __asm { vmovaps xmm6, xmm0 }
  *(double *)&_XMM0 = XAnimGetTime(obj->tree, 0, XANIM_SUBTREE_DEFAULT, OtherAdsSettleAnim);
  __asm { vucomiss xmm6, xmm8 }
  if ( v29 )
  {
    __asm
    {
      vmovss  [rsp+0C8h+var_98], xmm7
      vmovss  [rsp+0C8h+var_A0], xmm7
      vmovss  [rsp+0C8h+var_A8], xmm7
    }
    XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xA3u, v43, v51, v58, (scr_string_t)0, 0, 0, LINEAR, NULL);
    __asm
    {
      vmovss  [rsp+0C8h+var_98], xmm7
      vmovss  [rsp+0C8h+var_A0], xmm7
      vmovss  [rsp+0C8h+var_A8], xmm7
    }
    XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, AdsSettleAnim, v44, v52, v59, (scr_string_t)0, 0, 0, LINEAR, NULL);
    __asm
    {
      vmovss  [rsp+0C8h+var_98], xmm7
      vmovss  [rsp+0C8h+var_A0], xmm7
      vmovss  [rsp+0C8h+var_A8], xmm7
    }
    XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, OtherAdsSettleAnim, v45, v53, v60, (scr_string_t)0, 0, 0, LINEAR, NULL);
  }
  else
  {
    __asm
    {
      vucomiss xmm0, xmm8
      vcomiss xmm10, xmm7
    }
    if ( !(v28 | v29) )
    {
      __asm
      {
        vmovss  xmm1, cs:__real@3a83126f; min
        vsubss  xmm0, xmm8, xmm9; val
        vmovaps xmm2, xmm8; max
      }
      *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
      __asm
      {
        vmovss  [rsp+0C8h+var_98], xmm8
        vmovss  [rsp+0C8h+var_A0], xmm7
        vmovss  [rsp+0C8h+var_A8], xmm0
      }
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xA3u, v42, v50, v57, (scr_string_t)0, 0, 0, LINEAR, NULL);
    }
  }
  __asm
  {
    vmovaps xmm8, [rsp+0C8h+var_48]
    vmovaps xmm7, [rsp+0C8h+var_38]
    vmovaps xmm10, [rsp+0C8h+var_68]
  }
LABEL_17:
  _R11 = &v66;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm9, xmmword ptr [r11-40h]
  }
}

/*
==============
CG_Weapon_SetViewmodelWeaponFade
==============
*/
void CG_Weapon_SetViewmodelWeaponFade(const LocalClientNum_t localClientNum, const unsigned int entNum, const unsigned __int16 weaponIndex, DObj *weapHandDObj)
{
  cg_t *LocalClientGlobals; 
  const dvar_t *v9; 
  unsigned __int8 *modelEntityDataOffset; 
  unsigned __int8 numModels; 
  unsigned __int8 v12; 
  __int64 v13; 
  bool v14; 
  __int64 v15; 

  if ( !weapHandDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11475, ASSERT_TYPE_ASSERT, "( ( weapHandDObj != nullptr ) )", "( weapHandDObj ) = %p", NULL) )
    __debugbreak();
  if ( weaponIndex == 255 )
  {
    CG_WeaponFade_Init(localClientNum);
  }
  else
  {
    if ( weaponIndex > weapHandDObj->numModels )
    {
      LODWORD(v15) = weaponIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11484, ASSERT_TYPE_ASSERT, "( weaponIndex ) <= ( weapHandDObj->numModels )", "weaponIndex not in [0, weapHandDObj->numModels]\n\t%u not in [0, %u]", v15, weapHandDObj->numModels) )
        __debugbreak();
    }
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11487, ASSERT_TYPE_ASSERT, "( ( cgameGlob != nullptr ) )", "( cgameGlob ) = %p", NULL) )
      __debugbreak();
    if ( LocalClientGlobals->playerWeaponInfo.isWeaponDefault )
      CG_WeaponFade_InitFadedWeaponForEntity(localClientNum, entNum);
    else
      CG_WeaponFade_StartWeaponTransition(localClientNum, entNum);
    if ( CG_WeaponFade_IsWeaponFadedForEntity(localClientNum, entNum) )
    {
      if ( !weapHandDObj->materialData )
      {
        DObjAllocMaterialData(weapHandDObj);
        if ( !weapHandDObj->materialData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11506, ASSERT_TYPE_ASSERT, "( ( weapHandDObj->materialData != nullptr ) )", "( weapHandDObj->materialData ) = %p", NULL) )
          __debugbreak();
      }
      if ( !weapHandDObj->materialData->modelEntityDataOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 11507, ASSERT_TYPE_ASSERT, "( ( weapHandDObj->materialData->modelEntityDataOffset != nullptr ) )", "( weapHandDObj->materialData->modelEntityDataOffset ) = %p", NULL) )
        __debugbreak();
      v9 = DCONST_DVARBOOL_cg_weaponFade_applyToViewmodel;
      modelEntityDataOffset = weapHandDObj->materialData->modelEntityDataOffset;
      if ( !DCONST_DVARBOOL_cg_weaponFade_applyToViewmodel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_weaponFade_applyToViewmodel") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v9);
      numModels = weapHandDObj->numModels;
      if ( v9->current.enabled )
      {
        memset_0(modelEntityDataOffset, 0, numModels);
      }
      else
      {
        v12 = 0;
        if ( numModels )
        {
          do
          {
            v13 = v12;
            v14 = (unsigned __int16)v12++ != weaponIndex;
            modelEntityDataOffset[v13] = v14;
          }
          while ( v12 < weapHandDObj->numModels );
        }
      }
    }
  }
}

/*
==============
CG_Weapon_UpdateWeaponVisibility
==============
*/
char CG_Weapon_UpdateWeaponVisibility(const LocalClientNum_t localClientNum, const playerState_s *ps, const Weapon *r_weapon, const bool isAlternate)
{
  const dvar_t *v6; 
  char v7; 
  char v8; 
  __int64 v11; 
  char enabled; 
  CgWeaponMap *v14; 
  int weaponState; 
  unsigned __int64 v16; 
  __int64 v17; 
  bool v18; 
  const dvar_t *v19; 
  bool v20; 
  SkydiveViewmodelState ViewmodelState; 
  CgWeaponSystem *WeaponSystem; 
  const dvar_t *v23; 
  unsigned int time; 
  bool v28; 
  bool v29; 
  Material *whiteMaterial; 
  int fireDelay[4]; 
  int fireTime; 

  v6 = DCONST_DVARBOOL_cg_weapForceDefaultModel;
  v7 = 0;
  v8 = 0;
  v11 = localClientNum;
  if ( !DCONST_DVARBOOL_cg_weapForceDefaultModel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_weapForceDefaultModel") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v6);
  enabled = v6->current.enabled;
  _RBX = CG_GetLocalClientGlobals((const LocalClientNum_t)v11);
  if ( !CgWeaponMap::ms_instance[v11] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v14 = CgWeaponMap::ms_instance[v11];
  if ( BG_IsOffhandWeaponType(r_weapon, 0) )
  {
    weaponState = ps->weapState[0].weaponState;
    if ( weaponState == 16 || weaponState == 30 )
    {
      BG_GetFireTime(v14, ps, r_weapon, 0, 0, ps->weapState[0].weaponShotCount, &fireTime, fireDelay);
      if ( fireDelay[0] < fireTime )
        v8 = ps->weapState[0].weaponDelay == 0;
    }
  }
  if ( BG_HasLadderHand(ps) )
  {
    v16 = ps->weapState[0].weaponState;
    if ( (unsigned int)v16 <= 0x32 )
    {
      v17 = 0x6800000005020i64;
      if ( _bittest64(&v17, v16) )
      {
        v18 = BG_UsingAlternate(ps);
        if ( !BG_IsLadderWeapon(r_weapon, v18) )
          goto LABEL_21;
        v19 = DCONST_DVARMPBOOL_ladderEnableWeapon;
        if ( !DCONST_DVARMPBOOL_ladderEnableWeapon && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "ladderEnableWeapon") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v19);
        if ( !v19->current.enabled || (v20 = BG_UsingAlternate(ps), !BG_GetAmmoInClip(ps, r_weapon, v20, WEAPON_HAND_DEFAULT)) )
LABEL_21:
          v8 = 1;
      }
    }
  }
  ViewmodelState = CG_Skydive_GetViewmodelState((const LocalClientNum_t)v11);
  if ( ViewmodelState )
  {
    if ( ViewmodelState == Count && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10460, ASSERT_TYPE_ASSERT, "(skydiveViewmodelState != SkydiveViewmodelState::Count)", (const char *)&queryFormat, "skydiveViewmodelState != SkydiveViewmodelState::Count") )
      __debugbreak();
    v8 = 1;
  }
  WeaponSystem = CgWeaponSystem::GetWeaponSystem((const LocalClientNum_t)v11);
  if ( !WeaponSystem->IsWeaponViewModelLoaded(WeaponSystem, r_weapon) )
  {
    if ( BG_HasDefaultViewModel(r_weapon) )
      enabled = 1;
    else
      v8 = 1;
  }
  if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10362, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  v23 = DVARBOOL_cg_weapOverrideDefaultModelMat;
  if ( !DVARBOOL_cg_weapOverrideDefaultModelMat && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_weapOverrideDefaultModelMat") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v23);
  if ( v23->current.enabled )
  {
    if ( enabled )
    {
      _RBX->defaultViewmodelOverride.materialTargetType = Scriptable_MaterialOverrideType_Dissolve;
      _RBX->defaultViewmodelOverride.targetMaterial = cgMedia.whiteMaterial;
      _RBX->defaultViewmodelOverride.transitionIn = 0;
      _RBX->defaultViewmodelOverride.transitionLerp = 1.0;
      _RBX->defaultViewmodelMaterialTime = 0;
    }
    else if ( _RBX->playerWeaponInfo.isWeaponDefault )
    {
      _RBX->defaultViewmodelMaterialTime = _RBX->time;
    }
    if ( _RBX->defaultViewmodelMaterialTime )
    {
      _RDI = DVARFLT_cg_weapOverrideDefaultModelTrans;
      if ( !DVARFLT_cg_weapOverrideDefaultModelTrans && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_weapOverrideDefaultModelTrans") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(_RDI);
      __asm
      {
        vmovss  xmm0, dword ptr [rdi+28h]
        vmulss  xmm2, xmm0, cs:__real@447a0000
      }
      time = _RBX->time;
      v28 = time < _RBX->defaultViewmodelMaterialTime;
      v29 = time <= _RBX->defaultViewmodelMaterialTime;
      __asm
      {
        vxorps  xmm1, xmm1, xmm1; min
        vcomiss xmm2, xmm1
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm0, xmm0, eax
      }
      _RBX->refreshViewmodelMaterialOverride = 1;
      if ( v29 )
        goto LABEL_49;
      __asm { vcomiss xmm0, xmm2 }
      if ( !v28 )
      {
LABEL_49:
        _RBX->defaultViewmodelMaterialTime = 0;
        *(_QWORD *)&_RBX->defaultViewmodelOverride.entityNum = 0i64;
        _RBX->defaultViewmodelOverride.targetMaterial = NULL;
        *(_QWORD *)&_RBX->defaultViewmodelOverride.transitionLerp = 0i64;
      }
      else
      {
        __asm
        {
          vdivss  xmm0, xmm0, xmm2; val
          vmovaps [rsp+88h+var_38], xmm6
          vmovss  xmm6, cs:__real@3f800000
          vmovaps xmm2, xmm6; max
        }
        I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
        __asm
        {
          vsubss  xmm0, xmm6, xmm0
          vmovaps xmm6, [rsp+88h+var_38]
        }
        _RBX->defaultViewmodelOverride.materialTargetType = Scriptable_MaterialOverrideType_Dissolve;
        whiteMaterial = cgMedia.whiteMaterial;
        __asm { vmovss  dword ptr [rbx+0B53B0h], xmm0 }
        _RBX->defaultViewmodelOverride.targetMaterial = whiteMaterial;
        _RBX->defaultViewmodelOverride.transitionIn = 0;
      }
    }
  }
  if ( v8 != _RBX->playerWeaponInfo.isWeaponHidden )
  {
    _RBX->playerWeaponInfo.isWeaponHidden = v8;
    v7 = 1;
  }
  if ( enabled == _RBX->playerWeaponInfo.isWeaponDefault )
    return v7;
  _RBX->playerWeaponInfo.isWeaponDefault = enabled;
  return 1;
}

/*
==============
CG_Weapon_ViewModelDobj_CleanUp
==============
*/
void CG_Weapon_ViewModelDobj_CleanUp(const LocalClientNum_t localClientNum)
{
  cg_t *LocalClientGlobals; 
  int v3; 
  XAnimTree **p_tree; 
  bool v5; 
  __int64 v6; 
  __int64 v7; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10253, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  v3 = 0;
  p_tree = &LocalClientGlobals->m_weaponHand[0].tree;
  v5 = 1;
  do
  {
    if ( !v5 )
    {
      LODWORD(v7) = 2;
      LODWORD(v6) = v3;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v6, v7) )
        __debugbreak();
    }
    if ( !*p_tree )
      CG_Weapon_FreeViewModelDobjHand(localClientNum, (const PlayerHandIndex)v3);
    ++v3;
    p_tree += 5;
    v5 = (unsigned int)v3 < 2;
  }
  while ( v3 < 2 );
}

/*
==============
CG_Weapons_ActionSlotTypeUsageAllowed
==============
*/
char CG_Weapons_ActionSlotTypeUsageAllowed(const cg_t *const cgameGlob, const ActionSlotType type)
{
  CgWeaponMap *Instance; 
  CgHandler *Handler; 
  unsigned __int64 weaponState; 
  __int64 v7; 
  bool v8; 
  bool v9; 
  unsigned int v10; 

  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17990, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( !cgameGlob->nextSnap || GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&cgameGlob->predictedPlayerState.pm_flags, ACTIVE, 0x10u) || GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&cgameGlob->predictedPlayerState.pm_flags, ACTIVE, 0xFu) )
    return 0;
  Instance = CgWeaponMap::GetInstance((const LocalClientNum_t)cgameGlob->localClientNum);
  Handler = CgHandler::getHandler(cgameGlob->localClientNum);
  if ( (unsigned int)(type - 4) > 2 )
  {
    weaponState = cgameGlob->predictedPlayerState.weapState[0].weaponState;
    v8 = 0;
    if ( (unsigned int)weaponState <= 0x32 )
    {
      v7 = 0x4000000001FBEi64;
      if ( _bittest64(&v7, weaponState) )
        v8 = 1;
    }
    v9 = (unsigned int)(weaponState - 22) <= 2;
    v10 = weaponState - 26;
    if ( (v8 || v9 || v10 <= 6) && !PM_Weapon_IsInInterruptibleState(Instance, &cgameGlob->predictedPlayerState, WEAPON_HAND_DEFAULT, Handler) )
      return 0;
    if ( GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&cgameGlob->predictedPlayerState.weapCommon.weapFlags, ACTIVE, 0xAu) || GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&cgameGlob->predictedPlayerState.weapCommon.weapFlags, ACTIVE, 0xEu) && type != ACTIONSLOTTYPE_NIGHTVISION || BG_Offhand_HasNonInterruptibleActiveOffhand(Instance, &cgameGlob->predictedPlayerState, cgameGlob->time) )
      return 0;
  }
  if ( type != ACTIONSLOTTYPE_TAUNT && GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&cgameGlob->predictedPlayerState.pm_flags, ACTIVE, 0x1Du) && !PM_Weapon_IsInInterruptibleState(Instance, &cgameGlob->predictedPlayerState, WEAPON_HAND_DEFAULT, Handler) || !BG_IsPlayer(&cgameGlob->predictedPlayerState) || cgameGlob->IsClientGamePaused((cg_t *)cgameGlob) || GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&cgameGlob->predictedPlayerState.eFlags, ACTIVE, 0xBu) )
    return 0;
  if ( type > ACTIONSLOTTYPE_DONOTHING )
  {
    if ( type <= ACTIONSLOTTYPE_ALTWEAPONTOGGLE )
    {
      if ( GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&cgameGlob->predictedPlayerState.pm_flags, ACTIVE, 6u) || BG_IsTurretActive(&cgameGlob->predictedPlayerState) || cgameGlob->predictedPlayerState.vehicleState.entity != 2047 || Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_SLOW_SOFT_LAND|WEAPON_LADDER_AIM) && (unsigned int)(cgameGlob->predictedPlayerState.weapState[0].weaponState - 28) <= 1 )
        return 0;
    }
    else if ( (unsigned int)(type - 4) <= 2 && !BG_IsPlayerZeroG(&cgameGlob->predictedPlayerState) )
    {
      return 0;
    }
  }
  return 1;
}

/*
==============
CG_Weapons_ActionSlotUsageAllowed
==============
*/
bool CG_Weapons_ActionSlotUsageAllowed(const cg_t *const cgameGlob, const int slot)
{
  __int64 v2; 
  ActionSlotType v4; 

  v2 = slot;
  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17971, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  v4 = cgameGlob->predictedPlayerState.actionSlotType[v2];
  return ((_DWORD)v2 != 3 || !GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&cgameGlob->predictedPlayerState.pm_flags, ACTIVE, 5u)) && CG_Weapons_ActionSlotTypeUsageAllowed(cgameGlob, v4);
}

/*
==============
CG_Weapons_BlendOutOfRelativeSkydiveAnim
==============
*/
void CG_Weapons_BlendOutOfRelativeSkydiveAnim(const LocalClientNum_t localClientNum, const playerState_s *ps, const PlayerHandIndex hand, DObj *obj, const Weapon *weapon, const bool isAlternate, const bool isDualWielding, const int playerDualWieldingWeapon, const weapAnimFiles_t skydiveAnimIndex)
{
  XAnim_s *v15; 
  char v17; 
  float fmt; 
  __int64 goalTime; 
  float goalTimea; 
  float anims; 

  __asm { vmovaps [rsp+88h+var_28], xmm6 }
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6428, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6429, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  if ( (unsigned int)hand >= NUM_WEAPON_HANDS )
  {
    LODWORD(goalTime) = hand;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6430, ASSERT_TYPE_ASSERT, "(unsigned)( hand ) < (unsigned)( NUM_WEAPON_HANDS )", "hand doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", goalTime, 2) )
      __debugbreak();
  }
  v15 = XAnimGetAnims(obj->tree);
  if ( !v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6433, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
    __debugbreak();
  *(double *)&_XMM0 = XAnimGetGoalWeight(obj->tree, 0, XANIM_SUBTREE_DEFAULT, skydiveAnimIndex);
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vucomiss xmm0, xmm6
  }
  if ( !v17 )
  {
    *(float *)&_XMM0 = CG_Weapons_GetWeaponAnimRate(localClientNum, ps, hand, weapon, isAlternate, isDualWielding, v15, skydiveAnimIndex, skydiveAnimIndex, playerDualWieldingWeapon);
    __asm
    {
      vmovss  dword ptr [rsp+88h+anims], xmm0
      vmovss  xmm0, cs:BLEND_OUT_TIME
      vmovss  [rsp+88h+goalTime], xmm0
      vmovss  dword ptr [rsp+88h+fmt], xmm6
    }
    XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, skydiveAnimIndex, fmt, goalTimea, anims, (scr_string_t)0, 0, 0, LINEAR, NULL);
  }
  __asm { vmovaps xmm6, [rsp+88h+var_28] }
}

/*
==============
CG_Weapons_BuildDObj
==============
*/
void CG_Weapons_BuildDObj(const PlayerHandIndex hand, const Weapon *r_weapon, const bool useViewModel, const bool useStowedModel, const bool useDefaultModel, const bool useDualWielding, scr_string_t attachBoneName, const unsigned int maxDObjModels, DObjModel *outDObjModels, unsigned __int16 *outModelIndex, XAnimWeaponIKModelsContainer *outWeaponIKModels)
{
  PlayerHandIndex v13; 
  WeaponDef *weapDef; 
  scr_string_t tag_shield_back; 
  ClGameModeApplication *ActiveClientApplication; 
  const XModel *stowOffsetModel; 
  const XModel *WeaponModels; 
  const XModel *v19; 
  const char *WeaponName; 
  const DObjCamoParams *camoParams; 
  unsigned __int16 maxModels; 
  DObjModel *outDObjModel; 
  DObjModel *outDObjModela; 
  __int64 isUsingCensorshipWorldModel; 
  __int64 isUsingCensorshipWorldModela; 
  DObjCamoParams outLocalParams; 
  char output[1024]; 

  v13 = hand;
  if ( !r_weapon->weaponIdx && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25817, ASSERT_TYPE_ASSERT, "(!BG_IsNullWeapon( r_weapon ))", (const char *)&queryFormat, "!BG_IsNullWeapon( r_weapon )") )
    __debugbreak();
  if ( !outDObjModels && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25818, ASSERT_TYPE_ASSERT, "(outDObjModels)", (const char *)&queryFormat, "outDObjModels") )
    __debugbreak();
  if ( !outModelIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25819, ASSERT_TYPE_ASSERT, "(outModelIndex)", (const char *)&queryFormat, "outModelIndex") )
    __debugbreak();
  if ( *outModelIndex >= maxDObjModels )
  {
    LODWORD(outDObjModel) = *outModelIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25820, ASSERT_TYPE_ASSERT, "(unsigned)( *outModelIndex ) < (unsigned)( maxDObjModels )", "*outModelIndex doesn't index maxDObjModels\n\t%i not in [0, %i)", outDObjModel, maxDObjModels) )
      __debugbreak();
  }
  weapDef = BG_WeaponCompleteDef(r_weapon, 0)->weapDef;
  if ( !useStowedModel )
  {
    tag_shield_back = attachBoneName;
    goto LABEL_34;
  }
  if ( !weapDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25792, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  tag_shield_back = attachBoneName;
  if ( weapDef->stowOffsetModel )
  {
    ActiveClientApplication = ClGameModeApplication::GetActiveClientApplication();
    if ( ActiveClientApplication->IsModelLoaded(ActiveClientApplication, weapDef->stowOffsetModel) )
    {
      stowOffsetModel = weapDef->stowOffsetModel;
LABEL_22:
      if ( stowOffsetModel )
      {
        if ( *outModelIndex >= maxDObjModels )
        {
          LODWORD(isUsingCensorshipWorldModel) = maxDObjModels;
          LODWORD(outDObjModel) = *outModelIndex;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25830, ASSERT_TYPE_ASSERT, "(unsigned)( *outModelIndex ) < (unsigned)( maxDObjModels )", "*outModelIndex doesn't index maxDObjModels\n\t%i not in [0, %i)", outDObjModel, isUsingCensorshipWorldModel) )
            __debugbreak();
        }
        DObjInitModel(stowOffsetModel, attachBoneName, 1, 0, NULL, &outDObjModels[*outModelIndex]);
        ++*outModelIndex;
      }
      v13 = hand;
      goto LABEL_28;
    }
    if ( weapDef->stowOffsetModel == weapDef->worldModel )
    {
      stowOffsetModel = weapDef->defaultWorldModel;
      goto LABEL_22;
    }
  }
LABEL_28:
  if ( BG_GetWeaponType(r_weapon, 0) == WEAPTYPE_RIOTSHIELD )
  {
    tag_shield_back = scr_const.tag_shield_back;
  }
  else if ( weapDef->stowTag )
  {
    tag_shield_back = weapDef->stowTag;
  }
LABEL_34:
  WeaponModels = BG_GetWeaponModels(v13, r_weapon, useViewModel, useDefaultModel, useDualWielding, 0, 0);
  v19 = WeaponModels;
  if ( WeaponModels )
  {
    if ( outWeaponIKModels )
    {
      if ( !XAnimWeaponIKModelsContainer::AddXModel(outWeaponIKModels, hand, WeaponModels) )
      {
        WeaponName = BG_GetWeaponName(r_weapon, output, 0x400u);
        LODWORD(isUsingCensorshipWorldModela) = 12;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25859, ASSERT_TYPE_ASSERT, "(modelAdded)", "%s\n\tFailed to add IK target in xmodel because we reached the maximum number of %d for weapon %s", "modelAdded", isUsingCensorshipWorldModela, WeaponName) )
          __debugbreak();
      }
    }
    camoParams = BG_Camo_GetWeaponDObjCamoParams(r_weapon, useViewModel, &outLocalParams);
    if ( *outModelIndex >= maxDObjModels )
    {
      LODWORD(isUsingCensorshipWorldModela) = maxDObjModels;
      LODWORD(outDObjModela) = *outModelIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25866, ASSERT_TYPE_ASSERT, "(unsigned)( *outModelIndex ) < (unsigned)( maxDObjModels )", "*outModelIndex doesn't index maxDObjModels\n\t%i not in [0, %i)", outDObjModela, isUsingCensorshipWorldModela) )
        __debugbreak();
    }
    DObjInitModel(v19, tag_shield_back, 0, 0, camoParams, &outDObjModels[*outModelIndex]);
    ++*outModelIndex;
    if ( !useDefaultModel )
    {
      maxModels = truncate_cast<unsigned short,unsigned int>(maxDObjModels);
      BG_AddWeaponAttachmentModels(r_weapon, hand, useDualWielding, useViewModel, 1, 0, outDObjModels, maxModels, outModelIndex, outWeaponIKModels, camoParams);
    }
  }
}

/*
==============
CG_Weapons_BuildStickerSlotList
==============
*/
DObjStickerSlotList *CG_Weapons_BuildStickerSlotList(DObjStickerSlotList *result, const LocalClientNum_t localClientNum, const CharacterModelType *modelTypesToApply, const int modelTypesToApplyCount, const Weapon *weapon)
{
  unsigned __int64 v9; 
  unsigned int i; 
  __int64 v11; 
  DObjStickerSlot *slots; 
  unsigned __int16 v13; 
  unsigned __int16 v14; 
  Material *v15; 
  Material *v16; 

  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 19937, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, 2) )
    __debugbreak();
  memset_0(result, 0, sizeof(DObjStickerSlotList));
  v9 = 0i64;
  result->modelTypeCount = modelTypesToApplyCount;
  if ( modelTypesToApplyCount )
  {
    if ( !modelTypesToApply && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 19944, ASSERT_TYPE_ASSERT, "(modelTypesToApply)", (const char *)&queryFormat, "modelTypesToApply") )
      __debugbreak();
    for ( i = 0; i < result->modelTypeCount; result->modelTypeToApply[v11] = modelTypesToApply[v11] )
      v11 = i++;
  }
  slots = result->slots;
  do
  {
    v13 = weapon->stickerIndices[v9];
    if ( v13 )
    {
      v14 = cg_defaultWeaponStickerMaterialIndices[v9];
      if ( v14 )
      {
        v15 = CG_Draw_StickerMaterialHandleForIndex(localClientNum, v14);
        v16 = CG_Draw_StickerMaterialHandleForIndex(localClientNum, v13);
        if ( v15 )
        {
          if ( v16 )
          {
            slots->blankMaterial = v15;
            slots->overrideMaterial = v16;
          }
        }
      }
    }
    ++v9;
    ++slots;
  }
  while ( v9 < 4 );
  return result;
}

/*
==============
CG_Weapons_BulletTrace
==============
*/
bool CG_Weapons_BulletTrace(const LocalClientNum_t localClientNum, BulletFireParams *bp, const Weapon *weapon, bool isAlternate, const centity_t *attackerEnt, BulletTraceResults *br, int lastSurfaceType, const centity_t **outHitEnt, bool allowHitSelf)
{
  unsigned __int8 *priorityMap; 
  int IgnoreHitEntityCount; 
  unsigned __int16 EntityHitId; 
  unsigned __int16 v19; 
  centity_t *Entity; 
  entityType_s eType; 
  int v45; 
  bool v46; 
  unsigned int v47; 
  bool v48; 
  int *skipEntities; 
  int *skipEntitiesa; 
  __int64 skipEntityCount; 

  _RDI = br;
  __asm { vmovaps [rsp+0D8h+var_58], xmm6 }
  _RBP = bp;
  __asm { vmovaps [rsp+0D8h+var_68], xmm7 }
  if ( !bp && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23200, ASSERT_TYPE_ASSERT, "(bp)", (const char *)&queryFormat, "bp") )
    __debugbreak();
  if ( !attackerEnt && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23201, ASSERT_TYPE_ASSERT, "(attackerEnt)", (const char *)&queryFormat, "attackerEnt") )
    __debugbreak();
  if ( !br && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23202, ASSERT_TYPE_ASSERT, "(br)", (const char *)&queryFormat, "br") )
    __debugbreak();
  if ( (unsigned int)lastSurfaceType >= 0x40 )
  {
    LODWORD(skipEntities) = lastSurfaceType;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23203, ASSERT_TYPE_ASSERT, "(unsigned)( lastSurfaceType ) < (unsigned)( 64 )", "lastSurfaceType doesn't index SURF_TYPECOUNT\n\t%i not in [0, %i)", skipEntities, 64) )
      __debugbreak();
  }
  Sys_ProfBeginNamedEvent(0xFF008008, "CG_Weapons_BulletTrace");
  PhysPerfTrack_BulletClientTraceCountAdd();
  priorityMap = BG_GetWeaponPriorityMap(weapon, isAlternate);
  IgnoreHitEntityCount = BG_GetIgnoreHitEntityCount(_RBP);
  PhysicsQuery_LegacyMPCGWeaponSimTrace((Physics_WorldId)(3 * localClientNum + 4), &br->trace, &_RBP->start, &_RBP->end, &bounds_origin, _RBP->ignoreHitEntityQueue, IgnoreHitEntityCount, 0, 41969969, 1, priorityMap, All, 1);
  EntityHitId = Trace_GetEntityHitId(&br->trace);
  if ( EntityHitId < 0x800u )
  {
    v19 = EntityHitId;
    if ( (unsigned __int16)(EntityHitId - 2046) > 1u )
    {
      Entity = CG_GetEntity(localClientNum, EntityHitId);
      goto LABEL_16;
    }
  }
  else
  {
    v19 = 2047;
  }
  Entity = NULL;
LABEL_16:
  __asm
  {
    vmovss  xmm7, dword ptr [rdi]
    vmovss  xmm0, dword ptr [rbp+74h]
    vsubss  xmm1, xmm0, dword ptr [rax]
    vmulss  xmm2, xmm1, xmm7
    vaddss  xmm6, xmm2, dword ptr [rax]
    vmovss  dword ptr [rdi+60h], xmm6
    vmovss  xmm0, dword ptr [rbp+78h]
    vsubss  xmm1, xmm0, dword ptr [rax+4]
    vmulss  xmm2, xmm1, xmm7
    vaddss  xmm5, xmm2, dword ptr [rax+4]
    vmovss  dword ptr [rdi+64h], xmm5
    vmovss  xmm0, dword ptr [rbp+7Ch]
    vsubss  xmm1, xmm0, dword ptr [rax+8]
    vmulss  xmm2, xmm1, xmm7
    vaddss  xmm4, xmm2, dword ptr [rax+8]
    vmovss  dword ptr [rdi+68h], xmm4
    vsubss  xmm0, xmm5, dword ptr [rax+4]
    vsubss  xmm2, xmm6, dword ptr [rax]
    vsubss  xmm3, xmm4, dword ptr [rax+8]
    vmulss  xmm1, xmm0, xmm0
    vmulss  xmm0, xmm2, xmm2
    vaddss  xmm2, xmm1, xmm0
    vmulss  xmm1, xmm3, xmm3
    vaddss  xmm2, xmm2, xmm1
    vsqrtss xmm0, xmm2, xmm2
    vaddss  xmm3, xmm0, dword ptr [rbp+8Ch]
    vmovss  dword ptr [rbp+8Ch], xmm3
  }
  if ( !Entity )
    goto LABEL_32;
  if ( br->trace.partGroup == 19 )
  {
    br->trace.surfaceFlags = 15204352;
  }
  else
  {
    if ( BG_IsCharacterEntity(&Entity->nextState) )
      goto LABEL_46;
    if ( Entity == (centity_t *)-400i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 1983, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
      __debugbreak();
    eType = Entity->nextState.eType;
    if ( (unsigned __int16)eType <= ET_ACTOR_CORPSE )
    {
      v45 = 2359300;
      if ( _bittest(&v45, eType) )
      {
LABEL_46:
        if ( !br->trace.surfaceFlags )
          br->trace.surfaceFlags = Entity->nextState.surfType << 19;
      }
    }
  }
  if ( !allowHitSelf && v19 == attackerEnt->nextState.number )
    v46 = 1;
  else
LABEL_32:
    v46 = 0;
  br->ignoreHitEnt = v46;
  if ( outHitEnt )
    *outHitEnt = Entity;
  v47 = (br->trace.surfaceFlags >> 19) & 0x3F;
  v48 = (br->trace.surfaceFlags & 0x100) == 0;
  br->depthSurfaceType = v47;
  if ( v48 )
  {
    if ( !v47 )
    {
      if ( !lastSurfaceType )
        goto LABEL_43;
      br->depthSurfaceType = lastSurfaceType;
      v47 = lastSurfaceType;
    }
    if ( v47 >= 0x40 )
    {
      LODWORD(skipEntityCount) = 64;
      LODWORD(skipEntitiesa) = v47;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23265, ASSERT_TYPE_SANITY, "(unsigned)( br->depthSurfaceType ) < (unsigned)( 64 )", "br->depthSurfaceType doesn't index SURF_TYPECOUNT\n\t%i not in [0, %i)", skipEntitiesa, skipEntityCount) )
        __debugbreak();
    }
  }
  else
  {
    br->depthSurfaceType = 0;
  }
LABEL_43:
  Sys_ProfEndNamedEvent();
  __asm
  {
    vmovaps xmm6, [rsp+0D8h+var_58]
    vmovaps xmm7, [rsp+0D8h+var_68]
  }
  return br->trace.hitType != TRACE_HITTYPE_BEGIN;
}

/*
==============
CG_Weapons_CalculateMovement
==============
*/
void CG_Weapons_CalculateMovement(cg_t *cgameGlob, PlayerViewValues *viewValues, const tmat43_t<vec3_t> *viewTransform, vec3_t *outGunOffset, vec3_t *outGunAngles, vec3_t *outWeapOrigin, vec4_t *outWeapOrient)
{
  const dvar_t *v20; 
  bool enabled; 
  tmat33_t<vec3_t> *p_dst; 
  const dvar_t *v27; 
  int v28; 
  const dvar_t *v29; 
  __int64 localClientNum; 
  const Weapon *ViewmodelWeapon; 
  bool v45; 
  const dvar_t *v86; 
  CgWeaponMap *Instance; 
  const Weapon *v92; 
  bool v93; 
  __int64 v97; 
  const dvar_t *v113; 
  __int64 v119; 
  cg_t *LocalClientGlobals; 
  char v121; 
  char v122; 
  const CameraDef *Def; 
  float outWorldOffseta; 
  vec3_t *outWorldOffset; 
  vec3_t *v144; 
  vec3_t out; 
  vec3_t outAngles; 
  vec3_t offset; 
  vec3_t outLocalAngles; 
  vec3_t outLocalOffset; 
  tmat33_t<vec3_t> axis; 
  tmat33_t<vec3_t> dst; 
  char v155; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-58h], xmm6
    vmovaps xmmword ptr [rax-68h], xmm7
    vmovaps xmmword ptr [rax-78h], xmm8
    vmovaps xmmword ptr [rax-88h], xmm9
    vmovaps xmmword ptr [rax-98h], xmm11
    vmovaps xmmword ptr [rax-0A8h], xmm12
    vmovaps xmmword ptr [rax-0B8h], xmm13
  }
  _R15 = outGunOffset;
  _R12 = (const tmat33_t<vec3_t> *)viewTransform;
  *(_QWORD *)outLocalOffset.v = viewValues;
  _RSI = cgameGlob;
  _RBX = outWeapOrigin;
  v20 = DVARBOOL_cg_enableViewModelMotionPrecisionFix;
  if ( !DVARBOOL_cg_enableViewModelMotionPrecisionFix && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_enableViewModelMotionPrecisionFix") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v20);
  enabled = v20->current.enabled;
  MatrixCopy33(_R12, &dst);
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vmovss  [rbp+0D0h+var_C4], xmm6
    vmovss  [rbp+0D0h+var_C0], xmm6
    vmovss  [rbp+0D0h+var_BC], xmm6
  }
  p_dst = &dst;
  if ( !enabled )
    p_dst = (tmat33_t<vec3_t> *)_R12;
  if ( enabled )
  {
    __asm
    {
      vmovss  xmm11, dword ptr [r12+24h]
      vmovss  xmm12, dword ptr [r12+28h]
      vmovss  xmm13, dword ptr [r12+2Ch]
    }
  }
  else
  {
    __asm
    {
      vxorps  xmm11, xmm11, xmm11
      vxorps  xmm12, xmm12, xmm12
      vxorps  xmm13, xmm13, xmm13
    }
  }
  MatrixTransformVector43(&viewValues->weapMoveOrigin, (const tmat43_t<vec3_t> *)p_dst, &out);
  v27 = DCONST_DVARBOOL_cg_viewmodelAnimatedJumps;
  if ( !DCONST_DVARBOOL_cg_viewmodelAnimatedJumps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmodelAnimatedJumps") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v27);
  if ( !v27->current.enabled )
  {
    v28 = _RSI->time - _RSI->landTime;
    v29 = DCONST_DVARMPBOOL_cg_viewmotion_spring_enable;
    if ( !DCONST_DVARMPBOOL_cg_viewmotion_spring_enable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmotion_spring_enable") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v29);
    if ( v29->current.enabled )
      __asm { vmovss  xmm2, dword ptr [rsi+5A498h] }
    else
      __asm { vmovss  xmm2, cs:__real@3f800000 }
    __asm
    {
      vmovss  xmm0, dword ptr [rsi+6600h]
      vmulss  xmm1, xmm0, cs:__real@3e800000
      vmulss  xmm3, xmm1, xmm2
    }
    if ( v28 < 150 )
    {
      __asm
      {
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm0, xmm0, edi
        vmulss  xmm1, xmm0, xmm3
        vmulss  xmm3, xmm1, cs:__real@3bda740e
      }
LABEL_23:
      __asm
      {
        vaddss  xmm0, xmm3, dword ptr [rsp+1D0h+out+8]
        vmovss  dword ptr [rsp+1D0h+out+8], xmm0
      }
      goto LABEL_24;
    }
    if ( v28 < 450 )
    {
      __asm
      {
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm0, xmm0, eax
        vmulss  xmm1, xmm0, xmm3
        vmulss  xmm3, xmm1, cs:__real@3b5a740e
      }
      goto LABEL_23;
    }
  }
LABEL_24:
  if ( !_RSI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13660, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  localClientNum = _RSI->localClientNum;
  if ( !CgWeaponMap::ms_instance[localClientNum] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  ViewmodelWeapon = BG_GetViewmodelWeapon(CgWeaponMap::ms_instance[localClientNum], &_RSI->predictedPlayerState);
  v45 = BG_UsingAlternate(&_RSI->predictedPlayerState);
  if ( BG_IsAimDownSight(ViewmodelWeapon, v45) )
  {
    __asm
    {
      vmovss  xmm3, dword ptr [rsi+738h]
      vucomiss xmm3, xmm6
      vmovss  xmm0, dword ptr [rsp+1D0h+out]
      vsubss  xmm1, xmm0, dword ptr [r14+24h]
      vmulss  xmm2, xmm1, xmm3
      vmovss  dword ptr [r15], xmm2
      vmovss  xmm0, dword ptr [rsp+1D0h+out+4]
      vsubss  xmm1, xmm0, dword ptr [r14+28h]
      vmulss  xmm2, xmm1, xmm3
      vmovss  dword ptr [r15+4], xmm2
      vmovss  xmm0, dword ptr [rsp+1D0h+out+8]
      vsubss  xmm1, xmm0, dword ptr [r14+2Ch]
      vmulss  xmm2, xmm1, xmm3
      vmovss  dword ptr [r15+8], xmm2
    }
  }
  else
  {
    _R15->v[2] = 0.0;
    *(_QWORD *)_R15->v = 0i64;
  }
  CG_CalculateWeaponMovement_FovCompensation(_RSI, &out);
  _RDI = DVARFLT_cg_gun_x;
  if ( !DVARFLT_cg_gun_x && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_gun_x") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RDI);
  __asm
  {
    vmovss  xmm3, dword ptr [rdi+28h]
    vmulss  xmm1, xmm3, dword ptr [r14]
    vaddss  xmm1, xmm1, dword ptr [rsp+1D0h+out]
    vmovss  dword ptr [rsp+1D0h+out], xmm1
    vmulss  xmm2, xmm3, dword ptr [r14+4]
    vaddss  xmm1, xmm2, dword ptr [rsp+1D0h+out+4]
    vmovss  dword ptr [rsp+1D0h+out+4], xmm1
    vmulss  xmm2, xmm3, dword ptr [r14+8]
    vaddss  xmm1, xmm2, dword ptr [rsp+1D0h+out+8]
    vmovss  dword ptr [rsp+1D0h+out+8], xmm1
  }
  _RDI = DVARFLT_cg_gun_y;
  if ( !DVARFLT_cg_gun_y && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_gun_y") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RDI);
  __asm
  {
    vmovss  xmm3, dword ptr [rdi+28h]
    vmulss  xmm1, xmm3, dword ptr [r14+0Ch]
    vaddss  xmm1, xmm1, dword ptr [rsp+1D0h+out]
    vmovss  dword ptr [rsp+1D0h+out], xmm1
    vmulss  xmm2, xmm3, dword ptr [r14+10h]
    vaddss  xmm1, xmm2, dword ptr [rsp+1D0h+out+4]
    vmovss  dword ptr [rsp+1D0h+out+4], xmm1
    vmulss  xmm2, xmm3, dword ptr [r14+14h]
    vaddss  xmm1, xmm2, dword ptr [rsp+1D0h+out+8]
    vmovss  dword ptr [rsp+1D0h+out+8], xmm1
  }
  _RDI = DVARFLT_cg_gun_z;
  if ( !DVARFLT_cg_gun_z && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_gun_z") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RDI);
  __asm
  {
    vmovss  xmm3, dword ptr [rdi+28h]
    vmulss  xmm1, xmm3, dword ptr [r14+18h]
    vaddss  xmm1, xmm1, dword ptr [rsp+1D0h+out]
    vmovss  dword ptr [rsp+1D0h+out], xmm1
    vmulss  xmm2, xmm3, dword ptr [r14+1Ch]
    vaddss  xmm1, xmm2, dword ptr [rsp+1D0h+out+4]
    vmovss  dword ptr [rsp+1D0h+out+4], xmm1
    vmulss  xmm2, xmm3, dword ptr [r14+20h]
    vaddss  xmm1, xmm2, dword ptr [rsp+1D0h+out+8]
    vmovss  dword ptr [rsp+1D0h+out+8], xmm1
  }
  _R15 = *(const PlayerViewValues **)outLocalOffset.v;
  __asm
  {
    vmovsd  xmm0, qword ptr [r15+18h]
    vmovsd  qword ptr [rbp+0D0h+outAngles], xmm0
  }
  outAngles.v[2] = *(float *)(*(_QWORD *)outLocalOffset.v + 32i64);
  _RDI = DVARFLT_cg_gun_pitch;
  if ( !DVARFLT_cg_gun_pitch && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_gun_pitch") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RDI);
  __asm { vmovss  xmm8, dword ptr [rdi+28h] }
  _RDI = DVARFLT_cg_gun_yaw;
  if ( !DVARFLT_cg_gun_yaw && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_gun_yaw") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RDI);
  __asm { vmovss  xmm7, dword ptr [rdi+28h] }
  v86 = DVARFLT_cg_gun_roll;
  if ( !DVARFLT_cg_gun_roll && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_gun_roll") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v86);
  __asm
  {
    vaddss  xmm8, xmm8, dword ptr [rbp+0D0h+outAngles]
    vmovss  dword ptr [rbp+0D0h+outAngles], xmm8
    vaddss  xmm7, xmm7, dword ptr [rbp+0D0h+outAngles+4]
    vmovss  dword ptr [rbp+0D0h+outAngles+4], xmm7
    vmovss  xmm0, dword ptr [rbp+0D0h+outAngles+8]
    vaddss  xmm9, xmm0, dword ptr [rdi+28h]
    vmovss  dword ptr [rbp+0D0h+outAngles+8], xmm9
  }
  if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_FREEFALL_IDLE|WEAPON_LADDER_AIM) )
  {
    Instance = CgWeaponMap::GetInstance((const LocalClientNum_t)_RSI->localClientNum);
    v92 = BG_GetViewmodelWeapon(Instance, &_RSI->predictedPlayerState);
    v93 = BG_UsingAlternate(&_RSI->predictedPlayerState);
    if ( !BG_IsAimDownSight(v92, v93) )
    {
      if ( !_RSI->kickAngles.initialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\anticheat\\security_obfuscation_integer.h", 221, ASSERT_TYPE_ASSERT, "(initialized)", (const char *)&queryFormat, "initialized") )
        __debugbreak();
      __asm
      {
        vsubss  xmm0, xmm8, dword ptr [rbp+0D0h+offset]
        vmovss  dword ptr [rbp+0D0h+outAngles], xmm0
        vsubss  xmm1, xmm7, dword ptr [rbp+0D0h+offset+4]
        vmovss  dword ptr [rbp+0D0h+outAngles+4], xmm1
        vsubss  xmm0, xmm9, dword ptr [rbp+0D0h+offset+8]
        vmovss  dword ptr [rbp+0D0h+outAngles+8], xmm0
      }
      memset(&offset, 0, sizeof(offset));
      _R15 = *(const PlayerViewValues **)outLocalOffset.v;
    }
  }
  CG_CalculateWeaponMovement_ProceduralAdsMovement(_RSI, (const tmat43_t<vec3_t> *)p_dst, &out, &outAngles);
  v97 = _RSI->localClientNum;
  if ( !CgWeaponMap::ms_instance[v97] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  __asm
  {
    vmovsd  xmm0, qword ptr [r15+0CCh]
    vmovsd  qword ptr [rbp+0D0h+outLocalAngles], xmm0
  }
  outLocalAngles.v[2] = _R15->weapMoveAnglesCategorized[14].v[2];
  *(double *)&_XMM0 = BG_GetWeaponOrOffhandAdsFrac(CgWeaponMap::ms_instance[v97], &_RSI->predictedPlayerState);
  __asm { vmovaps xmm1, xmm0; adsFraction }
  CG_ViewMotion_GetSpringOffset(&_RSI->predictedPlayerState, *(const float *)&_XMM1, &_RSI->viewmodelSpring, &_RSI->predictedPlayerState.viewangles, &outLocalOffset, &offset);
  __asm
  {
    vmovss  xmm0, dword ptr [rsp+1D0h+out]
    vaddss  xmm1, xmm0, dword ptr [rbp+0D0h+offset]
    vmovss  dword ptr [rsp+1D0h+out], xmm1
    vmovss  xmm2, dword ptr [rsp+1D0h+out+4]
    vaddss  xmm0, xmm2, dword ptr [rbp+0D0h+offset+4]
    vmovss  dword ptr [rsp+1D0h+out+4], xmm0
    vmovss  xmm1, dword ptr [rsp+1D0h+out+8]
    vaddss  xmm2, xmm1, dword ptr [rbp+0D0h+offset+8]
    vmovss  dword ptr [rsp+1D0h+out+8], xmm2
  }
  CG_ViewMotion_LocalOffsetToLocalAngles(&_RSI->predictedPlayerState, &_RSI->viewmodelSpring, &outLocalOffset, &outLocalAngles);
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+0D0h+outAngles]
    vaddss  xmm1, xmm0, dword ptr [rbp+0D0h+outLocalAngles]
    vmovss  dword ptr [rbp+0D0h+outAngles], xmm1
    vmovss  xmm2, dword ptr [rbp+0D0h+outAngles+4]
    vaddss  xmm0, xmm2, dword ptr [rbp+0D0h+outLocalAngles+4]
    vmovss  dword ptr [rbp+0D0h+outAngles+4], xmm0
    vmovss  xmm1, dword ptr [rbp+0D0h+outAngles+8]
    vaddss  xmm2, xmm1, dword ptr [rbp+0D0h+outLocalAngles+8]
    vmovss  dword ptr [rbp+0D0h+outAngles+8], xmm2
    vmovss  xmm0, cs:dword_147FA82D0
    vmovss  dword ptr [rsp+1D0h+outWorldOffset], xmm0
  }
  CG_CalculateWeaponMovement_CalcAngles(_RSI, _R15, &out, &outAngles, &outLocalAngles, outWorldOffseta, outGunAngles, outWeapOrigin, outWeapOrient);
  v113 = DVARBOOL_cg_enableAdsAlignOffset;
  if ( !DVARBOOL_cg_enableAdsAlignOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_enableAdsAlignOffset") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v113);
  if ( v113->current.enabled )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rsi+18270h]
      vcomiss xmm0, xmm6
    }
    if ( v113->current.enabled )
      __asm { vcomiss xmm0, cs:__real@3f800000 }
    else
      __asm { vcomiss xmm0, cs:__real@3f800000 }
    CG_CalculateWeaponMovement_GetAdsOffset(_RSI, outWeapOrient, 1, &offset);
    __asm
    {
      vmovss  xmm5, dword ptr [rbp+0D0h+offset+8]
      vmovss  xmm4, dword ptr [rbp+0D0h+offset+4]
      vmovss  xmm7, dword ptr [rbp+0D0h+offset]
      vaddss  xmm0, xmm7, dword ptr [rbx]
      vmovss  dword ptr [rbx], xmm0
      vaddss  xmm1, xmm4, dword ptr [rbx+4]
      vmovss  dword ptr [rbx+4], xmm1
      vaddss  xmm0, xmm5, dword ptr [rbx+8]
      vmovss  dword ptr [rbx+8], xmm0
    }
  }
  v119 = _RSI->localClientNum;
  if ( (unsigned int)v119 >= 2 )
  {
    LODWORD(v144) = 2;
    LODWORD(outWorldOffset) = _RSI->localClientNum;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13985, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", outWorldOffset, v144) )
      __debugbreak();
  }
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v119);
  if ( !CgWeaponMap::ms_instance[v119] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  *(double *)&_XMM0 = BG_GetWeaponOrOffhandAdsFrac(CgWeaponMap::ms_instance[v119], &LocalClientGlobals->predictedPlayerState);
  __asm { vcomiss xmm0, xmm6 }
  if ( !(v121 | v122) )
  {
    Def = CG_Camera_Active_TryGetDef((LocalClientNum_t)v119);
    if ( !Def || Def->profile || !Def->firstPerson.disableFOVWeaponOffset )
    {
      *(float *)&_XMM0 = CG_CalculateWeaponMovement_GetFOVXOffset(LocalClientGlobals, *(double *)&_XMM1);
      __asm { vmovaps xmm6, xmm0 }
      QuatToAxis(outWeapOrient, &axis);
      __asm
      {
        vmulss  xmm2, xmm6, dword ptr [rbp+0D0h+axis]
        vaddss  xmm3, xmm2, dword ptr [rbx]
        vmovss  dword ptr [rbx], xmm3
        vmulss  xmm2, xmm6, dword ptr [rbp+0D0h+axis+4]
        vaddss  xmm3, xmm2, dword ptr [rbx+4]
        vmovss  dword ptr [rbx+4], xmm3
        vmulss  xmm0, xmm6, dword ptr [rbp+0D0h+axis+8]
        vaddss  xmm2, xmm0, dword ptr [rbx+8]
        vmovss  dword ptr [rbx+8], xmm2
      }
    }
  }
  _RSI->viewModelPlacementOffset = *outWeapOrigin;
  __asm
  {
    vaddss  xmm0, xmm11, dword ptr [rbx]
    vmovss  dword ptr [rbx], xmm0
    vaddss  xmm1, xmm12, dword ptr [rbx+4]
    vmovss  dword ptr [rbx+4], xmm1
    vaddss  xmm0, xmm13, dword ptr [rbx+8]
    vmovss  dword ptr [rbx+8], xmm0
  }
  _R11 = &v155;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-18h]
    vmovaps xmm7, xmmword ptr [r11-28h]
    vmovaps xmm8, xmmword ptr [r11-38h]
    vmovaps xmm9, xmmword ptr [r11-48h]
    vmovaps xmm11, xmmword ptr [r11-58h]
    vmovaps xmm12, xmmword ptr [r11-68h]
    vmovaps xmm13, xmmword ptr [r11-78h]
  }
}

/*
==============
CG_Weapons_CheckForGestureForcedBlendOuts
==============
*/
void CG_Weapons_CheckForGestureForcedBlendOuts(const LocalClientNum_t localClientNum, const playerState_s *ps, const PlayerHandIndex handIndex, const Weapon *r_weapon)
{
  float v8; 
  GestureWeaponAnimBlendOutInfo *outBlendOutInfo; 

  if ( handIndex == WEAPON_HAND_DEFAULT )
  {
    outBlendOutInfo = NULL;
    if ( CG_Gesture_ShouldBlendOutOfAnim(localClientNum, ps, WEAPON_HAND_DEFAULT, (const GestureWeaponAnimBlendOutInfo **)&outBlendOutInfo) )
    {
      _RCX = outBlendOutInfo;
      if ( !outBlendOutInfo )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8681, ASSERT_TYPE_ASSERT, "(blendOutInfo)", (const char *)&queryFormat, "blendOutInfo") )
          __debugbreak();
        _RCX = outBlendOutInfo;
      }
      __asm
      {
        vmovss  xmm0, dword ptr [rcx+10h]
        vmovss  [rsp+68h+var_30], xmm0
      }
      CG_Weapons_StartWeaponAnim(localClientNum, r_weapon, WEAPON_HAND_DEFAULT, (const WeaponAnimNumber)_RCX->animToBlendIn, (const weapAnimFiles_t)_RCX->animIndexToBlendIn, (const WeaponAnimNumber)_RCX->animToBlendOut, (const weapAnimFiles_t)_RCX->animIndexToBlendOut, v8, 0);
    }
  }
}

/*
==============
CG_Weapons_ClearAutoComplete
==============
*/
void CG_Weapons_ClearAutoComplete(void)
{
  Cmd_ClearAutoComplete("give");
  Cmd_ClearAutoComplete("take");
}

/*
==============
CG_Weapons_CreatePhysicsForWeapon
==============
*/
void CG_Weapons_CreatePhysicsForWeapon(LocalClientNum_t localClientNum, const DObj *obj, const Weapon *weapon)
{
  unsigned __int16 v5; 
  __int64 v6; 
  CG_PhysicsObject *v7; 
  __int32 v8; 
  __int32 v9; 
  __int64 v10; 
  unsigned int v11; 
  const XModel *InstanceDetailModel; 
  int v13; 
  const XModel *model; 
  CG_PhysicsObject *v16; 
  unsigned __int16 v20; 
  vec3_t outOrigin; 
  __int64 v22; 
  vec3_t angles; 
  vec4_t quat; 

  v22 = -2i64;
  if ( weapon->weaponIdx )
  {
    if ( BG_IsRiotShield(weapon, 0) )
    {
      v5 = 0;
      if ( obj->numModels )
      {
        while ( 1 )
        {
          v6 = v5;
          if ( BG_Weapons_IsRiotShieldModel(obj->models[v5]) )
            break;
          if ( ++v5 >= obj->numModels )
            return;
        }
        v7 = CG_PhysicsObject_Get((unsigned int)obj->entnum - 1, localClientNum);
        v8 = 3 * localClientNum + 4;
        v9 = 3 * localClientNum + 2;
        v10 = 3 * localClientNum;
        v11 = v7->physicsInstances[v10 + 4];
        if ( v11 != -1 )
        {
          InstanceDetailModel = Physics_GetInstanceDetailModel((Physics_WorldId)v8, v11);
          if ( InstanceDetailModel )
          {
            if ( BG_Weapons_IsRiotShieldModel(InstanceDetailModel) )
            {
              CG_EntityWorkers_AcquireWriteLock_Physics(BASE);
              CG_PhysicsObject_DestroyDetailBoneMapping((Physics_WorldId)v8, v7);
              Physics_DestroyInstance((Physics_WorldId)v8, v7->physicsInstances[v10 + 4], 0);
              v7->physicsInstances[v10 + 4] = -1;
              CG_PhysicsObject_DestroyDetailBoneMapping((Physics_WorldId)v9, v7);
              Physics_DestroyInstance((Physics_WorldId)v9, v7->physicsInstances[v10 + 2], 0);
              v7->physicsInstances[v10 + 2] = -1;
              CG_EntityWorkers_ReleaseWriteLock_Physics(BASE);
            }
          }
        }
        v13 = obj->entnum - 1;
        model = obj->models[v6];
        CG_EntityWorkers_AcquireWriteLock_Physics(BASE);
        _RDI = CG_GetEntity(localClientNum, v13);
        v16 = CG_PhysicsObject_Get(v13, localClientNum);
        CG_GetPoseOrigin(&_RDI->pose, &outOrigin);
        __asm
        {
          vmovss  xmm0, dword ptr [rdi+48h]
          vmovss  dword ptr [rsp+0B8h+angles], xmm0
          vmovss  xmm1, dword ptr [rdi+4Ch]
          vmovss  dword ptr [rsp+0B8h+angles+4], xmm1
          vmovss  xmm0, dword ptr [rdi+50h]
          vmovss  dword ptr [rsp+0B8h+angles+8], xmm0
        }
        AnglesToQuat(&angles, &quat);
        LOBYTE(_RDI) = !GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&_RDI->nextState.lerp.eFlags, ACTIVE, 1u);
        v20 = truncate_cast<unsigned short,int>(v13);
        LODWORD(_RDI) = Physics_MakeRef(Physics_RefSystem_CEntities, Physics_RelationshipSystem_None, (unsigned __int8)_RDI, v20);
        CG_Weapons_CreateRiotShieldModel((const Physics_WorldId)v9, v16, (const int)_RDI, obj, model, &outOrigin, &quat);
        CG_Weapons_CreateRiotShieldModel((const Physics_WorldId)v8, v16, (const int)_RDI, obj, model, &outOrigin, &quat);
        CG_EntityWorkers_ReleaseWriteLock_Physics(BASE);
        memset(&outOrigin, 0, sizeof(outOrigin));
      }
    }
  }
}

/*
==============
CG_Weapons_CreateRiotShieldModel
==============
*/
void CG_Weapons_CreateRiotShieldModel(const Physics_WorldId worldId, CG_PhysicsObject *physicsObj, const int physicsRef, const DObj *obj, const XModel *model, const vec3_t *position, const vec4_t *orientation)
{
  __int64 v7; 

  v7 = worldId;
  if ( physicsObj->physicsInstances[worldId] != -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25934, ASSERT_TYPE_ASSERT, "(physicsObj->physicsInstances[worldId] == 0xFFFFFFFF)", (const char *)&queryFormat, "physicsObj->physicsInstances[worldId] == PHYSICSINSTANCEID_INVALID") )
    __debugbreak();
  physicsObj->physicsInstances[v7] = Physics_InstantiateDetailModel((Physics_WorldId)v7, model, physicsRef, position, orientation, 0, 1, 0, 0);
  CG_PhysicsObject_CreateDetailBoneMapping((Physics_WorldId)v7, physicsObj, obj, model->physicsAsset);
}

/*
==============
CG_Weapons_CreateRiotShieldPhysics
==============
*/
void CG_Weapons_CreateRiotShieldPhysics(LocalClientNum_t localClientNum, const DObj *obj, const XModel *model, int entityNum)
{
  CG_PhysicsObject *v9; 
  unsigned __int16 v13; 
  int Ref; 
  vec3_t outOrigin; 
  __int64 v16; 
  vec3_t angles; 
  vec4_t quat; 

  v16 = -2i64;
  CG_EntityWorkers_AcquireWriteLock_Physics(BASE);
  _RDI = CG_GetEntity(localClientNum, entityNum);
  v9 = CG_PhysicsObject_Get(entityNum, localClientNum);
  CG_GetPoseOrigin(&_RDI->pose, &outOrigin);
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+48h]
    vmovss  dword ptr [rsp+0B8h+angles], xmm0
    vmovss  xmm1, dword ptr [rdi+4Ch]
    vmovss  dword ptr [rsp+0B8h+angles+4], xmm1
    vmovss  xmm0, dword ptr [rdi+50h]
    vmovss  dword ptr [rsp+0B8h+angles+8], xmm0
  }
  AnglesToQuat(&angles, &quat);
  LOBYTE(_RDI) = !GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&_RDI->nextState.lerp.eFlags, ACTIVE, 1u);
  v13 = truncate_cast<unsigned short,int>(entityNum);
  Ref = Physics_MakeRef(Physics_RefSystem_CEntities, Physics_RelationshipSystem_None, (unsigned __int8)_RDI, v13);
  CG_Weapons_CreateRiotShieldModel((const Physics_WorldId)(3 * localClientNum + 2), v9, Ref, obj, model, &outOrigin, &quat);
  CG_Weapons_CreateRiotShieldModel((const Physics_WorldId)(3 * localClientNum + 4), v9, Ref, obj, model, &outOrigin, &quat);
  CG_EntityWorkers_ReleaseWriteLock_Physics(BASE);
  memset(&outOrigin, 0, sizeof(outOrigin));
}

/*
==============
CG_Weapons_CreateWeaponPhysics
==============
*/
void CG_Weapons_CreateWeaponPhysics(LocalClientNum_t localClientNum, int clientNum)
{
  CgStatic *LocalClientStatics; 
  characterInfo_t *CharacterInfo; 
  const DObj *ClientDObj; 
  const DObj *v7; 

  LocalClientStatics = CgStatic::GetLocalClientStatics(localClientNum);
  if ( LocalClientStatics->HasCharacterInfo(LocalClientStatics, clientNum) )
  {
    CharacterInfo = CgStatic::GetCharacterInfo(LocalClientStatics, clientNum);
    if ( CharacterInfo->createWeaponPhysics )
    {
      ClientDObj = Com_GetClientDObj(clientNum, localClientNum);
      v7 = ClientDObj;
      if ( ClientDObj )
      {
        CG_Weapons_CreatePhysicsForWeapon(localClientNum, ClientDObj, &CharacterInfo->dobjHeldWeapon);
        CG_Weapons_CreatePhysicsForWeapon(localClientNum, v7, &CharacterInfo->dobjStowedWeapon);
      }
      CharacterInfo->createWeaponPhysics = 0;
    }
  }
}

/*
==============
CG_Weapons_CurrentWeaponCanAltToggle
==============
*/
bool CG_Weapons_CurrentWeaponCanAltToggle(LocalClientNum_t localClientNum)
{
  __int64 v1; 
  cg_t *LocalClientGlobals; 
  bool v3; 
  const BgWeaponMap **v4; 
  const Weapon *CurrentWeaponForPlayer; 

  v1 = localClientNum;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v3 = CgWeaponMap::ms_instance[v1] == NULL;
  v4 = (const BgWeaponMap **)&CgWeaponMap::ms_instance[v1];
  if ( v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(*v4, &LocalClientGlobals->predictedPlayerState);
  return !BG_IsThrowingAxe(CurrentWeaponForPlayer) && BG_HasUnderbarrelAmmo(CurrentWeaponForPlayer) && !BG_UseLeftTriggerAltFireMode(CurrentWeaponForPlayer);
}

/*
==============
CG_Weapons_CurrentWeaponCanHoldBreath
==============
*/
bool CG_Weapons_CurrentWeaponCanHoldBreath(LocalClientNum_t localClientNum)
{
  __int64 v1; 
  cg_t *LocalClientGlobals; 
  bool v3; 
  const BgWeaponMap **v4; 

  v1 = localClientNum;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v3 = CgWeaponMap::ms_instance[v1] == NULL;
  v4 = (const BgWeaponMap **)&CgWeaponMap::ms_instance[v1];
  if ( v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  return BG_HasHoldBreathAbility(*v4, &LocalClientGlobals->predictedPlayerState) != 0;
}

/*
==============
CG_Weapons_CurrentWeaponCanHybridToggle
==============
*/
bool CG_Weapons_CurrentWeaponCanHybridToggle(LocalClientNum_t localClientNum)
{
  __int64 v1; 
  cg_t *LocalClientGlobals; 
  bool v3; 
  const BgWeaponMap **v4; 
  const playerState_s *p_predictedPlayerState; 
  const Weapon *CurrentWeaponForPlayer; 
  bool v7; 

  v1 = localClientNum;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v3 = CgWeaponMap::ms_instance[v1] == NULL;
  v4 = (const BgWeaponMap **)&CgWeaponMap::ms_instance[v1];
  p_predictedPlayerState = &LocalClientGlobals->predictedPlayerState;
  if ( v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(*v4, p_predictedPlayerState);
  v7 = BG_UsingAlternate(p_predictedPlayerState);
  return BG_CanHybridToggle(p_predictedPlayerState, CurrentWeaponForPlayer, v7);
}

/*
==============
CG_Weapons_DestroyRiotShieldPhysics
==============
*/
void CG_Weapons_DestroyRiotShieldPhysics(LocalClientNum_t localClientNum, int entityNum)
{
  CG_PhysicsObject *v3; 
  __int32 v4; 
  CG_PhysicsObject *v5; 
  __int64 v6; 
  __int32 v7; 
  Physics_WorldId v8; 
  unsigned int v9; 
  const XModel *InstanceDetailModel; 

  v3 = CG_PhysicsObject_Get(entityNum, localClientNum);
  v4 = 3 * localClientNum;
  v5 = v3;
  v6 = 3 * localClientNum;
  v7 = 3 * localClientNum + 4;
  v8 = v4 + 2;
  v9 = v3->physicsInstances[v4 + 4];
  if ( v9 != -1 )
  {
    InstanceDetailModel = Physics_GetInstanceDetailModel((Physics_WorldId)v7, v9);
    if ( InstanceDetailModel )
    {
      if ( BG_Weapons_IsRiotShieldModel(InstanceDetailModel) )
      {
        CG_EntityWorkers_AcquireWriteLock_Physics(BASE);
        CG_PhysicsObject_DestroyDetailBoneMapping((Physics_WorldId)v7, v5);
        Physics_DestroyInstance((Physics_WorldId)v7, v5->physicsInstances[v6 + 4], 0);
        v5->physicsInstances[v6 + 4] = -1;
        CG_PhysicsObject_DestroyDetailBoneMapping(v8, v5);
        Physics_DestroyInstance(v8, v5->physicsInstances[v6 + 2], 0);
        v5->physicsInstances[v6 + 2] = -1;
        CG_EntityWorkers_ReleaseWriteLock_Physics(BASE);
      }
    }
  }
}

/*
==============
CG_Weapons_DevWeaponReport
==============
*/
void CG_Weapons_DevWeaponReport(void)
{
  unsigned int numLootVariants; 
  unsigned int numAltReticles; 
  unsigned int numReticles; 
  unsigned int v3; 
  cg_t *LocalClientGlobals; 
  Material **v5; 
  int *p_crosshairClientNum; 
  int *v7; 
  unsigned int v8; 
  const char **v9; 
  __int64 v10; 
  const WeaponCompleteDef *PointerToWeaponCompleteDefConst; 
  AttachmentList *attachments; 
  __int64 v13; 
  __int64 v14; 
  const char **v15; 
  unsigned int attachmentCount; 
  unsigned int v17; 
  unsigned int numModelVariations; 
  __int64 v19; 
  __int64 v20; 
  WeaponAttachment *v21; 
  unsigned int v22; 
  unsigned int CamoCount; 
  const Camo *Camo; 
  const char *v25; 
  unsigned int v26; 
  unsigned int v27; 
  unsigned int v28; 
  unsigned int v29; 
  unsigned int v30; 
  __int64 v31; 
  unsigned int v32; 
  unsigned int v33; 
  unsigned int v34; 
  unsigned int v35; 
  unsigned int v36; 
  const char **v37; 
  __int64 *v38; 
  __int64 v39; 
  unsigned int v40; 
  __int64 v41; 
  int *v42; 
  __int64 v43; 
  unsigned int v44; 
  char *fmt; 
  unsigned int v46; 
  unsigned int v47; 
  unsigned int NumWeapons; 
  unsigned int v49; 
  const char **v50; 
  __int64 v51; 
  __int64 v52[8]; 
  int v53[32]; 

  memset(v52, 0, 56);
  memset_0(v53, 0, 0x74ui64);
  numLootVariants = 0;
  numAltReticles = 0;
  numReticles = 0;
  Com_Printf(16, "(-- begin weapon report --)\n");
  if ( BG_WeaponSetup_Initialized() )
  {
    NumWeapons = BG_GetNumWeapons();
    v3 = NumWeapons;
    LocalClientGlobals = CG_GetLocalClientGlobals(LOCAL_CLIENT_0);
    v5 = &LocalClientGlobals->serverStickerMaterialCache[1];
    p_crosshairClientNum = &LocalClientGlobals->crosshairClientNum;
    v7 = (int *)v5;
    if ( v5 != (Material **)p_crosshairClientNum )
    {
      do
      {
        if ( !*(_QWORD *)v7 )
          break;
        v7 += 2;
      }
      while ( v7 != p_crosshairClientNum );
    }
    v49 = truncate_cast<unsigned int,__int64>(((char *)v7 - (char *)v5) >> 3);
    Com_Printf(16, "Weapons:\n");
    v8 = 0;
    v9 = ATT_SLOT_NAMES;
    v46 = 0;
    v10 = 14i64;
    if ( NumWeapons )
    {
      do
      {
        PointerToWeaponCompleteDefConst = BG_GetPointerToWeaponCompleteDefConst(v8);
        if ( !PointerToWeaponCompleteDefConst && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 26157, ASSERT_TYPE_ASSERT, "(weapCompleteDef)", (const char *)&queryFormat, "weapCompleteDef") )
          __debugbreak();
        Com_Printf(16, "* '%s'\n", PointerToWeaponCompleteDefConst->szInternalName);
        if ( PointerToWeaponCompleteDefConst->numLootVariants > numLootVariants )
          numLootVariants = PointerToWeaponCompleteDefConst->numLootVariants;
        v47 = numLootVariants;
        Com_Printf(16, "  %u loot variants\n");
        attachments = PointerToWeaponCompleteDefConst->attachments;
        v50 = ATT_SLOT_NAMES;
        v13 = 14i64;
        v14 = 0i64;
        v51 = 14i64;
        v15 = ATT_SLOT_NAMES;
        do
        {
          Com_Printf(16, "  '%s'\n", *v15);
          attachmentCount = attachments->attachmentCount;
          v17 = *(_DWORD *)((char *)v52 + v14 * 4);
          if ( attachments->attachmentCount > v17 )
            v17 = attachments->attachmentCount;
          *(_DWORD *)((char *)v52 + v14 * 4) = v17;
          if ( attachmentCount )
          {
            numModelVariations = v53[v14];
            v19 = 0i64;
            v20 = attachmentCount;
            do
            {
              v21 = attachments->attachments[v19];
              Com_Printf(16, "    '%s'\n", v21->szInternalName);
              if ( v21->numModelVariations > numModelVariations )
                numModelVariations = v21->numModelVariations;
              Com_Printf(16, "      %u variants\n");
              if ( v21->numReticles > numReticles )
                numReticles = v21->numReticles;
              Com_Printf(16, "      %u alt reticles\n");
              if ( v21->numAltReticles > numAltReticles )
                numAltReticles = v21->numAltReticles;
              Com_Printf(16, "      %u alt reticles\n");
              ++v19;
              --v20;
            }
            while ( v20 );
            v15 = v50;
            v13 = v51;
            v53[v14] = numModelVariations;
          }
          ++v15;
          ++attachments;
          ++v14;
          v50 = v15;
          v51 = --v13;
        }
        while ( v13 );
        v3 = NumWeapons;
        numLootVariants = v47;
        v8 = v46 + 1;
        v46 = v8;
      }
      while ( v8 < NumWeapons );
      v9 = ATT_SLOT_NAMES;
      v10 = 14i64;
    }
    Com_Printf(16, "\n");
    Com_Printf(16, "Camos:\n");
    v22 = 0;
    CamoCount = BG_Camo_GetCamoCount();
    if ( CamoCount )
    {
      do
      {
        Camo = BG_Camo_GetCamo(v22);
        v25 = SL_ConvertToString(Camo->internalName);
        Com_Printf(16, "  '%s'\n", v25);
        ++v22;
      }
      while ( v22 < CamoCount );
    }
    Com_Printf(16, "\n");
    if ( v3 )
      v26 = 32 - __lzcnt(v3 - 1);
    else
      v26 = 0;
    Com_Printf(16, "# Weapons: %u (bits needed: %u)\n", NumWeapons, v26);
    if ( CamoCount )
      v27 = 32 - __lzcnt(CamoCount - 1);
    else
      v27 = 0;
    Com_Printf(16, "# Camos: %u (bits needed: %u)\n", CamoCount, v27);
    v28 = v27 + v26;
    if ( v49 )
      v29 = 32 - __lzcnt(v49 - 1);
    else
      v29 = 0;
    Com_Printf(16, "# Stickers: %u (bits needed: %u x 4)\n", v49, v29);
    v30 = v28 + 4 * v29;
    if ( numLootVariants )
      v31 = 32 - __lzcnt(numLootVariants - 1);
    else
      v31 = 0i64;
    Com_Printf(16, "Max Loot Variants: %u (bits needed: %u)\n", numLootVariants, v31);
    v32 = numLootVariants + v30;
    if ( numReticles )
      v33 = 32 - __lzcnt(numReticles - 1);
    else
      v33 = 0;
    Com_Printf(16, "Max Reticles: %u (bits needed: %u)\n", numReticles, v33);
    v34 = v33 + v32;
    if ( numAltReticles )
      v35 = 32 - __lzcnt(numAltReticles - 1);
    else
      v35 = 0;
    Com_Printf(16, "Max Alt Reticles: %u (bits needed: %u)\n", numAltReticles, v35);
    v36 = v35 + v34;
    Com_Printf(16, "Max Attachments:\n");
    v37 = ATT_SLOT_NAMES;
    v38 = v52;
    do
    {
      v39 = *(unsigned int *)v38;
      if ( (_DWORD)v39 )
        v40 = 32 - __lzcnt(v39 - 1);
      else
        v40 = 0;
      LODWORD(fmt) = v40;
      v36 += v40;
      Com_Printf(16, "  %s: %u (bits needed: %u)\n", *v37, v39, fmt);
      v38 = (__int64 *)((char *)v38 + 4);
      ++v37;
      --v10;
    }
    while ( v10 );
    Com_Printf(16, "Max Variations:\n");
    v41 = 29i64;
    v42 = v53;
    do
    {
      v43 = (unsigned int)*v42;
      if ( (_DWORD)v43 )
        v44 = 32 - __lzcnt(v43 - 1);
      else
        v44 = 0;
      LODWORD(fmt) = v44;
      v36 += v44;
      Com_Printf(16, "  %s: %u (bits needed: %u)\n", *v9, v43, fmt);
      ++v42;
      ++v9;
      --v41;
    }
    while ( v41 );
    Com_Printf(16, "\n");
    Com_Printf(16, "Total bits needed for Weapon representation: %u\n", v36);
  }
  else
  {
    Com_PrintError(16, "ERROR: BG_WeaponSetup not initialized.\n");
  }
  Com_Printf(16, "(-- end weapon report --)\n");
}

/*
==============
CG_Weapons_EntityHasShield
==============
*/
bool CG_Weapons_EntityHasShield(const LocalClientNum_t localClientNum, const centity_t *const cent)
{
  CgStatic *LocalClientStatics; 
  const characterInfo_t *CharacterInfo; 
  const SuitDef *SuitDef; 
  DObj *ClientDObj; 
  unsigned int characterCollBoundsType; 
  __int64 v10; 

  if ( !cent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 26009, ASSERT_TYPE_ASSERT, "(cent != nullptr)", (const char *)&queryFormat, "cent != nullptr") )
    __debugbreak();
  if ( (cent->flags & 1) == 0 )
    return 0;
  if ( BG_IsPlayerOrAgentEntity(&cent->nextState) )
  {
    LocalClientStatics = CgStatic::GetLocalClientStatics(localClientNum);
    CharacterInfo = CgStatic::GetCharacterInfo(LocalClientStatics, cent->nextState.clientNum);
    if ( CharacterInfo->offhandShieldDeployed )
      return 1;
    SuitDef = BG_GetSuitDef(CharacterInfo->suitIndex);
    if ( SuitDef )
    {
      if ( SuitDef->suitAnimType == ANIM_SUIT_C8 )
        return 1;
    }
  }
  if ( cent == (const centity_t *const)-400i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 1928, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
    __debugbreak();
  if ( ((cent->nextState.eType - 19) & 0xFFFD) != 0 )
    return 0;
  ClientDObj = Com_GetClientDObj(cent->nextState.number, localClientNum);
  if ( !ClientDObj )
    return 0;
  characterCollBoundsType = (*ClientDObj->models)->characterCollBoundsType;
  if ( characterCollBoundsType >= 0xA )
  {
    LODWORD(v10) = (*ClientDObj->models)->characterCollBoundsType;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 26038, ASSERT_TYPE_ASSERT, "(unsigned)( collBoundsType ) < (unsigned)( XModelCharCollBoundsType::CharCollBoundsType_Num )", "collBoundsType doesn't index XModelCharCollBoundsType::CharCollBoundsType_Num\n\t%i not in [0, %i)", v10, 10) )
      __debugbreak();
  }
  return characterCollBoundsType == 3;
}

/*
==============
CG_Weapons_FastADSTransitionOverride
==============
*/
void CG_Weapons_FastADSTransitionOverride(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex handIndex, const Weapon *weapon, const bool isAlternate, const bool isAiming, const bool isInterruptible, int *outWeapAnim, int *outWeapAnimToggle)
{
  __int64 v11; 
  cg_t *LocalClientGlobals; 
  __int64 v16; 
  CgWeaponMap *v17; 
  char v19; 
  char v20; 
  bool v21; 
  __int64 v22; 
  char v23; 
  __int64 v24; 
  int weaponState; 
  bool v26; 
  bool v27; 
  bool v28; 
  bool v29; 

  v11 = handIndex;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8382, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !outWeapAnim && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8383, ASSERT_TYPE_ASSERT, "(outWeapAnim)", (const char *)&queryFormat, "outWeapAnim") )
    __debugbreak();
  if ( !outWeapAnimToggle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8384, ASSERT_TYPE_ASSERT, "(outWeapAnimToggle)", (const char *)&queryFormat, "outWeapAnimToggle") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v16 = LocalClientGlobals->localClientNum;
  if ( !CgWeaponMap::ms_instance[v16] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v17 = CgWeaponMap::ms_instance[v16];
  *(double *)&_XMM0 = BG_WeaponADSFractionAffectedByReload(v17, ps);
  __asm
  {
    vxorps  xmm1, xmm1, xmm1
    vcomiss xmm0, xmm1
  }
  v21 = !(v19 | v20) && *outWeapAnim != 55;
  if ( BG_ADSReloadEnabled(v17, ps, weapon, isAlternate) || (v22 = v11, (unsigned int)(ps->weapState[v11].weaponState - 18) > 3) || CG_Weapons_IsReloadActive(localClientNum, ps, (PlayerHandIndex)v11, weapon, isAlternate, isInterruptible) )
  {
    v23 = 0;
    v22 = v11;
  }
  else
  {
    v23 = 1;
  }
  v24 = v22;
  weaponState = ps->weapState[v22].weaponState;
  v26 = (unsigned int)(weaponState - 1) <= 4 && isInterruptible;
  v27 = (unsigned int)(weaponState - 22) <= 2 && isInterruptible;
  v28 = v23 || v26 || weaponState == 36 || v27;
  v29 = weaponState == 16 && BG_IsADSFireOnly(weapon, isAlternate) && ps->weapState[v24].weaponDelay > 0;
  if ( isAiming && v21 )
  {
    if ( !v28 )
      goto LABEL_48;
    if ( !v29 )
    {
      *outWeapAnim = 1;
      *outWeapAnimToggle = 1;
      LocalClientGlobals->fastADSTransActive = 1;
      return;
    }
  }
  if ( v28 && LocalClientGlobals->fastADSTransActive )
    goto LABEL_50;
LABEL_48:
  if ( LocalClientGlobals->fastADSTransActive && v29 )
  {
LABEL_50:
    *outWeapAnim = 1;
    *outWeapAnimToggle = 1;
    return;
  }
  if ( !v28 )
    LocalClientGlobals->fastADSTransActive = 0;
}

/*
==============
CG_Weapons_FreeAnimTreeHand
==============
*/
void CG_Weapons_FreeAnimTreeHand(const LocalClientNum_t localClientNum, const PlayerHandIndex hand)
{
  __int64 v2; 
  cg_t *LocalClientGlobals; 
  __int64 v5; 
  XAnimTree *v6; 
  __int64 v7; 
  __int64 v8; 

  v2 = hand;
  if ( (unsigned int)hand >= NUM_WEAPON_HANDS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10203, ASSERT_TYPE_ASSERT, "(unsigned)( hand ) < (unsigned)( NUM_WEAPON_HANDS )", "hand doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", hand, 2) )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( (unsigned int)v2 >= 2 )
  {
    LODWORD(v8) = 2;
    LODWORD(v7) = v2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v7, v8) )
      __debugbreak();
  }
  v5 = (__int64)&LocalClientGlobals->m_weaponHand[v2];
  if ( !v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10207, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
    __debugbreak();
  v6 = *(XAnimTree **)(v5 + 8);
  if ( v6 )
  {
    Com_XAnimFreeSmallTree(v6);
    *(_QWORD *)(v5 + 8) = 0i64;
  }
  if ( *(_QWORD *)v5 )
    DObjSetTree(*(DObj **)v5, NULL);
}

/*
==============
CG_Weapons_GetAnxietyWeight
==============
*/

float __fastcall CG_Weapons_GetAnxietyWeight(const cg_t *const cgameGlob, const playerState_s *const ps, const XAnimTree *animTree, double goalWeight)
{
  int m_skydiveAutodeployOffset; 
  double v41; 

  __asm
  {
    vmovaps [rsp+68h+var_38], xmm9
    vmovaps xmm9, xmm3
  }
  _RBX = cgameGlob;
  if ( !cgameGlob->m_skydiveAutodeployOffsetIsValid )
  {
    v41 = XAnimGetGoalWeight(animTree, 0, XANIM_SUBTREE_DEFAULT, 0xCDu);
    goto LABEL_10;
  }
  m_skydiveAutodeployOffset = cgameGlob->m_skydiveAutodeployOffset;
  __asm
  {
    vmovss  xmm2, dword ptr [rdx+38h]
    vxorps  xmm1, xmm1, xmm1
    vcvtsi2ss xmm1, xmm1, eax
    vcomiss xmm2, xmm1
    vmovaps [rsp+68h+var_18], xmm6
    vxorps  xmm6, xmm6, xmm6
    vcomiss xmm2, xmm6
    vmovaps [rsp+68h+var_28], xmm7
  }
  if ( cgameGlob->m_skydiveAutodeployOffsetIsValid )
    goto LABEL_6;
  if ( m_skydiveAutodeployOffset >= 0 )
  {
    __asm { vcomiss xmm2, xmm6 }
LABEL_6:
    if ( m_skydiveAutodeployOffset > 0 )
    {
      __asm
      {
        vmulss  xmm0, xmm1, cs:__real@40a00000
        vdivss  xmm7, xmm0, xmm2
      }
    }
    else
    {
      __asm
      {
        vmulss  xmm7, xmm1, cs:__real@c0c00000
        vcomiss xmm7, xmm6
        vaddss  xmm0, xmm7, dword ptr [rdi+38h]
        vaddss  xmm1, xmm7, cs:__real@3f800000
        vmovd   xmm2, dword ptr [rbx+0C52A0h]
        vcmpeqss xmm0, xmm0, xmm6
        vblendvps xmm3, xmm7, xmm1, xmm0
        vaddss  xmm1, xmm3, dword ptr [rdi+38h]
        vcvtdq2ps xmm2, xmm2
        vaddss  xmm0, xmm2, xmm3
        vmulss  xmm2, xmm0, cs:__real@40a00000
        vdivss  xmm7, xmm2, xmm1
        vmovss  [rsp+68h+arg_0], xmm3
      }
    }
    goto LABEL_9;
  }
  __asm
  {
    vmovss  xmm0, cs:__real@3e4ccccd
    vdivss  xmm1, xmm0, xmm1
    vmulss  xmm7, xmm1, xmm2
  }
LABEL_9:
  __asm
  {
    vcomiss xmm7, xmm6
    vcomiss xmm7, cs:__real@3e800000
    vmovss  xmm2, cs:__real@3f800000; max
    vmovss  xmm1, cs:__real@3e99999a; min
    vmovaps xmm0, xmm7; val
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm
  {
    vmulss  xmm1, xmm0, cs:__real@40a33333; Y
    vmovss  xmm0, cs:__real@402df3b6; X
  }
  *(float *)&_XMM0 = powf_0(*(float *)&_XMM0, *(float *)&_XMM1);
  __asm
  {
    vmulss  xmm1, xmm0, cs:__real@3dae2abc
    vmovss  xmm2, cs:__real@3f800000; max
    vmulss  xmm0, xmm1, xmm9; val
    vxorps  xmm1, xmm1, xmm1; min
  }
  v41 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm
  {
    vmovaps xmm6, [rsp+68h+var_18]
    vmovaps xmm7, [rsp+68h+var_28]
  }
LABEL_10:
  __asm { vmovaps xmm9, [rsp+68h+var_38] }
  return *(float *)&v41;
}

/*
==============
CG_Weapons_GetEntityHitId
==============
*/
unsigned __int16 CG_Weapons_GetEntityHitId(const trace_t *trace)
{
  unsigned __int16 result; 

  result = Trace_GetEntityHitId(trace);
  if ( result >= 0x800u )
    return 2047;
  return result;
}

/*
==============
CG_Weapons_GetLootVariantDisplayName
==============
*/
const char *CG_Weapons_GetLootVariantDisplayName(const Weapon *weapon, unsigned int lootVariantIndex)
{
  const WeaponCompleteDef *v4; 
  const char *szLootTable; 
  const char *ColumnValueForRow; 
  const char *result; 
  const dvar_t *v8; 
  const dvar_t *v9; 
  __int64 v10; 
  __int64 v11; 
  StringTable *tablePtr; 

  v4 = BG_WeaponCompleteDef(weapon, 0);
  if ( lootVariantIndex >= v4->numLootVariants && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22297, ASSERT_TYPE_ASSERT, "(unsigned)( lootVariantIndex ) < (unsigned)( weapCompleteDef->numLootVariants )", "lootVariantIndex doesn't index weapCompleteDef->numLootVariants\n\t%i not in [0, %i)", lootVariantIndex, v4->numLootVariants) )
    __debugbreak();
  szLootTable = v4->szLootTable;
  if ( (!szLootTable || !*szLootTable) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22298, ASSERT_TYPE_ASSERT, "(weapCompleteDef->szLootTable && weapCompleteDef->szLootTable[0])", (const char *)&queryFormat, "weapCompleteDef->szLootTable && weapCompleteDef->szLootTable[0]") )
    __debugbreak();
  StringTable_GetAsset(v4->szLootTable, (const StringTable **)&tablePtr);
  if ( !tablePtr && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22301, ASSERT_TYPE_ASSERT, "(lootTable)", (const char *)&queryFormat, "lootTable") )
    __debugbreak();
  if ( lootVariantIndex >= StringTable_GetRowCount(tablePtr) )
  {
    LODWORD(v11) = StringTable_GetRowCount(tablePtr);
    LODWORD(v10) = lootVariantIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22302, ASSERT_TYPE_ASSERT, "(unsigned)( lootVariantIndex ) < (unsigned)( StringTable_GetRowCount( lootTable ) )", "lootVariantIndex doesn't index StringTable_GetRowCount( lootTable )\n\t%i not in [0, %i)", v10, v11) )
      __debugbreak();
  }
  ColumnValueForRow = StringTable_GetColumnValueForRow(tablePtr, lootVariantIndex, 17);
  if ( !ColumnValueForRow && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 22305, ASSERT_TYPE_ASSERT, "(displayName)", (const char *)&queryFormat, "displayName") )
    __debugbreak();
  if ( !*ColumnValueForRow )
    return 0i64;
  result = SEH_StringEd_GetString(ColumnValueForRow);
  if ( !result )
  {
    v8 = DCONST_DVARBOOL_loc_warnings;
    if ( !DCONST_DVARBOOL_loc_warnings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "loc_warnings") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v8);
    if ( v8->current.enabled )
    {
      v9 = DCONST_DVARBOOL_loc_warningsAsErrors;
      if ( !DCONST_DVARBOOL_loc_warningsAsErrors && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "loc_warningsAsErrors") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v9);
      if ( v9->current.enabled )
        Com_Error_impl(ERR_LOCALIZATION, (const ObfuscateErrorText)&stru_1442E1080, 619i64, weapon->weaponIdx, ColumnValueForRow);
      else
        Com_PrintWarning(17, "WARNING: Weapon %d: Could not translate loot variant name \"%s\"\n", weapon->weaponIdx, ColumnValueForRow);
    }
    return ColumnValueForRow;
  }
  return result;
}

/*
==============
CG_Weapons_GetSFXImpactType
==============
*/
__int64 CG_Weapons_GetSFXImpactType(LocalClientNum_t localClientNum, const int sourceEntityNum, const Weapon *inWeapon, bool isAlternate)
{
  WeaponSFXPackage *SfxPackage; 
  int fxImpactType[6]; 

  SfxPackage = BG_GetSfxPackage(inWeapon, isAlternate);
  fxImpactType[0] = CG_Main_RegisteredImpactTypeToImpactType(UNKNOWN);
  if ( SfxPackage )
    fxImpactType[0] = SfxPackage->sfxImpactType;
  CG_OverrideImpactEffectType(localClientNum, sourceEntityNum, fxImpactType);
  return (unsigned int)fxImpactType[0];
}

/*
==============
CG_Weapons_GetSFXWhizbyType
==============
*/
WeaponSFXPackage *CG_Weapons_GetSFXWhizbyType(const Weapon *inWeapon, bool isAlternate)
{
  WeaponSFXPackage *result; 

  result = BG_GetSfxPackage(inWeapon, isAlternate);
  if ( result )
    return (WeaponSFXPackage *)result->whizbyType;
  return result;
}

/*
==============
CG_Weapons_GetScriptableHitId
==============
*/

unsigned int __fastcall CG_Weapons_GetScriptableHitId(const trace_t *trace)
{
  return Trace_GetScriptableHitId(trace);
}

/*
==============
CG_Weapons_GetStowedOffsetModel
==============
*/
XModel *CG_Weapons_GetStowedOffsetModel(const WeaponDef *weapDef)
{
  ClGameModeApplication *ActiveClientApplication; 

  if ( !weapDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25792, ASSERT_TYPE_ASSERT, "(weapDef)", (const char *)&queryFormat, "weapDef") )
    __debugbreak();
  if ( !weapDef->stowOffsetModel )
    return 0i64;
  ActiveClientApplication = ClGameModeApplication::GetActiveClientApplication();
  if ( ActiveClientApplication->IsModelLoaded(ActiveClientApplication, weapDef->stowOffsetModel) )
    return weapDef->stowOffsetModel;
  if ( weapDef->stowOffsetModel == weapDef->worldModel )
    return weapDef->defaultWorldModel;
  else
    return 0i64;
}

/*
==============
CG_Weapons_GetVFXImpactType
==============
*/
__int64 CG_Weapons_GetVFXImpactType(LocalClientNum_t localClientNum, const int sourceEntityNum, const Weapon *inWeapon, bool isAlternate)
{
  const WeaponCompleteDef *v8; 
  unsigned int WeaponAttachments; 
  unsigned int v10; 
  unsigned int v11; 
  WeaponAttachment **v12; 
  int *p_vfxImpactType; 
  int fxImpactType[4]; 
  WeaponAttachment *attachments[30]; 

  v8 = BG_WeaponCompleteDef(inWeapon, isAlternate);
  WeaponAttachments = BG_GetWeaponAttachments(inWeapon, isAlternate, (const WeaponAttachment **)attachments);
  v10 = 0;
  fxImpactType[0] = v8->vfxImpactType;
  v11 = WeaponAttachments;
  if ( WeaponAttachments )
  {
    v12 = attachments;
    while ( 1 )
    {
      if ( !*v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 19919, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      p_vfxImpactType = &(*v12)->impact->vfxImpactType;
      if ( p_vfxImpactType )
        break;
      ++v10;
      ++v12;
      if ( v10 >= v11 )
        goto LABEL_10;
    }
    fxImpactType[0] = *p_vfxImpactType;
  }
LABEL_10:
  CG_OverrideImpactEffectType(localClientNum, sourceEntityNum, fxImpactType);
  return (unsigned int)fxImpactType[0];
}

/*
==============
CG_Weapons_GetVMRelativeAnimIndex
==============
*/
__int64 CG_Weapons_GetVMRelativeAnimIndex(int ordinalIndex, bool isPostShipEnabled)
{
  unsigned int v4; 
  unsigned int v5; 
  int v6; 
  int v7; 
  __int64 v9; 
  __int64 v11; 
  int v12; 

  v4 = 16 * (isPostShipEnabled + 11);
  if ( ordinalIndex >= v4 )
  {
    v12 = 16 * (isPostShipEnabled + 11);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2907, ASSERT_TYPE_ASSERT, "(unsigned)( ordinalIndex ) < (unsigned)( CG_Weapons_GetVMRelativeAnimCount( isPostShipEnabled ) )", "ordinalIndex doesn't index CG_Weapons_GetVMRelativeAnimCount( isPostShipEnabled )\n\t%i not in [0, %i)", ordinalIndex, v12) )
      __debugbreak();
  }
  if ( ordinalIndex < 169 )
  {
    v5 = ordinalIndex + 236;
    goto LABEL_11;
  }
  v6 = ordinalIndex - 169;
  if ( v6 < 7 )
  {
    v5 = v6 + 398;
    goto LABEL_11;
  }
  v7 = v6 - 7;
  if ( isPostShipEnabled )
  {
    if ( v7 < 16 )
    {
      v5 = v7 + 432;
LABEL_11:
      if ( v5 - 236 > 0xA8 && v5 - 432 > 0xF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2890, ASSERT_TYPE_ASSERT, "(isValidViewmodelAnimIndex)", (const char *)&queryFormat, "isValidViewmodelAnimIndex") )
        __debugbreak();
      return v5;
    }
    v7 -= 16;
  }
  LODWORD(v11) = v4;
  LODWORD(v9) = v7;
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2939, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Encountered unexpected viewmodel animation index %i (count %i).", v9, v11) )
    __debugbreak();
  return 236i64;
}

/*
==============
CG_Weapons_GetVehicleViewOrigin
==============
*/
char CG_Weapons_GetVehicleViewOrigin(const LocalClientNum_t localClientNum, const playerState_s *ps, vec3_t *outOrigin)
{
  centity_t *Entity; 
  vec3_t outAngles; 

  if ( ps->vehicleState.entity == 2047 || BG_IsTurretActiveFlags(&ps->eFlags) )
    return 0;
  Entity = CG_GetEntity(localClientNum, ps->vehicleState.entity);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 15016, ASSERT_TYPE_ASSERT, "(vehicleEnt)", (const char *)&queryFormat, "vehicleEnt") )
    __debugbreak();
  if ( (Entity->flags & 1) == 0 || !BG_IsVehicleEntity(&Entity->nextState) )
    return 0;
  CG_VehicleCam_GetVehiclePosition(localClientNum, Entity, outOrigin, &outAngles);
  return 1;
}

/*
==============
CG_Weapons_GetVisibilityBoneIndex
==============
*/
__int64 CG_Weapons_GetVisibilityBoneIndex(const DObj *obj, const characterInfo_t *ci, const Weapon *r_weapon, const bool isAlternate, PlayerHandIndex hand, bool *outUseWeaponTag)
{
  bool *v10; 
  __int64 v11; 
  const WeaponDef *v12; 
  scr_string_t AttachBone; 
  bool v14; 
  CharacterModelType modelTypesToSearch[2]; 
  TagPair result; 
  unsigned __int8 inOutIndex; 
  scr_string_t outTagName; 

  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23092, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23093, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  v10 = outUseWeaponTag;
  if ( !outUseWeaponTag && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23094, ASSERT_TYPE_ASSERT, "(outUseWeaponTag)", (const char *)&queryFormat, "outUseWeaponTag") )
    __debugbreak();
  *v10 = 0;
  inOutIndex = -2;
  outTagName = 0;
  modelTypesToSearch[0] = CHAR_MODEL_WEAPON_HELD;
  modelTypesToSearch[1] = CHAR_MODEL_WEAPON_HELD_LEFT;
  BG_GetWeaponFlashTagname(&result, &ci->dobjHeldWeapon, 0, 0);
  if ( TagPair::GetTagNameAndBoneIndexForCharacter(&result, obj, ci, modelTypesToSearch, 2, &outTagName, &inOutIndex) )
  {
    LOBYTE(v11) = inOutIndex;
    if ( inOutIndex <= 0xFDu )
    {
      *v10 = 1;
      return (unsigned __int8)v11;
    }
  }
  if ( BG_IsThrowingAxe(r_weapon) || BG_IsMeleeOnlyAxe(r_weapon, isAlternate) )
  {
    inOutIndex = -2;
    v14 = DObjGetBoneIndexInternal_66(obj, scr_const.tag_weapon_right, &inOutIndex, (int *)&outUseWeaponTag) == 0;
    v11 = inOutIndex;
    if ( !v14 )
      return v11;
  }
  else
  {
    inOutIndex = -2;
    v12 = BG_WeaponDef(r_weapon, isAlternate);
    AttachBone = BG_Weapons_GetAttachBone(ci, v12->weapType, r_weapon, isAlternate, hand);
    if ( DObjGetBoneIndexInternal_66(obj, AttachBone, &inOutIndex, (int *)&outUseWeaponTag) )
      return inOutIndex;
  }
  return 254i64;
}

/*
==============
CG_Weapons_GetWeaponAnimRate
==============
*/
float CG_Weapons_GetWeaponAnimRate(const LocalClientNum_t localClientNum, const playerState_s *ps, const PlayerHandIndex hand, const Weapon *weapon, bool isAlternate, bool isDualWielding, XAnim_s *anims, weapAnimFiles_t animIndex_desiredTime, weapAnimFiles_t animIndex_actual, int oneHanded)
{
  __int64 v17; 
  char v18; 
  int ammoInClipBeforeReload; 
  CgHandler *Handler; 
  ReloadType v21; 
  CgHandler *v22; 
  ReloadType ReloadType; 
  CgHandler *v24; 
  int v25; 
  CgHandler *v26; 
  int v27; 
  CgHandler *v28; 
  int v29; 
  CgHandler *v30; 
  int weaponState; 
  cg_t *LocalClientGlobals; 
  int sprintInAnimLength; 
  cg_t *v34; 
  int sprintOutAnimLength; 
  CgWeaponMap *Instance; 
  bool IsMeleeAnimFatal; 
  const XAnimParts *v38; 
  int v39; 
  char *v40; 
  const char *name; 
  XAnim_s *v43; 
  unsigned int v44; 
  char v45; 
  char v46; 
  const XAnimParts *Parts; 
  char *WeaponName; 
  bool *v61; 
  bool *v62; 
  __int64 ammoInClip; 
  bool *hasFastReloadOverride; 
  bool *hasFastReloadOverridea; 
  bool *v66; 
  int time; 
  bool v68[4]; 
  unsigned int animIndex; 
  int outShellEjectTime; 
  XAnim_s *v71; 
  int outMeleeDamageTime; 
  char output[1024]; 

  v17 = hand;
  v71 = anims;
  animIndex = animIndex_actual;
  if ( !anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1705, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
    __debugbreak();
  if ( (unsigned int)animIndex_desiredTime >= NUM_WEAP_VIEWMODEL_ANIMS )
  {
    LODWORD(v61) = animIndex_desiredTime;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1706, ASSERT_TYPE_ASSERT, "(unsigned)( animIndex_desiredTime ) < (unsigned)( NUM_WEAP_VIEWMODEL_ANIMS )", "animIndex_desiredTime doesn't index NUM_WEAP_VIEWMODEL_ANIMS\n\t%i not in [0, %i)", v61, 608) )
      __debugbreak();
  }
  if ( (unsigned int)animIndex_actual >= NUM_WEAP_VIEWMODEL_ANIMS )
  {
    LODWORD(ammoInClip) = 608;
    LODWORD(v61) = animIndex_actual;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1707, ASSERT_TYPE_ASSERT, "(unsigned)( animIndex_actual ) < (unsigned)( NUM_WEAP_VIEWMODEL_ANIMS )", "animIndex_actual doesn't index NUM_WEAP_VIEWMODEL_ANIMS\n\t%i not in [0, %i)", v61, ammoInClip) )
      __debugbreak();
  }
  if ( (unsigned int)v17 >= 2 )
  {
    LODWORD(ammoInClip) = 2;
    LODWORD(v61) = v17;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1708, ASSERT_TYPE_ASSERT, "(unsigned)( hand ) < (unsigned)( NUM_WEAPON_HANDS )", "hand doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v61, ammoInClip) )
      __debugbreak();
  }
  BG_WeaponDef(weapon, isAlternate);
  if ( oneHanded && animIndex_desiredTime == WEAP_ANIM_RECHAMBER )
  {
    v18 = 1;
    time = BG_RechamberTimeOneHanded(ps, weapon, isAlternate, isDualWielding);
  }
  else
  {
    switch ( animIndex_desiredTime )
    {
      case WEAP_ANIM_ADDITIVE_MOVE_OFFSET_TRANS_JOG_TO_WALK:
      case WEAP_ANIM_VIEWMODEL_BLENDSPACE_START:
      case NUM_WEAP_ANIM_ADDITIVE_MOVE_CYCLE|NUM_WEAP_ANIMS_ROOT|WEAP_ANIM_RELOAD_MULTIPLE_4:
        time = BG_LadderClimbRaiseTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_ADDITIVE_SPRINT_IN:
      case WEAP_ANIM_SPRINT_IN:
        if ( Dvar_GetBool_Internal_DebugName(DCONST_DVARMPBOOL_movementAnimProto, "movementAnimProto") && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1946, ASSERT_TYPE_ASSERT, "(!Dvar_GetBool_Internal_DebugName( DCONST_DVARMPBOOL_movementAnimProto, \"movementAnimProto\" ))", (const char *)&queryFormat, "!DconstMP_GetBool( movementAnimProto )") )
          __debugbreak();
        LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
        if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1949, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
          __debugbreak();
        sprintInAnimLength = LocalClientGlobals->sprintAnimData.sprintInAnimLength;
        if ( !sprintInAnimLength )
        {
          CG_Weapons_StoreSprintAnimLength(localClientNum, animIndex_desiredTime, (const PlayerHandIndex)v17);
          sprintInAnimLength = LocalClientGlobals->sprintAnimData.sprintInAnimLength;
        }
        time = sprintInAnimLength;
        goto LABEL_96;
      case WEAP_ANIM_ADDITIVE_SPRINT_LOOP:
      case WEAP_ANIM_SPRINT_LOOP:
        time = BG_SprintLoopTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_ADDITIVE_SPRINT_OUT:
      case WEAP_ANIM_SPRINT_IN_CANCEL:
      case WEAP_ANIM_SPRINT_OUT:
        if ( Dvar_GetBool_Internal_DebugName(DCONST_DVARMPBOOL_movementAnimProto, "movementAnimProto") && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1968, ASSERT_TYPE_ASSERT, "(!Dvar_GetBool_Internal_DebugName( DCONST_DVARMPBOOL_movementAnimProto, \"movementAnimProto\" ))", (const char *)&queryFormat, "!DconstMP_GetBool( movementAnimProto )") )
          __debugbreak();
        v34 = CG_GetLocalClientGlobals(localClientNum);
        if ( !v34 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1971, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
          __debugbreak();
        sprintOutAnimLength = v34->sprintAnimData.sprintOutAnimLength;
        if ( !sprintOutAnimLength )
        {
          CG_Weapons_StoreSprintAnimLength(localClientNum, animIndex_desiredTime, (const PlayerHandIndex)v17);
          sprintOutAnimLength = v34->sprintAnimData.sprintOutAnimLength;
        }
        time = sprintOutAnimLength;
        goto LABEL_96;
      case WEAP_ANIM_PRE_FIRE:
        time = BG_PreFireTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_HOLD_FIRE:
        time = BG_GetWeaponFieldTime(ps, weapon, isAlternate, isDualWielding, 16i64);
        goto LABEL_96;
      case WEAP_ANIM_GRENADE_PRIME:
        BG_GetGrenadePrimeTime(ps, weapon, isAlternate, &time);
        goto LABEL_96;
      case WEAP_ANIM_GRENADE_PRIME_READY_TO_THROW:
        BG_GetGrenadePrimeReadyToThrowTime(ps, weapon, isAlternate, &time);
        goto LABEL_96;
      case WEAP_ANIM_SKYDIVE_RELATIVE_FIRST:
        time = BG_SkydiveFreefallRaiseTime(ps, weapon, isAlternate);
        goto LABEL_96;
      case WEAP_ANIM_SKYDIVE_OPEN_PARACHUTE:
        time = BG_SkydiveOpenParachuteTime(ps, weapon, isAlternate);
        goto LABEL_96;
      case WEAP_ANIM_SKYDIVE_QUICK_OPEN_PARACHUTE:
        time = BG_SkydiveQuickOpenParachuteTime(ps, weapon, isAlternate);
        goto LABEL_96;
      case WEAP_ANIM_SKYDIVE_PARACHUTE_STILL_LAND:
        time = BG_SkydiveParachuteStillLandingTime(ps, weapon, isAlternate);
        goto LABEL_96;
      case WEAP_ANIM_SKYDIVE_PARACHUTE_SLOW_SOFT_LAND:
        time = BG_SkydiveParachuteSlowSoftLandingTime(ps, weapon, isAlternate);
        goto LABEL_96;
      case WEAP_ANIM_SKYDIVE_PARACHUTE_SLOW_HARD_LAND:
        time = BG_SkydiveParachuteSlowHardLandingTime(ps, weapon, isAlternate);
        goto LABEL_96;
      case WEAP_ANIM_SKYDIVE_PARACHUTE_FAST_LAND:
        time = BG_SkydiveParachuteFastLandingTime(ps, weapon, isAlternate);
        goto LABEL_96;
      case WEAP_ANIM_SKYDIVE_PARACHUTE_MID_AIR_DETACH:
        time = BG_SkydiveParachuteMidAirDetachTime(ps, weapon, isAlternate);
        goto LABEL_96;
      case WEAP_ANIM_SKYDIVE_SUPER_DIVE_IN:
        time = BG_SkydiveSuperDiveInTime(ps, weapon, isAlternate);
        goto LABEL_96;
      case WEAP_ANIM_SKYDIVE_SUPER_DIVE_OUT:
        time = BG_SkydiveSuperDiveOutTime(ps, weapon, isAlternate);
        goto LABEL_96;
      case WEAP_ANIM_SKYDIVE_PARACHUTE_DETACH:
        time = BG_SkydiveParachuteDetachTime(ps, weapon, isAlternate);
        goto LABEL_96;
      case WEAP_ANIM_ALT_MELEE_LAST:
      case WEAP_ANIM_RELOAD_ADS:
      case WEAP_ANIM_RELOAD_ADS_NVG:
      case WEAP_ANIM_FAST_RELOAD_FIRST:
      case WEAP_ANIM_FAST_RELOAD_ADS:
      case WEAP_ANIM_FAST_RELOAD_ADS_NVG:
        ammoInClipBeforeReload = ps->weapState[v17].ammoInClipBeforeReload;
        v68[0] = 0;
        Handler = CgHandler::getHandler(localClientNum);
        time = BG_ReloadTime(ps, Handler, (const PlayerHandIndex)v17, weapon, isAlternate, isDualWielding, ammoInClipBeforeReload, v68);
        goto LABEL_96;
      case WEAP_ANIM_RELOAD_EMPTY:
      case WEAP_ANIM_RELOAD_EMPTY_ADS:
      case WEAP_ANIM_RELOAD_EMPTY_ADS_NVG:
      case WEAP_ANIM_FAST_RELOAD_EMPTY:
      case WEAP_ANIM_FAST_RELOAD_EMPTY_ADS:
      case WEAP_ANIM_FAST_RELOAD_EMPTY_ADS_NVG:
        v68[0] = 0;
        ReloadType = BG_GetReloadType(weapon, isAlternate);
        v24 = CgHandler::getHandler(localClientNum);
        if ( ReloadType == RELOAD_TYPE_MULTIPLE_PERCENTAGE )
          time = BG_ReloadMultipleTimePercentageBased(ps, v24, (const PlayerHandIndex)v17, weapon, isAlternate, v68);
        else
          time = BG_ReloadEmptyTime(ps, v24, (const PlayerHandIndex)v17, weapon, isAlternate, isDualWielding, v68);
        goto LABEL_96;
      case WEAP_ANIM_RELOAD_START:
      case WEAP_ANIM_RELOAD_START_ADS:
      case WEAP_ANIM_RELOAD_START_ADS_NVG:
      case WEAP_ANIM_RELOAD_START_TWO:
      case WEAP_ANIM_RELOAD_START_TWO_ADS:
      case WEAP_ANIM_RELOAD_START_TWO_ADS_NVG:
      case WEAP_ANIM_FAST_RELOAD_START:
      case WEAP_ANIM_FAST_RELOAD_START_ADS:
      case WEAP_ANIM_FAST_RELOAD_START_ADS_NVG:
      case WEAP_ANIM_FAST_RELOAD_START_TWO:
      case WEAP_ANIM_FAST_RELOAD_START_TWO_ADS:
      case WEAP_ANIM_FAST_RELOAD_START_TWO_ADS_NVG:
        v25 = ps->weapState[v17].ammoInClipBeforeReload;
        v68[0] = 0;
        v26 = CgHandler::getHandler(localClientNum);
        time = BG_ReloadStartTime(ps, v26, (const PlayerHandIndex)v17, weapon, isAlternate, isDualWielding, v25, v68);
        goto LABEL_96;
      case WEAP_ANIM_RELOAD_END:
      case WEAP_ANIM_RELOAD_END_ADS:
      case WEAP_ANIM_RELOAD_END_ADS_NVG:
      case WEAP_ANIM_FAST_RELOAD_END:
      case WEAP_ANIM_FAST_RELOAD_END_ADS:
      case WEAP_ANIM_FAST_RELOAD_END_ADS_NVG:
        v27 = ps->weapState[v17].ammoInClipBeforeReload;
        v68[0] = 0;
        v28 = CgHandler::getHandler(localClientNum);
        time = BG_ReloadEndTime(ps, v28, (const PlayerHandIndex)v17, weapon, isAlternate, isDualWielding, v27, v68);
        goto LABEL_96;
      case WEAP_ANIM_RELOAD_END_RECHAMBER:
      case WEAP_ANIM_RELOAD_END_RECHAMBER_ADS:
      case WEAP_ANIM_RELOAD_END_RECHAMBER_ADS_NVG:
      case WEAP_ANIM_FAST_RELOAD_END_RECHAMBER:
      case WEAP_ANIM_FAST_RELOAD_END_RECHAMBER_ADS:
      case WEAP_ANIM_FAST_RELOAD_END_RECHAMBER_ADS_NVG:
        v29 = ps->weapState[v17].ammoInClipBeforeReload;
        v68[0] = 0;
        outShellEjectTime = 0;
        v30 = CgHandler::getHandler(localClientNum);
        time = BG_ReloadEndRechamberTime(ps, v30, (const PlayerHandIndex)v17, weapon, isAlternate, isDualWielding, v29, &outShellEjectTime, v68);
        goto LABEL_96;
      case WEAP_ANIM_RAISE:
        time = BG_RaiseTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_FIRST_RAISE:
        time = BG_FirstRaiseTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_BREACH_RAISE:
        time = BG_BreachRaiseTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_DROP:
        time = BG_DropTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_ALT_RAISE:
        time = BG_AltRaiseTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_ALT_RAISE_ADS:
        time = BG_AltRaiseADSTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_ALT_RAISE_AKIMBO:
        time = BG_AltRaiseAkimboTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_ALT_DROP:
        time = BG_AltDropTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_ALT_DROP_ADS:
        time = BG_AltDropADSTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_ALT_DROP_AKIMBO:
        time = BG_AltDropAkimboTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_QUICK_RAISE:
        if ( ps->weapState[v17].weaponState == 6 )
          goto LABEL_41;
        time = BG_QuickRaiseTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_QUICK_DROP:
        weaponState = ps->weapState[v17].weaponState;
        if ( weaponState == 44 )
        {
          time = BG_Ladder_MantleDropTime(ps);
        }
        else if ( weaponState == 6 )
        {
LABEL_46:
          time = BG_LadderAimDropTime(ps, weapon, isAlternate, isDualWielding);
        }
        else
        {
          time = BG_QuickDropTime(ps, weapon, isAlternate, isDualWielding);
        }
        goto LABEL_96;
      case WEAP_ANIM_EMPTY_RAISE:
        time = BG_EmptyRaiseTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_EMPTY_DROP:
        time = BG_EmptyDropTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_STUNNED_START:
        time = BG_StunnedTimeBegin(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_STUNNED_LOOP:
        time = BG_StunnedTimeLoop(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_STUNNED_END:
        time = BG_StunnedTimeEnd(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_BLAST_FRONT:
        time = BG_BlastFrontTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_BLAST_RIGHT:
        time = BG_BlastRightTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_BLAST_BACK:
        time = BG_BlastBackTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_BLAST_LEFT:
        time = BG_BlastLeftTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_CHARGE_IN:
      case WEAP_ANIM_ADS_CHARGE_IN:
        time = BG_ChargeWeaponInTime(ps, animIndex_desiredTime, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_CHARGE_LOOP:
      case WEAP_ANIM_ADS_CHARGE_LOOP:
        time = BG_ChargeWeaponLoopTime(ps, animIndex_desiredTime, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_CHARGE_OUT:
      case WEAP_ANIM_ADS_CHARGE_OUT:
        if ( BG_WeaponCharge_GetType(weapon, isAlternate) == PTRDIFF )
          goto LABEL_117;
        time = BG_ChargeWeaponOutTime(ps, animIndex_desiredTime, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case WEAP_ANIM_RELOAD_MULTIPLE_FIRST:
      case WEAP_ANIM_RELOAD_MULTIPLE_2:
      case WEAP_ANIM_RELOAD_MULTIPLE_3:
      case WEAP_ANIM_RELOAD_MULTIPLE_4:
      case WEAP_ANIM_RELOAD_MULTIPLE_5:
      case WEAP_ANIM_RELOAD_MULTIPLE_6:
      case WEAP_ANIM_RELOAD_MULTIPLE_7:
      case WEAP_ANIM_RELOAD_MULTIPLE_8:
      case WEAP_ANIM_RELOAD_MULTIPLE_FAST_FIRST:
      case WEAP_ANIM_RELOAD_MULTIPLE_FAST_2:
      case WEAP_ANIM_RELOAD_MULTIPLE_FAST_3:
      case WEAP_ANIM_RELOAD_MULTIPLE_FAST_4:
      case WEAP_ANIM_RELOAD_MULTIPLE_FAST_5:
      case WEAP_ANIM_RELOAD_MULTIPLE_FAST_6:
      case WEAP_ANIM_RELOAD_MULTIPLE_FAST_7:
      case WEAP_ANIM_RELOAD_MULTIPLE_FAST_8:
        v68[0] = 0;
        v21 = BG_GetReloadType(weapon, isAlternate);
        v22 = CgHandler::getHandler(localClientNum);
        if ( v21 == RELOAD_TYPE_MULTIPLE_BULLET )
          time = BG_ReloadMultipleTimeBulletBased(ps, v22, (const PlayerHandIndex)v17, weapon, isAlternate, v68);
        else
          time = BG_ReloadMultipleTimePercentageBased(ps, v22, (const PlayerHandIndex)v17, weapon, isAlternate, v68);
        goto LABEL_96;
      case NUM_WEAP_ANIM_ADDITIVE_MOVE_OFFSET|WEAP_ANIM_RELOAD_MULTIPLE_4:
      case NUM_WEAP_ANIM_ADDITIVE_MOVE_OFFSET|WEAP_ANIM_ROOT_START|WEAP_ANIM_RELOAD_MULTIPLE_4:
        time = BG_LadderClimbDropTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case NUM_WEAP_ANIM_ADDITIVE_MOVE_OFFSET|NUM_ADDITIVE_SKYDIVE_CHILDREN|WEAP_ANIM_RELOAD_MULTIPLE_4:
LABEL_41:
        time = BG_LadderAimRaiseTime(ps, weapon, isAlternate, isDualWielding);
        goto LABEL_96;
      case NUM_WEAP_ANIM_ADDITIVE_MOVE_OFFSET|WEAP_ANIM_ROOT_START|NUM_ADDITIVE_SKYDIVE_CHILDREN|WEAP_ANIM_RELOAD_MULTIPLE_4:
        goto LABEL_46;
      default:
        if ( !BG_IsMeleeAnim(animIndex_desiredTime) )
        {
LABEL_117:
          __asm { vmovss  xmm0, cs:__real@3f800000 }
          return *(float *)&_XMM0;
        }
        Instance = CgWeaponMap::GetInstance(localClientNum);
        IsMeleeAnimFatal = BG_IsMeleeAnimFatal(animIndex_desiredTime);
        BG_GetMeleeTime(Instance, ps, isAlternate, isDualWielding, IsMeleeAnimFatal, &time, &outMeleeDamageTime, &outShellEjectTime);
LABEL_96:
        v18 = 0;
        break;
    }
  }
  if ( time > 0 )
  {
    v43 = v71;
    v44 = animIndex;
    __asm
    {
      vmovaps [rsp+4E0h+var_50], xmm6
      vmovaps [rsp+4E0h+var_60], xmm7
    }
    if ( XAnimBlendSpace_IsBlendspaceNode(v71, animIndex) )
      XAnimBlendSpace_GetLengthMsec(v43, v44);
    else
      XAnimGetLengthMsec(v43, v44);
    __asm
    {
      vxorps  xmm6, xmm6, xmm6
      vcvtsi2ss xmm6, xmm6, eax
      vxorps  xmm7, xmm7, xmm7
      vcomiss xmm6, xmm7
    }
    if ( v45 | v46 )
    {
      Parts = XAnimGetParts(v43, v44);
      if ( !Parts && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2117, ASSERT_TYPE_ASSERT, "( parts ) != ( nullptr )", "%s != %s\n\t%p, %p", "parts", "nullptr", NULL, NULL) )
        __debugbreak();
      WeaponName = BG_GetWeaponName(weapon, output, 0x400u);
      __asm
      {
        vcvtss2sd xmm1, xmm6, xmm6
        vmovsd  [rsp+4E0h+var_4B8], xmm1
      }
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1442DAD20, 601i64, Parts->name, WeaponName, v62);
      __asm { vxorps  xmm0, xmm0, xmm0 }
    }
    else
    {
      __asm
      {
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm0, xmm0, [rsp+4E0h+time]
        vdivss  xmm6, xmm6, xmm0
        vcomiss xmm6, xmm7
      }
      if ( v45 | v46 )
      {
        __asm
        {
          vcvtss2sd xmm0, xmm6, xmm6
          vmovsd  [rsp+4E0h+var_4A0], xmm0
          vxorpd  xmm1, xmm1, xmm1
          vmovsd  [rsp+4E0h+hasFastReloadOverride], xmm1
        }
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2125, ASSERT_TYPE_ASSERT, "( 0.0f ) < ( rate )", "%s < %s\n\t%g, %g", "0.0f", "rate", *(double *)&hasFastReloadOverridea, *(double *)&v66) )
          __debugbreak();
      }
      __asm { vmovaps xmm0, xmm6 }
    }
    __asm
    {
      vmovaps xmm6, [rsp+4E0h+var_50]
      vmovaps xmm7, [rsp+4E0h+var_60]
    }
  }
  else
  {
    v38 = XAnimGetParts(v71, animIndex_desiredTime);
    if ( !v38 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2090, ASSERT_TYPE_ASSERT, "( parts ) != ( nullptr )", "%s != %s\n\t%p, %p", "parts", "nullptr", NULL, NULL) )
      __debugbreak();
    v39 = time;
    v40 = BG_GetWeaponName(weapon, output, 0x400u);
    name = "rechamberTimeOneHanded";
    if ( !v18 )
      name = v38->name;
    LODWORD(hasFastReloadOverride) = animIndex;
    LODWORD(ammoInClip) = animIndex_desiredTime;
    LODWORD(v61) = v39;
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1442DAC80, 600i64, name, v40, v61, ammoInClip, hasFastReloadOverride);
    __asm { vxorps  xmm0, xmm0, xmm0 }
  }
  return *(float *)&_XMM0;
}

/*
==============
CG_Weapons_GetWeaponForName
==============
*/
Weapon *CG_Weapons_GetWeaponForName(Weapon *result, const char *weaponName)
{
  BG_Weapons_GetFullWeaponForName(weaponName, result, BG_FindBaseWeaponForName);
  return result;
}

/*
==============
CG_Weapons_GetWeaponStateModifiedAnimRate
==============
*/
float CG_Weapons_GetWeaponStateModifiedAnimRate(const LocalClientNum_t localClientNum, const playerState_s *ps, const Weapon *weapon, PlayerHandIndex hand, XAnim_s *anims, weapAnimFiles_t animIndex)
{
  __int64 v11; 
  __int64 v13; 
  bool HasUnderbarrelAmmo; 
  CgWeaponMap *v15; 
  weapAnimFiles_t animIndex_desiredTime; 
  int oneHanded; 
  __int64 v22; 
  unsigned __int64 weaponState; 
  __int64 v25; 
  GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64> *p_weapFlags; 
  bool v27; 
  bool HasPerk; 
  char v29; 
  bool v30; 
  int v31; 
  bool v32; 
  char v34; 
  CgWeaponMap *Instance; 
  int v38; 
  bool v39; 
  bool v40; 
  CgHandler *v41; 
  CgHandler *Handler; 
  bool IsUsingFastReloadStateTimer; 
  char v47; 
  bool isDualWielding; 
  Weapon r_weapon; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-58h], xmm6
    vmovaps xmmword ptr [rax-68h], xmm7
  }
  v11 = hand;
  v13 = localClientNum;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2162, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2163, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
    __debugbreak();
  HasUnderbarrelAmmo = BG_UsingAlternate(ps);
  if ( HasUnderbarrelAmmo )
    HasUnderbarrelAmmo = BG_HasUnderbarrelAmmo(weapon);
  if ( !CgWeaponMap::ms_instance[v13] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v15 = CgWeaponMap::ms_instance[v13];
  isDualWielding = BG_PlayerDualWieldingWeapon(v15, ps, weapon) == 1;
  if ( HasUnderbarrelAmmo )
    _RAX = BG_GetAltWeapon(weapon);
  else
    _RAX = weapon;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovups ymmword ptr [rsp+128h+r_weapon.weaponIdx], ymm0
    vmovups xmm1, xmmword ptr [rax+20h]
    vmovups xmmword ptr [rsp+128h+r_weapon.attachmentVariationIndices+5], xmm1
    vmovsd  xmm0, qword ptr [rax+30h]
    vmovsd  qword ptr [rsp+128h+r_weapon.attachmentVariationIndices+15h], xmm0
  }
  *(_DWORD *)&r_weapon.weaponCamo = *(_DWORD *)&_RAX->weaponCamo;
  if ( animIndex != WEAP_ANIM_EMPTY_DROP || (animIndex_desiredTime = WEAP_ANIM_QUICK_DROP, ps->weapState[v11].weaponState != 8) )
    animIndex_desiredTime = animIndex;
  oneHanded = BG_PlayerDualWieldingWeapon(v15, ps, &r_weapon);
  *(float *)&_XMM0 = CG_Weapons_GetWeaponAnimRate((const LocalClientNum_t)v13, ps, (const PlayerHandIndex)v11, &r_weapon, HasUnderbarrelAmmo, isDualWielding, anims, animIndex_desiredTime, animIndex, oneHanded);
  v22 = v11;
  __asm { vmovaps xmm7, xmm0 }
  weaponState = ps->weapState[v11].weaponState;
  if ( (unsigned int)weaponState <= 0x32 && (v25 = 0x4000000001FBEi64, _bittest64(&v25, weaponState)) )
  {
    p_weapFlags = &ps->weapCommon.weapFlags;
    if ( GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&ps->weapCommon.weapFlags, ACTIVE, 0x15u) )
    {
      v27 = GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&ps->otherFlags, GameModeFlagValues::ms_spValue, 0x29u);
      HasPerk = BG_HasPerk(&ps->perks, 0x2Bu);
      if ( v27 || HasPerk )
      {
        v29 = 1;
        goto LABEL_26;
      }
    }
  }
  else
  {
    p_weapFlags = &ps->weapCommon.weapFlags;
  }
  v29 = 0;
LABEL_26:
  __asm { vmovaps [rsp+128h+var_78], xmm9 }
  v30 = GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(p_weapFlags, ACTIVE, 0x16u);
  v31 = ps->weapState[v22].weaponState;
  v32 = v30;
  if ( (unsigned int)(v31 - 18) <= 3 )
  {
    Handler = CgHandler::getHandler((LocalClientNum_t)v13);
    IsUsingFastReloadStateTimer = BG_IsUsingFastReloadStateTimer(ps, Handler, hand, &r_weapon, HasUnderbarrelAmmo, isDualWielding);
    *(double *)&_XMM0 = BG_GetReloadTimeScale(v15, ps, weapon, HasUnderbarrelAmmo, ps->weapState[v22].ammoInClipBeforeReload, IsUsingFastReloadStateTimer);
    __asm
    {
      vxorps  xmm1, xmm1, xmm1
      vcomiss xmm0, xmm1
      vmovaps xmm6, xmm0
    }
    if ( v47 | v34 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2193, ASSERT_TYPE_ASSERT, "(reloadTimeScale > 0.0f)", (const char *)&queryFormat, "reloadTimeScale > 0.0f") )
      __debugbreak();
    __asm { vdivss  xmm6, xmm7, xmm6 }
  }
  else
  {
    if ( v31 == 36 && BG_HasPerk(&ps->perks, 0x13u) )
    {
      *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DVARFLT_perk_sprintRecoveryMultiplierVisual, "perk_sprintRecoveryMultiplierVisual");
      __asm
      {
        vxorps  xmm1, xmm1, xmm1
        vucomiss xmm0, xmm1
      }
      if ( !v34 )
      {
        Dvar_GetFloat_Internal_DebugName(DVARFLT_perk_sprintRecoveryMultiplierVisual, "perk_sprintRecoveryMultiplierVisual");
LABEL_31:
        __asm { vdivss  xmm6, xmm7, xmm0 }
        goto LABEL_57;
      }
LABEL_52:
      __asm { vmovss  xmm6, cs:__real@447a0000 }
      goto LABEL_57;
    }
    if ( (unsigned int)(ps->weapState[v22].weaponState - 26) <= 6 )
    {
      Instance = CgWeaponMap::GetInstance((const LocalClientNum_t)v13);
      if ( BG_UseFastOffhand(ps, Instance) )
      {
        *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_perk_fastOffhandMultiplier, "perk_fastOffhandMultiplier");
        __asm
        {
          vxorps  xmm1, xmm1, xmm1
          vucomiss xmm0, xmm1
        }
        if ( v34 )
        {
          __asm { vmovss  xmm6, cs:__real@447a0000 }
          goto LABEL_57;
        }
        goto LABEL_31;
      }
    }
    if ( v29 )
      goto LABEL_38;
    __asm { vmovaps xmm6, xmm7 }
    if ( v32 )
    {
LABEL_38:
      v38 = ps->weapState[v22].weaponState;
      v39 = (unsigned int)(v38 - 1) <= 4;
      v40 = (unsigned int)(v38 - 7) <= 5 || v38 == 50;
      __asm { vmovaps xmm6, xmm7 }
      v41 = CgHandler::getHandler((LocalClientNum_t)v13);
      __asm { vxorps  xmm9, xmm9, xmm9 }
      if ( !BG_UseQuickSwitchAnims(ps, weapon, HasUnderbarrelAmmo, isDualWielding, v41, v39) )
      {
        *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_perk_weapSwapMultiplier, "perk_weapSwapMultiplier");
        __asm { vucomiss xmm0, xmm9 }
        if ( v34 )
          __asm { vmovss  xmm6, cs:__real@447a0000 }
        else
          __asm { vdivss  xmm6, xmm7, xmm0 }
      }
      if ( v32 && v40 )
      {
        *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_player_meleeOverrideQuickDropScale, "player_meleeOverrideQuickDropScale");
        __asm { vucomiss xmm0, xmm9 }
        if ( v34 )
          goto LABEL_52;
      }
      else
      {
        if ( !GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&ps->otherFlags, GameModeFlagValues::ms_spValue, 0x29u) )
          goto LABEL_57;
        *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DVARFLT_bg_quickWeaponSwitchSpeedScaleSP, "bg_quickWeaponSwitchSpeedScaleSP");
        __asm { vucomiss xmm0, xmm9 }
        if ( v34 )
          goto LABEL_52;
      }
      __asm { vdivss  xmm6, xmm6, xmm0 }
    }
  }
LABEL_57:
  __asm
  {
    vmovaps xmm9, [rsp+128h+var_78]
    vmovaps xmm0, xmm6
    vmovaps xmm6, [rsp+128h+var_58]
    vmovaps xmm7, [rsp+128h+var_68]
  }
  return *(float *)&_XMM0;
}

/*
==============
CG_Weapons_GetWeaponViewRoughOriginIfValid
==============
*/
char CG_Weapons_GetWeaponViewRoughOriginIfValid(LocalClientNum_t localClientNum, const playerState_s *ps, vec3_t *result)
{
  __int16 linkEnt; 
  centity_t *Entity; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23141, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( (ps->linkFlags.m_flags[0] & 4) == 0 )
    return 0;
  linkEnt = ps->linkEnt;
  if ( linkEnt == 2047 )
    return 0;
  Entity = CG_GetEntity(localClientNum, linkEnt);
  if ( (Entity->flags & 1) == 0 )
    return 0;
  CG_GetPoseOrigin(&Entity->pose, result);
  return 1;
}

/*
==============
CG_Weapons_HoldBreathInit
==============
*/
void CG_Weapons_HoldBreathInit(cg_t *cgameGlob)
{
  cgameGlob->holdBreathTime = -1;
  *(_QWORD *)&cgameGlob->holdBreathDelay = 0i64;
}

/*
==============
CG_Weapons_HybridScopeUpdate
==============
*/
void CG_Weapons_HybridScopeUpdate(const LocalClientNum_t localClientNum, const playerState_s *ps, const Weapon *weapon, const bool isAlternate)
{
  __int64 v6; 
  cg_t *LocalClientGlobals; 
  DObj **p_viewModelDObj; 
  DObj *v12; 
  XAnim_s *Anims; 
  __int64 v14; 
  bool v15; 
  char CanHybridToggle; 
  bool v20; 
  const XAnimTree *Tree; 
  char v23; 
  bool v24; 
  int weaponState; 
  bool v27; 
  const Weapon *v28; 
  const playerState_s *v29; 
  LocalClientNum_t v30; 
  const XAnimTree *v32; 
  char v34; 
  const XAnimTree *v35; 
  char v37; 
  char *fmt; 
  float fmta; 
  float fmtb; 
  float fmtc; 
  ClientScopeToggleInfo *scopeToggleInfo; 
  XAnim_s *scopeToggleInfoa; 
  float scopeToggleInfob; 
  float scopeToggleInfoc; 
  float scopeToggleInfod; 
  ClientScopeToggleInfo *v48; 
  float v49; 
  float v50; 
  float v51; 
  const PlayerEquippedWeaponState *EquippedWeaponStateConst; 
  bool hybridScope; 
  CgWeaponMap *weaponMap; 
  CgHandler *weaponMapa; 

  v6 = localClientNum;
  _R13 = weapon;
  if ( (unsigned int)localClientNum >= LODWORD(cl_maxLocalClients) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7697, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( (cl_maxLocalClients) )", "localClientNum doesn't index MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, cl_maxLocalClients) )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7698, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v6);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7701, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  p_viewModelDObj = &LocalClientGlobals->m_weaponHand[0].viewModelDObj;
  _RBX = &LocalClientGlobals->scopeToggleInfo;
  if ( LocalClientGlobals == (cg_t *)-807496i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7706, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
    __debugbreak();
  v12 = *p_viewModelDObj;
  if ( !*p_viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7709, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  Anims = XAnimGetAnims(LocalClientGlobals->m_weaponHand[0].tree);
  if ( !Anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7712, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
    __debugbreak();
  v14 = v6;
  if ( !CgWeaponMap::ms_instance[v6] )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
      __debugbreak();
    v14 = v6;
  }
  weaponMap = CgWeaponMap::ms_instance[v14];
  if ( !weaponMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7715, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  EquippedWeaponStateConst = BG_GetEquippedWeaponStateConst(weaponMap, ps, _R13);
  if ( !EquippedWeaponStateConst || BG_Skydive_IsSkydiving(ps) )
  {
    memset_0(&LocalClientGlobals->scopeToggleInfo, 0, sizeof(LocalClientGlobals->scopeToggleInfo));
  }
  else
  {
    weaponMapa = CgHandler::getHandler((LocalClientNum_t)v6);
    if ( !weaponMapa && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7726, ASSERT_TYPE_ASSERT, "(handler)", (const char *)&queryFormat, "handler") )
      __debugbreak();
    v15 = GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&ps->otherFlags, GameModeFlagValues::ms_mpValue, 0x21u) || LocalClientGlobals->inKillCam;
    if ( memcmp_0(_RBX, _R13, 0x3Cui64) || _RBX->lastWeaponUsingAlternate != isAlternate || _RBX->prevFollowing != v15 )
    {
      memset_0(_RBX, 0, sizeof(ClientScopeToggleInfo));
      _RBX->toggleOnAnimExists = BG_ViewModelAnimExists(ps, WEAP_ANIM_SCOPE_TOGGLE_ON, WEAPON_HAND_DEFAULT, weaponMapa) != 0;
      _RBX->toggleOffAnimExists = BG_ViewModelAnimExists(ps, WEAP_ANIM_SCOPE_TOGGLE_OFF, WEAPON_HAND_DEFAULT, weaponMapa) != 0;
    }
    __asm
    {
      vmovups ymm0, ymmword ptr [r13+0]
      vmovups ymmword ptr [rbx], ymm0
      vmovups xmm1, xmmword ptr [r13+20h]
      vmovups xmmword ptr [rbx+20h], xmm1
      vmovsd  xmm0, qword ptr [r13+30h]
      vmovsd  qword ptr [rbx+30h], xmm0
    }
    *(_DWORD *)&_RBX->lastWeapon.weaponCamo = *(_DWORD *)&_R13->weaponCamo;
    _RBX->lastWeaponUsingAlternate = isAlternate;
    _RBX->prevFollowing = v15;
    CanHybridToggle = BG_CanHybridToggle(ps, _R13, 0);
    if ( BG_HasUnderbarrelAmmo(_R13) )
      CanHybridToggle |= BG_CanHybridToggle(ps, _R13, 1);
    hybridScope = EquippedWeaponStateConst->hybridScope;
    if ( CanHybridToggle )
      CG_Weapons_HybridScopeUpdate_CalcScopeFraction((const LocalClientNum_t)v6, ps, _R13, isAlternate, EquippedWeaponStateConst->hybridScope, _RBX);
    v24 = !_RBX->toggleOnAnimExists;
    _RBX->initialized = 1;
    v20 = !v24 && _RBX->toggleOffAnimExists;
    __asm { vmovaps [rsp+0B8h+var_48], xmm6 }
    if ( CanHybridToggle && v20 )
    {
      Tree = DObjGetTree(v12);
      if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7775, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
        __debugbreak();
      *(double *)&_XMM0 = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x104u);
      __asm { vmovaps xmm6, xmm0 }
      *(double *)&_XMM0 = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x105u);
      __asm
      {
        vxorps  xmm1, xmm1, xmm1
        vcomiss xmm6, xmm1
      }
      if ( v23 | v24 )
      {
        __asm { vcomiss xmm0, xmm1 }
        if ( v23 | v24 )
          *(_DWORD *)_RBX->state = 0;
      }
      switch ( *(_DWORD *)_RBX->state )
      {
        case 0:
          if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7603, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
            __debugbreak();
          if ( !v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7604, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
            __debugbreak();
          if ( !Anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7605, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
            __debugbreak();
          weaponState = ps->weapState[0].weaponState;
          if ( weaponState == 76 )
            goto LABEL_79;
          if ( weaponState == 77 )
            goto LABEL_109;
          v27 = isAlternate;
          v48 = _RBX;
          v28 = _R13;
          scopeToggleInfoa = Anims;
          v29 = ps;
          fmt = (char *)v12;
          v30 = (int)v6;
          if ( !hybridScope )
            goto LABEL_128;
          goto LABEL_68;
        case 1:
          if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7543, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
            __debugbreak();
          if ( !v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7544, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
            __debugbreak();
          if ( !Anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7545, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
            __debugbreak();
          if ( ps->weapState[0].weaponState == 76 )
          {
LABEL_79:
            CG_Weapons_ScopeToggleState_ToggleOn_Enter((const LocalClientNum_t)v6, ps, _R13, isAlternate, v12, Anims, _RBX);
            *(_DWORD *)_RBX->state = 2;
          }
          else if ( hybridScope )
          {
LABEL_68:
            CG_Weapons_ScopeToggleState_Scope2InPosition_Enter((const LocalClientNum_t)v6, ps, _R13, isAlternate, v12, Anims, _RBX);
            *(_DWORD *)_RBX->state = 4;
          }
          break;
        case 2:
          CG_Weapons_ScopeToggleState_ToggleOn_Update((const LocalClientNum_t)v6, ps, _R13, isAlternate, v12, Anims, _RBX);
          break;
        case 3:
          if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7336, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
            __debugbreak();
          if ( !v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7337, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
            __debugbreak();
          if ( !Anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7338, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
            __debugbreak();
          v32 = DObjGetTree(v12);
          if ( !v32 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7341, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
            __debugbreak();
          *(double *)&_XMM0 = XAnimGetWeight(v32, 0, XANIM_SUBTREE_DEFAULT, 0x103u);
          __asm { vmovaps xmm6, xmm0 }
          *(double *)&_XMM0 = XAnimGetTime(v32, 0, XANIM_SUBTREE_DEFAULT, 0x104u);
          __asm { vucomiss xmm6, cs:__real@3a83126f }
          if ( v24 )
          {
            __asm { vcomiss xmm0, cs:__real@3f800000 }
            if ( !v34 )
              goto LABEL_68;
          }
          break;
        case 4:
          if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7581, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
            __debugbreak();
          if ( !v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7582, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
            __debugbreak();
          if ( !Anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7583, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
            __debugbreak();
          if ( ps->weapState[0].weaponState == 77 )
          {
LABEL_109:
            CG_Weapons_ScopeToggleState_ToggleOff_Enter((const LocalClientNum_t)v6, ps, _R13, isAlternate, v12, Anims, _RBX);
            *(_DWORD *)_RBX->state = 5;
          }
          else if ( !hybridScope )
          {
LABEL_127:
            v48 = _RBX;
            v27 = isAlternate;
            scopeToggleInfoa = Anims;
            v28 = _R13;
            fmt = (char *)v12;
            v29 = ps;
            v30 = (int)v6;
LABEL_128:
            CG_Weapons_ScopeToggleState_Scope1InPosition_Enter(v30, v29, v28, v27, (DObj *)fmt, scopeToggleInfoa, v48);
            *(_DWORD *)_RBX->state = 1;
          }
          break;
        case 5:
          CG_Weapons_ScopeToggleState_ToggleOff_Update((const LocalClientNum_t)v6, ps, _R13, isAlternate, v12, Anims, _RBX);
          break;
        case 6:
          if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7444, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
            __debugbreak();
          if ( !v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7445, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
            __debugbreak();
          if ( !Anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7446, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
            __debugbreak();
          v35 = DObjGetTree(v12);
          if ( !v35 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7449, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
            __debugbreak();
          *(double *)&_XMM0 = XAnimGetWeight(v35, 0, XANIM_SUBTREE_DEFAULT, 0x103u);
          __asm { vmovaps xmm6, xmm0 }
          *(double *)&_XMM0 = XAnimGetTime(v35, 0, XANIM_SUBTREE_DEFAULT, 0x105u);
          __asm { vucomiss xmm6, cs:__real@3a83126f }
          if ( v24 )
          {
            __asm { vcomiss xmm0, cs:__real@3f800000 }
            if ( !v37 )
              goto LABEL_127;
          }
          break;
        default:
          LODWORD(scopeToggleInfo) = *(_DWORD *)_RBX->state;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7824, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Unhandled state %d in CG_Weapons_PlayScopeToggleAnimations", scopeToggleInfo) )
            __debugbreak();
          break;
      }
    }
    else
    {
      __asm
      {
        vxorps  xmm6, xmm6, xmm6
        vmovss  dword ptr [rsp+0B8h+var_88], xmm6
        vmovss  dword ptr [rsp+0B8h+scopeToggleInfo], xmm6
        vmovss  dword ptr [rsp+0B8h+fmt], xmm6
      }
      XAnimSetGoalWeight(v12, 0, XANIM_SUBTREE_DEFAULT, 0x103u, fmta, scopeToggleInfob, v49, (scr_string_t)0, 0, 0, LINEAR, NULL);
      if ( _RBX->toggleOnAnimExists )
      {
        __asm
        {
          vmovss  dword ptr [rsp+0B8h+var_88], xmm6
          vmovss  dword ptr [rsp+0B8h+scopeToggleInfo], xmm6
          vmovss  dword ptr [rsp+0B8h+fmt], xmm6
        }
        XAnimSetGoalWeight(v12, 0, XANIM_SUBTREE_DEFAULT, 0x104u, fmtb, scopeToggleInfoc, v50, (scr_string_t)0, 0, 0, LINEAR, NULL);
      }
      if ( _RBX->toggleOffAnimExists )
      {
        __asm
        {
          vmovss  dword ptr [rsp+0B8h+var_88], xmm6
          vmovss  dword ptr [rsp+0B8h+scopeToggleInfo], xmm6
          vmovss  dword ptr [rsp+0B8h+fmt], xmm6
        }
        XAnimSetGoalWeight(v12, 0, XANIM_SUBTREE_DEFAULT, 0x105u, fmtc, scopeToggleInfod, v51, (scr_string_t)0, 0, 0, LINEAR, NULL);
      }
    }
    __asm { vmovaps xmm6, [rsp+0B8h+var_48] }
  }
}

/*
==============
CG_Weapons_HybridScopeUpdate_CalcScopeFraction
==============
*/
void CG_Weapons_HybridScopeUpdate_CalcScopeFraction(const LocalClientNum_t localClientNum, const playerState_s *ps, const Weapon *weapon, const bool isAlternate, const bool scope2IsActive, ClientScopeToggleInfo *scopeToggleInfo)
{
  int weaponState; 
  bool v23; 
  bool v24; 
  int v25; 

  if ( (unsigned int)localClientNum >= LODWORD(cl_maxLocalClients) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7634, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( (cl_maxLocalClients) )", "localClientNum doesn't index MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, cl_maxLocalClients) )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7635, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  _RBX = scopeToggleInfo;
  if ( scopeToggleInfo->initialized )
  {
    weaponState = ps->weapState[0].weaponState;
    v23 = weaponState == 76 || weaponState != 77 && scope2IsActive;
    scopeToggleInfo->fractionInfo.increasing = v23;
    v24 = BG_PlayerDualWielding(ps) == 1;
    if ( scopeToggleInfo->fractionInfo.increasing )
      v25 = BG_ScopeToggleOnTime(ps, weapon, isAlternate, v24);
    else
      v25 = BG_ScopeToggleOffTime(ps, weapon, isAlternate, v24);
    if ( v25 <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7665, ASSERT_TYPE_ASSERT, "( scopeToggleTime ) > ( 0 )", "%s > %s\n\t%i, %i", "scopeToggleTime", "0", v25, 0i64) )
      __debugbreak();
    if ( !CG_GetLocalClientGlobals(localClientNum) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7668, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
      __debugbreak();
    __asm
    {
      vmovss  xmm3, dword ptr [rbx+40h]
      vxorps  xmm1, xmm1, xmm1
      vcvtsi2ss xmm1, xmm1, dword ptr [rbp+65E4h]
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, edi
      vdivss  xmm2, xmm1, xmm0
    }
    if ( scopeToggleInfo->fractionInfo.increasing )
    {
      __asm
      {
        vaddss  xmm0, xmm3, xmm2
        vminss  xmm1, xmm0, cs:__real@3f800000
      }
    }
    else
    {
      __asm
      {
        vsubss  xmm1, xmm3, xmm2
        vxorps  xmm0, xmm0, xmm0
        vmaxss  xmm1, xmm1, xmm0
      }
    }
    __asm { vmovss  dword ptr [rbx+40h], xmm1 }
  }
  else
  {
    _EAX = 0;
    __asm { vmovd   xmm1, eax }
    _EAX = scope2IsActive;
    __asm
    {
      vmovd   xmm0, eax
      vpcmpeqd xmm3, xmm0, xmm1
      vmovss  xmm1, cs:__real@3f800000
      vxorps  xmm2, xmm2, xmm2
      vblendvps xmm0, xmm1, xmm2, xmm3
      vmovss  dword ptr [rbx+40h], xmm0
    }
  }
}

/*
==============
CG_Weapons_Init
==============
*/
void CG_Weapons_Init(LocalClientNum_t localClientNum, bool isFirstInitizingClient)
{
  ClConfigStrings *ClConfigStrings; 
  unsigned __int16 *v4; 
  const char *const *v5; 
  __int64 v6; 
  unsigned int v7; 
  unsigned __int16 v8; 

  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1555, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, 2) )
    __debugbreak();
  if ( isFirstInitizingClient )
  {
    cg_tagIKTargetModelLeft = R_RegisterModel("tag_ik_target_left");
    cg_tagIKTargetModelRight = R_RegisterModel("tag_ik_target_right");
    CG_Gesture_Init();
  }
  ClConfigStrings = ClConfigStrings::GetClConfigStrings();
  v4 = cg_defaultWeaponStickerMaterialIndices;
  v5 = DEFAULT_STICKER_SLOT_MATERIAL_NAMES_0;
  v6 = 4i64;
  do
  {
    v7 = ClConfigStrings->GetStickerMaterialIndex(ClConfigStrings, *v5);
    v8 = v7;
    if ( v7 > 0xFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned short __cdecl truncate_cast_impl<unsigned short,unsigned int>(unsigned int)", "unsigned", (unsigned __int16)v7, "unsigned", v7) )
      __debugbreak();
    *v4 = v8;
    ++v5;
    ++v4;
    --v6;
  }
  while ( v6 );
}

/*
==============
CG_Weapons_IsAiming
==============
*/
bool CG_Weapons_IsAiming(const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, const bool isAlternate)
{
  return GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 9u) && !GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&ps->weapCommon.weapFlags, ACTIVE, 1u) && BG_IsAimDownSight(r_weapon, isAlternate) && (BG_PlayerLastWeaponHand(weaponMap, ps) == WEAPON_HAND_DEFAULT || BG_HasLadderHand(ps));
}

/*
==============
CG_Weapons_IsBulletWeapon
==============
*/
_BOOL8 CG_Weapons_IsBulletWeapon(const Weapon *weapon, bool isAlternate)
{
  return BG_GetWeaponType(weapon, isAlternate) == WEAPTYPE_BULLET;
}

/*
==============
CG_Weapons_IsInAds
==============
*/
bool CG_Weapons_IsInAds(const LocalClientNum_t localClientNum, const BgWeaponMap *weaponMap, const playerState_s *ps, const Weapon *r_weapon, const bool isAlternate, const PlayerHandIndex handIndex)
{
  CgHandler *Handler; 
  bool isInterruptible; 
  bool result; 

  result = 0;
  if ( CG_Weapons_IsAiming(weaponMap, ps, r_weapon, isAlternate) )
  {
    if ( (unsigned int)(ps->weapState[handIndex].weaponState - 18) > 1 )
      return 1;
    Handler = CgHandler::getHandler(localClientNum);
    isInterruptible = PM_Weapon_IsInInterruptibleState(weaponMap, ps, handIndex, Handler);
    if ( !CG_Weapons_IsReloadActive(localClientNum, ps, handIndex, r_weapon, isAlternate, isInterruptible) )
      return 1;
  }
  return result;
}

/*
==============
CG_Weapons_IsPlayerSprinting
==============
*/
bool CG_Weapons_IsPlayerSprinting(const characterInfo_t *ci, const centity_t *cent)
{
  entityState_t *p_nextState; 
  unsigned int Animset; 
  unsigned int Anim; 
  bool v7; 
  SuitAnimType SuitAnimIndex; 
  int LegsAnimation; 
  bool result; 

  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 26052, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  result = 0;
  if ( !ci->usingAnimState )
  {
    p_nextState = &cent->nextState;
    if ( PlayerASM_IsEnabled() )
    {
      Animset = BG_PlayerASM_GetAnimset(p_nextState);
      Anim = BG_PlayerASM_GetAnim(p_nextState, MOVEMENT);
      v7 = BG_PlayerASM_IsSprintAlias(Anim, Animset) == 0;
    }
    else
    {
      SuitAnimIndex = BG_AnimationMP_GetSuitAnimIndex(p_nextState);
      LegsAnimation = BG_AnimationMP_GetLegsAnimation(p_nextState);
      v7 = !BG_IsSprintAnim(LegsAnimation, SuitAnimIndex);
    }
    if ( !v7 )
      return 1;
  }
  return result;
}

/*
==============
CG_Weapons_IsReloadActive
==============
*/
bool CG_Weapons_IsReloadActive(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex handIndex, const Weapon *weapon, const bool isAlternate, const bool isInterruptible)
{
  __int64 v6; 
  __int64 v8; 
  bool v10; 
  const BgWeaponMap **v11; 
  const BgWeaponMap *v12; 
  ReloadType ReloadType; 

  v6 = handIndex;
  v8 = localClientNum;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8362, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v10 = CgWeaponMap::ms_instance[v8] == NULL;
  v11 = (const BgWeaponMap **)&CgWeaponMap::ms_instance[v8];
  if ( v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v12 = *v11;
  ReloadType = BG_GetReloadType(weapon, isAlternate);
  if ( ReloadType != RELOAD_TYPE_SEGMENTED && isInterruptible )
    return 0;
  if ( ReloadType == RELOAD_TYPE_SEGMENTED && (unsigned int)(ps->weapState[v6].weaponState - 20) > 1 )
    return 1;
  return ps->weapState[v6].weaponTime - BG_ADSReloadTransTime(v12, ps, weapon, isAlternate) > 0;
}

/*
==============
CG_Weapons_LoadViewModelDObj
==============
*/
void CG_Weapons_LoadViewModelDObj(const LocalClientNum_t localClientNum, const playerState_s *ps, const Weapon *weapon, const PlayerHandIndex weaponHand)
{
  __int64 v4; 
  cg_t *LocalClientGlobals; 
  __int64 v9; 
  ClConfigStrings *ClConfigStrings; 
  const char *v11; 
  const char *v12; 
  XModel *handXModel; 
  bool v14; 
  __int64 recreateAnimTrees; 

  v4 = weaponHand;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13453, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !weapon->weaponIdx && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13454, ASSERT_TYPE_ASSERT, "(weapon.weaponIdx != 0)", (const char *)&queryFormat, "weapon.weaponIdx != WP_NONE") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( (unsigned int)v4 >= 2 )
  {
    LODWORD(recreateAnimTrees) = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", recreateAnimTrees, 2) )
      __debugbreak();
  }
  v9 = (__int64)&LocalClientGlobals->m_weaponHand[v4];
  if ( !*(_DWORD *)(v9 + 32) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13459, ASSERT_TYPE_ASSERT, "(weapHand->hasAnimTree)", (const char *)&queryFormat, "weapHand->hasAnimTree") )
    __debugbreak();
  if ( !*(_QWORD *)v9 )
  {
    if ( ps->viewmodelIndex <= 0 )
    {
      v14 = BG_UsingAlternate(ps);
      handXModel = BG_WeaponDef(weapon, v14)->handXModel;
    }
    else
    {
      ClConfigStrings = ClConfigStrings::GetClConfigStrings();
      v11 = ClConfigStrings->GetModelString(ClConfigStrings, ps->viewmodelIndex);
      v12 = v11;
      if ( (!v11 || !*v11) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13468, ASSERT_TYPE_ASSERT, "(handModelName && handModelName[0])", (const char *)&queryFormat, "handModelName && handModelName[0]") )
        __debugbreak();
      handXModel = R_RegisterModel(v12);
    }
    CG_Weapon_ChangeViewmodelDobj(localClientNum, ps, weapon, handXModel, 1, 1, 0, 1);
    if ( *(_QWORD *)v9 )
      CG_Gesture_ClearEmptyAnimNodes(*(DObj **)v9);
  }
}

/*
==============
CG_Weapons_PlayAdditiveViewModelAnims
==============
*/
void CG_Weapons_PlayAdditiveViewModelAnims(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex hand, const Weapon *weapon)
{
  const dvar_t *v8; 
  const dvar_t *v9; 
  cg_t *LocalClientGlobals; 
  WeaponHand *ViewModelHand; 

  PlayAdditiveHipIdleAnim(localClientNum, ps, hand, weapon);
  v8 = DCONST_DVARBOOL_cg_viewmodelAdsAnims;
  if ( !DCONST_DVARBOOL_cg_viewmodelAdsAnims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmodelAdsAnims") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v8);
  if ( v8->current.enabled )
  {
    PlayAdditiveADSAnim(localClientNum, ps, hand, weapon);
    PlayAdditiveSwimDragAnims(localClientNum, ps, hand, weapon);
    PlaySwimForwardAnims(localClientNum, ps, hand, weapon);
  }
  CG_GameInterface_PlayAdditiveADSCoverAnims(localClientNum, ps, hand, weapon);
  v9 = DCONST_DVARBOOL_cg_viewmodelAnimatedJumps;
  if ( !DCONST_DVARBOOL_cg_viewmodelAnimatedJumps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmodelAnimatedJumps") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v9);
  if ( v9->current.enabled )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    ViewModelHand = cg_t::GetViewModelHand(LocalClientGlobals, hand);
    if ( !ViewModelHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4281, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
      __debugbreak();
    PlayAdditiveJumpAnim(LocalClientGlobals, ps, hand, ViewModelHand->viewModelDObj);
    PlayAdditiveJumpLandAnim(LocalClientGlobals, ps, hand, ViewModelHand->viewModelDObj);
  }
  PlayAdditiveCrawlAnims(localClientNum, ps, hand, weapon);
  PlayAdditiveProneDropAnim(localClientNum, ps, hand, weapon);
  PlayAdditiveWalkAnim(localClientNum, ps, hand, weapon);
  PlayAdditiveJogAnim(localClientNum, ps, hand, weapon);
  PlayProtoMovementAnim(localClientNum, ps, hand, weapon);
  PlayAdditiveFingerPoseAnims(localClientNum, ps, hand, weapon);
  PlayAdditiveMagazineBulletAnims(localClientNum, ps, hand, weapon);
  PlayAdditiveCosmeticLoopAnim(localClientNum, ps, hand, weapon);
  PlayAdditiveEmptyAnim(localClientNum, ps, hand, weapon);
  PlayAdvancedSwayAnim(localClientNum, ps, hand, weapon);
}

/*
==============
CG_Weapons_PlayDemeanorOffsetAnims
==============
*/
void CG_Weapons_PlayDemeanorOffsetAnims(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex hand, const Weapon *weapon)
{
  __int64 v15; 
  cg_t *LocalClientGlobals; 
  const DObj *viewModelDObj; 
  XAnimTree *Tree; 
  char v20; 
  char v21; 
  bool v22; 
  CgHandler *Handler; 
  bool v27; 
  int weaponState; 
  unsigned int CurrentSlot; 
  unsigned int v33; 
  LocalClientNum_t v34; 
  CgHandler *v45; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float fmtc; 
  float fmtd; 
  float fmte; 
  __int64 goalTime; 
  float goalTimeb; 
  float goalTimea; 
  float goalTimec; 
  float goalTimed; 
  float goalTimee; 
  float goalTimef; 
  __int64 rate; 
  float rateb; 
  float ratea; 
  float ratec; 
  float rated; 
  float ratee; 
  float ratef; 
  char v86; 
  void *retaddr; 
  bool v89; 
  bool v90; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-68h], xmm8
  }
  v15 = hand;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( (unsigned int)v15 >= 2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1207, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v15, 2) )
    __debugbreak();
  viewModelDObj = LocalClientGlobals->m_weaponHand[v15].viewModelDObj;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8567, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8568, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  Tree = DObjGetTree(viewModelDObj);
  if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8571, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
    __debugbreak();
  if ( !Tree->anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8572, ASSERT_TYPE_ASSERT, "(animTree->anims)", (const char *)&queryFormat, "animTree->anims") )
    __debugbreak();
  __asm { vmovaps [rsp+0F8h+var_58], xmm7 }
  *(double *)&_XMM0 = XAnimGetGoalWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x79u);
  __asm
  {
    vxorps  xmm8, xmm8, xmm8
    vcomiss xmm0, xmm8
  }
  v22 = !(v20 | v21);
  __asm { vmovaps xmm6, xmm0 }
  Handler = CgHandler::getHandler(localClientNum);
  if ( BG_ViewModelAnimExists(ps, WEAP_ANIM_ADDITIVE_DEMEANOR_OFFSET_SAFE, (PlayerHandIndex)v15, Handler) )
  {
    v90 = BG_Gesture_FindSlotUsingBlendToLoop(ps) != 2;
    v89 = BG_Gesture_GetAvailableSlotCount(ps) == 0;
    v27 = BG_Demeanor_IsPlaying(ps) && BG_Demeanor_GetTargetState(ps) != DEMEANOR_STATE_RELAXED;
    weaponState = ps->weapState[v15].weaponState;
    if ( (v27 || v90) && weaponState != 9 )
    {
      __asm
      {
        vmovaps [rsp+0F8h+var_78], xmm9
        vmovaps [rsp+0F8h+var_88], xmm10
        vmovaps [rsp+0F8h+var_98], xmm11
      }
      *(double *)&_XMM0 = XAnimGetGoalWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0xEu);
      __asm { vmovaps xmm9, xmm0 }
      *(double *)&_XMM0 = XAnimGetGoalTime(Tree, 0, XANIM_SUBTREE_DEFAULT, 0xEu);
      __asm { vmovss  xmm11, cs:__real@3d4ccccd }
      if ( v27 && v89 && !v90 )
      {
        __asm { vmaxss  xmm10, xmm0, xmm11 }
        CurrentSlot = BG_Demeanor_GetCurrentSlot(ps);
        v33 = CurrentSlot;
        if ( CurrentSlot >= 2 )
        {
          LODWORD(rate) = 2;
          LODWORD(goalTime) = CurrentSlot;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8609, ASSERT_TYPE_ASSERT, "(unsigned)( slot ) < (unsigned)( 2 )", "slot doesn't index GESTURE_NUM_SLOTS\n\t%i not in [0, %i)", goalTime, rate) )
            __debugbreak();
        }
        v34 = localClientNum;
        if ( !CG_Gesture_GetInfo(localClientNum, v33, (PlayerHandIndex)v15) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8612, ASSERT_TYPE_ASSERT, "(info)", (const char *)&queryFormat, "info") )
          __debugbreak();
        __asm
        {
          vmovss  xmm7, cs:__real@3f800000
          vsubss  xmm0, xmm7, dword ptr [r15+34h]; val
          vmovaps xmm2, xmm7; max
          vxorps  xmm1, xmm1, xmm1; min
        }
        *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
        __asm { vmovaps xmm9, xmm0 }
      }
      else
      {
        *(double *)&_XMM0 = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x79u);
        __asm
        {
          vmovss  xmm7, cs:__real@3f800000
          vmovaps xmm6, xmm0
          vsubss  xmm0, xmm7, xmm9; val
          vmovaps xmm2, xmm7; max
          vxorps  xmm1, xmm1, xmm1; min
        }
        *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
        v34 = localClientNum;
        __asm
        {
          vmovaps xmm9, xmm0
          vsubss  xmm0, xmm0, xmm6
          vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
          vmulss  xmm10, xmm0, cs:__real@3e800000
        }
        if ( weaponState == 2 )
        {
          __asm
          {
            vxorps  xmm0, xmm0, xmm0
            vcvtsi2ss xmm0, xmm0, dword ptr [rdi+rbx*8+53Ch]
            vmulss  xmm10, xmm0, cs:__real@3a83126f
          }
        }
      }
      if ( (unsigned int)(ps->weapState[v15].weaponState - 34) <= 2 )
      {
        v45 = CgHandler::getHandler(v34);
        if ( BG_ViewModelAnimExists(ps, WEAP_ANIM_ADDITIVE_SPRINT_OFFSET, (PlayerHandIndex)v15, v45) )
        {
          *(double *)&_XMM0 = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x62u);
          __asm
          {
            vucomiss xmm0, xmm8
            vmovaps xmm6, xmm0
          }
          if ( !v21 )
          {
            __asm
            {
              vsubss  xmm0, xmm7, xmm9; val
              vmovaps xmm2, xmm7; max
              vxorps  xmm1, xmm1, xmm1; min
            }
            *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
            __asm
            {
              vmovss  [rsp+0F8h+rate], xmm7
              vmulss  xmm1, xmm0, xmm6
              vmovss  [rsp+0F8h+goalTime], xmm11
              vmovss  dword ptr [rsp+0F8h+fmt], xmm1
            }
            XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x62u, fmta, goalTimec, ratec, (scr_string_t)0, 0, 0, LINEAR, NULL);
          }
        }
      }
      __asm
      {
        vmovss  [rsp+0F8h+rate], xmm7
        vmovss  [rsp+0F8h+goalTime], xmm10
        vmovss  dword ptr [rsp+0F8h+fmt], xmm9
      }
      XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x79u, fmtb, goalTimed, rated, (scr_string_t)0, 0, 0, LINEAR, NULL);
      __asm
      {
        vmovss  [rsp+0F8h+rate], xmm7
        vmovss  [rsp+0F8h+goalTime], xmm8
        vmovss  dword ptr [rsp+0F8h+fmt], xmm7
      }
      XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x7Au, fmtc, goalTimee, ratee, (scr_string_t)0, 0, 1, LINEAR, NULL);
      __asm
      {
        vmovaps xmm11, [rsp+0F8h+var_98]
        vmovaps xmm10, [rsp+0F8h+var_88]
        vmovaps xmm9, [rsp+0F8h+var_78]
      }
    }
    else if ( v22 )
    {
      __asm { vmovss  xmm7, cs:__real@3d4ccccd }
      if ( weaponState == 9 )
      {
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, dword ptr [rdi+rbx*8+53Ch]
          vmulss  xmm7, xmm0, cs:__real@3a83126f
        }
      }
      else if ( BG_Demeanor_GetTargetState(ps) == DEMEANOR_STATE_NORMAL )
      {
        __asm { vmulss  xmm7, xmm6, cs:__real@3e800000 }
      }
      __asm
      {
        vmovss  xmm6, cs:__real@3f800000
        vmovss  [rsp+0F8h+rate], xmm6
        vmovss  [rsp+0F8h+goalTime], xmm7
        vmovss  dword ptr [rsp+0F8h+fmt], xmm8
      }
      XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x79u, fmtd, goalTimef, ratef, (scr_string_t)0, 0, 0, LINEAR, NULL);
      __asm
      {
        vmovss  [rsp+0F8h+rate], xmm6
        vmovss  [rsp+0F8h+goalTime], xmm7
      }
      goto LABEL_49;
    }
  }
  else if ( v22 )
  {
    __asm
    {
      vmovss  xmm7, cs:__real@3f800000
      vmovss  xmm6, cs:__real@3d4ccccd
      vmovss  [rsp+0F8h+rate], xmm7
      vmovss  [rsp+0F8h+goalTime], xmm6
      vmovss  dword ptr [rsp+0F8h+fmt], xmm8
    }
    XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x79u, fmt, goalTimeb, rateb, (scr_string_t)0, 0, 0, LINEAR, NULL);
    __asm
    {
      vmovss  [rsp+0F8h+rate], xmm7
      vmovss  [rsp+0F8h+goalTime], xmm6
    }
LABEL_49:
    __asm { vmovss  dword ptr [rsp+0F8h+fmt], xmm8 }
    XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x7Au, fmte, goalTimea, ratea, (scr_string_t)0, 0, 0, LINEAR, NULL);
  }
  __asm { vmovaps xmm7, [rsp+0F8h+var_58] }
  _R11 = &v86;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm8, xmmword ptr [r11-30h]
  }
}

/*
==============
CG_Weapons_PlaySkydiveAnims
==============
*/
void CG_Weapons_PlaySkydiveAnims(const LocalClientNum_t localClientNum, const playerState_s *ps, const PlayerHandIndex hand, DObj *obj)
{
  __int64 v12; 
  CgWeaponMap *v17; 
  const Weapon *CurrentWeaponForPlayer; 
  bool v19; 
  int oneHanded; 
  XAnimTree *tree; 
  unsigned int v33; 
  bool v41; 
  const dvar_t *v43; 
  char v46; 
  bool v54; 
  XAnimTree *v58; 
  XAnimTree *v71; 
  signed int animIndex_actual; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float fmtc; 
  float fmtd; 
  float fmte; 
  float fmtf; 
  float fmtg; 
  float fmth; 
  float fmti; 
  float fmtj; 
  float fmtk; 
  float fmtl; 
  __int64 goalTime; 
  float goalTimea; 
  float goalTimeb; 
  float goalTimec; 
  float goalTimed; 
  float goalTimee; 
  float goalTimef; 
  float goalTimeg; 
  float goalTimeh; 
  float goalTimei; 
  float goalTimej; 
  float goalTimek; 
  float goalTimel; 
  float goalTimem; 
  float goalTimen; 
  float goalTimeo; 
  float goalTimep; 
  float goalTimeq; 
  float goalTimer; 
  float goalTimes; 
  float goalTimet; 
  float goalTimeu; 
  float goalTimev; 
  float goalTimew; 
  float goalTimex; 
  float animsa; 
  float anims; 
  float animsb; 
  float animsc; 
  float animsd; 
  float animse; 
  float animsf; 
  float animsg; 
  float animsh; 
  float animsi; 
  float animsj; 
  float animsk; 
  XAnimTree *animTree; 
  XAnimTree *animTreea; 
  bool v152; 
  bool v153; 
  bool IsSuperDiveActive; 
  signed int animIndex_desiredTime; 
  XAnim_s *v156; 

  v12 = localClientNum;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6446, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6447, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  if ( (unsigned int)hand >= NUM_WEAPON_HANDS )
  {
    LODWORD(goalTime) = hand;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6448, ASSERT_TYPE_ASSERT, "(unsigned)( hand ) < (unsigned)( NUM_WEAPON_HANDS )", "hand doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", goalTime, 2) )
      __debugbreak();
  }
  _RBP = CG_GetLocalClientGlobals((const LocalClientNum_t)v12);
  if ( !CgWeaponMap::ms_instance[v12] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v17 = CgWeaponMap::ms_instance[v12];
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(v17, ps);
  v153 = BG_UsingAlternate(ps);
  v19 = v153;
  v152 = BG_PlayerDualWieldingWeapon(v17, ps, CurrentWeaponForPlayer) == 1;
  oneHanded = BG_PlayerDualWieldingWeapon(v17, ps, CurrentWeaponForPlayer);
  v156 = XAnimGetAnims(obj->tree);
  if ( !v156 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6474, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
    __debugbreak();
  __asm
  {
    vmovaps [rsp+118h+var_58], xmm6
    vmovaps [rsp+118h+var_68], xmm7
    vmovaps [rsp+118h+var_78], xmm8
    vmovaps [rsp+118h+var_88], xmm9
    vmovaps [rsp+118h+var_98], xmm10
    vmovaps [rsp+118h+var_A8], xmm11
  }
  switch ( ps->weapState[0].weaponState )
  {
    case '@':
      __asm
      {
        vmovss  xmm0, cs:BLEND_TO_FREEFALL_IDLE_TIME; jumptable 0000000141DF785D case 64
        vmulss  xmm1, xmm0, cs:__real@447a0000
      }
      tree = obj->tree;
      __asm { vcvttss2si eax, xmm1 }
      if ( ps->weapState[0].weaponTime <= _EAX )
      {
        *(double *)&_XMM0 = XAnimGetGoalWeight(tree, 0, XANIM_SUBTREE_DEFAULT, 0xF6u);
        __asm { vucomiss xmm0, cs:__real@3f800000 }
        if ( !v41 )
        {
          __asm
          {
            vxorps  xmm0, xmm0, xmm0
            vcvtsi2ss xmm0, xmm0, dword ptr [rsi+53Ch]
            vmulss  xmm0, xmm0, cs:__real@3a83126f
            vmovss  [rsp+118h+goalTime], xmm0
          }
          CG_Weapons_PlaySkydiveAnims_FreefallIdle(_RBP, ps, hand, obj, 1, goalTimea);
          *(float *)&_XMM0 = CG_Weapons_GetWeaponAnimRate((const LocalClientNum_t)v12, ps, hand, CurrentWeaponForPlayer, v153, v152, v156, WEAP_ANIM_SKYDIVE_RELATIVE_FIRST, WEAP_ANIM_SKYDIVE_RELATIVE_FIRST, oneHanded);
          __asm
          {
            vmovss  dword ptr [rsp+118h+anims], xmm0
            vxorps  xmm1, xmm1, xmm1
            vcvtsi2ss xmm1, xmm1, dword ptr [rsi+53Ch]
            vmulss  xmm2, xmm1, cs:__real@3a83126f
            vxorps  xmm0, xmm0, xmm0
            vmovss  [rsp+118h+goalTime], xmm2
            vmovss  dword ptr [rsp+118h+fmt], xmm0
          }
          XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xF5u, fmt, goalTimeb, animsa, (scr_string_t)0, 0, 0, LINEAR, NULL);
        }
        break;
      }
      *(double *)&_XMM0 = XAnimGetGoalWeight(tree, 0, XANIM_SUBTREE_DEFAULT, 0xF5u);
      __asm
      {
        vmovss  xmm6, cs:__real@3f800000
        vucomiss xmm0, xmm6
      }
      if ( v41 )
        break;
      *(float *)&_XMM0 = CG_Weapons_GetWeaponAnimRate((const LocalClientNum_t)v12, ps, hand, CurrentWeaponForPlayer, v153, v152, v156, WEAP_ANIM_SKYDIVE_RELATIVE_FIRST, WEAP_ANIM_SKYDIVE_RELATIVE_FIRST, oneHanded);
      v33 = 245;
      __asm
      {
        vmovss  dword ptr [rsp+118h+anims], xmm0
        vmovss  xmm0, cs:BLEND_TO_FREEFALL_RAISE_TIME
      }
      goto LABEL_79;
    case 'A':
      *(double *)&_XMM0 = XAnimGetGoalWeight(obj->tree, 0, XANIM_SUBTREE_DEFAULT, 0x100u);
      __asm { vmovaps xmm9, xmm0 }
      *(double *)&_XMM0 = XAnimGetWeight(obj->tree, 0, XANIM_SUBTREE_DEFAULT, 0x100u);
      __asm { vmovaps xmm10, xmm0 }
      *(double *)&_XMM0 = XAnimGetTime(obj->tree, 0, XANIM_SUBTREE_DEFAULT, 0x100u);
      __asm { vmovaps xmm11, xmm0 }
      *(double *)&_XMM0 = XAnimGetWeight(obj->tree, 0, XANIM_SUBTREE_DEFAULT, 0x101u);
      __asm { vmovaps xmm8, xmm0 }
      IsSuperDiveActive = CG_Skydive_IsSuperDiveActive((const LocalClientNum_t)v12);
      CG_Weapons_BlendOutOfRelativeSkydiveAnim((const LocalClientNum_t)v12, ps, hand, obj, CurrentWeaponForPlayer, v19, v152, oneHanded, WEAP_ANIM_SKYDIVE_RELATIVE_FIRST);
      CG_Weapons_BlendOutOfRelativeSkydiveAnim((const LocalClientNum_t)v12, ps, hand, obj, CurrentWeaponForPlayer, v19, v152, oneHanded, WEAP_ANIM_SKYDIVE_OPEN_PARACHUTE);
      CG_Weapons_BlendOutOfRelativeSkydiveAnim((const LocalClientNum_t)v12, ps, hand, obj, CurrentWeaponForPlayer, v19, v152, oneHanded, WEAP_ANIM_SKYDIVE_QUICK_OPEN_PARACHUTE);
      CG_Weapons_BlendOutOfRelativeSkydiveAnim((const LocalClientNum_t)v12, ps, hand, obj, CurrentWeaponForPlayer, v19, v152, oneHanded, WEAP_ANIM_SKYDIVE_PARACHUTE_DETACH);
      __asm
      {
        vmovss  xmm7, cs:__real@3f800000
        vxorps  xmm6, xmm6, xmm6
      }
      v41 = !IsSuperDiveActive;
      if ( !IsSuperDiveActive )
        goto LABEL_28;
      __asm { vcomiss xmm8, xmm6 }
      if ( !IsSuperDiveActive )
      {
        __asm { vucomiss xmm9, xmm7 }
        if ( IsSuperDiveActive )
        {
          *(float *)&_XMM0 = CG_Weapons_GetWeaponAnimRate((const LocalClientNum_t)v12, ps, hand, CurrentWeaponForPlayer, v19, v152, v156, WEAP_ANIM_SKYDIVE_SUPER_DIVE_IN, WEAP_ANIM_SKYDIVE_SUPER_DIVE_IN, oneHanded);
          __asm { vmovaps xmm6, xmm0 }
          *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_cg_skydive_super_dive_in_blend_in_time, "cg_skydive_super_dive_in_blend_in_time");
          __asm
          {
            vmovss  dword ptr [rsp+118h+anims], xmm6
            vmovss  [rsp+118h+goalTime], xmm0
            vmovss  dword ptr [rsp+118h+fmt], xmm7
          }
          XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x100u, fmta, goalTimec, animsb, (scr_string_t)0, 1u, 0, LINEAR, NULL);
          *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_cg_skydive_super_dive_in_blend_in_time, "cg_skydive_super_dive_in_blend_in_time");
          __asm { vmovss  [rsp+118h+goalTime], xmm0 }
          CG_Weapons_PlaySkydiveAnims_FreefallIdle(_RBP, ps, hand, obj, 0, goalTimed);
          break;
        }
      }
      v41 = !IsSuperDiveActive;
      if ( IsSuperDiveActive )
        goto LABEL_32;
LABEL_28:
      __asm { vucomiss xmm8, xmm6 }
      if ( !v41 )
        goto LABEL_32;
      __asm { vucomiss xmm10, xmm7 }
      if ( !v41 )
        goto LABEL_32;
      __asm { vucomiss xmm11, xmm7 }
      if ( v41 )
      {
        *(float *)&_XMM0 = CG_Weapons_GetWeaponAnimRate((const LocalClientNum_t)v12, ps, hand, CurrentWeaponForPlayer, v19, v152, v156, WEAP_ANIM_SKYDIVE_SUPER_DIVE_IN, WEAP_ANIM_SKYDIVE_SUPER_DIVE_IN, oneHanded);
        __asm
        {
          vmovss  dword ptr [rsp+118h+anims], xmm0
          vmovss  [rsp+118h+goalTime], xmm6
          vmovss  dword ptr [rsp+118h+fmt], xmm6
        }
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x100u, fmtb, goalTimee, animsc, (scr_string_t)0, 0, 0, LINEAR, NULL);
        *(float *)&_XMM0 = CG_Weapons_GetWeaponAnimRate((const LocalClientNum_t)v12, ps, hand, CurrentWeaponForPlayer, v19, v152, v156, WEAP_ANIM_SKYDIVE_SUPER_DIVE_OUT, WEAP_ANIM_SKYDIVE_SUPER_DIVE_OUT, oneHanded);
        __asm
        {
          vmovss  dword ptr [rsp+118h+anims], xmm0
          vmovss  [rsp+118h+goalTime], xmm6
          vmovss  dword ptr [rsp+118h+fmt], xmm7
        }
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x101u, fmtc, goalTimef, animsd, (scr_string_t)0, 1u, 0, LINEAR, NULL);
      }
      else
      {
LABEL_32:
        animTree = obj->tree;
        *(double *)&_XMM0 = XAnimGetGoalWeight(obj->tree, 0, XANIM_SUBTREE_DEFAULT, 0x101u);
        __asm { vucomiss xmm0, xmm6 }
        if ( v41 )
          goto LABEL_86;
        *(float *)&_XMM0 = CG_GetWeaponAnimTimeRemaining(animTree, WEAP_ANIM_SKYDIVE_SUPER_DIVE_OUT);
        v43 = DCONST_DVARFLT_cg_skydive_super_dive_out_blend_out_time;
        animTreea = (XAnimTree *)DCONST_DVARFLT_cg_skydive_super_dive_out_blend_out_time;
        __asm { vmovaps xmm8, xmm0 }
        if ( !DCONST_DVARFLT_cg_skydive_super_dive_out_blend_out_time )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_super_dive_out_blend_out_time") )
            __debugbreak();
          v43 = (const dvar_t *)animTreea;
        }
        Dvar_CheckFrontendServerThread(v43);
        _RAX = animTreea;
        __asm { vcomiss xmm8, dword ptr [rax+28h] }
        if ( !(v46 | v41) )
        {
LABEL_86:
          if ( IsSuperDiveActive )
            goto LABEL_45;
          *(double *)&_XMM0 = XAnimGetGoalWeight(obj->tree, 0, XANIM_SUBTREE_DEFAULT, 0xF6u);
          __asm { vucomiss xmm0, xmm7 }
          if ( v41 )
          {
LABEL_45:
            __asm { vmovaps xmm3, xmm7; goalWeight }
            *(float *)&_XMM0 = CG_Weapons_GetAnxietyWeight(_RBP, ps, obj->tree, *(double *)&_XMM3);
            __asm
            {
              vmovss  xmm1, cs:BLEND_TO_FREEFALL_RAISE_TIME
              vmovss  dword ptr [rsp+118h+anims], xmm7
              vmovss  [rsp+118h+goalTime], xmm1
              vmovss  dword ptr [rsp+118h+fmt], xmm0
            }
            XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xCDu, fmte, goalTimej, animsf, (scr_string_t)0, 0, 0, LINEAR, NULL);
            *(double *)&_XMM0 = XAnimGetWeight(obj->tree, 0, XANIM_SUBTREE_DEFAULT, 0xC6u);
            __asm
            {
              vcomiss xmm0, xmm6
              vmovaps xmm7, xmm0
            }
            if ( !(v46 | v41) )
            {
              *(double *)&_XMM0 = XAnimGetGoalTime(obj->tree, 0, XANIM_SUBTREE_DEFAULT, 0xC6u);
              __asm
              {
                vmovss  xmm1, dword ptr [rbp+0BA178h]
                vmulss  xmm2, xmm7, dword ptr [rbp+0BA174h]
                vmovss  dword ptr [rsp+118h+anims], xmm1
                vmovss  [rsp+118h+goalTime], xmm0
                vmovss  dword ptr [rsp+118h+fmt], xmm2
              }
              XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xCCu, fmtf, goalTimek, animsg, (scr_string_t)0, 0, 0, LINEAR, NULL);
            }
          }
          else
          {
            __asm
            {
              vmovss  xmm0, cs:BLEND_TO_FREEFALL_IDLE_UNEXPECTED
              vmovss  [rsp+118h+goalTime], xmm0
            }
            CG_Weapons_PlaySkydiveAnims_FreefallIdle(_RBP, ps, hand, obj, 1, goalTimei);
          }
        }
        else
        {
          *(float *)&_XMM0 = CG_GetWeaponAnimTimeRemaining(obj->tree, WEAP_ANIM_SKYDIVE_SUPER_DIVE_OUT);
          __asm
          {
            vcomiss xmm0, xmm6
            vmovaps xmm7, xmm0
          }
          if ( v46 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6544, ASSERT_TYPE_ASSERT, "(timeRemaining >= 0.0f)", (const char *)&queryFormat, "timeRemaining >= 0.0f") )
            __debugbreak();
          *(float *)&_XMM0 = CG_Weapons_GetWeaponAnimRate((const LocalClientNum_t)v12, ps, hand, CurrentWeaponForPlayer, v19, v152, v156, WEAP_ANIM_SKYDIVE_SUPER_DIVE_OUT, WEAP_ANIM_SKYDIVE_SUPER_DIVE_OUT, oneHanded);
          __asm
          {
            vmovss  dword ptr [rsp+118h+anims], xmm0
            vmovss  [rsp+118h+goalTime], xmm7
            vmovss  dword ptr [rsp+118h+fmt], xmm6
          }
          XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x101u, fmtd, goalTimeg, animse, (scr_string_t)0, 0, 0, LINEAR, NULL);
          __asm { vmovss  [rsp+118h+goalTime], xmm7 }
          CG_Weapons_PlaySkydiveAnims_FreefallIdle(_RBP, ps, hand, obj, 1, goalTimeh);
        }
      }
      break;
    case 'B':
      CG_Weapons_BlendOutOfRelativeSkydiveAnim((const LocalClientNum_t)v12, ps, hand, obj, CurrentWeaponForPlayer, v153, v152, oneHanded, WEAP_ANIM_SKYDIVE_RELATIVE_FIRST);
      CG_Weapons_BlendOutOfRelativeSkydiveAnim((const LocalClientNum_t)v12, ps, hand, obj, CurrentWeaponForPlayer, v153, v152, oneHanded, WEAP_ANIM_SKYDIVE_SUPER_DIVE_IN);
      CG_Weapons_BlendOutOfRelativeSkydiveAnim((const LocalClientNum_t)v12, ps, hand, obj, CurrentWeaponForPlayer, v153, v152, oneHanded, WEAP_ANIM_SKYDIVE_SUPER_DIVE_OUT);
      v54 = GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 0x34u);
      __asm
      {
        vmovss  xmm0, cs:BLEND_TO_PARACHUTE_IDLE_TIME
        vmulss  xmm1, xmm0, cs:__real@447a0000
      }
      v41 = !v54;
      __asm { vcvttss2si eax, xmm1 }
      animIndex_desiredTime = !v41 + 248;
      v58 = obj->tree;
      if ( ps->weapState[0].weaponTime > _EAX )
      {
        *(double *)&_XMM0 = XAnimGetGoalWeight(v58, 0, XANIM_SUBTREE_DEFAULT, 0xF6u);
        __asm
        {
          vxorps  xmm6, xmm6, xmm6
          vucomiss xmm0, xmm6
        }
        if ( !v41 )
        {
          __asm
          {
            vmovss  xmm0, cs:BLEND_OUT_FREEFALL_IDLE_TIME
            vmovss  [rsp+118h+goalTime], xmm0
          }
          CG_Weapons_PlaySkydiveAnims_FreefallIdle(_RBP, ps, hand, obj, 0, goalTimen);
        }
        *(double *)&_XMM0 = XAnimGetGoalWeight(obj->tree, 0, XANIM_SUBTREE_DEFAULT, 0x100u);
        __asm { vucomiss xmm0, xmm6 }
        if ( !v41 )
        {
          *(float *)&_XMM0 = CG_Weapons_GetWeaponAnimRate((const LocalClientNum_t)v12, ps, hand, CurrentWeaponForPlayer, v19, v152, v156, WEAP_ANIM_SKYDIVE_SUPER_DIVE_IN, WEAP_ANIM_SKYDIVE_SUPER_DIVE_IN, oneHanded);
          __asm
          {
            vmovss  dword ptr [rsp+118h+anims], xmm0
            vmovss  xmm0, cs:BLEND_OUT_FREEFALL_IDLE_TIME
            vmovss  [rsp+118h+goalTime], xmm0
            vmovss  dword ptr [rsp+118h+fmt], xmm6
          }
          XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x100u, fmth, goalTimeo, animsi, (scr_string_t)0, 0, 0, LINEAR, NULL);
        }
        *(double *)&_XMM0 = XAnimGetGoalWeight(obj->tree, 0, XANIM_SUBTREE_DEFAULT, 0x101u);
        __asm { vucomiss xmm0, xmm6 }
        if ( !v41 )
        {
          *(float *)&_XMM0 = CG_Weapons_GetWeaponAnimRate((const LocalClientNum_t)v12, ps, hand, CurrentWeaponForPlayer, v19, v152, v156, WEAP_ANIM_SKYDIVE_SUPER_DIVE_OUT, WEAP_ANIM_SKYDIVE_SUPER_DIVE_OUT, oneHanded);
          __asm
          {
            vmovss  dword ptr [rsp+118h+anims], xmm0
            vmovss  xmm0, cs:BLEND_OUT_FREEFALL_IDLE_TIME
            vmovss  [rsp+118h+goalTime], xmm0
            vmovss  dword ptr [rsp+118h+fmt], xmm6
          }
          XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x101u, fmti, goalTimep, animsj, (scr_string_t)0, 0, 0, LINEAR, NULL);
        }
        *(double *)&_XMM0 = XAnimGetGoalWeight(obj->tree, 0, XANIM_SUBTREE_DEFAULT, animIndex_desiredTime);
        __asm
        {
          vmovss  xmm6, cs:__real@3f800000
          vucomiss xmm0, xmm6
        }
        if ( !v41 )
        {
          *(float *)&_XMM0 = CG_Weapons_GetWeaponAnimRate((const LocalClientNum_t)v12, ps, hand, CurrentWeaponForPlayer, v19, v152, v156, (weapAnimFiles_t)animIndex_desiredTime, (weapAnimFiles_t)animIndex_desiredTime, oneHanded);
          v33 = animIndex_desiredTime;
          __asm
          {
            vmovss  dword ptr [rsp+118h+anims], xmm0
            vmovss  xmm0, cs:BLEND_OUT_FREEFALL_IDLE_TIME
          }
          goto LABEL_79;
        }
      }
      else
      {
        *(double *)&_XMM0 = XAnimGetGoalWeight(v58, 0, XANIM_SUBTREE_DEFAULT, 0xFAu);
        __asm { vucomiss xmm0, cs:__real@3f800000 }
        if ( !v41 )
        {
          __asm
          {
            vxorps  xmm0, xmm0, xmm0
            vcvtsi2ss xmm0, xmm0, dword ptr [rsi+53Ch]
            vmulss  xmm0, xmm0, cs:__real@3a83126f
            vmovss  [rsp+118h+goalTime], xmm0
          }
          CG_Weapons_PlaySkydiveAnims_ParachuteIdle(_RBP, ps, hand, obj, 1, goalTimel);
          *(float *)&_XMM0 = CG_Weapons_GetWeaponAnimRate((const LocalClientNum_t)v12, ps, hand, CurrentWeaponForPlayer, v19, v152, v156, (weapAnimFiles_t)animIndex_desiredTime, (weapAnimFiles_t)animIndex_desiredTime, oneHanded);
          __asm
          {
            vmovss  dword ptr [rsp+118h+anims], xmm0
            vxorps  xmm1, xmm1, xmm1
            vcvtsi2ss xmm1, xmm1, dword ptr [rsi+53Ch]
            vmulss  xmm2, xmm1, cs:__real@3a83126f
            vxorps  xmm0, xmm0, xmm0
            vmovss  [rsp+118h+goalTime], xmm2
            vmovss  dword ptr [rsp+118h+fmt], xmm0
          }
          XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, animIndex_desiredTime, fmtg, goalTimem, animsh, (scr_string_t)0, 0, 0, LINEAR, NULL);
        }
      }
      break;
    case 'C':
      CG_Weapons_BlendOutOfRelativeSkydiveAnim((const LocalClientNum_t)v12, ps, hand, obj, CurrentWeaponForPlayer, v153, v152, oneHanded, WEAP_ANIM_SKYDIVE_RELATIVE_FIRST);
      CG_Weapons_BlendOutOfRelativeSkydiveAnim((const LocalClientNum_t)v12, ps, hand, obj, CurrentWeaponForPlayer, v153, v152, oneHanded, WEAP_ANIM_SKYDIVE_OPEN_PARACHUTE);
      CG_Weapons_BlendOutOfRelativeSkydiveAnim((const LocalClientNum_t)v12, ps, hand, obj, CurrentWeaponForPlayer, v153, v152, oneHanded, WEAP_ANIM_SKYDIVE_QUICK_OPEN_PARACHUTE);
      CG_Weapons_BlendOutOfRelativeSkydiveAnim((const LocalClientNum_t)v12, ps, hand, obj, CurrentWeaponForPlayer, v153, v152, oneHanded, WEAP_ANIM_SKYDIVE_PARACHUTE_DETACH);
      CG_Weapons_BlendOutOfRelativeSkydiveAnim((const LocalClientNum_t)v12, ps, hand, obj, CurrentWeaponForPlayer, v153, v152, oneHanded, WEAP_ANIM_SKYDIVE_SUPER_DIVE_IN);
      CG_Weapons_BlendOutOfRelativeSkydiveAnim((const LocalClientNum_t)v12, ps, hand, obj, CurrentWeaponForPlayer, v153, v152, oneHanded, WEAP_ANIM_SKYDIVE_SUPER_DIVE_OUT);
      __asm
      {
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm0, xmm0, dword ptr [rsi+53Ch]
        vmulss  xmm1, xmm0, cs:__real@3a83126f
        vmovss  [rsp+118h+goalTime], xmm1
      }
      CG_Weapons_PlaySkydiveAnims_ParachuteIdle(_RBP, ps, hand, obj, 1, goalTimev);
      break;
    case 'D':
      animIndex_actual = 251;
      goto LABEL_75;
    case 'E':
      animIndex_actual = 252;
      goto LABEL_75;
    case 'F':
      animIndex_actual = 253;
      goto LABEL_75;
    case 'G':
      animIndex_actual = 254;
      goto LABEL_75;
    case 'H':
      animIndex_actual = 255;
LABEL_75:
      *(double *)&_XMM0 = XAnimGetGoalWeight(obj->tree, 0, XANIM_SUBTREE_DEFAULT, 0xFAu);
      __asm
      {
        vxorps  xmm1, xmm1, xmm1
        vucomiss xmm0, xmm1
      }
      if ( !v41 )
      {
        __asm
        {
          vmovss  xmm0, cs:BLEND_OUT_PARACHUTE_IDLE_TIME
          vmovss  [rsp+118h+goalTime], xmm0
        }
        CG_Weapons_PlaySkydiveAnims_ParachuteIdle(_RBP, ps, hand, obj, 0, goalTimew);
      }
      *(double *)&_XMM0 = XAnimGetGoalWeight(obj->tree, 0, XANIM_SUBTREE_DEFAULT, animIndex_actual);
      __asm
      {
        vmovss  xmm6, cs:__real@3f800000
        vucomiss xmm0, xmm6
      }
      if ( v41 )
        break;
      *(float *)&_XMM0 = CG_Weapons_GetWeaponAnimRate((const LocalClientNum_t)v12, ps, hand, CurrentWeaponForPlayer, v153, v152, v156, (weapAnimFiles_t)animIndex_actual, (weapAnimFiles_t)animIndex_actual, oneHanded);
      v33 = animIndex_actual;
      __asm
      {
        vmovss  dword ptr [rsp+118h+anims], xmm0
        vmovss  xmm0, cs:BLEND_OUT_PARACHUTE_IDLE_TIME
      }
      goto LABEL_79;
    case 'J':
      *(double *)&_XMM0 = XAnimGetGoalWeight(obj->tree, 0, XANIM_SUBTREE_DEFAULT, 0xFAu);
      __asm
      {
        vxorps  xmm7, xmm7, xmm7
        vucomiss xmm0, xmm7
      }
      if ( !v41 )
      {
        __asm
        {
          vmovss  xmm0, cs:BLEND_OUT_PARACHUTE_IDLE_TIME
          vmovss  [rsp+118h+goalTime], xmm0
        }
        CG_Weapons_PlaySkydiveAnims_ParachuteIdle(_RBP, ps, hand, obj, 0, goalTimeq);
      }
      if ( (ps->skydivePlayerState.flagsExtra[0] & 0x10) != 0 )
        goto LABEL_68;
      __asm
      {
        vmovss  xmm0, cs:BLEND_TO_FREEFALL_IDLE_CUT_TIME
        vmulss  xmm1, xmm0, cs:__real@447a0000
      }
      v71 = obj->tree;
      __asm { vcvttss2si eax, xmm1 }
      if ( ps->weapState[0].weaponTime > _EAX )
      {
        *(double *)&_XMM0 = XAnimGetGoalWeight(v71, 0, XANIM_SUBTREE_DEFAULT, 0x102u);
        __asm
        {
          vmovss  xmm6, cs:__real@3f800000
          vucomiss xmm0, xmm6
        }
        if ( !v41 )
        {
          *(float *)&_XMM0 = CG_Weapons_GetWeaponAnimRate((const LocalClientNum_t)v12, ps, hand, CurrentWeaponForPlayer, v153, v152, v156, WEAP_ANIM_SKYDIVE_PARACHUTE_DETACH, WEAP_ANIM_SKYDIVE_PARACHUTE_DETACH, oneHanded);
          v33 = 258;
          __asm
          {
            vmovss  dword ptr [rsp+118h+anims], xmm0
            vmovss  xmm0, cs:BLEND_TO_FREEFALL_RAISE_TIME
          }
LABEL_79:
          __asm
          {
            vmovss  [rsp+118h+goalTime], xmm0
            vmovss  dword ptr [rsp+118h+fmt], xmm6
          }
          XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, v33, fmtk, goalTimex, anims, (scr_string_t)0, 1u, 0, LINEAR, NULL);
        }
      }
      else
      {
        *(double *)&_XMM0 = XAnimGetGoalWeight(v71, 0, XANIM_SUBTREE_DEFAULT, 0xF6u);
        __asm { vucomiss xmm0, cs:__real@3f800000 }
        if ( !v41 )
        {
          __asm
          {
            vxorps  xmm0, xmm0, xmm0
            vcvtsi2ss xmm0, xmm0, dword ptr [rsi+53Ch]
            vmulss  xmm0, xmm0, cs:__real@3a83126f
            vmovss  [rsp+118h+goalTime], xmm0
          }
          CG_Weapons_PlaySkydiveAnims_FreefallIdle(_RBP, ps, hand, obj, 1, goalTimer);
          *(float *)&_XMM0 = CG_Weapons_GetWeaponAnimRate((const LocalClientNum_t)v12, ps, hand, CurrentWeaponForPlayer, v153, v152, v156, WEAP_ANIM_SKYDIVE_PARACHUTE_DETACH, WEAP_ANIM_SKYDIVE_PARACHUTE_DETACH, oneHanded);
          __asm
          {
            vmovss  dword ptr [rsp+118h+anims], xmm0
            vxorps  xmm1, xmm1, xmm1
            vcvtsi2ss xmm1, xmm1, dword ptr [rsi+53Ch]
            vmulss  xmm2, xmm1, cs:__real@3a83126f
            vmovss  [rsp+118h+goalTime], xmm2
            vmovss  dword ptr [rsp+118h+fmt], xmm7
          }
          XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x102u, fmtj, goalTimes, animsk, (scr_string_t)0, 0, 0, LINEAR, NULL);
        }
      }
      break;
    case 'K':
      *(double *)&_XMM0 = XAnimGetGoalWeight(obj->tree, 0, XANIM_SUBTREE_DEFAULT, 0xFAu);
      __asm
      {
        vxorps  xmm1, xmm1, xmm1
        vucomiss xmm0, xmm1
      }
      if ( !v41 )
      {
        __asm
        {
          vmovss  xmm0, cs:BLEND_OUT_PARACHUTE_IDLE_TIME
          vmovss  [rsp+118h+goalTime], xmm0
        }
        CG_Weapons_PlaySkydiveAnims_ParachuteIdle(_RBP, ps, hand, obj, 0, goalTimet);
      }
LABEL_68:
      __asm
      {
        vmovss  xmm0, cs:BLEND_TO_WEAPON_RAISE_TIME
        vmovss  [rsp+118h+goalTime], xmm0
      }
      CG_Weapons_PlaySkydiveAnims_WeaponRaiseDetach((const LocalClientNum_t)v12, _RBP, ps, hand, obj, goalTimeu, WEAP_ANIM_SKYDIVE_PARACHUTE_MID_AIR_DETACH);
      break;
    default:
      CG_Weapons_ResetSkydiveAnimationParameters((const LocalClientNum_t)v12, ps, obj);
      CG_Weapons_ResetSkydiveAnimationParameters((const LocalClientNum_t)v12, ps, obj);
      if ( !_RBP->skydiveClientState.animState.blendedOutOfSkydiveAnims )
      {
        __asm { vmovss  xmm0, cs:BLEND_OUT_ALL_TIME }
        _RBP->skydiveClientState.animState.blendedOutOfSkydiveAnims = 1;
        __asm { vmovss  dword ptr [rsp+118h+fmt], xmm0 }
        CG_Weapons_PlaySkydiveAnims_BlendOutAll(_RBP, ps, hand, obj, fmtl);
      }
      goto LABEL_83;
  }
  _RBP->skydiveClientState.animState.blendedOutOfSkydiveAnims = 0;
  CG_Weapons_SetSkydiveAnimationParameters((const LocalClientNum_t)_RBP->localClientNum, ps, obj);
LABEL_83:
  __asm
  {
    vmovaps xmm11, [rsp+118h+var_A8]
    vmovaps xmm10, [rsp+118h+var_98]
    vmovaps xmm9, [rsp+118h+var_88]
    vmovaps xmm8, [rsp+118h+var_78]
    vmovaps xmm7, [rsp+118h+var_68]
    vmovaps xmm6, [rsp+118h+var_58]
  }
}

/*
==============
CG_Weapons_PlaySkydiveAnims_BlendOutAll
==============
*/
void CG_Weapons_PlaySkydiveAnims_BlendOutAll(const cg_t *cgameGlob, const playerState_s *ps, const PlayerHandIndex hand, DObj *obj, const float goalTime)
{
  float v17; 
  float v18; 
  float v19; 
  float v20; 
  float v21; 
  float v22; 
  float v23; 
  float v24; 
  float v25; 
  float v26; 
  float v27; 
  float v28; 
  float v29; 
  float v30; 
  float v31; 
  float v32; 
  float v33; 
  float v34; 
  float v35; 
  float v36; 
  float v37; 
  float v38; 
  float v39; 
  float v40; 
  float v41; 
  float v42; 
  float v43; 
  float v44; 
  float v45; 
  float v46; 
  float v47; 
  float v48; 
  float v49; 
  float v50; 
  float v51; 
  float v52; 
  float v53; 
  float v54; 
  float v55; 
  float v56; 
  float v57; 
  float v58; 
  float v59; 
  float v60; 
  float v61; 
  float v62; 
  float v63; 
  float v64; 
  float v65; 
  float v66; 
  float v67; 
  float v68; 
  float v69; 
  float v70; 
  float v71; 
  float v72; 
  float v73; 
  float v74; 
  float v75; 
  float v76; 
  float v77; 
  float v78; 
  float v79; 
  float v80; 
  float v81; 
  float v82; 
  float v83; 
  float v84; 
  float v85; 
  float v86; 
  float v87; 
  float v88; 
  float v89; 
  float v90; 
  float v91; 
  float v92; 
  float v93; 
  float v94; 
  float v95; 
  float v96; 
  float v97; 
  float v98; 
  float v99; 
  float v100; 
  float v101; 
  float v102; 
  float v103; 
  float v104; 
  float v105; 
  float v106; 
  float v107; 
  float v108; 
  float v109; 
  float v110; 
  float v111; 
  float v112; 
  float v113; 
  float v114; 
  float v115; 
  float v116; 
  float v117; 
  float v118; 
  float v119; 
  float v120; 
  float v121; 
  float v122; 
  float v123; 
  float v124; 
  float v125; 
  float v126; 
  float v127; 
  float v128; 
  float v129; 
  float v130; 
  char v132; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-18h], xmm6
    vmovaps xmmword ptr [rax-28h], xmm7
    vmovss  xmm7, [rsp+98h+goalTime]
    vmovaps xmmword ptr [rax-38h], xmm8
    vxorps  xmm8, xmm8, xmm8
    vmovss  dword ptr [rax-68h], xmm8
    vmovss  dword ptr [rax-70h], xmm7
    vmovss  dword ptr [rax-78h], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xF5u, v17, v55, v93, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+98h+var_68], xmm8
    vmovss  [rsp+98h+var_70], xmm7
    vmovss  [rsp+98h+var_78], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xF6u, v18, v56, v94, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+98h+var_68], xmm8
    vmovss  [rsp+98h+var_70], xmm7
    vmovss  [rsp+98h+var_78], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xF7u, v19, v57, v95, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+98h+var_68], xmm8
    vmovss  [rsp+98h+var_70], xmm7
    vmovss  [rsp+98h+var_78], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xF8u, v20, v58, v96, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+98h+var_68], xmm8
    vmovss  [rsp+98h+var_70], xmm7
    vmovss  [rsp+98h+var_78], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xF9u, v21, v59, v97, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+98h+var_68], xmm8
    vmovss  [rsp+98h+var_70], xmm7
    vmovss  [rsp+98h+var_78], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xFAu, v22, v60, v98, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+98h+var_68], xmm8
    vmovss  [rsp+98h+var_70], xmm7
    vmovss  [rsp+98h+var_78], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xFBu, v23, v61, v99, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+98h+var_68], xmm8
    vmovss  [rsp+98h+var_70], xmm7
    vmovss  [rsp+98h+var_78], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xFCu, v24, v62, v100, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+98h+var_68], xmm8
    vmovss  [rsp+98h+var_70], xmm7
    vmovss  [rsp+98h+var_78], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xFDu, v25, v63, v101, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+98h+var_68], xmm8
    vmovss  [rsp+98h+var_70], xmm7
    vmovss  [rsp+98h+var_78], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xFEu, v26, v64, v102, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+98h+var_68], xmm8
    vmovss  [rsp+98h+var_70], xmm7
    vmovss  [rsp+98h+var_78], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xFFu, v27, v65, v103, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+98h+var_68], xmm8
    vmovss  [rsp+98h+var_70], xmm7
    vmovss  [rsp+98h+var_78], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x100u, v28, v66, v104, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+98h+var_68], xmm8
    vmovss  [rsp+98h+var_70], xmm7
    vmovss  [rsp+98h+var_78], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x101u, v29, v67, v105, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+98h+var_68], xmm8
    vmovss  [rsp+98h+var_70], xmm7
    vmovss  [rsp+98h+var_78], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x102u, v30, v68, v106, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  xmm6, cs:__real@3f800000
    vmovss  [rsp+98h+var_68], xmm6
    vmovss  [rsp+98h+var_70], xmm7
    vmovss  [rsp+98h+var_78], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xC5u, v31, v69, v107, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+98h+var_68], xmm6
    vmovss  [rsp+98h+var_70], xmm7
    vmovss  [rsp+98h+var_78], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xC6u, v32, v70, v108, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+98h+var_68], xmm6
    vmovss  [rsp+98h+var_70], xmm7
    vmovss  [rsp+98h+var_78], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xC8u, v33, v71, v109, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+98h+var_68], xmm6
    vmovss  [rsp+98h+var_70], xmm7
    vmovss  [rsp+98h+var_78], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xCEu, v34, v72, v110, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+98h+var_68], xmm6
    vmovss  [rsp+98h+var_70], xmm7
    vmovss  [rsp+98h+var_78], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xC9u, v35, v73, v111, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+98h+var_68], xmm6
    vmovss  [rsp+98h+var_70], xmm7
    vmovss  [rsp+98h+var_78], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xD2u, v36, v74, v112, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+98h+var_68], xmm6
    vmovss  [rsp+98h+var_70], xmm7
    vmovss  [rsp+98h+var_78], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xCAu, v37, v75, v113, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+98h+var_68], xmm6
    vmovss  [rsp+98h+var_70], xmm7
    vmovss  [rsp+98h+var_78], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xD6u, v38, v76, v114, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+98h+var_68], xmm6
    vmovss  [rsp+98h+var_70], xmm7
    vmovss  [rsp+98h+var_78], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xCBu, v39, v77, v115, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+98h+var_68], xmm6
    vmovss  [rsp+98h+var_70], xmm7
    vmovss  [rsp+98h+var_78], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xDAu, v40, v78, v116, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+98h+var_68], xmm6
    vmovss  [rsp+98h+var_70], xmm7
    vmovss  [rsp+98h+var_78], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xCCu, v41, v79, v117, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+98h+var_68], xmm6
    vmovss  [rsp+98h+var_70], xmm7
    vmovss  [rsp+98h+var_78], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xCDu, v42, v80, v118, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+98h+var_68], xmm6
    vmovss  [rsp+98h+var_70], xmm7
    vmovss  [rsp+98h+var_78], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xC7u, v43, v81, v119, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+98h+var_68], xmm6
    vmovss  [rsp+98h+var_70], xmm7
    vmovss  [rsp+98h+var_78], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xE1u, v44, v82, v120, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+98h+var_68], xmm6
    vmovss  [rsp+98h+var_70], xmm7
    vmovss  [rsp+98h+var_78], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xE7u, v45, v83, v121, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+98h+var_68], xmm6
    vmovss  [rsp+98h+var_70], xmm7
    vmovss  [rsp+98h+var_78], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xE2u, v46, v84, v122, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+98h+var_68], xmm6
    vmovss  [rsp+98h+var_70], xmm7
    vmovss  [rsp+98h+var_78], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xE8u, v47, v85, v123, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+98h+var_68], xmm6
    vmovss  [rsp+98h+var_70], xmm7
    vmovss  [rsp+98h+var_78], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xE3u, v48, v86, v124, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+98h+var_68], xmm6
    vmovss  [rsp+98h+var_70], xmm7
    vmovss  [rsp+98h+var_78], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xE9u, v49, v87, v125, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+98h+var_68], xmm6
    vmovss  [rsp+98h+var_70], xmm7
    vmovss  [rsp+98h+var_78], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xE4u, v50, v88, v126, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+98h+var_68], xmm6
    vmovss  [rsp+98h+var_70], xmm7
    vmovss  [rsp+98h+var_78], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xEAu, v51, v89, v127, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+98h+var_68], xmm6
    vmovss  [rsp+98h+var_70], xmm7
    vmovss  [rsp+98h+var_78], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xE6u, v52, v90, v128, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+98h+var_68], xmm6
    vmovss  [rsp+98h+var_70], xmm7
    vmovss  [rsp+98h+var_78], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xE5u, v53, v91, v129, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+98h+var_68], xmm6
    vmovss  [rsp+98h+var_70], xmm7
    vmovss  [rsp+98h+var_78], xmm8
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xEBu, v54, v92, v130, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm { vmovaps xmm7, [rsp+98h+var_28] }
  _R11 = &v132;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm8, xmmword ptr [r11-30h]
  }
}

/*
==============
CG_Weapons_PlaySkydiveAnims_FreefallIdle
==============
*/
void CG_Weapons_PlaySkydiveAnims_FreefallIdle(const cg_t *cgameGlob, const playerState_s *ps, const PlayerHandIndex hand, DObj *obj, const bool blendIn, const float goalTime)
{
  char v27; 
  const dvar_t *v33; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float fmtc; 
  float fmtd; 
  float fmte; 
  float fmtf; 
  float fmtg; 
  float fmth; 
  float fmti; 
  float fmtj; 
  float fmtk; 
  float fmtl; 
  float fmtm; 
  float v64; 
  float v65; 
  float v66; 
  float v67; 
  float v68; 
  float v69; 
  float v70; 
  float v71; 
  float v72; 
  float v73; 
  float v74; 
  float v75; 
  float v76; 
  float v77; 
  float rate; 
  float ratea; 
  float rateb; 
  float ratec; 
  float rated; 
  float ratee; 
  float ratef; 
  float rateg; 
  float rateh; 
  float ratei; 
  float ratej; 
  float ratek; 
  float ratel; 
  float ratem; 
  char v94; 
  void *retaddr; 

  _RAX = &retaddr;
  _EBX = blendIn;
  _ER14 = 0;
  __asm
  {
    vmovaps xmmword ptr [rax-28h], xmm6
    vmovaps xmmword ptr [rax-38h], xmm7
    vmovss  xmm7, cs:__real@3f800000
  }
  _RBP = cgameGlob;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm8
    vmovss  xmm8, [rsp+0F8h+goalTime]
    vmovaps xmmword ptr [rax-58h], xmm9
    vmovaps xmmword ptr [rax-68h], xmm10
    vmovaps xmmword ptr [rax-78h], xmm11
    vmovd   xmm1, r14d
    vmovaps [rsp+0F8h+var_88], xmm12
    vmovaps [rsp+0F8h+var_98], xmm13
    vmovd   xmm0, ebx
    vpcmpeqd xmm2, xmm0, xmm1
    vmovss  [rsp+0F8h+rate], xmm7
    vxorps  xmm9, xmm9, xmm9
    vblendvps xmm6, xmm7, xmm9, xmm2
    vmovss  [rsp+0F8h+var_D0], xmm8
    vmovss  dword ptr [rsp+0F8h+fmt], xmm6
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xC6u, fmt, v64, rate, (scr_string_t)0, 0, 0, LINEAR, NULL);
  if ( blendIn )
  {
    *(double *)&_XMM0 = XAnimGetGoalWeight(obj->tree, 0, XANIM_SUBTREE_DEFAULT, 0xC5u);
    __asm { vucomiss xmm0, xmm7 }
    if ( !v27 )
    {
      __asm
      {
        vmovss  [rsp+0F8h+rate], xmm7
        vmovss  [rsp+0F8h+var_D0], xmm8
        vmovss  dword ptr [rsp+0F8h+fmt], xmm7
      }
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xC5u, fmta, v65, ratea, (scr_string_t)0, 0, 0, LINEAR, NULL);
    }
  }
  __asm
  {
    vmovss  [rsp+0F8h+rate], xmm9
    vmovss  [rsp+0F8h+var_D0], xmm8
    vmovss  dword ptr [rsp+0F8h+fmt], xmm6
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xF6u, fmtb, v66, rateb, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+0F8h+rate], xmm9
    vmovss  [rsp+0F8h+var_D0], xmm8
    vmovss  dword ptr [rsp+0F8h+fmt], xmm6
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xF7u, fmtc, v67, ratec, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmulss  xmm9, xmm6, dword ptr [rbp+0BA174h]
    vmovaps xmm3, xmm6; goalWeight
    vmovaps xmm12, xmm6
    vmovaps xmm11, xmm6
    vmovaps xmm10, xmm6
  }
  *(float *)&_XMM0 = CG_Weapons_GetAnxietyWeight(_RBP, ps, obj->tree, *(double *)&_XMM3);
  v33 = DCONST_DVARBOOL_cg_skydive_enable_debugAnimOverrides;
  __asm { vmovaps xmm13, xmm0 }
  if ( !DCONST_DVARBOOL_cg_skydive_enable_debugAnimOverrides && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_enable_debugAnimOverrides") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v33);
  if ( v33->current.enabled )
  {
    _RBX = DCONST_DVARFLT_cg_skydive_debug_throttleAnimWeight;
    if ( !DCONST_DVARFLT_cg_skydive_debug_throttleAnimWeight && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_debug_throttleAnimWeight") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm { vmovss  xmm6, dword ptr [rbx+28h] }
    _RBX = DCONST_DVARFLT_cg_skydive_debug_strafeAnimWeight;
    if ( !DCONST_DVARFLT_cg_skydive_debug_strafeAnimWeight && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_debug_strafeAnimWeight") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm { vmovss  xmm12, dword ptr [rbx+28h] }
    _RBX = DCONST_DVARFLT_cg_skydive_debug_yawAnimWeight;
    if ( !DCONST_DVARFLT_cg_skydive_debug_yawAnimWeight && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_debug_yawAnimWeight") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm { vmovss  xmm11, dword ptr [rbx+28h] }
    _RBX = DCONST_DVARFLT_cg_skydive_debug_pitchAnimWeight;
    if ( !DCONST_DVARFLT_cg_skydive_debug_pitchAnimWeight && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_debug_pitchAnimWeight") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm { vmovss  xmm10, dword ptr [rbx+28h] }
    _RBX = DCONST_DVARFLT_cg_skydive_debug_velAnimWeight;
    if ( !DCONST_DVARFLT_cg_skydive_debug_velAnimWeight && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_debug_velAnimWeight") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm { vmovss  xmm9, dword ptr [rbx+28h] }
  }
  __asm
  {
    vmovss  [rsp+0F8h+rate], xmm7
    vmovss  [rsp+0F8h+var_D0], xmm8
    vmovss  dword ptr [rsp+0F8h+fmt], xmm6
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xC8u, fmtd, v68, rated, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+0F8h+rate], xmm7
    vmovss  [rsp+0F8h+var_D0], xmm8
    vmovss  dword ptr [rsp+0F8h+fmt], xmm6
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xCEu, fmte, v69, ratee, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+0F8h+rate], xmm7
    vmovss  [rsp+0F8h+var_D0], xmm8
    vmovss  dword ptr [rsp+0F8h+fmt], xmm12
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xC9u, fmtf, v70, ratef, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+0F8h+rate], xmm7
    vmovss  [rsp+0F8h+var_D0], xmm8
    vmovss  dword ptr [rsp+0F8h+fmt], xmm12
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xD2u, fmtg, v71, rateg, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+0F8h+rate], xmm7
    vmovss  [rsp+0F8h+var_D0], xmm8
    vmovss  dword ptr [rsp+0F8h+fmt], xmm11
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xCAu, fmth, v72, rateh, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+0F8h+rate], xmm7
    vmovss  [rsp+0F8h+var_D0], xmm8
    vmovss  dword ptr [rsp+0F8h+fmt], xmm11
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xD6u, fmti, v73, ratei, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+0F8h+rate], xmm7
    vmovss  [rsp+0F8h+var_D0], xmm8
    vmovss  dword ptr [rsp+0F8h+fmt], xmm10
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xCBu, fmtj, v74, ratej, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+0F8h+rate], xmm7
    vmovss  [rsp+0F8h+var_D0], xmm8
    vmovss  dword ptr [rsp+0F8h+fmt], xmm10
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xDAu, fmtk, v75, ratek, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+0BA178h]
    vmovss  [rsp+0F8h+rate], xmm0
    vmovss  [rsp+0F8h+var_D0], xmm8
    vmovss  dword ptr [rsp+0F8h+fmt], xmm9
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xCCu, fmtl, v76, ratel, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+0F8h+rate], xmm7
    vmovss  [rsp+0F8h+var_D0], xmm8
    vmovss  dword ptr [rsp+0F8h+fmt], xmm13
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xCDu, fmtm, v77, ratem, (scr_string_t)0, 0, 0, LINEAR, NULL);
  _R11 = &v94;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
    vmovaps xmm13, xmmword ptr [r11-80h]
  }
}

/*
==============
CG_Weapons_PlaySkydiveAnims_ParachuteIdle
==============
*/
void CG_Weapons_PlaySkydiveAnims_ParachuteIdle(const cg_t *cgameGlob, const playerState_s *ps, const PlayerHandIndex hand, DObj *obj, const bool blendIn, const float goalTime)
{
  char v26; 
  const dvar_t *v27; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float fmtc; 
  float fmtd; 
  float fmte; 
  float fmtf; 
  float fmtg; 
  float fmth; 
  float fmti; 
  float fmtj; 
  float fmtk; 
  float fmtl; 
  float fmtm; 
  float v63; 
  float v64; 
  float v65; 
  float v66; 
  float v67; 
  float v68; 
  float v69; 
  float v70; 
  float v71; 
  float v72; 
  float v73; 
  float v74; 
  float v75; 
  float v76; 
  float rate; 
  float ratea; 
  float rateb; 
  float ratec; 
  float rated; 
  float ratee; 
  float ratef; 
  float rateg; 
  float rateh; 
  float ratei; 
  float ratej; 
  float ratek; 
  float ratel; 
  float ratem; 
  char v93; 
  void *retaddr; 

  _RAX = &retaddr;
  _EDI = blendIn;
  _EBP = 0;
  __asm
  {
    vmovaps xmmword ptr [rax-28h], xmm6
    vmovaps xmmword ptr [rax-38h], xmm7
  }
  _RSI = cgameGlob;
  __asm
  {
    vmovss  xmm7, cs:__real@3f800000
    vmovaps xmmword ptr [rax-48h], xmm8
    vmovss  xmm8, [rsp+0F8h+goalTime]
    vmovaps xmmword ptr [rax-58h], xmm9
    vmovaps xmmword ptr [rax-68h], xmm10
    vmovaps xmmword ptr [rax-78h], xmm11
    vmovd   xmm1, ebp
    vmovd   xmm0, edi
    vmovaps [rsp+0F8h+var_88], xmm12
    vmovaps [rsp+0F8h+var_98], xmm13
    vpcmpeqd xmm2, xmm0, xmm1
    vmovss  [rsp+0F8h+rate], xmm7
    vxorps  xmm9, xmm9, xmm9
    vblendvps xmm6, xmm7, xmm9, xmm2
    vmovss  [rsp+0F8h+var_D0], xmm8
    vmovss  dword ptr [rsp+0F8h+fmt], xmm6
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xC7u, fmt, v63, rate, (scr_string_t)0, 0, 0, LINEAR, NULL);
  if ( blendIn )
  {
    *(double *)&_XMM0 = XAnimGetGoalWeight(obj->tree, 0, XANIM_SUBTREE_DEFAULT, 0xC5u);
    __asm { vucomiss xmm0, xmm7 }
    if ( !v26 )
    {
      __asm
      {
        vmovss  [rsp+0F8h+rate], xmm7
        vmovss  [rsp+0F8h+var_D0], xmm8
        vmovss  dword ptr [rsp+0F8h+fmt], xmm7
      }
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xC5u, fmta, v64, ratea, (scr_string_t)0, 0, 0, LINEAR, NULL);
    }
  }
  __asm
  {
    vmovss  [rsp+0F8h+rate], xmm9
    vmovss  [rsp+0F8h+var_D0], xmm8
    vmovss  dword ptr [rsp+0F8h+fmt], xmm6
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xFAu, fmtb, v65, rateb, (scr_string_t)0, blendIn, 0, LINEAR, NULL);
  v27 = DCONST_DVARBOOL_cg_skydive_enable_debugAnimOverrides;
  __asm
  {
    vmulss  xmm10, xmm6, dword ptr [rsi+0BA174h]
    vmovaps xmm13, xmm6
    vmovaps xmm12, xmm6
    vmovaps xmm11, xmm6
    vmovaps xmm9, xmm6
  }
  if ( !DCONST_DVARBOOL_cg_skydive_enable_debugAnimOverrides && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_enable_debugAnimOverrides") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v27);
  if ( v27->current.enabled )
  {
    _RDI = DCONST_DVARFLT_cg_skydive_debug_throttleAnimWeight;
    if ( !DCONST_DVARFLT_cg_skydive_debug_throttleAnimWeight && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_debug_throttleAnimWeight") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RDI);
    __asm { vmovss  xmm6, dword ptr [rdi+28h] }
    _RDI = DCONST_DVARFLT_cg_skydive_debug_strafeAnimWeight;
    if ( !DCONST_DVARFLT_cg_skydive_debug_strafeAnimWeight && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_debug_strafeAnimWeight") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RDI);
    __asm { vmovss  xmm13, dword ptr [rdi+28h] }
    _RDI = DCONST_DVARFLT_cg_skydive_debug_yawAnimWeight;
    if ( !DCONST_DVARFLT_cg_skydive_debug_yawAnimWeight && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_debug_yawAnimWeight") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RDI);
    __asm { vmovss  xmm12, dword ptr [rdi+28h] }
    _RDI = DCONST_DVARFLT_cg_skydive_debug_pitchAnimWeight;
    if ( !DCONST_DVARFLT_cg_skydive_debug_pitchAnimWeight && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_debug_pitchAnimWeight") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RDI);
    __asm { vmovss  xmm11, dword ptr [rdi+28h] }
    _RDI = DCONST_DVARFLT_cg_skydive_debug_velAnimWeight;
    if ( !DCONST_DVARFLT_cg_skydive_debug_velAnimWeight && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_debug_velAnimWeight") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RDI);
    __asm { vmovss  xmm10, dword ptr [rdi+28h] }
    _RDI = DCONST_DVARFLT_cg_skydive_debug_lookAnimWeight;
    if ( !DCONST_DVARFLT_cg_skydive_debug_lookAnimWeight && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_debug_lookAnimWeight") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RDI);
    __asm { vmovss  xmm9, dword ptr [rdi+28h] }
  }
  __asm
  {
    vmovss  [rsp+0F8h+rate], xmm7
    vmovss  [rsp+0F8h+var_D0], xmm8
    vmovss  dword ptr [rsp+0F8h+fmt], xmm6
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xE1u, fmtc, v66, ratec, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+0F8h+rate], xmm7
    vmovss  [rsp+0F8h+var_D0], xmm8
    vmovss  dword ptr [rsp+0F8h+fmt], xmm6
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xE7u, fmtd, v67, rated, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+0F8h+rate], xmm7
    vmovss  [rsp+0F8h+var_D0], xmm8
    vmovss  dword ptr [rsp+0F8h+fmt], xmm13
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xE2u, fmte, v68, ratee, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+0F8h+rate], xmm7
    vmovss  [rsp+0F8h+var_D0], xmm8
    vmovss  dword ptr [rsp+0F8h+fmt], xmm13
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xE8u, fmtf, v69, ratef, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+0F8h+rate], xmm7
    vmovss  [rsp+0F8h+var_D0], xmm8
    vmovss  dword ptr [rsp+0F8h+fmt], xmm12
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xE3u, fmtg, v70, rateg, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+0F8h+rate], xmm7
    vmovss  [rsp+0F8h+var_D0], xmm8
    vmovss  dword ptr [rsp+0F8h+fmt], xmm12
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xE9u, fmth, v71, rateh, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+0F8h+rate], xmm7
    vmovss  [rsp+0F8h+var_D0], xmm8
    vmovss  dword ptr [rsp+0F8h+fmt], xmm11
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xE4u, fmti, v72, ratei, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+0F8h+rate], xmm7
    vmovss  [rsp+0F8h+var_D0], xmm8
    vmovss  dword ptr [rsp+0F8h+fmt], xmm11
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xEAu, fmtj, v73, ratej, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  xmm0, dword ptr [rsi+0BA178h]
    vmovss  [rsp+0F8h+rate], xmm0
    vmovss  [rsp+0F8h+var_D0], xmm8
    vmovss  dword ptr [rsp+0F8h+fmt], xmm10
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xE6u, fmtk, v74, ratek, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+0F8h+rate], xmm7
    vmovss  [rsp+0F8h+var_D0], xmm8
    vmovss  dword ptr [rsp+0F8h+fmt], xmm9
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xE5u, fmtl, v75, ratel, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+0F8h+rate], xmm7
    vmovss  [rsp+0F8h+var_D0], xmm8
    vmovss  dword ptr [rsp+0F8h+fmt], xmm9
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xEBu, fmtm, v76, ratem, (scr_string_t)0, 0, 0, LINEAR, NULL);
  _R11 = &v93;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
    vmovaps xmm13, xmmword ptr [r11-80h]
  }
}

/*
==============
CG_Weapons_PlaySkydiveAnims_WeaponRaiseDetach
==============
*/
void CG_Weapons_PlaySkydiveAnims_WeaponRaiseDetach(const LocalClientNum_t localClientNum, cg_t *cgameGlob, const playerState_s *ps, const PlayerHandIndex hand, DObj *obj, const float goalTime, const weapAnimFiles_t anim)
{
  __int64 v10; 
  CgWeaponMap *v13; 
  const Weapon *CurrentWeaponForPlayer; 
  XAnim_s *v15; 
  int weaponTime; 
  char v24; 
  CgSoundSystem *SoundSystem; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float fmtc; 
  float fmtd; 
  float fmte; 
  float fmtf; 
  float fmtg; 
  float isDualWielding; 
  float isDualWieldinga; 
  float isDualWieldingb; 
  float isDualWieldingc; 
  float isDualWieldingd; 
  float isDualWieldinge; 
  float isDualWieldingf; 
  float isDualWieldingg; 
  float anims; 
  float animsa; 
  float animsb; 
  float animsc; 
  float animsd; 
  float animse; 
  float animsf; 
  float animsg; 
  int oneHanded; 
  bool v55; 
  bool v56; 

  v10 = localClientNum;
  __asm { vmovaps [rsp+0C8h+var_58], xmm7 }
  if ( !CgWeaponMap::ms_instance[localClientNum] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v13 = CgWeaponMap::ms_instance[v10];
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(v13, ps);
  v56 = BG_UsingAlternate(ps);
  v55 = BG_PlayerDualWieldingWeapon(v13, ps, CurrentWeaponForPlayer) == 1;
  oneHanded = BG_PlayerDualWieldingWeapon(v13, ps, CurrentWeaponForPlayer);
  v15 = XAnimGetAnims(obj->tree);
  if ( !v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6339, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
    __debugbreak();
  weaponTime = ps->weapState[0].weaponTime;
  *(double *)&_XMM0 = XAnimGetGoalWeight(obj->tree, 0, XANIM_SUBTREE_DEFAULT, anim);
  __asm
  {
    vmovss  xmm7, [rsp+0C8h+goalTime]
    vmulss  xmm1, xmm7, cs:__real@447a0000
    vcvttss2si eax, xmm1
  }
  if ( weaponTime >= _EAX )
  {
    __asm
    {
      vmovaps [rsp+0C8h+var_48], xmm6
      vxorps  xmm6, xmm6, xmm6
      vucomiss xmm0, xmm6
      vmovss  dword ptr [rsp+0C8h+anims], xmm6
      vmovss  dword ptr [rsp+0C8h+isDualWielding], xmm6
      vmovss  dword ptr [rsp+0C8h+fmt], xmm6
    }
    XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xFBu, fmta, isDualWieldinga, animsa, (scr_string_t)0, 0, 0, LINEAR, NULL);
    __asm
    {
      vmovss  dword ptr [rsp+0C8h+anims], xmm6
      vmovss  dword ptr [rsp+0C8h+isDualWielding], xmm6
      vmovss  dword ptr [rsp+0C8h+fmt], xmm6
    }
    XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xFCu, fmtb, isDualWieldingb, animsb, (scr_string_t)0, 0, 0, LINEAR, NULL);
    __asm
    {
      vmovss  dword ptr [rsp+0C8h+anims], xmm6
      vmovss  dword ptr [rsp+0C8h+isDualWielding], xmm6
      vmovss  dword ptr [rsp+0C8h+fmt], xmm6
    }
    XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xFDu, fmtc, isDualWieldingc, animsc, (scr_string_t)0, 0, 0, LINEAR, NULL);
    __asm
    {
      vmovss  dword ptr [rsp+0C8h+anims], xmm6
      vmovss  dword ptr [rsp+0C8h+isDualWielding], xmm6
      vmovss  dword ptr [rsp+0C8h+fmt], xmm6
    }
    XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xFEu, fmtd, isDualWieldingd, animsd, (scr_string_t)0, 0, 0, LINEAR, NULL);
    __asm
    {
      vmovss  dword ptr [rsp+0C8h+anims], xmm6
      vmovss  dword ptr [rsp+0C8h+isDualWielding], xmm6
      vmovss  dword ptr [rsp+0C8h+fmt], xmm6
    }
    XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x100u, fmte, isDualWieldinge, animse, (scr_string_t)0, 0, 0, LINEAR, NULL);
    __asm
    {
      vmovss  dword ptr [rsp+0C8h+anims], xmm6
      vmovss  dword ptr [rsp+0C8h+isDualWielding], xmm6
      vmovss  dword ptr [rsp+0C8h+fmt], xmm6
    }
    XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x101u, fmtf, isDualWieldingf, animsf, (scr_string_t)0, 0, 0, LINEAR, NULL);
    *(double *)&_XMM0 = XAnimGetGoalWeight(obj->tree, 0, XANIM_SUBTREE_DEFAULT, anim);
    __asm
    {
      vmovss  xmm6, cs:__real@3f800000
      vcomiss xmm0, xmm6
    }
    if ( v24 )
    {
      *(float *)&_XMM0 = CG_Weapons_GetWeaponAnimRate((const LocalClientNum_t)v10, ps, hand, CurrentWeaponForPlayer, v56, v55, v15, anim, anim, oneHanded);
      __asm
      {
        vmovss  dword ptr [rsp+0C8h+anims], xmm0
        vmovss  dword ptr [rsp+0C8h+isDualWielding], xmm7
        vmovss  dword ptr [rsp+0C8h+fmt], xmm6
      }
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, anim, fmtg, isDualWieldingg, animsg, (scr_string_t)0, 1u, 0, LINEAR, NULL);
      SoundSystem = CgSoundSystem::GetSoundSystem((const LocalClientNum_t)v10);
      CgSoundSystem::PlayClientSoundAlias(SoundSystem, cgMedia.skydiveParachuteDetach);
    }
    __asm { vmovaps xmm6, [rsp+0C8h+var_48] }
  }
  else
  {
    __asm
    {
      vxorps  xmm1, xmm1, xmm1
      vcomiss xmm0, xmm1
    }
    if ( weaponTime > (unsigned int)_EAX )
    {
      *(float *)&_XMM0 = CG_Weapons_GetWeaponAnimRate((const LocalClientNum_t)v10, ps, hand, CurrentWeaponForPlayer, v56, v55, v15, anim, anim, oneHanded);
      __asm
      {
        vmovss  dword ptr [rsp+0C8h+anims], xmm0
        vmovss  xmm0, cs:__real@3ba3d70a
        vmovss  dword ptr [rsp+0C8h+isDualWielding], xmm7
        vmovss  dword ptr [rsp+0C8h+fmt], xmm0
      }
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, anim, fmt, isDualWielding, anims, (scr_string_t)0, 0, 0, LINEAR, NULL);
    }
  }
  __asm { vmovaps xmm7, [rsp+0C8h+var_58] }
}

/*
==============
CG_Weapons_PlayerWeaponSlotHasWeaponsWithAmmo
==============
*/
char CG_Weapons_PlayerWeaponSlotHasWeaponsWithAmmo(const LocalClientNum_t localClientNum, const playerState_s *ps, const WeaponSlot slot)
{
  __int64 v4; 
  bool v7; 
  BgWeaponMap **v8; 
  BgWeaponMap *v9; 
  int v10; 
  int EquippedWeaponIndex; 
  __int64 p_slot; 
  unsigned __int16 weaponIdx; 
  WeaponDef **v18; 
  __int64 v20; 
  __int64 v21; 
  Weapon r_weapon; 

  v4 = localClientNum;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16410, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v7 = CgWeaponMap::ms_instance[v4] == NULL;
  v8 = &CgWeaponMap::ms_instance[v4];
  if ( v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v9 = *v8;
  v10 = 0;
  while ( 1 )
  {
    if ( !v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 839, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 840, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    _RAX = BgWeaponMap::GetWeapon(v9, ps->weaponsEquipped[v10]);
    __asm
    {
      vmovups ymm2, ymmword ptr [rax]
      vmovups ymmword ptr [rsp+0C8h+r_weapon.weaponIdx], ymm2
      vmovups xmm0, xmmword ptr [rax+20h]
      vmovups xmmword ptr [rsp+0C8h+r_weapon.attachmentVariationIndices+5], xmm0
      vmovsd  xmm1, qword ptr [rax+30h]
      vmovsd  qword ptr [rsp+0C8h+r_weapon.attachmentVariationIndices+15h], xmm1
    }
    *(_DWORD *)&r_weapon.weaponCamo = *(_DWORD *)&_RAX->weaponCamo;
    __asm { vmovd   eax, xmm2 }
    r_weapon.weaponIdx = (unsigned __int16)_RAX;
    if ( (_WORD)_RAX )
    {
      if ( !v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1089, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
        __debugbreak();
      if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 1090, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
        __debugbreak();
      if ( r_weapon.weaponIdx && (EquippedWeaponIndex = BG_GetEquippedWeaponIndex(v9, ps, &r_weapon), EquippedWeaponIndex >= 0) )
        p_slot = (__int64)&ps->weapEquippedData[EquippedWeaponIndex].slot;
      else
        p_slot = 12i64;
      weaponIdx = r_weapon.weaponIdx;
      if ( r_weapon.weaponIdx > bg_lastParsedWeaponIndex )
      {
        LODWORD(v21) = bg_lastParsedWeaponIndex;
        LODWORD(v20) = r_weapon.weaponIdx;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1203, ASSERT_TYPE_ASSERT, "( weaponIdx ) <= ( bg_lastParsedWeaponIndex )", "weaponIdx not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", v20, v21) )
          __debugbreak();
      }
      v7 = bg_weaponDefs[weaponIdx] == NULL;
      v18 = &bg_weaponDefs[weaponIdx];
      if ( v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1204, ASSERT_TYPE_ASSERT, "(bg_weaponDefs[weaponIdx])", (const char *)&queryFormat, "bg_weaponDefs[weaponIdx]") )
        __debugbreak();
      if ( (*v18)->inventoryType == WEAPINVENTORY_PRIMARY && *(_DWORD *)p_slot == slot && BG_WeaponAmmo(v9, ps, &r_weapon, 0) )
        break;
    }
    if ( (unsigned int)++v10 >= 0xF )
      return 0;
  }
  return 1;
}

/*
==============
CG_Weapons_PrecacheMedia
==============
*/
void CG_Weapons_PrecacheMedia(void)
{
  unsigned int v2; 
  unsigned __int16 weaponIdx; 
  unsigned int NumWeapons; 
  __int64 v6; 
  WeaponCompleteDef *v7; 
  bool v8; 
  WeaponDef **v9; 
  WeaponDef *v10; 
  GfxImage *v11; 
  GfxImage *v12; 
  unsigned __int16 v13; 
  Material **v14; 
  unsigned int v15; 
  DB_AssetEntryFlags *p_m_headEntries; 
  DB_AssetEntryPool *AssetEntryPool; 
  unsigned int v18; 
  unsigned int assetCount; 
  char *v20; 
  __int64 v21; 
  __int64 v22; 
  __int64 v23; 
  GetAllXAssetFunctor functor; 
  Weapon r_weapon; 
  char v26[24896]; 

  __asm
  {
    vmovups ymm0, ymmword ptr cs:?NULL_WEAPON@@3UWeapon@@B.weaponIdx; Weapon const NULL_WEAPON
    vmovups xmm1, xmmword ptr cs:?NULL_WEAPON@@3UWeapon@@B.attachmentVariationIndices+5; Weapon const NULL_WEAPON
  }
  v2 = 0;
  *(_DWORD *)&r_weapon.weaponCamo = *(_DWORD *)&NULL_WEAPON.weaponCamo;
  weaponIdx = 0;
  NumWeapons = BG_GetNumWeapons();
  __asm { vmovups ymmword ptr [rsp+6210h+r_weapon.weaponIdx], ymm0 }
  r_weapon.weaponIdx = 0;
  __asm
  {
    vmovsd  xmm0, qword ptr cs:?NULL_WEAPON@@3UWeapon@@B.attachmentVariationIndices+15h; Weapon const NULL_WEAPON
    vmovsd  qword ptr [rbp+6110h+r_weapon.attachmentVariationIndices+15h], xmm0
    vmovups xmmword ptr [rsp+6210h+r_weapon.attachmentVariationIndices+5], xmm1
  }
  if ( NumWeapons )
  {
    do
    {
      v6 = weaponIdx;
      if ( weaponIdx > bg_lastParsedWeaponIndex )
      {
        LODWORD(v23) = bg_lastParsedWeaponIndex;
        LODWORD(v22) = weaponIdx;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1218, ASSERT_TYPE_ASSERT, "( weaponIndex ) <= ( bg_lastParsedWeaponIndex )", "weaponIndex not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", v22, v23) )
          __debugbreak();
        weaponIdx = r_weapon.weaponIdx;
      }
      if ( !bg_weaponCompleteDefs[v6] )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1219, ASSERT_TYPE_ASSERT, "(bg_weaponCompleteDefs[weaponIndex])", (const char *)&queryFormat, "bg_weaponCompleteDefs[weaponIndex]") )
          __debugbreak();
        weaponIdx = r_weapon.weaponIdx;
      }
      v7 = bg_weaponCompleteDefs[v6];
      if ( weaponIdx > bg_lastParsedWeaponIndex )
      {
        LODWORD(v23) = bg_lastParsedWeaponIndex;
        LODWORD(v22) = weaponIdx;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1203, ASSERT_TYPE_ASSERT, "( weaponIdx ) <= ( bg_lastParsedWeaponIndex )", "weaponIdx not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", v22, v23) )
          __debugbreak();
      }
      v8 = bg_weaponDefs[weaponIdx] == NULL;
      v9 = &bg_weaponDefs[weaponIdx];
      if ( v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1204, ASSERT_TYPE_ASSERT, "(bg_weaponDefs[weaponIdx])", (const char *)&queryFormat, "bg_weaponDefs[weaponIdx]") )
        __debugbreak();
      v10 = *v9;
      v11 = BG_HudIcon(&r_weapon, 0);
      v12 = BG_PickUpIcon(&r_weapon, 0);
      v13 = r_weapon.weaponIdx;
      v14 = &cgMedia.objectiveMaterials[r_weapon.weaponIdx - 552];
      if ( v12 )
      {
        *v14 = (Material *)v12;
      }
      else if ( v11 )
      {
        *v14 = (Material *)v11;
      }
      else
      {
        *v14 = NULL;
      }
      if ( v13 && !*v14 && v10->inventoryType == WEAPINVENTORY_PRIMARY && v10->weapClass <= WEAPCLASS_ROCKETLAUNCHER )
      {
        Com_PrintWarning(17, "Weapon '%s' has no hint icon\n", v7->szInternalName);
        v13 = r_weapon.weaponIdx;
      }
      weaponIdx = v13 + 1;
      r_weapon.weaponIdx = weaponIdx;
    }
    while ( weaponIdx < NumWeapons );
  }
  functor.type = ASSET_TYPE_ATTACHMENT;
  functor.assets = (XAssetHeader *)v26;
  functor.assetCount = 0;
  functor.maxCount = 3112;
  DB_LockHashRead();
  v15 = 0;
  p_m_headEntries = &s_assetManager.table.m_headEntries;
  AssetEntryPool = DB_GetAssetEntryPool();
  v18 = 0;
  do
  {
    DB_AssetEntryPool::MutableForEachInBlock<GetAllXAssetFunctor>(AssetEntryPool, &s_assetManager.table.m_headEntries, p_m_headEntries->m_flags.m_data[0], v18, &functor);
    v18 += 64;
    ++v15;
    p_m_headEntries = (DB_AssetEntryFlags *)((char *)p_m_headEntries + 8);
  }
  while ( v15 < 0x1768 );
  DB_UnlockHashRead();
  assetCount = functor.assetCount;
  if ( functor.assetCount )
  {
    v20 = v26;
    do
    {
      v21 = *(_QWORD *)v20;
      v20 += 8;
      *(_DWORD *)(v21 + 896) = v2++;
    }
    while ( v2 < assetCount );
  }
}

/*
==============
CG_Weapons_PrintWeaponShootingAngles
==============
*/
void CG_Weapons_PrintWeaponShootingAngles(const cg_t *const cgameGlob, const vec3_t *baseGunAngles, const vec3_t *localGunAngles, const vec3_t *resultGunAngles)
{
  const dvar_t *v15; 
  unsigned int commandTime; 
  CgWeaponMap *Instance; 
  unsigned int v25; 
  WeaponMovementState *p_weapMoveState; 
  unsigned int v27; 
  __int64 v28; 
  __int64 weaponIdx_low; 
  unsigned int v30; 
  unsigned int v31; 
  unsigned int v32; 
  unsigned int v33; 
  int v34; 
  ViewMovementState *p_viewMoveState; 
  __int64 v36; 
  __int64 fLastIdleFactor_low; 
  unsigned int v38; 
  unsigned int v39; 
  unsigned int v40; 
  int v57; 
  int v58; 
  int v83; 
  char *fmt; 
  double v102; 
  double v103; 
  double v104; 
  double v105; 
  double v106; 
  double v107; 
  double v108; 
  double v109; 
  double v110; 
  double v111; 
  double v112; 
  double v113; 
  double v114; 
  double v115; 
  double v116; 
  double v117; 
  double v118; 
  double v119; 
  double v120; 
  double v121; 
  double v122; 
  double v123; 

  v15 = DVARINT_bg_shootingAnglesLog;
  _R14 = resultGunAngles;
  _R15 = localGunAngles;
  _R12 = baseGunAngles;
  _RDI = cgameGlob;
  if ( !DVARINT_bg_shootingAnglesLog && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_shootingAnglesLog") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v15);
  if ( v15->current.integer == 1 )
  {
    commandTime = _RDI->predictedPlayerState.commandTime;
    __asm
    {
      vmovaps [rsp+1F8h+var_38], xmm6
      vmovaps [rsp+1F8h+var_48], xmm7
      vmovaps [rsp+1F8h+var_58], xmm8
      vmovaps [rsp+1F8h+var_68], xmm9
      vmovaps [rsp+1F8h+var_78], xmm10
      vmovaps [rsp+1F8h+var_88], xmm11
      vmovaps [rsp+1F8h+var_98], xmm12
      vmovaps [rsp+1F8h+var_A8], xmm13
      vmovaps [rsp+1F8h+var_B8], xmm14
      vmovaps [rsp+1F8h+var_C8], xmm15
    }
    Instance = CgWeaponMap::GetInstance((const LocalClientNum_t)_RDI->localClientNum);
    *(double *)&_XMM0 = BG_WeaponADSFractionAffectedByReload(Instance, &_RDI->predictedPlayerState);
    __asm
    {
      vcvtss2sd xmm0, xmm0, xmm0
      vmovsd  [rsp+1F8h+arg_0], xmm0
      vmovss  xmm0, dword ptr [rdi+738h]
      vcvtss2sd xmm0, xmm0, xmm0
    }
    v25 = -1;
    p_weapMoveState = &_RDI->predictedViewState.weapMoveState;
    __asm { vmovsd  [rsp+1F8h+var_F8], xmm0 }
    v27 = -1;
    v28 = 376i64;
    do
    {
      weaponIdx_low = LOBYTE(p_weapMoveState->weapon.weaponIdx);
      p_weapMoveState = (WeaponMovementState *)((char *)p_weapMoveState + 5);
      v30 = (v27 >> 8) ^ g_crc32Table[weaponIdx_low ^ (unsigned __int8)v27];
      v31 = (v30 >> 8) ^ g_crc32Table[p_weapMoveState[-1].recoilNeedsToCrossCenter ^ (unsigned __int64)(unsigned __int8)v30];
      v32 = (v31 >> 8) ^ g_crc32Table[*((unsigned __int8 *)&p_weapMoveState[-1].recoilNeedsToCrossCenter + 1) ^ (unsigned __int64)(unsigned __int8)v31];
      v33 = (v32 >> 8) ^ g_crc32Table[*((unsigned __int8 *)&p_weapMoveState[-1].recoilNeedsToCrossCenter + 2) ^ (unsigned __int64)(unsigned __int8)v32];
      v27 = (v33 >> 8) ^ g_crc32Table[*((unsigned __int8 *)&p_weapMoveState[-1].recoilNeedsToCrossCenter + 3) ^ (unsigned __int64)(unsigned __int8)v33];
      --v28;
    }
    while ( v28 );
    v34 = ~v27;
    p_viewMoveState = &_RDI->predictedViewState.viewMoveState;
    v36 = 418i64;
    do
    {
      fLastIdleFactor_low = LOBYTE(p_viewMoveState->fLastIdleFactor);
      p_viewMoveState = (ViewMovementState *)((char *)p_viewMoveState + 4);
      v38 = (v25 >> 8) ^ g_crc32Table[fLastIdleFactor_low ^ (unsigned __int8)v25];
      v39 = (v38 >> 8) ^ g_crc32Table[BYTE1(p_viewMoveState[-1].idleMotionCache.idleMotion2Spline.lastEvN) ^ (unsigned __int64)(unsigned __int8)v38];
      v40 = (v39 >> 8) ^ g_crc32Table[BYTE2(p_viewMoveState[-1].idleMotionCache.idleMotion2Spline.lastEvN) ^ (unsigned __int64)(unsigned __int8)v39];
      v25 = (v40 >> 8) ^ g_crc32Table[HIBYTE(p_viewMoveState[-1].idleMotionCache.idleMotion2Spline.lastEvN) ^ (unsigned __int64)(unsigned __int8)v40];
      --v36;
    }
    while ( v36 );
    __asm
    {
      vmovss  xmm0, dword ptr [rdi+5AA4h]
      vmovss  xmm1, dword ptr [rdi+53E0h]
      vmovss  xmm2, dword ptr [rdi+61C8h]
      vmovss  xmm3, dword ptr [rdi+61C4h]
      vmovss  xmm4, dword ptr [rdi+61C0h]
      vmovss  xmm5, dword ptr [rdi+0C4h]
      vmovss  xmm6, dword ptr [rdi+0C0h]
      vmovss  xmm7, dword ptr [rdi+0BCh]
      vmovss  xmm8, dword ptr [rdi+1E8h]
      vmovss  xmm9, dword ptr [rdi+1E4h]
      vmovss  xmm10, dword ptr [rdi+1E0h]
      vmovss  xmm11, dword ptr [r15+8]
      vmovss  xmm12, dword ptr [r15+4]
      vmovss  xmm13, dword ptr [r15]
      vmovss  xmm14, dword ptr [r14+8]
      vmovss  xmm15, dword ptr [r14+4]
    }
    v57 = _RDI->savedPlayerState.commandTime;
    v58 = ~v25;
    __asm
    {
      vcvtss2sd xmm0, xmm0, xmm0
      vmovsd  [rsp+1F8h+var_F0], xmm0
      vmovss  xmm0, dword ptr [r14]
      vcvtss2sd xmm0, xmm0, xmm0
      vmovsd  [rsp+1F8h+var_E8], xmm0
      vmovss  xmm0, dword ptr [r12+8]
      vcvtss2sd xmm0, xmm0, xmm0
      vmovsd  [rsp+1F8h+var_E0], xmm0
      vmovss  xmm0, dword ptr [r12+4]
      vcvtss2sd xmm0, xmm0, xmm0
      vmovsd  [rsp+1F8h+var_D8], xmm0
      vmovss  xmm0, dword ptr [r12]
      vcvtss2sd xmm0, xmm0, xmm0
      vmovsd  [rsp+1F8h+var_D0], xmm0
      vcvtss2sd xmm1, xmm1, xmm1
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm4, xmm4, xmm4
      vcvtss2sd xmm5, xmm5, xmm5
      vcvtss2sd xmm6, xmm6, xmm6
      vcvtss2sd xmm7, xmm7, xmm7
      vcvtss2sd xmm8, xmm8, xmm8
      vcvtss2sd xmm9, xmm9, xmm9
      vcvtss2sd xmm10, xmm10, xmm10
      vcvtss2sd xmm11, xmm11, xmm11
      vcvtss2sd xmm12, xmm12, xmm12
      vcvtss2sd xmm13, xmm13, xmm13
      vcvtss2sd xmm14, xmm14, xmm14
      vcvtss2sd xmm15, xmm15, xmm15
    }
    if ( v57 )
      v83 = _RDI->predictedPlayerState.commandTime - v57;
    else
      v83 = 0;
    __asm
    {
      vmovsd  xmm0, [rsp+1F8h+arg_0]
      vmovsd  [rsp+1F8h+var_100], xmm0
      vmovsd  xmm0, [rsp+1F8h+var_F8]
      vmovsd  [rsp+1F8h+var_108], xmm0
      vmovsd  xmm0, [rsp+1F8h+var_F0]
      vmovsd  [rsp+1F8h+var_138], xmm0
      vmovsd  xmm0, [rsp+1F8h+var_E8]
      vmovsd  [rsp+1F8h+var_140], xmm1
      vmovsd  xmm1, [rsp+1F8h+var_E0]
      vmovsd  [rsp+1F8h+var_148], xmm2
      vmovsd  xmm2, [rsp+1F8h+var_D8]
      vmovsd  [rsp+1F8h+var_150], xmm3
      vmovsd  [rsp+1F8h+var_158], xmm4
      vmovsd  [rsp+1F8h+var_160], xmm5
      vmovsd  [rsp+1F8h+var_168], xmm6
      vmovsd  [rsp+1F8h+var_170], xmm7
      vmovsd  [rsp+1F8h+var_178], xmm8
      vmovsd  [rsp+1F8h+var_180], xmm9
      vmovsd  [rsp+1F8h+var_188], xmm10
      vmovsd  [rsp+1F8h+var_190], xmm11
      vmovsd  [rsp+1F8h+var_198], xmm12
      vmovsd  [rsp+1F8h+var_1A0], xmm13
      vmovsd  [rsp+1F8h+var_1A8], xmm14
      vmovsd  [rsp+1F8h+var_1B0], xmm15
      vmovsd  [rsp+1F8h+var_1B8], xmm0
      vmovsd  xmm0, [rsp+1F8h+var_D0]
      vmovsd  [rsp+1F8h+var_1C0], xmm1
      vmovsd  [rsp+1F8h+var_1C8], xmm2
      vmovsd  [rsp+1F8h+var_1D0], xmm0
    }
    LODWORD(fmt) = v83;
    Com_Printf(17, "C->  Time:%d  CmdTime:%d  EX:%d  CA:[%f %f %f]  WA:[%f %f %f]  SA:[%f %f %f]  VA:[%f %f %f]  DA:[%f %f %f]  VMA:[%f %f %f]  VI:%f  WI:%f  VS:%d  WS:%d  IT1:%d  IT2:%d  ADST:%d  ADS:%f  ADSr:%f\n", (unsigned int)_RDI->time, commandTime, fmt, v102, v103, v104, v105, v106, v107, v108, v109, v110, v111, v112, v113, v114, v115, v116, v117, v118, v119, v120, v121, v58, v34, _RDI->predictedPlayerState.weapCommon.weaponIdleTime, _RDI->predictedPlayerState.weapCommon.weaponIdleTime2, _RDI->predictedPlayerState.weapCommon.adsStartTime, v122, v123);
    __asm
    {
      vmovaps xmm15, [rsp+1F8h+var_C8]
      vmovaps xmm14, [rsp+1F8h+var_B8]
      vmovaps xmm13, [rsp+1F8h+var_A8]
      vmovaps xmm12, [rsp+1F8h+var_98]
      vmovaps xmm11, [rsp+1F8h+var_88]
      vmovaps xmm10, [rsp+1F8h+var_78]
      vmovaps xmm9, [rsp+1F8h+var_68]
      vmovaps xmm8, [rsp+1F8h+var_58]
      vmovaps xmm7, [rsp+1F8h+var_48]
      vmovaps xmm6, [rsp+1F8h+var_38]
    }
  }
}

/*
==============
CG_Weapons_ProcessWeaponNoteTracks
==============
*/
void CG_Weapons_ProcessWeaponNoteTracks(LocalClientNum_t localClientNum, const playerState_s *predictedPlayerState, DObj *dObj, const PlayerHandIndex hand, const XAnimNotifyHandle dobjNotifyHandle)
{
  __int64 v6; 
  WeaponDef *v13; 
  const char *v15; 
  const char *v16; 
  __int64 v17; 
  int v18; 
  __int64 v19; 
  int v20; 
  int v21; 
  int v22; 
  const dvar_t *v23; 
  const playerState_s *v27; 
  GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64> *p_weapFlags; 
  bool v29; 
  const SuitDef *SuitDef; 
  __int64 weaponIdx; 
  WeaponCompleteDef *v32; 
  __int64 v33; 
  __int64 numNotetrackSuitEntries; 
  NoteTrackToSuitSoundEntry *notetrackSuitEntries; 
  const scr_string_t *notetrackSoundMapKeys; 
  __int64 v37; 
  WeaponCompleteDef *v38; 
  scr_string_t *v39; 
  scr_string_t *notetrackSoundMapValues; 
  unsigned int numNotetrackSoundMappings; 
  scr_string_t LowercaseString; 
  __int64 i; 
  scr_string_t v44; 
  scr_string_t v45; 
  const char *v46; 
  const playerState_s *v47; 
  bool v48; 
  scr_string_t v49; 
  scr_string_t v50; 
  FxCombinedDef v51; 
  FxCombinedDef *notetrackFXMapValues; 
  char *notetrackFXMapTagValues; 
  char *notetrackFXMapKeys; 
  scr_string_t v55; 
  int v56; 
  signed __int64 v57; 
  int v58; 
  scr_string_t v59; 
  int clientNum; 
  const char *v61; 
  int v62; 
  char *j; 
  char v64; 
  char *k; 
  char v66; 
  __int64 isViewmodel; 
  __int64 isMayhem; 
  unsigned int isMayhema; 
  unsigned int numMappings; 
  scr_string_t searchedNoteName[2]; 
  int entNum; 
  const playerState_s *v73; 
  scr_string_t *values; 
  scr_string_t *keys; 
  XAnimNotify *notify; 
  cg_t *LocalClientGlobals; 
  DObj *dObja; 
  WeaponDef *v79; 
  Weapon r_weapon; 
  char s0; 
  char note; 

  v6 = localClientNum;
  dObja = dObj;
  v73 = predictedPlayerState;
  if ( !CgWeaponMap::ms_instance[localClientNum] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  _RAX = BG_GetViewmodelWeapon(CgWeaponMap::ms_instance[v6], predictedPlayerState);
  __asm
  {
    vmovups ymm2, ymmword ptr [rax]
    vmovups ymmword ptr [rbp+250h+r_weapon.weaponIdx], ymm2
    vmovups xmm0, xmmword ptr [rax+20h]
    vmovups xmmword ptr [rbp+250h+r_weapon.attachmentVariationIndices+5], xmm0
    vmovsd  xmm1, qword ptr [rax+30h]
    vmovsd  qword ptr [rbp+250h+r_weapon.attachmentVariationIndices+15h], xmm1
  }
  *(_DWORD *)&r_weapon.weaponCamo = *(_DWORD *)&_RAX->weaponCamo;
  __asm { vmovd   eax, xmm2 }
  if ( (_WORD)_RAX )
  {
    if ( r_weapon.weaponIdx >= BG_GetNumWeapons() )
    {
      isMayhema = BG_GetNumWeapons();
      LODWORD(isViewmodel) = r_weapon.weaponIdx;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 13407, ASSERT_TYPE_ASSERT, "(unsigned)( weapon.weaponIdx ) < (unsigned)( BG_GetNumWeapons() )", "weapon.weaponIdx doesn't index BG_GetNumWeapons()\n\t%i not in [0, %i)", isViewmodel, isMayhema) )
        __debugbreak();
    }
    BG_UsingAlternate(predictedPlayerState);
    if ( r_weapon.weaponIdx > bg_lastParsedWeaponIndex )
    {
      LODWORD(isMayhem) = bg_lastParsedWeaponIndex;
      LODWORD(isViewmodel) = r_weapon.weaponIdx;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1203, ASSERT_TYPE_ASSERT, "( weaponIdx ) <= ( bg_lastParsedWeaponIndex )", "weaponIdx not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", isViewmodel, isMayhem) )
        __debugbreak();
    }
    if ( !bg_weaponDefs[r_weapon.weaponIdx] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1204, ASSERT_TYPE_ASSERT, "(bg_weaponDefs[weaponIdx])", (const char *)&queryFormat, "bg_weaponDefs[weaponIdx]") )
      __debugbreak();
    v13 = bg_weaponDefs[r_weapon.weaponIdx];
    v79 = v13;
    entNum = hand + 2048;
    LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v6);
    notify = (XAnimNotify *)DObjGetClientNotifyFirst(dobjNotifyHandle);
    _R14 = notify;
    if ( notify )
    {
      v15 = "end";
      do
      {
        v16 = SL_ConvertToString(_R14->noteName);
        v17 = 0x7FFFFFFFi64;
        if ( !v16 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
          __debugbreak();
        do
        {
          v18 = (unsigned __int8)v15[v16 - "end"];
          v19 = v17;
          v20 = *(unsigned __int8 *)v15++;
          --v17;
          if ( !v19 )
            break;
          if ( v18 != v20 )
          {
            v21 = v18 + 32;
            if ( (unsigned int)(v18 - 65) > 0x19 )
              v21 = v18;
            v18 = v21;
            v22 = v20 + 32;
            if ( (unsigned int)(v20 - 65) > 0x19 )
              v22 = v20;
            if ( v18 != v22 )
            {
              v23 = DVARBOOL_viewModelDebugNotetracks;
              if ( !DVARBOOL_viewModelDebugNotetracks && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "viewModelDebugNotetracks") )
                __debugbreak();
              Dvar_CheckFrontendServerThread(v23);
              if ( v23->current.enabled )
              {
                __asm
                {
                  vmovss  xmm2, dword ptr [r14+0Ch]
                  vcvtss2sd xmm2, xmm2, xmm2
                  vmovq   r8, xmm2
                }
                Com_Printf(14, "Viewmodel note at %.2f - \"%s\"\n", *(double *)&_XMM2, v16);
              }
              Sys_ProfBeginNamedEvent(0xFF44CCFF, "PlayNoteMappedSoundAliases");
              v27 = v73;
              p_weapFlags = &v73->weapCommon.weapFlags;
              v29 = v73 && !GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&v73->weapCommon.weapFlags, ACTIVE, 0x22u) && v27 && (GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(p_weapFlags, ACTIVE, 0x11u) || GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(p_weapFlags, ACTIVE, 0x1Bu));
              searchedNoteName[0] = SL_FindLowercaseString(v16);
              if ( searchedNoteName[0] )
              {
                numMappings = 0;
                if ( !v27 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12539, ASSERT_TYPE_ASSERT, "(predictedPlayerState)", (const char *)&queryFormat, "predictedPlayerState") )
                  __debugbreak();
                SuitDef = BG_GetSuitDef(v27->suitIndex);
                if ( !SuitDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12543, ASSERT_TYPE_ASSERT, "(suit)", (const char *)&queryFormat, "suit") )
                  __debugbreak();
                weaponIdx = r_weapon.weaponIdx;
                if ( r_weapon.weaponIdx > bg_lastParsedWeaponIndex )
                {
                  LODWORD(isMayhem) = bg_lastParsedWeaponIndex;
                  LODWORD(isViewmodel) = r_weapon.weaponIdx;
                  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1218, ASSERT_TYPE_ASSERT, "( weaponIndex ) <= ( bg_lastParsedWeaponIndex )", "weaponIndex not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", isViewmodel, isMayhem) )
                    __debugbreak();
                }
                if ( !bg_weaponCompleteDefs[weaponIdx] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1219, ASSERT_TYPE_ASSERT, "(bg_weaponCompleteDefs[weaponIndex])", (const char *)&queryFormat, "bg_weaponCompleteDefs[weaponIndex]") )
                  __debugbreak();
                v32 = bg_weaponCompleteDefs[weaponIdx];
                v33 = 0i64;
                numNotetrackSuitEntries = (int)v32->numNotetrackSuitEntries;
                if ( (int)numNotetrackSuitEntries > 0 )
                {
                  notetrackSuitEntries = v32->notetrackSuitEntries;
                  while ( notetrackSuitEntries->suitAnimState != SuitDef->suitAnimType )
                  {
                    ++v33;
                    ++notetrackSuitEntries;
                    if ( v33 >= numNotetrackSuitEntries )
                      goto LABEL_61;
                  }
                  if ( notetrackSuitEntries->numSoundMappings )
                  {
                    notetrackSoundMapKeys = notetrackSuitEntries->notetrackSoundMapKeys;
                    if ( *notetrackSoundMapKeys )
                      PlayMappedSoundAlias((LocalClientNum_t)v6, notetrackSuitEntries->numSoundMappings, notetrackSoundMapKeys, notetrackSuitEntries->notetrackSoundMapValues, searchedNoteName);
                  }
                }
LABEL_61:
                if ( BG_GetNotetrackOverrides(&r_weapon, v29, &numMappings, (const scr_string_t **)&keys, (const scr_string_t **)&values) )
                {
                  numNotetrackSoundMappings = numMappings;
                  notetrackSoundMapValues = values;
                  v39 = keys;
                }
                else
                {
                  v37 = r_weapon.weaponIdx;
                  if ( r_weapon.weaponIdx > bg_lastParsedWeaponIndex )
                  {
                    LODWORD(isMayhem) = bg_lastParsedWeaponIndex;
                    LODWORD(isViewmodel) = r_weapon.weaponIdx;
                    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1218, ASSERT_TYPE_ASSERT, "( weaponIndex ) <= ( bg_lastParsedWeaponIndex )", "weaponIndex not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", isViewmodel, isMayhem) )
                      __debugbreak();
                  }
                  if ( !bg_weaponCompleteDefs[v37] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1219, ASSERT_TYPE_ASSERT, "(bg_weaponCompleteDefs[weaponIndex])", (const char *)&queryFormat, "bg_weaponCompleteDefs[weaponIndex]") )
                    __debugbreak();
                  v38 = bg_weaponCompleteDefs[v37];
                  v39 = v38->notetrackSoundMapKeys;
                  keys = v39;
                  notetrackSoundMapValues = v38->notetrackSoundMapValues;
                  values = notetrackSoundMapValues;
                  numNotetrackSoundMappings = v38->numNotetrackSoundMappings;
                  numMappings = numNotetrackSoundMappings;
                }
                if ( numNotetrackSoundMappings && *v39 )
                  PlayMappedSoundAlias((LocalClientNum_t)v6, numNotetrackSoundMappings, v39, notetrackSoundMapValues, searchedNoteName);
              }
              Sys_ProfEndNamedEvent();
              if ( v13->weapClass == WEAPCLASS_TURRET )
              {
                if ( SL_FindLowercaseString(v16) )
                  CG_Rumble_PlayOnClientSafeByName((LocalClientNum_t)v6, v16);
              }
              else if ( *v13->notetrackRumbleMapKeys )
              {
                LowercaseString = SL_FindLowercaseString(v16);
                if ( LowercaseString )
                {
                  for ( i = 0i64; i < 16; ++i )
                  {
                    v44 = v13->notetrackRumbleMapKeys[i];
                    if ( !v44 )
                      break;
                    v45 = v13->notetrackRumbleMapValues[i];
                    if ( v45 )
                    {
                      if ( v44 == LowercaseString )
                      {
                        v46 = SL_ConvertToString(v45);
                        if ( v46 )
                          CG_Rumble_PlayOnClientSafeByName((LocalClientNum_t)v6, v46);
                      }
                    }
                  }
                }
              }
              v47 = v73;
              v48 = v73 && !GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(p_weapFlags, ACTIVE, 0x22u) && (GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(p_weapFlags, ACTIVE, 0x11u) || v47 && GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(p_weapFlags, ACTIVE, 0x1Bu));
              v49 = SL_FindLowercaseString(v16);
              v50 = v49;
              if ( v49 && (v49 == scr_const.mag_eject || v49 == scr_const.mag_eject_left) )
              {
                v51.particleSystemDef = BG_ViewMagEjectEffect(&r_weapon, v48).particleSystemDef;
                if ( v51.particleSystemDef )
                {
                  *(FxCombinedDef *)searchedNoteName = v51;
                  CG_PlayBoltedEffect((LocalClientNum_t)v6, (const FXRegisteredDef *)searchedNoteName, (v50 != scr_const.mag_eject) + 2048, scr_const.tag_clip);
                }
              }
              notetrackFXMapValues = v13->notetrackFXMapValues;
              notetrackFXMapTagValues = (char *)v13->notetrackFXMapTagValues;
              notetrackFXMapKeys = (char *)v13->notetrackFXMapKeys;
              *(_QWORD *)searchedNoteName = 0i64;
              if ( !notetrackFXMapKeys && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12653, ASSERT_TYPE_ASSERT, "(fxMapKeys)", (const char *)&queryFormat, "fxMapKeys") )
                __debugbreak();
              if ( !notetrackFXMapTagValues && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12654, ASSERT_TYPE_ASSERT, "(fxBoneNames)", (const char *)&queryFormat, "fxBoneNames") )
                __debugbreak();
              if ( !notetrackFXMapValues && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12655, ASSERT_TYPE_ASSERT, "(fxHandles)", (const char *)&queryFormat, "fxHandles") )
                __debugbreak();
              if ( *(_DWORD *)notetrackFXMapKeys )
              {
                v55 = SL_FindLowercaseString(v16);
                if ( v55 )
                {
                  v56 = 0;
                  v57 = notetrackFXMapKeys - notetrackFXMapTagValues;
                  do
                  {
                    v58 = *(_DWORD *)&notetrackFXMapTagValues[v57];
                    if ( !v58 )
                      break;
                    v59 = *(_DWORD *)notetrackFXMapTagValues;
                    if ( *(_DWORD *)notetrackFXMapTagValues && notetrackFXMapValues->particleSystemDef && v58 == v55 )
                    {
                      *(FxCombinedDef *)searchedNoteName = (FxCombinedDef)notetrackFXMapValues->particleSystemDef;
                      CG_PlayBoltedEffect((LocalClientNum_t)v6, (const FXRegisteredDef *)searchedNoteName, 2048, v59);
                    }
                    ++v56;
                    notetrackFXMapTagValues += 4;
                    ++notetrackFXMapValues;
                  }
                  while ( v56 < 16 );
                }
              }
              _R14 = notify;
              CG_Utils_ProcessNotetracks((LocalClientNum_t)v6, entNum, dObja, &LocalClientGlobals->viewModelPose, notify, 1, 0, 0, 0, 1);
              s0 = 0;
              note = 0;
              clientNum = v73->clientNum;
              if ( ScriptableCl_IsScriptableEntityByNum((const LocalClientNum_t)v6, clientNum) )
              {
                v61 = SL_ConvertToString(_R14->noteName);
                v62 = j_sscanf(v61, "%[^','],%s", &s0, &note);
                for ( j = &s0; ; ++j )
                {
                  v64 = *j;
                  if ( (unsigned __int8)*j < 9u || (unsigned __int8)v64 > 0x20u || !v64 )
                    break;
                }
                if ( v62 == 2 && !I_stricmp(j, "vm_scriptable") )
                {
                  for ( k = &note; ; ++k )
                  {
                    v66 = *k;
                    if ( (unsigned __int8)*k < 9u || (unsigned __int8)v66 > 0x20u )
                      break;
                    if ( !v66 )
                      goto LABEL_130;
                  }
                  if ( v66 )
                    ScriptableCl_AnimNotetrackEvent((const LocalClientNum_t)v6, clientNum, k);
                }
              }
LABEL_130:
              CG_Ladder_ProccessNotetracks((LocalClientNum_t)v6, _R14->noteName);
              v13 = v79;
              break;
            }
          }
        }
        while ( v18 );
        notify = (XAnimNotify *)DObjGetClientNotifyNext(_R14);
        _R14 = notify;
        v15 = "end";
      }
      while ( notify );
    }
  }
}

/*
==============
CG_Weapons_RebuildWeaponsArray
==============
*/
void CG_Weapons_RebuildWeaponsArray(LocalClientNum_t localClientNum)
{
  cg_t *LocalClientGlobals; 
  cg_t *v3; 
  CgWeaponMap *Instance; 
  CgHandler *Handler; 
  const Weapon *ViewmodelWeapon; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v3 = LocalClientGlobals;
  if ( LocalClientGlobals->inKillCam )
  {
    Com_PrintWarning(1, "Unable to update weapon anim arrays for client %d due to MyChanges because the client is in KillCam", (unsigned int)LocalClientGlobals->predictedPlayerState.clientNum);
  }
  else
  {
    Instance = CgWeaponMap::GetInstance(localClientNum);
    if ( Instance )
    {
      Handler = CgHandler::getHandler(localClientNum);
      PM_BuildWeaponAnimArrays(Instance, &v3->predictedPlayerState, Handler);
      ViewmodelWeapon = BG_GetViewmodelWeapon(Instance, &v3->predictedPlayerState);
      CG_CreateWeaponViewModelXAnimDefs(localClientNum, &v3->predictedPlayerState, ViewmodelWeapon, &v3->playerWeaponInfo);
      CG_Weapon_ChangeViewmodelDobj(localClientNum, &v3->predictedPlayerState, ViewmodelWeapon, v3->playerWeaponInfo.handModel, 0, 1, 0, 1);
    }
    else
    {
      Com_PrintWarning(1, "Unable to update weapon anim arrays for client %d due to WeaponMap not being initialized.", (unsigned int)v3->predictedPlayerState.clientNum);
    }
  }
}

/*
==============
CG_Weapons_ResetSkydiveAnimationParameters
==============
*/
void CG_Weapons_ResetSkydiveAnimationParameters(const LocalClientNum_t localClientNum, const playerState_s *ps, DObj *obj)
{
  _RBX = CG_GetLocalClientGlobals(localClientNum);
  __asm { vxorps  xmm2, xmm2, xmm2; value }
  *(_QWORD *)&_RBX->skydiveClientState.animState.throttle = 0i64;
  *(_QWORD *)&_RBX->skydiveClientState.animState.yaw = 0i64;
  *(_QWORD *)&_RBX->skydiveClientState.animState.normalizedSpeed = 0i64;
  *(_QWORD *)&_RBX->skydiveClientState.animState.velAnimPlayRate = 0i64;
  XAnimSetFloatGameParameterByIndex(obj, 0x1Eu, *(float *)&_XMM2);
  __asm { vmovss  xmm2, dword ptr [rbx+0BA164h]; value }
  XAnimSetFloatGameParameterByIndex(obj, 0x1Fu, *(float *)&_XMM2);
  __asm { vmovss  xmm2, dword ptr [rbx+0BA168h]; value }
  XAnimSetFloatGameParameterByIndex(obj, 0x20u, *(float *)&_XMM2);
  __asm { vmovss  xmm2, dword ptr [rbx+0BA16Ch]; value }
  XAnimSetFloatGameParameterByIndex(obj, 0x21u, *(float *)&_XMM2);
  __asm { vxorps  xmm2, xmm2, xmm2; value }
  XAnimSetFloatGameParameterByIndex(obj, 0x22u, *(float *)&_XMM2);
}

/*
==============
CG_Weapons_ScopeIsOverlayed
==============
*/
bool CG_Weapons_ScopeIsOverlayed(LocalClientNum_t localClientNum)
{
  const cg_t *LocalClientGlobals; 

  if ( CG_PlayerUsingScopedTurret(localClientNum) )
    return 1;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  return CG_GetWeapReticleZoom(LocalClientGlobals, NULL);
}

/*
==============
CG_Weapons_ScopeToggleState_BlendIntoIdle
==============
*/

void __fastcall CG_Weapons_ScopeToggleState_BlendIntoIdle(const playerState_s *ps, DObj *obj, double blendInTime)
{
  XAnimTree *Tree; 
  const dvar_t *v10; 
  const XAnimTree *v11; 
  bool enabled; 
  int v13; 
  int v14; 
  unsigned int VMRelativeAnimIndex; 
  unsigned int v17; 
  weapAnimFiles_t *v18; 
  char v19; 
  char v20; 
  float fmt; 
  float goalTime; 
  float rate; 

  __asm
  {
    vmovaps [rsp+0A8h+var_38], xmm6
    vmovaps [rsp+0A8h+var_48], xmm7
    vmovaps xmm7, xmm2
  }
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7290, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7291, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7251, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  Tree = DObjGetTree(obj);
  v10 = DVARBOOL_killswitch_weapon_post_ship_relative_anim_fix_enabled;
  v11 = Tree;
  if ( !DVARBOOL_killswitch_weapon_post_ship_relative_anim_fix_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_weapon_post_ship_relative_anim_fix_enabled") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v10);
  enabled = v10->current.enabled;
  v13 = 176;
  if ( enabled )
    v13 = 192;
  v14 = 0;
  __asm { vxorps  xmm6, xmm6, xmm6 }
  while ( 2 )
  {
    VMRelativeAnimIndex = CG_Weapons_GetVMRelativeAnimIndex(v14, enabled);
    v17 = VMRelativeAnimIndex;
    v18 = ignoredAnims;
    while ( *v18 != VMRelativeAnimIndex )
    {
      if ( (__int64)++v18 >= (__int64)&unk_147FA82B8 )
      {
        *(double *)&_XMM0 = XAnimGetWeight(v11, 0, XANIM_SUBTREE_DEFAULT, VMRelativeAnimIndex);
        __asm { vcomiss xmm0, xmm6 }
        if ( !(v19 | v20) )
          goto LABEL_23;
        *(double *)&_XMM0 = XAnimGetGoalWeight(v11, 0, XANIM_SUBTREE_DEFAULT, v17);
        __asm { vcomiss xmm0, xmm6 }
        if ( !(v19 | v20) )
          goto LABEL_23;
        break;
      }
    }
    if ( ++v14 < v13 )
      continue;
    break;
  }
  __asm
  {
    vmovss  xmm0, cs:__real@3f800000
    vmovss  [rsp+0A8h+rate], xmm0
    vmovss  [rsp+0A8h+goalTime], xmm7
    vmovss  dword ptr [rsp+0A8h+fmt], xmm0
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0xECu, fmt, goalTime, rate, (scr_string_t)0, 0, 0, LINEAR, NULL);
LABEL_23:
  __asm
  {
    vmovaps xmm6, [rsp+0A8h+var_38]
    vmovaps xmm7, [rsp+0A8h+var_48]
  }
}

/*
==============
CG_Weapons_ScopeToggleState_BlendOutRelativeAnims
==============
*/

void __fastcall CG_Weapons_ScopeToggleState_BlendOutRelativeAnims(const playerState_s *ps, DObj *obj, double blendOutTime)
{
  const XAnimTree *Tree; 
  unsigned __int64 v11; 
  unsigned int v13; 
  char v15; 
  char v16; 
  float fmt; 
  float goalTime; 
  float v23; 
  char v25; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-28h], xmm6
    vmovaps xmmword ptr [rax-38h], xmm7
    vmovaps xmmword ptr [rax-48h], xmm8
    vmovaps xmm8, xmm2
  }
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7207, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7208, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  Tree = DObjGetTree(obj);
  if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7211, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
    __debugbreak();
  v11 = 0i64;
  __asm { vxorps  xmm7, xmm7, xmm7 }
  do
  {
    v13 = arrRelativeAnims[v11];
    *(double *)&_XMM0 = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, v13);
    __asm { vmovaps xmm6, xmm0 }
    *(double *)&_XMM0 = XAnimGetGoalWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, v13);
    __asm { vcomiss xmm6, xmm7 }
    if ( v15 | v16 )
    {
      __asm { vcomiss xmm0, xmm7 }
      if ( !(v15 | v16) )
        goto LABEL_16;
    }
    else
    {
      __asm { vcomiss xmm0, xmm7 }
      if ( !(v15 | v16) )
        goto LABEL_16;
      *(double *)&_XMM0 = XAnimGetGoalTime(Tree, 0, XANIM_SUBTREE_DEFAULT, v13);
      __asm { vcomiss xmm0, xmm8 }
      if ( !(v15 | v16) )
      {
LABEL_16:
        __asm
        {
          vmovss  [rsp+0A8h+var_78], xmm7
          vmovss  [rsp+0A8h+goalTime], xmm8
          vmovss  dword ptr [rsp+0A8h+fmt], xmm7
        }
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, v13, fmt, goalTime, v23, (scr_string_t)0, 0, 0, LINEAR, NULL);
      }
    }
    ++v11;
  }
  while ( v11 < 3 );
  __asm { vmovaps xmm7, [rsp+0A8h+var_38] }
  _R11 = &v25;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm8, xmmword ptr [r11-30h]
  }
}

/*
==============
CG_Weapons_ScopeToggleState_Scope1InPosition_Enter
==============
*/
void CG_Weapons_ScopeToggleState_Scope1InPosition_Enter(const LocalClientNum_t localClientNum, const playerState_s *ps, const Weapon *weapon, bool isAlternate, DObj *obj, XAnim_s *anims, ClientScopeToggleInfo *scopeToggleInfo)
{
  XAnimTree *Tree; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float goalTime; 
  float goalTimea; 
  float goalTimeb; 
  float v19; 
  float v20; 
  float v21; 
  float obja; 

  __asm { vmovaps [rsp+78h+var_18], xmm6 }
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7527, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7528, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  if ( !anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7529, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
    __debugbreak();
  Tree = DObjGetTree(obj);
  if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7532, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
    __debugbreak();
  __asm
  {
    vmovss  xmm0, cs:__real@3a83126f
    vxorps  xmm6, xmm6, xmm6
    vmovss  [rsp+78h+var_48], xmm6
    vmovss  [rsp+78h+goalTime], xmm6
    vmovss  dword ptr [rsp+78h+fmt], xmm0
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x103u, fmt, goalTime, v19, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+78h+var_48], xmm6
    vmovss  [rsp+78h+goalTime], xmm6
    vmovss  dword ptr [rsp+78h+fmt], xmm6
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x104u, fmta, goalTimea, v20, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+78h+var_48], xmm6
    vmovss  [rsp+78h+goalTime], xmm6
    vmovss  xmm6, cs:__real@3f800000
    vmovss  dword ptr [rsp+78h+fmt], xmm6
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x105u, fmtb, goalTimeb, v21, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  dword ptr [rsp+78h+obj], xmm6
    vmovaps xmm6, [rsp+78h+var_18]
  }
  XAnimSetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x105u, obja);
}

/*
==============
CG_Weapons_ScopeToggleState_Scope2InPosition_Enter
==============
*/
void CG_Weapons_ScopeToggleState_Scope2InPosition_Enter(const LocalClientNum_t localClientNum, const playerState_s *ps, const Weapon *weapon, bool isAlternate, DObj *obj, XAnim_s *anims)
{
  XAnimTree *Tree; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float fmtc; 
  float goalTime; 
  float goalTimea; 
  float goalTimeb; 
  float v21; 
  float v22; 
  float v23; 

  __asm
  {
    vmovaps [rsp+88h+var_18], xmm6
    vmovaps [rsp+88h+var_28], xmm7
  }
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7565, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7566, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  if ( !anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7567, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
    __debugbreak();
  Tree = DObjGetTree(obj);
  if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7570, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
    __debugbreak();
  __asm
  {
    vmovss  xmm0, cs:__real@3a83126f
    vxorps  xmm7, xmm7, xmm7
    vmovss  [rsp+88h+var_58], xmm7
    vmovss  [rsp+88h+goalTime], xmm7
    vmovss  dword ptr [rsp+88h+fmt], xmm0
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x103u, fmt, goalTime, v21, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  xmm6, cs:__real@3f800000
    vmovss  [rsp+88h+var_58], xmm7
    vmovss  [rsp+88h+goalTime], xmm7
    vmovss  dword ptr [rsp+88h+fmt], xmm6
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x104u, fmta, goalTimea, v22, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm { vmovss  dword ptr [rsp+88h+fmt], xmm6 }
  XAnimSetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x104u, fmtb);
  __asm
  {
    vmovss  [rsp+88h+var_58], xmm7
    vmovss  [rsp+88h+goalTime], xmm7
    vmovss  dword ptr [rsp+88h+fmt], xmm7
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x105u, fmtc, goalTimeb, v23, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovaps xmm6, [rsp+88h+var_18]
    vmovaps xmm7, [rsp+88h+var_28]
  }
}

/*
==============
CG_Weapons_ScopeToggleState_ToggleOffSettle_Enter
==============
*/
void CG_Weapons_ScopeToggleState_ToggleOffSettle_Enter(const LocalClientNum_t localClientNum, const playerState_s *ps, const Weapon *weapon, const bool isAlternate, DObj *obj, XAnim_s *anims)
{
  bool v14; 
  int v15; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float goalTime; 
  float goalTimea; 
  float goalTimeb; 
  float rate; 
  float ratea; 
  float rateb; 

  __asm
  {
    vmovaps [rsp+98h+var_28], xmm6
    vmovaps [rsp+98h+var_38], xmm7
  }
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7419, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7420, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  if ( !anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7421, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
    __debugbreak();
  _RBX = DCONST_DVARFLT_cg_toggleScopeBlendOutTime;
  if ( !DCONST_DVARFLT_cg_toggleScopeBlendOutTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_toggleScopeBlendOutTime") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm { vmovss  xmm7, dword ptr [rbx+28h] }
  v14 = BG_PlayerDualWielding(ps) == 1;
  XAnimGetLengthMsec(anims, 0x105u);
  v15 = BG_ScopeToggleOnTime(ps, weapon, isAlternate, v14);
  if ( v15 <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7429, ASSERT_TYPE_ASSERT, "( stateLength ) > ( 0 )", "%s > %s\n\t%i, %i", "stateLength", "0", v15, 0i64) )
    __debugbreak();
  __asm
  {
    vmovss  xmm0, cs:__real@3f800000
    vmovss  xmm6, cs:__real@3a83126f
    vmovss  [rsp+98h+rate], xmm0
    vmovss  [rsp+98h+goalTime], xmm7
    vmovss  dword ptr [rsp+98h+fmt], xmm6
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x103u, fmt, goalTime, rate, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmovss  [rsp+98h+rate], xmm0
    vmovss  [rsp+98h+goalTime], xmm0
    vmovss  dword ptr [rsp+98h+fmt], xmm0
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x104u, fmta, goalTimea, ratea, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vxorps  xmm1, xmm1, xmm1
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm1, xmm1, esi
    vcvtsi2ss xmm0, xmm0, ebx
    vdivss  xmm3, xmm1, xmm0
    vmovss  [rsp+98h+rate], xmm3
    vmovss  [rsp+98h+goalTime], xmm7
    vmovss  dword ptr [rsp+98h+fmt], xmm6
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x105u, fmtb, goalTimeb, rateb, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovaps xmm2, xmm7
    vmovaps xmm6, [rsp+98h+var_28]
    vmovaps xmm7, [rsp+98h+var_38]
  }
  CG_Weapons_ScopeToggleState_BlendIntoIdle(ps, obj, *(double *)&_XMM2);
}

/*
==============
CG_Weapons_ScopeToggleState_ToggleOff_Enter
==============
*/
void CG_Weapons_ScopeToggleState_ToggleOff_Enter(const LocalClientNum_t localClientNum, const playerState_s *ps, const Weapon *weapon, const bool isAlternate, DObj *obj, XAnim_s *anims)
{
  const XAnimTree *Tree; 
  bool v16; 
  int v17; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float goalTime; 
  float goalTimea; 
  float goalTimeb; 
  float rate; 
  float ratea; 
  float rateb; 

  __asm
  {
    vmovaps [rsp+98h+var_28], xmm6
    vmovaps [rsp+98h+var_38], xmm7
  }
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7464, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7465, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  if ( !anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7466, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
    __debugbreak();
  Tree = DObjGetTree(obj);
  if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7469, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
    __debugbreak();
  _RBX = DCONST_DVARFLT_cg_toggleScopeBlendInTime;
  if ( !DCONST_DVARFLT_cg_toggleScopeBlendInTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_toggleScopeBlendInTime") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm { vmovss  xmm7, dword ptr [rbx+28h] }
  v16 = BG_PlayerDualWielding(ps) == 1;
  XAnimGetLengthMsec(anims, 0x105u);
  v17 = BG_ScopeToggleOffTime(ps, weapon, isAlternate, v16);
  if ( v17 <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7477, ASSERT_TYPE_ASSERT, "( stateLength ) > ( 0 )", "%s > %s\n\t%i, %i", "stateLength", "0", v17, 0i64) )
    __debugbreak();
  __asm
  {
    vmovss  xmm6, cs:__real@3f800000
    vmovss  [rsp+98h+rate], xmm6
    vmovss  [rsp+98h+goalTime], xmm7
    vmovss  dword ptr [rsp+98h+fmt], xmm6
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x103u, fmt, goalTime, rate, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vxorps  xmm1, xmm1, xmm1
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm1, xmm1, ebp
    vcvtsi2ss xmm0, xmm0, ebx
    vdivss  xmm2, xmm1, xmm0
    vmovss  [rsp+98h+rate], xmm2
    vmovss  [rsp+98h+goalTime], xmm7
    vmovss  dword ptr [rsp+98h+fmt], xmm6
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x105u, fmta, goalTimea, ratea, (scr_string_t)0, 1u, 0, LINEAR, NULL);
  *(double *)&_XMM0 = XAnimGetRate(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x104u);
  __asm
  {
    vmovss  [rsp+98h+rate], xmm0
    vxorps  xmm0, xmm0, xmm0
    vmovss  [rsp+98h+goalTime], xmm7
    vmovss  dword ptr [rsp+98h+fmt], xmm0
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x104u, fmtb, goalTimeb, rateb, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovaps xmm2, xmm7
    vmovaps xmm6, [rsp+98h+var_28]
    vmovaps xmm7, [rsp+98h+var_38]
  }
  CG_Weapons_ScopeToggleState_BlendOutRelativeAnims(ps, obj, *(double *)&_XMM2);
}

/*
==============
CG_Weapons_ScopeToggleState_ToggleOff_Update
==============
*/
void CG_Weapons_ScopeToggleState_ToggleOff_Update(const LocalClientNum_t localClientNum, const playerState_s *ps, const Weapon *weapon, const bool isAlternate, DObj *obj, XAnim_s *anims, ClientScopeToggleInfo *scopeToggleInfo)
{
  const XAnimTree *Tree; 
  char v17; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7492, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7493, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  if ( !anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7494, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
    __debugbreak();
  Tree = DObjGetTree(obj);
  if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7497, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
    __debugbreak();
  if ( ps->weapState[0].weaponState == 76 )
  {
    CG_Weapons_ScopeToggleState_ToggleOn_Enter(localClientNum, ps, weapon, isAlternate, obj, anims, scopeToggleInfo);
    *(_DWORD *)scopeToggleInfo->state = 2;
  }
  else
  {
    __asm { vmovaps [rsp+78h+var_38], xmm6 }
    *(double *)&_XMM0 = XAnimGetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x105u);
    _RBX = DCONST_DVARFLT_cg_toggleScopeBlendOutStartAnimNormalizedTime;
    __asm { vmovaps xmm6, xmm0 }
    if ( !DCONST_DVARFLT_cg_toggleScopeBlendOutStartAnimNormalizedTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_toggleScopeBlendOutStartAnimNormalizedTime") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm
    {
      vcomiss xmm6, dword ptr [rbx+28h]
      vmovaps xmm6, [rsp+78h+var_38]
    }
    if ( v17 )
    {
      _RBX = DCONST_DVARFLT_cg_toggleScopeBlendInTime;
      if ( !DCONST_DVARFLT_cg_toggleScopeBlendInTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_toggleScopeBlendInTime") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(_RBX);
      __asm { vmovss  xmm2, dword ptr [rbx+28h]; blendOutTime }
      CG_Weapons_ScopeToggleState_BlendOutRelativeAnims(ps, obj, *(double *)&_XMM2);
    }
    else
    {
      CG_Weapons_ScopeToggleState_ToggleOffSettle_Enter(localClientNum, ps, weapon, isAlternate, obj, anims);
      *(_DWORD *)scopeToggleInfo->state = 6;
    }
  }
}

/*
==============
CG_Weapons_ScopeToggleState_ToggleOnSettle_Enter
==============
*/
void CG_Weapons_ScopeToggleState_ToggleOnSettle_Enter(const LocalClientNum_t localClientNum, const playerState_s *ps, const Weapon *weapon, const bool isAlternate, DObj *obj, XAnim_s *anims)
{
  bool v14; 
  int v15; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float goalTime; 
  float goalTimea; 
  float goalTimeb; 
  float rate; 
  float ratea; 
  float rateb; 

  __asm
  {
    vmovaps [rsp+98h+var_28], xmm6
    vmovaps [rsp+98h+var_38], xmm7
  }
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7311, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7312, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  if ( !anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7313, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
    __debugbreak();
  _RBX = DCONST_DVARFLT_cg_toggleScopeBlendOutTime;
  if ( !DCONST_DVARFLT_cg_toggleScopeBlendOutTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_toggleScopeBlendOutTime") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm { vmovss  xmm7, dword ptr [rbx+28h] }
  v14 = BG_PlayerDualWielding(ps) == 1;
  XAnimGetLengthMsec(anims, 0x104u);
  v15 = BG_ScopeToggleOnTime(ps, weapon, isAlternate, v14);
  if ( v15 <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7321, ASSERT_TYPE_ASSERT, "( stateLength ) > ( 0 )", "%s > %s\n\t%i, %i", "stateLength", "0", v15, 0i64) )
    __debugbreak();
  __asm
  {
    vmovss  xmm0, cs:__real@3f800000
    vmovss  xmm6, cs:__real@3a83126f
    vmovss  [rsp+98h+rate], xmm0
    vmovss  [rsp+98h+goalTime], xmm7
    vmovss  dword ptr [rsp+98h+fmt], xmm6
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x103u, fmt, goalTime, rate, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vxorps  xmm1, xmm1, xmm1
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm1, xmm1, esi
    vcvtsi2ss xmm0, xmm0, ebx
    vdivss  xmm2, xmm1, xmm0
    vmovss  [rsp+98h+rate], xmm2
    vmovss  [rsp+98h+goalTime], xmm7
    vmovss  dword ptr [rsp+98h+fmt], xmm6
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x104u, fmta, goalTimea, ratea, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmovss  [rsp+98h+rate], xmm0
    vmovss  [rsp+98h+goalTime], xmm0
    vmovss  dword ptr [rsp+98h+fmt], xmm0
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x105u, fmtb, goalTimeb, rateb, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovaps xmm2, xmm7
    vmovaps xmm6, [rsp+98h+var_28]
    vmovaps xmm7, [rsp+98h+var_38]
  }
  CG_Weapons_ScopeToggleState_BlendIntoIdle(ps, obj, *(double *)&_XMM2);
}

/*
==============
CG_Weapons_ScopeToggleState_ToggleOn_Enter
==============
*/
void CG_Weapons_ScopeToggleState_ToggleOn_Enter(const LocalClientNum_t localClientNum, const playerState_s *ps, const Weapon *weapon, const bool isAlternate, DObj *obj, XAnim_s *anims)
{
  const XAnimTree *Tree; 
  bool v16; 
  int v17; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float goalTime; 
  float goalTimea; 
  float goalTimeb; 
  float rate; 
  float ratea; 
  float rateb; 

  __asm
  {
    vmovaps [rsp+98h+var_28], xmm6
    vmovaps [rsp+98h+var_38], xmm7
  }
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7356, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7357, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  if ( !anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7358, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
    __debugbreak();
  Tree = DObjGetTree(obj);
  if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7361, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
    __debugbreak();
  _RBX = DCONST_DVARFLT_cg_toggleScopeBlendInTime;
  if ( !DCONST_DVARFLT_cg_toggleScopeBlendInTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_toggleScopeBlendInTime") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm { vmovss  xmm7, dword ptr [rbx+28h] }
  v16 = BG_PlayerDualWielding(ps) == 1;
  XAnimGetLengthMsec(anims, 0x104u);
  v17 = BG_ScopeToggleOnTime(ps, weapon, isAlternate, v16);
  if ( v17 <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7369, ASSERT_TYPE_ASSERT, "( stateLength ) > ( 0 )", "%s > %s\n\t%i, %i", "stateLength", "0", v17, 0i64) )
    __debugbreak();
  __asm
  {
    vmovss  xmm6, cs:__real@3f800000
    vmovss  [rsp+98h+rate], xmm6
    vmovss  [rsp+98h+goalTime], xmm7
    vmovss  dword ptr [rsp+98h+fmt], xmm6
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x103u, fmt, goalTime, rate, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vxorps  xmm1, xmm1, xmm1
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm1, xmm1, ebp
    vcvtsi2ss xmm0, xmm0, ebx
    vdivss  xmm2, xmm1, xmm0
    vmovss  [rsp+98h+rate], xmm2
    vmovss  [rsp+98h+goalTime], xmm7
    vmovss  dword ptr [rsp+98h+fmt], xmm6
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x104u, fmta, goalTimea, ratea, (scr_string_t)0, 1u, 0, LINEAR, NULL);
  *(double *)&_XMM0 = XAnimGetRate(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x105u);
  __asm
  {
    vmovss  [rsp+98h+rate], xmm0
    vxorps  xmm0, xmm0, xmm0
    vmovss  [rsp+98h+goalTime], xmm7
    vmovss  dword ptr [rsp+98h+fmt], xmm0
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x105u, fmtb, goalTimeb, rateb, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovaps xmm2, xmm7
    vmovaps xmm6, [rsp+98h+var_28]
    vmovaps xmm7, [rsp+98h+var_38]
  }
  CG_Weapons_ScopeToggleState_BlendOutRelativeAnims(ps, obj, *(double *)&_XMM2);
}

/*
==============
CG_Weapons_ScopeToggleState_ToggleOn_Update
==============
*/
void CG_Weapons_ScopeToggleState_ToggleOn_Update(const LocalClientNum_t localClientNum, const playerState_s *ps, const Weapon *weapon, const bool isAlternate, DObj *obj, XAnim_s *anims, ClientScopeToggleInfo *scopeToggleInfo)
{
  const XAnimTree *Tree; 
  char v17; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7384, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7385, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  if ( !anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7386, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
    __debugbreak();
  Tree = DObjGetTree(obj);
  if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7389, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
    __debugbreak();
  if ( ps->weapState[0].weaponState == 77 )
  {
    CG_Weapons_ScopeToggleState_ToggleOff_Enter(localClientNum, ps, weapon, isAlternate, obj, anims);
    *(_DWORD *)scopeToggleInfo->state = 5;
  }
  else
  {
    __asm { vmovaps [rsp+78h+var_38], xmm6 }
    *(double *)&_XMM0 = XAnimGetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x104u);
    _RBX = DCONST_DVARFLT_cg_toggleScopeBlendOutStartAnimNormalizedTime;
    __asm { vmovaps xmm6, xmm0 }
    if ( !DCONST_DVARFLT_cg_toggleScopeBlendOutStartAnimNormalizedTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_toggleScopeBlendOutStartAnimNormalizedTime") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm
    {
      vcomiss xmm6, dword ptr [rbx+28h]
      vmovaps xmm6, [rsp+78h+var_38]
    }
    if ( v17 )
    {
      _RBX = DCONST_DVARFLT_cg_toggleScopeBlendInTime;
      if ( !DCONST_DVARFLT_cg_toggleScopeBlendInTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_toggleScopeBlendInTime") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(_RBX);
      __asm { vmovss  xmm2, dword ptr [rbx+28h]; blendOutTime }
      CG_Weapons_ScopeToggleState_BlendOutRelativeAnims(ps, obj, *(double *)&_XMM2);
    }
    else
    {
      CG_Weapons_ScopeToggleState_ToggleOnSettle_Enter(localClientNum, ps, weapon, isAlternate, obj, anims);
      *(_DWORD *)scopeToggleInfo->state = 3;
    }
  }
}

/*
==============
CG_Weapons_SetSkydiveAnimationParameters
==============
*/
void CG_Weapons_SetSkydiveAnimationParameters(const LocalClientNum_t localClientNum, const playerState_s *ps, DObj *obj)
{
  char forwardmove; 
  char rightmove; 
  char v66; 
  bool v70; 
  char v84; 
  bool v85; 
  bool v89; 
  bool v92; 
  bool v95; 
  bool v101; 
  const dvar_t *v115; 
  const dvar_t *v126; 
  const dvar_t *v127; 
  __int64 v139; 
  double v140; 
  double v141; 
  double v142; 
  double v143; 
  double v144; 
  double v145; 
  double v146; 
  double v147; 
  double v148; 
  double v149; 
  double v150; 
  double v151; 
  double v152; 
  double v153; 
  char v157; 
  void *retaddr; 
  vec2_t StickCartesianCoords; 
  vec2_t v160; 

  _RAX = &retaddr;
  __asm { vmovaps xmmword ptr [rax-28h], xmm6 }
  _RDI = ps;
  forwardmove = ps->lastInput.forwardmove;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm7
    vmovaps xmmword ptr [rax-48h], xmm8
  }
  rightmove = _RDI->lastInput.rightmove;
  __asm
  {
    vmovaps xmmword ptr [rax-58h], xmm9
    vmovaps xmmword ptr [rax-68h], xmm10
    vmovaps xmmword ptr [rax-78h], xmm11
    vmovaps xmmword ptr [rax-88h], xmm12
    vmovaps [rsp+108h+var_98], xmm13
    vmovaps [rsp+108h+var_A8], xmm14
    vmovaps [rsp+108h+var_B8], xmm15
  }
  StickCartesianCoords = BG_GetStickCartesianCoords(rightmove, forwardmove);
  v160 = BG_GetStickCartesianCoords(_RDI->lastInput.yawmove, _RDI->lastInput.pitchmove);
  _RSI = CG_GetLocalClientGlobals(localClientNum);
  _RBX = BG_GetSuitDef(_RDI->suitIndex);
  if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6071, ASSERT_TYPE_ASSERT, "(suitDef)", (const char *)&queryFormat, "suitDef") )
    __debugbreak();
  switch ( _RDI->skydivePlayerState.state[0] )
  {
    case 1:
    case 5:
    case 6:
      goto $LN7_306;
    case 2:
    case 3:
    case 4:
      __asm
      {
        vmovss  xmm13, dword ptr [rbx+54Ch]; jumptable 0000000141DFED78 cases 2-4
        vmovss  xmm2, dword ptr [rbx+550h]
        vmovss  xmm14, dword ptr [rbx+554h]
        vmovss  xmm15, dword ptr [rbx+558h]
        vmovss  xmm9, dword ptr [rbx+55Ch]
        vmovss  xmm10, dword ptr [rbx+560h]
        vmovss  xmm11, dword ptr [rbx+564h]
        vmovss  xmm12, dword ptr [rbx+568h]
        vmovss  xmm1, dword ptr [rbx+56Ch]
        vmovss  xmm3, dword ptr [rbx+570h]
      }
      break;
    default:
      LODWORD(v139) = (unsigned __int8)_RDI->skydivePlayerState.state[0];
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6118, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Unhandled skydive state %d while retrieving suit field values.", v139) )
        __debugbreak();
$LN7_306:
      __asm
      {
        vmovss  xmm3, dword ptr [rbx+420h]; jumptable 0000000141DFED78 cases 1,5,6
        vmovss  xmm1, dword ptr [rbx+41Ch]
        vmovss  xmm12, dword ptr [rbx+418h]
        vmovss  xmm11, dword ptr [rbx+414h]
        vmovss  xmm10, dword ptr [rbx+410h]
        vmovss  xmm9, dword ptr [rbx+40Ch]
        vmovss  xmm15, dword ptr [rbx+408h]
        vmovss  xmm14, dword ptr [rbx+404h]
        vmovss  xmm2, dword ptr [rbx+400h]; rate
        vmovss  xmm13, dword ptr [rbx+3FCh]
      }
      break;
  }
  __asm
  {
    vmulss  xmm8, xmm3, cs:__real@421d7ae1
    vmulss  xmm7, xmm1, cs:__real@421d7ae1
    vmovss  xmm1, dword ptr [rsi+0BA164h]; cur
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, dword ptr [rsi+65E4h]
    vmulss  xmm6, xmm0, cs:__real@3a83126f
    vmovss  xmm0, dword ptr [rsp+108h+arg_8]; tgt
    vmovaps xmm3, xmm6; deltaTime
  }
  *(double *)&_XMM0 = DiffTrack(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3);
  __asm
  {
    vmovss  xmm1, dword ptr [rsi+0BA160h]; cur
    vmovss  dword ptr [rsi+0BA164h], xmm0
    vmovss  xmm0, dword ptr [rsp+108h+arg_8+4]; tgt
    vmovaps xmm3, xmm6; deltaTime
    vmovaps xmm2, xmm13; rate
  }
  *(double *)&_XMM0 = DiffTrack(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3);
  __asm
  {
    vmovss  xmm1, dword ptr [rsi+0BA168h]; cur
    vmovss  dword ptr [rsi+0BA160h], xmm0
    vmovss  xmm0, dword ptr [rsp+108h+arg_18]; tgt
    vmovaps xmm3, xmm6; deltaTime
    vmovaps xmm2, xmm14; rate
  }
  *(double *)&_XMM0 = DiffTrack(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3);
  __asm
  {
    vmovss  xmm1, dword ptr [rsi+0BA16Ch]; cur
    vmovss  dword ptr [rsi+0BA168h], xmm0
    vmovss  xmm0, dword ptr [rsp+108h+arg_18+4]; tgt
    vmovaps xmm3, xmm6; deltaTime
    vmovaps xmm2, xmm15; rate
  }
  *(double *)&_XMM0 = DiffTrack(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3);
  __asm
  {
    vmovss  xmm2, dword ptr [rsi+0BA160h]; value
    vmovss  dword ptr [rsi+0BA16Ch], xmm0
  }
  XAnimSetFloatGameParameterByIndex(obj, 0x1Eu, *(float *)&_XMM2);
  __asm { vmovss  xmm2, dword ptr [rsi+0BA164h]; value }
  XAnimSetFloatGameParameterByIndex(obj, 0x1Fu, *(float *)&_XMM2);
  __asm { vmovss  xmm2, dword ptr [rsi+0BA168h]; value }
  XAnimSetFloatGameParameterByIndex(obj, 0x20u, *(float *)&_XMM2);
  __asm { vmovss  xmm2, dword ptr [rsi+0BA16Ch]; value }
  XAnimSetFloatGameParameterByIndex(obj, 0x21u, *(float *)&_XMM2);
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+1D8h]
    vmulss  xmm5, xmm0, cs:__real@3b360b61
    vaddss  xmm2, xmm5, cs:__real@3f000000
    vxorps  xmm0, xmm0, xmm0
    vroundss xmm4, xmm0, xmm2, 1
    vmovss  xmm2, cs:__real@42b40000; max
    vsubss  xmm1, xmm5, xmm4
    vmulss  xmm0, xmm1, cs:__real@43b40000; val
    vmovss  xmm1, cs:__real@c2b40000; min
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm { vmovaps xmm2, xmm0; value }
  XAnimSetFloatGameParameterByIndex(obj, 0x22u, *(float *)&_XMM2);
  __asm
  {
    vxorps  xmm13, xmm13, xmm13
    vcomiss xmm7, xmm13
  }
  if ( v66 )
  {
    __asm
    {
      vxorpd  xmm0, xmm0, xmm0
      vmovsd  [rsp+108h+var_C8], xmm0
      vcvtss2sd xmm1, xmm7, xmm7
      vmovsd  [rsp+108h+var_D0], xmm1
    }
    v70 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6147, ASSERT_TYPE_ASSERT, "( animSpeedForMinWeight ) >= ( 0.0f )", "%s >= %s\n\t%g, %g", "animSpeedForMinWeight", "0.0f", v146, v150);
    v66 = 0;
    if ( v70 )
      __debugbreak();
  }
  __asm { vcomiss xmm7, xmm8 }
  if ( !v66 )
  {
    __asm
    {
      vcvtss2sd xmm0, xmm8, xmm8
      vmovsd  [rsp+108h+var_C8], xmm0
      vcvtss2sd xmm1, xmm7, xmm7
      vmovsd  [rsp+108h+var_D0], xmm1
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6148, ASSERT_TYPE_ASSERT, "( animSpeedForMinWeight ) < ( animSpeedForMaxWeight )", "%s < %s\n\t%g, %g", "animSpeedForMinWeight", "animSpeedForMaxWeight", v147, v151) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+3Ch]
    vmovss  xmm2, dword ptr [rdi+40h]
    vmovss  xmm3, dword ptr [rdi+44h]
    vmulss  xmm1, xmm0, xmm0
    vmulss  xmm0, xmm2, xmm2
    vaddss  xmm2, xmm1, xmm0
    vmulss  xmm1, xmm3, xmm3
    vaddss  xmm2, xmm2, xmm1
    vsqrtss xmm0, xmm2, xmm2; val
    vmovaps xmm2, xmm8; max
    vmovaps xmm1, xmm7; min
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm
  {
    vcomiss xmm7, xmm8
    vmovaps xmm6, xmm0
  }
  if ( !(v84 | v85) )
  {
    __asm
    {
      vcvtss2sd xmm1, xmm8, xmm8
      vmovsd  [rsp+108h+var_D8], xmm1
      vcvtss2sd xmm2, xmm7, xmm7
      vmovsd  [rsp+108h+var_E0], xmm2
    }
    v89 = CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vector.h", 826, ASSERT_TYPE_SANITY, "( min ) <= ( max )", "min <= max\n\t%g, %g", v140, v143);
    v84 = 0;
    v85 = !v89;
    if ( v89 )
      __debugbreak();
  }
  __asm { vcomiss xmm6, xmm7 }
  if ( v84 )
  {
    __asm
    {
      vcvtss2sd xmm0, xmm7, xmm7
      vmovsd  [rsp+108h+var_D8], xmm0
      vcvtss2sd xmm1, xmm6, xmm6
      vmovsd  [rsp+108h+var_E0], xmm1
    }
    v92 = CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vector.h", 827, ASSERT_TYPE_SANITY, "( dist ) >= ( min )", "dist >= min\n\t%g, %g", v141, v144);
    v84 = 0;
    v85 = !v92;
    if ( v92 )
      __debugbreak();
  }
  __asm { vcomiss xmm6, xmm8 }
  if ( !(v84 | v85) )
  {
    __asm
    {
      vcvtss2sd xmm0, xmm8, xmm8
      vmovsd  [rsp+108h+var_D8], xmm0
      vcvtss2sd xmm1, xmm6, xmm6
      vmovsd  [rsp+108h+var_E0], xmm1
    }
    v95 = CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vector.h", 828, ASSERT_TYPE_SANITY, "( dist ) <= ( max )", "dist <= max\n\t%g, %g", v142, v145);
    v84 = 0;
    v85 = !v95;
    if ( v95 )
      __debugbreak();
  }
  __asm
  {
    vsubss  xmm1, xmm8, xmm7
    vcvtss2sd xmm0, xmm1, xmm1
    vcomisd xmm0, cs:__real@3eb0c6f7a0b5ed8d
  }
  if ( !(v84 | v85) )
  {
    __asm
    {
      vsubss  xmm0, xmm6, xmm7
      vdivss  xmm13, xmm0, xmm1
    }
  }
  __asm
  {
    vcomiss xmm9, xmm10
    vmovss  dword ptr [rsi+0BA170h], xmm13
  }
  if ( !v84 )
  {
    __asm
    {
      vcvtss2sd xmm0, xmm10, xmm10
      vmovsd  [rsp+108h+var_C8], xmm0
      vcvtss2sd xmm1, xmm9, xmm9
      vmovsd  [rsp+108h+var_D0], xmm1
    }
    v101 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6152, ASSERT_TYPE_ASSERT, "( velAnimMinWeight ) < ( velAnimMaxWeight )", "%s < %s\n\t%g, %g", "velAnimMinWeight", "velAnimMaxWeight", v148, v152);
    v84 = 0;
    if ( v101 )
      __debugbreak();
  }
  __asm
  {
    vcomiss xmm11, xmm12
    vmovss  xmm1, dword ptr [rsi+0BA170h]
    vmovss  xmm6, cs:__real@3f800000
    vsubss  xmm0, xmm6, xmm1
    vmulss  xmm2, xmm0, xmm9
    vmulss  xmm1, xmm1, xmm10
    vaddss  xmm2, xmm2, xmm1
    vmovss  dword ptr [rsi+0BA174h], xmm2
  }
  if ( !v84 )
  {
    __asm
    {
      vcvtss2sd xmm0, xmm12, xmm12
      vmovsd  [rsp+108h+var_C8], xmm0
      vcvtss2sd xmm1, xmm11, xmm11
      vmovsd  [rsp+108h+var_D0], xmm1
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6155, ASSERT_TYPE_ASSERT, "( velAnimMinPlayRate ) < ( velAnimMaxPlayRate )", "%s < %s\n\t%g, %g", "velAnimMinPlayRate", "velAnimMaxPlayRate", v149, v153) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm1, dword ptr [rsi+0BA170h]
    vsubss  xmm0, xmm6, xmm1
    vmulss  xmm2, xmm0, xmm11
    vmulss  xmm1, xmm1, xmm12
    vaddss  xmm2, xmm2, xmm1
    vmovss  dword ptr [rsi+0BA178h], xmm2
  }
  v115 = DCONST_DVARBOOL_cg_skydive_enable_debugAnimOverrides;
  if ( !DCONST_DVARBOOL_cg_skydive_enable_debugAnimOverrides && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_enable_debugAnimOverrides") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v115);
  if ( v115->current.enabled )
  {
    _RBX = DCONST_DVARFLT_cg_skydive_debug_paramInputThrottle;
    if ( !DCONST_DVARFLT_cg_skydive_debug_paramInputThrottle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_debug_paramInputThrottle") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm { vmovss  xmm2, dword ptr [rbx+28h]; value }
    XAnimSetFloatGameParameterByIndex(obj, 0x1Eu, *(float *)&_XMM2);
    _RBX = DCONST_DVARFLT_cg_skydive_debug_paramInputStrafe;
    if ( !DCONST_DVARFLT_cg_skydive_debug_paramInputStrafe && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_debug_paramInputStrafe") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm { vmovss  xmm2, dword ptr [rbx+28h]; value }
    XAnimSetFloatGameParameterByIndex(obj, 0x1Fu, *(float *)&_XMM2);
    _RBX = DCONST_DVARFLT_cg_skydive_debug_paramInputYaw;
    if ( !DCONST_DVARFLT_cg_skydive_debug_paramInputYaw && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_debug_paramInputYaw") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm { vmovss  xmm2, dword ptr [rbx+28h]; value }
    XAnimSetFloatGameParameterByIndex(obj, 0x20u, *(float *)&_XMM2);
    _RBX = DCONST_DVARFLT_cg_skydive_debug_paramInputPitch;
    if ( !DCONST_DVARFLT_cg_skydive_debug_paramInputPitch && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_debug_paramInputPitch") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm { vmovss  xmm2, dword ptr [rbx+28h]; value }
    XAnimSetFloatGameParameterByIndex(obj, 0x21u, *(float *)&_XMM2);
    _RBX = DCONST_DVARFLT_cg_skydive_debug_paramCameraPitch;
    if ( !DCONST_DVARFLT_cg_skydive_debug_paramCameraPitch && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_debug_paramCameraPitch") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm { vmovss  xmm2, dword ptr [rbx+28h]; value }
    XAnimSetFloatGameParameterByIndex(obj, 0x22u, *(float *)&_XMM2);
    v126 = DCONST_DVARFLT_cg_skydive_debug_velAnimWeight;
    if ( !DCONST_DVARFLT_cg_skydive_debug_velAnimWeight && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_debug_velAnimWeight") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v126);
    LODWORD(_RSI->skydiveClientState.animState.velAnimWeight) = v126->current.integer;
    v127 = DCONST_DVARFLT_cg_skydive_debug_velAnimPlayRate;
    if ( !DCONST_DVARFLT_cg_skydive_debug_velAnimPlayRate && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_skydive_debug_velAnimPlayRate") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v127);
    LODWORD(_RSI->skydiveClientState.animState.velAnimPlayRate) = v127->current.integer;
  }
  __asm { vmovaps xmm14, [rsp+108h+var_A8] }
  _R11 = &v157;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
    vmovaps xmm13, xmmword ptr [r11-80h]
    vmovaps xmm15, [rsp+108h+var_B8]
  }
}

/*
==============
CG_Weapons_SetupAutoComplete
==============
*/
void CG_Weapons_SetupAutoComplete(void)
{
  unsigned int v0; 
  unsigned __int16 v1; 
  unsigned int NumWeapons; 
  const char **v3; 
  __int64 v4; 
  __int64 v5; 
  __int64 v6; 

  v0 = 5;
  s_weapon_nameParamList[0] = "all";
  s_weapon_nameParamList[1] = "allammo";
  s_weapon_nameParamList[2] = "weapons";
  s_weapon_nameParamList[3] = "ammo";
  s_weapon_nameParamList[4] = "health";
  v1 = 1;
  NumWeapons = BG_GetNumWeapons();
  if ( NumWeapons > 1 )
  {
    v3 = &s_weapon_nameParamList[5];
    while ( 1 )
    {
      v4 = v1;
      if ( v1 > bg_lastParsedWeaponIndex )
      {
        LODWORD(v6) = bg_lastParsedWeaponIndex;
        LODWORD(v5) = v1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1218, ASSERT_TYPE_ASSERT, "( weaponIndex ) <= ( bg_lastParsedWeaponIndex )", "weaponIndex not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", v5, v6) )
          __debugbreak();
      }
      if ( !bg_weaponCompleteDefs[v1] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1219, ASSERT_TYPE_ASSERT, "(bg_weaponCompleteDefs[weaponIndex])", (const char *)&queryFormat, "bg_weaponCompleteDefs[weaponIndex]") )
        __debugbreak();
      if ( v0 >= 0x22B )
        break;
      ++v1;
      ++v0;
      *v3++ = bg_weaponCompleteDefs[v4]->szInternalName;
      if ( v1 >= NumWeapons )
        goto LABEL_13;
    }
    Com_PrintError(14, "CG_Weapons_SetupAutoComplete: Ran out of space for auto-complete\n");
  }
LABEL_13:
  Cmd_SetAutoCompleteList("give", s_weapon_nameParamList, v0);
  Cmd_SetAutoCompleteList("take", s_weapon_nameParamList, 5u);
}

/*
==============
CG_Weapons_ShouldSimulateBulletFire
==============
*/
bool CG_Weapons_ShouldSimulateBulletFire(const LocalClientNum_t localClientNum, BulletFireParams *bp, const centity_t *inflictorEnt, const bool isBeamTracer)
{
  const dvar_t *v14; 
  char v27; 
  char v55; 
  char v57; 
  char v58; 
  bool result; 
  vec3_t forward; 
  vec3_t point; 
  vec3_t dst; 
  vec3_t up; 

  v14 = DVARBOOL_cg_cullBullets;
  _R15 = bp;
  if ( !DVARBOOL_cg_cullBullets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_cullBullets") )
    __debugbreak();
  __asm
  {
    vmovaps [rsp+160h+var_30], xmm6
    vmovaps [rsp+160h+var_40], xmm7
    vmovaps [rsp+160h+var_50], xmm8
    vmovaps [rsp+160h+var_60], xmm9
    vmovaps [rsp+160h+var_70], xmm10
    vmovaps [rsp+160h+var_80], xmm11
    vmovaps [rsp+160h+var_90], xmm12
    vmovaps [rsp+160h+var_A0], xmm13
    vmovaps [rsp+160h+var_B0], xmm14
    vmovaps [rsp+160h+var_C0], xmm15
  }
  Dvar_CheckFrontendServerThread(v14);
  if ( !v14->current.enabled )
    goto LABEL_32;
  _RBX = CG_GetLocalClientGlobals(localClientNum);
  if ( GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&_RBX->predictedPlayerState.otherFlags, ACTIVE, 1u) || (_RBX->predictedPlayerState.linkFlags.m_flags[0] & 4) != 0 || GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&_RBX->predictedPlayerState.eFlags, ACTIVE, 7u) && _RBX->predictedPlayerState.viewlocked_entNum == inflictorEnt->nextState.number )
    goto LABEL_32;
  if ( _RBX->predictedPlayerState.vehicleState.entity == 2047 )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rbx+38h]
      vmovss  dword ptr [rsp+160h+point], xmm0
      vmovss  xmm1, dword ptr [rbx+3Ch]
      vmovss  dword ptr [rsp+160h+point+4], xmm1
      vmovss  xmm0, dword ptr [rbx+40h]
    }
  }
  else
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rbx+134h]
      vmovss  dword ptr [rsp+160h+point], xmm0
      vmovss  xmm1, dword ptr [rbx+138h]
      vmovss  dword ptr [rsp+160h+point+4], xmm1
      vmovss  xmm0, dword ptr [rbx+13Ch]
    }
  }
  __asm { vmovss  dword ptr [rsp+160h+point+8], xmm0 }
  AngleVectors(&_RBX->refdefViewAngles, &forward, NULL, &up);
  Dvar_GetFloat_Internal_DebugName(DVARFLT_cg_cullBulletAngle, "cg_cullBulletAngle");
  __asm
  {
    vmovss  xmm1, cs:__real@42b40000
    vsubss  xmm3, xmm1, xmm0; degrees
  }
  RotatePointAroundVector(&dst, &up, &forward, *(float *)&_XMM3);
  __asm
  {
    vmovss  xmm9, dword ptr [rsp+160h+dst]
    vmovss  xmm8, dword ptr [rsp+160h+dst+4]
    vmulss  xmm1, xmm9, dword ptr [rsp+160h+forward]
    vmulss  xmm0, xmm8, dword ptr [rsp+160h+forward+4]
    vmovss  xmm6, dword ptr [rsp+160h+dst+8]
    vmovss  xmm4, dword ptr [r15+68h]
    vmovss  xmm5, dword ptr [r15+6Ch]
    vsubss  xmm10, xmm4, dword ptr [rsp+160h+point]
    vaddss  xmm2, xmm1, xmm0
    vmulss  xmm0, xmm6, dword ptr [rsp+160h+forward+8]
    vaddss  xmm1, xmm2, xmm0
    vmulss  xmm3, xmm1, cs:__real@40000000
    vmulss  xmm2, xmm3, dword ptr [rsp+160h+forward]
    vmulss  xmm1, xmm3, dword ptr [rsp+160h+forward+8]
    vsubss  xmm0, xmm2, xmm9
    vmovss  xmm2, dword ptr [r15+7Ch]
    vsubss  xmm12, xmm2, dword ptr [rsp+160h+point+8]
    vmovss  [rsp+160h+var_11C], xmm0
    vmulss  xmm0, xmm3, dword ptr [rsp+160h+forward+4]
    vmovss  xmm3, dword ptr [r15+78h]
    vsubss  xmm11, xmm3, dword ptr [rsp+160h+point+4]
    vsubss  xmm0, xmm0, xmm8
    vsubss  xmm8, xmm5, dword ptr [rsp+160h+point+4]
    vmovss  [rsp+160h+var_120], xmm0
    vsubss  xmm0, xmm1, xmm6
    vmovss  xmm6, dword ptr [r15+70h]
    vsubss  xmm9, xmm6, dword ptr [rsp+160h+point+8]
    vmovss  [rsp+160h+var_118], xmm0
    vmovss  xmm0, dword ptr [r15+74h]
    vucomiss xmm4, xmm0
    vsubss  xmm7, xmm0, dword ptr [rsp+160h+point]
  }
  if ( !v27 )
    goto LABEL_16;
  __asm { vucomiss xmm5, xmm3 }
  if ( !v27 )
    goto LABEL_16;
  __asm { vucomiss xmm6, xmm2 }
  if ( v27 )
    v55 = 1;
  else
LABEL_16:
    v55 = 0;
  if ( v55 )
    goto LABEL_31;
  *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DVARFLT_cg_minCullBulletDist, "cg_minCullBulletDist");
  __asm { vmovaps xmm6, xmm0 }
  *(double *)&_XMM0 = PointToLineSegmentDistSq(&point, &_R15->start, &_R15->end);
  __asm
  {
    vmulss  xmm1, xmm6, xmm6
    vcomiss xmm0, xmm1
  }
  if ( v57 | v58 )
    goto LABEL_32;
  __asm
  {
    vmovss  xmm13, dword ptr [rsp+160h+dst]
    vmovss  xmm14, dword ptr [rsp+160h+dst+4]
    vmovss  xmm15, dword ptr [rsp+160h+dst+8]
    vsubss  xmm3, xmm7, xmm10
    vmulss  xmm0, xmm3, xmm3
    vsubss  xmm5, xmm12, xmm9
    vsubss  xmm4, xmm11, xmm8
    vmulss  xmm1, xmm4, xmm4
    vaddss  xmm2, xmm1, xmm0
    vmulss  xmm1, xmm5, xmm5
    vaddss  xmm2, xmm2, xmm1
    vmovss  xmm1, cs:__real@3f800000
    vsqrtss xmm11, xmm2, xmm2
    vcmpless xmm0, xmm11, cs:__real@80000000
    vblendvps xmm0, xmm11, xmm1, xmm0
    vdivss  xmm1, xmm1, xmm0
    vmulss  xmm6, xmm3, xmm1
    vmulss  xmm7, xmm5, xmm1
    vmulss  xmm0, xmm14, xmm8
    vmulss  xmm2, xmm13, xmm10
    vmulss  xmm4, xmm4, xmm1
    vaddss  xmm3, xmm2, xmm0
    vmulss  xmm1, xmm15, xmm9
    vaddss  xmm12, xmm3, xmm1
    vxorps  xmm5, xmm5, xmm5
    vcomiss xmm12, xmm5
  }
  if ( !(v57 | v58) )
  {
    __asm
    {
      vmovss  xmm13, [rsp+160h+var_120]
      vmovss  xmm3, [rsp+160h+var_11C]
      vmovss  xmm14, [rsp+160h+var_118]
      vmulss  xmm1, xmm8, xmm13
      vmulss  xmm0, xmm10, xmm3
      vaddss  xmm2, xmm1, xmm0
      vmulss  xmm1, xmm9, xmm14
      vaddss  xmm12, xmm2, xmm1
      vcomiss xmm12, xmm5
    }
    if ( !(v57 | v58) )
      goto LABEL_32;
    __asm
    {
      vmulss  xmm0, xmm3, xmm6
      vmulss  xmm1, xmm13, xmm4
      vaddss  xmm2, xmm1, xmm0
      vmulss  xmm1, xmm14, xmm7
      vaddss  xmm3, xmm2, xmm1
      vandps  xmm0, xmm3, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
      vcomiss xmm0, cs:__real@3a83126f
    }
    if ( !v57 )
    {
      __asm
      {
        vdivss  xmm0, xmm12, xmm3
        vxorps  xmm2, xmm0, cs:__xmm@80000000800000008000000080000000
        vcomiss xmm2, xmm5
        vcomiss xmm2, xmm11
      }
      if ( v57 | v58 )
      {
        __asm
        {
          vmulss  xmm0, xmm2, xmm4
          vaddss  xmm4, xmm0, xmm8
          vmulss  xmm0, xmm2, xmm6
          vmulss  xmm1, xmm2, xmm7
          vaddss  xmm3, xmm0, xmm10
          vaddss  xmm7, xmm1, xmm9
        }
        if ( !isBeamTracer )
        {
          __asm
          {
            vmulss  xmm2, xmm4, dword ptr [rsp+160h+forward+4]
            vmulss  xmm3, xmm3, dword ptr [rsp+160h+forward]
            vmulss  xmm1, xmm7, dword ptr [rsp+160h+forward+8]
            vaddss  xmm4, xmm3, xmm2
            vaddss  xmm2, xmm4, xmm1
            vcomiss xmm2, xmm5
          }
          result = isBeamTracer;
          goto LABEL_33;
        }
LABEL_32:
        result = 1;
        goto LABEL_33;
      }
    }
LABEL_31:
    result = 0;
    goto LABEL_33;
  }
  __asm
  {
    vmulss  xmm1, xmm14, xmm4
    vmulss  xmm0, xmm13, xmm6
    vaddss  xmm2, xmm1, xmm0
    vmulss  xmm1, xmm15, xmm7
    vaddss  xmm3, xmm2, xmm1
    vandps  xmm0, xmm3, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcomiss xmm0, cs:__real@3a83126f
  }
  if ( v57 )
    goto LABEL_31;
  __asm
  {
    vdivss  xmm0, xmm12, xmm3
    vxorps  xmm2, xmm0, cs:__xmm@80000000800000008000000080000000
    vcomiss xmm2, xmm5
    vcomiss xmm2, xmm11
  }
  if ( !(v57 | v58) )
    goto LABEL_31;
  __asm
  {
    vmulss  xmm0, xmm2, xmm4
    vaddss  xmm4, xmm0, xmm8
    vmulss  xmm0, xmm2, xmm6
    vmulss  xmm1, xmm2, xmm7
    vaddss  xmm3, xmm0, xmm10
    vaddss  xmm7, xmm1, xmm9
  }
  if ( isBeamTracer )
    goto LABEL_32;
  __asm
  {
    vmulss  xmm2, xmm4, dword ptr [rsp+160h+forward+4]
    vmulss  xmm3, xmm3, dword ptr [rsp+160h+forward]
    vmulss  xmm1, xmm7, dword ptr [rsp+160h+forward+8]
    vaddss  xmm4, xmm3, xmm2
    vaddss  xmm2, xmm4, xmm1
    vcomiss xmm2, xmm5
  }
  result = isBeamTracer;
LABEL_33:
  __asm
  {
    vmovaps xmm15, [rsp+160h+var_C0]
    vmovaps xmm14, [rsp+160h+var_B0]
    vmovaps xmm13, [rsp+160h+var_A0]
    vmovaps xmm12, [rsp+160h+var_90]
    vmovaps xmm11, [rsp+160h+var_80]
    vmovaps xmm10, [rsp+160h+var_70]
    vmovaps xmm9, [rsp+160h+var_60]
    vmovaps xmm8, [rsp+160h+var_50]
    vmovaps xmm7, [rsp+160h+var_40]
    vmovaps xmm6, [rsp+160h+var_30]
  }
  return result;
}

/*
==============
CG_Weapons_SimulateBulletFire_EndPos
==============
*/

void __fastcall CG_Weapons_SimulateBulletFire_EndPos(unsigned int *randSeed, double spreadInner, double spreadOuter, const vec3_t *start, vec3_t *end, vec3_t *dir, const float angleMin, const float angleMax, const vec3_t *forwardDir, const vec3_t *rightDir, const vec3_t *upDir, const float maxRange)
{
  bool v26; 
  bool v27; 
  int v51; 
  int v63; 
  double v92; 
  double v93; 
  char v94; 
  void *retaddr; 
  int v96; 
  int v97; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-18h], xmm6
    vmovaps xmmword ptr [rax-28h], xmm7
    vmovaps xmmword ptr [rax-38h], xmm8
    vmovaps xmmword ptr [rax-48h], xmm10
    vmovaps xmmword ptr [rax-58h], xmm11
    vmovss  [rsp+0A8h+arg_8], xmm1
    vmovaps xmm7, xmm2
    vmovaps xmm6, xmm1
  }
  if ( (v96 & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23404, ASSERT_TYPE_SANITY, "( !IS_NAN( spreadInner ) )", (const char *)&queryFormat, "!IS_NAN( spreadInner )") )
    __debugbreak();
  __asm { vmovss  [rsp+0A8h+arg_8], xmm7 }
  if ( (v97 & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23405, ASSERT_TYPE_SANITY, "( !IS_NAN( spreadOuter ) )", (const char *)&queryFormat, "!IS_NAN( spreadOuter )") )
    __debugbreak();
  __asm { vmulss  xmm0, xmm6, cs:__real@3c8efa35; X }
  *(float *)&_XMM0 = tanf_0(*(float *)&_XMM0);
  __asm
  {
    vmovss  xmm6, [rsp+0A8h+maxRange]
    vmulss  xmm10, xmm0, xmm6
    vmulss  xmm0, xmm7, cs:__real@3c8efa35; X
  }
  *(float *)&_XMM0 = tanf_0(*(float *)&_XMM0);
  __asm
  {
    vmovss  [rsp+0A8h+maxRange], xmm10
    vmulss  xmm11, xmm0, xmm6
  }
  if ( (LODWORD(maxRange) & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23410, ASSERT_TYPE_SANITY, "( !IS_NAN( aimOffsetMin ) )", (const char *)&queryFormat, "!IS_NAN( aimOffsetMin )") )
    __debugbreak();
  __asm { vmovss  [rsp+0A8h+maxRange], xmm11 }
  v26 = (LODWORD(maxRange) & 0x7F800000u) <= 0x7F800000;
  if ( (LODWORD(maxRange) & 0x7F800000) == 2139095040 )
  {
    v27 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23411, ASSERT_TYPE_SANITY, "( !IS_NAN( aimOffsetMax ) )", (const char *)&queryFormat, "!IS_NAN( aimOffsetMax )");
    v26 = !v27;
    if ( v27 )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm7, [rsp+0A8h+angleMin]
    vmovss  xmm8, [rsp+0A8h+angleMax]
    vcomiss xmm7, xmm8
  }
  if ( !v26 )
  {
    __asm
    {
      vcvtss2sd xmm0, xmm8, xmm8
      vmovsd  [rsp+0A8h+var_68], xmm0
      vcvtss2sd xmm1, xmm7, xmm7
      vmovsd  [rsp+0A8h+var_70], xmm1
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23280, ASSERT_TYPE_ASSERT, "( angleMin ) <= ( angleMax )", "%s <= %s\n\t%g, %g", "angleMin", "angleMax", v92, v93) )
      __debugbreak();
  }
  *(double *)&_XMM0 = BG_random(randSeed);
  __asm
  {
    vsubss  xmm1, xmm8, xmm7
    vmulss  xmm0, xmm0, xmm1
    vaddss  xmm0, xmm0, xmm7; angle
  }
  *(double *)&_XMM0 = AngleNormalize360(*(const float *)&_XMM0);
  __asm { vmulss  xmm0, xmm0, cs:__real@3c8efa35; radians }
  FastSinCos(*(const float *)&_XMM0, (float *)&angleMin, (float *)&maxRange);
  BG_random(randSeed);
  __asm
  {
    vmulss  xmm2, xmm10, [rsp+0A8h+maxRange]
    vsubss  xmm5, xmm11, xmm10
    vmulss  xmm1, xmm5, [rsp+0A8h+maxRange]
    vmulss  xmm3, xmm1, xmm0
    vmulss  xmm1, xmm5, [rsp+0A8h+angleMin]
    vaddss  xmm8, xmm3, xmm2
    vmulss  xmm2, xmm1, xmm0
    vmulss  xmm0, xmm10, [rsp+0A8h+angleMin]
    vmovss  [rsp+0A8h+maxRange], xmm8
    vaddss  xmm7, xmm2, xmm0
  }
  if ( (LODWORD(maxRange) & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23420, ASSERT_TYPE_SANITY, "( !IS_NAN( right ) )", (const char *)&queryFormat, "!IS_NAN( right )") )
    __debugbreak();
  __asm { vmovss  [rsp+0A8h+maxRange], xmm7 }
  if ( (LODWORD(maxRange) & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23421, ASSERT_TYPE_SANITY, "( !IS_NAN( up ) )", (const char *)&queryFormat, "!IS_NAN( up )") )
    __debugbreak();
  _RBX = end;
  __asm
  {
    vmulss  xmm0, xmm6, dword ptr [rax]
    vaddss  xmm1, xmm0, dword ptr [rdi]
    vmovss  dword ptr [rbx], xmm1
    vmulss  xmm0, xmm6, dword ptr [rax+4]
    vaddss  xmm2, xmm0, dword ptr [rdi+4]
    vmovss  dword ptr [rbx+4], xmm2
    vmulss  xmm0, xmm6, dword ptr [rax+8]
    vaddss  xmm3, xmm0, dword ptr [rdi+8]
    vmovss  [rsp+0A8h+maxRange], xmm1
  }
  v51 = LODWORD(maxRange) & 0x7F800000;
  __asm { vmovss  dword ptr [rbx+8], xmm3 }
  if ( v51 == 2139095040 )
    goto LABEL_40;
  __asm { vmovss  [rsp+0A8h+maxRange], xmm2 }
  if ( (LODWORD(maxRange) & 0x7F800000) == 2139095040 )
    goto LABEL_40;
  __asm { vmovss  [rsp+0A8h+maxRange], xmm3 }
  if ( (LODWORD(maxRange) & 0x7F800000) == 2139095040 )
  {
LABEL_40:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23425, ASSERT_TYPE_SANITY, "( !IS_NAN( ( end )[0] ) && !IS_NAN( ( end )[1] ) && !IS_NAN( ( end )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( end )[0] ) && !IS_NAN( ( end )[1] ) && !IS_NAN( ( end )[2] )") )
      __debugbreak();
  }
  __asm
  {
    vmulss  xmm0, xmm8, dword ptr [rax]
    vaddss  xmm1, xmm0, dword ptr [rbx]
    vmovss  dword ptr [rbx], xmm1
    vmulss  xmm0, xmm8, dword ptr [rax+4]
    vaddss  xmm2, xmm0, dword ptr [rbx+4]
    vmovss  dword ptr [rbx+4], xmm2
    vmulss  xmm0, xmm8, dword ptr [rax+8]
    vaddss  xmm3, xmm0, dword ptr [rbx+8]
    vmovss  dword ptr [rbx+8], xmm3
    vmulss  xmm0, xmm7, dword ptr [rax]
    vaddss  xmm1, xmm0, xmm1
    vmovss  dword ptr [rbx], xmm1
    vmulss  xmm0, xmm7, dword ptr [rax+4]
    vaddss  xmm4, xmm0, xmm2
    vmovss  dword ptr [rbx+4], xmm4
    vmulss  xmm0, xmm7, dword ptr [rax+8]
    vmovss  [rsp+0A8h+maxRange], xmm1
  }
  v63 = LODWORD(maxRange) & 0x7F800000;
  __asm
  {
    vaddss  xmm2, xmm0, xmm3
    vmovss  dword ptr [rbx+8], xmm2
  }
  if ( v63 == 2139095040 )
    goto LABEL_41;
  __asm { vmovss  [rsp+0A8h+maxRange], xmm4 }
  if ( (LODWORD(maxRange) & 0x7F800000) == 2139095040 )
    goto LABEL_41;
  __asm { vmovss  [rsp+0A8h+maxRange], xmm2 }
  if ( (LODWORD(maxRange) & 0x7F800000) == 2139095040 )
  {
LABEL_41:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23430, ASSERT_TYPE_SANITY, "( !IS_NAN( ( end )[0] ) && !IS_NAN( ( end )[1] ) && !IS_NAN( ( end )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( end )[0] ) && !IS_NAN( ( end )[1] ) && !IS_NAN( ( end )[2] )") )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rbx]
    vsubss  xmm7, xmm0, dword ptr [rdi]
  }
  _RCX = dir;
  __asm
  {
    vmulss  xmm2, xmm7, xmm7
    vmovss  dword ptr [rcx], xmm7
    vmovss  xmm0, dword ptr [rbx+4]
    vsubss  xmm6, xmm0, dword ptr [rdi+4]
    vmovss  dword ptr [rcx+4], xmm6
    vmovss  xmm0, dword ptr [rbx+8]
    vsubss  xmm5, xmm0, dword ptr [rdi+8]
    vmulss  xmm0, xmm5, xmm5
    vmulss  xmm1, xmm6, xmm6
    vaddss  xmm3, xmm2, xmm1
    vmovss  xmm1, cs:__real@3f800000
    vaddss  xmm2, xmm3, xmm0
    vsqrtss xmm4, xmm2, xmm2
    vcmpless xmm0, xmm4, cs:__real@80000000
    vblendvps xmm0, xmm4, xmm1, xmm0
    vdivss  xmm2, xmm1, xmm0
    vmulss  xmm0, xmm2, xmm7
    vmovss  dword ptr [rcx], xmm0
    vmulss  xmm1, xmm6, xmm2
    vmulss  xmm3, xmm5, xmm2
    vmovss  dword ptr [rcx+4], xmm1
    vmovss  dword ptr [rcx+8], xmm3
    vmovss  xmm0, dword ptr [rcx]
    vmovss  [rsp+0A8h+maxRange], xmm0
  }
  if ( (LODWORD(maxRange) & 0x7F800000) == 2139095040 )
    goto LABEL_42;
  __asm { vmovss  [rsp+0A8h+maxRange], xmm1 }
  if ( (LODWORD(maxRange) & 0x7F800000) == 2139095040 )
    goto LABEL_42;
  __asm { vmovss  [rsp+0A8h+maxRange], xmm3 }
  if ( (LODWORD(maxRange) & 0x7F800000) == 2139095040 )
  {
LABEL_42:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23435, ASSERT_TYPE_SANITY, "( !IS_NAN( ( dir )[0] ) && !IS_NAN( ( dir )[1] ) && !IS_NAN( ( dir )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( dir )[0] ) && !IS_NAN( ( dir )[1] ) && !IS_NAN( ( dir )[2] )") )
      __debugbreak();
  }
  _R11 = &v94;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm10, xmmword ptr [r11-40h]
    vmovaps xmm11, xmmword ptr [r11-50h]
  }
}

/*
==============
CG_Weapons_SimulateBulletFire_FakeTrace
==============
*/
bool CG_Weapons_SimulateBulletFire_FakeTrace(const LocalClientNum_t localClientNum, const BulletFireParams *bp, const centity_t *knownHitClientEntity, BulletTraceResults *outResults)
{
  entityState_t *p_nextState; 
  entityType_s eType; 
  char v31; 
  char v32; 
  bool result; 
  vec3_t outOrigin; 
  __int64 v67; 
  char v68; 
  void *retaddr; 

  _RAX = &retaddr;
  v67 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-28h], xmm6
    vmovaps xmmword ptr [rax-38h], xmm7
    vmovaps xmmword ptr [rax-48h], xmm8
    vmovaps xmmword ptr [rax-58h], xmm9
  }
  _RBX = outResults;
  _RSI = bp;
  if ( !bp && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23470, ASSERT_TYPE_ASSERT, "(bp)", (const char *)&queryFormat, "bp") )
    __debugbreak();
  if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23471, ASSERT_TYPE_ASSERT, "(outResults)", (const char *)&queryFormat, "outResults") )
    __debugbreak();
  if ( !knownHitClientEntity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23472, ASSERT_TYPE_ASSERT, "(knownHitClientEntity)", (const char *)&queryFormat, "knownHitClientEntity") )
    __debugbreak();
  if ( (knownHitClientEntity->flags & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23473, ASSERT_TYPE_ASSERT, "(CENextValid( knownHitClientEntity ))", (const char *)&queryFormat, "CENextValid( knownHitClientEntity )") )
    __debugbreak();
  p_nextState = &knownHitClientEntity->nextState;
  if ( knownHitClientEntity == (const centity_t *)-400i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 1921, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
    __debugbreak();
  eType = knownHitClientEntity->nextState.eType;
  if ( (((eType - 1) & 0xFFED) != 0 || eType == ET_ITEM) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23474, ASSERT_TYPE_ASSERT, "(BG_IsCharacterEntity( &knownHitClientEntity->nextState ))", (const char *)&queryFormat, "BG_IsCharacterEntity( &knownHitClientEntity->nextState )") )
    __debugbreak();
  if ( p_nextState->number != knownHitClientEntity->nextState.clientNum && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23475, ASSERT_TYPE_ASSERT, "( knownHitClientEntity->nextState.number ) == ( knownHitClientEntity->nextState.clientNum )", "%s == %s\n\t%i, %i", "knownHitClientEntity->nextState.number", "knownHitClientEntity->nextState.clientNum", p_nextState->number, knownHitClientEntity->nextState.clientNum) )
    __debugbreak();
  memset_0(_RBX, 0, sizeof(BulletTraceResults));
  CG_GetPoseOrigin(&knownHitClientEntity->pose, &outOrigin);
  __asm
  {
    vmovss  xmm0, dword ptr [rsp+0C8h+outOrigin]
    vsubss  xmm7, xmm0, dword ptr [rsi+68h]
    vmovss  xmm1, dword ptr [rsp+0C8h+outOrigin+4]
    vsubss  xmm8, xmm1, dword ptr [rsi+6Ch]
    vmovss  xmm0, dword ptr [rsp+0C8h+outOrigin+8]
    vsubss  xmm9, xmm0, dword ptr [rsi+70h]
    vmovss  xmm0, dword ptr [rsi+74h]
    vsubss  xmm5, xmm0, dword ptr [rsi+68h]
    vmovss  xmm1, dword ptr [rsi+78h]
    vsubss  xmm4, xmm1, dword ptr [rsi+6Ch]
    vmovss  xmm0, dword ptr [rsi+7Ch]
    vsubss  xmm6, xmm0, dword ptr [rsi+70h]
    vmulss  xmm2, xmm4, xmm4
    vmulss  xmm1, xmm5, xmm5
    vaddss  xmm3, xmm2, xmm1
    vmulss  xmm0, xmm6, xmm6
    vaddss  xmm3, xmm3, xmm0
    vcomiss xmm3, cs:__real@358637be
  }
  if ( v31 | v32 )
  {
    _RBX->trace.fraction = 0.0;
    __asm { vxorps  xmm0, xmm0, xmm0; val }
  }
  else
  {
    __asm
    {
      vmulss  xmm1, xmm4, xmm8
      vmulss  xmm0, xmm5, xmm7
      vaddss  xmm2, xmm1, xmm0
      vmulss  xmm1, xmm6, xmm9
      vaddss  xmm2, xmm2, xmm1
      vdivss  xmm0, xmm2, xmm3
      vmovss  dword ptr [rbx], xmm0
    }
  }
  __asm
  {
    vmovss  xmm2, cs:__real@3f800000; max
    vxorps  xmm1, xmm1, xmm1; min
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm
  {
    vmovaps xmm6, xmm0
    vmovss  dword ptr [rbx], xmm0
    vmovss  xmm1, dword ptr [rsi+74h]
    vsubss  xmm2, xmm1, dword ptr [rsi+68h]
    vmulss  xmm3, xmm2, xmm0
    vaddss  xmm4, xmm3, dword ptr [rsi+68h]
    vmovss  dword ptr [rbx+60h], xmm4
    vmovss  xmm1, dword ptr [rsi+78h]
    vsubss  xmm2, xmm1, dword ptr [rsi+6Ch]
    vmulss  xmm0, xmm2, xmm0
    vaddss  xmm3, xmm0, dword ptr [rsi+6Ch]
    vmovss  dword ptr [rbx+64h], xmm3
    vmovss  xmm0, dword ptr [rsi+7Ch]
    vsubss  xmm1, xmm0, dword ptr [rsi+70h]
    vmulss  xmm2, xmm1, xmm6
    vaddss  xmm3, xmm2, dword ptr [rsi+70h]
    vmovss  dword ptr [rbx+68h], xmm3
    vmovss  xmm0, dword ptr [rsi+80h]
    vmovss  xmm3, dword ptr cs:__xmm@80000000800000008000000080000000
    vxorps  xmm0, xmm0, xmm3
    vmovss  dword ptr [rbx+10h], xmm0
    vmovss  xmm1, dword ptr [rsi+84h]
    vxorps  xmm2, xmm1, xmm3
    vmovss  dword ptr [rbx+14h], xmm2
    vmovss  xmm0, dword ptr [rsi+88h]
    vxorps  xmm1, xmm0, xmm3
    vmovss  dword ptr [rbx+18h], xmm1
  }
  _RBX->trace.surfaceFlags = knownHitClientEntity->nextState.surfType << 19;
  _RBX->trace.contents = 1;
  _RBX->trace.hitType = TRACE_HITTYPE_ENTITY;
  _RBX->trace.hitId = (unsigned __int16)p_nextState->number;
  _RBX->depthSurfaceType = knownHitClientEntity->nextState.surfType;
  _RBX->hitClientNum = knownHitClientEntity->nextState.clientNum;
  _RBX->ignoreHitEnt = 0;
  result = 1;
  memset(&outOrigin, 0, sizeof(outOrigin));
  _R11 = &v68;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
  }
  return result;
}

/*
==============
CG_Weapons_SimulateBulletFire_GetKnownHitClientEntity
==============
*/
centity_t *CG_Weapons_SimulateBulletFire_GetKnownHitClientEntity(const LocalClientNum_t localClientNum, const int knownHitClientNum)
{
  centity_t *Entity; 
  centity_t *v5; 
  entityState_t *p_nextState; 
  __int16 eType; 
  __int64 v9; 
  __int64 v10; 
  unsigned int m_characterCount; 

  if ( knownHitClientNum == -1 )
    return 0i64;
  if ( !ComCharacterLimits::ms_isGameDataValid && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_character_limits.h", 123, ASSERT_TYPE_ASSERT, "(ms_isGameDataValid)", (const char *)&queryFormat, "ms_isGameDataValid") )
    __debugbreak();
  if ( knownHitClientNum >= ComCharacterLimits::ms_gameData.m_characterCount )
  {
    if ( !ComCharacterLimits::ms_isGameDataValid && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_character_limits.h", 123, ASSERT_TYPE_ASSERT, "(ms_isGameDataValid)", (const char *)&queryFormat, "ms_isGameDataValid") )
      __debugbreak();
    m_characterCount = ComCharacterLimits::ms_gameData.m_characterCount;
    LODWORD(v9) = knownHitClientNum;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23447, ASSERT_TYPE_ASSERT, "(unsigned)( knownHitClientNum ) < (unsigned)( ComCharacterLimits::GetCharacterMaxCount() )", "knownHitClientNum doesn't index ComCharacterLimits::GetCharacterMaxCount()\n\t%i not in [0, %i)", v9, m_characterCount) )
      __debugbreak();
  }
  Entity = CG_GetEntity(localClientNum, knownHitClientNum);
  v5 = Entity;
  if ( (Entity->flags & 1) == 0 )
    return 0i64;
  p_nextState = &Entity->nextState;
  if ( Entity == (centity_t *)-400i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 1921, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
    __debugbreak();
  eType = p_nextState->eType;
  if ( (((eType - 1) & 0xFFED) != 0 || eType == 3) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23454, ASSERT_TYPE_SANITY, "( BG_IsCharacterEntity( &knownHitClientEntity->nextState ) )", (const char *)&queryFormat, "BG_IsCharacterEntity( &knownHitClientEntity->nextState )") )
    __debugbreak();
  if ( p_nextState->number != knownHitClientNum )
  {
    LODWORD(v10) = knownHitClientNum;
    LODWORD(v9) = p_nextState->number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23455, ASSERT_TYPE_SANITY, "( knownHitClientEntity->nextState.number ) == ( knownHitClientNum )", "knownHitClientEntity->nextState.number == knownHitClientNum\n\t%i, %i", v9, v10) )
      __debugbreak();
  }
  if ( v5->nextState.clientNum != knownHitClientNum )
  {
    LODWORD(v10) = knownHitClientNum;
    LODWORD(v9) = v5->nextState.clientNum;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23456, ASSERT_TYPE_SANITY, "( knownHitClientEntity->nextState.clientNum ) == ( knownHitClientNum )", "knownHitClientEntity->nextState.clientNum == knownHitClientNum\n\t%i, %i", v9, v10) )
      __debugbreak();
  }
  return v5;
}

/*
==============
CG_Weapons_StartWeaponAnim
==============
*/
void CG_Weapons_StartWeaponAnim(LocalClientNum_t localClientNum, const Weapon *weapon, PlayerHandIndex hand, const WeaponAnimNumber anim, const weapAnimFiles_t animIndex, const WeaponAnimNumber prevAnim, const weapAnimFiles_t prevAnimIndex, float transitionTime, bool forceTransitionTime)
{
  __int64 v19; 
  cg_t *LocalClientGlobals; 
  const dvar_t *v21; 
  cg_t *v22; 
  const playerState_s *p_predictedPlayerState; 
  DObj *viewModelDObj; 
  XAnim_s *Anims; 
  char v28; 
  char v29; 
  DObj *v32; 
  DObj *v33; 
  weapAnimFiles_t v34; 
  const XAnimTree *Tree; 
  bool CanModifyAnimWeight; 
  DObj *v40; 
  bool v47; 
  int v48; 
  int v50; 
  weapAnimFiles_t VMRelativeAnimIndex; 
  unsigned int v52; 
  bool ShouldClearAnim; 
  DObj *v54; 
  unsigned __int64 v55; 
  unsigned int *v56; 
  const WeapAnimGroup (*v58)[7]; 
  int v59; 
  const WeapAnimGroup (*v60)[7]; 
  unsigned __int64 i; 
  bool v62; 
  int v63; 
  DObj *v66; 
  int j; 
  weapAnimFiles_t v68; 
  signed int v69; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float fmtc; 
  float fmtd; 
  float fmte; 
  __int64 v85; 
  int v86; 
  float v87; 
  float v88; 
  float v89; 
  float v90; 
  float v91; 
  float v92; 
  float *blendOutTime; 
  float blendOutTimea; 
  float blendOutTimeb; 
  float blendOutTimec; 
  float blendOutTimed; 
  float blendOutTimee; 
  float blendOutTimef; 
  double notifyName; 
  float *v101; 
  float blendInTime; 
  float v103; 
  DObj *obj; 
  cg_t *cgameGlob; 
  WeaponHand *weaponHand; 
  char v110; 
  void *retaddr; 
  bool enabled; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
  }
  v19 = hand;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v21 = DVARBOOL_killswitch_weapon_post_ship_relative_anim_fix_enabled;
  cgameGlob = LocalClientGlobals;
  v22 = LocalClientGlobals;
  p_predictedPlayerState = &LocalClientGlobals->predictedPlayerState;
  if ( !DVARBOOL_killswitch_weapon_post_ship_relative_anim_fix_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_weapon_post_ship_relative_anim_fix_enabled") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v21);
  enabled = v21->current.enabled;
  if ( (unsigned int)(animIndex - 236) > 0xA8 && (unsigned int)(animIndex - 432) > 0xF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2890, ASSERT_TYPE_ASSERT, "(isValidViewmodelAnimIndex)", (const char *)&queryFormat, "isValidViewmodelAnimIndex") )
    __debugbreak();
  if ( (unsigned int)v19 >= 2 )
  {
    LODWORD(blendOutTime) = 2;
    LODWORD(v85) = v19;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v85, blendOutTime) )
      __debugbreak();
  }
  viewModelDObj = v22->m_weaponHand[v19].viewModelDObj;
  weaponHand = &v22->m_weaponHand[v19];
  obj = viewModelDObj;
  if ( !viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2975, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  Anims = XAnimGetAnims(v22->m_weaponHand[v19].tree);
  if ( !Anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2978, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
    __debugbreak();
  *(float *)&_XMM0 = CG_Weapons_GetWeaponStateModifiedAnimRate(localClientNum, p_predictedPlayerState, weapon, (PlayerHandIndex)v19, Anims, animIndex);
  __asm
  {
    vxorps  xmm9, xmm9, xmm9
    vcomiss xmm0, xmm9
    vmovaps xmm8, xmm0
  }
  if ( v28 | v29 )
  {
    __asm
    {
      vcvtss2sd xmm1, xmm8, xmm0
      vmovsd  [rsp+108h+var_C8], xmm1
      vxorpd  xmm2, xmm2, xmm2
      vmovsd  qword ptr [rsp+108h+notifyName], xmm2
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2981, ASSERT_TYPE_ASSERT, "( 0.0f ) < ( rate )", "%s < %s\n\t%g, %g", "0.0f", "rate", notifyName, *(double *)&v101) )
      __debugbreak();
  }
  v32 = obj;
  v86 = v22->playerWeaponInfo.meleeStartTime[v19];
  v33 = obj;
  v22->playerWeaponInfo.meleeStartTime[v19] = v22->predictedPlayerState.meleeStartTime;
  v34 = prevAnimIndex;
  __asm { vmovaps xmm3, xmm8; animRate }
  if ( !WeaponAnimBlendMeleeMisprediction(p_predictedPlayerState, v33, animIndex, *(float *)&_XMM3, prevAnimIndex, v86) )
  {
    CG_Weapons_StoreSprintAnimLength(localClientNum, animIndex, (const PlayerHandIndex)v19);
    Tree = DObjGetTree(v32);
    if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2993, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
      __debugbreak();
    __asm
    {
      vmovaps [rsp+108h+var_48], xmm6
      vmovaps [rsp+108h+var_58], xmm7
      vmovss  [rsp+108h+var_A4], xmm9
      vmovss  [rsp+108h+blendInTime], xmm9
      vmovaps [rsp+108h+var_88], xmm10
    }
    if ( !CG_GetFastADSBlendTimes(localClientNum, p_predictedPlayerState, weapon, anim, prevAnim, &blendInTime, &v103) )
    {
      if ( !p_predictedPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2330, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
        __debugbreak();
      if ( GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&p_predictedPlayerState->pm_flags, ACTIVE, 5u) && anim == WEAP_FORCE_IDLE && (unsigned int)prevAnim > WEAP_FORCE_IDLE )
      {
        _RBX = DCONST_DVARFLT_cg_mantleQuickBlendTime;
        if ( !DCONST_DVARFLT_cg_mantleQuickBlendTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_mantleQuickBlendTime") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(_RBX);
        __asm
        {
          vmovss  xmm0, dword ptr [rbx+28h]
          vmovss  [rsp+108h+blendInTime], xmm0
          vmovss  [rsp+108h+var_A4], xmm0
        }
      }
      else if ( !GetAnimBlendTimes(localClientNum, weapon, p_predictedPlayerState, prevAnim, prevAnimIndex, anim, animIndex, &v103, &blendInTime) )
      {
        goto LABEL_67;
      }
    }
    if ( !forceTransitionTime )
    {
      *(double *)&_XMM0 = XAnimGetRate(Tree, 0, XANIM_SUBTREE_DEFAULT, prevAnimIndex);
      __asm { vmovaps xmm10, xmm0 }
      CanModifyAnimWeight = CG_CanModifyAnimWeight(p_predictedPlayerState, prevAnimIndex);
      v40 = obj;
      if ( CanModifyAnimWeight )
      {
        __asm
        {
          vmovss  xmm0, [rsp+108h+var_A4]
          vmovss  dword ptr [rsp+108h+blendOutTime], xmm10
          vmovss  [rsp+108h+var_E0], xmm0
          vmovss  dword ptr [rsp+108h+fmt], xmm9
        }
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, prevAnimIndex, fmt, v87, blendOutTimea, (scr_string_t)0, 0, 0, LINEAR, NULL);
      }
      __asm { vmovss  xmm6, cs:__real@3f800000 }
      if ( animIndex == WEAP_ANIM_IDLE )
      {
        __asm
        {
          vmovss  xmm0, [rsp+108h+blendInTime]
          vcomiss xmm0, xmm9
        }
      }
      if ( CG_CanModifyAnimWeight(p_predictedPlayerState, animIndex) )
      {
        __asm
        {
          vmovss  xmm0, [rsp+108h+blendInTime]
          vmovss  dword ptr [rsp+108h+blendOutTime], xmm8
          vmovss  [rsp+108h+var_E0], xmm0
          vmovss  dword ptr [rsp+108h+fmt], xmm6
        }
        XAnimSetGoalWeight(v40, 0, XANIM_SUBTREE_DEFAULT, animIndex, fmta, v88, blendOutTimeb, (scr_string_t)0, 1u, 1, LINEAR, NULL);
      }
      __asm
      {
        vmovss  xmm0, [rsp+108h+blendInTime]; blendInDuration
        vmovaps xmm3, xmm8; animRate
      }
      CG_WeaponAnimGroup_BlendIn(*(double *)&_XMM0, animIndex, (const PlayerHandIndex)v19, *(double *)&_XMM3, cgameGlob);
      v47 = enabled;
      v48 = 176;
      __asm { vmovss  xmm7, [rsp+108h+transitionTime] }
      v50 = 0;
      if ( enabled )
        v48 = 192;
      do
      {
        VMRelativeAnimIndex = (unsigned int)CG_Weapons_GetVMRelativeAnimIndex(v50, v47);
        v52 = VMRelativeAnimIndex;
        if ( VMRelativeAnimIndex == prevAnimIndex || VMRelativeAnimIndex == animIndex )
        {
          v54 = obj;
        }
        else
        {
          ShouldClearAnim = CG_ShouldClearAnim(localClientNum, p_predictedPlayerState, VMRelativeAnimIndex);
          v54 = obj;
          if ( ShouldClearAnim )
          {
            __asm
            {
              vmovss  dword ptr [rsp+108h+blendOutTime], xmm6
              vmovss  [rsp+108h+var_E0], xmm7
              vmovss  dword ptr [rsp+108h+fmt], xmm9
            }
            XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, v52, fmtb, v89, blendOutTimec, (scr_string_t)0, 0, 0, LINEAR, NULL);
          }
        }
        v47 = enabled;
        ++v50;
      }
      while ( v50 < v48 );
      v55 = g_weapAnimGroupCount;
      v56 = NULL;
      __asm { vmovss  xmm6, [rsp+108h+var_A4] }
      if ( g_weapAnimGroupCount )
      {
        v58 = g_weapAnimGroups;
        do
        {
          v59 = 0;
          v60 = v58;
          while ( *(_DWORD *)v60 )
          {
            if ( *(_DWORD *)v60 == prevAnimIndex )
            {
              v56 = (unsigned int *)v58;
              break;
            }
            ++v59;
            v60 = (const WeapAnimGroup (*)[7])((char *)v60 + 16);
            if ( v59 >= 7 )
              break;
          }
          ++v58;
          --v55;
        }
        while ( v55 );
        if ( v56 )
        {
          for ( i = 0i64; i < 7; ++i )
          {
            if ( !*v56 )
              break;
            if ( CG_ShouldClearAnim(localClientNum, p_predictedPlayerState, (weapAnimFiles_t)*v56) )
            {
              __asm
              {
                vmovss  dword ptr [rsp+108h+blendOutTime], xmm10
                vmovss  [rsp+108h+var_E0], xmm6
                vmovss  dword ptr [rsp+108h+fmt], xmm9
              }
              XAnimSetGoalWeight(v54, 0, XANIM_SUBTREE_DEFAULT, *v56, fmtc, v90, blendOutTimed, (scr_string_t)0, 0, 0, LINEAR, NULL);
            }
            v56 += 4;
          }
        }
      }
      goto LABEL_78;
    }
LABEL_67:
    v62 = enabled;
    v63 = 176;
    __asm
    {
      vmovss  xmm6, [rsp+108h+transitionTime]
      vmovss  xmm7, cs:__real@3f800000
    }
    v66 = obj;
    if ( enabled )
      v63 = 192;
    for ( j = 0; j < v63; ++j )
    {
      v68 = (unsigned int)CG_Weapons_GetVMRelativeAnimIndex(j, v62);
      v69 = v68;
      if ( animIndex == v68 )
      {
        if ( CG_CanModifyAnimWeight(p_predictedPlayerState, v68) )
        {
          __asm
          {
            vmovss  dword ptr [rsp+108h+blendOutTime], xmm8
            vmovss  [rsp+108h+var_E0], xmm6
            vmovss  dword ptr [rsp+108h+fmt], xmm7
          }
          XAnimSetGoalWeight(v66, 0, XANIM_SUBTREE_DEFAULT, v69, fmtd, v91, blendOutTimee, (scr_string_t)0, 1u, 1, LINEAR, NULL);
        }
        __asm
        {
          vmovaps xmm3, xmm8; animRate
          vmovaps xmm0, xmm6; blendInDuration
        }
        CG_WeaponAnimGroup_BlendIn(*(double *)&_XMM0, (const weapAnimFiles_t)v69, (const PlayerHandIndex)v19, *(double *)&_XMM3, cgameGlob);
      }
      else if ( CG_ShouldClearAnim(localClientNum, p_predictedPlayerState, v68) )
      {
        __asm
        {
          vmovss  dword ptr [rsp+108h+blendOutTime], xmm7
          vmovss  [rsp+108h+var_E0], xmm6
          vmovss  dword ptr [rsp+108h+fmt], xmm9
        }
        XAnimSetGoalWeight(v66, 0, XANIM_SUBTREE_DEFAULT, v69, fmte, v92, blendOutTimef, (scr_string_t)0, 0, 0, LINEAR, NULL);
      }
      v62 = enabled;
    }
    v34 = prevAnimIndex;
LABEL_78:
    __asm
    {
      vmovaps xmm10, [rsp+108h+var_88]
      vmovaps xmm7, [rsp+108h+var_58]
      vmovaps xmm6, [rsp+108h+var_48]
    }
    if ( !CgWeaponMap::ms_instance[localClientNum] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
      __debugbreak();
    if ( BG_IsSprintAdditive(CgWeaponMap::ms_instance[localClientNum], p_predictedPlayerState) && (unsigned int)(v34 - 93) <= 6 )
    {
      __asm { vmovss  xmm3, [rsp+108h+var_A4]; blendOutTime }
      CG_StopSprintAdditives(p_predictedPlayerState, obj, weaponHand, *(double *)&_XMM3);
    }
  }
  _R11 = &v110;
  __asm
  {
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
  }
}

/*
==============
CG_Weapons_StoreSprintAnimLength
==============
*/
void CG_Weapons_StoreSprintAnimLength(LocalClientNum_t localClientNum, const weapAnimFiles_t animIndex, const PlayerHandIndex hand)
{
  const dvar_t *v3; 
  __int64 v5; 
  bool v7; 
  bool v8; 
  cg_t *LocalClientGlobals; 
  cg_t *v10; 
  playerState_s *p_predictedPlayerState; 
  int weaponTime; 

  v3 = DCONST_DVARMPBOOL_movementAnimProto;
  v5 = hand;
  if ( !DCONST_DVARMPBOOL_movementAnimProto && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "movementAnimProto") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v3);
  if ( !v3->current.enabled )
  {
    v7 = animIndex == WEAP_ANIM_SPRINT_IN || animIndex == WEAP_ANIM_ADDITIVE_SPRINT_IN;
    v8 = animIndex == WEAP_ANIM_SPRINT_OUT || animIndex == WEAP_ANIM_SPRINT_IN_CANCEL || animIndex == WEAP_ANIM_ADDITIVE_SPRINT_OUT;
    if ( v7 || v8 )
    {
      LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
      if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2307, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
        __debugbreak();
      v10 = CG_GetLocalClientGlobals(localClientNum);
      p_predictedPlayerState = &v10->predictedPlayerState;
      if ( v10 == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2310, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
        __debugbreak();
      weaponTime = p_predictedPlayerState->weapState[v5].weaponTime;
      if ( weaponTime <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2314, ASSERT_TYPE_ASSERT, "(0 < weaponTime)", "%s\n\tCG_Weapons_StoreSprintAnimLength(): remaining weaponTime must be greater than 0.", "0 < weaponTime") )
        __debugbreak();
      if ( weaponTime < 1 )
        weaponTime = 1;
      if ( v7 )
        LocalClientGlobals->sprintAnimData.sprintInAnimLength = weaponTime;
      else
        LocalClientGlobals->sprintAnimData.sprintOutAnimLength = weaponTime;
    }
  }
}

/*
==============
CG_Weapons_ThermalScopeIsOverlayed
==============
*/
bool CG_Weapons_ThermalScopeIsOverlayed(LocalClientNum_t localClientNum)
{
  const cg_t *LocalClientGlobals; 
  cg_t *v3; 
  const playerState_s *p_predictedPlayerState; 
  CgWeaponMap *Instance; 
  bool outIsAlternate; 
  Weapon r_weapon; 

  if ( !CG_PlayerUsingScopedTurret(localClientNum) )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    if ( !CG_GetWeapReticleZoom(LocalClientGlobals, NULL) )
      return 0;
  }
  v3 = CG_GetLocalClientGlobals(localClientNum);
  p_predictedPlayerState = &v3->predictedPlayerState;
  if ( v3 == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2152, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( BG_IsTurretActiveFlags(&p_predictedPlayerState->eFlags) )
    return 0;
  Instance = CgWeaponMap::GetInstance(localClientNum);
  _RAX = BG_GetViewmodelOrOffhandADSWeapon(Instance, p_predictedPlayerState, &outIsAlternate);
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovups ymmword ptr [rsp+88h+r_weapon.weaponIdx], ymm0
    vmovups xmm1, xmmword ptr [rax+20h]
    vmovups xmmword ptr [rsp+88h+r_weapon.attachmentVariationIndices+5], xmm1
    vmovsd  xmm0, qword ptr [rax+30h]
    vmovsd  qword ptr [rsp+88h+r_weapon.attachmentVariationIndices+15h], xmm0
  }
  *(_DWORD *)&r_weapon.weaponCamo = *(_DWORD *)&_RAX->weaponCamo;
  return BG_IsThermalEnabled(Instance, &r_weapon, p_predictedPlayerState);
}

/*
==============
CG_Weapons_ToggleEquip
==============
*/
void CG_Weapons_ToggleEquip(LocalClientNum_t localClientNum)
{
  CgWeaponMap *Instance; 
  bool equipSelectInAlt; 
  int v5; 
  bool isCurrentValid; 
  bool isOtherValid; 

  _RBX = CG_GetLocalClientGlobals(localClientNum);
  CG_Weapons_ToggleEquip_IsOffhandValid(localClientNum, &isCurrentValid, &isOtherValid);
  if ( !isCurrentValid || isOtherValid )
  {
    if ( !BG_IsSpectating(&_RBX->predictedPlayerState) )
      _RBX->equipSelectInAlt = !_RBX->equipSelectInAlt;
  }
  else
  {
    Instance = CgWeaponMap::GetInstance(localClientNum);
    equipSelectInAlt = _RBX->equipSelectInAlt;
    v5 = 2;
    if ( !equipSelectInAlt )
      v5 = 9;
    if ( _RBX->invalidCmdHintType != v5 )
    {
      _RBX->invalidCmdHintTime = _RBX->time;
      _RBX->invalidCmdHintType = v5;
    }
    _RAX = BG_GetFirstEquippedOffhandBySlot(Instance, &_RBX->predictedPlayerState, (const OffhandSlot)(!equipSelectInAlt + 1));
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovups ymmword ptr [rbx+180BCh], ymm0
      vmovups xmm1, xmmword ptr [rax+20h]
      vmovups xmmword ptr [rbx+180DCh], xmm1
      vmovsd  xmm0, qword ptr [rax+30h]
      vmovsd  qword ptr [rbx+180ECh], xmm0
    }
    *(_DWORD *)&_RBX->invalidCmdHintWeapon.weaponCamo = *(_DWORD *)&_RAX->weaponCamo;
  }
}

/*
==============
CG_Weapons_ToggleEquip_IsOffhandValid
==============
*/
void CG_Weapons_ToggleEquip_IsOffhandValid(LocalClientNum_t localClientNum, bool *isCurrentValid, bool *isOtherValid)
{
  __int64 v3; 
  cg_t *LocalClientGlobals; 
  const playerState_s *p_predictedPlayerState; 
  CgWeaponMap **v8; 
  bool equipSelectInAlt; 
  const BgWeaponMap *v10; 
  const Weapon *OffHandWeaponForSlot; 
  const Weapon *v12; 
  bool v13; 

  v3 = localClientNum;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  p_predictedPlayerState = &LocalClientGlobals->predictedPlayerState;
  v8 = &CgWeaponMap::ms_instance[v3];
  if ( !*v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  equipSelectInAlt = LocalClientGlobals->equipSelectInAlt;
  v10 = *v8;
  OffHandWeaponForSlot = PM_Weapon_GetOffHandWeaponForSlot(v10, p_predictedPlayerState, (OffhandSlot)(equipSelectInAlt + 1));
  v12 = PM_Weapon_GetOffHandWeaponForSlot(v10, p_predictedPlayerState, (OffhandSlot)(!equipSelectInAlt + 1));
  v13 = OffHandWeaponForSlot->weaponIdx && PM_Weapon_OffHandHasAmmo(p_predictedPlayerState, v10, OffHandWeaponForSlot);
  *isCurrentValid = v13;
  *isOtherValid = v12->weaponIdx && PM_Weapon_OffHandHasAmmo(p_predictedPlayerState, v10, v12);
}

/*
==============
CG_Weapons_ToggleEquip_OnOffhandEnd
==============
*/
void CG_Weapons_ToggleEquip_OnOffhandEnd(LocalClientNum_t localClientNum)
{
  cg_t *LocalClientGlobals; 
  bool isCurrentValid; 
  bool isOtherValid; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  CG_Weapons_ToggleEquip_IsOffhandValid(localClientNum, &isCurrentValid, &isOtherValid);
  if ( !isCurrentValid && isOtherValid )
    LocalClientGlobals->equipSelectInAlt = !LocalClientGlobals->equipSelectInAlt;
}

/*
==============
CG_Weapons_ToggleWeaponAltMode
==============
*/
char CG_Weapons_ToggleWeaponAltMode(LocalClientNum_t localClientNum)
{
  cg_t *LocalClientGlobals; 
  __int64 v3; 
  CgWeaponMap *Instance; 
  const Weapon *CurrentWeaponForPlayer; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( LocalClientGlobals->predictedPlayerState.weapState[0].weaponState <= 0x32u )
  {
    v3 = 0x4000000001FBCi64;
    if ( _bittest64(&v3, LocalClientGlobals->predictedPlayerState.weapState[0].weaponState) )
      return 0;
  }
  if ( BG_Skydive_IsSkydiving(&LocalClientGlobals->predictedPlayerState) )
    return 0;
  if ( !LocalClientGlobals->IsClientValid(LocalClientGlobals) )
    return 0;
  if ( GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&LocalClientGlobals->predictedPlayerState.weapCommon.weapFlags, ACTIVE, 0xAu) )
    return 0;
  if ( GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&LocalClientGlobals->predictedPlayerState.weapCommon.weapFlags, ACTIVE, 0xEu) )
    return 0;
  Instance = CgWeaponMap::GetInstance(localClientNum);
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(Instance, &LocalClientGlobals->predictedPlayerState);
  if ( BG_UseLeftTriggerAltFireMode(CurrentWeaponForPlayer) || BG_WeaponDef(CurrentWeaponForPlayer, 0)->inventoryType == WEAPINVENTORY_EXCLUSIVE )
    return 0;
  if ( !BG_UsingAlternate(&LocalClientGlobals->predictedPlayerState) && (!CurrentWeaponForPlayer->weaponIdx || !BG_ActiveUnderbarrel(CurrentWeaponForPlayer)) && !BG_GetAltWeapon(CurrentWeaponForPlayer)->weaponIdx )
    return 0;
  CG_SelectWeapon(localClientNum, &LocalClientGlobals->weaponSelect, LocalClientGlobals->weaponSelectInAlt == 0);
  return 1;
}

/*
==============
CG_Weapons_UpdateSprintAnim
==============
*/
void CG_Weapons_UpdateSprintAnim(LocalClientNum_t localClientNum, const Weapon *weapon, PlayerHandIndex hand, weapAnimFiles_t animIndex)
{
  const dvar_t *v5; 
  cg_t *LocalClientGlobals; 
  const playerState_s *p_predictedPlayerState; 
  const WeaponHand *ViewModelHand; 
  const DObj *viewModelDObj; 
  XAnimTree *Tree; 
  CgHandler *Handler; 
  CgHandler *v15; 
  CgHandler *v16; 
  float fmt; 
  float fmta; 

  v5 = DCONST_DVARBOOL_cg_viewmodelAdditiveSprint;
  if ( !DCONST_DVARBOOL_cg_viewmodelAdditiveSprint && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmodelAdditiveSprint") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v5);
  if ( v5->current.enabled )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3191, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
      __debugbreak();
    p_predictedPlayerState = &LocalClientGlobals->predictedPlayerState;
    if ( LocalClientGlobals == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3193, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    ViewModelHand = cg_t::GetViewModelHand(LocalClientGlobals, hand);
    if ( !ViewModelHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3195, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
      __debugbreak();
    viewModelDObj = ViewModelHand->viewModelDObj;
    if ( !viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3197, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
      __debugbreak();
    Tree = DObjGetTree(viewModelDObj);
    if ( Tree && !BG_IsSuperSprinting(p_predictedPlayerState) && (animIndex == WEAP_ANIM_ADDITIVE_SPRINT_LOOP || animIndex == WEAP_ANIM_SPRINT_LOOP) )
    {
      Handler = CgHandler::getHandler(localClientNum);
      if ( !BG_ViewModelAnimExists(p_predictedPlayerState, WEAP_ANIM_ADDITIVE_SPRINT_IN, hand, Handler) || XAnimHasFinished(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x5Eu) )
      {
        v15 = CgHandler::getHandler(localClientNum);
        if ( !BG_ViewModelAnimExists(p_predictedPlayerState, WEAP_ANIM_SPRINT_IN, hand, v15) || XAnimHasFinished(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x151u) )
        {
          v16 = CgHandler::getHandler(localClientNum);
          if ( BG_ViewModelAnimExists(p_predictedPlayerState, animIndex, hand, v16) )
          {
            *(double *)&_XMM0 = BG_GetBobCycleAnimTime((const int (*)[2])p_predictedPlayerState->packedBobCycle);
            __asm { vmovss  dword ptr [rsp+58h+fmt], xmm0 }
            XAnimSetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, animIndex, fmt);
            __asm
            {
              vxorps  xmm0, xmm0, xmm0
              vmovss  dword ptr [rsp+58h+fmt], xmm0
            }
            XAnimSetAnimRate(Tree, 0, XANIM_SUBTREE_DEFAULT, animIndex, fmta);
          }
        }
      }
    }
  }
}

/*
==============
CG_Weapons_UpdateSuperSprintAnim
==============
*/
void CG_Weapons_UpdateSuperSprintAnim(LocalClientNum_t localClientNum, const Weapon *weapon, PlayerHandIndex hand, weapAnimFiles_t animIndex)
{
  __int64 v7; 
  cg_t *LocalClientGlobals; 
  const playerState_s *p_predictedPlayerState; 
  const WeaponHand *v11; 
  DObj *viewModelDObj; 
  const XAnimTree *Tree; 
  const dvar_t *v14; 
  const dvar_t *v15; 
  signed int v16; 
  char v19; 
  char v20; 
  signed int v23; 
  float fmt; 
  __int64 prevAnim; 
  float prevAnima; 
  float prevAnimIndex; 
  float notifyName; 
  float notifyNamea; 
  float notifyNameb; 

  v7 = hand;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3083, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  p_predictedPlayerState = &LocalClientGlobals->predictedPlayerState;
  if ( LocalClientGlobals == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3086, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( (unsigned int)v7 >= 2 )
  {
    LODWORD(prevAnim) = v7;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1207, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", prevAnim, 2) )
      __debugbreak();
  }
  v11 = &LocalClientGlobals->m_weaponHand[v7];
  if ( (cg_t *)((char *)LocalClientGlobals + 40 * v7) == (cg_t *)-807496i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3089, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
    __debugbreak();
  viewModelDObj = v11->viewModelDObj;
  if ( !v11->viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3092, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  Tree = DObjGetTree(viewModelDObj);
  if ( Tree )
  {
    v14 = DCONST_DVARMPBOOL_movementAnimProto;
    if ( !DCONST_DVARMPBOOL_movementAnimProto && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "movementAnimProto") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v14);
    if ( !v14->current.enabled )
    {
      v15 = DCONST_DVARMPBOOL_superSprintEnable;
      if ( !DCONST_DVARMPBOOL_superSprintEnable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "superSprintEnable") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v15);
      if ( v15->current.enabled )
      {
        v16 = p_predictedPlayerState->weapState[v7].weapAnim & 0xFFFFFF7F;
        if ( BG_IsSuperSprinting(p_predictedPlayerState) )
        {
          if ( (unsigned int)(animIndex - 93) <= 6 || ((v16 - 32) & 0xFFFFFFFC) == 0 && v16 != 33 )
          {
            *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_superSprintBlendOutSprintTime, "superSprintBlendOutSprintTime");
            __asm { vmovaps xmm3, xmm0; blendOutTime }
            CG_StopSprintAdditives(p_predictedPlayerState, viewModelDObj, v11, *(double *)&_XMM3);
            *(double *)&_XMM0 = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x154u);
            __asm
            {
              vxorps  xmm1, xmm1, xmm1
              vcomiss xmm0, xmm1
            }
            if ( v19 | v20 )
            {
              *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_superSprintBlendTime, "superSprintBlendTime");
              __asm { vmovss  [rsp+0A8h+notifyName], xmm0 }
              CG_Weapons_StartWeaponAnim(localClientNum, weapon, (PlayerHandIndex)v7, WEAP_SPRINT_LOOP, WEAP_ANIM_SUPER_SPRINT_LOOP, WEAP_IDLE, WEAP_ANIM_IDLE, notifyName, 0);
            }
          }
          return;
        }
        __asm { vmovaps [rsp+0A8h+var_48], xmm6 }
        *(double *)&_XMM0 = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x154u);
        __asm
        {
          vxorps  xmm6, xmm6, xmm6
          vcomiss xmm0, xmm6
        }
        if ( v19 | v20 )
        {
LABEL_46:
          __asm { vmovaps xmm6, [rsp+0A8h+var_48] }
          return;
        }
        *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_superSprintBlendTime, "superSprintBlendTime");
        __asm
        {
          vmovss  xmm1, cs:__real@3f800000
          vmovss  [rsp+0A8h+prevAnimIndex], xmm1
          vmovss  [rsp+0A8h+prevAnim], xmm0
          vmovss  dword ptr [rsp+0A8h+fmt], xmm6
        }
        XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x154u, fmt, prevAnima, prevAnimIndex, (scr_string_t)0, 0, 0, LINEAR, NULL);
        if ( animIndex == WEAP_ANIM_ADDITIVE_SPRINT_LOOP )
        {
          CG_StartSprintAdditive(localClientNum, p_predictedPlayerState, viewModelDObj, weapon, v11, (const PlayerHandIndex)v7, WEAP_SPRINT_LOOP, WEAP_ANIM_SUPER_SPRINT_LOOP, WEAP_SPRINT_LOOP, WEAP_ANIM_ADDITIVE_SPRINT_LOOP);
          goto LABEL_46;
        }
        if ( ((v16 - 32) & 0xFFFFFFFC) != 0 || v16 == 33 )
        {
          *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_superSprintBlendTime, "superSprintBlendTime");
          __asm { vmovss  [rsp+0A8h+notifyName], xmm0 }
          CG_Weapons_StartWeaponAnim(localClientNum, weapon, (PlayerHandIndex)v7, WEAP_IDLE, WEAP_ANIM_IDLE, WEAP_SPRINT_LOOP, WEAP_ANIM_SUPER_SPRINT_LOOP, notifyNameb, 1);
          goto LABEL_46;
        }
        switch ( v16 )
        {
          case ' ':
            v23 = 337;
            *(double *)&_XMM0 = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x151u);
            __asm { vucomiss xmm0, xmm6 }
            if ( v20 )
              goto LABEL_44;
            v23 = 338;
            break;
          case '"':
            v23 = 339;
            break;
          case '#':
            v23 = 341;
            break;
          default:
            goto LABEL_46;
        }
        *(double *)&_XMM0 = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, v23);
        __asm { vucomiss xmm0, xmm6 }
        if ( !v20 )
          goto LABEL_46;
LABEL_44:
        *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_superSprintBlendTime, "superSprintBlendTime");
        __asm { vmovss  [rsp+0A8h+notifyName], xmm0 }
        CG_Weapons_StartWeaponAnim(localClientNum, weapon, (PlayerHandIndex)v7, (const WeaponAnimNumber)v16, (const weapAnimFiles_t)v23, (const WeaponAnimNumber)v16, WEAP_ANIM_SUPER_SPRINT_LOOP, notifyNamea, 1);
        goto LABEL_46;
      }
    }
  }
}

/*
==============
CalcDistanceFactors
==============
*/
bool CalcDistanceFactors(const vec3_t *listenerOrigin, const MissileConeSoundVars *mcv, float *result_line, float *result_missile)
{
  bool v12; 
  bool v13; 
  char v15; 
  bool v16; 
  bool v25; 
  bool result; 
  float result_projectedDistanceFromStart; 
  vec3_t result_projectedPoint; 

  __asm { vmovaps [rsp+0B8h+var_38], xmm6 }
  _RSI = result_missile;
  _RDI = result_line;
  _RBX = mcv;
  v12 = mcv == NULL;
  if ( !mcv )
  {
    v13 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21947, ASSERT_TYPE_ASSERT, "(mcv)", (const char *)&queryFormat, "mcv");
    v12 = !v13;
    if ( v13 )
      __debugbreak();
  }
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vucomiss xmm6, dword ptr [rbx+30h]
  }
  if ( v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21948, ASSERT_TYPE_ASSERT, "(mcv->height != 0)", (const char *)&queryFormat, "mcv->height != 0") )
    __debugbreak();
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21949, ASSERT_TYPE_ASSERT, "(result_line)", (const char *)&queryFormat, "result_line") )
    __debugbreak();
  if ( !_RSI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21950, ASSERT_TYPE_ASSERT, "(result_missile)", (const char *)&queryFormat, "result_missile") )
    __debugbreak();
  __asm { vmovaps [rsp+0B8h+var_48], xmm7 }
  ProjectPointOntoVectorDir(listenerOrigin, &_RBX->start, &_RBX->dir, &result_projectedPoint, &result_projectedDistanceFromStart);
  __asm
  {
    vmovss  xmm0, [rsp+0B8h+result_projectedDistanceFromStart]
    vdivss  xmm1, xmm0, dword ptr [rbx+30h]
    vcomiss xmm1, xmm6
  }
  if ( v15 )
    goto LABEL_19;
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+2Ch]
    vmovaps [rsp+0B8h+var_58], xmm8
    vmovss  xmm8, cs:__real@3f800000
    vminss  xmm7, xmm1, xmm8
    vsubss  xmm1, xmm0, dword ptr [rbx+28h]
    vmulss  xmm2, xmm1, xmm7
    vmovaps [rsp+0B8h+var_68], xmm9
    vaddss  xmm9, xmm2, dword ptr [rbx+28h]
    vucomiss xmm9, xmm6
  }
  if ( v16 )
  {
    v25 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21965, ASSERT_TYPE_ASSERT, "(maxLineDist != 0.f)", (const char *)&queryFormat, "maxLineDist != 0.f");
    v15 = 0;
    v16 = !v25;
    if ( v25 )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rsp+0B8h+result_projectedPoint]
    vsubss  xmm3, xmm0, dword ptr [rbp+0]
    vmovss  xmm1, dword ptr [rsp+0B8h+result_projectedPoint+4]
    vsubss  xmm2, xmm1, dword ptr [rbp+4]
    vmovss  xmm0, dword ptr [rsp+0B8h+result_projectedPoint+8]
    vsubss  xmm4, xmm0, dword ptr [rbp+8]
    vmulss  xmm2, xmm2, xmm2
    vmulss  xmm1, xmm3, xmm3
    vaddss  xmm3, xmm2, xmm1
    vmulss  xmm0, xmm4, xmm4
    vaddss  xmm2, xmm3, xmm0
    vdivss  xmm0, xmm8, xmm9
    vmovaps xmm9, [rsp+0B8h+var_68]
    vsqrtss xmm1, xmm2, xmm2
    vmulss  xmm2, xmm1, xmm0
    vcomiss xmm2, xmm8
    vmovaps xmm8, [rsp+0B8h+var_58]
  }
  if ( !(v15 | v16) )
  {
LABEL_19:
    result = 0;
    *_RDI = 0.0;
    *_RSI = 0.0;
  }
  else
  {
    __asm
    {
      vmovss  dword ptr [rdi], xmm2
      vmovss  dword ptr [rsi], xmm7
    }
    result = 1;
  }
  __asm
  {
    vmovaps xmm7, [rsp+0B8h+var_48]
    vmovaps xmm6, [rsp+0B8h+var_38]
  }
  return result;
}

/*
==============
MovementAnimState::CalcOffsetTransitionParams
==============
*/
void MovementAnimState::CalcOffsetTransitionParams(MovementAnimState *this, const LocalClientNum_t localClientNum, const XAnimTree *const animTree, const XAnimParts *const *const animArray, const MovementAnimState::State prev, const MovementAnimState::State next, const weapAnimFiles_t prevAnim, weapAnimFiles_t *outNextAnim, float *outBlendTime, float *outPrevRate, float *outNextRate)
{
  MovementAnimState::State v17; 
  __int64 v22; 
  cg_t *LocalClientGlobals; 
  weapAnimFiles_t OffsetAnimation; 
  weapAnimFiles_t *v26; 
  float *v30; 
  unsigned int v31; 
  unsigned int v32; 
  __int64 v33; 
  const XAnimParts *v34; 
  char v36; 
  char v37; 
  const dvar_t *v40; 
  __int64 v41; 
  const XAnimParts *v43; 
  float *outTransDurationSec; 
  float *outCycleTransDurationSec; 
  __int64 v58; 
  double v59; 
  __int64 v60; 
  double v61; 
  char v64; 
  void *retaddr; 

  _R11 = &retaddr;
  v17 = prev;
  __asm
  {
    vmovaps [rsp+0A8h+var_48], xmm7
    vmovaps xmmword ptr [r11-58h], xmm8
  }
  if ( !animTree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5362, ASSERT_TYPE_ASSERT, "( animTree ) != ( nullptr )", "%s != %s\n\t%p, %p", "animTree", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( !animArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5363, ASSERT_TYPE_ASSERT, "( animArray ) != ( nullptr )", "%s != %s\n\t%p, %p", "animArray", "nullptr", NULL, NULL) )
    __debugbreak();
  v22 = next;
  if ( next == -1 )
  {
    LODWORD(v60) = next;
    LODWORD(v58) = next;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5364, ASSERT_TYPE_ASSERT, "( static_cast<int>( next ) ) != ( static_cast<int>( State::NONE ) )", "%s != %s\n\t%i, %i", "static_cast<int>( next )", "static_cast<int>( State::NONE )", v58, v60) )
      __debugbreak();
  }
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  __asm
  {
    vxorps  xmm8, xmm8, xmm8
    vmovss  [rsp+0A8h+prev], xmm8
  }
  MovementAnimState::GetTransitionDuration(this, localClientNum, &LocalClientGlobals->predictedPlayerState, v17, (const MovementAnimState::State)v22, (float *)&prev, (float *)&next);
  OffsetAnimation = MovementAnimState::GetOffsetAnimation(this, (const MovementAnimState::State)v22);
  v26 = outNextAnim;
  _R15 = outBlendTime;
  _RDI = outNextRate;
  __asm { vmovss  xmm7, [rsp+0A8h+prev] }
  *outNextAnim = OffsetAnimation;
  v30 = outPrevRate;
  __asm { vmovss  dword ptr [r15], xmm7 }
  *v30 = 1.0;
  *_RDI = 1.0;
  if ( v17 != -1 || (_DWORD)v22 )
  {
    if ( v17 == (_DWORD)v22 )
    {
      LODWORD(v60) = v22;
      LODWORD(v58) = v17;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5725, ASSERT_TYPE_ASSERT, "( static_cast<int>( prevState ) ) != ( static_cast<int>( nextState ) )", "%s != %s\n\t%i, %i", "static_cast<int>( prevState )", "static_cast<int>( nextState )", v58, v60) )
        __debugbreak();
    }
    if ( v17 != -1 || (v31 = 0, (_DWORD)v22) )
    {
      v32 = 0;
      if ( v17 != -1 )
        v32 = v17;
      if ( (_DWORD)v22 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5750, ASSERT_TYPE_ASSERT, "(nextState != State::NONE)", (const char *)&queryFormat, "nextState != State::NONE") )
        __debugbreak();
      if ( v32 >= 4 )
      {
        LODWORD(outCycleTransDurationSec) = 4;
        LODWORD(outTransDurationSec) = v32;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5751, ASSERT_TYPE_ASSERT, "(unsigned)( static_cast<int>( prevState ) ) < (unsigned)( ( sizeof( *array_counter( s_transitions ) ) + 0 ) )", "static_cast<int>( prevState ) doesn't index ARRAY_COUNT( s_transitions )\n\t%i not in [0, %i)", outTransDurationSec, outCycleTransDurationSec) )
          __debugbreak();
      }
      v31 = v32;
      if ( (unsigned int)v22 >= 4 )
      {
        LODWORD(outCycleTransDurationSec) = 4;
        LODWORD(outTransDurationSec) = v22;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5752, ASSERT_TYPE_ASSERT, "(unsigned)( static_cast<int>( nextState ) ) < (unsigned)( ( sizeof( *array_counter( s_transitions[0] ) ) + 0 ) )", "static_cast<int>( nextState ) doesn't index ARRAY_COUNT( s_transitions[0] )\n\t%i not in [0, %i)", outTransDurationSec, outCycleTransDurationSec) )
          __debugbreak();
      }
      _RDI = outNextRate;
    }
    else if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5734, ASSERT_TYPE_ASSERT, "(nextState != State::WALK)", (const char *)&queryFormat, "nextState != State::WALK") )
    {
      __debugbreak();
    }
    v33 = s_transitions[v31][v22];
    if ( !(_DWORD)v33 )
    {
      LODWORD(v58) = 0;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5754, ASSERT_TYPE_ASSERT, "( static_cast<int>( transitionAnim ) ) != ( 0 )", "%s != %s\n\t%i, %i", "static_cast<int>( transitionAnim )", "0", v58, 0i64) )
        __debugbreak();
    }
    v34 = animArray[v33];
    __asm { vmovaps [rsp+0A8h+var_38], xmm6 }
    if ( v34 )
    {
      *v26 = v33;
      *(double *)&_XMM0 = XAnimGetLengthFromParts(v34);
      __asm
      {
        vcomiss xmm7, xmm8
        vmovaps xmm6, xmm0
      }
      if ( v36 | v37 )
      {
        __asm
        {
          vcvtss2sd xmm1, xmm7, xmm7
          vmovsd  [rsp+0A8h+var_68], xmm1
          vxorpd  xmm2, xmm2, xmm2
          vmovsd  [rsp+0A8h+var_70], xmm2
        }
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5399, ASSERT_TYPE_ASSERT, "( 0.0f ) < ( transDurationSec )", "%s < %s\n\t%g, %g", "0.0f", "transDurationSec", v59, v61) )
          __debugbreak();
      }
      __asm
      {
        vdivss  xmm0, xmm6, xmm7
        vmovss  dword ptr [rdi], xmm0
      }
      v40 = DCONST_DVARMPFLT_movementAnimProto_TransitionBlendTime;
      if ( !DCONST_DVARMPFLT_movementAnimProto_TransitionBlendTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "movementAnimProto_TransitionBlendTime") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v40);
      *_R15 = v40->current.value;
    }
    v41 = prevAnim;
    if ( (unsigned int)(prevAnim - 50) <= 0xB && animArray[prevAnim] )
    {
      *(double *)&_XMM0 = XAnimGetRate(animTree, 0, XANIM_SUBTREE_DEFAULT, prevAnim);
      _RSI = outPrevRate;
      __asm { vmovss  dword ptr [rsi], xmm0 }
      v43 = animArray[v41];
      if ( !v43 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5413, ASSERT_TYPE_ASSERT, "( prevParts ) != ( nullptr )", "%s != %s\n\t%p, %p", "prevParts", "nullptr", NULL, NULL) )
        __debugbreak();
      *(double *)&_XMM0 = XAnimGetTime(animTree, 0, XANIM_SUBTREE_DEFAULT, v41);
      __asm { vmovaps xmm6, xmm0 }
      *(double *)&_XMM0 = XAnimGetLengthFromParts(v43);
      __asm { vmovss  xmm1, cs:__real@3f800000 }
      _RBX = DCONST_DVARMPFLT_movementAnimProto_TransitionToTransitionBlendTime;
      __asm
      {
        vsubss  xmm2, xmm1, xmm6
        vmulss  xmm0, xmm0, xmm2
        vmulss  xmm6, xmm0, dword ptr [rsi]
      }
      if ( !DCONST_DVARMPFLT_movementAnimProto_TransitionToTransitionBlendTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "movementAnimProto_TransitionToTransitionBlendTime") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(_RBX);
      __asm
      {
        vmovss  xmm0, dword ptr [rbx+28h]
        vminss  xmm1, xmm0, xmm6
        vmovss  dword ptr [r15], xmm1
      }
    }
    __asm { vmovaps xmm6, [rsp+0A8h+var_38] }
  }
  else
  {
    *_R15 = 0.0;
    if ( (unsigned int)(*v26 - 50) <= 0xB && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5384, ASSERT_TYPE_ASSERT, "(!IsOffsetAnimationTransition( outNextAnim ))", (const char *)&queryFormat, "!IsOffsetAnimationTransition( outNextAnim )") )
      __debugbreak();
  }
  __asm { vmovaps xmm7, [rsp+0A8h+var_48] }
  _R11 = &v64;
  __asm { vmovaps xmm8, xmmword ptr [r11-30h] }
}

/*
==============
CalcSwimDragFriction
==============
*/
void CalcSwimDragFriction(DObj *obj, LocalClientNum_t localClientNum, const playerState_s *ps, const vec3_t (*viewAxis)[3])
{
  char v25; 
  char v26; 
  double v77; 
  double v78; 
  vec3_t outLookAtPos; 
  void *retaddr; 

  _R11 = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [r11-68h], xmm9
    vmovaps xmmword ptr [r11-0B8h], xmm14
    vmovaps [rsp+138h+var_C8], xmm15
  }
  _RBX = DCONST_DVARFLT_player_swimDragHandLookAtOffset;
  _RDI = ps;
  if ( !DCONST_DVARFLT_player_swimDragHandLookAtOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_swimDragHandLookAtOffset") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm { vmovss  xmm14, dword ptr [rbx+28h] }
  _RBX = DCONST_DVARFLT_player_swimDragHandFrictionMin;
  if ( !DCONST_DVARFLT_player_swimDragHandFrictionMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_swimDragHandFrictionMin") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm { vmovss  xmm0, dword ptr [rbx+28h] }
  _RBX = DCONST_DVARFLT_player_swimDragHandFrictionMax;
  __asm { vmovss  [rsp+138h+var_E8], xmm0 }
  if ( !DCONST_DVARFLT_player_swimDragHandFrictionMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_swimDragHandFrictionMax") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm { vmovss  xmm15, dword ptr [rbx+28h] }
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3511, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  _RBX = CG_GetLocalClientGlobals(localClientNum);
  CalcSwimDragLookAtPosition(_RDI, viewAxis, &outLookAtPos);
  __asm
  {
    vmovss  xmm9, cs:__real@3f800000
    vucomiss xmm9, dword ptr [rdi+730h]
  }
  if ( v26 )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rsp+138h+outLookAtPos]
      vmovss  xmm1, dword ptr [rsp+138h+outLookAtPos+4]
      vmovss  dword ptr [rbx+67580h], xmm0
      vmovss  xmm0, dword ptr [rsp+138h+outLookAtPos+8]
      vmovss  dword ptr [rbx+67588h], xmm0
      vmovss  dword ptr [rbx+67584h], xmm1
    }
  }
  else
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rbx+67580h]
      vmovss  xmm1, dword ptr [rbx+67584h]
      vmovaps [rsp+138h+var_38], xmm6
      vmovss  xmm6, dword ptr [rsp+138h+outLookAtPos]
      vmovaps [rsp+138h+var_48], xmm7
      vmovss  xmm7, dword ptr [rsp+138h+outLookAtPos+4]
      vmovaps [rsp+138h+var_58], xmm8
      vmovss  xmm8, dword ptr [rsp+138h+outLookAtPos+8]
      vmovaps [rsp+138h+var_78], xmm10
      vmovaps [rsp+138h+var_88], xmm11
      vsubss  xmm11, xmm0, xmm6
      vmovss  xmm0, dword ptr [rbx+67588h]
      vmovaps [rsp+138h+var_98], xmm12
      vsubss  xmm12, xmm1, xmm7
      vmulss  xmm1, xmm12, xmm12
      vmovaps [rsp+138h+var_A8], xmm13
      vsubss  xmm13, xmm0, xmm8
      vmulss  xmm0, xmm11, xmm11
      vaddss  xmm2, xmm1, xmm0
      vmulss  xmm1, xmm13, xmm13
      vxorps  xmm0, xmm0, xmm0
      vcomiss xmm14, xmm0
      vaddss  xmm2, xmm2, xmm1
      vsqrtss xmm10, xmm2, xmm2
    }
    if ( v25 | v26 )
    {
      __asm
      {
        vmovsd  [rsp+138h+var_F8], xmm0
        vcvtss2sd xmm1, xmm14, xmm14
        vmovsd  [rsp+138h+var_100], xmm1
      }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3526, ASSERT_TYPE_ASSERT, "( FORWARDOFFSET ) > ( 0.0f )", "%s > %s\n\t%g, %g", "FORWARDOFFSET", "0.0f", v77, v78) )
        __debugbreak();
    }
    __asm
    {
      vdivss  xmm0, xmm10, xmm14; val
      vmovaps xmm2, xmm9; max
      vxorps  xmm1, xmm1, xmm1; min
      vxorps  xmm14, xmm14, xmm14
    }
    *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
    __asm
    {
      vsubss  xmm1, xmm9, xmm0
      vmulss  xmm2, xmm1, [rsp+138h+var_E8]
      vmovd   xmm1, dword ptr [rbx+65E4h]
      vmulss  xmm0, xmm0, xmm15
      vaddss  xmm3, xmm2, xmm0
      vcvtdq2ps xmm1, xmm1
      vmulss  xmm2, xmm3, xmm1
      vmulss  xmm0, xmm2, cs:__real@3a83126f
      vsubss  xmm4, xmm10, xmm0
      vcomiss xmm4, xmm14
    }
    if ( v25 | v26 )
    {
      __asm
      {
        vmovss  dword ptr [rbx+67580h], xmm6
        vmovss  dword ptr [rbx+67584h], xmm7
        vmovss  dword ptr [rbx+67588h], xmm8
      }
    }
    else
    {
      __asm
      {
        vdivss  xmm3, xmm4, xmm10
        vmulss  xmm0, xmm11, xmm3
        vaddss  xmm1, xmm0, xmm6
        vmulss  xmm2, xmm12, xmm3
        vaddss  xmm0, xmm2, xmm7
        vmovss  dword ptr [rbx+67580h], xmm1
        vmulss  xmm1, xmm13, xmm3
        vaddss  xmm2, xmm1, xmm8
        vmovss  dword ptr [rbx+67588h], xmm2
        vmovss  dword ptr [rbx+67584h], xmm0
      }
    }
    __asm
    {
      vmovaps xmm12, [rsp+138h+var_98]
      vmovaps xmm11, [rsp+138h+var_88]
      vmovaps xmm10, [rsp+138h+var_78]
      vmovaps xmm8, [rsp+138h+var_58]
      vmovaps xmm7, [rsp+138h+var_48]
      vmovaps xmm6, [rsp+138h+var_38]
      vmovaps xmm13, [rsp+138h+var_A8]
    }
  }
  __asm
  {
    vmovaps xmm9, [rsp+138h+var_68]
    vmovaps xmm14, [rsp+138h+var_B8]
    vmovaps xmm15, [rsp+138h+var_C8]
  }
}

/*
==============
CalcSwimDragLookAtPosition
==============
*/
void CalcSwimDragLookAtPosition(const playerState_s *ps, const vec3_t (*viewAxis)[3], vec3_t *outLookAtPos)
{
  _RBX = DCONST_DVARFLT_player_swimDragHandLookAtOffset;
  _RSI = outLookAtPos;
  __asm { vmovaps [rsp+58h+var_18], xmm6 }
  if ( !DCONST_DVARFLT_player_swimDragHandLookAtOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_swimDragHandLookAtOffset") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm { vmovss  xmm6, dword ptr [rbx+28h] }
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3297, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  __asm
  {
    vmulss  xmm0, xmm6, dword ptr [rbp+18h]
    vaddss  xmm1, xmm0, dword ptr [rdi+30h]
    vmovss  dword ptr [rsi], xmm1
    vmulss  xmm0, xmm6, dword ptr [rbp+1Ch]
    vaddss  xmm1, xmm0, dword ptr [rdi+34h]
    vmovss  dword ptr [rsi+4], xmm1
    vmulss  xmm0, xmm6, dword ptr [rbp+20h]
    vaddss  xmm1, xmm0, dword ptr [rdi+38h]
    vmovaps xmm6, [rsp+58h+var_18]
    vmovss  dword ptr [rsi+8], xmm1
  }
}

/*
==============
CalcSwimDragWeights
==============
*/
void CalcSwimDragWeights(DObj *obj, LocalClientNum_t localClientNum, const playerState_s *ps, const vec3_t (*viewAxis)[3], float *dragWeights)
{
  char v32; 
  char v54; 
  const XAnimTree *Tree; 
  char v61; 
  double v73; 
  double v74; 
  double v75; 
  vec3_t outLookAtPos; 
  AdditiveEaseInfo easeInfoArray; 
  int v78; 
  int v81; 
  int v84; 
  int v87; 
  int v90; 
  int v93; 
  int v96; 
  int v99; 
  int v102; 
  int v105; 
  int v108; 
  int v111; 
  int v114; 
  int v117; 
  int v120; 
  int v123; 
  int v126; 
  int v129; 
  int v132; 
  int v135; 
  char v138; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-58h], xmm6
    vmovaps xmmword ptr [rax-68h], xmm7
    vmovaps xmmword ptr [rax-78h], xmm8
    vmovaps xmmword ptr [rax-88h], xmm9
    vmovaps xmmword ptr [rax-98h], xmm10
    vmovaps xmmword ptr [rax-0A8h], xmm11
  }
  _RBX = DCONST_DVARFLT_player_swimDragHandLookAtOffset;
  _RDI = dragWeights;
  if ( !DCONST_DVARFLT_player_swimDragHandLookAtOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_swimDragHandLookAtOffset") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  easeInfoArray.animIndex = WEAP_ANIM_SPRINT_IN;
  v78 = 339;
  v81 = 341;
  v84 = 338;
  v87 = 286;
  v90 = 287;
  v93 = 288;
  v96 = 289;
  v99 = 290;
  v102 = 291;
  v105 = 304;
  v108 = 305;
  v111 = 306;
  v114 = 307;
  v117 = 308;
  v120 = 309;
  v123 = 326;
  v126 = 327;
  v129 = 328;
  v132 = 31;
  v135 = 32;
  __asm
  {
    vmovss  xmm0, cs:__real@3f4ccccd
    vmovss  xmm1, cs:__real@3dcccccd
    vmovss  xmm2, cs:__real@3eb33333
    vmovss  xmm9, cs:__real@3f800000
    vmovss  xmm6, dword ptr [rbx+28h]
    vxorps  xmm8, xmm8, xmm8
    vmovss  [rbp+110h+var_178], xmm0
    vmovss  [rbp+110h+var_16C], xmm0
    vmovss  [rbp+110h+var_160], xmm0
    vmovss  [rbp+110h+var_154], xmm0
    vmovss  [rbp+110h+var_148], xmm0
    vmovss  [rbp+110h+var_13C], xmm0
    vmovss  [rbp+110h+var_130], xmm0
    vmovss  [rbp+110h+var_124], xmm0
    vmovss  [rbp+110h+var_118], xmm0
    vmovss  [rbp+110h+var_10C], xmm0
    vmovss  [rbp+110h+var_100], xmm0
    vmovss  [rbp+110h+var_F4], xmm0
    vmovss  xmm0, cs:__real@3e800000
    vmovss  [rbp+110h+var_C8], xmm0
    vmovss  [rbp+110h+var_BC], xmm0
    vmovss  [rsp+210h+easeInfoArray.easeOutTime], xmm2
    vmovss  [rsp+210h+easeInfoArray.easeInTime], xmm9
    vmovss  [rsp+210h+var_1A0], xmm8
    vmovss  [rsp+210h+var_19C], xmm9
    vmovss  [rsp+210h+var_194], xmm8
    vmovss  [rbp+110h+var_190], xmm9
    vmovss  [rbp+110h+var_188], xmm8
    vmovss  [rbp+110h+var_184], xmm2
    vmovss  [rbp+110h+var_17C], xmm1
    vmovss  [rbp+110h+var_170], xmm1
    vmovss  [rbp+110h+var_164], xmm1
    vmovss  [rbp+110h+var_158], xmm1
    vmovss  [rbp+110h+var_14C], xmm1
    vmovss  [rbp+110h+var_140], xmm1
    vmovss  [rbp+110h+var_134], xmm2
    vmovss  [rbp+110h+var_128], xmm2
    vmovss  [rbp+110h+var_11C], xmm2
    vmovss  [rbp+110h+var_110], xmm2
    vmovss  [rbp+110h+var_104], xmm2
    vmovss  [rbp+110h+var_F8], xmm2
    vmovss  [rbp+110h+var_EC], xmm8
    vmovss  [rbp+110h+var_E8], xmm1
    vmovss  [rbp+110h+var_E0], xmm8
    vmovss  [rbp+110h+var_DC], xmm1
    vmovss  [rbp+110h+var_D4], xmm8
    vmovss  [rbp+110h+var_D0], xmm1
    vmovss  [rbp+110h+var_C4], xmm9
    vmovss  [rbp+110h+var_B8], xmm9
  }
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3443, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  _RBX = CG_GetLocalClientGlobals(localClientNum);
  CalcSwimDragLookAtPosition(ps, viewAxis, &outLookAtPos);
  __asm
  {
    vcomiss xmm6, xmm8
    vmovss  xmm0, dword ptr [rbx+67580h]
    vsubss  xmm7, xmm0, dword ptr [rsp+210h+outLookAtPos]
    vmovss  xmm0, dword ptr [rbx+67588h]
    vmovss  xmm1, dword ptr [rbx+67584h]
    vsubss  xmm11, xmm0, dword ptr [rsp+210h+outLookAtPos+8]
    vsubss  xmm10, xmm1, dword ptr [rsp+210h+outLookAtPos+4]
  }
  if ( v54 | v32 )
  {
    __asm
    {
      vxorpd  xmm0, xmm0, xmm0
      vmovsd  [rsp+210h+var_1D0], xmm0
      vcvtss2sd xmm1, xmm6, xmm6
      vmovsd  [rsp+210h+var_1D8], xmm1
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3450, ASSERT_TYPE_ASSERT, "( FORWARDOFFSET ) > ( 0.0f )", "%s > %s\n\t%g, %g", "FORWARDOFFSET", "0.0f", v74, v75) )
      __debugbreak();
  }
  __asm
  {
    vmulss  xmm0, xmm7, dword ptr [r15]
    vmulss  xmm1, xmm10, dword ptr [r15+4]
    vaddss  xmm2, xmm1, xmm0
    vmulss  xmm1, xmm11, dword ptr [r15+8]
    vaddss  xmm0, xmm2, xmm1
    vmulss  xmm1, xmm7, dword ptr [r15+0Ch]
    vmulss  xmm2, xmm10, dword ptr [r15+10h]
    vaddss  xmm3, xmm2, xmm1
    vmulss  xmm2, xmm11, dword ptr [r15+14h]
    vaddss  xmm1, xmm3, xmm2
    vdivss  xmm4, xmm9, xmm6
    vmovss  xmm6, cs:__real@bf800000
    vmulss  xmm7, xmm1, xmm4
    vmovaps xmm1, xmm6; min
    vmulss  xmm0, xmm0, xmm4; val
    vmovaps xmm2, xmm9; max
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm
  {
    vmovaps xmm10, xmm0
    vmovaps xmm0, xmm7; val
    vmovaps xmm2, xmm9; max
    vmovaps xmm1, xmm6; min
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm
  {
    vcomiss xmm10, xmm8
    vmovss  xmm3, dword ptr cs:__xmm@80000000800000008000000080000000
  }
  if ( v54 )
  {
    __asm
    {
      vxorps  xmm1, xmm1, xmm1
      vxorps  xmm2, xmm10, xmm3
    }
  }
  else
  {
    __asm
    {
      vmovaps xmm1, xmm10
      vxorps  xmm2, xmm2, xmm2
    }
  }
  __asm
  {
    vcomiss xmm0, xmm8
    vmovss  dword ptr [rdi+0Ch], xmm2
    vmovss  dword ptr [rdi+4], xmm1
  }
  if ( v54 )
  {
    __asm
    {
      vxorps  xmm1, xmm0, xmm3
      vxorps  xmm0, xmm0, xmm0
    }
  }
  else
  {
    __asm { vxorps  xmm1, xmm1, xmm1 }
  }
  __asm
  {
    vmovss  dword ptr [rdi], xmm0
    vmovss  dword ptr [rdi+8], xmm1
  }
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3480, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  Tree = DObjGetTree(obj);
  *(float *)&_XMM0 = GetAdditiveAnimMax(Tree, ps, &easeInfoArray, 21);
  __asm
  {
    vcomiss xmm0, xmm9
    vmovaps xmm6, xmm0
    vshufps xmm6, xmm6, xmm6, 0
  }
  if ( v61 )
  {
    __asm { vcomiss xmm0, xmm8 }
    if ( v61 )
    {
      __asm
      {
        vcvtss2sd xmm0, xmm0, xmm0
        vmovsd  [rsp+210h+var_1E8], xmm0
      }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3485, ASSERT_TYPE_ASSERT, "( ( blendFraction >= 0.0f ) )", "( blendFraction ) = %g", v73) )
        __debugbreak();
    }
    __asm
    {
      vminps  xmm1, xmm6, xmmword ptr [rdi]
      vmovups xmmword ptr [rdi], xmm1
    }
  }
  _R11 = &v138;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-18h]
    vmovaps xmm7, xmmword ptr [r11-28h]
    vmovaps xmm8, xmmword ptr [r11-38h]
    vmovaps xmm9, xmmword ptr [r11-48h]
    vmovaps xmm10, xmmword ptr [r11-58h]
    vmovaps xmm11, xmmword ptr [r11-68h]
  }
}

/*
==============
CalcViewmodelHitPos
==============
*/
char CalcViewmodelHitPos(const LocalClientNum_t localClientNum, unsigned int eventParm, vec3_t *resultPos, vec3_t *resultNormal)
{
  unsigned __int8 v9; 
  cg_t *LocalClientGlobals; 
  const DObj *viewModelDObj; 
  __int32 v55; 
  const centity_t *Entity; 
  unsigned int DetailPhysicsInstanceId; 
  unsigned int RigidBodyID; 
  HavokPhysics_CollisionQueryResult *ClosestResult; 
  unsigned __int8 *WeaponPriorityMap; 
  bool resultHitFront; 
  Physics_RaycastExtendedData extendedData; 
  vec3_t start; 
  vec3_t end; 
  vec3_t result; 

  _RBX = resultPos;
  v9 = eventParm;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  viewModelDObj = LocalClientGlobals->m_weaponHand[0].viewModelDObj;
  if ( !viewModelDObj || (DObjGetContents(viewModelDObj) & 0x2806931) == 0 )
    return 0;
  __asm
  {
    vmovaps [rsp+100h+var_40], xmm6
    vmovaps [rsp+100h+var_50], xmm7
    vmovaps [rsp+100h+var_60], xmm8
  }
  BG_ShieldHitDecode(v9, &result, &resultHitFront);
  __asm
  {
    vmovss  xmm4, dword ptr [rbp+57h+result]
    vmovss  xmm6, dword ptr [rbp+57h+result+4]
    vmulss  xmm1, xmm6, dword ptr [rdi+6950h]
    vmovss  xmm5, dword ptr [rbp+57h+result+8]
    vmulss  xmm0, xmm4, dword ptr [rdi+6944h]
    vaddss  xmm2, xmm1, xmm0
    vmulss  xmm0, xmm5, dword ptr [rdi+695Ch]
    vaddss  xmm1, xmm2, xmm0
    vmulss  xmm0, xmm6, dword ptr [rdi+6954h]
    vaddss  xmm8, xmm1, dword ptr [rdi+699Ch]
    vmulss  xmm2, xmm4, dword ptr [rdi+6948h]
    vmulss  xmm1, xmm5, dword ptr [rdi+6960h]
    vaddss  xmm3, xmm2, xmm0
    vaddss  xmm0, xmm3, xmm1
    vaddss  xmm7, xmm0, dword ptr [rdi+69A0h]
    vmulss  xmm0, xmm6, dword ptr [rdi+6958h]
    vmulss  xmm1, xmm4, dword ptr [rdi+694Ch]
    vaddss  xmm2, xmm1, xmm0
    vmulss  xmm1, xmm5, dword ptr [rdi+6964h]
    vaddss  xmm0, xmm2, xmm1
    vaddss  xmm6, xmm0, dword ptr [rdi+69A4h]
  }
  _ER12 = 0;
  if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_STILL_LAND|WEAPON_LADDER_AIM) )
  {
    _EAX = resultHitFront;
    __asm
    {
      vmovss  xmm2, cs:__real@c2c80000
      vmovd   xmm1, r12d
      vmovd   xmm0, eax
      vpcmpeqd xmm3, xmm0, xmm1
      vmovss  xmm1, cs:__real@42c80000
      vblendvps xmm4, xmm1, xmm2, xmm3
    }
  }
  else
  {
    __asm { vmovss  xmm4, cs:__real@42c80000 }
  }
  __asm
  {
    vmulss  xmm0, xmm4, dword ptr [rdi+6944h]
    vxorps  xmm2, xmm4, cs:__xmm@80000000800000008000000080000000
    vaddss  xmm1, xmm0, xmm8
    vmovss  dword ptr [rbp+57h+start], xmm1
    vmulss  xmm0, xmm4, dword ptr [rdi+6948h]
    vaddss  xmm1, xmm0, xmm7
    vmovss  dword ptr [rbp+57h+start+4], xmm1
    vmulss  xmm0, xmm4, dword ptr [rdi+694Ch]
    vaddss  xmm1, xmm0, xmm6
    vmovss  dword ptr [rbp+57h+start+8], xmm1
    vmulss  xmm0, xmm2, dword ptr [rdi+6944h]
    vaddss  xmm1, xmm0, xmm8
    vmovss  dword ptr [rbp+57h+end], xmm1
    vmulss  xmm0, xmm2, dword ptr [rdi+6948h]
    vaddss  xmm1, xmm0, xmm7
    vmovss  dword ptr [rbp+57h+end+4], xmm1
    vmulss  xmm0, xmm2, dword ptr [rdi+694Ch]
    vaddss  xmm1, xmm0, xmm6
    vmovss  dword ptr [rbp+57h+end+8], xmm1
  }
  v55 = 3 * localClientNum + 4;
  Entity = CG_GetEntity(localClientNum, LocalClientGlobals->clientNum);
  DetailPhysicsInstanceId = CG_PhysicsCharacterProxy_GetDetailPhysicsInstanceId(localClientNum, Entity);
  __asm
  {
    vmovaps xmm8, [rsp+100h+var_60]
    vmovaps xmm7, [rsp+100h+var_50]
    vmovaps xmm6, [rsp+100h+var_40]
  }
  if ( DetailPhysicsInstanceId == -1 )
    return 0;
  RigidBodyID = Physics_GetRigidBodyID((const Physics_WorldId)v55, DetailPhysicsInstanceId, 0);
  if ( (RigidBodyID & 0xFFFFFF) == 0xFFFFFF )
    return 0;
  ClosestResult = PhysicsQuery_GetClosestResult((Physics_WorldId)v55);
  HavokPhysics_CollisionQueryResult::Reset(ClosestResult, 1);
  WeaponPriorityMap = BG_GetWeaponPriorityMap(&NULL_WEAPON, 0);
  Physics_AddDetailTrace(ClosestResult, WeaponPriorityMap);
  __asm { vxorps  xmm0, xmm0, xmm0 }
  extendedData.ignoreBodies = NULL;
  extendedData.phaseSelection = All;
  extendedData.insideHitType = Physics_RaycastInsideHitType_InsideHits;
  __asm { vmovss  [rbp+57h+var_C8.collisionBuffer], xmm0 }
  *(_WORD *)&extendedData.collectInsideHits = 256;
  extendedData.contents = 41969969;
  extendedData.characterProxyType = PHYSICS_CHARACTERPROXY_TYPE_DETAIL;
  Physics_Raycast((Physics_WorldId)v55, RigidBodyID, &start, &end, &extendedData, ClosestResult);
  if ( !HavokPhysics_CollisionQueryResult::HasHit(ClosestResult) )
    return 0;
  HavokPhysics_CollisionQueryResult::GetRaycastHitNormal(ClosestResult, 0, resultNormal);
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+57h+end]
    vsubss  xmm1, xmm0, dword ptr [rbp+57h+start]
    vmovss  xmm0, dword ptr [rbp+57h+end+4]
    vmovss  dword ptr [rbx], xmm1
    vsubss  xmm1, xmm0, dword ptr [rbp+57h+start+4]
    vmovss  xmm0, dword ptr [rbp+57h+end+8]
    vmovss  dword ptr [rbx+4], xmm1
    vsubss  xmm1, xmm0, dword ptr [rbp+57h+start+8]
    vmovss  dword ptr [rbx+8], xmm1
  }
  *(double *)&_XMM0 = HavokPhysics_CollisionQueryResult::GetRaycastHitFraction(ClosestResult, 0);
  __asm
  {
    vmulss  xmm1, xmm0, dword ptr [rbx]
    vmulss  xmm2, xmm0, dword ptr [rbx+4]
    vmulss  xmm0, xmm0, dword ptr [rbx+8]
    vaddss  xmm5, xmm0, dword ptr [rbp+57h+start+8]
    vaddss  xmm3, xmm1, dword ptr [rbp+57h+start]
    vaddss  xmm4, xmm2, dword ptr [rbp+57h+start+4]
    vmovss  xmm2, cs:MY_TWEAK_FORWARD
    vmovss  dword ptr [rbx+8], xmm5
    vmovss  dword ptr [rbx], xmm3
    vmovss  dword ptr [rbx+4], xmm4
    vmulss  xmm0, xmm2, dword ptr [r15]
    vaddss  xmm1, xmm0, xmm3
    vmovss  dword ptr [rbx], xmm1
    vmulss  xmm0, xmm2, dword ptr [r15+4]
    vaddss  xmm1, xmm0, xmm4
    vmovss  dword ptr [rbx+4], xmm1
    vmulss  xmm0, xmm2, dword ptr [r15+8]
    vaddss  xmm1, xmm0, xmm5
    vmovss  dword ptr [rbx+8], xmm1
  }
  return 1;
}

/*
==============
CgWeaponSystem::CalculateTagOffset
==============
*/
char CgWeaponSystem::CalculateTagOffset(CgWeaponSystem *this, const int entNum, scr_string_t tagName, const vec3_t *worldPos, vec3_t *outTagOffset)
{
  centity_t *Entity; 
  const DObj *ClientDObj; 
  const DObj *v11; 
  int v14; 
  unsigned __int8 inOutIndex[4]; 
  int modelIndex; 
  tmat43_t<vec3_t> outTagMat; 

  if ( (unsigned int)entNum >= 0x800 )
  {
    v14 = 2048;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24009, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", entNum, v14) )
      __debugbreak();
  }
  *(_QWORD *)outTagOffset->v = 0i64;
  outTagOffset->v[2] = 0.0;
  Entity = CG_GetEntity((const LocalClientNum_t)this->m_localClientNum, entNum);
  if ( (Entity->flags & 1) == 0 )
    return 0;
  ClientDObj = Com_GetClientDObj(entNum, this->m_localClientNum);
  v11 = ClientDObj;
  if ( !ClientDObj )
    return 0;
  inOutIndex[0] = -2;
  if ( !DObjGetBoneIndexInternal_66(ClientDObj, tagName, inOutIndex, &modelIndex) || !CG_DObjGetWorldBoneMatrix(&Entity->pose, v11, inOutIndex[0], (tmat33_t<vec3_t> *)&outTagMat, &outTagMat.m[3]) )
    return 0;
  MatrixTransposeTransformVector43(worldPos, &outTagMat, outTagOffset);
  return 1;
}

/*
==============
CgWeaponSystem::ChargeWeaponOnRespawn
==============
*/
void CgWeaponSystem::ChargeWeaponOnRespawn(CgWeaponSystem *this, const playerState_s *ps)
{
  ClientChargeWeaponInfo *InfoStruct; 
  ClientChargeWeaponInfo *v5; 
  const RumbleInfo *rumble; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17265, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  InfoStruct = CgWeaponSystem::ChargedWeaponGetInfoStruct(this, ps->clientNum);
  v5 = InfoStruct;
  if ( InfoStruct )
  {
    rumble = InfoStruct->soundRumbleInfo[0].rumble;
    if ( rumble )
    {
      if ( CG_Rumble_IsActive(this->m_localClientNum, ps->clientNum, rumble) )
        CgWeaponSystem::ChargedWeaponStopRumble(this, v5->soundRumbleInfo);
      else
        v5->soundRumbleInfo[0].rumble = NULL;
    }
  }
  else if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17269, ASSERT_TYPE_ASSERT, "(chargeWeapInfo)", (const char *)&queryFormat, "chargeWeapInfo") )
  {
    __debugbreak();
  }
}

/*
==============
CgWeaponSystem::ChargedWeaponClearClientOnlyChargeAmountOverride
==============
*/
void CgWeaponSystem::ChargedWeaponClearClientOnlyChargeAmountOverride(CgWeaponSystem *this, const playerState_s *ps)
{
  ClientChargeWeaponInfo *InfoStruct; 
  __int64 m_localClientNum; 
  int WeaponHandForViewWeapon; 
  int *weaponChargeAmountOverride; 
  __int64 i; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17171, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  InfoStruct = CgWeaponSystem::ChargedWeaponGetInfoStruct(this, ps->clientNum);
  if ( !InfoStruct && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17175, ASSERT_TYPE_ASSERT, "(chargeWeapInfo)", (const char *)&queryFormat, "chargeWeapInfo") )
    __debugbreak();
  InfoStruct->weaponChargeAmountLerpStartTime = 0;
  m_localClientNum = this->m_localClientNum;
  if ( !CgWeaponMap::ms_instance[m_localClientNum] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  WeaponHandForViewWeapon = BG_PlayerLastWeaponHandForViewWeapon(CgWeaponMap::ms_instance[m_localClientNum], ps);
  if ( WeaponHandForViewWeapon >= 0 )
  {
    weaponChargeAmountOverride = InfoStruct->weaponChargeAmountOverride;
    for ( i = WeaponHandForViewWeapon + 1i64; i; --i )
      *weaponChargeAmountOverride++ = 0;
  }
}

/*
==============
CgWeaponSystem::ChargedWeaponClearViewModelFX
==============
*/
void CgWeaponSystem::ChargedWeaponClearViewModelFX(CgWeaponSystem *this, const centity_t *cent)
{
  ClientChargeWeaponInfo *InfoStruct; 
  ClientChargeWeaponInfo *v4; 
  unsigned int i; 
  scr_string_t MeterBoneName; 
  FXRegisteredDef fxDef; 

  InfoStruct = CgWeaponSystem::ChargedWeaponGetInfoStruct(this, cent->nextState.number);
  v4 = InfoStruct;
  if ( InfoStruct && InfoStruct->fxSlotsPlaying > 0 )
  {
    fxDef.m_particleSystemDef = InfoStruct->fxTypePlaying.m_particleSystemDef;
    if ( fxDef.m_particleSystemDef )
    {
      for ( i = 0; i < BG_WeaponCharge_GetMeterBoneMaxCount(); ++i )
      {
        MeterBoneName = BG_WeaponCharge_GetMeterBoneName(i);
        CG_KillBoltedEffects(this->m_localClientNum, &fxDef, 2048, MeterBoneName);
      }
    }
    v4->fxSlotsPlaying = 0;
    v4->fxTypePlaying.m_particleSystemDef = NULL;
  }
}

/*
==============
CgWeaponSystem::ChargedWeaponGetChargeAmount
==============
*/
__int64 CgWeaponSystem::ChargedWeaponGetChargeAmount(CgWeaponSystem *this, const playerState_s *ps, const PlayerHandIndex hand)
{
  __int64 v3; 
  ClientChargeWeaponInfo *InfoStruct; 
  __int64 result; 
  __int64 v8; 

  v3 = hand;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17498, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( (unsigned int)v3 >= 2 )
  {
    LODWORD(v8) = v3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17499, ASSERT_TYPE_ASSERT, "(unsigned)( hand ) < (unsigned)( NUM_WEAPON_HANDS )", "hand doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v8, 2) )
      __debugbreak();
  }
  InfoStruct = CgWeaponSystem::ChargedWeaponGetInfoStruct(this, ps->clientNum);
  if ( !InfoStruct && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17503, ASSERT_TYPE_ASSERT, "(chargeWeapInfo)", (const char *)&queryFormat, "chargeWeapInfo") )
    __debugbreak();
  result = (unsigned int)InfoStruct->weaponChargeAmountOverride[v3];
  if ( (int)result <= 0 )
    return (unsigned int)ps->weapState[v3].weaponChargeAmount;
  return result;
}

/*
==============
CgWeaponSystem::ChargedWeaponGetInfoStruct
==============
*/
ClientChargeWeaponInfo *CgWeaponSystem::ChargedWeaponGetInfoStruct(CgWeaponSystem *this, const int entNum)
{
  __int64 v2; 
  cg_t *LocalClientGlobals; 

  v2 = entNum;
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17517, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( ((int)v2 < 0 || (unsigned int)v2 >= 0xF8) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17519, ASSERT_TYPE_ASSERT, "(( entNum >= 0 ) && ( entNum < ( sizeof( *array_counter( cgameGlob->chargeWeaponInfo ) ) + 0 ) ))", (const char *)&queryFormat, "( entNum >= 0 ) && ( entNum < ARRAY_COUNT( cgameGlob->chargeWeaponInfo ) )") )
    __debugbreak();
  return &LocalClientGlobals->chargeWeaponInfo[v2];
}

/*
==============
CgWeaponSystem::ChargedWeaponOnBeginCharging
==============
*/
void CgWeaponSystem::ChargedWeaponOnBeginCharging(CgWeaponSystem *this, const playerState_s *ps, const centity_t *cent, const Weapon *weapon, bool isAlternate, bool isPlayerView, ClientChargeWeaponSoundRumbleInfo *soundRumbleInfo)
{
  entityState_t *p_nextState; 
  const char *name; 
  CgSoundSystem *SoundSystem; 
  const char *v14; 
  int number; 
  CgSoundSystem *v16; 
  const RumbleInfo *Rumble; 
  cg_t *LocalClientGlobals; 
  float v20; 
  int isPlayerViewa; 

  if ( !cent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17072, ASSERT_TYPE_ASSERT, "(cent)", (const char *)&queryFormat, "cent") )
    __debugbreak();
  p_nextState = &cent->nextState;
  if ( cent == (const centity_t *)-400i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17074, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
    __debugbreak();
  CgWeaponSystem::ChargedWeaponUpdateWeaponType(this, cent, weapon, isAlternate, isPlayerView);
  CgWeaponSystem::ChargedWeaponStopSound(this, p_nextState->number, &soundRumbleInfo->chargeDownSound);
  CgWeaponSystem::ChargedWeaponStopSound(this, p_nextState->number, &soundRumbleInfo->chargeMaxSound);
  if ( soundRumbleInfo->lastState == CHARGE_WEAPON_SOUND_RUMBLE_STATE_CHARGE_DOWN )
  {
    name = BG_WeaponCharge_GetChargeDownToUpSound(weapon, isAlternate, isPlayerView).name;
    isPlayerViewa = p_nextState->number;
    SoundSystem = CgSoundSystem::GetSoundSystem((const LocalClientNum_t)this->m_localClientNum);
    if ( !SoundSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17052, ASSERT_TYPE_ASSERT, "(soundSystem)", (const char *)&queryFormat, "soundSystem") )
      __debugbreak();
    CgSoundSystem::PlayEntitySoundAliasByLookup(SoundSystem, isPlayerViewa, (SndAliasLookup)name);
    soundRumbleInfo->chargeDownToUpSound.name = name;
  }
  v14 = BG_WeaponCharge_GetChargeUpSound(weapon, isAlternate, isPlayerView).name;
  number = p_nextState->number;
  v16 = CgSoundSystem::GetSoundSystem((const LocalClientNum_t)this->m_localClientNum);
  if ( !v16 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17052, ASSERT_TYPE_ASSERT, "(soundSystem)", (const char *)&queryFormat, "soundSystem") )
    __debugbreak();
  CgSoundSystem::PlayEntitySoundAliasByLookup(v16, number, (SndAliasLookup)v14);
  soundRumbleInfo->chargeUpSound.name = v14;
  if ( ps )
  {
    if ( !CG_Rumble_ShouldNotRumble(this->m_localClientNum) && !soundRumbleInfo->rumble )
    {
      Rumble = BG_WeaponCharge_GetRumble(weapon, isAlternate);
      if ( Rumble )
      {
        LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
        if ( !LocalClientGlobals->nextSnap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17409, ASSERT_TYPE_ASSERT, "(cgameGlob->nextSnap)", (const char *)&queryFormat, "cgameGlob->nextSnap") )
          __debugbreak();
        __asm
        {
          vmovss  xmm0, cs:__real@3f800000
          vmovss  [rsp+68h+var_38], xmm0
        }
        CG_Rumble_PlayDeferred(this->m_localClientNum, Rumble, RUMBLELOOP_LOOP_NOENTFLAG, RUMBLESOURCE_ENTITY, LocalClientGlobals->predictedPlayerState.clientNum, NULL, v20, 0);
        soundRumbleInfo->rumble = Rumble;
      }
    }
  }
}

/*
==============
CgWeaponSystem::ChargedWeaponOnEmptyCharge
==============
*/
void CgWeaponSystem::ChargedWeaponOnEmptyCharge(CgWeaponSystem *this, const centity_t *cent, const Weapon *weapon, bool isAlternate, ClientChargeWeaponSoundRumbleInfo *soundRumbleInfo)
{
  entityState_t *p_nextState; 
  CgSoundSystem *SoundSystem; 
  const char *name; 
  const char *v12; 

  if ( !cent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17138, ASSERT_TYPE_ASSERT, "(cent)", (const char *)&queryFormat, "cent") )
    __debugbreak();
  p_nextState = &cent->nextState;
  if ( !p_nextState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17142, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
    __debugbreak();
  if ( BG_WeaponCharge_GetType(weapon, isAlternate) == PTRDIFF )
  {
    SoundSystem = CgSoundSystem::GetSoundSystem((const LocalClientNum_t)this->m_localClientNum);
    if ( !SoundSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17148, ASSERT_TYPE_ASSERT, "(soundSystem)", (const char *)&queryFormat, "soundSystem") )
      __debugbreak();
    CgSoundSystem::StopSoundAlias(SoundSystem, p_nextState->number, soundRumbleInfo->chargeUpSound);
    name = soundRumbleInfo->chargeDownToUpSound.name;
    soundRumbleInfo->chargeUpSound.name = NULL;
    CgSoundSystem::StopSoundAlias(SoundSystem, p_nextState->number, (SndAliasLookup)name);
    v12 = soundRumbleInfo->chargeMaxSound.name;
    soundRumbleInfo->chargeDownToUpSound.name = NULL;
    CgSoundSystem::StopSoundAlias(SoundSystem, p_nextState->number, (SndAliasLookup)v12);
    soundRumbleInfo->chargeMaxSound.name = NULL;
    CgWeaponSystem::ChargedWeaponStopRumble(this, soundRumbleInfo);
  }
  else
  {
    CgWeaponSystem::ChargedWeaponStopAllSoundsAndRumble(this, p_nextState->number, soundRumbleInfo);
  }
}

/*
==============
CgWeaponSystem::ChargedWeaponOnMaxCharge
==============
*/
void CgWeaponSystem::ChargedWeaponOnMaxCharge(CgWeaponSystem *this, const playerState_s *ps, const centity_t *cent, const Weapon *weapon, bool isAlternate, bool isPlayerView, ClientChargeWeaponSoundRumbleInfo *soundRumbleInfo)
{
  entityState_t *p_nextState; 
  const char *name; 
  int number; 
  CgSoundSystem *SoundSystem; 

  if ( !cent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17117, ASSERT_TYPE_ASSERT, "(cent)", (const char *)&queryFormat, "cent") )
    __debugbreak();
  if ( BG_WeaponCharge_GetType(weapon, isAlternate) == LONG_LONG )
  {
    p_nextState = &cent->nextState;
    if ( cent == (const centity_t *)-400i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17127, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
      __debugbreak();
    CgWeaponSystem::ChargedWeaponStopSound(this, p_nextState->number, &soundRumbleInfo->chargeUpSound);
    CgWeaponSystem::ChargedWeaponStopSound(this, p_nextState->number, &soundRumbleInfo->chargeDownSound);
    name = BG_WeaponCharge_GetChargeMaxSound(weapon, isAlternate, isPlayerView).name;
    number = p_nextState->number;
    SoundSystem = CgSoundSystem::GetSoundSystem((const LocalClientNum_t)this->m_localClientNum);
    if ( !SoundSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17052, ASSERT_TYPE_ASSERT, "(soundSystem)", (const char *)&queryFormat, "soundSystem") )
      __debugbreak();
    CgSoundSystem::PlayEntitySoundAliasByLookup(SoundSystem, number, (SndAliasLookup)name);
    soundRumbleInfo->chargeMaxSound.name = name;
  }
}

/*
==============
CgWeaponSystem::ChargedWeaponOnStopCharging
==============
*/
void CgWeaponSystem::ChargedWeaponOnStopCharging(CgWeaponSystem *this, const playerState_s *ps, const centity_t *cent, const Weapon *weapon, bool isAlternate, bool isPlayerView, ClientChargeWeaponSoundRumbleInfo *soundRumbleInfo)
{
  entityState_t *p_nextState; 
  const char *name; 
  CgSoundSystem *SoundSystem; 
  const char *v14; 
  int number; 
  CgSoundSystem *v16; 
  int soundRumbleInfoa; 

  if ( !cent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17095, ASSERT_TYPE_ASSERT, "(cent)", (const char *)&queryFormat, "cent") )
    __debugbreak();
  p_nextState = &cent->nextState;
  if ( !p_nextState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17097, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
    __debugbreak();
  CgWeaponSystem::ChargedWeaponStopSound(this, p_nextState->number, &soundRumbleInfo->chargeUpSound);
  CgWeaponSystem::ChargedWeaponStopSound(this, p_nextState->number, &soundRumbleInfo->chargeMaxSound);
  if ( soundRumbleInfo->lastState == CHARGE_WEAPON_SOUND_RUMBLE_STATE_CHARGE_UP )
  {
    name = BG_WeaponCharge_GetChargeUpToDownSound(weapon, isAlternate, isPlayerView).name;
    soundRumbleInfoa = p_nextState->number;
    SoundSystem = CgSoundSystem::GetSoundSystem((const LocalClientNum_t)this->m_localClientNum);
    if ( !SoundSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17052, ASSERT_TYPE_ASSERT, "(soundSystem)", (const char *)&queryFormat, "soundSystem") )
      __debugbreak();
    CgSoundSystem::PlayEntitySoundAliasByLookup(SoundSystem, soundRumbleInfoa, (SndAliasLookup)name);
    soundRumbleInfo->chargeUpToDownSound.name = name;
  }
  v14 = BG_WeaponCharge_GetChargeDownSound(weapon, isAlternate, isPlayerView).name;
  number = p_nextState->number;
  v16 = CgSoundSystem::GetSoundSystem((const LocalClientNum_t)this->m_localClientNum);
  if ( !v16 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17052, ASSERT_TYPE_ASSERT, "(soundSystem)", (const char *)&queryFormat, "soundSystem") )
    __debugbreak();
  CgSoundSystem::PlayEntitySoundAliasByLookup(v16, number, (SndAliasLookup)v14);
  soundRumbleInfo->chargeDownSound.name = v14;
  if ( ps )
    CgWeaponSystem::ChargedWeaponStopRumble(this, soundRumbleInfo);
}

/*
==============
CgWeaponSystem::ChargedWeaponPlaySound
==============
*/
SndAliasLookup CgWeaponSystem::ChargedWeaponPlaySound(CgWeaponSystem *this, char *entNum, SndAliasLookup sndAliasLookup, SndAliasLookup a4)
{
  int name; 
  CgSoundSystem *SoundSystem; 
  SndAliasLookup result; 

  name = (int)sndAliasLookup.name;
  SoundSystem = CgSoundSystem::GetSoundSystem((const LocalClientNum_t)this->m_localClientNum);
  if ( !SoundSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17052, ASSERT_TYPE_ASSERT, "(soundSystem)", (const char *)&queryFormat, "soundSystem") )
    __debugbreak();
  CgSoundSystem::PlayEntitySoundAliasByLookup(SoundSystem, name, a4);
  result.name = entNum;
  *(SndAliasLookup *)entNum = a4;
  return result;
}

/*
==============
CgWeaponSystem::ChargedWeaponSetChargeAmountOverride
==============
*/
void CgWeaponSystem::ChargedWeaponSetChargeAmountOverride(CgWeaponSystem *this, const centity_t *cent, const PlayerHandIndex hand, const int chargeAmount)
{
  __int64 v4; 
  ClientChargeWeaponInfo *InfoStruct; 

  v4 = hand;
  if ( (unsigned int)hand >= NUM_WEAPON_HANDS && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17485, ASSERT_TYPE_ASSERT, "(unsigned)( hand ) < (unsigned)( NUM_WEAPON_HANDS )", "hand doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", hand, 2) )
    __debugbreak();
  InfoStruct = CgWeaponSystem::ChargedWeaponGetInfoStruct(this, cent->nextState.number);
  if ( !InfoStruct && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17489, ASSERT_TYPE_ASSERT, "(chargeWeapInfo)", (const char *)&queryFormat, "chargeWeapInfo") )
    __debugbreak();
  InfoStruct->weaponChargeAmountAtTimeOfFire[v4] = chargeAmount;
  InfoStruct->weaponChargeAmountOverride[v4] = chargeAmount;
}

/*
==============
CgWeaponSystem::ChargedWeaponStartRumble
==============
*/
void CgWeaponSystem::ChargedWeaponStartRumble(CgWeaponSystem *this, const Weapon *weapon, bool isAlternate, ClientChargeWeaponSoundRumbleInfo *soundRumbleInfo)
{
  const RumbleInfo *Rumble; 
  cg_t *LocalClientGlobals; 
  float v11; 

  if ( !soundRumbleInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17396, ASSERT_TYPE_ASSERT, "(soundRumbleInfo)", (const char *)&queryFormat, "soundRumbleInfo") )
    __debugbreak();
  if ( !CG_Rumble_ShouldNotRumble(this->m_localClientNum) && !soundRumbleInfo->rumble )
  {
    Rumble = BG_WeaponCharge_GetRumble(weapon, isAlternate);
    if ( Rumble )
    {
      LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
      if ( !LocalClientGlobals->nextSnap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17409, ASSERT_TYPE_ASSERT, "(cgameGlob->nextSnap)", (const char *)&queryFormat, "cgameGlob->nextSnap") )
        __debugbreak();
      __asm
      {
        vmovss  xmm0, cs:__real@3f800000
        vmovss  [rsp+48h+var_18], xmm0
      }
      CG_Rumble_PlayDeferred(this->m_localClientNum, Rumble, RUMBLELOOP_LOOP_NOENTFLAG, RUMBLESOURCE_ENTITY, LocalClientGlobals->predictedPlayerState.clientNum, NULL, v11, 0);
      soundRumbleInfo->rumble = Rumble;
    }
  }
}

/*
==============
CgWeaponSystem::ChargedWeaponStopAllEffects
==============
*/
void CgWeaponSystem::ChargedWeaponStopAllEffects(CgWeaponSystem *this, const centity_t *cent)
{
  ClientChargeWeaponInfo *InfoStruct; 

  InfoStruct = CgWeaponSystem::ChargedWeaponGetInfoStruct(this, cent->nextState.number);
  if ( InfoStruct )
  {
    if ( InfoStruct->currentWeapon.weaponIdx )
      CgWeaponSystem::ChargedWeaponClearViewModelFX(this, cent);
  }
}

/*
==============
CgWeaponSystem::ChargedWeaponStopAllSoundsAndRumble
==============
*/
void CgWeaponSystem::ChargedWeaponStopAllSoundsAndRumble(CgWeaponSystem *this, const int entNum, ClientChargeWeaponSoundRumbleInfo *soundRumbleInfo)
{
  CgSoundSystem *SoundSystem; 
  const char *name; 
  const char *v8; 
  const char *v9; 
  const char *v10; 

  if ( !soundRumbleInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16824, ASSERT_TYPE_ASSERT, "(soundRumbleInfo)", (const char *)&queryFormat, "soundRumbleInfo") )
    __debugbreak();
  SoundSystem = CgSoundSystem::GetSoundSystem((const LocalClientNum_t)this->m_localClientNum);
  if ( !SoundSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16827, ASSERT_TYPE_ASSERT, "(soundSystem)", (const char *)&queryFormat, "soundSystem") )
    __debugbreak();
  CgSoundSystem::StopSoundAlias(SoundSystem, entNum, soundRumbleInfo->chargeUpSound);
  name = soundRumbleInfo->chargeDownSound.name;
  soundRumbleInfo->chargeUpSound.name = NULL;
  CgSoundSystem::StopSoundAlias(SoundSystem, entNum, (SndAliasLookup)name);
  v8 = soundRumbleInfo->chargeUpToDownSound.name;
  soundRumbleInfo->chargeDownSound.name = NULL;
  CgSoundSystem::StopSoundAlias(SoundSystem, entNum, (SndAliasLookup)v8);
  v9 = soundRumbleInfo->chargeDownToUpSound.name;
  soundRumbleInfo->chargeUpToDownSound.name = NULL;
  CgSoundSystem::StopSoundAlias(SoundSystem, entNum, (SndAliasLookup)v9);
  v10 = soundRumbleInfo->chargeMaxSound.name;
  soundRumbleInfo->chargeDownToUpSound.name = NULL;
  CgSoundSystem::StopSoundAlias(SoundSystem, entNum, (SndAliasLookup)v10);
  soundRumbleInfo->chargeUpSound.name = NULL;
  CgWeaponSystem::ChargedWeaponStopRumble(this, soundRumbleInfo);
}

/*
==============
CgWeaponSystem::ChargedWeaponStopRumble
==============
*/
void CgWeaponSystem::ChargedWeaponStopRumble(CgWeaponSystem *this, ClientChargeWeaponSoundRumbleInfo *soundRumbleInfo)
{
  cg_t *LocalClientGlobals; 

  if ( !soundRumbleInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17421, ASSERT_TYPE_ASSERT, "(soundRumbleInfo)", (const char *)&queryFormat, "soundRumbleInfo") )
    __debugbreak();
  if ( !CG_Rumble_ShouldNotRumble(this->m_localClientNum) && soundRumbleInfo->rumble )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
    if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17431, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
      __debugbreak();
    CG_Rumble_StopDeferred(this->m_localClientNum, soundRumbleInfo->rumble, LocalClientGlobals->predictedPlayerState.clientNum);
    soundRumbleInfo->rumble = NULL;
  }
}

/*
==============
CgWeaponSystem::ChargedWeaponStopSound
==============
*/
void CgWeaponSystem::ChargedWeaponStopSound(CgWeaponSystem *this, const int entNum, SndAliasLookup *sndAliasLookup)
{
  CgSoundSystem *SoundSystem; 

  SoundSystem = CgSoundSystem::GetSoundSystem((const LocalClientNum_t)this->m_localClientNum);
  if ( !SoundSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17063, ASSERT_TYPE_ASSERT, "(soundSystem)", (const char *)&queryFormat, "soundSystem") )
    __debugbreak();
  CgSoundSystem::StopSoundAlias(SoundSystem, entNum, (SndAliasLookup)sndAliasLookup->name);
  sndAliasLookup->name = NULL;
}

/*
==============
CgWeaponSystem::ChargedWeaponUpdate
==============
*/
void CgWeaponSystem::ChargedWeaponUpdate(CgWeaponSystem *this, const playerState_s *ps, centity_t *cent, const Weapon *weapon, bool isAlternate, int bViewModel, int bDrawGun)
{
  cg_t *LocalClientGlobals; 
  entityState_t *p_nextState; 
  int number; 
  CgWeaponMap *Instance; 
  bool v14; 
  ClientChargeWeaponInfo *v17; 
  int clientNum; 
  ClientChargeWeaponInfo *InfoStruct; 

  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  p_nextState = &cent->nextState;
  number = cent->nextState.number;
  clientNum = LocalClientGlobals->predictedPlayerState.clientNum;
  if ( clientNum != number || bViewModel || (ps = &LocalClientGlobals->predictedPlayerState, LocalClientGlobals->renderingThirdPerson) || (Instance = CgWeaponMap::GetInstance((const LocalClientNum_t)this->m_localClientNum), BG_IsThirdPersonMode(Instance, ps)) )
  {
    if ( ps )
    {
      v14 = ps->pm_type >= 7;
    }
    else
    {
      if ( cent == (centity_t *)-400i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2004, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
        __debugbreak();
      v14 = GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&cent->nextState.lerp.eFlags, ACTIVE, 0x11u);
    }
    CgWeaponSystem::ChargedWeaponUpdateWeaponType(this, cent, weapon, isAlternate, bViewModel);
    InfoStruct = CgWeaponSystem::ChargedWeaponGetInfoStruct(this, p_nextState->number);
    if ( !InfoStruct && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17024, ASSERT_TYPE_ASSERT, "(chargeWeapInfo)", (const char *)&queryFormat, "chargeWeapInfo") )
      __debugbreak();
    if ( clientNum == number && ps )
    {
      _RSI = CgWeaponSystem::ChargedWeaponGetInfoStruct(this, ps->clientNum);
      if ( !_RSI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16975, ASSERT_TYPE_ASSERT, "(chargeWeapInfo)", (const char *)&queryFormat, "chargeWeapInfo") )
        __debugbreak();
      __asm
      {
        vmovsd  xmm0, qword ptr [rsi+4Ch]
        vmovsd  qword ptr [rsi+54h], xmm0
      }
      _RSI->weapHands[0].weaponChargeAmount = ps->weapState[0].weaponChargeAmount;
      _RSI->weapHands[1].weaponChargeAmount = ps->weapState[1].weaponChargeAmount;
    }
    CgWeaponSystem::ChargedWeaponUpdateRumbleAndSound(this, ps, cent, weapon, isAlternate, bViewModel);
    if ( bViewModel )
    {
      if ( !v14 && InfoStruct->currentWeapon.weaponIdx && bDrawGun )
      {
        if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17042, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
          __debugbreak();
        CgWeaponSystem::ChargedWeaponUpdateViewModelFX(this, ps, cent, weapon, isAlternate);
      }
      else
      {
        CgWeaponSystem::ChargedWeaponClearClientOnlyChargeAmountOverride(this, ps);
        v17 = CgWeaponSystem::ChargedWeaponGetInfoStruct(this, p_nextState->number);
        if ( v17 && v17->currentWeapon.weaponIdx )
          CgWeaponSystem::ChargedWeaponClearViewModelFX(this, cent);
      }
    }
  }
}

/*
==============
CgWeaponSystem::ChargedWeaponUpdateChargeStateForLocalPlayer
==============
*/
void CgWeaponSystem::ChargedWeaponUpdateChargeStateForLocalPlayer(CgWeaponSystem *this, const playerState_s *ps)
{
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16971, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  _RBX = CgWeaponSystem::ChargedWeaponGetInfoStruct(this, ps->clientNum);
  if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16975, ASSERT_TYPE_ASSERT, "(chargeWeapInfo)", (const char *)&queryFormat, "chargeWeapInfo") )
    __debugbreak();
  __asm
  {
    vmovsd  xmm0, qword ptr [rbx+4Ch]
    vmovsd  qword ptr [rbx+54h], xmm0
  }
  _RBX->weapHands[0].weaponChargeAmount = ps->weapState[0].weaponChargeAmount;
  _RBX->weapHands[1].weaponChargeAmount = ps->weapState[1].weaponChargeAmount;
}

/*
==============
CgWeaponSystem::ChargedWeaponUpdateChargeStateFromSnapshot
==============
*/
void CgWeaponSystem::ChargedWeaponUpdateChargeStateFromSnapshot(CgWeaponSystem *this, const int entityNum, const CharacterChargedWeaponInfo *characterChargedWeaponInfo)
{
  if ( !characterChargedWeaponInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16945, ASSERT_TYPE_ASSERT, "(characterChargedWeaponInfo)", (const char *)&queryFormat, "characterChargedWeaponInfo") )
    __debugbreak();
  if ( CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum)->predictedPlayerState.clientNum != entityNum )
  {
    _RBX = CgWeaponSystem::ChargedWeaponGetInfoStruct(this, entityNum);
    if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16957, ASSERT_TYPE_ASSERT, "(chargeWeapInfo)", (const char *)&queryFormat, "chargeWeapInfo") )
      __debugbreak();
    __asm
    {
      vmovsd  xmm0, qword ptr [rbx+4Ch]
      vmovsd  qword ptr [rbx+54h], xmm0
    }
    _RBX->weapHands[0].weaponChargeAmount = characterChargedWeaponInfo->weaponChargeAmount[0];
    _RBX->weapHands[1].weaponChargeAmount = characterChargedWeaponInfo->weaponChargeAmount[1];
  }
}

/*
==============
CgWeaponSystem::ChargedWeaponUpdateClientOnlyChargeAmountOverride
==============
*/
void CgWeaponSystem::ChargedWeaponUpdateClientOnlyChargeAmountOverride(CgWeaponSystem *this, const playerState_s *ps, centity_t *cent, const PlayerHandIndex hand, const Weapon *weapon, bool isAlternate)
{
  __int64 v8; 
  ClientChargeWeaponInfo *InfoStruct; 
  __int64 v11; 
  cg_t *LocalClientGlobals; 
  cg_t *v13; 
  CgWeaponMap *Instance; 
  int v15; 
  int FireWeaponAnim; 
  CgHandler *Handler; 
  bool v18; 
  weapAnimFiles_t v19; 
  CgHandler *v20; 
  int FireAnimTime; 
  int v22; 
  bool v25; 
  int v26; 
  unsigned int shotCount; 
  PlayerHandIndex fireTime; 
  int v41; 
  int fireDelay; 
  bool v43; 

  v8 = hand;
  InfoStruct = CgWeaponSystem::ChargedWeaponGetInfoStruct(this, cent->nextState.number);
  if ( !InfoStruct && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17190, ASSERT_TYPE_ASSERT, "(chargeWeapInfo)", (const char *)&queryFormat, "chargeWeapInfo") )
    __debugbreak();
  v11 = v8;
  if ( ps->weapState[v8].weaponState == 16 || !InfoStruct->weaponChargeAmountOverride[v8] )
  {
    InfoStruct->weaponChargeAmountLerpStartTime = 0;
  }
  else
  {
    LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
    v13 = LocalClientGlobals;
    if ( !InfoStruct->weaponChargeAmountLerpStartTime )
      InfoStruct->weaponChargeAmountLerpStartTime = LocalClientGlobals->time;
    Instance = CgWeaponMap::GetInstance((const LocalClientNum_t)this->m_localClientNum);
    v15 = BG_PlayerDualWielding(ps);
    shotCount = ps->weapState[v8].weaponShotCount;
    v43 = v15 != 0;
    BG_GetFireTime(Instance, ps, weapon, isAlternate, v15 != 0, shotCount, &v41, &fireDelay);
    if ( PM_WeaponClipEmpty(Instance, ps, (PlayerHandIndex)v8) )
    {
      FireWeaponAnim = PM_Weapon_GetFireWeaponAnim(Instance, ps, (PlayerHandIndex)v8);
      Handler = CgHandler::getHandler(this->m_localClientNum);
      fireTime = (int)v8;
      v18 = isAlternate;
      v19 = BG_MapWeaponAnimStateToAnimIndex(Instance, ps, FireWeaponAnim, 0, weapon, isAlternate, fireTime, Handler);
      v20 = CgHandler::getHandler(this->m_localClientNum);
      FireAnimTime = BG_GetFireAnimTime(weapon, v18, v43, ps, v20, v19);
      v22 = v41;
      if ( FireAnimTime )
        v22 = FireAnimTime;
      v41 = v22;
    }
    else
    {
      v18 = isAlternate;
    }
    *(double *)&_XMM0 = BG_WeaponCharge_GetEmptyCooldown(weapon, v18);
    __asm
    {
      vmulss  xmm1, xmm0, cs:__real@447a0000
      vcvttss2si ebx, xmm1
    }
    v25 = _EBX <= v41;
    v26 = _EBX - v41;
    __asm
    {
      vxorps  xmm1, xmm1, xmm1
      vcvtsi2ss xmm1, xmm1, ebx
      vxorps  xmm0, xmm0, xmm0
      vcomiss xmm1, xmm0
    }
    if ( v25 )
      v26 = 300;
    if ( v26 - I_clamp(v13->time - InfoStruct->weaponChargeAmountLerpStartTime, 0, v26) > 0 )
    {
      __asm
      {
        vxorps  xmm1, xmm1, xmm1
        vcvtsi2ss xmm1, xmm1, ecx
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm0, xmm0, ebx
        vdivss  xmm2, xmm1, xmm0
        vxorps  xmm1, xmm1, xmm1
        vcvtsi2ss xmm1, xmm1, dword ptr [rdi+rsi*4+0D0h]
        vmulss  xmm2, xmm2, xmm1
        vcvttss2si eax, xmm2
      }
      InfoStruct->weaponChargeAmountOverride[v11] = _EAX;
      if ( !_EAX )
        InfoStruct->weaponChargeAmountAtTimeOfFire[v11] = 0;
    }
    else
    {
      InfoStruct->weaponChargeAmountAtTimeOfFire[v11] = 0;
      InfoStruct->weaponChargeAmountOverride[v11] = 0;
    }
  }
}

/*
==============
CgWeaponSystem::ChargedWeaponUpdateRumbleAndSound
==============
*/
void CgWeaponSystem::ChargedWeaponUpdateRumbleAndSound(CgWeaponSystem *this, const playerState_s *ps, centity_t *cent, const Weapon *weapon, bool isAlternate, int bViewModel)
{
  const Weapon *v8; 
  centity_t *v9; 
  entityState_t *p_nextState; 
  ClientChargeWeaponInfo *InfoStruct; 
  bool v13; 
  bool IsChargeShotWeapon; 
  __int64 v15; 
  int v16; 
  ClientChargeWeaponSoundRumbleInfo *v18; 
  int weaponChargeAmount; 
  int v20; 
  int lastState; 
  const char *name; 
  int number; 
  CgSoundSystem *SoundSystem; 
  CgSoundSystem *v25; 
  bool v26; 
  const char *v27; 
  int v28; 
  CgSoundSystem *v29; 
  const char *v30; 
  int v31; 
  CgSoundSystem *v32; 
  __int16 eType; 
  __int64 m_localClientNum; 
  CgCompassSystem *v36; 
  void (__fastcall *FunctionPointer_origin)(const vec4_t *, vec3_t *); 
  __int64 isPlayerView; 
  ClientChargeWeaponSoundRumbleInfo *soundRumbleInfo; 
  bool v52; 
  __int64 v53; 
  ClientChargeWeaponInfo *v54; 
  vec3_t origin; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm { vmovaps xmmword ptr [rax-48h], xmm6 }
  v8 = weapon;
  v9 = cent;
  if ( !cent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16850, ASSERT_TYPE_ASSERT, "(cent)", (const char *)&queryFormat, "cent") )
    __debugbreak();
  p_nextState = &v9->nextState;
  InfoStruct = CgWeaponSystem::ChargedWeaponGetInfoStruct(this, v9->nextState.number);
  v54 = InfoStruct;
  if ( !InfoStruct && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16854, ASSERT_TYPE_ASSERT, "(chargeWeapInfo)", (const char *)&queryFormat, "chargeWeapInfo") )
    __debugbreak();
  v13 = isAlternate;
  IsChargeShotWeapon = BG_IsChargeShotWeapon(v8, isAlternate);
  v52 = IsChargeShotWeapon;
  v15 = 0i64;
  v53 = 0i64;
  v16 = bViewModel;
  __asm { vmovsd  xmm6, cs:__real@3f30000000000000 }
  do
  {
    v18 = &InfoStruct->soundRumbleInfo[v15];
    if ( !IsChargeShotWeapon )
    {
      CgWeaponSystem::ChargedWeaponStopAllSoundsAndRumble(this, p_nextState->number, &InfoStruct->soundRumbleInfo[v15]);
      v18->lastState = CHARGE_WEAPON_SOUND_RUMBLE_STATE_NONE;
      goto LABEL_56;
    }
    weaponChargeAmount = InfoStruct->prevWeapHands[v15].weaponChargeAmount;
    v20 = InfoStruct->weapHands[v15].weaponChargeAmount;
    if ( v20 == 4095 )
    {
      lastState = 4;
      if ( BG_WeaponCharge_GetType(v8, v13) == LONG_LONG )
      {
        if ( !p_nextState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17127, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
          __debugbreak();
        CgWeaponSystem::ChargedWeaponStopSound(this, p_nextState->number, &v18->chargeUpSound);
        CgWeaponSystem::ChargedWeaponStopSound(this, p_nextState->number, &v18->chargeDownSound);
        name = BG_WeaponCharge_GetChargeMaxSound(v8, v13, bViewModel != 0).name;
        number = p_nextState->number;
        SoundSystem = CgSoundSystem::GetSoundSystem((const LocalClientNum_t)this->m_localClientNum);
        if ( !SoundSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17052, ASSERT_TYPE_ASSERT, "(soundSystem)", (const char *)&queryFormat, "soundSystem") )
          __debugbreak();
        CgSoundSystem::PlayEntitySoundAliasByLookup(SoundSystem, number, (SndAliasLookup)name);
        v18->chargeMaxSound.name = name;
        v9 = cent;
        v8 = weapon;
        v13 = isAlternate;
      }
      goto LABEL_60;
    }
    if ( !v20 )
    {
      lastState = 3;
      if ( v18->lastState != CHARGE_WEAPON_SOUND_RUMBLE_STATE_CHARGE_EMPTY )
      {
        if ( !p_nextState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17142, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
          __debugbreak();
        if ( BG_WeaponCharge_GetType(v8, v13) == PTRDIFF )
        {
          v25 = CgSoundSystem::GetSoundSystem((const LocalClientNum_t)this->m_localClientNum);
          if ( !v25 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17148, ASSERT_TYPE_ASSERT, "(soundSystem)", (const char *)&queryFormat, "soundSystem") )
            __debugbreak();
          CgSoundSystem::StopSoundAlias(v25, p_nextState->number, v18->chargeUpSound);
          v18->chargeUpSound.name = NULL;
          CgSoundSystem::StopSoundAlias(v25, p_nextState->number, v18->chargeDownToUpSound);
          v18->chargeDownToUpSound.name = NULL;
          CgSoundSystem::StopSoundAlias(v25, p_nextState->number, v18->chargeMaxSound);
          v18->chargeMaxSound.name = NULL;
          CgWeaponSystem::ChargedWeaponStopRumble(this, v18);
        }
        else
        {
          CgWeaponSystem::ChargedWeaponStopAllSoundsAndRumble(this, p_nextState->number, v18);
        }
        v16 = bViewModel;
      }
      if ( v16 && !v15 && !v54->weaponChargeAmountOverride[0] )
        CgWeaponSystem::ChargedWeaponClearViewModelFX(this, v9);
      goto LABEL_55;
    }
    if ( v20 > weaponChargeAmount )
    {
      lastState = 1;
      if ( v18->lastState != CHARGE_WEAPON_SOUND_RUMBLE_STATE_CHARGE_UP )
        CgWeaponSystem::ChargedWeaponOnBeginCharging(this, ps, v9, v8, v13, v16 != 0, v18);
LABEL_60:
      if ( !BG_WeaponCharge_GetHudReveal(v8, v13) )
        goto LABEL_55;
      if ( !p_nextState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 1921, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
        __debugbreak();
      eType = p_nextState->eType;
      if ( (((eType - 1) & 0xFFED) != 0 || eType == 3) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16930, ASSERT_TYPE_ASSERT, "(BG_IsCharacterEntity( &cent->nextState ))", (const char *)&queryFormat, "BG_IsCharacterEntity( &cent->nextState )") )
        __debugbreak();
      m_localClientNum = this->m_localClientNum;
      if ( !(_BYTE)CgCompassSystem::ms_allocatedType )
      {
        LODWORD(soundRumbleInfo) = this->m_localClientNum;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 575, ASSERT_TYPE_ASSERT, "(ms_allocatedType != GameModeType::NONE)", "%s\n\tTrying to access the compass system for localClientNum %d but the compass system type is not known\n", "ms_allocatedType != GameModeType::NONE", soundRumbleInfo) )
          __debugbreak();
      }
      if ( (unsigned int)m_localClientNum >= CgCompassSystem::ms_allocatedCount )
      {
        LODWORD(soundRumbleInfo) = CgCompassSystem::ms_allocatedCount;
        LODWORD(isPlayerView) = m_localClientNum;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 576, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( ms_allocatedCount )", "localClientNum doesn't index ms_allocatedCount\n\t%i not in [0, %i)", isPlayerView, soundRumbleInfo) )
          __debugbreak();
      }
      if ( !CgCompassSystem::ms_compassSystemArray[m_localClientNum] )
      {
        LODWORD(soundRumbleInfo) = m_localClientNum;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_compass.h", 577, ASSERT_TYPE_ASSERT, "(ms_compassSystemArray[localClientNum])", "%s\n\tTrying to access unallocated compass system for localClientNum %d\n", "ms_compassSystemArray[localClientNum]", soundRumbleInfo) )
          __debugbreak();
      }
      v36 = CgCompassSystem::ms_compassSystemArray[m_localClientNum];
      if ( !v9->pose.origin.Get_origin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_pose.h", 380, ASSERT_TYPE_ASSERT, "(pose->origin.Get_origin)", (const char *)&queryFormat, "pose->origin.Get_origin") )
        __debugbreak();
      FunctionPointer_origin = ObfuscateGetFunctionPointer_origin(v9->pose.origin.Get_origin, &v9->pose);
      FunctionPointer_origin(&v9->pose.origin.origin.origin, &origin);
      if ( v9->pose.isPosePrecise )
      {
        __asm
        {
          vmovd   xmm0, dword ptr [rsp+0B8h+origin]
          vcvtdq2pd xmm0, xmm0
          vmulsd  xmm1, xmm0, xmm6
          vcvtsd2ss xmm2, xmm1, xmm1
          vmovss  dword ptr [rsp+0B8h+origin], xmm2
          vmovd   xmm0, dword ptr [rsp+0B8h+origin+4]
          vcvtdq2pd xmm0, xmm0
          vmulsd  xmm1, xmm0, xmm6
          vcvtsd2ss xmm2, xmm1, xmm1
          vmovss  dword ptr [rsp+0B8h+origin+4], xmm2
          vmovd   xmm0, dword ptr [rsp+0B8h+origin+8]
          vcvtdq2pd xmm0, xmm0
          vmulsd  xmm1, xmm0, xmm6
          vcvtsd2ss xmm2, xmm1, xmm1
          vmovss  dword ptr [rsp+0B8h+origin+8], xmm2
        }
      }
      CgCompassSystem::AddContinuousPingInfo(v36, v9, &origin);
      memset(&origin, 0, sizeof(origin));
      goto LABEL_54;
    }
    if ( v20 >= weaponChargeAmount )
    {
      lastState = v18->lastState;
      if ( v18->lastState != CHARGE_WEAPON_SOUND_RUMBLE_STATE_CHARGE_MAX && lastState != 1 )
        goto LABEL_55;
      goto LABEL_60;
    }
    lastState = 2;
    if ( v18->lastState != CHARGE_WEAPON_SOUND_RUMBLE_STATE_CHARGE_DOWN )
    {
      v26 = v16 != 0;
      if ( !p_nextState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17097, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
        __debugbreak();
      CgWeaponSystem::ChargedWeaponStopSound(this, p_nextState->number, &v18->chargeUpSound);
      CgWeaponSystem::ChargedWeaponStopSound(this, p_nextState->number, &v18->chargeMaxSound);
      if ( v18->lastState == CHARGE_WEAPON_SOUND_RUMBLE_STATE_CHARGE_UP )
      {
        v27 = BG_WeaponCharge_GetChargeUpToDownSound(v8, v13, v26).name;
        v28 = p_nextState->number;
        v29 = CgSoundSystem::GetSoundSystem((const LocalClientNum_t)this->m_localClientNum);
        if ( !v29 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17052, ASSERT_TYPE_ASSERT, "(soundSystem)", (const char *)&queryFormat, "soundSystem") )
          __debugbreak();
        CgSoundSystem::PlayEntitySoundAliasByLookup(v29, v28, (SndAliasLookup)v27);
        v18->chargeUpToDownSound.name = v27;
        v8 = weapon;
        v13 = isAlternate;
      }
      v30 = BG_WeaponCharge_GetChargeDownSound(v8, v13, v26).name;
      v31 = p_nextState->number;
      v32 = CgSoundSystem::GetSoundSystem((const LocalClientNum_t)this->m_localClientNum);
      if ( !v32 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17052, ASSERT_TYPE_ASSERT, "(soundSystem)", (const char *)&queryFormat, "soundSystem") )
        __debugbreak();
      CgSoundSystem::PlayEntitySoundAliasByLookup(v32, v31, (SndAliasLookup)v30);
      v18->chargeDownSound.name = v30;
      if ( ps )
        CgWeaponSystem::ChargedWeaponStopRumble(this, v18);
      v15 = v53;
LABEL_54:
      v13 = isAlternate;
    }
LABEL_55:
    v18->lastState = lastState;
    v9 = cent;
    v8 = weapon;
    InfoStruct = v54;
LABEL_56:
    v53 = ++v15;
    v16 = bViewModel;
    IsChargeShotWeapon = v52;
  }
  while ( v15 < 2 );
  __asm { vmovaps xmm6, [rsp+0B8h+var_48] }
}

/*
==============
CgWeaponSystem::ChargedWeaponUpdateViewModelFX
==============
*/
void CgWeaponSystem::ChargedWeaponUpdateViewModelFX(CgWeaponSystem *this, const playerState_s *ps, centity_t *cent, const Weapon *weapon, bool isAlternate)
{
  bool v9; 
  FxCombinedDef v10; 
  unsigned int MeterBoneCount; 
  cg_t *LocalClientGlobals; 
  WeaponHand *m_weaponHand; 
  ClientChargeWeaponInfo *InfoStruct; 
  ClientChargeWeaponInfo *v15; 
  int weaponChargeAmount; 
  int v17; 
  signed int fxSlotsPlaying; 
  int v19; 
  scr_string_t MeterBoneName; 
  unsigned int v21; 
  scr_string_t v22; 
  const ParticleSystemDef *m_particleSystemDef; 
  __int64 v24; 
  __int64 v25; 
  FXRegisteredDef fxDef; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17293, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !cent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17294, ASSERT_TYPE_ASSERT, "(cent)", (const char *)&queryFormat, "cent") )
    __debugbreak();
  v9 = isAlternate;
  v10.particleSystemDef = BG_WeaponCharge_GetMeterEffect(weapon, isAlternate).particleSystemDef;
  if ( v10.particleSystemDef )
  {
    fxDef.m_particleSystemDef = v10.particleSystemDef;
    MeterBoneCount = BG_WeaponCharge_GetMeterBoneCount(weapon, v9);
    if ( MeterBoneCount )
    {
      LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
      if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17311, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
        __debugbreak();
      m_weaponHand = LocalClientGlobals->m_weaponHand;
      if ( !m_weaponHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17316, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
        __debugbreak();
      if ( m_weaponHand->viewModelDObj )
      {
        InfoStruct = CgWeaponSystem::ChargedWeaponGetInfoStruct(this, cent->nextState.number);
        if ( InfoStruct )
        {
          CgWeaponSystem::ChargedWeaponUpdateClientOnlyChargeAmountOverride(this, ps, cent, WEAPON_HAND_DEFAULT, weapon, v9);
          if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17498, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
            __debugbreak();
          v15 = CgWeaponSystem::ChargedWeaponGetInfoStruct(this, ps->clientNum);
          if ( !v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17503, ASSERT_TYPE_ASSERT, "(chargeWeapInfo)", (const char *)&queryFormat, "chargeWeapInfo") )
            __debugbreak();
          weaponChargeAmount = v15->weaponChargeAmountOverride[0];
          if ( weaponChargeAmount <= 0 )
            weaponChargeAmount = ps->weapState[0].weaponChargeAmount;
          v17 = BG_WeaponCharge_CalcNumTagsUsed(weapon, v9, weaponChargeAmount);
          fxSlotsPlaying = InfoStruct->fxSlotsPlaying;
          v19 = v17;
          if ( fxSlotsPlaying < v17 )
          {
            do
            {
              if ( fxSlotsPlaying >= MeterBoneCount )
              {
                LODWORD(v25) = MeterBoneCount;
                LODWORD(v24) = fxSlotsPlaying;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17337, ASSERT_TYPE_ASSERT, "(unsigned)( i ) < (unsigned)( tagCount )", "i doesn't index tagCount\n\t%i not in [0, %i)", v24, v25) )
                  __debugbreak();
              }
              if ( InfoStruct->fxSlotsPlaying >= (signed int)MeterBoneCount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17338, ASSERT_TYPE_ASSERT, "(chargeWeapInfo->fxSlotsPlaying < tagCount)", (const char *)&queryFormat, "chargeWeapInfo->fxSlotsPlaying < tagCount") )
                __debugbreak();
              ++InfoStruct->fxSlotsPlaying;
              MeterBoneName = BG_WeaponCharge_GetMeterBoneName(fxSlotsPlaying);
              CG_PlayBoltedEffect(this->m_localClientNum, &fxDef, 2048, MeterBoneName);
              ++fxSlotsPlaying;
            }
            while ( fxSlotsPlaying < v19 );
            fxSlotsPlaying = InfoStruct->fxSlotsPlaying;
          }
          v21 = fxSlotsPlaying - 1;
          if ( fxSlotsPlaying - 1 >= v19 )
          {
            do
            {
              if ( v21 >= MeterBoneCount )
              {
                LODWORD(v25) = MeterBoneCount;
                LODWORD(v24) = v21;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17346, ASSERT_TYPE_ASSERT, "(unsigned)( i ) < (unsigned)( tagCount )", "i doesn't index tagCount\n\t%i not in [0, %i)", v24, v25) )
                  __debugbreak();
              }
              if ( InfoStruct->fxSlotsPlaying <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17347, ASSERT_TYPE_ASSERT, "(chargeWeapInfo->fxSlotsPlaying > 0)", (const char *)&queryFormat, "chargeWeapInfo->fxSlotsPlaying > 0") )
                __debugbreak();
              --InfoStruct->fxSlotsPlaying;
              v22 = BG_WeaponCharge_GetMeterBoneName(v21);
              CG_KillBoltedEffects(this->m_localClientNum, &fxDef, 2048, v22);
              --v21;
            }
            while ( (int)v21 >= v19 );
            fxSlotsPlaying = InfoStruct->fxSlotsPlaying;
          }
          m_particleSystemDef = NULL;
          if ( fxSlotsPlaying > 0 )
            m_particleSystemDef = fxDef.m_particleSystemDef;
          InfoStruct->fxTypePlaying.m_particleSystemDef = m_particleSystemDef;
        }
      }
    }
  }
}

/*
==============
CgWeaponSystem::ChargedWeaponUpdateWeaponType
==============
*/
void CgWeaponSystem::ChargedWeaponUpdateWeaponType(CgWeaponSystem *this, const centity_t *cent, const Weapon *weapon, bool isAlternate)
{
  ClientChargeWeaponInfo *InfoStruct; 
  ClientChargeWeaponInfo *v13; 

  _RSI = weapon;
  InfoStruct = CgWeaponSystem::ChargedWeaponGetInfoStruct(this, cent->nextState.number);
  _RDI = InfoStruct;
  if ( InfoStruct && (memcmp_0(&InfoStruct->currentWeapon, _RSI, 0x3Cui64) || _RDI->currentWeaponIsAlt != isAlternate) )
  {
    if ( BG_WeaponCharge_GetType(_RSI, isAlternate) )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rsi]
        vmovups ymmword ptr [rdi+0Ch], ymm0
        vmovups xmm1, xmmword ptr [rsi+20h]
        vmovups xmmword ptr [rdi+2Ch], xmm1
        vmovsd  xmm0, qword ptr [rsi+30h]
        vmovsd  qword ptr [rdi+3Ch], xmm0
      }
      *(_DWORD *)&_RDI->currentWeapon.weaponCamo = *(_DWORD *)&_RSI->weaponCamo;
      _RDI->currentWeaponIsAlt = isAlternate;
      v13 = CgWeaponSystem::ChargedWeaponGetInfoStruct(this, cent->nextState.number);
      if ( v13 )
      {
        if ( v13->currentWeapon.weaponIdx )
          CgWeaponSystem::ChargedWeaponClearViewModelFX(this, cent);
      }
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr cs:?NULL_WEAPON@@3UWeapon@@B.weaponIdx; Weapon const NULL_WEAPON
        vmovups ymmword ptr [rdi+0Ch], ymm0
        vmovups xmm1, xmmword ptr cs:?NULL_WEAPON@@3UWeapon@@B.attachmentVariationIndices+5; Weapon const NULL_WEAPON
        vmovups xmmword ptr [rdi+2Ch], xmm1
        vmovsd  xmm0, qword ptr cs:?NULL_WEAPON@@3UWeapon@@B.attachmentVariationIndices+15h; Weapon const NULL_WEAPON
        vmovsd  qword ptr [rdi+3Ch], xmm0
      }
      *(_DWORD *)&_RDI->currentWeapon.weaponCamo = *(_DWORD *)&NULL_WEAPON.weaponCamo;
      _RDI->currentWeaponIsAlt = 0;
    }
  }
}

/*
==============
CgWeaponSystem::ClaimBulletId
==============
*/
__int64 CgWeaponSystem::ClaimBulletId(CgWeaponSystem *this)
{
  __int64 result; 

  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25541, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  result = (unsigned int)this->m_nextBulletId;
  this->m_nextBulletId = result + 1;
  return result;
}

/*
==============
ClampDragPositionToLookAtPlane
==============
*/
void ClampDragPositionToLookAtPlane(LocalClientNum_t localClientNum, const playerState_s *ps, const vec3_t (*viewAxis)[3])
{
  char v13; 
  char v30; 
  vec3_t outLookAtPos; 
  char v62; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-28h], xmm6
    vmovaps xmmword ptr [rax-38h], xmm7
    vmovaps xmmword ptr [rax-48h], xmm8
  }
  _RBX = DCONST_DVARFLT_player_swimDragHandLookAtOffset;
  if ( !DCONST_DVARFLT_player_swimDragHandLookAtOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_swimDragHandLookAtOffset") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm { vmovss  xmm6, dword ptr [rbx+28h] }
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3312, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  _RBX = CG_GetLocalClientGlobals(localClientNum);
  CalcSwimDragLookAtPosition(ps, viewAxis, &outLookAtPos);
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+67580h]
    vsubss  xmm5, xmm0, dword ptr [rsp+0A8h+outLookAtPos]
    vmovss  xmm1, dword ptr [rbx+67584h]
    vsubss  xmm7, xmm1, dword ptr [rsp+0A8h+outLookAtPos+4]
    vmovss  xmm0, dword ptr [rbx+67588h]
    vsubss  xmm8, xmm0, dword ptr [rsp+0A8h+outLookAtPos+8]
    vmulss  xmm0, xmm5, xmm5
    vmulss  xmm1, xmm7, xmm7
    vaddss  xmm2, xmm1, xmm0
    vmulss  xmm1, xmm8, xmm8
    vaddss  xmm2, xmm2, xmm1
    vmovss  xmm1, cs:__real@3f800000
    vsqrtss xmm3, xmm2, xmm2
    vcomiss xmm3, xmm6
    vcmpless xmm0, xmm3, cs:__real@80000000
    vblendvps xmm0, xmm3, xmm1, xmm0
    vdivss  xmm2, xmm1, xmm0
  }
  if ( !(v13 | v30) )
  {
    __asm
    {
      vmulss  xmm0, xmm2, xmm5
      vmulss  xmm5, xmm0, xmm6
      vmulss  xmm0, xmm2, xmm8
      vmulss  xmm1, xmm2, xmm7
      vmulss  xmm8, xmm0, xmm6
      vmulss  xmm7, xmm1, xmm6
      vmovaps xmm3, xmm6
    }
  }
  __asm { vcomiss xmm3, cs:__real@3a83126f }
  if ( !v13 )
  {
    __asm
    {
      vmulss  xmm1, xmm5, dword ptr [rsi]
      vmulss  xmm0, xmm7, dword ptr [rsi+4]
      vaddss  xmm2, xmm1, xmm0
      vmulss  xmm0, xmm5, dword ptr [rsi+0Ch]
      vmulss  xmm1, xmm8, dword ptr [rsi+8]
      vaddss  xmm6, xmm2, xmm1
      vmulss  xmm1, xmm7, dword ptr [rsi+10h]
      vaddss  xmm2, xmm1, xmm0
      vmulss  xmm1, xmm8, dword ptr [rsi+14h]
      vmulss  xmm0, xmm6, dword ptr [rsi]
      vaddss  xmm5, xmm2, xmm1
      vmulss  xmm1, xmm5, dword ptr [rsi+0Ch]
      vaddss  xmm2, xmm0, dword ptr [rsp+0A8h+outLookAtPos]
      vaddss  xmm2, xmm2, xmm1
      vmovss  dword ptr [rbx+67580h], xmm2
      vmulss  xmm0, xmm6, dword ptr [rsi+4]
      vmulss  xmm1, xmm5, dword ptr [rsi+10h]
      vaddss  xmm2, xmm0, dword ptr [rsp+0A8h+outLookAtPos+4]
      vaddss  xmm0, xmm2, xmm1
      vmovss  dword ptr [rbx+67584h], xmm0
      vmulss  xmm1, xmm6, dword ptr [rsi+8]
      vmulss  xmm0, xmm5, dword ptr [rsi+14h]
      vaddss  xmm2, xmm1, dword ptr [rsp+0A8h+outLookAtPos+8]
      vaddss  xmm1, xmm2, xmm0
      vmovss  dword ptr [rbx+67588h], xmm1
    }
  }
  _R11 = &v62;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, [rsp+0A8h+var_38]
    vmovaps xmm8, xmmword ptr [r11-30h]
  }
}

/*
==============
CgWeaponSystem::ClientViewLockedOnTurret
==============
*/
_BOOL8 CgWeaponSystem::ClientViewLockedOnTurret(CgWeaponSystem *this, int entnum)
{
  cg_t *LocalClientGlobals; 
  playerState_s *p_predictedPlayerState; 

  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  p_predictedPlayerState = &LocalClientGlobals->predictedPlayerState;
  if ( LocalClientGlobals == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2152, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  return BG_IsTurretActiveFlags(&p_predictedPlayerState->eFlags) && p_predictedPlayerState->viewlocked_entNum == entnum;
}

/*
==============
CgWeaponSystem::CullBulletHitEffect
==============
*/
__int64 CgWeaponSystem::CullBulletHitEffect(CgWeaponSystem *this, int eventType, const vec3_t *position, const vec3_t *up, int sourceEntityNum, int targetEntityNum, unsigned int impactFlags)
{
  cg_t *LocalClientGlobals; 
  const dvar_t *v14; 
  __int64 result; 
  centity_t *Entity; 
  const entityState_t *p_nextState; 
  char v45; 
  unsigned int prevViewIndex; 
  unsigned int v52; 
  vec3_t outOrg; 
  __int64 v58; 
  Bounds bounds; 
  char v60; 
  void *retaddr; 

  _RAX = &retaddr;
  v58 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm6
    vmovaps xmmword ptr [rax-48h], xmm7
    vmovaps xmmword ptr [rax-58h], xmm8
  }
  _RSI = position;
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20464, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  v14 = DVARBOOL_cg_weapHitCullEnable;
  if ( !DVARBOOL_cg_weapHitCullEnable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_weapHitCullEnable") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v14);
  if ( !v14->current.enabled || LocalClientGlobals->predictedPlayerState.clientNum == sourceEntityNum )
  {
    result = 0i64;
  }
  else
  {
    RefdefView_GetOrg(&LocalClientGlobals->refdef.view, &outOrg);
    __asm
    {
      vmovss  xmm0, dword ptr [rsi]
      vsubss  xmm6, xmm0, dword ptr [rsp+0E8h+outOrg]
      vmovss  xmm1, dword ptr [rsi+4]
      vsubss  xmm5, xmm1, dword ptr [rsp+0E8h+outOrg+4]
      vmovss  xmm0, dword ptr [rsi+8]
      vsubss  xmm4, xmm0, dword ptr [rsp+0E8h+outOrg+8]
      vmulss  xmm2, xmm5, xmm5
      vmulss  xmm1, xmm6, xmm6
      vaddss  xmm3, xmm2, xmm1
      vmulss  xmm0, xmm4, xmm4
      vaddss  xmm2, xmm3, xmm0
      vsqrtss xmm1, xmm2, xmm2
      vcmpless xmm0, xmm1, cs:__real@80000000
      vmovss  xmm2, cs:__real@3f800000
      vblendvps xmm1, xmm1, xmm2, xmm0
      vdivss  xmm0, xmm2, xmm1
      vmulss  xmm7, xmm6, xmm0
      vmulss  xmm6, xmm5, xmm0
      vmulss  xmm8, xmm4, xmm0
    }
    if ( (impactFlags & 0x100) == 0 )
    {
      if ( (unsigned int)targetEntityNum >= 0x7FE || (Entity = CG_GetEntity((const LocalClientNum_t)this->m_localClientNum, targetEntityNum), (Entity->flags & 1) != 0) && (p_nextState = &Entity->nextState, !BG_IsCharacterEntity(&Entity->nextState)) && !BG_IsPlayerOrAgentCorpseEntity(p_nextState) )
      {
        __asm
        {
          vmulss  xmm1, xmm6, dword ptr [r14+4]
          vmulss  xmm0, xmm7, dword ptr [r14]
          vaddss  xmm2, xmm1, xmm0
          vmulss  xmm1, xmm8, dword ptr [r14+8]
          vaddss  xmm6, xmm2, xmm1
        }
        _RDI = DVARFLT_cg_weapHitCullAngle;
        if ( !DVARFLT_cg_weapHitCullAngle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_weapHitCullAngle") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(_RDI);
        __asm
        {
          vmovss  xmm0, dword ptr [rdi+28h]
          vmulss  xmm0, xmm0, cs:__real@3c8efa35; X
        }
        *(float *)&_XMM0 = cosf_0(*(float *)&_XMM0);
        __asm { vcomiss xmm6, xmm0 }
        if ( !v45 )
          goto LABEL_24;
      }
    }
    prevViewIndex = LocalClientGlobals->prevViewIndex;
    if ( CL_IsRenderingSplitScreen() )
      goto LABEL_25;
    _RDI = DVARFLT_cg_weapHitCullRadius;
    if ( !DVARFLT_cg_weapHitCullRadius && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_weapHitCullRadius") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RDI);
    __asm
    {
      vmovss  xmm2, dword ptr [rdi+28h]
      vmovss  xmm0, dword ptr [rsi]
      vmovss  dword ptr [rsp+0E8h+bounds.midPoint], xmm0
      vmovss  xmm1, dword ptr [rsi+4]
      vmovss  dword ptr [rsp+0E8h+bounds.midPoint+4], xmm1
      vmovss  xmm0, dword ptr [rsi+8]
      vmovss  dword ptr [rsp+0E8h+bounds.midPoint+8], xmm0
      vmovss  dword ptr [rsp+0E8h+bounds.halfSize], xmm2
      vmovss  dword ptr [rsp+0E8h+bounds.halfSize+4], xmm2
      vmovss  dword ptr [rsp+0E8h+bounds.halfSize+8], xmm2
    }
    if ( R_Umbra_IsBoxVisible(&bounds, 0, prevViewIndex, 0) )
LABEL_25:
      v52 = 0;
    else
LABEL_24:
      v52 = 1;
    memset(&outOrg, 0, sizeof(outOrg));
    result = v52;
  }
  _R11 = &v60;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
  }
  return result;
}

/*
==============
CycleWeapPrimary
==============
*/
char CycleWeapPrimary(LocalClientNum_t localClientNum, int cycleSlot, int cycleForward, int bIgnoreEmpty, int bIgnoreStanceUnusable, int forceWrapAround)
{
  int v7; 
  int v8; 
  LocalClientNum_t v9; 
  cg_t *LocalClientGlobals; 
  cg_t *v11; 
  const playerState_s *p_predictedPlayerState; 
  const WeaponDef *v17; 
  CgWeaponMap *Instance; 
  int weaponState; 
  unsigned int AllWeaponAttachments; 
  bool shareAmmoWithAlt; 
  unsigned int v22; 
  WeaponAttachment **v23; 
  WeaponAttachment *v24; 
  Weapon *p_weaponSelect; 
  int inAltMode; 
  LocalClientNum_t v27; 
  const PlayerEquippedWeaponState *EquippedWeaponState; 
  weapInventoryType_t inventoryType; 
  bool v31; 
  int EquippedWeaponIndex; 
  int v33; 
  int v34; 
  char v35; 
  WeaponSlot EquippedSlot; 
  const Weapon *p_weaponPrevPrimary; 
  WeaponSlot v38; 
  WeaponSlot v39; 
  const PlayerEquippedWeaponState *v40; 
  LocalClientNum_t v41; 
  bool v42; 
  unsigned int v43; 
  unsigned int v44; 
  int v45; 
  bool IsWeaponUsableInState; 
  int v51; 
  const WeaponDef *v52; 
  const PlayerEquippedWeaponState *v53; 
  __int64 v57; 
  __int64 v58; 
  bool v59; 
  WeaponSlot v61; 
  int v64; 
  int v66; 
  weapInventoryType_t v67; 
  Weapon *weapon; 
  Weapon r_weapon; 
  WeaponAttachment *attachments[30]; 

  v7 = cycleForward;
  v8 = cycleSlot;
  v9 = localClientNum;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v11 = LocalClientGlobals;
  if ( !LocalClientGlobals->nextSnap )
    return 0;
  p_predictedPlayerState = &LocalClientGlobals->predictedPlayerState;
  if ( !BG_IsPlayer(&LocalClientGlobals->predictedPlayerState) )
    return 0;
  if ( p_predictedPlayerState->pm_type >= 7 )
    return 0;
  _RAX = &v11->weaponSelect;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovups ymmword ptr [rsp+1E0h+r_weapon.weaponIdx], ymm0
    vmovups xmm1, xmmword ptr [rax+20h]
    vmovups xmmword ptr [rbp+0E0h+r_weapon.attachmentVariationIndices+5], xmm1
    vmovsd  xmm0, qword ptr [rax+30h]
    vmovsd  qword ptr [rbp+0E0h+r_weapon.attachmentVariationIndices+15h], xmm0
  }
  weapon = &v11->weaponSelect;
  *(_DWORD *)&r_weapon.weaponCamo = *(_DWORD *)&v11->weaponSelect.weaponCamo;
  v17 = BG_WeaponDef(&r_weapon, 0);
  if ( BG_GetNumWeapons() < 2 )
    return 0;
  Instance = CgWeaponMap::GetInstance(v9);
  if ( r_weapon.weaponIdx )
  {
    if ( BG_UsingAlternate(p_predictedPlayerState) )
    {
      weaponState = p_predictedPlayerState->weapState[0].weaponState;
      if ( (unsigned int)(weaponState - 7) > 5 && weaponState != 50 && (!BG_PWF_UseAlternateAsOffhand(p_predictedPlayerState) || !BG_HasUnderbarrelShotgun(&r_weapon)) && !v17->altModeSameWeapon )
      {
        AllWeaponAttachments = BG_GetAllWeaponAttachments(&r_weapon, (const WeaponAttachment **)attachments);
        shareAmmoWithAlt = attachments[0] == NULL;
        v22 = 0;
        if ( AllWeaponAttachments )
        {
          v23 = attachments;
          do
          {
            if ( shareAmmoWithAlt )
              goto LABEL_24;
            if ( !*v23 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17614, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
              __debugbreak();
            v24 = *v23;
            ++v22;
            ++v23;
            shareAmmoWithAlt = v24->shareAmmoWithAlt;
          }
          while ( v22 < AllWeaponAttachments );
          v9 = localClientNum;
        }
        if ( !shareAmmoWithAlt )
        {
          p_weaponSelect = &v11->weaponSelect;
          inAltMode = 0;
          v27 = v9;
LABEL_22:
          CG_SelectWeapon(v27, p_weaponSelect, inAltMode);
          return 1;
        }
LABEL_24:
        v7 = cycleForward;
        v8 = cycleSlot;
      }
    }
  }
  if ( (v17->inventoryType & 0xFFFFFFFB) != 0 && v11->weaponLatestPrimary.weaponIdx && BG_PlayerHasWeapon(Instance, p_predictedPlayerState, &v11->weaponLatestPrimary) )
  {
    EquippedWeaponState = BG_GetEquippedWeaponState(Instance, p_predictedPlayerState, &v11->weaponLatestPrimary);
    if ( EquippedWeaponState )
    {
      p_weaponSelect = &v11->weaponLatestPrimary;
      v27 = localClientNum;
      inAltMode = EquippedWeaponState->inAltMode;
    }
    else
    {
      v27 = localClientNum;
      p_weaponSelect = &v11->weaponLatestPrimary;
      inAltMode = 0;
    }
    goto LABEL_22;
  }
  inventoryType = v17->inventoryType;
  v31 = v7 == 0;
  EquippedWeaponIndex = 0;
  v67 = inventoryType;
  v33 = -1;
  if ( !v31 )
    v33 = 1;
  v64 = v33;
  v34 = 4;
  if ( inventoryType != WEAPINVENTORY_EXCLUSIVE )
    v34 = 0;
  v66 = v34;
  if ( r_weapon.weaponIdx )
  {
    v35 = 0;
    EquippedWeaponIndex = BG_GetEquippedWeaponIndex(Instance, p_predictedPlayerState, &r_weapon);
    if ( EquippedWeaponIndex < 0 )
      EquippedWeaponIndex = 0;
    if ( (unsigned int)EquippedWeaponIndex >= 0xF )
    {
      LODWORD(v57) = EquippedWeaponIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17655, ASSERT_TYPE_ASSERT, "(unsigned)( startIndex ) < (unsigned)( 15 )", "startIndex doesn't index MAX_EQUIPPED_WEAPONS\n\t%i not in [0, %i)", v57, 15) )
        __debugbreak();
    }
  }
  else
  {
    v35 = 1;
  }
  if ( inventoryType == WEAPINVENTORY_EXCLUSIVE )
  {
    v39 = WEAPON_SLOT_NONE;
  }
  else
  {
    EquippedSlot = BG_PlayerWeaponGetEquippedSlot(Instance, p_predictedPlayerState, &r_weapon);
    if ( EquippedSlot )
      v61 = BG_PlayerWeaponGetCycleSlot(EquippedSlot, v8);
    else
      v61 = WEAPON_SLOT_PRIMARY;
    if ( v8 && (p_weaponPrevPrimary = &v11->weaponPrevPrimary, v11->weaponPrevPrimary.weaponIdx) )
    {
      v38 = BG_PlayerWeaponGetEquippedSlot(Instance, p_predictedPlayerState, &v11->weaponPrevPrimary);
      v39 = v61;
      if ( v38 == v61 && BG_PlayerHasWeapon(Instance, p_predictedPlayerState, p_weaponPrevPrimary) )
      {
        v40 = BG_GetEquippedWeaponState(Instance, p_predictedPlayerState, p_weaponPrevPrimary);
        if ( v40 )
          LOBYTE(v40) = v40->inAltMode;
        v41 = localClientNum;
        if ( CG_SelectWeapon(localClientNum, p_weaponPrevPrimary, (unsigned __int8)v40) )
          return 1;
        goto LABEL_57;
      }
    }
    else
    {
      v39 = v61;
    }
  }
  v41 = localClientNum;
LABEL_57:
  v42 = CL_Input_IsGamepadEnabled(v41) || forceWrapAround || GamerProfile_GetWeaponSwitchWrapAround(v41);
  v59 = v42;
  v43 = EquippedWeaponIndex;
  while ( 1 )
  {
    v44 = v43;
    if ( !v35 )
      break;
    v35 = 0;
    v43 = 0;
LABEL_73:
    _RAX = BG_GetEquippedWeaponForPlayer(Instance, p_predictedPlayerState, v43);
    v42 = v59;
    __asm
    {
      vmovups ymm2, ymmword ptr [rax]
      vmovups ymmword ptr [rsp+1E0h+r_weapon.weaponIdx], ymm2
      vmovups xmm0, xmmword ptr [rax+20h]
      vmovups xmmword ptr [rbp+0E0h+r_weapon.attachmentVariationIndices+5], xmm0
      vmovsd  xmm1, qword ptr [rax+30h]
      vmovsd  qword ptr [rbp+0E0h+r_weapon.attachmentVariationIndices+15h], xmm1
    }
    *(_DWORD *)&r_weapon.weaponCamo = *(_DWORD *)&_RAX->weaponCamo;
    __asm { vmovd   eax, xmm2 }
    if ( (_WORD)_RAX )
    {
      if ( !bIgnoreStanceUnusable || (IsWeaponUsableInState = BG_IsWeaponUsableInState(p_predictedPlayerState, &r_weapon), v42 = v59, IsWeaponUsableInState) )
      {
        if ( !bIgnoreEmpty || (v51 = BG_WeaponAmmo(Instance, p_predictedPlayerState, &r_weapon, 0), v42 = v59, v51) )
        {
          v52 = BG_WeaponDef(&r_weapon, 0);
          v42 = v59;
          if ( v52->inventoryType == v66 )
          {
            v53 = BG_GetEquippedWeaponState(Instance, p_predictedPlayerState, &r_weapon);
            if ( v67 == WEAPINVENTORY_EXCLUSIVE || (v42 = v59, v53->slot == v39) )
            {
              p_weaponSelect = &r_weapon;
              if ( v53 )
                inAltMode = v53->inAltMode;
              else
                inAltMode = 0;
              v27 = v41;
              goto LABEL_22;
            }
          }
        }
      }
    }
  }
  if ( v42 || v43 + v64 <= 0xE )
  {
    v45 = 14;
    if ( cycleForward )
      v45 = 16;
    v43 = (int)(v44 + v45) % 15;
    if ( v43 >= 0xF )
    {
      LODWORD(v58) = 15;
      LODWORD(v57) = v43;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 17712, ASSERT_TYPE_ASSERT, "(unsigned)( equippedIndex ) < (unsigned)( 15 )", "equippedIndex doesn't index MAX_EQUIPPED_WEAPONS\n\t%i not in [0, %i)", v57, v58) )
        __debugbreak();
    }
    if ( v43 != EquippedWeaponIndex )
      goto LABEL_73;
  }
  if ( !BG_PlayerHasWeapon(Instance, p_predictedPlayerState, weapon) )
  {
    __asm
    {
      vmovups ymm0, ymmword ptr cs:?NULL_WEAPON@@3UWeapon@@B.weaponIdx; Weapon const NULL_WEAPON
      vmovups xmm1, xmmword ptr cs:?NULL_WEAPON@@3UWeapon@@B.attachmentVariationIndices+5; Weapon const NULL_WEAPON
      vmovups ymmword ptr [rsp+1E0h+r_weapon.weaponIdx], ymm0
      vmovsd  xmm0, qword ptr cs:?NULL_WEAPON@@3UWeapon@@B.attachmentVariationIndices+15h; Weapon const NULL_WEAPON
    }
    *(_DWORD *)&r_weapon.weaponCamo = *(_DWORD *)&NULL_WEAPON.weaponCamo;
    __asm
    {
      vmovsd  qword ptr [rbp+0E0h+r_weapon.attachmentVariationIndices+15h], xmm0
      vmovups xmmword ptr [rbp+0E0h+r_weapon.attachmentVariationIndices+5], xmm1
    }
    CG_SelectWeapon(v41, &r_weapon, 0);
  }
  return 0;
}

/*
==============
CgWeaponSystem::DebugDrawBulletHitLocation
==============
*/
void CgWeaponSystem::DebugDrawBulletHitLocation(CgWeaponSystem *this)
{
  cg_t *LocalClientGlobals; 
  __int64 m_localClientNum; 
  CgWeaponMap *v10; 
  const playerState_s *p_predictedPlayerState; 
  const Weapon *CurrentWeaponForPlayer; 
  bool v13; 
  centity_t *Entity; 
  CgBallistics *System; 
  unsigned __int8 *priorityMap; 
  char v56; 
  char v57; 
  char *fmt; 
  float fmta; 
  int r_weapon; 
  Weapon *r_weapona; 
  double isAlternate; 
  __int64 v77; 
  TagPair result; 
  __int64 v79; 
  vec3_t point; 
  ClientFov v81; 
  vec3_t end; 
  vec3_t start; 
  char v87[24]; 
  trace_t results; 
  char dest[1024]; 
  char v90; 
  void *retaddr; 

  _RAX = &retaddr;
  v79 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm6
    vmovaps xmmword ptr [rax-48h], xmm7
    vmovaps xmmword ptr [rax-58h], xmm8
    vmovaps xmmword ptr [rax-68h], xmm9
  }
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  m_localClientNum = this->m_localClientNum;
  if ( !CgWeaponMap::ms_instance[m_localClientNum] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v10 = CgWeaponMap::ms_instance[m_localClientNum];
  p_predictedPlayerState = &LocalClientGlobals->predictedPlayerState;
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(v10, p_predictedPlayerState);
  v13 = BG_UsingAlternate(p_predictedPlayerState);
  if ( BG_GetWeaponType(CurrentWeaponForPlayer, v13) == WEAPTYPE_BULLET )
  {
    Entity = CG_GetEntity((const LocalClientNum_t)this->m_localClientNum, p_predictedPlayerState->clientNum);
    BG_GetWeaponFlashTagname(&result, CurrentWeaponForPlayer, v13, 0);
    __asm
    {
      vxorps  xmm8, xmm8, xmm8
      vmovss  dword ptr [rsp+5D0h+var_560], xmm8
    }
    LOBYTE(r_weapon) = 1;
    if ( ((__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _BYTE, _DWORD, _BYTE, _QWORD, _QWORD, _QWORD, _QWORD))this->SimulateBulletFire_Orientation)(this, Entity, CurrentWeaponForPlayer, v13, result, r_weapon, 1, WEAPON_HAND_DEFAULT, 1, NULL, (orientation_t *)&start, (float *)&v77, (vec3_t *)v87) )
    {
      System = CgBallistics::GetSystem((const LocalClientNum_t)this->m_localClientNum);
      *(double *)&_XMM0 = BG_GetBulletRange<CgBallisticInstance>(v10, System, p_predictedPlayerState, &Entity->nextState, &p_predictedPlayerState->perks, CurrentWeaponForPlayer, v13);
      __asm
      {
        vmovaps xmm6, xmm0
        vmulss  xmm2, xmm0, [rbp+4D0h+var_50C]
        vaddss  xmm3, xmm2, dword ptr [rbp+4D0h+start]
        vmovss  dword ptr [rbp+4D0h+end], xmm3
        vmulss  xmm2, xmm0, [rbp+4D0h+var_508]
        vaddss  xmm3, xmm2, dword ptr [rbp+4D0h+start+4]
        vmovss  dword ptr [rbp+4D0h+end+4], xmm3
        vmulss  xmm2, xmm0, [rbp+4D0h+var_504]
        vaddss  xmm3, xmm2, dword ptr [rbp+4D0h+start+8]
        vmovss  dword ptr [rbp+4D0h+end+8], xmm3
      }
      priorityMap = BG_GetWeaponPriorityMap(CurrentWeaponForPlayer, v13);
      PhysicsQuery_LegacyMPCGWeaponSimTrace((Physics_WorldId)(3 * this->m_localClientNum + 4), &results, &start, &end, &bounds_origin, &p_predictedPlayerState->clientNum, 1, 0, 41969969, 1, priorityMap, NormalSpace, 1);
      __asm { vmovss  xmm9, cs:__real@3f800000 }
      if ( results.allsolid && results.startsolid )
      {
        __asm
        {
          vmovss  xmm0, dword ptr [rbp+4D0h+start]
          vmovss  dword ptr [rbp+4D0h+point], xmm0
          vmovss  xmm1, dword ptr [rbp+4D0h+start+4]
          vmovss  dword ptr [rbp+4D0h+point+4], xmm1
          vmovss  xmm0, dword ptr [rbp+4D0h+start+8]
          vmovss  dword ptr [rbp+4D0h+point+8], xmm0
        }
      }
      else
      {
        __asm
        {
          vmovss  xmm0, [rbp+4D0h+results.fraction]
          vcomiss xmm0, xmm9
          vmovaps xmm8, xmm6
          vmovsd  xmm0, qword ptr [rbp+4D0h+end]
          vmovsd  qword ptr [rbp+4D0h+point], xmm0
        }
        point.v[2] = end.v[2];
      }
      if ( dword_1512FDF2C > *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1772i64) )
      {
        j__Init_thread_header(&dword_1512FDF2C);
        if ( dword_1512FDF2C == -1 )
        {
          *(double *)&_XMM0 = BG_MaxBulletRange();
          __asm { vmovss  cs:DEBUG_FONT_SIZE_MAX_DISTANCE, xmm0 }
          j__Init_thread_footer(&dword_1512FDF2C);
        }
      }
      __asm
      {
        vmovss  xmm2, cs:DEBUG_FONT_SIZE_MAX_DISTANCE; max
        vmovss  xmm1, cs:DEBUG_FONT_SIZE_MIN_DISTANCE; min
        vmovaps xmm0, xmm8; val
      }
      *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
      __asm
      {
        vsubss  xmm2, xmm0, cs:DEBUG_FONT_SIZE_MIN_DISTANCE
        vmovss  xmm0, cs:DEBUG_FONT_SIZE_MAX_DISTANCE
        vsubss  xmm1, xmm0, cs:DEBUG_FONT_SIZE_MIN_DISTANCE
        vdivss  xmm7, xmm2, xmm1
      }
      _RAX = CG_GetViewFovBySpace(&v81, (const LocalClientNum_t)this->m_localClientNum, CG_FovSpace_Scene, 0);
      __asm { vmovsd  xmm3, qword ptr [rax] }
      v81.baseFovAdjustment = _RAX->baseFovAdjustment;
      __asm
      {
        vmovss  xmm2, cs:DEBUG_FONT_SIZE_WIDE_FOV; max
        vmovss  xmm1, cs:DEBUG_FONT_SIZE_NARROW_FOV; min
        vmovaps xmm0, xmm3; val
        vmovsd  qword ptr [rbp+4D0h+var_538.finalFov], xmm3
      }
      *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
      __asm
      {
        vsubss  xmm2, xmm0, cs:DEBUG_FONT_SIZE_NARROW_FOV
        vmovss  xmm0, cs:DEBUG_FONT_SIZE_WIDE_FOV
        vsubss  xmm1, xmm0, cs:DEBUG_FONT_SIZE_NARROW_FOV
        vdivss  xmm6, xmm2, xmm1
        vmovss  xmm3, dword ptr [rsp+5D0h+var_560]
        vcvtss2sd xmm3, xmm3, xmm3
        vcvtss2sd xmm0, xmm8, xmm8
        vmovsd  [rsp+5D0h+isAlternate], xmm3
        vmovsd  [rsp+5D0h+r_weapon], xmm0
      }
      LODWORD(fmt) = 0;
      Com_sprintf(dest, 0x400ui64, "hit geo: %s surf flags: %d dist: %.4f spread: %.4f", "no", fmt, *(double *)&r_weapona, isAlternate);
      __asm
      {
        vsubss  xmm0, xmm9, xmm7
        vmulss  xmm3, xmm0, cs:DEBUG_FONT_SIZE_MIN
        vmulss  xmm2, xmm7, cs:DEBUG_FONT_SIZE_MAX
        vaddss  xmm0, xmm3, xmm2
        vmulss  xmm3, xmm0, xmm6
        vmovss  dword ptr [rsp+5D0h+fmt], xmm3
      }
      CG_DebugStarWithText(&point, &colorGreen, &colorWhite, dest, fmta, 0);
      __asm
      {
        vmovss  xmm4, dword ptr [rsp+5D0h+var_560]
        vcvtss2sd xmm0, xmm4, xmm4
        vcomisd xmm0, cs:__real@3eb0c6f7a0b5ed8d
      }
      if ( !(v56 | v57) )
      {
        __asm
        {
          vmovss  xmm3, dword ptr cs:__xmm@80000000800000008000000080000000
          vmovss  xmm0, [rbp+4D0h+var_50C]
          vxorps  xmm1, xmm0, xmm3
          vmovss  [rbp+4D0h+var_538.finalFov], xmm1
          vmovss  xmm2, [rbp+4D0h+var_508]
          vxorps  xmm0, xmm2, xmm3
          vmovss  [rbp+4D0h+var_538.baseFov], xmm0
          vmovss  xmm1, [rbp+4D0h+var_504]
          vxorps  xmm2, xmm1, xmm3
          vmovss  [rbp+4D0h+var_538.baseFovAdjustment], xmm2
          vmulss  xmm0, xmm4, cs:__real@3c8efa35; X
        }
        *(float *)&_XMM0 = tanf_0(*(float *)&_XMM0);
        __asm { vmulss  xmm1, xmm0, xmm8; radius }
        CG_DebugCircle(&point, *(float *)&_XMM1, (const vec3_t *)&v81, &colorBlue, 0, 0);
      }
    }
  }
  _R11 = &v90;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
  }
}

/*
==============
DebugDrawMissileProjectedSound
==============
*/
void DebugDrawMissileProjectedSound(const MissileConeSoundVars *mcv)
{
  bool v23; 
  int v93; 
  vec3_t *v94; 
  vec3_t *v96; 
  vec3_t *v134; 
  vec3_t *v135; 
  vec3_t start; 
  vec3_t v144; 
  vec3_t v145; 
  vec3_t dst; 
  vec3_t end; 
  vec3_t point; 
  vec3_t v149; 
  vec3_t v150; 
  vec3_t v151; 
  vec3_t v152; 
  vec3_t v153; 
  vec3_t v154; 
  vec3_t v155; 
  vec3_t v156; 
  char v157; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm6
    vmovaps xmmword ptr [rax-48h], xmm7
    vmovaps xmmword ptr [rax-58h], xmm8
    vmovaps xmmword ptr [rax-68h], xmm9
    vmovaps xmmword ptr [rax-78h], xmm10
    vmovaps xmmword ptr [rax-88h], xmm11
    vmovss  xmm3, dword ptr [rcx+30h]
    vmulss  xmm0, xmm3, dword ptr [rcx+0Ch]
    vaddss  xmm1, xmm0, dword ptr [rcx]
    vmulss  xmm0, xmm3, dword ptr [rcx+10h]
    vmovss  dword ptr [rsp+190h+var_140], xmm1
    vaddss  xmm1, xmm0, dword ptr [rcx+4]
    vmulss  xmm0, xmm3, dword ptr [rcx+14h]
    vaddss  xmm3, xmm3, cs:MY_BEYONDDRAW_DIST
    vmulss  xmm2, xmm3, dword ptr [rcx+10h]
    vmovss  dword ptr [rsp+190h+var_140+4], xmm1
    vaddss  xmm1, xmm0, dword ptr [rcx+8]
    vmulss  xmm0, xmm3, dword ptr [rcx+0Ch]
    vmovss  dword ptr [rsp+190h+var_140+8], xmm1
    vaddss  xmm1, xmm0, dword ptr [rcx]
    vaddss  xmm0, xmm2, dword ptr [rcx+4]
    vmovss  dword ptr [rsp+190h+end], xmm1
    vmulss  xmm1, xmm3, dword ptr [rcx+14h]
    vaddss  xmm2, xmm1, dword ptr [rcx+8]
    vmovss  dword ptr [rsp+190h+end+8], xmm2
    vmovss  dword ptr [rsp+190h+end+4], xmm0
  }
  _RBX = mcv;
  CG_DebugLine(&mcv->start, &end, &MY_COLOR, MY_DEPTHTEST, MY_DURATION);
  PerpendicularVector(&_RBX->dir, &dst);
  v23 = !_RBX->pitchshiftEnabled;
  __asm
  {
    vmovss  xmm2, dword ptr [rbx+28h]
    vmovss  xmm5, dword ptr [rsp+190h+dst]
    vmovss  xmm6, dword ptr [rsp+190h+dst+4]
    vmovss  xmm9, dword ptr [rsp+190h+dst+8]
    vmovss  xmm3, dword ptr [rbx+2Ch]
    vmovss  xmm11, cs:__real@3f800000
    vmulss  xmm0, xmm5, xmm2
    vmovss  dword ptr [rbp+90h+point], xmm0
    vmulss  xmm0, xmm9, xmm2
    vmovss  dword ptr [rbp+90h+point+8], xmm0
    vmulss  xmm1, xmm6, xmm2
    vmulss  xmm2, xmm2, dword ptr [rbx+3Ch]
    vmovss  dword ptr [rbp+90h+point+4], xmm1
    vmulss  xmm0, xmm5, xmm2
    vmovss  dword ptr [rbp+90h+var_100], xmm0
    vmulss  xmm0, xmm9, xmm2
    vmulss  xmm1, xmm6, xmm2
    vmulss  xmm2, xmm3, dword ptr [rbx+3Ch]
    vmovss  dword ptr [rbp+90h+var_100+8], xmm0
    vmovss  dword ptr [rbp+90h+var_100+4], xmm1
    vmulss  xmm0, xmm5, xmm3
    vmulss  xmm1, xmm6, xmm3
    vmovss  dword ptr [rbp+90h+var_F0], xmm0
    vmovss  dword ptr [rbp+90h+var_F0+4], xmm1
    vmulss  xmm0, xmm9, xmm3
    vmulss  xmm1, xmm5, xmm2
    vmovss  dword ptr [rbp+90h+var_F0+8], xmm0
    vmovss  dword ptr [rbp+90h+var_E0], xmm1
    vmulss  xmm0, xmm6, xmm2
    vmulss  xmm1, xmm9, xmm2
    vmovss  dword ptr [rbp+90h+var_E0+4], xmm0
    vmovss  dword ptr [rbp+90h+var_E0+8], xmm1
    vxorps  xmm10, xmm10, xmm10
  }
  if ( !v23 )
  {
    __asm
    {
      vmovss  xmm4, dword ptr [rbx+4Ch]
      vucomiss xmm4, xmm10
    }
    if ( v23 )
      __asm { vucomiss xmm10, dword ptr [rbx+50h] }
    __asm
    {
      vmovss  xmm2, cs:MY_ALTLINEOFFSET
      vmulss  xmm0, xmm5, xmm2
      vaddss  xmm7, xmm0, dword ptr [rbx]
      vmulss  xmm0, xmm9, xmm2
      vaddss  xmm9, xmm0, dword ptr [rbx+8]
      vmulss  xmm1, xmm6, xmm2
      vaddss  xmm8, xmm1, dword ptr [rbx+4]
      vmulss  xmm2, xmm4, dword ptr [rbx+30h]
      vmulss  xmm0, xmm2, dword ptr [rbx+0Ch]
      vaddss  xmm1, xmm0, xmm7
      vmulss  xmm0, xmm2, dword ptr [rbx+10h]
      vmovss  dword ptr [rsp+190h+var_150], xmm1
      vaddss  xmm1, xmm0, xmm8
      vmulss  xmm0, xmm2, dword ptr [rbx+14h]
      vmovss  dword ptr [rsp+190h+var_150+4], xmm1
      vaddss  xmm1, xmm0, xmm9
      vsubss  xmm0, xmm11, dword ptr [rbx+50h]
      vmulss  xmm3, xmm0, dword ptr [rbx+30h]
      vmulss  xmm0, xmm3, dword ptr [rbx+10h]
      vmovss  dword ptr [rsp+190h+var_150+8], xmm1
      vmulss  xmm1, xmm3, dword ptr [rbx+0Ch]
      vaddss  xmm2, xmm1, xmm7
      vaddss  xmm1, xmm0, xmm8
      vmovss  dword ptr [rsp+190h+start], xmm2
      vmulss  xmm2, xmm3, dword ptr [rbx+14h]
      vaddss  xmm0, xmm2, xmm9
      vmovss  dword ptr [rsp+190h+start+8], xmm0
      vmovss  dword ptr [rsp+190h+start+4], xmm1
    }
    CG_DebugLine(&start, &v144, &MY_COLOR_PITCH, MY_DEPTHTEST, MY_DURATION);
    __asm
    {
      vmovss  xmm5, dword ptr [rsp+190h+dst]
      vmovss  xmm9, dword ptr [rsp+190h+dst+8]
      vmovss  xmm6, dword ptr [rsp+190h+dst+4]
    }
  }
  if ( _RBX->crossfadeEnabled )
  {
    __asm
    {
      vmovss  xmm4, dword ptr [rbx+58h]
      vucomiss xmm4, xmm10
    }
    if ( _RBX->crossfadeEnabled )
      goto LABEL_8;
    __asm { vucomiss xmm10, dword ptr [rbx+5Ch] }
    if ( _RBX->crossfadeEnabled )
    {
LABEL_8:
      __asm
      {
        vmovss  xmm0, cs:MY_ALTLINEOFFSET
        vxorps  xmm2, xmm0, cs:__xmm@80000000800000008000000080000000
        vmulss  xmm1, xmm5, xmm2
        vaddss  xmm7, xmm1, dword ptr [rbx]
        vmulss  xmm1, xmm9, xmm2
        vaddss  xmm9, xmm1, dword ptr [rbx+8]
        vmulss  xmm0, xmm6, xmm2
        vaddss  xmm8, xmm0, dword ptr [rbx+4]
        vmulss  xmm2, xmm4, dword ptr [rbx+30h]
        vmulss  xmm0, xmm2, dword ptr [rbx+0Ch]
        vaddss  xmm1, xmm0, xmm7
        vmulss  xmm0, xmm2, dword ptr [rbx+10h]
        vmovss  dword ptr [rsp+190h+var_150], xmm1
        vaddss  xmm1, xmm0, xmm8
        vmulss  xmm0, xmm2, dword ptr [rbx+14h]
        vmovss  dword ptr [rsp+190h+var_150+4], xmm1
        vaddss  xmm1, xmm0, xmm9
        vsubss  xmm0, xmm11, dword ptr [rbx+5Ch]
        vmulss  xmm3, xmm0, dword ptr [rbx+30h]
        vmulss  xmm0, xmm3, dword ptr [rbx+10h]
        vmovss  dword ptr [rsp+190h+var_150+8], xmm1
        vmulss  xmm1, xmm3, dword ptr [rbx+0Ch]
        vaddss  xmm2, xmm1, xmm7
        vaddss  xmm1, xmm0, xmm8
        vmovss  dword ptr [rsp+190h+start], xmm2
        vmulss  xmm2, xmm3, dword ptr [rbx+14h]
        vaddss  xmm0, xmm2, xmm9
        vmovss  dword ptr [rsp+190h+start+8], xmm0
        vmovss  dword ptr [rsp+190h+start+4], xmm1
      }
      CG_DebugLine(&start, &v144, &MY_COLOR_CROSSFADE, MY_DEPTHTEST, MY_DURATION);
    }
  }
  _RSI = &v153;
  __asm
  {
    vmovss  xmm0, cs:__real@43b40000
    vxorps  xmm1, xmm1, xmm1
  }
  v93 = 0;
  v94 = &v154;
  _RDI = &v155;
  v96 = &v156;
  __asm
  {
    vcvtsi2ss xmm1, xmm1, eax
    vdivss  xmm6, xmm0, xmm1
  }
  if ( MY_STEPS >= 0 )
  {
    do
    {
      __asm { vmovaps xmm3, xmm10; degrees }
      RotatePointAroundVector(_RSI, &_RBX->dir, &point, *(float *)&_XMM3);
      __asm
      {
        vmovss  xmm0, dword ptr [rsi]
        vaddss  xmm1, xmm0, dword ptr [rbx]
        vmovss  xmm0, dword ptr [rsi+4]
        vmovss  dword ptr [rsi], xmm1
        vaddss  xmm1, xmm0, dword ptr [rbx+4]
        vmovss  xmm0, dword ptr [rbx+8]
        vmovss  dword ptr [rsi+4], xmm1
        vaddss  xmm1, xmm0, dword ptr [rsi+8]
        vmovaps xmm3, xmm10; degrees
        vmovss  dword ptr [rsi+8], xmm1
      }
      RotatePointAroundVector(&start, &_RBX->dir, &v149, *(float *)&_XMM3);
      __asm
      {
        vmovss  xmm0, dword ptr [rsp+190h+start]
        vaddss  xmm1, xmm0, dword ptr [rbx]
        vmovss  xmm2, dword ptr [rsp+190h+start+4]
        vaddss  xmm0, xmm2, dword ptr [rbx+4]
        vmovss  dword ptr [rsp+190h+start], xmm1
        vmovss  xmm1, dword ptr [rsp+190h+start+8]
        vaddss  xmm2, xmm1, dword ptr [rbx+8]
        vmovss  dword ptr [rsp+190h+start+8], xmm2
        vmovss  dword ptr [rsp+190h+start+4], xmm0
      }
      CG_DebugLine(&_RBX->start, &start, &MY_COLOR_INNER, MY_DEPTHTEST, MY_DURATION);
      CG_DebugLine(&start, _RSI, &MY_COLOR, MY_DEPTHTEST, MY_DURATION);
      __asm { vmovaps xmm3, xmm10; degrees }
      RotatePointAroundVector(_RDI, &_RBX->dir, &v150, *(float *)&_XMM3);
      __asm
      {
        vmovss  xmm0, dword ptr [rsp+190h+var_140]
        vaddss  xmm1, xmm0, dword ptr [rdi]
        vmovss  xmm0, dword ptr [rsp+190h+var_140+4]
        vmovss  dword ptr [rdi], xmm1
        vaddss  xmm1, xmm0, dword ptr [rdi+4]
        vmovss  xmm0, dword ptr [rsp+190h+var_140+8]
        vmovss  dword ptr [rdi+4], xmm1
        vaddss  xmm1, xmm0, dword ptr [rdi+8]
        vmovaps xmm3, xmm10; degrees
        vmovss  dword ptr [rdi+8], xmm1
      }
      RotatePointAroundVector(&v144, &_RBX->dir, &v151, *(float *)&_XMM3);
      __asm
      {
        vmovss  xmm0, dword ptr [rsp+190h+var_150]
        vaddss  xmm1, xmm0, dword ptr [rsp+190h+var_140]
        vmovss  xmm2, dword ptr [rsp+190h+var_150+4]
        vaddss  xmm0, xmm2, dword ptr [rsp+190h+var_140+4]
        vmovss  dword ptr [rsp+190h+var_150], xmm1
        vmovss  xmm1, dword ptr [rsp+190h+var_150+8]
        vaddss  xmm2, xmm1, dword ptr [rsp+190h+var_140+8]
        vmovss  dword ptr [rsp+190h+var_150+8], xmm2
        vmovss  dword ptr [rsp+190h+var_150+4], xmm0
      }
      CG_DebugLine(&v145, &v144, &MY_COLOR_INNER, MY_DEPTHTEST, MY_DURATION);
      CG_DebugLine(&v144, _RDI, &MY_COLOR, MY_DEPTHTEST, MY_DURATION);
      CG_DebugLine(_RSI, _RDI, &MY_COLOR, MY_DEPTHTEST, MY_DURATION);
      __asm
      {
        vmovss  xmm3, cs:MY_BEYONDDRAW_DIST
        vmulss  xmm0, xmm3, dword ptr [rbx+0Ch]
        vaddss  xmm1, xmm0, dword ptr [rdi]
        vmulss  xmm2, xmm3, dword ptr [rbx+10h]
        vaddss  xmm0, xmm2, dword ptr [rdi+4]
        vmovss  dword ptr [rbp+90h+var_D0], xmm1
        vmulss  xmm1, xmm3, dword ptr [rbx+14h]
        vmovss  dword ptr [rbp+90h+var_D0+4], xmm0
        vaddss  xmm0, xmm1, dword ptr [rdi+8]
        vmovss  dword ptr [rbp+90h+var_D0+8], xmm0
      }
      CG_DebugLine(_RDI, &v152, &MY_COLOR, MY_DEPTHTEST, MY_DURATION);
      if ( v93 )
      {
        CG_DebugLine(_RSI, v94, &MY_COLOR, MY_DEPTHTEST, MY_DURATION);
        CG_DebugLine(_RDI, v96, &MY_COLOR, MY_DEPTHTEST, MY_DURATION);
      }
      v134 = _RSI;
      ++v93;
      _RSI = v94;
      v94 = v134;
      v135 = _RDI;
      _RDI = v96;
      v96 = v135;
      __asm { vaddss  xmm10, xmm10, xmm6 }
    }
    while ( v93 <= MY_STEPS );
  }
  _R11 = &v157;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
  }
}

/*
==============
DevPrintAnimTree
==============
*/
void DevPrintAnimTree(const LocalClientNum_t localClientNum, const XAnimTree *animTree, const playerState_s *ps, __int64 hand, const Weapon *weapon)
{
  __int64 v6; 
  int v8; 
  int v9; 
  __int64 v10; 
  XAnimParts *parts; 
  const char *name; 
  CgHandler *Handler; 
  __int64 v14; 
  int i; 
  const char *v16; 
  const char **v17; 
  const char *v18; 
  bool v19; 
  const WeaponDef *v20; 
  int v21; 
  __int64 v22; 
  const char **p_name; 
  const char *v24; 
  const BgWeaponMap **v25; 
  unsigned __int16 weaponIdx; 
  WeaponDef *v31; 
  __int64 v32; 
  const char **v33; 
  const char *v34; 
  __int64 v35; 
  Weapon Buf2; 
  char output[1024]; 

  v6 = localClientNum;
  if ( !animTree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3758, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
    __debugbreak();
  if ( !animTree->anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3759, ASSERT_TYPE_ASSERT, "(animTree->anims)", (const char *)&queryFormat, "animTree->anims") )
    __debugbreak();
  Com_Printf(19, "DevPrintAnimTree: dumping animTree parts\n", ps, hand);
  v8 = 0;
  v9 = 0;
  v10 = 0i64;
  do
  {
    if ( animTree->anims->entries[v10].numAnims )
    {
      name = "<animParent>";
    }
    else
    {
      parts = animTree->anims->entries[v10].parts;
      if ( !parts || (name = parts->name) == NULL || !*name )
        name = "<empty>";
    }
    Com_Printf(19, "%d: %s\n", (unsigned int)v9++, name);
    ++v10;
  }
  while ( v9 < 608 );
  Handler = CgHandler::getHandler((LocalClientNum_t)v6);
  v14 = (__int64)Handler->PlayerWeaponAnimsConst(Handler, ps);
  if ( !v14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3788, ASSERT_TYPE_ASSERT, "(weaponAnimArrays)", (const char *)&queryFormat, "weaponAnimArrays") )
    __debugbreak();
  Com_Printf(19, "DevPrintAnimTree: dumping cached anims\n");
  for ( i = 0; i < 608; ++i )
  {
    if ( *(_QWORD *)v14 )
      v16 = **(const char ***)v14;
    else
      v16 = "<empty>";
    v17 = *(const char ***)(v14 + 4976);
    if ( v17 )
      v18 = *v17;
    else
      v18 = "<empty>";
    Com_Printf(19, "%d: %s, %s\n", (unsigned int)i, v16, v18);
    v14 += 8i64;
  }
  BG_GetWeaponName(weapon, output, 0x400u);
  Com_Printf(19, "DevPrintAnimTree: dumping szXAnims for %s\n", output);
  v19 = BG_UsingAlternate(ps);
  v20 = BG_WeaponDef(weapon, v19);
  if ( v20->szXAnims )
  {
    v21 = 0;
    v22 = 0i64;
    do
    {
      p_name = &v20->szXAnims->anims[v22]->name;
      if ( p_name )
        v24 = *p_name;
      else
        v24 = "<empty>";
      Com_Printf(19, "%d: %s\n", (unsigned int)v21++, v24);
      ++v22;
    }
    while ( v21 < 608 );
  }
  v25 = (const BgWeaponMap **)&CgWeaponMap::ms_instance[v6];
  if ( !*v25 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  _RAX = BG_GetViewmodelWeapon(*v25, ps);
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovups [rsp+4C8h+Buf2], ymm0
    vmovups xmm1, xmmword ptr [rax+20h]
    vmovups [rsp+4C8h+var_468], xmm1
    vmovsd  xmm0, qword ptr [rax+30h]
    vmovsd  [rsp+4C8h+var_458], xmm0
  }
  *(_DWORD *)&Buf2.weaponCamo = *(_DWORD *)&_RAX->weaponCamo;
  if ( memcmp_0(weapon, &Buf2, 0x3Cui64) )
  {
    BG_GetWeaponName(&Buf2, output, 0x400u);
    Com_Printf(19, "DevPrintAnimTree: dumping viewmodelWeapon szXAnims for %s\n", output);
    BG_UsingAlternate(ps);
    weaponIdx = Buf2.weaponIdx;
    if ( Buf2.weaponIdx > bg_lastParsedWeaponIndex )
    {
      LODWORD(v35) = Buf2.weaponIdx;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1203, ASSERT_TYPE_ASSERT, "( weaponIdx ) <= ( bg_lastParsedWeaponIndex )", "weaponIdx not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", v35, bg_lastParsedWeaponIndex) )
        __debugbreak();
    }
    if ( !bg_weaponDefs[weaponIdx] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1204, ASSERT_TYPE_ASSERT, "(bg_weaponDefs[weaponIdx])", (const char *)&queryFormat, "bg_weaponDefs[weaponIdx]") )
      __debugbreak();
    v31 = bg_weaponDefs[weaponIdx];
    if ( v31->szXAnims )
    {
      v32 = 0i64;
      do
      {
        v33 = &v31->szXAnims->anims[v32]->name;
        if ( v33 )
          v34 = *v33;
        else
          v34 = "<empty>";
        Com_Printf(19, "%d: %s\n", (unsigned int)v8++, v34);
        ++v32;
      }
      while ( v8 < 608 );
    }
  }
}

/*
==============
CgWeaponSystem::DrawDebugBulletLines
==============
*/
void CgWeaponSystem::DrawDebugBulletLines(CgWeaponSystem *this)
{
  volatile int v2; 
  int v3; 
  const dvar_t *v4; 

  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25527, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  v2 = 0;
  if ( this->m_numBulletDebugLines <= 0 )
  {
    this->m_numBulletDebugLines = 0;
  }
  else
  {
    v3 = 0;
    do
    {
      v4 = DCONST_DVARINT_cg_debugBulletsDrawDuration;
      if ( !DCONST_DVARINT_cg_debugBulletsDrawDuration && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_debugBulletsDrawDuration") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v4);
      CG_DebugLine(&this->m_bulletDebugPoints[v3], &this->m_bulletDebugPoints[v3 + 1], &colorBlue, 0, v4->current.integer);
      ++v2;
      v3 += 2;
    }
    while ( v2 < this->m_numBulletDebugLines );
    this->m_numBulletDebugLines = 0;
  }
}

/*
==============
CgWeaponSystem::DrawFriendOrFoeTargetBoxes
==============
*/
void CgWeaponSystem::DrawFriendOrFoeTargetBoxes(CgWeaponSystem *this)
{
  cg_t *LocalClientGlobals; 
  centity_t *Entity; 
  centity_t *v6; 
  Material *material; 
  int IconDims; 
  float fmt; 
  float h; 
  float v26; 
  float v27; 
  float w; 
  float v29; 
  float v30; 
  float v31; 
  float y; 
  float x; 
  __int64 v34; 
  vec4_t outOrigin; 
  char v36; 
  void *retaddr; 

  _RAX = &retaddr;
  v34 = -2i64;
  __asm { vmovaps xmmword ptr [rax-28h], xmm6 }
  if ( !CG_IsCinematicCameraActive(this->m_localClientNum) )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
    if ( !GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&LocalClientGlobals->predictedPlayerState.eFlags, ACTIVE, 0xCu) )
    {
      Entity = CG_GetEntity((const LocalClientNum_t)this->m_localClientNum, LocalClientGlobals->predictedPlayerState.clientNum);
      v6 = Entity;
      if ( (Entity->flags & 1) != 0 && BG_IsCharacterEntity(&Entity->nextState) )
      {
        material = cgMedia.FOFTargetBox_Self;
        if ( (v6->flags & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21592, ASSERT_TYPE_ASSERT, "(CENextValid( cent ))", (const char *)&queryFormat, "CENextValid( cent )") )
          __debugbreak();
        if ( BG_IsCharacterEntity(&v6->nextState) )
        {
          CG_GetPoseOrigin(&v6->pose, (vec3_t *)&outOrigin);
          IconDims = CgWeaponSystem::GetIconDims(this, (const vec3_t *)&outOrigin, &x, &y, &w, &v29);
          memset(&outOrigin, 0, 0xCui64);
          if ( IconDims )
          {
            __asm
            {
              vmovss  xmm0, [rbp+57h+var_68]
              vmovss  [rbp+57h+var_60], xmm0
              vmovss  xmm1, [rbp+57h+w]
              vmovss  [rbp+57h+var_58], xmm1
              vmovss  xmm0, [rbp+57h+y]
              vmovss  [rbp+57h+w], xmm0
              vmovss  xmm1, [rbp+57h+x]
              vmovss  [rbp+57h+var_68], xmm1
            }
            if ( !material && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21619, ASSERT_TYPE_ASSERT, "(icon)", (const char *)&queryFormat, "icon") )
              __debugbreak();
            __asm
            {
              vmovss  xmm0, dword ptr cs:?colorWhite@@3Tvec4_t@@B; vec4_t const colorWhite
              vmovss  dword ptr [rbp+57h+outOrigin], xmm0
              vmovss  xmm1, dword ptr cs:?colorWhite@@3Tvec4_t@@B+4; vec4_t const colorWhite
              vmovss  dword ptr [rbp+57h+outOrigin+4], xmm1
              vmovss  xmm0, dword ptr cs:?colorWhite@@3Tvec4_t@@B+8; vec4_t const colorWhite
              vmovss  dword ptr [rbp+57h+outOrigin+8], xmm0
              vmovss  xmm6, cs:__real@3f800000
              vmovss  [rbp+57h+var_34], xmm6
            }
            ScrPlace_HiResApplyRect(&v29, &w, &v31, &v30);
            __asm
            {
              vmovss  dword ptr [rsp+0C0h+var_88], xmm6
              vmovss  [rsp+0C0h+var_90], xmm6
              vxorps  xmm0, xmm0, xmm0
              vmovss  dword ptr [rsp+0C0h+h], xmm0
              vmovss  dword ptr [rsp+0C0h+fmt], xmm0
              vmovss  xmm3, [rbp+57h+var_60]; h
              vmovss  xmm2, [rbp+57h+var_58]; w
              vmovss  xmm1, [rbp+57h+w]; y
              vmovss  xmm0, [rbp+57h+var_68]; x
            }
            CL_DrawStretchPicPhysical(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, fmt, h, v26, v27, &outOrigin, material);
          }
        }
      }
    }
  }
  _R11 = &v36;
  __asm { vmovaps xmm6, xmmword ptr [r11-10h] }
}

/*
==============
CgWeaponSystem::DrawTargetBox
==============
*/

void __fastcall CgWeaponSystem::DrawTargetBox(CgWeaponSystem *this, double x, double y, double w, float h, Material *icon, float alpha)
{
  Material *material; 
  float fmt; 
  float t1; 
  float v20; 
  float v21; 
  float wa; 
  float ya; 
  float xa; 
  vec4_t color; 

  material = icon;
  __asm
  {
    vmovss  [rsp+88h+x], xmm1
    vmovss  [rsp+88h+y], xmm2
    vmovss  [rsp+88h+w], xmm3
  }
  if ( !icon && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21619, ASSERT_TYPE_ASSERT, "(icon)", (const char *)&queryFormat, "icon") )
    __debugbreak();
  __asm
  {
    vmovss  xmm0, dword ptr cs:?colorWhite@@3Tvec4_t@@B; vec4_t const colorWhite
    vmovss  xmm1, dword ptr cs:?colorWhite@@3Tvec4_t@@B+4; vec4_t const colorWhite
    vmovss  dword ptr [rsp+88h+var_20], xmm0
    vmovss  xmm0, dword ptr cs:?colorWhite@@3Tvec4_t@@B+8; vec4_t const colorWhite
    vmovss  dword ptr [rsp+88h+var_20+4], xmm1
    vmovss  xmm1, [rsp+88h+alpha]
    vmovss  dword ptr [rsp+88h+var_20+8], xmm0
    vmovss  dword ptr [rsp+88h+var_20+0Ch], xmm1
  }
  ScrPlace_HiResApplyRect(&xa, &ya, &wa, &h);
  __asm
  {
    vmovss  xmm0, cs:__real@3f800000
    vmovss  xmm3, [rsp+88h+h]; h
    vmovss  xmm2, [rsp+88h+w]; w
    vmovss  [rsp+88h+var_50], xmm0
    vxorps  xmm1, xmm1, xmm1
    vmovss  [rsp+88h+var_58], xmm0
    vmovss  xmm0, [rsp+88h+x]; x
    vmovss  [rsp+88h+t1], xmm1
    vmovss  dword ptr [rsp+88h+fmt], xmm1
    vmovss  xmm1, [rsp+88h+y]; y
  }
  CL_DrawStretchPicPhysical(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, fmt, t1, v20, v21, &color, material);
}

/*
==============
GetAdditiveAnimMax
==============
*/
float GetAdditiveAnimMax(const XAnimTree *animTree, const playerState_s *ps, const AdditiveEaseInfo *easeInfoArray, const int numEaseInfo)
{
  __int64 v8; 
  bool v10; 
  bool v11; 
  __int64 v17; 
  unsigned int v19; 
  char v20; 

  __asm
  {
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps [rsp+58h+var_28], xmm7
  }
  _RDI = ps;
  v8 = numEaseInfo;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3378, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !animTree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3379, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
    __debugbreak();
  if ( !easeInfoArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3380, ASSERT_TYPE_ASSERT, "(easeInfoArray)", (const char *)&queryFormat, "easeInfoArray") )
    __debugbreak();
  v10 = (_DWORD)v8 == 0;
  if ( (int)v8 < 0 )
  {
    v11 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3381, ASSERT_TYPE_ASSERT, "(numEaseInfo >= 0)", (const char *)&queryFormat, "numEaseInfo >= 0");
    v10 = !v11;
    if ( v11 )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+730h]; lerpTime
    vmovss  xmm6, cs:__real@3f800000
    vxorps  xmm7, xmm7, xmm7
    vcomiss xmm0, xmm7
  }
  if ( !v10 )
  {
    __asm
    {
      vmovss  xmm1, cs:__real@3f4ccccd; easeOutTime
      vmovaps xmm2, xmm6; easeInTime
    }
    *(float *)&_XMM0 = GetAdditiveAnimMax_EaseInOut(*(const float *)&_XMM0, *(const float *)&_XMM1, *(const float *)&_XMM2);
    __asm { vmovaps xmm6, xmm0 }
  }
  v17 = v8;
  if ( (int)v8 > 0 )
  {
    _RBX = &easeInfoArray->easeOutTime;
    do
    {
      v19 = *((_DWORD *)_RBX - 1);
      *(double *)&_XMM0 = XAnimGetWeight(animTree, 0, XANIM_SUBTREE_DEFAULT, v19);
      __asm { vcomiss xmm0, xmm7 }
      if ( !(v20 | v10) )
      {
        *(double *)&_XMM0 = XAnimGetTime(animTree, 0, XANIM_SUBTREE_DEFAULT, v19);
        __asm
        {
          vmovss  xmm2, dword ptr [rbx+4]; easeInTime
          vmovss  xmm1, dword ptr [rbx]; easeOutTime
        }
        *(float *)&_XMM0 = GetAdditiveAnimMax_EaseInOut(*(const float *)&_XMM0, *(const float *)&_XMM1, *(const float *)&_XMM2);
        __asm { vminss  xmm6, xmm0, xmm6 }
      }
      _RBX += 3;
      --v17;
    }
    while ( v17 );
  }
  __asm
  {
    vmovaps xmm7, [rsp+58h+var_28]
    vmovaps xmm0, xmm6
    vmovaps xmm6, [rsp+58h+var_18]
  }
  return *(float *)&_XMM0;
}

/*
==============
GetAdditiveAnimMax_EaseInOut
==============
*/

float __fastcall GetAdditiveAnimMax_EaseInOut(double lerpTime, double easeOutTime, double easeInTime)
{
  bool v19; 
  bool v20; 
  bool v21; 
  bool v23; 
  double v34; 
  double v35; 
  double v36; 
  double v37; 
  double v38; 
  double v39; 
  double v40; 
  double v41; 
  double v42; 
  double v43; 
  char v44; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-18h], xmm6
    vmovaps xmmword ptr [rax-28h], xmm7
    vmovaps xmmword ptr [rax-38h], xmm8
    vmovss  xmm8, cs:__real@3f800000
    vmovaps xmmword ptr [rax-48h], xmm9
    vmovaps xmmword ptr [rax-58h], xmm10
    vmovaps xmmword ptr [rax-68h], xmm11
    vxorps  xmm9, xmm9, xmm9
    vcomiss xmm1, xmm9
    vmovaps xmmword ptr [rax-78h], xmm12
    vmovsd  xmm12, cs:__real@3ff0000000000000
    vmovaps xmm6, xmm2
    vmovaps xmm7, xmm1
    vmovaps xmm10, xmm0
    vxorpd  xmm11, xmm11, xmm11
    vcomiss xmm1, xmm8
    vmovsd  [rsp+0C8h+var_90], xmm12
    vcvtss2sd xmm0, xmm7, xmm7
    vmovsd  [rsp+0C8h+var_98], xmm11
    vmovsd  [rsp+0C8h+var_A0], xmm0
  }
  v19 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3341, ASSERT_TYPE_ASSERT, "( 0.0f ) <= ( easeOutTime ) && ( easeOutTime ) <= ( 1.0f )", "easeOutTime not in [0.0f, 1.0f]\n\t%g not in [%g, %g]", v34, v36, v38);
  v20 = !v19;
  if ( v19 )
    __debugbreak();
  __asm
  {
    vcomiss xmm6, xmm9
    vcomiss xmm6, xmm8
  }
  if ( v19 )
  {
    __asm
    {
      vmovsd  [rsp+0C8h+var_90], xmm12
      vcvtss2sd xmm0, xmm6, xmm6
      vmovsd  [rsp+0C8h+var_98], xmm11
      vmovsd  [rsp+0C8h+var_A0], xmm0
    }
    v21 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3342, ASSERT_TYPE_ASSERT, "( 0.0f ) <= ( easeInTime ) && ( easeInTime ) <= ( 1.0f )", "easeInTime not in [0.0f, 1.0f]\n\t%g not in [%g, %g]", v35, v37, v39);
    v20 = !v21;
    if ( v21 )
      __debugbreak();
  }
  __asm { vcomiss xmm7, xmm6 }
  if ( !v20 )
  {
    __asm
    {
      vcvtss2sd xmm0, xmm6, xmm6
      vmovsd  [rsp+0C8h+var_88], xmm0
      vcvtss2sd xmm1, xmm7, xmm7
      vmovsd  [rsp+0C8h+var_90], xmm1
    }
    v23 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3343, ASSERT_TYPE_ASSERT, "( easeOutTime ) <= ( easeInTime )", "%s <= %s\n\t%g, %g", "easeOutTime", "easeInTime", v40, v42);
    v20 = !v23;
    if ( v23 )
      __debugbreak();
  }
  __asm
  {
    vcomiss xmm10, xmm7
    vcomiss xmm10, xmm6
  }
  if ( !v20 )
  {
    __asm
    {
      vcomiss xmm6, xmm8
      vmovsd  [rsp+0C8h+var_88], xmm12
      vcvtss2sd xmm0, xmm6, xmm6
      vmovsd  [rsp+0C8h+var_90], xmm0
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3357, ASSERT_TYPE_ASSERT, "( easeInTime ) < ( 1.0f )", "%s < %s\n\t%g, %g", "easeInTime", "1.0f", v41, v43) )
      __debugbreak();
    __asm { vcomiss xmm6, xmm8 }
  }
  __asm { vxorps  xmm0, xmm0, xmm0 }
  _R11 = &v44;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
  }
  return *(float *)&_XMM0;
}

/*
==============
GetAnimBlendTimes
==============
*/
__int64 GetAnimBlendTimes(const LocalClientNum_t localClientNum, const Weapon *r_weapon, const playerState_s *const ps, const WeaponAnimNumber blendOutAnim, const unsigned int blendOutAnimIndex, const WeaponAnimNumber blendInAnim, const unsigned int blendInAnimIndex, float *blendOutTime, float *blendInTime)
{
  const dvar_t *v9; 
  const AnimStateBlendTimes *v16; 
  unsigned int v17; 
  unsigned int i; 
  weapAnimFiles_t *p_animBlendIn; 
  void (__fastcall *blendFunc)(const LocalClientNum_t, const Weapon *, const playerState_s *const, const WeaponAnimNumber, const unsigned int, const WeaponAnimNumber, const unsigned int, float *, float *); 
  __int64 v24; 
  __int64 v25; 

  v9 = DCONST_DVARBOOL_cg_viewmodelAnimBlending;
  if ( !DCONST_DVARBOOL_cg_viewmodelAnimBlending && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmodelAnimBlending") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v9);
  if ( !v9->current.enabled )
    return 0i64;
  _R14 = blendOutTime;
  if ( !blendOutTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1502, ASSERT_TYPE_ASSERT, "(blendOutTime)", (const char *)&queryFormat, "blendOutTime") )
    __debugbreak();
  _RSI = blendInTime;
  if ( !blendInTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1503, ASSERT_TYPE_ASSERT, "(blendInTime)", (const char *)&queryFormat, "blendInTime") )
    __debugbreak();
  if ( blendOutAnimIndex >= 0x260 )
  {
    LODWORD(v25) = 608;
    LODWORD(v24) = blendOutAnimIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1504, ASSERT_TYPE_ASSERT, "(unsigned)( blendOutAnimIndex ) < (unsigned)( NUM_WEAP_VIEWMODEL_ANIMS )", "blendOutAnimIndex doesn't index NUM_WEAP_VIEWMODEL_ANIMS\n\t%i not in [0, %i)", v24, v25) )
      __debugbreak();
  }
  if ( blendInAnimIndex >= 0x260 )
  {
    LODWORD(v25) = 608;
    LODWORD(v24) = blendInAnimIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1505, ASSERT_TYPE_ASSERT, "(unsigned)( blendInAnimIndex ) < (unsigned)( NUM_WEAP_VIEWMODEL_ANIMS )", "blendInAnimIndex doesn't index NUM_WEAP_VIEWMODEL_ANIMS\n\t%i not in [0, %i)", v24, v25) )
      __debugbreak();
  }
  v16 = s_blendAnimStates;
  v17 = 0;
  for ( i = 0; i < 0xB5; ++i )
  {
    if ( v16->animBlendOut == blendOutAnim && v16->animBlendIn == blendInAnim )
    {
      blendFunc = v16->blendFunc;
      if ( blendFunc )
      {
        blendFunc(localClientNum, r_weapon, ps, blendOutAnim, blendOutAnimIndex, blendInAnim, blendInAnimIndex, blendOutTime, blendInTime);
      }
      else
      {
        *blendOutTime = v16->animBlendTimeOut;
        *blendInTime = v16->animBlendTimeIn;
      }
      return 1i64;
    }
    ++v16;
  }
  p_animBlendIn = &s_blendAnims[0].animBlendIn;
  do
  {
    if ( *((_DWORD *)p_animBlendIn - 1) == blendOutAnimIndex && *p_animBlendIn == blendInAnimIndex )
    {
      *blendOutTime = s_blendAnims[v17].animBlendTimeOut;
      *blendInTime = s_blendAnims[v17].animBlendTimeIn;
      return 1i64;
    }
    ++v17;
    p_animBlendIn += 4;
  }
  while ( v17 < 0x14 );
  if ( blendInAnimIndex - 262 > 0x17 || blendOutAnimIndex - 262 > 0x17 )
    return 0i64;
  _RBX = DCONST_DVARFLT_cg_viewmodelMeleeAnimBlendTimeSec;
  if ( !DCONST_DVARFLT_cg_viewmodelMeleeAnimBlendTimeSec && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmodelMeleeAnimBlendTimeSec") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+28h]
    vmovss  dword ptr [r14], xmm0
    vmovss  dword ptr [rsi], xmm0
  }
  return 1i64;
}

/*
==============
MovementAnimState::GetCycleAnimation
==============
*/
__int64 MovementAnimState::GetCycleAnimation(MovementAnimState *this, const MovementAnimState::State state)
{
  __int32 v3; 
  __int32 v4; 

  if ( state == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5781, ASSERT_TYPE_ASSERT, "(state != State::NONE)", (const char *)&queryFormat, "state != State::NONE") )
    __debugbreak();
  if ( state )
  {
    v3 = state - 1;
    if ( !v3 )
      return 64i64;
    v4 = v3 - 1;
    if ( !v4 )
      return 65i64;
    if ( v4 == 1 )
      return 66i64;
  }
  return 63i64;
}

/*
==============
CAssistTarget::GetEntNum
==============
*/
__int64 CAssistTarget::GetEntNum(CAssistTarget *this)
{
  const centity_t *m_target; 

  m_target = this->m_target;
  if ( m_target )
    return (unsigned int)m_target->nextState.number;
  else
    return 2047i64;
}

/*
==============
MovementAnimState::GetGoalState
==============
*/
__int64 MovementAnimState::GetGoalState(MovementAnimState *this, const LocalClientNum_t localClientNum, const playerState_s *ps)
{
  bool IsSuperSprinting; 
  bool v6; 
  bool IsJogging; 

  if ( MovementAnimState::PlayerActionForcesWalk(localClientNum, ps) )
    return 0i64;
  IsSuperSprinting = BG_IsSuperSprinting(ps);
  v6 = !IsSuperSprinting && GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 0x14u);
  IsJogging = CG_IsJogging(localClientNum);
  if ( IsSuperSprinting )
    return 3i64;
  if ( v6 )
    return 2i64;
  return IsJogging;
}

/*
==============
CgWeaponSystem::GetIconDims
==============
*/
__int64 CgWeaponSystem::GetIconDims(CgWeaponSystem *this, const vec3_t *targetPos, float *x, float *y, float *w, float *h)
{
  bool v18; 
  const ScreenPlacement *v19; 
  LocalClientNum_t m_localClientNum; 
  const dvar_t *v42; 
  __int64 result; 
  vec2_t v62; 
  vec2_t outScreenPos; 
  vec3_t worldPos; 

  _R15 = w;
  _R14 = y;
  _RBP = h;
  _R12 = x;
  _RDI = targetPos;
  if ( !x && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21529, ASSERT_TYPE_ASSERT, "(x)", (const char *)&queryFormat, "x") )
    __debugbreak();
  if ( !_R14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21530, ASSERT_TYPE_ASSERT, "(y)", (const char *)&queryFormat, "y") )
    __debugbreak();
  if ( !w && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21531, ASSERT_TYPE_ASSERT, "(w)", (const char *)&queryFormat, "w") )
    __debugbreak();
  if ( !h && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21532, ASSERT_TYPE_ASSERT, "(h)", (const char *)&queryFormat, "h") )
    __debugbreak();
  if ( activeScreenPlacementMode )
  {
    if ( activeScreenPlacementMode == SCRMODE_DISPLAY )
    {
      v19 = &scrPlaceViewDisplay[this->m_localClientNum];
      goto LABEL_20;
    }
    if ( activeScreenPlacementMode == SCRMODE_INVALID )
      v18 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\screen_placement.h", 127, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "ScrPlace_GetActivePlacement() called when outside of a valid render loop.");
    else
      v18 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\screen_placement.h", 130, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Unsupported activeScreenPlacementMode");
    if ( v18 )
      __debugbreak();
  }
  v19 = &scrPlaceFull;
  if ( !CG_WorldPosToScreenPosReal(this->m_localClientNum, v19, _RDI, &outScreenPos) )
    goto LABEL_34;
LABEL_20:
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  xmm1, dword ptr [rdi+4]
  }
  m_localClientNum = this->m_localClientNum;
  __asm
  {
    vmovss  dword ptr [rsp+118h+worldPos], xmm0
    vmovss  xmm0, dword ptr [rdi+8]
    vaddss  xmm2, xmm0, cs:__real@42700000
    vmovss  dword ptr [rsp+118h+worldPos+8], xmm2
    vmovss  dword ptr [rsp+118h+worldPos+4], xmm1
  }
  if ( CG_WorldPosToScreenPosReal(m_localClientNum, v19, &worldPos, &v62) )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rsp+118h+outScreenPos]
      vaddss  xmm1, xmm0, dword ptr [rsp+118h+var_D8]
      vmovss  xmm0, dword ptr [rsp+118h+outScreenPos+4]
    }
    _RDI = DVARFLT_FoFIconMinSize;
    __asm
    {
      vmovaps [rsp+118h+var_58], xmm6
      vmovaps [rsp+118h+var_68], xmm7
      vmovaps [rsp+118h+var_78], xmm8
      vmovaps [rsp+118h+var_88], xmm9
      vmovaps [rsp+118h+var_98], xmm10
      vmovaps [rsp+118h+var_A8], xmm11
      vmovss  xmm6, cs:__real@3f000000
      vmulss  xmm10, xmm1, xmm6
      vaddss  xmm1, xmm0, dword ptr [rsp+118h+var_D8+4]
      vmulss  xmm11, xmm1, xmm6
    }
    if ( !DVARFLT_FoFIconMinSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "FoFIconMinSize") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RDI);
    __asm { vmovss  xmm0, dword ptr [rdi+28h] }
    _RDI = DVARFLT_FoFIconMaxSize;
    __asm { vmulss  xmm7, xmm0, dword ptr [rbx] }
    if ( !DVARFLT_FoFIconMaxSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "FoFIconMaxSize") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RDI);
    __asm
    {
      vmovss  xmm0, dword ptr [rdi+28h]
      vmulss  xmm8, xmm0, dword ptr [rbx]
      vmovss  xmm0, dword ptr [rsp+118h+var_D8+4]
      vmovss  xmm1, dword ptr [rsp+118h+var_D8]
      vsubss  xmm2, xmm0, dword ptr [rsp+118h+outScreenPos+4]
      vsubss  xmm4, xmm1, dword ptr [rsp+118h+outScreenPos]
    }
    v42 = DVARFLT_FoFIconScale;
    __asm
    {
      vmulss  xmm3, xmm2, xmm2
      vmulss  xmm1, xmm4, xmm4
      vaddss  xmm0, xmm3, xmm1
      vsqrtss xmm9, xmm0, xmm0
    }
    if ( !DVARFLT_FoFIconScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "FoFIconScale") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v42);
    __asm
    {
      vmulss  xmm0, xmm9, dword ptr [rbx+28h]; val
      vmovaps xmm2, xmm8; max
      vmovaps xmm1, xmm7; min
    }
    *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
    __asm
    {
      vmulss  xmm2, xmm0, cs:?cls@@3UClStatic@@A.vidConfig.aspectRatioDisplayPixel; ClStatic cls
      vmovaps xmm9, [rsp+118h+var_88]
    }
    result = 1i64;
    __asm
    {
      vmovaps xmm8, [rsp+118h+var_78]
      vmovaps xmm7, [rsp+118h+var_68]
      vmovss  dword ptr [r15], xmm0
      vmovss  dword ptr [rbp+0], xmm2
      vmulss  xmm0, xmm0, xmm6
      vsubss  xmm1, xmm10, xmm0
      vmovaps xmm10, [rsp+118h+var_98]
      vmulss  xmm2, xmm2, xmm6
      vmovaps xmm6, [rsp+118h+var_58]
      vsubss  xmm0, xmm11, xmm2
      vmovaps xmm11, [rsp+118h+var_A8]
      vmovss  dword ptr [r12], xmm1
      vmovss  dword ptr [r14], xmm0
    }
  }
  else
  {
LABEL_34:
    result = 0i64;
    *_R12 = 0.0;
    *_R14 = 0.0;
    *w = 0.0;
    *h = 0.0;
  }
  return result;
}

/*
==============
CgWeaponSystem::GetIconDimsForPlayer
==============
*/
__int64 CgWeaponSystem::GetIconDimsForPlayer(CgWeaponSystem *this, const centity_t *cent, float *x, float *y, float *w, float *h, bool forceCheck)
{
  __int64 result; 
  unsigned int IconDims; 
  vec3_t outOrigin; 

  if ( !cent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21591, ASSERT_TYPE_ASSERT, "(cent)", (const char *)&queryFormat, "cent", -2i64) )
    __debugbreak();
  if ( (cent->flags & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21592, ASSERT_TYPE_ASSERT, "(CENextValid( cent ))", (const char *)&queryFormat, "CENextValid( cent )") )
    __debugbreak();
  if ( !x && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21593, ASSERT_TYPE_ASSERT, "(x)", (const char *)&queryFormat, "x") )
    __debugbreak();
  if ( !y && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21594, ASSERT_TYPE_ASSERT, "(y)", (const char *)&queryFormat, "y") )
    __debugbreak();
  if ( !w && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21595, ASSERT_TYPE_ASSERT, "(w)", (const char *)&queryFormat, "w") )
    __debugbreak();
  if ( !h && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21596, ASSERT_TYPE_ASSERT, "(h)", (const char *)&queryFormat, "h") )
    __debugbreak();
  if ( BG_IsCharacterEntity(&cent->nextState) || forceCheck )
  {
    CG_GetPoseOrigin(&cent->pose, &outOrigin);
    IconDims = CgWeaponSystem::GetIconDims(this, &outOrigin, x, y, w, h);
    memset(&outOrigin, 0, sizeof(outOrigin));
    return IconDims;
  }
  else
  {
    result = 0i64;
    *x = 0.0;
    *y = 0.0;
    *w = 0.0;
    *h = 0.0;
  }
  return result;
}

/*
==============
MovementAnimState::GetOffsetAnimation
==============
*/
__int64 MovementAnimState::GetOffsetAnimation(MovementAnimState *this, const MovementAnimState::State state)
{
  __int32 v3; 
  __int32 v4; 

  if ( state == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5762, ASSERT_TYPE_ASSERT, "(state != State::NONE)", (const char *)&queryFormat, "state != State::NONE") )
    __debugbreak();
  if ( state )
  {
    v3 = state - 1;
    if ( !v3 )
      return 47i64;
    v4 = v3 - 1;
    if ( !v4 )
      return 48i64;
    if ( v4 == 1 )
      return 49i64;
  }
  return 46i64;
}

/*
==============
CAssistTarget::GetTarget
==============
*/
const centity_t *CAssistTarget::GetTarget(CAssistTarget *this)
{
  return this->m_target;
}

/*
==============
CgWeaponSystem::GetTargetEvaluator
==============
*/
CConeTargetEvaluator *CgWeaponSystem::GetTargetEvaluator(targetAssistType_t assistType)
{
  if ( assistType == TARGET_ASSISTTYPPE_CONE )
    return &CgWeaponSystem::ms_coneTargetEvaluator;
  else
    return 0i64;
}

/*
==============
MovementAnimState::GetTransitionAnimation
==============
*/
__int64 MovementAnimState::GetTransitionAnimation(MovementAnimState *this, MovementAnimState::State prevState, const MovementAnimState::State nextState)
{
  __int64 v3; 
  MovementAnimState::State v5; 
  bool v6; 
  MovementAnimState::State v7; 
  weapAnimFiles_t v8; 
  __int64 v10; 
  __int64 v11; 
  __int64 v12; 

  v3 = nextState;
  if ( prevState == nextState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5725, ASSERT_TYPE_ASSERT, "( static_cast<int>( prevState ) ) != ( static_cast<int>( nextState ) )", "%s != %s\n\t%i, %i", "static_cast<int>( prevState )", "static_cast<int>( nextState )", prevState, nextState) )
    __debugbreak();
  if ( prevState == -1 )
  {
    v5 = NONE;
    if ( !(_DWORD)v3 )
    {
      v6 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5734, ASSERT_TYPE_ASSERT, "(nextState != State::WALK)", (const char *)&queryFormat, "nextState != State::WALK");
      goto LABEL_17;
    }
  }
  v7 = NONE;
  if ( prevState != -1 )
    v7 = prevState;
  if ( (_DWORD)v3 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5750, ASSERT_TYPE_ASSERT, "(nextState != State::NONE)", (const char *)&queryFormat, "nextState != State::NONE") )
    __debugbreak();
  if ( (unsigned int)v7 >= LONG_LONG )
  {
    LODWORD(v11) = 4;
    LODWORD(v10) = v7;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5751, ASSERT_TYPE_ASSERT, "(unsigned)( static_cast<int>( prevState ) ) < (unsigned)( ( sizeof( *array_counter( s_transitions ) ) + 0 ) )", "static_cast<int>( prevState ) doesn't index ARRAY_COUNT( s_transitions )\n\t%i not in [0, %i)", v10, v11) )
      __debugbreak();
  }
  v5 = v7;
  if ( (unsigned int)v3 >= 4 )
  {
    LODWORD(v11) = 4;
    LODWORD(v10) = v3;
    v6 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5752, ASSERT_TYPE_ASSERT, "(unsigned)( static_cast<int>( nextState ) ) < (unsigned)( ( sizeof( *array_counter( s_transitions[0] ) ) + 0 ) )", "static_cast<int>( nextState ) doesn't index ARRAY_COUNT( s_transitions[0] )\n\t%i not in [0, %i)", v10, v11);
LABEL_17:
    if ( v6 )
      __debugbreak();
  }
  v8 = s_transitions[v5][v3];
  if ( v8 == WEAP_ANIM_ROOT )
  {
    LODWORD(v12) = 0;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5754, ASSERT_TYPE_ASSERT, "( static_cast<int>( transitionAnim ) ) != ( 0 )", "%s != %s\n\t%i, %i", "static_cast<int>( transitionAnim )", "0", v12, 0i64) )
      __debugbreak();
  }
  return (unsigned int)v8;
}

/*
==============
MovementAnimState::GetTransitionDuration
==============
*/
void MovementAnimState::GetTransitionDuration(MovementAnimState *this, const LocalClientNum_t localClientNum, const playerState_s *ps, const MovementAnimState::State prevState, const MovementAnimState::State nextState, float *outTransDurationSec, float *outCycleTransDurationSec)
{
  __int64 v9; 
  const Weapon *ViewmodelWeapon; 
  bool v14; 
  bool v15; 
  __int32 v19; 
  __int64 v33; 
  __int64 v34; 

  v9 = localClientNum;
  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5644, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, 2) )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5645, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  _RBX = outTransDurationSec;
  if ( !outTransDurationSec && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5646, ASSERT_TYPE_ASSERT, "(outTransDurationSec)", (const char *)&queryFormat, "outTransDurationSec") )
    __debugbreak();
  if ( !outCycleTransDurationSec && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5647, ASSERT_TYPE_ASSERT, "(outCycleTransDurationSec)", (const char *)&queryFormat, "outCycleTransDurationSec") )
    __debugbreak();
  if ( !CgWeaponMap::ms_instance[v9] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  ViewmodelWeapon = BG_GetViewmodelWeapon(CgWeaponMap::ms_instance[v9], ps);
  v14 = BG_UsingAlternate(ps);
  v15 = BG_PlayerDualWielding(ps) != 0;
  if ( prevState == -1 && nextState == NONE )
  {
    *outTransDurationSec = 0.0;
    __asm { vxorps  xmm0, xmm0, xmm0 }
    goto LABEL_54;
  }
  if ( nextState < prevState )
  {
    if ( (unsigned int)v9 >= 2 )
    {
      LODWORD(v34) = 2;
      LODWORD(v33) = v9;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5615, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v33, v34) )
        __debugbreak();
    }
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5616, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    if ( MovementAnimState::PlayerActionForcesWalk((const LocalClientNum_t)v9, ps) )
    {
      if ( prevState == HALF_HALF )
      {
        _RDI = DCONST_DVARMPFLT_movementAnimProto_QuickTransOutSprint;
        if ( !DCONST_DVARMPFLT_movementAnimProto_QuickTransOutSprint && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "movementAnimProto_QuickTransOutSprint") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(_RDI);
        __asm { vmovss  xmm0, dword ptr [rdi+28h] }
        goto LABEL_53;
      }
      if ( prevState == LONG )
      {
        _RDI = DCONST_DVARMPFLT_movementAnimProto_QuickTransOutSuperSprint;
        if ( !DCONST_DVARMPFLT_movementAnimProto_QuickTransOutSuperSprint && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "movementAnimProto_QuickTransOutSuperSprint") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(_RDI);
        __asm { vmovss  xmm0, dword ptr [rdi+28h] }
        goto LABEL_53;
      }
    }
    v19 = prevState - 2;
    if ( !v19 )
    {
      BG_MoveTransitionTime(ps, ViewmodelWeapon, v14, v15, MOVE_TRANS_DOWNFROM_SPRINT);
      __asm
      {
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm0, xmm0, eax
        vmulss  xmm1, xmm0, cs:__real@3a83126f; sprintOutTime
      }
      *(float *)&_XMM0 = ScaleSprintOutTime((const LocalClientNum_t)v9, *(float *)&_XMM1);
LABEL_53:
      __asm { vmovss  dword ptr [rbx], xmm0 }
      goto LABEL_54;
    }
    if ( v19 == 1 )
    {
      __asm { vmovaps [rsp+78h+var_38], xmm6 }
      BG_MoveTransitionTime(ps, ViewmodelWeapon, v14, v15, MOVE_TRANS_DOWNFROM_SUPERSPRINT);
      __asm
      {
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm0, xmm0, eax
        vmulss  xmm1, xmm0, cs:__real@3a83126f; sprintOutTime
      }
      *(float *)&_XMM0 = ScaleSprintOutTime((const LocalClientNum_t)v9, *(float *)&_XMM1);
      __asm { vmovss  dword ptr [rbx], xmm0 }
      *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARMPFLT_movementAnimProto_DownFromSuperSprintCycleBlendScale, "movementAnimProto_DownFromSuperSprintCycleBlendScale");
      __asm { vmovaps xmm6, xmm0 }
      BG_MoveTransitionTime(ps, ViewmodelWeapon, v14, v15, MOVE_TRANS_DOWNFROM_SUPERSPRINT);
      __asm
      {
        vxorps  xmm1, xmm1, xmm1
        vcvtsi2ss xmm1, xmm1, eax
        vmulss  xmm2, xmm1, cs:__real@3a83126f
        vmulss  xmm1, xmm2, xmm6; sprintOutTime
      }
      *(float *)&_XMM0 = ScaleSprintOutTime((const LocalClientNum_t)v9, *(float *)&_XMM1);
      __asm { vmovaps xmm6, [rsp+78h+var_38] }
      goto LABEL_54;
    }
  }
  switch ( nextState )
  {
    case NONE:
      BG_MoveTransitionTime(ps, ViewmodelWeapon, v14, v15, MOVE_TRANS_TO_WALK);
      goto LABEL_52;
    case HALF:
      BG_MoveTransitionTime(ps, ViewmodelWeapon, v14, v15, MOVE_TRANS_TO_JOG);
      goto LABEL_52;
    case HALF_HALF:
      BG_MoveTransitionTime(ps, ViewmodelWeapon, v14, v15, MOVE_TRANS_TO_SPRINT);
      goto LABEL_52;
    case LONG:
      BG_MoveTransitionTime(ps, ViewmodelWeapon, v14, v15, MOVE_TRANS_TO_SUPERSPRINT);
LABEL_52:
      __asm
      {
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm0, xmm0, eax
        vmulss  xmm0, xmm0, cs:__real@3a83126f
      }
      goto LABEL_53;
  }
  LODWORD(v33) = nextState;
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5715, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "GetTransDuration(): Encountered unexpected nextState %i", v33) )
    __debugbreak();
  __asm { vmovss  xmm0, cs:__real@3c23d70a }
  *outTransDurationSec = 0.0099999998;
LABEL_54:
  _RAX = outCycleTransDurationSec;
  __asm { vmovss  dword ptr [rax], xmm0 }
}

/*
==============
HandleExclusiveAkimboSwitchAnimPlay
==============
*/
bool HandleExclusiveAkimboSwitchAnimPlay(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex hand, const Weapon *weapon)
{
  __int64 v7; 
  cg_t *LocalClientGlobals; 
  const XAnimTree *tree; 
  char v11; 
  char v12; 
  char v13; 
  int weaponState; 
  bool result; 
  __int64 goalTime; 

  __asm { vmovaps [rsp+98h+var_28], xmm6 }
  _RSI = ps;
  v7 = hand;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5919, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( (unsigned int)v7 >= 2 )
  {
    LODWORD(goalTime) = v7;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1207, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", goalTime, 2) )
      __debugbreak();
  }
  if ( (cg_t *)((char *)LocalClientGlobals + 40 * v7) == (cg_t *)-807496i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5922, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
    __debugbreak();
  tree = LocalClientGlobals->m_weaponHand[v7].tree;
  if ( !tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5925, ASSERT_TYPE_ASSERT, "(tree)", (const char *)&queryFormat, "tree") )
    __debugbreak();
  *(double *)&_XMM0 = XAnimGetWeight(tree, 0, XANIM_SUBTREE_DEFAULT, 0x14Bu);
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vcomiss xmm0, xmm6
  }
  if ( !(v11 | v12) )
    goto LABEL_16;
  *(double *)&_XMM0 = XAnimGetWeight(tree, 0, XANIM_SUBTREE_DEFAULT, 0x148u);
  __asm { vcomiss xmm0, xmm6 }
  if ( v11 | v12 )
    v13 = 0;
  else
LABEL_16:
    v13 = 1;
  weaponState = _RSI->weapState[0].weaponState;
  if ( weaponState == 11 || weaponState == 4 )
  {
    if ( v13 )
      __asm { vucomiss xmm6, dword ptr [rsi+730h] }
  }
  result = 0;
  __asm { vmovaps xmm6, [rsp+98h+var_28] }
  return result;
}

/*
==============
HoldBreathUpdate
==============
*/

void __fastcall HoldBreathUpdate(LocalClientNum_t localClientNum, __int64 a2, double _XMM2_8)
{
  int holdBreathDelay; 
  CgSoundSystem *SoundSystem; 
  bool v18; 
  int holdBreathTime; 

  _RBX = CG_GetLocalClientGlobals(localClientNum);
  holdBreathDelay = _RBX->holdBreathDelay;
  if ( holdBreathDelay > 0 )
    _RBX->holdBreathDelay = holdBreathDelay - _RBX->frametime;
  SoundSystem = CgSoundSystem::GetSoundSystem(localClientNum);
  if ( GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&_RBX->predictedPlayerState.weapCommon.weapFlags, ACTIVE, 2u) )
  {
    _RSI = DVARFLT_player_breath_snd_lerp;
    __asm
    {
      vmovaps [rsp+68h+var_28], xmm6
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, dword ptr [rbx+65E4h]
      vmulss  xmm6, xmm0, cs:__real@3a83126f
    }
    if ( !DVARFLT_player_breath_snd_lerp && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_breath_snd_lerp") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RSI);
    __asm
    {
      vmovss  xmm2, dword ptr [rsi+28h]; rate
      vmovss  xmm1, dword ptr [rbx+4A080h]; cur
      vmovss  xmm0, cs:__real@3f800000; tgt
      vmovaps xmm3, xmm6; deltaTime
    }
    *(double *)&_XMM0 = DiffTrack(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3);
    __asm { vmovss  dword ptr [rbx+4A080h], xmm0 }
    CG_SND_PlayerBreathsHold(localClientNum);
    __asm { vmovaps xmm6, [rsp+68h+var_28] }
    if ( _RBX->holdBreathTime >= 0 )
    {
      if ( _RBX->breathHoldState == BREATH_HOLD_HOLDING )
        CgSoundSystem::PlayClientSoundAlias(SoundSystem, cgMedia.playerHeartBeatSound);
    }
    else
    {
      v18 = _RBX->holdBreathDelay <= 0;
      _RBX->holdBreathTime = 0;
      if ( v18 )
      {
        _RSI = DVARFLT_player_breath_snd_delay;
        if ( !DVARFLT_player_breath_snd_delay && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_breath_snd_delay") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(_RSI);
        __asm
        {
          vmovss  xmm0, dword ptr [rsi+28h]
          vmulss  xmm1, xmm0, cs:__real@447a0000
          vcvttss2si eax, xmm1
        }
        _RBX->holdBreathDelay = _EAX;
        _RSI = DVARFLT_player_breath_snd_lerp;
        if ( !DVARFLT_player_breath_snd_lerp && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_breath_snd_lerp") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(_RSI);
        __asm { vmovss  xmm3, dword ptr [rsi+28h]; fadeTime }
        CG_SetAudioOverride(localClientNum, "hold_breath", CTAUD_OVERRIDE_HOLDBREATH, *(float *)&_XMM3, 2047);
      }
    }
    _RBX->holdBreathTime += _RBX->frametime;
  }
  else
  {
    holdBreathTime = _RBX->holdBreathTime;
    if ( holdBreathTime >= 0 )
    {
      _RBX->holdBreathTime = _RBX->frametime + holdBreathTime;
      if ( _RBX->holdBreathTime <= BG_HoldBreathMaxTime(&_RBX->predictedPlayerState) )
      {
        if ( _RBX->holdBreathDelay <= 0 )
        {
          *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DVARFLT_player_breath_snd_delay, "player_breath_snd_delay");
          __asm
          {
            vmulss  xmm1, xmm0, cs:__real@447a0000
            vcvttss2si eax, xmm1
          }
          _RBX->holdBreathDelay = _EAX;
        }
      }
      else
      {
        CG_SND_PlayerBreathsGasp(localClientNum);
      }
    }
    __asm { vxorps  xmm2, xmm2, xmm2; fadeTime }
    _RBX->holdBreathTime = -1;
    _RBX->holdBreathFrac = 0.0;
    CG_ClearAudioOverride(localClientNum, CTAUD_OVERRIDE_HOLDBREATH, *(float *)&_XMM2);
  }
}

/*
==============
IsAdditiveCrawlEnabled
==============
*/
_BOOL8 IsAdditiveCrawlEnabled(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex hand)
{
  const dvar_t *v3; 
  CgHandler *Handler; 
  CgHandler *v8; 
  _BOOL8 result; 

  v3 = DCONST_DVARBOOL_cg_viewmodelAnimatedCrawl;
  if ( !DCONST_DVARBOOL_cg_viewmodelAnimatedCrawl && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmodelAnimatedCrawl") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v3);
  result = 0;
  if ( v3->current.enabled )
  {
    Handler = CgHandler::getHandler(localClientNum);
    if ( BG_ViewModelAnimExists(ps, WEAP_ANIM_ADDITIVE_CRAWL_IN, hand, Handler) )
    {
      v8 = CgHandler::getHandler(localClientNum);
      if ( BG_ViewModelAnimExists(ps, WEAP_ANIM_ADDITIVE_CRAWL_LOOP, hand, v8) )
        return 1;
    }
  }
  return result;
}

/*
==============
MovementAnimState::IsOffsetAnimationTransition
==============
*/
bool MovementAnimState::IsOffsetAnimationTransition(MovementAnimState *this, const weapAnimFiles_t animIndex)
{
  return (unsigned int)(animIndex - 50) <= 0xB;
}

/*
==============
CgWeaponSystem::IsPlayerWeaponLaserOn
==============
*/
bool CgWeaponSystem::IsPlayerWeaponLaserOn(CgWeaponSystem *this, const Weapon *r_weapon)
{
  cg_t *LocalClientGlobals; 

  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  return this->IsWeaponLaserOn(this, r_weapon, &LocalClientGlobals->predictedPlayerState, NULL) || this->IsLaserFlagOn(this, &LocalClientGlobals->predictedPlayerState) || CG_LaserForceOnEnabled();
}

/*
==============
CgWeaponSystem::IsWeaponLaserOn
==============
*/
bool CgWeaponSystem::IsWeaponLaserOn(CgWeaponSystem *this, const Weapon *r_weapon, const playerState_s *ps, const centity_t *cent)
{
  bool inAltWeaponMode; 
  cg_t *LocalClientGlobals; 
  const cg_t *v11; 
  bool v12; 
  char v13; 
  char v14; 
  bool result; 
  entityState_t *p_nextState; 
  bool v17; 
  const characterInfo_t *CharacterInfo; 
  unsigned int Animset; 
  unsigned int Anim; 
  bool v21; 
  SuitAnimType SuitAnimIndex; 
  int LegsAnimation; 
  int usingNVG; 
  bool IsAdsEntity; 
  LaserSettings outLaserSettings; 

  _RDI = ps;
  if ( ps )
    inAltWeaponMode = BG_UsingAlternate(ps);
  else
    inAltWeaponMode = cent->nextState.inAltWeaponMode;
  BG_GetWeaponLaserSettings(r_weapon, inAltWeaponMode, &outLaserSettings);
  if ( !outLaserSettings.forceLaserOn )
    return 0;
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  v11 = LocalClientGlobals;
  if ( _RDI && _RDI == &LocalClientGlobals->predictedPlayerState )
  {
    if ( !BG_IsEMPJammed(_RDI) && (unsigned int)(_RDI->weapState[0].weaponState - 34) > 2 )
    {
      v12 = CG_LookingThroughNightVision((const LocalClientNum_t)this->m_localClientNum);
      *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DVARFLT_laserAdsFraction, "laserAdsFraction");
      __asm { vcomiss xmm0, dword ptr [rdi+730h] }
      v13 = v14 | v21;
      *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DVARFLT_laserHipFraction, "laserHipFraction");
      __asm { vcomiss xmm0, dword ptr [rdi+730h] }
      if ( v12 )
      {
        if ( v13 )
          return outLaserSettings.localPlayerNVGADSLaserEnabled;
        if ( !v14 && outLaserSettings.localPlayerNVGHipLaserEnabled )
          return 1;
      }
      else
      {
        if ( v13 )
          return outLaserSettings.localPlayerADSLaserEnabled;
        if ( !v14 && outLaserSettings.localPlayerHipLaserEnabled )
          return 1;
      }
    }
    return 0;
  }
  if ( (cent->nextState.lerp.u.player.playerFlags & 0x200) != 0 )
    return 0;
  p_nextState = &cent->nextState;
  v17 = CG_LookingThroughNightVision((const LocalClientNum_t)this->m_localClientNum);
  if ( !BG_IsPlayerOrAgentEntity(&cent->nextState) )
    return outLaserSettings.remotePlayerHipLaserEnabled;
  CharacterInfo = CG_GetCharacterInfo(v11, p_nextState->number);
  if ( !CharacterInfo )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25621, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
      __debugbreak();
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 26052, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
      __debugbreak();
  }
  if ( !CharacterInfo->usingAnimState )
  {
    if ( PlayerASM_IsEnabled() )
    {
      Animset = BG_PlayerASM_GetAnimset(p_nextState);
      Anim = BG_PlayerASM_GetAnim(p_nextState, MOVEMENT);
      v21 = BG_PlayerASM_IsSprintAlias(Anim, Animset) == 0;
    }
    else
    {
      SuitAnimIndex = BG_AnimationMP_GetSuitAnimIndex(p_nextState);
      LegsAnimation = BG_AnimationMP_GetLegsAnimation(p_nextState);
      v21 = !BG_IsSprintAnim(LegsAnimation, SuitAnimIndex);
    }
    if ( !v21 )
      return 0;
  }
  usingNVG = CharacterInfo->usingNVG;
  IsAdsEntity = BG_IsAdsEntity(p_nextState);
  if ( usingNVG != 1 || !v17 )
  {
    if ( IsAdsEntity )
      return outLaserSettings.remotePlayerADSLaserEnabled;
    return outLaserSettings.remotePlayerHipLaserEnabled;
  }
  result = outLaserSettings.remotePlayerNVGHipLaserEnabled;
  if ( IsAdsEntity )
    return outLaserSettings.remotePlayerNVGADSLaserEnabled;
  return result;
}

/*
==============
NormalizeForMinMax
==============
*/

float __fastcall NormalizeForMinMax(double original, double min, double max)
{
  bool v9; 

  __asm
  {
    vcomiss xmm1, xmm2
    vmovaps [rsp+68h+var_18], xmm6
    vmovaps [rsp+68h+var_28], xmm7
    vmovaps [rsp+68h+var_38], xmm8
    vmovaps xmm8, xmm0
    vmovaps xmm7, xmm2
    vmovaps xmm6, xmm1
  }
  v9 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 21984, ASSERT_TYPE_ASSERT, "(min <= max)", (const char *)&queryFormat, "min <= max");
  if ( v9 )
    __debugbreak();
  __asm
  {
    vcomiss xmm8, xmm6
    vcomiss xmm8, xmm7
  }
  if ( v9 )
  {
    __asm { vmovss  xmm0, cs:__real@3f800000 }
  }
  else
  {
    __asm
    {
      vucomiss xmm6, xmm7
      vxorps  xmm0, xmm0, xmm0
    }
  }
  __asm
  {
    vmovaps xmm6, [rsp+68h+var_18]
    vmovaps xmm7, [rsp+68h+var_28]
    vmovaps xmm8, [rsp+68h+var_38]
  }
  return *(float *)&_XMM0;
}

/*
==============
CgWeaponSystem::OffhandWeaponVmFxStopAll
==============
*/
void CgWeaponSystem::OffhandWeaponVmFxStopAll(CgWeaponSystem *this)
{
  cg_t *LocalClientGlobals; 
  ParticleManager *ParticleManager; 

  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16755, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  CgWeaponSystem::OffhandWeaponVmFxValidate(this);
  if ( LocalClientGlobals->offhandWeaponVmFxInfo.currentFxHandle )
  {
    ParticleManager = ParticleManager::GetParticleManager(this->m_localClientNum);
    ParticleManager::KillSystem(ParticleManager, LocalClientGlobals->offhandWeaponVmFxInfo.currentFxHandle);
    LocalClientGlobals->offhandWeaponVmFxInfo.currentFxHandle = PARTICLE_SYSTEM_INVALID_HANDLE;
  }
}

/*
==============
CgWeaponSystem::OffhandWeaponVmFxTryStart
==============
*/
void CgWeaponSystem::OffhandWeaponVmFxTryStart(CgWeaponSystem *this)
{
  cg_t *LocalClientGlobals; 

  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16721, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( LocalClientGlobals->offhandWeaponVmFxInfo.fxRegDef.m_particleSystemDef && !LocalClientGlobals->offhandWeaponVmFxInfo.isWeaponHidden && BG_IsOffhandWeaponType(&LocalClientGlobals->offhandWeaponVmFxInfo.weapon, LocalClientGlobals->offhandWeaponVmFxInfo.currentWeaponIsAlt) )
  {
    CgWeaponSystem::OffhandWeaponVmFxValidate(this);
    if ( LocalClientGlobals->offhandWeaponVmFxInfo.currentFxHandle == PARTICLE_SYSTEM_INVALID_HANDLE )
      LocalClientGlobals->offhandWeaponVmFxInfo.currentFxHandle = CG_PlayBoltedEffect(this->m_localClientNum, &LocalClientGlobals->offhandWeaponVmFxInfo.fxRegDef, 2048, scr_const.tag_fx);
  }
}

/*
==============
CgWeaponSystem::OffhandWeaponVmFxUpdate
==============
*/
void CgWeaponSystem::OffhandWeaponVmFxUpdate(CgWeaponSystem *this, const Weapon *currWeap, bool isAlternate)
{
  DObj *ClientDObj; 
  unsigned __int8 numBones; 
  const XModel *FirstModel; 
  FxCombinedDef v13; 
  cg_t *LocalClientGlobals; 

  _R15 = currWeap;
  _RSI = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  if ( !_RSI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16775, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  ClientDObj = Com_GetClientDObj(2048, this->m_localClientNum);
  numBones = 0;
  FirstModel = NULL;
  if ( ClientDObj )
  {
    numBones = ClientDObj->numBones;
    FirstModel = DObjGetFirstModel(ClientDObj);
  }
  if ( memcmp_0(&_RSI->offhandWeaponVmFxInfo, _R15, 0x3Cui64) || isAlternate != _RSI->offhandWeaponVmFxInfo.currentWeaponIsAlt || numBones != _RSI->offhandWeaponVmFxInfo.viewModelBoneCount || FirstModel != _RSI->offhandWeaponVmFxInfo.handModel || _RSI->playerWeaponInfo.isWeaponHidden != _RSI->offhandWeaponVmFxInfo.isWeaponHidden )
  {
    CgWeaponSystem::OffhandWeaponVmFxStopAll(this);
    __asm
    {
      vmovups ymm0, ymmword ptr [r15]
      vmovups ymmword ptr [rsi+77E60h], ymm0
      vmovups xmm1, xmmword ptr [r15+20h]
      vmovups xmmword ptr [rsi+77E80h], xmm1
      vmovsd  xmm0, qword ptr [r15+30h]
      vmovsd  qword ptr [rsi+77E90h], xmm0
    }
    *(_DWORD *)&_RSI->offhandWeaponVmFxInfo.weapon.weaponCamo = *(_DWORD *)&_R15->weaponCamo;
    _RSI->offhandWeaponVmFxInfo.currentWeaponIsAlt = isAlternate;
    _RSI->offhandWeaponVmFxInfo.viewModelBoneCount = numBones;
    _RSI->offhandWeaponVmFxInfo.handModel = FirstModel;
    _RSI->offhandWeaponVmFxInfo.isWeaponHidden = _RSI->playerWeaponInfo.isWeaponHidden;
    _RSI->offhandWeaponVmFxInfo.fxRegDef.m_particleSystemDef = NULL;
    v13.particleSystemDef = BG_VMProjBodyEffect(_R15, isAlternate).particleSystemDef;
    if ( v13.particleSystemDef )
      _RSI->offhandWeaponVmFxInfo.fxRegDef.m_particleSystemDef = v13.particleSystemDef;
  }
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16721, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( LocalClientGlobals->offhandWeaponVmFxInfo.fxRegDef.m_particleSystemDef && !LocalClientGlobals->offhandWeaponVmFxInfo.isWeaponHidden && BG_IsOffhandWeaponType(&LocalClientGlobals->offhandWeaponVmFxInfo.weapon, LocalClientGlobals->offhandWeaponVmFxInfo.currentWeaponIsAlt) )
  {
    CgWeaponSystem::OffhandWeaponVmFxValidate(this);
    if ( LocalClientGlobals->offhandWeaponVmFxInfo.currentFxHandle == PARTICLE_SYSTEM_INVALID_HANDLE )
      LocalClientGlobals->offhandWeaponVmFxInfo.currentFxHandle = CG_PlayBoltedEffect(this->m_localClientNum, &LocalClientGlobals->offhandWeaponVmFxInfo.fxRegDef, 2048, scr_const.tag_fx);
  }
}

/*
==============
CgWeaponSystem::OffhandWeaponVmFxValidate
==============
*/
void CgWeaponSystem::OffhandWeaponVmFxValidate(CgWeaponSystem *this)
{
  cg_t *LocalClientGlobals; 
  ParticleSystemHandle currentFxHandle; 
  __int64 v4; 

  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16706, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  currentFxHandle = LocalClientGlobals->offhandWeaponVmFxInfo.currentFxHandle;
  if ( currentFxHandle )
  {
    v4 = ((__int64)(int)this->m_localClientNum << 12) + (currentFxHandle & 0xFFF);
    if ( g_particleSystemsGeneration[v4].__all32 != currentFxHandle || g_particleSystems[0][v4] < (ParticleSystem *)0x1000 )
      LocalClientGlobals->offhandWeaponVmFxInfo.currentFxHandle = PARTICLE_SYSTEM_INVALID_HANDLE;
  }
}

/*
==============
CgWeaponSystem::OutOfAmmoChange
==============
*/
void CgWeaponSystem::OutOfAmmoChange(CgWeaponSystem *this, bool clipOnly)
{
  bool IsGamepadEnabled; 
  LocalClientNum_t m_localClientNum; 
  bool AutoWeaponSwitchGamepad; 
  cg_t *LocalClientGlobals; 
  cg_t *v8; 
  CgWeaponMap *Instance; 
  const Weapon *CurrentWeaponForPlayer; 
  unsigned __int16 weaponIdx; 
  bool v12; 
  const PlayerEquippedWeaponState *EquippedWeaponState; 
  const WeaponDef *v14; 
  const PlayerEquippedWeaponState *v15; 
  int v16; 
  unsigned __int8 ActiveGameMode; 
  WeaponSlot CurrentWeaponSlot; 
  WeaponSlot CycleSlot; 
  int v20; 
  unsigned __int16 v21; 

  IsGamepadEnabled = CL_Input_IsGamepadEnabled(this->m_localClientNum);
  m_localClientNum = this->m_localClientNum;
  if ( IsGamepadEnabled )
    AutoWeaponSwitchGamepad = GamerProfile_GetAutoWeaponSwitchGamepad(m_localClientNum);
  else
    AutoWeaponSwitchGamepad = GamerProfile_GetAutoWeaponSwitchKeyboard(m_localClientNum);
  if ( !AutoWeaponSwitchGamepad )
    return;
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  v8 = LocalClientGlobals;
  if ( !LocalClientGlobals->nextSnap )
    return;
  if ( LocalClientGlobals->demoType )
    return;
  if ( CG_View_IsKillCamView((const LocalClientNum_t)this->m_localClientNum) )
    return;
  if ( v8->predictedPlayerState.pm_type >= 7 )
    return;
  Instance = CgWeaponMap::GetInstance((const LocalClientNum_t)this->m_localClientNum);
  if ( GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&v8->predictedPlayerState.weapCommon.weapFlags, GameModeFlagValues::ms_spValue, 0x37u) || GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&v8->predictedPlayerState.weapCommon.weapFlags, GameModeFlagValues::ms_mpValue, 0x39u) )
    return;
  CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(Instance, &v8->predictedPlayerState);
  weaponIdx = CurrentWeaponForPlayer->weaponIdx;
  v21 = CurrentWeaponForPlayer->weaponIdx;
  v12 = CurrentWeaponForPlayer->weaponIdx && BG_UsingAlternate(&v8->predictedPlayerState);
  if ( !weaponIdx && v8->weaponLatestPrimary.weaponIdx && BG_PlayerHasWeapon(Instance, &v8->predictedPlayerState, &v8->weaponLatestPrimary) )
  {
    EquippedWeaponState = BG_GetEquippedWeaponState(Instance, &v8->predictedPlayerState, &v8->weaponLatestPrimary);
    if ( EquippedWeaponState )
      LOBYTE(EquippedWeaponState) = EquippedWeaponState->inAltMode;
    CG_SelectWeapon(this->m_localClientNum, &v8->weaponLatestPrimary, (unsigned __int8)EquippedWeaponState);
    return;
  }
  v14 = BG_WeaponDef(CurrentWeaponForPlayer, v12);
  if ( !BG_IsThrowingAxe(CurrentWeaponForPlayer) || BG_IsRemoveWeaponOnEmpty(Instance, &v8->predictedPlayerState, CurrentWeaponForPlayer, v12) )
  {
    if ( v14->cancelAutoHolsterWhenEmpty || v21 && BG_Offhand_HasActiveOffhand(&v8->predictedPlayerState) && !BG_AllowWeaponSwitchWhileHoldingGrenade(CurrentWeaponForPlayer, v12) )
      return;
    if ( BG_PlayerDualWieldingWeapon(Instance, &v8->predictedPlayerState, CurrentWeaponForPlayer) && (!BG_WeaponBothClipEmpty(Instance, &v8->predictedPlayerState) || BG_WeaponWillHaveEnoughAmmoToFireAfterAutoReload(Instance, &v8->predictedPlayerState)) )
      goto LABEL_48;
    if ( v12 && BG_WeaponAmmo(Instance, &v8->predictedPlayerState, CurrentWeaponForPlayer, v12) )
      goto LABEL_34;
    if ( !CycleWeapPrimary(this->m_localClientNum, 0, 1, 1, 0, 1) )
    {
      if ( v12 )
      {
LABEL_34:
        v15 = BG_GetEquippedWeaponState(Instance, &v8->predictedPlayerState, CurrentWeaponForPlayer);
        if ( v15 )
          CG_SelectWeapon(this->m_localClientNum, CurrentWeaponForPlayer, v15->inAltMode);
        else
          CG_SelectWeapon(this->m_localClientNum, CurrentWeaponForPlayer, 0);
        goto LABEL_48;
      }
      if ( clipOnly && CycleWeapPrimary(this->m_localClientNum, 0, 1, 0, 0, 1) )
      {
        if ( v14->inventoryType == WEAPINVENTORY_ALTMODE )
          return;
        v16 = v8->time + 1500;
LABEL_52:
        v8->weaponForcedSelectTime = v16;
        return;
      }
      if ( !Dvar_GetBool_Internal_DebugName(DVARBOOL_cg_autoSwitchToHeavyWeapon, "cg_autoSwitchToHeavyWeapon") )
      {
        ActiveGameMode = Com_GameMode_GetActiveGameMode();
        if ( BG_GameInterface_GameModeIsMP((GameModeType)ActiveGameMode) )
          return;
      }
      CurrentWeaponSlot = CG_GetCurrentWeaponSlot(this->m_localClientNum);
      if ( CurrentWeaponSlot == WEAPON_SLOT_NONE )
        return;
      CycleSlot = BG_PlayerWeaponGetCycleSlot(CurrentWeaponSlot, 1);
      if ( !CG_Weapons_PlayerWeaponSlotHasWeaponsWithAmmo((const LocalClientNum_t)this->m_localClientNum, &v8->predictedPlayerState, CycleSlot) || !CycleWeapPrimary(this->m_localClientNum, 1, 1, 0, 0, 1) )
        return;
    }
LABEL_48:
    if ( v14->inventoryType == WEAPINVENTORY_ALTMODE )
      return;
    v20 = 750;
    if ( clipOnly )
      v20 = 1500;
    v16 = v8->time + v20;
    goto LABEL_52;
  }
  if ( !v12 )
    CG_SelectWeapon(this->m_localClientNum, CurrentWeaponForPlayer, 1);
}

/*
==============
PlayADSAnim
==============
*/

void __fastcall PlayADSAnim(const LocalClientNum_t localClientNum, const playerState_s *const ps, const bool isADSWeapon, double weaponPosFrac, DObj *obj, const int weaponAnim, PlayerHandIndex hand)
{
  PlayerHandIndex v15; 
  cg_t *LocalClientGlobals; 
  bool v21; 
  bool adsAltSwitchInProgress; 
  const dvar_t *v23; 
  unsigned int v27; 
  CgWeaponMap *Instance; 
  const Weapon *ViewmodelWeapon; 
  char v45; 
  bool fWeaponPosFracIn; 
  unsigned int v60; 
  BgHandler *v62; 
  int v63; 
  int v64; 
  bool v66; 
  unsigned int OtherAdsUpAnim; 
  signed int AdsDownAnim; 
  unsigned int OtherAdsDownAnim; 
  float v81; 
  unsigned int v83; 
  unsigned int v84; 
  char v85; 
  char v86; 
  char v88; 
  char v89; 
  unsigned int v99; 
  XAnimTree *v100; 
  float v121; 
  float v122; 
  float v123; 
  float v124; 
  float v125; 
  float v126; 
  float v127; 
  float v128; 
  float v129; 
  float v130; 
  float v131; 
  float v132; 
  float v133; 
  float outAdsTransOutSpeedMs; 
  float outAdsTransOutSpeedMsa; 
  float outAdsTransOutSpeedMsb; 
  float outAdsTransOutSpeedMsc; 
  float outAdsTransOutSpeedMsd; 
  float outAdsTransOutSpeedMse; 
  float outAdsTransOutSpeedMsf; 
  float outAdsTransOutSpeedMsg; 
  float outAdsTransOutSpeedMsh; 
  float v143; 
  float v144; 
  float v145; 
  float v146; 
  float v147; 
  float v148; 
  float v149; 
  float v150; 
  double notifyName; 
  double notifyType; 
  bool v153; 
  bool v154; 
  bool outIsFinishedAccel; 
  float v156; 
  float outAdsTransInSpeedMs; 
  BgHandler *pmoveHandler; 
  XAnimTree *tree; 
  char v167; 

  v15 = hand;
  __asm
  {
    vmovaps [rsp+118h+var_78], xmm10
    vmovaps xmm10, xmm3
  }
  if ( CG_GameInterface_PlayADSAnim(localClientNum, ps, isADSWeapon, *(float *)&weaponPosFrac, obj, weaponAnim, hand) )
    goto LABEL_68;
  __asm
  {
    vmovaps [rsp+118h+var_38], xmm6
    vmovaps [rsp+118h+var_48], xmm7
    vmovaps [rsp+118h+var_58], xmm8
    vmovaps [rsp+118h+var_68], xmm9
    vmovaps [rsp+118h+var_88], xmm11
    vmovaps [rsp+118h+var_98], xmm12
  }
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6826, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6827, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  tree = DObjGetTree(obj);
  if ( !tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6830, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
    __debugbreak();
  pmoveHandler = CgHandler::getHandler(localClientNum);
  if ( !pmoveHandler && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6833, ASSERT_TYPE_ASSERT, "(pmoveHandler)", (const char *)&queryFormat, "pmoveHandler") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v21 = BG_UsingAlternate(ps);
  adsAltSwitchInProgress = LocalClientGlobals->adsAltSwitchInProgress;
  v23 = DCONST_DVARBOOL_cg_viewmodelAdsUpDown;
  v153 = adsAltSwitchInProgress;
  if ( !DCONST_DVARBOOL_cg_viewmodelAdsUpDown && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmodelAdsUpDown") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v23);
  __asm { vmovss  xmm8, cs:__real@3f800000 }
  if ( !v23->current.enabled || weaponAnim == 55 || hand == WEAPON_HAND_LEFT && BG_HasLadderHand(ps) )
  {
LABEL_35:
    _ESI = 0;
    v27 = 0;
    __asm { vxorps  xmm11, xmm11, xmm11 }
    goto LABEL_36;
  }
  if ( isADSWeapon )
  {
    if ( !v153 )
    {
      Instance = CgWeaponMap::GetInstance(localClientNum);
      ViewmodelWeapon = BG_GetViewmodelWeapon(Instance, ps);
      *(double *)&_XMM0 = BG_GetADSVelocityScale(Instance, ps, ViewmodelWeapon, v21);
      __asm { vmovaps xmm6, xmm0 }
      BG_GetADSTransTimes(Instance, ps, ViewmodelWeapon, v21, &outAdsTransInSpeedMs, &v156);
      __asm
      {
        vmulss  xmm1, xmm6, cs:__real@447a0000
        vmulss  xmm4, xmm1, [rsp+118h+outAdsTransInSpeedMs]
        vmulss  xmm1, xmm6, cs:__real@c47a0000
        vmulss  xmm3, xmm1, [rsp+118h+var_B4]
      }
      _EAX = ps->weapCommon.fWeaponPosFracIn;
      _ESI = 0;
      __asm
      {
        vmovd   xmm0, eax
        vmovd   xmm1, esi
        vpcmpeqd xmm2, xmm0, xmm1
        vblendvps xmm0, xmm4, xmm3, xmm2
        vmovss  [rsp+118h+var_F8], xmm0
        vmovss  [rsp+118h+outAdsTransInSpeedMs], xmm4
        vmovss  [rsp+118h+var_B4], xmm3
      }
      *(double *)&_XMM0 = BG_GetADSFracCurrentVelocity(Instance, ps, ViewmodelWeapon, v21, v121, &outIsFinishedAccel);
      __asm
      {
        vmovss  xmm2, [rsp+118h+outAdsTransInSpeedMs]; max
        vmovss  xmm1, [rsp+118h+var_B4]; min
      }
      *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
      __asm
      {
        vmovss  xmm2, [rsp+118h+var_B4]
        vmovss  xmm3, [rsp+118h+outAdsTransInSpeedMs]
        vcomiss xmm2, xmm3
        vmovaps xmm6, xmm0
      }
      if ( !v45 )
      {
        __asm
        {
          vcvtss2sd xmm0, xmm3, xmm3
          vmovsd  qword ptr [rsp+118h+notifyType], xmm0
          vcvtss2sd xmm1, xmm2, xmm2
          vmovsd  qword ptr [rsp+118h+notifyName], xmm1
        }
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6887, ASSERT_TYPE_ASSERT, "( adsOutVelocity ) < ( adsInVelocity )", "%s < %s\n\t%g, %g", "adsOutVelocity", "adsInVelocity", notifyName, notifyType) )
          __debugbreak();
        __asm
        {
          vmovss  xmm3, [rsp+118h+outAdsTransInSpeedMs]
          vmovss  xmm2, [rsp+118h+var_B4]
        }
      }
      __asm
      {
        vsubss  xmm1, xmm6, xmm2
        vsubss  xmm0, xmm3, xmm2
        vdivss  xmm0, xmm1, xmm0; val
        vxorps  xmm1, xmm1, xmm1; min
        vmovaps xmm2, xmm8; max
        vxorps  xmm7, xmm7, xmm7
      }
      *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
      __asm
      {
        vmovaps xmm9, xmm0
        vsubss  xmm0, xmm8, xmm0; val
        vmovaps xmm2, xmm8; max
        vxorps  xmm1, xmm1, xmm1; min
      }
      *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
      fWeaponPosFracIn = ps->weapCommon.fWeaponPosFracIn;
      __asm { vmovaps xmm11, xmm0 }
      if ( fWeaponPosFracIn )
      {
        __asm { vcomiss xmm9, xmm7 }
        v60 = 1;
      }
      else
      {
        v60 = 0;
      }
      if ( !fWeaponPosFracIn )
        __asm { vcomiss xmm0, xmm7 }
      v27 = 0;
      v15 = hand;
      __asm
      {
        vmovss  dword ptr [rsp+118h+outAdsTransOutSpeedMs], xmm0
        vmovaps xmm2, xmm10; weaponPosFrac
      }
      CG_Weapon_PlayADSSettleAnim(localClientNum, ps, *(float *)&_XMM2, obj, hand, outAdsTransOutSpeedMs);
      goto LABEL_37;
    }
    goto LABEL_35;
  }
  _ESI = 0;
  __asm
  {
    vxorps  xmm10, xmm10, xmm10
    vmovaps xmm11, xmm8
  }
  v27 = 1;
LABEL_36:
  __asm
  {
    vxorps  xmm7, xmm7, xmm7
    vxorps  xmm9, xmm9, xmm9
  }
  v60 = 0;
LABEL_37:
  v62 = pmoveHandler;
  v63 = BG_ViewModelAnimExists(ps, WEAP_ANIM_ADDITIVE_ADS_UP, v15, pmoveHandler);
  v154 = v63 != 0;
  v64 = v63;
  __asm { vcmpless xmm0, xmm10, xmm7 }
  v66 = BG_ViewModelAnimExists(ps, WEAP_ANIM_ADDITIVE_ADS_DOWN, v15, v62) != 0;
  outIsFinishedAccel = v66;
  __asm
  {
    vblendvps xmm0, xmm8, xmm7, xmm0
    vmovss  [rsp+118h+var_B4], xmm0
  }
  if ( v64 )
  {
    _EAX = v66;
    __asm
    {
      vmovd   xmm0, eax
      vmovd   xmm1, esi
      vpcmpeqd xmm2, xmm0, xmm1
      vblendvps xmm12, xmm9, xmm8, xmm2
    }
  }
  else
  {
    __asm { vxorps  xmm12, xmm12, xmm12 }
  }
  _EAX = v66;
  __asm
  {
    vmovd   xmm0, eax
    vmovd   xmm1, esi
    vpcmpeqd xmm2, xmm0, xmm1
    vblendvps xmm6, xmm11, xmm7, xmm2
  }
  LODWORD(outAdsTransInSpeedMs) = BG_GetAdsUpAnim(ps, v62);
  OtherAdsUpAnim = BG_GetOtherAdsUpAnim(SLODWORD(outAdsTransInSpeedMs));
  AdsDownAnim = BG_GetAdsDownAnim(ps, v62);
  OtherAdsDownAnim = BG_GetOtherAdsDownAnim((const weapAnimFiles_t)AdsDownAnim);
  __asm
  {
    vmovss  [rsp+118h+var_E8], xmm7
    vmovss  dword ptr [rsp+118h+outAdsTransOutSpeedMs], xmm7
    vmovss  [rsp+118h+var_F8], xmm7
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, OtherAdsUpAnim, v122, outAdsTransOutSpeedMsa, v143, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+118h+var_E8], xmm7
    vmovss  dword ptr [rsp+118h+outAdsTransOutSpeedMs], xmm7
    vmovss  [rsp+118h+var_F8], xmm7
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, OtherAdsDownAnim, v123, outAdsTransOutSpeedMsb, v144, (scr_string_t)0, 0, 0, LINEAR, NULL);
  v81 = outAdsTransInSpeedMs;
  __asm
  {
    vmovss  [rsp+118h+var_E8], xmm7
    vmovss  dword ptr [rsp+118h+outAdsTransOutSpeedMs], xmm7
    vmovss  [rsp+118h+var_F8], xmm9
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, LODWORD(outAdsTransInSpeedMs), v124, outAdsTransOutSpeedMsc, v145, (scr_string_t)0, v60, 0, LINEAR, NULL);
  __asm
  {
    vmovss  [rsp+118h+var_E8], xmm7
    vmovss  dword ptr [rsp+118h+outAdsTransOutSpeedMs], xmm7
    vmovss  [rsp+118h+var_F8], xmm11
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, AdsDownAnim, v125, outAdsTransOutSpeedMsd, v146, (scr_string_t)0, v27, 0, LINEAR, NULL);
  __asm
  {
    vmovss  xmm0, [rsp+118h+var_B4]
    vmovss  [rsp+118h+var_E8], xmm7
    vmovss  dword ptr [rsp+118h+outAdsTransOutSpeedMs], xmm7
    vmovss  [rsp+118h+var_F8], xmm0
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x1Eu, v126, outAdsTransOutSpeedMse, v147, (scr_string_t)0, 0, 0, LINEAR, NULL);
  v83 = 0;
  __asm { vcomiss xmm12, xmm7 }
  if ( !(v45 | v85) )
    v83 = v60;
  __asm
  {
    vmovss  [rsp+118h+var_E8], xmm7
    vmovss  dword ptr [rsp+118h+outAdsTransOutSpeedMs], xmm7
    vmovss  [rsp+118h+var_F8], xmm12
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x1Fu, v127, outAdsTransOutSpeedMsf, v148, (scr_string_t)0, v83, 0, LINEAR, NULL);
  v84 = 0;
  __asm { vcomiss xmm6, xmm7 }
  if ( !(v45 | v85) )
    v84 = v27;
  __asm
  {
    vmovss  [rsp+118h+var_E8], xmm7
    vmovss  dword ptr [rsp+118h+outAdsTransOutSpeedMs], xmm7
    vmovss  [rsp+118h+var_F8], xmm6
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x20u, v128, outAdsTransOutSpeedMsg, v149, (scr_string_t)0, v84, 0, LINEAR, NULL);
  __asm { vucomiss xmm9, xmm7 }
  v86 = ps->skydivePlayerState.state[0];
  __asm { vmovaps xmm12, [rsp+118h+var_98] }
  if ( v85 )
  {
    v88 = 0;
    v85 = 1;
  }
  else
  {
    v88 = 1;
  }
  __asm { vucomiss xmm9, xmm7 }
  if ( !v85 )
    goto LABEL_50;
  __asm { vucomiss xmm11, xmm7 }
  if ( v85 )
    v89 = 1;
  else
LABEL_50:
    v89 = 0;
  __asm { vmovaps xmm11, [rsp+118h+var_88] }
  LOBYTE(_EAX) = v86 == 5 && (!v88 || v89);
  __asm { vmovd   xmm1, esi }
  _EAX = (unsigned __int8)_EAX;
  __asm
  {
    vmovd   xmm0, eax
    vpcmpeqd xmm2, xmm0, xmm1
    vblendvps xmm0, xmm8, xmm7, xmm2
    vmovss  [rsp+118h+outAdsTransInSpeedMs], xmm0
    vmovaps xmm0, xmm10; val
    vmovaps xmm2, xmm8; max
    vxorps  xmm1, xmm1, xmm1; min
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  v99 = LODWORD(v81);
  v100 = tree;
  __asm { vmovss  [rsp+118h+var_F8], xmm0 }
  XAnimSetTime(tree, 0, XANIM_SUBTREE_DEFAULT, v99, v129);
  __asm
  {
    vsubss  xmm9, xmm8, xmm10
    vmovaps xmm0, xmm9; val
    vmovaps xmm2, xmm8; max
    vxorps  xmm1, xmm1, xmm1; min
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm { vmovss  [rsp+118h+var_F8], xmm0 }
  XAnimSetTime(v100, 0, XANIM_SUBTREE_DEFAULT, AdsDownAnim, v130);
  if ( v154 )
  {
    if ( v86 == 5 )
    {
      __asm
      {
        vmovaps xmm2, xmm8; max
        vxorps  xmm1, xmm1, xmm1; min
        vmovaps xmm0, xmm9; val
      }
      *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
      __asm { vmovaps xmm6, xmm0 }
    }
    else
    {
      __asm { vxorps  xmm6, xmm6, xmm6 }
    }
    __asm
    {
      vmovaps xmm2, xmm8; max
      vxorps  xmm1, xmm1, xmm1; min
      vmovaps xmm0, xmm10; val
    }
    *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
    __asm { vmovss  [rsp+118h+var_F8], xmm0 }
    XAnimSetTime(v100, 0, XANIM_SUBTREE_DEFAULT, 0x1Fu, v131);
  }
  else
  {
    __asm { vmovss  xmm6, [rsp+118h+outAdsTransInSpeedMs] }
  }
  if ( outIsFinishedAccel )
  {
    if ( v86 == 5 )
    {
      __asm
      {
        vmovaps xmm2, xmm8; max
        vxorps  xmm1, xmm1, xmm1; min
        vmovaps xmm0, xmm10; val
      }
      *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
      __asm { vmovaps xmm6, xmm0 }
    }
    else
    {
      __asm { vxorps  xmm6, xmm6, xmm6 }
    }
    __asm
    {
      vmovaps xmm2, xmm8; max
      vxorps  xmm1, xmm1, xmm1; min
      vmovaps xmm0, xmm9; val
    }
    *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
    __asm { vmovss  [rsp+118h+var_F8], xmm0 }
    XAnimSetTime(v100, 0, XANIM_SUBTREE_DEFAULT, 0x20u, v132);
  }
  __asm
  {
    vmovss  [rsp+118h+var_E8], xmm8
    vmovss  dword ptr [rsp+118h+outAdsTransOutSpeedMs], xmm7
    vmovss  [rsp+118h+var_F8], xmm6
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x1B0u, v133, outAdsTransOutSpeedMsh, v150, (scr_string_t)0, 0, 0, LINEAR, NULL);
  __asm
  {
    vmovaps xmm9, [rsp+118h+var_68]
    vmovaps xmm8, [rsp+118h+var_58]
    vmovaps xmm7, [rsp+118h+var_48]
    vmovaps xmm6, [rsp+118h+var_38]
  }
LABEL_68:
  _R11 = &v167;
  __asm { vmovaps xmm10, xmmword ptr [r11-50h] }
}

/*
==============
PlayAdditiveADSAnim
==============
*/
void PlayAdditiveADSAnim(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex hand, const Weapon *weapon)
{
  CgHandler *Handler; 
  cg_t *LocalClientGlobals; 
  WeaponHand *ViewModelHand; 
  DObj *viewModelDObj; 
  XAnimTree *Tree; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float fmtc; 
  float fmtd; 
  float fmte; 
  float fmtf; 
  float fmtg; 

  _RBX = ps;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4015, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  Handler = CgHandler::getHandler(localClientNum);
  if ( BG_ViewModelAnimExists(_RBX, WEAP_ANIM_ADDITIVE_ADS_UP, hand, Handler) )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    ViewModelHand = cg_t::GetViewModelHand(LocalClientGlobals, hand);
    if ( !ViewModelHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4025, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
      __debugbreak();
    viewModelDObj = ViewModelHand->viewModelDObj;
    if ( !viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4028, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
      __debugbreak();
    Tree = DObjGetTree(viewModelDObj);
    if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4031, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
      __debugbreak();
    if ( !Tree->anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4032, ASSERT_TYPE_ASSERT, "(animTree->anims)", (const char *)&queryFormat, "animTree->anims") )
      __debugbreak();
    if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_OPEN_PARACHUTE|WEAPON_FIRING) && BG_IsSwimWeapon(weapon) )
    {
      if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_OPEN_PARACHUTE|WEAPON_FIRING) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4039, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::PLAYER_SWIMMING ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::PLAYER_SWIMMING )") )
        __debugbreak();
      __asm
      {
        vmovss  xmm0, dword ptr [rbx+10D0h]
        vmaxss  xmm1, xmm0, dword ptr [rbx+730h]
        vcomiss xmm1, cs:__real@3a83126f
        vmovaps [rsp+48h+var_18], xmm6
        vxorps  xmm6, xmm6, xmm6
        vmovss  dword ptr [rsp+48h+fmt], xmm6
      }
      XAnimSetAnimRate(Tree, 0, XANIM_SUBTREE_DEFAULT, 0xECu, fmt);
      __asm { vmovss  dword ptr [rsp+48h+fmt], xmm6 }
      XAnimSetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, 0xECu, fmta);
      __asm
      {
        vmovss  xmm6, cs:__real@3d4ccccd
        vmovaps xmm3, xmm6; blendOutTime
        vmovss  dword ptr [rsp+48h+fmt], xmm6
      }
      BlendViewModelAnimIfPlaying(viewModelDObj, WEAP_ANIM_SPRINT_OUT, WEAP_ANIM_IDLE, *(double *)&_XMM3, fmtb);
      __asm
      {
        vmovaps xmm3, xmm6; blendOutTime
        vmovss  dword ptr [rsp+48h+fmt], xmm6
      }
      BlendViewModelAnimIfPlaying(viewModelDObj, WEAP_ANIM_SPRINT_IN_CANCEL, WEAP_ANIM_IDLE, *(double *)&_XMM3, fmtc);
      __asm
      {
        vmovss  xmm6, cs:__real@3dcccccd
        vmovaps xmm3, xmm6; blendOutTime
        vmovss  dword ptr [rsp+48h+fmt], xmm6
      }
      BlendViewModelAnimIfPlaying(viewModelDObj, WEAP_ANIM_ALT_RAISE, WEAP_ANIM_IDLE, *(double *)&_XMM3, fmtd);
      __asm
      {
        vmovaps xmm3, xmm6; blendOutTime
        vmovss  dword ptr [rsp+48h+fmt], xmm6
      }
      BlendViewModelAnimIfPlaying(viewModelDObj, WEAP_ANIM_ALT_RAISE_ADS, WEAP_ANIM_IDLE, *(double *)&_XMM3, fmte);
      __asm
      {
        vmovaps xmm3, xmm6; blendOutTime
        vmovss  dword ptr [rsp+48h+fmt], xmm6
      }
      BlendViewModelAnimIfPlaying(viewModelDObj, WEAP_ANIM_ALT_RAISE_AKIMBO, WEAP_ANIM_IDLE, *(double *)&_XMM3, fmtf);
      __asm
      {
        vmovss  xmm3, cs:__real@3e4ccccd; blendOutTime
        vmovss  dword ptr [rsp+48h+fmt], xmm3
      }
      BlendViewModelAnimIfPlaying(viewModelDObj, WEAP_ANIM_FIRST_RAISE, WEAP_ANIM_IDLE, *(double *)&_XMM3, fmtg);
      __asm { vmovaps xmm6, [rsp+48h+var_18] }
    }
  }
}

/*
==============
PlayAdditiveCosmeticLoopAnim
==============
*/
void PlayAdditiveCosmeticLoopAnim(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex hand, const Weapon *weapon)
{
  __int64 v8; 
  CgWeaponMap *v9; 
  cg_t *LocalClientGlobals; 
  int v11; 
  const WeaponHand *ViewModelHand; 
  const DObj *viewModelDObj; 
  float fmt; 
  float fmta; 
  float goalTime; 
  float goalTimea; 
  float v20; 
  float v21; 

  v8 = localClientNum;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4513, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !CgWeaponMap::ms_instance[v8] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v9 = CgWeaponMap::ms_instance[v8];
  if ( !v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4517, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v8);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4519, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  v11 = BG_PlayerDualWieldingWeapon(v9, ps, weapon);
  if ( BG_IsAnimInWeaponPackages(weapon, 0, v11 == 1, ps->weapCommon.meleeComboSeqIdx, WEAP_ANIM_ADDITIVE_COSMETIC) )
  {
    __asm { vmovaps [rsp+88h+var_28], xmm6 }
    ViewModelHand = cg_t::GetViewModelHand(LocalClientGlobals, hand);
    if ( !ViewModelHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4530, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
      __debugbreak();
    viewModelDObj = ViewModelHand->viewModelDObj;
    if ( !viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4532, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
      __debugbreak();
    __asm
    {
      vmovss  xmm6, cs:__real@3f800000
      vmovss  [rsp+88h+var_58], xmm6
      vmovss  [rsp+88h+goalTime], xmm6
      vmovss  dword ptr [rsp+88h+fmt], xmm6
    }
    XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0xB1u, fmt, goalTime, v20, (scr_string_t)0, 0, 0, LINEAR, NULL);
    __asm
    {
      vmovss  [rsp+88h+var_58], xmm6
      vmovss  [rsp+88h+goalTime], xmm6
      vmovss  dword ptr [rsp+88h+fmt], xmm6
    }
    XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0xB2u, fmta, goalTimea, v21, (scr_string_t)0, 0, 0, LINEAR, NULL);
    __asm { vmovaps xmm6, [rsp+88h+var_28] }
  }
}

/*
==============
PlayAdditiveCrawlAnims
==============
*/
void PlayAdditiveCrawlAnims(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex hand, const Weapon *weapon)
{
  const dvar_t *v9; 
  __int64 v12; 
  cg_t *LocalClientGlobals; 
  WeaponHand *ViewModelHand; 
  DObj *viewModelDObj; 
  CgHandler *Handler; 
  const snapshot_t *snap; 
  const snapshot_t *nextSnap; 
  __int64 v23; 
  const dvar_t *v36; 
  const dvar_t *v39; 
  bool v47; 
  CgWeaponMap *Instance; 
  const Weapon *ViewmodelWeapon; 
  bool v56; 
  char v58; 
  bool v60; 
  float fmt; 
  float *outAdsTransOutSpeedMs; 
  float outAdsTransInSpeedMs; 
  float v72[3]; 

  v9 = DCONST_DVARINT_cg_crawlBlendTime;
  _RBP = ps;
  __asm
  {
    vmovaps [rsp+0C8h+var_48], xmm6
    vmovaps [rsp+0C8h+var_68], xmm8
  }
  v12 = hand;
  if ( !DCONST_DVARINT_cg_crawlBlendTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_crawlBlendTime") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v9);
  __asm
  {
    vmovss  xmm8, cs:__real@3a83126f
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, dword ptr [rbx+28h]
    vmulss  xmm6, xmm0, xmm8
  }
  if ( !_RBP && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4915, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( IsAdditiveCrawlEnabled(localClientNum, _RBP, (PlayerHandIndex)v12) )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    ViewModelHand = cg_t::GetViewModelHand(LocalClientGlobals, (const PlayerHandIndex)v12);
    if ( !ViewModelHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4925, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
      __debugbreak();
    viewModelDObj = ViewModelHand->viewModelDObj;
    Handler = CgHandler::getHandler(localClientNum);
    if ( BG_ShouldPlayAdditiveCrawlAnim(_RBP, (const PlayerHandIndex)v12, Handler) )
    {
      if ( BG_IsSpectating(_RBP) )
      {
        snap = LocalClientGlobals->snap;
        if ( snap )
        {
          nextSnap = LocalClientGlobals->nextSnap;
          if ( nextSnap )
          {
            if ( snap != nextSnap )
            {
              v23 = (__int64)snap->GetPlayerState(snap, (const LocalClientNum_t)localClientNum);
              _RBX = (__int64)nextSnap->GetPlayerState(nextSnap, (const LocalClientNum_t)localClientNum);
              if ( !v23 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4941, ASSERT_TYPE_ASSERT, "(prevPs)", (const char *)&queryFormat, "prevPs") )
                __debugbreak();
              if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4942, ASSERT_TYPE_ASSERT, "(nextPs)", (const char *)&queryFormat, "nextPs") )
                __debugbreak();
              __asm
              {
                vmovss  xmm0, dword ptr [rbx+30h]
                vsubss  xmm3, xmm0, dword ptr [rdi+30h]
                vmovss  xmm1, dword ptr [rbx+34h]
                vsubss  xmm2, xmm1, dword ptr [rdi+34h]
                vmovss  xmm0, dword ptr [rbx+38h]
                vsubss  xmm4, xmm0, dword ptr [rdi+38h]
                vmulss  xmm2, xmm2, xmm2
                vmulss  xmm1, xmm3, xmm3
                vmulss  xmm0, xmm4, xmm4
                vaddss  xmm3, xmm2, xmm1
                vaddss  xmm2, xmm3, xmm0
                vcomiss xmm2, xmm8
              }
            }
          }
        }
      }
      LocalClientGlobals->lastProneCrawlInputTime = LocalClientGlobals->time;
      UpdateAdditiveCrawlAnims(localClientNum, _RBP, viewModelDObj, (const PlayerHandIndex)v12);
    }
    else
    {
      __asm
      {
        vmovaps [rsp+0C8h+var_58], xmm7
        vmovaps [rsp+0C8h+var_78], xmm9
      }
      if ( GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&_RBP->eFlags, ACTIVE, 0xAu) )
      {
        v36 = DCONST_DVARINT_cg_crawlBlendOutTimeFiring;
        if ( !DCONST_DVARINT_cg_crawlBlendOutTimeFiring && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_crawlBlendOutTimeFiring") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v36);
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, dword ptr [rbx+28h]
          vmulss  xmm6, xmm0, xmm8
        }
      }
      if ( BG_PWF_UseAlternateAsOffhand(_RBP) )
      {
        if ( !Com_GameMode_SupportsFeature(WEAPON_INSPECT|WEAPON_LADDER_AIM) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4963, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::WEAPON_OFFHAND_UNDERBARREL ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::WEAPON_OFFHAND_UNDERBARREL )") )
          __debugbreak();
        v39 = DCONST_DVARINT_cg_crawlBlendOutTimeFiring;
        if ( !DCONST_DVARINT_cg_crawlBlendOutTimeFiring && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_crawlBlendOutTimeFiring") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v39);
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, dword ptr [rbx+28h]
          vmulss  xmm6, xmm0, xmm8
        }
      }
      __asm { vxorps  xmm7, xmm7, xmm7 }
      _ECX = 2;
      _EAX = _RBP->weapState[v12].weaponState - 22;
      __asm { vmovd   xmm0, eax }
      v47 = LocalClientGlobals->time < (unsigned int)LocalClientGlobals->lastProneCrawlInputTime;
      __asm
      {
        vmovd   xmm1, ecx
        vpcmpgtq xmm2, xmm0, xmm1
        vblendvps xmm6, xmm7, xmm6, xmm2
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm0, xmm0, eax
        vmulss  xmm9, xmm0, xmm8
        vcomiss xmm9, xmm6
        vmovss  [rsp+0C8h+outAdsTransInSpeedMs], xmm6
      }
      if ( v47 )
      {
        __asm { vcomiss xmm7, dword ptr [rbp+730h] }
        if ( v47 )
        {
          Instance = CgWeaponMap::GetInstance(localClientNum);
          ViewmodelWeapon = BG_GetViewmodelWeapon(Instance, _RBP);
          v56 = BG_UsingAlternate(_RBP);
          BG_GetADSTransTimes(Instance, _RBP, ViewmodelWeapon, v56, &outAdsTransInSpeedMs, v72);
          __asm
          {
            vmovss  xmm0, [rsp+0C8h+outAdsTransInSpeedMs]
            vcomiss xmm0, xmm7
          }
          if ( v47 | v58 )
          {
            __asm
            {
              vcvtss2sd xmm0, xmm0, xmm0
              vmovsd  [rsp+0C8h+outAdsTransOutSpeedMs], xmm0
            }
            v60 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4982, ASSERT_TYPE_ASSERT, "( ( adsTransInTime > 0.0f ) )", "( adsTransInTime ) = %g", *(double *)&outAdsTransOutSpeedMs);
            v47 = 0;
            if ( v60 )
              __debugbreak();
            __asm { vmovss  xmm0, [rsp+0C8h+outAdsTransInSpeedMs] }
          }
          __asm
          {
            vdivss  xmm0, xmm8, xmm0
            vminss  xmm6, xmm0, xmm6
          }
        }
      }
      else
      {
        __asm { vxorps  xmm6, xmm6, xmm6 }
      }
      __asm
      {
        vcomiss xmm9, xmm6
        vmovaps xmm9, [rsp+0C8h+var_78]
      }
      LocalClientGlobals->firstProneCrawlLoopTime = -1;
      if ( !v47 )
      {
        LocalClientGlobals->prevProneForwardAnimTime = -1.0;
        LocalClientGlobals->prevProneLeftRightAnimTime = 0.0;
      }
      __asm { vxorps  xmm1, xmm1, xmm1; right }
      UpdateAdditiveCrawlBlend(LocalClientGlobals->frametime, *(float *)&_XMM1, &LocalClientGlobals->crawlForwardBlend);
      __asm { vxorps  xmm1, xmm1, xmm1; right }
      UpdateAdditiveCrawlBlend(LocalClientGlobals->frametime, *(float *)&_XMM1, &LocalClientGlobals->crawlRightBlend);
      __asm { vmovss  dword ptr [rsp+0C8h+fmt], xmm6 }
      StopAdditiveCrawlAnims(localClientNum, _RBP, viewModelDObj, (const PlayerHandIndex)v12, fmt);
      __asm { vmovaps xmm7, [rsp+0C8h+var_58] }
    }
  }
  __asm
  {
    vmovaps xmm6, [rsp+0C8h+var_48]
    vmovaps xmm8, [rsp+0C8h+var_68]
  }
}

/*
==============
PlayAdditiveEmptyAnim
==============
*/
void PlayAdditiveEmptyAnim(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex hand, const Weapon *weapon)
{
  __int64 v7; 
  CgHandler *Handler; 
  cg_t *LocalClientGlobals; 
  WeaponHand *ViewModelHand; 
  const DObj *viewModelDObj; 
  XAnimTree *Tree; 
  bool v16; 
  const char *v17; 
  bool v18; 
  char v20; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float goalTimea; 
  float goalTime; 
  float goalTimeb; 
  float v31; 
  float v32; 
  float v33; 
  unsigned int notifyType; 

  v7 = hand;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3906, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  Handler = CgHandler::getHandler(localClientNum);
  if ( BG_ViewModelAnimExists(ps, WEAP_ANIM_ADDITIVE_EMPTY, (PlayerHandIndex)v7, Handler) )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    ViewModelHand = cg_t::GetViewModelHand(LocalClientGlobals, (const PlayerHandIndex)v7);
    if ( !ViewModelHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3914, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
      __debugbreak();
    viewModelDObj = ViewModelHand->viewModelDObj;
    if ( !viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3917, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
      __debugbreak();
    Tree = DObjGetTree(viewModelDObj);
    if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3920, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
      __debugbreak();
    if ( !Tree->anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3921, ASSERT_TYPE_ASSERT, "(animTree->anims)", (const char *)&queryFormat, "animTree->anims") )
      __debugbreak();
    if ( !Tree->anims[30].entries[0].parts )
    {
      v16 = BG_UsingAlternate(ps);
      v17 = "false";
      if ( v16 )
        v17 = "true";
      Com_PrintError(19, "PlayAdditiveEmptyAnim: missing anim parts for WEAP_ANIM_ADDITIVE_EMPTY on hand: %d, isAlternate: %s\n", (unsigned int)v7, v17);
      DevPrintAnimTree(localClientNum, Tree, ps, (unsigned int)v7, weapon);
    }
    __asm
    {
      vmovaps [rsp+98h+var_28], xmm6
      vmovaps [rsp+98h+var_38], xmm7
    }
    v18 = BG_UsingAlternate(ps);
    if ( BG_GetAmmoInClip(ps, weapon, v18, (PlayerHandIndex)v7) || (unsigned int)(ps->weapState[v7].weaponState - 18) <= 3 )
    {
      *(double *)&_XMM0 = XAnimGetGoalWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0xB3u);
      __asm
      {
        vxorps  xmm7, xmm7, xmm7
        vucomiss xmm0, xmm7
      }
      if ( !v20 )
      {
        __asm
        {
          vmovss  xmm6, cs:__real@3f800000
          vmovss  [rsp+98h+var_68], xmm6
          vmovss  [rsp+98h+goalTime], xmm7
          vmovss  dword ptr [rsp+98h+fmt], xmm7
        }
        XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0xB3u, fmta, goalTimeb, v33, (scr_string_t)0, 0, 1, LINEAR, NULL);
        notifyType = 0;
        __asm
        {
          vmovss  [rsp+98h+var_68], xmm6
          vmovss  [rsp+98h+goalTime], xmm7
        }
        goto LABEL_27;
      }
    }
    else
    {
      *(double *)&_XMM0 = XAnimGetGoalWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0xB3u);
      __asm
      {
        vmovss  xmm7, cs:__real@3f800000
        vucomiss xmm0, xmm7
      }
      if ( !v20 )
      {
        __asm
        {
          vmovss  xmm6, cs:__real@3d4ccccd
          vmovss  [rsp+98h+var_68], xmm7
          vmovss  [rsp+98h+goalTime], xmm6
          vmovss  dword ptr [rsp+98h+fmt], xmm7
        }
        XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0xB3u, fmt, goalTimea, v31, (scr_string_t)0, 0, 1, LINEAR, NULL);
        notifyType = 1;
        __asm
        {
          vmovss  [rsp+98h+var_68], xmm7
          vmovss  [rsp+98h+goalTime], xmm6
        }
LABEL_27:
        __asm { vmovss  dword ptr [rsp+98h+fmt], xmm7 }
        XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0xB4u, fmtb, goalTime, v32, (scr_string_t)0, notifyType, 1, LINEAR, NULL);
      }
    }
    __asm
    {
      vmovaps xmm6, [rsp+98h+var_28]
      vmovaps xmm7, [rsp+98h+var_38]
    }
  }
}

/*
==============
PlayAdditiveFingerPoseAnims
==============
*/
void PlayAdditiveFingerPoseAnims(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex hand, const Weapon *weapon)
{
  __int64 v15; 
  const DObj *viewModelDObj; 
  XAnimTree *Tree; 
  unsigned __int64 weaponState; 
  __int64 v21; 
  bool v22; 
  bool IsSkydiving; 
  const dvar_t *v24; 
  bool v25; 
  const dvar_t *v26; 
  const XAnimInfo *AnimInfo; 
  CgHandler *Handler; 
  char v33; 
  char v34; 
  CgHandler *v45; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float fmtc; 
  float goalTime; 
  float goalTimea; 
  float goalTimeb; 
  float goalTimec; 
  float rate; 
  float ratea; 
  float rateb; 
  float ratec; 
  float outAnimWeights[2]; 
  __int64 v72; 
  cg_t *LocalClientGlobals; 
  char v81; 
  __int64 outWeights; 

  __asm
  {
    vmovaps [rsp+128h+var_98], xmm11
    vmovaps [rsp+128h+var_A8], xmm12
  }
  v15 = hand;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( (unsigned int)v15 >= 2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1207, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v15, 2) )
    __debugbreak();
  viewModelDObj = LocalClientGlobals->m_weaponHand[v15].viewModelDObj;
  v72 = 5 * v15;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4599, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4600, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  Tree = DObjGetTree(viewModelDObj);
  if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4603, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
    __debugbreak();
  if ( !Tree->anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4604, ASSERT_TYPE_ASSERT, "(animTree->anims)", (const char *)&queryFormat, "animTree->anims") )
    __debugbreak();
  *(double *)&_XMM0 = XAnimGetGoalWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x75u);
  __asm { vmovaps xmm11, xmm0 }
  *(double *)&_XMM0 = XAnimGetGoalWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x77u);
  __asm { vmovaps xmm12, xmm0 }
  weaponState = ps->weapState[v15].weaponState;
  v22 = 0;
  if ( (unsigned int)weaponState <= 0x2F )
  {
    v21 = 0x800000001020i64;
    if ( _bittest64(&v21, weaponState) )
      v22 = 1;
  }
  IsSkydiving = BG_Skydive_IsSkydiving(ps);
  v24 = DCONST_DVARBOOL_xanim_finger_pose_disable;
  v25 = IsSkydiving;
  if ( !DCONST_DVARBOOL_xanim_finger_pose_disable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "xanim_finger_pose_disable") )
    __debugbreak();
  __asm
  {
    vmovaps [rsp+128h+var_48], xmm6
    vmovaps [rsp+128h+var_58], xmm7
  }
  Dvar_CheckFrontendServerThread(v24);
  if ( v24->current.enabled )
    goto LABEL_43;
  v26 = DCONST_DVARBOOL_cg_viewmodelFingerPoses;
  if ( !DCONST_DVARBOOL_cg_viewmodelFingerPoses && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmodelFingerPoses") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v26);
  if ( !v26->current.enabled || v22 || v25 )
  {
LABEL_43:
    __asm
    {
      vmovss  xmm7, cs:__real@3dcccccd
      vxorps  xmm6, xmm6, xmm6
      vcomiss xmm11, xmm6
      vcomiss xmm12, xmm6
    }
  }
  else
  {
    __asm
    {
      vmovaps [rsp+128h+var_68], xmm8
      vmovaps [rsp+128h+var_88], xmm10
    }
    if ( Tree->children )
    {
      outWeights = 0i64;
      *(_QWORD *)outAnimWeights = 0i64;
      AnimInfo = GetAnimInfo(Tree->children);
      BG_CalcFingerPoseWeights(AnimInfo, (float *)&outWeights, outAnimWeights);
    }
    Handler = CgHandler::getHandler(localClientNum);
    __asm
    {
      vmovss  xmm10, cs:__real@3dcccccd
      vmovss  xmm6, cs:__real@3f800000
      vxorps  xmm8, xmm8, xmm8
    }
    if ( BG_ViewModelAnimExists(ps, WEAP_ANIM_ADDITIVE_FINGER_POSE_LEFT, (PlayerHandIndex)v15, Handler) )
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rsp+128h+outWeights]; val
        vmovaps xmm2, xmm6; max
        vxorps  xmm1, xmm1, xmm1; min
      }
      *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
      __asm
      {
        vucomiss xmm11, xmm0
        vmovaps xmm7, xmm0
      }
      if ( !v34 )
      {
        __asm
        {
          vucomiss xmm11, xmm8
          vmovaps [rsp+128h+var_78], xmm9
          vmovaps xmm9, xmm10
        }
        if ( v34 )
        {
          __asm { vcomiss xmm0, cs:__real@3f7fbe77 }
          if ( !v33 )
          {
            _RCX = LocalClientGlobals;
            _EAX = 25;
            __asm { vmovd   xmm1, eax }
            _RAX = v72;
            __asm
            {
              vmovd   xmm0, dword ptr [rcx+rax*8+0C5264h]
              vpcmpeqd xmm2, xmm0, xmm1
              vmovss  xmm1, cs:L_FINGER_POSE_BLEND_OVERRIDE
              vblendvps xmm9, xmm9, xmm1, xmm2
            }
          }
        }
        __asm
        {
          vmovss  [rsp+128h+rate], xmm6
          vmovss  [rsp+128h+goalTime], xmm9
          vmovss  dword ptr [rsp+128h+fmt], xmm7
        }
        XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x75u, fmt, goalTime, rate, (scr_string_t)0, 0, 0, LINEAR, NULL);
        __asm
        {
          vmovss  [rsp+128h+rate], xmm6
          vmovss  [rsp+128h+goalTime], xmm9
          vmovss  dword ptr [rsp+128h+fmt], xmm7
        }
        XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x76u, fmta, goalTimea, ratea, (scr_string_t)0, 0, 0, LINEAR, NULL);
        __asm { vmovaps xmm9, [rsp+128h+var_78] }
      }
    }
    v45 = CgHandler::getHandler(localClientNum);
    if ( BG_ViewModelAnimExists(ps, WEAP_ANIM_ADDITIVE_FINGER_POSE_RIGHT, (PlayerHandIndex)v15, v45) )
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rsp+128h+outWeights+4]; val
        vmovaps xmm2, xmm6; max
        vxorps  xmm1, xmm1, xmm1; min
      }
      *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
      __asm
      {
        vucomiss xmm12, xmm0
        vmovaps xmm7, xmm0
      }
      if ( !v34 )
      {
        __asm
        {
          vmovss  [rsp+128h+rate], xmm6
          vmovss  [rsp+128h+goalTime], xmm10
          vmovss  dword ptr [rsp+128h+fmt], xmm0
        }
        XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x77u, fmtb, goalTimeb, rateb, (scr_string_t)0, 0, 0, LINEAR, NULL);
        __asm
        {
          vmovss  [rsp+128h+rate], xmm6
          vmovss  [rsp+128h+goalTime], xmm10
          vmovss  dword ptr [rsp+128h+fmt], xmm7
        }
        XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x78u, fmtc, goalTimec, ratec, (scr_string_t)0, 0, 0, LINEAR, NULL);
      }
    }
    __asm
    {
      vmovaps xmm8, [rsp+128h+var_68]
      vmovaps xmm10, [rsp+128h+var_88]
    }
  }
  __asm { vmovaps xmm7, [rsp+128h+var_58] }
  _R11 = &v81;
  __asm
  {
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
    vmovaps xmm6, [rsp+128h+var_48]
  }
}

/*
==============
PlayAdditiveHipIdleAnim
==============
*/
void PlayAdditiveHipIdleAnim(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex hand, const Weapon *weapon)
{
  __int64 v8; 
  CgHandler *Handler; 
  cg_t *LocalClientGlobals; 
  WeaponHand *ViewModelHand; 
  const DObj *viewModelDObj; 
  XAnimTree *Tree; 
  bool v17; 
  const char *v18; 
  const dvar_t *v19; 
  unsigned __int64 weaponState; 
  __int64 v21; 
  const dvar_t *v22; 
  cg_t *v23; 
  bool IsPlaying; 
  bool v25; 
  float fmt; 
  float fmta; 
  float goalTime; 
  float goalTimea; 
  float rate; 
  float ratea; 

  v8 = hand;
  _RBX = ps;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3962, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  Handler = CgHandler::getHandler(localClientNum);
  if ( BG_ViewModelAnimExists(_RBX, WEAP_ANIM_ADDITIVE_HIP_IDLE, (PlayerHandIndex)v8, Handler) )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    ViewModelHand = cg_t::GetViewModelHand(LocalClientGlobals, (const PlayerHandIndex)v8);
    if ( !ViewModelHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3970, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
      __debugbreak();
    viewModelDObj = ViewModelHand->viewModelDObj;
    if ( !ViewModelHand->viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3973, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
      __debugbreak();
    Tree = DObjGetTree(viewModelDObj);
    if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3976, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
      __debugbreak();
    if ( !Tree->anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3977, ASSERT_TYPE_ASSERT, "(animTree->anims)", (const char *)&queryFormat, "animTree->anims") )
      __debugbreak();
    if ( !*(_QWORD *)&Tree->anims[5].lodDistances[2] )
    {
      v17 = BG_UsingAlternate(_RBX);
      v18 = "false";
      if ( v17 )
        v18 = "true";
      Com_PrintError(19, "PlayAdditiveADSAnim: missing anim parts for WEAP_ANIM_ADDITIVE_HIP_IDLE on hand: %d, isAlternate: %s\n", (unsigned int)v8, v18);
      DevPrintAnimTree(localClientNum, Tree, _RBX, (unsigned int)v8, weapon);
    }
    if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3857, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    v19 = DCONST_DVARBOOL_cg_viewmodelActiveIdle;
    if ( !DCONST_DVARBOOL_cg_viewmodelActiveIdle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmodelActiveIdle") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v19);
    if ( !v19->current.enabled )
      goto LABEL_39;
    weaponState = _RBX->weapState[v8].weaponState;
    if ( (unsigned int)weaponState > 0x3B )
      goto LABEL_39;
    v21 = 0xC01000000000001i64;
    if ( !_bittest64(&v21, weaponState) )
      goto LABEL_39;
    v22 = DCONST_DVARBOOL_adsCover_enabled;
    if ( !DCONST_DVARBOOL_adsCover_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "adsCover_enabled") )
      __debugbreak();
    if ( (Dvar_CheckFrontendServerThread(v22), v22->current.enabled) && BG_ContextMount_CanMount(&_RBX->mountState) || (v23 = CG_GetLocalClientGlobals(localClientNum), BG_Gesture_IsPlaying(_RBX, v23->time, 0)) || CG_IsJogging(localClientNum) || (IsPlaying = BG_Demeanor_IsPlaying(_RBX)) )
    {
LABEL_39:
      v25 = 0;
    }
    else
    {
      __asm
      {
        vmovss  xmm0, cs:__real@3a83126f
        vcomiss xmm0, dword ptr [rbx+730h]
      }
      v25 = IsPlaying;
    }
    __asm
    {
      vmovaps [rsp+0B8h+var_38], xmm6
      vmovaps [rsp+0B8h+var_48], xmm7
    }
    *(double *)&_XMM0 = XAnimGetGoalWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x1Cu);
    if ( v25 )
    {
      __asm
      {
        vmovss  xmm7, cs:__real@3f800000
        vucomiss xmm0, xmm7
        vmovss  xmm6, cs:__real@3e4ccccd
        vmovss  [rsp+0B8h+rate], xmm7
        vmovss  [rsp+0B8h+goalTime], xmm6
        vmovss  dword ptr [rsp+0B8h+fmt], xmm7
      }
      XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x1Cu, fmt, goalTime, rate, (scr_string_t)0, 0, 1, LINEAR, NULL);
      __asm
      {
        vmovss  [rsp+0B8h+rate], xmm7
        vmovss  [rsp+0B8h+goalTime], xmm6
        vmovss  dword ptr [rsp+0B8h+fmt], xmm7
      }
      XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x1Du, fmta, goalTimea, ratea, (scr_string_t)0, 1u, 1, LINEAR, NULL);
    }
    else
    {
      __asm
      {
        vmovaps [rsp+0B8h+var_58], xmm8
        vxorps  xmm8, xmm8, xmm8
        vucomiss xmm0, xmm8
        vmovaps xmm8, [rsp+0B8h+var_58]
      }
    }
    __asm
    {
      vmovaps xmm6, [rsp+0B8h+var_38]
      vmovaps xmm7, [rsp+0B8h+var_48]
    }
  }
}

/*
==============
PlayAdditiveJogAnim
==============
*/
void PlayAdditiveJogAnim(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex hand, const Weapon *weapon)
{
  const dvar_t *v11; 
  cg_t *LocalClientGlobals; 
  WeaponHand *ViewModelHand; 
  const DObj *viewModelDObj; 
  const dvar_t *v16; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float goalTime; 
  float goalTimea; 
  float rate; 
  float ratea; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5143, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v11 = DCONST_DVARMPBOOL_movementAnimProto;
  if ( !DCONST_DVARMPBOOL_movementAnimProto && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "movementAnimProto") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v11);
  if ( !v11->current.enabled )
  {
    __asm { vmovaps [rsp+0B8h+var_38], xmm6 }
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    ViewModelHand = cg_t::GetViewModelHand(LocalClientGlobals, hand);
    if ( !ViewModelHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5153, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
      __debugbreak();
    viewModelDObj = ViewModelHand->viewModelDObj;
    __asm { vmovaps [rsp+0B8h+var_48], xmm7 }
    *(double *)&_XMM0 = XAnimGetGoalWeight(ViewModelHand->tree, 0, XANIM_SUBTREE_DEFAULT, 0x69u);
    __asm { vmovaps xmm6, xmm0 }
    if ( !CG_IsJogging(localClientNum) )
      goto LABEL_25;
    v16 = DCONST_DVARBOOL_cg_viewmodelAdditiveJog;
    if ( !DCONST_DVARBOOL_cg_viewmodelAdditiveJog && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmodelAdditiveJog") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v16);
    if ( v16->current.enabled )
    {
      _RBX = DCONST_DVARFLT_jogBlendTime;
      if ( !DCONST_DVARFLT_jogBlendTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "jogBlendTime") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(_RBX);
      __asm
      {
        vmovss  xmm7, dword ptr [rbx+28h]
        vmovss  xmm6, cs:__real@3f800000
        vmovss  [rsp+0B8h+rate], xmm6
        vmovss  [rsp+0B8h+goalTime], xmm7
        vmovss  dword ptr [rsp+0B8h+fmt], xmm6
      }
      XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x69u, fmt, goalTime, rate, (scr_string_t)0, 0, 0, LINEAR, NULL);
      __asm
      {
        vmovss  [rsp+0B8h+rate], xmm6
        vmovss  [rsp+0B8h+goalTime], xmm7
        vmovss  dword ptr [rsp+0B8h+fmt], xmm6
      }
      XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x6Au, fmta, goalTimea, ratea, (scr_string_t)0, 0, 0, LINEAR, NULL);
      *(double *)&_XMM0 = BG_GetBobCycleAnimTime((const int (*)[2])ps->packedBobCycle);
      __asm { vmovss  dword ptr [rsp+0B8h+fmt], xmm0 }
      XAnimSetTime(ViewModelHand->tree, 0, XANIM_SUBTREE_DEFAULT, 0x6Au, fmtb);
    }
    else
    {
LABEL_25:
      if ( !CG_IsJogging(localClientNum) )
      {
        __asm
        {
          vmovaps [rsp+0B8h+var_58], xmm8
          vxorps  xmm8, xmm8, xmm8
          vucomiss xmm6, xmm8
          vmovaps xmm8, [rsp+0B8h+var_58]
        }
      }
    }
    __asm
    {
      vmovaps xmm7, [rsp+0B8h+var_48]
      vmovaps xmm6, [rsp+0B8h+var_38]
    }
  }
}

/*
==============
PlayAdditiveJumpAnim
==============
*/
void PlayAdditiveJumpAnim(const cg_t *cgameGlob, const playerState_s *ps, PlayerHandIndex hand, DObj *obj)
{
  CgHandler *Handler; 
  int landTime; 
  int time; 
  XAnimTree *Tree; 
  bool v20; 
  GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64> *p_pm_flags; 
  bool v22; 
  bool v23; 
  char v25; 
  char v26; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float fmtc; 
  float fmtd; 
  float fmte; 
  float fmtf; 
  float fmtg; 
  float fmth; 
  float fmti; 
  float fmtj; 
  float fmtk; 
  float goalTime; 
  float goalTimea; 
  float goalTimeb; 
  float goalTimec; 
  float goalTimed; 
  float goalTimee; 
  float goalTimef; 
  float goalTimeg; 
  float goalTimeh; 
  float goalTimei; 
  float goalTimej; 
  float goalTimek; 
  float v59; 
  float v60; 
  float v61; 
  float v62; 
  float v63; 
  float v64; 
  float v65; 
  float v66; 
  float v67; 
  float v68; 
  float v69; 
  float v70; 

  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4066, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4067, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4068, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  Handler = CgHandler::getHandler(cgameGlob->localClientNum);
  if ( BG_ViewModelAnimExists(ps, WEAP_ANIM_ADDITIVE_JUMP, hand, Handler) )
  {
    landTime = cgameGlob->landTime;
    time = cgameGlob->time;
    __asm
    {
      vmovaps [rsp+0B8h+var_38], xmm7
      vmovaps [rsp+0B8h+var_58], xmm9
    }
    Tree = DObjGetTree(obj);
    if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4096, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
      __debugbreak();
    if ( !Tree->anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4097, ASSERT_TYPE_ASSERT, "(animTree->anims)", (const char *)&queryFormat, "animTree->anims") )
      __debugbreak();
    __asm
    {
      vmovss  xmm7, cs:__real@3f800000
      vsubss  xmm0, xmm7, dword ptr [rbx+730h]
      vmulss  xmm1, xmm0, cs:__real@3f4ccccd
      vaddss  xmm9, xmm1, cs:__real@3e4ccccd
    }
    if ( GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 0x14u) )
      __asm { vaddss  xmm9, xmm9, xmm7 }
    __asm { vmovaps [rsp+0B8h+var_28], xmm6 }
    v20 = Jump_JumpedThisFrame(ps, ps->serverTime);
    p_pm_flags = &ps->pm_flags;
    v22 = v20;
    v23 = GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(p_pm_flags, ACTIVE, 5u);
    if ( v22 )
    {
      __asm { vmovaps [rsp+0B8h+var_48], xmm8 }
      *(double *)&_XMM0 = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x44u);
      __asm
      {
        vxorps  xmm8, xmm8, xmm8
        vucomiss xmm0, xmm8
        vmovss  [rsp+0B8h+var_88], xmm7
        vmovss  [rsp+0B8h+goalTime], xmm8
        vmovss  dword ptr [rsp+0B8h+fmt], xmm9
      }
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x43u, fmt, goalTime, v59, (scr_string_t)0, 0, 1, LINEAR, NULL);
      __asm
      {
        vmovss  [rsp+0B8h+var_88], xmm7
        vmovss  [rsp+0B8h+goalTime], xmm8
        vmovss  dword ptr [rsp+0B8h+fmt], xmm9
      }
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x44u, fmta, goalTimea, v60, (scr_string_t)0, 0, 1, LINEAR, NULL);
      *(double *)&_XMM0 = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x47u);
      __asm { vcomiss xmm0, xmm8 }
      if ( !(v25 | v26) )
      {
        *(double *)&_XMM0 = XAnimGetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x47u);
        __asm { vcomiss xmm0, xmm7 }
        if ( v25 )
        {
          __asm
          {
            vmovss  xmm6, cs:__real@3e800000
            vmovss  [rsp+0B8h+var_88], xmm7
            vmovss  [rsp+0B8h+goalTime], xmm6
            vmovss  dword ptr [rsp+0B8h+fmt], xmm8
          }
          XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x46u, fmtb, goalTimeb, v61, (scr_string_t)0, 0, 0, LINEAR, NULL);
          __asm
          {
            vmovss  [rsp+0B8h+var_88], xmm7
            vmovss  [rsp+0B8h+goalTime], xmm6
            vmovss  dword ptr [rsp+0B8h+fmt], xmm8
          }
          XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x47u, fmtc, goalTimec, v62, (scr_string_t)0, 0, 0, LINEAR, NULL);
        }
      }
      __asm { vmovaps xmm8, [rsp+0B8h+var_48] }
      goto LABEL_24;
    }
    if ( v23 )
    {
      __asm
      {
        vmovss  xmm6, cs:__real@3d4ccccd
        vxorps  xmm7, xmm7, xmm7
        vmovss  [rsp+0B8h+var_88], xmm7
        vmovss  [rsp+0B8h+goalTime], xmm6
        vmovss  dword ptr [rsp+0B8h+fmt], xmm7
      }
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x43u, fmtd, goalTimed, v63, (scr_string_t)0, 0, 0, LINEAR, NULL);
      __asm
      {
        vmovss  [rsp+0B8h+var_88], xmm7
        vmovss  [rsp+0B8h+goalTime], xmm6
        vmovss  dword ptr [rsp+0B8h+fmt], xmm7
      }
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x44u, fmte, goalTimee, v64, (scr_string_t)0, 0, 0, LINEAR, NULL);
      __asm
      {
        vmovss  [rsp+0B8h+var_88], xmm7
        vmovss  [rsp+0B8h+goalTime], xmm6
        vmovss  dword ptr [rsp+0B8h+fmt], xmm7
      }
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x45u, fmtf, goalTimef, v65, (scr_string_t)0, 0, 0, LINEAR, NULL);
    }
    else
    {
      __asm { vxorps  xmm6, xmm6, xmm6 }
      if ( landTime == time )
        goto LABEL_33;
      *(double *)&_XMM0 = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x44u);
      __asm { vcomiss xmm0, xmm6 }
      if ( v25 | v26 )
      {
        *(double *)&_XMM0 = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x45u);
        __asm { vcomiss xmm0, xmm6 }
        if ( v25 | v26 )
          goto LABEL_24;
      }
      *(double *)&_XMM0 = XAnimGetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x44u);
      __asm { vcomiss xmm0, xmm7 }
      if ( !v25 )
      {
LABEL_33:
        __asm
        {
          vmovss  [rsp+0B8h+var_88], xmm6
          vmovss  [rsp+0B8h+goalTime], xmm6
          vmovss  dword ptr [rsp+0B8h+fmt], xmm6
        }
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x43u, fmti, goalTimei, v68, (scr_string_t)0, 0, 0, LINEAR, NULL);
        __asm
        {
          vmovss  [rsp+0B8h+var_88], xmm6
          vmovss  [rsp+0B8h+goalTime], xmm6
          vmovss  dword ptr [rsp+0B8h+fmt], xmm6
        }
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x44u, fmtj, goalTimej, v69, (scr_string_t)0, 0, 0, LINEAR, NULL);
      }
      else
      {
        __asm
        {
          vmovss  [rsp+0B8h+var_88], xmm7
          vmovss  [rsp+0B8h+goalTime], xmm6
          vmovss  dword ptr [rsp+0B8h+fmt], xmm9
        }
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x43u, fmtg, goalTimeg, v66, (scr_string_t)0, 0, 0, LINEAR, NULL);
        __asm
        {
          vmovss  [rsp+0B8h+var_88], xmm7
          vmovss  [rsp+0B8h+goalTime], xmm6
          vmovss  dword ptr [rsp+0B8h+fmt], xmm9
        }
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x44u, fmth, goalTimeh, v67, (scr_string_t)0, 0, 0, LINEAR, NULL);
      }
      __asm
      {
        vmovss  [rsp+0B8h+var_88], xmm6
        vmovss  [rsp+0B8h+goalTime], xmm6
        vmovss  dword ptr [rsp+0B8h+fmt], xmm6
      }
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x45u, fmtk, goalTimek, v70, (scr_string_t)0, 0, 0, LINEAR, NULL);
    }
LABEL_24:
    __asm
    {
      vmovaps xmm6, [rsp+0B8h+var_28]
      vmovaps xmm7, [rsp+0B8h+var_38]
      vmovaps xmm9, [rsp+0B8h+var_58]
    }
  }
}

/*
==============
PlayAdditiveJumpLandAnim
==============
*/
void PlayAdditiveJumpLandAnim(const cg_t *cgameGlob, const playerState_s *ps, PlayerHandIndex hand, DObj *obj)
{
  CgHandler *Handler; 
  XAnimTree *Tree; 
  char v40; 
  char v41; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float fmtc; 
  float fmtd; 
  float fmte; 
  float goalTime; 
  float goalTimea; 
  float goalTimeb; 
  float goalTimec; 
  float goalTimed; 
  float goalTimee; 
  float rate; 
  float ratea; 
  float rateb; 
  float ratec; 
  float rated; 
  float ratee; 
  characterAnimData_s animDistances; 

  _RBX = ps;
  _RDI = cgameGlob;
  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4215, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4216, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4217, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  Handler = CgHandler::getHandler(_RDI->localClientNum);
  if ( BG_ViewModelAnimExists(_RBX, WEAP_ANIM_ADDITIVE_JUMP_LAND, hand, Handler) )
  {
    __asm { vmovaps [rsp+118h+var_58], xmm7 }
    Tree = DObjGetTree(obj);
    if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4223, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
      __debugbreak();
    if ( !Tree->anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4224, ASSERT_TYPE_ASSERT, "(animTree->anims)", (const char *)&queryFormat, "animTree->anims") )
      __debugbreak();
    __asm { vxorps  xmm7, xmm7, xmm7 }
    if ( _RDI->landTime == _RDI->time )
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rdi+6600h]
        vmulss  xmm0, xmm0, cs:__real@bd2aaaab
      }
    }
    else
    {
      if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4177, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
        __debugbreak();
      if ( (_RDI->lastMantleflags & 0x40) != 0 || (_RBX->mantleState.flags & 0x40) == 0 )
      {
        *(double *)&_XMM0 = XAnimGetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x47u);
        __asm { vucomiss xmm0, cs:__real@3f800000 }
        if ( v41 )
        {
          __asm
          {
            vmovss  [rsp+118h+rate], xmm7
            vmovss  [rsp+118h+goalTime], xmm7
            vmovss  dword ptr [rsp+118h+fmt], xmm7
          }
          XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x46u, fmtd, goalTimed, rated, (scr_string_t)0, 0, 0, LINEAR, NULL);
          __asm
          {
            vmovss  [rsp+118h+rate], xmm7
            vmovss  [rsp+118h+goalTime], xmm7
            vmovss  dword ptr [rsp+118h+fmt], xmm7
          }
          XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x47u, fmte, goalTimee, ratee, (scr_string_t)0, 0, 0, LINEAR, NULL);
        }
        goto LABEL_38;
      }
      Mantle_UnpackAnimData(&_RBX->mantleState.compressedAnimData, &animDistances);
      if ( (_RBX->mantleState.flags & 1) != 0 )
      {
        __asm { vmovss  xmm1, [rsp+118h+animDistances.distanceZ] }
      }
      else
      {
        __asm
        {
          vmovss  xmm0, [rsp+118h+animDistances.distanceZ]
          vmulss  xmm1, xmm0, cs:__real@3e000000; fallHeight
        }
      }
      BG_GetViewDip(_RBX, *(float *)&_XMM1);
      __asm
      {
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm0, xmm0, eax
        vmulss  xmm0, xmm0, cs:__real@3d2aaaab; val
      }
    }
    __asm
    {
      vmovaps [rsp+118h+var_48], xmm6
      vmovaps [rsp+118h+var_68], xmm8
      vmovss  xmm8, cs:__real@3f800000
      vmovaps xmm2, xmm8; max
      vmovaps [rsp+118h+var_78], xmm9
      vxorps  xmm1, xmm1, xmm1; min
      vmovaps [rsp+118h+var_88], xmm10
    }
    *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
    __asm
    {
      vmulss  xmm1, xmm0, cs:__real@40000000
      vmovss  xmm0, dword ptr [rbx+730h]
      vmovss  xmm9, cs:__real@3e800000
    }
    _RBX = DCONST_DVARFLT_cg_viewmodelLandDipMin;
    __asm
    {
      vaddss  xmm2, xmm1, xmm9
      vmulss  xmm1, xmm0, cs:__real@3f000000
      vsubss  xmm10, xmm2, xmm1
    }
    if ( !DCONST_DVARFLT_cg_viewmodelLandDipMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmodelLandDipMin") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm { vmovss  xmm6, dword ptr [rbx+28h] }
    _RBX = DCONST_DVARFLT_cg_viewmodelLandDipMax;
    if ( !DCONST_DVARFLT_cg_viewmodelLandDipMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmodelLandDipMax") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm
    {
      vmovss  xmm2, dword ptr [rbx+28h]; max
      vmovaps xmm1, xmm6; min
      vmovaps xmm0, xmm10; val
    }
    *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
    __asm
    {
      vmovss  [rsp+118h+rate], xmm8
      vmovss  [rsp+118h+goalTime], xmm7
      vmovss  dword ptr [rsp+118h+fmt], xmm0
      vmovaps xmm6, xmm0
    }
    XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x46u, fmt, goalTime, rate, (scr_string_t)0, 0, 1, LINEAR, NULL);
    __asm
    {
      vmovss  [rsp+118h+rate], xmm8
      vmovss  [rsp+118h+goalTime], xmm7
      vmovss  dword ptr [rsp+118h+fmt], xmm6
    }
    XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x47u, fmta, goalTimea, ratea, (scr_string_t)0, 0, 1, LINEAR, NULL);
    *(double *)&_XMM0 = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x44u);
    __asm
    {
      vcomiss xmm0, xmm7
      vmovaps xmm10, [rsp+118h+var_88]
      vmovaps xmm6, [rsp+118h+var_48]
    }
    if ( !(v40 | v41) )
    {
      *(double *)&_XMM0 = XAnimGetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x44u);
      __asm { vcomiss xmm0, xmm8 }
      if ( v40 )
      {
        __asm
        {
          vmovss  [rsp+118h+rate], xmm8
          vmovss  [rsp+118h+goalTime], xmm9
          vmovss  dword ptr [rsp+118h+fmt], xmm7
        }
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x43u, fmtb, goalTimeb, rateb, (scr_string_t)0, 0, 0, LINEAR, NULL);
        __asm
        {
          vmovss  [rsp+118h+rate], xmm8
          vmovss  [rsp+118h+goalTime], xmm9
          vmovss  dword ptr [rsp+118h+fmt], xmm7
        }
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x44u, fmtc, goalTimec, ratec, (scr_string_t)0, 0, 0, LINEAR, NULL);
      }
    }
    __asm
    {
      vmovaps xmm8, [rsp+118h+var_68]
      vmovaps xmm9, [rsp+118h+var_78]
    }
LABEL_38:
    __asm { vmovaps xmm7, [rsp+118h+var_58] }
  }
}

/*
==============
PlayAdditiveMagazineBulletAnims
==============
*/
void PlayAdditiveMagazineBulletAnims(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex hand, const Weapon *weapon)
{
  __int64 v10; 
  __int64 v12; 
  bool v14; 
  CgWeaponMap *v15; 
  int v16; 
  cg_t *LocalClientGlobals; 
  const WeaponHand *ViewModelHand; 
  const DObj *viewModelDObj; 
  cg_t *v20; 
  int v23; 
  CgHandler *Handler; 
  char v26; 
  const dvar_t *v27; 
  char v38; 
  char v39; 
  float fmt; 
  float fmta; 
  float fmtb; 
  double bIsAlternate; 
  float bIsAlternatea; 
  float bIsAlternateb; 
  double handIndex; 
  float handIndexa; 
  float handIndexb; 
  BgHandler *pmoveHandler; 
  bool v68; 
  signed int animFile; 
  int weaponDelay; 
  XAnimTree *tree; 
  AmmoStore result; 
  AmmoStore r_clipIndex; 

  v10 = hand;
  v12 = localClientNum;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4420, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v68 = BG_UsingAlternate(ps);
  v14 = v68;
  if ( !CgWeaponMap::ms_instance[v12] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v15 = CgWeaponMap::ms_instance[v12];
  if ( !v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4425, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  v16 = BG_PlayerDualWieldingWeapon(v15, ps, weapon);
  if ( BG_IsAnimInWeaponPackages(weapon, v68, v16 == 1, ps->weapCommon.meleeComboSeqIdx, WEAP_ANIM_ADDITIVE_MAGAZINE_BULLETS) )
  {
    __asm
    {
      vmovaps [rsp+198h+var_58], xmm6
      vmovaps [rsp+198h+var_68], xmm7
      vmovaps [rsp+198h+var_78], xmm8
    }
    LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v12);
    if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4434, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
      __debugbreak();
    ViewModelHand = cg_t::GetViewModelHand(LocalClientGlobals, (const PlayerHandIndex)v10);
    if ( !ViewModelHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4436, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
      __debugbreak();
    viewModelDObj = ViewModelHand->viewModelDObj;
    if ( !viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4438, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
      __debugbreak();
    tree = DObjGetTree(viewModelDObj);
    if ( !tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4440, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
      __debugbreak();
    v20 = CG_GetLocalClientGlobals((const LocalClientNum_t)v12);
    if ( !v20 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4409, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
      __debugbreak();
    __asm
    {
      vmovss  xmm7, cs:__real@3f800000
      vmovaps [rsp+198h+var_88], xmm9
      vxorps  xmm8, xmm8, xmm8
    }
    v23 = v20->predictedPlayerState.weapState[v10].weapAnim & 0xFFFFFF7F;
    if ( (unsigned int)(v23 - 16) <= 5 )
    {
      Handler = CgHandler::getHandler((LocalClientNum_t)v12);
      animFile = BG_MapWeaponAnimStateToAnimIndex(v15, ps, v23, 0, weapon, v68, (PlayerHandIndex)v10, Handler);
      *(double *)&_XMM0 = XAnimGetNotetrackTime(tree->anims, animFile, scr_const.show_full_magazine);
      __asm
      {
        vucomiss xmm0, cs:__real@bf800000
        vmovaps xmm9, xmm0
      }
      if ( v39 )
        v26 = 0;
      else
        v26 = 1;
      v27 = DVARBOOL_killswitch_show_full_magazine_suppress_ammo_add_enabled;
      weaponDelay = ps->weapState[v10].weaponDelay;
      if ( !DVARBOOL_killswitch_show_full_magazine_suppress_ammo_add_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_show_full_magazine_suppress_ammo_add_enabled") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v27);
      if ( !v26 )
        goto LABEL_43;
      if ( v27->current.enabled )
      {
        *(double *)&_XMM0 = CG_GetWeaponAnimTime((LocalClientNum_t)v12, (PlayerHandIndex)v10, (weapAnimFiles_t)animFile);
        v14 = v68;
        __asm
        {
          vmovaps xmm6, xmm0
          vcomiss xmm9, xmm6
        }
        BG_GetClipSize(ps, weapon, v68);
        if ( v38 | v39 )
          BG_WeaponAmmo(v15, ps, weapon, v68);
        __asm
        {
          vxorps  xmm1, xmm1, xmm1
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm1, xmm1, eax
          vcvtsi2ss xmm0, xmm0, esi
        }
LABEL_41:
        __asm
        {
          vdivss  xmm2, xmm1, xmm0
          vsubss  xmm0, xmm7, xmm2; val
          vmovaps xmm2, xmm7; max
          vxorps  xmm1, xmm1, xmm1; min
        }
        *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
        __asm
        {
          vucomiss xmm0, cs:__real@bf800000
          vmovaps xmm6, xmm0
        }
        if ( !v39 )
          goto LABEL_45;
        goto LABEL_44;
      }
      if ( weaponDelay > 0 )
      {
        *(double *)&_XMM0 = CG_GetWeaponAnimTime((LocalClientNum_t)v12, (PlayerHandIndex)v10, (weapAnimFiles_t)animFile);
        __asm { vcomiss xmm0, xmm9 }
        v14 = v68;
        if ( !(v38 | v39) )
        {
          BG_WeaponAmmo(v15, ps, weapon, v68);
          BG_GetClipSize(ps, weapon, v68);
          __asm
          {
            vxorps  xmm1, xmm1, xmm1
            vxorps  xmm0, xmm0, xmm0
            vcvtsi2ss xmm1, xmm1, ebx
            vcvtsi2ss xmm0, xmm0, eax
          }
          goto LABEL_41;
        }
      }
      else
      {
LABEL_43:
        v14 = v68;
      }
    }
LABEL_44:
    BG_GetClipSize(ps, weapon, v14);
    _RAX = BG_AmmoStoreForWeapon(&result, weapon, v14);
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovups ymmword ptr [rsp+198h+r_clipIndex.weapon.weaponIdx], ymm0
      vmovups ymm1, ymmword ptr [rax+20h]
      vmovups ymmword ptr [rsp+198h+r_clipIndex.weapon.attachmentVariationIndices+5], ymm1
    }
    BG_GetClipAmmoPtrConst(ps, &r_clipIndex);
    __asm
    {
      vxorps  xmm1, xmm1, xmm1
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm1, xmm1, eax
      vcvtsi2ss xmm0, xmm0, ebx
      vdivss  xmm2, xmm1, xmm0
      vsubss  xmm0, xmm7, xmm2; val
      vmovaps xmm2, xmm7; max
      vxorps  xmm1, xmm1, xmm1; min
    }
    *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
    __asm { vmovaps xmm6, xmm0 }
LABEL_45:
    __asm
    {
      vcomiss xmm6, xmm8
      vmovaps xmm9, [rsp+198h+var_88]
    }
    if ( v38 )
      goto LABEL_47;
    __asm { vcomiss xmm6, xmm7 }
    if ( !(v38 | v39) )
    {
LABEL_47:
      __asm
      {
        vmovsd  xmm1, cs:__real@3ff0000000000000
        vmovsd  [rsp+198h+pmoveHandler], xmm1
        vxorpd  xmm2, xmm2, xmm2
        vmovsd  qword ptr [rsp+198h+handIndex], xmm2
        vcvtss2sd xmm3, xmm6, xmm6
        vmovsd  qword ptr [rsp+198h+bIsAlternate], xmm3
      }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4504, ASSERT_TYPE_ASSERT, "( 0.0f ) <= ( magazineAnimTime ) && ( magazineAnimTime ) <= ( 1.0f )", "magazineAnimTime not in [0.0f, 1.0f]\n\t%g not in [%g, %g]", bIsAlternate, handIndex, *(double *)&pmoveHandler) )
        __debugbreak();
    }
    __asm
    {
      vmovss  [rsp+198h+handIndex], xmm8
      vmovss  dword ptr [rsp+198h+bIsAlternate], xmm8
      vmovss  dword ptr [rsp+198h+fmt], xmm7
    }
    XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0xA8u, fmt, bIsAlternatea, handIndexa, (scr_string_t)0, 0, 0, LINEAR, NULL);
    __asm
    {
      vmovss  [rsp+198h+handIndex], xmm8
      vmovss  dword ptr [rsp+198h+bIsAlternate], xmm8
      vmovss  dword ptr [rsp+198h+fmt], xmm7
    }
    XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0xA9u, fmta, bIsAlternateb, handIndexb, (scr_string_t)0, 0, 0, LINEAR, NULL);
    __asm { vmovss  dword ptr [rsp+198h+fmt], xmm6 }
    XAnimSetTime(tree, 0, XANIM_SUBTREE_DEFAULT, 0xA9u, fmtb);
    __asm
    {
      vmovaps xmm8, [rsp+198h+var_78]
      vmovaps xmm7, [rsp+198h+var_68]
      vmovaps xmm6, [rsp+198h+var_58]
    }
  }
}

/*
==============
PlayAdditiveProneDropAnim
==============
*/
void PlayAdditiveProneDropAnim(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex hand, const Weapon *weapon)
{
  const dvar_t *v10; 
  CgHandler *Handler; 
  cg_t *LocalClientGlobals; 
  const WeaponHand *ViewModelHand; 
  const DObj *viewModelDObj; 
  const XAnimTree *Tree; 
  const SuitDef *SuitDef; 
  CgWeaponMap *Instance; 
  int ViewHeightLerpTime; 
  int v19; 
  char v23; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float fmtc; 
  float goalTime; 
  float goalTimea; 
  float goalTimeb; 
  float goalTimec; 
  float rate; 
  float ratea; 
  float rateb; 
  float ratec; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4300, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v10 = DCONST_DVARBOOL_cg_viewmodelAnimatedCrawl;
  if ( !DCONST_DVARBOOL_cg_viewmodelAnimatedCrawl && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmodelAnimatedCrawl") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v10);
  if ( v10->current.enabled )
  {
    Handler = CgHandler::getHandler(localClientNum);
    if ( BG_ViewModelAnimExists(ps, WEAP_ANIM_ADDITIVE_PRONE_DROP, hand, Handler) )
    {
      LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
      ViewModelHand = cg_t::GetViewModelHand(LocalClientGlobals, hand);
      if ( !ViewModelHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4312, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
        __debugbreak();
      viewModelDObj = ViewModelHand->viewModelDObj;
      if ( !viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4315, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
        __debugbreak();
      Tree = DObjGetTree(viewModelDObj);
      SuitDef = BG_GetSuitDef(ps->suitIndex);
      if ( !SuitDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4319, ASSERT_TYPE_ASSERT, "(suitDef)", (const char *)&queryFormat, "suitDef") )
        __debugbreak();
      __asm { vmovaps [rsp+98h+var_28], xmm6 }
      Instance = CgWeaponMap::GetInstance(localClientNum);
      if ( ps->viewHeightLerpTarget != BG_Suit_GetProneViewHeight(SuitDef) || BG_UsingSniperScope(Instance, ps) || ps->viewHeightLerpTime <= 0 || (ViewHeightLerpTime = PM_GetViewHeightLerpTime(ps, ps->viewHeightLerpTarget, 1), v19 = ps->viewHeightLerpTime, 100 * (ps->serverTime - LocalClientGlobals->frametime - v19) / ViewHeightLerpTime >= 45) || 100 * (ps->serverTime - v19) / ViewHeightLerpTime < 45 )
      {
        *(double *)&_XMM0 = XAnimGetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x74u);
        __asm { vucomiss xmm0, cs:__real@3f800000 }
        if ( v23 )
        {
          __asm
          {
            vxorps  xmm6, xmm6, xmm6
            vmovss  [rsp+98h+rate], xmm6
            vmovss  [rsp+98h+goalTime], xmm6
            vmovss  dword ptr [rsp+98h+fmt], xmm6
          }
          XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x73u, fmtb, goalTimeb, rateb, (scr_string_t)0, 0, 1, LINEAR, NULL);
          __asm
          {
            vmovss  [rsp+98h+rate], xmm6
            vmovss  [rsp+98h+goalTime], xmm6
            vmovss  dword ptr [rsp+98h+fmt], xmm6
          }
          XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x74u, fmtc, goalTimec, ratec, (scr_string_t)0, 0, 1, LINEAR, NULL);
        }
      }
      else
      {
        __asm
        {
          vmovaps [rsp+98h+var_38], xmm7
          vmovss  xmm7, cs:__real@3f800000
          vmovss  [rsp+98h+rate], xmm7
          vxorps  xmm6, xmm6, xmm6
          vmovss  [rsp+98h+goalTime], xmm6
          vmovss  dword ptr [rsp+98h+fmt], xmm7
        }
        XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x73u, fmt, goalTime, rate, (scr_string_t)0, 0, 1, LINEAR, NULL);
        __asm
        {
          vmovss  [rsp+98h+rate], xmm7
          vmovss  [rsp+98h+goalTime], xmm6
          vmovss  dword ptr [rsp+98h+fmt], xmm7
        }
        XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x74u, fmta, goalTimea, ratea, (scr_string_t)0, 0, 1, LINEAR, NULL);
        __asm { vmovaps xmm7, [rsp+98h+var_38] }
      }
      __asm { vmovaps xmm6, [rsp+98h+var_28] }
    }
  }
}

/*
==============
PlayAdditiveSwimDragAnims
==============
*/
void PlayAdditiveSwimDragAnims(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex hand, const Weapon *weapon)
{
  const dvar_t *v9; 
  cg_t *LocalClientGlobals; 
  WeaponHand *ViewModelHand; 
  DObj *viewModelDObj; 
  weapAnimFiles_t *v13; 
  CgHandler *Handler; 
  char v15; 
  float dragWeights[2]; 
  __int64 v19; 
  vec3_t right[3]; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3556, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v9 = DCONST_DVARBOOL_player_swimDragHandEnabled;
  if ( !DCONST_DVARBOOL_player_swimDragHandEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_swimDragHandEnabled") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v9);
  if ( v9->current.enabled )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    ViewModelHand = cg_t::GetViewModelHand(LocalClientGlobals, hand);
    if ( !ViewModelHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3563, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
      __debugbreak();
    viewModelDObj = ViewModelHand->viewModelDObj;
    if ( !ViewModelHand->viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3566, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
      __debugbreak();
    if ( LocalClientGlobals->frametime )
    {
      if ( BG_UsingAlternate(ps) && BG_IsSwimWeapon(weapon) )
      {
        if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_OPEN_PARACHUTE|WEAPON_FIRING) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3577, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::PLAYER_SWIMMING ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::PLAYER_SWIMMING )") )
          __debugbreak();
        if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3267, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
          __debugbreak();
        v13 = (weapAnimFiles_t *)s_dragAnims;
        while ( 1 )
        {
          Handler = CgHandler::getHandler(localClientNum);
          if ( BG_ViewModelAnimExists(ps, *v13, hand, Handler) )
            break;
          if ( (__int64)++v13 >= (__int64)&unk_1442D8DA8 )
            return;
        }
        AngleVectors(&ps->viewangles, &right[2], right, &right[1]);
        _R8 = &LocalClientGlobals->lastDragPosition;
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vucomiss xmm0, dword ptr [r8]
        }
        if ( !v15 )
          goto LABEL_31;
        __asm { vucomiss xmm0, dword ptr [r8+4] }
        if ( !v15 )
          goto LABEL_31;
        __asm { vucomiss xmm0, dword ptr [r8+8] }
        if ( v15 )
        {
          CalcSwimDragLookAtPosition(ps, (const vec3_t (*)[3])right, _R8);
          *(_QWORD *)dragWeights = 0i64;
          v19 = 0i64;
          SetSwimDragGoalWeights(localClientNum, viewModelDObj, ps, hand, weapon, dragWeights);
        }
        else
        {
LABEL_31:
          CalcSwimDragFriction(viewModelDObj, localClientNum, ps, (const vec3_t (*)[3])right);
          ClampDragPositionToLookAtPlane(localClientNum, ps, (const vec3_t (*)[3])right);
          CalcSwimDragWeights(viewModelDObj, localClientNum, ps, (const vec3_t (*)[3])right, dragWeights);
          SetSwimDragGoalWeights(localClientNum, viewModelDObj, ps, hand, weapon, dragWeights);
        }
      }
      else
      {
        *(_QWORD *)LocalClientGlobals->lastDragPosition.v = 0i64;
        LocalClientGlobals->lastDragPosition.v[2] = 0.0;
      }
    }
  }
}

/*
==============
PlayAdditiveWalkAnim
==============
*/
void PlayAdditiveWalkAnim(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex hand, const Weapon *weapon)
{
  const dvar_t *v11; 
  __int64 v13; 
  WeaponHand *ViewModelHand; 
  XAnimTree *Tree; 
  unsigned int v18; 
  weapAnimFiles_t v19; 
  CgHandler *Handler; 
  const dvar_t *v25; 
  const dvar_t *v26; 
  char v27; 
  bool v28; 
  CgWeaponMap *Instance; 
  bool v51; 
  CgHandler *v52; 
  weapAnimFiles_t v60; 
  float *v68; 
  unsigned int i; 
  weapAnimFiles_t v72; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float fmtc; 
  float fmtd; 
  float fmte; 
  float fmtf; 
  float fmtg; 
  float goalTime; 
  float goalTimea; 
  float goalTimeb; 
  float goalTimec; 
  float goalTimed; 
  float goalTimee; 
  float goalTimef; 
  float rate; 
  float ratea; 
  float rateb; 
  float ratec; 
  float rated; 
  float ratee; 
  float ratef; 
  weapAnimFiles_t outWalkAnimGroup; 
  float outBlendWeights[6]; 
  bool outAnimMissing; 

  v11 = DCONST_DVARMPBOOL_movementAnimProto;
  _RBP = ps;
  v13 = localClientNum;
  if ( !DCONST_DVARMPBOOL_movementAnimProto && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "movementAnimProto") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v11);
  if ( !v11->current.enabled )
  {
    __asm
    {
      vmovaps [rsp+128h+var_48], xmm6
      vmovaps [rsp+128h+var_58], xmm7
      vmovaps [rsp+128h+var_68], xmm8
      vmovaps [rsp+128h+var_78], xmm9
    }
    _RSI = CG_GetLocalClientGlobals((const LocalClientNum_t)v13);
    ViewModelHand = cg_t::GetViewModelHand(_RSI, hand);
    if ( !ViewModelHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5031, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
      __debugbreak();
    Tree = DObjGetTree(ViewModelHand->viewModelDObj);
    if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5034, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
      __debugbreak();
    if ( !Tree->anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5035, ASSERT_TYPE_ASSERT, "(animTree->anims)", (const char *)&queryFormat, "animTree->anims") )
      __debugbreak();
    v18 = 73;
    v19 = WEAP_ANIM_ADDITIVE_WALK_START;
    if ( BG_CanSprintFire(_RBP) && GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&_RBP->pm_flags, ACTIVE, 0x14u) )
      v19 = WEAP_ANIM_ADDITIVE_GUNGHO_SPRINT;
    if ( Com_GameMode_SupportsFeature(WEAPON_SPRINT_DROP|0x80) && BG_Gesture_GetWalkAnimOverride(_RBP, &outWalkAnimGroup, NULL) )
      v19 = outWalkAnimGroup;
    __asm
    {
      vmovss  xmm9, cs:__real@3e19999a
      vmovss  xmm7, cs:__real@3f800000
    }
    _RSI->prevWalkGroup = v19;
    __asm
    {
      vxorps  xmm6, xmm6, xmm6
      vxorps  xmm8, xmm8, xmm8
    }
    do
    {
      if ( v18 - (v18 - 73) % 5 != v19 )
      {
        *(double *)&_XMM0 = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, v18);
        __asm { vcomiss xmm0, xmm6 }
        if ( !(v27 | v28) )
        {
          __asm
          {
            vmovss  [rsp+128h+rate], xmm7
            vmovss  [rsp+128h+goalTime], xmm9
            vmovss  dword ptr [rsp+128h+fmt], xmm6
            vmovaps xmm8, xmm9
          }
          XAnimSetGoalWeight(ViewModelHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, v18, fmt, goalTime, rate, (scr_string_t)0, 0, 0, LINEAR, NULL);
        }
      }
      ++v18;
    }
    while ( v18 < 0x5D );
    Handler = CgHandler::getHandler((LocalClientNum_t)v13);
    if ( !CgWeaponMap::ms_instance[v13] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
      __debugbreak();
    if ( !BG_ShouldPlayAdditiveWalkAnim(CgWeaponMap::ms_instance[v13], _RBP, Handler) )
      goto LABEL_55;
    v25 = DCONST_DVARBOOL_cg_viewmodelAdditiveWalk;
    if ( !DCONST_DVARBOOL_cg_viewmodelAdditiveWalk && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmodelAdditiveWalk") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v25);
    if ( v25->current.enabled )
    {
      v26 = DCONST_DVARBOOL_adsReloadUseAdditiveWalk;
      __asm
      {
        vmovaps [rsp+128h+var_88], xmm10
        vmovaps [rsp+128h+var_98], xmm11
      }
      if ( !DCONST_DVARBOOL_adsReloadUseAdditiveWalk && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "adsReloadUseAdditiveWalk") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v26);
      v27 = 0;
      v28 = !v26->current.enabled;
      if ( v26->current.enabled )
      {
        Instance = CgWeaponMap::GetInstance((const LocalClientNum_t)v13);
        BG_WeaponADSFractionAffectedByReload(Instance, _RBP);
      }
      else
      {
        __asm { vmovss  xmm0, dword ptr [rbp+730h] }
      }
      __asm
      {
        vmovss  xmm2, cs:ADDITIVE_WALK_STOP_ADS_FRACTION
        vmovss  xmm10, cs:__real@3a83126f
        vcomiss xmm2, xmm10
      }
      if ( v27 | v28 )
      {
        __asm { vmovaps xmm9, xmm6 }
      }
      else
      {
        __asm
        {
          vsubss  xmm0, xmm2, xmm0
          vminss  xmm1, xmm0, xmm2
          vdivss  xmm2, xmm1, xmm2
          vmaxss  xmm0, xmm2, xmm6
          vminss  xmm9, xmm0, xmm7
        }
      }
      _ER13 = 0;
      __asm { vmovd   xmm1, r13d }
      _EAX = GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&_RBP->pm_flags, ACTIVE, 1u);
      __asm
      {
        vmovd   xmm0, eax
        vpcmpeqd xmm2, xmm0, xmm1
        vmovss  xmm1, cs:__real@3f000000
        vblendvps xmm0, xmm1, xmm7, xmm2
        vmovss  xmm1, dword ptr [rsi+1829Ch]; prevYaw
        vmulss  xmm11, xmm0, xmm9
        vmovss  xmm0, dword ptr [rbp+1DCh]; yaw
      }
      *(double *)&_XMM0 = BG_CalcViewspeedBobRatio(*(const float *)&_XMM0, *(const float *)&_XMM1, _RBP, _RSI->frametime);
      __asm
      {
        vcomiss xmm0, cs:ADDITIVE_WALK_MINIMUM_TURN_RATIO
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm0, xmm0, dword ptr [rsi+65E4h]
        vmulss  xmm10, xmm0, xmm10
      }
      _RSI->weaponAdditiveWalkPrevYaw = _RBP->viewangles.v[1];
      v51 = !v27;
      v52 = CgHandler::getHandler((LocalClientNum_t)v13);
      if ( !BG_PlayerIsLinkedOrNotMoving(_RBP, _RSI->time, v52) || v51 )
      {
        __asm
        {
          vdivss  xmm0, xmm10, cs:ADDITIVE_WALK_BLEND_IN_TIME
          vaddss  xmm0, xmm0, dword ptr [rsi+18298h]; val
        }
      }
      else
      {
        __asm
        {
          vdivss  xmm1, xmm10, cs:ADDITIVE_WALK_BLEND_OUT_TIME
          vmovss  xmm0, dword ptr [rsi+18298h]
          vsubss  xmm0, xmm0, xmm1
        }
      }
      __asm
      {
        vmovaps xmm2, xmm7; max
        vmovaps xmm1, xmm6; min
        vmovss  dword ptr [rsi+18298h], xmm0
      }
      *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
      __asm
      {
        vucomiss xmm0, xmm6
        vmovaps xmm10, [rsp+128h+var_88]
        vmovss  dword ptr [rsi+18298h], xmm0
      }
      if ( v28 )
      {
        __asm
        {
          vmovss  [rsp+128h+rate], xmm7
          vmovss  [rsp+128h+goalTime], xmm8
          vmovss  dword ptr [rsp+128h+fmt], xmm6
        }
        XAnimSetGoalWeight(ViewModelHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x48u, fmta, goalTimea, ratea, (scr_string_t)0, 0, 0, LINEAR, NULL);
        v60 = v19 + 5;
        if ( !__OFSUB__(v19, v19 + 5) )
        {
          do
          {
            __asm
            {
              vmovss  [rsp+128h+rate], xmm7
              vmovss  [rsp+128h+goalTime], xmm8
              vmovss  dword ptr [rsp+128h+fmt], xmm6
            }
            XAnimSetGoalWeight(ViewModelHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, v19++, fmtb, goalTimeb, rateb, (scr_string_t)0, 0, 0, LINEAR, NULL);
          }
          while ( v19 < v60 );
        }
      }
      else
      {
        *(double *)&_XMM0 = BG_GetBobCycleAnimTime((const int (*)[2])_RBP->packedBobCycle);
        __asm { vmovaps xmm6, xmm0 }
        CG_CalcSlopeAnimBlendWeights(_RSI, v19, outBlendWeights, &outAnimMissing);
        __asm
        {
          vmulss  xmm1, xmm11, dword ptr [rsi+18298h]
          vmovss  [rsp+128h+rate], xmm7
          vmovss  [rsp+128h+goalTime], xmm8
          vmovss  dword ptr [rsp+128h+fmt], xmm1
        }
        XAnimSetGoalWeight(ViewModelHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x48u, fmtc, goalTimec, ratec, (scr_string_t)0, 0, 0, LINEAR, NULL);
        v68 = outBlendWeights;
        for ( i = 0; i < 5; ++i )
        {
          __asm
          {
            vmulss  xmm0, xmm9, dword ptr [rbp+0]
            vmovss  [rsp+128h+rate], xmm7
            vmovss  [rsp+128h+goalTime], xmm8
            vmovss  dword ptr [rsp+128h+fmt], xmm0
          }
          XAnimSetGoalWeight(ViewModelHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, i + v19, fmtd, goalTimed, rated, (scr_string_t)0, 0, 0, LINEAR, NULL);
          __asm { vmovss  dword ptr [rsp+128h+fmt], xmm6 }
          XAnimSetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, i + v19, fmte);
          ++v68;
        }
      }
      __asm { vmovaps xmm11, [rsp+128h+var_98] }
    }
    else
    {
LABEL_55:
      __asm
      {
        vmovss  xmm8, cs:__real@3d4ccccd
        vmovss  [rsp+128h+rate], xmm7
        vmovss  [rsp+128h+goalTime], xmm8
        vmovss  dword ptr [rsp+128h+fmt], xmm6
      }
      XAnimSetGoalWeight(ViewModelHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x48u, fmtf, goalTimee, ratee, (scr_string_t)0, 0, 0, LINEAR, NULL);
      v72 = v19 + 5;
      if ( !__OFSUB__(v19, v19 + 5) )
      {
        do
        {
          __asm
          {
            vmovss  [rsp+128h+rate], xmm7
            vmovss  [rsp+128h+goalTime], xmm8
            vmovss  dword ptr [rsp+128h+fmt], xmm6
          }
          XAnimSetGoalWeight(ViewModelHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, v19++, fmtg, goalTimef, ratef, (scr_string_t)0, 0, 0, LINEAR, NULL);
        }
        while ( v19 < v72 );
      }
      _RSI->weaponAdditiveWalkBlendRate = 0.0;
    }
    __asm
    {
      vmovaps xmm8, [rsp+128h+var_68]
      vmovaps xmm7, [rsp+128h+var_58]
      vmovaps xmm6, [rsp+128h+var_48]
      vmovaps xmm9, [rsp+128h+var_78]
    }
  }
}

/*
==============
PlayAdvancedSwayAnim
==============
*/
void PlayAdvancedSwayAnim(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex hand, const Weapon *weapon)
{
  __int64 v8; 
  cg_t *LocalClientGlobals; 
  DObj *viewModelDObj; 
  const XAnimTree *Tree; 
  char v17; 
  char v18; 
  float fmt; 
  __int64 goalTime; 
  float goalTimea; 
  __int64 rate; 
  float ratea; 
  vec2_t outBsParams; 
  char v30; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-18h], xmm6
    vmovaps xmmword ptr [rax-28h], xmm7
  }
  v8 = hand;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4541, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( (unsigned int)v8 >= 2 )
  {
    LODWORD(goalTime) = v8;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4542, ASSERT_TYPE_ASSERT, "(unsigned)( hand ) < (unsigned)( NUM_WEAPON_HANDS )", "hand doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", goalTime, 2) )
      __debugbreak();
  }
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( (unsigned int)v8 >= 2 )
  {
    LODWORD(rate) = 2;
    LODWORD(goalTime) = v8;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1207, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", goalTime, rate) )
      __debugbreak();
  }
  viewModelDObj = LocalClientGlobals->m_weaponHand[v8].viewModelDObj;
  if ( !viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4548, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  AdvancedSwayState::GetBlendspaceParams(&LocalClientGlobals->vmMotionState, &outBsParams);
  __asm { vmovss  xmm2, dword ptr [rsp+98h+outBsParams]; value }
  XAnimSetFloatGameParameterByIndex(viewModelDObj, 8u, *(float *)&_XMM2);
  __asm { vmovss  xmm2, dword ptr [rsp+98h+outBsParams+4]; value }
  XAnimSetFloatGameParameterByIndex(viewModelDObj, 9u, *(float *)&_XMM2);
  Tree = DObjGetTree(viewModelDObj);
  if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4558, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
    __debugbreak();
  *(double *)&_XMM0 = XAnimGetGoalWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x18Du);
  __asm
  {
    vxorps  xmm7, xmm7, xmm7
    vcomiss xmm0, xmm7
    vmovaps xmm6, xmm0
  }
  if ( !(v17 | v18) && XAnimIsCustomNodeByName(Tree->anims, 0x18Du, scr_const.xanimBlendSpace2D) )
  {
    __asm
    {
      vmovss  xmm1, cs:__real@3f800000
      vucomiss xmm6, xmm1
      vmovss  [rsp+98h+rate], xmm1
      vmovss  [rsp+98h+goalTime], xmm7
      vmovss  dword ptr [rsp+98h+fmt], xmm1
    }
    XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x18Du, fmt, goalTimea, ratea, (scr_string_t)0, 0, 0, LINEAR, NULL);
  }
  _R11 = &v30;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, [rsp+98h+var_28]
  }
}

/*
==============
PlayMappedSoundAlias
==============
*/
char PlayMappedSoundAlias(LocalClientNum_t localClientNum, unsigned int numMappings, const scr_string_t *keys, const scr_string_t *values, const scr_string_t *searchedNoteName)
{
  unsigned int v9; 
  signed __int64 v10; 
  int v11; 
  const char *v12; 
  CgSoundSystem *SoundSystem; 

  if ( !keys && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12503, ASSERT_TYPE_ASSERT, "(keys)", (const char *)&queryFormat, "keys") )
    __debugbreak();
  if ( !values && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 12504, ASSERT_TYPE_ASSERT, "(values)", (const char *)&queryFormat, "values") )
    __debugbreak();
  v9 = 0;
  if ( numMappings )
  {
    v10 = (char *)keys - (char *)values;
    do
    {
      v11 = *(const scr_string_t *)((char *)values + v10);
      if ( !v11 )
        break;
      if ( *values )
      {
        if ( v11 == *searchedNoteName )
        {
          v12 = SL_ConvertToString((scr_string_t)*values);
          if ( v12 )
          {
            SoundSystem = CgSoundSystem::GetSoundSystem(localClientNum);
            CgSoundSystem::PlayClientSoundAliasByName2(SoundSystem, v12);
            return 1;
          }
        }
      }
      ++v9;
      ++values;
    }
    while ( v9 < numMappings );
  }
  return 0;
}

/*
==============
PlayProtoMovementAnim
==============
*/
void PlayProtoMovementAnim(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex hand, const Weapon *weapon)
{
  const dvar_t *v8; 
  __int64 v10; 
  cg_t *LocalClientGlobals; 
  WeaponHand *ViewModelHand; 
  XAnimTree *Tree; 
  MovementAnimState::State v17; 
  MovementAnimState *v22; 
  bool IsSuperSprinting; 
  bool v24; 
  bool IsJogging; 
  unsigned int v26; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float fmtc; 
  float fmtd; 
  float fmte; 
  float fmtf; 
  float goalTime; 
  float goalTimea; 
  float goalTimeb; 
  float goalTimec; 
  float goalTimed; 
  float goalTimee; 
  float rate; 
  float ratea; 
  float rateb; 
  float ratec; 
  float rated; 
  float ratee; 

  v8 = DCONST_DVARMPBOOL_movementAnimProto;
  v10 = hand;
  if ( !DCONST_DVARMPBOOL_movementAnimProto && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "movementAnimProto") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v8);
  if ( v8->current.enabled )
  {
    __asm
    {
      vmovaps [rsp+0B8h+var_38], xmm6
      vmovaps [rsp+0B8h+var_48], xmm7
      vmovaps [rsp+0B8h+var_58], xmm8
    }
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    ViewModelHand = cg_t::GetViewModelHand(LocalClientGlobals, (const PlayerHandIndex)v10);
    if ( !ViewModelHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5844, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
      __debugbreak();
    Tree = DObjGetTree(ViewModelHand->viewModelDObj);
    if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5847, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
      __debugbreak();
    if ( !Tree->anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5848, ASSERT_TYPE_ASSERT, "(animTree->anims)", (const char *)&queryFormat, "animTree->anims") )
      __debugbreak();
    __asm { vmovss  xmm7, cs:__real@3f800000 }
    v17 = NONE;
    __asm
    {
      vxorps  xmm8, xmm8, xmm8
      vmovss  [rsp+0B8h+rate], xmm7
      vmovss  [rsp+0B8h+goalTime], xmm8
      vmovss  dword ptr [rsp+0B8h+fmt], xmm8
    }
    XAnimSetGoalWeight(ViewModelHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x48u, fmt, goalTime, rate, (scr_string_t)0, 0, 0, LINEAR, NULL);
    __asm
    {
      vmovss  [rsp+0B8h+rate], xmm7
      vmovss  [rsp+0B8h+goalTime], xmm8
      vmovss  dword ptr [rsp+0B8h+fmt], xmm8
    }
    XAnimSetGoalWeight(ViewModelHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x69u, fmta, goalTimea, ratea, (scr_string_t)0, 0, 0, LINEAR, NULL);
    __asm
    {
      vmovss  [rsp+0B8h+rate], xmm7
      vmovss  [rsp+0B8h+goalTime], xmm8
      vmovss  dword ptr [rsp+0B8h+fmt], xmm8
    }
    XAnimSetGoalWeight(ViewModelHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x5Du, fmtb, goalTimeb, rateb, (scr_string_t)0, 0, 0, LINEAR, NULL);
    __asm
    {
      vmovss  [rsp+0B8h+rate], xmm7
      vmovss  [rsp+0B8h+goalTime], xmm8
      vmovss  dword ptr [rsp+0B8h+fmt], xmm8
    }
    XAnimSetGoalWeight(ViewModelHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x62u, fmtc, goalTimec, ratec, (scr_string_t)0, 0, 0, LINEAR, NULL);
    *(float *)&_XMM0 = UpdateMovementAnimWeightRoot(localClientNum, ps, (PlayerHandIndex)v10, weapon);
    __asm
    {
      vmovss  [rsp+0B8h+rate], xmm7
      vmovss  [rsp+0B8h+goalTime], xmm8
      vmovss  dword ptr [rsp+0B8h+fmt], xmm0
      vmovaps xmm6, xmm0
    }
    XAnimSetGoalWeight(ViewModelHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x2Du, fmtd, goalTimed, rated, (scr_string_t)0, 0, 0, LINEAR, NULL);
    __asm
    {
      vmovss  [rsp+0B8h+rate], xmm7
      vmovss  [rsp+0B8h+goalTime], xmm8
      vmovss  dword ptr [rsp+0B8h+fmt], xmm6
    }
    XAnimSetGoalWeight(ViewModelHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x3Eu, fmte, goalTimee, ratee, (scr_string_t)0, 0, 0, LINEAR, NULL);
    __asm
    {
      vmovaps xmm7, [rsp+0B8h+var_48]
      vcomiss xmm6, xmm8
      vmovaps xmm8, [rsp+0B8h+var_58]
    }
    v22 = &LocalClientGlobals->animMoveState[v10];
    if ( __CFADD__(v10, v10) || 2 * v10 == 0 )
    {
      MovementAnimState::Reset(&LocalClientGlobals->animMoveState[v10], localClientNum, (const PlayerHandIndex)v10);
    }
    else
    {
      if ( !LocalClientGlobals->animMoveState[v10].m_isInitialized )
        MovementAnimState::Reset(&LocalClientGlobals->animMoveState[v10], localClientNum, (const PlayerHandIndex)v10);
      if ( v22->m_goal == -1 )
        MovementAnimState::UpdateInternal(&LocalClientGlobals->animMoveState[v10], localClientNum, (const PlayerHandIndex)v10, ps, NONE);
      if ( !MovementAnimState::PlayerActionForcesWalk(localClientNum, ps) )
      {
        IsSuperSprinting = BG_IsSuperSprinting(ps);
        v24 = !IsSuperSprinting && GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 0x14u);
        IsJogging = CG_IsJogging(localClientNum);
        if ( IsSuperSprinting )
        {
          v17 = LONG;
        }
        else if ( v24 )
        {
          v17 = HALF_HALF;
        }
        else
        {
          LOBYTE(v17) = IsJogging;
        }
      }
      MovementAnimState::UpdateInternal(v22, localClientNum, (const PlayerHandIndex)v10, ps, v17);
    }
    *(double *)&_XMM0 = BG_GetBobCycleAnimTime((const int (*)[2])ps->packedBobCycle);
    v26 = 63;
    __asm { vmovaps xmm6, xmm0 }
    do
    {
      __asm { vmovss  dword ptr [rsp+0B8h+fmt], xmm6 }
      XAnimSetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, v26++, fmtf);
    }
    while ( v26 <= 0x42 );
    __asm { vmovaps xmm6, [rsp+0B8h+var_38] }
  }
}

/*
==============
CgWeaponSystem::PlayPullbackSound
==============
*/
void CgWeaponSystem::PlayPullbackSound(CgWeaponSystem *this, const int entNum, const bool isPlayerView, const Weapon *r_weapon, const bool isAlternate)
{
  __int64 v5; 
  unsigned int id; 
  cg_t *LocalClientGlobals; 
  unsigned int lastPullbackId; 
  CgSoundSystem *SoundSystem; 
  const SndAliasList *WeaponSoundWithFallback; 
  const SndAliasList *v14; 
  cg_t *v15; 
  __int64 v16; 
  __int64 v17; 

  v5 = entNum;
  id = 0;
  if ( entNum < cls.maxClients )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
    if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25077, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
      __debugbreak();
    if ( (unsigned __int64)cls.maxClients > 0xC8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25079, ASSERT_TYPE_ASSERT, "( ( sizeof( *array_counter( cgameGlob->soundPlaybackCache.clients ) ) + 0 ) ) >= ( cls.maxClients )", "%s >= %s\n\t%i, %i", "ARRAY_COUNT( cgameGlob->soundPlaybackCache.clients )", "cls.maxClients", 200, cls.maxClients) )
      __debugbreak();
    lastPullbackId = LocalClientGlobals->soundPlaybackCache.clients[v5].lastPullbackId;
    if ( lastPullbackId )
      SND_StopSoundAliasAndSecondariesByAliasId(lastPullbackId, this->m_localClientNum, v5);
    LocalClientGlobals->soundPlaybackCache.clients[v5].lastPullbackId = 0;
  }
  SoundSystem = CgSoundSystem::GetSoundSystem((const LocalClientNum_t)this->m_localClientNum);
  if ( !SoundSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25098, ASSERT_TYPE_ASSERT, "(soundSystem)", (const char *)&queryFormat, "soundSystem") )
    __debugbreak();
  WeaponSoundWithFallback = BG_GetWeaponSoundWithFallback(r_weapon, isAlternate, 8i64 * isPlayerView + 48);
  v14 = WeaponSoundWithFallback;
  if ( WeaponSoundWithFallback && CgSoundSystem::PlayEntitySoundAlias(SoundSystem, v5, WeaponSoundWithFallback) )
    id = v14->id;
  if ( (int)v5 < cls.maxClients )
  {
    v15 = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
    if ( !v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25114, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
      __debugbreak();
    if ( (unsigned __int64)cls.maxClients > 0xC8 )
    {
      LODWORD(v17) = cls.maxClients;
      LODWORD(v16) = 200;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25116, ASSERT_TYPE_ASSERT, "( ( sizeof( *array_counter( cgameGlob->soundPlaybackCache.clients ) ) + 0 ) ) >= ( cls.maxClients )", "%s >= %s\n\t%i, %i", "ARRAY_COUNT( cgameGlob->soundPlaybackCache.clients )", "cls.maxClients", v16, v17) )
        __debugbreak();
    }
    v15->soundPlaybackCache.clients[v5].lastPullbackId = id;
  }
}

/*
==============
PlayRecoilAnim
==============
*/
void PlayRecoilAnim(LocalClientNum_t localClientNum, const playerState_s *ps, const Weapon *weapon, PlayerHandIndex hand, weapAnimFiles_t animIndex)
{
  __int64 v10; 
  cg_t *LocalClientGlobals; 
  const DObj *viewModelDObj; 
  __int64 v15; 
  cg_t *v16; 
  PlayerWeaponAnimArrays *p_m_weaponAnimArrays; 
  char v18; 
  unsigned int v19; 
  bool v22; 
  bool IsDualWield; 
  const WeaponCompleteDef *v24; 
  int weaponShotCount; 
  CgWeaponMap *Instance; 
  bool IsLooped; 
  bool v38; 
  const char *AnimDebugName; 
  bool v40; 
  XAnimTree *Tree; 
  char v44; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float fmtc; 
  float fmtd; 
  float fmte; 
  float fmtf; 
  float fmtg; 
  float goalTime; 
  float goalTimea; 
  float goalTimeb; 
  float goalTimec; 
  float goalTimed; 
  float goalTimee; 
  float goalTimef; 
  float rate; 
  float ratea; 
  float rateb; 
  float ratec; 
  float rated; 
  float ratee; 
  float ratef; 
  int fireTime; 
  int fireDelay; 
  __int64 v76; 
  unsigned int v81; 
  char v83; 

  v10 = hand;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( (unsigned int)v10 >= 2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v10, 2) )
    __debugbreak();
  v76 = v10;
  viewModelDObj = LocalClientGlobals->m_weaponHand[v10].viewModelDObj;
  v15 = v10;
  if ( !viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6977, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  if ( !CG_HasRecoilAnim(localClientNum, ps, (PlayerHandIndex)v10) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 6978, ASSERT_TYPE_ASSERT, "(CG_HasRecoilAnim( localClientNum, ps, hand ))", (const char *)&queryFormat, "CG_HasRecoilAnim( localClientNum, ps, hand )") )
    __debugbreak();
  if ( !GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 0x10u) && !BG_IsPlayerFireDisabledForHand(ps, (const PlayerHandIndex)v10) )
  {
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5970, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    v16 = CG_GetLocalClientGlobals(localClientNum);
    if ( !v16 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5976, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
      __debugbreak();
    if ( &v16->predictedPlayerState != ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5977, ASSERT_TYPE_ASSERT, "(&cgameGlob->predictedPlayerState == ps)", "%s\n\tInvalid player state in client weapon processing. Expected predicted player state.\n", "&cgameGlob->predictedPlayerState == ps") )
      __debugbreak();
    p_m_weaponAnimArrays = &v16->m_weaponAnimArrays;
    if ( !p_m_weaponAnimArrays && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5980, ASSERT_TYPE_ASSERT, "(weaponAnimArrays)", (const char *)&queryFormat, "weaponAnimArrays") )
      __debugbreak();
    if ( BG_UsingAlternate(ps) )
      p_m_weaponAnimArrays = (PlayerWeaponAnimArrays *)((char *)p_m_weaponAnimArrays + 4976);
    v83 = 0;
    v18 = 0;
    v81 = 412;
    v19 = 412;
    if ( p_m_weaponAnimArrays->normalAnimArray[176] )
    {
      v83 = 1;
      v81 = 176;
      v18 = 1;
      v19 = 175;
    }
    __asm
    {
      vmovaps [rsp+0E8h+var_58], xmm6
      vmovaps [rsp+0E8h+var_68], xmm7
      vmovaps [rsp+0E8h+var_78], xmm8
    }
    if ( animIndex == WEAP_ANIM_RECOIL )
    {
      if ( LocalClientGlobals->weaponRecoilTime[v15] > 0 )
      {
        v22 = BG_UsingAlternate(ps);
        IsDualWield = BG_WeaponIsDualWield(weapon);
        v24 = BG_WeaponCompleteDef(weapon, v22);
        weaponShotCount = ps->weapState[v76].weaponShotCount;
        Instance = CgWeaponMap::GetInstance(localClientNum);
        BG_GetFireTime(Instance, ps, weapon, v22, IsDualWield, weaponShotCount, &fireTime, &fireDelay);
        if ( fireDelay + fireTime * v24->iClipSize <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7011, ASSERT_TYPE_ASSERT, "(totalTime > 0)", (const char *)&queryFormat, "totalTime > 0") )
          __debugbreak();
        __asm
        {
          vmovss  xmm7, cs:__real@3f800000
          vxorps  xmm1, xmm1, xmm1
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm1, xmm1, eax
          vcvtsi2ss xmm0, xmm0, ebx
          vdivss  xmm0, xmm1, xmm0; val
          vxorps  xmm1, xmm1, xmm1; min
          vmovaps xmm2, xmm7; max
          vxorps  xmm6, xmm6, xmm6
        }
        *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
        __asm { vmovaps xmm8, xmm0 }
        IsLooped = XAnimIsLooped(viewModelDObj->tree->anims, v81);
        v38 = !IsLooped;
        if ( IsLooped )
        {
          AnimDebugName = XAnimGetAnimDebugName(viewModelDObj->tree->anims, v81);
          v40 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7015, ASSERT_TYPE_ASSERT, "(!XAnimIsLooped( obj->tree->anims, recoilAnim ))", "%s\n\tRecoil anims cannot be looping. Animation '%s'.", "!XAnimIsLooped( obj->tree->anims, recoilAnim )", AnimDebugName);
          v38 = !v40;
          if ( v40 )
            __debugbreak();
        }
        __asm { vcomiss xmm8, xmm6 }
        if ( !v38 )
        {
          __asm
          {
            vmovss  xmm0, cs:__real@3e19999a
            vmovss  [rsp+0E8h+rate], xmm6
            vmovss  [rsp+0E8h+goalTime], xmm0
            vmovss  dword ptr [rsp+0E8h+fmt], xmm7
          }
          XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, v19, fmta, goalTimea, ratea, (scr_string_t)0, 1u, 0, LINEAR, NULL);
          if ( v83 )
          {
            __asm
            {
              vmovss  [rsp+0E8h+rate], xmm6
              vmovss  [rsp+0E8h+goalTime], xmm6
              vmovss  dword ptr [rsp+0E8h+fmt], xmm7
            }
            XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, v81, fmtb, goalTimeb, rateb, (scr_string_t)0, 1u, 0, LINEAR, NULL);
          }
          Tree = DObjGetTree(viewModelDObj);
          __asm { vmovss  dword ptr [rsp+0E8h+fmt], xmm8 }
          XAnimSetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, v81, fmtc);
        }
      }
      else
      {
        *(double *)&_XMM0 = XAnimGetWeight(LocalClientGlobals->m_weaponHand[v15].tree, 0, XANIM_SUBTREE_DEFAULT, v19);
        __asm
        {
          vmulss  xmm1, xmm0, cs:__real@3e19999a
          vxorps  xmm0, xmm0, xmm0
          vmovss  [rsp+0E8h+rate], xmm0
          vmovss  [rsp+0E8h+goalTime], xmm1
          vmovss  dword ptr [rsp+0E8h+fmt], xmm0
        }
        XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, v19, fmt, goalTime, rate, (scr_string_t)0, 0, 0, LINEAR, NULL);
      }
    }
    else if ( animIndex == WEAP_ANIM_RECOIL_SETTLE )
    {
      *(double *)&_XMM0 = XAnimGetWeight(LocalClientGlobals->m_weaponHand[v15].tree, 0, XANIM_SUBTREE_DEFAULT, v19);
      __asm
      {
        vcomiss xmm0, cs:__real@3a83126f
        vmovaps xmm6, xmm0
      }
      if ( !(v44 | v38) )
        LocalClientGlobals->weaponRecoilTime[v15] = -1;
      __asm
      {
        vmulss  xmm1, xmm6, cs:__real@3e19999a
        vxorps  xmm8, xmm8, xmm8
        vmovss  [rsp+0E8h+rate], xmm8
        vmovss  [rsp+0E8h+goalTime], xmm1
        vmovss  dword ptr [rsp+0E8h+fmt], xmm8
      }
      XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, v19, fmtd, goalTimec, ratec, (scr_string_t)0, 0, 0, LINEAR, NULL);
      if ( v18 )
        __asm { vucomiss xmm6, xmm8 }
      XAnimGetWeight(LocalClientGlobals->m_weaponHand[v15].tree, 0, XANIM_SUBTREE_DEFAULT, v19);
      if ( LocalClientGlobals->weaponRecoilTime[v15] == -1 )
      {
        __asm
        {
          vmovss  xmm7, cs:__real@3f800000
          vmovss  xmm6, cs:__real@3ca3d70a
          vmovss  [rsp+0E8h+rate], xmm7
          vmovss  [rsp+0E8h+goalTime], xmm6
          vmovss  dword ptr [rsp+0E8h+fmt], xmm7
        }
        XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x175u, fmte, goalTimed, rated, (scr_string_t)0, 0, 0, LINEAR, NULL);
        __asm
        {
          vmovss  [rsp+0E8h+rate], xmm7
          vmovss  [rsp+0E8h+goalTime], xmm6
          vmovss  dword ptr [rsp+0E8h+fmt], xmm8
        }
        XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0xEFu, fmtf, goalTimee, ratee, (scr_string_t)0, 0, 0, LINEAR, NULL);
        __asm
        {
          vmovss  [rsp+0E8h+rate], xmm7
          vmovss  [rsp+0E8h+goalTime], xmm6
          vmovss  dword ptr [rsp+0E8h+fmt], xmm8
        }
        XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0xF1u, fmtg, goalTimef, ratef, (scr_string_t)0, 0, 0, LINEAR, NULL);
        LocalClientGlobals->weaponRecoilTime[v15] = 0;
      }
    }
    else if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7061, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "PlayRecoilAnim passed unsupported weapon anim index.") )
    {
      __debugbreak();
    }
    __asm
    {
      vmovaps xmm7, [rsp+0E8h+var_68]
      vmovaps xmm6, [rsp+0E8h+var_58]
      vmovaps xmm8, [rsp+0E8h+var_78]
    }
  }
}

/*
==============
PlaySwimForwardAnims
==============
*/
void PlaySwimForwardAnims(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex hand, const Weapon *weapon)
{
  WeaponHand *ViewModelHand; 
  const DObj *viewModelDObj; 
  XAnimTree *Tree; 
  CgHandler *Handler; 
  CgHandler *v43; 
  char v69; 
  CgHandler *v80; 
  int v81; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float fmtc; 
  float fmtd; 
  float fmte; 
  float fmtf; 
  float goalTime; 
  float goalTimea; 
  float goalTimeb; 
  float goalTimec; 
  float goalTimed; 
  float rate; 
  float ratea; 
  float rateb; 
  float ratec; 
  float rated; 
  vec3_t forward; 
  AdditiveEaseInfo easeInfoArray; 
  int v110; 
  int v113; 
  int v116; 
  int v119; 
  int v122; 
  int v125; 
  int v128; 
  int v131; 
  int v134; 
  int v137; 
  int v140; 
  int v143; 
  int v146; 
  int v149; 
  int v152; 
  int v155; 
  int v158; 
  char v170; 

  __asm
  {
    vmovaps [rsp+240h+var_80], xmm9
    vmovaps [rsp+240h+var_90], xmm10
    vmovaps [rsp+240h+var_A0], xmm11
    vmovaps [rsp+240h+var_B0], xmm12
    vmovaps [rsp+240h+var_D0], xmm14
  }
  _RDI = DCONST_DVARMPFLT_player_swimSpeed;
  if ( !DCONST_DVARMPFLT_player_swimSpeed && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_swimSpeed") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RDI);
  __asm { vmovss  xmm12, dword ptr [rdi+28h] }
  _RDI = DCONST_DVARFLT_player_swimForwardAnimCatchupMin;
  if ( !DCONST_DVARFLT_player_swimForwardAnimCatchupMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_swimForwardAnimCatchupMin") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RDI);
  __asm { vmovss  xmm14, dword ptr [rdi+28h] }
  _RDI = DCONST_DVARFLT_player_swimForwardAnimCatchupMax;
  if ( !DCONST_DVARFLT_player_swimForwardAnimCatchupMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_swimForwardAnimCatchupMax") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RDI);
  __asm
  {
    vmovss  xmm1, cs:__real@3eb33333
    vmovss  xmm0, cs:__real@3f4ccccd
    vmovss  xmm11, cs:__real@3f800000
    vmovss  xmm9, dword ptr [rdi+28h]
    vmovss  [rbp+140h+easeInfoArray.easeOutTime], xmm1
    vmovss  [rbp+140h+var_1A0], xmm1
    vmovss  [rbp+140h+var_198], xmm1
    vmovss  [rbp+140h+var_194], xmm0
    vmovss  [rbp+140h+var_18C], xmm1
    vmovss  [rbp+140h+var_188], xmm0
    vmovss  [rbp+140h+var_180], xmm1
    vmovss  [rbp+140h+var_17C], xmm0
    vmovss  [rbp+140h+var_174], xmm1
    vmovss  [rbp+140h+var_170], xmm0
    vmovss  [rbp+140h+var_168], xmm1
    vmovss  [rbp+140h+var_164], xmm0
    vmovss  [rbp+140h+var_15C], xmm1
    vmovss  [rbp+140h+var_158], xmm0
    vmovss  [rbp+140h+var_150], xmm1
    vmovss  [rbp+140h+var_14C], xmm0
    vmovss  [rbp+140h+var_144], xmm1
    vmovss  [rbp+140h+var_140], xmm0
    vmovss  [rbp+140h+var_138], xmm1
    vmovss  [rbp+140h+var_134], xmm0
    vmovss  [rbp+140h+var_12C], xmm1
    vmovss  [rbp+140h+var_128], xmm0
    vmovss  [rbp+140h+var_120], xmm1
    vmovss  [rbp+140h+var_11C], xmm0
    vmovss  [rbp+140h+var_114], xmm1
    vmovss  xmm1, cs:__real@3e4ccccd
    vmovss  [rbp+140h+var_110], xmm0
    vmovss  xmm0, cs:__real@3ee66666
    vxorps  xmm10, xmm10, xmm10
  }
  easeInfoArray.animIndex = WEAP_ANIM_SPRINT_IN;
  __asm
  {
    vmovss  [rbp+140h+var_108], xmm1
    vmovss  [rbp+140h+var_104], xmm0
    vmovss  [rbp+140h+var_FC], xmm1
    vmovss  [rbp+140h+var_F8], xmm0
    vmovss  [rbp+140h+var_F0], xmm1
    vmovss  [rbp+140h+var_EC], xmm0
    vmovss  [rbp+140h+easeInfoArray.easeInTime], xmm11
    vmovss  [rbp+140h+var_1B0], xmm10
    vmovss  [rbp+140h+var_1AC], xmm11
    vmovss  [rbp+140h+var_1A4], xmm10
  }
  v110 = 339;
  v113 = 338;
  v116 = 286;
  v119 = 287;
  v122 = 288;
  v125 = 289;
  v128 = 290;
  v131 = 291;
  v134 = 304;
  v137 = 305;
  v140 = 306;
  v143 = 307;
  v146 = 308;
  v149 = 309;
  v152 = 329;
  v155 = 330;
  v158 = 331;
  if ( BG_IsSwimWeapon(weapon) )
  {
    __asm
    {
      vmovaps [rsp+240h+var_50], xmm6
      vmovaps [rsp+240h+var_C0], xmm13
    }
    if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3648, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_OPEN_PARACHUTE|WEAPON_FIRING) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3649, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::PLAYER_SWIMMING ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::PLAYER_SWIMMING )") )
      __debugbreak();
    _R14 = CG_GetLocalClientGlobals(localClientNum);
    ViewModelHand = cg_t::GetViewModelHand(_R14, hand);
    if ( !ViewModelHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3653, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
      __debugbreak();
    viewModelDObj = ViewModelHand->viewModelDObj;
    if ( !viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3655, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
      __debugbreak();
    Tree = DObjGetTree(viewModelDObj);
    if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 3658, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
      __debugbreak();
    AngleVectors(&ps->viewangles, &forward, NULL, NULL);
    __asm
    {
      vmovss  xmm0, dword ptr [rsp+240h+forward+4]
      vmovss  xmm1, dword ptr [rsp+240h+forward]
      vmulss  xmm3, xmm0, dword ptr [rbx+40h]
      vmulss  xmm2, xmm1, dword ptr [rbx+3Ch]
      vmovss  xmm0, dword ptr [rsp+240h+forward+8]
      vmulss  xmm1, xmm0, dword ptr [rbx+44h]
      vaddss  xmm4, xmm3, xmm2
      vaddss  xmm13, xmm4, xmm1
      vsubss  xmm6, xmm13, dword ptr [r14+6758Ch]
      vmovss  dword ptr [r14+6758Ch], xmm13
    }
    Handler = CgHandler::getHandler(localClientNum);
    if ( BG_ViewModelAnimExists(ps, WEAP_ANIM_ADDITIVE_SWIM_FORWARD, hand, Handler) )
    {
      v43 = CgHandler::getHandler(localClientNum);
      if ( BG_ViewModelAnimExists(ps, WEAP_ANIM_ADDITIVE_SWIM_BACKWARD, hand, v43) )
      {
        __asm
        {
          vcomiss xmm12, xmm10
          vmovss  xmm4, cs:__real@3a83126f
          vmovaps [rsp+240h+var_60], xmm7
          vmovss  xmm7, dword ptr cs:__xmm@7fffffff7fffffff7fffffff7fffffff
          vandps  xmm5, xmm6, xmm7
          vcomiss xmm5, xmm4
          vmovaps [rsp+240h+var_70], xmm8
          vmovss  xmm8, dword ptr cs:__xmm@80000000800000008000000080000000
          vdivss  xmm1, xmm6, xmm12
          vandps  xmm1, xmm1, xmm7
          vsubss  xmm0, xmm11, xmm1
          vmulss  xmm2, xmm0, xmm14
          vmovd   xmm0, dword ptr [r14+65E4h]
          vcvtdq2ps xmm0, xmm0
          vmulss  xmm1, xmm9, xmm1
          vaddss  xmm3, xmm2, xmm1
          vmulss  xmm2, xmm3, xmm0
          vmulss  xmm4, xmm2, xmm4
          vcmpltss xmm0, xmm6, xmm10
          vxorps  xmm1, xmm4, xmm8
          vblendvps xmm2, xmm4, xmm1, xmm0
          vandps  xmm0, xmm2, xmm7
          vcomiss xmm5, xmm0
          vmovss  [rsp+240h+var_1E0], xmm2
          vsubss  xmm0, xmm6, xmm2
          vsubss  xmm1, xmm13, xmm0
          vmovss  dword ptr [r14+6758Ch], xmm1
          vmovss  xmm0, dword ptr [r14+6758Ch]
          vmovss  xmm1, cs:__real@bf800000; min
          vdivss  xmm0, xmm0, xmm12; val
          vmovaps xmm2, xmm11; max
        }
        *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
        __asm
        {
          vcomiss xmm0, xmm10
          vmaxss  xmm7, xmm0, xmm10
        }
        if ( v69 )
          __asm { vxorps  xmm6, xmm0, xmm8 }
        else
          __asm { vxorps  xmm6, xmm6, xmm6 }
        *(float *)&_XMM0 = GetAdditiveAnimMax(Tree, ps, &easeInfoArray, 18);
        __asm
        {
          vminss  xmm8, xmm0, xmm7
          vminss  xmm9, xmm0, xmm6
          vcmpneqss xmm0, xmm8, xmm10
          vblendvps xmm6, xmm10, xmm11, xmm0
          vmovss  [rsp+240h+rate], xmm10
          vcmpneqss xmm0, xmm9, xmm10
          vmovss  [rsp+240h+goalTime], xmm10
          vmovss  dword ptr [rsp+240h+fmt], xmm6
          vblendvps xmm7, xmm10, xmm11, xmm0
        }
        XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x29u, fmt, goalTime, rate, (scr_string_t)0, 0, 0, LINEAR, NULL);
        __asm
        {
          vmovss  [rsp+240h+rate], xmm10
          vmovss  [rsp+240h+goalTime], xmm10
          vmovss  dword ptr [rsp+240h+fmt], xmm6
        }
        XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x2Au, fmta, goalTimea, ratea, (scr_string_t)0, 0, 0, LINEAR, NULL);
        __asm
        {
          vmovss  [rsp+240h+rate], xmm10
          vmovss  [rsp+240h+goalTime], xmm10
          vmovss  dword ptr [rsp+240h+fmt], xmm7
        }
        XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x2Bu, fmtb, goalTimeb, rateb, (scr_string_t)0, 0, 0, LINEAR, NULL);
        __asm
        {
          vmovss  [rsp+240h+rate], xmm10
          vmovss  [rsp+240h+goalTime], xmm10
          vmovss  dword ptr [rsp+240h+fmt], xmm7
        }
        XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x2Cu, fmtc, goalTimec, ratec, (scr_string_t)0, 0, 0, LINEAR, NULL);
        __asm { vmovss  dword ptr [rsp+240h+fmt], xmm8 }
        XAnimSetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x2Au, fmtd);
        __asm { vmovss  dword ptr [rsp+240h+fmt], xmm9 }
        XAnimSetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x2Cu, fmte);
        __asm
        {
          vmovaps xmm8, [rsp+240h+var_70]
          vmovaps xmm7, [rsp+240h+var_60]
        }
      }
    }
    v80 = CgHandler::getHandler(localClientNum);
    v81 = BG_ViewModelAnimExists(ps, WEAP_ANIM_SWIM_LOOP, hand, v80);
    __asm { vmovaps xmm6, [rsp+240h+var_50] }
    if ( v81 )
    {
      __asm
      {
        vcomiss xmm12, xmm10
        vmovss  [rsp+240h+rate], xmm10
        vmovss  [rsp+240h+goalTime], xmm10
        vmovss  dword ptr [rsp+240h+fmt], xmm10
      }
      XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x176u, fmtf, goalTimed, rated, (scr_string_t)0, 0, 0, LINEAR, NULL);
    }
    __asm { vmovaps xmm13, [rsp+240h+var_C0] }
  }
  _R11 = &v170;
  __asm
  {
    vmovaps xmm9, xmmword ptr [r11-48h]
    vmovaps xmm10, xmmword ptr [r11-58h]
    vmovaps xmm11, xmmword ptr [r11-68h]
    vmovaps xmm12, xmmword ptr [r11-78h]
    vmovaps xmm14, xmmword ptr [r11-98h]
  }
}

/*
==============
MovementAnimState::PlayerActionForcesWalk
==============
*/
bool MovementAnimState::PlayerActionForcesWalk(const LocalClientNum_t localClientNum, const playerState_s *ps)
{
  __int64 v2; 
  const BgWeaponMap **v4; 
  const BgWeaponMap *v5; 
  CgHandler *Handler; 
  PlayerHandIndex v7; 
  int WeaponHand; 
  __int64 v9; 
  __int64 v10; 
  int *p_weaponState; 
  __int64 v12; 
  unsigned __int64 v13; 
  __int64 v14; 

  v2 = localClientNum;
  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5560, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, 2) )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5561, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v4 = (const BgWeaponMap **)&CgWeaponMap::ms_instance[v2];
  if ( !*v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v5 = *v4;
  Handler = CgHandler::getHandler((LocalClientNum_t)v2);
  if ( !*v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v7 = WEAPON_HAND_DEFAULT;
  WeaponHand = BG_PlayerLastWeaponHand(*v4, ps);
  v9 = WeaponHand;
  if ( WeaponHand >= 0 )
  {
    v10 = 0i64;
    p_weaponState = &ps->weapState[0].weaponState;
    v12 = 0x40F0000001F80i64;
    do
    {
      v13 = *p_weaponState;
      if ( (unsigned int)v13 <= 0x32 )
      {
        if ( _bittest64(&v12, v13) )
          return 1;
      }
      if ( !PM_Weapon_IsInInterruptibleState(v5, ps, v7, Handler) && (unsigned int)v13 <= 0x20 )
      {
        v14 = 0x1FDC0003Ei64;
        if ( _bittest64(&v14, v13) )
          return 1;
      }
      ++v7;
      ++v10;
      p_weaponState += 20;
      v12 = 0x40F0000001F80i64;
    }
    while ( v10 <= v9 );
  }
  return BG_Offhand_HasActiveOffhand(ps);
}

/*
==============
CgWeaponSystem::ProcessDeferredTracer
==============
*/
void CgWeaponSystem::ProcessDeferredTracer(CgWeaponSystem *this)
{
  cg_t *LocalClientGlobals; 
  int v3; 
  scr_string_t *p_sourcePrimaryTagName; 
  __int64 localClientNum; 
  CgWeaponMap *v6; 
  __int64 v7; 
  const DObj *viewModelDObj; 
  unsigned int clientNum; 
  LocalClientNum_t m_localClientNum; 
  unsigned int v11; 
  unsigned int v12; 
  int entnum; 
  cg_t_vtbl *v14; 
  const characterInfo_t *CharacterInfo; 
  bool TagNameAndBoneIndexForCharacter; 
  const char *v17; 
  const cpose_t *Pose; 
  const char *v19; 
  scr_string_t *outTagName; 
  unsigned __int8 *outBoneIndex; 
  unsigned __int8 v22[4]; 
  scr_string_t stringValue; 
  TagPair v24; 
  vec3_t outOrigin; 
  tmat33_t<vec3_t> outTagMat; 
  CharacterModelType modelTypesToSearch[4]; 

  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  if ( LocalClientGlobals->delayedSpawnTracerEventsCount > 0x10u && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16630, ASSERT_TYPE_ASSERT, "( 0 ) <= ( cgameGlob->delayedSpawnTracerEventsCount ) && ( cgameGlob->delayedSpawnTracerEventsCount ) <= ( 16 )", "cgameGlob->delayedSpawnTracerEventsCount not in [0, MAX_DELAYED_SPAWN_TRACER_EVENTS]\n\t%i not in [%i, %i]", LocalClientGlobals->delayedSpawnTracerEventsCount, 0i64, 16) )
    __debugbreak();
  v3 = 0;
  if ( LocalClientGlobals->delayedSpawnTracerEventsCount > 0 )
  {
    p_sourcePrimaryTagName = &LocalClientGlobals->delayedSpawnTracerEvents[0].sourcePrimaryTagName;
    do
    {
      TagPair::TagPair(&v24, *p_sourcePrimaryTagName, p_sourcePrimaryTagName[1]);
      localClientNum = LocalClientGlobals->localClientNum;
      if ( !CgWeaponMap::ms_instance[localClientNum] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
        __debugbreak();
      v6 = CgWeaponMap::ms_instance[localClientNum];
      if ( LocalClientGlobals->renderingThirdPerson || BG_IsThirdPersonMode(CgWeaponMap::ms_instance[localClientNum], &LocalClientGlobals->predictedPlayerState) )
      {
        clientNum = LocalClientGlobals->predictedPlayerState.clientNum;
        m_localClientNum = this->m_localClientNum;
        if ( clientNum > 0x9E4 )
        {
          LODWORD(outBoneIndex) = LocalClientGlobals->predictedPlayerState.clientNum;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\dobj_management.h", 55, ASSERT_TYPE_ASSERT, "( ( handle >= 0 && handle < ((((((((((((( 2048 ) + 0)) + NUM_WEAPON_HANDS) + 64 - 1) + 1) + 1) + 1) + 1) + CLIENT_MODEL_MAX_COUNT - 1) + 1) + ( 32 ) - 1) + 1) ) )", "%s\n\t( handle ) = %i", "( handle >= 0 && handle < ((((((((((((( 2048 ) + 0)) + NUM_WEAPON_HANDS) + 64 - 1) + 1) + 1) + 1) + 1) + CLIENT_MODEL_MAX_COUNT - 1) + 1) + ( 32 ) - 1) + 1) )", outBoneIndex) )
            __debugbreak();
        }
        if ( (unsigned int)m_localClientNum >= LOCAL_CLIENT_COUNT )
        {
          LODWORD(outBoneIndex) = 2;
          LODWORD(outTagName) = m_localClientNum;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\dobj_management.h", 58, ASSERT_TYPE_ASSERT, "(unsigned)( localClientIndex ) < (unsigned)( (2) )", "localClientIndex doesn't index MAX_DOBJ_CLIENTS\n\t%i not in [0, %i)", outTagName, outBoneIndex) )
            __debugbreak();
        }
        v11 = 2533 * m_localClientNum + clientNum;
        if ( v11 >= 0x13CA )
        {
          LODWORD(outBoneIndex) = v11;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\dobj_management.h", 62, ASSERT_TYPE_ASSERT, "( ( (unsigned)handle < ( sizeof( *array_counter( clientObjMap ) ) + 0 ) ) )", "%s\n\t( handle ) = %i", "( (unsigned)handle < ( sizeof( *array_counter( clientObjMap ) ) + 0 ) )", outBoneIndex) )
            __debugbreak();
        }
        v12 = clientObjMap[v11];
        if ( v12 )
        {
          if ( v12 >= (unsigned int)s_objCount )
          {
            LODWORD(outBoneIndex) = v12;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\dobj_management.h", 64, ASSERT_TYPE_ASSERT, "( ( !objIndex || ( (unsigned)objIndex < s_objCount ) ) )", "%s\n\t( objIndex ) = %i", "( !objIndex || ( (unsigned)objIndex < s_objCount ) )", outBoneIndex) )
              __debugbreak();
          }
          viewModelDObj = (const DObj *)s_objBuf[v12];
        }
        else
        {
          viewModelDObj = NULL;
        }
      }
      else
      {
        v7 = *((int *)p_sourcePrimaryTagName + 21);
        if ( (unsigned int)v7 >= 2 )
        {
          LODWORD(outBoneIndex) = 2;
          SLODWORD(outTagName) = p_sourcePrimaryTagName[21];
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", outTagName, outBoneIndex) )
            __debugbreak();
        }
        viewModelDObj = LocalClientGlobals->m_weaponHand[v7].viewModelDObj;
      }
      if ( viewModelDObj )
      {
        entnum = viewModelDObj->entnum;
        v14 = LocalClientGlobals->__vftable;
        v22[0] = -2;
        stringValue = 0;
        if ( v14->HasCharacterInfo(LocalClientGlobals, entnum - 1) && (CharacterInfo = CG_GetCharacterInfo(LocalClientGlobals, entnum - 1)) != NULL )
        {
          modelTypesToSearch[0] = CHAR_MODEL_WEAPON_HELD;
          modelTypesToSearch[1] = CHAR_MODEL_WEAPON_HELD_LEFT;
          modelTypesToSearch[2] = CHAR_MODEL_WEAPON_EXECUTION;
          TagNameAndBoneIndexForCharacter = TagPair::GetTagNameAndBoneIndexForCharacter(&v24, viewModelDObj, CharacterInfo, modelTypesToSearch, 3, &stringValue, v22);
        }
        else
        {
          TagNameAndBoneIndexForCharacter = TagPair::GetTagNameAndBoneIndex(&v24, viewModelDObj, &stringValue, v22);
        }
        if ( TagNameAndBoneIndexForCharacter )
        {
          if ( LocalClientGlobals->renderingThirdPerson || BG_IsThirdPersonMode(v6, &LocalClientGlobals->predictedPlayerState) )
            Pose = CG_GetPose(this->m_localClientNum, LocalClientGlobals->predictedPlayerState.clientNum);
          else
            Pose = &LocalClientGlobals->viewModelPose;
          if ( CG_DObjGetWorldBoneMatrix(Pose, viewModelDObj, v22[0], &outTagMat, &outOrigin) )
          {
            Tracer_Spawn(this->m_localClientNum, *((_DWORD *)p_sourcePrimaryTagName - 2), (const bitarray<64> *)p_sourcePrimaryTagName + 11, &outOrigin, (const vec3_t *)(p_sourcePrimaryTagName + 2), *((_DWORD *)p_sourcePrimaryTagName - 1), (const Weapon *)(p_sourcePrimaryTagName + 5), *((_BYTE *)p_sourcePrimaryTagName + 80), 0);
          }
          else
          {
            v19 = SL_ConvertToString(stringValue);
            Com_PrintWarning(14, "CgWeaponSystem::ProcessDeferredTracer unable to calc orientation for bone %s.\n", v19);
          }
        }
        else
        {
          v17 = SL_ConvertToString(stringValue);
          Com_PrintWarning(14, "CgWeaponSystem::ProcessDeferredTracer unable find bone %s\n", v17);
        }
      }
      ++v3;
      p_sourcePrimaryTagName += 26;
    }
    while ( v3 < LocalClientGlobals->delayedSpawnTracerEventsCount );
  }
  LocalClientGlobals->delayedSpawnTracerEventsCount = 0;
}

/*
==============
MovementAnimState::Reset
==============
*/
void MovementAnimState::Reset(MovementAnimState *this, const LocalClientNum_t localClientNum, const PlayerHandIndex hand)
{
  signed int v6; 
  signed int v7; 
  cg_t *LocalClientGlobals; 
  const WeaponHand *ViewModelHand; 
  const DObj **p_viewModelDObj; 
  float v16; 
  float v17; 
  float v18; 
  float v19; 
  float v20; 
  float v21; 

  this->m_goal = -1;
  v6 = 46;
  v7 = 63;
  this->m_offsetAnim = WEAP_ANIM_ADDITIVE_MOVE_OFFSET_START;
  this->m_cycleAnim = WEAP_ANIM_ADDITIVE_MOVE_CYCLE_START;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( LocalClientGlobals )
  {
    ViewModelHand = cg_t::GetViewModelHand(LocalClientGlobals, hand);
    p_viewModelDObj = (const DObj **)&ViewModelHand->viewModelDObj;
    if ( ViewModelHand && ViewModelHand->viewModelDObj && DObjGetTree(ViewModelHand->viewModelDObj) )
    {
      __asm
      {
        vmovaps [rsp+88h+var_18], xmm6
        vmovaps [rsp+88h+var_28], xmm7
        vmovss  xmm7, cs:__real@3f800000
        vxorps  xmm6, xmm6, xmm6
      }
      do
      {
        __asm
        {
          vmovss  [rsp+88h+var_58], xmm7
          vmovss  [rsp+88h+var_60], xmm6
          vmovss  [rsp+88h+var_68], xmm6
        }
        XAnimSetGoalWeight(*p_viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, v6++, v16, v18, v20, (scr_string_t)0, 0, 0, LINEAR, NULL);
      }
      while ( v6 <= 61 );
      do
      {
        __asm
        {
          vmovss  [rsp+88h+var_58], xmm7
          vmovss  [rsp+88h+var_60], xmm6
          vmovss  [rsp+88h+var_68], xmm6
        }
        XAnimSetGoalWeight(*p_viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, v7++, v17, v19, v21, (scr_string_t)0, 0, 0, LINEAR, NULL);
      }
      while ( v7 <= 66 );
      __asm
      {
        vmovaps xmm7, [rsp+88h+var_28]
        vmovaps xmm6, [rsp+88h+var_18]
      }
      this->m_isInitialized = 1;
    }
    else
    {
      this->m_isInitialized = 1;
    }
  }
  else
  {
    this->m_isInitialized = 1;
  }
}

/*
==============
ResetWeaponAnimTrees
==============
*/

void __fastcall ResetWeaponAnimTrees(LocalClientNum_t localClientNum, const playerState_s *ps, double _XMM2_8)
{
  __int64 v5; 
  WeaponHand *m_weaponHand; 
  CgWeaponMap *v8; 
  DObj *viewModelDObj; 
  XAnimTree *Tree; 
  PlayerHandIndex v17; 
  int WeaponHandForViewWeapon; 
  __int64 v20; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float fmtc; 
  float fmtd; 
  float fmte; 
  float fmtf; 
  int forceBlendTimea; 
  int forceBlendTimeb; 
  int forceBlendTimec; 
  int forceBlendTimed; 
  int forceBlendTimee; 
  int forceBlendTimef; 
  __int64 forceBlendTime; 
  float objIDa; 
  float objIDb; 
  float objIDc; 
  float objIDd; 
  float objIDe; 
  float objIDf; 
  void *objID; 
  float curveID; 
  Weapon weapon; 

  v5 = localClientNum;
  if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_FREEFALL_RAISE|WEAPON_LADDER_AIM) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9045, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::WEAPON_ANIM_TREE_RESET ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::WEAPON_ANIM_TREE_RESET )") )
    __debugbreak();
  m_weaponHand = CG_GetLocalClientGlobals((const LocalClientNum_t)v5)->m_weaponHand;
  if ( !CgWeaponMap::ms_instance[v5] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v8 = CgWeaponMap::ms_instance[v5];
  _RAX = BG_GetCurrentWeaponForPlayer(v8, ps);
  __asm
  {
    vmovups ymm2, ymmword ptr [rax]
    vmovups ymmword ptr [rsp+108h+weapon.weaponIdx], ymm2
    vmovups xmm0, xmmword ptr [rax+20h]
    vmovups xmmword ptr [rsp+108h+weapon.attachmentVariationIndices+5], xmm0
    vmovsd  xmm1, qword ptr [rax+30h]
    vmovsd  qword ptr [rsp+108h+weapon.attachmentVariationIndices+15h], xmm1
  }
  *(_DWORD *)&weapon.weaponCamo = *(_DWORD *)&_RAX->weaponCamo;
  __asm { vmovd   eax, xmm2 }
  if ( (_WORD)_RAX || ps->pm_type >= 7 )
  {
    viewModelDObj = m_weaponHand->viewModelDObj;
    if ( m_weaponHand->viewModelDObj )
    {
      __asm
      {
        vmovaps [rsp+108h+var_48], xmm6
        vmovaps [rsp+108h+var_58], xmm7
      }
      Tree = DObjGetTree(viewModelDObj);
      if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9061, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
        __debugbreak();
      __asm
      {
        vxorps  xmm7, xmm7, xmm7
        vmovss  dword ptr [rsp+108h+fmt], xmm7
      }
      XAnimClearTreeGoalWeights(Tree, 0, XANIM_SUBTREE_DEFAULT, 0, fmt, 1, viewModelDObj, LINEAR);
      __asm
      {
        vmovss  xmm6, cs:__real@3f800000
        vmovss  dword ptr [rsp+108h+objID], xmm6
        vmovss  [rsp+108h+forceBlendTime], xmm7
        vmovss  dword ptr [rsp+108h+fmt], xmm6
      }
      XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0, fmta, *(float *)&forceBlendTimea, objIDa, (scr_string_t)0, 1u, 0, LINEAR, NULL);
      __asm
      {
        vmovss  dword ptr [rsp+108h+objID], xmm6
        vmovss  [rsp+108h+forceBlendTime], xmm7
        vmovss  dword ptr [rsp+108h+fmt], xmm6
      }
      XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 1u, fmtb, *(float *)&forceBlendTimeb, objIDb, (scr_string_t)0, 1u, 0, LINEAR, NULL);
      __asm
      {
        vmovss  dword ptr [rsp+108h+objID], xmm6
        vmovss  [rsp+108h+forceBlendTime], xmm7
        vmovss  dword ptr [rsp+108h+fmt], xmm6
      }
      XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0xEu, fmtc, *(float *)&forceBlendTimec, objIDc, (scr_string_t)0, 1u, 0, LINEAR, NULL);
      __asm
      {
        vmovss  dword ptr [rsp+108h+objID], xmm6
        vmovss  [rsp+108h+forceBlendTime], xmm7
        vmovss  dword ptr [rsp+108h+fmt], xmm6
      }
      XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 8u, fmtd, *(float *)&forceBlendTimed, objIDd, (scr_string_t)0, 1u, 0, LINEAR, NULL);
      __asm
      {
        vmovss  dword ptr [rsp+108h+objID], xmm6
        vmovss  [rsp+108h+forceBlendTime], xmm7
        vmovss  dword ptr [rsp+108h+fmt], xmm6
      }
      XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0xAu, fmte, *(float *)&forceBlendTimee, objIDe, (scr_string_t)0, 1u, 0, LINEAR, NULL);
      __asm
      {
        vmovss  dword ptr [rsp+108h+objID], xmm6
        vmovss  [rsp+108h+forceBlendTime], xmm7
        vmovss  dword ptr [rsp+108h+fmt], xmm6
      }
      XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0xBu, fmtf, *(float *)&forceBlendTimef, objIDf, (scr_string_t)0, 1u, 0, LINEAR, NULL);
      v17 = WEAPON_HAND_DEFAULT;
      WeaponHandForViewWeapon = BG_PlayerLastWeaponHandForViewWeapon(v8, ps);
      __asm { vmovaps xmm6, [rsp+108h+var_48] }
      if ( WeaponHandForViewWeapon >= 0 )
      {
        v20 = WeaponHandForViewWeapon + 1i64;
        do
        {
          if ( (unsigned int)v17 >= NUM_WEAPON_HANDS )
          {
            LODWORD(objID) = 2;
            LODWORD(forceBlendTime) = v17;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", forceBlendTime, objID) )
              __debugbreak();
          }
          if ( m_weaponHand->viewModelDObj )
          {
            __asm { vmovss  dword ptr [rsp+108h+curveID], xmm7 }
            if ( PM_WeaponClipEmpty(v8, ps, v17) )
              CG_Weapons_StartWeaponAnim((LocalClientNum_t)v5, &weapon, v17, WEAP_IDLE, WEAP_ANIM_EMPTY_IDLE, WEAP_IDLE, WEAP_ANIM_EMPTY_IDLE, curveID, 0);
            else
              CG_Weapons_StartWeaponAnim((LocalClientNum_t)v5, &weapon, v17, WEAP_IDLE, WEAP_ANIM_IDLE, WEAP_IDLE, WEAP_ANIM_IDLE, curveID, 0);
          }
          ++v17;
          ++m_weaponHand;
          --v20;
        }
        while ( v20 );
      }
      __asm { vmovaps xmm7, [rsp+108h+var_58] }
    }
  }
}

/*
==============
RestorePersistentAnims
==============
*/
void RestorePersistentAnims(WeaponHand *weapHand, const float *animWeights, const float *animTimes, const float *animGoalWeights, const float *animGoalTimes)
{
  char *v10; 
  __int64 v15; 
  unsigned int v16; 
  char v20; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float fmtc; 
  float goalTime; 
  float goalTimea; 
  float goalTimeb; 
  float v30; 
  float v31; 
  float v32; 

  __asm { vmovaps [rsp+98h+var_38], xmm6 }
  _RBX = animWeights;
  if ( !weapHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10078, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
    __debugbreak();
  if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10079, ASSERT_TYPE_ASSERT, "(animWeights)", (const char *)&queryFormat, "animWeights") )
    __debugbreak();
  if ( !animTimes && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10080, ASSERT_TYPE_ASSERT, "(animTimes)", (const char *)&queryFormat, "animTimes") )
    __debugbreak();
  v10 = (char *)((char *)s_persistentAnims - (char *)_RBX);
  _R13 = (char *)((char *)animGoalTimes - (char *)_RBX);
  _R15 = (char *)((char *)animGoalWeights - (char *)_RBX);
  _RBP = (char *)((char *)animTimes - (char *)_RBX);
  __asm { vxorps  xmm6, xmm6, xmm6 }
  v15 = 53i64;
  do
  {
    v16 = *(_DWORD *)((char *)_RBX + (_QWORD)v10);
    __asm { vmovss  xmm0, dword ptr [rbx] }
    if ( v16 - 245 > 0xD )
    {
      __asm
      {
        vcomiss xmm0, xmm6
        vmovss  [rsp+98h+var_68], xmm6
        vmovss  [rsp+98h+goalTime], xmm6
        vmovss  dword ptr [rsp+98h+fmt], xmm0
      }
      XAnimSetGoalWeight(weapHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, v16, fmtb, goalTimeb, v32, (scr_string_t)0, 0, 0, LINEAR, NULL);
    }
    else
    {
      __asm
      {
        vcomiss xmm0, xmm6
        vcomiss xmm6, dword ptr [r15+rbx]
      }
      if ( v16 - 245 >= 0xD )
        goto LABEL_20;
      __asm
      {
        vmovss  [rsp+98h+var_68], xmm6
        vmovss  [rsp+98h+goalTime], xmm6
        vmovss  dword ptr [rsp+98h+fmt], xmm0
      }
      XAnimSetGoalWeight(weapHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, v16, fmt, goalTime, v30, (scr_string_t)0, 0, 0, LINEAR, NULL);
      __asm
      {
        vmovss  xmm1, dword ptr [r15+rbx]
        vmovss  xmm0, dword ptr [rbx+r13]
        vcomiss xmm1, xmm6
        vmovss  [rsp+98h+var_68], xmm6
        vmovss  [rsp+98h+goalTime], xmm0
        vmovss  dword ptr [rsp+98h+fmt], xmm1
      }
      XAnimSetGoalWeight(weapHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, v16, fmta, goalTimea, v31, (scr_string_t)0, 0, 0, LINEAR, NULL);
    }
    __asm { vcomiss xmm6, dword ptr [rbx+rbp] }
    if ( v20 && XAnimIsLeafNode(weapHand->tree->anims, v16) )
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rbx+rbp]
        vmovss  dword ptr [rsp+98h+fmt], xmm0
      }
      XAnimSetTime(weapHand->tree, 0, XANIM_SUBTREE_DEFAULT, v16, fmtc);
    }
LABEL_20:
    ++_RBX;
    --v15;
  }
  while ( v15 );
  __asm { vmovaps xmm6, [rsp+98h+var_38] }
}

/*
==============
RestoreShieldPersistentAnims
==============
*/
void RestoreShieldPersistentAnims(WeaponHand *weapHand, const float *animWeights, const float *animTimes, const XAnimParts **shieldXAnimParts)
{
  const XAnim_s *Anims; 
  unsigned int *v13; 
  signed __int64 v14; 
  bool v15; 
  const XAnimParts *Parts; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float goalTime; 
  float v27; 

  __asm
  {
    vmovaps [rsp+0A8h+var_38], xmm6
    vmovaps [rsp+0A8h+var_48], xmm7
  }
  if ( !weapHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10166, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
    __debugbreak();
  if ( !animWeights && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10167, ASSERT_TYPE_ASSERT, "(animWeights)", (const char *)&queryFormat, "animWeights") )
    __debugbreak();
  if ( !animTimes && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10168, ASSERT_TYPE_ASSERT, "(animTimes)", (const char *)&queryFormat, "animTimes") )
    __debugbreak();
  if ( !shieldXAnimParts && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10169, ASSERT_TYPE_ASSERT, "(shieldXAnimParts)", (const char *)&queryFormat, "shieldXAnimParts") )
    __debugbreak();
  Anims = XAnimGetAnims(weapHand->tree);
  if ( !Anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10172, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
    __debugbreak();
  __asm { vmovss  xmm7, cs:__real@3f800000 }
  _R14 = (char *)animWeights - (char *)animTimes;
  v13 = (unsigned int *)s_shieldPersistentAnims;
  v14 = (char *)animTimes - (char *)s_shieldPersistentAnims;
  v15 = 0;
  __asm { vxorps  xmm6, xmm6, xmm6 }
  do
  {
    _RDI = (char *)v13 + v14;
    __asm { vcomiss xmm6, dword ptr [rdi+r14] }
    if ( v15 )
    {
      Parts = XAnimGetParts(Anims, *v13);
      if ( Parts )
      {
        if ( Parts == *shieldXAnimParts )
        {
          __asm
          {
            vmovss  xmm0, dword ptr [rdi+r14]
            vmovss  [rsp+0A8h+var_78], xmm6
            vmovss  [rsp+0A8h+goalTime], xmm6
            vmovss  dword ptr [rsp+0A8h+fmt], xmm0
          }
          XAnimSetGoalWeight(weapHand->viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, *v13, fmt, goalTime, v27, (scr_string_t)0, 0, 0, LINEAR, NULL);
          __asm { vcomiss xmm6, dword ptr [rdi] }
          if ( v15 )
          {
            if ( XAnimIsLeafNode(weapHand->tree->anims, *v13) )
            {
              if ( XAnimIsLooped(Anims, *v13) )
                __asm { vcomiss xmm7, dword ptr [rdi] }
              __asm
              {
                vmovss  xmm0, dword ptr [rdi]
                vmovss  dword ptr [rsp+0A8h+fmt], xmm0
              }
              XAnimSetTime(weapHand->tree, 0, XANIM_SUBTREE_DEFAULT, *v13, fmta);
              __asm { vmovss  dword ptr [rsp+0A8h+fmt], xmm7 }
              XAnimSetAnimRate(weapHand->tree, 0, XANIM_SUBTREE_DEFAULT, *v13, fmtb);
            }
          }
        }
      }
    }
    ++shieldXAnimParts;
    v15 = ++v13 < &dword_1442D8E94;
  }
  while ( (__int64)v13 < (__int64)&dword_1442D8E94 );
  __asm
  {
    vmovaps xmm6, [rsp+0A8h+var_38]
    vmovaps xmm7, [rsp+0A8h+var_48]
  }
}

/*
==============
ScaleSprintOutTime
==============
*/

float __fastcall ScaleSprintOutTime(const LocalClientNum_t localClientNum, double sprintOutTime)
{
  __int64 v4; 
  cg_t *LocalClientGlobals; 
  const playerState_s *p_predictedPlayerState; 
  CgWeaponMap *v8; 
  const Weapon *ViewmodelWeapon; 
  bool v10; 

  v4 = localClientNum;
  __asm
  {
    vmovaps [rsp+68h+var_18], xmm6
    vmovaps xmm6, xmm1
  }
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  p_predictedPlayerState = &LocalClientGlobals->predictedPlayerState;
  if ( LocalClientGlobals == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5545, ASSERT_TYPE_ASSERT, "( ps ) != ( nullptr )", "%s != %s\n\t%p, %p", "ps", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( !CgWeaponMap::ms_instance[v4] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v8 = CgWeaponMap::ms_instance[v4];
  ViewmodelWeapon = BG_GetViewmodelWeapon(v8, p_predictedPlayerState);
  v10 = BG_UsingAlternate(p_predictedPlayerState);
  *(double *)&_XMM0 = BG_GetSprintOutTimeScale(v8, p_predictedPlayerState, ViewmodelWeapon, v10);
  __asm
  {
    vmulss  xmm0, xmm0, xmm6
    vmovaps xmm6, [rsp+68h+var_18]
  }
  return *(float *)&_XMM0;
}

/*
==============
SetSwimDragGoalWeights
==============
*/
void SetSwimDragGoalWeights(LocalClientNum_t localClientNum, DObj *obj, const playerState_s *ps, const PlayerHandIndex hand, const Weapon *weapon, const float *dragWeights)
{
  signed __int64 v9; 
  __int64 v13; 
  CgHandler *Handler; 
  float v19; 
  float v20; 
  float v21; 
  float v22; 
  float v23; 
  float v24; 

  _RBX = dragWeights;
  __asm { vmovaps [rsp+98h+var_38], xmm6 }
  v9 = (char *)s_dragAnims - (char *)dragWeights;
  v13 = 4i64;
  __asm { vxorps  xmm6, xmm6, xmm6 }
  do
  {
    Handler = CgHandler::getHandler(localClientNum);
    if ( BG_ViewModelAnimExists(ps, *(weapAnimFiles_t *)((char *)_RBX + v9), hand, Handler) )
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rbx]
        vmovss  [rsp+98h+var_68], xmm6
        vmovss  [rsp+98h+var_70], xmm6
        vmovss  [rsp+98h+var_78], xmm0
      }
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, *(_DWORD *)((char *)_RBX + (char *)s_dragAnimRoots - (char *)dragWeights), v19, v21, v23, (scr_string_t)0, 0, 0, LINEAR, NULL);
      __asm
      {
        vmovss  xmm0, dword ptr [rbx]
        vmovss  [rsp+98h+var_68], xmm6
        vmovss  [rsp+98h+var_70], xmm6
        vmovss  [rsp+98h+var_78], xmm0
      }
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, *(_DWORD *)((char *)_RBX + v9), v20, v22, v24, (scr_string_t)0, 0, 0, LINEAR, NULL);
    }
    ++_RBX;
    --v13;
  }
  while ( v13 );
  __asm { vmovaps xmm6, [rsp+98h+var_38] }
}

/*
==============
CAssistTarget::SetTarget
==============
*/
void CAssistTarget::SetTarget(CAssistTarget *this, const centity_t *target)
{
  this->m_target = target;
}

/*
==============
MovementAnimState::ShouldApplyQuickDescendTransition
==============
*/
char MovementAnimState::ShouldApplyQuickDescendTransition(const LocalClientNum_t localClientNum, const playerState_s *ps, const MovementAnimState::State prevState, const MovementAnimState::State nextState, float *outTransDurationSec, float *outCycleTransDurationSec)
{
  const char *v11; 

  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5615, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( 2 )", "localClientNum doesn't index STATIC_MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", localClientNum, 2) )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5616, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( nextState >= prevState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5617, ASSERT_TYPE_ASSERT, "( static_cast<int>( nextState ) ) < ( static_cast<int>( prevState ) )", "%s < %s\n\t%i, %i", "static_cast<int>( nextState )", "static_cast<int>( prevState )", nextState, prevState) )
    __debugbreak();
  if ( MovementAnimState::PlayerActionForcesWalk(localClientNum, ps) )
  {
    if ( prevState == HALF_HALF )
    {
      _RBX = DCONST_DVARMPFLT_movementAnimProto_QuickTransOutSprint;
      if ( !DCONST_DVARMPFLT_movementAnimProto_QuickTransOutSprint )
      {
        v11 = "movementAnimProto_QuickTransOutSprint";
        goto LABEL_14;
      }
      goto LABEL_16;
    }
    if ( prevState == LONG )
    {
      _RBX = DCONST_DVARMPFLT_movementAnimProto_QuickTransOutSuperSprint;
      if ( !DCONST_DVARMPFLT_movementAnimProto_QuickTransOutSuperSprint )
      {
        v11 = "movementAnimProto_QuickTransOutSuperSprint";
LABEL_14:
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", v11) )
          __debugbreak();
      }
LABEL_16:
      Dvar_CheckFrontendServerThread(_RBX);
      _RAX = outTransDurationSec;
      __asm
      {
        vmovss  xmm0, dword ptr [rbx+28h]
        vmovss  dword ptr [rax], xmm0
      }
      _RAX = outCycleTransDurationSec;
      __asm { vmovss  dword ptr [rax], xmm0 }
      return 1;
    }
  }
  return 0;
}

/*
==============
CgWeaponSystem::ShouldSpawnTracer
==============
*/
bool CgWeaponSystem::ShouldSpawnTracer(CgWeaponSystem *this, const int attackerEntNum, const bitarray<64> *r_perks, const PlayerHandIndex hand, const Weapon *weapon, bool isAlternate, const bool isMainBulletSimulation)
{
  cg_t *LocalClientGlobals; 
  CgStatic *LocalClientStatics; 
  centity_t *Entity; 
  entityState_t *p_nextState; 
  characterInfo_t *CharacterInfo; 
  bool result; 
  int v18; 

  if ( (unsigned int)attackerEntNum >= 0x800 )
  {
    v18 = 2048;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 19540, ASSERT_TYPE_ASSERT, "(unsigned)( attackerEntNum ) < (unsigned)( ( 2048 ) )", "attackerEntNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", attackerEntNum, v18) )
      __debugbreak();
  }
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  result = !BG_IsBeamStyleTracer(weapon, isAlternate) && (!CG_PlayerUsingScopedTurret(this->m_localClientNum) || LocalClientGlobals->predictedPlayerState.viewlocked_entNum != attackerEntNum) && (!isMainBulletSimulation || LocalClientGlobals->predictedPlayerState.clientNum == attackerEntNum || (LocalClientStatics = CgStatic::GetLocalClientStatics((const LocalClientNum_t)LocalClientGlobals->localClientNum), Entity = CG_GetEntity((const LocalClientNum_t)this->m_localClientNum, attackerEntNum), (Entity->flags & 1) == 0) || (p_nextState = &Entity->nextState, !BG_IsCharacterEntity(&Entity->nextState)) || (CharacterInfo = CgStatic::GetCharacterInfo(LocalClientStatics, p_nextState->number)) == NULL || !CharacterInfo->doNotSimulateTracers) && Tracer_ShouldDraw((const LocalClientNum_t)this->m_localClientNum, r_perks, hand, weapon, isAlternate, attackerEntNum) != 0;
  return result;
}

/*
==============
CgWeaponSystem::ShouldSpawnTracerFromEvent
==============
*/
bool CgWeaponSystem::ShouldSpawnTracerFromEvent(CgWeaponSystem *this, const int eventId, const centity_t *hitEventEnt, const int attackerEntNum, const bitarray<64> *r_attackerPerks, const Weapon *weapon, bool isAlternate)
{
  cg_t *LocalClientGlobals; 
  centity_t *Entity; 
  cg_t *v13; 
  __int64 attackerEntNuma; 
  __int64 v16; 

  if ( (unsigned int)attackerEntNum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 19598, ASSERT_TYPE_ASSERT, "(unsigned)( attackerEntNum ) < (unsigned)( ( 2048 ) )", "attackerEntNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", attackerEntNum, 2048) )
    __debugbreak();
  if ( (unsigned int)(eventId - 211) <= 3 )
  {
    if ( !hitEventEnt && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 19606, ASSERT_TYPE_ASSERT, "(hitEventEnt)", (const char *)&queryFormat, "hitEventEnt") )
      __debugbreak();
    if ( (LOBYTE(hitEventEnt->nextState.lerp.u.vehicle.bodyPitch) & 1) == 0 )
      return 0;
  }
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  Entity = CG_GetEntity((const LocalClientNum_t)this->m_localClientNum, attackerEntNum);
  if ( (Entity->flags & 1) != 0 && BG_IsPlayerOrAgentEntity(&Entity->nextState) && CG_IsPlayerEntityNumber(&LocalClientGlobals->predictedPlayerState, attackerEntNum) )
    return 0;
  if ( BG_GetPenetrateType(weapon, isAlternate) == PENETRATE_TYPE_RICOCHET )
    return 0;
  if ( (unsigned int)attackerEntNum >= 0x800 )
  {
    LODWORD(v16) = 2048;
    LODWORD(attackerEntNuma) = attackerEntNum;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 19540, ASSERT_TYPE_ASSERT, "(unsigned)( attackerEntNum ) < (unsigned)( ( 2048 ) )", "attackerEntNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", attackerEntNuma, v16) )
      __debugbreak();
  }
  v13 = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  return !BG_IsBeamStyleTracer(weapon, isAlternate) && (!CG_PlayerUsingScopedTurret(this->m_localClientNum) || v13->predictedPlayerState.viewlocked_entNum != attackerEntNum) && Tracer_ShouldDraw((const LocalClientNum_t)this->m_localClientNum, r_attackerPerks, WEAPON_HAND_DEFAULT, weapon, isAlternate, attackerEntNum) != 0;
}

/*
==============
CgWeaponSystem::ShouldWeaponPing
==============
*/
__int64 CgWeaponSystem::ShouldWeaponPing(CgWeaponSystem *this, const centity_t *cent, const Weapon *weapon, const bool isAlternate)
{
  __int64 result; 
  cg_t *LocalClientGlobals; 
  vec3_t outOrg; 
  __int64 v25; 

  v25 = -2i64;
  __asm { vmovaps [rsp+88h+var_28], xmm6 }
  if ( !BG_IsOffhandWeaponType(weapon, isAlternate) )
  {
    if ( !BG_IsSilenced(weapon, isAlternate) )
    {
      result = 1i64;
      __asm { vmovaps xmm6, [rsp+88h+var_28] }
      return result;
    }
    LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
    RefdefView_GetOrg(&LocalClientGlobals->refdef.view, &outOrg);
    __asm
    {
      vmovss  xmm0, dword ptr [rsp+88h+outOrg]
      vsubss  xmm3, xmm0, dword ptr [rax]
      vmovss  xmm1, dword ptr [rsp+88h+outOrg+4]
      vsubss  xmm2, xmm1, dword ptr [rax+4]
      vmovss  xmm0, dword ptr [rsp+88h+outOrg+8]
      vsubss  xmm4, xmm0, dword ptr [rax+8]
      vmulss  xmm2, xmm2, xmm2
      vmulss  xmm1, xmm3, xmm3
      vaddss  xmm3, xmm2, xmm1
      vmulss  xmm0, xmm4, xmm4
      vaddss  xmm6, xmm3, xmm0
    }
    _RDI = DCONST_DVARFLT_cg_silencedWeaponPingRangeSquared;
    if ( !DCONST_DVARFLT_cg_silencedWeaponPingRangeSquared && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_silencedWeaponPingRangeSquared") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RDI);
    __asm { vcomiss xmm6, dword ptr [rdi+28h] }
    memset(&outOrg, 0, sizeof(outOrg));
  }
  result = 0i64;
  __asm { vmovaps xmm6, [rsp+88h+var_28] }
  return result;
}

/*
==============
CgWeaponSystem::SimulateBulletFire
==============
*/
void CgWeaponSystem::SimulateBulletFire(CgWeaponSystem *this, int eventId, centity_t *inflictorEnt, const int knownHitClientNum, const Weapon *weapon, bool isAlternate, const TagPair tagPair, bool isPlayerView, bool isPlayerWeaponView, PlayerHandIndex hand, const int fireSequenceIndex, const CgEventLodData *optionalEventLod, const CgFireEventHighPrecisionData *highPrecisionFireData)
{
  signed __int64 v13; 
  void *v20; 
  const CgEventLodData *v23; 
  const CgFireEventHighPrecisionData *v24; 
  entityType_s eType; 
  cg_t *LocalClientGlobals; 
  __int64 m_localClientNum; 
  CgStatic *LocalClientStatics; 
  const characterInfo_t *CharacterInfo; 
  bitarray<64> *v30; 
  playerState_s *p_predictedPlayerState; 
  bool (__fastcall *SimulateBulletFire_Orientation)(CgWeaponSystem *, centity_t *, const Weapon *, bool, const TagPair, bool, bool, PlayerHandIndex, const bool, const CgFireEventHighPrecisionData *, orientation_t *, float *, vec3_t *); 
  bool v33; 
  centity_t *v34; 
  int time; 
  cg_t *v36; 
  DebugBulletFireInfoLog *v39; 
  const centity_t *v46; 
  bool v47; 
  Weapon *v48; 
  bool IsBeamWeapon; 
  bool IsKillCamView; 
  bool ShouldSpread; 
  int v52; 
  CgBallistics *System; 
  const snapshot_t *nextSnap; 
  int serverTime; 
  const dvar_t *v59; 
  bool v60; 
  char v71; 
  bool v76; 
  bool HasCustomBulletTargetLogic; 
  targetAssistType_t TargetAssistType; 
  Weapon *v79; 
  targetAssistBehavior_t TargetAssistBehavior; 
  centity_t *v81; 
  int v82; 
  bool v83; 
  int v86; 
  int v89; 
  int v90; 
  unsigned __int64 v91; 
  const centity_t **p_m_target; 
  centity_t *v93; 
  PlayerHandIndex v99; 
  __int64 v107; 
  const dvar_t *v118; 
  char *fmt; 
  float fmta; 
  int v126; 
  Weapon *v127; 
  Weapon *v128; 
  double isAlternatea; 
  double v130; 
  int v131; 
  bool ShouldPerformEvent; 
  __int64 v133; 
  int v134; 
  const CgFireEventHighPrecisionData *v135; 
  int v136; 
  bool v137; 
  bool v138; 
  bool v139; 
  bool v140; 
  bool v141; 
  unsigned int pHoldrand; 
  float outAngle; 
  int v144; 
  float spreadMaxOut; 
  int v146; 
  Weapon *weapona; 
  centity_t *ownerEnt; 
  float spreadMinOut; 
  float angleMinOut; 
  float angleMaxOut; 
  playerState_s *ps; 
  cg_t *v153; 
  entityState_t *entState; 
  int v155; 
  BgWeaponMap *weaponMap; 
  int v157; 
  BGSpreadSetting v158; 
  __int64 v159; 
  SimulateBulletFirePelletData pelletData; 
  bitarray<64> perks; 
  __m256i v162; 
  int v164[6]; 
  ntl::fixed_array<CAssistTarget,20> ptr; 
  char v170; 

  v20 = alloca(v13);
  v159 = -2i64;
  __asm
  {
    vmovaps [rsp+4860h+var_40], xmm6
    vmovaps [rsp+4860h+var_50], xmm7
    vmovaps [rsp+4860h+var_60], xmm8
    vmovaps [rsp+4860h+var_70], xmm9
  }
  v155 = knownHitClientNum;
  ownerEnt = inflictorEnt;
  v157 = eventId;
  weapona = (Weapon *)weapon;
  v23 = optionalEventLod;
  v24 = highPrecisionFireData;
  Sys_ProfBeginNamedEvent(0xFF44CCFF, "SimulateBulletFire");
  PhysPerfTrack_BulletClientTimeStart();
  PhysPerfTrack_BulletClientEventCountAdd();
  if ( !inflictorEnt && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23571, ASSERT_TYPE_ASSERT, "(inflictorEnt)", (const char *)&queryFormat, "inflictorEnt") )
    __debugbreak();
  BG_WeaponDef(weapon, isAlternate);
  if ( BG_GetWeaponType(weapon, isAlternate) != WEAPTYPE_BULLET && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23575, ASSERT_TYPE_ASSERT, "(CG_Weapons_IsBulletWeapon( weapon, isAlternate ))", (const char *)&queryFormat, "CG_Weapons_IsBulletWeapon( weapon, isAlternate )") )
    __debugbreak();
  eType = inflictorEnt->nextState.eType;
  if ( eType >= ET_EVENTS && eType != (ET_PRIMARY_LIGHT|0x40) )
    goto LABEL_16;
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  v153 = LocalClientGlobals;
  m_localClientNum = this->m_localClientNum;
  if ( !CgWeaponMap::ms_instance[m_localClientNum] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  weaponMap = CgWeaponMap::ms_instance[m_localClientNum];
  if ( (inflictorEnt->flags & 1) != 0 && BG_IsCharacterEntity(&inflictorEnt->nextState) )
  {
    LocalClientStatics = CgStatic::GetLocalClientStatics((const LocalClientNum_t)this->m_localClientNum);
    CharacterInfo = CgStatic::GetCharacterInfo(LocalClientStatics, inflictorEnt->nextState.number);
    v30 = (bitarray<64> *)CharacterInfo;
    if ( CharacterInfo && !CharacterInfo->infoValid )
    {
LABEL_16:
      PhysPerfTrack_BulletClientTimeStop();
      Sys_ProfEndNamedEvent();
      goto LABEL_111;
    }
  }
  else
  {
    v30 = NULL;
  }
  p_predictedPlayerState = &LocalClientGlobals->predictedPlayerState;
  if ( !isPlayerWeaponView )
    p_predictedPlayerState = NULL;
  ps = p_predictedPlayerState;
  SimulateBulletFire_Orientation = this->SimulateBulletFire_Orientation;
  v135 = v24;
  ShouldPerformEvent = CG_EventLod_ShouldPerformEvent((const LocalClientNum_t)this->m_localClientNum, CG_EVENT_LOD_TYPE_FIRE_WEAPON_EXACT_MUZZLE_POINT, v23);
  v33 = isPlayerView;
  LOBYTE(v126) = isPlayerView;
  v34 = ownerEnt;
  if ( !((__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _BYTE, _DWORD, _BYTE, _QWORD, _QWORD, _QWORD, _QWORD))SimulateBulletFire_Orientation)(this, ownerEnt, weapon, isAlternate, tagPair, v126, isPlayerWeaponView, hand, ShouldPerformEvent, v135, (orientation_t *)&v162, (float *)&v144, (vec3_t *)v164) )
    goto LABEL_16;
  time = LocalClientGlobals->time;
  entState = &v34->nextState;
  if ( CG_DebugBulletFireLog_ShouldLog(v34->nextState.number) )
  {
    v36 = CG_GetLocalClientGlobals(LOCAL_CLIENT_0);
    _RDI = &v36->predictedPlayerState;
    Sys_EnterCriticalSection(CRITSECT_DEBUG_BULLET_FIRE_LOG);
    _RBX = NULL;
    if ( s_debugBulletFireInfoLog.entryCount == 50 )
    {
      _RBX = &s_debugBulletFireInfoLog.entries[49];
    }
    else
    {
      v39 = &s_debugBulletFireInfoLog;
      while ( v39->entries[0].isUsed )
      {
        v39 = (DebugBulletFireInfoLog *)((char *)v39 + 160);
        if ( (__int64)v39 >= (__int64)&s_debugBulletFireInfoLog.entryCount )
          goto LABEL_29;
      }
      ++s_debugBulletFireInfoLog.entryCount;
      _RBX = (DebugBulletFireInfoEntry *)v39;
    }
LABEL_29:
    _RBX->isUsed = 1;
    _RBX->serverTime = time;
    _RBX->clientGunPitch = v36->gunAngles.v[0];
    _RBX->clientGunYaw = v36->gunAngles.v[1];
    _RBX->clientViewAngles.v[0] = v36->predictedPlayerState.viewangles.v[0];
    __asm
    {
      vmovss  xmm0, dword ptr [rdi+1DCh]
      vmovss  dword ptr [rbx+10h], xmm0
      vmovss  xmm1, dword ptr [rdi+1E0h]
      vmovss  dword ptr [rbx+14h], xmm1
    }
    _RBX->clientDeltaAngles.v[0] = v36->predictedPlayerState.delta_angles.v[0];
    __asm
    {
      vmovss  xmm0, dword ptr [rdi+0B8h]
      vmovss  dword ptr [rbx+1Ch], xmm0
      vmovss  xmm1, dword ptr [rdi+0BCh]
      vmovss  dword ptr [rbx+20h], xmm1
    }
    _RBX->clientAdsStartTime = v36->predictedPlayerState.weapCommon.adsStartTime;
    _RBX->clientAdsFraction = v36->predictedPlayerState.weapCommon.fWeaponPosFrac;
    if ( !CgWeaponMap::ms_instance[0] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
      __debugbreak();
    *(double *)&_XMM0 = BG_WeaponADSFractionAffectedByReload(CgWeaponMap::ms_instance[0], _RDI);
    __asm { vmovss  dword ptr [rbx+2Ch], xmm0 }
    _RBX->clientIdleTimer1 = v36->predictedPlayerState.weapCommon.weaponIdleTime;
    _RBX->clientIdleTimer2 = v36->predictedPlayerState.weapCommon.weaponIdleTime2;
    __asm
    {
      vmovups xmm0, xmmword ptr [rbp+4760h+var_4308]
      vmovups xmmword ptr [rbx+38h], xmm0
      vmovss  xmm0, dword ptr [rbp+4760h+var_4308+10h]
      vmovss  dword ptr [rbx+48h], xmm0
      vmovss  xmm1, dword ptr [rbp+4760h+var_4308+14h]
      vmovss  dword ptr [rbx+4Ch], xmm1
    }
    _RBX->serverBulletEntryAdded = 0;
    v46 = NULL;
    *(_QWORD *)_RBX->serverBulletOrigin.v = 0i64;
    *(_QWORD *)&_RBX->serverBulletOrigin.z = 0i64;
    *(_QWORD *)&_RBX->serverBulletDir.y = 0i64;
    std::_Sort_unchecked<DebugBulletFireInfoEntry *,bool (*)(DebugBulletFireInfoEntry &,DebugBulletFireInfoEntry &)>(s_debugBulletFireInfoLog.entries, (DebugBulletFireInfoEntry *)&s_debugBulletFireInfoLog.entryCount, 50i64, CG_DebugBulletFireLog_Sorter);
    Sys_LeaveCriticalSection(CRITSECT_DEBUG_BULLET_FIRE_LOG);
    v33 = isPlayerView;
    v34 = ownerEnt;
  }
  else
  {
    v46 = NULL;
  }
  if ( v30 )
    perks = v30[347];
  else
    perks = 0i64;
  v47 = isAlternate;
  v48 = weapona;
  IsBeamWeapon = BG_IsBeamWeapon(weapona, isAlternate);
  IsKillCamView = CG_View_IsKillCamView((const LocalClientNum_t)this->m_localClientNum);
  if ( IsBeamWeapon && (IsKillCamView || !v33) )
    v46 = CG_BeamEntity_GetByOwner((const LocalClientNum_t)this->m_localClientNum, v34);
  ShouldSpread = BG_WeaponBulletFire_ShouldSpread(perks, v48, isAlternate);
  if ( ShouldSpread || IsBeamWeapon )
    v52 = BG_ShotCount(v48, isAlternate);
  else
    v52 = 1;
  System = CgBallistics::GetSystem((const LocalClientNum_t)this->m_localClientNum);
  v127 = v48;
  _RBX = ps;
  *(double *)&_XMM0 = BG_GetBulletRange<CgBallisticInstance>(weaponMap, System, ps, entState, &perks, v127, isAlternate);
  __asm { vmovaps xmm9, xmm0 }
  nextSnap = v153->nextSnap;
  if ( nextSnap )
    serverTime = nextSnap->serverTime;
  else
    serverTime = Sys_Milliseconds();
  if ( _RBX )
    serverTime = _RBX->serverTime;
  if ( _RBX )
  {
    _RSI = &_RBX->viewangles;
    pHoldrand = BG_srand_timeangles(serverTime + (hand != WEAPON_HAND_DEFAULT ? 0xA : 0), &_RBX->viewangles);
    v59 = DCONST_DVARBOOL_bg_aimSpreadDebugLog;
    if ( !DCONST_DVARBOOL_bg_aimSpreadDebugLog && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_aimSpreadDebugLog") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v59);
    v60 = !v59->current.enabled;
    _RBX = ps;
    if ( !v60 )
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rbx+1E0h]
        vcvtss2sd xmm0, xmm0, xmm0
        vmovss  xmm1, dword ptr [rbx+1DCh]
        vcvtss2sd xmm1, xmm1, xmm1
        vmovss  xmm3, dword ptr [rsi]
        vcvtss2sd xmm3, xmm3, xmm3
        vmovss  xmm2, [rbp+4760h+var_47D0]
        vcvtss2sd xmm2, xmm2, xmm2
      }
      LODWORD(v133) = pHoldrand;
      __asm
      {
        vmovsd  [rsp+4860h+var_4828], xmm0
        vmovsd  qword ptr [rsp+4860h+isAlternate], xmm1
        vmovsd  [rsp+4860h+var_4838], xmm3
      }
      LODWORD(fmt) = ps->commandTime;
      __asm { vmovq   r8, xmm2 }
      Com_Printf(17, "C: SimulateBulletFire: Spread: %f Server Time: %d  Command Time: %d View Angles:[%f %f %f] Rand Seed: %u\n", *(double *)&_XMM2, (unsigned int)ps->serverTime, fmt, *(double *)&v128, isAlternatea, v130, v133);
    }
    v47 = isAlternate;
  }
  else
  {
    pHoldrand = serverTime + (hand != WEAPON_HAND_DEFAULT ? 0xA : 0);
    BG_srand(&pHoldrand);
  }
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vmovss  [rbp+4760h+angleMinOut], xmm6
    vmovss  xmm8, cs:__real@43b40000
    vmovss  [rbp+4760h+angleMaxOut], xmm8
    vmovss  [rbp+4760h+spreadMinOut], xmm6
    vmovss  xmm7, [rbp+4760h+var_47D0]
    vmovss  [rbp+4760h+spreadMaxOut], xmm7
  }
  if ( ShouldSpread && v52 > 1 )
  {
    __asm { vcomiss xmm7, xmm6 }
    v71 = 1;
  }
  else
  {
    v71 = 0;
  }
  v137 = v71;
  *(_QWORD *)&v158.m_shotCount = 0i64;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmovups xmmword ptr [rbp+4760h+var_4770.m_angleRange], xmm0
  }
  if ( v71 )
  {
    *(double *)&_XMM0 = BG_random(&pHoldrand);
    __asm
    {
      vmulss  xmm1, xmm0, xmm8; angleStart
      vmovss  dword ptr [rsp+4860h+fmt], xmm7
      vxorps  xmm3, xmm3, xmm3; initSpreadMin
    }
    BGSpreadSetting::Init(&v158, *(float *)&_XMM1, v52, *(float *)&_XMM3, fmta);
  }
  _R15 = weapona;
  LODWORD(weaponMap) = BG_WeaponBulletFire_GetMethodOfDeath(perks, weapona, v47);
  v76 = isPlayerView && BG_IsTargetAssistActive(_RBX, entState, _R15, v47);
  `eh vector constructor iterator'(&ptr, 0x350ui64, 0x14ui64, (void (__fastcall *)(void *))CAssistTarget::CAssistTarget, (void (__fastcall *)(void *))CAssistTarget::~CAssistTarget);
  HasCustomBulletTargetLogic = BG_GameInterface_HasCustomBulletTargetLogic(ps);
  if ( v76 )
  {
    TargetAssistType = BG_GetTargetAssistType(_R15, isAlternate);
    v79 = (Weapon *)&CgWeaponSystem::ms_coneTargetEvaluator;
    if ( TargetAssistType != TARGET_ASSISTTYPPE_CONE )
      v79 = NULL;
    weapona = v79;
  }
  else
  {
    weapona = NULL;
  }
  if ( v76 )
    TargetAssistBehavior = BG_GetTargetAssistBehavior(_R15, isAlternate);
  else
    TargetAssistBehavior = TARGET_ASSISTBEHAVE_DEFAULT;
  v140 = TargetAssistBehavior == TARGET_ASSISTBEHAVE_DIRECT_DAMAGE;
  v139 = TargetAssistBehavior == TARGET_ASSISTBEHAVE_TARGET_ONLY;
  v141 = TargetAssistBehavior == TARGET_ASSISTBEHAVE_BEAM;
  v146 = 0;
  v138 = 0;
  if ( weapona && !HasCustomBulletTargetLogic )
  {
    Sys_ProfBeginNamedEvent(0xFF44CCFF, "Target Evaluator");
    if ( v46 )
    {
      v81 = ownerEnt;
      v82 = CG_BeamEntity_BuildTargetArray((const LocalClientNum_t)this->m_localClientNum, ownerEnt, v46, v153->time, &ptr);
      v138 = 1;
      v83 = isAlternate;
    }
    else
    {
      __asm
      {
        vmovaps xmm3, xmm9; fallbackRange
        vmovss  xmm2, [rbp+4760h+spreadMaxOut]; fallbackAngle
      }
      BG_GetTargetAssistAngleRange(_R15, isAlternate, *(const float *)&_XMM2, *(const float *)&_XMM3, &outAngle, (float *)&entState);
      v86 = v52;
      if ( TargetAssistBehavior == TARGET_ASSISTBEHAVE_DIRECT_DAMAGE )
        v86 = 20;
      LOBYTE(v136) = IsBeamWeapon;
      __asm
      {
        vmovss  xmm0, [rbp+4760h+outAngle]
        vmovss  dword ptr [rsp+4860h+var_4820], xmm0
        vmovss  xmm1, dword ptr [rbp+4760h+entState]
        vmovss  dword ptr [rsp+4860h+var_4828], xmm1
      }
      v81 = ownerEnt;
      v82 = (**(__int64 (__fastcall ***)(Weapon *, _QWORD, Weapon *, bool, centity_t *, __m256i *, char *, int, int, int, int, const unsigned int, int, char, ntl::fixed_array<CAssistTarget,20> *))&weapona->weaponIdx)(weapona, (unsigned int)this->m_localClientNum, _R15, isAlternate, ownerEnt, &v162, &v162.m256i_i8[12], v131, v134, v86, v136, HITLOC_MASK_ALL, v153->time, 1, &ptr);
      v83 = isAlternate;
    }
    v89 = v82;
    v146 = v82;
    if ( BG_IsBeamStyleTracer(_R15, v83) )
      CG_LocalEntity_BeamTargetsUpdate((const LocalClientNum_t)this->m_localClientNum, v81, v89, &ptr);
    Sys_ProfEndNamedEvent();
  }
  v90 = 0;
  v153 = (cg_t *)v52;
  if ( v52 > 0 )
  {
    v91 = 0i64;
    p_m_target = &ptr.m_data[0].m_target;
    v93 = ownerEnt;
    do
    {
      PhysPerfTrack_BulletClientPelletCountAdd();
      LODWORD(outAngle) = v90 + pHoldrand;
      BG_srand((unsigned int *)&outAngle);
      if ( v137 )
        BGSpreadSetting::CalculateSpread(&v158, v90, &spreadMinOut, &spreadMaxOut, &angleMinOut, &angleMaxOut);
      ConeTargetInfo::ConeTargetInfo(&pelletData.assistTarget);
      pelletData.assistTarget.__vftable = (CAssistTarget_vtbl *)&CAssistTarget::`vftable';
      pelletData.assistTarget.m_target = NULL;
      if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25541, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
        __debugbreak();
      pelletData.bulletId = this->m_nextBulletId;
      this->m_nextBulletId = pelletData.bulletId + 1;
      pelletData.shotIndex = v90;
      pelletData.inflictorEnt = v93;
      pelletData.knownHitClientNum = v155;
      __asm
      {
        vmovups ymm0, ymmword ptr [r15]
        vmovups ymmword ptr [rbp+4760h+pelletData.weapon.weaponIdx], ymm0
        vmovups xmm1, xmmword ptr [r15+20h]
        vmovups xmmword ptr [rbp+4760h+pelletData.weapon.attachmentVariationIndices+5], xmm1
        vmovsd  xmm0, qword ptr [r15+30h]
        vmovsd  qword ptr [rbp+4760h+pelletData.weapon.attachmentVariationIndices+15h], xmm0
      }
      *(_DWORD *)&pelletData.weapon.weaponCamo = *(_DWORD *)&_R15->weaponCamo;
      pelletData.isAlternate = isAlternate;
      pelletData.primaryTagName = TagPair::GetPrimaryTagName((TagPair *)&tagPair);
      pelletData.fallbackTagName = TagPair::GetFallbackTagName((TagPair *)&tagPair);
      *(float *)&pelletData.randSeed = outAngle;
      pelletData.isPlayerWeaponView = isPlayerWeaponView;
      __asm
      {
        vmovss  [rbp+4760h+pelletData.bulletRange], xmm9
        vmovups ymm0, [rbp+4760h+var_4308]
        vmovups ymmword ptr [rbp+4760h+pelletData.orient.origin], ymm0
        vmovups xmm0, [rbp+4760h+var_42E8]
        vmovups xmmword ptr [rbp+4760h+pelletData.orient.axis+14h], xmm0
      }
      pelletData.meansOfDeath = (int)weaponMap;
      pelletData.attackerPerks = perks;
      v99 = hand;
      pelletData.hand = hand;
      __asm
      {
        vmovss  xmm0, [rbp+4760h+var_47D0]
        vmovss  [rbp+4760h+pelletData.aimSpreadAmount], xmm0
        vmovss  xmm1, [rbp+4760h+spreadMinOut]
        vmovss  [rbp+4760h+pelletData.spreadMin], xmm1
        vmovss  xmm0, [rbp+4760h+spreadMaxOut]
        vmovss  [rbp+4760h+pelletData.spreadMax], xmm0
        vmovss  xmm1, [rbp+4760h+angleMinOut]
        vmovss  [rbp+4760h+pelletData.angleMin], xmm1
        vmovss  xmm0, [rbp+4760h+angleMaxOut]
        vmovss  [rbp+4760h+pelletData.angleMax], xmm0
      }
      pelletData.distributePellets = v137;
      pelletData.ignoreTargetEvaluation = v138;
      pelletData.targetEvaluator = (CTargetEvaluator *)weapona;
      pelletData.targetCount = v146;
      pelletData.targetAssistOnlyTargets = v139;
      pelletData.targetAssistDirectDamage = v140;
      pelletData.targetAssistBeam = v141;
      if ( v91 >= 0x14 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\array\\fixed_array.h", 87, ASSERT_TYPE_ASSERT, "( index < size() )", (const char *)&queryFormat, "index < size()") )
          __debugbreak();
        v99 = hand;
      }
      _RCX = p_m_target - 104;
      _RDX = &pelletData.assistTarget.m_hitResults;
      v107 = 6i64;
      do
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rcx]
          vmovups ymmword ptr [rdx], ymm0
          vmovups ymm0, ymmword ptr [rcx+20h]
          vmovups ymmword ptr [rdx+20h], ymm0
          vmovups ymm0, ymmword ptr [rcx+40h]
          vmovups ymmword ptr [rdx+40h], ymm0
          vmovups xmm0, xmmword ptr [rcx+60h]
          vmovups xmmword ptr [rdx+60h], xmm0
        }
        _RDX = (ConeTargetHitResults *)((char *)_RDX + 128);
        __asm
        {
          vmovups xmm1, xmmword ptr [rcx+70h]
          vmovups xmmword ptr [rdx-10h], xmm1
        }
        _RCX += 16;
        --v107;
      }
      while ( v107 );
      __asm
      {
        vmovups ymm0, ymmword ptr [rcx]
        vmovups ymmword ptr [rdx], ymm0
        vmovups xmm0, xmmword ptr [rcx+20h]
        vmovups xmmword ptr [rdx+20h], xmm0
      }
      *(_QWORD *)&_RDX->hits[0].tagName = _RCX[6];
      _RDX->hits[0].modelIndex = *((_DWORD *)_RCX + 14);
      pelletData.assistTarget.m_target = *p_m_target;
      __asm
      {
        vmovss  xmm0, [rbp+4760h+var_42D8]
        vmovss  dword ptr [rbp+4760h+pelletData.tracerStart], xmm0
        vmovss  xmm1, [rbp+4760h+var_42D4]
        vmovss  dword ptr [rbp+4760h+pelletData.tracerStart+4], xmm1
        vmovss  xmm0, [rbp+4760h+var_42D0]
        vmovss  dword ptr [rbp+4760h+pelletData.tracerStart+8], xmm0
      }
      pelletData.shouldSpawnTracer = CgWeaponSystem::ShouldSpawnTracer(this, v93->nextState.number, &perks, v99, _R15, isAlternate, 1);
      v118 = DCONST_DVARBOOL_bg_ballisticsDoClientImpactFx;
      if ( !DCONST_DVARBOOL_bg_ballisticsDoClientImpactFx && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_ballisticsDoClientImpactFx") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v118);
      if ( v118->current.enabled || (pelletData.shouldPredictCharacterImpacts = 0, v157 == 41) )
        pelletData.shouldPredictCharacterImpacts = 1;
      pelletData.localClientNum = this->m_localClientNum;
      CG_GameInterface_SetSimulateBulletFirePelletData(pelletData.localClientNum, &pelletData, ps);
      if ( !CgSimBulletFirePellet_AreWorkersEnabled() || !CgSimBulletFirePellet_TryToPrepareWorker(this->m_localClientNum, &pelletData) )
        CgWeaponSystem::SimulateBulletFirePellet(this, &pelletData, 0);
      pelletData.assistTarget.__vftable = (CAssistTarget_vtbl *)&CAssistTarget::`vftable';
      ConeTargetInfo::~ConeTargetInfo(&pelletData.assistTarget);
      ++v90;
      ++v91;
      p_m_target += 106;
    }
    while ( (__int64)v91 < (__int64)v153 );
  }
  PhysPerfTrack_BulletClientTimeStop();
  Sys_ProfEndNamedEvent();
  `eh vector destructor iterator'(&ptr, 0x350ui64, 0x14ui64, (void (__fastcall *)(void *))CAssistTarget::~CAssistTarget);
LABEL_111:
  _R11 = &v170;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
  }
}

/*
==============
CgWeaponSystem::SimulateBulletFirePellet
==============
*/
void CgWeaponSystem::SimulateBulletFirePellet(CgWeaponSystem *this, SimulateBulletFirePelletData *pelletFireData, bool shouldDeferEvents)
{
  centity_t *v17; 
  const Weapon *p_weapon; 
  bool isAlternate; 
  scr_string_t fallbackTagName; 
  scr_string_t primaryTagName; 
  CAssistTarget *p_assistTarget; 
  LocalClientNum_t localClientNum; 
  const playerState_s *v30; 
  int v31; 
  unsigned __int16 *p_linkedEnt; 
  int v33; 
  __int64 m_localClientNum; 
  __int64 p_perks; 
  bool v42; 
  bool v43; 
  int v55; 
  char v56; 
  char v57; 
  ConeTargetHitResults *HitResults; 
  ConeTargetHitResults *v59; 
  LocalClientNum_t v60; 
  CgBallistics *System; 
  centity_t *v62; 
  bool v63; 
  bool IsBeamStyleTracer; 
  bool ShouldSimulateBulletFire; 
  ConeTargetHitResults *v72; 
  ConeTargetHitResults *v73; 
  ConeTargetHitResults *v76; 
  int v78; 
  scr_string_t tagName; 
  LocalClientNum_t v81; 
  unsigned int v82; 
  centity_t *Entity; 
  LocalClientNum_t v86; 
  centity_t *v87; 
  const DObj *ClientDObj; 
  const DObj *v89; 
  int fmt; 
  centity_t *owner; 
  bitarray<64> *r_attackerPerks; 
  float r_attackerPerksa; 
  float isPlayerWeaponView; 
  float upDir; 
  int ricochetCount; 
  int ricochetCounta; 
  float shouldSpawnTracer; 
  bool v110; 
  unsigned __int8 inOutIndex; 
  bool targetAssistBeam; 
  bool v113; 
  bool v114; 
  bool targetAssistDirectDamage; 
  bool targetAssistOnlyTargets; 
  bool shouldPredictCharacterImpacts; 
  bool ignoreTargetEvaluation; 
  int targetCount; 
  scr_string_t autoTargetedEntTag; 
  int shotIndex; 
  PlayerHandIndex hand; 
  int autoTargetedEntNum; 
  int bulletId; 
  unsigned int randSeed; 
  int modelIndex; 
  centity_t *inflictorEnt; 
  TagPair tagPair; 
  CTargetEvaluator *targetEvaluator; 
  vec3_t *start; 
  vec3_t bulletEndPos; 
  vec3_t out; 
  BulletFireParams outBP; 
  tmat43_t<vec3_t> outTagMat; 
  char v135; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
    vmovaps xmmword ptr [rax-88h], xmm10
    vmovaps xmmword ptr [rax-98h], xmm11
    vmovaps xmmword ptr [rax-0A8h], xmm12
    vmovaps xmmword ptr [rax-0B8h], xmm13
    vmovaps xmmword ptr [rax-0C8h], xmm14
    vmovaps xmmword ptr [rax-0D8h], xmm15
  }
  _RBX = pelletFireData;
  v114 = shouldDeferEvents;
  Sys_ProfBeginNamedEvent(0xFF44CCFF, "SimulateBulletFirePellet");
  if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24051, ASSERT_TYPE_ASSERT, "(pelletFireData)", (const char *)&queryFormat, "pelletFireData") )
    __debugbreak();
  v17 = _RBX->inflictorEnt;
  p_weapon = &_RBX->weapon;
  isAlternate = _RBX->isAlternate;
  fallbackTagName = _RBX->fallbackTagName;
  primaryTagName = _RBX->primaryTagName;
  bulletId = _RBX->bulletId;
  shotIndex = _RBX->shotIndex;
  modelIndex = _RBX->knownHitClientNum;
  inflictorEnt = v17;
  v110 = isAlternate;
  TagPair::TagPair(&tagPair, primaryTagName, fallbackTagName);
  p_assistTarget = &_RBX->assistTarget;
  localClientNum = _RBX->localClientNum;
  __asm
  {
    vmovss  xmm10, dword ptr [rbx+64h]
    vmovss  xmm15, dword ptr [rbx+0A8h]
    vmovss  xmm11, dword ptr [rbx+0ACh]
    vmovss  xmm12, dword ptr [rbx+0B0h]
    vmovss  xmm13, dword ptr [rbx+0B4h]
    vmovss  xmm14, dword ptr [rbx+0B8h]
  }
  randSeed = _RBX->randSeed;
  v113 = _RBX->isPlayerWeaponView;
  autoTargetedEntTag = _RBX->meansOfDeath;
  *(_QWORD *)out.v = &_RBX->attackerPerks;
  hand = _RBX->hand;
  ignoreTargetEvaluation = _RBX->ignoreTargetEvaluation;
  targetEvaluator = _RBX->targetEvaluator;
  targetCount = _RBX->targetCount;
  targetAssistOnlyTargets = _RBX->targetAssistOnlyTargets;
  targetAssistDirectDamage = _RBX->targetAssistDirectDamage;
  targetAssistBeam = _RBX->targetAssistBeam;
  start = &_RBX->tracerStart;
  inOutIndex = _RBX->shouldSpawnTracer;
  shouldPredictCharacterImpacts = _RBX->shouldPredictCharacterImpacts;
  if ( this->m_localClientNum != localClientNum && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24101, ASSERT_TYPE_ASSERT, "(m_localClientNum == pelletFireData->localClientNum)", "%s\n\tLocalClientNum mismatch between worker data (%i) and worker thread (%i).", "m_localClientNum == pelletFireData->localClientNum", localClientNum, this->m_localClientNum) )
    __debugbreak();
  *(_QWORD *)bulletEndPos.v = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  v30 = (const playerState_s *)(*(_QWORD *)bulletEndPos.v + 8i64);
  if ( !v113 )
    v30 = NULL;
  memset_0(&outBP, 0, sizeof(outBP));
  outBP.weaponEntIndex = 2046;
  outBP.ignoreHitEntCount = 0;
  BG_AddIgnoreEntToBP(&outBP, v17->nextState.number);
  if ( v30 && v30->numViewLinkedEnts > 0 )
  {
    v31 = 0;
    p_linkedEnt = &v30->viewLinkedEntityData[0].linkedEnt;
    do
    {
      BG_AddIgnoreEntToBP(&outBP, *p_linkedEnt);
      ++v31;
      p_linkedEnt += 16;
    }
    while ( v31 < v30->numViewLinkedEnts );
    isAlternate = v110;
    v17 = inflictorEnt;
  }
  if ( v17->nextState.eType == ET_TURRET )
  {
    v33 = v17->nextState.lerp.u.anonymous.data[6];
    if ( v33 != 2047 )
      BG_AddIgnoreEntToBP(&outBP, v33);
  }
  CG_GameInterface_SimulateBulletFirePellet_AddIgnoreEnts(_RBX, v30, &outBP);
  m_localClientNum = this->m_localClientNum;
  if ( !CgWeaponMap::ms_instance[m_localClientNum] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  *(double *)&_XMM0 = BG_GetADSDamageRangeScale(CgWeaponMap::ms_instance[m_localClientNum], v30, &_RBX->weapon, isAlternate);
  __asm
  {
    vmovss  xmm9, cs:__real@3f800000
    vmovaps xmm8, xmm0
  }
  if ( !v30 )
  {
    p_perks = 4464i64;
    goto LABEL_27;
  }
  p_perks = (__int64)&v30->perks;
  if ( !BG_HasPerk(&v30->perks, 0x18u) )
  {
LABEL_27:
    __asm { vmovaps xmm7, xmm9 }
    goto LABEL_28;
  }
  _RSI = DCONST_DVARFLT_perk_longerRangeScale;
  if ( !DCONST_DVARFLT_perk_longerRangeScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "perk_longerRangeScale") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RSI);
  __asm { vmovss  xmm7, dword ptr [rsi+28h] }
LABEL_28:
  if ( v30 && BG_HasPerk((const bitarray<64> *)p_perks, 0x1Cu) )
  {
    _RDI = DVARFLT_perk_bulletPenetrationMultiplier;
    if ( !DVARFLT_perk_bulletPenetrationMultiplier && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "perk_bulletPenetrationMultiplier") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RDI);
    __asm { vmovss  xmm6, dword ptr [rdi+28h] }
  }
  else
  {
    __asm { vmovaps xmm6, xmm9 }
  }
  if ( v30 )
  {
    v42 = v30->weapState[hand].weaponFiredAtMaxCharge == 0;
    v43 = v110;
    if ( !v42 && BG_IsChargeShotWeapon(&_RBX->weapon, v110) )
    {
      *(double *)&_XMM0 = BG_WeaponCharge_GetFireAtMaxDamageMultiplier(&_RBX->weapon, v110);
      __asm { vmovaps xmm1, xmm0 }
      goto LABEL_41;
    }
  }
  else
  {
    v43 = v110;
  }
  __asm { vmovaps xmm1, xmm9 }
LABEL_41:
  __asm { vmovss  xmm2, dword ptr [rbx+68h] }
  _RDI = &_RBX->orient.axis;
  __asm
  {
    vmulss  xmm0, xmm7, xmm8
    vmovss  [rbp+1A0h+outBP.rangeScale], xmm0
    vmovss  xmm0, dword ptr [rdi]
    vmovss  dword ptr [rbp+1A0h+outBP.dir], xmm0
    vmovss  xmm0, dword ptr [rdi+8]
    vmovss  [rbp+1A0h+outBP.chargedDamageMultiplier], xmm1
    vmovss  xmm1, dword ptr [rdi+4]
    vmovss  dword ptr [rbp+1A0h+outBP.dir+8], xmm0
    vmovss  xmm0, dword ptr [rbx+70h]
    vmovss  [rbp+1A0h+outBP.penetrationMultiplier], xmm6
    vmovss  dword ptr [rbp+1A0h+outBP.dir+4], xmm1
    vmovss  xmm1, dword ptr [rbx+6Ch]
  }
  outBP.methodOfDeath = autoTargetedEntTag;
  __asm
  {
    vmovss  dword ptr [rbp+1A0h+outBP.start], xmm2
    vmovss  dword ptr [rbp+1A0h+outBP.initialPos], xmm2
  }
  autoTargetedEntNum = 2047;
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vmovaps xmm2, xmm10; range
  }
  autoTargetedEntTag = 0;
  __asm
  {
    vmovss  dword ptr [rbp+1A0h+outBP.start+8], xmm0
    vmovss  dword ptr [rbp+1A0h+outBP.initialPos+8], xmm0
    vmovss  [rbp+1A0h+outBP.damageMultiplier], xmm9
    vmovss  dword ptr [rbp+1A0h+outBP.start+4], xmm1
    vmovss  dword ptr [rbp+1A0h+outBP.initialPos+4], xmm1
    vmovss  [rbp+1A0h+outBP.travelDistance], xmm6
  }
  v42 = !CG_GameInterface_CalcBulletEndPos(_RBX, &outBP.start, *(float *)&_XMM2, &outBP.dir, &outBP.end);
  v55 = targetCount;
  if ( !v42 )
    goto LABEL_77;
  v56 = targetAssistDirectDamage;
  v57 = targetAssistBeam;
  if ( shotIndex < targetCount && !targetAssistDirectDamage && !targetAssistBeam )
  {
    if ( !targetEvaluator )
    {
LABEL_75:
      __asm
      {
        vmovss  [rsp+2D0h+ricochetCount], xmm10
        vmovss  dword ptr [rsp+2D0h+isPlayerWeaponView], xmm14
        vmovss  dword ptr [rsp+2D0h+r_attackerPerks], xmm13
        vmovaps xmm2, xmm12; spreadOuter
        vmovaps xmm1, xmm11; spreadInner
      }
      CG_Weapons_SimulateBulletFire_EndPos(&randSeed, *(const float *)&_XMM1, *(const float *)&_XMM2, &outBP.start, &outBP.end, &outBP.dir, r_attackerPerksa, isPlayerWeaponView, _RBX->orient.axis.m, &_RBX->orient.axis.m[1], &_RBX->orient.axis.m[2], *(const float *)&ricochetCount);
      goto LABEL_76;
    }
    if ( ignoreTargetEvaluation )
      goto LABEL_48;
    __asm { vmovss  dword ptr [rsp+2D0h+fmt], xmm10 }
    if ( ((unsigned __int8 (__fastcall *)(CTargetEvaluator *, _QWORD, CAssistTarget *, vec3_t *, int, vec3_t *, vec3_t *))targetEvaluator->EvaluateTarget)(targetEvaluator, (unsigned int)this->m_localClientNum, &_RBX->assistTarget, &outBP.start, fmt, &outBP.end, &outBP.dir) )
    {
LABEL_48:
      HitResults = ConeTargetInfo::GetHitResults(&_RBX->assistTarget);
      if ( !ConeTargetHitResults::GetFirstVisibleHit(HitResults) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24186, ASSERT_TYPE_ASSERT, "(assistTarget->GetHitResults().GetFirstVisibleHit())", (const char *)&queryFormat, "assistTarget->GetHitResults().GetFirstVisibleHit()") )
        __debugbreak();
      autoTargetedEntNum = p_assistTarget->GetEntNum(&_RBX->assistTarget);
      v59 = ConeTargetInfo::GetHitResults(&_RBX->assistTarget);
      autoTargetedEntTag = ConeTargetHitResults::GetFirstVisibleHit(v59)->tagName;
LABEL_52:
      if ( targetAssistOnlyTargets && shotIndex && shotIndex >= targetCount )
        goto LABEL_103;
LABEL_55:
      v60 = this->m_localClientNum;
      __asm { vmovss  [rbp+1A0h+outBP.damageMultiplier], xmm9 }
      System = CgBallistics::GetSystem(v60);
      if ( !System && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24284, ASSERT_TYPE_ASSERT, "(ballisticSystem)", (const char *)&queryFormat, "ballisticSystem") )
        __debugbreak();
      v62 = inflictorEnt;
      v63 = System->ShouldFireBallisticBullet(System, &_RBX->weapon, v43, inflictorEnt->nextState.number);
      IsBeamStyleTracer = BG_IsBeamStyleTracer(&_RBX->weapon, v43);
      ShouldSimulateBulletFire = CG_Weapons_ShouldSimulateBulletFire((const LocalClientNum_t)this->m_localClientNum, &outBP, v62, IsBeamStyleTracer);
      if ( v113 || ShouldSimulateBulletFire )
      {
        if ( BG_WeaponBulletFire_ShouldRicochet(_RBX->attackerPerks, &_RBX->weapon, v43) )
        {
          if ( v63 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24293, ASSERT_TYPE_ASSERT, "(!fireBallistic)", "%s\n\tBallistic trajectory cannot be enabled for richocet penetration type!", "!fireBallistic") )
            __debugbreak();
          __asm { vmovss  dword ptr [rsp+2D0h+upDir], xmm10 }
          CgWeaponSystem::SimulateBulletFire_Ricochet(this, &outBP, bulletId, &_RBX->weapon, v43, v62, *(const bitarray<64> **)out.v, v113, hand, tagPair, upDir, 0, inOutIndex, v114);
        }
        else if ( v63 )
        {
          if ( autoTargetedEntNum != 2047 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24313, ASSERT_TYPE_ASSERT, "(autoTargetedEntNum == ENTITYNUM_NONE)", "%s\n\tBallistic trajectory cannot be enabled for weapons with target assist!", "autoTargetedEntNum == ENTITYNUM_NONE") )
            __debugbreak();
          CgBallistics::FireBallistics(System, bulletId, &_RBX->weapon, v43, v113, inOutIndex, hand, randSeed, &outBP, &_RBX->orient.axis.m[1], &_RBX->orient.axis.m[2], v62->nextState.number, &_RBX->attackerPerks, &_RBX->tracerStart, &tagPair, *(_DWORD *)(*(_QWORD *)bulletEndPos.v + 26092i64), shouldPredictCharacterImpacts);
        }
        else
        {
          __asm { vmovss  [rsp+2D0h+ricochetCount], xmm15 }
          CgWeaponSystem::SimulateBulletFire_DoBulletPathSim(this, &outBP, bulletId, &_RBX->weapon, v43, v62, &_RBX->attackerPerks, modelIndex, autoTargetedEntNum, autoTargetedEntTag, &_RBX->tracerStart, *(float *)&ricochetCounta, v113, hand, tagPair, shotIndex, inOutIndex, 1, v114, shouldPredictCharacterImpacts, &bulletEndPos);
        }
      }
      goto LABEL_103;
    }
    v55 = targetCount;
    v56 = targetAssistDirectDamage;
    v57 = targetAssistBeam;
  }
  if ( !targetEvaluator || !v56 && !targetAssistOnlyTargets && !v57 )
    goto LABEL_75;
  __asm
  {
    vmulss  xmm1, xmm10, dword ptr [rbp+1A0h+outBP.dir]
    vaddss  xmm2, xmm1, dword ptr [rbp+1A0h+outBP.start]
    vmulss  xmm1, xmm10, dword ptr [rbp+1A0h+outBP.dir+4]
    vmovss  dword ptr [rbp+1A0h+outBP.end], xmm2
    vaddss  xmm2, xmm1, dword ptr [rbp+1A0h+outBP.start+4]
    vmulss  xmm1, xmm10, dword ptr [rbp+1A0h+outBP.dir+8]
    vmovss  dword ptr [rbp+1A0h+outBP.end+4], xmm2
    vaddss  xmm2, xmm1, dword ptr [rbp+1A0h+outBP.start+8]
    vmovss  dword ptr [rbp+1A0h+outBP.end+8], xmm2
  }
  if ( shotIndex >= v55 )
    goto LABEL_77;
  v72 = ConeTargetInfo::GetHitResults(&_RBX->assistTarget);
  if ( !ConeTargetHitResults::GetFirstVisibleHit(v72) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24198, ASSERT_TYPE_ASSERT, "(assistTarget->GetHitResults().GetFirstVisibleHit())", (const char *)&queryFormat, "assistTarget->GetHitResults().GetFirstVisibleHit()") )
    __debugbreak();
  autoTargetedEntNum = p_assistTarget->GetEntNum(&_RBX->assistTarget);
  v73 = ConeTargetInfo::GetHitResults(&_RBX->assistTarget);
  autoTargetedEntTag = ConeTargetHitResults::GetFirstVisibleHit(v73)->tagName;
LABEL_76:
  v55 = targetCount;
LABEL_77:
  if ( !targetAssistBeam )
    goto LABEL_52;
  if ( shotIndex && !v55 )
    goto LABEL_103;
  if ( v55 <= 0 )
    goto LABEL_55;
  if ( shotIndex < v55 && BG_IsBeamStyleTracer(&_RBX->weapon, v43) )
  {
    v76 = ConeTargetInfo::GetHitResults(&_RBX->assistTarget);
    _RDI = ConeTargetHitResults::GetFirstVisibleHit(v76);
    if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24247, ASSERT_TYPE_ASSERT, "(coneTargetHitInfo)", (const char *)&queryFormat, "coneTargetHitInfo") )
      __debugbreak();
    v78 = p_assistTarget->GetEntNum(&_RBX->assistTarget);
    __asm { vmovss  xmm0, dword ptr [rdi] }
    tagName = _RDI->tagName;
    v81 = this->m_localClientNum;
    v82 = v78;
    __asm
    {
      vmovss  dword ptr [rbp+1A0h+bulletEndPos], xmm0
      vmovss  xmm1, dword ptr [rdi+4]
      vmovss  dword ptr [rbp+1A0h+bulletEndPos+4], xmm1
      vmovss  xmm0, dword ptr [rdi+8]
      vmovss  dword ptr [rbp+1A0h+bulletEndPos+8], xmm0
    }
    Entity = CG_GetEntity(v81, v78);
    if ( (Entity->flags & 1) != 0 )
      CgWeaponSystem::SimulateImpactEffectForBeamWeapons(this, inflictorEnt->nextState.number, p_weapon, v110, Entity, &outBP, &bulletEndPos, v114, &bulletEndPos);
    if ( v82 >= 0x800 )
    {
      LODWORD(r_attackerPerks) = 2048;
      LODWORD(owner) = v82;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24009, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", owner, r_attackerPerks) )
        __debugbreak();
    }
    v86 = this->m_localClientNum;
    __asm
    {
      vmovss  dword ptr [rbp+1A0h+out], xmm6
      vmovss  dword ptr [rbp+1A0h+out+4], xmm6
      vmovss  dword ptr [rbp+1A0h+out+8], xmm6
    }
    v87 = CG_GetEntity(v86, v82);
    if ( (v87->flags & 1) != 0 )
    {
      ClientDObj = Com_GetClientDObj(v82, this->m_localClientNum);
      v89 = ClientDObj;
      if ( ClientDObj )
      {
        inOutIndex = -2;
        if ( DObjGetBoneIndexInternal_66(ClientDObj, tagName, &inOutIndex, &modelIndex) )
        {
          if ( CG_DObjGetWorldBoneMatrix(&v87->pose, v89, inOutIndex, (tmat33_t<vec3_t> *)&outTagMat, &outTagMat.m[3]) )
            MatrixTransposeTransformVector43(&bulletEndPos, &outTagMat, &out);
        }
      }
    }
    __asm { vmovss  dword ptr [rsp+2D0h+shouldSpawnTracer], xmm15 }
    CgWeaponSystem::TryCG_TrackingLaserBeamAdd(this, v114, (const LocalClientNum_t)this->m_localClientNum, start, &outBP.end, inflictorEnt, p_weapon, v110, shotIndex, v82, tagName, &out, shouldSpawnTracer);
  }
LABEL_103:
  Sys_ProfEndNamedEvent();
  _R11 = &v135;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
    vmovaps xmm13, xmmword ptr [r11-80h]
    vmovaps xmm14, xmmword ptr [r11-90h]
    vmovaps xmm15, xmmword ptr [r11-0A0h]
  }
}

/*
==============
CgWeaponSystem::SimulateBulletFire_DoBulletPathSim
==============
*/
bool CgWeaponSystem::SimulateBulletFire_DoBulletPathSim(CgWeaponSystem *this, BulletFireParams *bp, const int bulletId, const Weapon *weapon, bool isAlternate, centity_t *inflictorEnt, const bitarray<64> *r_attackerPerks, const int knownHitClientNum, const int autoTargetedEntNum, const scr_string_t autoTargetedEntTag, const vec3_t *tracerStart, float aimSpreadAmount, bool isPlayerWeaponView, PlayerHandIndex hand, const TagPair tagPair, const int shotIndex, bool shouldSpawnTracer, bool shouldSpawnExitTracers, bool shouldDeferEvents, bool forceClientSideImpactFx, vec3_t *outLastBulletPos)
{
  const Weapon *r_weapon; 
  cg_t *LocalClientGlobals; 
  const dvar_t *v35; 
  cg_t *v36; 
  bool v37; 
  const dvar_t *v54; 
  bool v55; 
  const dvar_t *v56; 
  const centity_t *KnownHitClientEntity; 
  LocalClientNum_t m_localClientNum; 
  bool v59; 
  bool v60; 
  unsigned __int16 EntityHitId; 
  unsigned int ScriptableHitId; 
  const dvar_t *v63; 
  vec3_t *p_hitPos; 
  LocalClientNum_t v67; 
  centity_t *v76; 
  unsigned int v78; 
  entityType_s eType; 
  const char *EntityTypeName; 
  int v82; 
  bool result; 
  int v84; 
  int v85; 
  vec3_t *meansOfDeath; 
  int surfaceFlags; 
  int number; 
  const entityState_t *v92; 
  unsigned __int16 v93; 
  char v97; 
  bool v98; 
  bool IsCharacterEntity; 
  char v102; 
  bool v103; 
  bool HasPerk; 
  const dvar_t *v105; 
  bool IsBeamStyleTracer; 
  bool v111; 
  const dvar_t *v112; 
  bool v113; 
  vec3_t *p_end; 
  bool (__fastcall *CheckFirePenetrateStop)(CgWeaponSystem *, const centity_t *, const centity_t *, bool); 
  centity_t *Entity; 
  bool v150; 
  bool v151; 
  bool IsHitSurfaceTransparent; 
  int v153; 
  int v164; 
  unsigned __int16 v165; 
  unsigned int v166; 
  unsigned __int16 v170; 
  char v192; 
  bool v193; 
  const cg_t *v210; 
  int v212; 
  int v214; 
  unsigned int methodOfDeath; 
  int v216; 
  unsigned int v217; 
  unsigned __int16 v218; 
  meansOfDeath_t v219; 
  unsigned __int16 v220; 
  unsigned __int16 v227; 
  bool isBallistics; 
  bool fmt; 
  int spawnDelay; 
  bool v245; 
  unsigned __int8 v246; 
  bool v247; 
  bool v248; 
  unsigned __int16 v249; 
  bool v250; 
  int entityIndex; 
  unsigned __int16 entityIndexa; 
  int triggerTime; 
  int triggerTimea; 
  unsigned int targetScriptableIndex; 
  unsigned int targetScriptableIndexa; 
  cg_t *cgameGlob; 
  unsigned int impactEffects; 
  unsigned int v261; 
  vec3_t tagOffset; 
  vec3_t initialBulletPos; 
  BulletTraceResults outResults; 
  BulletTraceResults trace; 
  BulletFireParams v266; 

  __asm
  {
    vmovaps [rsp+3A0h+var_C0], xmm13
    vmovaps [rsp+3A0h+var_D0], xmm14
    vmovaps [rsp+3A0h+var_E0], xmm15
  }
  _R15 = bp;
  r_weapon = weapon;
  Sys_ProfBeginNamedEvent(0xFF44CCFF, "SimulateBulletFire_Internal");
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  v35 = DCONST_DVARBOOL_cg_debugBullets;
  cgameGlob = LocalClientGlobals;
  v36 = LocalClientGlobals;
  if ( !DCONST_DVARBOOL_cg_debugBullets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_debugBullets") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v35);
  if ( v35->current.enabled && _R15->isBallistics )
    Com_Printf(14, "CgWeaponSystem::SimulateBulletFire_DoBulletPathSim: Client Time: %d Ballistics Time: %d\n", (unsigned int)v36->time, (unsigned int)_R15->ballisticsTickStartTime);
  if ( !_R15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24378, ASSERT_TYPE_ASSERT, "(bp)", (const char *)&queryFormat, "bp") )
    __debugbreak();
  if ( !inflictorEnt && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24379, ASSERT_TYPE_ASSERT, "(inflictorEnt)", (const char *)&queryFormat, "inflictorEnt") )
    __debugbreak();
  v37 = isAlternate;
  if ( BG_GetWeaponType(r_weapon, isAlternate) != WEAPTYPE_BULLET && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24380, ASSERT_TYPE_ASSERT, "(CG_Weapons_IsBulletWeapon( weapon, isAlternate ))", (const char *)&queryFormat, "CG_Weapons_IsBulletWeapon( weapon, isAlternate )") )
    __debugbreak();
  v103 = !_R15->isBallistics;
  _RAX = &_R15->end;
  __asm
  {
    vmovss  xmm1, dword ptr [r15+68h]
    vmovss  xmm0, dword ptr [rax]
    vmovss  xmm2, dword ptr [r15+6Ch]
    vmovss  xmm4, dword ptr [r15+70h]
    vsubss  xmm3, xmm0, xmm1
    vmovss  xmm0, dword ptr [rax+8]
    vmovss  dword ptr [rbp+290h+initialBulletPos+4], xmm2
    vmovss  dword ptr [rbp+290h+initialBulletPos], xmm1
    vmovss  xmm1, dword ptr [rax+4]
    vsubss  xmm2, xmm1, xmm2
    vmulss  xmm2, xmm2, xmm2
    vmovss  dword ptr [rbp+290h+initialBulletPos+8], xmm4
    vsubss  xmm4, xmm0, xmm4
    vmulss  xmm1, xmm3, xmm3
    vaddss  xmm3, xmm2, xmm1
    vmulss  xmm0, xmm4, xmm4
    vaddss  xmm2, xmm3, xmm0
    vsqrtss xmm15, xmm2, xmm2
  }
  if ( v103 )
  {
    v248 = shouldDeferEvents;
  }
  else
  {
    v54 = DCONST_DVARBOOL_bg_ballisticsSyncImpactFx;
    if ( !DCONST_DVARBOOL_bg_ballisticsSyncImpactFx && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_ballisticsSyncImpactFx") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v54);
    v103 = !v54->current.enabled;
    v55 = 1;
    v56 = DCONST_DVARINT_bg_ballisticsSimTimeStepMs;
    if ( v103 )
      v55 = shouldDeferEvents;
    v248 = v55;
    if ( !DCONST_DVARINT_bg_ballisticsSimTimeStepMs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_ballisticsSimTimeStepMs") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v56);
    _R15->ballisticsTickEndTime = v56->current.integer + _R15->ballisticsTickStartTime;
  }
  KnownHitClientEntity = CG_Weapons_SimulateBulletFire_GetKnownHitClientEntity((const LocalClientNum_t)this->m_localClientNum, knownHitClientNum);
  m_localClientNum = this->m_localClientNum;
  if ( KnownHitClientEntity )
    v59 = CG_Weapons_SimulateBulletFire_FakeTrace(m_localClientNum, _R15, KnownHitClientEntity, &outResults);
  else
    v59 = CG_Weapons_BulletTrace(m_localClientNum, _R15, r_weapon, isAlternate, inflictorEnt, &outResults, 0, NULL, 0);
  v245 = v59;
  v60 = v59;
  EntityHitId = Trace_GetEntityHitId(&outResults.trace);
  if ( EntityHitId >= 0x800u )
    EntityHitId = 2047;
  v249 = EntityHitId;
  ScriptableHitId = Trace_GetScriptableHitId(&outResults.trace);
  v63 = DCONST_DVARBOOL_cg_debugBullets;
  targetScriptableIndex = ScriptableHitId;
  if ( !DCONST_DVARBOOL_cg_debugBullets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_debugBullets") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v63);
  if ( v63->current.enabled )
  {
    p_hitPos = &outResults.hitPos;
    if ( !v60 )
      p_hitPos = &_R15->end;
    CgWeaponSystem::AddDebugBulletLine(this, &_R15->start, p_hitPos);
  }
  CG_SND_VerifyTracerAndWhizbySpeeds(*r_attackerPerks, r_weapon, isAlternate);
  *(double *)&_XMM0 = CG_GetTracerSpeed(*r_attackerPerks, r_weapon, isAlternate);
  __asm
  {
    vxorps  xmm13, xmm13, xmm13
    vcomiss xmm0, xmm13
    vmovss  [rbp+290h+var_2D8], xmm0
  }
  if ( v102 | v103 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24431, ASSERT_TYPE_ASSERT, "(tracerSpeed > 0.0f)", (const char *)&queryFormat, "tracerSpeed > 0.0f") )
    __debugbreak();
  __asm { vxorps  xmm14, xmm14, xmm14 }
  if ( shouldSpawnTracer )
  {
    CgWeaponSystem::TrySpawnTracer(this, bulletId, v248, isPlayerWeaponView, inflictorEnt->nextState.number, r_attackerPerks, hand, tagPair, tracerStart, &outResults.hitPos, r_weapon, isAlternate, 0);
    __asm { vmovss  xmm14, dword ptr [r15+8Ch] }
  }
  if ( BG_IsBeamStyleTracer(r_weapon, isAlternate) )
  {
    v67 = this->m_localClientNum;
    if ( autoTargetedEntNum == 2047 )
    {
      if ( v248 )
      {
        _RAX = CgSimBulletFirePellet_GetQueueEntry();
        _RDX = _RAX;
        if ( _RAX )
        {
          _RAX->event.type = CgSimBulletFirePellet_EventType_LaserAdd;
          _RAX->event.hitEffect.sourceEntityNum = v67;
          _RAX->event.trackingLaserAdd.start = *tracerStart;
          __asm
          {
            vmovss  xmm0, dword ptr [rbp+290h+outResults.hitPos]
            vmovss  dword ptr [rax+18h], xmm0
            vmovss  xmm1, dword ptr [rbp+290h+outResults.hitPos+4]
            vmovss  dword ptr [rax+1Ch], xmm1
            vmovss  xmm0, dword ptr [rbp+290h+outResults.hitPos+8]
            vmovss  dword ptr [rax+20h], xmm0
          }
          _RAX->event.laserAdd.owner = inflictorEnt;
          __asm
          {
            vmovups ymm0, ymmword ptr [r13+0]
            vmovups ymmword ptr [rdx+30h], ymm0
            vmovups xmm1, xmmword ptr [r13+20h]
            vmovups xmmword ptr [rdx+50h], xmm1
            vmovsd  xmm0, qword ptr [r13+30h]
            vmovsd  qword ptr [rdx+60h], xmm0
          }
          _RAX->event.hitEffect.startPos.v[1] = *(float *)&r_weapon->weaponCamo;
          _RAX->event.trackingLaserAdd.weapon.attachmentVariationIndices[25] = isAlternate;
          _RAX->valid = 1;
        }
      }
      else
      {
        CG_LaserBeamAdd(v67, tracerStart, &outResults.hitPos, inflictorEnt, r_weapon, isAlternate, 0);
        v76 = inflictorEnt;
        if ( inflictorEnt )
          goto LABEL_54;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25250, ASSERT_TYPE_ASSERT, "(cent)", (const char *)&queryFormat, "cent") )
          __debugbreak();
      }
    }
    else
    {
      __asm
      {
        vmovss  xmm0, [rbp+290h+aimSpreadAmount]
        vmovss  [rsp+3A0h+spawnDelay], xmm0
      }
      *(_QWORD *)&tagOffset.y = 0i64;
      __asm { vmovss  dword ptr [rbp+290h+var_2B8], xmm13 }
      CgWeaponSystem::TryCG_TrackingLaserBeamAdd(this, v248, v67, tracerStart, &outResults.hitPos, inflictorEnt, r_weapon, isAlternate, shotIndex, autoTargetedEntNum, autoTargetedEntTag, &tagOffset, *(const float *)&spawnDelay);
    }
  }
  v76 = inflictorEnt;
LABEL_54:
  if ( v245 && _R15->methodOfDeath == MOD_EXPLOSIVE_BULLET )
  {
    v78 = 1;
    if ( !BG_IsCharacterEntity(&v76->nextState) )
    {
      eType = inflictorEnt->nextState.eType;
      if ( eType != ET_HELICOPTER )
      {
        EntityTypeName = BG_GetEntityTypeName(eType);
        Com_PrintWarning(17, "WARNING: Explosive bullets fired by unsupported entity '%i' of type '%s'.\n", (unsigned int)inflictorEnt->nextState.number, EntityTypeName);
      }
    }
  }
  else
  {
    v78 = 0;
  }
  fmt = _R15->isBallistics;
  __asm { vmovaps xmm2, xmm15; fullTraceLength }
  if ( !v245 )
  {
    v82 = CG_CalcBallisticBulletEffectTime(cgameGlob, &initialBulletPos, *(double *)&_XMM2, &_R15->end, fmt);
    *outLastBulletPos = _R15->end;
    CgWeaponSystem::TrySimulateBulletFire_MissEffect(this, v82, v248, inflictorEnt->nextState.number, r_weapon, isAlternate, &_R15->initialPos, &_R15->start, &outResults.hitPos, (outResults.trace.surfaceFlags >> 19) & 0x3F);
    Sys_ProfEndNamedEvent();
    result = 1;
    goto LABEL_150;
  }
  v84 = CG_CalcBallisticBulletEffectTime(cgameGlob, &initialBulletPos, *(double *)&_XMM2, &outResults.hitPos, fmt);
  v85 = v84;
  triggerTime = v84;
  if ( _R15->isBallistics )
    _R15->ballisticsTickEndTime = v84;
  meansOfDeath = outLastBulletPos;
  __asm { vmovss  xmm0, dword ptr [rbp+290h+outResults.hitPos] }
  surfaceFlags = outResults.trace.surfaceFlags;
  __asm
  {
    vmovss  xmm1, dword ptr [rbp+290h+outResults.hitPos+4]
    vmovss  dword ptr [rax], xmm0
    vmovss  xmm0, dword ptr [rbp+290h+outResults.hitPos+8]
    vmovss  dword ptr [rax+8], xmm0
    vmovss  dword ptr [rax+4], xmm1
    vmovaps [rsp+3A0h+var_50], xmm6
  }
  *(_QWORD *)tagOffset.v = &inflictorEnt->nextState;
  __asm
  {
    vmovaps [rsp+3A0h+var_60], xmm7
    vmovaps [rsp+3A0h+var_70], xmm8
  }
  number = inflictorEnt->nextState.number;
  LODWORD(meansOfDeath) = _R15->methodOfDeath;
  __asm
  {
    vmovaps [rsp+3A0h+var_80], xmm9
    vmovaps [rsp+3A0h+var_90], xmm10
    vmovaps [rsp+3A0h+var_A0], xmm11
    vmovaps [rsp+3A0h+var_B0], xmm12
  }
  CgWeaponSystem::TrySimulateBulletFire_HitEffect(this, v85, v248, number, v249, targetScriptableIndex, knownHitClientNum, r_weapon, isAlternate, &_R15->initialPos, &_R15->start, &outResults.hitPos, &outResults.trace.normal, (surfaceFlags >> 19) & 0x3F, (unsigned int)meansOfDeath, 0, outResults.trace.contents, forceClientSideImpactFx);
  CgWeaponSystem::TryBulletScriptableImpact(this, triggerTime, v248, (__int16)**(_WORD **)tagOffset.v, v249, r_weapon, isAlternate, (const meansOfDeath_t)_R15->methodOfDeath, &_R15->start, &outResults.hitPos, (const scr_string_t)outResults.trace.partName);
  if ( outResults.trace.startsolid )
    goto LABEL_148;
  v92 = *(const entityState_t **)tagOffset.v;
  if ( knownHitClientNum != -1 )
    Com_PrintWarning(17, "WARNING: Possible Client/Server Perk desync - Received HITCLIENT fire event from entity '%i' but the bullet did not explode as expected (%i).\n", (unsigned int)(__int16)**(_WORD **)tagOffset.v, v78);
  v93 = Trace_GetEntityHitId(&outResults.trace);
  if ( v93 >= 0x800u )
    v93 = 2047;
  entityIndex = v93;
  __asm
  {
    vmovss  xmm8, dword ptr cs:__xmm@80000000800000008000000080000000
    vmovss  xmm6, cs:__real@3c23d70a
    vmovss  xmm9, cs:__real@447a0000
  }
  targetScriptableIndexa = 0;
  v97 = 1;
  v98 = BG_GetPenetrateType(r_weapon, isAlternate) == PENETRATE_TYPE_MAXIMUM;
  v250 = v98;
  while ( 1 )
  {
    __asm { vmovss  xmm7, cs:__real@7f7fffff }
    if ( !v98 )
    {
      *(double *)&_XMM0 = BG_GetSurfacePenetrationDepth(r_weapon, v37, outResults.depthSurfaceType);
      __asm { vmovaps xmm7, xmm0 }
      IsCharacterEntity = BG_IsCharacterEntity(v92);
      v102 = 0;
      v103 = !IsCharacterEntity;
      if ( IsCharacterEntity )
      {
        HasPerk = BG_HasPerk(r_attackerPerks, 0x1Cu);
        v102 = 0;
        v103 = !HasPerk;
        if ( HasPerk )
        {
          v105 = DVARFLT_perk_bulletPenetrationMultiplier;
          if ( !DVARFLT_perk_bulletPenetrationMultiplier && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "perk_bulletPenetrationMultiplier") )
            __debugbreak();
          Dvar_CheckFrontendServerThread(v105);
          __asm { vmulss  xmm7, xmm7, dword ptr [rdi+28h] }
        }
      }
      __asm { vcomiss xmm7, xmm13 }
      if ( v102 | v103 )
        goto LABEL_153;
    }
    __asm
    {
      vmovss  xmm3, cs:__real@3e0a3d71; dist
      vmovss  xmm10, dword ptr [rbp+290h+outResults.hitPos]
      vmovss  xmm11, dword ptr [rbp+290h+outResults.hitPos+4]
      vmovss  xmm12, dword ptr [rbp+290h+outResults.hitPos+8]
    }
    if ( !BG_AdvanceTrace(_R15, &outResults.trace, &outResults.hitPos, *(float *)&_XMM3) )
      goto LABEL_153;
    IsBeamStyleTracer = BG_IsBeamStyleTracer(r_weapon, v37);
    if ( !CG_Weapons_ShouldSimulateBulletFire((const LocalClientNum_t)this->m_localClientNum, _R15, inflictorEnt, IsBeamStyleTracer) )
      goto LABEL_153;
    if ( !v97 || (v246 = 1, (outResults.trace.contents & 0x10) == 0) )
      v246 = 0;
    v111 = CG_Weapons_BulletTrace((const LocalClientNum_t)this->m_localClientNum, _R15, r_weapon, v37, inflictorEnt, &outResults, outResults.depthSurfaceType, NULL, 0);
    v112 = DCONST_DVARBOOL_cg_debugBullets;
    v113 = v111;
    v247 = v111;
    if ( !DCONST_DVARBOOL_cg_debugBullets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_debugBullets") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v112);
    if ( v112->current.enabled )
    {
      p_end = &outResults.hitPos;
      if ( !v113 )
        p_end = &_R15->end;
      CgWeaponSystem::AddDebugBulletLine(this, &_R15->start, p_end);
    }
    CheckFirePenetrateStop = this->CheckFirePenetrateStop;
    Entity = CG_GetEntity((const LocalClientNum_t)this->m_localClientNum, entityIndex);
    if ( CheckFirePenetrateStop(this, inflictorEnt, Entity, v246) )
    {
LABEL_153:
      Sys_ProfEndNamedEvent();
      result = 0;
      goto LABEL_149;
    }
    __asm { vmovups ymm0, ymmword ptr [r15] }
    _RCX = &v266;
    __asm
    {
      vmovups ymmword ptr [rcx], ymm0
      vmovups ymm0, ymmword ptr [r15+20h]
      vmovups ymmword ptr [rcx+20h], ymm0
      vmovups ymm0, ymmword ptr [r15+40h]
      vmovups ymmword ptr [rcx+40h], ymm0
      vmovups ymm0, ymmword ptr [r15+60h]
      vmovups ymmword ptr [rcx+60h], ymm0
      vmovups ymm0, ymmword ptr [r15+80h]
      vmovups ymmword ptr [rcx+80h], ymm0
    }
    BG_RemoveIgnoreEntFromBP(&v266, entityIndex);
    __asm
    {
      vmovss  xmm2, dword ptr [r15+80h]
      vmovss  xmm3, dword ptr [r15+84h]
      vmovss  xmm4, dword ptr [r15+88h]
      vxorps  xmm0, xmm2, xmm8
      vmovss  dword ptr [rbp+290h+var_190.dir], xmm0
      vxorps  xmm1, xmm3, xmm8
      vmovss  dword ptr [rbp+290h+var_190.dir+4], xmm1
      vmovss  xmm1, dword ptr [r15+74h]
      vmovss  dword ptr [rbp+290h+var_190.start], xmm1
      vmovss  xmm1, dword ptr [r15+7Ch]
      vmovss  dword ptr [rbp+290h+var_190.start+8], xmm1
      vmulss  xmm1, xmm3, xmm6
      vmovups ymm3, ymmword ptr [rbp+290h+outResults.trace.fraction]
      vmovups ymmword ptr [rbp+290h+trace.fraction], ymm3
      vxorps  xmm0, xmm4, xmm8
      vmovss  dword ptr [rbp+290h+var_190.dir+8], xmm0
      vmovss  xmm0, dword ptr [r15+78h]
      vmovss  dword ptr [rbp+290h+var_190.start+4], xmm0
      vmulss  xmm0, xmm2, xmm6
      vsubss  xmm2, xmm10, xmm0
      vsubss  xmm0, xmm11, xmm1
      vmovss  dword ptr [rbp+290h+var_190.end+4], xmm0
      vmovups ymm0, ymmword ptr [rbp+290h+outResults.trace.contents]
      vmovups ymmword ptr [rbp+290h+trace.contents], ymm0
      vmovups xmm0, xmmword ptr [rbp+290h+outResults.hitPos]
      vmovups [rbp+290h+var_1B0], xmm0
      vmovss  dword ptr [rbp+290h+var_190.end], xmm2
      vmulss  xmm2, xmm4, xmm6
      vsubss  xmm1, xmm12, xmm2
      vmovss  dword ptr [rbp+290h+var_190.end+8], xmm1
      vmovups ymm1, ymmword ptr [rbp+40h]
      vmovups ymmword ptr [rbp+290h+trace.allsolid], ymm1
      vmovsd  xmm1, qword ptr [rbp+290h+outResults.depthSurfaceType]
      vextractf128 xmm0, ymm3, 1
      vxorps  xmm0, xmm0, xmm8
      vmovsd  qword ptr [rbp+290h+surfaceType], xmm1
      vmovss  xmm1, dword ptr [rbp+290h+trace.normal+4]
      vxorps  xmm2, xmm1, xmm8
      vmovss  dword ptr [rbp+290h+trace.normal], xmm0
      vmovss  xmm0, dword ptr [rbp+290h+trace.normal+8]
      vxorps  xmm1, xmm0, xmm8
      vmovss  dword ptr [rbp+290h+trace.normal+8], xmm1
      vmovss  dword ptr [rbp+290h+trace.normal+4], xmm2
    }
    if ( v113 )
    {
      __asm { vmovaps xmm3, xmm6; dist }
      BG_AdvanceTrace(&v266, &trace.trace, &trace.hitPos, *(float *)&_XMM3);
    }
    v150 = CG_Weapons_BulletTrace((const LocalClientNum_t)this->m_localClientNum, &v266, r_weapon, v37, inflictorEnt, &trace, trace.depthSurfaceType, NULL, 0);
    v151 = v150 && trace.trace.allsolid || outResults.trace.startsolid && trace.trace.startsolid;
    triggerTimea = BG_IsHitSurfaceTransparent(&outResults.trace) ? 0x100 : 0;
    IsHitSurfaceTransparent = BG_IsHitSurfaceTransparent(&trace.trace);
    v153 = 4;
    if ( IsHitSurfaceTransparent )
      v153 = 260;
    impactEffects = v153;
    if ( v150 || v151 )
    {
      v170 = Trace_GetEntityHitId(&trace.trace);
      if ( v170 >= 0x800u )
        v170 = 2047;
      entityIndexa = v170;
      v261 = Trace_GetScriptableHitId(&trace.trace);
      __asm
      {
        vmovss  xmm8, dword ptr [rbp+290h+var_1B0+8]
        vmovss  xmm6, dword ptr [rbp+290h+var_1B0+4]
        vmovss  xmm9, dword ptr [rbp+290h+var_1B0]
      }
      if ( v151 )
      {
        __asm
        {
          vmovss  xmm0, dword ptr [rbp+290h+var_190.end]
          vsubss  xmm3, xmm0, dword ptr [rbp+290h+var_190.start]
          vmovss  xmm1, dword ptr [rbp+290h+var_190.end+4]
          vmovss  xmm0, dword ptr [rbp+290h+var_190.end+8]
          vsubss  xmm2, xmm1, dword ptr [rbp+290h+var_190.start+4]
          vsubss  xmm4, xmm0, dword ptr [rbp+290h+var_190.start+8]
          vmulss  xmm2, xmm2, xmm2
          vmulss  xmm1, xmm3, xmm3
          vmulss  xmm0, xmm4, xmm4
          vaddss  xmm3, xmm2, xmm1
          vaddss  xmm5, xmm3, xmm0
        }
      }
      else
      {
        __asm
        {
          vsubss  xmm0, xmm11, xmm6
          vmulss  xmm1, xmm0, xmm0
          vsubss  xmm2, xmm10, xmm9
          vmulss  xmm0, xmm2, xmm2
          vaddss  xmm2, xmm1, xmm0
          vsubss  xmm3, xmm12, xmm8
          vmulss  xmm1, xmm3, xmm3
          vaddss  xmm5, xmm2, xmm1
        }
      }
      v192 = 0;
      v193 = !v250;
      __asm
      {
        vsqrtss xmm0, xmm5, xmm5
        vmaxss  xmm10, xmm0, cs:__real@3f800000
      }
      if ( v250 )
      {
        __asm { vmovss  xmm2, dword ptr [r15+4Ch] }
      }
      else
      {
        v192 = 0;
        v193 = !v150;
        if ( v150 )
        {
          if ( BG_HasPerk(r_attackerPerks, 0x1Cu) )
          {
            *(double *)&_XMM0 = BG_GetSurfacePenetrationDepth(r_weapon, v37, trace.depthSurfaceType);
            __asm { vmovaps xmm6, xmm0 }
            Dvar_GetFloat_Internal_DebugName(DVARFLT_perk_bulletPenetrationMultiplier, "perk_bulletPenetrationMultiplier");
            __asm
            {
              vmulss  xmm1, xmm6, xmm0
              vminss  xmm7, xmm1, xmm7
            }
          }
          else
          {
            *(double *)&_XMM0 = BG_GetSurfacePenetrationDepth(r_weapon, v37, trace.depthSurfaceType);
            __asm { vminss  xmm7, xmm0, xmm7 }
          }
          __asm { vcomiss xmm7, xmm13 }
          if ( v192 | v193 )
            goto LABEL_153;
          __asm
          {
            vmovss  xmm8, dword ptr [rbp+290h+var_1B0+8]
            vmovss  xmm6, dword ptr [rbp+290h+var_1B0+4]
            vmovss  xmm9, dword ptr [rbp+290h+var_1B0]
          }
        }
        __asm
        {
          vmovss  xmm0, dword ptr [r15+4Ch]
          vdivss  xmm1, xmm10, xmm7
          vsubss  xmm2, xmm0, xmm1
          vmovss  dword ptr [r15+4Ch], xmm2
        }
      }
      __asm { vcomiss xmm2, xmm13 }
      if ( v192 | v193 )
        goto LABEL_153;
      if ( v151 )
        goto LABEL_140;
      __asm
      {
        vsubss  xmm7, xmm9, dword ptr [rbp+290h+outResults.hitPos]
        vsubss  xmm6, xmm6, dword ptr [rbp+290h+outResults.hitPos+4]
        vsubss  xmm8, xmm8, dword ptr [rbp+290h+outResults.hitPos+8]
      }
      *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_bullet_penetrationMinFxDist, "bullet_penetrationMinFxDist");
      __asm
      {
        vmulss  xmm2, xmm6, xmm6
        vmulss  xmm1, xmm7, xmm7
        vaddss  xmm3, xmm2, xmm1
        vmulss  xmm2, xmm8, xmm8
        vaddss  xmm4, xmm3, xmm2
        vmulss  xmm0, xmm0, xmm0
        vcomiss xmm4, xmm0
      }
      if ( v102 | v103 )
        goto LABEL_140;
      if ( v247 && (outResults.trace.surfaceFlags & 4) != 0 )
      {
        v210 = cgameGlob;
      }
      else
      {
        v210 = cgameGlob;
        __asm { vmovaps xmm2, xmm15; fullTraceLength }
        v212 = CG_CalcBallisticBulletEffectTime(cgameGlob, &initialBulletPos, *(double *)&_XMM2, &trace.hitPos, _R15->isBallistics);
        CgWeaponSystem::TrySimulateBulletFire_HitEffect(this, v212, v248, (__int16)**(_WORD **)tagOffset.v, entityIndexa, v261, knownHitClientNum, r_weapon, v37, &_R15->initialPos, &v266.start, &trace.hitPos, &_R15->dir, (trace.trace.surfaceFlags >> 19) & 0x3F, _R15->methodOfDeath, impactEffects, trace.trace.contents, forceClientSideImpactFx);
      }
      if ( !v247 )
      {
LABEL_140:
        __asm { vmovss  xmm9, cs:__real@447a0000 }
      }
      else
      {
        __asm { vmovaps xmm2, xmm15; fullTraceLength }
        v214 = CG_CalcBallisticBulletEffectTime(v210, &initialBulletPos, *(double *)&_XMM2, &outResults.hitPos, _R15->isBallistics);
        methodOfDeath = _R15->methodOfDeath;
        v216 = v214;
        v217 = Trace_GetScriptableHitId(&outResults.trace);
        v218 = Trace_GetEntityHitId(&outResults.trace);
        if ( v218 >= 0x800u )
          v218 = 2047;
        CgWeaponSystem::TrySimulateBulletFire_HitEffect(this, v216, v248, (__int16)**(_WORD **)tagOffset.v, v218, v217, knownHitClientNum, r_weapon, isAlternate, &_R15->initialPos, &_R15->start, &outResults.hitPos, &outResults.trace.normal, (outResults.trace.surfaceFlags >> 19) & 0x3F, methodOfDeath, triggerTimea, outResults.trace.contents, forceClientSideImpactFx);
        v219 = _R15->methodOfDeath;
        v220 = Trace_GetEntityHitId(&outResults.trace);
        if ( v220 >= 0x800u )
          v220 = 2047;
        CgWeaponSystem::TryBulletScriptableImpact(this, v216, v248, (__int16)**(_WORD **)tagOffset.v, v220, r_weapon, isAlternate, v219, &_R15->start, &outResults.hitPos, (const scr_string_t)outResults.trace.partName);
        __asm { vmovss  xmm9, cs:__real@447a0000 }
        v37 = isAlternate;
        if ( shouldSpawnTracer && shouldSpawnExitTracers )
        {
          __asm
          {
            vdivss  xmm0, xmm14, [rbp+290h+var_2D8]
            vmulss  xmm1, xmm0, xmm9
            vcvttss2si eax, xmm1
          }
          CgWeaponSystem::TrySpawnTracer(this, bulletId, v248, 0, (__int16)**(_WORD **)tagOffset.v, r_attackerPerks, hand, tagPair, &_R15->start, &outResults.hitPos, r_weapon, isAlternate, _EAX);
          __asm { vmovss  xmm14, dword ptr [r15+8Ch] }
        }
      }
      goto LABEL_141;
    }
    if ( v247 && !outResults.trace.allsolid )
    {
      __asm
      {
        vsubss  xmm7, xmm10, dword ptr [rbp+290h+outResults.hitPos]
        vsubss  xmm6, xmm11, dword ptr [rbp+290h+outResults.hitPos+4]
        vsubss  xmm8, xmm12, dword ptr [rbp+290h+outResults.hitPos+8]
      }
      *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_bullet_penetrationMinFxDist, "bullet_penetrationMinFxDist");
      __asm
      {
        vmulss  xmm2, xmm6, xmm6
        vmulss  xmm1, xmm7, xmm7
        vaddss  xmm3, xmm2, xmm1
        vmulss  xmm2, xmm8, xmm8
        vaddss  xmm4, xmm3, xmm2
        vmulss  xmm0, xmm0, xmm0
        vcomiss xmm4, xmm0
      }
      if ( !(v102 | v103) )
      {
        __asm { vmovaps xmm2, xmm15; fullTraceLength }
        v164 = CG_CalcBallisticBulletEffectTime(cgameGlob, &initialBulletPos, *(double *)&_XMM2, &outResults.hitPos, _R15->isBallistics);
        v165 = Trace_GetEntityHitId(&outResults.trace);
        if ( v165 >= 0x800u )
          v165 = 2047;
        v166 = Trace_GetScriptableHitId(&outResults.trace);
        CgWeaponSystem::TrySimulateBulletFire_HitEffect(this, v164, v248, (__int16)**(_WORD **)tagOffset.v, v165, v166, knownHitClientNum, r_weapon, v37, &_R15->initialPos, &_R15->start, &outResults.hitPos, &outResults.trace.normal, (outResults.trace.surfaceFlags >> 19) & 0x3F, _R15->methodOfDeath, triggerTimea, outResults.trace.contents, forceClientSideImpactFx);
        CgWeaponSystem::TryBulletScriptableImpact(this, v164, v248, (__int16)**(_WORD **)tagOffset.v, v165, r_weapon, v37, (const meansOfDeath_t)_R15->methodOfDeath, &_R15->start, &outResults.hitPos, (const scr_string_t)outResults.trace.partName);
        if ( shouldSpawnTracer && shouldSpawnExitTracers )
        {
          __asm
          {
            vdivss  xmm0, xmm14, [rbp+290h+var_2D8]
            vmulss  xmm1, xmm0, xmm9
            vcvttss2si eax, xmm1
          }
          CgWeaponSystem::TrySpawnTracer(this, bulletId, v248, 0, (__int16)**(_WORD **)tagOffset.v, r_attackerPerks, hand, tagPair, &_R15->start, &outResults.hitPos, r_weapon, v37, _EAX);
          __asm { vmovss  xmm14, dword ptr [r15+8Ch] }
        }
      }
LABEL_141:
      __asm
      {
        vmovss  xmm8, dword ptr cs:__xmm@80000000800000008000000080000000
        vmovss  xmm6, cs:__real@3c23d70a
      }
    }
    v227 = Trace_GetEntityHitId(&outResults.trace);
    if ( v227 >= 0x800u )
      v227 = 2047;
    entityIndex = v227;
    if ( !v247 )
      break;
    _RAX = outLastBulletPos;
    __asm
    {
      vmovss  xmm0, dword ptr [rbp+290h+outResults.hitPos]
      vmovss  xmm1, dword ptr [rbp+290h+outResults.hitPos+4]
      vmovss  dword ptr [rax], xmm0
      vmovss  xmm0, dword ptr [rbp+290h+outResults.hitPos+8]
      vmovss  dword ptr [rax+8], xmm0
      vmovss  dword ptr [rax+4], xmm1
    }
    isBallistics = _R15->isBallistics;
    if ( isBallistics )
    {
      __asm { vmovaps xmm2, xmm15; fullTraceLength }
      _R15->ballisticsTickEndTime = CG_CalcBallisticBulletEffectTime(cgameGlob, &initialBulletPos, *(double *)&_XMM2, &outResults.hitPos, isBallistics);
    }
    v92 = *(const entityState_t **)tagOffset.v;
    v97 = v246;
    v98 = v250;
    if ( (int)++targetScriptableIndexa >= 5 )
      goto LABEL_148;
  }
  *outLastBulletPos = _R15->end;
  if ( _R15->isBallistics )
    _R15->ballisticsTickEndTime = _R15->ballisticsTickStartTime + Dvar_GetInt_Internal_DebugName(DCONST_DVARINT_bg_ballisticsSimTimeStepMs, "bg_ballisticsSimTimeStepMs");
LABEL_148:
  Sys_ProfEndNamedEvent();
  result = 1;
LABEL_149:
  __asm
  {
    vmovaps xmm11, [rsp+3A0h+var_A0]
    vmovaps xmm10, [rsp+3A0h+var_90]
    vmovaps xmm9, [rsp+3A0h+var_80]
    vmovaps xmm8, [rsp+3A0h+var_70]
    vmovaps xmm7, [rsp+3A0h+var_60]
    vmovaps xmm6, [rsp+3A0h+var_50]
    vmovaps xmm12, [rsp+3A0h+var_B0]
  }
LABEL_150:
  __asm
  {
    vmovaps xmm13, [rsp+3A0h+var_C0]
    vmovaps xmm14, [rsp+3A0h+var_D0]
    vmovaps xmm15, [rsp+3A0h+var_E0]
  }
  return result;
}

/*
==============
CgWeaponSystem::SimulateBulletFire_HitEffect
==============
*/
void CgWeaponSystem::SimulateBulletFire_HitEffect(CgWeaponSystem *this, int sourceEntityNum, int targetEntityNum, unsigned int targetScriptableIndex, const int knownHitClientNum, const Weapon *weapon, bool isAlternate, const vec3_t *initialShootingPos, const vec3_t *startPos, const vec3_t *position, const vec3_t *normal, int surfType, unsigned int meansOfDeath, unsigned int impactEffects, int hitContents, const bool forceClientSideHandling)
{
  cg_t *LocalClientGlobals; 
  int ClientHitEvent; 
  int v22; 
  LocalClientNum_t m_localClientNum; 
  CgWeaponSystem *WeaponSystem; 
  int fmt; 
  int event; 

  if ( meansOfDeath >= 0x19 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23527, ASSERT_TYPE_ASSERT, "(unsigned)( meansOfDeath ) < (unsigned)( MOD_NUM )", "meansOfDeath doesn't index MOD_NUM\n\t%i not in [0, %i)", meansOfDeath, 25) )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23530, ASSERT_TYPE_SANITY, "( cgameGlob )", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( knownHitClientNum == LocalClientGlobals->predictedPlayerState.clientNum )
    ClientHitEvent = BG_WeaponBulletFire_GetClientHitEvent(meansOfDeath, 0);
  else
    ClientHitEvent = BG_WeaponBulletFire_GetHitEvent(meansOfDeath, 0);
  v22 = ClientHitEvent;
  if ( forceClientSideHandling || !this->SimulateBulletFire_UseEventBasedHitEffect(this, sourceEntityNum, targetEntityNum, ClientHitEvent) )
  {
    if ( knownHitClientNum == LocalClientGlobals->predictedPlayerState.clientNum )
    {
      m_localClientNum = this->m_localClientNum;
      if ( sourceEntityNum < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20697, ASSERT_TYPE_ASSERT, "(sourceEntityNum >= 0)", (const char *)&queryFormat, "sourceEntityNum >= 0") )
        __debugbreak();
      if ( sourceEntityNum == 2047 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20698, ASSERT_TYPE_ASSERT, "(sourceEntityNum != ENTITYNUM_NONE)", (const char *)&queryFormat, "sourceEntityNum != ENTITYNUM_NONE") )
        __debugbreak();
      if ( (unsigned int)surfType > 0x3F && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 20699, ASSERT_TYPE_ASSERT, "(surfType >= 0 && surfType < 64)", (const char *)&queryFormat, "surfType >= 0 && surfType < SURF_TYPECOUNT") )
        __debugbreak();
      Sys_ProfBeginNamedEvent(0xFF008080, "CG_BulletHitClientEvent");
      BulletHitClientEventSound(m_localClientNum, sourceEntityNum, weapon, isAlternate, position, surfType, v22, impactEffects, SND_HIT_ARMOR_TYPE_NONE);
      if ( (impactEffects & 4) == 0 )
      {
        WeaponSystem = CgWeaponSystem::GetWeaponSystem(m_localClientNum);
        WeaponSystem->BulletTrajectoryEffects(WeaponSystem, sourceEntityNum, weapon, isAlternate, startPos, position, surfType, v22);
      }
      CG_Rumble_PlayOnPositionByName(m_localClientNum, "damage_bullet", startPos);
      Sys_ProfEndNamedEvent();
    }
    else
    {
      LOBYTE(event) = isAlternate;
      LOBYTE(fmt) = -2;
      this->BulletHitEvent(this, sourceEntityNum, targetEntityNum, targetScriptableIndex, fmt, weapon, event, initialShootingPos, startPos, position, normal, surfType, v22, impactEffects, hitContents, 0, (const scr_string_t)0, forceClientSideHandling, -1, SND_HIT_ARMOR_TYPE_NONE, SND_HITMARKER_TYPE_STANDARD, NULL);
    }
  }
}

/*
==============
CgWeaponSystem::SimulateBulletFire_MissEffect
==============
*/
void CgWeaponSystem::SimulateBulletFire_MissEffect(CgWeaponSystem *this, __int64 sourceEntityNum, const Weapon *weapon, _BOOL8 isAlternate, const vec3_t *initialShootingPos, const vec3_t *startPos, const vec3_t *position, int surfType)
{
  this->BulletTrajectoryEffects(this, sourceEntityNum, weapon, isAlternate, startPos, position, surfType, 93);
}

/*
==============
CgWeaponSystem::SimulateBulletFire_Ricochet
==============
*/
void CgWeaponSystem::SimulateBulletFire_Ricochet(CgWeaponSystem *this, BulletFireParams *bp, const int bulletId, const Weapon *weapon, bool isAlternate, centity_t *inflictorEnt, const bitarray<64> *r_attackerPerks, bool isPlayerWeaponView, PlayerHandIndex hand, const TagPair tagPair, float bulletRange, int ricochetCount, bool shouldSpawnTracer, bool shouldDeferEvents)
{
  CgWeaponSystem *v25; 
  const Weapon *v26; 
  bool v28; 
  bitarray<64> v29; 
  char v36; 
  char v37; 
  int v41; 
  unsigned __int16 EntityHitId; 
  unsigned int ScriptableHitId; 
  const dvar_t *v45; 
  vec3_t *p_hitPos; 
  unsigned __int16 partGroup; 
  centity_t *v48; 
  CgHandler *Handler; 
  int number; 
  CgStatic *LocalClientStatics; 
  const cg_t *LocalClientGlobals; 
  const characterInfo_t *CharacterInfo; 
  team_t v55; 
  CgHandler *v56; 
  int v57; 
  CgStatic *v58; 
  const cg_t *v59; 
  const characterInfo_t *v60; 
  bool v65; 
  int weaponEntIndex; 
  int v100; 
  int v108; 
  bool v109; 
  bool v110; 
  bool v118; 
  unsigned __int16 v119; 
  team_t team; 
  int i; 
  unsigned int targetScriptableIndex; 
  centity_t *outHitEnt; 
  vec3_t *p_start; 
  vec3_t tracerStart; 
  BulletTraceResults br; 
  char v135; 
  void *retaddr; 

  _R11 = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [r11-0A8h], xmm11
    vmovaps xmmword ptr [r11-0B8h], xmm12
    vmovaps xmmword ptr [r11-0C8h], xmm13
  }
  v25 = this;
  v26 = weapon;
  _RSI = bp;
  __asm
  {
    vmovaps xmmword ptr [r11-98h], xmm10
    vmovaps xmmword ptr [r11-0D8h], xmm14
    vmovaps xmmword ptr [r11-0E8h], xmm15
  }
  Sys_ProfBeginNamedEvent(0xFF44CCFF, "SimulateBulletFire_Ricochet");
  if ( !_RSI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24725, ASSERT_TYPE_ASSERT, "(bp)", (const char *)&queryFormat, "bp") )
    __debugbreak();
  if ( !inflictorEnt && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24726, ASSERT_TYPE_ASSERT, "(inflictorEnt)", (const char *)&queryFormat, "inflictorEnt") )
    __debugbreak();
  v28 = isAlternate;
  if ( BG_GetWeaponType(v26, isAlternate) != WEAPTYPE_BULLET && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24727, ASSERT_TYPE_ASSERT, "(CG_Weapons_IsBulletWeapon( weapon, isAlternate ))", (const char *)&queryFormat, "CG_Weapons_IsBulletWeapon( weapon, isAlternate )") )
    __debugbreak();
  if ( BG_IsBeamStyleTracer(v26, isAlternate) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24728, ASSERT_TYPE_ASSERT, "(!BG_IsBeamStyleTracer( weapon, isAlternate ))", (const char *)&queryFormat, "!BG_IsBeamStyleTracer( weapon, isAlternate )") )
    __debugbreak();
  v29 = *r_attackerPerks;
  _RAX = &_RSI->start;
  __asm
  {
    vmovss  xmm0, dword ptr [rax]
    vmovss  xmm1, dword ptr [rax+4]
    vmovss  dword ptr [rbp+140h+tracerStart], xmm0
    vmovss  xmm0, dword ptr [rax+8]
  }
  p_start = &_RSI->start;
  __asm
  {
    vmovss  dword ptr [rbp+140h+tracerStart+8], xmm0
    vmovss  dword ptr [rbp+140h+tracerStart+4], xmm1
  }
  CG_SND_VerifyTracerAndWhizbySpeeds(v29, v26, isAlternate);
  *(double *)&_XMM0 = CG_GetTracerSpeed(*r_attackerPerks, v26, isAlternate);
  __asm
  {
    vxorps  xmm10, xmm10, xmm10
    vcomiss xmm0, xmm10
    vmovaps xmm12, xmm0
  }
  if ( v36 | v37 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24746, ASSERT_TYPE_ASSERT, "(tracerSpeed > 0.0f)", (const char *)&queryFormat, "tracerSpeed > 0.0f") )
    __debugbreak();
  __asm
  {
    vmovss  xmm14, [rbp+140h+bulletRange]
    vmovss  xmm13, cs:__real@447a0000
    vmovss  xmm15, cs:__real@3e0a3d71
  }
  v41 = ricochetCount;
  __asm
  {
    vmovaps xmmword ptr [rsp+250h+var_58+8], xmm6
    vmovaps [rsp+250h+var_68+8], xmm7
    vmovaps [rsp+250h+var_78+8], xmm8
    vmovaps [rsp+250h+var_88+8], xmm9
    vxorps  xmm11, xmm11, xmm11
  }
  for ( i = 0; i < 12; ++i )
  {
    v118 = CG_Weapons_BulletTrace((const LocalClientNum_t)v25->m_localClientNum, _RSI, v26, v28, inflictorEnt, &br, 0, (const centity_t **)&outHitEnt, v41 > 0);
    EntityHitId = Trace_GetEntityHitId(&br.trace);
    if ( EntityHitId >= 0x800u )
      EntityHitId = 2047;
    v119 = EntityHitId;
    ScriptableHitId = Trace_GetScriptableHitId(&br.trace);
    v45 = DCONST_DVARBOOL_cg_debugBullets;
    targetScriptableIndex = ScriptableHitId;
    if ( !DCONST_DVARBOOL_cg_debugBullets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_debugBullets") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v45);
    if ( v45->current.enabled )
    {
      p_hitPos = &br.hitPos;
      if ( !v118 )
        p_hitPos = &_RSI->end;
      CgWeaponSystem::AddDebugBulletLine(v25, &_RSI->start, p_hitPos);
    }
    if ( br.trace.startsolid )
      break;
    if ( !v118 )
      break;
    partGroup = br.trace.partGroup;
    if ( (unsigned __int16)(br.trace.partGroup - 19) <= 1u || _RSI->methodOfDeath == MOD_EXPLOSIVE_BULLET )
      break;
    v48 = outHitEnt;
    if ( outHitEnt && (outHitEnt->flags & 1) != 0 )
    {
      if ( GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&outHitEnt->nextState.lerp.eFlags, ACTIVE, 0x10u) )
      {
        if ( br.ignoreHitEnt )
        {
          __asm { vmovaps xmm3, xmm10; dist }
          BG_AdvanceTrace(_RSI, &br.trace, &br.hitPos, *(float *)&_XMM3);
          v41 = ricochetCount;
        }
        else
        {
          if ( !Dvar_GetBool_Internal_DebugName(DCONST_DVARMPBOOL_bullet_penetration_enabled, "bullet_penetration_enabled") || !BG_IsCharacterEntity(&v48->nextState) )
            break;
          team = TEAM_ZERO;
          Handler = CgHandler::getHandler(v25->m_localClientNum);
          number = v48->nextState.number;
          LocalClientStatics = CgStatic::GetLocalClientStatics((const LocalClientNum_t)Handler->m_localClientNum);
          LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)LocalClientStatics->m_localClientNum);
          if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_static_inline.h", 33, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
            __debugbreak();
          CharacterInfo = CG_GetCharacterInfo(LocalClientGlobals, number);
          if ( CharacterInfo )
            team = CharacterInfo->team;
          v55 = TEAM_ZERO;
          if ( (inflictorEnt->flags & 1) != 0 && BG_IsCharacterEntity(&inflictorEnt->nextState) )
          {
            v56 = CgHandler::getHandler(v25->m_localClientNum);
            v57 = inflictorEnt->nextState.number;
            v58 = CgStatic::GetLocalClientStatics((const LocalClientNum_t)v56->m_localClientNum);
            v59 = CG_GetLocalClientGlobals((const LocalClientNum_t)v58->m_localClientNum);
            if ( !v59 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_static_inline.h", 33, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
              __debugbreak();
            v60 = CG_GetCharacterInfo(v59, v57);
            v25 = this;
            if ( v60 )
              v55 = v60->team;
          }
          v28 = isAlternate;
          if ( !BG_IsRifleBullet(weapon, isAlternate) || inflictorEnt == v48 || v55 && v55 == team )
            break;
          __asm { vmovaps xmm3, xmm10; dist }
          BG_AdvanceTrace(_RSI, &br.trace, &br.hitPos, *(float *)&_XMM3);
          v41 = ricochetCount;
          v26 = weapon;
        }
        continue;
      }
      partGroup = br.trace.partGroup;
    }
    if ( partGroup == 19 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24851, ASSERT_TYPE_ASSERT, "(br.trace.partGroup != HITLOC_SHIELD)", (const char *)&queryFormat, "br.trace.partGroup != HITLOC_SHIELD") )
      __debugbreak();
    *(double *)&_XMM0 = BG_GetPenetrateMultiplier(v26, v28);
    __asm { vcvttss2si edi, xmm0 }
    if ( _EDI >= 5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 24853, ASSERT_TYPE_ASSERT, "(weaponRicochetMax < 5)", (const char *)&queryFormat, "weaponRicochetMax < BULLET_MAX_RICOCHET") )
      __debugbreak();
    if ( ricochetCount >= _EDI )
      break;
    __asm
    {
      vsubss  xmm0, xmm14, dword ptr [rsi+8Ch]
      vmaxss  xmm9, xmm0, xmm10
      vcomiss xmm9, xmm10
    }
    if ( ricochetCount <= (unsigned int)_EDI )
      break;
    CgWeaponSystem::TrySimulateBulletFire_HitEffect(v25, 0x80000000, shouldDeferEvents, inflictorEnt->nextState.number, v119, targetScriptableIndex, 2047, v26, v28, &_RSI->initialPos, &_RSI->start, &br.hitPos, &br.trace.normal, (br.trace.surfaceFlags >> 19) & 0x3F, _RSI->methodOfDeath, 0x800u, br.trace.contents, 0);
    CgWeaponSystem::TryBulletScriptableImpact(v25, 0x80000000, shouldDeferEvents, inflictorEnt->nextState.number, v119, v26, v28, (const meansOfDeath_t)_RSI->methodOfDeath, &_RSI->start, &br.hitPos, (const scr_string_t)br.trace.partName);
    if ( shouldSpawnTracer )
    {
      v65 = isPlayerWeaponView && !ricochetCount;
      __asm
      {
        vdivss  xmm0, xmm11, xmm12
        vmulss  xmm1, xmm0, xmm13
        vcvttss2si eax, xmm1
      }
      CgWeaponSystem::TrySpawnTracer(v25, bulletId, shouldDeferEvents, v65, inflictorEnt->nextState.number, r_attackerPerks, hand, tagPair, &tracerStart, &br.hitPos, v26, v28, _EAX);
      __asm { vmovss  xmm11, dword ptr [rsi+8Ch] }
      if ( debugDrawTracer )
        CG_DebugLine(&tracerStart, &br.hitPos, &colorGreen, 1, 75);
    }
    __asm
    {
      vmulss  xmm2, xmm15, dword ptr [rsi+80h]
      vmovss  xmm1, dword ptr [rbp+140h+var_170.hitPos]
      vmovss  xmm8, dword ptr [rbp+140h+var_170.trace.normal+8]
      vmovss  xmm6, dword ptr [rbp+140h+var_170.trace.normal+4]
      vsubss  xmm5, xmm1, xmm2
      vmovss  xmm1, dword ptr [rbp+140h+var_170.hitPos+4]
      vmovss  dword ptr [rsi+68h], xmm5
      vmulss  xmm2, xmm15, dword ptr [rsi+84h]
      vsubss  xmm4, xmm1, xmm2
      vmovss  xmm1, dword ptr [rbp+140h+var_170.hitPos+8]
      vmovss  dword ptr [rsi+6Ch], xmm4
      vmulss  xmm2, xmm15, dword ptr [rsi+88h]
      vsubss  xmm3, xmm1, xmm2
      vmovss  dword ptr [rsi+70h], xmm3
      vmulss  xmm0, xmm8, dword ptr [rsi+88h]
      vmovss  xmm7, dword ptr [rsi+80h]
      vmulss  xmm1, xmm6, dword ptr [rsi+84h]
      vmovss  dword ptr [rbp+140h+tracerStart+4], xmm4
      vmulss  xmm4, xmm0, cs:__real@c0000000
      vmulss  xmm0, xmm7, dword ptr [rbp+140h+var_170.trace.normal]
      vaddss  xmm1, xmm1, xmm0
      vmulss  xmm2, xmm1, cs:__real@40000000
      vmovss  dword ptr [rbp+140h+tracerStart], xmm5
      vsubss  xmm5, xmm4, xmm2
      vmulss  xmm0, xmm5, dword ptr [rbp+140h+var_170.trace.normal]
      vaddss  xmm2, xmm0, xmm7
      vmovss  dword ptr [rsi+80h], xmm2
      vmulss  xmm0, xmm6, xmm5
      vaddss  xmm1, xmm0, dword ptr [rsi+84h]
      vmovss  dword ptr [rsi+84h], xmm1
      vmulss  xmm0, xmm8, xmm5
      vaddss  xmm1, xmm0, dword ptr [rsi+88h]
      vmovss  dword ptr [rsi+88h], xmm1
      vmulss  xmm0, xmm9, xmm2
      vaddss  xmm1, xmm0, dword ptr [rsi+68h]
      vmovss  dword ptr [rsi+74h], xmm1
      vmulss  xmm2, xmm9, dword ptr [rsi+84h]
      vaddss  xmm0, xmm2, dword ptr [rsi+6Ch]
      vmovss  dword ptr [rsi+78h], xmm0
      vmulss  xmm1, xmm9, dword ptr [rsi+88h]
      vaddss  xmm2, xmm1, dword ptr [rsi+70h]
      vmovss  dword ptr [rsi+7Ch], xmm2
    }
    weaponEntIndex = _RSI->weaponEntIndex;
    __asm { vmovss  dword ptr [rbp+140h+tracerStart+8], xmm3 }
    BG_RemoveIgnoreEntFromBP(_RSI, weaponEntIndex);
    if ( inflictorEnt->nextState.eType == ET_TURRET )
    {
      v100 = inflictorEnt->nextState.lerp.u.anonymous.data[6];
      if ( v100 != 2047 )
        BG_RemoveIgnoreEntFromBP(_RSI, v100);
    }
    v41 = ++ricochetCount;
  }
  __asm
  {
    vmovaps xmm15, [rsp+250h+var_E8+8]
    vmovaps xmm14, xmmword ptr [rsp+250h+var_D8+8]
    vmovaps xmm10, [rsp+250h+var_98+8]
    vmovaps xmm9, [rsp+250h+var_88+8]
    vmovaps xmm8, [rsp+250h+var_78+8]
    vmovaps xmm7, [rsp+250h+var_68+8]
    vmovaps xmm6, xmmword ptr [rsp+250h+var_58+8]
  }
  v108 = inflictorEnt->nextState.number;
  if ( v118 )
  {
    CgWeaponSystem::TrySimulateBulletFire_HitEffect(v25, 0x80000000, shouldDeferEvents, v108, v119, targetScriptableIndex, 2047, weapon, v28, &_RSI->initialPos, &_RSI->start, &br.hitPos, &br.trace.normal, (br.trace.surfaceFlags >> 19) & 0x3F, _RSI->methodOfDeath, 0, br.trace.contents, 0);
    v109 = shouldDeferEvents;
    CgWeaponSystem::TryBulletScriptableImpact(v25, 0x80000000, shouldDeferEvents, inflictorEnt->nextState.number, v119, weapon, v28, (const meansOfDeath_t)_RSI->methodOfDeath, &_RSI->start, &br.hitPos, (const scr_string_t)br.trace.partName);
  }
  else
  {
    v109 = shouldDeferEvents;
    CgWeaponSystem::TrySimulateBulletFire_MissEffect(v25, 0x80000000, shouldDeferEvents, v108, weapon, v28, &_RSI->initialPos, p_start, &br.hitPos, (br.trace.surfaceFlags >> 19) & 0x3F);
  }
  if ( shouldSpawnTracer )
  {
    v110 = isPlayerWeaponView && !ricochetCount;
    __asm
    {
      vdivss  xmm0, xmm11, xmm12
      vmulss  xmm1, xmm0, xmm13
      vcvttss2si eax, xmm1
    }
    CgWeaponSystem::TrySpawnTracer(v25, bulletId, v109, v110, inflictorEnt->nextState.number, r_attackerPerks, hand, tagPair, &tracerStart, &br.hitPos, weapon, v28, _EAX);
    if ( debugDrawTracer )
      CG_DebugLine(&tracerStart, &br.hitPos, &colorGreen, 1, 75);
  }
  Sys_ProfEndNamedEvent();
  _R11 = &v135;
  __asm
  {
    vmovaps xmm11, xmmword ptr [r11-70h]
    vmovaps xmm12, xmmword ptr [r11-80h]
    vmovaps xmm13, xmmword ptr [r11-90h]
  }
}

/*
==============
CgWeaponSystem::SimulateImpactEffectForBeamWeapons
==============
*/
void CgWeaponSystem::SimulateImpactEffectForBeamWeapons(CgWeaponSystem *this, const int attackerEntNum, const Weapon *r_weapon, const bool isAlternate, const centity_t *victimEnt, const BulletFireParams *bp, const vec3_t *bulletEndPos, const bool shouldDeferEvents, vec3_t *outImpactPos)
{
  bool IsCharacterEntity; 
  LocalClientNum_t m_localClientNum; 
  bool v18; 
  int v19; 
  int v20; 
  unsigned int DetailPhysicsInstanceId; 
  CG_PhysicsObject *v22; 
  HavokPhysics_CollisionQueryResult *ClosestResult; 
  unsigned int impactEffects; 
  unsigned __int8 *WeaponPriorityMap; 
  int v28; 
  Physics_CharacterProxy_Type v29; 
  signed int v58; 
  hknpBodyId *RigidBodyID; 
  const Physics_DetailHitData *DetailHitData; 
  int surfaceFlags; 
  int v67; 
  entityState_t *v69; 
  Weapon *weapon; 
  HavokPhysics_CollisionQueryResult *v72; 
  __int64 knownHitClientNum; 
  bool v75; 
  int NumRigidBodys; 
  hknpBodyId result; 
  vec3_t *v79; 
  entityState_t *p_nextState; 
  Weapon *v81; 
  CgWeaponSystem *v82; 
  Physics_RaycastExtendedData extendedData; 
  vec3_t pos; 
  vec3_t end; 
  vec3_t start; 
  trace_t trace; 

  v81 = (Weapon *)r_weapon;
  v82 = this;
  v79 = outImpactPos;
  if ( !bp && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23881, ASSERT_TYPE_ASSERT, "(bp)", (const char *)&queryFormat, "bp") )
    __debugbreak();
  if ( !victimEnt && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23882, ASSERT_TYPE_ASSERT, "(victimEnt)", (const char *)&queryFormat, "victimEnt") )
    __debugbreak();
  if ( (victimEnt->flags & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23883, ASSERT_TYPE_ASSERT, "(CENextValid( victimEnt ))", (const char *)&queryFormat, "CENextValid( victimEnt )") )
    __debugbreak();
  _RSI = bulletEndPos;
  *outImpactPos = *bulletEndPos;
  Sys_ProfBeginNamedEvent(0xFF44CCFF, "SimulateImpactEffectForBeamWeapons");
  p_nextState = &victimEnt->nextState;
  IsCharacterEntity = BG_IsCharacterEntity(&victimEnt->nextState);
  m_localClientNum = this->m_localClientNum;
  v18 = IsCharacterEntity;
  v75 = IsCharacterEntity;
  v19 = 3 * m_localClientNum;
  v20 = 3 * m_localClientNum + 4;
  if ( IsCharacterEntity )
  {
    DetailPhysicsInstanceId = CG_PhysicsCharacterProxy_GetDetailPhysicsInstanceId(m_localClientNum, victimEnt);
  }
  else
  {
    v22 = CG_PhysicsObject_Get(victimEnt->nextState.number, m_localClientNum);
    if ( !v22 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23902, ASSERT_TYPE_ASSERT, "(victimEntPhysicsObject)", (const char *)&queryFormat, "victimEntPhysicsObject") )
      __debugbreak();
    if ( (unsigned int)v20 >= 8 )
    {
      LODWORD(v72) = v19 + 4;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 23905, ASSERT_TYPE_ASSERT, "(unsigned)( clientDetailWorldId ) < (unsigned)( PHYSICS_WORLD_ID_COUNT )", "clientDetailWorldId doesn't index PHYSICS_WORLD_ID_COUNT\n\t%i not in [0, %i)", v72, 8) )
        __debugbreak();
    }
    DetailPhysicsInstanceId = v22->physicsInstances[v19 + 4];
  }
  if ( DetailPhysicsInstanceId != -1 )
  {
    __asm
    {
      vmovaps [rsp+220h+var_50], xmm6
      vmovaps [rsp+220h+var_60], xmm7
      vmovaps [rsp+220h+var_70], xmm8
      vmovaps [rsp+220h+var_80], xmm9
    }
    ClosestResult = PhysicsQuery_GetClosestResult((Physics_WorldId)v20);
    HavokPhysics_CollisionQueryResult::Reset(ClosestResult, 1);
    impactEffects = 0;
    if ( v18 )
      WeaponPriorityMap = BG_GetWeaponPriorityMap(r_weapon, isAlternate);
    else
      WeaponPriorityMap = NULL;
    Physics_AddDetailTrace(ClosestResult, WeaponPriorityMap);
    __asm { vmovss  xmm0, dword ptr [rsi] }
    v28 = 1;
    extendedData.ignoreBodies = NULL;
    extendedData.phaseSelection = All;
    v29 = PHYSICS_CHARACTERPROXY_TYPE_COLLISION;
    extendedData.insideHitType = Physics_RaycastInsideHitType_InsideHits;
    if ( v18 )
      v29 = PHYSICS_CHARACTERPROXY_TYPE_DETAIL;
    *(_WORD *)&extendedData.collectInsideHits = 256;
    __asm { vxorps  xmm4, xmm4, xmm4 }
    extendedData.characterProxyType = v29;
    _RAX = bp;
    __asm { vmovss  [rbp+110h+extendedData.collisionBuffer], xmm4 }
    extendedData.contents = 41969969;
    __asm
    {
      vmovss  xmm1, dword ptr [rax+68h]
      vmovss  xmm2, dword ptr [rax+6Ch]
      vmovss  xmm3, dword ptr [rax+70h]
      vsubss  xmm6, xmm0, xmm1
      vmovss  xmm0, dword ptr [rsi+8]
      vmovss  dword ptr [rbp+110h+start], xmm1
      vmovss  xmm1, dword ptr [rsi+4]
      vsubss  xmm7, xmm1, xmm2
      vsubss  xmm8, xmm0, xmm3
      vmulss  xmm1, xmm7, xmm7
      vmulss  xmm0, xmm6, xmm6
      vmovss  dword ptr [rbp+110h+start+4], xmm2
      vaddss  xmm2, xmm1, xmm0
      vmulss  xmm1, xmm8, xmm8
      vaddss  xmm9, xmm2, xmm1
      vcomiss xmm9, xmm4
      vmovss  dword ptr [rbp+110h+start+8], xmm3
    }
    if ( !v18 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vector.h", 639, ASSERT_TYPE_SANITY, "( val > 0 )", (const char *)&queryFormat, "val > 0") )
      __debugbreak();
    __asm
    {
      vmovss  xmm3, cs:__real@3e800000
      vmovaps xmm1, xmm9
      vrsqrtss xmm4, xmm1, xmm1
      vmulss  xmm0, xmm6, xmm4
      vmulss  xmm0, xmm0, xmm3
      vaddss  xmm1, xmm0, dword ptr [rsi]
      vmulss  xmm2, xmm7, xmm4
      vmulss  xmm0, xmm2, xmm3
      vmovss  dword ptr [rbp+110h+end], xmm1
      vaddss  xmm1, xmm0, dword ptr [rsi+4]
      vmulss  xmm2, xmm8, xmm4
      vmulss  xmm0, xmm2, xmm3
      vmovss  dword ptr [rbp+110h+end+4], xmm1
      vaddss  xmm1, xmm0, dword ptr [rsi+8]
      vmovss  dword ptr [rbp+110h+end+8], xmm1
      vmovaps xmm9, [rsp+220h+var_80]
    }
    v58 = 0;
    __asm
    {
      vmovaps xmm8, [rsp+220h+var_70]
      vmovaps xmm7, [rsp+220h+var_60]
      vmovaps xmm6, [rsp+220h+var_50]
    }
    NumRigidBodys = Physics_GetNumRigidBodys((const Physics_WorldId)v20, DetailPhysicsInstanceId);
    if ( NumRigidBodys > 0 )
    {
      do
      {
        if ( !g_physicsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 105, ASSERT_TYPE_ASSERT, "(g_physicsInitialized)", "%s\n\tPhysics: Trying to Get Rigid Body ID when system is not initialized", "g_physicsInitialized") )
          __debugbreak();
        if ( (unsigned int)v20 > 7 )
        {
          LODWORD(knownHitClientNum) = v20;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 106, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tPhysics: Trying to Get Rigid Body ID with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", knownHitClientNum) )
            __debugbreak();
        }
        if ( !g_physicsClientWorldsCreated && (unsigned int)(v20 - 2) <= 5 )
        {
          LODWORD(knownHitClientNum) = v20;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 108, ASSERT_TYPE_ASSERT, "(g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST)", "%s\n\tPhysics: Trying to Get Rigid Body ID in client world %i when client worlds have not been set up", "g_physicsClientWorldsCreated || worldId < PHYSICS_WORLD_ID_CLIENT_FIRST || worldId > PHYSICS_WORLD_ID_CLIENT_LAST", knownHitClientNum) )
            __debugbreak();
        }
        if ( !g_physicsServerWorldsCreated && (unsigned int)v20 <= 1 )
        {
          LODWORD(knownHitClientNum) = v20;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\public\\physicsimplementationinterface.inl", 109, ASSERT_TYPE_ASSERT, "(g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST)", "%s\n\tPhysics: Trying to Get Rigid Body ID in server world %i when server worlds have not been set up", "g_physicsServerWorldsCreated || worldId < PHYSICS_WORLD_ID_SERVER_FIRST || worldId > PHYSICS_WORLD_ID_SERVER_LAST", knownHitClientNum) )
            __debugbreak();
        }
        RigidBodyID = HavokPhysics_GetRigidBodyID(&result, (const Physics_WorldId)v20, DetailPhysicsInstanceId, v58);
        Physics_Raycast((Physics_WorldId)v20, RigidBodyID->m_serialAndIndex, &start, &end, &extendedData, ClosestResult);
        ++v58;
      }
      while ( v58 < NumRigidBodys );
      v18 = v75;
      impactEffects = 0;
      v28 = 1;
    }
    if ( HavokPhysics_CollisionQueryResult::HasHit(ClosestResult) )
    {
      DetailHitData = NULL;
      if ( v18 )
        DetailHitData = Physics_GetDetailHitData(ClosestResult, 0, 0);
      Physics_ConvertRayQueryResultToLegacyTrace(ClosestResult, NULL, DetailHitData, &trace);
      surfaceFlags = trace.surfaceFlags;
      if ( v18 )
        surfaceFlags = 3670016;
      trace.surfaceFlags = surfaceFlags;
      if ( trace.partGroup == 2 || trace.partGroup == 1 )
      {
        if ( trace.partGroup == 1 )
          v28 = 1025;
        impactEffects = v28;
      }
      else if ( (unsigned int)trace.partGroup - 6 > 0xB )
      {
        if ( trace.partGroup == 20 )
          impactEffects = 128;
      }
      else
      {
        impactEffects = 64;
      }
      HavokPhysics_CollisionQueryResult::GetRaycastHitPosition(ClosestResult, 0, &pos);
      _RAX = v79;
      __asm { vmovss  xmm0, dword ptr [rbp+110h+pos] }
      v67 = trace.surfaceFlags;
      __asm { vmovss  xmm1, dword ptr [rbp+110h+pos+4] }
      v69 = p_nextState;
      weapon = v81;
      __asm
      {
        vmovss  dword ptr [rax], xmm0
        vmovss  xmm0, dword ptr [rbp+110h+pos+8]
        vmovss  dword ptr [rax+8], xmm0
        vmovss  dword ptr [rax+4], xmm1
      }
      CgWeaponSystem::TrySimulateBulletFire_HitEffect(v82, 0x80000000, shouldDeferEvents, attackerEntNum, v69->number, 0xFFFFFFFF, -1, weapon, isAlternate, &bp->initialPos, &bp->start, &pos, &trace.normal, (v67 >> 19) & 0x3F, bp->methodOfDeath, impactEffects, trace.contents, 1);
      CgWeaponSystem::TryBulletScriptableImpact(v82, 0x80000000, shouldDeferEvents, attackerEntNum, v69->number, weapon, isAlternate, (const meansOfDeath_t)bp->methodOfDeath, &bp->start, &pos, (const scr_string_t)trace.partName);
    }
  }
  Sys_ProfEndNamedEvent();
}

/*
==============
SndWeaponShotGetSecureOrigin
==============
*/
void SndWeaponShotGetSecureOrigin(const vec3_t *from, vec3_t *to)
{
  float v2; 
  float v3; 
  int v7; 
  int v8; 
  int v9; 
  int v10; 
  __int64 v11; 

  v2 = from->v[2];
  v3 = from->v[0];
  LOBYTE(v10) = BYTE3(from);
  HIBYTE(v10) = BYTE2(from);
  *(_WORD *)((char *)&v10 + 1) = (_WORD)from;
  LODWORD(to->v[2]) = LODWORD(v2) ^ v10 ^ s_weaponsoundorg_aab_Z ^ LODWORD(from->v[1]);
  LODWORD(to->v[0]) = LODWORD(v3) ^ LODWORD(v2) ^ v10 ^ s_weaponsoundorg_aab_X;
  LODWORD(to->v[1]) = LODWORD(v3) ^ v10 ^ ~s_weaponsoundorg_aab_Y;
  __asm { vmovss  xmm0, dword ptr [rdx] }
  memset(&v11, 0, sizeof(v11));
  __asm { vmovss  dword ptr [rsp+38h+arg_0], xmm0 }
  if ( (v7 & 0x7F800000) == 2139095040 )
    goto LABEL_8;
  __asm
  {
    vmovss  xmm0, dword ptr [rdx+4]
    vmovss  dword ptr [rsp+38h+arg_0], xmm0
  }
  if ( (v8 & 0x7F800000) == 2139095040 )
    goto LABEL_8;
  __asm
  {
    vmovss  xmm0, dword ptr [rdx+8]
    vmovss  dword ptr [rsp+38h+arg_0], xmm0
  }
  if ( (v9 & 0x7F800000) == 2139095040 )
  {
LABEL_8:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1352, ASSERT_TYPE_SANITY, "( !IS_NAN( ( to )[0] ) && !IS_NAN( ( to )[1] ) && !IS_NAN( ( to )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( to )[0] ) && !IS_NAN( ( to )[1] ) && !IS_NAN( ( to )[2] )") )
      __debugbreak();
  }
}

/*
==============
SndWeaponShotSetSecureOrigin
==============
*/
void SndWeaponShotSetSecureOrigin(const vec3_t *from, vec3_t *to)
{
  const vec3_t *v4; 
  unsigned int v7; 
  unsigned int v8; 
  unsigned int v9; 
  int v10; 
  int v11; 
  int v12; 
  int v13; 
  vec3_t *v14; 

  v14 = to;
  __asm
  {
    vmovss  xmm0, dword ptr [rcx]
    vmovss  [rsp+38h+arg_0], xmm0
  }
  v4 = from;
  if ( (v10 & 0x7F800000) == 2139095040 )
    goto LABEL_9;
  __asm
  {
    vmovss  xmm0, dword ptr [rcx+4]
    vmovss  [rsp+38h+arg_0], xmm0
  }
  if ( (v11 & 0x7F800000) == 2139095040 )
    goto LABEL_9;
  __asm
  {
    vmovss  xmm0, dword ptr [rcx+8]
    vmovss  [rsp+38h+arg_0], xmm0
  }
  if ( (v12 & 0x7F800000) == 2139095040 )
  {
LABEL_9:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1359, ASSERT_TYPE_SANITY, "( !IS_NAN( ( from )[0] ) && !IS_NAN( ( from )[1] ) && !IS_NAN( ( from )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( from )[0] ) && !IS_NAN( ( from )[1] ) && !IS_NAN( ( from )[2] )") )
      __debugbreak();
  }
  LOBYTE(v13) = BYTE3(to);
  HIBYTE(v13) = BYTE2(v14);
  *(_WORD *)((char *)&v13 + 1) = (_WORD)to;
  v7 = v13 ^ ~s_weaponsoundorg_aab_Y ^ LODWORD(v4->v[1]);
  v8 = s_weaponsoundorg_aab_Z ^ LODWORD(v4->v[2]);
  v9 = v13 ^ v7 ^ s_weaponsoundorg_aab_X ^ LODWORD(v4->v[0]);
  LODWORD(to->v[0]) = v7;
  LODWORD(to->v[2]) = v9;
  LODWORD(to->v[1]) = v13 ^ v9 ^ v8;
  memset(&v14, 0, sizeof(v14));
}

/*
==============
CgWeaponSystem::SpawnTracer
==============
*/
void CgWeaponSystem::SpawnTracer(CgWeaponSystem *this, const int bulletId, bool blendFromViewmodel, const int inflictorEntNum, const bitarray<64> *r_inflictorPerks, PlayerHandIndex hand, const TagPair sourceTagPair, const vec3_t *tracerStart, const vec3_t *tracerEnd, const Weapon *r_weapon, bool isAlternate, int spawnDelay)
{
  int v16; 
  __int64 delayedSpawnTracerEventsCount; 
  scr_string_t FallbackTagName; 
  const vec3_t *v21; 
  __int64 instigatorEntNum; 
  Weapon *weapon; 

  if ( (unsigned int)inflictorEntNum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16579, ASSERT_TYPE_ASSERT, "(unsigned)( inflictorEntNum ) < (unsigned)( ( 2048 ) )", "inflictorEntNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", inflictorEntNum, 2048) )
    __debugbreak();
  if ( (unsigned int)hand >= NUM_WEAPON_HANDS )
  {
    LODWORD(weapon) = 2;
    LODWORD(instigatorEntNum) = hand;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16580, ASSERT_TYPE_ASSERT, "(unsigned)( hand ) < (unsigned)( NUM_WEAPON_HANDS )", "hand doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", instigatorEntNum, weapon) )
      __debugbreak();
  }
  v16 = spawnDelay;
  if ( spawnDelay < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16581, ASSERT_TYPE_ASSERT, "(spawnDelay >= 0)", (const char *)&queryFormat, "spawnDelay >= 0") )
    __debugbreak();
  _RDI = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  if ( !blendFromViewmodel || v16 )
  {
    Tracer_Spawn(this->m_localClientNum, bulletId, r_inflictorPerks, tracerStart, tracerEnd, inflictorEntNum, r_weapon, isAlternate, v16);
  }
  else
  {
    if ( !TagPair::GetPrimaryTagName((TagPair *)&sourceTagPair) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16591, ASSERT_TYPE_ASSERT, "(sourceTagPair.GetPrimaryTagName() != ( static_cast< scr_string_t >( 0 ) ))", (const char *)&queryFormat, "sourceTagPair.GetPrimaryTagName() != NULL_SCR_STRING") )
      __debugbreak();
    delayedSpawnTracerEventsCount = _RDI->delayedSpawnTracerEventsCount;
    if ( (int)delayedSpawnTracerEventsCount < 16 )
    {
      _RBX = delayedSpawnTracerEventsCount;
      _RDI->delayedSpawnTracerEvents[_RBX].bulletId = bulletId;
      _RDI->delayedSpawnTracerEvents[_RBX].sourceEntityNum = inflictorEntNum;
      _RDI->delayedSpawnTracerEvents[_RBX].sourcePrimaryTagName = TagPair::GetPrimaryTagName((TagPair *)&sourceTagPair);
      FallbackTagName = TagPair::GetFallbackTagName((TagPair *)&sourceTagPair);
      v21 = tracerEnd;
      _RDI->delayedSpawnTracerEvents[_RBX].sourceFallbackTagName = FallbackTagName;
      _RDI->delayedSpawnTracerEvents[_RBX].target = *v21;
      _RAX = r_weapon;
      __asm
      {
        vmovups ymm0, ymmword ptr [rax]
        vmovups ymmword ptr [rbx+rdi+66B48h], ymm0
        vmovups xmm1, xmmword ptr [rax+20h]
        vmovups xmmword ptr [rbx+rdi+66B68h], xmm1
        vmovsd  xmm0, qword ptr [rax+30h]
        vmovsd  qword ptr [rbx+rdi+66B78h], xmm0
      }
      *(_DWORD *)&_RDI->delayedSpawnTracerEvents[_RBX].weapon.weaponCamo = *(_DWORD *)&_RAX->weaponCamo;
      _RDI->delayedSpawnTracerEvents[_RBX].isAlternate = isAlternate;
      _RDI->delayedSpawnTracerEvents[_RBX].hand = hand;
      _RDI->delayedSpawnTracerEvents[_RBX].perks = *r_inflictorPerks;
      ++_RDI->delayedSpawnTracerEventsCount;
    }
    else
    {
      Com_PrintWarning(14, "CgWeaponSystem::QueueTracer: No deferred tracers remaining - Too many this frame (max is %i).\n", 16i64);
    }
  }
}

/*
==============
StopAdditiveCrawlAnims
==============
*/
void StopAdditiveCrawlAnims(LocalClientNum_t localClientNum, const playerState_s *ps, DObj *obj, const PlayerHandIndex hand, const float blendOutSeconds)
{
  const XAnimTree *Tree; 
  __int64 v18; 
  CgHandler *Handler; 
  signed int v21; 
  char v22; 
  char v23; 
  float fmt; 
  float fmta; 
  float goalTime; 
  float goalTimea; 
  float v32; 
  float v33; 
  weapAnimFiles_t anim[4]; 
  unsigned int animIndex[4]; 
  char v36; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-58h], xmm6
    vmovaps xmmword ptr [rax-68h], xmm7
    vmovaps xmmword ptr [rax-78h], xmm8
    vmovdqu xmm0, cs:__xmm@000000710000006f0000006d0000006b
    vmovdqu xmm1, cs:__xmm@00000072000000700000006e0000006c
    vmovdqu xmmword ptr [rsp+108h+animIndex], xmm0
    vmovdqu xmmword ptr [rsp+108h+anim], xmm1
  }
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4888, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !IsAdditiveCrawlEnabled(localClientNum, ps, hand) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4889, ASSERT_TYPE_ASSERT, "(IsAdditiveCrawlEnabled( localClientNum, ps, hand ))", (const char *)&queryFormat, "IsAdditiveCrawlEnabled( localClientNum, ps, hand )") )
    __debugbreak();
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4891, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  Tree = DObjGetTree(obj);
  if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4893, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
    __debugbreak();
  __asm
  {
    vmovss  xmm6, [rsp+108h+blendOutSeconds]
    vmovss  xmm8, cs:__real@3f800000
  }
  v18 = 0i64;
  __asm { vxorps  xmm7, xmm7, xmm7 }
  do
  {
    Handler = CgHandler::getHandler(localClientNum);
    v21 = anim[v18];
    if ( BG_ViewModelAnimExists(ps, (weapAnimFiles_t)v21, hand, Handler) )
    {
      *(double *)&_XMM0 = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, v21);
      __asm { vcomiss xmm0, xmm7 }
      if ( !(v22 | v23) )
        goto LABEL_17;
      *(double *)&_XMM0 = XAnimGetGoalTime(Tree, 0, XANIM_SUBTREE_DEFAULT, v21);
      __asm { vcomiss xmm6, xmm0 }
      if ( v22 )
      {
LABEL_17:
        __asm
        {
          vmovss  [rsp+108h+var_D8], xmm8
          vmovss  [rsp+108h+goalTime], xmm6
          vmovss  dword ptr [rsp+108h+fmt], xmm7
        }
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, animIndex[v18], fmt, goalTime, v32, (scr_string_t)0, 0, 0, LINEAR, NULL);
        __asm
        {
          vmovss  [rsp+108h+var_D8], xmm8
          vmovss  [rsp+108h+goalTime], xmm6
          vmovss  dword ptr [rsp+108h+fmt], xmm7
        }
        XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, v21, fmta, goalTimea, v33, (scr_string_t)0, 0, 0, LINEAR, NULL);
      }
    }
    ++v18;
  }
  while ( v18 < 4 );
  _R11 = &v36;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-18h]
    vmovaps xmm7, xmmword ptr [r11-28h]
    vmovaps xmm8, xmmword ptr [r11-38h]
  }
}

/*
==============
CgWeaponSystem::StopPullbackSound
==============
*/
void CgWeaponSystem::StopPullbackSound(CgWeaponSystem *this, const int entNum)
{
  __int64 v2; 
  cg_t *LocalClientGlobals; 
  unsigned int lastPullbackId; 

  v2 = entNum;
  if ( entNum < cls.maxClients )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
    if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25077, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
      __debugbreak();
    if ( (unsigned __int64)cls.maxClients > 0xC8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25079, ASSERT_TYPE_ASSERT, "( ( sizeof( *array_counter( cgameGlob->soundPlaybackCache.clients ) ) + 0 ) ) >= ( cls.maxClients )", "%s >= %s\n\t%i, %i", "ARRAY_COUNT( cgameGlob->soundPlaybackCache.clients )", "cls.maxClients", 200, cls.maxClients) )
      __debugbreak();
    lastPullbackId = LocalClientGlobals->soundPlaybackCache.clients[v2].lastPullbackId;
    if ( lastPullbackId )
      SND_StopSoundAliasAndSecondariesByAliasId(lastPullbackId, this->m_localClientNum, v2);
    LocalClientGlobals->soundPlaybackCache.clients[v2].lastPullbackId = 0;
  }
}

/*
==============
StopRecoilAnim
==============
*/
void StopRecoilAnim(const LocalClientNum_t localClientNum, const playerState_s *const ps, DObj *const obj)
{
  cg_t *LocalClientGlobals; 
  PlayerWeaponAnimArrays *p_m_weaponAnimArrays; 
  char v11; 
  unsigned int v12; 
  unsigned int v13; 
  float fmt; 
  float fmta; 
  float goalTime; 
  float goalTimea; 
  float v22; 
  float v23; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-18h], xmm6
    vmovaps xmmword ptr [rax-28h], xmm7
  }
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7068, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 7069, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5970, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5976, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( &LocalClientGlobals->predictedPlayerState != ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5977, ASSERT_TYPE_ASSERT, "(&cgameGlob->predictedPlayerState == ps)", "%s\n\tInvalid player state in client weapon processing. Expected predicted player state.\n", "&cgameGlob->predictedPlayerState == ps") )
    __debugbreak();
  p_m_weaponAnimArrays = &LocalClientGlobals->m_weaponAnimArrays;
  if ( !p_m_weaponAnimArrays && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5980, ASSERT_TYPE_ASSERT, "(weaponAnimArrays)", (const char *)&queryFormat, "weaponAnimArrays") )
    __debugbreak();
  if ( BG_UsingAlternate(ps) )
    p_m_weaponAnimArrays = (PlayerWeaponAnimArrays *)((char *)p_m_weaponAnimArrays + 4976);
  v11 = 0;
  v12 = 412;
  v13 = 412;
  if ( p_m_weaponAnimArrays->normalAnimArray[176] )
  {
    v13 = 176;
    v11 = 1;
    v12 = 175;
  }
  __asm
  {
    vmovss  xmm7, cs:__real@3e19999a
    vxorps  xmm6, xmm6, xmm6
    vmovss  [rsp+88h+var_58], xmm6
    vmovss  [rsp+88h+goalTime], xmm7
    vmovss  dword ptr [rsp+88h+fmt], xmm6
  }
  XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, v12, fmt, goalTime, v22, (scr_string_t)0, 0, 0, LINEAR, NULL);
  if ( v11 )
  {
    __asm
    {
      vmovss  [rsp+88h+var_58], xmm6
      vmovss  [rsp+88h+goalTime], xmm7
      vmovss  dword ptr [rsp+88h+fmt], xmm6
    }
    XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, v13, fmta, goalTimea, v23, (scr_string_t)0, 0, 0, LINEAR, NULL);
  }
  __asm
  {
    vmovaps xmm6, [rsp+88h+var_18]
    vmovaps xmm7, [rsp+88h+var_28]
  }
}

/*
==============
StoreShieldPersistentAnims
==============
*/
void StoreShieldPersistentAnims(const WeaponHand *weapHand, float *outAnimWeights, float *outAnimTimes, const XAnimParts **outShieldXParts)
{
  XAnimTree *tree; 
  bool v10; 
  XAnimTree *v14; 
  const XAnim_s *Anims; 
  const XAnimParts *Parts; 
  const XAnimParts *v17; 
  unsigned int v18; 

  if ( !weapHand && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10124, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
    __debugbreak();
  if ( !outAnimWeights && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10125, ASSERT_TYPE_ASSERT, "(outAnimWeights)", (const char *)&queryFormat, "outAnimWeights") )
    __debugbreak();
  if ( !outAnimTimes && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10126, ASSERT_TYPE_ASSERT, "(outAnimTimes)", (const char *)&queryFormat, "outAnimTimes") )
    __debugbreak();
  tree = weapHand->tree;
  v10 = tree && tree->anims;
  _RBX = (unsigned int *)s_shieldPersistentAnims;
  _R12 = (char *)outAnimWeights - (char *)s_shieldPersistentAnims;
  _R15 = (char *)outAnimTimes - (char *)s_shieldPersistentAnims;
  do
  {
    *(unsigned int *)((char *)_RBX + _R12) = 0;
    *(unsigned int *)((char *)_RBX + _R15) = 0;
    *outShieldXParts = NULL;
    if ( v10 )
    {
      v14 = weapHand->tree;
      if ( (signed int)*_RBX < (signed int)v14->anims->size )
      {
        Anims = XAnimGetAnims(v14);
        if ( !Anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10148, ASSERT_TYPE_ASSERT, "(anims)", (const char *)&queryFormat, "anims") )
          __debugbreak();
        Parts = XAnimGetParts(Anims, *_RBX);
        v17 = XAnimGetParts(Anims, 0xECu);
        if ( *_RBX == 236 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 10151, ASSERT_TYPE_ASSERT, "(s_shieldPersistentAnims[persistAnimIndex] != WEAP_ANIM_IDLE)", (const char *)&queryFormat, "s_shieldPersistentAnims[persistAnimIndex] != WEAP_ANIM_IDLE") )
          __debugbreak();
        if ( Parts )
        {
          if ( Parts != v17 )
          {
            *(double *)&_XMM0 = XAnimGetWeight(weapHand->tree, 0, XANIM_SUBTREE_DEFAULT, *_RBX);
            v18 = *_RBX;
            __asm { vmovss  dword ptr [r12+rbx], xmm0 }
            *(double *)&_XMM0 = XAnimGetTime(weapHand->tree, 0, XANIM_SUBTREE_DEFAULT, v18);
            __asm { vmovss  dword ptr [r15+rbx], xmm0 }
            *outShieldXParts = Parts;
          }
        }
      }
    }
    ++_RBX;
    ++outShieldXParts;
  }
  while ( (__int64)_RBX < (__int64)&dword_1442D8E94 );
}

/*
==============
CgWeaponSystem::TryBulletScriptableImpact
==============
*/
void CgWeaponSystem::TryBulletScriptableImpact(CgWeaponSystem *this, const int triggerTime, bool needsDeferring, const unsigned int inflictorEntNum, const unsigned int targetEntityNum, const Weapon *weapon, bool isAlternate, const meansOfDeath_t mod, const vec3_t *start, const vec3_t *hitPos, const scr_string_t hitPartName)
{
  if ( needsDeferring )
  {
    _RAX = CgSimBulletFirePellet_GetQueueEntry();
    if ( _RAX )
    {
      _RAX->event.hitEffect.targetEntityNum = targetEntityNum;
      _RCX = weapon;
      _RAX->event.eventTriggerTime = triggerTime;
      _RAX->event.type = CgSimBulletFirePellet_EventType_BulletScriptableImpact;
      _RAX->event.hitEffect.sourceEntityNum = inflictorEntNum;
      __asm
      {
        vmovups ymm0, ymmword ptr [rcx]
        vmovups ymmword ptr [rax+10h], ymm0
        vmovups xmm1, xmmword ptr [rcx+20h]
        vmovups xmmword ptr [rax+30h], xmm1
        vmovsd  xmm0, qword ptr [rcx+30h]
        vmovsd  qword ptr [rax+40h], xmm0
      }
      *(_DWORD *)&_RAX->event.spawnTracer.r_weapon.stickerIndices[3] = *(_DWORD *)&weapon->weaponCamo;
      _RAX->event.hitEffect.weapon.attachmentVariationIndices[25] = isAlternate;
      _RAX->event.bulletScriptableImpact.mod = mod;
      _RAX->event.bulletScriptableImpact.start = *start;
      _RAX->event.bulletScriptableImpact.hitPos = *hitPos;
      _RAX->event.bulletScriptableImpact.hitPartName = hitPartName;
      _RAX->valid = 1;
    }
  }
  else
  {
    CgWeaponSystem::BulletScriptableImpact(this, inflictorEntNum, targetEntityNum, weapon, isAlternate, mod, start, hitPos, hitPartName);
  }
}

/*
==============
CgWeaponSystem::TryCG_Glass_BreakGlass
==============
*/
void CgWeaponSystem::TryCG_Glass_BreakGlass(CgWeaponSystem *this, bool needsDeferring, LocalClientNum_t localClientNum, const vec3_t *cameraPosition, unsigned __int16 glassPieceIndex, const vec3_t *hitPosition, const vec3_t *hitDirection)
{
  CgSimBulletFirePellet_MainThreadEvent_QueueEntry *QueueEntry; 

  if ( needsDeferring )
  {
    QueueEntry = CgSimBulletFirePellet_GetQueueEntry();
    if ( QueueEntry )
    {
      QueueEntry->event.type = CgSimBulletFirePellet_EventType_BreakGlass;
      QueueEntry->event.hitEffect.sourceEntityNum = localClientNum;
      QueueEntry->event.hitEffect.targetEntityNum = LODWORD(cameraPosition->v[0]);
      QueueEntry->event.hitEffect.targetScriptableIndex = LODWORD(cameraPosition->v[1]);
      QueueEntry->event.hitEffect.knownHitClientNum = LODWORD(cameraPosition->v[2]);
      QueueEntry->event.hitEffect.weapon.weaponIdx = glassPieceIndex;
      QueueEntry->event.breakGlass.hitPosition = *hitPosition;
      QueueEntry->event.breakGlass.hitDirection = *hitDirection;
      QueueEntry->valid = 1;
    }
  }
  else
  {
    CG_Glass_BreakGlass(localClientNum, cameraPosition, glassPieceIndex, hitPosition, hitDirection);
  }
}

/*
==============
CgWeaponSystem::TryCG_LaserBeamAdd
==============
*/
void CgWeaponSystem::TryCG_LaserBeamAdd(CgWeaponSystem *this, bool needsDeferring, const LocalClientNum_t localClientNum, const vec3_t *start, const vec3_t *end, const centity_t *owner, const Weapon *weapon, const bool isAlternate)
{
  CgSimBulletFirePellet_MainThreadEvent_QueueEntry *QueueEntry; 

  if ( needsDeferring )
  {
    QueueEntry = CgSimBulletFirePellet_GetQueueEntry();
    _RDX = QueueEntry;
    if ( QueueEntry )
    {
      QueueEntry->event.type = CgSimBulletFirePellet_EventType_LaserAdd;
      QueueEntry->event.hitEffect.sourceEntityNum = localClientNum;
      QueueEntry->event.hitEffect.targetEntityNum = LODWORD(start->v[0]);
      QueueEntry->event.hitEffect.targetScriptableIndex = LODWORD(start->v[1]);
      QueueEntry->event.hitEffect.knownHitClientNum = LODWORD(start->v[2]);
      QueueEntry->event.trackingLaserAdd.end = *end;
      QueueEntry->event.laserAdd.owner = owner;
      _RAX = weapon;
      __asm
      {
        vmovups ymm0, ymmword ptr [rax]
        vmovups ymmword ptr [rdx+30h], ymm0
        vmovups xmm1, xmmword ptr [rax+20h]
        vmovups xmmword ptr [rdx+50h], xmm1
        vmovsd  xmm0, qword ptr [rax+30h]
        vmovsd  qword ptr [rdx+60h], xmm0
      }
      _RDX->event.hitEffect.startPos.v[1] = *(float *)&weapon->weaponCamo;
      _RDX->event.trackingLaserAdd.weapon.attachmentVariationIndices[25] = isAlternate;
      _RDX->valid = 1;
    }
  }
  else
  {
    CG_LaserBeamAdd(localClientNum, start, end, owner, weapon, isAlternate, 0);
    if ( !owner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25250, ASSERT_TYPE_ASSERT, "(cent)", (const char *)&queryFormat, "cent") )
      __debugbreak();
  }
}

/*
==============
CgWeaponSystem::TryCG_TrackingLaserBeamAdd
==============
*/
void CgWeaponSystem::TryCG_TrackingLaserBeamAdd(CgWeaponSystem *this, bool needsDeferring, const LocalClientNum_t localClientNum, const vec3_t *start, const vec3_t *end, const centity_t *owner, const Weapon *weapon, const bool isAlternate, const int shotIndex, const int trackedEntNum, const scr_string_t autoTargetEntTag, const vec3_t *tagOffset, const float aimSpreadAmount)
{
  CgSimBulletFirePellet_MainThreadEvent_QueueEntry *QueueEntry; 
  float v23; 

  if ( needsDeferring )
  {
    QueueEntry = CgSimBulletFirePellet_GetQueueEntry();
    _RDX = QueueEntry;
    if ( QueueEntry )
    {
      QueueEntry->event.type = CgSimBulletFirePellet_EventType_TrackingLaserAdd;
      QueueEntry->event.hitEffect.sourceEntityNum = localClientNum;
      QueueEntry->event.hitEffect.targetEntityNum = LODWORD(start->v[0]);
      QueueEntry->event.hitEffect.targetScriptableIndex = LODWORD(start->v[1]);
      QueueEntry->event.hitEffect.knownHitClientNum = LODWORD(start->v[2]);
      QueueEntry->event.trackingLaserAdd.end = *end;
      QueueEntry->event.trackingLaserAdd.owner = owner;
      _RAX = weapon;
      __asm
      {
        vmovups ymm0, ymmword ptr [rax]
        vmovups ymmword ptr [rdx+38h], ymm0
        vmovups xmm1, xmmword ptr [rax+20h]
        vmovups xmmword ptr [rdx+58h], xmm1
        vmovsd  xmm0, qword ptr [rax+30h]
        vmovsd  qword ptr [rdx+68h], xmm0
        vmovss  xmm0, [rsp+68h+aimSpreadAmount]
      }
      _RDX->event.missEffect.surfType = *(_DWORD *)&weapon->weaponCamo;
      _RDX->event.trackingLaserAdd.isAlternate = isAlternate;
      _RDX->event.trackingLaserAdd.shotIndex = shotIndex;
      _RDX->event.trackingLaserAdd.trackedEntNum = trackedEntNum;
      _RDX->event.spawnTracer.spawnDelay = autoTargetEntTag;
      _RDX->event.trackingLaserAdd.tagOffset = *tagOffset;
      __asm { vmovss  dword ptr [rdx+84h], xmm0 }
      _RDX->valid = 1;
    }
  }
  else
  {
    __asm
    {
      vmovss  xmm0, [rsp+68h+aimSpreadAmount]
      vmovss  [rsp+68h+var_18], xmm0
    }
    CG_TrackingLaserBeamAdd(localClientNum, start, end, owner, weapon, isAlternate, shotIndex, trackedEntNum, autoTargetEntTag, tagOffset, v23, 0);
    if ( !owner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 25250, ASSERT_TYPE_ASSERT, "(cent)", (const char *)&queryFormat, "cent") )
      __debugbreak();
  }
}

/*
==============
CgWeaponSystem::TrySimulateBulletFire_HitEffect
==============
*/
void CgWeaponSystem::TrySimulateBulletFire_HitEffect(CgWeaponSystem *this, const int triggerTime, bool needsDeferring, int sourceEntityNum, int targetEntityNum, unsigned int targetScriptableIndex, const int knownHitClientNum, const Weapon *weapon, bool isAlternate, const vec3_t *initialShootingPos, const vec3_t *startPos, const vec3_t *position, const vec3_t *normal, int surfType, unsigned int meansOfDeath, unsigned int impactEffects, int hitContents, const bool forceClientSideHandling)
{
  if ( needsDeferring )
  {
    _RAX = CgSimBulletFirePellet_GetQueueEntry();
    if ( _RAX )
    {
      _RAX->event.hitEffect.targetEntityNum = targetEntityNum;
      _RAX->event.hitEffect.targetScriptableIndex = targetScriptableIndex;
      _RAX->event.eventTriggerTime = triggerTime;
      _RAX->event.type = CgSimBulletFirePellet_EventType_HitEffect;
      _RAX->event.hitEffect.sourceEntityNum = sourceEntityNum;
      _RAX->event.hitEffect.knownHitClientNum = knownHitClientNum;
      _RCX = weapon;
      __asm
      {
        vmovups ymm0, ymmword ptr [rcx]
        vmovups ymmword ptr [rax+18h], ymm0
        vmovups xmm1, xmmword ptr [rcx+20h]
        vmovups xmmword ptr [rax+38h], xmm1
        vmovsd  xmm0, qword ptr [rcx+30h]
        vmovsd  qword ptr [rax+48h], xmm0
      }
      _RAX->event.bulletScriptableImpact.mod = *(_DWORD *)&weapon->weaponCamo;
      _RAX->event.hitEffect.isAlternate = isAlternate;
      _RAX->event.hitEffect.initialShootingPos = *initialShootingPos;
      _RAX->event.hitEffect.startPos = *startPos;
      _RAX->event.hitEffect.position = *position;
      _RAX->event.hitEffect.normal = *normal;
      _RAX->event.hitEffect.surfType = surfType;
      _RAX->event.hitEffect.meansOfDeath = meansOfDeath;
      _RAX->event.hitEffect.impactEffects = impactEffects;
      _RAX->event.hitEffect.hitContents = hitContents;
      _RAX->event.hitEffect.forceClientSideHandling = forceClientSideHandling;
      _RAX->valid = 1;
    }
  }
  else
  {
    this->SimulateBulletFire_HitEffect(this, sourceEntityNum, targetEntityNum, targetScriptableIndex, knownHitClientNum, weapon, isAlternate, initialShootingPos, startPos, position, normal, surfType, meansOfDeath, impactEffects, hitContents, forceClientSideHandling);
  }
}

/*
==============
CgWeaponSystem::TrySimulateBulletFire_MissEffect
==============
*/
void CgWeaponSystem::TrySimulateBulletFire_MissEffect(CgWeaponSystem *this, const int triggerTime, bool needsDeferring, int sourceEntityNum, const Weapon *weapon, bool isAlternate, const vec3_t *initialShootingPos, const vec3_t *startPos, const vec3_t *position, int surfType)
{
  if ( needsDeferring )
  {
    _RAX = CgSimBulletFirePellet_GetQueueEntry();
    if ( _RAX )
    {
      _RCX = weapon;
      _RAX->event.eventTriggerTime = triggerTime;
      _RAX->event.type = CgSimBulletFirePellet_EventType_MissEffect;
      _RAX->event.hitEffect.sourceEntityNum = sourceEntityNum;
      __asm
      {
        vmovups ymm0, ymmword ptr [rcx]
        vmovups ymmword ptr [rax+0Ch], ymm0
        vmovups xmm1, xmmword ptr [rcx+20h]
        vmovups xmmword ptr [rax+2Ch], xmm1
        vmovsd  xmm0, qword ptr [rcx+30h]
        vmovsd  qword ptr [rax+3Ch], xmm0
      }
      *(_DWORD *)&_RAX->event.spawnTracer.r_weapon.stickerIndices[1] = *(_DWORD *)&weapon->weaponCamo;
      _RAX->event.hitEffect.weapon.attachmentVariationIndices[21] = isAlternate;
      _RAX->event.missEffect.initialShootingPos = *initialShootingPos;
      _RAX->event.hitEffect.initialShootingPos = *startPos;
      _RAX->event.hitEffect.startPos = *position;
      _RAX->event.missEffect.surfType = surfType;
      _RAX->valid = 1;
    }
  }
  else
  {
    this->SimulateBulletFire_MissEffect(this, sourceEntityNum, weapon, isAlternate, initialShootingPos, startPos, position, surfType);
  }
}

/*
==============
CgWeaponSystem::TrySpawnTracer
==============
*/
void CgWeaponSystem::TrySpawnTracer(CgWeaponSystem *this, const int bulletId, bool needsDeferring, bool blendFromViewmodel, const int inflictorEntNum, const bitarray<64> *r_inflictorPerks, PlayerHandIndex hand, const TagPair sourceTagPair, const vec3_t *tracerStart, const vec3_t *tracerEnd, const Weapon *r_weapon, bool isAlternate, int spawnDelay)
{
  CgSimBulletFirePellet_MainThreadEvent_QueueEntry *QueueEntry; 
  scr_string_t FallbackTagName; 
  const vec3_t *v18; 
  float v19; 
  const vec3_t *v20; 

  if ( needsDeferring )
  {
    QueueEntry = CgSimBulletFirePellet_GetQueueEntry();
    _RBX = QueueEntry;
    if ( QueueEntry )
    {
      QueueEntry->event.hitEffect.targetScriptableIndex = inflictorEntNum;
      QueueEntry->event.type = CgSimBulletFirePellet_EventType_SpawnTracer;
      QueueEntry->event.hitEffect.sourceEntityNum = bulletId;
      QueueEntry->event.spawnTracer.blendFromViewmodel = blendFromViewmodel;
      QueueEntry->event.spawnTracer.inflictorPerks = *r_inflictorPerks;
      QueueEntry->event.spawnTracer.hand = hand;
      QueueEntry->event.spawnTracer.sourcePrimaryTagName = TagPair::GetPrimaryTagName((TagPair *)&sourceTagPair);
      FallbackTagName = TagPair::GetFallbackTagName((TagPair *)&sourceTagPair);
      v18 = tracerStart;
      _RBX->event.spawnTracer.sourceFallbackTagName = FallbackTagName;
      _RBX->event.trackingLaserAdd.tagOffset.v[1] = v18->v[0];
      _RBX->event.trackingLaserAdd.tagOffset.v[2] = v18->v[1];
      v19 = v18->v[2];
      v20 = tracerEnd;
      _RBX->event.breakGlass.hitDirection.v[2] = v19;
      _RBX->event.spawnTracer.tracerEnd = *v20;
      _RAX = r_weapon;
      __asm
      {
        vmovups ymm0, ymmword ptr [rax]
        vmovups ymmword ptr [rbx+40h], ymm0
        vmovups xmm1, xmmword ptr [rax+20h]
        vmovups xmmword ptr [rbx+60h], xmm1
        vmovsd  xmm0, qword ptr [rax+30h]
        vmovsd  qword ptr [rbx+70h], xmm0
      }
      _RBX->event.trackingLaserAdd.shotIndex = *(_DWORD *)&_RAX->weaponCamo;
      _RBX->event.spawnTracer.isAlternate = isAlternate;
      _RBX->event.spawnTracer.spawnDelay = spawnDelay;
      _RBX->valid = 1;
    }
  }
  else
  {
    CgWeaponSystem::SpawnTracer(this, bulletId, blendFromViewmodel, inflictorEntNum, r_inflictorPerks, hand, sourceTagPair, tracerStart, tracerEnd, r_weapon, isAlternate, spawnDelay);
  }
}

/*
==============
MovementAnimState::Update
==============
*/
void MovementAnimState::Update(MovementAnimState *this, const LocalClientNum_t localClientNum, const PlayerHandIndex hand, const playerState_s *ps)
{
  MovementAnimState::State newGoal; 
  bool IsSuperSprinting; 
  bool v10; 
  bool IsJogging; 

  if ( !this->m_isInitialized )
    MovementAnimState::Reset(this, localClientNum, hand);
  newGoal = NONE;
  if ( this->m_goal == -1 )
    MovementAnimState::UpdateInternal(this, localClientNum, hand, ps, NONE);
  if ( !MovementAnimState::PlayerActionForcesWalk(localClientNum, ps) )
  {
    IsSuperSprinting = BG_IsSuperSprinting(ps);
    v10 = !IsSuperSprinting && GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 0x14u);
    IsJogging = CG_IsJogging(localClientNum);
    if ( IsSuperSprinting )
    {
      newGoal = LONG;
    }
    else if ( v10 )
    {
      newGoal = HALF_HALF;
    }
    else
    {
      LOBYTE(newGoal) = IsJogging;
    }
  }
  MovementAnimState::UpdateInternal(this, localClientNum, hand, ps, newGoal);
}

/*
==============
UpdateAdditiveCrawlAnims
==============
*/
void UpdateAdditiveCrawlAnims(LocalClientNum_t localClientNum, const playerState_s *ps, DObj *obj, const PlayerHandIndex hand)
{
  const dvar_t *v15; 
  XAnimTree *Tree; 
  const dvar_t *v66; 
  int firstProneCrawlLoopTime; 
  int time; 
  const dvar_t *v84; 
  char v87; 
  char v88; 
  bool v93; 
  bool v94; 
  CgHandler *Handler; 
  CgHandler *v105; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float fmtc; 
  float fmtd; 
  float fmte; 
  float fmtf; 
  float fmtg; 
  float fmth; 
  float fmti; 
  double goalTime; 
  float goalTimea; 
  float goalTimeb; 
  float goalTimec; 
  float goalTimed; 
  float goalTimee; 
  float goalTimef; 
  double rate; 
  float ratea; 
  float rateb; 
  float ratec; 
  float rated; 
  float ratee; 
  float ratef; 
  double notifyName; 
  BobCycle v147; 
  __int64 v148; 
  vec3_t forward; 
  vec3_t right; 
  char v154; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-58h], xmm6
    vmovaps xmmword ptr [rax-68h], xmm7
    vmovaps xmmword ptr [rax-78h], xmm8
    vmovaps xmmword ptr [rax-88h], xmm9
    vmovaps xmmword ptr [rax-98h], xmm10
    vmovaps xmmword ptr [rax-0A8h], xmm11
  }
  v15 = DCONST_DVARINT_cg_crawlBlendTime;
  _RSI = ps;
  if ( !DCONST_DVARINT_cg_crawlBlendTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_crawlBlendTime") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v15);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, dword ptr [rbx+28h]
    vmulss  xmm10, xmm0, cs:__real@3a83126f
    vxorps  xmm7, xmm7, xmm7
    vcomiss xmm10, xmm7
  }
  if ( v87 | v88 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4752, ASSERT_TYPE_ASSERT, "(CRAWL_BLEND_SECONDS > 0.0f)", (const char *)&queryFormat, "CRAWL_BLEND_SECONDS > 0.0f") )
    __debugbreak();
  _RBX = DCONST_DVARFLT_bg_crawlMaxSpeed;
  if ( !DCONST_DVARFLT_bg_crawlMaxSpeed && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_crawlMaxSpeed") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RBX);
  __asm
  {
    vmovss  xmm6, dword ptr [rbx+28h]
    vcomiss xmm6, xmm7
  }
  if ( v87 | v88 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4754, ASSERT_TYPE_ASSERT, "(CRAWL_MAX_SPEED > 0.0f)", (const char *)&queryFormat, "CRAWL_MAX_SPEED > 0.0f") )
    __debugbreak();
  if ( !_RSI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4771, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4772, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  if ( !IsAdditiveCrawlEnabled(localClientNum, _RSI, hand) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4773, ASSERT_TYPE_ASSERT, "(IsAdditiveCrawlEnabled( localClientNum, ps, hand ))", (const char *)&queryFormat, "IsAdditiveCrawlEnabled( localClientNum, ps, hand )") )
    __debugbreak();
  Tree = DObjGetTree(obj);
  if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4776, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
    __debugbreak();
  _R14 = CG_GetLocalClientGlobals(localClientNum);
  if ( !_RSI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_playerstate.h", 1145, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  __asm { vmovss  xmm1, cs:__real@40a00000; maxAbsValueSize }
  *(double *)&_XMM0 = MSG_UnpackUnsignedFloat(_RSI->moveSpeedScaleMultiplier, *(float *)&_XMM1, 0xCu);
  __asm
  {
    vcomiss xmm0, xmm7
    vmovss  xmm8, cs:__real@3f800000
  }
  if ( v87 | v88 )
  {
    __asm { vdivss  xmm6, xmm8, xmm6 }
  }
  else
  {
    __asm
    {
      vmulss  xmm0, xmm0, xmm6
      vdivss  xmm6, xmm8, xmm0
    }
  }
  AngleVectors(&_RSI->viewangles, &forward, &right, NULL);
  __asm
  {
    vmovss  xmm4, dword ptr [rsi+3Ch]
    vmulss  xmm1, xmm4, dword ptr [rsp+1A8h+forward]
    vmovss  xmm3, dword ptr [rsi+40h]
    vmulss  xmm0, xmm3, dword ptr [rsp+1A8h+forward+4]
    vmovss  xmm5, dword ptr [rsi+44h]
    vmulss  xmm3, xmm3, dword ptr [rsp+1A8h+right+4]
    vaddss  xmm2, xmm1, xmm0
    vmulss  xmm1, xmm5, dword ptr [rsp+1A8h+forward+8]
    vaddss  xmm2, xmm2, xmm1
    vmulss  xmm1, xmm5, dword ptr [rsp+1A8h+right+8]
    vmulss  xmm0, xmm2, xmm6; val
    vmulss  xmm2, xmm4, dword ptr [rsp+1A8h+right]
    vaddss  xmm4, xmm3, xmm2
    vaddss  xmm2, xmm4, xmm1
    vmovss  xmm1, cs:__real@bf800000; min
    vmulss  xmm6, xmm2, xmm6
    vmovaps xmm2, xmm8; max
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm
  {
    vmovss  xmm1, cs:__real@bf800000; min
    vmovaps xmm9, xmm0
    vmovaps xmm0, xmm6; val
    vmovaps xmm2, xmm8; max
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm
  {
    vmulss  xmm1, xmm9, xmm9
    vmulss  xmm3, xmm1, cs:__real@41800000
    vmulss  xmm2, xmm0, xmm0
    vaddss  xmm3, xmm3, xmm2
    vsqrtss xmm4, xmm3, xmm3
    vcmpless xmm1, xmm4, cs:__real@80000000
    vblendvps xmm1, xmm4, xmm8, xmm1
    vdivss  xmm1, xmm8, xmm1
    vmulss  xmm11, xmm1, xmm0
    vmovaps xmm1, xmm9; right
    vmovaps xmm6, xmm0
  }
  UpdateAdditiveCrawlBlend(_R14->frametime, *(float *)&_XMM1, &_R14->crawlForwardBlend);
  __asm { vmovaps xmm1, xmm11; right }
  UpdateAdditiveCrawlBlend(_R14->frametime, *(float *)&_XMM1, &_R14->crawlRightBlend);
  v66 = DVARBOOL_killswitch_crawl_vm_left_right_blend_enabled;
  if ( !DVARBOOL_killswitch_crawl_vm_left_right_blend_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_crawl_vm_left_right_blend_enabled") )
    __debugbreak();
  __asm { vmovaps [rsp+1A8h+var_B8], xmm12 }
  Dvar_CheckFrontendServerThread(v66);
  __asm { vmovss  xmm12, dword ptr cs:__xmm@7fffffff7fffffff7fffffff7fffffff }
  if ( v66->current.enabled )
  {
    __asm
    {
      vmovss  xmm6, dword ptr [r14+6634h]
      vandps  xmm6, xmm6, xmm12
    }
  }
  else
  {
    __asm
    {
      vandps  xmm6, xmm6, xmm12
      vandps  xmm9, xmm9, xmm12
      vmaxss  xmm6, xmm6, xmm9
    }
  }
  *(double *)&_XMM0 = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x6Cu);
  __asm
  {
    vucomiss xmm0, xmm8
    vmovss  dword ptr [rsp+1A8h+fmt], xmm6
  }
  XAnimSetAnimRate(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x6Cu, fmt);
  *(double *)&_XMM0 = XAnimGetWeight(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x6Cu);
  __asm
  {
    vmovss  xmm1, cs:__real@3f000000
    vcomiss xmm0, xmm1
  }
  if ( !v87 )
  {
    firstProneCrawlLoopTime = _R14->firstProneCrawlLoopTime;
    time = _R14->time;
    __asm
    {
      vmovaps [rsp+1A8h+var_C8], xmm13
      vmovaps [rsp+1A8h+var_D8], xmm14
      vsubss  xmm0, xmm0, xmm1
      vmulss  xmm14, xmm0, cs:__real@40000000
      vmovaps xmm13, xmm14
    }
    if ( firstProneCrawlLoopTime == -1 )
      _R14->firstProneCrawlLoopTime = time;
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, eax
      vmulss  xmm1, xmm0, cs:__real@3a83126f
      vsubss  xmm0, xmm10, xmm1; val
      vxorps  xmm1, xmm1, xmm1; min
      vmovaps xmm2, xmm8; max
    }
    *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
    v84 = DVARBOOL_killswitch_crawl_vm_left_right_blend_enabled;
    __asm { vmovaps xmm10, xmm0 }
    if ( !DVARBOOL_killswitch_crawl_vm_left_right_blend_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_crawl_vm_left_right_blend_enabled") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v84);
    if ( v84->current.enabled )
      __asm { vmovss  xmm11, dword ptr [r14+6638h] }
    *(double *)&_XMM0 = BG_GetBobCycleAnimTime((const int (*)[2])_RSI->packedBobCycle);
    __asm { vmovaps xmm9, xmm0 }
    BobCycle::UnpackBobCycle(&v147, (const int (*)[2])_RSI->packedBobCycle);
    __asm
    {
      vcomiss xmm9, xmm7
      vmovsd  xmm2, qword ptr [rsp+1A8h+var_148.amplitudeRatioGun]
      vmovsd  [rsp+1A8h+var_118], xmm2
    }
    if ( v87 )
      goto LABEL_69;
    __asm { vcomiss xmm9, xmm8 }
    if ( !(v87 | v88) )
    {
LABEL_69:
      __asm
      {
        vmovsd  xmm0, cs:__real@3ff0000000000000
        vmovsd  qword ptr [rsp+1A8h+notifyName], xmm0
        vxorpd  xmm1, xmm1, xmm1
        vmovsd  qword ptr [rsp+1A8h+rate], xmm1
        vcvtss2sd xmm2, xmm9, xmm9
        vmovsd  qword ptr [rsp+1A8h+goalTime], xmm2
      }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4688, ASSERT_TYPE_ASSERT, "( 0.0f ) <= ( animTime ) && ( animTime ) <= ( 1.0f )", "animTime not in [0.0f, 1.0f]\n\t%g not in [%g, %g]", goalTime, rate, notifyName) )
        __debugbreak();
    }
    _RBX = CG_GetLocalClientGlobals(localClientNum);
    v93 = _RBX == NULL;
    if ( !_RBX )
    {
      v94 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4691, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob");
      v93 = !v94;
      if ( v94 )
        __debugbreak();
    }
    __asm
    {
      vmovss  xmm0, dword ptr [rbx+6614h]
      vucomiss xmm0, cs:__real@bf800000
      vxorps  xmm1, xmm1, xmm1
    }
    if ( !v93 )
    {
      __asm
      {
        vcomiss xmm0, xmm7
        vcomiss xmm0, xmm8
      }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4697, ASSERT_TYPE_ASSERT, "(0.0f <= cgameGlob->prevProneForwardAnimTime && cgameGlob->prevProneForwardAnimTime < 1.0f)", (const char *)&queryFormat, "0.0f <= cgameGlob->prevProneForwardAnimTime && cgameGlob->prevProneForwardAnimTime < 1.0f") )
        __debugbreak();
      __asm
      {
        vmovss  xmm0, dword ptr [rbx+6614h]
        vmovaps xmm1, xmm0
      }
      v93 = BYTE4(v148) == 0;
      if ( BYTE4(v148) )
      {
        __asm
        {
          vcomiss xmm9, xmm0
          vaddss  xmm1, xmm0, xmm8
        }
      }
      else
      {
        __asm { vcomiss xmm9, xmm0 }
      }
      __asm
      {
        vsubss  xmm1, xmm9, xmm1
        vandps  xmm1, xmm1, xmm12
      }
    }
    __asm
    {
      vcomiss xmm11, xmm7
      vmovss  dword ptr [rbx+6614h], xmm9
    }
    if ( !v93 )
    {
      __asm
      {
        vaddss  xmm0, xmm1, dword ptr [rbx+6618h]
        vcomiss xmm0, xmm8
        vmovss  dword ptr [rbx+6618h], xmm0
        vsubss  xmm0, xmm0, xmm8
        vmovss  dword ptr [rbx+6618h], xmm0
      }
    }
    Handler = CgHandler::getHandler(localClientNum);
    if ( BG_ViewModelAnimExists(_RSI, WEAP_ANIM_ADDITIVE_CRAWL_LOOP_LEFT, hand, Handler) )
    {
      __asm
      {
        vcomiss xmm11, xmm7
        vxorps  xmm0, xmm0, xmm0
        vmulss  xmm6, xmm0, xmm14
        vmovss  [rsp+1A8h+rate], xmm7
        vmovss  [rsp+1A8h+goalTime], xmm10
        vmovss  dword ptr [rsp+1A8h+fmt], xmm6
        vsubss  xmm13, xmm14, xmm6
      }
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x6Fu, fmta, goalTimea, ratea, (scr_string_t)0, 0, 0, LINEAR, NULL);
      __asm
      {
        vmovss  [rsp+1A8h+rate], xmm7
        vmovss  [rsp+1A8h+goalTime], xmm10
        vmovss  dword ptr [rsp+1A8h+fmt], xmm6
      }
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x70u, fmtb, goalTimeb, rateb, (scr_string_t)0, 0, 0, LINEAR, NULL);
      __asm
      {
        vmovss  xmm0, dword ptr [r14+6618h]
        vmovss  dword ptr [rsp+1A8h+fmt], xmm0
      }
      XAnimSetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x70u, fmtc);
    }
    v105 = CgHandler::getHandler(localClientNum);
    if ( BG_ViewModelAnimExists(_RSI, WEAP_ANIM_ADDITIVE_CRAWL_LOOP_RIGHT, hand, v105) )
    {
      __asm
      {
        vmaxss  xmm0, xmm11, xmm7
        vmulss  xmm6, xmm0, xmm14
        vmovss  [rsp+1A8h+rate], xmm7
        vmovss  [rsp+1A8h+goalTime], xmm10
        vmovss  dword ptr [rsp+1A8h+fmt], xmm6
        vsubss  xmm13, xmm13, xmm6
      }
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x71u, fmtd, goalTimec, ratec, (scr_string_t)0, 0, 0, LINEAR, NULL);
      __asm
      {
        vmovss  [rsp+1A8h+rate], xmm7
        vmovss  [rsp+1A8h+goalTime], xmm10
        vmovss  dword ptr [rsp+1A8h+fmt], xmm6
      }
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x72u, fmte, goalTimed, rated, (scr_string_t)0, 0, 0, LINEAR, NULL);
      __asm
      {
        vmovss  xmm1, dword ptr [r14+6618h]
        vmovss  dword ptr [rsp+1A8h+fmt], xmm1
      }
      XAnimSetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x72u, fmtf);
    }
    __asm
    {
      vmovaps xmm2, xmm8; max
      vxorps  xmm1, xmm1, xmm1; min
      vmovaps xmm0, xmm13; val
    }
    *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
    __asm
    {
      vmovss  [rsp+1A8h+rate], xmm7
      vmovss  [rsp+1A8h+goalTime], xmm10
      vmovss  dword ptr [rsp+1A8h+fmt], xmm0
      vmovaps xmm6, xmm0
    }
    XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x6Du, fmtg, goalTimee, ratee, (scr_string_t)0, 0, 0, LINEAR, NULL);
    __asm
    {
      vmovss  [rsp+1A8h+rate], xmm7
      vmovss  [rsp+1A8h+goalTime], xmm10
      vmovss  dword ptr [rsp+1A8h+fmt], xmm6
    }
    XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0x6Eu, fmth, goalTimef, ratef, (scr_string_t)0, 0, 0, LINEAR, NULL);
    __asm { vmovss  dword ptr [rsp+1A8h+fmt], xmm9 }
    XAnimSetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, 0x6Eu, fmti);
    __asm
    {
      vmovaps xmm14, [rsp+1A8h+var_D8]
      vmovaps xmm13, [rsp+1A8h+var_C8]
    }
  }
  __asm { vmovaps xmm12, [rsp+1A8h+var_B8] }
  _R11 = &v154;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-18h]
    vmovaps xmm7, xmmword ptr [r11-28h]
    vmovaps xmm8, xmmword ptr [r11-38h]
    vmovaps xmm9, xmmword ptr [r11-48h]
    vmovaps xmm10, xmmword ptr [r11-58h]
    vmovaps xmm11, xmmword ptr [r11-68h]
  }
}

/*
==============
UpdateAdditiveCrawlBlend
==============
*/

void __fastcall UpdateAdditiveCrawlBlend(int timeMs, double right, float *inOutRightBlended)
{
  const dvar_t *v11; 
  char v17; 
  char v18; 
  double v26; 
  __int128 v27; 

  __asm
  {
    vcomiss xmm1, cs:__real@bf800000
    vmovaps [rsp+68h+var_18], xmm6
  }
  _RDI = inOutRightBlended;
  __asm
  {
    vmovaps [rsp+68h+var_28], xmm7
    vmovss  xmm7, cs:__real@3f800000
    vmovaps xmm6, xmm1
    vcomiss xmm1, xmm7
    vmovaps xmm0, cs:__xmm@3ff0000000000000bff0000000000000
    vmovups [rsp+68h+var_38], xmm0
    vcvtss2sd xmm2, xmm6, xmm6
    vmovsd  [rsp+68h+var_40], xmm2
  }
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4734, ASSERT_TYPE_ASSERT, "( -1.0f ) <= ( right ) && ( right ) <= ( 1.0f )", "right not in [-1.0f, 1.0f]\n\t%g not in [%g, %g]", v26, *(double *)&v27, *((double *)&v27 + 1)) )
    __debugbreak();
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 4735, ASSERT_TYPE_ASSERT, "(inOutRightBlended)", (const char *)&queryFormat, "inOutRightBlended") )
    __debugbreak();
  if ( timeMs > 0 )
  {
    v11 = DCONST_DVARINT_cg_crawlBlendDirTime;
    if ( !DCONST_DVARINT_cg_crawlBlendDirTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_crawlBlendDirTime") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v11);
    __asm
    {
      vxorps  xmm1, xmm1, xmm1
      vcvtsi2ss xmm1, xmm1, dword ptr [rbx+28h]
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, esi
      vdivss  xmm2, xmm1, xmm0
      vcomiss xmm2, xmm7
    }
    if ( !(v17 | v18) )
    {
      __asm
      {
        vmovss  xmm1, dword ptr [rdi]
        vdivss  xmm3, xmm7, xmm2
        vmulss  xmm0, xmm3, xmm1
        vsubss  xmm2, xmm1, xmm0
        vmulss  xmm1, xmm3, xmm6
        vaddss  xmm6, xmm2, xmm1
      }
    }
    __asm { vmovss  dword ptr [rdi], xmm6 }
  }
  __asm
  {
    vmovaps xmm6, [rsp+68h+var_18]
    vmovaps xmm7, [rsp+68h+var_28]
  }
}

/*
==============
MovementAnimState::UpdateInternal
==============
*/
void MovementAnimState::UpdateInternal(MovementAnimState *this, const LocalClientNum_t localClientNum, const PlayerHandIndex hand, const playerState_s *ps, const MovementAnimState::State newGoal)
{
  __int64 v11; 
  cg_t *LocalClientGlobals; 
  const DObj **p_viewModelDObj; 
  XAnimTree *Tree; 
  MovementAnimState::State v17; 
  unsigned __int32 v18; 
  MovementAnimState::State m_goal; 
  const XAnimParts *const *normalAnimArray; 
  weapAnimFiles_t v26; 
  unsigned int m_cycleAnim; 
  int v28; 
  char v32; 
  weapAnimFiles_t OffsetAnimation; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float fmtc; 
  float fmtd; 
  float fmte; 
  float outTransDurationSec; 
  float outTransDurationSeca; 
  float outTransDurationSecb; 
  float outTransDurationSecc; 
  float outTransDurationSecd; 
  float outTransDurationSece; 
  float outCycleTransDurationSec; 
  float outCycleTransDurationSeca; 
  float outCycleTransDurationSecb; 
  float outCycleTransDurationSecc; 
  float outCycleTransDurationSecd; 
  float outCycleTransDurationSece; 
  float outPrevRate; 
  float outBlendTime; 
  float outNextRate; 
  weapAnimFiles_t outNextAnim; 
  float v63; 

  v11 = hand;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( (unsigned int)v11 >= 2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v11, 2) )
    __debugbreak();
  p_viewModelDObj = (const DObj **)&LocalClientGlobals->m_weaponHand[v11].viewModelDObj;
  if ( (cg_t *)((char *)LocalClientGlobals + 40 * v11) == (cg_t *)-807496i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5431, ASSERT_TYPE_ASSERT, "(weapHand)", (const char *)&queryFormat, "weapHand") )
    __debugbreak();
  if ( *p_viewModelDObj )
  {
    Tree = DObjGetTree(*p_viewModelDObj);
    if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5439, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
      __debugbreak();
    if ( !Tree->anims && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5440, ASSERT_TYPE_ASSERT, "(animTree->anims)", (const char *)&queryFormat, "animTree->anims") )
      __debugbreak();
    v17 = newGoal;
    v18 = this->m_offsetAnim - 50;
    if ( newGoal == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5444, ASSERT_TYPE_ASSERT, "(newGoal != State::NONE)", (const char *)&queryFormat, "newGoal != State::NONE") )
      __debugbreak();
    m_goal = this->m_goal;
    __asm
    {
      vmovaps [rsp+0C8h+var_38], xmm6
      vmovaps [rsp+0C8h+var_48], xmm7
    }
    if ( m_goal == v17 )
    {
      if ( v18 <= 0xB )
      {
        *(double *)&_XMM0 = XAnimGetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, this->m_offsetAnim);
        __asm
        {
          vmovss  xmm7, cs:__real@3f800000
          vcomiss xmm0, xmm7
        }
        if ( !v32 )
        {
          OffsetAnimation = MovementAnimState::GetOffsetAnimation(this, (const MovementAnimState::State)this->m_goal);
          *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARMPFLT_movementAnimProto_TransitionBlendTime, "movementAnimProto_TransitionBlendTime");
          __asm
          {
            vmovss  dword ptr [rsp+0C8h+outCycleTransDurationSec], xmm7
            vxorps  xmm1, xmm1, xmm1
            vmovss  dword ptr [rsp+0C8h+outTransDurationSec], xmm0
            vmovss  dword ptr [rsp+0C8h+fmt], xmm1
            vmovaps xmm6, xmm0
          }
          XAnimSetGoalWeight(*p_viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, this->m_offsetAnim, fmtd, outTransDurationSecd, outCycleTransDurationSecd, (scr_string_t)0, 0, 0, LINEAR, NULL);
          __asm
          {
            vmovss  dword ptr [rsp+0C8h+outCycleTransDurationSec], xmm7
            vmovss  dword ptr [rsp+0C8h+outTransDurationSec], xmm6
            vmovss  dword ptr [rsp+0C8h+fmt], xmm7
          }
          XAnimSetGoalWeight(*p_viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, OffsetAnimation, fmte, outTransDurationSece, outCycleTransDurationSece, (scr_string_t)0, 0, 0, LINEAR, NULL);
          this->m_offsetAnim = OffsetAnimation;
        }
      }
      goto LABEL_35;
    }
    __asm
    {
      vmovaps [rsp+0C8h+var_58], xmm8
      vxorps  xmm7, xmm7, xmm7
      vmovss  [rsp+0C8h+var_68], xmm7
      vmovss  [rsp+0C8h+arg_10], xmm7
    }
    MovementAnimState::GetTransitionDuration(this, localClientNum, ps, m_goal, v17, &outPrevRate, &v63);
    normalAnimArray = (const XAnimParts *const *)LocalClientGlobals->m_weaponAnimArrays.normalAnimArray;
    if ( BG_UsingAlternate(ps) )
      normalAnimArray += 622;
    MovementAnimState::CalcOffsetTransitionParams(this, localClientNum, Tree, normalAnimArray, (const MovementAnimState::State)this->m_goal, v17, (const weapAnimFiles_t)this->m_offsetAnim, &outNextAnim, &outBlendTime, &outPrevRate, &outNextRate);
    __asm
    {
      vmovss  xmm0, [rsp+0C8h+var_68]
      vmovss  xmm6, [rsp+0C8h+var_64]
      vmovss  dword ptr [rsp+0C8h+outCycleTransDurationSec], xmm0
      vmovss  dword ptr [rsp+0C8h+outTransDurationSec], xmm6
      vmovss  dword ptr [rsp+0C8h+fmt], xmm7
    }
    XAnimSetGoalWeight(*p_viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, this->m_offsetAnim, fmt, outTransDurationSec, outCycleTransDurationSec, (scr_string_t)0, 0, 0, LINEAR, NULL);
    __asm
    {
      vmovss  xmm0, [rsp+0C8h+var_60]
      vmovss  xmm8, cs:__real@3f800000
    }
    v26 = outNextAnim;
    __asm
    {
      vmovss  dword ptr [rsp+0C8h+outCycleTransDurationSec], xmm0
      vmovss  dword ptr [rsp+0C8h+outTransDurationSec], xmm6
      vmovss  dword ptr [rsp+0C8h+fmt], xmm8
    }
    XAnimSetGoalWeight(*p_viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, outNextAnim, fmta, outTransDurationSeca, outCycleTransDurationSeca, (scr_string_t)0, 0, 0, LINEAR, NULL);
    m_cycleAnim = this->m_cycleAnim;
    if ( v17 == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5781, ASSERT_TYPE_ASSERT, "(state != State::NONE)", (const char *)&queryFormat, "state != State::NONE") )
      __debugbreak();
    if ( v17 )
    {
      switch ( v17 )
      {
        case HALF:
          v28 = 64;
          goto LABEL_31;
        case HALF_HALF:
          v28 = 65;
          goto LABEL_31;
        case LONG:
          v28 = 66;
LABEL_31:
          __asm
          {
            vmovss  xmm6, [rsp+0C8h+arg_10]
            vmovss  dword ptr [rsp+0C8h+outCycleTransDurationSec], xmm7
            vmovss  dword ptr [rsp+0C8h+outTransDurationSec], xmm6
            vmovss  dword ptr [rsp+0C8h+fmt], xmm7
          }
          XAnimSetGoalWeight(*p_viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, m_cycleAnim, fmtb, outTransDurationSecb, outCycleTransDurationSecb, (scr_string_t)0, 0, 0, LINEAR, NULL);
          __asm
          {
            vmovss  dword ptr [rsp+0C8h+outCycleTransDurationSec], xmm7
            vmovss  dword ptr [rsp+0C8h+outTransDurationSec], xmm6
            vmovss  dword ptr [rsp+0C8h+fmt], xmm8
          }
          XAnimSetGoalWeight(*p_viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, v28, fmtc, outTransDurationSecc, outCycleTransDurationSecc, (scr_string_t)0, 0, 0, LINEAR, NULL);
          __asm { vmovaps xmm8, [rsp+0C8h+var_58] }
          this->m_goal = v17;
          this->m_offsetAnim = v26;
          this->m_cycleAnim = v28;
LABEL_35:
          __asm
          {
            vmovaps xmm6, [rsp+0C8h+var_38]
            vmovaps xmm7, [rsp+0C8h+var_48]
          }
          return;
      }
    }
    v28 = 63;
    goto LABEL_31;
  }
}

/*
==============
UpdateMovementAnimWeightRoot
==============
*/
float UpdateMovementAnimWeightRoot(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex hand, const Weapon *weapon)
{
  CgWeaponMap *Instance; 
  bool v15; 
  char v16; 
  char v17; 
  int suitIndex; 
  const SuitDef *SuitDef; 
  const SuitDef *v29; 
  char v31; 
  float outStartFrac[4]; 
  float outEndFrac; 

  _RBX = ps;
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 5240, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( BG_Skydive_IsSkydiving(_RBX) || GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&_RBX->pm_flags, ACTIVE, 6u) || BG_Gesture_IsGestureTypePlaying(_RBX, GESTURE_TYPE_IK_TARGET) )
  {
    __asm { vxorps  xmm0, xmm0, xmm0 }
    return *(float *)&_XMM0;
  }
  __asm
  {
    vmovaps [rsp+98h+var_18], xmm6
    vmovaps [rsp+98h+var_28], xmm7
    vmovaps [rsp+98h+var_38], xmm8
    vmovaps [rsp+98h+var_48], xmm9
  }
  Instance = CgWeaponMap::GetInstance(localClientNum);
  if ( BG_IsUsingOffhandGestureWeaponADSSupport(Instance, _RBX) )
  {
    *(double *)&_XMM0 = BG_GetOffhandAdsFrac(_RBX);
    __asm { vmovaps xmm8, xmm0 }
    weapon = BG_GetOffhandGestureWeapon(Instance, _RBX);
    v15 = 0;
  }
  else
  {
    v15 = BG_UsingAlternate(_RBX);
    __asm { vmovss  xmm8, dword ptr [rbx+730h] }
  }
  BG_ADSMovementAnimBlendFrac(weapon, v15, outStartFrac, &outEndFrac);
  __asm
  {
    vmovss  xmm0, [rsp+98h+outEndFrac]
    vmovss  xmm1, [rsp+98h+outStartFrac]
    vmovss  xmm6, cs:__real@3f800000
    vxorps  xmm7, xmm7, xmm7
    vcomiss xmm0, xmm7
    vsubss  xmm2, xmm0, xmm1
  }
  if ( v16 | v17 )
  {
    __asm { vxorps  xmm9, xmm9, xmm9 }
  }
  else
  {
    __asm { vcomiss xmm2, xmm7 }
    if ( v16 | v17 )
    {
      __asm
      {
        vcmpltss xmm0, xmm8, xmm1
        vblendvps xmm9, xmm7, xmm6, xmm0
      }
    }
    else
    {
      __asm
      {
        vsubss  xmm0, xmm8, xmm1
        vdivss  xmm0, xmm0, xmm2; val
        vmovaps xmm2, xmm6; max
        vxorps  xmm1, xmm1, xmm1; min
      }
      *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
      __asm { vsubss  xmm9, xmm6, xmm0 }
    }
  }
  suitIndex = _RBX->suitIndex;
  __asm { vmovaps [rsp+98h+var_58], xmm10 }
  SuitDef = BG_GetSuitDef(suitIndex);
  v29 = SuitDef;
  if ( !SuitDef )
    goto LABEL_23;
  __asm { vmovss  xmm8, dword ptr [rbx+1E8h] }
  BG_Suit_GetProneViewHeight(SuitDef);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, eax
    vcomiss xmm8, xmm0
  }
  if ( v31 )
    goto LABEL_23;
  __asm
  {
    vxorps  xmm1, xmm1, xmm1
    vcvtsi2ss xmm1, xmm1, ecx
    vcomiss xmm8, xmm1
  }
  if ( !v31 )
  {
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, eax
      vcomiss xmm8, xmm0
    }
    if ( v31 )
    {
      __asm
      {
        vxorps  xmm2, xmm2, xmm2
        vcvtsi2ss xmm2, xmm2, eax
        vcvtss2sd xmm0, xmm2, xmm2
        vcomisd xmm0, cs:__real@3eb0c6f7a0b5ed8d
      }
      if ( v29->viewheight_stand > (unsigned int)v29->viewheight_crouch )
      {
        __asm
        {
          vsubss  xmm0, xmm8, xmm1
          vdivss  xmm1, xmm0, xmm2
          vsubss  xmm0, xmm6, cs:dword_147FA827C
          vsubss  xmm2, xmm6, xmm1
          vmulss  xmm1, xmm2, xmm0
          vsubss  xmm0, xmm6, xmm1
        }
        goto LABEL_24;
      }
    }
LABEL_23:
    __asm { vmovaps xmm0, xmm6 }
    goto LABEL_24;
  }
  __asm
  {
    vxorps  xmm10, xmm10, xmm10
    vcvtsi2ss xmm10, xmm10, ecx
    vcvtss2sd xmm0, xmm10, xmm10
    vcomisd xmm0, cs:__real@3eb0c6f7a0b5ed8d
  }
  if ( v29->viewheight_crouch <= (unsigned int)BG_Suit_GetProneViewHeight(v29) )
    goto LABEL_23;
  BG_Suit_GetProneViewHeight(v29);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, eax
    vsubss  xmm1, xmm8, xmm0
    vsubss  xmm0, xmm6, cs:dword_147FA827C
    vdivss  xmm2, xmm1, xmm10
    vmulss  xmm1, xmm0, xmm2
    vsubss  xmm0, xmm6, xmm1
  }
LABEL_24:
  __asm
  {
    vmulss  xmm0, xmm0, xmm9; val
    vmovaps xmm2, xmm6; max
    vxorps  xmm1, xmm1, xmm1; min
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm
  {
    vmovaps xmm10, [rsp+98h+var_58]
    vmovaps xmm9, [rsp+98h+var_48]
    vmovaps xmm8, [rsp+98h+var_38]
    vmovaps xmm7, [rsp+98h+var_28]
    vmovaps xmm6, [rsp+98h+var_18]
  }
  return *(float *)&_XMM0;
}

/*
==============
ViewModelScriptedStateChanged
==============
*/
bool ViewModelScriptedStateChanged(LocalClientNum_t localClientNum, const playerState_s *ps)
{
  cg_t *LocalClientGlobals; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9922, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 9923, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  return LocalClientGlobals->viewModelAnimScriptedInfo.lastScriptedAnimStartTime != ps->viewModelAnimScripted.animStartTime || LocalClientGlobals->viewModelAnimScriptedInfo.lastAnimIndex != ps->viewModelAnimScripted.animIndex;
}

/*
==============
WeaponAnimBlendMeleeMisprediction
==============
*/

__int64 __fastcall WeaponAnimBlendMeleeMisprediction(const playerState_s *ps, DObj *obj, weapAnimFiles_t animIndex, double animRate, weapAnimFiles_t prevAnimIndex, int prevMeleeStartTime)
{
  XAnimTree *Tree; 
  char v26; 
  bool v27; 
  bool v31; 
  char v38; 
  bool v39; 
  bool v41; 
  char v50; 
  bool v51; 
  bool v53; 
  const XAnimParts *Parts; 
  const XAnimParts *v60; 
  __int64 result; 
  char *fmt; 
  float fmta; 
  float fmtb; 
  float fmtc; 
  double goalTime; 
  double goalTimea; 
  __int64 goalTimeb; 
  float goalTimec; 
  float goalTimed; 
  double rate; 
  double ratea; 
  float rateb; 
  float ratec; 
  double notifyName; 
  double notifyNamea; 
  double notifyNameb; 
  double notifyNamec; 
  double notifyNamed; 
  __int64 notifyNamee; 
  double notifyType; 
  double notifyTypea; 
  double notifyTypeb; 
  __int64 notifyTypec; 
  __int64 bRestart; 
  char v105; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm6
    vmovaps xmmword ptr [rax-48h], xmm7
    vmovaps xmmword ptr [rax-58h], xmm8
    vmovaps xmmword ptr [rax-68h], xmm9
    vmovaps xmmword ptr [rax-78h], xmm10
    vmovaps xmmword ptr [rax-88h], xmm11
    vmovaps xmmword ptr [rax-98h], xmm12
    vmovaps xmmword ptr [rax-0A8h], xmm13
    vmovaps xmmword ptr [rax-0B8h], xmm14
    vmovaps [rsp+138h+var_C8], xmm15
    vmovaps xmm14, xmm3
  }
  if ( !BG_IsMeleeAnim(prevAnimIndex) || !BG_IsMeleeAnim(animIndex) || prevMeleeStartTime != ps->meleeStartTime )
    goto LABEL_44;
  if ( prevAnimIndex != animIndex )
  {
    Tree = DObjGetTree(obj);
    if ( !Tree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1619, ASSERT_TYPE_ASSERT, "(animTree)", (const char *)&queryFormat, "animTree") )
      __debugbreak();
    if ( (prevAnimIndex - 262) / 3 != (animIndex - 262) / 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1626, ASSERT_TYPE_ASSERT, "( prevMeleeSet ) == ( meleeSet )", "%s == %s\n\t%i, %i", "prevMeleeSet", "meleeSet", (prevAnimIndex - 262) / 3, (animIndex - 262) / 3) )
      __debugbreak();
    *(double *)&_XMM0 = XAnimGetLength(Tree->anims, prevAnimIndex);
    __asm { vmovaps xmm7, xmm0 }
    *(double *)&_XMM0 = XAnimGetRate(Tree, 0, XANIM_SUBTREE_DEFAULT, prevAnimIndex);
    __asm { vmovaps xmm10, xmm0 }
    *(double *)&_XMM0 = XAnimGetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, prevAnimIndex);
    __asm
    {
      vxorps  xmm6, xmm6, xmm6
      vcomiss xmm0, xmm6
      vmovaps xmm11, xmm0
    }
    if ( !(v26 | v27) )
    {
      __asm
      {
        vcomiss xmm10, xmm6
        vxorpd  xmm13, xmm13, xmm13
      }
      if ( v26 | v27 )
      {
        __asm
        {
          vcvtss2sd xmm1, xmm10, xmm10
          vmovsd  qword ptr [rsp+138h+notifyType], xmm1
          vmovsd  qword ptr [rsp+138h+notifyName], xmm13
        }
        v31 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1638, ASSERT_TYPE_ASSERT, "( 0.0f ) < ( prevAnimRate )", "%s < %s\n\t%g, %g", "0.0f", "prevAnimRate", notifyName, notifyType);
        v26 = 0;
        v27 = !v31;
        if ( v31 )
          __debugbreak();
      }
      __asm
      {
        vmovss  xmm12, cs:__real@34000000
        vcomiss xmm10, xmm12
      }
      if ( !(v26 | v27) )
        __asm { vdivss  xmm7, xmm7, xmm10 }
      __asm
      {
        vcomiss xmm11, xmm6
        vmovsd  xmm15, cs:__real@3ff0000000000000
        vmovss  xmm9, cs:__real@3f800000
      }
      if ( v26 )
        goto LABEL_48;
      __asm { vcomiss xmm11, xmm9 }
      if ( !(v26 | v27) )
      {
LABEL_48:
        __asm
        {
          vmovsd  qword ptr [rsp+138h+notifyName], xmm15
          vcvtss2sd xmm0, xmm11, xmm11
          vmovsd  qword ptr [rsp+138h+rate], xmm13
          vmovsd  qword ptr [rsp+138h+goalTime], xmm0
        }
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1640, ASSERT_TYPE_ASSERT, "( 0.0f ) <= ( prevAnimTime ) && ( prevAnimTime ) <= ( 1.0f )", "prevAnimTime not in [0.0f, 1.0f]\n\t%g not in [%g, %g]", goalTime, rate, notifyNamea) )
          __debugbreak();
      }
      __asm
      {
        vmulss  xmm8, xmm7, xmm11
        vsubss  xmm0, xmm7, xmm8
        vmovss  [rsp+138h+var_D8], xmm0
      }
      *(double *)&_XMM0 = XAnimGetLength(Tree->anims, animIndex);
      __asm
      {
        vcomiss xmm14, xmm6
        vmovaps xmm7, xmm0
      }
      if ( v38 | v39 )
      {
        __asm
        {
          vcvtss2sd xmm1, xmm14, xmm14
          vmovsd  qword ptr [rsp+138h+notifyType], xmm1
          vmovsd  qword ptr [rsp+138h+notifyName], xmm13
        }
        v41 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1647, ASSERT_TYPE_ASSERT, "( 0.0f ) < ( animRate )", "%s < %s\n\t%g, %g", "0.0f", "animRate", notifyNameb, notifyTypea);
        v38 = 0;
        v39 = !v41;
        if ( v41 )
          __debugbreak();
      }
      __asm { vcomiss xmm14, xmm12 }
      if ( !(v38 | v39) )
        __asm { vdivss  xmm7, xmm7, xmm14 }
      __asm
      {
        vdivss  xmm0, xmm8, xmm7; val
        vmovaps xmm2, xmm9; max
        vxorps  xmm1, xmm1, xmm1; min
      }
      *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
      __asm
      {
        vcomiss xmm0, xmm9
        vmovaps xmm7, xmm0
      }
      if ( v26 )
      {
        if ( (unsigned int)(ps->weapState[0].weaponState - 22) > 2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1663, ASSERT_TYPE_ASSERT, "(( (ps->weapState[WEAPON_HAND_DEFAULT].weaponState == WEAPON_MELEE) || (ps->weapState[WEAPON_HAND_DEFAULT].weaponState == WEAPON_MELEE_FATAL) || (ps->weapState[WEAPON_HAND_DEFAULT].weaponState == WEAPON_MELEE_END) ))", (const char *)&queryFormat, "WEAPONSTATE_MELEE( ps->weapState[WEAPON_HAND_DEFAULT].weaponState )") )
          __debugbreak();
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, dword ptr [rbx+53Ch]
          vmulss  xmm8, xmm0, cs:__real@3a83126f
        }
        *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_melee_mispredictBlendDurationMinimum, "melee_mispredictBlendDurationMinimum");
        __asm { vcomiss xmm8, xmm0 }
        if ( !v50 )
        {
          __asm { vcomiss xmm8, xmm12 }
          if ( !(v50 | v51) )
          {
            __asm
            {
              vcomiss xmm7, xmm6
              vcomiss xmm7, xmm9
            }
            if ( !(v50 | v51) )
            {
              __asm
              {
                vmovsd  qword ptr [rsp+138h+notifyName], xmm15
                vcvtss2sd xmm0, xmm7, xmm7
                vmovsd  qword ptr [rsp+138h+rate], xmm13
                vmovsd  qword ptr [rsp+138h+goalTime], xmm0
              }
              v53 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1671, ASSERT_TYPE_ASSERT, "( 0.0f ) <= ( animTime ) && ( animTime ) <= ( 1.0f )", "animTime not in [0.0f, 1.0f]\n\t%g not in [%g, %g]", goalTimea, ratea, notifyNamec);
              v50 = 0;
              v51 = !v53;
              if ( v53 )
                __debugbreak();
            }
            __asm { vcomiss xmm8, xmm6 }
            if ( v50 | v51 )
            {
              __asm
              {
                vcvtss2sd xmm0, xmm8, xmm8
                vmovsd  qword ptr [rsp+138h+notifyType], xmm0
                vmovsd  qword ptr [rsp+138h+notifyName], xmm13
              }
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1672, ASSERT_TYPE_ASSERT, "( 0.0f ) < ( animDurationRemainingS )", "%s < %s\n\t%g, %g", "0.0f", "animDurationRemainingS", notifyNamed, notifyTypeb) )
                __debugbreak();
            }
            __asm
            {
              vsubss  xmm0, xmm9, xmm7
              vdivss  xmm12, xmm0, xmm8
            }
            *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DCONST_DVARFLT_melee_mispredictBlendDuration, "melee_mispredictBlendDuration");
            __asm
            {
              vminss  xmm1, xmm8, [rsp+138h+var_D8]
              vminss  xmm8, xmm0, xmm1
            }
            Parts = XAnimGetParts(Tree->anims, prevAnimIndex);
            v60 = XAnimGetParts(Tree->anims, animIndex);
            __asm
            {
              vcvtss2sd xmm4, xmm8, xmm8
              vmovsd  qword ptr [rsp+138h+bRestart], xmm4
              vcvtss2sd xmm0, xmm14, xmm14
              vmovsd  qword ptr [rsp+138h+notifyType], xmm0
              vcvtss2sd xmm1, xmm7, xmm7
              vmovsd  qword ptr [rsp+138h+notifyName], xmm1
              vcvtss2sd xmm3, xmm11, xmm11
              vcvtss2sd xmm2, xmm10, xmm10
              vmovsd  qword ptr [rsp+138h+goalTime], xmm4
              vmovq   r9, xmm3
              vmovsd  [rsp+138h+fmt], xmm2
            }
            Com_PrintWarning(17, "Melee result misprediction:\n\t'%s' t:%.2f r:%.2f bo:%.2f\n\t'%s' t:%.2f r:%.2f bi:%.2f\n", Parts->name, _R9, fmt, goalTimeb, v60->name, notifyNamee, notifyTypec, bRestart);
            if ( !obj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 1688, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
              __debugbreak();
            __asm
            {
              vmovss  [rsp+138h+rate], xmm10
              vmovss  [rsp+138h+goalTime], xmm8
              vmovss  dword ptr [rsp+138h+fmt], xmm6
            }
            XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, prevAnimIndex, fmta, goalTimec, rateb, (scr_string_t)0, 0, 0, LINEAR, NULL);
            __asm
            {
              vmovss  [rsp+138h+rate], xmm12
              vmovss  [rsp+138h+goalTime], xmm8
              vmovss  dword ptr [rsp+138h+fmt], xmm9
            }
            XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, animIndex, fmtb, goalTimed, ratec, (scr_string_t)0, 1u, 1, LINEAR, NULL);
            __asm { vmovss  dword ptr [rsp+138h+fmt], xmm7 }
            XAnimSetTime(Tree, 0, XANIM_SUBTREE_DEFAULT, animIndex, fmtc);
          }
        }
      }
      goto LABEL_43;
    }
LABEL_44:
    result = 0i64;
    goto LABEL_45;
  }
LABEL_43:
  result = 1i64;
LABEL_45:
  __asm { vmovaps xmm15, [rsp+138h+var_C8] }
  _R11 = &v105;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
    vmovaps xmm13, xmmword ptr [r11-80h]
    vmovaps xmm14, xmmword ptr [r11-90h]
  }
  return result;
}

/*
==============
WeaponCycleAllowed
==============
*/
bool WeaponCycleAllowed(cg_t *cgameGlob)
{
  CgWeaponMap *Instance; 
  const Weapon *CurrentWeaponForPlayer; 
  bool v4; 
  CgWeaponMap *v5; 
  const Weapon *v6; 
  CgHandler *Handler; 
  CgWeaponMap *v8; 
  bool v9; 
  bool v10; 
  int v11; 
  CgWeaponMap *v12; 

  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 16049, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
    __debugbreak();
  if ( BG_Skydive_IsSkydiving(&cgameGlob->predictedPlayerState) )
    return 0;
  if ( GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&cgameGlob->predictedPlayerState.pm_flags, ACTIVE, 0x10u) )
    return 0;
  if ( GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&cgameGlob->predictedPlayerState.pm_flags, ACTIVE, 0xFu) )
    return 0;
  if ( GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&cgameGlob->predictedPlayerState.pm_flags, ACTIVE, 6u) )
    return 0;
  if ( GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&cgameGlob->predictedPlayerState.weapCommon.weapFlags, ACTIVE, 0xAu) )
    return 0;
  if ( GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&cgameGlob->predictedPlayerState.weapCommon.weapFlags, ACTIVE, 0xEu) )
    return 0;
  if ( (unsigned int)(cgameGlob->predictedPlayerState.weapState[0].weaponState - 40) <= 3 )
    return 0;
  if ( BG_IsUsingOffhandGestureWeapon(&cgameGlob->predictedPlayerState) && (cgameGlob->predictedPlayerState.weapCommon.offhandGestureFlags & 8) == 0 )
  {
    Instance = CgWeaponMap::GetInstance((const LocalClientNum_t)cgameGlob->localClientNum);
    CurrentWeaponForPlayer = BG_GetCurrentWeaponForPlayer(Instance, &cgameGlob->predictedPlayerState);
    v4 = BG_UsingAlternate(&cgameGlob->predictedPlayerState);
    if ( !BG_AllowWeaponSwitchWhileHoldingGrenade(CurrentWeaponForPlayer, v4) )
      return 0;
  }
  v5 = CgWeaponMap::GetInstance((const LocalClientNum_t)cgameGlob->localClientNum);
  v6 = BG_GetCurrentWeaponForPlayer(v5, &cgameGlob->predictedPlayerState);
  Handler = CgHandler::getHandler(cgameGlob->localClientNum);
  v8 = CgWeaponMap::GetInstance((const LocalClientNum_t)cgameGlob->localClientNum);
  LOBYTE(Handler) = PM_Weapon_IsInInterruptibleState(v8, &cgameGlob->predictedPlayerState, WEAPON_HAND_DEFAULT, Handler);
  v9 = BG_UsingAlternate(&cgameGlob->predictedPlayerState);
  v10 = BG_IsForceUseWeapon(v6, v9) != 0;
  if ( !(_BYTE)Handler && v10 )
    return 0;
  if ( GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&cgameGlob->predictedPlayerState.otherFlags, ACTIVE, 1u) )
    return 0;
  v11 = CL_Input_IsGamepadEnabled(cgameGlob->localClientNum) ? Dvar_GetInt_Internal_DebugName(DVARINT_cg_weaponCycleDelay, "cg_weaponCycleDelay") : GamerProfile_GetWeaponSwitchCancelDelay(cgameGlob->localClientNum);
  if ( cgameGlob->time - cgameGlob->weaponSelectTime < v11 )
    return 0;
  if ( cgameGlob->time < cgameGlob->weaponForcedSelectTime )
    return 0;
  if ( GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&cgameGlob->predictedPlayerState.pm_flags, ACTIVE, 0x1Du) )
  {
    v12 = CgWeaponMap::GetInstance((const LocalClientNum_t)cgameGlob->localClientNum);
    if ( !Slide_CanSwitchWeapons(cgameGlob->localClientNum, v12, &cgameGlob->predictedPlayerState) )
      return 0;
  }
  return BG_IsPlayer(&cgameGlob->predictedPlayerState) && !cgameGlob->IsClientGamePaused(cgameGlob) && !BG_IsTurretActive(&cgameGlob->predictedPlayerState) && !BG_IsVehicleActive(&cgameGlob->predictedPlayerState);
}

/*
==============
WeaponRunOverrideAnims
==============
*/
void WeaponRunOverrideAnims(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex handIndex, int curAnim, const Weapon *weapon, bool isAlternate, const bool raiseToIdle)
{
  __int64 v12; 
  cg_t *LocalClientGlobals; 
  unsigned int v15; 
  const DObj *viewModelDObj; 
  CgHandler *Handler; 
  unsigned int v18; 
  CgHandler *v21; 
  unsigned int notifyType; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float goalTime; 
  float goalTimea; 
  float goalTimeb; 
  float rate; 
  float ratea; 
  float rateb; 

  __asm
  {
    vmovaps [rsp+98h+var_28], xmm6
    vmovaps [rsp+98h+var_38], xmm7
  }
  v12 = handIndex;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( (unsigned int)v12 >= 2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v12, 2) )
    __debugbreak();
  v15 = curAnim & 0xFFFFFF7F;
  viewModelDObj = LocalClientGlobals->m_weaponHand[v12].viewModelDObj;
  if ( !isAlternate || !raiseToIdle && v15 - 22 <= 5 )
  {
    __asm
    {
      vmovss  xmm6, cs:__real@3f800000
      vxorps  xmm7, xmm7, xmm7
      vmovss  [rsp+98h+rate], xmm6
      vmovss  [rsp+98h+goalTime], xmm7
      vmovss  dword ptr [rsp+98h+fmt], xmm7
    }
    XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x1A6u, fmta, goalTimea, ratea, (scr_string_t)0, 0, 0, LINEAR, NULL);
    v18 = 332;
LABEL_11:
    notifyType = 0;
    __asm { vxorps  xmm0, xmm0, xmm0 }
    goto LABEL_12;
  }
  Handler = CgHandler::getHandler(localClientNum);
  v18 = 332;
  __asm
  {
    vmovss  xmm6, cs:__real@3f800000
    vxorps  xmm7, xmm7, xmm7
  }
  if ( !BG_ViewModelAnimExists(ps, WEAP_ANIM_ALT_OVERRIDE, (PlayerHandIndex)v12, Handler) )
  {
    __asm
    {
      vmovss  [rsp+98h+rate], xmm6
      vmovss  [rsp+98h+goalTime], xmm7
      vmovss  dword ptr [rsp+98h+fmt], xmm7
    }
    XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, 0x14Cu, fmt, goalTime, rate, (scr_string_t)0, 0, 0, LINEAR, NULL);
    v21 = CgHandler::getHandler(localClientNum);
    v18 = 422;
    if ( !BG_ViewModelAnimExists(ps, WEAP_ALT_ANIM_ADJUST, (PlayerHandIndex)v12, v21) )
      goto LABEL_11;
  }
  __asm { vmovaps xmm0, xmm6 }
  notifyType = 1;
LABEL_12:
  __asm
  {
    vmovss  [rsp+98h+rate], xmm6
    vmovss  [rsp+98h+goalTime], xmm7
    vmovss  dword ptr [rsp+98h+fmt], xmm0
  }
  XAnimSetGoalWeight(viewModelDObj, 0, XANIM_SUBTREE_DEFAULT, v18, fmtb, goalTimeb, rateb, (scr_string_t)0, notifyType, 0, LINEAR, NULL);
  __asm
  {
    vmovaps xmm6, [rsp+98h+var_28]
    vmovaps xmm7, [rsp+98h+var_38]
  }
}

/*
==============
WeaponRunXModelAnims
==============
*/
void WeaponRunXModelAnims(LocalClientNum_t localClientNum, const playerState_s *ps, PlayerHandIndex handIndex)
{
  __int64 v8; 
  __int64 v10; 
  DObj *viewModelDObj; 
  CgWeaponMap *v12; 
  bool v17; 
  CgHandler *Handler; 
  bool v19; 
  bool v20; 
  int v21; 
  bool v22; 
  CgHandler *v23; 
  BOOL IsSwimWeapon; 
  bool v25; 
  XAnimTree *v30; 
  WeaponAnimNumber v31; 
  CgHandler *v32; 
  int v33; 
  WeaponHand *v34; 
  bool v36; 
  int v39; 
  cg_t *LocalClientGlobals; 
  unsigned int v41; 
  const WeaponAnimNumber *v42; 
  int AnimBlendTimes; 
  bool v44; 
  CgWeaponMap *Instance; 
  bool v47; 
  const dvar_t *v53; 
  char v54; 
  int v55; 
  int v57; 
  signed int VMRelativeAnimIndex; 
  signed int v59; 
  CgHandler *v60; 
  char v61; 
  int v62; 
  DObj *v67; 
  CgHandler *v68; 
  unsigned int AdsUpAnim; 
  DObj *v70; 
  unsigned int AdsDownAnim; 
  DObj *v72; 
  bool v74; 
  cg_t *v78; 
  DObj *v82; 
  int v83; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float fmtc; 
  float fmtd; 
  float fmte; 
  float isAiming; 
  float isAiminga; 
  float isAimingb; 
  float isInterruptible; 
  float isInterruptiblea; 
  float isInterruptibleb; 
  WeaponAnimNumber isInterruptiblec; 
  float outWeapAnim; 
  float outWeapAnima; 
  float outWeapAnimb; 
  bool v107; 
  char v108; 
  bool v109; 
  bool IsSprintAdditive; 
  char v111; 
  int weaponAnim; 
  int animState; 
  bool enabled; 
  weapAnimFiles_t prevAnimIndex; 
  WeaponHand *weapHand; 
  int outWeapAnimToggle; 
  DObj *obj; 
  cg_t *cgameGlob; 
  XAnimTree *tree; 
  float outAdsTransInSpeedMs; 
  float blendOutTime; 
  float outAdsTransOutSpeedMs; 
  Weapon r_weapon; 

  v8 = localClientNum;
  v10 = handIndex;
  cgameGlob = CG_GetLocalClientGlobals(localClientNum);
  if ( (unsigned int)v10 >= 2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_globals.h", 1200, ASSERT_TYPE_ASSERT, "(unsigned)( handIndex ) < (unsigned)( NUM_WEAPON_HANDS )", "handIndex doesn't index NUM_WEAPON_HANDS\n\t%i not in [0, %i)", v10, 2) )
    __debugbreak();
  viewModelDObj = cgameGlob->m_weaponHand[v10].viewModelDObj;
  weapHand = &cgameGlob->m_weaponHand[v10];
  obj = viewModelDObj;
  if ( !viewModelDObj && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8775, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
    __debugbreak();
  tree = DObjGetTree(viewModelDObj);
  if ( !CgWeaponMap::ms_instance[v8] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v12 = CgWeaponMap::ms_instance[v8];
  _RAX = BG_GetViewmodelWeapon(v12, ps);
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovups ymmword ptr [rbp+80h+r_weapon.weaponIdx], ymm0
    vmovups xmm1, xmmword ptr [rax+20h]
    vmovups xmmword ptr [rbp+80h+r_weapon.attachmentVariationIndices+5], xmm1
    vmovsd  xmm0, qword ptr [rax+30h]
    vmovsd  qword ptr [rbp+80h+r_weapon.attachmentVariationIndices+15h], xmm0
  }
  *(_DWORD *)&r_weapon.weaponCamo = *(_DWORD *)&_RAX->weaponCamo;
  v17 = BG_UsingAlternate(ps);
  v107 = v17;
  if ( !r_weapon.weaponIdx && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8783, ASSERT_TYPE_ASSERT, "(weapon.weaponIdx != 0)", (const char *)&queryFormat, "weapon.weaponIdx != WP_NONE") )
    __debugbreak();
  Handler = CgHandler::getHandler((LocalClientNum_t)v8);
  v109 = PM_Weapon_IsInInterruptibleState(v12, ps, (PlayerHandIndex)v10, Handler);
  v19 = BG_IsAimDownSight(&r_weapon, v17) && (BG_PlayerLastWeaponHand(v12, ps) == WEAPON_HAND_DEFAULT || BG_HasLadderHand(ps));
  v20 = GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 9u) && !GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&ps->weapCommon.weapFlags, ACTIVE, 1u) && BG_IsAimDownSight(&r_weapon, v107) && (BG_PlayerLastWeaponHand(v12, ps) == WEAPON_HAND_DEFAULT || BG_HasLadderHand(ps));
  v21 = cgameGlob->m_weaponHand[v10].iPrevAnim & 0xFFFFFF7F;
  cgameGlob->m_weaponHand[v10].animPlayingAtBeginFrame = v21;
  animState = v21;
  outWeapAnimToggle = ps->weapState[v10].weapAnim;
  weaponAnim = outWeapAnimToggle & 0xFFFFFF7F;
  CG_Weapons_FastADSTransitionOverride((LocalClientNum_t)v8, ps, (PlayerHandIndex)v10, &r_weapon, v107, v20, v109, &weaponAnim, &outWeapAnimToggle);
  prevAnimIndex = WEAP_ANIM_IDLE;
  if ( weapHand->iPrevAnim > 0 )
  {
    v22 = (unsigned int)(ps->weapState[v10].weaponState - 22) <= 2 && BG_IsMeleeAnimState(animState) && BG_IsMeleeAnimState(weaponAnim) && cgameGlob->playerWeaponInfo.meleeStartTime[v10] != ps->meleeStartTime;
    v23 = CgHandler::getHandler((LocalClientNum_t)v8);
    prevAnimIndex = BG_MapWeaponAnimStateToAnimIndex(v12, ps, weapHand->iPrevAnim & 0xFFFFFF7F, v22, &r_weapon, v107, (PlayerHandIndex)v10, v23);
  }
  IsSwimWeapon = BG_IsSwimWeapon(&r_weapon);
  if ( HandleExclusiveAkimboSwitchAnimPlay((LocalClientNum_t)v8, ps, (PlayerHandIndex)v10, &r_weapon) )
  {
    CG_Gesture_ProcessViewmodel((LocalClientNum_t)v8, ps, (const PlayerHandIndex)v10, &r_weapon);
    CG_Weapons_CheckForGestureForcedBlendOuts((const LocalClientNum_t)v8, ps, (const PlayerHandIndex)v10, &r_weapon);
    CG_Weapons_PlayDemeanorOffsetAnims((LocalClientNum_t)v8, ps, (PlayerHandIndex)v10, &r_weapon);
    CG_Weapons_HybridScopeUpdate((const LocalClientNum_t)v8, ps, &r_weapon, v107);
    return;
  }
  __asm
  {
    vmovaps [rsp+180h+var_60], xmm8
    vmovaps [rsp+180h+var_70], xmm9
  }
  CG_SetADSAltSwitchGlobals((LocalClientNum_t)v8, ps, weapHand, &r_weapon, v107, cgameGlob);
  v25 = CG_Weapons_IsInAds((const LocalClientNum_t)v8, v12, ps, &r_weapon, v107, (const PlayerHandIndex)v10);
  if ( !v25 && weaponAnim == 3 && CG_HasRecoilAnim((LocalClientNum_t)v8, ps, (PlayerHandIndex)v10) )
    PlayRecoilAnim((LocalClientNum_t)v8, ps, &r_weapon, (PlayerHandIndex)v10, WEAP_ANIM_RECOIL);
  else
    StopRecoilAnim((const LocalClientNum_t)v8, ps, obj);
  if ( !BG_IsUsingTurretViewarms(v12, ps) )
  {
    _RAX = cgameGlob;
    __asm { vmovss  xmm3, dword ptr [rax+7C64Ch]; weaponPosFrac }
    PlayADSAnim((const LocalClientNum_t)v8, ps, v19, *(double *)&_XMM3, obj, weaponAnim, (PlayerHandIndex)v10);
  }
  CG_Weapons_PlaySkydiveAnims((const LocalClientNum_t)v8, ps, (const PlayerHandIndex)v10, obj);
  __asm
  {
    vmovss  xmm9, cs:__real@3f800000
    vxorps  xmm8, xmm8, xmm8
  }
  if ( IsSwimWeapon )
  {
    if ( v25 )
    {
      v30 = tree;
      __asm { vmovss  dword ptr [rsp+180h+fmt], xmm8 }
      XAnimSetAnimRate(tree, 0, XANIM_SUBTREE_DEFAULT, 0xECu, fmt);
      __asm { vmovss  dword ptr [rsp+180h+fmt], xmm8 }
      XAnimSetTime(v30, 0, XANIM_SUBTREE_DEFAULT, 0xECu, fmta);
    }
    else
    {
      __asm { vmovss  dword ptr [rsp+180h+fmt], xmm9 }
      XAnimSetAnimRate(tree, 0, XANIM_SUBTREE_DEFAULT, 0xECu, fmtb);
    }
  }
  v31 = weaponAnim;
  if ( ((unsigned int)weaponAnim <= 1 || weaponAnim == 67) && CG_HasRecoilAnim((LocalClientNum_t)v8, ps, (PlayerHandIndex)v10) )
    PlayRecoilAnim((LocalClientNum_t)v8, ps, &r_weapon, (PlayerHandIndex)v10, WEAP_ANIM_RECOIL_SETTLE);
  __asm
  {
    vmovaps [rsp+180h+var_40], xmm6
    vmovaps [rsp+180h+var_50], xmm7
    vmovaps [rsp+180h+var_80], xmm10
  }
  v32 = CgHandler::getHandler((LocalClientNum_t)v8);
  v33 = BG_MapWeaponAnimStateToAnimIndex(v12, ps, v31, 0, &r_weapon, v107, (PlayerHandIndex)v10, v32);
  v34 = weapHand;
  weaponAnim = v33;
  if ( outWeapAnimToggle == weapHand->iPrevAnim )
  {
    _RBX = &cgameGlob->prevViewmodelWeapon;
    if ( !memcmp_0(&r_weapon, &cgameGlob->prevViewmodelWeapon, 0x3Cui64) || BG_WeaponsDifferOnlyInVariantForInstantSwitch(ps, cgameGlob->prevWeaponFlags, &r_weapon, _RBX) )
    {
      v74 = v107;
      goto LABEL_137;
    }
  }
  IsSprintAdditive = BG_IsSprintAdditive(v12, ps);
  v36 = IsSprintAdditive;
  __asm
  {
    vmovss  xmm10, cs:__real@3dcccccd
    vxorps  xmm7, xmm7, xmm7
  }
  if ( v31 == WEAP_SLIDE )
  {
    v39 = animState;
  }
  else
  {
    if ( v31 == WEAP_IDLE )
      goto LABEL_59;
    v39 = animState;
    if ( animState == 55 )
    {
      __asm
      {
        vmovss  dword ptr [rsp+180h+isInterruptible], xmm9
        vmovss  dword ptr [rsp+180h+isAiming], xmm10
        vmovss  dword ptr [rsp+180h+fmt], xmm8
      }
      XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, 0, fmtc, isAiming, isInterruptible, (scr_string_t)0, 0, 1, LINEAR, NULL);
    }
  }
  if ( (unsigned int)v31 <= WEAP_FORCE_IDLE || v31 == WEAP_WALLRUN )
  {
LABEL_59:
    v39 = animState;
    if ( !IsSprintAdditive || ((animState - 32) & 0xFFFFFFFC) != 0 || (v111 = 1, animState == 33) )
      v111 = 0;
    XAnimGetAnims(v34->tree);
    __asm
    {
      vmovss  [rbp+80h+blendOutTime], xmm8
      vmovss  [rsp+180h+animState], xmm8
    }
    LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v8);
    if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2359, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
      __debugbreak();
    if ( v31 == WEAP_FORCE_IDLE && LocalClientGlobals->fastADSTransActive )
    {
      v41 = 0;
      v42 = s_fastADSBlendAnimStates;
      while ( v39 != *v42 )
      {
        ++v41;
        ++v42;
        if ( v41 >= 0xE )
          goto LABEL_71;
      }
      Instance = CgWeaponMap::GetInstance((const LocalClientNum_t)v8);
      if ( !Instance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 2376, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
        __debugbreak();
      v47 = BG_UsingAlternate(ps);
      BG_GetADSTransTimes(Instance, ps, &r_weapon, v47, &outAdsTransInSpeedMs, &outAdsTransOutSpeedMs);
      __asm
      {
        vmovss  xmm0, cs:__real@3a83126f
        vdivss  xmm6, xmm0, [rbp+80h+outAdsTransInSpeedMs]
      }
      BG_WeaponADSFractionAffectedByReload(Instance, ps);
      __asm
      {
        vsubss  xmm0, xmm9, xmm0; val
        vmovaps xmm2, xmm9; max
        vmovaps xmm1, xmm8; min
      }
      *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
      __asm
      {
        vmulss  xmm1, xmm0, xmm6
        vmulss  xmm2, xmm1, cs:__real@3f333333
      }
    }
    else
    {
LABEL_71:
      AnimBlendTimes = GetAnimBlendTimes((const LocalClientNum_t)v8, &r_weapon, ps, (const WeaponAnimNumber)v39, prevAnimIndex, v31, weaponAnim, &blendOutTime, (float *)&animState);
      v44 = AnimBlendTimes == 0;
      if ( !AnimBlendTimes )
        goto LABEL_79;
      __asm { vmovss  xmm2, [rbp+80h+blendOutTime] }
    }
    __asm { vucomiss xmm2, xmm8 }
    if ( v44 )
    {
      v108 = 1;
LABEL_80:
      v53 = DVARBOOL_killswitch_weapon_post_ship_relative_anim_fix_enabled;
      if ( !DVARBOOL_killswitch_weapon_post_ship_relative_anim_fix_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_weapon_post_ship_relative_anim_fix_enabled") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v53);
      v55 = 176;
      __asm { vmovss  xmm6, cs:__real@3f000000 }
      enabled = v53->current.enabled;
      v54 = enabled;
      if ( enabled )
        v55 = 192;
      v57 = 0;
      LODWORD(outAdsTransInSpeedMs) = v55;
      while ( 1 )
      {
        VMRelativeAnimIndex = CG_Weapons_GetVMRelativeAnimIndex(v57, v54);
        v59 = VMRelativeAnimIndex;
        if ( (unsigned int)(VMRelativeAnimIndex - 286) > 0x23 && (unsigned int)(VMRelativeAnimIndex - 381) > 7 && (unsigned int)(VMRelativeAnimIndex - 389) > 7 )
        {
          if ( VMRelativeAnimIndex == 341 && IsSprintAdditive )
            v59 = 97;
          v60 = CgHandler::getHandler((LocalClientNum_t)v8);
          if ( BG_ViewModelAnimExists(ps, (weapAnimFiles_t)v59, (PlayerHandIndex)v10, v60) )
          {
            if ( !XAnimIsLooped(tree->anims, v59) && !XAnimHasFinished(tree, 0, XANIM_SUBTREE_DEFAULT, v59) && (weapHand->iPrevAnim != v39 || !v108) )
            {
              if ( v39 != 28 && !v111 && !v108 && v39 != 4 )
                weapHand->iPrevAnim = -1;
              if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8724, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
                __debugbreak();
              if ( v59 != 323 || !GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 0x14u) && !BG_IsSuperSprinting(ps) )
                goto LABEL_115;
              *(double *)&_XMM0 = XAnimGetTime(tree, 0, XANIM_SUBTREE_DEFAULT, 0x143u);
              __asm { vcomiss xmm0, cs:dword_147FA82C4 }
              if ( v61 | v44 )
              {
                __asm { vmovss  xmm7, cs:dword_147FA82C8 }
              }
              else
              {
LABEL_115:
                if ( (outWeapAnimToggle & 1) == 0 )
                {
                  if ( (unsigned int)(v59 - 326) > 6 || (v62 = 83, !_bittest(&v62, v59 - 326)) )
                  {
                    if ( (unsigned int)(v59 - 259) > 2 && (v39 != 28 || v59 != 334) )
                    {
                      __asm { vmovups ymm0, ymmword ptr [rbp+80h+r_weapon.weaponIdx] }
                      _R15 = cgameGlob;
                      __asm
                      {
                        vmovups ymmword ptr [r15+181DAh], ymm0
                        vmovups xmm1, xmmword ptr [rbp+80h+r_weapon.attachmentVariationIndices+5]
                        vmovups xmmword ptr [r15+181FAh], xmm1
                        vmovsd  xmm0, qword ptr [rbp+80h+r_weapon.attachmentVariationIndices+15h]
                        vmovsd  qword ptr [r15+1820Ah], xmm0
                      }
                      *(_DWORD *)&_R15->prevViewmodelWeapon.weaponCamo = *(_DWORD *)&r_weapon.weaponCamo;
                      WeaponRunOverrideAnims((LocalClientNum_t)v8, ps, (PlayerHandIndex)v10, weapHand->iPrevAnim, &r_weapon, v107, (unsigned int)(v59 - 322) <= 1);
                      CG_Weapons_PlayAdditiveViewModelAnims((LocalClientNum_t)v8, ps, (PlayerHandIndex)v10, &r_weapon);
                      CG_Gesture_ProcessViewmodel((LocalClientNum_t)v8, ps, (const PlayerHandIndex)v10, &r_weapon);
                      CG_Weapons_CheckForGestureForcedBlendOuts((const LocalClientNum_t)v8, ps, (const PlayerHandIndex)v10, &r_weapon);
                      CG_Weapons_PlayDemeanorOffsetAnims((LocalClientNum_t)v8, ps, (PlayerHandIndex)v10, &r_weapon);
                      v67 = obj;
                      CG_Ladder_PlayAnims((const LocalClientNum_t)v8, ps, (const PlayerHandIndex)v10, obj);
                      CG_WeaponAnimGroup_Update((const weapAnimFiles_t)weaponAnim, _R15, (const PlayerHandIndex)v10, &r_weapon, v107, tree, v67);
                      CG_Weapons_HybridScopeUpdate((const LocalClientNum_t)v8, ps, &r_weapon, v107);
                      goto LABEL_147;
                    }
                  }
                }
                __asm { vmovaps xmm7, xmm6 }
              }
            }
          }
        }
        if ( ++v57 >= SLODWORD(outAdsTransInSpeedMs) )
          break;
        v54 = enabled;
      }
      v34 = weapHand;
      v36 = IsSprintAdditive;
      goto LABEL_121;
    }
LABEL_79:
    v108 = 0;
    goto LABEL_80;
  }
LABEL_121:
  if ( v31 == WEAP_SLIDE )
  {
    __asm { vmovss  dword ptr [rsp+180h+outWeapAnim], xmm10 }
    CG_Weapons_StartWeaponAnim((LocalClientNum_t)v8, &r_weapon, (PlayerHandIndex)v10, WEAP_SLIDE, WEAP_ANIM_IDLE, (const WeaponAnimNumber)v39, prevAnimIndex, outWeapAnim, 0);
    v68 = CgHandler::getHandler((LocalClientNum_t)v8);
    AdsUpAnim = BG_GetAdsUpAnim(ps, v68);
    v70 = obj;
    __asm
    {
      vmovss  dword ptr [rsp+180h+isInterruptible], xmm9
      vmovss  dword ptr [rsp+180h+isAiming], xmm8
      vmovss  dword ptr [rsp+180h+fmt], xmm8
    }
    XAnimSetGoalWeight(obj, 0, XANIM_SUBTREE_DEFAULT, AdsUpAnim, fmtd, isAiminga, isInterruptiblea, (scr_string_t)0, 0, 1, LINEAR, NULL);
    AdsDownAnim = BG_GetAdsDownAnim(ps, v68);
    __asm
    {
      vmovss  dword ptr [rsp+180h+isInterruptible], xmm9
      vmovss  dword ptr [rsp+180h+isAiming], xmm8
      vmovss  dword ptr [rsp+180h+fmt], xmm8
    }
    XAnimSetGoalWeight(v70, 0, XANIM_SUBTREE_DEFAULT, AdsDownAnim, fmte, isAimingb, isInterruptibleb, (scr_string_t)0, 0, 1, LINEAR, NULL);
    CG_GameInterface_ClearADSAnims((const LocalClientNum_t)v8, ps, v70);
  }
  else
  {
    if ( ((v31 - 32) & 0xFFFFFFFC) != 0 || v31 == WEAP_SPRINT_IN_CANCEL || !v36 )
    {
      *(double *)&_XMM0 = XAnimGetWeight(tree, 0, XANIM_SUBTREE_DEFAULT, 0x154u);
      __asm { vcomiss xmm0, xmm8 }
      if ( !(v61 | v44) )
      {
        _RBX = DCONST_DVARFLT_superSprintBlendTime;
        if ( !DCONST_DVARFLT_superSprintBlendTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "superSprintBlendTime") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(_RBX);
        __asm { vmovss  xmm7, dword ptr [rbx+28h] }
      }
      __asm { vmovss  dword ptr [rsp+180h+outWeapAnim], xmm7 }
      CG_Weapons_StartWeaponAnim((LocalClientNum_t)v8, &r_weapon, (PlayerHandIndex)v10, v31, (const weapAnimFiles_t)weaponAnim, (const WeaponAnimNumber)v39, prevAnimIndex, outWeapAnima, 0);
      v72 = obj;
    }
    else
    {
      isInterruptiblec = v39;
      v72 = obj;
      CG_StartSprintAdditive((LocalClientNum_t)v8, ps, obj, &r_weapon, v34, (const PlayerHandIndex)v10, isInterruptiblec, prevAnimIndex, v31, (const weapAnimFiles_t)weaponAnim);
    }
    if ( (unsigned int)(v31 - 14) <= 1 )
      XAnimBonePhysicsReset(v72);
  }
  v74 = v107;
  _RBX = &cgameGlob->prevViewmodelWeapon;
  v34->iPrevAnim = outWeapAnimToggle;
  __asm
  {
    vmovups ymm0, ymmword ptr [rbp+80h+r_weapon.weaponIdx]
    vmovups ymmword ptr [rbx], ymm0
    vmovups xmm1, xmmword ptr [rbp+80h+r_weapon.attachmentVariationIndices+5]
    vmovups xmmword ptr [rbx+20h], xmm1
    vmovsd  xmm0, qword ptr [rbp+80h+r_weapon.attachmentVariationIndices+15h]
    vmovsd  qword ptr [rbx+30h], xmm0
  }
  *(_DWORD *)&_RBX->weaponCamo = *(_DWORD *)&r_weapon.weaponCamo;
  WeaponRunOverrideAnims((LocalClientNum_t)v8, ps, (PlayerHandIndex)v10, v34->iPrevAnim, &r_weapon, v107, 0);
LABEL_137:
  v78 = cgameGlob;
  if ( BG_WeaponsDifferOnlyInVariantForInstantSwitch(ps, cgameGlob->prevWeaponFlags, &r_weapon, _RBX) )
  {
    __asm
    {
      vmovups ymm0, ymmword ptr [rbp+80h+r_weapon.weaponIdx]
      vmovups ymmword ptr [rbx], ymm0
      vmovups xmm1, xmmword ptr [rbp+80h+r_weapon.attachmentVariationIndices+5]
      vmovups xmmword ptr [rbx+20h], xmm1
      vmovsd  xmm0, qword ptr [rbp+80h+r_weapon.attachmentVariationIndices+15h]
      vmovsd  qword ptr [rbx+30h], xmm0
    }
    *(_DWORD *)&_RBX->weaponCamo = *(_DWORD *)&r_weapon.weaponCamo;
  }
  CG_Weapons_HybridScopeUpdate((const LocalClientNum_t)v8, ps, &r_weapon, v74);
  v82 = obj;
  CG_Ladder_PlayAnims((const LocalClientNum_t)v8, ps, (const PlayerHandIndex)v10, obj);
  v83 = weaponAnim;
  CG_Weapons_UpdateSuperSprintAnim((LocalClientNum_t)v8, &r_weapon, (PlayerHandIndex)v10, (weapAnimFiles_t)weaponAnim);
  CG_Weapons_UpdateSprintAnim((LocalClientNum_t)v8, &r_weapon, (PlayerHandIndex)v10, (weapAnimFiles_t)v83);
  CG_Weapons_PlayAdditiveViewModelAnims((LocalClientNum_t)v8, ps, (PlayerHandIndex)v10, &r_weapon);
  CG_Gesture_ProcessViewmodel((LocalClientNum_t)v8, ps, (const PlayerHandIndex)v10, &r_weapon);
  weapHand = NULL;
  if ( !(_DWORD)v10 && CG_Gesture_ShouldBlendOutOfAnim((const LocalClientNum_t)v8, ps, WEAPON_HAND_DEFAULT, (const GestureWeaponAnimBlendOutInfo **)&weapHand) )
  {
    _RDX = weapHand;
    if ( !weapHand )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapons.cpp", 8681, ASSERT_TYPE_ASSERT, "(blendOutInfo)", (const char *)&queryFormat, "blendOutInfo") )
        __debugbreak();
      _RDX = weapHand;
    }
    __asm
    {
      vmovss  xmm0, dword ptr [rdx+10h]
      vmovss  dword ptr [rsp+180h+outWeapAnim], xmm0
    }
    CG_Weapons_StartWeaponAnim((LocalClientNum_t)v8, &r_weapon, WEAPON_HAND_DEFAULT, (const WeaponAnimNumber)_RDX->tree, SHIDWORD(_RDX->tree), (const WeaponAnimNumber)_RDX->viewModelDObj, SHIDWORD(_RDX->viewModelDObj), outWeapAnimb, 0);
  }
  CG_Weapons_PlayDemeanorOffsetAnims((LocalClientNum_t)v8, ps, (PlayerHandIndex)v10, &r_weapon);
  CG_WeaponAnimGroup_Update((const weapAnimFiles_t)v83, v78, (const PlayerHandIndex)v10, &r_weapon, v74, tree, v82);
LABEL_147:
  __asm
  {
    vmovaps xmm6, [rsp+180h+var_40]
    vmovaps xmm7, [rsp+180h+var_50]
    vmovaps xmm10, [rsp+180h+var_80]
    vmovaps xmm8, [rsp+180h+var_60]
    vmovaps xmm9, [rsp+180h+var_70]
  }
}

