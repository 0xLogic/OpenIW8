/*
==============
Scr_AgentMain
==============
*/

void Scr_AgentMain(void)
{
  ?Scr_AgentMain@@YAXXZ();
}

/*
==============
Scr_AgentKilled
==============
*/

void __fastcall Scr_AgentKilled(gentity_s *self, const gentity_s *inflictor, gentity_s *attacker, int damage, int damageFlags, int meansOfDeath, const Weapon *r_weapon, bool isAlternate, const vec3_t *vDir, const hitLocation_t hitLoc, int psTimeOffset, int deathAnimDuration)
{
  ?Scr_AgentKilled@@YAXPEAUgentity_s@@PEBU1@0HHHAEBUWeapon@@_NPEBTvec3_t@@W4hitLocation_t@@HH@Z(self, inflictor, attacker, damage, damageFlags, meansOfDeath, r_weapon, isAlternate, vDir, hitLoc, psTimeOffset, deathAnimDuration);
}

/*
==============
Scr_PlayerDisconnect
==============
*/

void __fastcall Scr_PlayerDisconnect(gentity_s *self, const char *reason)
{
  ?Scr_PlayerDisconnect@@YAXPEAUgentity_s@@PEBD@Z(self, reason);
}

/*
==============
GScr_MainMP_TriggerFX
==============
*/

void __fastcall GScr_MainMP_TriggerFX(scrContext_t *scrContext)
{
  ?GScr_MainMP_TriggerFX@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_GetNearNodeListForSpawnCheck
==============
*/

void __fastcall Scr_GetNearNodeListForSpawnCheck(scrContext_t *scrContext, scr_entref_t entref)
{
  ?Scr_GetNearNodeListForSpawnCheck@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
Scr_PlayerVote
==============
*/

void __fastcall Scr_PlayerVote(gentity_s *self, char *option)
{
  ?Scr_PlayerVote@@YAXPEAUgentity_s@@PEAD@Z(self, option);
}

/*
==============
Scr_BotMain
==============
*/

void Scr_BotMain(void)
{
  ?Scr_BotMain@@YAXXZ();
}

/*
==============
GScr_GetAltBunkerIndexForName
==============
*/

void __fastcall GScr_GetAltBunkerIndexForName(scrContext_t *scrContext)
{
  ?GScr_GetAltBunkerIndexForName@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_GetClanWarsBonusForCurrentPlaylist
==============
*/

void __fastcall GScr_GetClanWarsBonusForCurrentPlaylist(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScr_GetClanWarsBonusForCurrentPlaylist@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_MainMP_SpawnFX
==============
*/

void __fastcall GScr_MainMP_SpawnFX(scrContext_t *scrContext)
{
  ?GScr_MainMP_SpawnFX@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_AnalyticsReset
==============
*/

void __fastcall GScr_AnalyticsReset(scrContext_t *scrContext)
{
  ?GScr_AnalyticsReset@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
ScrCmd_PlayerForceDeathAnim
==============
*/

void __fastcall ScrCmd_PlayerForceDeathAnim(scrContext_t *scrContext, scr_entref_t entref)
{
  ?ScrCmd_PlayerForceDeathAnim@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
Scr_PlayerKilled
==============
*/

void __fastcall Scr_PlayerKilled(gentity_s *self, const gentity_s *inflictor, gentity_s *attacker, int damage, int damageFlags, int meansOfDeath, const Weapon *r_weapon, bool isAlternate, const vec3_t *vDir, const hitLocation_t hitLoc, int psTimeOffset, int deathAnimDuration)
{
  ?Scr_PlayerKilled@@YAXPEAUgentity_s@@PEBU1@0HHHAEBUWeapon@@_NPEBTvec3_t@@W4hitLocation_t@@HH@Z(self, inflictor, attacker, damage, damageFlags, meansOfDeath, r_weapon, isAlternate, vDir, hitLoc, psTimeOffset, deathAnimDuration);
}

/*
==============
GScr_MainMP_LoadScripts
==============
*/

void __fastcall GScr_MainMP_LoadScripts(const SvServerInitSettings *initSettings)
{
  ?GScr_MainMP_LoadScripts@@YAXPEBUSvServerInitSettings@@@Z(initSettings);
}

/*
==============
GScr_StopAC130
==============
*/

void __fastcall GScr_StopAC130(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScr_StopAC130@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
ScrCmd_EnablePlayerUseForAllPlayers
==============
*/

void __fastcall ScrCmd_EnablePlayerUseForAllPlayers(scrContext_t *scrContext, scr_entref_t entref)
{
  ?ScrCmd_EnablePlayerUseForAllPlayers@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_MainMP_SetHealth
==============
*/

void __fastcall GScr_MainMP_SetHealth(scrContext_t *scrContext, gentity_s *ent, int offset)
{
  ?GScr_MainMP_SetHealth@@YAXAEAUscrContext_t@@PEAUgentity_s@@H@Z(scrContext, ent, offset);
}

/*
==============
GScr_DisableForceHelmetWhenSpectating
==============
*/

void __fastcall GScr_DisableForceHelmetWhenSpectating(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScr_DisableForceHelmetWhenSpectating@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_DisableLootSpawnPoint
==============
*/

void __fastcall GScr_DisableLootSpawnPoint(scrContext_t *scrContext)
{
  ?GScr_DisableLootSpawnPoint@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_AgentDamage
==============
*/

void __fastcall Scr_AgentDamage(gentity_s *self, const gentity_s *inflictor, gentity_s *attacker, int damage, int dflags, int meansOfDeath, const Weapon *r_weapon, bool isAlternate, const vec3_t *vPoint, const vec3_t *vDir, const hitLocation_t hitLoc, int timeOffset, int modelIndex, scr_string_t partName)
{
  ?Scr_AgentDamage@@YAXPEAUgentity_s@@PEBU1@0HHHAEBUWeapon@@_NPEBTvec3_t@@4W4hitLocation_t@@HHW4scr_string_t@@@Z(self, inflictor, attacker, damage, dflags, meansOfDeath, r_weapon, isAlternate, vPoint, vDir, hitLoc, timeOffset, modelIndex, partName);
}

/*
==============
GScr_AddEntityAllowUndefined
==============
*/

void __fastcall GScr_AddEntityAllowUndefined(const gentity_s *pEnt)
{
  ?GScr_AddEntityAllowUndefined@@YAXPEBUgentity_s@@@Z(pEnt);
}

/*
==============
Scr_AgentGameTypeMain
==============
*/

void Scr_AgentGameTypeMain(void)
{
  ?Scr_AgentGameTypeMain@@YAXXZ();
}

/*
==============
ScrCmd_DisablePlayerUseForAllPlayers
==============
*/

void __fastcall ScrCmd_DisablePlayerUseForAllPlayers(scrContext_t *scrContext, scr_entref_t entref)
{
  ?ScrCmd_DisablePlayerUseForAllPlayers@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_VerifyBunkerCode
==============
*/

void __fastcall GScr_VerifyBunkerCode(scrContext_t *scrContext)
{
  ?GScr_VerifyBunkerCode@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
ScrCmd_DisablePlayerUse
==============
*/

void __fastcall ScrCmd_DisablePlayerUse(scrContext_t *scrContext, scr_entref_t entref)
{
  ?ScrCmd_DisablePlayerUse@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_GetLootSpawnPoint
==============
*/

void __fastcall GScr_GetLootSpawnPoint(scrContext_t *scrContext)
{
  ?GScr_GetLootSpawnPoint@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_BotGameTypeMain
==============
*/

void Scr_BotGameTypeMain(void)
{
  ?Scr_BotGameTypeMain@@YAXXZ();
}

/*
==============
GScr_GetQuestPoints
==============
*/

void __fastcall GScr_GetQuestPoints(scrContext_t *scrContext)
{
  ?GScr_GetQuestPoints@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_LoadRead
==============
*/

void *__fastcall Scr_LoadRead(int len)
{
  return ?Scr_LoadRead@@YAPEAXH@Z(len);
}

/*
==============
GScr_AnalyticsAddEvent
==============
*/

void __fastcall GScr_AnalyticsAddEvent(scrContext_t *scrContext)
{
  ?GScr_AnalyticsAddEvent@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_GetLootSpawnPointCount
==============
*/

void __fastcall GScr_GetLootSpawnPointCount(scrContext_t *scrContext)
{
  ?GScr_GetLootSpawnPointCount@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScriptMP::ConstructMessageString
==============
*/

void __fastcall GScriptMP::ConstructMessageString(GScriptMP *this, scrContext_t *scrContext, int firstParmIndex, int lastParmIndex, const char *errorContext, char *string, unsigned int stringLimit)
{
  ?ConstructMessageString@GScriptMP@@UEBAXAEAUscrContext_t@@HHPEBDPEADI@Z(this, scrContext, firstParmIndex, lastParmIndex, errorContext, string, stringLimit);
}

/*
==============
GScr_SetIntroCameraActive
==============
*/

void __fastcall GScr_SetIntroCameraActive(scrContext_t *scrContext)
{
  ?GScr_SetIntroCameraActive@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_HostMigration
==============
*/

void Scr_HostMigration(void)
{
  ?Scr_HostMigration@@YAXXZ();
}

/*
==============
GScr_GetUnusedLootCachePoints
==============
*/

void __fastcall GScr_GetUnusedLootCachePoints(scrContext_t *scrContext)
{
  ?GScr_GetUnusedLootCachePoints@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_ForceThirdPersonWhenSpectating
==============
*/

void __fastcall GScr_ForceThirdPersonWhenSpectating(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScr_ForceThirdPersonWhenSpectating@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_MainMP_PrecacheAiTypes
==============
*/

void __fastcall GScr_MainMP_PrecacheAiTypes(scrContext_t *scrContext)
{
  ?GScr_MainMP_PrecacheAiTypes@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_MainMP_PlayLoopedFX
==============
*/

void __fastcall GScr_MainMP_PlayLoopedFX(scrContext_t *scrContext)
{
  ?GScr_MainMP_PlayLoopedFX@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_SetBallPassAllowed
==============
*/

void __fastcall GScr_SetBallPassAllowed(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScr_SetBallPassAllowed@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_AnalyticsWriteCSV
==============
*/

void __fastcall GScr_AnalyticsWriteCSV(scrContext_t *scrContext)
{
  ?GScr_AnalyticsWriteCSV@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_GetDateTime
==============
*/

void __fastcall GScr_GetDateTime(scrContext_t *scrContext)
{
  ?GScr_GetDateTime@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
ScrCmd_EnablePlayerUse
==============
*/

void __fastcall ScrCmd_EnablePlayerUse(scrContext_t *scrContext, scr_entref_t entref)
{
  ?ScrCmd_EnablePlayerUse@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_ForceHelmetWhenSpectating
==============
*/

void __fastcall GScr_ForceHelmetWhenSpectating(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScr_ForceHelmetWhenSpectating@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
Scr_LeaderDialog
==============
*/

void __fastcall Scr_LeaderDialog(gentity_s *self, const scr_string_t dialog, const vec3_t *location)
{
  ?Scr_LeaderDialog@@YAXPEAUgentity_s@@W4scr_string_t@@AEBTvec3_t@@@Z(self, dialog, location);
}

/*
==============
Scr_AgentAdded
==============
*/

void __fastcall Scr_AgentAdded(gentity_s *self)
{
  ?Scr_AgentAdded@@YAXPEAUgentity_s@@@Z(self);
}

/*
==============
Scr_PlayerDamage
==============
*/

void __fastcall Scr_PlayerDamage(gentity_s *self, const gentity_s *inflictor, gentity_s *attacker, int damage, int dflags, int meansOfDeath, const Weapon *r_weapon, bool isAlternate, const vec3_t *vPoint, const vec3_t *vDir, const hitLocation_t hitLoc, int timeOffset, int modelIndex, scr_string_t partName, const GExtraDamageParams *extraParams, int unscaledDamage)
{
  ?Scr_PlayerDamage@@YAXPEAUgentity_s@@PEBU1@0HHHAEBUWeapon@@_NPEBTvec3_t@@4W4hitLocation_t@@HHW4scr_string_t@@AEBVGExtraDamageParams@@H@Z(self, inflictor, attacker, damage, dflags, meansOfDeath, r_weapon, isAlternate, vPoint, vDir, hitLoc, timeOffset, modelIndex, partName, extraParams, unscaledDamage);
}

/*
==============
GScr_GetLootSpawnScriptableIndexFirst
==============
*/

void __fastcall GScr_GetLootSpawnScriptableIndexFirst(scrContext_t *scrContext)
{
  ?GScr_GetLootSpawnScriptableIndexFirst@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_StartAC130
==============
*/

void __fastcall GScr_StartAC130(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScr_StartAC130@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
Scr_PlayerLastStand
==============
*/

bool __fastcall Scr_PlayerLastStand(gentity_s *self, gentity_s *inflictor, gentity_s *attacker, int damage, int meansOfDeath, const Weapon *r_weapon, bool isAlternate, const vec3_t *vDir, const hitLocation_t hitLoc, int psTimeOffset)
{
  return ?Scr_PlayerLastStand@@YA_NPEAUgentity_s@@00HHAEBUWeapon@@_NAEBTvec3_t@@W4hitLocation_t@@H@Z(self, inflictor, attacker, damage, meansOfDeath, r_weapon, isAlternate, vDir, hitLoc, psTimeOffset);
}

/*
==============
GScr_DisableForceThirdPersonWhenSpectating
==============
*/

void __fastcall GScr_DisableForceThirdPersonWhenSpectating(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScr_DisableForceThirdPersonWhenSpectating@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScriptMP::GetFunction
==============
*/

unsigned int __fastcall GScriptMP::GetFunction(GScriptMP *this, const char **pName, BuiltinType *type)
{
  return ?GetFunction@GScriptMP@@UEBAIPEAPEBDPEAW4BuiltinType@@@Z(this, pName, type);
}

/*
==============
Scr_PlayerActive
==============
*/

void __fastcall Scr_PlayerActive(gentity_s *self)
{
  ?Scr_PlayerActive@@YAXPEAUgentity_s@@@Z(self);
}

/*
==============
GScr_BRMatchStarted
==============
*/

void __fastcall GScr_BRMatchStarted(scrContext_t *scrContext)
{
  ?GScr_BRMatchStarted@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_RequestGameLobbyRemainIntact
==============
*/

void __fastcall GScr_RequestGameLobbyRemainIntact(scrContext_t *scrContext)
{
  ?GScr_RequestGameLobbyRemainIntact@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_PlayerMigrated
==============
*/

void __fastcall Scr_PlayerMigrated(gentity_s *self)
{
  ?Scr_PlayerMigrated@@YAXPEAUgentity_s@@@Z(self);
}

/*
==============
Scr_LoadGameType
==============
*/

void Scr_LoadGameType(void)
{
  ?Scr_LoadGameType@@YAXXZ();
}

/*
==============
GScriptMP::GetMethod
==============
*/

unsigned int __fastcall GScriptMP::GetMethod(GScriptMP *this, const char **pName, BuiltinType *type)
{
  return ?GetMethod@GScriptMP@@UEBAIPEAPEBDPEAW4BuiltinType@@@Z(this, pName, type);
}

/*
==============
Scr_StartupGameType
==============
*/

void Scr_StartupGameType(void)
{
  ?Scr_StartupGameType@@YAXXZ();
}

/*
==============
GScr_GetCorpseAnim
==============
*/

void __fastcall GScr_GetCorpseAnim(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScr_GetCorpseAnim@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
Scr_PlayerConnect
==============
*/

void __fastcall Scr_PlayerConnect(gentity_s *self)
{
  ?Scr_PlayerConnect@@YAXPEAUgentity_s@@@Z(self);
}

/*
==============
Scr_VoteCalled
==============
*/

void __fastcall Scr_VoteCalled(gentity_s *self, char *command, char *param1, char *param2)
{
  ?Scr_VoteCalled@@YAXPEAUgentity_s@@PEAD11@Z(self, command, param1, param2);
}

/*
==============
Scr_SetFXKillDefOnDelete
==============
*/

void __fastcall Scr_SetFXKillDefOnDelete(scrContext_t *scrContext, scr_entref_t entref)
{
  ?Scr_SetFXKillDefOnDelete@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
Scr_GetFxEventParam
==============
*/
__int64 Scr_GetFxEventParam(const int fxId, const int boneIndex, const int onlyClientIndex)
{
  unsigned int v6; 
  __int64 v8; 
  __int64 v9; 
  int v10; 
  int v11; 

  if ( fxId <= 0 )
    goto LABEL_22;
  if ( !BgDynamicLimits::IsValidGameMode() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_dynamic_limits.h", 98, ASSERT_TYPE_ASSERT, "(IsValidGameMode())", "%s\n\tAccessing BgDynamicLimits during invalid game mode", "IsValidGameMode()") )
    __debugbreak();
  if ( fxId >= BgDynamicLimits::ms_data.m_effectNamesCount )
  {
LABEL_22:
    if ( !BgDynamicLimits::IsValidGameMode() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_dynamic_limits.h", 98, ASSERT_TYPE_ASSERT, "(IsValidGameMode())", "%s\n\tAccessing BgDynamicLimits during invalid game mode", "IsValidGameMode()") )
      __debugbreak();
    v11 = BgDynamicLimits::ms_data.m_effectNamesCount - 1;
    v10 = fxId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 15115, ASSERT_TYPE_ASSERT, "(FX_IsValidFxId( fxId ))", "%s\n\tInvalid fxId %d. Max effect ID is %d", "FX_IsValidFxId( fxId )", v10, v11) )
      __debugbreak();
  }
  if ( (unsigned int)boneIndex >= 0x100 )
  {
    LODWORD(v9) = 256;
    LODWORD(v8) = boneIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 15118, ASSERT_TYPE_ASSERT, "(unsigned)( boneIndex ) < (unsigned)( (1<<8) )", "boneIndex doesn't index BONEINDEX_COUNT\n\t%i not in [0, %i)", v8, v9) )
      __debugbreak();
  }
  v6 = fxId | (boneIndex << BgDynamicLimits::GetEffectBits());
  if ( onlyClientIndex != -1 )
  {
    if ( (unsigned int)onlyClientIndex >= level.maxclients )
    {
      LODWORD(v9) = level.maxclients;
      LODWORD(v8) = onlyClientIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 15124, ASSERT_TYPE_ASSERT, "(unsigned)( onlyClientIndex ) < (unsigned)( level.maxclients )", "onlyClientIndex doesn't index level.maxclients\n\t%i not in [0, %i)", v8, v9) )
        __debugbreak();
    }
    v6 |= onlyClientIndex << (BgDynamicLimits::GetEffectBits() + 8);
  }
  return v6;
}

/*
==============
GScr_GetUAVStrengthLevelNeutral
==============
*/
void GScr_GetUAVStrengthLevelNeutral(scrContext_t *scrContext)
{
  const dvar_t *v1; 

  v1 = DCONST_DVARINT_bg_UAVStrengthLevelNeutral;
  if ( !DCONST_DVARINT_bg_UAVStrengthLevelNeutral && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_UAVStrengthLevelNeutral") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  Scr_AddInt(scrContext, v1->current.integer);
}

/*
==============
GScr_GetUAVStrengthLevelShowEnemyFastSweep
==============
*/
void GScr_GetUAVStrengthLevelShowEnemyFastSweep(scrContext_t *scrContext)
{
  const dvar_t *v1; 

  v1 = DCONST_DVARINT_bg_UAVStrengthLevelShowEnemyFastSweep;
  if ( !DCONST_DVARINT_bg_UAVStrengthLevelShowEnemyFastSweep && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_UAVStrengthLevelShowEnemyFastSweep") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  Scr_AddInt(scrContext, v1->current.integer);
}

/*
==============
GScr_GetUAVStrengthLevelShowEnemyDirectional
==============
*/
void GScr_GetUAVStrengthLevelShowEnemyDirectional(scrContext_t *scrContext)
{
  const dvar_t *v1; 

  v1 = DCONST_DVARINT_bg_UAVStrengthLevelShowEnemyDirectional;
  if ( !DCONST_DVARINT_bg_UAVStrengthLevelShowEnemyDirectional && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_UAVStrengthLevelShowEnemyDirectional") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  Scr_AddInt(scrContext, v1->current.integer);
}

/*
==============
GScr_BlockTeamRadar
==============
*/
void GScr_BlockTeamRadar(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const char *v3; 
  const char *v4; 
  const char *v5; 
  const char *v6; 
  team_t outTeam; 

  ConstString = Scr_GetConstString(scrContext, 0);
  if ( Com_Teams_TeamFromString(ConstString, &outTeam) )
  {
    if ( outTeam >= TEAM_MP_NUM_TEAMS )
    {
      v5 = SL_ConvertToString(ConstString);
      v6 = j_va("Illegal team string '%s'. Must be axis, allies, team_three, team_four, team_five, team_six or none.", v5);
      Scr_ParamError(COM_ERR_3241, scrContext, 0, v6);
    }
    level.teamRadarBlocked[outTeam] = 1;
  }
  else
  {
    v3 = SL_ConvertToString(ConstString);
    v4 = j_va("unknown team '%s'", v3);
    Scr_Error(COM_ERR_3240, scrContext, v4);
  }
}

/*
==============
GScr_UnblockTeamRadar
==============
*/
void GScr_UnblockTeamRadar(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const char *v3; 
  const char *v4; 
  const char *v5; 
  const char *v6; 
  team_t outTeam; 

  ConstString = Scr_GetConstString(scrContext, 0);
  if ( Com_Teams_TeamFromString(ConstString, &outTeam) )
  {
    if ( outTeam >= TEAM_MP_NUM_TEAMS )
    {
      v5 = SL_ConvertToString(ConstString);
      v6 = j_va("Illegal team string '%s'. Must be axis, allies, team_three, team_four, team_five, team_six or none.", v5);
      Scr_ParamError(COM_ERR_3243, scrContext, 0, v6);
    }
    level.teamRadarBlocked[outTeam] = 0;
  }
  else
  {
    v3 = SL_ConvertToString(ConstString);
    v4 = j_va("unknown team '%s'", v3);
    Scr_Error(COM_ERR_3242, scrContext, v4);
  }
}

/*
==============
GScr_IsTeamRadarBlocked
==============
*/
void GScr_IsTeamRadarBlocked(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const char *v3; 
  const char *v4; 
  const char *v5; 
  const char *v6; 
  team_t outTeam; 

  ConstString = Scr_GetConstString(scrContext, 0);
  if ( Com_Teams_TeamFromString(ConstString, &outTeam) )
  {
    if ( outTeam >= TEAM_MP_NUM_TEAMS )
    {
      v5 = SL_ConvertToString(ConstString);
      v6 = j_va("Illegal team string '%s'. Must be axis, allies, team_three, team_four, team_five, team_six or none.", v5);
      Scr_ParamError(COM_ERR_3245, scrContext, 0, v6);
    }
    Scr_AddInt(scrContext, level.teamRadarBlocked[outTeam]);
  }
  else
  {
    v3 = SL_ConvertToString(ConstString);
    v4 = j_va("unknown team '%s'", v3);
    Scr_Error(COM_ERR_3244, scrContext, v4);
  }
}

/*
==============
GScr_EndLobby
==============
*/
void GScr_EndLobby(scrContext_t *scrContext)
{
  const dvar_t *v1; 

  v1 = DVARBOOL_g_kickHostIfIdle;
  if ( !DVARBOOL_g_kickHostIfIdle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "g_kickHostIfIdle") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  if ( v1->current.enabled )
    Cbuf_AddText(LOCAL_CLIENT_0, "xpartydisbandafterround\n");
}

/*
==============
GScr_MainMP_StartRagdoll
==============
*/
void GScr_MainMP_StartRagdoll(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  bool v4; 
  int Int; 

  Entity = GetEntity(entref);
  v4 = 0;
  if ( Scr_GetNumParam(scrContext) )
  {
    if ( Scr_GetType(scrContext, 0) != VAR_INTEGER )
      Scr_Error(COM_ERR_3246, scrContext, "GScr_MainMP_StartRagdoll - first param must be a boolean - it should be true if the ragdoll is being played instantly on a player\n");
    Int = Scr_GetInt(scrContext, 0);
    v4 = Int != 0;
    if ( Int && Entity->s.eType != ET_PLAYER_CORPSE )
      Scr_Error(COM_ERR_3247, scrContext, "GScr_MainMP_StartRagdoll - flagged as an instant player ragdoll - but the entity isn't a player corpse\n");
  }
  if ( G_PlayerCorpseMP_CheckShouldStartRagdoll(Entity) )
    G_PlayerCorpseMP_StartRagdoll(Entity, v4);
}

/*
==============
GScr_MainMP_StartRagdollFromImpact
==============
*/
void GScr_MainMP_StartRagdollFromImpact(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t ConstString; 
  int HitLocationIndexFromString; 
  vec3_t vectorValue; 

  Entity = GetEntity(entref);
  if ( Entity->s.eType != ET_AGENT_CORPSE )
    Scr_Error(COM_ERR_3248, scrContext, "GScr_MainMP_StartRagdollFromImpact - Must only be called on agent corpse. \n");
  if ( G_PlayerCorpseMP_CheckShouldStartRagdoll(Entity) )
  {
    vectorValue.v[0] = 0.0;
    vectorValue.v[1] = 0.0;
    vectorValue.v[2] = 0.0;
    ConstString = Scr_GetConstString(scrContext, 0);
    HitLocationIndexFromString = G_Combat_GetHitLocationIndexFromString(ConstString);
    if ( !HitLocationIndexFromString && ConstString != scr_const.none )
      Scr_Error(COM_ERR_3249, scrContext, "HitLoc parameter must be a valid hit location string e.g. 'torso_upper'\n");
    Scr_GetVector(scrContext, 1u, &vectorValue);
    if ( HitLocationIndexFromString )
    {
      LerpEntityStateAgentCorpse::SetHitLoc((LerpEntityStateAgentCorpse *)&Entity->s.lerp.u, HitLocationIndexFromString);
      LerpEntityStateAgentCorpse::SetImpactVector((LerpEntityStateAgentCorpse *)&Entity->s.lerp.u, &vectorValue);
    }
    G_PlayerCorpseMP_StartRagdoll(Entity, 0);
  }
}

/*
==============
GScr_MainMP_StartRagdollFromVehicleHit
==============
*/
void GScr_MainMP_StartRagdollFromVehicleHit(scrContext_t *scrContext, scr_entref_t entref)
{
  const dvar_t *v2; 
  gentity_s *Entity; 
  gentity_s *v6; 
  Vehicle *vehicle; 
  GVehicles *VehicleSystem; 
  BgVehiclePhysicsManager *v9; 
  BgVehiclePhysics *ObjectById; 
  float v12; 
  __int128 v14; 
  float v15; 
  float v16; 
  const dvar_t *v17; 
  __int128 v18; 
  float v21; 
  float v23; 
  float v24; 
  float v25; 
  GHandler *Handler; 
  int v27[4]; 
  vec3_t outVelLs; 

  v2 = DVARBOOL_bg_vehRagdoll;
  if ( !DVARBOOL_bg_vehRagdoll && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_vehRagdoll") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  if ( v2->current.enabled )
  {
    Entity = GetEntity(entref);
    if ( Entity->s.eType != ET_PLAYER_CORPSE )
      Scr_Error(COM_ERR_6219, scrContext, "GScr_MainMP_StartRagdollFromVehicleHit - Must only be called on player corpse. \n");
    if ( G_PlayerCorpseMP_CheckShouldStartRagdoll(Entity) )
    {
      v6 = GScr_GetEntity(0);
      if ( !BG_IsVehicleEntity(&v6->s) || (vehicle = v6->vehicle) == NULL || !BGVehicles::PhysicsIsValid(vehicle->physicsVehicle) )
        Scr_Error(COM_ERR_6220, scrContext, "GScr_MainMP_StartRagdollFromVehicleHit - Must be called with a physics vehicle entity. \n");
      VehicleSystem = GVehicles::GetVehicleSystem();
      v9 = VehicleSystem->PhysicsGetVehiclePhysicsManager(VehicleSystem);
      ObjectById = BgVehiclePhysicsManager::GetObjectById(v9, v6->vehicle->physicsVehicle);
      if ( !ObjectById && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 9559, ASSERT_TYPE_ASSERT, "(vehObj)", (const char *)&queryFormat, "vehObj") )
        __debugbreak();
      BgVehiclePhysics::ComputeVelocityLocalSpace(ObjectById, &ObjectById->m_linearVelocityWs, &outVelLs);
      _XMM0 = LODWORD(outVelLs.v[0]);
      v12 = (float)(*(float *)&_XMM0 * *(float *)&_XMM0) + (float)(outVelLs.v[1] * outVelLs.v[1]);
      *(double *)&_XMM0 = BgVehiclePhysics::GetTopSpeedForward(ObjectById);
      __asm { vmaxss  xmm1, xmm0, cs:__real@41200000 }
      *(double *)&_XMM0 = I_fclamp(fsqrt(v12) * (float)(1.0 / *(float *)&_XMM1), 0.0, 1.0);
      v14 = LODWORD(ObjectById->m_linearVelocityWs.v[0]);
      v15 = ObjectById->m_linearVelocityWs.v[1];
      v16 = ObjectById->m_linearVelocityWs.v[2];
      v17 = DCONST_DVARFLT_bg_vehRagdollSpawnAhead;
      v18 = v14;
      *(float *)&v18 = fsqrt((float)((float)(*(float *)&v14 * *(float *)&v14) + (float)(v15 * v15)) + (float)(v16 * v16));
      _XMM4 = v18;
      __asm { vcmpless xmm1, xmm4, cs:__real@80000000 }
      v21 = *(float *)&_XMM0;
      __asm { vblendvps xmm0, xmm4, xmm8, xmm1 }
      v23 = *(float *)&v14 * (float)(1.0 / *(float *)&_XMM0);
      v24 = v15 * (float)(1.0 / *(float *)&_XMM0);
      if ( !DCONST_DVARFLT_bg_vehRagdollSpawnAhead && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_vehRagdollSpawnAhead") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v17);
      v25 = (float)(v21 * v21) * v17->current.value;
      *(float *)v27 = (float)(v23 * v25) + Entity->r.currentOrigin.v[0];
      *(float *)&v27[1] = (float)(v24 * v25) + Entity->r.currentOrigin.v[1];
      *(float *)&v27[2] = (float)((float)(v16 * (float)(1.0 / *(float *)&_XMM0)) * v25) + Entity->r.currentOrigin.v[2];
      Handler = GHandler::getHandler();
      Handler->SetEntityOrigin(Handler, Entity->s.number, (const vec3_t *)v27);
      G_PlayerCorpseMP_StartRagdoll(Entity, 0);
    }
  }
}

/*
==============
GScr_MainMP_StartRagdollFromVehicleImpact
==============
*/
void GScr_MainMP_StartRagdollFromVehicleImpact(scrContext_t *scrContext, scr_entref_t entref)
{
  const dvar_t *v2; 
  gentity_s *Entity; 
  gentity_s *v6; 
  Vehicle *vehicle; 
  GVehicles *VehicleSystem; 
  BgVehiclePhysicsManager *v9; 
  BgVehiclePhysics *ObjectById; 
  float v12; 
  unsigned int PhysicsBodyId; 
  Physics_WorldId m_worldId; 
  unsigned int v15; 
  hknpWorld *world; 
  float *v17; 
  __m128 v18; 
  float v19; 
  float v20; 
  float v22; 
  __int128 v23; 
  __int64 v27; 
  char v28; 
  vec3_t impactVector; 
  float v30; 

  v2 = DVARBOOL_bg_vehRagdoll;
  if ( !DVARBOOL_bg_vehRagdoll && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_vehRagdoll") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  if ( v2->current.enabled )
  {
    Entity = GetEntity(entref);
    if ( ((Entity->s.eType - 2) & 0xFFEF) != 0 )
      Scr_Error(COM_ERR_6288, scrContext, "GScr_MainMP_StartRagdollFromVehicleHit - Must only be called on player corpse. \n");
    if ( G_PlayerCorpseMP_CheckShouldStartRagdoll(Entity) )
    {
      v6 = GScr_GetEntity(0);
      if ( !BG_IsVehicleEntity(&v6->s) || (vehicle = v6->vehicle) == NULL || !BGVehicles::PhysicsIsValid(vehicle->physicsVehicle) )
        Scr_Error(COM_ERR_6289, scrContext, "GScr_MainMP_StartRagdollFromVehicleHit - Must be called with a physics vehicle entity. \n");
      VehicleSystem = GVehicles::GetVehicleSystem();
      v9 = VehicleSystem->PhysicsGetVehiclePhysicsManager(VehicleSystem);
      ObjectById = BgVehiclePhysicsManager::GetObjectById(v9, v6->vehicle->physicsVehicle);
      if ( !ObjectById && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 9613, ASSERT_TYPE_ASSERT, "(vehObj)", (const char *)&queryFormat, "vehObj") )
        __debugbreak();
      if ( BgVehiclePhysics::IsDynamic(ObjectById) )
      {
        _XMM0 = LODWORD(ObjectById->m_transform.m[0].v[2]);
        v12 = (float)((float)(ObjectById->m_transform.m[0].v[1] * ObjectById->m_linearVelocityWs.v[1]) + (float)(ObjectById->m_transform.m[0].v[0] * ObjectById->m_linearVelocityWs.v[0])) + (float)(*(float *)&_XMM0 * ObjectById->m_linearVelocityWs.v[2]);
      }
      else
      {
        PhysicsBodyId = BgVehiclePhysics::GetPhysicsBodyId(ObjectById);
        m_worldId = ObjectById->m_worldId;
        v15 = PhysicsBodyId;
        if ( (unsigned int)m_worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
        {
          LODWORD(v27) = ObjectById->m_worldId;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 850, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body Transform with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v27) )
            __debugbreak();
        }
        if ( (v15 & 0xFFFFFF) == 0xFFFFFF )
        {
          LODWORD(v27) = m_worldId;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 851, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Get Rigid Body Transform with invalid body id for world %i", "bodyId.isValid()", v27) )
            __debugbreak();
        }
        world = HavokPhysics_GetConstWorld(m_worldId)->world;
        if ( !world )
        {
          LODWORD(v27) = m_worldId;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 855, ASSERT_TYPE_ASSERT, "(world)", "%s\n\tHavokPhysics Get rigid Body Transform %i: world is NULL", "world", v27) )
            __debugbreak();
        }
        v17 = (float *)((__int64 (__fastcall *)(hknpWorldReader *, _QWORD))world->getBodyTransform)(&world->hknpWorldReader, v15);
        v18 = (__m128)*(unsigned __int64 *)ObjectById->m_history.m_lastLinearVel.v;
        v19 = _mm_shuffle_ps(v18, v18, 85).m128_f32[0] * v17[1];
        v20 = v18.m128_f32[0] * *v17;
        *((_QWORD *)&_XMM0 + 1) = 0i64;
        v30 = ObjectById->m_history.m_lastLinearVel.v[2];
        v12 = (float)(v19 + v20) + (float)(v30 * v17[2]);
      }
      if ( v12 <= 0.0 )
        *(double *)&_XMM0 = BgVehiclePhysics::GetTopSpeedReverse(ObjectById);
      else
        *(double *)&_XMM0 = BgVehiclePhysics::GetTopSpeedForward(ObjectById);
      __asm { vmaxss  xmm0, xmm0, cs:__real@41200000 }
      *(double *)&_XMM0 = I_fclamp(COERCE_FLOAT(COERCE_UNSIGNED_INT(v12 / *(float *)&_XMM0) & _xmm), 0.0, 1.0);
      v22 = *(float *)&_XMM0;
      ObjectById->GetRagdollInitialImpact(ObjectById, &Entity->r.currentOrigin, 0, (int *)&v28, &impactVector);
      v23 = LODWORD(impactVector.v[0]);
      *(float *)&v23 = fsqrt((float)((float)(*(float *)&v23 * *(float *)&v23) + (float)(impactVector.v[1] * impactVector.v[1])) + (float)(impactVector.v[2] * impactVector.v[2]));
      _XMM2 = v23;
      __asm
      {
        vcmpless xmm0, xmm2, cs:__real@80000000
        vblendvps xmm0, xmm2, xmm9, xmm0
      }
      impactVector.v[0] = (float)(impactVector.v[0] * (float)(1.0 / *(float *)&_XMM0)) * (float)(v22 * sScale);
      impactVector.v[2] = (float)(impactVector.v[2] * (float)(1.0 / *(float *)&_XMM0)) * (float)(v22 * sScale);
      impactVector.v[1] = (float)(impactVector.v[1] * (float)(1.0 / *(float *)&_XMM0)) * (float)(v22 * sScale);
      LerpEntityStateAgentCorpse::SetHitLoc((LerpEntityStateAgentCorpse *)&Entity->s.lerp.u, 5);
      LerpEntityStateAgentCorpse::SetImpactVector((LerpEntityStateAgentCorpse *)&Entity->s.lerp.u, &impactVector);
      G_PlayerCorpseMP_StartRagdoll(&g_entities[Entity->s.number], 0);
    }
  }
}

/*
==============
GScr_MainMP_SetPlayerCorpseDone
==============
*/
void GScr_MainMP_SetPlayerCorpseDone(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  GCorpseInfoMP *CorpseInfo; 

  Entity = GetEntity(entref);
  if ( Entity->s.eType != ET_PLAYER_CORPSE )
    Scr_Error(COM_ERR_5755, scrContext, "GScr_MainMP_SetPlayerCorpseDone only valid for player corpses.\n");
  CorpseInfo = G_PlayerCorpseMP_FindCorpseInfo(Entity);
  if ( !CorpseInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 9658, ASSERT_TYPE_ASSERT, "( corpseInfo )", (const char *)&queryFormat, "corpseInfo") )
    __debugbreak();
  CorpseInfo->canDetachClientCorpse = 1;
  G_PlayerCorpseMP_UpdateClientDetachState(Entity, CorpseInfo);
}

/*
==============
GScr_GetCorpseAnim
==============
*/
void GScr_GetCorpseAnim(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  __int64 v4; 
  gentity_s *v5; 
  __int64 v6; 
  const BgAnimStatic *v7; 
  entityType_s eType; 
  GameScriptDataMP *GameScriptDataMP; 
  const XAnimTree **p_tree; 
  unsigned __int16 AnimIndex; 
  GameScriptDataMP *v12; 
  __int64 AgentCorpseIndex; 
  scr_string_t AnimsetName; 
  SuitAnimType SuitAnimIndex; 
  int LegsAnimation; 
  const XAnim_s *Anims; 
  const char *v18; 
  scr_anim_t value; 

  Entity = GetEntity(entref);
  v4 = tls_index;
  v5 = Entity;
  if ( !*(_QWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 272i64) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_static.h", 169, ASSERT_TYPE_ASSERT, "(ms_activeBgs)", (const char *)&queryFormat, "ms_activeBgs") )
    __debugbreak();
  v6 = *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + v4) + 272i64);
  if ( !v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 9676, ASSERT_TYPE_ASSERT, "( bgameStatic )", (const char *)&queryFormat, "bgameStatic") )
    __debugbreak();
  v7 = (const BgAnimStatic *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v6 + 8i64))(v6);
  if ( !v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 9679, ASSERT_TYPE_ASSERT, "( bgameAnim )", (const char *)&queryFormat, "bgameAnim") )
    __debugbreak();
  eType = v5->s.eType;
  if ( eType == ET_PLAYER_CORPSE )
  {
    GameScriptDataMP = GameScriptDataMP::GetGameScriptDataMP();
    p_tree = (const XAnimTree **)&GameScriptDataMP->playerCorpseInfo[G_PlayerCorpseMP_GetEntCorpseIndex(v5)].tree;
    goto LABEL_12;
  }
  if ( eType == ET_AGENT_CORPSE )
  {
    v12 = GameScriptDataMP::GetGameScriptDataMP();
    AgentCorpseIndex = G_PlayerCorpseMP_GetAgentCorpseIndex(v5);
    p_tree = (const XAnimTree **)&v12->agentCorpseInfo[AgentCorpseIndex].tree;
    if ( v12->agentCorpseInfo[AgentCorpseIndex].ci.usingAnimState )
    {
      AnimsetName = BG_AnimationState_GetAnimsetName(&v5->s);
      if ( !AnimsetName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 9714, ASSERT_TYPE_ASSERT, "( animsetName != ( static_cast< scr_string_t >( 0 ) ) )", (const char *)&queryFormat, "animsetName != NULL_SCR_STRING") )
        __debugbreak();
      AnimIndex = BG_AnimationState_GetAnimIndex(AnimsetName, &v5->s);
      goto LABEL_21;
    }
LABEL_12:
    if ( PlayerASM_IsEnabled() )
    {
      AnimIndex = BG_PlayerASM_GetXAnimIndex(&v5->s, MOVEMENT);
    }
    else
    {
      SuitAnimIndex = BG_AnimationMP_GetSuitAnimIndex(&v5->s);
      LegsAnimation = BG_AnimationMP_GetLegsAnimation(&v5->s);
      AnimIndex = BG_AnimationMP_GetXAnimIndex(v7, SuitAnimIndex, LegsAnimation & 0xFFFFEFFF);
    }
LABEL_21:
    value.index = AnimIndex;
    Anims = XAnimGetAnims(*p_tree);
    value.tree = Scr_GetAnimsIndex(Anims, 1u);
    Scr_AddAnim(scrContext, value);
    return;
  }
  v18 = j_va("Only valid on player corpses");
  Scr_Error(COM_ERR_3250, scrContext, v18);
}

/*
==============
GScr_SetCorpseFalling
==============
*/
void GScr_SetCorpseFalling(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  bool v4; 
  __int64 EntCorpseIndex; 

  Entity = GetEntity(entref);
  v4 = Scr_GetInt(scrContext, 0) != 0;
  if ( Entity && Entity->s.eType == ET_PLAYER_CORPSE )
  {
    EntCorpseIndex = G_PlayerCorpseMP_GetEntCorpseIndex(Entity);
    GameScriptDataMP::GetGameScriptDataMP()->playerCorpseInfo[EntCorpseIndex].falling = v4;
  }
  else
  {
    Scr_Error(COM_ERR_3251, scrContext, "SetCorpseFalling called on a non-corpse entity\n");
  }
}

/*
==============
GScr_GetCorpseEntity
==============
*/
void GScr_GetCorpseEntity(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  const GCorpseInfoMP *CorpseInfoFromEntity; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3678, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 9796, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client && !v4->agent )
    {
      v5 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3677, scrContext, v5);
    }
  }
  CorpseInfoFromEntity = GetCorpseInfoFromEntity(v4);
  if ( CorpseInfoFromEntity )
    GScr_AddEntity(&g_entities[CorpseInfoFromEntity->entnum]);
  else
    Scr_AddUndefined(scrContext);
}

/*
==============
ScrCmd_PlayerForceDeathAnim
==============
*/
void ScrCmd_PlayerForceDeathAnim(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const gentity_s *v4; 
  int v5; 
  hitLocation_t hitLoc; 
  int v7; 
  bool outIsAlternate; 
  vec3_t vectorValue; 
  Weapon outWeapon; 

  Entity = GetEntity(entref);
  if ( !Entity->client )
    Scr_Error(COM_ERR_3252, scrContext, "Must be called on a player.");
  v4 = GScr_GetEntity(0);
  v5 = G_Combat_MeansOfDeathFromScriptParam(scrContext, 1);
  GScr_Main_GetWeaponParam(scrContext, 2u, &outWeapon, &outIsAlternate);
  hitLoc = G_Combat_HitLocFromScriptParam(scrContext, 3);
  Scr_GetVector(scrContext, 4u, &vectorValue);
  v7 = G_CombatMP_DeathAnimForScript(Entity, v4, v5, &outWeapon, hitLoc, &vectorValue);
  Scr_AddInt(scrContext, v7);
}

/*
==============
GScr_ForceThirdPersonWhenSpectating
==============
*/
void GScr_ForceThirdPersonWhenSpectating(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gclient_s *client; 

  Entity = GetEntity(entref);
  client = Entity->client;
  if ( !client )
  {
    Scr_ObjectError(COM_ERR_3253, scrContext, "not a player entity");
    client = Entity->client;
  }
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal(&client->ps.otherFlags, GameModeFlagValues::ms_mpValue, 0x2Bu);
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal(&Entity->client->ps.otherFlags, GameModeFlagValues::ms_mpValue, 0x2Cu);
}

/*
==============
GScr_ForceHelmetWhenSpectating
==============
*/
void GScr_ForceHelmetWhenSpectating(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gclient_s *client; 

  Entity = GetEntity(entref);
  client = Entity->client;
  if ( !client )
  {
    Scr_ObjectError(COM_ERR_6082, scrContext, "not a player entity");
    client = Entity->client;
  }
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal(&client->ps.otherFlags, GameModeFlagValues::ms_mpValue, 0x2Cu);
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal(&Entity->client->ps.otherFlags, GameModeFlagValues::ms_mpValue, 0x2Bu);
}

/*
==============
GScr_DisableForceHelmetWhenSpectating
==============
*/
void GScr_DisableForceHelmetWhenSpectating(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gclient_s *client; 

  Entity = GetEntity(entref);
  client = Entity->client;
  if ( !client )
  {
    Scr_ObjectError(COM_ERR_3255, scrContext, "not a player entity");
    client = Entity->client;
  }
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal(&client->ps.otherFlags, GameModeFlagValues::ms_mpValue, 0x2Cu);
}

/*
==============
GScr_SetBallPassAllowed
==============
*/
void GScr_SetBallPassAllowed(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gclient_s *client; 
  int Int; 
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *p_otherFlags; 

  Entity = GetEntity(entref);
  client = Entity->client;
  if ( !client )
  {
    Scr_ObjectError(COM_ERR_3254, scrContext, "SetBallPassAllowed() must be called on a player");
    client = Entity->client;
    if ( !client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 9945, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
  }
  Int = Scr_GetInt(scrContext, 0);
  p_otherFlags = &client->ps.otherFlags;
  if ( Int )
    GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagStrict(p_otherFlags, (POtherFlagsMP)48);
  else
    GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagStrict(p_otherFlags, (POtherFlagsMP)48);
}

/*
==============
GScr_DisableForceThirdPersonWhenSpectating
==============
*/
void GScr_DisableForceThirdPersonWhenSpectating(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gclient_s *client; 

  Entity = GetEntity(entref);
  client = Entity->client;
  if ( !client )
  {
    Scr_ObjectError(COM_ERR_6083, scrContext, "not a player entity");
    client = Entity->client;
  }
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal(&client->ps.otherFlags, GameModeFlagValues::ms_mpValue, 0x2Bu);
}

/*
==============
GScr_StartAC130
==============
*/
void GScr_StartAC130(scrContext_t *scrContext, scr_entref_t entref)
{
  if ( !GetEntity(entref)->client )
    Scr_ObjectError(COM_ERR_3256, scrContext, "not a player entity");
  Scr_Error(COM_ERR_3257, scrContext, "This functionality has been disabled, code needs to re-enable special ambient support");
}

/*
==============
GScr_StopAC130
==============
*/
void GScr_StopAC130(scrContext_t *scrContext, scr_entref_t entref)
{
  if ( !GetEntity(entref)->client )
    Scr_ObjectError(COM_ERR_3258, scrContext, "not a player entity");
  Scr_Error(COM_ERR_3259, scrContext, "This functionality has been disabled, code needs to re-enable special ambient support");
}

/*
==============
Scr_DevSetMinimapDvarSettings
==============
*/
void Scr_DevSetMinimapDvarSettings(scrContext_t *scrContext)
{
  const char *v2; 
  double Float; 
  double v4; 

  if ( Scr_GetNumParam(scrContext) != 2 )
  {
    v2 = j_va("USAGE: DevSetMinimapDvarSettings(<znear>, <angle>);\n");
    Scr_Error(COM_ERR_3260, scrContext, v2);
  }
  Dvar_SetBoolByName("SROLTPQLK", 0);
  Dvar_SetBoolByName("NNTRRPNLQ", 0);
  Dvar_SetBoolByName("LKQNQLPSNQ", 0);
  Dvar_SetBoolByName("MSMKRKOKQP", 0);
  Dvar_SetBoolByName("LTOKRMRTMM", 0);
  Dvar_SetBoolByName("MQRQQONQSL", 1);
  Dvar_SetBoolByName("RNPPKQOTN", 1);
  Dvar_SetIntByName("OLNTNRTPPL", 0);
  Dvar_SetFloatByName("QTSTQORQL", 0.0);
  Dvar_SetFloatByName("LOMLPPTKO", 90.0);
  Dvar_SetFloatByName("NNSNKNRTPL", 0.0);
  Dvar_SetFloatByName("NQPKSOTP", 1.0);
  Float = Scr_GetFloat(scrContext, 1u);
  Dvar_SetFloatByName("QTSPTNLOL", *(float *)&Float);
  v4 = Scr_GetFloat(scrContext, 1u);
  Dvar_SetFloatByName("LQSSPMSRQK", *(float *)&v4);
}

/*
==============
Scr_GetPathDist
==============
*/
void Scr_GetPathDist(scrContext_t *scrContext)
{
  double Float; 
  double Dist; 
  vec3_t vEndPos; 
  vec3_t vectorValue; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &vEndPos);
  if ( Scr_GetNumParam(scrContext) <= 2 )
    *(float *)&Float = FLOAT_1024_0;
  else
    Float = Scr_GetFloat(scrContext, 2u);
  Dist = Path_GetPathFindDist(&vectorValue, &vEndPos, *(float *)&Float);
  Scr_AddFloat(scrContext, *(float *)&Dist);
}

/*
==============
GScr_EmissiveBlend
==============
*/
void GScr_EmissiveBlend(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int v6; 
  double Float; 
  msg_t buf; 

  Entity = GetEntity(entref);
  if ( (Entity->s.eType & 0x11) != 0 )
  {
    _XMM7 = 0i64;
    Scr_GetFloat(scrContext, 0);
    __asm { vroundss xmm3, xmm7, xmm1, 1 }
    v6 = (int)*(float *)&_XMM3;
    if ( (int)*(float *)&_XMM3 < 0 )
      Scr_Error(COM_ERR_3264, scrContext, "duration must be positive.");
    if ( v6 > 0xFFFF )
      Scr_Error(COM_ERR_3265, scrContext, "duration must be less than 65.535s any longer will require more bandwidth.");
    Float = Scr_GetFloat(scrContext, 1u);
    if ( *(float *)&Float < 0.0 || *(float *)&Float > 1.0 )
      Scr_Error(COM_ERR_3266, scrContext, "Intensity must be between 0 and 1");
    MSG_Init(&buf, msgBuffer, 1020);
    MSG_WriteByte(&buf, 49i64);
    if ( Entity->s.number >= 255 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 10209, ASSERT_TYPE_ASSERT, "(ent->s.number < 0xff)", (const char *)&queryFormat, "ent->s.number < 0xff") )
      __debugbreak();
    MSG_WriteByte(&buf, Entity->s.number);
    __asm { vroundss xmm0, xmm7, xmm2, 1 }
    MSG_WriteByte(&buf, (int)*(float *)&_XMM0);
    MSG_WriteShort(&buf, v6);
    SV_Game_BroadcastServerCommandMsg(SV_CMD_CAN_IGNORE, &buf);
  }
}

/*
==============
GScr_SetAutoBoxCalculationUsingDobj
==============
*/
void GScr_SetAutoBoxCalculationUsingDobj(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  GameModeFlagContainer<enum BgEntityFlagsCommon,enum BgEntityFlagsSP,enum BgEntityFlagsMP,64> *p_flags; 

  Entity = GetEntity(entref);
  if ( Entity->classname == scr_const.script_model )
  {
    p_flags = &Entity->flags;
    if ( Scr_GetInt(scrContext, 0) )
    {
      if ( GameModeFlagValues::ms_mpValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 201, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a MP-only context", "IsFlagActive( index )") )
        __debugbreak();
      p_flags->m_flags[1] |= 0x10u;
    }
    else
    {
      GameModeFlagContainer<enum BgEntityFlagsCommon,enum BgEntityFlagsSP,enum BgEntityFlagsMP,64>::ClearFlagStrict(p_flags, (BgEntityFlagsMP)36);
    }
  }
  else
  {
    Scr_Error(COM_ERR_6490, scrContext, "Currently only supported on script model entities.");
  }
}

/*
==============
GScr_DisableMissileStick
==============
*/
void GScr_DisableMissileStick(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( Entity->classname != scr_const.script_model )
    Scr_Error(COM_ERR_3267, scrContext, "Currently only supported on script model entities");
  if ( GameModeFlagValues::ms_mpValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 201, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a MP-only context", "IsFlagActive( index )") )
    __debugbreak();
  Entity->flags.m_flags[1] |= 2u;
}

/*
==============
GScr_EnableMissileStick
==============
*/
void GScr_EnableMissileStick(scrContext_t *scrContext, scr_entref_t entref)
{
  GameModeFlagContainer<enum BgEntityFlagsCommon,enum BgEntityFlagsSP,enum BgEntityFlagsMP,64> *Entity; 

  Entity = (GameModeFlagContainer<enum BgEntityFlagsCommon,enum BgEntityFlagsSP,enum BgEntityFlagsMP,64> *)GetEntity(entref);
  if ( Entity[47].m_flags[1] != scr_const.script_model )
    Scr_Error(COM_ERR_3268, scrContext, "Currently only supported on script model entities");
  if ( GameModeFlagValues::ms_mpValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 212, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a MP-only context", "IsFlagActive( index )") )
    __debugbreak();
  GameModeFlagContainer<enum BgEntityFlagsCommon,enum BgEntityFlagsSP,enum BgEntityFlagsMP,64>::ClearFlagInternal(Entity + 52, ACTIVE, 0x21u);
}

/*
==============
GScr_RideVehicle
==============
*/
void GScr_RideVehicle(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  gclient_s *client; 
  int NumParam; 
  double Float; 
  double v8; 
  double v9; 
  double v10; 
  double v11; 
  double v12; 
  double v13; 
  double v14; 
  unsigned int v15; 
  bool v16; 
  scr_string_t **v17; 
  const char *v18; 
  __int64 v19[2]; 
  char outErrorMessage[256]; 

  Entity = GetEntity(entref);
  if ( !Entity->client )
    Scr_ObjectError(COM_ERR_3269, scrContext, "not a player entity");
  v4 = GScr_GetEntity(0);
  if ( !v4->vehicle )
    Scr_ParamError(COM_ERR_3270, scrContext, 0, "not a vehicle entity");
  if ( (v4->flags.m_flags[0] & 0x80000) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 10326, ASSERT_TYPE_ASSERT, "(!vehicleEntity->flags.TestFlag( BgEntityFlagsCommon::MOVER_SLIDE ))", "%s\n\tVehicles cannot be script movers", "!vehicleEntity->flags.TestFlag( BgEntityFlagsCommon::MOVER_SLIDE )") )
    __debugbreak();
  client = Entity->client;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam <= 1 )
    *(float *)&Float = FLOAT_180_0;
  else
    Float = Scr_GetFloat(scrContext, 1u);
  v8 = I_fclamp(*(float *)&Float, 0.0, 180.0);
  client->link_viewClamp.min.goal.v[1] = COERCE_FLOAT(LODWORD(v8) ^ _xmm);
  if ( NumParam <= 2 )
    *(float *)&v9 = FLOAT_180_0;
  else
    v9 = Scr_GetFloat(scrContext, 2u);
  v10 = I_fclamp(*(float *)&v9, 0.0, 180.0);
  client->link_viewClamp.max.goal.v[1] = *(float *)&v10;
  if ( NumParam <= 3 )
    *(float *)&v11 = FLOAT_180_0;
  else
    v11 = Scr_GetFloat(scrContext, 3u);
  v12 = I_fclamp(*(float *)&v11, 0.0, 180.0);
  client->link_viewClamp.min.goal.v[0] = COERCE_FLOAT(LODWORD(v12) ^ _xmm);
  if ( NumParam <= 4 )
    *(float *)&v13 = FLOAT_180_0;
  else
    v13 = Scr_GetFloat(scrContext, 4u);
  v14 = I_fclamp(*(float *)&v13, 0.0, 180.0);
  client->link_viewClamp.max.goal.v[0] = *(float *)&v14;
  if ( NumParam <= 5 )
  {
    v15 = 0;
    v16 = 0;
  }
  else
  {
    v15 = 0;
    v16 = Scr_GetInt(scrContext, 5u) != 0;
  }
  client->link_useTagAnglesForViewAngles = v16;
  client->link_useBaseAnglesForViewClamp = 0;
  *(_WORD *)&client->link_rotationMovesEyePos = 1;
  client->linkAnglesFrac = 0.0;
  client->prevLinkAnglesSet = 0;
  client->ps.viewlocked_entNum = v4->s.number;
  client->ps.viewlocked = PLAYERVIEWLOCK_FULL;
  client->ps.linkFlags.m_flags[0] &= 0xFFFFFFFA;
  G_SnapToViewAngleClampGoal(&client->link_viewClamp);
  v19[0] = (__int64)&scr_const.tag_rider;
  v17 = (scr_string_t **)v19;
  v19[1] = (__int64)&scr_const.tag_driver;
  while ( !G_EntLinkTo(Entity, v4, **v17, 256, outErrorMessage) )
  {
    ++v15;
    ++v17;
    if ( v15 >= 2 )
      goto LABEL_28;
  }
  G_InitPlayerLinkAngles(Entity);
LABEL_28:
  if ( v15 == 2 )
  {
    v18 = j_va("failed to link player entity %i to vehicle entity %i: %s", (unsigned int)Entity->s.number, (unsigned int)v4->s.number, outErrorMessage);
    Scr_Error(COM_ERR_3271, scrContext, v18);
  }
}

/*
==============
GScr_StopRidingVehicle
==============
*/
void GScr_StopRidingVehicle(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gclient_s *client; 
  __int16 viewlocked_entNum; 
  GMovingPlatformClient *ClientFromGEntity; 
  int v7; 
  int v8; 

  Entity = GetEntity(entref);
  client = Entity->client;
  if ( !client )
  {
    Scr_ObjectError(COM_ERR_3272, scrContext, "not a player entity");
    client = Entity->client;
  }
  viewlocked_entNum = client->ps.viewlocked_entNum;
  if ( viewlocked_entNum == 2047 )
  {
    Scr_ObjectError(COM_ERR_3273, scrContext, "player not riding a vehicle");
    viewlocked_entNum = client->ps.viewlocked_entNum;
  }
  if ( (unsigned __int16)viewlocked_entNum >= 0x800u )
  {
    v8 = 2048;
    v7 = viewlocked_entNum;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 10401, ASSERT_TYPE_ASSERT, "(unsigned)( ps->viewlocked_entNum ) < (unsigned)( ( 2048 ) )", "ps->viewlocked_entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v7, v8) )
      __debugbreak();
  }
  if ( !g_entities[client->ps.viewlocked_entNum].vehicle )
    Scr_ObjectError(COM_ERR_3274, scrContext, "player not riding a vehicle");
  G_EntUnlink(Entity);
  ClientFromGEntity = GMovingPlatforms::GetClientFromGEntity(Entity);
  if ( ClientFromGEntity )
    GMovingPlatformClient::UpdatePlatformTrace(ClientFromGEntity, Entity, 1);
  else
    Scr_ObjectError(COM_ERR_3275, scrContext, "Cannot get moving platform data from player entity.");
  client->ps.viewlocked_entNum = 2047;
}

/*
==============
GScr_DisableMissileBoosting
==============
*/
void GScr_DisableMissileBoosting(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( Entity->s.eType == ET_MISSILE )
  {
    Entity->c.missile.flags &= ~0x200u;
  }
  else
  {
    Scr_Error(COM_ERR_3276, scrContext, "This should only be used with missiles");
    v4->c.missile.flags &= ~0x200u;
  }
}

/*
==============
GScr_EnableMissileBoosting
==============
*/
void GScr_EnableMissileBoosting(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( Entity->s.eType == ET_MISSILE )
  {
    Entity->c.missile.flags |= 0x200u;
  }
  else
  {
    Scr_Error(COM_ERR_3277, scrContext, "This should only be used with missiles");
    v4->c.missile.flags |= 0x200u;
  }
}

/*
==============
GScr_MainMP_LaunchGrenade
==============
*/
void GScr_MainMP_LaunchGrenade(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  unsigned __int16 weaponIdx; 
  double Float; 
  int time; 
  gentity_s *rethrowEnt; 
  gentity_s *v8; 
  scr_string_t grenade; 
  const gentity_s *v10; 
  __int64 hand; 
  bool outIsAlternate; 
  vec3_t dir; 
  vec3_t vectorValue; 
  Weapon outWeapon; 

  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 10492, ASSERT_TYPE_ASSERT, "(entity)", (const char *)&queryFormat, "entity") )
    __debugbreak();
  if ( Scr_GetNumParam(scrContext) < 3 || Scr_GetNumParam(scrContext) > 5 )
    Scr_Error(COM_ERR_3278, scrContext, "LaunchGrenade <grenade type> <origin> <velocity> [time to blow (seconds)] [rethrow grenade entity].\n");
  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  weaponIdx = outWeapon.weaponIdx;
  if ( !outWeapon.weaponIdx )
  {
    Scr_ParamError(COM_ERR_3279, scrContext, 0, "Specified grenade weapon is not valid");
    weaponIdx = outWeapon.weaponIdx;
  }
  if ( weaponIdx > bg_lastParsedWeaponIndex )
  {
    LODWORD(hand) = weaponIdx;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1203, ASSERT_TYPE_ASSERT, "( weaponIdx ) <= ( bg_lastParsedWeaponIndex )", "weaponIdx not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", hand, bg_lastParsedWeaponIndex) )
      __debugbreak();
  }
  if ( !bg_weaponDefs[weaponIdx] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1204, ASSERT_TYPE_ASSERT, "(bg_weaponDefs[weaponIdx])", (const char *)&queryFormat, "bg_weaponDefs[weaponIdx]") )
    __debugbreak();
  Scr_GetVector(scrContext, 1u, &vectorValue);
  Scr_GetVector(scrContext, 2u, &dir);
  if ( Scr_GetNumParam(scrContext) > 3 && Scr_GetType(scrContext, 3u) )
  {
    Float = Scr_GetFloat(scrContext, 3u);
    time = (int)(float)(*(float *)&Float * 1000.0);
  }
  else
  {
    time = BG_WeaponFuseTime(&outWeapon, 0);
  }
  rethrowEnt = NULL;
  if ( Scr_GetNumParam(scrContext) > 4 && Scr_GetType(scrContext, 4u) )
  {
    if ( Scr_GetType(scrContext, 4u) != VAR_ENTITY && Scr_GetType(scrContext, 4u) != VAR_POINTER )
      Scr_Error(COM_ERR_3280, scrContext, "LaunchGrenade(): provided rethrow entity is not an entity.");
    v8 = GScr_GetEntity(4u);
    rethrowEnt = v8;
    if ( v8 )
    {
      if ( v8->s.eType != ET_MISSILE )
        Scr_Error(COM_ERR_3281, scrContext, "LaunchGrenade(): provided rethrow entity type is not ET_MISSILE.");
      grenade = scr_const.grenade;
      if ( rethrowEnt->classname != scr_const.grenade )
      {
        Scr_Error(COM_ERR_3282, scrContext, "LaunchGrenade(): provided rethrow entity classname is not 'grenade'.");
        grenade = scr_const.grenade;
      }
      if ( rethrowEnt->script_classname != grenade )
        Scr_Error(COM_ERR_3283, scrContext, "LaunchGrenade(): provided rethrow entity script_classname is not 'grenade'.");
    }
  }
  v10 = G_Missile_FireGrenadeRethrow(Entity, &vectorValue, &dir, &outWeapon, 0, WEAPON_HAND_DEFAULT, 1, time, 0, level.time, rethrowEnt);
  if ( v10 )
    GScr_AddEntity(v10);
  else
    Scr_AddUndefined(scrContext);
}

/*
==============
ScrCmd_SetGrenadeThrowScale
==============
*/
void ScrCmd_SetGrenadeThrowScale(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  double Float; 
  float v7; 
  double v8; 
  float v9; 
  gagent_s *agent; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3678, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 10575, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client && !v4->agent )
    {
      v5 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3677, scrContext, v5);
    }
  }
  Float = Scr_GetFloat(scrContext, 0);
  v7 = *(float *)&Float;
  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    v8 = Scr_GetFloat(scrContext, 1u);
    v9 = *(float *)&v8;
  }
  else
  {
    v9 = FLOAT_1_0;
  }
  agent = v4->agent;
  if ( agent )
  {
    agent->grenadeThrowSpeedScale = v7;
    v4->agent->grenadeThrowSpeedUpScale = v9;
  }
  else
  {
    if ( !v4->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 10587, ASSERT_TYPE_ASSERT, "( pSelf->client )", (const char *)&queryFormat, "pSelf->client") )
      __debugbreak();
    v4->client->grenadeThrowSpeedScale = v7;
    v4->client->grenadeThrowSpeedUpScale = v9;
  }
}

/*
==============
ScrCmd_SetGrenadeCookScale
==============
*/
void ScrCmd_SetGrenadeCookScale(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  _DWORD *p_commandTime; 
  double Float; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3678, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 10607, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client && !v4->agent )
    {
      v5 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3677, scrContext, v5);
    }
  }
  p_commandTime = &v4->agent->playerState.commandTime;
  if ( !p_commandTime )
    p_commandTime = &v4->client->ps.commandTime;
  Float = Scr_GetFloat(scrContext, 0);
  if ( !p_commandTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_playerstate.h", 1159, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  p_commandTime[220] = MSG_PackSignedFloat(*(float *)&Float, 5.0, 0xCu);
}

/*
==============
Scr_GetNearNodeListForSpawnCheck
==============
*/
void Scr_GetNearNodeListForSpawnCheck(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  Scr_GetNearNodeListForSightToPathNodeCheck(scrContext, Entity);
}

/*
==============
GScr_MainMP_SpawnFX
==============
*/
void GScr_MainMP_SpawnFX(scrContext_t *scrContext)
{
  int v2; 
  int fxId; 
  unsigned int v4; 
  __int128 v5; 
  __int128 v9; 
  const gentity_s *v13; 
  tmat33_t<vec3_t> v14; 
  vec3_t pos; 

  if ( Scr_GetNumParam(scrContext) < 2 || Scr_GetNumParam(scrContext) > 4 )
    Scr_Error(COM_ERR_3284, scrContext, "Incorrect number of parameters");
  v2 = 0;
  fxId = Scr_GetInt(scrContext, 0);
  if ( !FX_IsValidFxId(fxId) )
    Scr_FxParamError(COM_ERR_5308, scrContext, 0, "spawnFx called with invalid effect id", fxId);
  v4 = Scr_GetNumParam(scrContext) - 3;
  if ( v4 )
  {
    if ( v4 != 1 )
      goto LABEL_14;
    Scr_GetVector(scrContext, 3u, &v14.m[2]);
    v5 = LODWORD(v14.m[2].v[0]);
    *(float *)&v5 = fsqrt((float)((float)(*(float *)&v5 * *(float *)&v5) + (float)(v14.m[2].v[1] * v14.m[2].v[1])) + (float)(v14.m[2].v[2] * v14.m[2].v[2]));
    _XMM4 = v5;
    __asm
    {
      vcmpless xmm0, xmm4, cs:__real@80000000
      vblendvps xmm0, xmm4, xmm7, xmm0
    }
    v14.m[2].v[0] = v14.m[2].v[0] * (float)(1.0 / *(float *)&_XMM0);
    v14.m[2].v[2] = v14.m[2].v[2] * (float)(1.0 / *(float *)&_XMM0);
    v14.m[2].v[1] = v14.m[2].v[1] * (float)(1.0 / *(float *)&_XMM0);
    if ( *(float *)&v5 == 0.0 )
      Scr_FxParamError(COM_ERR_5309, scrContext, 3, "spawnFx called with (0 0 0) up direction", fxId);
    v2 = 1;
  }
  Scr_GetVector(scrContext, 2u, v14.m);
  v9 = LODWORD(v14.m[0].v[0]);
  *(float *)&v9 = fsqrt((float)((float)(*(float *)&v9 * *(float *)&v9) + (float)(v14.m[0].v[1] * v14.m[0].v[1])) + (float)(v14.m[0].v[2] * v14.m[0].v[2]));
  _XMM4 = v9;
  __asm
  {
    vcmpless xmm0, xmm4, cs:__real@80000000
    vblendvps xmm0, xmm4, xmm7, xmm0
  }
  v14.m[0].v[0] = v14.m[0].v[0] * (float)(1.0 / *(float *)&_XMM0);
  v14.m[0].v[2] = v14.m[0].v[2] * (float)(1.0 / *(float *)&_XMM0);
  v14.m[0].v[1] = v14.m[0].v[1] * (float)(1.0 / *(float *)&_XMM0);
  if ( *(float *)&v9 == 0.0 )
    Scr_FxParamError(COM_ERR_5310, scrContext, 2, "spawnFx called with (0 0 0) forward direction", fxId);
  ++v2;
LABEL_14:
  Scr_GetVector(scrContext, 1u, &pos);
  v13 = Scr_SpawnFXInternal(scrContext, fxId, &pos, v2, &v14);
  GScr_AddEntity(v13);
}

/*
==============
GScr_MainMP_SpawnFXForClient
==============
*/
void GScr_MainMP_SpawnFXForClient(scrContext_t *scrContext)
{
  __int128 v1; 
  __int128 v2; 
  __int128 v3; 
  unsigned int NumParam; 
  int v6; 
  int fxId; 
  gentity_s *Entity; 
  unsigned int v9; 
  __int128 v10; 
  __int128 v14; 
  gentity_s *v18; 
  unsigned int number; 
  tmat33_t<vec3_t> v20; 
  vec3_t pos; 
  __int128 v22; 
  __int128 v23; 
  __int128 v24; 

  v23 = v2;
  v22 = v3;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam - 3 > 2 )
    Scr_Error(COM_ERR_3285, scrContext, "Incorrect number of parameters");
  v6 = 0;
  fxId = Scr_GetInt(scrContext, 0);
  if ( !FX_IsValidFxId(fxId) )
    Scr_FxParamError(COM_ERR_5311, scrContext, 0, "spawnFxForClient called with invalid effect id", fxId);
  Entity = GScr_GetEntity(2u);
  if ( Entity->s.number >= level.maxclients )
    Scr_FxParamError(COM_ERR_5312, scrContext, 2, "spawnFx called with invalid client entity", fxId);
  v24 = v1;
  v9 = NumParam - 4;
  if ( v9 )
  {
    if ( v9 != 1 )
      goto LABEL_15;
    Scr_GetVector(scrContext, 4u, &v20.m[2]);
    v10 = LODWORD(v20.m[2].v[0]);
    *(float *)&v10 = fsqrt((float)((float)(*(float *)&v10 * *(float *)&v10) + (float)(v20.m[2].v[1] * v20.m[2].v[1])) + (float)(v20.m[2].v[2] * v20.m[2].v[2]));
    _XMM4 = v10;
    __asm
    {
      vcmpless xmm0, xmm4, cs:__real@80000000
      vblendvps xmm0, xmm4, xmm7, xmm0
    }
    v20.m[2].v[0] = v20.m[2].v[0] * (float)(1.0 / *(float *)&_XMM0);
    v20.m[2].v[2] = v20.m[2].v[2] * (float)(1.0 / *(float *)&_XMM0);
    v20.m[2].v[1] = v20.m[2].v[1] * (float)(1.0 / *(float *)&_XMM0);
    if ( *(float *)&v10 == 0.0 )
      Scr_FxParamError(COM_ERR_5313, scrContext, 4, "spawnFx called with (0 0 0) up direction", fxId);
    v6 = 1;
  }
  Scr_GetVector(scrContext, 3u, v20.m);
  v14 = LODWORD(v20.m[0].v[0]);
  *(float *)&v14 = fsqrt((float)((float)(*(float *)&v14 * *(float *)&v14) + (float)(v20.m[0].v[1] * v20.m[0].v[1])) + (float)(v20.m[0].v[2] * v20.m[0].v[2]));
  _XMM4 = v14;
  __asm
  {
    vcmpless xmm0, xmm4, cs:__real@80000000
    vblendvps xmm0, xmm4, xmm7, xmm0
  }
  v20.m[0].v[0] = v20.m[0].v[0] * (float)(1.0 / *(float *)&_XMM0);
  v20.m[0].v[2] = v20.m[0].v[2] * (float)(1.0 / *(float *)&_XMM0);
  v20.m[0].v[1] = v20.m[0].v[1] * (float)(1.0 / *(float *)&_XMM0);
  if ( *(float *)&v14 == 0.0 )
    Scr_FxParamError(COM_ERR_5314, scrContext, 3, "spawnFx called with (0 0 0) forward direction", fxId);
  ++v6;
LABEL_15:
  Scr_GetVector(scrContext, 1u, &pos);
  v18 = Scr_SpawnFXInternal(scrContext, fxId, &pos, v6, &v20);
  if ( (unsigned int)Entity->s.number >= level.maxclients && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 10768, ASSERT_TYPE_ASSERT, "(unsigned)( clientEnt->s.number ) < (unsigned)( level.maxclients )", "clientEnt->s.number doesn't index level.maxclients\n\t%i not in [0, %i)", Entity->s.number, level.maxclients) )
    __debugbreak();
  *(_QWORD *)v18->clientMask.array = -1i64;
  *(_QWORD *)&v18->clientMask.array[2] = -1i64;
  *(_QWORD *)&v18->clientMask.array[4] = -1i64;
  v18->clientMask.array[6] = -1;
  number = Entity->s.number;
  if ( number >= 0xE0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 290, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", Entity->s.number, 224) )
    __debugbreak();
  v18->clientMask.array[(unsigned __int64)number >> 5] &= ~(0x80000000 >> (number & 0x1F));
  GScr_AddEntity(v18);
}

/*
==============
Scr_PlayFXOnTagForTeam
==============
*/
void Scr_PlayFXOnTagForTeam(scrContext_t *scrContext)
{
  unsigned int Int; 
  gentity_s *Entity; 
  scr_string_t ConstLowercaseString; 
  scr_string_t v5; 
  team_t v6; 
  const char *v7; 
  const char *v8; 
  const char *v9; 
  const char *v10; 
  int BoneIndex; 
  unsigned int model; 
  const char *v13; 
  const char *v14; 
  const char *v15; 
  unsigned int FxEventParam_0; 

  if ( Scr_GetNumParam(scrContext) < 4 )
    Scr_Error(COM_ERR_3286, scrContext, "Incorrect number of parameters");
  Int = Scr_GetInt(scrContext, 0);
  Entity = GScr_GetEntity(1u);
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 2u);
  v5 = Scr_GetConstLowercaseString(scrContext, 3u);
  v6 = TEAM_ZERO;
  if ( v5 == scr_const.allies )
  {
    v6 = TEAM_TWO;
  }
  else if ( v5 == scr_const.axis )
  {
    v6 = TEAM_ONE;
  }
  else
  {
    v7 = SL_ConvertToString(v5);
    v8 = j_va("effect team %s is invalid\n", v7);
    Scr_ParamError(COM_ERR_3287, scrContext, 0, v8);
  }
  if ( !FX_IsValidFxId(Int) )
  {
    v9 = j_va("effect id %i is invalid\n", Int);
    Scr_ParamError(COM_ERR_3288, scrContext, 0, v9);
  }
  v10 = SL_ConvertToString(ConstLowercaseString);
  if ( strchr_0(v10, 34) )
    Scr_ParamError(COM_ERR_3289, scrContext, 2u, "cannot use \" characters in tag names\n");
  BoneIndex = SV_Game_DObjGetBoneIndex(Entity, ConstLowercaseString);
  if ( BoneIndex < 0 )
  {
    SV_Game_DObjDumpInfo(Entity);
    model = Entity->model;
    if ( !GConfigStrings::ms_gConfigStrings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_configstrings.h", 71, ASSERT_TYPE_ASSERT, "( ms_gConfigStrings )", (const char *)&queryFormat, "ms_gConfigStrings") )
      __debugbreak();
    v13 = GConfigStrings::ms_gConfigStrings->GetModelNameString(GConfigStrings::ms_gConfigStrings, model);
    v14 = SL_ConvertToString(ConstLowercaseString);
    v15 = j_va("tag '%s' does not exist on entity with model '%s'", v14, v13);
    Scr_ParamError(COM_ERR_3290, scrContext, 2u, v15);
  }
  FxEventParam_0 = Scr_GetFxEventParam_0(Int, BoneIndex, -1, v6);
  G_Utils_AddEvent(Entity, 0x81u, FxEventParam_0);
}

/*
==============
GScr_MainMP_TriggerFX
==============
*/
void GScr_MainMP_TriggerFX(scrContext_t *scrContext)
{
  gentity_s *Entity; 

  if ( !Scr_GetNumParam(scrContext) || Scr_GetNumParam(scrContext) > 2 )
    Scr_Error(COM_ERR_3291, scrContext, "Incorrect number of parameters");
  Entity = GScr_GetEntity(0);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 10885, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( Entity->s.eType != ET_FX )
    Scr_ParamError(COM_ERR_3292, scrContext, 0, "entity wasn't created with 'newFx'");
  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    Scr_GetFloat(scrContext, 1u);
    _XMM0 = 0i64;
    __asm { vroundss xmm1, xmm0, xmm4, 1 }
    Entity->s.time2 = (int)*(float *)&_XMM1;
  }
  else
  {
    Entity->s.time2 = level.time;
  }
}

/*
==============
GScr_MainMP_PlayLoopedFX
==============
*/
void GScr_MainMP_PlayLoopedFX(scrContext_t *scrContext)
{
  int v2; 
  float v3; 
  int fxId; 
  unsigned int v5; 
  unsigned int v6; 
  __int128 v7; 
  __int128 v11; 
  double Float; 
  gentity_s *v18; 
  tmat33_t<vec3_t> v19; 
  vec3_t origin; 

  Sys_ProfBeginNamedEvent(0xFFFF0000, "GScr_MainMP_PlayLoopedFX");
  if ( Scr_GetNumParam(scrContext) < 3 || Scr_GetNumParam(scrContext) > 6 )
    Scr_Error(COM_ERR_3293, scrContext, "Incorrect number of parameters");
  v2 = 0;
  v3 = 0.0;
  fxId = Scr_GetInt(scrContext, 0);
  if ( !FX_IsValidFxId(fxId) )
    Scr_FxParamError(COM_ERR_5315, scrContext, 0, "playLoopedFx called with invalid effect id", fxId);
  v5 = Scr_GetNumParam(scrContext) - 4;
  if ( v5 )
  {
    v6 = v5 - 1;
    if ( v6 )
    {
      if ( v6 != 1 )
        goto LABEL_15;
      v2 = 1;
      Scr_GetVector(scrContext, 5u, &v19.m[2]);
      v7 = LODWORD(v19.m[2].v[0]);
      *(float *)&v7 = fsqrt((float)((float)(*(float *)&v7 * *(float *)&v7) + (float)(v19.m[2].v[1] * v19.m[2].v[1])) + (float)(v19.m[2].v[2] * v19.m[2].v[2]));
      _XMM4 = v7;
      __asm
      {
        vcmpless xmm0, xmm4, cs:__real@80000000
        vblendvps xmm0, xmm4, xmm8, xmm0
      }
      v19.m[2].v[0] = v19.m[2].v[0] * (float)(1.0 / *(float *)&_XMM0);
      v19.m[2].v[2] = v19.m[2].v[2] * (float)(1.0 / *(float *)&_XMM0);
      v19.m[2].v[1] = v19.m[2].v[1] * (float)(1.0 / *(float *)&_XMM0);
      if ( *(float *)&v7 == 0.0 )
        Scr_FxParamError(COM_ERR_5316, scrContext, 5, "playLoopedFx called with (0 0 0) up direction", fxId);
    }
    Scr_GetVector(scrContext, 4u, v19.m);
    v11 = LODWORD(v19.m[0].v[0]);
    *(float *)&v11 = fsqrt((float)((float)(*(float *)&v11 * *(float *)&v11) + (float)(v19.m[0].v[1] * v19.m[0].v[1])) + (float)(v19.m[0].v[2] * v19.m[0].v[2]));
    _XMM4 = v11;
    __asm
    {
      vcmpless xmm0, xmm4, cs:__real@80000000
      vblendvps xmm0, xmm4, xmm8, xmm0
    }
    v19.m[0].v[0] = v19.m[0].v[0] * (float)(1.0 / *(float *)&_XMM0);
    v19.m[0].v[2] = v19.m[0].v[2] * (float)(1.0 / *(float *)&_XMM0);
    v19.m[0].v[1] = v19.m[0].v[1] * (float)(1.0 / *(float *)&_XMM0);
    if ( *(float *)&v11 == 0.0 )
      Scr_FxParamError(COM_ERR_5317, scrContext, 4, "playLoopedFx called with (0 0 0) forward direction", fxId);
    ++v2;
  }
  Float = Scr_GetFloat(scrContext, 3u);
  v3 = *(float *)&Float;
LABEL_15:
  Scr_GetVector(scrContext, 2u, &origin);
  Scr_GetFloat(scrContext, 1u);
  _XMM0 = 0i64;
  __asm { vroundss xmm1, xmm0, xmm4, 1 }
  if ( (int)*(float *)&_XMM1 <= 0 )
    Scr_FxParamError(COM_ERR_5318, scrContext, 1, "playLoopedFx called with repeat < 0.001 seconds", fxId);
  v18 = G_Utils_SpawnEntity();
  v18->s.eType = ET_LOOP_FX;
  v18->s.staticState.general.xmodel = fxId;
  G_SetOrigin(v18, &origin, 1, 1);
  Scr_SetFxAngles(scrContext, v2, &v19, &v18->s.lerp.apos.trBase, fxId);
  v18->s.lerp.u.anonymous.data[1] = (int)*(float *)&_XMM1;
  v18->s.lerp.u.turret.gunAngles.v[0] = v3;
  SV_LinkEntity(v18);
  GScr_AddEntity(v18);
  Sys_ProfEndNamedEvent();
}

/*
==============
GScr_MainMP_SetNoJIPScore
==============
*/
void GScr_MainMP_SetNoJIPScore(scrContext_t *scrContext)
{
  unsigned int v2; 
  int Int; 
  BOOL v4; 
  int v5; 
  const char *v6; 

  if ( !Scr_GetNumParam(scrContext) || Scr_GetNumParam(scrContext) > 2 )
    Scr_Error(COM_ERR_3294, scrContext, "USAGE: SetNoJIPScore( no_jip )\n");
  v2 = 0;
  Int = Scr_GetInt(scrContext, 0);
  v4 = Int != 0;
  Com_Printf(24, "SetNoJIPScore() Called from script with value(%i)\n", Int != 0);
  if ( Int )
  {
    QosPayload::DisableJoinInProgressForScore(&QosPayload::ms_qosPayload);
    OnlineMatchmakerOmniscient::TurnOffBackfill_JIP(&OnlineMatchmakerOmniscient::ms_instance);
  }
  else
  {
    QosPayload::EnableJoinInProgressForScore(&QosPayload::ms_qosPayload);
    OnlineMatchmakerOmniscient::TurnOnBackfill_JIP(&OnlineMatchmakerOmniscient::ms_instance);
  }
  if ( Scr_GetNumParam(scrContext) > 1 )
  {
    v5 = Scr_GetInt(scrContext, 1u);
    LOBYTE(v2) = v5 != 0;
    Com_Printf(24, "SetNoJIPScore() invite join disabled value (%i)\n", v2);
    if ( v5 )
    {
      v6 = j_va("%c %d", 35i64, v4);
      SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v6);
    }
  }
}

/*
==============
GScr_MainMP_SetNoJIPTime
==============
*/
void GScr_MainMP_SetNoJIPTime(scrContext_t *scrContext)
{
  unsigned int v2; 
  int Int; 
  BOOL v4; 
  int v5; 
  const char *v6; 

  if ( !Scr_GetNumParam(scrContext) || Scr_GetNumParam(scrContext) > 2 )
    Scr_Error(COM_ERR_3295, scrContext, "USAGE: SetNoJIPTime( no_jip )\n");
  v2 = 0;
  Int = Scr_GetInt(scrContext, 0);
  v4 = Int != 0;
  Com_Printf(24, "SetNoJIPTime() Called from script with value(%i)\n", Int != 0);
  if ( Int )
  {
    QosPayload::DisableJoinInProgressForTime(&QosPayload::ms_qosPayload);
    OnlineMatchmakerOmniscient::TurnOffBackfill_JIP(&OnlineMatchmakerOmniscient::ms_instance);
  }
  else
  {
    QosPayload::EnableJoinInProgressForTime(&QosPayload::ms_qosPayload);
    OnlineMatchmakerOmniscient::TurnOnBackfill_JIP(&OnlineMatchmakerOmniscient::ms_instance);
  }
  if ( Scr_GetNumParam(scrContext) > 1 )
  {
    v5 = Scr_GetInt(scrContext, 1u);
    LOBYTE(v2) = v5 != 0;
    Com_Printf(24, "SetNoJIPTime() invite join disabled value (%i)\n", v2);
    if ( v5 )
    {
      v6 = j_va("%c %d", 35i64, v4);
      SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v6);
    }
  }
}

/*
==============
GScr_MainMP_CancelJoins
==============
*/
void GScr_MainMP_CancelJoins(scrContext_t *scrContext)
{
  PartyData *GameParty; 

  if ( Lobby_IsInLobby() || Live_IsInSystemlinkLobby() )
  {
    GameParty = Live_GetGameParty();
    PartyHost_ClearGoAsync(GameParty);
  }
}

/*
==============
GScr_AreWorldWeaponsLoaded
==============
*/
void GScr_AreWorldWeaponsLoaded(scrContext_t *scrContext)
{
  unsigned int v2; 
  int HasWorldWeaponsLoaded; 
  Weapon outWeapons; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_3296, scrContext, "LoadWeaponsForPlayer requires an array of weapon names.");
  v2 = GScr_Main_FillWeaponArray(scrContext, &outWeapons, 0x40u);
  HasWorldWeaponsLoaded = SV_StreamSync_HasWorldWeaponsLoaded(&outWeapons, v2);
  Scr_AddBool(scrContext, HasWorldWeaponsLoaded);
}

/*
==============
GScr_LoadWorldWeapons
==============
*/
void GScr_LoadWorldWeapons(scrContext_t *scrContext)
{
  unsigned int v2; 
  Weapon outWeapons; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_3297, scrContext, "LoadWorldWeapons requires an array of weapon names.");
  v2 = GScr_Main_FillWeaponArray(scrContext, &outWeapons, 0x20u);
  G_WeaponStreaming_SetGameWorldWeapons(&outWeapons, v2);
}

/*
==============
GScr_ClearWorldWeapons
==============
*/
void GScr_ClearWorldWeapons(scrContext_t *scrContext)
{
  if ( Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_3298, scrContext, "ClearWorldWeapons does not accept arguments.");
  G_WeaponStreaming_ClearGameRequests();
}

/*
==============
GScr_MainMp_ComputeWeaponClientLoadout
==============
*/
void GScr_MainMp_ComputeWeaponClientLoadout(scrContext_t *scrContext)
{
  unsigned int Int; 
  unsigned int v3; 
  unsigned int v4; 
  unsigned __int16 v5; 

  Int = Scr_GetInt(scrContext, 0);
  v3 = Scr_GetInt(scrContext, 1u);
  v4 = Scr_GetInt(scrContext, 2u);
  v5 = BG_WarPaint_EncodeClientLoadout(Int, v3, v4);
  Scr_AddInt(scrContext, v5);
}

/*
==============
Scr_IsGameBattleMatch
==============
*/
void Scr_IsGameBattleMatch(scrContext_t *scrContext)
{
  bool IsGameBattleActive; 

  IsGameBattleActive = GameBattles_IsGameBattleActive();
  Scr_AddInt(scrContext, IsGameBattleActive);
}

/*
==============
GScr_SetUAVJammed
==============
*/
void GScr_SetUAVJammed(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *p_otherFlags; 

  Entity = GetEntity(entref);
  if ( !Entity->client )
    Scr_Error(COM_ERR_3299, scrContext, "SetUAVJammed: Entity must be a player entity");
  if ( !Com_GameMode_SupportsFeature(WEAPON_MANTLE_OVER_WEAPON_DOWN|0x80) )
    Scr_Error(COM_ERR_3300, scrContext, "SetUAVJammed: Feature not supported by the current game mode");
  Int = Scr_GetInt(scrContext, 0);
  p_otherFlags = &Entity->client->ps.otherFlags;
  if ( Int )
    GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal(p_otherFlags, GameModeFlagValues::ms_mpValue, 0x37u);
  else
    GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal(p_otherFlags, GameModeFlagValues::ms_mpValue, 0x37u);
}

/*
==============
ScrCmd_StopSpectatePlayer
==============
*/
void ScrCmd_StopSpectatePlayer(scrContext_t *scrContext)
{
  unsigned int Int; 
  gentity_s *GEntity; 
  const char *v4; 

  Int = Scr_GetInt(scrContext, 0);
  if ( Scr_GetNumParam(scrContext) > 1 && Scr_GetInt(scrContext, 1u) )
  {
    GEntity = G_GetGEntity(Int);
    G_CmdsMP_StopSpectating(GEntity, 1, 0);
    G_CmdsMP_StopSpectateClientnum_ReplicateFollow_f(GEntity, Int, 1, 0);
  }
  else
  {
    v4 = j_va("stopspectate %i\n", Int);
    Cbuf_AddText(LOCAL_CLIENT_0, v4);
  }
}

/*
==============
ScrCmd_SpectateClientNum
==============
*/
void ScrCmd_SpectateClientNum(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int number; 
  unsigned int Int; 
  gentity_s *GEntity; 
  const char *v6; 

  number = GetEntity(entref)->s.number;
  Int = Scr_GetInt(scrContext, 0);
  if ( Scr_GetNumParam(scrContext) > 1 && Scr_GetInt(scrContext, 1u) )
  {
    GEntity = G_GetGEntity(number);
    G_CmdsMP_SpectateClientnum_f(GEntity, Int);
    G_CmdsMP_SpectateClientnum_ReplicateFollow_f(GEntity, number, Int);
  }
  else
  {
    v6 = j_va("svrspectateclientnum %i %i\n", number, Int);
    Cbuf_AddText(LOCAL_CLIENT_0, v6);
  }
}

/*
==============
ScrCmd_IsSpectatingPlayer
==============
*/
void ScrCmd_IsSpectatingPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gclient_s *client; 
  bool v5; 

  Entity = GetEntity(entref);
  client = Entity->client;
  if ( !client )
  {
    Scr_Error(COM_ERR_3301, scrContext, "IsSpectatingPlayer must be called on a player.");
    client = Entity->client;
    if ( !client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2275, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
  }
  v5 = GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&client->ps.otherFlags, GameModeFlagValues::ms_mpValue, 0x21u);
  Scr_AddInt(scrContext, v5);
}

/*
==============
ScrCmd_GetFollowedPlayer
==============
*/
void ScrCmd_GetFollowedPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gclient_s *client; 

  Entity = GetEntity(entref);
  client = Entity->client;
  if ( !client )
  {
    Scr_Error(COM_ERR_6383, scrContext, "GetFollowedPlayer must be called on a player.");
    client = Entity->client;
  }
  if ( client->sess.cs.team != TEAM_FOLLOWER )
  {
    Scr_Error(COM_ERR_6384, scrContext, "GetFollowedPlayer must be called on a follower.");
    client = Entity->client;
  }
  Scr_AddInt(scrContext, client->sess.cs.indexMLGFollower);
}

/*
==============
Scr_LoadInfilTransient
==============
*/
void Scr_LoadInfilTransient(scrContext_t *scrContext)
{
  unsigned int NumParam; 
  const char *v3; 
  const char *String; 
  const char *v5; 
  const char *v6; 
  const char *v7; 
  const OmnvarDef *Def; 
  OmnvarData *Data; 
  InfilTransientType outType; 
  unsigned int outIndex; 

  if ( !BG_TransientsInfilMP_IsOmnvarsInited() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 11609, ASSERT_TYPE_ASSERT, "(BG_TransientsInfilMP_IsOmnvarsInited())", (const char *)&queryFormat, "BG_TransientsInfilMP_IsOmnvarsInited()") )
    __debugbreak();
  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    String = Scr_GetString(scrContext, 0);
    v5 = String;
    if ( String )
    {
      if ( BG_TransientsInfilMP_GetInfilOmnvarIndexByName(String, &outType, &outIndex) )
      {
        if ( outType )
        {
          Def = BG_Omnvar_GetDef(outIndex);
          Data = G_Omnvar_GetData(outIndex, -1, NULL);
          G_Omnvar_SetBool(Def, Data, 1);
          G_Omnvar_MarkChanged(Data);
        }
        else
        {
          v7 = j_va("LoadInfilTransient cannot load intro infil '%s' during gameplay.", v5);
          Scr_Error(COM_ERR_6061, scrContext, v7);
        }
      }
      else
      {
        v6 = j_va("LoadInfilTransient couldn't find transient '%s' listed in the infil csv files for this map", v5);
        Scr_Error(COM_ERR_6060, scrContext, v6);
      }
    }
    else
    {
      Scr_Error(COM_ERR_3305, scrContext, "LoadInfilTransient takes a string parameter");
    }
  }
  else
  {
    NumParam = Scr_GetNumParam(scrContext);
    v3 = j_va("LoadInfilTransient has %d parameters.  There should be exactly one.", NumParam);
    Scr_Error(COM_ERR_3304, scrContext, v3);
  }
}

/*
==============
Scr_UnloadInfilTransient
==============
*/
void Scr_UnloadInfilTransient(scrContext_t *scrContext)
{
  unsigned int NumParam; 
  const char *v3; 
  const char *String; 
  const char *v5; 
  const char *v6; 
  const OmnvarDef *Def; 
  OmnvarData *Data; 
  InfilTransientType outType; 
  unsigned int outIndex; 

  if ( !BG_TransientsInfilMP_IsOmnvarsInited() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 11657, ASSERT_TYPE_ASSERT, "(BG_TransientsInfilMP_IsOmnvarsInited())", (const char *)&queryFormat, "BG_TransientsInfilMP_IsOmnvarsInited()") )
    __debugbreak();
  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    String = Scr_GetString(scrContext, 0);
    v5 = String;
    if ( String )
    {
      if ( BG_TransientsInfilMP_GetInfilOmnvarIndexByName(String, &outType, &outIndex) )
      {
        Def = BG_Omnvar_GetDef(outIndex);
        Data = G_Omnvar_GetData(outIndex, -1, NULL);
        G_Omnvar_SetBool(Def, Data, 0);
        G_Omnvar_MarkChanged(Data);
      }
      else
      {
        v6 = j_va("UnloadInfilTransient couldn't find transient '%s' listed in the infil csv files for this map", v5);
        Scr_Error(COM_ERR_6062, scrContext, v6);
      }
    }
    else
    {
      Scr_Error(COM_ERR_3307, scrContext, "UnloadInfilTransient takes a string parameter");
    }
  }
  else
  {
    NumParam = Scr_GetNumParam(scrContext);
    v3 = j_va("UnloadInfilTransient has %d parameters.  There should be exactly one.", NumParam);
    Scr_Error(COM_ERR_3306, scrContext, v3);
  }
}

/*
==============
Scr_UnloadAllInfilIntroTransients
==============
*/
void Scr_UnloadAllInfilIntroTransients(scrContext_t *scrContext)
{
  unsigned int NumParam; 
  const char *v3; 
  unsigned int i; 
  unsigned int InfilOmnvarIndexByIndex; 
  const OmnvarDef *Def; 
  OmnvarData *Data; 

  if ( !BG_TransientsInfilMP_IsOmnvarsInited() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 11698, ASSERT_TYPE_ASSERT, "(BG_TransientsInfilMP_IsOmnvarsInited())", (const char *)&queryFormat, "BG_TransientsInfilMP_IsOmnvarsInited()") )
    __debugbreak();
  if ( Scr_GetNumParam(scrContext) )
  {
    NumParam = Scr_GetNumParam(scrContext);
    v3 = j_va("unloadallinfilintrotransients has %d parameters.  There should be exactly zero.", NumParam);
    Scr_Error(COM_ERR_6058, scrContext, v3);
  }
  else
  {
    for ( i = 0; i < BG_TransientsInfilMP_GetInfilCount(); ++i )
    {
      if ( BG_TransientsInfilMP_GetInfilType(i) == INFIL_TRTYPE_INTRO )
      {
        InfilOmnvarIndexByIndex = BG_TransientsInfilMP_GetInfilOmnvarIndexByIndex(i);
        if ( InfilOmnvarIndexByIndex == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 11712, ASSERT_TYPE_ASSERT, "(omnvarIndex != ((uint)-1))", (const char *)&queryFormat, "omnvarIndex != OMNVAR_NONE") )
          __debugbreak();
        Def = BG_Omnvar_GetDef(InfilOmnvarIndexByIndex);
        Data = G_Omnvar_GetData(InfilOmnvarIndexByIndex, -1, NULL);
        if ( !Def && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_omnvar.h", 47, ASSERT_TYPE_ASSERT, "(def)", (const char *)&queryFormat, "def") )
          __debugbreak();
        if ( !Data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_omnvar.h", 48, ASSERT_TYPE_ASSERT, "(data)", (const char *)&queryFormat, "data") )
          __debugbreak();
        if ( Def->type )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_omnvar.h", 49, ASSERT_TYPE_ASSERT, "(def->type == OMNVAR_TYPE_BOOL)", (const char *)&queryFormat, "def->type == OMNVAR_TYPE_BOOL") )
            __debugbreak();
        }
        Data->current.enabled = 0;
        G_Omnvar_MarkChanged(Data);
      }
    }
  }
}

/*
==============
GScr_GetAIArray
==============
*/
void GScr_GetAIArray(scrContext_t *scrContext)
{
  bitarray<224> *TeamFlags; 
  unsigned int v3; 
  __int128 v4; 
  double v5; 
  __int128 *v6; 
  const bitarray<224> *AllTeamFlags; 
  __int128 v8; 
  double v9; 
  int v10; 
  AIIterator *AIAgentIterator; 
  const gentity_s *i; 
  unsigned __int64 eTeam; 
  ai_agent_t *ScriptedAgentInfo; 
  __int64 v15; 
  __int64 v16; 
  __int64 v17; 
  __int128 v18; 
  double v19; 
  int v20; 
  AIAgentInterface result; 
  AIAgentInterface *p_result; 

  TeamFlags = Scr_GetTeamFlags((bitarray<224> *)&result, scrContext, 0);
  v3 = 0;
  v4 = *(_OWORD *)TeamFlags->array;
  v5 = *(double *)&TeamFlags->array[4];
  v20 = TeamFlags->array[6];
  v6 = &v18;
  v18 = v4;
  v19 = v5;
  while ( !*(_DWORD *)v6 )
  {
    ++v3;
    v6 = (__int128 *)((char *)v6 + 4);
    if ( v3 >= 7 )
    {
      if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_WEAPON_DROP|0x80) )
        AllTeamFlags = Com_TeamsSP_GetAllTeamFlags();
      else
        AllTeamFlags = Com_TeamsMP_GetAllTeamFlags();
      v8 = *(_OWORD *)AllTeamFlags->array;
      v9 = *(double *)&AllTeamFlags->array[4];
      v10 = AllTeamFlags->array[6];
      v18 = v8;
      v19 = v9;
      v20 = v10;
      break;
    }
  }
  Scr_MakeArray(scrContext);
  AIAgentIterator = AIAgentInterface::GetAIAgentIterator();
  for ( i = (const gentity_s *)AIAgentIterator->GetFirst(AIAgentIterator); i; i = AIAgentIterator->GetNext(AIAgentIterator) )
  {
    eTeam = (unsigned int)i->sentient->eTeam;
    if ( (unsigned int)eTeam >= 0xE0 )
    {
      LODWORD(v17) = 224;
      LODWORD(v16) = i->sentient->eTeam;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v16, v17) )
        __debugbreak();
    }
    if ( ((0x80000000 >> (eTeam & 0x1F)) & *((_DWORD *)&v18 + (eTeam >> 5))) != 0 )
    {
      AIAgentInterface::AIAgentInterface(&result);
      result.__vftable = (AIAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
      p_result = NULL;
      if ( SV_IsAgentScripted(i) )
      {
        ScriptedAgentInfo = AIAgentInterface::GetScriptedAgentInfo(i);
        if ( ScriptedAgentInfo )
        {
          p_result = &result;
          AINewAgentInterface::SetAgent((AINewAgentInterface *)&result, ScriptedAgentInfo);
        }
      }
      v15 = (__int64)p_result;
      if ( !p_result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 11757, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
        __debugbreak();
      if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v15 + 128i64))(v15) )
      {
        if ( !*(_BYTE *)((**(__int64 (__fastcall ***)(__int64))v15)(v15) + 1851) )
        {
          GScr_AddEntity(i);
          Scr_AddArray(scrContext);
        }
      }
    }
  }
}

/*
==============
GScr_GetAIArrayInRadius
==============
*/
void GScr_GetAIArrayInRadius(scrContext_t *scrContext)
{
  double Float; 
  float v3; 
  bitarray<224> *TeamFlags; 
  unsigned int v5; 
  __int128 v6; 
  double v7; 
  __int128 *v8; 
  const bitarray<224> *AllTeamFlags; 
  __int128 v10; 
  double v11; 
  int v12; 
  AIIterator *AIAgentIterator; 
  const gentity_s *i; 
  unsigned __int64 eTeam; 
  ai_agent_t *ScriptedAgentInfo; 
  __int64 v17; 
  __int64 v18; 
  __int64 v19; 
  vec3_t vectorValue; 
  __int128 v21; 
  double v22; 
  int v23; 
  AIAgentInterface result; 
  AIAgentInterface *p_result; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  Float = Scr_GetFloat(scrContext, 1u);
  v3 = *(float *)&Float * *(float *)&Float;
  TeamFlags = Scr_GetTeamFlags((bitarray<224> *)&result, scrContext, 2u);
  v5 = 0;
  v6 = *(_OWORD *)TeamFlags->array;
  v7 = *(double *)&TeamFlags->array[4];
  v23 = TeamFlags->array[6];
  v8 = &v21;
  v21 = v6;
  v22 = v7;
  while ( !*(_DWORD *)v8 )
  {
    ++v5;
    v8 = (__int128 *)((char *)v8 + 4);
    if ( v5 >= 7 )
    {
      if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_WEAPON_DROP|0x80) )
        AllTeamFlags = Com_TeamsSP_GetAllTeamFlags();
      else
        AllTeamFlags = Com_TeamsMP_GetAllTeamFlags();
      v10 = *(_OWORD *)AllTeamFlags->array;
      v11 = *(double *)&AllTeamFlags->array[4];
      v12 = AllTeamFlags->array[6];
      v21 = v10;
      v22 = v11;
      v23 = v12;
      break;
    }
  }
  Scr_MakeArray(scrContext);
  AIAgentIterator = AIAgentInterface::GetAIAgentIterator();
  for ( i = (const gentity_s *)AIAgentIterator->GetFirst(AIAgentIterator); i; i = AIAgentIterator->GetNext(AIAgentIterator) )
  {
    eTeam = (unsigned int)i->sentient->eTeam;
    if ( (unsigned int)eTeam >= 0xE0 )
    {
      LODWORD(v19) = 224;
      LODWORD(v18) = i->sentient->eTeam;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v18, v19) )
        __debugbreak();
    }
    if ( ((0x80000000 >> (eTeam & 0x1F)) & *((_DWORD *)&v21 + (eTeam >> 5))) != 0 )
    {
      AIAgentInterface::AIAgentInterface(&result);
      result.__vftable = (AIAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
      p_result = NULL;
      if ( SV_IsAgentScripted(i) )
      {
        ScriptedAgentInfo = AIAgentInterface::GetScriptedAgentInfo(i);
        if ( ScriptedAgentInfo )
        {
          p_result = &result;
          AINewAgentInterface::SetAgent((AINewAgentInterface *)&result, ScriptedAgentInfo);
        }
      }
      v17 = (__int64)p_result;
      if ( !p_result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 11816, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
        __debugbreak();
      if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v17 + 128i64))(v17) && !*(_BYTE *)((**(__int64 (__fastcall ***)(__int64))v17)(v17) + 1851) && (float)((float)((float)((float)(vectorValue.v[1] - i->r.currentOrigin.v[1]) * (float)(vectorValue.v[1] - i->r.currentOrigin.v[1])) + (float)((float)(vectorValue.v[0] - i->r.currentOrigin.v[0]) * (float)(vectorValue.v[0] - i->r.currentOrigin.v[0]))) + (float)((float)(vectorValue.v[2] - i->r.currentOrigin.v[2]) * (float)(vectorValue.v[2] - i->r.currentOrigin.v[2]))) <= v3 )
      {
        GScr_AddEntity(i);
        Scr_AddArray(scrContext);
      }
    }
  }
}

/*
==============
GScr_ReportChallengeUserEvent
==============
*/
void GScr_ReportChallengeUserEvent(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  unsigned int NumParam; 
  scr_string_t ConstString; 
  unsigned int v6; 
  VariableType Type; 
  unsigned int Int; 
  signed int v9; 
  const char *v10; 
  ComErrorCode v11; 
  double Float; 
  signed int v13; 
  scr_string_t v14; 
  signed int v15; 
  unsigned int ArrayObject; 
  unsigned int v17; 
  unsigned int ArraySize; 
  unsigned int ArrayVariable; 
  VariableType ValueType; 
  VariableType v21; 
  const char *NameForType; 
  const char *v23; 
  ComErrorCode v24; 
  VariableUnion *v25; 
  int v26; 
  const char *v27; 
  VariableUnion *v28; 
  const char *v29; 
  scr_string_t *VariableValueAddress; 
  const char *v31; 
  char dest[1024]; 

  Entity = GetEntity(entref);
  if ( !Entity->client )
    Scr_Error(COM_ERR_3313, scrContext, "ReportChallengeUserEvent: entity must be a player entity");
  NumParam = Scr_GetNumParam(scrContext);
  if ( !NumParam )
    Scr_Error(COM_ERR_3314, scrContext, "ReportChallengeUserEvent: must supply at least an event name");
  ConstString = Scr_GetConstString(scrContext, 0);
  if ( !SV_Challenges_BeginEvent(Entity->client, ConstString) )
  {
    SV_Challenges_DiscardEvent();
    Scr_Error(COM_ERR_5873, scrContext, "ReportChallengeUserEvent: challenge event buffer full");
  }
  v6 = 1;
  if ( NumParam > 1 )
  {
    while ( 1 )
    {
      Type = Scr_GetType(scrContext, v6);
      if ( Type == VAR_UNDEFINED )
        goto LABEL_43;
      if ( Type == VAR_POINTER )
        break;
      if ( Type != VAR_STRING )
      {
        if ( Type == VAR_FLOAT )
        {
          Float = Scr_GetFloat(scrContext, v6);
          v13 = Com_sprintf(dest, 0x400ui64, "%f", *(float *)&Float);
          if ( v13 < 0 )
          {
            SV_Challenges_DiscardEvent();
            Scr_Error(COM_ERR_5877, scrContext, "ReportChallengeUserEvent: challenge event buffer full");
          }
          if ( SV_Challenges_AddParamString(dest, v13) )
            goto LABEL_43;
          SV_Challenges_DiscardEvent();
          v10 = "ReportChallengeUserEvent: challenge event buffer full";
          v11 = COM_ERR_5878;
        }
        else if ( Type == VAR_INTEGER )
        {
          Int = Scr_GetInt(scrContext, v6);
          v9 = Com_sprintf(dest, 0x400ui64, "%i", Int);
          if ( v9 < 0 )
          {
            SV_Challenges_DiscardEvent();
            Scr_Error(COM_ERR_5875, scrContext, "ReportChallengeUserEvent: challenge event buffer full");
          }
          if ( SV_Challenges_AddParamString(dest, v9) )
            goto LABEL_43;
          SV_Challenges_DiscardEvent();
          v10 = "ReportChallengeUserEvent: challenge event buffer full";
          v11 = COM_ERR_5876;
        }
        else
        {
LABEL_41:
          SV_Challenges_DiscardEvent();
          v10 = j_va("ReportChallengeUserEvent: invalid parameter %d is not an array, string or number", v6);
          v11 = COM_ERR_5753;
        }
LABEL_42:
        Scr_Error(v11, scrContext, v10);
        goto LABEL_43;
      }
      v14 = Scr_GetConstString(scrContext, v6);
      if ( !SV_Challenges_AddParam(v14) )
      {
        SV_Challenges_DiscardEvent();
        v10 = "ReportChallengeUserEvent: challenge event buffer full";
        v11 = COM_ERR_5874;
        goto LABEL_42;
      }
LABEL_43:
      if ( ++v6 >= NumParam )
        goto LABEL_44;
    }
    if ( Scr_GetPointerType(scrContext, v6) != VAR_ARRAY )
      goto LABEL_41;
    v15 = 0;
    dest[0] = 0;
    ArrayObject = BGScr_Main_GetArrayObject(scrContext, v6);
    v17 = 0;
    ArraySize = GetArraySize(scrContext, ArrayObject);
    if ( !ArraySize )
    {
LABEL_39:
      if ( !SV_Challenges_AddParamString(dest, v15) )
      {
        SV_Challenges_DiscardEvent();
        v10 = "ReportChallengeUserEvent: challenge event buffer full";
        v11 = COM_ERR_5881;
        goto LABEL_42;
      }
      goto LABEL_43;
    }
    while ( 1 )
    {
      ArrayVariable = GetArrayVariable(scrContext, ArrayObject, v17);
      ValueType = GetValueType(scrContext, ArrayVariable);
      if ( ValueType )
      {
        if ( ValueType == VAR_STRING )
        {
          VariableValueAddress = (scr_string_t *)GetVariableValueAddress(scrContext, ArrayVariable);
          v31 = SL_ConvertToString(*VariableValueAddress);
          v15 += Com_sprintf(&dest[v15], 1024i64 - v15, "%s|", v31);
          if ( (unsigned int)(v15 + 1) >= 0x400 )
          {
            SV_Challenges_DiscardEvent();
            v23 = j_va("ReportChallengeUserEvent: array parameter %d is too long", v6);
            v24 = COM_ERR_5880;
            goto LABEL_37;
          }
        }
        else
        {
          if ( ValueType == VAR_FLOAT )
          {
            v28 = GetVariableValueAddress(scrContext, ArrayVariable);
            v26 = Com_sprintf(&dest[v15], 1024i64 - v15, "%f|", v28->floatValue);
            if ( v26 < 0 )
            {
              SV_Challenges_DiscardEvent();
              v29 = j_va("ReportChallengeUserEvent: array parameter %d is too long", v6);
              Scr_Error(COM_ERR_5879, scrContext, v29);
              v15 += v26;
              goto LABEL_38;
            }
          }
          else
          {
            if ( ValueType != VAR_INTEGER )
            {
              SV_Challenges_DiscardEvent();
              v21 = GetValueType(scrContext, ArrayVariable);
              NameForType = Scr_GetNameForType(v21);
              v23 = j_va("ReportChallengeUserEvent: invalid entry %d in parameter %d -- %s is not a string or number", v17, v6, NameForType);
              v24 = COM_ERR_5752;
LABEL_37:
              Scr_Error(v24, scrContext, v23);
              goto LABEL_38;
            }
            v25 = GetVariableValueAddress(scrContext, ArrayVariable);
            v26 = Com_sprintf(&dest[v15], 1024i64 - v15, "%i|", v25->uintValue);
            if ( v26 < 0 )
            {
              SV_Challenges_DiscardEvent();
              v27 = j_va("ReportChallengeUserEvent: array parameter %d is too long", v6);
              Scr_Error(COM_ERR_5751, scrContext, v27);
            }
          }
          v15 += v26;
        }
      }
LABEL_38:
      if ( ++v17 >= ArraySize )
        goto LABEL_39;
    }
  }
LABEL_44:
  SV_Challenges_FinishEvent();
}

/*
==============
GScr_GetLobbySquadIndex
==============
*/
void GScr_GetLobbySquadIndex(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *PlayerEntity; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v8; 

  entnum = entref.entnum;
  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  if ( !G_Utils_IsClient(PlayerEntity) )
  {
    targetname = PlayerEntity->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(PlayerEntity->classname);
    v8 = j_va("GetLobbySquadIndex(). Only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, PlayerEntity->r.currentOrigin.v[0], PlayerEntity->r.currentOrigin.v[1], PlayerEntity->r.currentOrigin.v[2], v7, v6);
    Scr_Error(COM_ERR_5290, scrContext, v8);
  }
  Scr_AddInt(scrContext, PlayerEntity->client->sess.lobbySquadIndex);
}

/*
==============
GScr_SavePOTGData
==============
*/

void __fastcall GScr_SavePOTGData(scrContext_t *scrContext)
{
  SV_SnapWorkersMP_StartSnapshotPOTGArchiveSave();
}

/*
==============
GScr_GetPOTGStartTime
==============
*/
void GScr_GetPOTGStartTime(scrContext_t *scrContext)
{
  int POTGStartTime; 

  POTGStartTime = SV_SnapshotMP_ArchiveGetPOTGStartTime();
  Scr_AddInt(scrContext, POTGStartTime);
}

/*
==============
GScr_GetPOTGDuration
==============
*/
void GScr_GetPOTGDuration(scrContext_t *scrContext)
{
  int POTGDuration; 

  POTGDuration = SV_SnapshotMP_ArchiveGetPOTGDuration();
  Scr_AddInt(scrContext, POTGDuration);
}

/*
==============
GScr_CompleteSceneTransition
==============
*/
void GScr_CompleteSceneTransition(scrContext_t *scrContext)
{
  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
    Cbuf_AddText(LOCAL_CLIENT_0, "completeSceneTransition\n");
}

/*
==============
GScr_CTGS_ReportUserMatchStats
==============
*/
void GScr_CTGS_ReportUserMatchStats(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  BG_SynchronizedPlayerInfo *PlayerInfo; 
  BG_SynchronizedPlayerInfo *v7; 
  const char *String; 
  int Int; 
  int v10; 
  int v11; 
  int v12; 
  int v13; 
  signed int v14; 
  char *v15; 
  unsigned __int64 MatchId; 
  unsigned int UTC; 
  XUID v18; 
  const char *MapName; 
  unsigned __int64 UniversalId; 
  __int64 v21; 
  ScopedCriticalSection v22; 
  int v23; 
  int v24; 
  int v25; 

  v21 = -2i64;
  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 12315, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  PlayerInfo = SvClientMP::GetPlayerInfo(v4->s.clientNum);
  v7 = PlayerInfo;
  if ( PlayerInfo && PlayerInfo->clientPlatform[0] == 2 )
  {
    String = Scr_GetString(scrContext, 0);
    Int = Scr_GetInt(scrContext, 1u);
    v10 = Scr_GetInt(scrContext, 2u);
    v11 = Scr_GetInt(scrContext, 3u);
    v12 = Scr_GetInt(scrContext, 4u);
    v25 = Scr_GetInt(scrContext, 5u);
    v24 = Scr_GetInt(scrContext, 6u);
    v23 = Scr_GetInt(scrContext, 7u);
    v13 = Scr_GetInt(scrContext, 8u);
    MapName = SV_Game_GetMapName();
    v18.m_id = v7->xuid.m_id;
    UniversalId = XUID::GetUniversalId(&v18);
    ScopedCriticalSection::ScopedCriticalSection(&v22, CRITSECT_QQTECH_MATCHDATA, SCOPED_CRITSECT_NORMAL);
    v14 = s_matchdata_queue_size;
    if ( (int)s_matchdata_queue_size < 64 )
      goto LABEL_14;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qqtech\\ac_matchdata.h", 53, ASSERT_TYPE_ASSERT, "(s_matchdata_queue_size < 64)", (const char *)&queryFormat, "s_matchdata_queue_size < AC_MATCHDATA_MAX_QUEUED") )
      __debugbreak();
    v14 = s_matchdata_queue_size;
    if ( (int)s_matchdata_queue_size < 64 )
    {
LABEL_14:
      v15 = s_matchdata_queue[(__int64)v14];
      MatchId = OnlineMatchId::GetMatchId();
      UTC = LiveStorage_GetUTC();
      j_snprintf(v15, 0x200ui64, "{\n\t\"%s\" :\n\t{\n\t\t\"%s\": %llu,\n\t\t\"%s\": %lu,\n\t\t\"%s\": \"%llu\",\n\t\t\"%s\": \"%s\",\n\t\t\"%s\": \"%s\",\n\t\t\"%s\": \"%lu\",\n\t\t\"%s\": \"%lu\",\n\t\t\"%s\": \"%lu\",\n\t\t\"%s\": \"%lu\",\n\t\t\"%s\": \"%lu\",\n\t\t\"%s\": \"%lu\",\n\t\t\"%s\": \"%lu\",\n\t\t\"%s\": \"%lu\"\n\t}\n}\n", "zh5l", "g2p0", UniversalId, "r9ic", UTC, "u3p0", MatchId, "xb9r", MapName, "bjf8", String, "lo0c", Int, "wv8c", v10, "ipo4", v11, "pwb8", v12, "tmr9", v25, "g7c1", v24, "f7fd", v23, "dd6b", v13);
      ++s_matchdata_queue_size;
    }
    ScopedCriticalSection::~ScopedCriticalSection(&v22);
  }
}

/*
==============
GScr_IncrementPersistentStat
==============
*/
void GScr_IncrementPersistentStat(scrContext_t *scrContext)
{
  VariableValue *Variable; 
  unsigned int *v3; 
  scr_entref_t EntityIdRef; 
  gentity_s *v5; 
  gclient_s *client; 
  unsigned int ConstString; 
  unsigned int v8; 
  unsigned int v9; 
  VariableType VariableType; 
  VariableUnion *VariableValueAddress; 
  VariableValue *v12; 
  VariableType type; 
  float v14; 
  const char *v15; 
  ComErrorCode v16; 
  VariableType v17; 
  VariableValue value; 

  if ( Scr_GetNumParam(scrContext) != 3 )
  {
    Scr_Error(COM_ERR_6310, scrContext, "Usage: IncrementPersistentStat( player, stateName, increment )");
    return;
  }
  Variable = Scr_GetVariable(scrContext, 0);
  v3 = (unsigned int *)Variable;
  if ( Variable->type == VAR_POINTER && GetObjectType(scrContext, Variable->u.intValue) == VAR_ENTITY )
  {
    EntityIdRef = Scr_GetEntityIdRef(scrContext, *v3);
    if ( EntityIdRef.entclass == ENTITY_CLASS_GENTITY )
    {
      if ( EntityIdRef.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 12366, ASSERT_TYPE_ASSERT, "( entref.entnum < ( 2048 ) )", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
        __debugbreak();
      v5 = &g_entities[EntityIdRef.entnum];
      client = v5->client;
      if ( client )
      {
        if ( client->sess.scriptPersId )
        {
          ConstString = Scr_GetConstString(scrContext, 1u);
          v8 = FindVariable(scrContext, v5->client->sess.scriptPersId, ConstString);
          v9 = v8;
          if ( v8 )
          {
            VariableType = GetVariableType(scrContext, v8);
            VariableValueAddress = GetVariableValueAddress(scrContext, v9);
            v12 = Scr_GetVariable(scrContext, 2u);
            if ( VariableType == VAR_INTEGER )
            {
              type = v12->type;
              if ( type == VAR_INTEGER )
              {
                VariableValueAddress->intValue += v12->u.intValue;
                return;
              }
              if ( type == VAR_FLOAT )
              {
                v14 = (float)VariableValueAddress->intValue + v12->u.floatValue;
                value.type = VAR_FLOAT;
                value.u.floatValue = v14;
                SetVariableValue(scrContext, v9, &value);
                return;
              }
              v15 = "Persistent stat increment must be int or float";
              v16 = COM_ERR_6311;
            }
            else if ( VariableType == VAR_FLOAT )
            {
              v17 = v12->type;
              if ( v17 == VAR_FLOAT )
              {
                VariableValueAddress->floatValue = v12->u.floatValue + VariableValueAddress->floatValue;
                return;
              }
              if ( v17 == VAR_INTEGER )
              {
                VariableValueAddress->floatValue = (float)v12->u.intValue + VariableValueAddress->floatValue;
                return;
              }
              v15 = "Persistent stat increment must be int or float";
              v16 = COM_ERR_6338;
            }
            else
            {
              v15 = "Persistent stat must be int or float to increment";
              v16 = COM_ERR_6312;
            }
            Scr_Error(v16, scrContext, v15);
          }
        }
      }
    }
  }
}

/*
==============
GScr_MainMP_IsDismembermentEnabled
==============
*/
void GScr_MainMP_IsDismembermentEnabled(scrContext_t *scrContext)
{
  int v1; 
  unsigned int v3; 
  SvClient *CommonClient; 

  v1 = 0;
  v3 = 0;
  if ( (int)SvClient::ms_clientCount <= 0 )
  {
LABEL_8:
    v1 = 1;
  }
  else
  {
    while ( 1 )
    {
      if ( (_BYTE)SvClient::ms_allocatedType != HALF_HALF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_mp\\sv_client_mp.h", 957, ASSERT_TYPE_ASSERT, "( ms_allocatedType == ALLOCATION_TYPE )", (const char *)&queryFormat, "ms_allocatedType == ALLOCATION_TYPE") )
        __debugbreak();
      CommonClient = SvClient::GetCommonClient(v3);
      if ( CommonClient->state >= CS_CONNECTED && !LOBYTE(CommonClient[1116].lastUsercmd.commandTime) )
        break;
      if ( (int)++v3 >= (int)SvClient::ms_clientCount )
        goto LABEL_8;
    }
  }
  Scr_AddBool(scrContext, v1);
}

/*
==============
GScr_MainMP_IsDismembermentEnabledForPlayer
==============
*/
void GScr_MainMP_IsDismembermentEnabledForPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  int v2; 
  unsigned int entnum; 
  gentity_s *v5; 
  const char *v6; 
  unsigned int number; 
  SvClient *CommonClient; 

  v2 = 0;
  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v5 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 12469, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v5 = &g_entities[entnum];
    if ( !v5->client )
    {
      v6 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v6);
    }
  }
  number = v5->s.number;
  if ( (_BYTE)SvClient::ms_allocatedType != HALF_HALF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_mp\\sv_client_mp.h", 957, ASSERT_TYPE_ASSERT, "( ms_allocatedType == ALLOCATION_TYPE )", (const char *)&queryFormat, "ms_allocatedType == ALLOCATION_TYPE") )
    __debugbreak();
  CommonClient = SvClient::GetCommonClient(number);
  if ( CommonClient->state >= CS_CONNECTED )
    LOBYTE(v2) = LOBYTE(CommonClient[1116].lastUsercmd.commandTime) != 0;
  Scr_AddBool(scrContext, v2);
}

/*
==============
GScr_IsPlayerHeadless
==============
*/
void GScr_IsPlayerHeadless(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  BG_SynchronizedPlayerInfo *PlayerInfo; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 12499, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  PlayerInfo = SvClientMP::GetPlayerInfo(v4->s.number);
  if ( !PlayerInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 12501, ASSERT_TYPE_ASSERT, "( storedPlayerInfo )", (const char *)&queryFormat, "storedPlayerInfo") )
    __debugbreak();
  Scr_AddBool(scrContext, PlayerInfo->isHeadless);
}

/*
==============
GScr_Knockback
==============
*/
void GScr_Knockback(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  gentity_s *v9; 
  playerState_s *p_ps; 
  const char *v11; 
  ComErrorCode v12; 
  double Float; 
  float v14; 
  __int128 v15; 
  EntityClass entclass; 
  vec3_t vectorValue; 

  entclass = entref.entclass;
  entnum = entref.entnum;
  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 538, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClientOrAgent(Entity) )
  {
    targetname = Entity->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(Entity->classname);
    v8 = j_va("Knockback(): Only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, Entity->r.currentOrigin.v[0], Entity->r.currentOrigin.v[1], Entity->r.currentOrigin.v[2], v7, v6);
    Scr_Error(COM_ERR_2977, scrContext, v8);
  }
  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_Error(COM_ERR_2978, scrContext, "Knockback() USAGE: <player> Knockback(<velocity dir>,<velocity magnitud>)\n");
  if ( entclass )
  {
    v11 = "not an entity";
    v12 = COM_ERR_3682;
    goto LABEL_19;
  }
  if ( entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 548, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v9 = &g_entities[entnum];
  p_ps = &v9->client->ps;
  if ( !p_ps )
  {
    p_ps = &v9->agent->playerState;
    if ( !p_ps )
    {
      v11 = j_va("entity %i is not a player or agent", entnum);
      v12 = COM_ERR_3679;
LABEL_19:
      Scr_ObjectError(v12, scrContext, v11);
      p_ps = NULL;
    }
  }
  Scr_GetVector(scrContext, 0, &vectorValue);
  Float = Scr_GetFloat(scrContext, 1u);
  v14 = *(float *)&Float;
  v15 = LODWORD(vectorValue.v[0]);
  *(float *)&v15 = fsqrt((float)((float)(*(float *)&v15 * *(float *)&v15) + (float)(vectorValue.v[1] * vectorValue.v[1])) + (float)(vectorValue.v[2] * vectorValue.v[2]));
  _XMM4 = v15;
  __asm
  {
    vcmpless xmm1, xmm4, cs:__real@80000000
    vblendvps xmm0, xmm4, xmm2, xmm1
  }
  vectorValue.v[0] = (float)(vectorValue.v[0] * (float)(1.0 / *(float *)&_XMM0)) * v14;
  vectorValue.v[1] = (float)(vectorValue.v[1] * (float)(1.0 / *(float *)&_XMM0)) * v14;
  vectorValue.v[2] = (float)(vectorValue.v[2] * (float)(1.0 / *(float *)&_XMM0)) * v14;
  p_ps->velocity = vectorValue;
  BG_SetKnockbackFlag(p_ps);
}

/*
==============
GScr_SetOnWallAnimConditional
==============
*/
void GScr_SetOnWallAnimConditional(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  gentity_s *v9; 
  playerState_s *p_ps; 
  const char *v11; 
  ComErrorCode v12; 
  bool v13; 
  EntityClass entclass; 

  entclass = entref.entclass;
  entnum = entref.entnum;
  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 578, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClientOrAgent(Entity) )
  {
    targetname = Entity->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(Entity->classname);
    v8 = j_va("SetOnWallAnimConditional(): Only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, Entity->r.currentOrigin.v[0], Entity->r.currentOrigin.v[1], Entity->r.currentOrigin.v[2], v7, v6);
    Scr_Error(COM_ERR_2979, scrContext, v8);
  }
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_2980, scrContext, "SetOnWallAnimConditional() USAGE: <player> SetOnWallAnimConditional(<enable>)\n");
  if ( entclass )
  {
    v11 = "not an entity";
    v12 = COM_ERR_3682;
    goto LABEL_19;
  }
  if ( entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 588, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v9 = &g_entities[entnum];
  p_ps = &v9->client->ps;
  if ( !p_ps )
  {
    p_ps = &v9->agent->playerState;
    if ( !p_ps )
    {
      v11 = j_va("entity %i is not a player or agent", entnum);
      v12 = COM_ERR_3679;
LABEL_19:
      Scr_ObjectError(v12, scrContext, v11);
      p_ps = NULL;
    }
  }
  v13 = 0;
  if ( Scr_GetType(scrContext, 0) )
    v13 = Scr_GetInt(scrContext, 0) > 0;
  BG_SetOnWallAnimFlag(p_ps, v13);
}

/*
==============
GScr_SetSeatedAnimConditional
==============
*/
void GScr_SetSeatedAnimConditional(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  PMoveFlagsMP v4; 
  gentity_s *Entity; 
  scr_string_t targetname; 
  const char *v7; 
  const char *v8; 
  const char *v9; 
  gentity_s *v10; 
  playerState_s *p_ps; 
  const char *v12; 
  ComErrorCode v13; 
  bool v14; 
  scr_string_t ConstString; 
  EntityClass entclass; 

  entclass = entref.entclass;
  entnum = entref.entnum;
  v4 = ANIM_LINKEDTO_NONE;
  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 623, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClientOrAgent(Entity) )
  {
    targetname = Entity->targetname;
    if ( targetname )
      v7 = SL_ConvertToString(targetname);
    else
      v7 = "<undefined>";
    v8 = SL_ConvertToString(Entity->classname);
    v9 = j_va("SetSeatedAnimConditional(): Only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, Entity->r.currentOrigin.v[0], Entity->r.currentOrigin.v[1], Entity->r.currentOrigin.v[2], v8, v7);
    Scr_Error(COM_ERR_2981, scrContext, v9);
  }
  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_Error(COM_ERR_2982, scrContext, "SetSeatedAnimConditional() USAGE: <player> SetSeatedAnimConditional(<type>,<enable>)\n");
  if ( entclass )
  {
    v12 = "not an entity";
    v13 = COM_ERR_3682;
    goto LABEL_19;
  }
  if ( entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 633, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v10 = &g_entities[entnum];
  p_ps = &v10->client->ps;
  if ( !p_ps )
  {
    p_ps = &v10->agent->playerState;
    if ( !p_ps )
    {
      v12 = j_va("entity %i is not a player or agent", entnum);
      v13 = COM_ERR_3679;
LABEL_19:
      Scr_ObjectError(v13, scrContext, v12);
      p_ps = NULL;
    }
  }
  v14 = 0;
  if ( Scr_GetType(scrContext, 0) == VAR_UNDEFINED )
    Scr_Error(COM_ERR_2983, scrContext, "SetSeatedAnimConditional() USAGE: <player> SetSeatedAnimConditional(<type>,<enable>). Valid types are \"seat\" and \"zipline\".\n");
  if ( Scr_GetType(scrContext, 1u) )
    v14 = Scr_GetInt(scrContext, 1u) > 0;
  ConstString = Scr_GetConstString(scrContext, 0);
  if ( ConstString == scr_const.animLinkedToSeat )
  {
    v4 = 59;
  }
  else if ( ConstString == scr_const.animLinkedToZipline )
  {
    v4 = 60;
  }
  else
  {
    Scr_Error(COM_ERR_2984, scrContext, "SetSeatedAnimConditional() USAGE: <player> SetSeatedAnimConditional(<type>,<enable>). Valid types are \"seat\" and \"zipline\".\n");
  }
  if ( v14 )
    BG_ClearLinkedToAnimFlags(p_ps);
  BG_SetLinkedToAnimFlag(p_ps, v4, v14);
}

/*
==============
GScr_OverrideVehicleSeatAnimConditionals
==============
*/
void GScr_OverrideVehicleSeatAnimConditionals(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  gentity_s *v9; 
  const char *v10; 
  ComErrorCode v11; 
  unsigned int v12; 
  unsigned int Int; 
  const char *v14; 
  scr_string_t ConstLowercaseString; 
  const char *v16; 
  const char *v17; 
  gclient_s *v18; 
  const char *v19; 
  const VehicleDef *ServerDef; 
  const char *v21; 
  animScriptVehicleType_t v22; 
  animScriptVehicleSeat_t v23; 
  gclient_s *client; 
  scr_entref_t outIndex; 

  outIndex = entref;
  entnum = entref.entnum;
  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 695, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClientOrAgent(Entity) )
  {
    targetname = Entity->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(Entity->classname);
    v8 = j_va("SetVehicleSeatAnimConditionals(): Only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, Entity->r.currentOrigin.v[0], Entity->r.currentOrigin.v[1], Entity->r.currentOrigin.v[2], v7, v6);
    Scr_Error(COM_ERR_6212, scrContext, v8);
  }
  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_Error(COM_ERR_6213, scrContext, "SetVehicleSeatAnimConditionals() USAGE: <player> SetVehicleSeatAnimConditionals( <vehicletype>, <seat> )\n");
  if ( outIndex.entclass )
  {
    v10 = "not an entity";
    v11 = COM_ERR_3682;
    goto LABEL_19;
  }
  if ( entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 707, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v9 = &g_entities[entnum];
  if ( !v9->client && !v9->agent )
  {
    v10 = j_va("entity %i is not a player or agent", entnum);
    v11 = COM_ERR_3679;
LABEL_19:
    Scr_ObjectError(v11, scrContext, v10);
  }
  v12 = 0;
  if ( Scr_GetType(scrContext, 0) == VAR_UNDEFINED )
    Scr_Error(COM_ERR_6214, scrContext, "SetVehicleSeatAnimConditionals() USAGE: <player> SetVehicleSeatAnimConditionals( <vehicletype>, <seat> )\n");
  if ( Scr_GetType(scrContext, 1u) )
  {
    Int = Scr_GetInt(scrContext, 1u);
    v12 = Int;
    if ( Int > 9 )
    {
      v14 = j_va("SetVehicleSeatAnimConditionals(): cannot assign a seat of index %i! Must be a 0-9 index.\n", Int);
      Scr_Error(COM_ERR_6215, scrContext, v14);
    }
  }
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  v16 = SL_ConvertToString(ConstLowercaseString);
  v17 = v16;
  if ( *v16 )
  {
    if ( !G_Vehicle_GetServerDefIndex(v16, (unsigned int *)&outIndex) )
    {
      v19 = j_va("SetVehicleSeatAnimConditionals(): could not find server def index for vehicle with asset name: %s\n", v17);
      Scr_Error(COM_ERR_6216, scrContext, v19);
    }
    ServerDef = G_Vehicle_GetServerDef(outIndex.entnum);
    if ( !ServerDef )
    {
      v21 = j_va("SetVehicleSeatAnimConditionals(): could not find VehicleDef for vehicle of type: %s\n", v17);
      Scr_Error(COM_ERR_6217, scrContext, v21);
    }
    v22 = BG_VehicleOccupancy_MapVehicleProfileToVehicleType((const VehiclePhysicsAnimProfile)ServerDef->vehiclePhysicsDef.physics_animProfile);
    v23 = v12 + 1;
    client = Entity->client;
    if ( client )
    {
      client->animOverrideVehicleType = v22;
      Entity->client->animOverrideVehicleSeat = v23;
    }
    else
    {
      Entity->agent->animOverrideVehicleType = v22;
      Entity->agent->animOverrideVehicleSeat = v23;
    }
  }
  else
  {
    v18 = Entity->client;
    if ( v18 )
    {
      v18->animOverrideVehicleType = VEHICLE_TYPE_UNUSED;
      Entity->client->animOverrideVehicleSeat = VEHICLE_SEAT_UNUSED;
    }
    else
    {
      Entity->agent->animOverrideVehicleType = VEHICLE_TYPE_UNUSED;
      Entity->agent->animOverrideVehicleSeat = VEHICLE_SEAT_UNUSED;
    }
  }
}

/*
==============
GScr_SpawnPlane
==============
*/
void GScr_SpawnPlane(scrContext_t *scrContext)
{
  gentity_s *Entity; 
  scr_string_t ConstString; 
  int Int; 
  const char *String; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  gentity_s *v9; 
  signed __int64 v10; 
  const char *v11; 
  const char *v12; 
  __int64 v13; 
  __int64 v14; 
  unsigned int outIndex; 
  unsigned int v16; 
  vec3_t vectorValue; 

  Entity = GScr_GetEntity(0);
  if ( !Entity->client )
    Scr_ParamError(COM_ERR_2985, scrContext, 0, "Owner entity is not a player");
  ConstString = Scr_GetConstString(scrContext, 1u);
  Scr_GetVector(scrContext, 2u, &vectorValue);
  Int = 0;
  if ( Scr_GetNumParam(scrContext) > 3 && Scr_GetType(scrContext, 3u) )
  {
    String = Scr_GetString(scrContext, 3u);
    if ( !NetConstStrings_GetIndexPlusOneFromName(NETCONSTSTRINGTYPE_MINIMAPICON, String, &outIndex) )
    {
      v6 = j_va("Couldn't find icon index for friendly icon '%s'", String);
      Scr_ParamError(COM_ERR_2986, scrContext, 3u, v6);
    }
    if ( !outIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 814, ASSERT_TYPE_ASSERT, "( friendIconIndex != 0 )", (const char *)&queryFormat, "friendIconIndex != 0") )
      __debugbreak();
  }
  else
  {
    outIndex = 0;
  }
  if ( Scr_GetNumParam(scrContext) > 4 && Scr_GetType(scrContext, 4u) )
  {
    v7 = Scr_GetString(scrContext, 4u);
    if ( !NetConstStrings_GetIndexPlusOneFromName(NETCONSTSTRINGTYPE_MINIMAPICON, v7, &v16) )
    {
      v8 = j_va("Couldn't find icon index for enemy icon '%s'", v7);
      Scr_ParamError(COM_ERR_2987, scrContext, 4u, v8);
    }
    if ( !v16 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 828, ASSERT_TYPE_ASSERT, "( enemyIconIndex != 0 )", (const char *)&queryFormat, "enemyIconIndex != 0") )
      __debugbreak();
  }
  else
  {
    v16 = 0;
  }
  if ( Scr_GetNumParam(scrContext) > 5 )
    Int = Scr_GetInt(scrContext, 5u);
  v9 = G_Utils_SpawnEntity();
  Scr_SetString(&v9->script_classname, ConstString);
  v9->r.currentOrigin = vectorValue;
  v9->spawnflags = Int;
  if ( G_Spawn_CallForEntity(v9) )
  {
    v9->s.eType = ET_PLANE;
    v10 = Entity->client - level.clients;
    if ( (unsigned __int64)(v10 + 0x80000000i64) > 0xFFFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "int __cdecl truncate_cast_impl<int,__int64>(__int64)", "signed", (int)v10, "signed", Entity->client - level.clients) )
      __debugbreak();
    v9->s.lerp.u.anonymous.data[0] = v10;
    if ( (unsigned int)v10 >= level.maxclients )
    {
      LODWORD(v14) = level.maxclients;
      LODWORD(v13) = v10;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 853, ASSERT_TYPE_ASSERT, "(unsigned)( ent->s.lerp.u.plane.ownerNum ) < (unsigned)( level.maxclients )", "ent->s.lerp.u.plane.ownerNum doesn't index level.maxclients\n\t%i not in [0, %i)", v13, v14) )
        __debugbreak();
    }
    v9->s.lerp.u.anonymous.data[2] = outIndex;
    v9->s.lerp.u.anonymous.data[1] = v16;
    GScr_AddEntity(v9);
  }
  else
  {
    if ( !GUtils::ms_gUtils && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_utils.h", 112, ASSERT_TYPE_ASSERT, "( ms_gUtils )", (const char *)&queryFormat, "ms_gUtils") )
      __debugbreak();
    GUtils::ms_gUtils->FreeEntity(GUtils::ms_gUtils, v9);
    v11 = SL_ConvertToString(ConstString);
    v12 = j_va("unable to spawn \"%s\" entity", v11);
    Scr_Error(COM_ERR_2988, scrContext, v12);
  }
}

/*
==============
GScr_SpawnHelicopter
==============
*/
void GScr_SpawnHelicopter(scrContext_t *scrContext)
{
  gentity_s *Entity; 
  const char *String; 
  const char *v4; 
  gentity_s *v5; 
  vec3_t vectorValue; 
  vec3_t v7; 

  Entity = GScr_GetEntity(0);
  if ( !Entity->client )
    Scr_ParamError(COM_ERR_2989, scrContext, 0, "Owner entity is not a player");
  Scr_GetVector(scrContext, 1u, &vectorValue);
  Scr_GetVector(scrContext, 2u, &v7);
  String = Scr_GetString(scrContext, 3u);
  v4 = Scr_GetString(scrContext, 4u);
  if ( G_VehicleHeliMP_CanSpawn() )
  {
    v5 = G_Utils_SpawnEntity();
    Scr_SetString(&v5->classname, scr_const.script_vehicle);
    Scr_SetString(&v5->script_classname, scr_const.script_vehicle);
    v5->r.currentOrigin = vectorValue;
    v5->r.currentAngles = v7;
    G_VehicleHeliMP_Spawn(v5, Entity, String, v4);
    GScr_AddEntity(v5);
  }
  else
  {
    Com_PrintError(1, "Can't spawn extra helicopter (%s %s)\n", String, v4);
    Scr_Error(COM_ERR_2990, scrContext, "Can't spawn extra helicopter. In ship this will return 'undefined' instead of a script error.");
    Scr_AddUndefined(scrContext);
  }
}

/*
==============
GScr_SpawnImpulseField
==============
*/
void GScr_SpawnImpulseField(scrContext_t *scrContext)
{
  const dvar_t *v1; 
  const char *v3; 
  VariableType Type; 
  bool v5; 
  const gentity_s *Entity; 
  gentity_s *v7; 
  GWeaponMap *Instance; 
  bool outIsAlternate; 
  vec3_t vectorValue; 
  Weapon outWeapon; 

  v1 = DCONST_DVARBOOL_bg_impulse_field_instrumentation_enabled;
  if ( !DCONST_DVARBOOL_bg_impulse_field_instrumentation_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_impulse_field_instrumentation_enabled") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  if ( v1->current.enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 939, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Script spawned an impulse field.") )
    __debugbreak();
  if ( G_MainMP_GetImpulseFieldEntityCount(LOCAL_CLIENT_INVALID) == 24 )
  {
    v3 = j_va("You cannot create more than %d impulse fields.", 24i64);
    Scr_Error(COM_ERR_2991, scrContext, v3);
    return;
  }
  if ( Scr_GetNumParam(scrContext) != 3 )
  {
    Scr_Error(COM_ERR_2992, scrContext, "Incorrect number of parameters. Correct usage: SpawnImpulseField( <owner>, <weapon>, <origin> )");
    return;
  }
  Type = Scr_GetType(scrContext, 0);
  v5 = Type == VAR_UNDEFINED;
  if ( Type && Scr_GetType(scrContext, 0) == VAR_POINTER && Scr_GetPointerType(scrContext, 0) == VAR_ENTITY )
  {
    Entity = GScr_GetEntity(0);
  }
  else
  {
    if ( !v5 )
    {
      Scr_Error(COM_ERR_2993, scrContext, "First argument must be either the owner entity or undefined.");
      return;
    }
    Entity = NULL;
  }
  GScr_Main_GetWeaponParam(scrContext, 1u, &outWeapon, &outIsAlternate);
  if ( outWeapon.weaponIdx )
  {
    Scr_GetVector(scrContext, 2u, &vectorValue);
    v7 = G_Utils_SpawnEntity();
    v7->r.currentOrigin = vectorValue;
    Scr_SetString(&v7->classname, scr_const.script_impulse_field);
    Scr_SetString(&v7->script_classname, scr_const.script_impulse_field);
    G_ScrMover_InitScriptMover(v7);
    if ( Entity )
    {
      EntHandle::setEnt(&v7->r.ownerNum, Entity);
      EntHandle::setEnt(&v7->parent, Entity);
      v7->s.otherEntityNum = Entity->s.number;
    }
    Instance = GWeaponMap::GetInstance();
    if ( !Instance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 447, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    if ( !v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 448, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
      __debugbreak();
    Instance->SetWeapon(Instance, &v7->s.weaponHandle, &outWeapon);
    v7->s.lerp.u.anonymous.data[2] |= 4u;
    SV_LinkEntity(v7);
    GScr_AddEntity(v7);
  }
  else
  {
    Scr_ParamError(COM_ERR_2994, scrContext, 0, "Invalid weapon.");
    Scr_AddUndefined(scrContext);
  }
}

/*
==============
GScr_SetPlayerGhost
==============
*/
void GScr_SetPlayerGhost(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *client; 
  const char *v6; 
  ComErrorCode v7; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *v8; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 1028, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = (GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *)v4->client;
  if ( !client )
  {
    client = (GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *)v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v7, scrContext, v6);
      client = NULL;
    }
  }
  v8 = client + 94;
  if ( Scr_GetInt(scrContext, 0) )
    GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(v8, GameModeFlagValues::ms_mpValue, 0x1Au);
  else
    GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(v8, GameModeFlagValues::ms_mpValue, 0x1Au);
}

/*
==============
GScr_SetPlayerAdvancedUAVDot
==============
*/
void GScr_SetPlayerAdvancedUAVDot(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *v4; 
  const char *v5; 
  ComErrorCode v6; 
  gentity_s *Entity; 
  scr_string_t targetname; 
  const char *v9; 
  const char *v10; 
  const char *v11; 
  int Int; 
  __int16 playerFlags; 
  __int16 v14; 
  __int16 v15; 

  if ( entref.entclass )
  {
    v5 = "not an entity";
    v6 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 1055, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entref.entnum];
  if ( !v4->client && !v4->agent )
  {
    v5 = j_va("entity %i is not a player or agent", entref.entnum);
    v6 = COM_ERR_3679;
LABEL_9:
    Scr_ObjectError(v6, scrContext, v5);
  }
  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 1060, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClientOrAgent(Entity) )
  {
    targetname = Entity->targetname;
    if ( targetname )
      v9 = SL_ConvertToString(targetname);
    else
      v9 = "<undefined>";
    v10 = SL_ConvertToString(Entity->classname);
    v11 = j_va("SetPlayerAdvancedUAVDot(): Only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entref.entnum, Entity->r.currentOrigin.v[0], Entity->r.currentOrigin.v[1], Entity->r.currentOrigin.v[2], v10, v9);
    Scr_Error(COM_ERR_6168, scrContext, v11);
  }
  Int = Scr_GetInt(scrContext, 0);
  playerFlags = Entity->s.lerp.u.player.playerFlags;
  v14 = playerFlags | 0x4000;
  v15 = playerFlags & 0xBFFF;
  if ( Int )
    v15 = v14;
  Entity->s.lerp.u.player.playerFlags = v15;
}

/*
==============
Scr_SysPrint
==============
*/
void Scr_SysPrint(scrContext_t *scrContext)
{
  signed int v2; 
  int NumParam; 
  const char *DebugString; 

  v2 = 0;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam > 0 )
  {
    do
    {
      DebugString = Scr_GetDebugString(scrContext, v2);
      Compass_Print(DebugString);
      Sys_Print("\n");
      ++v2;
    }
    while ( v2 < NumParam );
  }
}

/*
==============
GScr_RemoveAllCorpses
==============
*/
void GScr_RemoveAllCorpses(scrContext_t *scrContext)
{
  G_MainMP_FreeAllPlayerCorpses(1);
  G_MainMP_FreeAllAgentCorpses();
}

/*
==============
GScr_SetOmnvarForAllClients
==============
*/
void GScr_SetOmnvarForAllClients(scrContext_t *scrContext)
{
  const char *String; 
  unsigned int IndexByName; 
  const char *v4; 
  const OmnvarDef *Def; 
  const char *v6; 
  int maxclients; 
  int v8; 
  __int64 v9; 
  OmnvarData *Data; 

  String = Scr_GetString(scrContext, 0);
  IndexByName = BG_Omnvar_GetIndexByName(String);
  if ( IndexByName == -1 )
  {
    v4 = j_va("SetOmnvarForAllClients - '%s' not found", String);
    Scr_Error(COM_ERR_2995, scrContext, v4);
  }
  Def = BG_Omnvar_GetDef(IndexByName);
  if ( (Def->flags & 2) == 0 )
  {
    v6 = j_va("SetOmnvarForAllClients '%s' must be done on a client-scope Omnvar", String);
    Scr_Error(COM_ERR_2996, scrContext, v6);
  }
  maxclients = level.maxclients;
  v8 = 0;
  if ( level.maxclients > 0 )
  {
    v9 = 0i64;
    do
    {
      if ( level.clients[v9].sess.connected == CON_CONNECTED )
      {
        Data = G_Omnvar_GetData(IndexByName, v8, &level.clients[v9].ps);
        GScr_SetOmnvarInternal(scrContext, Def, Data, 1);
        maxclients = level.maxclients;
      }
      ++v8;
      ++v9;
    }
    while ( v8 < maxclients );
  }
}

/*
==============
ScrCmd_SetSoundBlend
==============
*/
void ScrCmd_SetSoundBlend(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  const char *String; 
  unsigned __int16 v6; 
  const char *v7; 
  unsigned __int16 v8; 
  double Float; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( Entity->s.eType != ET_SOUND || Entity->s.lerp.u.anonymous.data[0] )
    Scr_Error(COM_ERR_3011, scrContext, "Entity is not a sound_blend\n");
  String = Scr_GetString(scrContext, 0);
  v6 = G_CStringMP_LoopedSoundAliasIndex(String);
  v7 = Scr_GetString(scrContext, 1u);
  v8 = G_CStringMP_LoopedSoundAliasIndex(v7);
  Float = Scr_GetFloat(scrContext, 2u);
  if ( *(float *)&Float < 0.0 || *(float *)&Float > 1.0 )
    Scr_Error(COM_ERR_3012, scrContext, "Lerp must be between 0.0f and 1.0f\n");
  v4->s.lerp.u.turret.gunAngles.v[2] = *(float *)&Float;
  v4->s.lerp.u.player.torsoPitchPacked = v6;
  v4->s.lerp.u.actor.lookAtEntityNum = v8;
  *(_QWORD *)&v4->s.lerp.u.scriptMover.animIndex = 0i64;
}

/*
==============
ScrCmd_PlaySoundOnMovingEnt
==============
*/
void ScrCmd_PlaySoundOnMovingEnt(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *String; 
  const char *v6; 
  const char *v7; 
  const SndAliasList *Alias; 
  const char *v9; 
  const char *v10; 
  unsigned __int16 v11; 
  const char *v12; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_3014, scrContext, "Usage: PlaySoundOnMovingEnt( <aliasname> );");
  Entity = GetEntity(entref);
  String = Scr_GetString(scrContext, 0);
  if ( (Entity->r.svFlags & 1) != 0 )
  {
    v6 = SL_ConvertToString(Entity->classname);
    v7 = j_va("PlaySoundOnMovingEnt called on a server only entity of type %s.", v6);
    Scr_Error(COM_ERR_3015, scrContext, v7);
  }
  Alias = SND_FindAlias(String);
  if ( !Alias )
  {
    v9 = j_va("unknown sound alias '%s'", String);
    Scr_ParamError(COM_ERR_3016, scrContext, 0, v9);
  }
  if ( Com_IsSoundAliasLooping(Alias) )
  {
    v10 = j_va("'%s' is a looping alias, use 'playloopsound' instead", String);
    Scr_ParamError(COM_ERR_3017, scrContext, 0, v10);
  }
  v11 = G_CStringMP_SoundAliasIndex(String);
  if ( (unsigned __int16)(v11 - 1) > 0x7FFFu )
  {
    v12 = j_va("'%s' does has not have a valid index (%i)", String, v11);
    Scr_ParamError(COM_ERR_3018, scrContext, 0, v12);
  }
  G_Utils_AddEvent(Entity, 3u, v11);
}

/*
==============
ScrCmd_PlaySoundAtPos
==============
*/
void ScrCmd_PlaySoundAtPos(scrContext_t *scrContext)
{
  unsigned int NumParam; 
  const char *v3; 
  const char *String; 
  vec3_t vectorValue; 

  if ( Scr_GetNumParam(scrContext) != 2 )
  {
    NumParam = Scr_GetNumParam(scrContext);
    v3 = j_va("playsoundatpos needs 2 parameters - you had %i parameters", NumParam);
    Scr_Error(COM_ERR_3019, scrContext, v3);
  }
  Scr_GetVector(scrContext, 0, &vectorValue);
  String = Scr_GetString(scrContext, 1u);
  ScrCmd_PlaySoundAtPosInternal(scrContext, &vectorValue, String);
}

/*
==============
GScr_TurretGetAim
==============
*/
void GScr_TurretGetAim(scrContext_t *scrContext, scr_entref_t entref)
{
  ;
}

/*
==============
ScrCmd_IsThirdPersonCamVehicle
==============
*/
void ScrCmd_IsThirdPersonCamVehicle(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  const playerState_s *EntityPlayerState; 
  GHandler *Handler; 
  bool ShouldHandleThirdPersonVehicleCamera; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 1824, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  EntityPlayerState = G_GetEntityPlayerState(v4);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 1827, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  Handler = GHandler::getHandler();
  ShouldHandleThirdPersonVehicleCamera = BG_ShouldHandleThirdPersonVehicleCamera(EntityPlayerState, Handler);
  Scr_AddBool(scrContext, ShouldHandleThirdPersonVehicleCamera);
}

/*
==============
ScrCmd_SetThirdPersonCamVehicle
==============
*/
void ScrCmd_SetThirdPersonCamVehicle(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  playerState_s *EntityPlayerState; 
  unsigned int NumParam; 
  const char *v8; 
  int Int; 
  unsigned int v10; 
  unsigned int v11; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 1845, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  EntityPlayerState = G_GetEntityPlayerState(v4);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 1848, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( Scr_GetNumParam(scrContext) != 1 )
  {
    NumParam = Scr_GetNumParam(scrContext);
    v8 = j_va("SetThirdPersonCamVehicle needs 1 parameter - you had %i parameters", NumParam);
    Scr_Error(COM_ERR_3023, scrContext, v8);
  }
  Int = Scr_GetInt(scrContext, 0);
  v10 = EntityPlayerState->pm_flags.m_flags[1];
  if ( Int )
    v11 = v10 | 0x1000;
  else
    v11 = v10 & 0xFFFFEFFF;
  EntityPlayerState->pm_flags.m_flags[1] = v11;
}

/*
==============
ScrCmd_PlaySoundToTeam
==============
*/
void ScrCmd_PlaySoundToTeam(scrContext_t *scrContext, scr_entref_t entref)
{
  scr_entref_t v2; 
  gentity_s *Entity; 
  char v5; 
  gentity_s *v6; 
  const char *String; 
  gentity_s *v8; 
  gentity_s *v9; 
  scr_string_t ConstString; 
  const char *v11; 
  const char *v12; 
  unsigned int entnum; 
  const char *v14; 
  const char *v15; 
  signed int v16; 
  gentity_s *v17; 
  gentity_s *v18; 
  const char *v19; 
  bitarray_base<bitarray<224> > *p_clientMask; 
  gentity_s *v21; 
  __int64 v22; 
  __int64 v23; 
  __int64 v24; 
  __int64 v25; 
  scr_entref_t entrefa; 

  v2 = entref;
  entrefa = entref;
  if ( Scr_GetNumParam(scrContext) > 3 && Scr_GetType(scrContext, 3u) )
  {
    Entity = GScr_GetEntity(3u);
    if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 1488, ASSERT_TYPE_ASSERT, "( soundSourceEnt )", (const char *)&queryFormat, "soundSourceEnt") )
      __debugbreak();
    v5 = 1;
    entrefa.entnum = Entity->s.number;
    entrefa.entclass = ENTITY_CLASS_GENTITY;
    v2 = entrefa;
  }
  else
  {
    v5 = 0;
  }
  v6 = GetEntity(v2);
  String = Scr_GetString(scrContext, 0);
  v8 = ScrCmd_PlaySoundAtPosInternal(scrContext, &v6->r.currentOrigin, String);
  v9 = v8;
  if ( v5 )
    v8->s.otherEntityNum = entrefa.entnum;
  ConstString = Scr_GetConstString(scrContext, 1u);
  if ( Com_Teams_TeamFromString(ConstString, (team_t *)&entrefa) )
  {
    entnum = entrefa.entnum;
    if ( !entrefa.entnum || entrefa.entnum - 201 <= 1 )
    {
      v14 = SL_ConvertToString(ConstString);
      v15 = j_va("Illegal team string '%s'. Must be allies, axis, team_three, team_four, team_five, or team_six.", v14);
      Scr_Error(COM_ERR_3025, scrContext, v15);
    }
    v16 = 0;
    if ( Scr_GetNumParam(scrContext) >= 3 && Scr_GetType(scrContext, 2u) )
    {
      v17 = GScr_GetEntity(2u);
      v18 = v17;
      if ( !v17->client )
      {
        v19 = j_va("entity %i is not a player", (unsigned int)v17->s.number);
        Scr_ObjectError(COM_ERR_3026, scrContext, v19);
      }
    }
    else
    {
      v18 = NULL;
    }
    p_clientMask = &v9->clientMask;
    v9->clientMask.array[0] = -1;
    *(_QWORD *)&v9->clientMask.array[1] = -1i64;
    *(_QWORD *)&v9->clientMask.array[3] = -1i64;
    *(_QWORD *)&v9->clientMask.array[5] = -1i64;
    v21 = g_entities;
    if ( (int)SvClient::ms_clientCount > 0 )
    {
      v22 = 0i64;
      v23 = 0i64;
      do
      {
        if ( (unsigned int)v16 >= 0x800 )
        {
          LODWORD(v25) = 2048;
          LODWORD(v24) = v16;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v24, v25) )
            __debugbreak();
        }
        if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
          __debugbreak();
        if ( g_entities[v22].r.isInUse != g_entityIsInUse[v23] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
          __debugbreak();
        if ( g_entityIsInUse[v23] && v21 != v18 )
        {
          if ( !v21->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 1925, ASSERT_TYPE_ASSERT, "(clientEnt->client)", (const char *)&queryFormat, "clientEnt->client") )
            __debugbreak();
          if ( v21->client->sess.cs.team == entnum )
            bitarray_base<bitarray<224>>::resetBit(p_clientMask, v21->s.number);
        }
        ++v16;
        ++v23;
        ++v22;
        ++v21;
      }
      while ( v16 < (int)SvClient::ms_clientCount );
    }
  }
  else
  {
    v11 = SL_ConvertToString(ConstString);
    v12 = j_va("unknown team '%s'", v11);
    Scr_Error(COM_ERR_3024, scrContext, v12);
  }
}

/*
==============
ScrCmd_PlaySoundToPlayer
==============
*/
void ScrCmd_PlaySoundToPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  scr_entref_t v2; 
  gentity_s *Entity; 
  char v5; 
  gentity_s *v6; 
  const char *String; 
  gentity_s *v8; 
  gentity_s *v9; 
  gentity_s *v10; 
  gentity_s *v11; 
  const char *v12; 
  unsigned int number; 
  unsigned int *v14; 
  scr_entref_t entrefa; 

  v2 = entref;
  entrefa = entref;
  if ( Scr_GetNumParam(scrContext) > 2 && Scr_GetType(scrContext, 2u) )
  {
    Entity = GScr_GetEntity(2u);
    if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 1488, ASSERT_TYPE_ASSERT, "( soundSourceEnt )", (const char *)&queryFormat, "soundSourceEnt") )
      __debugbreak();
    v5 = 1;
    entrefa.entnum = Entity->s.number;
    entrefa.entclass = ENTITY_CLASS_GENTITY;
    v2 = entrefa;
  }
  else
  {
    v5 = 0;
  }
  v6 = GetEntity(v2);
  String = Scr_GetString(scrContext, 0);
  v8 = ScrCmd_PlaySoundAtPosInternal(scrContext, &v6->r.currentOrigin, String);
  v9 = v8;
  if ( v5 )
    v8->s.otherEntityNum = entrefa.entnum;
  v10 = GScr_GetEntity(1u);
  v11 = v10;
  if ( !v10->client )
  {
    v12 = j_va("entity %i is not a player", (unsigned int)v10->s.number);
    Scr_ObjectError(COM_ERR_3027, scrContext, v12);
  }
  *(_QWORD *)v9->clientMask.array = -1i64;
  *(_QWORD *)&v9->clientMask.array[2] = -1i64;
  *(_QWORD *)&v9->clientMask.array[4] = -1i64;
  v9->clientMask.array[6] = -1;
  number = v11->s.number;
  if ( number >= 0xE0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 290, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", number, 224) )
    __debugbreak();
  v14 = &v9->clientMask.array[(unsigned __int64)number >> 5];
  *v14 &= ~(0x80000000 >> (number & 0x1F));
}

/*
==============
ScrCmd_QueueDialogForPlayer
==============
*/
void ScrCmd_QueueDialogForPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  int groupOverride; 
  unsigned int entnum; 
  gentity_s *v5; 
  const char *v6; 
  const char *String; 
  scr_string_t ConstString; 
  unsigned int v11; 
  scr_string_t group; 
  vec3_t vectorValue; 

  groupOverride = 0;
  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3678, scrContext, "not an entity");
    v5 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 1995, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v5 = &g_entities[entnum];
    if ( !v5->client && !v5->agent )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3677, scrContext, v6);
    }
  }
  if ( !SV_IsAgentEntity(v5) || SV_IsAgentBot(v5->agent->agentState.entityNum) )
  {
    String = Scr_GetString(scrContext, 0);
    ConstString = Scr_GetConstString(scrContext, 1u);
    Scr_GetFloat(scrContext, 2u);
    _XMM0 = 0i64;
    __asm { vroundss xmm1, xmm0, xmm4, 1 }
    v11 = 0;
    if ( !strstr_0(String, "null") )
    {
      v11 = SND_HashName(String);
      if ( !v11 )
        Scr_ParamError(COM_ERR_3028, scrContext, 0, "Invalid sound name specified");
    }
    if ( Scr_GetNumParam(scrContext) > 3 && Scr_GetType(scrContext, 3u) )
      group = Scr_GetConstString(scrContext, 3u);
    else
      group = 0;
    if ( Scr_GetNumParam(scrContext) > 4 && Scr_GetType(scrContext, 4u) )
      groupOverride = Scr_GetInt(scrContext, 4u);
    if ( Scr_GetNumParam(scrContext) > 5 && Scr_GetType(scrContext, 5u) )
    {
      Scr_GetVector(scrContext, 5u, &vectorValue);
    }
    else
    {
      vectorValue.v[0] = 0.0;
      vectorValue.v[1] = 0.0;
      vectorValue.v[2] = 0.0;
    }
    G_QueueDialogForPlayer(v5, ConstString, v11, &vectorValue, (int)*(float *)&_XMM1, group, groupOverride);
  }
}

/*
==============
ScrCmd_QueueDialog
==============
*/
void ScrCmd_QueueDialog(scrContext_t *scrContext)
{
  const char *String; 
  const char *v3; 
  const char *v6; 
  unsigned int v7; 
  team_t v8; 
  scr_string_t ConstString; 
  const char *v10; 
  const char *v11; 
  unsigned int ArrayObject; 
  unsigned int ArraySize; 
  const char *v14; 
  const char *NameForType; 
  const char *v16; 
  unsigned int i; 
  gclient_s *v18; 
  SvClientMP *MpClient; 
  team_t team; 
  __int64 v21; 
  scr_entref_t EntityIdRef; 
  gentity_s *Entity; 
  unsigned int v24; 
  gentity_s *v25; 
  unsigned int j; 
  unsigned int v27; 
  __int64 v28; 
  gentity_s *v29; 
  gagent_s *agent; 
  int entityNum; 
  team_t v32; 
  __int64 v33; 
  scr_entref_t v34; 
  gentity_s *v35; 
  unsigned int v36; 
  unsigned int *failureIndex; 
  VariableType *failureType; 
  unsigned int count; 
  VariableType v40[4]; 
  team_t outTeam; 
  unsigned int v42; 
  scr_string_t group; 
  unsigned int soundHash; 
  int duration; 
  scr_string_t dialogName; 
  unsigned int v47; 
  vec3_t vectorValue; 
  unsigned int buffer[248]; 

  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
    Scr_Error(COM_ERR_3029, scrContext, "Function not supported for front-end server");
  if ( !SV_Game_IsLocalSplitscreenGame() )
  {
    String = Scr_GetString(scrContext, 0);
    v3 = Scr_GetString(scrContext, 1u);
    dialogName = Scr_GetConstString(scrContext, 2u);
    Scr_GetFloat(scrContext, 3u);
    _XMM0 = 0i64;
    __asm { vroundss xmm1, xmm0, xmm4, 1 }
    duration = (int)*(float *)&_XMM1;
    v6 = SL_ConvertToString(dialogName);
    if ( I_strncmp(v6, "null", 0x7FFFFFFFui64) )
    {
      v7 = 0;
      v42 = 0;
      soundHash = 0;
      if ( !strstr_0(String, "null") )
      {
        v42 = SND_HashName(String);
        if ( !v42 )
          Scr_ParamError(COM_ERR_3030, scrContext, 0, "Invalid sound allies sound name specified");
      }
      if ( !strstr_0(v3, "null") )
      {
        soundHash = SND_HashName(v3);
        v7 = soundHash;
        if ( !soundHash )
          Scr_ParamError(COM_ERR_3031, scrContext, 1u, "Invalid sound axis sound name specified");
      }
      v8 = TEAM_ZERO;
      outTeam = TEAM_ZERO;
      if ( Scr_GetNumParam(scrContext) > 4 && Scr_GetType(scrContext, 4u) )
      {
        ConstString = Scr_GetConstString(scrContext, 4u);
        if ( !Com_Teams_TeamFromString(ConstString, &outTeam) )
        {
          v10 = SL_ConvertToString(ConstString);
          v11 = j_va("unknown team '%s'", v10);
          Scr_Error(COM_ERR_3032, scrContext, v11);
          return;
        }
        v8 = outTeam;
      }
      if ( Scr_GetNumParam(scrContext) > 5 && Scr_GetType(scrContext, 5u) )
        group = Scr_GetConstString(scrContext, 5u);
      else
        group = 0;
      count = 0;
      if ( Scr_GetNumParam(scrContext) > 6 && Scr_GetType(scrContext, 6u) )
      {
        ArrayObject = BGScr_Main_GetArrayObject(scrContext, 6u);
        ArraySize = GetArraySize(scrContext, ArrayObject);
        count = ArraySize;
        if ( ArraySize > 0xF8 )
        {
          v14 = j_va("array is too large (%d > %d)", ArraySize, 248i64);
          Scr_ParamError(COM_ERR_3033, scrContext, 0, v14);
        }
        if ( !Scr_GetEntityArray(scrContext, ArrayObject, 0xF8u, buffer, &count, &v47, v40) )
        {
          NameForType = Scr_GetNameForType(v40[0]);
          v16 = j_va("element %i of array: type %s is not an entity", v47, NameForType);
          Scr_ParamError(COM_ERR_3034, scrContext, 0, v16);
        }
      }
      if ( Scr_GetNumParam(scrContext) > 7 && Scr_GetType(scrContext, 7u) )
      {
        Scr_GetVector(scrContext, 7u, &vectorValue);
      }
      else
      {
        vectorValue.v[0] = 0.0;
        vectorValue.v[1] = 0.0;
        vectorValue.v[2] = 0.0;
      }
      for ( i = 0; i < level.maxclients; ++i )
      {
        if ( i >= 0x800 )
        {
          LODWORD(failureType) = 2048;
          LODWORD(failureIndex) = i;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", failureIndex, failureType) )
            __debugbreak();
        }
        if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
          __debugbreak();
        if ( g_entities[i].r.isInUse != g_entityIsInUse[i] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
          __debugbreak();
        if ( g_entityIsInUse[i] )
        {
          v18 = &level.clients[i];
          if ( v18->sess.connected == CON_CONNECTED )
          {
            MpClient = SV_Client_GetMpClient(i);
            if ( !MpClient->bIsSplitscreenClient || NetConnection::GetNetId(&MpClient->clientConnection) == NS_CLIENT1 )
            {
              team = v18->sess.cs.team;
              if ( (unsigned int)(team - 201) > 1 && (v8 == TEAM_ZERO || v8 == team) )
              {
                v21 = 0i64;
                if ( !count )
                  goto LABEL_55;
                while ( 1 )
                {
                  EntityIdRef = Scr_GetEntityIdRef(scrContext, buffer[v21]);
                  Entity = GetEntity(EntityIdRef);
                  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 2182, ASSERT_TYPE_ASSERT, "( excludedEntity )", (const char *)&queryFormat, "excludedEntity") )
                    __debugbreak();
                  if ( Entity->s.number == i )
                    break;
                  v21 = (unsigned int)(v21 + 1);
                  if ( (unsigned int)v21 >= count )
                    goto LABEL_55;
                }
                if ( (unsigned int)v21 >= count )
                {
LABEL_55:
                  v24 = v42;
                  if ( team == TEAM_ONE )
                    v24 = v7;
                  v25 = &g_entities[i];
                  if ( !v25->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 2195, ASSERT_TYPE_ASSERT, "( clientEntity->client )", (const char *)&queryFormat, "clientEntity->client") )
                    __debugbreak();
                  G_QueueDialogForPlayer(v25, dialogName, v24, &vectorValue, duration, group, 0);
                }
              }
            }
          }
        }
        v8 = outTeam;
      }
      for ( j = 0; (int)j < level.maxagents; ++j )
      {
        if ( !ComCharacterLimits::ms_isGameDataValid && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_character_limits.h", 116, ASSERT_TYPE_ASSERT, "(ms_isGameDataValid)", (const char *)&queryFormat, "ms_isGameDataValid") )
          __debugbreak();
        if ( j >= ComCharacterLimits::ms_gameData.m_agentCount )
        {
          if ( !ComCharacterLimits::ms_isGameDataValid && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_character_limits.h", 116, ASSERT_TYPE_ASSERT, "(ms_isGameDataValid)", (const char *)&queryFormat, "ms_isGameDataValid") )
            __debugbreak();
          LODWORD(failureType) = ComCharacterLimits::ms_gameData.m_agentCount;
          LODWORD(failureIndex) = j;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_character_limits.h", 186, ASSERT_TYPE_ASSERT, "(unsigned)( agentIndex ) < (unsigned)( ComCharacterLimits::GetAgentMaxCount() )", "agentIndex doesn't index ComCharacterLimits::GetAgentMaxCount()\n\t%i not in [0, %i)", failureIndex, failureType) )
            __debugbreak();
        }
        if ( !ComCharacterLimits::ms_isGameDataValid && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_character_limits.h", 168, ASSERT_TYPE_ASSERT, "(ms_isGameDataValid)", (const char *)&queryFormat, "ms_isGameDataValid") )
          __debugbreak();
        v27 = j + ComCharacterLimits::ms_gameData.m_clientCount;
        if ( j + ComCharacterLimits::ms_gameData.m_clientCount >= 0x800 )
        {
          LODWORD(failureType) = 2048;
          LODWORD(failureIndex) = j + ComCharacterLimits::ms_gameData.m_clientCount;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", failureIndex, failureType) )
            __debugbreak();
        }
        if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
          __debugbreak();
        v28 = (int)v27;
        if ( g_entities[v28].r.isInUse != g_entityIsInUse[v27] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
          __debugbreak();
        if ( g_entityIsInUse[v27] )
        {
          if ( !ComCharacterLimits::ms_isGameDataValid && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_character_limits.h", 123, ASSERT_TYPE_ASSERT, "(ms_isGameDataValid)", (const char *)&queryFormat, "ms_isGameDataValid") )
            __debugbreak();
          if ( v27 >= ComCharacterLimits::ms_gameData.m_characterCount )
          {
            if ( !ComCharacterLimits::ms_isGameDataValid && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_character_limits.h", 123, ASSERT_TYPE_ASSERT, "(ms_isGameDataValid)", (const char *)&queryFormat, "ms_isGameDataValid") )
              __debugbreak();
            LODWORD(failureType) = ComCharacterLimits::ms_gameData.m_characterCount;
            LODWORD(failureIndex) = v27;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 2207, ASSERT_TYPE_ASSERT, "(unsigned)( characterIndex ) < (unsigned)( ComCharacterLimits::GetCharacterMaxCount() )", "characterIndex doesn't index ComCharacterLimits::GetCharacterMaxCount()\n\t%i not in [0, %i)", failureIndex, failureType) )
              __debugbreak();
          }
          v29 = &g_entities[v28];
          agent = g_entities[v28].agent;
          if ( agent )
          {
            if ( v29->r.isLinked )
            {
              if ( (v29->r.svFlags & 1) == 0 )
              {
                entityNum = agent->agentState.entityNum;
                if ( entityNum == v27 )
                {
                  if ( SV_IsAgentBot(entityNum) )
                  {
                    v32 = v29->agent->agentState.team;
                    if ( (unsigned int)(v32 - 201) > 1 && (outTeam == TEAM_ZERO || outTeam == v32) )
                    {
                      v33 = 0i64;
                      if ( !count )
                        goto LABEL_110;
                      while ( 1 )
                      {
                        v34 = Scr_GetEntityIdRef(scrContext, buffer[v33]);
                        v35 = GetEntity(v34);
                        if ( !v35 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 2237, ASSERT_TYPE_ASSERT, "( excludedEntity )", (const char *)&queryFormat, "excludedEntity") )
                          __debugbreak();
                        if ( v35->s.number == v27 )
                          break;
                        v33 = (unsigned int)(v33 + 1);
                        if ( (unsigned int)v33 >= count )
                          goto LABEL_110;
                      }
                      if ( (unsigned int)v33 >= count )
                      {
LABEL_110:
                        v36 = v42;
                        if ( v32 == TEAM_ONE )
                          v36 = soundHash;
                        G_QueueDialogForPlayer(v29, dialogName, v36, &vectorValue, duration, group, 0);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

/*
==============
Scr_SetFXKillDefOnDelete
==============
*/
void Scr_SetFXKillDefOnDelete(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 2267, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( Entity->s.eType != ET_FX )
    Scr_Error(COM_ERR_3035, scrContext, "SetFXKillDefOnDelete should only be operated on an entity that is an FX type");
  Entity->s.staticState.player.stowedWeaponHandle.m_mapEntryId = 1;
}

/*
==============
GScr_GetClanWarsBonusForCurrentPlaylist
==============
*/
void GScr_GetClanWarsBonusForCurrentPlaylist(scrContext_t *scrContext, scr_entref_t entref)
{
  Scr_AddFloat(scrContext, 0.0);
}

/*
==============
GScr_MainMP_EntityWillNeverChange
==============
*/
void GScr_MainMP_EntityWillNeverChange(scrContext_t *scrContext, scr_entref_t entref)
{
  LerpEntityState *p_lerp; 

  p_lerp = &GetEntity(entref)->s.lerp;
  if ( GameModeFlagValues::ms_mpValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 201, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a MP-only context", "IsFlagActive( index )") )
    __debugbreak();
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(&p_lerp->eFlags, ACTIVE, 0x1Eu);
}

/*
==============
GScr_MainMP_EntityForceNetfieldHighLoD
==============
*/
void GScr_MainMP_EntityForceNetfieldHighLoD(scrContext_t *scrContext, scr_entref_t entref)
{
  GameModeFlagContainer<enum BgEntityFlagsCommon,enum BgEntityFlagsSP,enum BgEntityFlagsMP,64> *p_flags; 

  p_flags = &GetEntity(entref)->flags;
  if ( Scr_GetInt(scrContext, 0) )
  {
    if ( GameModeFlagValues::ms_mpValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 201, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a MP-only context", "IsFlagActive( index )") )
      __debugbreak();
    p_flags->m_flags[1] |= 0x20u;
  }
  else
  {
    GameModeFlagContainer<enum BgEntityFlagsCommon,enum BgEntityFlagsSP,enum BgEntityFlagsMP,64>::ClearFlagStrict(p_flags, TURRET_ACTIVE_PRONE|0x20);
  }
}

/*
==============
ScrCmd_PlayerHide
==============
*/
void ScrCmd_PlayerHide(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  bool v4; 
  bool v5; 

  Entity = GetEntity(entref);
  if ( !Entity->client )
    Scr_Error(COM_ERR_3040, scrContext, "Must be called on a player.");
  v4 = 0;
  if ( Scr_GetNumParam(scrContext) && Scr_GetType(scrContext, 0) )
    v4 = Scr_GetInt(scrContext, 0) != 0;
  v5 = 0;
  if ( Scr_GetNumParam(scrContext) > 1 && Scr_GetType(scrContext, 1u) )
    v5 = Scr_GetInt(scrContext, 1u) != 0;
  if ( v4 )
  {
    if ( v5 )
      Scr_Error(COM_ERR_6080, scrContext, "Cannot call PlayerHide with both <forceTransmitToAllClients> and <forceTransmitToNoClients> set to true");
    *(_QWORD *)Entity->clientMask.array = 0i64;
    *(_QWORD *)&Entity->clientMask.array[2] = 0i64;
    *(_QWORD *)&Entity->clientMask.array[4] = 0i64;
    Entity->clientMask.array[6] = 0;
  }
  if ( v5 )
  {
    *(_QWORD *)Entity->clientMask.array = -1i64;
    *(_QWORD *)&Entity->clientMask.array[2] = -1i64;
    *(_QWORD *)&Entity->clientMask.array[4] = -1i64;
    Entity->clientMask.array[6] = -1;
  }
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(&Entity->client->ps.eFlags, ACTIVE, 0xCu);
}

/*
==============
ScrCmd_PlayerShow
==============
*/
void ScrCmd_PlayerShow(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  bool v4; 
  bool v5; 

  Entity = GetEntity(entref);
  if ( !Entity->client )
    Scr_Error(COM_ERR_3041, scrContext, "Must be called on a player.");
  v4 = 0;
  if ( Scr_GetNumParam(scrContext) && Scr_GetType(scrContext, 0) )
    v4 = Scr_GetInt(scrContext, 0) != 0;
  v5 = 0;
  if ( Scr_GetNumParam(scrContext) > 1 && Scr_GetType(scrContext, 1u) )
    v5 = Scr_GetInt(scrContext, 1u) != 0;
  if ( v4 )
  {
    if ( v5 )
      Scr_Error(COM_ERR_6081, scrContext, "Cannot call PlayerHide with both <forceTransmitToAllClients> and <forceTransmitToNoClients> set to true");
    *(_QWORD *)Entity->clientMask.array = 0i64;
    *(_QWORD *)&Entity->clientMask.array[2] = 0i64;
    *(_QWORD *)&Entity->clientMask.array[4] = 0i64;
    Entity->clientMask.array[6] = 0;
  }
  if ( v5 )
  {
    *(_QWORD *)Entity->clientMask.array = -1i64;
    *(_QWORD *)&Entity->clientMask.array[2] = -1i64;
    *(_QWORD *)&Entity->clientMask.array[4] = -1i64;
    Entity->clientMask.array[6] = -1;
  }
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(&Entity->client->ps.eFlags, ACTIVE, 0xCu);
}

/*
==============
ScrCmd_ShowOnlyToPlayer
==============
*/
void ScrCmd_ShowOnlyToPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  gclient_s *client; 
  __int64 v6; 

  Entity = GetEntity(entref);
  if ( GameModeFlagValues::ms_mpValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 190, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a MP-only context", "IsFlagActive( index )") )
    __debugbreak();
  if ( GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&Entity->s.lerp.eFlags, ACTIVE, 0x1Eu) )
    Scr_Error(COM_ERR_5868, scrContext, "Cannot change a 'willNeverChange' entity");
  if ( Entity->client )
    Scr_Error(COM_ERR_5963, scrContext, "ShowOnlyToPlayer only works on non-player entities");
  v4 = GScr_GetEntity(0);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 2626, ASSERT_TYPE_ASSERT, "( clientEnt )", (const char *)&queryFormat, "clientEnt") )
    __debugbreak();
  if ( !v4->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 2627, ASSERT_TYPE_ASSERT, "( clientEnt->client )", (const char *)&queryFormat, "clientEnt->client") )
    __debugbreak();
  client = v4->client;
  if ( v4->s.number < level.maxclients )
  {
    if ( Entity->tagInfo || Entity->tagChildren )
    {
      if ( client->ps.linkEnt == Entity->s.number )
      {
        client->ps.linkFlags.m_flags[0] |= GameModeFlagValues::ms_mpValue << 7;
        GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(&Entity->s.lerp.eFlags, ACTIVE, 0xCu);
        *(_QWORD *)Entity->clientMask.array = 0i64;
        *(_QWORD *)&Entity->clientMask.array[2] = 0i64;
        *(_QWORD *)&Entity->clientMask.array[4] = 0i64;
        Entity->clientMask.array[6] = 0;
      }
      else
      {
        LODWORD(v6) = Entity->s.number;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 2646, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "ShowOnlyToPlayer can only be called on a non-linked entity or an entity a player is linked to. Entity number: %d Client: %d", v6, v4->s.number) )
          __debugbreak();
      }
    }
    else
    {
      GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(&Entity->s.lerp.eFlags, ACTIVE, 0xCu);
      Entity->clientMask.array[0] = -1;
      *(_QWORD *)&Entity->clientMask.array[1] = -1i64;
      *(_QWORD *)&Entity->clientMask.array[3] = -1i64;
      *(_QWORD *)&Entity->clientMask.array[5] = -1i64;
      bitarray_base<bitarray<224>>::resetBit(&Entity->clientMask, v4->s.number);
    }
  }
  else
  {
    Scr_Error(COM_ERR_5869, scrContext, "showOnlyToClient error: param must be a client entity\n");
  }
}

/*
==============
ScrCmd_ShowToPlayer
==============
*/
void ScrCmd_ShowToPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *client; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *p_eFlags; 
  unsigned int number; 
  unsigned int *v8; 
  int v9; 
  int v10; 

  Entity = GetEntity(entref);
  if ( GameModeFlagValues::ms_mpValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 190, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a MP-only context", "IsFlagActive( index )") )
    __debugbreak();
  if ( GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&Entity->s.lerp.eFlags, ACTIVE, 0x1Eu) )
    Scr_Error(COM_ERR_3042, scrContext, "Cannot change a 'willNeverChange' entity");
  v4 = GScr_GetEntity(0);
  if ( v4->s.number >= level.maxclients )
  {
    Scr_Error(COM_ERR_3043, scrContext, "showToClient error: param must be a client entity\n");
    return;
  }
  client = (GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *)Entity->client;
  if ( client )
  {
    if ( GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(client + 94, ACTIVE, 0xCu) )
    {
      p_eFlags = &Entity->client->ps.eFlags;
LABEL_13:
      GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(p_eFlags, ACTIVE, 0xCu);
      *(_QWORD *)Entity->clientMask.array = -1i64;
      *(_QWORD *)&Entity->clientMask.array[2] = -1i64;
      *(_QWORD *)&Entity->clientMask.array[4] = -1i64;
      Entity->clientMask.array[6] = -1;
    }
  }
  else if ( GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&Entity->s.lerp.eFlags, ACTIVE, 0xCu) )
  {
    p_eFlags = &Entity->s.lerp.eFlags;
    goto LABEL_13;
  }
  number = v4->s.number;
  if ( number >= 0xE0 )
  {
    v10 = 224;
    v9 = v4->s.number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 290, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v9, v10) )
      __debugbreak();
  }
  v8 = &Entity->clientMask.array[(unsigned __int64)number >> 5];
  *v8 &= ~(0x80000000 >> (number & 0x1F));
}

/*
==============
ScrCmd_HideFromPlayer
==============
*/
void ScrCmd_HideFromPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *client; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *p_eFlags; 
  unsigned int number; 
  unsigned int *v8; 
  int v9; 
  int v10; 

  Entity = GetEntity(entref);
  if ( GameModeFlagValues::ms_mpValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 190, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a MP-only context", "IsFlagActive( index )") )
    __debugbreak();
  if ( GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&Entity->s.lerp.eFlags, ACTIVE, 0x1Eu) )
    Scr_Error(COM_ERR_3044, scrContext, "Cannot change a 'willNeverChange' entity");
  v4 = GScr_GetEntity(0);
  if ( v4->s.number >= level.maxclients )
  {
    Scr_Error(COM_ERR_3045, scrContext, "showToClient error: param must be a client entity\n");
    return;
  }
  client = (GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *)Entity->client;
  if ( client )
  {
    if ( GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(client + 94, ACTIVE, 0xCu) )
    {
      p_eFlags = &Entity->client->ps.eFlags;
LABEL_13:
      GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(p_eFlags, ACTIVE, 0xCu);
      *(_QWORD *)Entity->clientMask.array = -1i64;
      *(_QWORD *)&Entity->clientMask.array[2] = -1i64;
      *(_QWORD *)&Entity->clientMask.array[4] = -1i64;
      Entity->clientMask.array[6] = -1;
    }
  }
  else if ( GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&Entity->s.lerp.eFlags, ACTIVE, 0xCu) )
  {
    p_eFlags = &Entity->s.lerp.eFlags;
    goto LABEL_13;
  }
  number = v4->s.number;
  if ( number >= 0xE0 )
  {
    v10 = 224;
    v9 = v4->s.number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 263, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v9, v10) )
      __debugbreak();
  }
  v8 = &Entity->clientMask.array[(unsigned __int64)number >> 5];
  *v8 |= 0x80000000 >> (number & 0x1F);
}

/*
==============
ScrCmd_SetClientOwner
==============
*/
void ScrCmd_SetClientOwner(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 

  Entity = GetEntity(entref);
  if ( Entity->client )
  {
    Scr_ObjectError(COM_ERR_3046, scrContext, "SetClientOwner() cannot be called on a client.");
  }
  else if ( Scr_GetNumParam(scrContext) == 1 )
  {
    if ( GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagStrict(&Entity->s.lerp.eFlags, (EntityStateFlagsMP)30) )
      Scr_Error(COM_ERR_3048, scrContext, "Cannot change a 'willNeverChange' entity");
    v4 = GScr_GetEntity(0);
    if ( !v4->client )
      Scr_ParamError(COM_ERR_3049, scrContext, 0, "entity is not a client");
    Entity->s.clientNum = v4->s.number + 1;
  }
  else
  {
    Scr_Error(COM_ERR_3047, scrContext, "SetClientOwner() needs to have a client passed in. ");
  }
}

/*
==============
Scr_GetWeaponExplosionRadius
==============
*/
void Scr_GetWeaponExplosionRadius(scrContext_t *scrContext)
{
  int v2; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  v2 = BG_ExplosionRadius(&outWeapon, outIsAlternate);
  Scr_AddInt(scrContext, v2);
}

/*
==============
Scr_GetPredictedEntityPosition
==============
*/
void Scr_GetPredictedEntityPosition(scrContext_t *scrContext)
{
  gentity_s *Entity; 
  double Float; 
  int v4; 
  playerState_s *EntityPlayerState; 
  __int128 v6; 
  __int128 v7; 
  pathnode_t *v11; 
  pathnode_t *BestNode; 
  ai_search_t search; 
  vec3_t forward; 
  vec3_t pos; 

  Entity = GScr_GetEntity(0);
  Float = Scr_GetFloat(scrContext, 1u);
  v4 = (int)(float)(*(float *)&Float * 1000.0);
  EntityPlayerState = G_GetEntityPlayerState(Entity);
  if ( EntityPlayerState )
  {
    v6 = LODWORD(EntityPlayerState->velocity.v[0]);
    v7 = v6;
    *(float *)&v7 = fsqrt((float)((float)(*(float *)&v6 * *(float *)&v6) + (float)(EntityPlayerState->velocity.v[1] * EntityPlayerState->velocity.v[1])) + (float)(EntityPlayerState->velocity.v[2] * EntityPlayerState->velocity.v[2]));
    _XMM7 = v7;
    __asm
    {
      vcmpless xmm0, xmm7, cs:__real@80000000
      vblendvps xmm0, xmm7, xmm6, xmm0
    }
    forward.v[0] = *(float *)&v6 * (float)(1.0 / *(float *)&_XMM0);
    forward.v[1] = (float)(1.0 / *(float *)&_XMM0) * EntityPlayerState->velocity.v[1];
    forward.v[2] = (float)(1.0 / *(float *)&_XMM0) * EntityPlayerState->velocity.v[2];
  }
  else
  {
    AngleVectors(&Entity->r.currentAngles, &forward, NULL, NULL);
    LODWORD(_XMM7) = 0;
  }
  *(_QWORD *)search.searchOrigin.v = *(_QWORD *)Entity->r.currentOrigin.v;
  search.searchOrigin.v[2] = Entity->r.currentOrigin.v[2];
  if ( Entity->sentient )
    v11 = Sentient_NearestNode(Entity->sentient);
  else
    v11 = Path_NearestNode(&Entity->r.currentOrigin, Entity->clipmask, NULL);
  search.nodeNearestSearchOrigin = v11;
  if ( v11 )
  {
    search.highestPriorityDistScalar = FLOAT_1_0;
    search.maxSearchDistScalar = FLOAT_1_0;
    AI_BuildSearchArea(&search, &forward, *(float *)&_XMM7, v4, NULL, 0, AI_SEARCH_THOROUGH);
    if ( search.totalNodeCount )
    {
      BestNode = AI_SearchGetBestNode(&search);
      pathnode_t::GetPos(BestNode, &pos);
      Scr_AddVector(scrContext, pos.v);
    }
  }
}

/*
==============
Scr_MakeEntityNoMeleeTarget
==============
*/
void Scr_MakeEntityNoMeleeTarget(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v3; 

  Entity = GetEntity(entref);
  v3 = Entity;
  if ( GameModeFlagValues::ms_mpValue == ACTIVE )
  {
    Entity->flags.m_flags[1] |= 4u;
  }
  else
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 201, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a MP-only context", "IsFlagActive( index )") )
      __debugbreak();
    v3->flags.m_flags[1] |= 4u;
  }
}

/*
==============
ScrCmd_MissileDontTrackKillCam
==============
*/
void ScrCmd_MissileDontTrackKillCam(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( Entity->s.eType == ET_MISSILE )
    Entity->s.lerp.u.anonymous.data[4] |= 0x80u;
  else
    Scr_Error(COM_ERR_3050, scrContext, "MissileDontTrackKillCam must be called on a missile.");
}

/*
==============
ScrCmd_SetScriptMoverKillCam
==============
*/
void ScrCmd_SetScriptMoverKillCam(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  unsigned int v4; 
  const char **v5; 
  const char *String; 
  const char *v7; 
  ComErrorCode v8; 
  int v9; 
  unsigned int Int; 
  unsigned int v11; 
  __int64 v12[10]; 
  __m256i v13; 
  int v14; 

  v14 = 9;
  v12[0] = (__int64)"helicopter";
  v12[1] = (__int64)"airstrike";
  v12[2] = (__int64)"explosive";
  v12[3] = (__int64)"offset explosive";
  v12[4] = (__int64)"fast explosive";
  v12[5] = (__int64)"rocket";
  v12[6] = (__int64)"turret";
  v12[7] = (__int64)"javelin";
  v12[8] = (__int64)"missile";
  v13 = _ymm;
  Entity = GetEntity(entref);
  if ( !Scr_GetNumParam(scrContext) )
  {
    Scr_Error(COM_ERR_3051, scrContext, "First argument missing in SetScriptMoverKillCam() invocation.");
    return;
  }
  if ( Entity->s.eType != ET_SCRIPTMOVER )
  {
    Scr_ParamError(COM_ERR_3053, scrContext, 0, "SetScriptMoverKillCam() can only be invoked on a script mover.");
    return;
  }
  if ( GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagStrict(&Entity->s.lerp.eFlags, (EntityStateFlagsMP)30) )
  {
    Scr_Error(COM_ERR_3054, scrContext, "SetScriptMoverKillCam() was invoked on a 'willNeverChange' entity");
    return;
  }
  v4 = 0;
  v5 = (const char **)v12;
  String = Scr_GetString(scrContext, 0);
  while ( !String || I_strnicmp(String, *v5, 0x7FFFFFFFui64) )
  {
    ++v4;
    ++v5;
    if ( v4 >= 9 )
      goto LABEL_11;
  }
  v9 = v13.m256i_i32[v4];
  if ( !v9 )
  {
LABEL_11:
    v7 = j_va("SetScriptMoverKillCam needs to have a correct killcam type passed in. This can be 'helicopter', 'airstrike', 'explosive', 'fast explosive', 'rocket', 'turret', 'javelin', 'missile'.\nWe had %s.", String);
    v8 = COM_ERR_3052;
LABEL_12:
    Scr_Error(v8, scrContext, v7);
    return;
  }
  Entity->s.eventParm = v9;
  if ( v9 == 4 )
  {
    if ( Scr_GetNumParam(scrContext) < 3 )
    {
      v7 = "SetScriptMoverKillCam(): since type 'offset explosive' was specified, offset 'up' and 'back' arguments are required.";
      v8 = COM_ERR_6533;
      goto LABEL_12;
    }
    Int = Scr_GetInt(scrContext, 1u);
    v11 = Scr_GetInt(scrContext, 2u);
    BG_ScriptMoverKillcam_PackOffset(Int, v11, &Entity->s.eventParm2);
  }
}

/*
==============
ScrCmd_MakeScrambler
==============
*/
void ScrCmd_MakeScrambler(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t ConstLowercaseString; 
  gentity_s *v6; 

  Entity = GetEntity(entref);
  G_SetAffector(Entity, (const EntityStateFlagsMP)20);
  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 1u);
    v6 = GetEntity(entref);
    if ( v6->s.eType != ET_SCRIPTMOVER && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 3008, ASSERT_TYPE_ASSERT, "(ent->s.eType == ET_SCRIPTMOVER)", (const char *)&queryFormat, "ent->s.eType == ET_SCRIPTMOVER") )
      __debugbreak();
    if ( ConstLowercaseString == scr_const.little )
    {
      BG_SetJammingType(&v6->s, JAMMING_TYPE_LITTLE);
    }
    else if ( ConstLowercaseString == scr_const.medium )
    {
      BG_SetJammingType(&v6->s, JAMMING_TYPE_MEDIUM);
    }
    else if ( ConstLowercaseString == scr_const.large )
    {
      BG_SetJammingType(&v6->s, JAMMING_TYPE_LARGE);
    }
    else
    {
      Scr_Error(COM_ERR_3055, scrContext, "SetJammerFlag: Invalid parameter. Must be one of: (little, medium, large)");
    }
  }
}

/*
==============
ScrCmd_ClearScrambler
==============
*/
void ScrCmd_ClearScrambler(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  G_ClearAffector(Entity, (const EntityStateFlagsMP)20);
  if ( Entity->s.eType != ET_SCRIPTMOVER && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 3065, ASSERT_TYPE_ASSERT, "(ent->s.eType == ET_SCRIPTMOVER)", (const char *)&queryFormat, "ent->s.eType == ET_SCRIPTMOVER") )
    __debugbreak();
  BG_ClearJammingType(&Entity->s);
}

/*
==============
ScrCmd_TriggerOneOffRadarSweep
==============
*/
void ScrCmd_TriggerOneOffRadarSweep(scrContext_t *scrContext)
{
  gclient_s *client; 

  if ( (int)Scr_GetNumParam(scrContext) < 1 )
    Scr_Error(COM_ERR_3056, scrContext, "TriggerOneOffRadarSweep(): Invalid parameters. Check documentation.\n");
  client = GScr_GetEntity(0)->client;
  if ( client )
    client->ps.radarOneOffSweepTime = level.time;
  else
    Scr_Error(COM_ERR_3057, scrContext, "TriggerOneOffRadarSweep(): Owner must be a player.\n");
}

/*
==============
ScrCmd_MakePortableRadar
==============
*/
void ScrCmd_MakePortableRadar(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  G_SetAffector(Entity, LEGACY_LADDER_CENTERLINE|LEGACY_MOUNT|0x10);
}

/*
==============
ScrCmd_ClearPortableRadar
==============
*/
void ScrCmd_ClearPortableRadar(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  G_ClearAffector(Entity, LEGACY_LADDER_CENTERLINE|LEGACY_MOUNT|0x10);
}

/*
==============
ScrCmd_PingLocationEnemyTeams
==============
*/
void ScrCmd_PingLocationEnemyTeams(scrContext_t *scrContext)
{
  unsigned int NumParam; 
  __int16 number; 
  int integer; 
  const dvar_t *v5; 
  int Int; 
  const dvar_t *v7; 
  scr_string_t ConstString; 
  const char *v9; 
  const char *v10; 
  gentity_s *v11; 
  signed int v12; 
  bitarray_base<bitarray<224> > *p_clientMask; 
  gentity_s *v14; 
  team_t v15; 
  __int64 v16; 
  __int64 v17; 
  gclient_s *client; 
  __int64 v19; 
  __int64 v20; 
  team_t outTeam; 
  vec3_t vectorValue; 

  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam - 2 > 3 )
    Scr_Error(COM_ERR_3058, scrContext, "PingLocationEnemyTeams(): Invalid parameters. Check documentation.\n");
  Scr_GetVector(scrContext, 0, &vectorValue);
  if ( NumParam < 3 )
    number = 2047;
  else
    number = GScr_GetEntity(2u)->s.number;
  if ( NumParam < 4 )
  {
    v5 = DCONST_DVARINT_bg_compassNumDecoyActors;
    if ( !DCONST_DVARINT_bg_compassNumDecoyActors && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_compassNumDecoyActors") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v5);
    integer = v5->current.integer;
  }
  else
  {
    integer = Scr_GetInt(scrContext, 3u);
    if ( integer <= 0 )
      Scr_Error(COM_ERR_3059, scrContext, "PingLocationEnemyTeams(): Invalid number of decoys.\n");
  }
  if ( NumParam < 5 )
  {
    v7 = DCONST_DVARINT_bg_compassDecoyPingMagnitude;
    if ( !DCONST_DVARINT_bg_compassDecoyPingMagnitude && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_compassDecoyPingMagnitude") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v7);
    Int = v7->current.integer;
  }
  else
  {
    Int = Scr_GetInt(scrContext, 4u);
    if ( Int < 0 )
      Scr_Error(COM_ERR_3060, scrContext, "PingLocationEnemyTeams(): Invalid magnitude.\n");
  }
  ConstString = Scr_GetConstString(scrContext, 1u);
  if ( Com_Teams_TeamFromString(ConstString, &outTeam) )
  {
    v11 = G_Utils_SpawnEventEntity(&vectorValue, 157);
    v12 = 0;
    p_clientMask = &v11->clientMask;
    v11->clientMask.array[0] = -1;
    *(_QWORD *)&v11->clientMask.array[1] = -1i64;
    *(_QWORD *)&v11->clientMask.array[3] = -1i64;
    *(_QWORD *)&v11->clientMask.array[5] = -1i64;
    v11->s.eventParm = integer;
    v11->s.time2 = Int;
    v11->s.otherEntityNum = number;
    v14 = g_entities;
    if ( (int)SvClient::ms_clientCount > 0 )
    {
      v15 = outTeam;
      v16 = 0i64;
      v17 = 0i64;
      do
      {
        if ( (unsigned int)v12 >= 0x800 )
        {
          LODWORD(v20) = 2048;
          LODWORD(v19) = v12;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v19, v20) )
            __debugbreak();
        }
        if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
          __debugbreak();
        if ( g_entities[v17].r.isInUse != g_entityIsInUse[v16] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
          __debugbreak();
        if ( g_entityIsInUse[v16] )
        {
          client = v14->client;
          if ( client )
          {
            if ( client->sess.cs.team != v15 )
              bitarray_base<bitarray<224>>::resetBit(p_clientMask, v14->s.number);
          }
        }
        ++v12;
        ++v16;
        ++v17;
        ++v14;
      }
      while ( v12 < (int)SvClient::ms_clientCount );
    }
  }
  else
  {
    v9 = SL_ConvertToString(ConstString);
    v10 = j_va("unknown team '%s'", v9);
    Scr_Error(COM_ERR_3061, scrContext, v10);
  }
}

/*
==============
ScrCmd_TriggerPortableRadarPing
==============
*/
void ScrCmd_TriggerPortableRadarPing(scrContext_t *scrContext)
{
  unsigned int NumParam; 
  gentity_s *Entity; 
  int value; 
  const dvar_t *v5; 
  int integer; 
  const dvar_t *v7; 
  const char *String; 
  unsigned int PerkCodeIndexForName; 
  unsigned int number; 
  gentity_s *v11; 
  vec3_t vectorValue; 

  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam - 2 > 3 )
    Scr_Error(COM_ERR_3062, scrContext, "TriggerPortableRadarPing(): Invalid parameters. Check documentation.\n");
  Scr_GetVector(scrContext, 0, &vectorValue);
  Entity = GScr_GetEntity(1u);
  if ( NumParam < 3 )
  {
    v5 = DCONST_DVARFLT_bg_compassPortableRadarTriggeredRadius;
    if ( !DCONST_DVARFLT_bg_compassPortableRadarTriggeredRadius && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_compassPortableRadarTriggeredRadius") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v5);
    value = (int)v5->current.value;
  }
  else
  {
    value = Scr_GetInt(scrContext, 2u);
    if ( value < 0 )
      Scr_Error(COM_ERR_3063, scrContext, "TriggerPortableRadarPing(): Invalid radius.\n");
  }
  if ( NumParam < 4 )
  {
    v7 = DCONST_DVARINT_bg_compassPortableRadarTriggeredSweepTime;
    if ( !DCONST_DVARINT_bg_compassPortableRadarTriggeredSweepTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_compassPortableRadarTriggeredSweepTime") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v7);
    integer = v7->current.integer;
  }
  else
  {
    integer = Scr_GetInt(scrContext, 3u);
    if ( integer < 0 )
      Scr_Error(COM_ERR_3064, scrContext, "TriggerPortableRadarPing(): Invalid sweep time.\n");
  }
  if ( NumParam < 5 )
  {
    PerkCodeIndexForName = 68;
  }
  else
  {
    String = Scr_GetString(scrContext, 4u);
    PerkCodeIndexForName = BG_GetPerkCodeIndexForName(String);
    if ( PerkCodeIndexForName == 68 )
      Scr_Error(COM_ERR_6534, scrContext, "TriggerPortableRadarPing(): Invalid perk name.\n");
  }
  if ( SV_BotIsBotEnt(Entity) )
    SV_BotKnownEnemiesRadial(Entity, &vectorValue, (float)value, 0x1Au);
  if ( Entity->client )
  {
    number = Entity->s.number;
    v11 = G_Utils_SpawnEventEntity(&vectorValue, 198);
    *(_QWORD *)v11->clientMask.array = -1i64;
    *(_QWORD *)&v11->clientMask.array[2] = -1i64;
    *(_QWORD *)&v11->clientMask.array[4] = -1i64;
    v11->clientMask.array[6] = -1;
    if ( number >= 0xE0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 290, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", number, 224) )
      __debugbreak();
    v11->clientMask.array[(unsigned __int64)number >> 5] &= ~(0x80000000 >> (number & 0x1F));
    v11->s.time2 = integer;
    v11->s.eventParm = value;
    v11->s.eventParm2 = PerkCodeIndexForName;
  }
  else if ( !SV_BotIsBotEnt(Entity) )
  {
    Scr_Error(COM_ERR_3065, scrContext, "TriggerPortableRadarPing(): Owner must be a player or agent player.\n");
  }
}

/*
==============
ScrCmd_TriggerPortableRadarPingTeam
==============
*/
void ScrCmd_TriggerPortableRadarPingTeam(scrContext_t *scrContext)
{
  unsigned int NumParam; 
  scr_string_t ConstString; 
  const char *v4; 
  const char *v5; 
  int value; 
  const dvar_t *v7; 
  int integer; 
  const dvar_t *v9; 
  gentity_s *v10; 
  bitarray_base<bitarray<224> > *p_clientMask; 
  signed int v12; 
  gentity_s *v13; 
  team_t v14; 
  __int64 v15; 
  __int64 v16; 
  gclient_s *client; 
  __int64 v18; 
  __int64 v19; 
  team_t outTeam; 
  vec3_t vectorValue; 

  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam - 2 > 2 )
    Scr_Error(COM_ERR_3066, scrContext, "TriggerPortableRadarPingTeam(): Invalid parameters. Check documentation.\n");
  Scr_GetVector(scrContext, 0, &vectorValue);
  ConstString = Scr_GetConstString(scrContext, 1u);
  if ( Com_Teams_TeamFromString(ConstString, &outTeam) )
  {
    if ( NumParam < 3 )
    {
      v7 = DCONST_DVARFLT_bg_compassPortableRadarTriggeredRadius;
      if ( !DCONST_DVARFLT_bg_compassPortableRadarTriggeredRadius && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_compassPortableRadarTriggeredRadius") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v7);
      value = (int)v7->current.value;
    }
    else
    {
      value = Scr_GetInt(scrContext, 2u);
      if ( value < 0 )
        Scr_Error(COM_ERR_3068, scrContext, "TriggerPortableRadarPingTeam(): Invalid radius.\n");
    }
    if ( NumParam < 4 )
    {
      v9 = DCONST_DVARINT_bg_compassPortableRadarTriggeredSweepTime;
      if ( !DCONST_DVARINT_bg_compassPortableRadarTriggeredSweepTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_compassPortableRadarTriggeredSweepTime") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v9);
      integer = v9->current.integer;
    }
    else
    {
      integer = Scr_GetInt(scrContext, 3u);
      if ( integer < 0 )
        Scr_Error(COM_ERR_3069, scrContext, "TriggerPortableRadarPingTeam(): Invalid sweep time.\n");
    }
    v10 = G_Utils_SpawnEventEntity(&vectorValue, 198);
    v10->s.time2 = integer;
    p_clientMask = &v10->clientMask;
    v10->s.eventParm = value;
    v12 = 0;
    v10->clientMask.array[0] = -1;
    *(_QWORD *)&v10->clientMask.array[1] = -1i64;
    *(_QWORD *)&v10->clientMask.array[3] = -1i64;
    *(_QWORD *)&v10->clientMask.array[5] = -1i64;
    v13 = g_entities;
    if ( (int)SvClient::ms_clientCount > 0 )
    {
      v14 = outTeam;
      v15 = 0i64;
      v16 = 0i64;
      do
      {
        if ( (unsigned int)v12 >= 0x800 )
        {
          LODWORD(v19) = 2048;
          LODWORD(v18) = v12;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v18, v19) )
            __debugbreak();
        }
        if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
          __debugbreak();
        if ( g_entities[v16].r.isInUse != g_entityIsInUse[v15] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
          __debugbreak();
        if ( g_entityIsInUse[v15] )
        {
          client = v13->client;
          if ( client )
          {
            if ( client->sess.cs.team == v14 )
            {
              if ( SV_BotIsBotEnt(v13) )
                SV_BotKnownEnemiesRadial(v13, &vectorValue, (float)value, 0x1Au);
              bitarray_base<bitarray<224>>::resetBit(p_clientMask, v13->s.number);
            }
          }
        }
        ++v12;
        ++v15;
        ++v16;
        ++v13;
      }
      while ( v12 < (int)SvClient::ms_clientCount );
    }
  }
  else
  {
    v4 = SL_ConvertToString(ConstString);
    v5 = j_va("unknown team '%s'", v4);
    Scr_Error(COM_ERR_3067, scrContext, v5);
  }
}

/*
==============
ScrCmd_IsDedicatedServer
==============
*/
void ScrCmd_IsDedicatedServer(scrContext_t *scrContext)
{
  Scr_AddInt(scrContext, 0);
}

/*
==============
ScrCmd_GetDediServerGuid
==============
*/
void ScrCmd_GetDediServerGuid(scrContext_t *scrContext)
{
  Scr_AddString(scrContext, (const char *)&queryFormat.fmt + 3);
}

/*
==============
ScrCmd_GetPlaylistVersion
==============
*/
void ScrCmd_GetPlaylistVersion(scrContext_t *scrContext)
{
  int VersionNumber; 

  VersionNumber = Playlist_GetVersionNumber();
  Scr_AddInt(scrContext, VersionNumber);
}

/*
==============
ScrCmd_GetPlaylistID
==============
*/
void ScrCmd_GetPlaylistID(scrContext_t *scrContext)
{
  const dvar_t *v2; 
  int PlaylistIdForNum; 

  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
    Scr_Error(COM_ERR_3070, scrContext, "Not supported for front-end server");
  v2 = DVARINT_playlist;
  if ( !DVARINT_playlist && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "playlist") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  PlaylistIdForNum = Playlist_GetPlaylistIdForNum(v2->current.integer);
  Scr_AddInt(scrContext, PlaylistIdForNum);
}

/*
==============
ScrCmd_GetPlaylistName
==============
*/
void ScrCmd_GetPlaylistName(scrContext_t *scrContext)
{
  const dvar_t *v2; 
  int PlaylistIdForNum; 
  const char *PlaylistName; 

  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
    Scr_Error(COM_ERR_6535, scrContext, "Not supported for front-end server");
  v2 = DVARINT_playlist;
  if ( !DVARINT_playlist && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "playlist") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  PlaylistIdForNum = Playlist_GetPlaylistIdForNum(v2->current.integer);
  PlaylistName = Playlist_GetPlaylistName(PlaylistIdForNum);
  Scr_AddString(scrContext, PlaylistName);
}

/*
==============
ScrCmd_GetActiveClientCount
==============
*/
void ScrCmd_GetActiveClientCount(scrContext_t *scrContext)
{
  int v2; 
  int Int; 
  signed int i; 
  SvClientConnectionState state; 

  v2 = 0;
  if ( Scr_GetNumParam(scrContext) )
    Int = Scr_GetInt(scrContext, 0);
  else
    Int = 0;
  for ( i = 0; i < (int)SvClient::ms_clientCount; ++i )
  {
    state = SvClient::GetCommonClient(i)->state;
    if ( Int && (unsigned __int8)state >= CS_CONNECTED || state == CS_ACTIVE )
      ++v2;
  }
  Scr_AddInt(scrContext, v2);
}

/*
==============
ScrCmd_EnablePlayerUse
==============
*/
void ScrCmd_EnablePlayerUse(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  unsigned __int16 v5; 
  gagent_s *agent; 
  const char *v7; 
  unsigned __int16 v8; 
  int v9; 

  entnum = entref.entnum;
  Entity = GScr_GetEntity(0);
  if ( SV_IsAgentEntity(Entity) )
  {
    v5 = truncate_cast<unsigned short,unsigned int>(entnum);
    if ( !SV_AgentSetEntUsable(Entity, v5) )
    {
      agent = Entity->agent;
      v9 = agent->useEntsEnabled[1];
      v7 = j_va("Agent entity %i could not enable entity %i for use, probably exceeded max enabled ents (%i, %i)", (unsigned int)Entity->s.number, entnum, agent->useEntsEnabled[0], v9);
      Scr_Error(COM_ERR_3071, scrContext, v7);
    }
  }
  else if ( Entity->client )
  {
    v8 = truncate_cast<unsigned short,unsigned int>(entnum);
    G_Client_SetEntUsable(Entity->client, v8);
  }
  else
  {
    Scr_ParamError(COM_ERR_3072, scrContext, 0, "entity is not a player or agent\n");
  }
}

/*
==============
ScrCmd_DisablePlayerUse
==============
*/
void ScrCmd_DisablePlayerUse(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  unsigned __int16 v5; 
  unsigned __int16 v6; 

  entnum = entref.entnum;
  Entity = GScr_GetEntity(0);
  if ( SV_IsAgentEntity(Entity) )
  {
    v5 = truncate_cast<unsigned short,unsigned int>(entnum);
    SV_AgentSetEntUnusable(Entity, v5);
  }
  else if ( Entity->client )
  {
    v6 = truncate_cast<unsigned short,unsigned int>(entnum);
    G_Client_SetEntUnusable(Entity->client, v6);
  }
  else
  {
    Scr_ParamError(COM_ERR_3073, scrContext, 0, "entity is not a player or agent\n");
  }
}

/*
==============
ScrCmd_EnablePlayerUseForAllPlayers
==============
*/
void ScrCmd_EnablePlayerUseForAllPlayers(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  int v3; 
  int maxclients; 
  __int64 v5; 
  gentity_s *v6; 
  gclient_s *client; 

  entnum = entref.entnum;
  v3 = 0;
  maxclients = level.maxclients;
  if ( level.maxclients > 0 )
  {
    v5 = 0i64;
    do
    {
      v6 = &g_entities[v5];
      if ( &g_entities[v5] )
      {
        client = v6->client;
        if ( client )
        {
          if ( entnum > 0xFFFF )
          {
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned short __cdecl truncate_cast_impl<unsigned short,unsigned int>(unsigned int)", "unsigned", (unsigned __int16)entnum, "unsigned", entnum) )
              __debugbreak();
            client = v6->client;
          }
          G_Client_SetEntUsable(client, entnum);
          maxclients = level.maxclients;
        }
      }
      ++v3;
      ++v5;
    }
    while ( v3 < maxclients );
  }
}

/*
==============
ScrCmd_DisablePlayerUseForAllPlayers
==============
*/
void ScrCmd_DisablePlayerUseForAllPlayers(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  int v3; 
  int maxclients; 
  __int64 v5; 
  gentity_s *v6; 
  gclient_s *client; 

  entnum = entref.entnum;
  v3 = 0;
  maxclients = level.maxclients;
  if ( level.maxclients > 0 )
  {
    v5 = 0i64;
    do
    {
      v6 = &g_entities[v5];
      if ( &g_entities[v5] )
      {
        client = v6->client;
        if ( client )
        {
          if ( entnum > 0xFFFF )
          {
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned short __cdecl truncate_cast_impl<unsigned short,unsigned int>(unsigned int)", "unsigned", (unsigned __int16)entnum, "unsigned", entnum) )
              __debugbreak();
            client = v6->client;
          }
          G_Client_SetEntUnusable(client, entnum);
          maxclients = level.maxclients;
        }
      }
      ++v3;
      ++v5;
    }
    while ( v3 < maxclients );
  }
}

/*
==============
GScr_TurretMP_SetMode
==============
*/
void GScr_TurretMP_SetMode(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  const char *v5; 
  const char *v6; 
  scr_string_t ConstString; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_3074, scrContext, v6);
  }
  ConstString = Scr_GetConstString(scrContext, 0);
  if ( ConstString == scr_const.manual )
  {
    G_Turret_SetMode(v4, 0);
  }
  else if ( ConstString == scr_const.manual_ai )
  {
    Scr_ParamError(COM_ERR_3075, scrContext, 0, "'manual_ai' is not support in MP");
  }
  else if ( ConstString == scr_const.auto_nonai )
  {
    G_Turret_SetMode(v4, 4);
  }
  else if ( ConstString == scr_const.auto_ai )
  {
    Scr_ParamError(COM_ERR_3076, scrContext, 0, "'auto_ai' is not support in MP");
  }
  else if ( ConstString == scr_const.manual_target )
  {
    G_Turret_SetMode(v4, 2052);
  }
  else if ( ConstString == scr_const.sentry )
  {
    G_Turret_SetMode(v4, 12);
  }
  else if ( ConstString == scr_const.sentry_offline )
  {
    G_Turret_SetMode(v4, 1032);
  }
  else
  {
    Scr_Error(COM_ERR_3077, scrContext, "Error setting the mode of a turret.\n");
  }
}

/*
==============
GScr_TurretMP_GetMode
==============
*/
void GScr_TurretMP_GetMode(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  const char *v5; 
  const char *v6; 
  __int64 v7; 
  bool v8; 
  GTurret **v9; 
  int flags; 
  scr_string_t sentry; 
  __int64 v12; 
  int v13; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_3078, scrContext, v6);
  }
  if ( !v4->turretHandle.m_objIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_object_handle.h", 36, ASSERT_TYPE_ASSERT, "(IsDefined())", "%s\n\tCan't get the index of an undefined handle", "IsDefined()") )
    __debugbreak();
  v7 = v4->turretHandle.m_objIndex - 1;
  if ( !(_BYTE)GTurret::ms_allocatedType && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_turret.h", 226, ASSERT_TYPE_ASSERT, "( ms_allocatedType != GameModeType::NONE )", (const char *)&queryFormat, "ms_allocatedType != GameModeType::NONE") )
    __debugbreak();
  if ( (unsigned int)v7 >= 0x80 )
  {
    v13 = 128;
    LODWORD(v12) = v7;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_turret.h", 227, ASSERT_TYPE_ASSERT, "(unsigned)( turretIndex ) < (unsigned)( ( sizeof( *array_counter( ms_turretArray ) ) + 0 ) )", "turretIndex doesn't index ARRAY_COUNT( ms_turretArray )\n\t%i not in [0, %i)", v12, v13) )
      __debugbreak();
  }
  v8 = GTurret::ms_turretArray[v7] == NULL;
  v9 = &GTurret::ms_turretArray[v7];
  if ( v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_turret.h", 228, ASSERT_TYPE_ASSERT, "( ms_turretArray[turretIndex] )", (const char *)&queryFormat, "ms_turretArray[turretIndex]") )
    __debugbreak();
  flags = (*v9)->m_data.flags;
  if ( (flags & 0xC) != 0 )
  {
    sentry = scr_const.sentry;
  }
  else
  {
    sentry = scr_const.auto_nonai;
    if ( (flags & 4) == 0 )
      sentry = scr_const.manual;
  }
  Scr_AddConstString(scrContext, sentry);
}

/*
==============
GScr_PlayCinematicForPlayer
==============
*/
void GScr_PlayCinematicForPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *String; 
  const char *v5; 
  unsigned int number; 
  const char *v7; 
  SvClient *CommonClient; 

  Entity = GetEntity(entref);
  String = Scr_GetString(scrContext, 0);
  v5 = j_va("%c \"%s\" %d", 51i64, String, 0i64);
  number = Entity->s.number;
  v7 = v5;
  if ( number == -1 )
  {
    SV_Game_BroadcastServerCommand(SV_CMD_CAN_IGNORE, v5);
  }
  else
  {
    CommonClient = SvClient::GetCommonClient(number);
    CommonClient->SendServerCommand(CommonClient, SV_CMD_CAN_IGNORE, v7);
  }
}

/*
==============
GScr_PlayCinematicForPlayerLooping
==============
*/
void GScr_PlayCinematicForPlayerLooping(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *String; 
  const char *v5; 
  unsigned int number; 
  const char *v7; 
  SvClient *CommonClient; 

  Entity = GetEntity(entref);
  String = Scr_GetString(scrContext, 0);
  v5 = j_va("%c \"%s\"", 53i64, String);
  number = Entity->s.number;
  v7 = v5;
  if ( number == -1 )
  {
    SV_Game_BroadcastServerCommand(SV_CMD_CAN_IGNORE, v5);
  }
  else
  {
    CommonClient = SvClient::GetCommonClient(number);
    CommonClient->SendServerCommand(CommonClient, SV_CMD_CAN_IGNORE, v7);
  }
}

/*
==============
GScr_PreloadCinematicForPlayer
==============
*/
void GScr_PreloadCinematicForPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *String; 
  const char *v5; 
  unsigned int number; 
  const char *v7; 
  SvClient *CommonClient; 

  Entity = GetEntity(entref);
  String = Scr_GetString(scrContext, 0);
  v5 = j_va("%c \"%s\" %d", 51i64, String, 1i64);
  number = Entity->s.number;
  v7 = v5;
  if ( number == -1 )
  {
    SV_Game_BroadcastServerCommand(SV_CMD_CAN_IGNORE, v5);
  }
  else
  {
    CommonClient = SvClient::GetCommonClient(number);
    CommonClient->SendServerCommand(CommonClient, SV_CMD_CAN_IGNORE, v7);
  }
}

/*
==============
GScr_StopCinematicForPlayer
==============
*/
void GScr_StopCinematicForPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *v3; 
  unsigned int number; 
  const char *v5; 
  SvClient *CommonClient; 

  Entity = GetEntity(entref);
  v3 = j_va("%c", 52i64);
  number = Entity->s.number;
  v5 = v3;
  if ( number == -1 )
  {
    SV_Game_BroadcastServerCommand(SV_CMD_CAN_IGNORE, v3);
  }
  else
  {
    CommonClient = SvClient::GetCommonClient(number);
    CommonClient->SendServerCommand(CommonClient, SV_CMD_CAN_IGNORE, v5);
  }
}

/*
==============
GScr_PlayCinematicForAll
==============
*/
void GScr_PlayCinematicForAll(scrContext_t *scrContext)
{
  const char *String; 
  const char *v2; 

  String = Scr_GetString(scrContext, 0);
  v2 = j_va("%c \"%s\" %d", 51i64, String, 0i64);
  SV_Game_BroadcastServerCommand(SV_CMD_CAN_IGNORE, v2);
}

/*
==============
GScr_PlayEncryptedCinematicForAll
==============
*/
void GScr_PlayEncryptedCinematicForAll(scrContext_t *scrContext)
{
  const char *String; 
  const char *v2; 
  unsigned __int64 keyByte16; 
  unsigned __int64 keyByte8; 
  unsigned __int64 keyByte0; 

  String = Scr_GetString(scrContext, 0);
  BinkKey_ExtractKeyBytes(String, &keyByte0, &keyByte8, &keyByte16);
  v2 = j_va("%c \"%s\" %d %llu %llu %llu", 61i64, String, 0i64, keyByte0, keyByte8, keyByte16);
  SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v2);
}

/*
==============
GScr_PlayEncryptedCinematicForPlayer
==============
*/
void GScr_PlayEncryptedCinematicForPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *String; 
  const char *v5; 
  unsigned int number; 
  const char *v7; 
  SvClient *CommonClient; 
  unsigned __int64 keyByte0[3]; 
  unsigned __int64 keyByte16; 
  unsigned __int64 keyByte8; 

  Entity = GetEntity(entref);
  String = Scr_GetString(scrContext, 0);
  BinkKey_ExtractKeyBytes(String, keyByte0, &keyByte8, &keyByte16);
  v5 = j_va("%c \"%s\" %d %llu %llu %llu", 61i64, String, 0i64, keyByte0[0], keyByte8, keyByte16);
  number = Entity->s.number;
  v7 = v5;
  if ( number == -1 )
  {
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v5);
  }
  else
  {
    CommonClient = SvClient::GetCommonClient(number);
    CommonClient->SendServerCommand(CommonClient, SV_CMD_RELIABLE, v7);
  }
}

/*
==============
GScr_PlayCinematicForAllLooping
==============
*/
void GScr_PlayCinematicForAllLooping(scrContext_t *scrContext)
{
  const char *String; 
  const char *v2; 

  String = Scr_GetString(scrContext, 0);
  v2 = j_va("%c \"%s\"", 53i64, String);
  SV_Game_BroadcastServerCommand(SV_CMD_CAN_IGNORE, v2);
}

/*
==============
GScr_PreloadCinematicForAll
==============
*/
void GScr_PreloadCinematicForAll(scrContext_t *scrContext)
{
  const char *String; 
  const char *v2; 

  String = Scr_GetString(scrContext, 0);
  v2 = j_va("%c \"%s\" %d", 51i64, String, 1i64);
  SV_Game_BroadcastServerCommand(SV_CMD_CAN_IGNORE, v2);
}

/*
==============
GScr_StopCinematicForAll
==============
*/
void GScr_StopCinematicForAll(scrContext_t *scrContext)
{
  const char *v1; 

  v1 = j_va("%c", 52i64);
  SV_Game_BroadcastServerCommand(SV_CMD_CAN_IGNORE, v1);
}

/*
==============
GScr_LogPrint
==============
*/
void GScr_LogPrint(scrContext_t *scrContext)
{
  int v2; 
  signed int NumParam; 
  signed int i; 
  const char *String; 
  __int64 v6; 
  char dest[1024]; 

  dest[0] = 0;
  v2 = 0;
  NumParam = Scr_GetNumParam(scrContext);
  for ( i = 0; i < NumParam; ++i )
  {
    String = Scr_GetString(scrContext, i);
    v6 = -1i64;
    do
      ++v6;
    while ( String[v6] );
    v2 += v6;
    if ( v2 >= 1024 )
      break;
    I_strcat(dest, 0x400ui64, String);
  }
  G_MainMP_LogPrintf((const char *)&queryFormat, dest);
}

/*
==============
GScr_AnalyticsStreamerLogFileStartStream
==============
*/
void GScr_AnalyticsStreamerLogFileStartStream(scrContext_t *scrContext)
{
  const dvar_t *v1; 
  const char *HostName; 
  unsigned __int64 MatchId; 
  char *fmt; 
  __int64 v5; 
  __int64 v6; 
  int tm_hour; 
  int tm_min; 
  int tm_sec; 
  qtime_s qtime; 
  char dest[256]; 

  v1 = DVARBOOL_online_should_upload_analytics_streamer_log_file;
  if ( !DVARBOOL_online_should_upload_analytics_streamer_log_file && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "online_should_upload_analytics_streamer_log_file") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  if ( v1->current.enabled )
  {
    HostName = SV_GameMP_GetHostName();
    Com_RealTime(0, &qtime);
    tm_sec = qtime.tm_sec;
    tm_min = qtime.tm_min;
    tm_hour = qtime.tm_hour;
    LODWORD(v6) = qtime.tm_mday;
    LODWORD(v5) = qtime.tm_mon + 1;
    LODWORD(fmt) = qtime.tm_year - 100;
    Com_sprintf(dest, 0x100ui64, "games_mp_log_%s_%02d_%02d_%02d_%02d%02d%02d", HostName, fmt, v5, v6, tm_hour, tm_min, tm_sec);
    AnalyticsStreamer_StartStream(ANALYTICS_STREAMER_LOG_FILE, dest);
    MatchId = OnlineMatchId::GetMatchId();
    AnalyticsStreamer_AddTag(ANALYTICS_STREAMER_LOG_FILE, 8ui64, MatchId);
    AnalyticsStreamer_AddTag(ANALYTICS_STREAMER_LOG_FILE, 9ui64, 0i64);
  }
  else if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 3980, ASSERT_TYPE_ASSERT, "(mpLogStreamerEnabled)", (const char *)&queryFormat, "mpLogStreamerEnabled") )
  {
    __debugbreak();
  }
}

/*
==============
GScr_AnalyticsStreamerLogFileEndStream
==============
*/
void GScr_AnalyticsStreamerLogFileEndStream(scrContext_t *scrContext)
{
  const dvar_t *v1; 

  v1 = DVARBOOL_online_should_upload_analytics_streamer_log_file;
  if ( !DVARBOOL_online_should_upload_analytics_streamer_log_file && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "online_should_upload_analytics_streamer_log_file") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  if ( v1->current.enabled )
  {
    AnalyticsStreamer_EndStream(ANALYTICS_STREAMER_LOG_FILE);
  }
  else if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 4021, ASSERT_TYPE_ASSERT, "(mpLogStreamerEnabled)", (const char *)&queryFormat, "mpLogStreamerEnabled") )
  {
    __debugbreak();
  }
}

/*
==============
GScr_AnalyticsStreamerLogFileWriteToBuffer
==============
*/
void GScr_AnalyticsStreamerLogFileWriteToBuffer(scrContext_t *scrContext)
{
  const dvar_t *v1; 
  int v3; 
  __int64 v4; 
  signed int NumParam; 
  signed int i; 
  const char *String; 
  __int64 v8; 
  int v9; 
  char *fmt; 
  __int64 v11; 
  char dest[1024]; 
  char data[1024]; 

  v1 = DVARBOOL_online_should_upload_analytics_streamer_log_file;
  if ( !DVARBOOL_online_should_upload_analytics_streamer_log_file && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "online_should_upload_analytics_streamer_log_file") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  if ( v1->current.enabled )
  {
    v3 = 0;
    dest[0] = 0;
    v4 = -1i64;
    NumParam = Scr_GetNumParam(scrContext);
    for ( i = 0; i < NumParam; ++i )
    {
      String = Scr_GetString(scrContext, i);
      v8 = -1i64;
      do
        ++v8;
      while ( String[v8] );
      v3 += v8;
      if ( v3 >= 1024 )
        break;
      I_strcat(dest, 0x400ui64, String);
    }
    v9 = level.time / 1000 % 60;
    LODWORD(v11) = v9 % 10;
    LODWORD(fmt) = v9 / 10;
    Com_sprintf(data, 0x400ui64, "%3i:%i%i %s", (unsigned int)(level.time / 1000 / 60), fmt, v11, dest);
    do
      ++v4;
    while ( data[v4] );
    AnalyticsStreamer_WriteToBuffer(ANALYTICS_STREAMER_LOG_FILE, data, v4);
  }
  else if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 4052, ASSERT_TYPE_ASSERT, "(mpLogStreamerEnabled)", (const char *)&queryFormat, "mpLogStreamerEnabled") )
  {
    __debugbreak();
  }
}

/*
==============
GScr_AnalyticsStreamerLogFileTagPlayer
==============
*/
void GScr_AnalyticsStreamerLogFileTagPlayer(scrContext_t *scrContext)
{
  const dvar_t *v2; 
  const char *String; 
  const XUID *v4; 
  unsigned __int64 UniversalId; 
  XUID v6; 
  XUID result; 

  XUID::XUID(&v6);
  v2 = DVARBOOL_online_should_upload_analytics_streamer_log_file;
  if ( !DVARBOOL_online_should_upload_analytics_streamer_log_file && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "online_should_upload_analytics_streamer_log_file") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  if ( v2->current.enabled )
  {
    String = Scr_GetString(scrContext, 0);
    v4 = XUID::FromString(&result, String);
    XUID::operator=(&v6, v4);
    UniversalId = XUID::GetUniversalId(&v6);
    AnalyticsStreamer_AddTag(ANALYTICS_STREAMER_LOG_FILE, 4ui64, UniversalId);
  }
  else if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 4103, ASSERT_TYPE_ASSERT, "(mpLogStreamerEnabled)", (const char *)&queryFormat, "mpLogStreamerEnabled") )
  {
    __debugbreak();
  }
}

/*
==============
GScr_AnalyticsStreamerIsLogFileStreamingEnabled
==============
*/
void GScr_AnalyticsStreamerIsLogFileStreamingEnabled(scrContext_t *scrContext)
{
  int v2; 
  const dvar_t *v3; 

  v2 = 0;
  if ( AnalyticsStreamer_IsSystemEnabled() )
  {
    v3 = DVARBOOL_online_should_upload_analytics_streamer_log_file;
    if ( !DVARBOOL_online_should_upload_analytics_streamer_log_file && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "online_should_upload_analytics_streamer_log_file") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v3);
    if ( v3->current.enabled )
      v2 = 1;
  }
  Scr_AddBool(scrContext, v2);
}

/*
==============
GScr_WorldEntNumber
==============
*/
void GScr_WorldEntNumber(scrContext_t *scrContext)
{
  Scr_AddInt(scrContext, 2046);
}

/*
==============
GScr_Obituary
==============
*/
void GScr_Obituary(scrContext_t *scrContext)
{
  signed int v2; 
  bool v3; 
  __int64 v4; 
  gentity_s *Entity; 
  int v6; 
  gentity_s *v7; 
  GWeaponMap *Instance; 
  BOOL v9; 
  __int16 number; 
  ClientBits *p_clientMask; 
  unsigned int ArrayObject; 
  unsigned int ArraySize; 
  int maxclients; 
  const char *NameForType; 
  const char *v16; 
  __int64 weaponIdx; 
  bool v18; 
  WeaponCompleteDef **v19; 
  Material *killIconMat; 
  MaterialTextureDef *textureTable; 
  scr_entref_t EntityIdRef; 
  gentity_s *v23; 
  unsigned int v24; 
  const char *v25; 
  unsigned int *failureIndex; 
  VariableType *failureType; 
  __int64 v28; 
  __int64 v29; 
  VariableType v30[4]; 
  unsigned int count; 
  bool outIsAlternate; 
  unsigned int v33; 
  Weapon outWeapon; 
  unsigned int buffer[200]; 

  if ( !Scr_GetNumParam(scrContext) || Scr_GetNumParam(scrContext) > 5 )
    Scr_Error(COM_ERR_4658, scrContext, "Incorrect number of parameters: GScr_Obituary( victim, attacker, weapon, weapon, <optional_obitPlayers> )\n");
  GScr_Main_GetWeaponParam(scrContext, 2u, &outWeapon, &outIsAlternate);
  v2 = G_Combat_MeansOfDeathFromScriptParam(scrContext, 3);
  v3 = 0;
  v4 = 0i64;
  Entity = GScr_GetEntity(0);
  if ( (unsigned int)v2 > 0x18 )
    goto LABEL_39;
  v6 = 31646464;
  if ( !_bittest(&v6, v2) )
    goto LABEL_39;
  v3 = 1;
  if ( v2 != 17 )
  {
    if ( v2 == 8 )
    {
      v3 = !BG_IsMeleeOnlyWeapon(&outWeapon, 0);
      if ( BG_IsRiotShield(&outWeapon, 0) )
        goto LABEL_8;
      goto LABEL_34;
    }
LABEL_39:
    if ( v2 == 12 )
    {
      weaponIdx = outWeapon.weaponIdx;
      if ( outWeapon.weaponIdx > bg_lastParsedWeaponIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1218, ASSERT_TYPE_ASSERT, "( weaponIndex ) <= ( bg_lastParsedWeaponIndex )", "weaponIndex not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", outWeapon.weaponIdx, bg_lastParsedWeaponIndex) )
        __debugbreak();
      v18 = bg_weaponCompleteDefs[weaponIdx] == NULL;
      v19 = &bg_weaponCompleteDefs[weaponIdx];
      if ( v18 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1219, ASSERT_TYPE_ASSERT, "(bg_weaponCompleteDefs[weaponIndex])", (const char *)&queryFormat, "bg_weaponCompleteDefs[weaponIndex]") )
        __debugbreak();
      killIconMat = (*v19)->killIconMat;
      if ( killIconMat )
      {
        textureTable = killIconMat->textureTable;
        if ( textureTable )
        {
          if ( textureTable->image )
            goto LABEL_8;
        }
      }
      goto LABEL_35;
    }
LABEL_34:
    if ( v3 )
      goto LABEL_35;
LABEL_8:
    v7 = G_Utils_SpawnEventEntity(&vec3_origin, 154);
    Instance = GWeaponMap::GetInstance();
    if ( !Instance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 489, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    if ( v7 == (gentity_s *)-156i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 490, ASSERT_TYPE_ASSERT, "(eventParm)", (const char *)&queryFormat, "eventParm") )
      __debugbreak();
    if ( outWeapon.weaponIdx >= BG_GetNumWeapons() )
    {
      LODWORD(failureType) = BG_GetNumWeapons();
      LODWORD(failureIndex) = outWeapon.weaponIdx;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 491, ASSERT_TYPE_ASSERT, "(unsigned)( r_weapon.weaponIdx ) < (unsigned)( BG_GetNumWeapons() )", "r_weapon.weaponIdx doesn't index BG_GetNumWeapons()\n\t%i not in [0, %i)", failureIndex, failureType) )
        __debugbreak();
    }
    Instance->SetWeapon(Instance, (BgWeaponHandle *)&v7->s.eventParm, &outWeapon);
    goto LABEL_18;
  }
  if ( BG_GetWeaponClass(&outWeapon, 0) == WEAPCLASS_THROWINGKNIFE )
    goto LABEL_8;
LABEL_35:
  v7 = G_Utils_SpawnEventEntity(&vec3_origin, 155);
  if ( v2 >= 25 )
  {
    LODWORD(failureType) = v2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 4232, ASSERT_TYPE_ASSERT, "(meansOfDeath < MOD_NUM)", "%s\n\tMOD value of %d is not valid.\n", "meansOfDeath < MOD_NUM", failureType) )
      __debugbreak();
  }
  v7->s.eventParm = v2;
LABEL_18:
  v7->s.eventParm2 = 0;
  v7->s.otherEntityNum = Entity->s.number;
  v9 = v2 == 18;
  number = 2046;
  v7->s.eventParm2 = v9;
  if ( Scr_GetType(scrContext, 1u) == VAR_POINTER && Scr_GetPointerType(scrContext, 1u) == VAR_ENTITY )
    number = GScr_GetEntity(1u)->s.number;
  v7->s.attackerEntityNum = number;
  if ( Scr_GetNumParam(scrContext) == 5 && Scr_GetType(scrContext, 4u) )
  {
    p_clientMask = &v7->clientMask;
    count = 0;
    v7->clientMask.array[0] = -1;
    *(_QWORD *)&v7->clientMask.array[1] = -1i64;
    *(_QWORD *)&v7->clientMask.array[3] = -1i64;
    *(_QWORD *)&v7->clientMask.array[5] = -1i64;
    if ( Scr_GetType(scrContext, 4u) == VAR_POINTER && Scr_GetPointerType(scrContext, 4u) == VAR_ARRAY )
    {
      ArrayObject = BGScr_Main_GetArrayObject(scrContext, 4u);
      ArraySize = GetArraySize(scrContext, ArrayObject);
      maxclients = level.maxclients;
      count = ArraySize;
      if ( level.maxclients < 1 || (unsigned __int64)level.maxclients > 0xC8 )
      {
        LODWORD(failureType) = 1;
        LODWORD(failureIndex) = level.maxclients;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 4271, ASSERT_TYPE_ASSERT, "( 1 ) <= ( level.maxclients ) && ( level.maxclients ) <= ( ( sizeof( *array_counter( entities ) ) + 0 ) )", "level.maxclients not in [1, ARRAY_COUNT( entities )]\n\t%i not in [%i, %i]", failureIndex, failureType, 200) )
          __debugbreak();
        maxclients = level.maxclients;
      }
      if ( !Scr_GetEntityArray(scrContext, ArrayObject, maxclients, buffer, &count, &v33, v30) )
      {
        NameForType = Scr_GetNameForType(v30[0]);
        v16 = j_va("element %i of array: type %s is not an entity", v33, NameForType);
        Scr_ParamError(COM_ERR_4659, scrContext, 0, v16);
        return;
      }
    }
    else if ( Scr_GetType(scrContext, 4u) == VAR_POINTER && Scr_GetPointerType(scrContext, 4u) == VAR_ENTITY )
    {
      count = 1;
      buffer[0] = Scr_GetObject(scrContext, 4u);
    }
    if ( count )
    {
      do
      {
        EntityIdRef = Scr_GetEntityIdRef(scrContext, buffer[v4]);
        v23 = GetEntity(EntityIdRef);
        v24 = v23->s.number;
        if ( v23->client )
        {
          if ( v24 >= 0xE0 )
          {
            LODWORD(v29) = 224;
            LODWORD(v28) = v23->s.number;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 290, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v28, v29) )
              __debugbreak();
          }
          p_clientMask->array[(unsigned __int64)v24 >> 5] &= ~(0x80000000 >> (v24 & 0x1F));
        }
        else
        {
          v25 = j_va("entity %i is not a player", v24);
          Scr_ObjectError(COM_ERR_4660, scrContext, v25);
        }
        v4 = (unsigned int)(v4 + 1);
      }
      while ( (unsigned int)v4 < count );
    }
  }
}

/*
==============
GScr_PositionWouldTelefrag
==============
*/
void GScr_PositionWouldTelefrag(scrContext_t *scrContext)
{
  Bounds *Bounds; 
  gentity_s *Entity; 
  gclient_s *client; 
  gagent_s *agent; 
  GUtils *v6; 
  bool WouldTelefrag; 
  vec3_t vectorValue; 
  Bounds worldBounds; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  Bounds = &playerBox;
  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    Entity = GScr_GetEntity(1u);
    client = Entity->client;
    if ( client )
    {
      Bounds = (Bounds *)BG_Suit_GetBounds(client->ps.suitIndex, PM_EFF_STANCE_DEFAULT);
    }
    else
    {
      agent = Entity->agent;
      if ( agent )
        Bounds = (Bounds *)BG_Suit_GetBounds(agent->playerState.suitIndex, PM_EFF_STANCE_DEFAULT);
      else
        Scr_ParamError(COM_ERR_3079, scrContext, 1u, "Entity is not a client or agent.");
    }
  }
  worldBounds.midPoint.v[0] = vectorValue.v[0] + Bounds->midPoint.v[0];
  worldBounds.midPoint.v[1] = vectorValue.v[1] + Bounds->midPoint.v[1];
  worldBounds.midPoint.v[2] = vectorValue.v[2] + Bounds->midPoint.v[2];
  worldBounds.halfSize = Bounds->halfSize;
  if ( !GUtils::ms_gUtils && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_utils.h", 112, ASSERT_TYPE_ASSERT, "( ms_gUtils )", (const char *)&queryFormat, "ms_gUtils") )
    __debugbreak();
  v6 = GUtils::ms_gUtils;
  if ( !GUtils::ms_gUtils && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 4366, ASSERT_TYPE_ASSERT, "(gUtils)", (const char *)&queryFormat, "gUtils") )
    __debugbreak();
  WouldTelefrag = GUtils::WorldBoundsWouldTelefrag(v6, &worldBounds);
  Scr_AddInt(scrContext, WouldTelefrag);
}

/*
==============
GScr_CanSpawn
==============
*/
void GScr_CanSpawn(scrContext_t *scrContext)
{
  const Bounds *Bounds; 
  gentity_s *Entity; 
  gclient_s *client; 
  gagent_s *agent; 
  vec3_t vectorValue; 
  trace_t results; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  Bounds = &playerBox;
  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    Entity = GScr_GetEntity(1u);
    client = Entity->client;
    if ( client )
    {
      Bounds = BG_Suit_GetBounds(client->ps.suitIndex, PM_EFF_STANCE_DEFAULT);
    }
    else
    {
      agent = Entity->agent;
      if ( agent )
        Bounds = BG_Suit_GetBounds(agent->playerState.suitIndex, PM_EFF_STANCE_DEFAULT);
      else
        Scr_ParamError(COM_ERR_3080, scrContext, 1u, "Entity is not a client or agent.");
    }
  }
  G_Main_TraceCapsule(&results, &vectorValue, &vectorValue, Bounds, 2047, 65553);
  Scr_AddInt(scrContext, !results.allsolid);
}

/*
==============
GScr_CapsuleTracePassed
==============
*/
void GScr_CapsuleTracePassed(scrContext_t *scrContext)
{
  double Float; 
  float v3; 
  double v4; 
  int passEntityNum; 
  int contentmask; 
  Bounds bounds; 
  vec3_t vectorValue; 
  trace_t results; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  Float = Scr_GetFloat(scrContext, 1u);
  v3 = *(float *)&Float;
  if ( *(float *)&Float <= 0.0 )
    Scr_Error(COM_ERR_3081, scrContext, "CapsuleTrace capsule radius too small!");
  v4 = Scr_GetFloat(scrContext, 2u);
  if ( (float)(*(float *)&v4 * 0.5) < v3 )
    Scr_Error(COM_ERR_3082, scrContext, "CapsuleTrace capsule half height must be greater than the radius!");
  passEntityNum = 2047;
  bounds.midPoint.v[0] = vec3_origin.v[0];
  bounds.midPoint.v[1] = vec3_origin.v[1];
  bounds.midPoint.v[2] = (float)(*(float *)&v4 * 0.5) + 0.0;
  bounds.halfSize.v[0] = v3;
  bounds.halfSize.v[1] = v3;
  bounds.halfSize.v[2] = *(float *)&v4 * 0.5;
  if ( Scr_GetNumParam(scrContext) > 3 && Scr_GetType(scrContext, 3u) == VAR_POINTER && Scr_GetPointerType(scrContext, 3u) == VAR_ENTITY )
    passEntityNum = GScr_GetEntity(3u)->s.number;
  contentmask = 33636369;
  if ( Scr_GetNumParam(scrContext) > 4 && !Scr_GetInt(scrContext, 4u) )
    contentmask = 65553;
  if ( Scr_GetNumParam(scrContext) > 5 && Scr_GetInt(scrContext, 5u) )
    contentmask |= 0x200u;
  G_Main_TraceCapsule(&results, &vectorValue, &vectorValue, &bounds, passEntityNum, contentmask);
  Scr_AddBool(scrContext, results.fraction >= 1.0);
}

/*
==============
GScr_getStartTime
==============
*/
void GScr_getStartTime(scrContext_t *scrContext)
{
  Scr_AddInt(scrContext, level.startTime);
}

/*
==============
GScr_MapRestart
==============
*/
void GScr_MapRestart(scrContext_t *scrContext)
{
  const char *v2; 

  if ( level.finished )
  {
    v2 = "exitlevel already called";
    if ( level.finished == 1 )
      v2 = "map_restart already called";
    Scr_Error(COM_ERR_3083, scrContext, v2);
  }
  level.finished = 1;
  level.savepersist = 0;
  if ( Scr_GetNumParam(scrContext) )
    level.savepersist = Scr_GetInt(scrContext, 0);
  Cbuf_AddCall(LOCAL_CLIENT_0, SV_CmdsMP_FastRestart);
}

/*
==============
GScr_SpawnSightTrace
==============
*/
void GScr_SpawnSightTrace(scrContext_t *scrContext)
{
  double v2; 
  vec3_t end; 
  vec3_t vectorValue; 

  Scr_GetVector(scrContext, 1u, &vectorValue);
  Scr_GetVector(scrContext, 2u, &end);
  v2 = PhysicsQuery_LegacyBrushModelSightTraceAroundCorners(PHYSICS_WORLD_ID_FIRST, &vectorValue, &end, 6145);
  Scr_AddFloat(scrContext, *(float *)&v2);
}

/*
==============
GScr_ExitLevel
==============
*/
void GScr_ExitLevel(scrContext_t *scrContext)
{
  const char *v2; 
  unsigned int Int; 

  if ( level.finished )
  {
    v2 = "exitlevel already called";
    if ( level.finished == 1 )
      v2 = "map_restart already called";
    Scr_Error(COM_ERR_3084, scrContext, v2);
  }
  level.finished = 3;
  level.savepersist = 0;
  if ( Scr_GetNumParam(scrContext) )
  {
    Int = Scr_GetInt(scrContext, 0);
    level.savepersist = Int;
  }
  else
  {
    Int = level.savepersist;
  }
  Com_Printf(24, "ExitLevel() Called from script (%i)\n", Int);
  SV_MainMP_MatchEnd();
  G_MainMP_ExitLevel();
}

/*
==============
GScr_AddTestClient
==============
*/
void GScr_AddTestClient(scrContext_t *scrContext)
{
  const gentity_s *v1; 

  GStatic::ClearActiveStatics();
  v1 = SV_ClientMP_AddTestClient();
  GStatic::SetActiveStatics();
  if ( v1 )
    GScr_AddEntity(v1);
}

/*
==============
GScr_AddBot
==============
*/
void GScr_AddBot(scrContext_t *scrContext)
{
  const char *String; 
  const gentity_s *v3; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_3085, scrContext, "AddBot: Invalid number of args");
  GStatic::ClearActiveStatics();
  String = Scr_GetString(scrContext, 0);
  v3 = SV_ClientMP_AddBot(String, 0, 0, 0);
  GStatic::SetActiveStatics();
  if ( v3 )
    GScr_AddEntity(v3);
}

/*
==============
GScr_IsBotMatchMakingEnabled
==============
*/
void GScr_IsBotMatchMakingEnabled(scrContext_t *scrContext)
{
  bool IsBotMatchMakingAllowedForPlaylist; 

  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
    Scr_Error(COM_ERR_3086, scrContext, "This function cannot be used by the front-end server");
  IsBotMatchMakingAllowedForPlaylist = BG_Bots_IsBotMatchMakingAllowedForPlaylist();
  Scr_AddBool(scrContext, IsBotMatchMakingAllowedForPlaylist);
}

/*
==============
GScr_AddMPBotToTeam
==============
*/
void GScr_AddMPBotToTeam(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const char *v3; 
  const char *v4; 
  const gentity_s *v5; 
  team_t outTeam; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_3087, scrContext, "AddBot: Invalid number of args");
  ConstString = Scr_GetConstString(scrContext, 0);
  if ( Com_Teams_TeamFromString(ConstString, &outTeam) )
  {
    GStatic::ClearActiveStatics();
    v5 = SV_ClientMP_AddMPBotToTeam(outTeam);
    GStatic::SetActiveStatics();
    if ( v5 )
      GScr_AddEntity(v5);
  }
  else
  {
    v3 = SL_ConvertToString(ConstString);
    v4 = j_va("unknown team '%s'", v3);
    Scr_Error(COM_ERR_3088, scrContext, v4);
  }
}

/*
==============
GScr_CanSpawnBotOrTestClient
==============
*/
void GScr_CanSpawnBotOrTestClient(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  int CanSpawnBotOrTestClient; 

  Entity = GetEntity(entref);
  CanSpawnBotOrTestClient = SV_ClientMP_CanSpawnBotOrTestClient(Entity);
  Scr_AddBool(scrContext, CanSpawnBotOrTestClient);
}

/*
==============
GScr_SpawnBotOrTestClient
==============
*/
void GScr_SpawnBotOrTestClient(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  GStatic::ClearActiveStatics();
  LODWORD(Entity) = SV_ClientMP_SpawnBotOrTestClient(Entity);
  GStatic::SetActiveStatics();
  if ( !(_DWORD)Entity )
    Scr_Error(COM_ERR_3089, scrContext, "SpawnBotOrTestClient() must be called on a valid bot or test client. See console log for details");
}

/*
==============
GScr_IsTestClient
==============
*/
void GScr_IsTestClient(scrContext_t *scrContext)
{
  gentity_s *Entity; 
  int IsTestClient; 

  Entity = GScr_GetEntity(0);
  if ( Entity->client )
  {
    IsTestClient = SV_ClientMP_IsTestClient(Entity->s.number);
    Scr_AddInt(scrContext, IsTestClient);
  }
  else
  {
    Scr_AddInt(scrContext, 0);
  }
}

/*
==============
GScr_AddAgent
==============
*/
void GScr_AddAgent(scrContext_t *scrContext)
{
  const gentity_s *v1; 

  v1 = SV_AgentMP_AddAgent();
  if ( v1 )
    GScr_AddEntity(v1);
}

/*
==============
GScr_AllClientsPrint
==============
*/
void GScr_AllClientsPrint(scrContext_t *scrContext)
{
  const char *String; 
  const char *v3; 

  if ( Scr_GetNumParam(scrContext) )
  {
    String = Scr_GetString(scrContext, 0);
    v3 = j_va("%c \"%s\"", 101i64, String);
    SV_Game_BroadcastServerCommand(SV_CMD_CAN_IGNORE, v3);
  }
}

/*
==============
GScr_MapExists
==============
*/
void GScr_MapExists(scrContext_t *scrContext)
{
  if ( Scr_GetNumParam(scrContext) )
    Scr_AddInt(scrContext, 1);
}

/*
==============
GScr_KickPlayer
==============
*/
void GScr_KickPlayer(scrContext_t *scrContext)
{
  const char *String; 
  bool v3; 
  unsigned int NumParam; 
  const char *v5; 
  int Int; 
  int v7; 
  const char *v8; 

  String = "EXE/PLAYERKICKED";
  v3 = 0;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam == 1 )
    goto LABEL_8;
  if ( NumParam != 2 )
  {
    if ( NumParam != 3 )
    {
      Scr_Error(COM_ERR_3091, scrContext, "Not enough parameters for Kick() ");
      return;
    }
    v3 = Scr_GetInt(scrContext, 2u) != 0;
  }
  String = Scr_GetString(scrContext, 1u);
  if ( !I_strnicmp("EXE/PLAYERKICKED", String, 0x10ui64) )
  {
LABEL_8:
    Int = Scr_GetInt(scrContext, 0);
    v7 = Int;
    if ( Int < 0 || Int >= (int)SvClient::ms_clientCount )
    {
      v8 = j_va("Invalid client specified (%i) out of %i clients", (unsigned int)Int, SvClient::ms_clientCount);
      Scr_ParamError(COM_ERR_3092, scrContext, 0, v8);
    }
    GStatic::ClearActiveStatics();
    SV_CmdsMP_KickClientNum(v7, String, v3);
    GStatic::SetActiveStatics();
  }
  else
  {
    v5 = j_va("Localized string should start with %s", "EXE/PLAYERKICKED");
    Scr_ParamError(COM_ERR_3090, scrContext, 1u, v5);
  }
}

/*
==============
GScr_ClientPrint
==============
*/
void GScr_ClientPrint(scrContext_t *scrContext)
{
  gentity_s *Entity; 
  const char *String; 
  const char *v4; 
  __int64 v5; 
  SvClient *CommonClient; 
  __int64 v7; 
  int v8; 

  if ( Scr_GetNumParam(scrContext) )
  {
    Entity = GScr_GetEntity(0);
    String = Scr_GetString(scrContext, 1u);
    v4 = j_va("%c \"%s\"", 101i64, String);
    if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 196, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
      __debugbreak();
    v5 = Entity - g_entities;
    if ( (unsigned int)v5 >= 0x800 )
    {
      v8 = 2048;
      LODWORD(v7) = ((int)Entity - (int)g_entities) / 1456;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 199, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( ( 2048 ) )", "index doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v7, v8) )
        __debugbreak();
    }
    if ( (__int16)v5 == -1 )
    {
      SV_Game_BroadcastServerCommand(SV_CMD_CAN_IGNORE, v4);
    }
    else
    {
      CommonClient = SvClient::GetCommonClient((__int16)v5);
      CommonClient->SendServerCommand(CommonClient, SV_CMD_CAN_IGNORE, v4);
    }
  }
}

/*
==============
GScr_PrecacheStatusIcon
==============
*/
void GScr_PrecacheStatusIcon(scrContext_t *scrContext)
{
  const char *String; 

  String = Scr_GetString(scrContext, 0);
  Com_Printf(15, "PreCacheStatusIcon (%s) is deprecated, remove this script call. Precaching is done via precache_statusicon in CSV files\n", String);
}

/*
==============
GScr_PrecacheMiniMapIcon
==============
*/
void GScr_PrecacheMiniMapIcon(scrContext_t *scrContext)
{
  const char *String; 

  String = Scr_GetString(scrContext, 0);
  Com_Printf(15, "PrecacheMiniMapIcon (%s) is deprecated, remove this script call. Precaching is done via precache_minimapicon in CSV files\n", String);
}

/*
==============
GScr_PrecacheMpAnim
==============
*/
void GScr_PrecacheMpAnim(scrContext_t *scrContext)
{
  const char *String; 

  String = Scr_GetString(scrContext, 0);
  Com_Printf(15, "PrecacheMpAnim (%s) is deprecated, remove this script call. Precaching is done via precache_xanim in CSV files\n", String);
}

/*
==============
Scr_VisionSetAlternateForPlayer
==============
*/
void Scr_VisionSetAlternateForPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  int number; 
  const char *v7; 
  unsigned int Int; 
  const char *v11; 
  const char *v12; 
  SvClient *CommonClient; 
  int outControllingClientNum; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3678, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 4989, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client && !v4->agent )
    {
      v5 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3677, scrContext, v5);
    }
  }
  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_Error(COM_ERR_3093, scrContext, "USAGE: <player> VisionSetAlternateForPlayer( <stage>, <duration> )\n");
  number = v4->s.number;
  outControllingClientNum = number;
  if ( !SV_IsAgent(number) || SV_GetAgentControlledByPlayerNum(outControllingClientNum, &outControllingClientNum) )
  {
    Int = Scr_GetInt(scrContext, 0);
    Scr_GetFloat(scrContext, 1u);
    _XMM0 = 0i64;
    __asm { vroundss xmm1, xmm0, xmm4, 1 }
    v11 = j_va("%c %i %i", 48i64, Int, (unsigned int)(int)*(float *)&_XMM1);
    v12 = v11;
    if ( outControllingClientNum == -1 )
    {
      SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v11);
    }
    else
    {
      CommonClient = SvClient::GetCommonClient(outControllingClientNum);
      CommonClient->SendServerCommand(CommonClient, SV_CMD_RELIABLE, v12);
    }
  }
  else
  {
    v7 = j_va("entity %i is not a player or player-controlled agent", entnum);
    Scr_ObjectError(COM_ERR_3094, scrContext, v7);
  }
}

/*
==============
Scr_VisionSetNakedForPlayer
==============
*/
void Scr_VisionSetNakedForPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  unsigned int *client; 
  const char *v6; 
  ComErrorCode v7; 
  int v8; 
  unsigned int v9; 
  scr_string_t ConstLowercaseString; 
  const char *v13; 
  const char *v14; 
  const char *v15; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5087, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = (unsigned int *)v4->client;
  if ( !client )
  {
    client = (unsigned int *)v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v7, scrContext, v6);
      client = NULL;
    }
  }
  v8 = 1000;
  v9 = Scr_GetNumParam(scrContext) - 1;
  if ( v9 )
  {
    if ( v9 != 1 )
    {
      Scr_Error(COM_ERR_3098, scrContext, "USAGE: <player> VisionSetForPlayer( <visionset name>, <transition time> )\n");
      return;
    }
    Scr_GetFloat(scrContext, 1u);
    _XMM0 = 0i64;
    __asm { vroundss xmm1, xmm0, xmm4, 1 }
    v8 = (int)*(float *)&_XMM1;
  }
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  v13 = SL_ConvertToString(ConstLowercaseString);
  v14 = v13;
  if ( *v13 )
  {
    if ( !NetConstStrings_GetVisionSetIndex(v13, client + 317) )
    {
      v15 = j_va("visionset %s has not been precached, include with precache_vision", v14);
      Scr_Error(COM_ERR_3099, scrContext, v15);
    }
    if ( !client[317] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5118, ASSERT_TYPE_ASSERT, "( ps->visionSetOverride.visionSetIndex != 0 )", (const char *)&queryFormat, "ps->visionSetOverride.visionSetIndex != 0") )
      __debugbreak();
  }
  else
  {
    client[317] = 0;
  }
  client[318] = level.time;
  client[319] = v8;
}

/*
==============
Scr_VisionSetNightForPlayer
==============
*/
void Scr_VisionSetNightForPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  Scr_VisionSetForPlayer_Internal(scrContext, entref, VISIONSET_NIGHT);
}

/*
==============
Scr_VisionSetMissileCamForPlayer
==============
*/
void Scr_VisionSetMissileCamForPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  unsigned int *client; 
  const char *v6; 
  ComErrorCode v7; 
  scr_string_t ConstLowercaseString; 
  const char *v9; 
  const char *v10; 
  const char *v11; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5158, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = (unsigned int *)v4->client;
  if ( !client )
  {
    client = (unsigned int *)v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v7, scrContext, v6);
      client = NULL;
    }
  }
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  v9 = SL_ConvertToString(ConstLowercaseString);
  v10 = v9;
  if ( *v9 )
  {
    if ( !NetConstStrings_GetVisionSetIndex(v9, client + 325) )
    {
      v11 = j_va("visionset %s has not been precached, include with precache_vision", v10);
      Scr_Error(COM_ERR_3100, scrContext, v11);
    }
    if ( !client[325] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5172, ASSERT_TYPE_ASSERT, "( ps->missileOverrideVisionSetIndex != 0 )", (const char *)&queryFormat, "ps->missileOverrideVisionSetIndex != 0") )
      __debugbreak();
  }
  else
  {
    client[325] = 0;
  }
}

/*
==============
Scr_VisionSetThermalForPlayer
==============
*/
void Scr_VisionSetThermalForPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  unsigned int *client; 
  const char *v6; 
  ComErrorCode v7; 
  scr_string_t ConstLowercaseString; 
  const char *v9; 
  const char *v10; 
  const char *v11; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5190, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = (unsigned int *)v4->client;
  if ( !client )
  {
    client = (unsigned int *)v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v7, scrContext, v6);
      client = NULL;
    }
  }
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  v9 = SL_ConvertToString(ConstLowercaseString);
  v10 = v9;
  if ( *v9 )
  {
    if ( !NetConstStrings_GetVisionSetIndex(v9, client + 323) )
    {
      v11 = j_va("visionset %s has not been precached, include with precache_vision", v10);
      Scr_Error(COM_ERR_3101, scrContext, v11);
    }
    if ( !client[323] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5204, ASSERT_TYPE_ASSERT, "( ps->thermalOverrideVisionSetIndex != 0 )", (const char *)&queryFormat, "ps->thermalOverrideVisionSetIndex != 0") )
      __debugbreak();
  }
  else
  {
    client[323] = 0;
  }
}

/*
==============
Scr_VisionSetPainForPlayer
==============
*/
void Scr_VisionSetPainForPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  unsigned int *client; 
  const char *v6; 
  ComErrorCode v7; 
  scr_string_t ConstLowercaseString; 
  const char *v9; 
  const char *v10; 
  const char *v11; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5222, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = (unsigned int *)v4->client;
  if ( !client )
  {
    client = (unsigned int *)v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v7, scrContext, v6);
      client = NULL;
    }
  }
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  v9 = SL_ConvertToString(ConstLowercaseString);
  v10 = v9;
  if ( *v9 )
  {
    if ( !NetConstStrings_GetVisionSetIndex(v9, client + 324) )
    {
      v11 = j_va("visionset %s has not been precached, include with precache_vision", v10);
      Scr_Error(COM_ERR_3102, scrContext, v11);
    }
    if ( !client[324] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5236, ASSERT_TYPE_ASSERT, "( ps->painOverrideVisionSetIndex != 0 )", (const char *)&queryFormat, "ps->painOverrideVisionSetIndex != 0") )
      __debugbreak();
  }
  else
  {
    client[324] = 0;
  }
}

/*
==============
Scr_VisionSetFadeToBlackForPlayer
==============
*/
void Scr_VisionSetFadeToBlackForPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  Scr_VisionSetForPlayer_Internal(scrContext, entref, VISIONSET_FADE_TO_BLACK);
}

/*
==============
Scr_VisionSetKillStreakForPlayer
==============
*/
void Scr_VisionSetKillStreakForPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  unsigned int *client; 
  const char *v6; 
  ComErrorCode v7; 
  scr_string_t ConstLowercaseString; 
  const char *v9; 
  const char *v10; 
  const char *v11; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5273, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = (unsigned int *)v4->client;
  if ( !client )
  {
    client = (unsigned int *)v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v7, scrContext, v6);
      client = NULL;
    }
  }
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  v9 = SL_ConvertToString(ConstLowercaseString);
  v10 = v9;
  if ( *v9 )
  {
    if ( !NetConstStrings_GetVisionSetIndex(v9, client + 326) )
    {
      v11 = j_va("visionset %s has not been precached, include with precache_vision", v10);
      Scr_Error(COM_ERR_3103, scrContext, v11);
    }
    if ( !client[326] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5287, ASSERT_TYPE_ASSERT, "( ps->killstreakOverrideVisionSetIndex != 0 )", (const char *)&queryFormat, "ps->killstreakOverrideVisionSetIndex != 0") )
      __debugbreak();
  }
  else
  {
    client[326] = 0;
  }
}

/*
==============
ScrCmd_AutoSpotOverlayOn
==============
*/
void ScrCmd_AutoSpotOverlayOn(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  gclient_s *client; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5304, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  client = v4->client;
  if ( GameModeFlagValues::ms_mpValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 201, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a MP-only context", "IsFlagActive( index )") )
    __debugbreak();
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal(&client->ps.otherFlags, ACTIVE, 0x27u);
}

/*
==============
ScrCmd_AutoSpotOverlayOff
==============
*/
void ScrCmd_AutoSpotOverlayOff(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  gclient_s *client; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5321, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  client = v4->client;
  if ( GameModeFlagValues::ms_mpValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 212, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a MP-only context", "IsFlagActive( index )") )
    __debugbreak();
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal(&client->ps.otherFlags, ACTIVE, 0x27u);
}

/*
==============
ScrCmd_EnableWorldUp
==============
*/
void ScrCmd_EnableWorldUp(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  playerState_s *EntityPlayerState; 
  int Int; 
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *p_otherFlags; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5338, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  EntityPlayerState = G_GetEntityPlayerState(v4);
  if ( !EntityPlayerState )
    Scr_Error(COM_ERR_3104, scrContext, "EnableWorldUp only works on players.");
  Int = Scr_GetInt(scrContext, 0);
  p_otherFlags = &EntityPlayerState->otherFlags;
  if ( Int )
    GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagStrict(p_otherFlags, DEAD|PRONE|0x20);
  else
    GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagStrict(p_otherFlags, DEAD|PRONE|0x20);
}

/*
==============
ScrCmd_SetEyesOnUplinkEnabled
==============
*/
void ScrCmd_SetEyesOnUplinkEnabled(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  char *client; 
  const char *v6; 
  ComErrorCode v7; 
  int Int; 
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *v9; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5370, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = (char *)v4->client;
  if ( !client )
  {
    client = (char *)v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v7, scrContext, v6);
      client = NULL;
    }
  }
  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    Int = Scr_GetInt(scrContext, 0);
    v9 = (GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *)(client + 28);
    if ( Int )
      GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagStrict(v9, FIRING|0x20);
    else
      GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagStrict(v9, FIRING|0x20);
  }
  else
  {
    Scr_Error(COM_ERR_3105, scrContext, "SetEyesOnUplinkEnabled requires 1 argument");
  }
}

/*
==============
GScr_ControlTurretOn
==============
*/
void GScr_ControlTurretOn(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  gentity_s *Entity; 
  gentity_s *v7; 
  const char *v8; 
  const char *v9; 
  bool v10; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5398, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  Entity = GScr_GetEntity(0);
  v7 = Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v8 = SL_ConvertToString(Entity->classname);
    v9 = j_va("entity type '%s' is not a turret", v8);
    Scr_Error(COM_ERR_3106, scrContext, v9);
  }
  v10 = G_Turret_ScrUse(scrContext, v7, v4, 0);
  Scr_AddBool(scrContext, v10);
}

/*
==============
GScr_ControlTurretOff
==============
*/
void GScr_ControlTurretOff(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  gentity_s *Entity; 
  gentity_s *v7; 
  const char *v8; 
  const char *v9; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5426, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  Entity = GScr_GetEntity(0);
  v7 = Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v8 = SL_ConvertToString(Entity->classname);
    v9 = j_va("entity type '%s' is not a turret", v8);
    Scr_Error(COM_ERR_3107, scrContext, v9);
  }
  G_Turret_ScrStopUse(v7, v4);
}

/*
==============
GScr_RemoteControlVehicleTarget
==============
*/
void GScr_RemoteControlVehicleTarget(scrContext_t *scrContext, scr_entref_t entref)
{
  EntHandle *Entity; 
  gentity_s *v4; 
  playerState_s *EntityPlayerState; 
  gentity_s *v6; 
  int number; 

  Entity = (EntHandle *)GetEntity(entref);
  if ( Entity[2].number != 12 )
    Scr_Error(COM_ERR_3108, scrContext, "Specified entity is not a helicopter. Currently only helicopters are supported for this feature.");
  if ( !EntHandle::isDefined(Entity + 82) )
    Scr_Error(COM_ERR_3109, scrContext, "Specified helicopter is not controlled by a player");
  v4 = EntHandle::ent(Entity + 82);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5462, ASSERT_TYPE_ASSERT, "( playerEntity )", (const char *)&queryFormat, "playerEntity") )
    __debugbreak();
  if ( v4->s.eType != ET_PLAYER )
    Scr_Error(COM_ERR_3110, scrContext, "Specified helicopter is not controlled by a player");
  EntityPlayerState = G_GetEntityPlayerState(v4);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5468, ASSERT_TYPE_ASSERT, "( playerState )", (const char *)&queryFormat, "playerState") )
    __debugbreak();
  v6 = GScr_GetEntity(0);
  if ( !v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5471, ASSERT_TYPE_ASSERT, "( targetEntity )", (const char *)&queryFormat, "targetEntity") )
    __debugbreak();
  number = v6->s.number;
  v6->r.svFlags &= ~1u;
  EntityPlayerState->vehicleState.targetEntity = number;
}

/*
==============
GScr_RemoteControlVehicleTargetOff
==============
*/
void GScr_RemoteControlVehicleTargetOff(scrContext_t *scrContext, scr_entref_t entref)
{
  EntHandle *Entity; 
  gentity_s *v4; 
  playerState_s *EntityPlayerState; 

  Entity = (EntHandle *)GetEntity(entref);
  if ( Entity[2].number != 12 )
    Scr_Error(COM_ERR_3111, scrContext, "Specified entity is not a helicopter. Currently only helicopters are supported for this feature.");
  if ( !EntHandle::isDefined(Entity + 82) )
    Scr_Error(COM_ERR_3112, scrContext, "Specified helicopter is not controlled by a player");
  v4 = EntHandle::ent(Entity + 82);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5502, ASSERT_TYPE_ASSERT, "( playerEntity )", (const char *)&queryFormat, "playerEntity") )
    __debugbreak();
  if ( v4->s.eType != ET_PLAYER )
    Scr_Error(COM_ERR_3113, scrContext, "Specified helicopter is not controlled by a player");
  EntityPlayerState = G_GetEntityPlayerState(v4);
  if ( EntityPlayerState )
  {
    EntityPlayerState->vehicleState.targetEntity = 2047;
  }
  else
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5508, ASSERT_TYPE_ASSERT, "( playerState )", (const char *)&queryFormat, "playerState") )
      __debugbreak();
    MEMORY[0x128] = 2047;
  }
}

/*
==============
GScr_MainMP_EnableAimAssist
==============
*/
void GScr_MainMP_EnableAimAssist(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( Entity->s.eType != ET_SCRIPTMOVER && !BG_IsVehicleEntity(&Entity->s) && v4->r.modelType != 5 )
    Scr_Error(COM_ERR_3114, scrContext, "Currently only supported on script movers, vehicle/helicopters entities, entities with brush models");
  GScr_Main_EnableAimAssistCommon(v4);
}

/*
==============
GScr_MainMP_DisableAimAssist
==============
*/
void GScr_MainMP_DisableAimAssist(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 1914, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
    __debugbreak();
  if ( ((Entity->s.eType - 12) & 0xFFFD) != 0 && Entity->r.modelType != 5 )
    Scr_Error(COM_ERR_3115, scrContext, "Currently only supported on vehicle/helicopters entities or entities with brush models");
  GScr_Main_DisableAimAssistCommon(Entity);
}

/*
==============
GScr_MainMP_IsItemUnlocked
==============
*/
void GScr_MainMP_IsItemUnlocked(scrContext_t *scrContext, scr_entref_t entref)
{
  Scr_AddInt(scrContext, 0);
}

/*
==============
GScr_SetCodcasterClientMatchData
==============
*/
void GScr_SetCodcasterClientMatchData(scrContext_t *scrContext)
{
  SvGameGlobalsMP *SvGameGlobalsMP; 
  const DDLDef *Asset; 
  DDLState state; 
  DDLContext ddlContext; 

  SvGameGlobalsMP = SvGameGlobalsMP::GetSvGameGlobalsMP();
  if ( !SvGameGlobalsMP->codcasterClientMatchData.def[0] )
    GScr_SetCodcasterClientMatchDataDef(scrContext);
  Asset = Com_DDL_LoadAsset(SvGameGlobalsMP->codcasterClientMatchData.def);
  Com_DDL_CreateContext(SvGameGlobalsMP->codcasterClientMatchData.data, 1614, Asset, &ddlContext, NULL, NULL);
  __asm { vpxor   xmm0, xmm0, xmm0 }
  *(_OWORD *)&state.member = _XMM0;
  state.isValid = 0;
  state.offset = 0;
  state.arrayIndex = -1;
  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
    Scr_Error(COM_ERR_3121, scrContext, "SetDDL: Can't use this function on the front end server");
  LiveStorage_InitializeDDLStateForStatsGroup(Asset, &state, STATSGROUP_IGNORE);
  GScr_Main_SetDDL(scrContext, &state, Asset, &ddlContext, "GScr_SetCodcasterClientMatchData", 0);
}

/*
==============
GScr_GetCodcasterClientMatchData
==============
*/
void GScr_GetCodcasterClientMatchData(scrContext_t *scrContext)
{
  SvGameGlobalsMP *SvGameGlobalsMP; 
  const DDLDef *Asset; 
  DDLState state; 
  DDLContext ddlContext; 

  SvGameGlobalsMP = SvGameGlobalsMP::GetSvGameGlobalsMP();
  if ( !SvGameGlobalsMP->codcasterClientMatchData.def[0] )
    GScr_SetCodcasterClientMatchDataDef(scrContext);
  Asset = Com_DDL_LoadAsset(SvGameGlobalsMP->codcasterClientMatchData.def);
  Com_DDL_CreateContext(SvGameGlobalsMP->codcasterClientMatchData.data, 1614, Asset, &ddlContext, NULL, NULL);
  __asm { vpxor   xmm0, xmm0, xmm0 }
  *(_OWORD *)&state.member = _XMM0;
  state.isValid = 0;
  state.offset = 0;
  state.arrayIndex = -1;
  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
    Scr_Error(COM_ERR_3120, scrContext, "GetDDL: Can't use this function on the front end server");
  LiveStorage_InitializeDDLStateForStatsGroup(Asset, &state, STATSGROUP_IGNORE);
  GScr_Main_GetDDL(scrContext, &state, Asset, &ddlContext, "GetCodcasterClientMatchData", 0);
}

/*
==============
GScr_SendCodcasterClientMatchData
==============
*/
void GScr_SendCodcasterClientMatchData(scrContext_t *scrContext)
{
  int maxclients; 
  int v2; 
  __int64 v3; 

  if ( SvGameGlobalsMP::GetSvGameGlobalsMP()->codcasterClientMatchData.def[0] )
  {
    maxclients = level.maxclients;
    v2 = 0;
    if ( level.maxclients > 0 )
    {
      v3 = 0i64;
      do
      {
        if ( level.clients[v3].sess.connected == CON_CONNECTED )
        {
          SV_ClientMP_SendCodcasterClientMatchData(v2);
          maxclients = level.maxclients;
        }
        ++v2;
        ++v3;
      }
      while ( v2 < maxclients );
    }
  }
}

/*
==============
GScr_MainMP_HasPlayerData
==============
*/
void GScr_MainMP_HasPlayerData(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  unsigned int number; 
  const SvClientMP *CommonClient; 
  int HasAllClientStatPackets; 

  Entity = GetEntity(entref);
  if ( !Entity->client )
    Scr_Error(COM_ERR_3131, scrContext, "GetPlayerData: entity must be a player entity");
  number = Entity->s.number;
  if ( (_BYTE)SvClient::ms_allocatedType != HALF_HALF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_mp\\sv_client_mp.h", 957, ASSERT_TYPE_ASSERT, "( ms_allocatedType == ALLOCATION_TYPE )", (const char *)&queryFormat, "ms_allocatedType == ALLOCATION_TYPE") )
    __debugbreak();
  CommonClient = (const SvClientMP *)SvClient::GetCommonClient(number);
  HasAllClientStatPackets = SV_HasAllClientStatPackets(CommonClient);
  Scr_AddBool(scrContext, HasAllClientStatPackets != 0);
}

/*
==============
GScr_MainMP_GetPlayerData
==============
*/
void GScr_MainMP_GetPlayerData(scrContext_t *scrContext, scr_entref_t entref)
{
  scr_string_t ConstString; 
  unsigned int RawHash; 
  StatsGroup StatsGroupByHash; 
  gentity_s *Entity; 
  unsigned int number; 
  const SvClientMP *CommonClient; 
  const DDLDef *DefForStatsGroup; 
  unsigned __int8 *ClientPlayerDataBuffer; 
  int PlayerDataBufferSize; 
  DDLState state; 
  DDLContext ddlContext; 

  ConstString = Scr_GetConstString(scrContext, 0);
  RawHash = j_SL_GetRawHash(ConstString);
  StatsGroupByHash = Com_PlayerData_FindStatsGroupByHash(RawHash);
  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
    Scr_Error(COM_ERR_3122, scrContext, "GetPlayerData not allowed on front end server");
  Entity = GetEntity(entref);
  if ( !Entity->client )
    Scr_Error(COM_ERR_3123, scrContext, "GetPlayerData: entity must be a player entity");
  number = Entity->s.number;
  if ( (_BYTE)SvClient::ms_allocatedType != HALF_HALF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_mp\\sv_client_mp.h", 957, ASSERT_TYPE_ASSERT, "( ms_allocatedType == ALLOCATION_TYPE )", (const char *)&queryFormat, "ms_allocatedType == ALLOCATION_TYPE") )
    __debugbreak();
  CommonClient = (const SvClientMP *)SvClient::GetCommonClient(number);
  if ( !SV_HasAllClientStatPackets(CommonClient) )
    Scr_Error(COM_ERR_3124, scrContext, "GetPlayerData: we don't have that player's stats yet");
  DefForStatsGroup = Com_PlayerData_GetDefForStatsGroup(StatsGroupByHash);
  ClientPlayerDataBuffer = SV_ClientMP_GetClientPlayerDataBuffer(Entity->s.number, StatsGroupByHash);
  PlayerDataBufferSize = LiveStorage_GetPlayerDataBufferSize(StatsGroupByHash);
  Com_DDL_CreateContext(ClientPlayerDataBuffer, PlayerDataBufferSize, DefForStatsGroup, &ddlContext, NULL, NULL);
  __asm { vpxor   xmm0, xmm0, xmm0 }
  *(_OWORD *)&state.member = _XMM0;
  state.isValid = 0;
  state.offset = 0;
  state.arrayIndex = -1;
  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
    Scr_Error(COM_ERR_3120, scrContext, "GetDDL: Can't use this function on the front end server");
  LiveStorage_InitializeDDLStateForStatsGroup(DefForStatsGroup, &state, StatsGroupByHash);
  GScr_Main_GetDDL(scrContext, &state, DefForStatsGroup, &ddlContext, "GetPlayerData", 1);
}

/*
==============
GScr_MainMP_SetPlayerData
==============
*/
void GScr_MainMP_SetPlayerData(scrContext_t *scrContext, scr_entref_t entref)
{
  scr_string_t ConstString; 
  unsigned int RawHash; 
  StatsGroup StatsGroupByHash; 
  gentity_s *Entity; 
  unsigned int number; 
  const SvClientMP *CommonClient; 
  const DDLDef *DefForStatsGroup; 
  unsigned __int8 *ClientPlayerDataBuffer; 
  int PlayerDataBufferSize; 
  DDLState state; 
  DDLContext ddlContext; 

  ConstString = Scr_GetConstString(scrContext, 0);
  RawHash = j_SL_GetRawHash(ConstString);
  StatsGroupByHash = Com_PlayerData_FindStatsGroupByHash(RawHash);
  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
    Scr_Error(COM_ERR_3128, scrContext, "SetPlayerData not allowed on front end server");
  Entity = GetEntity(entref);
  if ( !Entity->client )
    Scr_Error(COM_ERR_3129, scrContext, "SetPlayerData: entity must be a player entity");
  number = Entity->s.number;
  if ( (_BYTE)SvClient::ms_allocatedType != HALF_HALF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_mp\\sv_client_mp.h", 957, ASSERT_TYPE_ASSERT, "( ms_allocatedType == ALLOCATION_TYPE )", (const char *)&queryFormat, "ms_allocatedType == ALLOCATION_TYPE") )
    __debugbreak();
  CommonClient = (const SvClientMP *)SvClient::GetCommonClient(number);
  if ( !SV_HasAllClientStatPackets(CommonClient) )
    Scr_Error(COM_ERR_3130, scrContext, "GetPlayerData: we don't have that player's stats yet");
  DefForStatsGroup = Com_PlayerData_GetDefForStatsGroup(StatsGroupByHash);
  ClientPlayerDataBuffer = SV_ClientMP_GetClientPlayerDataBuffer(Entity->s.number, StatsGroupByHash);
  s_callbackData.modifiedFlags = SV_ClientMP_GetClientPersistentDataModifiedFlags(Entity->s.number);
  s_callbackData.baseOffset = Com_PlayerData_GetStatsGroupOffset(StatsGroupByHash) + 4;
  PlayerDataBufferSize = LiveStorage_GetPlayerDataBufferSize(StatsGroupByHash);
  Com_DDL_CreateContext(ClientPlayerDataBuffer, PlayerDataBufferSize, DefForStatsGroup, &ddlContext, DDLAccessCB, &s_callbackData);
  __asm { vpxor   xmm0, xmm0, xmm0 }
  *(_OWORD *)&state.member = _XMM0;
  state.isValid = 0;
  state.offset = 0;
  state.arrayIndex = -1;
  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
    Scr_Error(COM_ERR_3121, scrContext, "SetDDL: Can't use this function on the front end server");
  LiveStorage_InitializeDDLStateForStatsGroup(DefForStatsGroup, &state, StatsGroupByHash);
  GScr_Main_SetDDL(scrContext, &state, DefForStatsGroup, &ddlContext, "SetPlayerData", 1);
  SV_ClientMP_SetClientPersistentDataModified(Entity->s.number);
}

/*
==============
GScr_MainMP_LogStatMatchGUID
==============
*/
void GScr_MainMP_LogStatMatchGUID(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const gentity_s *v7; 
  const SvClientMP *MpClient; 
  const DDLDef *DefForStatsGroup; 
  unsigned __int8 *ClientPlayerDataBuffer; 
  int PlayerDataBufferSize; 
  unsigned __int64 MatchId; 
  DDLState fromState; 
  DDLState toState; 
  DDLContext ddlContext; 
  DDLState result; 
  unsigned int path; 
  unsigned int RawHash; 

  fromState.isValid = 0;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  fromState.offset = 0;
  *(_OWORD *)&fromState.member = _XMM0;
  toState.isValid = 0;
  toState.offset = 0;
  *(_OWORD *)&toState.member = _XMM0;
  fromState.arrayIndex = -1;
  toState.arrayIndex = -1;
  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
  {
    Scr_Error(COM_ERR_3132, scrContext, "LogStatMatchGUID not allowed on front end server");
  }
  else
  {
    Entity = GetEntity(entref);
    v7 = Entity;
    if ( Entity && Entity->client )
    {
      MpClient = SV_Client_GetMpClient(Entity->s.number);
      if ( SV_HasAllClientStatPackets(MpClient) )
      {
        DefForStatsGroup = Com_PlayerData_GetDefForStatsGroup(STATSGROUP_COMMON);
        ClientPlayerDataBuffer = SV_ClientMP_GetClientPlayerDataBuffer(v7->s.number, STATSGROUP_COMMON);
        PlayerDataBufferSize = LiveStorage_GetPlayerDataBufferSize(STATSGROUP_COMMON);
        if ( DefForStatsGroup && !SV_BotIsBotEntClient(v7) && !Dvar_GetBool_Internal_DebugName(DVARBOOL_xblive_privatematch, "xblive_privatematch") )
        {
          path = j_SL_GetRawHash(scr_const.commonData);
          RawHash = j_SL_GetRawHash(scr_const.lastMatchGUID);
          fromState = *DDL_GetRootState(&result, DefForStatsGroup);
          DDL_MoveToPathByHash(&fromState, &toState, 2, &path);
          Com_DDL_CreateContext(ClientPlayerDataBuffer, PlayerDataBufferSize, DefForStatsGroup, &ddlContext, NULL, NULL);
          MatchId = OnlineMatchId::GetMatchId();
          DDL_SetUInt64(&toState, &ddlContext, MatchId);
        }
      }
      else
      {
        Scr_Error(COM_ERR_3134, scrContext, "LogStatMatchGUID: we don't have that player's stats yet");
      }
    }
    else
    {
      Scr_Error(COM_ERR_3133, scrContext, "LogStatMatchGUID: entity must be a player entity");
    }
  }
}

/*
==============
GScr_MainMP_IsEnumValueValid
==============
*/
void GScr_MainMP_IsEnumValueValid(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const char *String; 
  scr_string_t v4; 
  unsigned int RawHash; 
  StatsGroup StatsGroupByHash; 
  const DDLDef *DefForStatsGroup; 
  unsigned int v8; 
  bool IsEnumValueHashValid; 

  ConstString = Scr_GetConstString(scrContext, 0);
  String = Scr_GetString(scrContext, 1u);
  v4 = Scr_GetConstString(scrContext, 2u);
  RawHash = j_SL_GetRawHash(ConstString);
  StatsGroupByHash = Com_PlayerData_FindStatsGroupByHash(RawHash);
  DefForStatsGroup = Com_PlayerData_GetDefForStatsGroup(StatsGroupByHash);
  if ( !DefForStatsGroup && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5964, ASSERT_TYPE_SANITY, "( def )", (const char *)&queryFormat, "def") )
    __debugbreak();
  v8 = j_SL_GetRawHash(v4);
  IsEnumValueHashValid = DDL_IsEnumValueHashValid(DefForStatsGroup, String, v8);
  Scr_AddBool(scrContext, IsEnumValueHashValid);
}

/*
==============
GScr_MainMP_IsSquadsMode
==============
*/
void GScr_MainMP_IsSquadsMode(scrContext_t *scrContext)
{
  Scr_AddInt(scrContext, 0);
}

/*
==============
GScr_MainMP_GetSquadAssaultEnemyPrestige
==============
*/
void GScr_MainMP_GetSquadAssaultEnemyPrestige(scrContext_t *scrContext)
{
  Scr_AddInt(scrContext, 0);
}

/*
==============
GScr_MainMP_GetEnemySquadData
==============
*/
void GScr_MainMP_GetEnemySquadData(scrContext_t *scrContext)
{
  ;
}

/*
==============
GScr_MainMP_GetEnemySquadDogType
==============
*/
void GScr_MainMP_GetEnemySquadDogType(scrContext_t *scrContext)
{
  Scr_AddInt(scrContext, 0);
}

/*
==============
GScr_MainMP_GetSquadAssaultELO
==============
*/
void GScr_MainMP_GetSquadAssaultELO(scrContext_t *scrContext)
{
  Scr_AddInt(scrContext, 0);
}

/*
==============
GScr_MainMP_GetSquadAssaultSquadIndex
==============
*/
void GScr_MainMP_GetSquadAssaultSquadIndex(scrContext_t *scrContext)
{
  Scr_AddInt(scrContext, 0);
}

/*
==============
GScr_MainMP_SpawnLoopingSound
==============
*/
void GScr_MainMP_SpawnLoopingSound(scrContext_t *scrContext)
{
  if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_SLOW_SOFT_LAND) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 6062, ASSERT_TYPE_ASSERT, "( !Com_GameMode_SupportsFeature( Com_GameMode_Feature::SOUND_SERVER_CULL ) )", (const char *)&queryFormat, "!Com_GameMode_SupportsFeature( Com_GameMode_Feature::SOUND_SERVER_CULL )") )
    __debugbreak();
}

/*
==============
GScr_MainMP_Delete
==============
*/
void GScr_MainMP_Delete(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  if ( entref.entclass == ENTITY_CLASS_SOUNDENTITY )
  {
    ScrCmd_SoundEntity_Delete(scrContext, entref);
  }
  else
  {
    Entity = GetEntity(entref);
    GScr_Main_DeleteCommon(scrContext, Entity);
  }
}

/*
==============
GScr_MainMP_GetGameTypeIndex
==============
*/
void GScr_MainMP_GetGameTypeIndex(scrContext_t *scrContext)
{
  const char *String; 
  int index; 

  index = -1;
  String = Scr_GetString(scrContext, 0);
  Com_GameInfo_GetGameTypeIndexForInternalName(String, &index);
  Scr_AddInt(scrContext, index);
}

/*
==============
GScr_MainMP_IsAI
==============
*/
void GScr_MainMP_IsAI(scrContext_t *scrContext)
{
  const gentity_s *Entity; 

  if ( Scr_GetType(scrContext, 0) == VAR_POINTER && Scr_GetPointerType(scrContext, 0) == VAR_ENTITY && !(unsigned __int8)*(_DWORD *)&Scr_GetEntityRef(scrContext, 0).entclass && ((Entity = GScr_GetEntity(0), SV_BotIsBotEnt(Entity)) || SV_IsAgentEntity(Entity)) )
    Scr_AddBool(scrContext, 1);
  else
    Scr_AddBool(scrContext, 0);
}

/*
==============
GScr_IsPlayerNumber
==============
*/
void GScr_IsPlayerNumber(scrContext_t *scrContext)
{
  int Int; 

  Int = Scr_GetInt(scrContext, 0);
  if ( Int < 0 || Int >= level.maxclients )
    Scr_AddInt(scrContext, 0);
  else
    Scr_AddInt(scrContext, 1);
}

/*
==============
GScr_SetWinningTeam
==============
*/
void GScr_SetWinningTeam(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const char *v3; 
  const char *v4; 
  team_t outTeam; 

  ConstString = Scr_GetConstString(scrContext, 0);
  if ( Com_Teams_TeamFromString(ConstString, &outTeam) )
  {
    SV_MainMP_SetWinningTeam(outTeam);
  }
  else
  {
    v3 = SL_ConvertToString(ConstString);
    v4 = j_va("unknown team '%s'", v3);
    Scr_Error(COM_ERR_3136, scrContext, v4);
  }
}

/*
==============
GScr_Announcement
==============
*/
void GScr_Announcement(scrContext_t *scrContext)
{
  GScript *v2; 
  void (__fastcall *ConstructMessageString)(GScript *, scrContext_t *, int, int, const char *, char *, unsigned int); 
  unsigned int NumParam; 
  const char *v5; 
  char v6[1024]; 

  if ( !GScript::ms_gScriptSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.h", 183, ASSERT_TYPE_ASSERT, "( ms_gScriptSystem )", (const char *)&queryFormat, "ms_gScriptSystem") )
    __debugbreak();
  v2 = GScript::ms_gScriptSystem;
  ConstructMessageString = GScript::ms_gScriptSystem->ConstructMessageString;
  NumParam = Scr_GetNumParam(scrContext);
  ConstructMessageString(v2, scrContext, 0, NumParam - 1, "Announcement", v6, 1024u);
  v5 = j_va("%c \"%s\" 2", 99i64, v6);
  SV_Game_BroadcastServerCommand(SV_CMD_CAN_IGNORE, v5);
}

/*
==============
GScr_ClientAnnouncement
==============
*/
void GScr_ClientAnnouncement(scrContext_t *scrContext)
{
  gentity_s *Entity; 
  GScript *v3; 
  void (__fastcall *ConstructMessageString)(GScript *, scrContext_t *, int, int, const char *, char *, unsigned int); 
  unsigned int NumParam; 
  const char *v6; 
  unsigned int number; 
  const char *v8; 
  SvClient *CommonClient; 
  char v10[1024]; 

  Entity = GScr_GetEntity(0);
  if ( !GScript::ms_gScriptSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.h", 183, ASSERT_TYPE_ASSERT, "( ms_gScriptSystem )", (const char *)&queryFormat, "ms_gScriptSystem") )
    __debugbreak();
  v3 = GScript::ms_gScriptSystem;
  ConstructMessageString = GScript::ms_gScriptSystem->ConstructMessageString;
  NumParam = Scr_GetNumParam(scrContext);
  ConstructMessageString(v3, scrContext, 1, NumParam - 1, "Announcement", v10, 1024u);
  v6 = j_va("%c \"%s\" 2", 99i64, v10);
  number = Entity->s.number;
  v8 = v6;
  if ( number == -1 )
  {
    SV_Game_BroadcastServerCommand(SV_CMD_CAN_IGNORE, v6);
  }
  else
  {
    CommonClient = SvClient::GetCommonClient(number);
    CommonClient->SendServerCommand(CommonClient, SV_CMD_CAN_IGNORE, v8);
  }
}

/*
==============
GScr_SetTeamMode
==============
*/
void GScr_SetTeamMode(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const char *v3; 
  const char *v4; 

  ConstString = Scr_GetConstString(scrContext, 0);
  if ( ConstString == scr_const.teammode_ffa )
  {
    level.teammode = TEAMMODE_FFA;
  }
  else if ( ConstString == scr_const.teammode_axisallies )
  {
    level.teammode = TEAMMODE_AXIS_ALLIES;
  }
  else
  {
    v3 = SL_ConvertToString(ConstString);
    v4 = j_va("Illegal teammode string '%s'. Must be ffa, or axis_allies.", v3);
    Scr_Error(COM_ERR_3137, scrContext, v4);
  }
}

/*
==============
GScr_GetTeamScore
==============
*/
void GScr_GetTeamScore(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const char *v3; 
  const char *v4; 
  team_t outTeam; 

  ConstString = Scr_GetConstString(scrContext, 0);
  if ( Com_Teams_TeamFromString(ConstString, &outTeam) )
  {
    Scr_AddInt(scrContext, level.teamScores[outTeam]);
  }
  else
  {
    v3 = SL_ConvertToString(ConstString);
    v4 = j_va("unknown team '%s'", v3);
    Scr_Error(COM_ERR_3138, scrContext, v4);
  }
}

/*
==============
GScr_SetTeamScore
==============
*/
void GScr_SetTeamScore(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const char *v3; 
  const char *v4; 
  int Int; 
  team_t v6; 
  int v7; 
  unsigned __int16 v8; 
  unsigned __int16 v9; 
  team_t outTeam; 

  ConstString = Scr_GetConstString(scrContext, 0);
  if ( Com_Teams_TeamFromString(ConstString, &outTeam) )
  {
    Int = Scr_GetInt(scrContext, 1u);
    v6 = outTeam;
    v7 = Int;
    level.teamScores[outTeam] = Int;
    if ( SV_OnlineTournament_IsInTournament() )
    {
      if ( v6 == TEAM_TWO )
      {
        v8 = truncate_cast<unsigned short,int>(v7);
        SV_OnlineTournament_TeamScoreUpdated(TEAM_1, v8);
      }
      else if ( v6 == TEAM_ONE )
      {
        v9 = truncate_cast<unsigned short,int>(v7);
        SV_OnlineTournament_TeamScoreUpdated(TEAM_0, v9);
      }
    }
  }
  else
  {
    v3 = SL_ConvertToString(ConstString);
    v4 = j_va("unknown team '%s'", v3);
    Scr_Error(COM_ERR_3139, scrContext, v4);
  }
}

/*
==============
GScr_SetTeamPlacement
==============
*/
void GScr_SetTeamPlacement(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const char *v3; 
  const char *v4; 
  int Int; 
  team_t outTeam; 

  ConstString = Scr_GetConstString(scrContext, 0);
  if ( Com_Teams_TeamFromString(ConstString, &outTeam) )
  {
    Int = Scr_GetInt(scrContext, 1u);
    level.teamPlacements[outTeam] = Int;
  }
  else
  {
    v3 = SL_ConvertToString(ConstString);
    v4 = j_va("unknown team '%s'", v3);
    Scr_Error(COM_ERR_6536, scrContext, v4);
  }
}

/*
==============
GScr_SetClientNameMode
==============
*/
void GScr_SetClientNameMode(scrContext_t *scrContext)
{
  scr_string_t ConstString; 

  ConstString = Scr_GetConstString(scrContext, 0);
  if ( ConstString == scr_const.auto_change )
  {
    level.manualNameChange = 0;
  }
  else if ( ConstString == scr_const.manual_change )
  {
    level.manualNameChange = 1;
  }
  else
  {
    Scr_Error(COM_ERR_3140, scrContext, "Unknown mode");
  }
}

/*
==============
GScr_UpdateClientNames
==============
*/
void GScr_UpdateClientNames(scrContext_t *scrContext)
{
  int maxclients; 
  int v2; 
  char *name; 
  char *v4; 
  int v5; 
  int v6; 
  char dest[40]; 

  if ( !level.manualNameChange )
    Scr_Error(COM_ERR_3141, scrContext, "Only works in [manual_change] mode");
  maxclients = level.maxclients;
  v2 = 0;
  if ( level.maxclients > 0 )
  {
    name = level.clients->sess.cs.name;
    do
    {
      if ( *((_DWORD *)name - 193) == 2 )
      {
        v4 = name;
        do
        {
          v5 = (unsigned __int8)*(v4 - 192);
          v6 = (unsigned __int8)*v4 - v5;
          if ( v6 )
            break;
          ++v4;
        }
        while ( v5 );
        if ( v6 )
        {
          Core_strcpy(dest, 0x24ui64, name);
          Core_strcpy(name, 0x24ui64, name - 192);
          G_ClientMP_UserinfoChanged(v2);
          maxclients = level.maxclients;
        }
      }
      ++v2;
      name += 64592;
    }
    while ( v2 < maxclients );
  }
}

/*
==============
GScr_GetTeamPlayersAlive
==============
*/
void GScr_GetTeamPlayersAlive(scrContext_t *scrContext)
{
  scrContext_t *v1; 
  scr_string_t ConstString; 
  const char *v3; 
  const char *v4; 
  int v5; 
  signed int v6; 
  __int64 v7; 
  __int64 v8; 
  team_t v9; 
  __int64 v10; 
  __int64 v11; 
  team_t outTeam; 

  v1 = scrContext;
  ConstString = Scr_GetConstString(scrContext, 0);
  if ( Com_Teams_TeamFromString(ConstString, &outTeam) )
  {
    v5 = 0;
    v6 = 0;
    if ( (int)SvClient::ms_clientCount > 0 )
    {
      v7 = 0i64;
      v8 = 0i64;
      v9 = outTeam;
      do
      {
        if ( (unsigned int)v6 >= 0x800 )
        {
          LODWORD(v11) = 2048;
          LODWORD(v10) = v6;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v10, v11) )
            __debugbreak();
        }
        if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
          __debugbreak();
        if ( g_entities[v7].r.isInUse != g_entityIsInUse[v8] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
          __debugbreak();
        if ( g_entityIsInUse[v8] && g_entities[v7].client->sess.cs.team == v9 && g_entities[v7].health > 0 )
          ++v5;
        ++v6;
        ++v8;
        ++v7;
      }
      while ( v6 < (int)SvClient::ms_clientCount );
      v1 = scrContext;
    }
    Scr_AddInt(v1, v5);
  }
  else
  {
    v3 = SL_ConvertToString(ConstString);
    v4 = j_va("unknown team '%s'", v3);
    Scr_Error(COM_ERR_3142, v1, v4);
  }
}

/*
==============
GScr_SetPlayerTeamRank
==============
*/
void GScr_SetPlayerTeamRank(scrContext_t *scrContext)
{
  gentity_s *Entity; 
  int Int; 
  double Float; 

  if ( Scr_GetNumParam(scrContext) != 3 )
    Scr_ParamError(COM_ERR_3143, scrContext, 0, "setPlayerTeamRank [entity] [team] [rank]");
  Entity = GScr_GetEntity(0);
  Int = Scr_GetInt(scrContext, 1u);
  Float = Scr_GetFloat(scrContext, 2u);
  if ( !Entity )
    Scr_ParamError(COM_ERR_3144, scrContext, 0, "setPlayerTeamRank Error: param 1 is not an entity");
  if ( Int < 0 )
    Scr_ParamError(COM_ERR_3145, scrContext, 1u, "setPlayerTeamRank Error: param 2 must be >= 0");
  SV_ClientMP_SetClientRankValue(Entity->s.number, *(const float *)&Float);
}

/*
==============
GScr_EndXboxLiveLobby
==============
*/
void GScr_EndXboxLiveLobby(scrContext_t *scrContext)
{
  ;
}

/*
==============
GScr_GetAssignedTeam
==============
*/
void GScr_GetAssignedTeam(scrContext_t *scrContext)
{
  gentity_s *Entity; 
  int AssignedTeam; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_ParamError(COM_ERR_3146, scrContext, 0, "getAssignedTeam [player]");
  Entity = GScr_GetEntity(0);
  if ( !Entity )
    Scr_ParamError(COM_ERR_3147, scrContext, 0, "getAssignedTeam Error: param 1 is not an entity.");
  AssignedTeam = SV_ClientMP_GetAssignedTeam(Entity->s.number);
  Scr_AddInt(scrContext, AssignedTeam);
}

/*
==============
GScr_SendLeaderboards
==============
*/
void GScr_SendLeaderboards(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *v4; 
  unsigned int number; 
  const char *v6; 
  SvClient *CommonClient; 

  Entity = GetEntity(entref);
  if ( !Entity->client )
    Scr_Error(COM_ERR_3148, scrContext, "sendleaderboards: entity must be a player entity");
  v4 = j_va("%c", 73i64);
  number = Entity->s.number;
  v6 = v4;
  if ( number == -1 )
  {
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v4);
  }
  else
  {
    CommonClient = SvClient::GetCommonClient(number);
    CommonClient->SendServerCommand(CommonClient, SV_CMD_RELIABLE, v6);
  }
}

/*
==============
GScr_GetClientMatchData
==============
*/
void GScr_GetClientMatchData(scrContext_t *scrContext)
{
  SvGameGlobalsMP *SvGameGlobalsMP; 
  const DDLDef *Asset; 
  DDLState state; 
  DDLContext ddlContext; 

  SvGameGlobalsMP = SvGameGlobalsMP::GetSvGameGlobalsMP();
  if ( !SvGameGlobalsMP->clientMatchData.def[0] )
    Scr_Error(COM_ERR_3149, scrContext, "No match data def defined");
  Asset = Com_DDL_LoadAsset(SvGameGlobalsMP->clientMatchData.def);
  if ( !Com_DDL_CreateContext(SvGameGlobalsMP->clientMatchData.data, 24000, Asset, &ddlContext, NULL, NULL) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 6620, ASSERT_TYPE_ASSERT, "(Com_DDL_CreateContext( sv->clientMatchData.data, sizeof( sv->clientMatchData.data ), def, &buffer, 0, 0 ))", (const char *)&queryFormat, "Com_DDL_CreateContext( sv->clientMatchData.data, sizeof( sv->clientMatchData.data ), def, &buffer, NULL, NULL )") )
    __debugbreak();
  __asm { vpxor   xmm0, xmm0, xmm0 }
  *(_OWORD *)&state.member = _XMM0;
  state.isValid = 0;
  state.offset = 0;
  state.arrayIndex = -1;
  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
    Scr_Error(COM_ERR_3120, scrContext, "GetDDL: Can't use this function on the front end server");
  LiveStorage_InitializeDDLStateForStatsGroup(Asset, &state, STATSGROUP_IGNORE);
  GScr_Main_GetDDL(scrContext, &state, Asset, &ddlContext, "GetMatchData", 0);
}

/*
==============
GScr_GetMatchData
==============
*/
void GScr_GetMatchData(scrContext_t *scrContext)
{
  SvGameGlobalsMP *SvGameGlobalsMP; 
  const DDLDef *Asset; 
  DDLState state; 
  DDLContext ddlContext; 

  SvGameGlobalsMP = SvGameGlobalsMP::GetSvGameGlobalsMP();
  if ( !SvGameGlobalsMP->matchDataDef[0] )
    Scr_Error(COM_ERR_3150, scrContext, "No match data def defined");
  Asset = Com_DDL_LoadAsset(SvGameGlobalsMP->matchDataDef);
  Com_DDL_CreateContext(SvGameGlobalsMP->matchData, 2048, Asset, &ddlContext, NULL, NULL);
  __asm { vpxor   xmm0, xmm0, xmm0 }
  *(_OWORD *)&state.member = _XMM0;
  state.isValid = 0;
  state.offset = 0;
  state.arrayIndex = -1;
  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
    Scr_Error(COM_ERR_3120, scrContext, "GetDDL: Can't use this function on the front end server");
  LiveStorage_InitializeDDLStateForStatsGroup(Asset, &state, STATSGROUP_IGNORE);
  GScr_Main_GetDDL(scrContext, &state, Asset, &ddlContext, "GetMatchData", 0);
}

/*
==============
GScr_OnMatchBegin
==============
*/
void GScr_OnMatchBegin(scrContext_t *scrContext)
{
  const char *MatchIdString; 

  MatchIdString = OnlineMatchId::GetMatchIdString();
  SV_SetConfigstring(0x218u, MatchIdString);
  Com_Printf(16, "GScr_OnMatchBegin\n");
}

/*
==============
GScr_OnMatchEnd
==============
*/
void GScr_OnMatchEnd(scrContext_t *scrContext)
{
  Online_MatchData_RecordBreadcrumbCount();
  Com_Printf(16, "GScr_OnMatchEnd\n");
}

/*
==============
GScr_SendMatchData
==============
*/
void GScr_SendMatchData(scrContext_t *scrContext)
{
  if ( !SvGameGlobalsMP::GetSvGameGlobalsMP()->matchDataDef[0] )
    Scr_Error(COM_ERR_3151, scrContext, "No match data def defined");
  Cbuf_AddCall(LOCAL_CLIENT_0, SV_CmdsMP_SendMatchData);
}

/*
==============
GScr_ClearMatchData
==============
*/
void GScr_ClearMatchData(scrContext_t *scrContext)
{
  SvGameGlobalsMP *SvGameGlobalsMP; 

  SvGameGlobalsMP = SvGameGlobalsMP::GetSvGameGlobalsMP();
  memset_0(SvGameGlobalsMP->matchData, 0, sizeof(SvGameGlobalsMP->matchData));
  SvGameGlobalsMP->matchDataDef[0] = 0;
}

/*
==============
GScr_SetClientMatchData
==============
*/
void GScr_SetClientMatchData(scrContext_t *scrContext)
{
  SvGameGlobalsMP *SvGameGlobalsMP; 
  const DDLDef *Asset; 
  DDLState state; 
  DDLContext ddlContext; 

  SvGameGlobalsMP = SvGameGlobalsMP::GetSvGameGlobalsMP();
  if ( !SvGameGlobalsMP->clientMatchData.def[0] )
    Scr_Error(COM_ERR_3153, scrContext, "No match data def defined");
  Asset = Com_DDL_LoadAsset(SvGameGlobalsMP->clientMatchData.def);
  if ( !Com_DDL_CreateContext(SvGameGlobalsMP->clientMatchData.data, 24000, Asset, &ddlContext, NULL, NULL) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 6771, ASSERT_TYPE_ASSERT, "(Com_DDL_CreateContext( sv->clientMatchData.data, sizeof( sv->clientMatchData.data ), def, &buffer, 0, 0 ))", (const char *)&queryFormat, "Com_DDL_CreateContext( sv->clientMatchData.data, sizeof( sv->clientMatchData.data ), def, &buffer, NULL, NULL )") )
    __debugbreak();
  __asm { vpxor   xmm0, xmm0, xmm0 }
  *(_OWORD *)&state.member = _XMM0;
  state.isValid = 0;
  state.offset = 0;
  state.arrayIndex = -1;
  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
    Scr_Error(COM_ERR_3121, scrContext, "SetDDL: Can't use this function on the front end server");
  LiveStorage_InitializeDDLStateForStatsGroup(Asset, &state, STATSGROUP_IGNORE);
  GScr_Main_SetDDL(scrContext, &state, Asset, &ddlContext, "GScr_SetClientMatchData", 0);
}

/*
==============
GScr_SetMatchClientIP
==============
*/
void GScr_SetMatchClientIP(scrContext_t *scrContext)
{
  SvGameGlobalsMP *SvGameGlobalsMP; 
  gentity_s *Entity; 
  int Int; 
  __int64 number; 
  const DDLDef *Asset; 
  unsigned int RawHash; 
  unsigned int v10; 
  bool v11; 
  __int64 v12; 
  unsigned __int8 In4AddrByte; 
  unsigned __int8 v14; 
  unsigned __int8 v15; 
  unsigned __int8 v16; 
  unsigned int v17; 
  unsigned int v18; 
  unsigned int v19; 
  unsigned int v20; 
  VoteType *p_vote; 
  int v22; 
  unsigned int newOffset; 
  DDLState state; 
  DDLState fromState; 
  DDLState toState; 
  DDLContext ddlContext; 
  DDLState result; 
  bdAddr v29; 
  XNADDR outAddr; 

  fromState.isValid = 0;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  fromState.offset = 0;
  *(_OWORD *)&fromState.member = _XMM0;
  toState.isValid = 0;
  toState.offset = 0;
  *(_OWORD *)&toState.member = _XMM0;
  state.isValid = 0;
  state.offset = 0;
  *(_OWORD *)&state.member = _XMM0;
  fromState.arrayIndex = -1;
  toState.arrayIndex = -1;
  state.arrayIndex = -1;
  SvGameGlobalsMP = SvGameGlobalsMP::GetSvGameGlobalsMP();
  if ( !SvGameGlobalsMP->matchDataDef[0] )
    Scr_Error(COM_ERR_3154, scrContext, "No match data def defined");
  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    if ( SvPersistentGlobalsMP::IsFrontEndServer() )
      Scr_Error(COM_ERR_3156, scrContext, "SetMatchClientIP cannot be called for front-end server");
    Entity = GScr_GetEntity(0);
    Int = Scr_GetInt(scrContext, 1u);
    if ( !Entity )
      Scr_ParamError(COM_ERR_3157, scrContext, 0, "matchdata set ip Error: param 1 is not an entity");
    if ( !SV_IsDemoPlaying() )
    {
      number = Entity->s.number;
      SV_ClientMP_GetXNAddr(Entity->s.number, &outAddr);
      Asset = Com_DDL_LoadAsset(SvGameGlobalsMP->matchDataDef);
      Com_DDL_CreateContext(SvGameGlobalsMP->matchData, 2048, Asset, &ddlContext, NULL, NULL);
      fromState = *DDL_GetRootState(&result, Asset);
      RawHash = j_SL_GetRawHash(scr_const.players);
      DDL_MoveToNameByHash(&fromState, &fromState, RawHash, NULL);
      if ( DDL_MoveToIndex(&fromState, &fromState, Int) )
      {
        v10 = j_SL_GetRawHash(scr_const.playerIP);
        DDL_MoveToNameByHash(&fromState, &toState, v10, NULL);
        bdAddr::bdAddr(&v29);
        v11 = 1;
        newOffset = 0;
        v12 = 5i64;
        do
        {
          v11 = v11 && bdAddr::deserialize(&v29, &outAddr, 0x54u, newOffset, &newOffset);
          --v12;
        }
        while ( v12 );
        if ( v11 )
          bdAddr::deserialize(&v29, &outAddr, 0x54u, newOffset, &newOffset);
        In4AddrByte = bdSockAddr::getIn4AddrByte(&v29.m_address, 0);
        v14 = bdSockAddr::getIn4AddrByte(&v29.m_address, 1);
        v15 = bdSockAddr::getIn4AddrByte(&v29.m_address, 2);
        v16 = bdSockAddr::getIn4AddrByte(&v29.m_address, 3);
        v17 = j_SL_GetRawHash(scr_const.a);
        DDL_MoveToNameByHash(&toState, &state, v17, NULL);
        DDL_SetByte(&state, &ddlContext, In4AddrByte);
        v18 = j_SL_GetRawHash(scr_const.b);
        DDL_MoveToNameByHash(&toState, &state, v18, NULL);
        DDL_SetByte(&state, &ddlContext, v14);
        v19 = j_SL_GetRawHash(scr_const.c);
        DDL_MoveToNameByHash(&toState, &state, v19, NULL);
        DDL_SetByte(&state, &ddlContext, v15);
        v20 = j_SL_GetRawHash(scr_const.d);
        DDL_MoveToNameByHash(&toState, &state, v20, NULL);
        DDL_SetByte(&state, &ddlContext, v16);
        if ( mapvote_logging->current.integer == 1 )
        {
          p_vote = &Lobby_GetPartyData()->partyMembers[number].info.vote;
          Com_Printf(16, "Client %d voted for %d\n", (unsigned int)number, *(unsigned int *)p_vote);
          DDL_MoveToName(&fromState, &toState, "voteType");
          v22 = *p_vote;
          if ( (v22 < 0 || (unsigned int)v22 > 0xFF) && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned char __cdecl truncate_cast_impl<unsigned char,enum VoteType>(enum VoteType)", "unsigned", (unsigned __int8)v22, "signed", v22) )
            __debugbreak();
          DDL_SetByte(&toState, &ddlContext, v22);
        }
      }
    }
  }
  else
  {
    Scr_Error(COM_ERR_3155, scrContext, "Incorrect number of parameters.\n");
  }
}

/*
==============
GScr_RecordBreadcrumbDataForPlayer
==============
*/
void GScr_RecordBreadcrumbDataForPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  unsigned int clientNum; 
  BG_SynchronizedPlayerInfo *PlayerInfo; 
  const char *v6; 
  unsigned int Int; 
  int v8; 
  int v9; 

  Entity = GetEntity(entref);
  if ( Entity->client )
  {
    if ( Scr_GetNumParam(scrContext) == 3 )
    {
      clientNum = Entity->s.clientNum;
      PlayerInfo = SvClientMP::GetPlayerInfo(clientNum);
      if ( !PlayerInfo )
      {
        v6 = j_va("Online_MatchData_RecordBreadcrumbData - error accessing playerInfo for clientNum %d", clientNum);
        Scr_Error(COM_ERR_5699, scrContext, v6);
      }
      Int = Scr_GetInt(scrContext, 0);
      v8 = Scr_GetInt(scrContext, 1u);
      v9 = Scr_GetInt(scrContext, 2u);
      Online_MatchData_RecordBreadcrumbData(Entity, PlayerInfo, Int, v8, v9 != 0);
    }
    else
    {
      Scr_Error(COM_ERR_3159, scrContext, "RecordBreadcrumbDataForPlayer takes 3 params!\n");
    }
  }
  else
  {
    Scr_Error(COM_ERR_3158, scrContext, "RecordBreadcrumbDataForPlayer must be called on a player\n");
  }
}

/*
==============
GScr_LogPingHistogram
==============
*/
void GScr_LogPingHistogram(scrContext_t *scrContext, scr_entref_t entref)
{
  Com_Printf(15, "LogPingHistogram is deprecated. client network histograms are logged by sendClientNetworkTelemetry()");
}

/*
==============
GScr_SendClientNetworkTelemetry
==============
*/
void GScr_SendClientNetworkTelemetry(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( Entity->client )
    SV_ClientNetPerf_SendClientNetworkTelemetry(Entity->s.clientNum);
  else
    Scr_Error(COM_ERR_6218, scrContext, "GScr_SendClientNetworkTelemetry must be called on a client");
}

/*
==============
GScr_SendCollectedClientAnticheatData
==============
*/
void GScr_SendCollectedClientAnticheatData(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( Entity->client )
    SV_ClientAntiCheatMP_SendCollectedAntiCheatData(Entity->s.clientNum);
  else
    Scr_Error(COM_ERR_6537, scrContext, "GScr_SendCollectedClientAnticheatData must be called on a client");
}

/*
==============
GScr_IsTrialVersion
==============
*/
void GScr_IsTrialVersion(scrContext_t *scrContext, scr_entref_t entref)
{
  Scr_AddInt(scrContext, 0);
}

/*
==============
GScr_LogPlayerEndMatchData
==============
*/
void GScr_LogPlayerEndMatchData(scrContext_t *scrContext, scr_entref_t entref)
{
  Com_PrintWarning(16, "GScr_LogPlayerEndMatchData is deprecated\n");
}

/*
==============
GScr_LogPlayerEndMatchDataShotsHits
==============
*/
void GScr_LogPlayerEndMatchDataShotsHits(scrContext_t *scrContext, scr_entref_t entref)
{
  Com_PrintWarning(16, "GScr_LogPlayerEndMatchDataShotsHits is deprecated\n");
}

/*
==============
GScr_LogPlayerEndMatchDataMisc
==============
*/
void GScr_LogPlayerEndMatchDataMisc(scrContext_t *scrContext, scr_entref_t entref)
{
  Com_PrintWarning(16, "GScr_LogPlayerEndMatchDataMisc is deprecated\n");
}

/*
==============
GScr_LogPlayerEndMatchDataHeadBody
==============
*/
void GScr_LogPlayerEndMatchDataHeadBody(scrContext_t *scrContext, scr_entref_t entref)
{
  Com_PrintWarning(16, "GScr_LogPlayerEndMatchDataHeadBody is deprecated\n");
}

/*
==============
GScr_LogPlayerEndMatchDataGesture
==============
*/
void GScr_LogPlayerEndMatchDataGesture(scrContext_t *scrContext, scr_entref_t entref)
{
  Com_PrintWarning(16, "GScr_LogPlayerEndMatchDataGesture is deprecated\n");
}

/*
==============
GScr_LogPlayerEndMatchDataMatchResult
==============
*/
void GScr_LogPlayerEndMatchDataMatchResult(scrContext_t *scrContext, scr_entref_t entref)
{
  Com_PrintWarning(16, "GScr_LogPlayerEndMatchDataMatchResult is deprecated\n");
}

/*
==============
GScr_LogMatchDataLife
==============
*/
void GScr_LogMatchDataLife(scrContext_t *scrContext, scr_entref_t entref)
{
  SvGameGlobalsMP *SvGameGlobalsMP; 
  gentity_s *Entity; 
  int Int; 
  int v9; 
  const DDLDef *Asset; 
  unsigned int RawHash; 
  int v12; 
  unsigned int v13; 
  unsigned int v14; 
  unsigned int v15; 
  unsigned int v16; 
  unsigned int v17; 
  unsigned int v18; 
  unsigned int v19; 
  team_t team; 
  const char *v21; 
  DDLState toState; 
  int v23; 
  int v24; 
  DDLState v25; 
  DDLContext ddlContext; 
  DDLState fromState; 
  DDLState v28; 
  DDLState result; 
  vec3_t vectorValue; 

  fromState.isValid = 0;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  fromState.offset = 0;
  *(_OWORD *)&fromState.member = _XMM0;
  v28.isValid = 0;
  v28.offset = 0;
  *(_OWORD *)&v28.member = _XMM0;
  v25.isValid = 0;
  v25.offset = 0;
  *(_OWORD *)&v25.member = _XMM0;
  toState.isValid = 0;
  toState.offset = 0;
  *(_OWORD *)&toState.member = _XMM0;
  fromState.arrayIndex = -1;
  v28.arrayIndex = -1;
  v25.arrayIndex = -1;
  toState.arrayIndex = -1;
  SvGameGlobalsMP = SvGameGlobalsMP::GetSvGameGlobalsMP();
  if ( !SvGameGlobalsMP->matchDataDef[0] )
    Scr_Error(COM_ERR_3168, scrContext, "No match data def defined");
  if ( Scr_GetNumParam(scrContext) < 5 )
    Scr_Error(COM_ERR_3169, scrContext, "Missing information for match data life.");
  Entity = GetEntity(entref);
  if ( !Entity->client )
  {
    Scr_Error(COM_ERR_3170, scrContext, "LogMatchDataLife must be called on a client");
    if ( !Entity->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7158, ASSERT_TYPE_ASSERT, "( entity->client )", (const char *)&queryFormat, "entity->client", *(_QWORD *)&toState.isValid, *(_QWORD *)&toState.arrayIndex, toState.member, toState.ddlDef) )
      __debugbreak();
  }
  Int = Scr_GetInt(scrContext, 0);
  Scr_GetVector(scrContext, 1u, &vectorValue);
  v9 = Scr_GetInt(scrContext, 2u);
  v23 = Scr_GetInt(scrContext, 3u);
  v24 = Scr_GetInt(scrContext, 4u);
  Asset = Com_DDL_LoadAsset(SvGameGlobalsMP->matchDataDef);
  Com_DDL_CreateContext(SvGameGlobalsMP->matchData, 2048, Asset, &ddlContext, NULL, NULL);
  fromState = *DDL_GetRootState(&result, Asset);
  RawHash = j_SL_GetRawHash(scr_const.lifeCount);
  if ( !DDL_MoveToNameByHash(&fromState, &toState, RawHash, NULL) )
    Scr_Error(COM_ERR_3171, scrContext, "Invalid match data definition specified. Must contain a lifeCount field.");
  if ( DDL_GetType(&toState) != DDL_SHORT_TYPE )
    Scr_Error(COM_ERR_3172, scrContext, "Invalid match data definition specified. lifeCount must be a short");
  LOWORD(v12) = DDL_GetShort(&toState, &ddlContext);
  if ( (_WORD)v12 != 0xFFFF )
    DDL_SetShort(&toState, &ddlContext, v12 + 1);
  if ( (unsigned __int16)v12 < 0x1DBu )
  {
    v13 = j_SL_GetRawHash(scr_const.lives);
    if ( !DDL_MoveToNameByHash(&fromState, &v28, v13, NULL) )
      Scr_Error(COM_ERR_3173, scrContext, "Invalid match data definition specified. The lives field must be an indexed array of life structures");
    v12 = (unsigned __int16)v12;
    if ( !DDL_MoveToIndex(&v28, &v25, (unsigned __int16)v12) )
      Scr_Error(COM_ERR_3174, scrContext, "Invalid match data definition specified. The lives field must be an indexed array of life structures");
    v14 = j_SL_GetRawHash(scr_const.player);
    DDL_MoveToNameByHash(&v25, &toState, v14, NULL);
    DDL_SetInt(&toState, &ddlContext, Int);
    v15 = j_SL_GetRawHash(scr_const.spawnPos);
    DDL_MoveToNameByHash(&v25, &toState, v15, NULL);
    Com_DDL_SetShortVec3(&toState, &ddlContext, &vectorValue);
    v16 = j_SL_GetRawHash(scr_const.spawnTime_msFromMatchStart);
    DDL_MoveToNameByHash(&v25, &toState, v16, NULL);
    DDL_SetInt(&toState, &ddlContext, v9);
    v17 = j_SL_GetRawHash(scr_const.wasTacticalInsertion);
    DDL_MoveToNameByHash(&v25, &toState, v17, NULL);
    DDL_SetBool(&toState, &ddlContext, v23 != 0);
    v18 = j_SL_GetRawHash(scr_const.loadoutIndex);
    DDL_MoveToNameByHash(&v25, &toState, v18, NULL);
    DDL_SetByte(&toState, &ddlContext, v24);
    v19 = j_SL_GetRawHash(scr_const.team);
    DDL_MoveToNameByHash(&v25, &toState, v19, NULL);
    team = Entity->client->sess.cs.team;
    if ( team )
    {
      if ( team == TEAM_ONE )
      {
        v21 = "axis";
      }
      else if ( team == TEAM_TWO )
      {
        v21 = "allies";
      }
      else
      {
        if ( (unsigned int)(team - 201) > 1 )
          goto LABEL_30;
        v21 = "spectator";
      }
    }
    else
    {
      v21 = "none";
    }
    DDL_SetEnum(&toState, &ddlContext, v21);
    goto LABEL_30;
  }
  v12 = 474;
LABEL_30:
  Scr_AddInt(scrContext, v12);
}

/*
==============
GScr_LogMatchDataDeath
==============
*/
void GScr_LogMatchDataDeath(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int v3; 
  int Int; 
  gentity_s *Entity; 
  gentity_s *v9; 
  unsigned int v10; 
  unsigned int ArrayObject; 
  unsigned int ArraySize; 
  const char *v13; 
  unsigned int v14; 
  const char *v15; 
  const DDLDef *Asset; 
  unsigned int RawHash; 
  unsigned int v18; 
  unsigned int v19; 
  unsigned int v20; 
  unsigned int v21; 
  unsigned __int8 MotionState; 
  unsigned int v23; 
  float v24; 
  float v25; 
  __int128 v26; 
  float v30; 
  unsigned int v31; 
  unsigned int v32; 
  unsigned int v33; 
  unsigned int v34; 
  unsigned int v35; 
  unsigned int v36; 
  unsigned __int8 v37; 
  unsigned int v38; 
  unsigned int v39; 
  unsigned int v40; 
  unsigned int v41; 
  unsigned int v42; 
  unsigned int v43; 
  unsigned int v44; 
  unsigned int v45; 
  unsigned int v46; 
  unsigned int v47; 
  unsigned int attachmentsStringHash; 
  unsigned int weaponAltModeHash; 
  unsigned int v50; 
  int lifeIndex; 
  unsigned int v52; 
  unsigned int v53; 
  unsigned int v54; 
  bool v55; 
  bool outIsAlternate; 
  DDLState state; 
  DDLState lifeState; 
  int index; 
  int val; 
  int v61; 
  int v62; 
  int v63; 
  int v64; 
  int v65; 
  int v66; 
  int v67; 
  unsigned int attachmentsArrayId; 
  unsigned int attachmentsArrayCount; 
  DDLContext ddlContext; 
  char *fileName; 
  SvGameGlobalsMP *SvGameGlobalsMP; 
  char *String; 
  DDLState fromState; 
  DDLState toState; 
  DDLState result; 
  vec2_t forward; 
  Weapon r_weapon; 
  Weapon outWeapon; 

  v3 = 0;
  fromState.isValid = 0;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  Int = -1;
  fromState.offset = 0;
  fromState.arrayIndex = -1;
  *(_OWORD *)&fromState.member = _XMM0;
  toState.isValid = 0;
  toState.offset = 0;
  toState.arrayIndex = -1;
  *(_OWORD *)&toState.member = _XMM0;
  lifeState.isValid = 0;
  lifeState.offset = 0;
  lifeState.arrayIndex = -1;
  *(_OWORD *)&lifeState.member = _XMM0;
  state.isValid = 0;
  state.offset = 0;
  state.arrayIndex = -1;
  *(_OWORD *)&state.member = _XMM0;
  SvGameGlobalsMP = SvGameGlobalsMP::GetSvGameGlobalsMP();
  fileName = SvGameGlobalsMP->matchDataDef;
  if ( !SvGameGlobalsMP->matchDataDef[0] )
    Scr_Error(COM_ERR_3178, scrContext, "No match data def defined");
  Entity = GetEntity(entref);
  if ( !Entity->client )
  {
    Scr_Error(COM_ERR_3179, scrContext, "LogMatchDataDeath must be called on a client");
    if ( !Entity->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7494, ASSERT_TYPE_ASSERT, "( victim->client )", (const char *)&queryFormat, "victim->client") )
      __debugbreak();
  }
  if ( Scr_GetNumParam(scrContext) != 17 )
  {
    Scr_Error(COM_ERR_3180, scrContext, "GScr_LogMatchDataDeath requires 17 params\n");
    return;
  }
  index = Scr_GetInt(scrContext, 0);
  LODWORD(forward.v[0]) = Scr_GetInt(scrContext, 1u);
  if ( Scr_GetType(scrContext, 2u) )
    v9 = GScr_GetEntity(2u);
  else
    v9 = NULL;
  if ( Scr_GetType(scrContext, 3u) )
    Int = Scr_GetInt(scrContext, 3u);
  GScr_Main_GetWeaponParam(scrContext, 4u, &outWeapon, &outIsAlternate);
  String = (char *)Scr_GetString(scrContext, 5u);
  v63 = Scr_GetInt(scrContext, 6u);
  v61 = Scr_GetInt(scrContext, 7u);
  attachmentsArrayId = BGScr_Main_GetArrayObject(scrContext, 8u);
  v10 = attachmentsArrayId;
  val = Scr_GetInt(scrContext, 9u);
  if ( Scr_GetType(scrContext, 0xAu) )
  {
    GScr_Main_GetWeaponParam(scrContext, 0xAu, &r_weapon, &v55);
    ArrayObject = BGScr_Main_GetArrayObject(scrContext, 0xBu);
    ArraySize = GetArraySize(scrContext, ArrayObject);
    v3 = ArraySize;
    if ( ArraySize > 0x800 )
    {
      v13 = j_va("array is too large (%d > %d), need to increase sortable array size", ArraySize, 2048i64);
      Scr_ParamError(COM_ERR_3181, scrContext, 0xBu, v13);
      return;
    }
  }
  else
  {
    ArrayObject = 0;
    memset(&r_weapon, 0, 48);
    *(double *)&r_weapon.attachmentVariationIndices[21] = *(double *)&NULL_WEAPON.attachmentVariationIndices[21];
    *(_DWORD *)&r_weapon.weaponCamo = *(_DWORD *)&NULL_WEAPON.weaponCamo;
    v55 = 0;
  }
  v64 = Scr_GetInt(scrContext, 0xCu);
  v65 = Scr_GetInt(scrContext, 0xDu);
  v66 = Scr_GetInt(scrContext, 0xEu);
  v67 = Scr_GetInt(scrContext, 0xFu);
  v62 = Scr_GetInt(scrContext, 0x10u);
  v14 = GetArraySize(scrContext, v10);
  attachmentsArrayCount = v14;
  if ( v14 <= 0x800 )
  {
    Asset = Com_DDL_LoadAsset(fileName);
    Com_DDL_CreateContext(SvGameGlobalsMP->matchData, 2048, Asset, &ddlContext, NULL, NULL);
    fromState = *DDL_GetRootState(&result, Asset);
    RawHash = j_SL_GetRawHash(scr_const.lives);
    if ( !DDL_MoveToNameByHash(&fromState, &toState, RawHash, NULL) )
      Scr_Error(COM_ERR_3183, scrContext, "Invalid match data definition specified. The lives field must be an indexed array of life structures");
    if ( !DDL_MoveToIndex(&toState, &lifeState, index) )
      Scr_Error(COM_ERR_3184, scrContext, "Invalid match data definition specified. The lives field must be an indexed array of life structures");
    v18 = j_SL_GetRawHash(scr_const.deathTime_msFromMatchStart);
    DDL_MoveToNameByHash(&lifeState, &state, v18, NULL);
    DDL_SetInt(&state, &ddlContext, val);
    v19 = j_SL_GetRawHash(scr_const.player);
    DDL_MoveToNameByHash(&lifeState, &state, v19, NULL);
    DDL_SetInt(&state, &ddlContext, SLODWORD(forward.v[0]));
    v20 = j_SL_GetRawHash(scr_const.deathPos);
    DDL_MoveToNameByHash(&lifeState, &state, v20, NULL);
    Com_DDL_SetShortVec3(&state, &ddlContext, &Entity->r.currentOrigin);
    v21 = j_SL_GetRawHash(scr_const.deathAngles);
    DDL_MoveToNameByHash(&lifeState, &state, v21, NULL);
    Com_DDL_SetShortVec3(&state, &ddlContext, &Entity->r.currentAngles);
    MotionState = Online_MatchData_GetMotionState(&Entity->client->ps);
    v23 = j_SL_GetRawHash(scr_const.victimMotionState);
    DDL_MoveToNameByHash(&lifeState, &state, v23, NULL);
    DDL_SetByte(&state, &ddlContext, MotionState);
    if ( v9 && v9->client )
    {
      YawVectors2D(Entity->r.currentAngles.v[1], &forward, NULL);
      v24 = Entity->r.currentOrigin.v[0] - v9->r.currentOrigin.v[0];
      v26 = LODWORD(Entity->r.currentOrigin.v[1]);
      v25 = Entity->r.currentOrigin.v[1] - v9->r.currentOrigin.v[1];
      *(float *)&v26 = fsqrt((float)(v25 * v25) + (float)(v24 * v24));
      _XMM3 = v26;
      __asm
      {
        vcmpless xmm0, xmm3, cs:__real@80000000
        vblendvps xmm0, xmm3, xmm1, xmm0
      }
      *(float *)&v26 = v24 * (float)(1.0 / *(float *)&_XMM0);
      v30 = v25 * (float)(1.0 / *(float *)&_XMM0);
      v31 = j_SL_GetRawHash(scr_const.attacker);
      DDL_MoveToNameByHash(&lifeState, &state, v31, NULL);
      DDL_SetInt(&state, &ddlContext, Int);
      v32 = j_SL_GetRawHash(scr_const.attackerPos);
      DDL_MoveToNameByHash(&lifeState, &state, v32, NULL);
      Com_DDL_SetShortVec3(&state, &ddlContext, &v9->r.currentOrigin);
      v33 = j_SL_GetRawHash(scr_const.dotOfDeath);
      DDL_MoveToNameByHash(&lifeState, &state, v33, NULL);
      DDL_SetFloat(&state, &ddlContext, (float)(*(float *)&v26 * forward.v[0]) + (float)(v30 * forward.v[1]));
      v34 = j_SL_GetRawHash(scr_const.attackerIsJuggernaut);
      DDL_MoveToNameByHash(&lifeState, &state, v34, NULL);
      DDL_SetBool(&state, &ddlContext, v61 != 0);
      v35 = j_SL_GetRawHash(scr_const.attackerCurrentLifeIndex);
      DDL_MoveToNameByHash(&lifeState, &state, v35, NULL);
      DDL_SetShort(&state, &ddlContext, v62);
      v36 = j_SL_GetRawHash(scr_const.attackerAngles);
      DDL_MoveToNameByHash(&lifeState, &state, v36, NULL);
      Com_DDL_SetShortVec3(&state, &ddlContext, &v9->r.currentAngles);
      v37 = Online_MatchData_GetMotionState(&v9->client->ps);
      v38 = j_SL_GetRawHash(scr_const.attackerMotionState);
      DDL_MoveToNameByHash(&lifeState, &state, v38, NULL);
      DDL_SetByte(&state, &ddlContext, v37);
    }
    else
    {
      v39 = j_SL_GetRawHash(scr_const.attacker);
      DDL_MoveToNameByHash(&lifeState, &state, v39, NULL);
      DDL_SetInt(&state, &ddlContext, 255);
      v40 = j_SL_GetRawHash(scr_const.attackerPos);
      DDL_MoveToNameByHash(&lifeState, &state, v40, NULL);
      Com_DDL_SetShortVec3(&state, &ddlContext, &Entity->r.currentOrigin);
    }
    v41 = j_SL_GetRawHash(scr_const.mod);
    DDL_MoveToNameByHash(&lifeState, &state, v41, NULL);
    DDL_SetEnum(&state, &ddlContext, String);
    v42 = j_SL_GetRawHash(scr_const.modifiers);
    DDL_MoveToNameByHash(&lifeState, &state, v42, NULL);
    v43 = j_SL_GetRawHash(scr_const.killstreak);
    DDL_MoveToNameByHash(&state, &state, v43, NULL);
    DDL_SetBool(&state, &ddlContext, v63 != 0);
    v44 = j_SL_GetRawHash(scr_const.victimWasADS);
    DDL_MoveToNameByHash(&lifeState, &state, v44, NULL);
    DDL_SetBool(&state, &ddlContext, v64 != 0);
    v45 = j_SL_GetRawHash(scr_const.attackerWasADS);
    DDL_MoveToNameByHash(&lifeState, &state, v45, NULL);
    DDL_SetBool(&state, &ddlContext, v65 != 0);
    v46 = j_SL_GetRawHash(scr_const.victimWasInAttackerFOV);
    DDL_MoveToNameByHash(&lifeState, &state, v46, NULL);
    DDL_SetBool(&state, &ddlContext, v66 != 0);
    v47 = j_SL_GetRawHash(scr_const.attackerWasInVictimFOV);
    DDL_MoveToNameByHash(&lifeState, &state, v47, NULL);
    DDL_SetBool(&state, &ddlContext, v67 != 0);
    LogMatchDataDeathWhileReloadingHelper(scrContext, &lifeState, &ddlContext, Entity);
    attachmentsStringHash = j_SL_GetRawHash(scr_const.attacker_weapon_attachments);
    weaponAltModeHash = j_SL_GetRawHash(scr_const.attacker_weapon_alt_mode);
    v50 = j_SL_GetRawHash(scr_const.attacker_weapon);
    lifeIndex = index;
    LogMatchDataDeathWeaponHelper(scrContext, &outWeapon, outIsAlternate, attachmentsArrayCount, attachmentsArrayId, v50, weaponAltModeHash, attachmentsStringHash, &lifeState, &ddlContext, index);
    if ( r_weapon.weaponIdx )
    {
      v52 = j_SL_GetRawHash(scr_const.victim_current_weapon_attachments);
      v53 = j_SL_GetRawHash(scr_const.victim_current_weapon_alt_mode);
      v54 = j_SL_GetRawHash(scr_const.victim_current_weapon);
      LogMatchDataDeathWeaponHelper(scrContext, &r_weapon, v55, v3, ArrayObject, v54, v53, v52, &lifeState, &ddlContext, lifeIndex);
    }
  }
  else
  {
    v15 = j_va("array is too large (%d > %d), need to increase sortable array size", v14, 2048i64);
    Scr_ParamError(COM_ERR_3182, scrContext, 0, v15);
  }
}

/*
==============
GScr_MatchDataPlayerExistingSlot
==============
*/
void GScr_MatchDataPlayerExistingSlot(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  unsigned __int8 ActiveGameMode; 
  int v6; 
  unsigned int v8; 
  SvGameGlobalsMP *SvGameGlobalsMP; 
  gentity_s *v10; 
  const char *v11; 
  const DDLDef *Asset; 
  unsigned int RawHash; 
  unsigned int v14; 
  int Int; 
  unsigned int v16; 
  unsigned int v17; 
  const char *String; 
  bool v19; 
  unsigned int v20; 
  unsigned int v21; 
  unsigned __int64 UInt64; 
  unsigned int v23; 
  unsigned __int64 v24; 
  Online_ErrorReporting *InstancePtr; 
  const char *v26; 
  unsigned __int64 outUnoId; 
  unsigned __int64 outFirstPartyUserId; 
  DDLState state; 
  DLogFirstPartyAccountType outFirstPartyAccountType; 
  unsigned __int64 outUserSessionId; 
  DDLState fromState; 
  DDLState v33; 
  DDLState v34; 
  DDLState toState; 
  DDLState v36; 
  DDLContext ddlContext; 
  DDLState result; 
  EntityClass entclass; 
  char v40; 
  ClientPlatform outClientPlatform; 

  entclass = entref.entclass;
  entnum = entref.entnum;
  ActiveGameMode = Com_GameMode_GetActiveGameMode();
  v6 = -1;
  if ( BG_GameInterface_GameModeIsMP((GameModeType)ActiveGameMode) )
  {
    __asm { vpxor   xmm0, xmm0, xmm0 }
    v8 = 0;
    fromState.offset = 0;
    toState.isValid = 0;
    toState.offset = 0;
    v36.isValid = 0;
    v36.offset = 0;
    v33.isValid = 0;
    v33.offset = 0;
    v34.isValid = 0;
    v34.offset = 0;
    state.isValid = 0;
    state.offset = 0;
    outUnoId = 0i64;
    outFirstPartyUserId = 0i64;
    outUserSessionId = 0i64;
    v40 = 0;
    fromState.isValid = 0;
    fromState.arrayIndex = -1;
    *(_OWORD *)&fromState.member = _XMM0;
    toState.arrayIndex = -1;
    *(_OWORD *)&toState.member = _XMM0;
    v36.arrayIndex = -1;
    *(_OWORD *)&v36.member = _XMM0;
    v33.arrayIndex = -1;
    *(_OWORD *)&v33.member = _XMM0;
    v34.arrayIndex = -1;
    *(_OWORD *)&v34.member = _XMM0;
    state.arrayIndex = -1;
    *(_OWORD *)&state.member = _XMM0;
    SvGameGlobalsMP = SvGameGlobalsMP::GetSvGameGlobalsMP();
    if ( !SvGameGlobalsMP->matchDataDef[0] )
      Scr_Error(COM_ERR_3185, scrContext, "No matchdata def defined");
    if ( entclass )
    {
      Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
      v10 = NULL;
    }
    else
    {
      if ( entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7709, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
        __debugbreak();
      v10 = &g_entities[entnum];
      if ( !v10->client )
      {
        v11 = j_va("entity %i is not a player", entnum);
        Scr_ObjectError(COM_ERR_3680, scrContext, v11);
      }
    }
    if ( SV_BotIsBotEntClient(v10) || SV_ClientMP_IsTestClient(v10->s.number) == 1 )
      v40 = 1;
    else
      DLog_Util_GetPlayerHeaderFieldsFromEntity(v10, &outUnoId, &outFirstPartyUserId, &outFirstPartyAccountType, &outUserSessionId, &outClientPlatform);
    Asset = Com_DDL_LoadAsset(SvGameGlobalsMP->matchDataDef);
    if ( !Asset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7721, ASSERT_TYPE_ASSERT, "(def)", (const char *)&queryFormat, "def") )
      __debugbreak();
    Com_DDL_CreateContext(SvGameGlobalsMP->matchData, 2048, Asset, &ddlContext, NULL, NULL);
    fromState = *DDL_GetRootState(&result, Asset);
    RawHash = j_SL_GetRawHash(scr_const.commonMatchData);
    if ( !DDL_MoveToNameByHash(&fromState, &toState, RawHash, NULL) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7726, ASSERT_TYPE_ASSERT, "(DDL_MoveToNameByHash( &root, &commonMatchData, SL_GetRawHash( scr_const.commonMatchData ) ))", (const char *)&queryFormat, "DDL_MoveToNameByHash( &root, &commonMatchData, SL_GetRawHash( scr_const.commonMatchData ) )") )
      __debugbreak();
    v14 = j_SL_GetRawHash(scr_const.player_count);
    if ( !DDL_MoveToNameByHash(&toState, &state, v14, NULL) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7727, ASSERT_TYPE_ASSERT, "(DDL_MoveToNameByHash( &commonMatchData, &temp, SL_GetRawHash( scr_const.player_count ) ))", (const char *)&queryFormat, "DDL_MoveToNameByHash( &commonMatchData, &temp, SL_GetRawHash( scr_const.player_count ) )") )
      __debugbreak();
    Int = DDL_GetInt(&state, &ddlContext);
    v16 = j_SL_GetRawHash(scr_const.players);
    if ( !DDL_MoveToNameByHash(&fromState, &v36, v16, NULL) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7730, ASSERT_TYPE_ASSERT, "(DDL_MoveToNameByHash( &root, &players, SL_GetRawHash( scr_const.players ) ))", (const char *)&queryFormat, "DDL_MoveToNameByHash( &root, &players, SL_GetRawHash( scr_const.players ) )") )
      __debugbreak();
    if ( Int > 0 )
    {
      while ( DDL_MoveToIndex(&v36, &v33, v8) )
      {
        if ( v40 )
        {
          v17 = j_SL_GetRawHash(scr_const.gamertag);
          if ( !DDL_MoveToNameByHash(&v33, &state, v17, NULL) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7739, ASSERT_TYPE_ASSERT, "(DDL_MoveToNameByHash( &player, &temp, SL_GetRawHash( scr_const.gamertag ) ))", (const char *)&queryFormat, "DDL_MoveToNameByHash( &player, &temp, SL_GetRawHash( scr_const.gamertag ) )") )
            __debugbreak();
          String = DDL_GetString(&state, &ddlContext);
          v19 = I_strncmp(String, v10->client->sess.cs.name, 0x7FFFFFFFui64) == 0;
        }
        else
        {
          v20 = j_SL_GetRawHash(scr_const.player);
          if ( !DDL_MoveToNameByHash(&v33, &v34, v20, NULL) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7751, ASSERT_TYPE_ASSERT, "(DDL_MoveToNameByHash( &player, &playerHeader, SL_GetRawHash( scr_const.player ) ))", (const char *)&queryFormat, "DDL_MoveToNameByHash( &player, &playerHeader, SL_GetRawHash( scr_const.player ) )") )
            __debugbreak();
          v21 = j_SL_GetRawHash(scr_const.uno_id);
          if ( !DDL_MoveToNameByHash(&v34, &state, v21, NULL) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7752, ASSERT_TYPE_ASSERT, "(DDL_MoveToNameByHash( &playerHeader, &temp, SL_GetRawHash( scr_const.uno_id ) ))", (const char *)&queryFormat, "DDL_MoveToNameByHash( &playerHeader, &temp, SL_GetRawHash( scr_const.uno_id ) )") )
            __debugbreak();
          UInt64 = DDL_GetUInt64(&state, &ddlContext);
          if ( UInt64 )
          {
            v19 = outUnoId == UInt64;
          }
          else
          {
            v23 = j_SL_GetRawHash(scr_const.first_party_user_id);
            if ( !DDL_MoveToNameByHash(&v34, &state, v23, NULL) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7767, ASSERT_TYPE_ASSERT, "(DDL_MoveToNameByHash( &playerHeader, &temp, SL_GetRawHash( scr_const.first_party_user_id ) ))", (const char *)&queryFormat, "DDL_MoveToNameByHash( &playerHeader, &temp, SL_GetRawHash( scr_const.first_party_user_id ) )") )
              __debugbreak();
            v24 = DDL_GetUInt64(&state, &ddlContext);
            v19 = v24 == outFirstPartyUserId;
          }
        }
        if ( v19 )
        {
          v6 = v8;
          goto LABEL_51;
        }
        if ( (int)++v8 >= Int )
          goto LABEL_51;
      }
      Com_PrintWarning(16, "Warning - GScr_MatchDataPlayerExistingSlot - warning, unable to access player slot %d in matchdata\n", v8);
      InstancePtr = Online_ErrorReporting::GetInstancePtr();
      v26 = j_va("GScr_MatchDataPlayerExistingSlot playerIndex %d", v8);
      Online_ErrorReporting::ReportError(InstancePtr, (Online_Error_CAT_DEFAULT_t)0x10000, v26);
    }
  }
LABEL_51:
  Scr_AddInt(scrContext, v6);
}

/*
==============
GScr_GetPlayerIP
==============
*/
void GScr_GetPlayerIP(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  EntityClass entclass; 
  unsigned int v5; 
  gentity_s *v6; 
  const char *v7; 
  bool v8; 
  __int64 v9; 
  int *v10; 
  int v11; 
  unsigned int newOffset[3]; 
  bdAddr v13; 
  XNADDR outAddr; 

  entnum = entref.entnum;
  entclass = entref.entclass;
  if ( Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_6192, scrContext, "GScr_GetPlayerIP takes no parameters");
  v5 = 0;
  if ( entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v6 = NULL;
  }
  else
  {
    if ( entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7817, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v6 = &g_entities[entnum];
    if ( !v6->client )
    {
      v7 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v7);
    }
  }
  if ( SV_ClientMP_GetXNAddr(v6->s.number, &outAddr) )
  {
    bdAddr::bdAddr(&v13);
    v8 = 1;
    newOffset[0] = 0;
    v9 = 5i64;
    do
    {
      v8 = v8 && bdAddr::deserialize(&v13, &outAddr, 0x54u, newOffset[0], newOffset);
      --v9;
    }
    while ( v9 );
    if ( v8 )
      bdAddr::deserialize(&v13, &outAddr, 0x54u, newOffset[0], newOffset);
    LOBYTE(v11) = bdSockAddr::getIn4AddrByte(&v13.m_address, 0);
    BYTE1(v11) = bdSockAddr::getIn4AddrByte(&v13.m_address, 1);
    BYTE2(v11) = bdSockAddr::getIn4AddrByte(&v13.m_address, 2);
    HIBYTE(v11) = bdSockAddr::getIn4AddrByte(&v13.m_address, 3);
  }
  else
  {
    v11 = 0;
  }
  Scr_MakeArray(scrContext);
  v10 = &v11;
  do
  {
    Scr_AddInt(scrContext, *(unsigned __int8 *)v10);
    Scr_AddArray(scrContext);
    ++v5;
    v10 = (int *)((char *)v10 + 1);
  }
  while ( v5 < 4 );
}

/*
==============
GScr_GetUnusedLootCachePoints
==============
*/
void GScr_GetUnusedLootCachePoints(scrContext_t *scrContext)
{
  float v1; 
  vec3_t *p_vectorValue; 
  float v4; 
  bool bDistance2D; 
  int NumParam; 
  double Float; 
  double v8; 
  vec3_t vectorValue; 

  v1 = FLOAT_3_4028235e38;
  p_vectorValue = NULL;
  v4 = 0.0;
  bDistance2D = 0;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam >= 2 )
  {
    Scr_GetVector(scrContext, 0, &vectorValue);
    Float = Scr_GetFloat(scrContext, 1u);
    p_vectorValue = &vectorValue;
    v1 = *(float *)&Float;
    if ( NumParam >= 3 )
    {
      v8 = Scr_GetFloat(scrContext, 2u);
      v4 = *(float *)&v8;
      if ( NumParam >= 4 )
        bDistance2D = Scr_GetInt(scrContext, 3u) != 0;
    }
  }
  GScr_GetQuestPoints_Internal(scrContext, 0xFFFDu, p_vectorValue, v1, v4, bDistance2D, NULL);
}

/*
==============
GScr_GetLootSpawnPoint
==============
*/
void GScr_GetLootSpawnPoint(scrContext_t *scrContext)
{
  __int64 Int; 
  SpawnGroupPoint *v3; 
  int v4; 
  unsigned __int16 cluster; 
  int v6; 
  unsigned int CanonicalString; 
  unsigned int v8; 
  unsigned int v9; 
  unsigned int v10; 
  unsigned int v11; 
  const char *v12; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    Int = Scr_GetInt(scrContext, 0);
    if ( (int)Int < 0 || (int)Int >= cm.mapEnts->spawnGroupLoot.pointCount )
    {
      v12 = j_va("Requested point index %d is invalid, valid range is [0, %d)", (unsigned int)Int, cm.mapEnts->spawnGroupLoot.pointCount);
      Scr_Error(COM_ERR_6543, scrContext, v12);
    }
    else
    {
      v3 = &cm.mapEnts->spawnGroupLoot.points[Int];
      v4 = 0;
      cluster = v3->cluster;
      if ( cluster == 0xFFFD )
      {
        v6 = 1;
      }
      else
      {
        v6 = 0;
        if ( cluster == 0xFFFB )
          v6 = 2;
      }
      Scr_MakeStruct(scrContext);
      Scr_AddInt(scrContext, Int);
      CanonicalString = SL_GetCanonicalString("index");
      Scr_AddStructField(scrContext, CanonicalString);
      Scr_AddVector(scrContext, v3->origin.v);
      v8 = SL_GetCanonicalString("origin");
      Scr_AddStructField(scrContext, v8);
      Scr_AddVector(scrContext, v3->angles.v);
      v9 = SL_GetCanonicalString("angles");
      Scr_AddStructField(scrContext, v9);
      Scr_AddInt(scrContext, v6);
      v10 = SL_GetCanonicalString("type");
      Scr_AddStructField(scrContext, v10);
      LOBYTE(v4) = ScriptableSv_IsLootPointInUse(Int);
      Scr_AddInt(scrContext, v4);
      v11 = SL_GetCanonicalString("game_extrainfo");
      Scr_AddStructField(scrContext, v11);
    }
  }
  else
  {
    Scr_Error(COM_ERR_6542, scrContext, "Usage: GetLootSpawnPoint( <pointIndex> )");
  }
}

/*
==============
GScr_GetQuestPoints
==============
*/
void GScr_GetQuestPoints(scrContext_t *scrContext)
{
  float v1; 
  vec3_t *p_vectorValue; 
  float v4; 
  bool bDistance2D; 
  int NumParam; 
  double Float; 
  double v8; 
  int type; 
  vec3_t vectorValue; 

  v1 = FLOAT_3_4028235e38;
  p_vectorValue = NULL;
  v4 = 0.0;
  bDistance2D = 0;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam >= 1 )
  {
    if ( NumParam == 2 )
    {
      Scr_Error(COM_ERR_6541, scrContext, "GetQuestPoints(): Must specify at least a maximum radius when providing an origin.\n");
    }
    else
    {
      type = Scr_GetInt(scrContext, 0);
      if ( NumParam >= 3 )
      {
        Scr_GetVector(scrContext, 1u, &vectorValue);
        Float = Scr_GetFloat(scrContext, 2u);
        p_vectorValue = &vectorValue;
        v1 = *(float *)&Float;
        if ( NumParam >= 4 )
        {
          v8 = Scr_GetFloat(scrContext, 3u);
          v4 = *(float *)&v8;
          if ( NumParam >= 5 )
            bDistance2D = Scr_GetInt(scrContext, 4u) != 0;
        }
      }
      GScr_GetQuestPoints_Internal(scrContext, 0xFFFBu, p_vectorValue, v1, v4, bDistance2D, &type);
    }
  }
  else
  {
    Scr_Error(COM_ERR_6540, scrContext, "GetQuestPoints(): Must specify a point type.\n");
  }
}

/*
==============
GScr_DisableLootSpawnPoint
==============
*/
void GScr_DisableLootSpawnPoint(scrContext_t *scrContext)
{
  __int64 Int; 
  SpawnGroupPoint *v3; 
  unsigned __int16 cluster; 
  const char *v5; 
  const char *v6; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    Int = Scr_GetInt(scrContext, 0);
    if ( (int)Int < 0 || (int)Int >= cm.mapEnts->spawnGroupLoot.pointCount )
    {
      v6 = j_va("DisableLootSpawnPoint - Requested point index %d is invalid, valid range is [0, %d)", Int, cm.mapEnts->spawnGroupLoot.pointCount);
      Scr_Error(COM_ERR_6545, scrContext, v6);
    }
    else
    {
      v3 = &cm.mapEnts->spawnGroupLoot.points[Int];
      cluster = v3->cluster;
      if ( ((cluster + 4) & 0xFFFD) != 0 )
      {
        if ( cluster == 0xFFFD )
        {
          v3->cluster = -4;
          ScriptableSv_DisableQuestPointIndex(Int);
        }
        else if ( cluster == 0xFFFB )
        {
          v3->cluster = -2;
          ScriptableSv_DisableQuestPointIndex(Int);
        }
        else
        {
          v5 = j_va("DisableLootSpawnPoint - Requested point index %d is not a cache or quest point", Int);
          Scr_Error(COM_ERR_6546, scrContext, v5);
        }
      }
    }
  }
  else
  {
    Scr_Error(COM_ERR_6544, scrContext, "Usage: DisableLootSpawnPoint( <pointIndex> )");
  }
}

/*
==============
GScr_GetLootSpawnPointCount
==============
*/
void GScr_GetLootSpawnPointCount(scrContext_t *scrContext)
{
  Scr_AddInt(scrContext, cm.mapEnts->spawnGroupLoot.pointCount);
}

/*
==============
GScr_GetLootSpawnScriptableIndexFirst
==============
*/
void GScr_GetLootSpawnScriptableIndexFirst(scrContext_t *scrContext)
{
  ScriptableCommon_AssertCountsInitialized();
  Scr_AddInt(scrContext, g_scriptableWorldCounts.runtimeInstanceCount);
}

/*
==============
GScr_GetDateTime
==============
*/
void GScr_GetDateTime(scrContext_t *scrContext)
{
  qtime_s qtime; 

  Com_RealTime(0, &qtime);
  Scr_MakeArray(scrContext);
  Scr_AddInt(scrContext, qtime.tm_year - 100);
  Scr_AddArray(scrContext);
  Scr_AddInt(scrContext, qtime.tm_mon + 1);
  Scr_AddArray(scrContext);
  Scr_AddInt(scrContext, qtime.tm_mday);
  Scr_AddArray(scrContext);
  Scr_AddInt(scrContext, qtime.tm_hour);
  Scr_AddArray(scrContext);
  Scr_AddInt(scrContext, qtime.tm_min);
  Scr_AddArray(scrContext);
  Scr_AddInt(scrContext, qtime.tm_sec);
  Scr_AddArray(scrContext);
}

/*
==============
GScr_AnalyticsReset
==============
*/
void GScr_AnalyticsReset(scrContext_t *scrContext)
{
  ;
}

/*
==============
GScr_AnalyticsAddEvent
==============
*/
void GScr_AnalyticsAddEvent(scrContext_t *scrContext)
{
  ;
}

/*
==============
GScr_AnalyticsWriteCSV
==============
*/
void GScr_AnalyticsWriteCSV(scrContext_t *scrContext)
{
  ;
}

/*
==============
GScr_RequestGameLobbyRemainIntact
==============
*/
void GScr_RequestGameLobbyRemainIntact(scrContext_t *scrContext)
{
  OnlineMatchmakerOmniscient::RequestGameLobbyRemainIntact(&OnlineMatchmakerOmniscient::ms_instance);
}

/*
==============
GScr_BRMatchStarted
==============
*/
void GScr_BRMatchStarted(scrContext_t *scrContext)
{
  ;
}

/*
==============
GScr_VerifyBunkerCode
==============
*/
void GScr_VerifyBunkerCode(scrContext_t *scrContext)
{
  unsigned __int64 Int; 
  int v3; 
  int v4; 
  __int128 v5; 
  int v6; 
  int v7; 

  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_Error(COM_ERR_6549, scrContext, "VerifyBunkerCode() USAGE: VerifyBunkerCode( <bunkerIndex>, <bunkerCode> )\n");
  Int = Scr_GetInt(scrContext, 0);
  v3 = Scr_GetInt(scrContext, 1u);
  v4 = 0;
  v6 = 27495810;
  v7 = 60274513;
  v5 = _xmm;
  if ( Int < 6 )
    LOBYTE(v4) = *((_DWORD *)&v5 + Int) == v3;
  Scr_AddBool(scrContext, v4);
}

/*
==============
GScr_GetAltBunkerIndexForName
==============
*/
void GScr_GetAltBunkerIndexForName(scrContext_t *scrContext)
{
  int v2; 
  const char *String; 
  const char *v4; 
  __int64 v5; 
  __int64 v6; 
  int v7; 
  __int64 v8; 
  int v9; 
  int v10; 
  int v11; 
  const char *v12; 
  __int64 v13; 
  int v14; 
  __int64 v15; 
  int v16; 
  int v17; 
  int v18; 
  const char *v19; 
  __int64 v20; 
  int v21; 
  __int64 v22; 
  int v23; 
  int v24; 
  int v25; 
  const char *v26; 
  __int64 v27; 
  int v28; 
  __int64 v29; 
  int v30; 
  int v31; 
  int v32; 
  const char *v33; 
  __int64 v34; 
  int v35; 
  __int64 v36; 
  int v37; 
  int v38; 
  int v39; 
  const char *v40; 
  __int64 v41; 
  int v42; 
  __int64 v43; 
  int v44; 
  int v45; 
  int v46; 
  const char *v47; 
  signed __int64 v48; 
  int v49; 
  __int64 v50; 
  int v51; 
  int v52; 
  int v53; 

  v2 = -1;
  String = Scr_GetString(scrContext, 0);
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_6550, scrContext, "GetAltBunkerIndexForName() USAGE: GetAltBunkerIndexForName( <bunkerScriptableInstanceName> )\n");
  v4 = "br_bunker_alt_barn";
  v5 = 0x7FFFFFFFi64;
  v6 = 0x7FFFFFFFi64;
  if ( !String && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
    __debugbreak();
  while ( 1 )
  {
    v7 = (unsigned __int8)v4[String - "br_bunker_alt_barn"];
    v8 = v6;
    v9 = *(unsigned __int8 *)v4++;
    --v6;
    if ( !v8 )
    {
LABEL_14:
      v2 = 0;
      goto LABEL_15;
    }
    if ( v7 != v9 )
    {
      v10 = v7 + 32;
      if ( (unsigned int)(v7 - 65) > 0x19 )
        v10 = v7;
      v7 = v10;
      v11 = v9 + 32;
      if ( (unsigned int)(v9 - 65) > 0x19 )
        v11 = v9;
      if ( v7 != v11 )
        break;
    }
    if ( !v7 )
      goto LABEL_14;
  }
  v12 = "bunker_door_3";
  v13 = 0x7FFFFFFFi64;
  if ( !String && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
    __debugbreak();
  while ( 1 )
  {
    v14 = (unsigned __int8)v12[String - "bunker_door_3"];
    v15 = v13;
    v16 = *(unsigned __int8 *)v12++;
    --v13;
    if ( !v15 )
    {
LABEL_27:
      v2 = 1;
      goto LABEL_15;
    }
    if ( v14 != v16 )
    {
      v17 = v14 + 32;
      if ( (unsigned int)(v14 - 65) > 0x19 )
        v17 = v14;
      v14 = v17;
      v18 = v16 + 32;
      if ( (unsigned int)(v16 - 65) > 0x19 )
        v18 = v16;
      if ( v14 != v18 )
        break;
    }
    if ( !v14 )
      goto LABEL_27;
  }
  v19 = "br_bunker_alt_outhouse";
  v20 = 0x7FFFFFFFi64;
  if ( !String && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
    __debugbreak();
  while ( 1 )
  {
    v21 = (unsigned __int8)v19[String - "br_bunker_alt_outhouse"];
    v22 = v20;
    v23 = *(unsigned __int8 *)v19++;
    --v20;
    if ( !v22 )
    {
LABEL_39:
      v2 = 2;
      goto LABEL_15;
    }
    if ( v21 != v23 )
    {
      v24 = v21 + 32;
      if ( (unsigned int)(v21 - 65) > 0x19 )
        v24 = v21;
      v21 = v24;
      v25 = v23 + 32;
      if ( (unsigned int)(v23 - 65) > 0x19 )
        v25 = v23;
      if ( v21 != v25 )
        break;
    }
    if ( !v21 )
      goto LABEL_39;
  }
  v26 = "bunker_door_1";
  v27 = 0x7FFFFFFFi64;
  if ( !String && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
    __debugbreak();
  while ( 1 )
  {
    v28 = (unsigned __int8)v26[String - "bunker_door_1"];
    v29 = v27;
    v30 = *(unsigned __int8 *)v26++;
    --v27;
    if ( !v29 )
    {
LABEL_51:
      v2 = 3;
      goto LABEL_15;
    }
    if ( v28 != v30 )
    {
      v31 = v28 + 32;
      if ( (unsigned int)(v28 - 65) > 0x19 )
        v31 = v28;
      v28 = v31;
      v32 = v30 + 32;
      if ( (unsigned int)(v30 - 65) > 0x19 )
        v32 = v30;
      if ( v28 != v32 )
        break;
    }
    if ( !v28 )
      goto LABEL_51;
  }
  v33 = "br_bunker_alt_shed_01";
  v34 = 0x7FFFFFFFi64;
  if ( !String && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
    __debugbreak();
  do
  {
    v35 = (unsigned __int8)v33[String - "br_bunker_alt_shed_01"];
    v36 = v34;
    v37 = *(unsigned __int8 *)v33++;
    --v34;
    if ( !v36 )
      break;
    if ( v35 != v37 )
    {
      v38 = v35 + 32;
      if ( (unsigned int)(v35 - 65) > 0x19 )
        v38 = v35;
      v35 = v38;
      v39 = v37 + 32;
      if ( (unsigned int)(v37 - 65) > 0x19 )
        v39 = v37;
      if ( v35 != v39 )
      {
        v40 = "br_bunker_alt_shed_02";
        v41 = 0x7FFFFFFFi64;
        if ( !String && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
          __debugbreak();
        while ( 1 )
        {
          v42 = (unsigned __int8)v40[String - "br_bunker_alt_shed_02"];
          v43 = v41;
          v44 = *(unsigned __int8 *)v40++;
          --v41;
          if ( !v43 )
            goto LABEL_63;
          if ( v42 != v44 )
          {
            v45 = v42 + 32;
            if ( (unsigned int)(v42 - 65) > 0x19 )
              v45 = v42;
            v42 = v45;
            v46 = v44 + 32;
            if ( (unsigned int)(v44 - 65) > 0x19 )
              v46 = v44;
            if ( v42 != v46 )
            {
              v47 = "bunker_door_10";
              if ( !String && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
                __debugbreak();
              v48 = String - "bunker_door_10";
              do
              {
                v49 = (unsigned __int8)v47[v48];
                v50 = v5;
                v51 = *(unsigned __int8 *)v47++;
                --v5;
                if ( !v50 )
                  break;
                if ( v49 != v51 )
                {
                  v52 = v49 + 32;
                  if ( (unsigned int)(v49 - 65) > 0x19 )
                    v52 = v49;
                  v49 = v52;
                  v53 = v51 + 32;
                  if ( (unsigned int)(v51 - 65) > 0x19 )
                    v53 = v51;
                  if ( v49 != v53 )
                    goto LABEL_15;
                }
              }
              while ( v49 );
              v2 = 5;
              goto LABEL_15;
            }
          }
          if ( !v42 )
          {
            v2 = 4;
            goto LABEL_15;
          }
        }
      }
    }
  }
  while ( v35 );
LABEL_63:
  v2 = 4;
LABEL_15:
  Scr_AddInt(scrContext, v2);
}

/*
==============
GScr_MatchDataFillPlayerHeader
==============
*/
void GScr_MatchDataFillPlayerHeader(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  unsigned __int8 ActiveGameMode; 
  gentity_s *v6; 
  SvGameGlobalsMP *SvGameGlobalsMP; 
  unsigned int Int; 
  const char *v10; 
  ComErrorCode v11; 
  const DDLDef *Asset; 
  unsigned int RawHash; 
  unsigned int v15; 
  unsigned int v16; 
  unsigned int v17; 
  unsigned int v18; 
  unsigned int v19; 
  unsigned int v20; 
  Online_ErrorReporting *InstancePtr; 
  const char *v22; 
  DDLState state; 
  DDLState v24; 
  unsigned __int64 outUnoId; 
  unsigned __int64 outUserSessionId; 
  unsigned __int64 outFirstPartyUserId; 
  DDLState result; 
  DDLState fromState; 
  DDLState toState; 
  DDLContext ddlContext; 
  EntityClass entclass; 
  ClientPlatform outClientPlatform; 
  DLogFirstPartyAccountType outFirstPartyAccountType; 

  entclass = entref.entclass;
  entnum = entref.entnum;
  ActiveGameMode = Com_GameMode_GetActiveGameMode();
  if ( !BG_GameInterface_GameModeIsMP((GameModeType)ActiveGameMode) )
    return;
  v6 = NULL;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  fromState.isValid = 0;
  fromState.offset = 0;
  fromState.arrayIndex = -1;
  *(_OWORD *)&fromState.member = _XMM0;
  toState.isValid = 0;
  toState.offset = 0;
  toState.arrayIndex = -1;
  *(_OWORD *)&toState.member = _XMM0;
  SvGameGlobalsMP = SvGameGlobalsMP::GetSvGameGlobalsMP();
  if ( !SvGameGlobalsMP->matchDataDef[0] )
    Scr_Error(COM_ERR_5871, scrContext, "No matchdata def defined");
  if ( !Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_5680, scrContext, "Missing information for GScr_MatchDataFillPlayerHeader.");
  Int = Scr_GetInt(scrContext, 0);
  if ( entclass )
  {
    v10 = "not an entity";
    v11 = COM_ERR_3681;
  }
  else
  {
    if ( entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7916, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v6 = &g_entities[entnum];
    if ( v6->client )
      goto LABEL_14;
    v10 = j_va("entity %i is not a player", entnum);
    v11 = COM_ERR_3680;
  }
  Scr_ObjectError(v11, scrContext, v10);
LABEL_14:
  DLog_Util_GetPlayerHeaderFieldsFromEntity(v6, &outUnoId, &outFirstPartyUserId, &outFirstPartyAccountType, &outUserSessionId, &outClientPlatform);
  Asset = Com_DDL_LoadAsset(SvGameGlobalsMP->matchDataDef);
  if ( !Asset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7921, ASSERT_TYPE_ASSERT, "(def)", (const char *)&queryFormat, "def") )
    __debugbreak();
  Com_DDL_CreateContext(SvGameGlobalsMP->matchData, 2048, Asset, &ddlContext, NULL, NULL);
  fromState = *DDL_GetRootState(&result, Asset);
  RawHash = j_SL_GetRawHash(scr_const.players);
  if ( DDL_MoveToNameByHash(&fromState, &toState, RawHash, NULL) )
  {
    __asm { vpxor   xmm0, xmm0, xmm0 }
    result.isValid = 0;
    result.offset = 0;
    result.arrayIndex = -1;
    *(_OWORD *)&result.member = _XMM0;
    *(_OWORD *)&v24.member = _XMM0;
    *(_OWORD *)&state.member = _XMM0;
    v24.isValid = 0;
    v24.offset = 0;
    v24.arrayIndex = -1;
    state.isValid = 0;
    state.offset = 0;
    state.arrayIndex = -1;
    if ( DDL_MoveToIndex(&toState, &result, Int) )
    {
      v15 = j_SL_GetRawHash(scr_const.player);
      if ( !DDL_MoveToNameByHash(&result, &v24, v15, NULL) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7933, ASSERT_TYPE_ASSERT, "(DDL_MoveToNameByHash( &player, &playerHeader, SL_GetRawHash( scr_const.player ) ))", (const char *)&queryFormat, "DDL_MoveToNameByHash( &player, &playerHeader, SL_GetRawHash( scr_const.player ) )", *(_QWORD *)&state.isValid, *(_QWORD *)&state.arrayIndex, state.member, state.ddlDef, *(_QWORD *)&v24.isValid, *(_QWORD *)&v24.arrayIndex, v24.member, v24.ddlDef) )
        __debugbreak();
      v16 = j_SL_GetRawHash(scr_const.uno_id);
      if ( !DDL_MoveToNameByHash(&v24, &state, v16, NULL) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7934, ASSERT_TYPE_ASSERT, "(DDL_MoveToNameByHash( &playerHeader, &temp, SL_GetRawHash( scr_const.uno_id ) ))", (const char *)&queryFormat, "DDL_MoveToNameByHash( &playerHeader, &temp, SL_GetRawHash( scr_const.uno_id ) )") )
        __debugbreak();
      DDL_SetUInt64(&state, &ddlContext, outUnoId);
      v17 = j_SL_GetRawHash(scr_const.user_session_id);
      if ( !DDL_MoveToNameByHash(&v24, &state, v17, NULL) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7937, ASSERT_TYPE_ASSERT, "(DDL_MoveToNameByHash( &playerHeader, &temp, SL_GetRawHash( scr_const.user_session_id ) ))", (const char *)&queryFormat, "DDL_MoveToNameByHash( &playerHeader, &temp, SL_GetRawHash( scr_const.user_session_id ) )") )
        __debugbreak();
      DDL_SetUInt64(&state, &ddlContext, outUserSessionId);
      v18 = j_SL_GetRawHash(scr_const.first_party_user_id);
      if ( !DDL_MoveToNameByHash(&v24, &state, v18, NULL) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7940, ASSERT_TYPE_ASSERT, "(DDL_MoveToNameByHash( &playerHeader, &temp, SL_GetRawHash( scr_const.first_party_user_id ) ))", (const char *)&queryFormat, "DDL_MoveToNameByHash( &playerHeader, &temp, SL_GetRawHash( scr_const.first_party_user_id ) )") )
        __debugbreak();
      DDL_SetUInt64(&state, &ddlContext, outFirstPartyUserId);
      v19 = j_SL_GetRawHash(scr_const.first_party_account_type);
      if ( !DDL_MoveToNameByHash(&v24, &state, v19, NULL) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7943, ASSERT_TYPE_ASSERT, "(DDL_MoveToNameByHash( &playerHeader, &temp, SL_GetRawHash( scr_const.first_party_account_type ) ))", (const char *)&queryFormat, "DDL_MoveToNameByHash( &playerHeader, &temp, SL_GetRawHash( scr_const.first_party_account_type ) )") )
        __debugbreak();
      DDL_SetUInt(&state, &ddlContext, outFirstPartyAccountType);
      v20 = j_SL_GetRawHash(scr_const.platform);
      if ( !DDL_MoveToNameByHash(&v24, &state, v20, NULL) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7946, ASSERT_TYPE_ASSERT, "(DDL_MoveToNameByHash( &playerHeader, &temp, SL_GetRawHash( scr_const.platform ) ))", (const char *)&queryFormat, "DDL_MoveToNameByHash( &playerHeader, &temp, SL_GetRawHash( scr_const.platform ) )") )
        __debugbreak();
      DDL_SetUInt(&state, &ddlContext, (char)outClientPlatform);
    }
    else
    {
      Com_PrintWarning(16, "Warning - GScr_MatchDataFillPlayerHeader - unable to move to slot %d in player array", Int);
      InstancePtr = Online_ErrorReporting::GetInstancePtr();
      v22 = j_va("GScr_MatchDataFillPlayerHeader playerIndex %d", Int);
      Online_ErrorReporting::ReportError(InstancePtr, (Online_Error_CAT_DEFAULT_t)0x10000, v22);
    }
  }
  else
  {
    Scr_Error(COM_ERR_5684, scrContext, "GScr_MatchDataFillPlayerHeader - unable to move to players array in matchdata");
  }
}

/*
==============
GScr_IsInTournament
==============
*/
void GScr_IsInTournament(scrContext_t *scrContext)
{
  bool v2; 

  v2 = SV_OnlineTournament_IsInTournament();
  Scr_AddBool(scrContext, v2);
}

/*
==============
GScr_UpdateTournamentRoundTime
==============
*/
void GScr_UpdateTournamentRoundTime(scrContext_t *scrContext)
{
  double Float; 
  int Int; 
  MatchTimeMode v4; 

  if ( SV_OnlineTournament_IsInTournament() )
  {
    Float = Scr_GetFloat(scrContext, 0);
    Int = Scr_GetInt(scrContext, 1u);
    v4 = (char)Int;
    if ( (Int < 0 || (unsigned int)Int > 0xFF) && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "enum MatchTimeMode __cdecl truncate_cast_impl<enum MatchTimeMode,int>(int)", "unsigned", (unsigned __int8)Int, "signed", Int) )
      __debugbreak();
    SV_OnlineTournament_RoundTimeUpdated((int)*(float *)&Float, v4);
  }
}

/*
==============
GScr_DoTournamentEndGame
==============
*/
void GScr_DoTournamentEndGame(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const char *v3; 

  if ( SV_OnlineTournament_IsInTournament() )
  {
    ConstString = Scr_GetConstString(scrContext, 0);
    if ( ConstString == scr_const.allies )
    {
      SV_OnlineTournament_MatchComplete(TEAM_1);
    }
    else
    {
      if ( ConstString != scr_const.axis )
      {
        v3 = SL_ConvertToString(ConstString);
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 8032, ASSERT_TYPE_ASSERT, "(winner == scr_const.axis)", "%s\n\tUnexpected winner %s", "winner == scr_const.axis", v3) )
          __debugbreak();
      }
      SV_OnlineTournament_MatchComplete(TEAM_0);
    }
  }
}

/*
==============
GScr_LogTournamentDeath
==============
*/
void GScr_LogTournamentDeath(scrContext_t *scrContext)
{
  const char *String; 
  const char *v3; 
  int Int; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  if ( SV_OnlineTournament_IsInTournament() )
  {
    String = Scr_GetString(scrContext, 0);
    v3 = Scr_GetString(scrContext, 1u);
    GScr_Main_GetWeaponParam(scrContext, 2u, &outWeapon, &outIsAlternate);
    Int = Scr_GetInt(scrContext, 3u);
    SV_OnlineTournament_KillUpdate(String, v3, outWeapon.weaponIdx, Int != 0);
  }
}

/*
==============
GScr_SetMatchData
==============
*/
void GScr_SetMatchData(scrContext_t *scrContext)
{
  SvGameGlobalsMP *SvGameGlobalsMP; 
  const dvar_t *v4; 
  const DDLDef *Asset; 
  DDLState state; 
  DDLContext ddlContext; 

  SvGameGlobalsMP = SvGameGlobalsMP::GetSvGameGlobalsMP();
  if ( SvGameGlobalsMP->matchDataDef[0] )
  {
LABEL_7:
    Asset = Com_DDL_LoadAsset(SvGameGlobalsMP->matchDataDef);
    if ( Com_DDL_CreateContext(SvGameGlobalsMP->matchData, 2048, Asset, &ddlContext, NULL, NULL) )
    {
      __asm { vpxor   xmm0, xmm0, xmm0 }
      *(_OWORD *)&state.member = _XMM0;
      state.isValid = 0;
      state.offset = 0;
      state.arrayIndex = -1;
      if ( SvPersistentGlobalsMP::IsFrontEndServer() )
        Scr_Error(COM_ERR_3121, scrContext, "SetDDL: Can't use this function on the front end server");
      LiveStorage_InitializeDDLStateForStatsGroup(Asset, &state, STATSGROUP_IGNORE);
      GScr_Main_SetDDL(scrContext, &state, Asset, &ddlContext, "SetMatchData", 0);
    }
    else
    {
      Scr_Error(COM_ERR_6128, scrContext, "Could not create match data context.  Match data may be too big so we can't load it!");
    }
    return;
  }
  v4 = DVARBOOL_online_matchdata_enabled;
  if ( !DVARBOOL_online_matchdata_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "online_matchdata_enabled") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v4);
  if ( v4->current.enabled )
  {
    Scr_Error(COM_ERR_3189, scrContext, "No match data def defined");
    goto LABEL_7;
  }
}

/*
==============
GScr_SetMatchDataDef
==============
*/
void GScr_SetMatchDataDef(scrContext_t *scrContext)
{
  SvGameGlobalsMP *SvGameGlobalsMP; 
  const char *String; 
  __int64 v4; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    SvGameGlobalsMP = SvGameGlobalsMP::GetSvGameGlobalsMP();
    String = Scr_GetString(scrContext, 0);
    if ( I_strnicmp(String, SvGameGlobalsMP->matchDataDef, 0x7FFFFFFFui64) )
    {
      if ( SvGameGlobalsMP->matchDataDef[0] )
      {
        Scr_Error(COM_ERR_3191, scrContext, "Already set match data def\n");
      }
      else
      {
        v4 = -1i64;
        do
          ++v4;
        while ( String[v4] );
        if ( (unsigned int)v4 < 0x40 )
        {
          Core_strcpy(SvGameGlobalsMP->matchDataDef, 0x40ui64, String);
          Online_MatchData_Load();
        }
        else
        {
          Scr_ParamError(COM_ERR_3192, scrContext, 0, "def name too long.\n");
        }
      }
    }
    else
    {
      Com_PrintWarning(16, "SetMatchDataDef -- trying to set matchdata defName to the existing value\n");
    }
  }
  else
  {
    Scr_Error(COM_ERR_3190, scrContext, "SetMatchDataDef takes exactly one argument: <def asset name>\n");
  }
}

/*
==============
GScr_SetClientMatchDataDef
==============
*/
void GScr_SetClientMatchDataDef(scrContext_t *scrContext)
{
  SvGameGlobalsMP *SvGameGlobalsMP; 
  const char *String; 
  __int64 v4; 
  const DDLDef *Asset; 
  DDLContext ddlContext; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_3193, scrContext, "SetClientMatchDataDef takes exactly one argument: <def asset name>\n");
  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
    Scr_Error(COM_ERR_3194, scrContext, "Cannot use client match data for front-end server");
  SvGameGlobalsMP = SvGameGlobalsMP::GetSvGameGlobalsMP();
  String = Scr_GetString(scrContext, 0);
  if ( I_strnicmp(String, SvGameGlobalsMP->clientMatchData.def, 0x7FFFFFFFui64) )
  {
    if ( SvGameGlobalsMP->clientMatchData.def[0] )
      Scr_Error(COM_ERR_3195, scrContext, "Already set client match data def\n");
    v4 = -1i64;
    do
      ++v4;
    while ( String[v4] );
    if ( (unsigned int)v4 >= 0x40 )
      Scr_ParamError(COM_ERR_3196, scrContext, 0, "def name too long.\n");
    Core_strcpy(SvGameGlobalsMP->clientMatchData.def, 0x40ui64, String);
    Asset = Com_DDL_LoadAsset(SvGameGlobalsMP->clientMatchData.def);
    if ( !DDL_ResetContext(SvGameGlobalsMP->clientMatchData.data, 24000, Asset, &ddlContext, NULL, NULL) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 8200, ASSERT_TYPE_ASSERT, "(DDL_ResetContext( sv->clientMatchData.data, sizeof( sv->clientMatchData.data ), def, &buffer, 0, 0 ))", (const char *)&queryFormat, "DDL_ResetContext( sv->clientMatchData.data, sizeof( sv->clientMatchData.data ), def, &buffer, NULL, NULL )") )
      __debugbreak();
  }
}

/*
==============
GScr_LogClientMatchDataDeath
==============
*/
void GScr_LogClientMatchDataDeath(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *v3; 
  int Int; 
  SvGameGlobalsMP *SvGameGlobalsMP; 
  gentity_s *Entity; 
  gclient_s *client; 
  const DDLDef *Asset; 
  unsigned int RawHash; 
  int v13; 
  unsigned int v14; 
  unsigned int v15; 
  unsigned int v16; 
  unsigned int v17; 
  const vec3_t *p_currentOrigin; 
  unsigned int v19; 
  unsigned int v20; 
  DDLState toState; 
  int val; 
  DDLState v23; 
  DDLState fromState; 
  DDLState v25; 
  DDLContext ddlContext; 
  DDLState result; 
  vec2_t vec; 

  v3 = NULL;
  fromState.isValid = 0;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  Int = -1;
  fromState.offset = 0;
  fromState.arrayIndex = -1;
  *(_OWORD *)&fromState.member = _XMM0;
  v25.isValid = 0;
  v25.offset = 0;
  v25.arrayIndex = -1;
  *(_OWORD *)&v25.member = _XMM0;
  v23.isValid = 0;
  v23.offset = 0;
  v23.arrayIndex = -1;
  *(_OWORD *)&v23.member = _XMM0;
  toState.isValid = 0;
  toState.offset = 0;
  toState.arrayIndex = -1;
  *(_OWORD *)&toState.member = _XMM0;
  SvGameGlobalsMP = SvGameGlobalsMP::GetSvGameGlobalsMP();
  if ( !SvGameGlobalsMP->clientMatchData.def[0] )
    Scr_Error(COM_ERR_3198, scrContext, "No client match data def defined");
  Entity = GetEntity(entref);
  client = Entity->client;
  if ( !client )
  {
    Scr_Error(COM_ERR_3199, scrContext, "LogClientMatchDataDeath must be called on a client");
    client = Entity->client;
  }
  if ( !client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 8259, ASSERT_TYPE_ASSERT, "( victim->client )", (const char *)&queryFormat, "victim->client", *(_QWORD *)&toState.isValid, *(_QWORD *)&toState.arrayIndex, toState.member, toState.ddlDef) )
    __debugbreak();
  val = Scr_GetInt(scrContext, 1u);
  if ( Scr_GetType(scrContext, 2u) )
    v3 = GScr_GetEntity(2u);
  if ( Scr_GetType(scrContext, 2u) )
    Int = Scr_GetInt(scrContext, 3u);
  Asset = Com_DDL_LoadAsset(SvGameGlobalsMP->clientMatchData.def);
  if ( !Com_DDL_CreateContext(SvGameGlobalsMP->clientMatchData.data, 24000, Asset, &ddlContext, NULL, NULL) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 8267, ASSERT_TYPE_ASSERT, "(Com_DDL_CreateContext( sv->clientMatchData.data, sizeof( sv->clientMatchData.data ), def, &buffer, 0, 0 ))", (const char *)&queryFormat, "Com_DDL_CreateContext( sv->clientMatchData.data, sizeof( sv->clientMatchData.data ), def, &buffer, NULL, NULL )") )
    __debugbreak();
  fromState = *DDL_GetRootState(&result, Asset);
  RawHash = j_SL_GetRawHash(scr_const.deathCount);
  if ( !DDL_MoveToNameByHash(&fromState, &toState, RawHash, NULL) )
    Scr_Error(COM_ERR_3200, scrContext, "Invalid client match data definition specified. Must contain a deathCount field.");
  if ( DDL_GetType(&toState) != DDL_SHORT_TYPE )
    Scr_Error(COM_ERR_3201, scrContext, "Invalid client match data definition specified. deathCount must be a short");
  LOWORD(v13) = DDL_GetShort(&toState, &ddlContext);
  if ( (__int16)v13 < 300 )
  {
    DDL_SetShort(&toState, &ddlContext, v13 + 1);
    v14 = j_SL_GetRawHash(scr_const.deaths);
    if ( !DDL_MoveToNameByHash(&fromState, &v25, v14, NULL) )
      Scr_Error(COM_ERR_3202, scrContext, "Invalid client match data definition specified. The deaths field must be an indexed array of life structures");
    v13 = (__int16)v13;
    if ( !DDL_MoveToIndex(&v25, &v23, (__int16)v13) )
      Scr_Error(COM_ERR_3203, scrContext, "Invalid client match data definition specified. The deaths field must be an indexed array of life structures");
    v15 = j_SL_GetRawHash(scr_const.player);
    DDL_MoveToNameByHash(&v23, &toState, v15, NULL);
    DDL_SetInt(&toState, &ddlContext, val);
    NormalizePosition(scrContext, &Entity->r.currentOrigin, &vec);
    v16 = j_SL_GetRawHash(scr_const.deathPos);
    DDL_MoveToNameByHash(&v23, &toState, v16, NULL);
    Com_DDL_SetByteVec2(&toState, &ddlContext, &vec);
    if ( v3 && v3->client )
    {
      v17 = j_SL_GetRawHash(scr_const.attacker);
      DDL_MoveToNameByHash(&v23, &toState, v17, NULL);
      DDL_SetInt(&toState, &ddlContext, Int);
      p_currentOrigin = &v3->r.currentOrigin;
    }
    else
    {
      if ( (unsigned __int8)Com_GameMode_GetActiveGameMode() != LONG )
      {
        v19 = j_SL_GetRawHash(scr_const.attacker);
        DDL_MoveToNameByHash(&v23, &toState, v19, NULL);
        DDL_SetInt(&toState, &ddlContext, 255);
      }
      p_currentOrigin = &Entity->r.currentOrigin;
    }
    NormalizePosition(scrContext, p_currentOrigin, &vec);
    v20 = j_SL_GetRawHash(scr_const.attackerPos);
    DDL_MoveToNameByHash(&v23, &toState, v20, NULL);
    Com_DDL_SetByteVec2(&toState, &ddlContext, &vec);
  }
  else
  {
    v13 = (__int16)v13;
  }
  Scr_AddInt(scrContext, v13);
}

/*
==============
GScr_GetMatchRulesData
==============
*/
void GScr_GetMatchRulesData(scrContext_t *scrContext)
{
  GameStateInfo *v3; 
  const DDLDef *Asset; 
  DDLState state; 
  DDLContext ddlContext; 

  v3 = GameStateInfo_Get();
  if ( !v3->usingRecipe )
    Scr_Error(COM_ERR_3204, scrContext, "GetMatchRulesData called when not using recipe!");
  if ( !v3->matchRules && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 8365, ASSERT_TYPE_ASSERT, "(gInfo->matchRules)", (const char *)&queryFormat, "gInfo->matchRules") )
    __debugbreak();
  Asset = Com_DDL_LoadAsset("ddl/mp/recipes.ddl");
  Com_DDL_CreateContext(v3->matchRules, 4096, Asset, &ddlContext, NULL, NULL);
  __asm { vpxor   xmm0, xmm0, xmm0 }
  *(_OWORD *)&state.member = _XMM0;
  state.isValid = 0;
  state.offset = 0;
  state.arrayIndex = -1;
  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
    Scr_Error(COM_ERR_3120, scrContext, "GetDDL: Can't use this function on the front end server");
  LiveStorage_InitializeDDLStateForStatsGroup(Asset, &state, STATSGROUP_IGNORE);
  GScr_Main_GetDDL(scrContext, &state, Asset, &ddlContext, "GetMatchRulesData", 0);
}

/*
==============
GScr_IsUsingMatchRulesData
==============
*/
void GScr_IsUsingMatchRulesData(scrContext_t *scrContext)
{
  GameStateInfo *v2; 

  v2 = GameStateInfo_Get();
  Scr_AddBool(scrContext, v2->usingRecipe);
}

/*
==============
GScr_AttachmentIsRestricted
==============
*/
void GScr_AttachmentIsRestricted(scrContext_t *scrContext)
{
  const char *String; 
  const char *v3; 
  int IsWeaponAttachmentRestricted; 
  char dest[256]; 

  String = Scr_GetString(scrContext, 0);
  v3 = Scr_GetString(scrContext, 1u);
  if ( MatchRules_IsAttachmentRestricted(String) )
  {
    IsWeaponAttachmentRestricted = 1;
  }
  else
  {
    Com_sprintf<256>((char (*)[256])dest, "%s_%s", v3, String);
    IsWeaponAttachmentRestricted = MatchRules_IsWeaponAttachmentRestricted(dest);
  }
  Scr_AddBool(scrContext, IsWeaponAttachmentRestricted);
}

/*
==============
GScr_WeaponIsRestricted
==============
*/
void GScr_WeaponIsRestricted(scrContext_t *scrContext)
{
  const char *String; 
  int IsWeaponRestricted; 

  String = Scr_GetString(scrContext, 0);
  IsWeaponRestricted = MatchRules_IsWeaponRestricted(String);
  Scr_AddBool(scrContext, IsWeaponRestricted);
}

/*
==============
GScr_PerkIsRestricted
==============
*/
void GScr_PerkIsRestricted(scrContext_t *scrContext)
{
  const char *String; 
  int IsPerkRestricted; 

  String = Scr_GetString(scrContext, 0);
  IsPerkRestricted = MatchRules_IsPerkRestricted(String);
  Scr_AddBool(scrContext, IsPerkRestricted);
}

/*
==============
GScr_EquipmentIsRestricted
==============
*/
void GScr_EquipmentIsRestricted(scrContext_t *scrContext)
{
  const char *String; 
  int IsEquipmentRestricted; 

  String = Scr_GetString(scrContext, 0);
  IsEquipmentRestricted = MatchRules_IsEquipmentRestricted(String);
  Scr_AddBool(scrContext, IsEquipmentRestricted);
}

/*
==============
GScr_KillstreakIsRestricted
==============
*/
void GScr_KillstreakIsRestricted(scrContext_t *scrContext)
{
  const char *String; 
  int IsKillstreakRestricted; 

  String = Scr_GetString(scrContext, 0);
  IsKillstreakRestricted = MatchRules_IsKillstreakRestricted(String);
  Scr_AddBool(scrContext, IsKillstreakRestricted);
}

/*
==============
GScr_SuperIsRestricted
==============
*/
void GScr_SuperIsRestricted(scrContext_t *scrContext)
{
  const char *String; 
  int IsSuperRestricted; 

  String = Scr_GetString(scrContext, 0);
  IsSuperRestricted = MatchRules_IsSuperRestricted(String);
  Scr_AddBool(scrContext, IsSuperRestricted);
}

/*
==============
GScr_IsUsingOnlineDataOffline
==============
*/
void GScr_IsUsingOnlineDataOffline(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  bool IsUsingOnlineStatsOffline; 

  Entity = GetEntity(entref);
  if ( !Entity->client )
    Scr_Error(COM_ERR_3205, scrContext, "setstat: entity must be a player entity");
  IsUsingOnlineStatsOffline = SV_ClientMP_IsUsingOnlineStatsOffline(Entity->s.number);
  Scr_AddBool(scrContext, IsUsingOnlineStatsOffline);
}

/*
==============
GScr_GetRestedTime
==============
*/
void GScr_GetRestedTime(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gclient_s *client; 
  __int64 connected; 
  const char *v7; 
  int Int; 

  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
    Scr_Error(COM_ERR_3206, scrContext, "GetRestedTime not allowed on front end server");
  Entity = GetEntity(entref);
  if ( !Entity->client )
  {
    Scr_Error(COM_ERR_3207, scrContext, "setstat: entity must be a player entity");
    if ( !Entity->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5544, ASSERT_TYPE_ASSERT, "( playerEnt->client )", (const char *)&queryFormat, "playerEnt->client") )
      __debugbreak();
  }
  client = Entity->client;
  connected = (unsigned int)client->sess.connected;
  if ( (_DWORD)connected != 2 )
  {
    v7 = j_va("cannot read persistent data: player has not finished connecting, or ExitLevel has been called. (%s, %d)", client->sess.cs.name, connected);
    Scr_ObjectError(COM_ERR_3116, scrContext, v7);
  }
  if ( SV_IsDemoPlaying() )
  {
    GetRestedTime_Internal(Entity);
    Int = SV_Demo_GetInt();
  }
  else
  {
    Int = GetRestedTime_Internal(Entity);
    SV_Record_GetInt(Int);
  }
  Scr_AddInt(scrContext, Int);
}

/*
==============
GScr_SendClientMatchData
==============
*/
void GScr_SendClientMatchData(scrContext_t *scrContext)
{
  int maxclients; 
  int v2; 
  __int64 v3; 

  if ( SvGameGlobalsMP::GetSvGameGlobalsMP()->clientMatchData.def[0] )
  {
    maxclients = level.maxclients;
    v2 = 0;
    if ( level.maxclients > 0 )
    {
      v3 = 0i64;
      do
      {
        if ( level.clients[v3].sess.connected == CON_CONNECTED )
        {
          SV_ClientMP_SendClientMatchData(v2);
          maxclients = level.maxclients;
        }
        ++v2;
        ++v3;
      }
      while ( v2 < maxclients );
    }
  }
}

/*
==============
GScr_SendClientMatchDataForClient
==============
*/
void GScr_SendClientMatchDataForClient(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gclient_s *client; 

  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
    Scr_Error(COM_ERR_6538, scrContext, "SendClientMatchDataForClient not allowed on front end server");
  Entity = GetEntity(entref);
  if ( !Entity->client )
    Scr_Error(COM_ERR_6539, scrContext, "SendClientMatchDataForClient: entity must be a player entity");
  if ( SvGameGlobalsMP::GetSvGameGlobalsMP()->clientMatchData.def[0] )
  {
    client = Entity->client;
    if ( client->sess.connected == CON_CONNECTED )
      SV_ClientMP_SendClientMatchData(client->ps.clientNum);
  }
}

/*
==============
GScr_GetSystemTime
==============
*/
void GScr_GetSystemTime(scrContext_t *scrContext)
{
  int Int; 

  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
    Scr_Error(COM_ERR_3208, scrContext, "This function is not available for the front end scene");
  if ( SV_IsDemoPlaying() )
  {
    Int = SV_Demo_GetInt();
  }
  else
  {
    if ( LiveStorage_IsTimeSynced() )
      Int = LiveStorage_GetUTC();
    else
      Int = Sys_GetTimeAsSeconds();
    SV_Record_GetInt(Int);
  }
  Scr_AddInt(scrContext, Int);
}

/*
==============
GScr_GetServerHostName
==============
*/
void GScr_GetServerHostName(scrContext_t *scrContext)
{
  const char *HostName; 

  HostName = SV_GameMP_GetHostName();
  Scr_AddString(scrContext, HostName);
}

/*
==============
GScr_SetIntroCameraActive
==============
*/
void GScr_SetIntroCameraActive(scrContext_t *scrContext)
{
  level.introCameraActive = Scr_GetInt(scrContext, 0) != 0;
}

/*
==============
GScr_StartPodium
==============
*/
void GScr_StartPodium(scrContext_t *scrContext)
{
  int Int; 
  unsigned int v3; 
  const char *v4; 
  unsigned int Object; 
  unsigned int ArraySize; 
  unsigned int v7; 
  const char *v8; 
  signed int v9; 
  const char *NameForType; 
  const char *v11; 
  __int64 v12; 
  unsigned int *v13; 
  int cursize; 
  unsigned int CanonicalString; 
  unsigned int v16; 
  unsigned int v17; 
  unsigned int v18; 
  VariableType type; 
  const char *v20; 
  const char *v21; 
  __int64 v22; 
  char v23; 
  __int64 v24; 
  char v25; 
  bool v26; 
  unsigned __int64 v27; 
  scr_entref_t EntityIdRef; 
  unsigned int v29; 
  const char *v30; 
  unsigned int v31; 
  const char *v32; 
  unsigned int v33; 
  const char *v34; 
  const char *v35; 
  const char *v36; 
  const char *v37; 
  const char *v38; 
  const char *v39; 
  const char *v40; 
  const char *v41; 
  const char *v42; 
  SvClient *CommonClient; 
  __int64 v44; 
  VariableType failureType[4]; 
  unsigned int failureIndex; 
  int v47; 
  VariableValue v48; 
  int v49; 
  VariableValue v50; 
  VariableValue v51; 
  VariableValue out; 
  VariableValue v53; 
  VariableValue v54; 
  VariableValue v55; 
  msg_t buf; 
  XUID v57; 
  Weapon result; 
  Weapon r_weapon; 
  unsigned int buffer[2]; 
  __int64 v61; 
  __int64 v62; 
  unsigned __int8 data[1024]; 

  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_Error(COM_ERR_3209, scrContext, "StartPodium(): invalid number of arguments provided.  StartPodium( <client>, <mvp array> );");
  Int = Scr_GetInt(scrContext, 0);
  v3 = Int;
  v47 = Int;
  if ( Int < -1 || level.maxclients <= Int )
  {
    v4 = j_va("StartPodium(): client index should be an integer between -1 and %i", (unsigned int)level.maxclients);
    Scr_Error(COM_ERR_3210, scrContext, v4);
  }
  if ( Scr_GetType(scrContext, 1u) != VAR_POINTER || Scr_GetPointerType(scrContext, 1u) != VAR_ARRAY )
    Scr_Error(COM_ERR_3211, scrContext, "StartPodium(): expected an array.");
  Object = Scr_GetObject(scrContext, 1u);
  ArraySize = GetArraySize(scrContext, Object);
  v7 = ArraySize;
  if ( ArraySize > 6 )
  {
    v8 = j_va("StartPodium(): too many array entries were provided.  %i provided, %i supported.", ArraySize, 6i64);
    Scr_Error(COM_ERR_3212, scrContext, v8);
  }
  *(_QWORD *)buffer = 0i64;
  v9 = 0;
  v61 = 0i64;
  v62 = 0i64;
  failureType[0] = VAR_UNDEFINED;
  failureIndex = 0;
  if ( !Scr_GetObjectArray(scrContext, Object, 6u, buffer, &failureIndex, failureType) )
  {
    if ( failureIndex >= 6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 8800, ASSERT_TYPE_ASSERT, "(failureIndex < 6)", "%s\n\tStartPodium(): Internal error.", "failureIndex < MAX_PODIUM_CLIENTS") )
      __debugbreak();
    NameForType = Scr_GetNameForType(failureType[0]);
    v11 = j_va("StartPodium(): element %i of provided array -- type %s is not an object", failureIndex, NameForType);
    Scr_Error(COM_ERR_3213, scrContext, v11);
  }
  MSG_Init(&buf, data, 1020);
  MSG_WriteByte(&buf, 65i64);
  if ( (v7 > 0x7FFFFFFF || v7 + 128 > 0xFF) && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "char __cdecl truncate_cast_impl<char,unsigned int>(unsigned int)", "signed", (char)v7, "unsigned", v7) )
    __debugbreak();
  MSG_WriteByte(&buf, (char)v7);
  if ( v7 > 6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 8815, ASSERT_TYPE_ASSERT, "(arraySize <= 6)", (const char *)&queryFormat, "arraySize <= MAX_PODIUM_CLIENTS") )
    __debugbreak();
  if ( (int)(v7 - 1) > 0 )
    v9 = v7 - 1;
  v12 = 4i64 * v9;
  v13 = &buffer[(unsigned __int64)v12 / 4];
  if ( &buffer[(unsigned __int64)v12 / 4] < buffer )
  {
LABEL_85:
    if ( v3 == -1 )
    {
      SV_Game_BroadcastServerCommandMsg(SV_CMD_RELIABLE, &buf);
    }
    else
    {
      CommonClient = SvClient::GetCommonClient(v3);
      SV_Game_SendServerCommandMsg(CommonClient, SV_CMD_RELIABLE, &buf);
    }
    return;
  }
  while ( 1 )
  {
    if ( !*v13 )
    {
LABEL_84:
      v3 = v47;
      goto LABEL_85;
    }
    cursize = buf.cursize;
    v49 = buf.cursize;
    CanonicalString = SL_GetCanonicalString("rigindex");
    Scr_FindVariableField_Out(scrContext, *v13, CanonicalString, &out);
    if ( out.type != VAR_INTEGER )
    {
      RemoveRefToValue(scrContext, (unsigned __int8)out.type, out.u);
      v42 = j_va("StartPodium(): element %zu of provided array -- field 'rigIndex' is missing or is not an integer.", v12 >> 2);
      Scr_Error(COM_ERR_3214, scrContext, v42);
      return;
    }
    if ( out.u.intValue > 511 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 8835, ASSERT_TYPE_ASSERT, "(r_rigValue.u.intValue <= ((1 << 9) - 1))", (const char *)&queryFormat, "r_rigValue.u.intValue <= MAX_PODIUM_CUSTOMIZATION_INDEX") )
      __debugbreak();
    MSG_WriteBits(&buf, out.u.intValue, 9u);
    RemoveRefToValue(scrContext, (unsigned __int8)out.type, out.u);
    v16 = SL_GetCanonicalString("headindex");
    Scr_FindVariableField_Out(scrContext, *v13, v16, &v51);
    if ( v51.type != VAR_INTEGER )
    {
      RemoveRefToValue(scrContext, (unsigned __int8)v51.type, v51.u);
      v41 = j_va("StartPodium(): element %zu of provided array -- field 'headindex' is missing or is not an integer.", v12 >> 2);
      Scr_Error(COM_ERR_3215, scrContext, v41);
      return;
    }
    if ( v51.u.intValue > 511 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 8847, ASSERT_TYPE_ASSERT, "(r_headValue.u.intValue <= ((1 << 9) - 1))", (const char *)&queryFormat, "r_headValue.u.intValue <= MAX_PODIUM_CUSTOMIZATION_INDEX") )
      __debugbreak();
    MSG_WriteBits(&buf, v51.u.intValue, 9u);
    RemoveRefToValue(scrContext, (unsigned __int8)v51.type, v51.u);
    v17 = SL_GetCanonicalString("bodyindex");
    Scr_FindVariableField_Out(scrContext, *v13, v17, &v50);
    if ( v50.type != VAR_INTEGER )
    {
      RemoveRefToValue(scrContext, (unsigned __int8)v50.type, v50.u);
      v40 = j_va("StartPodium(): element %zu of provided array -- field 'bodyIndex' is missing or is not an integer.", v12 >> 2);
      Scr_Error(COM_ERR_3216, scrContext, v40);
      return;
    }
    if ( v50.u.intValue > 511 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 8859, ASSERT_TYPE_ASSERT, "(r_bodyValue.u.intValue <= ((1 << 9) - 1))", (const char *)&queryFormat, "r_bodyValue.u.intValue <= MAX_PODIUM_CUSTOMIZATION_INDEX") )
      __debugbreak();
    MSG_WriteBits(&buf, v50.u.intValue, 9u);
    RemoveRefToValue(scrContext, (unsigned __int8)v50.type, v50.u);
    v18 = SL_GetCanonicalString("weaponname");
    Scr_FindVariableField_Out(scrContext, *v13, v18, &v48);
    type = v48.type;
    if ( v48.type == VAR_STRING )
    {
      v20 = SL_ConvertToString((scr_string_t)v48.u.intValue);
      if ( !v20 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 8868, ASSERT_TYPE_ASSERT, "(weaponName)", (const char *)&queryFormat, "weaponName") )
          __debugbreak();
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1138, ASSERT_TYPE_ASSERT, "(weaponName)", (const char *)&queryFormat, "weaponName") )
          __debugbreak();
      }
      v21 = "none";
      v22 = 4i64;
      if ( !v20 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 181, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
        __debugbreak();
      while ( 1 )
      {
        v23 = v21[v20 - "none"];
        v24 = v22;
        v25 = *v21;
        --v22;
        ++v21;
        if ( !v24 )
          goto LABEL_51;
        if ( v23 != v25 )
          break;
        if ( !v23 )
          goto LABEL_51;
      }
      v27 = -1i64;
      do
        ++v27;
      while ( v20[v27] );
      if ( v27 <= 4 || *v20 != 97 || v20[1] != 108 || v20[2] != 116 || v20[3] != 95 )
      {
LABEL_51:
        v26 = 0;
        goto LABEL_52;
      }
      v26 = 1;
LABEL_52:
      r_weapon = *GScr_Main_GetWeaponForName(&result, scrContext, v20);
      Scr_VerifyWeapon(scrContext, &r_weapon, v26, v20);
      cursize = v49;
      goto LABEL_65;
    }
    if ( v48.type != VAR_POINTER )
      goto LABEL_92;
    if ( GetObjectType(scrContext, v48.u.uintValue) != VAR_ENTITY )
      break;
    EntityIdRef = Scr_GetEntityIdRef(scrContext, v48.u.uintValue);
    if ( EntityIdRef.entclass != ENTITY_CLASS_SAVED_COUNT )
    {
      RemoveRefToValue(scrContext, (unsigned __int8)v48.type, v48.u);
      v38 = j_va("StartPodium(): element %zu of provided array -- field 'weaponName' is not a valid weapon entity.", v12 >> 2);
      Scr_Error(COM_ERR_3217, scrContext, v38);
      return;
    }
    r_weapon = *GScr_Weapon_GetWeapon(scrContext, (const scr_weapon_t)EntityIdRef.entnum);
    GScr_Weapon_IsAlternate(scrContext, (const scr_weapon_t)EntityIdRef.entnum);
LABEL_65:
    MSG_WriteWeapon(&buf, &r_weapon);
    RemoveRefToValue(scrContext, (unsigned __int8)v48.type, v48.u);
    v29 = SL_GetCanonicalString("clantag");
    Scr_FindVariableField_Out(scrContext, *v13, v29, &v55);
    if ( v55.type != VAR_STRING )
    {
      RemoveRefToValue(scrContext, (unsigned __int8)v55.type, v55.u);
      v37 = j_va("StartPodium(): element %zu of provided array -- field 'clanTag' is missing or is not a string.", v12 >> 2);
      Scr_Error(COM_ERR_3219, scrContext, v37);
      return;
    }
    v30 = SL_ConvertToString((scr_string_t)v55.u.intValue);
    if ( !v30 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 8908, ASSERT_TYPE_ASSERT, "(clanTag)", (const char *)&queryFormat, "clanTag") )
      __debugbreak();
    MSG_WriteString(&buf, v30);
    RemoveRefToValue(scrContext, (unsigned __int8)v55.type, v55.u);
    v31 = SL_GetCanonicalString((const char *)&stru_143C9A1A4);
    Scr_FindVariableField_Out(scrContext, *v13, v31, &v54);
    if ( v54.type != VAR_STRING )
    {
      RemoveRefToValue(scrContext, (unsigned __int8)v54.type, v54.u);
      v36 = j_va("StartPodium(): element %zu of provided array -- field 'name' is missing or is not a string.", v12 >> 2);
      Scr_Error(COM_ERR_3220, scrContext, v36);
      return;
    }
    v32 = SL_ConvertToString((scr_string_t)v54.u.intValue);
    if ( !v32 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 8921, ASSERT_TYPE_ASSERT, (const char *)&stru_143C9A1A4.m_end, (const char *)&queryFormat, &stru_143C9A1A4) )
      __debugbreak();
    MSG_WriteString(&buf, v32);
    RemoveRefToValue(scrContext, (unsigned __int8)v54.type, v54.u);
    v33 = SL_GetCanonicalString("xuid");
    Scr_FindVariableField_Out(scrContext, *v13, v33, &v53);
    if ( v53.type != VAR_STRING )
    {
      RemoveRefToValue(scrContext, (unsigned __int8)v53.type, v53.u);
      v35 = j_va("StartPodium(): element %zu of provided array -- field 'xuid' is missing or is not a string.", v12 >> 2);
      Scr_Error(COM_ERR_3221, scrContext, v35);
      return;
    }
    v34 = SL_ConvertToString((scr_string_t)v53.u.intValue);
    if ( !v34 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 8934, ASSERT_TYPE_ASSERT, "(xuidStr)", (const char *)&queryFormat, "xuidStr") )
      __debugbreak();
    XUID::FromHexString(&v57, v34);
    XUID::Serialize(&v57, &buf);
    RemoveRefToValue(scrContext, (unsigned __int8)v53.type, v53.u);
    --v13;
    v12 -= 4i64;
    if ( buf.overflowed && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 8943, ASSERT_TYPE_ASSERT, "(!msg.overflowed)", "%s\n\tStartPodium(): internal error.  Server command buffer overflowed while writing message.", "!msg.overflowed") )
      __debugbreak();
    if ( (unsigned int)(buf.cursize - cursize) > 0x3F )
    {
      LODWORD(v44) = buf.cursize - cursize;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 8946, ASSERT_TYPE_ASSERT, "(messageSize <= PER_CLIENT_MAX_MESSAGE_SIZE)", "%s\n\tStartPodium(): internal error.  (%i) bytes were written out of (%zu) maximum expected.  No overflow occurred, but please update PER_CLIENT_MESSAGE_SIZE so that compile-time assertions are valid.", "messageSize <= PER_CLIENT_MAX_MESSAGE_SIZE", v44, 0x3Fui64) )
        __debugbreak();
    }
    if ( v13 < buffer )
      goto LABEL_84;
  }
  type = v48.type;
LABEL_92:
  RemoveRefToValue(scrContext, (unsigned __int8)type, v48.u);
  v39 = j_va("StartPodium(): element %zu of provided array -- field 'weaponName' is missing or is not a weapon type.", v12 >> 2);
  Scr_Error(COM_ERR_3218, scrContext, v39);
}

/*
==============
GScr_SetTeamForTrigger
==============
*/
void GScr_SetTeamForTrigger(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t classname; 
  const char *v5; 
  const char *v6; 
  const char *v7; 
  scr_string_t ConstString; 
  const char *v9; 
  const char *v10; 
  team_t outTeam; 

  Entity = GetEntity(entref);
  classname = Entity->classname;
  if ( classname != scr_const.trigger_use && classname != scr_const.trigger_use_touch )
  {
    v5 = SL_ConvertToString(scr_const.trigger_use_touch);
    v6 = SL_ConvertToString(scr_const.trigger_use);
    v7 = j_va("setteamfortrigger: trigger entity must be of type %s or %s", v6, v5);
    Scr_Error(COM_ERR_3222, scrContext, v7);
  }
  ConstString = Scr_GetConstString(scrContext, 0);
  if ( Com_Teams_TeamFromString(ConstString, &outTeam) )
  {
    Entity->c.trigger.team = outTeam;
  }
  else
  {
    v9 = SL_ConvertToString(ConstString);
    v10 = j_va("unknown team '%s'", v9);
    Scr_Error(COM_ERR_3223, scrContext, v10);
  }
}

/*
==============
GScr_ClientClaimTrigger
==============
*/
void GScr_ClientClaimTrigger(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  playerState_s *EntityPlayerState; 
  gentity_s *v5; 
  scr_string_t classname; 
  const char *v7; 
  const char *v8; 
  const char *v9; 
  unsigned __int16 v10; 

  Entity = GetEntity(entref);
  EntityPlayerState = G_GetEntityPlayerState(Entity);
  if ( !Entity->agent && !Entity->client )
    Scr_Error(COM_ERR_3224, scrContext, "clientclaimtrigger: claimer must be a client or an agent.");
  v5 = GScr_GetEntity(0);
  classname = v5->classname;
  if ( classname != scr_const.trigger_use && classname != scr_const.trigger_use_touch )
  {
    v7 = SL_ConvertToString(scr_const.trigger_use_touch);
    v8 = SL_ConvertToString(scr_const.trigger_use);
    v9 = j_va("clientclaimtrigger: trigger entity must be of type %s or %s", v8, v7);
    Scr_Error(COM_ERR_3225, scrContext, v9);
  }
  v10 = v5->c.item[0].weapon.stickerIndices[1];
  if ( v10 == 2047 || v10 == EntityPlayerState->clientNum )
    v5->c.item[0].weapon.stickerIndices[1] = truncate_cast<unsigned short,int>(EntityPlayerState->clientNum);
}

/*
==============
GScr_ClientReleaseTrigger
==============
*/
void GScr_ClientReleaseTrigger(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  playerState_s *EntityPlayerState; 
  gentity_s *v5; 
  scr_string_t classname; 
  const char *v7; 
  const char *v8; 
  const char *v9; 

  Entity = GetEntity(entref);
  EntityPlayerState = G_GetEntityPlayerState(Entity);
  if ( !Entity->agent && !Entity->client )
    Scr_Error(COM_ERR_3226, scrContext, "clientreleasetrigger: releaser must be a client or an agent.");
  v5 = GScr_GetEntity(0);
  classname = v5->classname;
  if ( classname != scr_const.trigger_use && classname != scr_const.trigger_use_touch )
  {
    v7 = SL_ConvertToString(scr_const.trigger_use_touch);
    v8 = SL_ConvertToString(scr_const.trigger_use);
    v9 = j_va("clientreleasetrigger: trigger entity must be of type %s or %s", v8, v7);
    Scr_Error(COM_ERR_3227, scrContext, v9);
  }
  if ( v5->c.item[0].weapon.stickerIndices[1] == EntityPlayerState->clientNum )
    v5->c.item[0].weapon.stickerIndices[1] = 2047;
}

/*
==============
GScr_ReleaseClaimedTrigger
==============
*/
void GScr_ReleaseClaimedTrigger(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t classname; 
  const char *v5; 
  const char *v6; 
  const char *v7; 

  Entity = GetEntity(entref);
  classname = Entity->classname;
  if ( classname != scr_const.trigger_use && classname != scr_const.trigger_use_touch )
  {
    v5 = SL_ConvertToString(scr_const.trigger_use_touch);
    v6 = SL_ConvertToString(scr_const.trigger_use);
    v7 = j_va("releaseclaimedtrigger: trigger entity must be of type %s or %s", v6, v5);
    Scr_Error(COM_ERR_3228, scrContext, v7);
  }
  Entity->c.item[0].weapon.stickerIndices[1] = 2047;
}

/*
==============
GScr_SetMapCenter
==============
*/
void GScr_SetMapCenter(scrContext_t *scrContext)
{
  vec3_t vectorValue; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_3229, scrContext, "Expected 1 argument to setMapCenter()");
  Scr_GetVector(scrContext, 0, &vectorValue);
  SV_GameMP_SetMapCenter(&vectorValue);
}

/*
==============
GScr_SetGameEndTime
==============
*/
void GScr_SetGameEndTime(scrContext_t *scrContext)
{
  int Int; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_3230, scrContext, "Expected 1 argument to setGameEndTime()");
  Int = Scr_GetInt(scrContext, 0);
  SV_GameMP_SetGameEndTime(Int);
}

/*
==============
GScr_SetTeamRadar
==============
*/
void GScr_SetTeamRadar(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const char *v3; 
  const char *v4; 
  const char *v5; 
  const char *v6; 
  bool v7; 
  team_t outTeam; 

  ConstString = Scr_GetConstString(scrContext, 0);
  if ( Com_Teams_TeamFromString(ConstString, &outTeam) )
  {
    if ( outTeam >= TEAM_MP_NUM_TEAMS )
    {
      v5 = SL_ConvertToString(ConstString);
      v6 = j_va("Illegal team string '%s'. Must be allies, axis, team_three, team_four, team_five, team_six or none.", v5);
      Scr_ParamError(COM_ERR_3232, scrContext, 0, v6);
    }
    v7 = Scr_GetInt(scrContext, 1u) == 0;
    level.teamHasRadar[outTeam] = !v7;
  }
  else
  {
    v3 = SL_ConvertToString(ConstString);
    v4 = j_va("unknown team '%s'", v3);
    Scr_Error(COM_ERR_3231, scrContext, v4);
  }
}

/*
==============
GScr_GetTeamRadar
==============
*/
void GScr_GetTeamRadar(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const char *v3; 
  const char *v4; 
  const char *v5; 
  const char *v6; 
  team_t outTeam; 

  ConstString = Scr_GetConstString(scrContext, 0);
  if ( Com_Teams_TeamFromString(ConstString, &outTeam) )
  {
    if ( outTeam >= TEAM_MP_NUM_TEAMS )
    {
      v5 = SL_ConvertToString(ConstString);
      v6 = j_va("Illegal team string '%s'. Must be allies, axis, team_three, team_four, team_five, team_six or none.", v5);
      Scr_ParamError(COM_ERR_3234, scrContext, 0, v6);
    }
    Scr_AddInt(scrContext, level.teamHasRadar[outTeam]);
  }
  else
  {
    v3 = SL_ConvertToString(ConstString);
    v4 = j_va("unknown team '%s'", v3);
    Scr_Error(COM_ERR_3233, scrContext, v4);
  }
}

/*
==============
GScr_SetTeamRadarStrength
==============
*/
void GScr_SetTeamRadarStrength(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const char *v3; 
  const char *v4; 
  const char *v5; 
  const char *v6; 
  int Int; 
  const dvar_t *v8; 
  int v9; 
  int integer; 
  const dvar_t *v11; 
  __int64 unsignedInt; 
  const char *v13; 
  team_t outTeam; 

  ConstString = Scr_GetConstString(scrContext, 0);
  if ( Com_Teams_TeamFromString(ConstString, &outTeam) )
  {
    if ( outTeam >= TEAM_MP_NUM_TEAMS )
    {
      v5 = SL_ConvertToString(ConstString);
      v6 = j_va("Illegal team string '%s'. Must be a valid team.", v5);
      Scr_ParamError(COM_ERR_3236, scrContext, 0, v6);
    }
    Int = Scr_GetInt(scrContext, 1u);
    v8 = DCONST_DVARINT_bg_UAVStrengthMin;
    v9 = Int;
    if ( !DCONST_DVARINT_bg_UAVStrengthMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_UAVStrengthMin") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v8);
    integer = v8->current.integer;
    v11 = DCONST_DVARINT_bg_UAVStrengthMax;
    if ( !DCONST_DVARINT_bg_UAVStrengthMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_UAVStrengthMax") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v11);
    unsignedInt = v11->current.unsignedInt;
    if ( v9 < integer || v9 > (int)unsignedInt )
    {
      v13 = j_va("Illegal UAV radar strength value'%d'. Must be between %d and %d.", (unsigned int)v9, (unsigned int)integer, unsignedInt);
      Scr_ParamError(COM_ERR_3237, scrContext, 0, v13);
    }
    level.teamRadarStrength[outTeam] = v9;
  }
  else
  {
    v3 = SL_ConvertToString(ConstString);
    v4 = j_va("unknown team '%s'", v3);
    Scr_Error(COM_ERR_3235, scrContext, v4);
  }
}

/*
==============
GScr_GetTeamRadarStrength
==============
*/
void GScr_GetTeamRadarStrength(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const char *v3; 
  const char *v4; 
  const char *v5; 
  const char *v6; 
  team_t outTeam; 

  ConstString = Scr_GetConstString(scrContext, 0);
  if ( Com_Teams_TeamFromString(ConstString, &outTeam) )
  {
    if ( outTeam >= TEAM_MP_NUM_TEAMS )
    {
      v5 = SL_ConvertToString(ConstString);
      v6 = j_va("Illegal team string '%s'. Must be axis, allies, team_three, team_four, team_five, team_six or none.", v5);
      Scr_ParamError(COM_ERR_3239, scrContext, 0, v6);
    }
    Scr_AddInt(scrContext, level.teamRadarStrength[outTeam]);
  }
  else
  {
    v3 = SL_ConvertToString(ConstString);
    v4 = j_va("unknown team '%s'", v3);
    Scr_Error(COM_ERR_3238, scrContext, v4);
  }
}

/*
==============
GScr_GetUAVStrengthMin
==============
*/
void GScr_GetUAVStrengthMin(scrContext_t *scrContext)
{
  const dvar_t *v1; 

  v1 = DCONST_DVARINT_bg_UAVStrengthMin;
  if ( !DCONST_DVARINT_bg_UAVStrengthMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_UAVStrengthMin") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  Scr_AddInt(scrContext, v1->current.integer);
}

/*
==============
GScr_GetUAVStrengthMax
==============
*/
void GScr_GetUAVStrengthMax(scrContext_t *scrContext)
{
  const dvar_t *v1; 

  v1 = DCONST_DVARINT_bg_UAVStrengthMax;
  if ( !DCONST_DVARINT_bg_UAVStrengthMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_UAVStrengthMax") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  Scr_AddInt(scrContext, v1->current.integer);
}

/*
==============
GScriptMP::ConstructMessageString
==============
*/
void GScriptMP::ConstructMessageString(GScriptMP *this, scrContext_t *scrContext, int firstParmIndex, int lastParmIndex, const char *errorContext, char *string, unsigned int stringLimit)
{
  __int64 v7; 
  int v8; 
  unsigned int v10; 
  const char *v11; 
  VariableType Type; 
  const char *IString; 
  const char *v14; 
  __int64 v15; 
  const char *v16; 
  gentity_s *Entity; 
  gclient_s *client; 
  char *v19; 
  const char *v20; 
  ComErrorCode v21; 
  const char *v22; 
  unsigned int v23; 
  const char *v24; 
  char v25; 
  const char *v26; 
  __int64 v27; 
  char v28; 
  const dvar_t *v29; 
  const dvar_t *v30; 
  bool v31; 
  const char *v32; 

  v7 = 0i64;
  v8 = firstParmIndex;
  if ( firstParmIndex <= lastParmIndex )
  {
    v10 = stringLimit;
    v11 = errorContext;
    while ( 1 )
    {
      Type = Scr_GetType(scrContext, v8);
      if ( Type == VAR_ISTRING )
      {
        IString = Scr_GetIString(scrContext, v8);
        v14 = IString;
        v15 = -1i64;
        do
          ++v15;
        while ( IString[v15] );
        Scr_ValidateLocalizedStringRef(scrContext, v8, IString, v15);
        if ( (int)v15 + (int)v7 + 1 >= v10 )
        {
          v16 = j_va("%s is too long. Max length is %i\n", v11, v10);
          Scr_ParamError(COM_ERR_2972, scrContext, v8, v16);
        }
        if ( (_DWORD)v7 )
        {
          string[v7] = 30;
          goto LABEL_41;
        }
        goto LABEL_42;
      }
      if ( Type == VAR_POINTER && Scr_GetPointerType(scrContext, v8) == VAR_ENTITY )
        break;
      v22 = Scr_GetString(scrContext, v8);
      v14 = v22;
      v15 = -1i64;
      do
        ++v15;
      while ( v22[v15] );
      v23 = 0;
      if ( (_DWORD)v15 )
      {
        v24 = v22;
        while ( 1 )
        {
          v25 = *v24;
          if ( (unsigned __int8)(*v24 - 30) <= 1u || v25 == 22 )
          {
            v26 = j_va("bad escape character (%i) present in string", (unsigned int)v25);
            Scr_ParamError(COM_ERR_2975, scrContext, v8, v26);
            v25 = *v24;
          }
          if ( isalpha(v25) )
            break;
          ++v23;
          ++v24;
          if ( v23 >= (unsigned int)v15 )
            goto LABEL_35;
        }
        v29 = DCONST_DVARBOOL_loc_warnings;
        if ( !DCONST_DVARBOOL_loc_warnings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "loc_warnings") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v29);
        if ( !v29->current.enabled )
        {
LABEL_35:
          v11 = errorContext;
          goto LABEL_36;
        }
        v30 = DCONST_DVARBOOL_loc_warningsAsErrors;
        if ( !DCONST_DVARBOOL_loc_warningsAsErrors && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "loc_warningsAsErrors") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v30);
        v31 = !v30->current.enabled;
        v11 = errorContext;
        if ( v31 )
        {
          Com_PrintWarning(17, "WARNING: Non-localized %s string is not allowed to have letters in it. Must be changed over to a localized string: \"%s\"\n", errorContext, v14);
        }
        else
        {
          v32 = j_va("non-localized %s strings are not allowed to have letters in them: \"%s\"", errorContext, v14);
          Scr_LocalizationError(scrContext, v8, v32);
        }
      }
LABEL_36:
      v10 = stringLimit;
      if ( (int)v15 + (int)v7 + 1 >= stringLimit )
      {
        v20 = j_va("%s is too long. Max length is %i\n", v11, stringLimit);
        v21 = COM_ERR_2976;
        goto LABEL_38;
      }
LABEL_39:
      if ( (_DWORD)v15 )
      {
        string[v7] = 31;
LABEL_41:
        v7 = (unsigned int)(v7 + 1);
LABEL_42:
        if ( (_DWORD)v15 )
        {
          v27 = (unsigned int)v15;
          do
          {
            v28 = *v14;
            if ( ((*v14 - 22) & 0xF6) == 0 && v28 != 23 )
              v28 = 46;
            string[v7] = v28;
            ++v14;
            v7 = (unsigned int)(v7 + 1);
            --v27;
          }
          while ( v27 );
        }
      }
      if ( ++v8 > lastParmIndex )
      {
        string[v7] = 0;
        return;
      }
    }
    Entity = GScr_GetEntity(v8);
    client = Entity->client;
    if ( !client )
    {
      Scr_ParamError(COM_ERR_2973, scrContext, v8, "Entity is not a player");
      client = Entity->client;
    }
    if ( client->sess.cs.clanAbbrev[0] )
    {
      switch ( client->sess.cs.clanTagType )
      {
        case 0u:
          v19 = j_va("[%s]%s^7", client->sess.cs.clanAbbrev, client->sess.cs.name);
LABEL_22:
          v14 = v19;
          v15 = -1i64;
          do
            ++v15;
          while ( v19[v15] );
          if ( (int)v15 + (int)v7 + 1 >= v10 )
          {
            v20 = j_va("%s is too long. Max length is %i\n", v11, v10);
            v21 = COM_ERR_2974;
LABEL_38:
            Scr_ParamError(v21, scrContext, v8, v20);
            goto LABEL_39;
          }
          goto LABEL_39;
        case 2u:
          v19 = j_va("[^3%s^7]%s^7", client->sess.cs.clanAbbrev, client->sess.cs.name);
          goto LABEL_22;
        case 3u:
          v19 = j_va("[^1%s^7]%s^7", client->sess.cs.clanAbbrev, client->sess.cs.name);
          goto LABEL_22;
      }
    }
    v19 = j_va("%s^7", client->sess.cs.name);
    goto LABEL_22;
  }
  *string = 0;
}

/*
==============
GScr_AddEntityAllowUndefined
==============
*/
void GScr_AddEntityAllowUndefined(const gentity_s *pEnt)
{
  scrContext_t *v2; 

  v2 = ScriptContext_Server();
  if ( pEnt )
    GScr_AddEntity(pEnt);
  else
    Scr_AddUndefined(v2);
}

/*
==============
GScr_GetQuestPoints_Internal
==============
*/
void GScr_GetQuestPoints_Internal(scrContext_t *scrContext, const unsigned __int16 targetClusterId, const vec3_t *origin, const float maxRadius, const float minRadius, const bool bDistance2D, const int *type)
{
  unsigned __int16 TotalQuestPointCount; 
  unsigned __int16 i; 
  unsigned __int16 QuestPointIndex; 
  unsigned __int16 pointCount; 
  SpawnGroupPoint *v14; 
  float v15; 
  float v16; 
  float v17; 
  unsigned int CanonicalString; 
  unsigned int v19; 
  unsigned int v20; 
  unsigned int v21; 
  __int64 v22; 
  __int64 v23; 

  TotalQuestPointCount = ScriptableSv_GetTotalQuestPointCount();
  Scr_MakeArray(scrContext);
  for ( i = 0; i < TotalQuestPointCount; ++i )
  {
    QuestPointIndex = ScriptableSv_GetQuestPointIndex(i);
    pointCount = cm.mapEnts->spawnGroupLoot.pointCount;
    if ( QuestPointIndex >= pointCount )
    {
      LODWORD(v23) = pointCount;
      LODWORD(v22) = QuestPointIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 13051, ASSERT_TYPE_ASSERT, "(unsigned)( pointIndex ) < (unsigned)( cm.mapEnts->spawnGroupLoot.pointCount )", "pointIndex doesn't index cm.mapEnts->spawnGroupLoot.pointCount\n\t%i not in [0, %i)", v22, v23) )
        __debugbreak();
    }
    v14 = &cm.mapEnts->spawnGroupLoot.points[QuestPointIndex];
    if ( v14->cluster == targetClusterId && (!type || !*type || (v14->zone & *type) != 0) )
    {
      if ( !origin )
        goto LABEL_14;
      v15 = origin->v[1] - v14->origin.v[1];
      v16 = (float)(v15 * v15) + (float)((float)(origin->v[0] - v14->origin.v[0]) * (float)(origin->v[0] - v14->origin.v[0]));
      if ( !bDistance2D )
      {
        v17 = origin->v[2] - v14->origin.v[2];
        v16 = (float)(v17 * v17) + v16;
      }
      if ( v16 <= (float)(maxRadius * maxRadius) && v16 >= (float)(minRadius * minRadius) )
      {
LABEL_14:
        Scr_MakeStruct(scrContext);
        Scr_AddInt(scrContext, QuestPointIndex);
        CanonicalString = SL_GetCanonicalString("index");
        Scr_AddStructField(scrContext, CanonicalString);
        Scr_AddVector(scrContext, v14->origin.v);
        v19 = SL_GetCanonicalString("origin");
        Scr_AddStructField(scrContext, v19);
        Scr_AddVector(scrContext, v14->angles.v);
        v20 = SL_GetCanonicalString("angles");
        Scr_AddStructField(scrContext, v20);
        Scr_AddInt(scrContext, v14->zone);
        v21 = SL_GetCanonicalString("spawnflags");
        Scr_AddStructField(scrContext, v21);
        Scr_AddArray(scrContext);
      }
    }
  }
}

/*
==============
GScr_MainMP_LoadScripts
==============
*/
void GScr_MainMP_LoadScripts(const SvServerInitSettings *initSettings)
{
  scrContext_t *v2; 
  bool agentsEnabled; 
  bool v4; 
  int v5; 
  const char **p_label; 
  int v7; 
  const char *v8; 
  int FunctionHandle; 
  int *v10; 
  __int64 v11; 
  int v12; 
  GameModeType gamemode; 
  __int64 gamemodea; 
  __int64 botsEnabled; 
  char *outName[2]; 
  EntryLoadScriptArray loadArray; 
  char dest[128]; 

  if ( !initSettings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 309, ASSERT_TYPE_ASSERT, "(initSettings)", (const char *)&queryFormat, "initSettings") )
    __debugbreak();
  Sys_ProfBeginNamedEvent(0xFFFFFFFF, "GScr_MainMP_LoadScripts");
  Scr_Mem_AcquireScriptLocks();
  v2 = ScriptContext_Server();
  Scr_BeginLoadScripts(v2, (const ScrThreadMode)initSettings->serverThreadStartup);
  loadArray.count = 0;
  agentsEnabled = BG_AgentSystemEnabled() != 0;
  v4 = BG_BotScriptsEnabled();
  LOBYTE(gamemode) = Com_GameMode_GetActiveGameMode();
  GScr_MainMP_LoadScripts_shared(&loadArray, MAIN, initSettings->gameType, initSettings->isFrontEnd, initSettings->mapName, gamemode, v4, agentsEnabled);
  v5 = 0;
  if ( loadArray.count > 0 )
  {
    p_label = &loadArray.entries[0].label;
    do
    {
      v7 = *((_DWORD *)p_label + 2);
      v8 = *p_label;
      if ( !Scr_LoadScript(v2, loadArray.entries[v5].scriptfile) && v7 )
        Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143FE4450, 831i64, loadArray.entries[v5].scriptfile);
      FunctionHandle = Scr_GetFunctionHandle(v2, loadArray.entries[v5].scriptfile, v8);
      if ( !FunctionHandle && v7 )
        Scr_UnknownLabel(loadArray.entries[v5].scriptfile, v8);
      v10 = (int *)*(p_label - 18);
      ++v5;
      p_label += 20;
      *v10 = FunctionHandle;
    }
    while ( v5 < loadArray.count );
  }
  v11 = 0i64;
  if ( NetConstStrings_GetNameFromIndex(NETCONSTSTRINGTYPE_AITYPE, 0, (const char **)outName) )
  {
    while ( 1 )
    {
      if ( (unsigned int)v11 >= 0x80 )
      {
        LODWORD(botsEnabled) = 128;
        LODWORD(gamemodea) = v11;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 299, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( 128 )", "index doesn't index MAX_AITYPE_SCRIPT_MP\n\t%i not in [0, %i)", gamemodea, botsEnabled) )
          __debugbreak();
      }
      Com_sprintf(dest, 0x80ui64, "aitype/%s%s", outName[0], ".gsc");
      if ( !Scr_LoadScript(v2, dest) )
        break;
      v12 = Scr_GetFunctionHandle(v2, dest, "precache");
      if ( !v12 )
      {
        Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143FE4408, 1230i64, "precache", dest);
        goto LABEL_21;
      }
LABEL_22:
      g_aiTypeScriptMP[v11].precache = v12;
      v11 = (unsigned int)(v11 + 1);
      if ( !NetConstStrings_GetNameFromIndex(NETCONSTSTRINGTYPE_AITYPE, v11, (const char **)outName) )
        goto LABEL_23;
    }
    Com_Printf(15, "Could not find script '%s'\n", dest);
LABEL_21:
    v12 = 0;
    goto LABEL_22;
  }
LABEL_23:
  Scr_PostCompileScripts(v2);
  GScr_Main_UpdateClassMap();
  GScr_Main_PostLoadScriptsCommon();
  Scr_EndLoadScripts(v2);
  Scr_Mem_ReleaseScriptLocks();
  Sys_ProfEndNamedEvent();
}

/*
==============
GScr_MainMP_PrecacheAiTypes
==============
*/
void GScr_MainMP_PrecacheAiTypes(scrContext_t *scrContext)
{
  __int64 i; 
  AITypeScriptMP *v3; 
  unsigned int v4; 
  __int64 v5; 
  __int64 v6; 
  char *outName; 

  for ( i = 0i64; NetConstStrings_GetNameFromIndex(NETCONSTSTRINGTYPE_AITYPE, i, (const char **)&outName); i = (unsigned int)(i + 1) )
  {
    if ( (unsigned int)i >= 0x80 )
    {
      LODWORD(v6) = 128;
      LODWORD(v5) = i;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 351, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( 128 )", "index doesn't index MAX_AITYPE_SCRIPT_MP\n\t%i not in [0, %i)", v5, v6) )
        __debugbreak();
    }
    v3 = &g_aiTypeScriptMP[i];
    if ( !v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 354, ASSERT_TYPE_ASSERT, "( typeScript )", (const char *)&queryFormat, "typeScript") )
      __debugbreak();
    v4 = Scr_ExecThread(scrContext, v3->precache, 0);
    Scr_FreeThread(scrContext, v4);
  }
}

/*
==============
GScr_MainMP_SetHealth
==============
*/
void GScr_MainMP_SetHealth(scrContext_t *scrContext, gentity_s *ent, int offset)
{
  int Int; 
  _DWORD *p_commandTime; 
  __int64 v7; 
  const char *v8; 
  scr_string_t targetname; 
  const char *v10; 
  const char *v11; 

  Int = Scr_GetInt(scrContext, 0);
  p_commandTime = &ent->client->ps.commandTime;
  if ( p_commandTime )
  {
    v7 = (unsigned int)p_commandTime[152];
    if ( Int > (int)v7 )
    {
      v8 = j_va("assignment of client.health: health (%i) must be less than maxHealth (%i)", (unsigned int)Int, v7);
      Scr_Error(COM_ERR_3318, scrContext, v8);
      return;
    }
    goto LABEL_10;
  }
  p_commandTime = &ent->agent->playerState.commandTime;
  if ( p_commandTime )
  {
    if ( Int > 0 )
    {
LABEL_10:
      ent->health = Int;
      p_commandTime[150] = Int;
      return;
    }
    targetname = ent->targetname;
    if ( targetname )
      v10 = SL_ConvertToString(targetname);
    else
      v10 = "<not set>";
    v11 = j_va("self.health must be greater than 0 (tried to set %i on ent %i, name %s)", (unsigned int)Int, (unsigned int)ent->s.number, v10);
    Scr_Error(COM_ERR_3319, scrContext, v11);
  }
  else
  {
    ent->maxHealth = Int;
    ent->health = Int;
  }
}

/*
==============
GScr_SetCodcasterClientMatchDataDef
==============
*/
void GScr_SetCodcasterClientMatchDataDef(scrContext_t *scrContext)
{
  SvGameGlobalsMP *SvGameGlobalsMP; 
  const DDLDef *Asset; 
  DDLContext ddlContext; 

  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
    Scr_Error(COM_ERR_3125, scrContext, "Cannot use codcaster client match data for front-end server");
  SvGameGlobalsMP = SvGameGlobalsMP::GetSvGameGlobalsMP();
  if ( I_strnicmp("ddl/mp/codcasterclientmatchdata.ddl", SvGameGlobalsMP->codcasterClientMatchData.def, 0x7FFFFFFFui64) )
  {
    if ( SvGameGlobalsMP->codcasterClientMatchData.def[0] )
      Scr_Error(COM_ERR_3126, scrContext, "Already set codcaster client match data def\n");
    Core_strcpy(SvGameGlobalsMP->codcasterClientMatchData.def, 0x40ui64, "ddl/mp/codcasterclientmatchdata.ddl");
    Asset = Com_DDL_LoadAsset(SvGameGlobalsMP->codcasterClientMatchData.def);
    DDL_ResetContext(SvGameGlobalsMP->codcasterClientMatchData.data, 1614, Asset, &ddlContext, NULL, NULL);
  }
}

/*
==============
GScriptMP::GetFunction
==============
*/
unsigned int GScriptMP::GetFunction(GScriptMP *this, const char **pName, BuiltinType *type)
{
  const scrContext_t *v5; 
  unsigned int result; 

  *type = BUILTIN_ANY;
  v5 = ScriptContext_Server();
  result = Scr_GetFunctionFromTable(v5, pName, type, &g_scrGameInterfaceFunctions_Server);
  if ( !result )
  {
    result = Scr_GetFunctionFromTable(v5, pName, type, &g_scrGameInterfaceMPFunctions_Server);
    if ( !result )
    {
      result = Scr_GetFunctionFromTable(v5, pName, type, &g_scrCommonFunctions_BothServer);
      if ( !result )
      {
        result = Scr_GetFunctionFromTable(v5, pName, type, &g_scrCommonFunctions_Server);
        if ( !result )
        {
          result = Scr_GetFunctionFromTable(v5, pName, type, &g_scrPhysicsFunctions_Server);
          if ( !result )
          {
            result = Scr_GetFunctionFromTable(v5, pName, type, &g_scrObjectivesFunctions_Server);
            if ( !result )
            {
              result = Scr_GetFunctionFromTable(v5, pName, type, &g_scrSentientFunctions_Server);
              if ( !result )
              {
                result = Scr_GetFunctionFromTable(v5, pName, type, &g_scrAIFunctions_Server);
                if ( !result )
                {
                  result = Scr_GetFunctionFromTable(v5, pName, type, &g_scrWeaponFunctions_Server);
                  if ( !result )
                  {
                    result = Scr_GetFunctionFromTable(v5, pName, type, &g_scrPlayerSpawnFunctions_Server);
                    if ( !result )
                      return Scr_GetFunctionFromTable(v5, pName, type, &g_scrBuiltinMPFunctions_Server);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

/*
==============
GScriptMP::GetMethod
==============
*/
unsigned int GScriptMP::GetMethod(GScriptMP *this, const char **pName, BuiltinType *type)
{
  const scrContext_t *v5; 
  unsigned int result; 

  *type = BUILTIN_ANY;
  v5 = ScriptContext_Server();
  result = Scr_GetMethodFromTable(v5, pName, type, &g_scrGameInterfaceMethods_Server);
  if ( !result )
  {
    result = Scr_GetMethodFromTable(v5, pName, type, &g_scrGameInterfaceMPMethods_Server);
    if ( !result )
    {
      result = Scr_GetMethodFromTable(v5, pName, type, &g_scrMainMethods_Server);
      if ( !result )
      {
        result = Scr_GetMethodFromTable(v5, pName, type, &g_scrClientScrMPMethods_Server);
        if ( !result )
        {
          result = Scr_GetMethodFromTable(v5, pName, type, &g_scrPlayerCommonMethods_Server);
          if ( !result )
          {
            result = Scr_GetMethodFromTable(v5, pName, type, &g_scrAIMethods_Server);
            if ( !result )
            {
              result = Scr_GetMethodFromTable(v5, pName, type, &g_scrMoverMethods_Server);
              if ( !result )
              {
                result = Scr_GetMethodFromTable(v5, pName, type, &g_scrMoverMPMethods_Server);
                if ( !result )
                {
                  result = Scr_GetMethodFromTable(v5, pName, type, &g_scrPhysicsMethods_Server);
                  if ( !result )
                  {
                    result = Scr_GetMethodFromTable(v5, pName, type, &g_scrVehicleMethods_Server);
                    if ( !result )
                    {
                      result = Scr_GetMethodFromTable(v5, pName, type, &g_scrVehicleMPMethods_Server);
                      if ( !result )
                      {
                        result = Scr_GetMethodFromTable(v5, pName, type, &g_scrVehicleHeliMethods_Server);
                        if ( !result )
                        {
                          result = Scr_GetMethodFromTable(v5, pName, type, &g_scrHudElemMethods_Server);
                          if ( !result )
                          {
                            result = Scr_GetMethodFromTable(v5, pName, type, &g_scrSentientMethods_Server);
                            if ( !result )
                            {
                              result = Scr_GetMethodFromTable(v5, pName, type, &g_scrAnimationMethods_Server);
                              if ( !result )
                              {
                                result = Scr_GetMethodFromTable(v5, pName, type, &g_scrWeaponMethods_Server);
                                if ( !result )
                                {
                                  result = Scr_GetMethodFromTable(v5, pName, type, &g_scrPlayerSpawnMethods_Server);
                                  if ( !result )
                                  {
                                    result = Scr_GetMethodFromTable(v5, pName, type, &g_scrBuiltinMPMethods_Server);
                                    if ( !result )
                                      return Scr_GetMethodFromTable(v5, pName, type, &g_scrCalloutMarkerPingMethods_Server);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

/*
==============
GetRestedTime_Internal
==============
*/
__int64 GetRestedTime_Internal(gentity_s *playerEnt)
{
  unsigned __int8 *ClientPlayerDataBuffer; 
  unsigned __int8 *ClientPersistentDataModifiedFlags; 
  const DDLDef *DefForStatsGroup; 
  const DDLDef *v5; 
  int PlayerDataBufferSize; 
  unsigned int TimeAsSeconds; 
  unsigned int v8; 
  DDLContext ddlContext; 

  if ( BYTE1(SvGameGlobals::ms_allocatedType) != 2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_mp\\sv_persistent_globals_mp.h", 166, ASSERT_TYPE_ASSERT, "( ms_allocatedType == ALLOCATION_TYPE )", (const char *)&queryFormat, "ms_allocatedType == ALLOCATION_TYPE") )
    __debugbreak();
  if ( !SvPersistentGlobals::ms_svPersistent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server\\sv_persistent_globals.h", 72, ASSERT_TYPE_ASSERT, "(ms_svPersistent)", "%s\n\tAttempting to access server static data outside of an active server context", "ms_svPersistent") )
    __debugbreak();
  if ( !BYTE1(SvGameGlobals::ms_allocatedType) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server\\sv_persistent_globals.h", 73, ASSERT_TYPE_ASSERT, "(ms_allocatedType != GameModeType::NONE)", "%s\n\tAttempting to access server static data outside of an active server context", "ms_allocatedType != GameModeType::NONE") )
    __debugbreak();
  if ( BYTE2(SvPersistentGlobals::ms_svPersistent[4].m_skelMemSize) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 8521, ASSERT_TYPE_ASSERT, "( !SvPersistentGlobalsMP::IsFrontEndServer() )", (const char *)&queryFormat, "!SvPersistentGlobalsMP::IsFrontEndServer()") )
    __debugbreak();
  ClientPlayerDataBuffer = SV_ClientMP_GetClientPlayerDataBuffer(playerEnt->s.number, STATSGROUP_COMMON);
  ClientPersistentDataModifiedFlags = SV_ClientMP_GetClientPersistentDataModifiedFlags(playerEnt->s.number);
  if ( !ClientPlayerDataBuffer && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 8525, ASSERT_TYPE_ASSERT, "(data)", (const char *)&queryFormat, "data") )
    __debugbreak();
  DefForStatsGroup = Com_PlayerData_GetDefForStatsGroup(STATSGROUP_COMMON);
  s_callbackData.modifiedFlags = ClientPersistentDataModifiedFlags;
  v5 = DefForStatsGroup;
  s_callbackData.baseOffset = Com_PlayerData_GetStatsGroupOffset(STATSGROUP_COMMON) + 4;
  PlayerDataBufferSize = LiveStorage_GetPlayerDataBufferSize(STATSGROUP_COMMON);
  Com_DDL_CreateContext(ClientPlayerDataBuffer, PlayerDataBufferSize, v5, &ddlContext, DDLAccessCB, &s_callbackData);
  TimeAsSeconds = Sys_GetTimeAsSeconds();
  v8 = LiveStorage_GetAndResetLastPlayTime(&ddlContext);
  SV_ClientMP_SetClientPersistentDataModified(playerEnt->s.number);
  if ( v8 )
    return TimeAsSeconds - v8;
  else
    return 0i64;
}

/*
==============
LogMatchDataDeathWeaponHelper
==============
*/
void LogMatchDataDeathWeaponHelper(scrContext_t *scrContext, const Weapon *r_weapon, bool isAlternate, unsigned int attachmentsArrayCount, unsigned int attachmentsArrayId, unsigned int weaponStringHash, unsigned int weaponAltModeHash, unsigned int attachmentsStringHash, DDLState *lifeState, DDLContext *buffer)
{
  int v14; 
  const WeaponDef *v16; 
  weapClass_t WeaponClass; 
  int inventoryType; 
  char *v19; 
  unsigned int v21; 
  unsigned int i; 
  unsigned int ArrayVariable; 
  scr_string_t *VariableValueAddress; 
  unsigned int RawHash; 
  DDLState toState; 
  unsigned int v27; 
  char *src; 
  DDLState fromState; 
  char dest[1024]; 

  __asm { vpxor   xmm0, xmm0, xmm0 }
  v14 = 0;
  v27 = attachmentsArrayCount;
  toState.isValid = 0;
  toState.offset = 0;
  toState.arrayIndex = -1;
  *(_OWORD *)&toState.member = _XMM0;
  src = (char *)BG_GetWeaponBaseName(r_weapon, isAlternate);
  if ( I_strncmp(src, "destructible", 0xBui64) )
  {
    v16 = BG_WeaponDef(r_weapon, isAlternate);
    if ( v16 )
    {
      WeaponClass = BG_GetWeaponClass(r_weapon, isAlternate);
      if ( isAlternate )
        inventoryType = 3;
      else
        inventoryType = v16->inventoryType;
      v19 = src;
      if ( !src )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7356, ASSERT_TYPE_ASSERT, "( baseWeaponName )", (const char *)&queryFormat, "baseWeaponName", *(_QWORD *)&toState.isValid, *(_QWORD *)&toState.arrayIndex, toState.member, toState.ddlDef) )
          __debugbreak();
        v19 = src;
      }
      Core_strcpy(dest, 0x400ui64, v19);
      if ( !inventoryType || inventoryType > 0 && inventoryType > 2 && inventoryType == 3 )
      {
        DDL_MoveToNameByHash(lifeState, &toState, weaponStringHash, NULL);
        DDL_SetEnum(&toState, buffer, dest);
        if ( (unsigned int)WeaponClass <= WEAPCLASS_ROCKETLAUNCHER || WeaponClass == WEAPCLASS_BEAM )
        {
          __asm { vpxor   xmm0, xmm0, xmm0 }
          fromState.isValid = 0;
          fromState.offset = 0;
          *(_OWORD *)&fromState.member = _XMM0;
          fromState.arrayIndex = -1;
          DDL_MoveToNameByHash(lifeState, &toState, weaponAltModeHash, NULL);
          DDL_SetBool(&toState, buffer, isAlternate);
          if ( !DDL_MoveToNameByHash(lifeState, &fromState, attachmentsStringHash, NULL) )
            Scr_Error(COM_ERR_3175, scrContext, "Invalid match data definition specified. The attachments field must be an indexed array of enumerations");
          v21 = v27;
          for ( i = 0; i < v21; ++i )
          {
            ArrayVariable = GetArrayVariable(scrContext, attachmentsArrayId, i);
            if ( GetValueType(scrContext, ArrayVariable) != VAR_STRING )
              Scr_Error(COM_ERR_3176, scrContext, "All elements need to be strings.");
            VariableValueAddress = (scr_string_t *)GetVariableValueAddress(scrContext, ArrayVariable);
            RawHash = j_SL_GetRawHash(*VariableValueAddress);
            if ( !DDL_MoveToIndex(&fromState, &toState, i) )
              Scr_Error(COM_ERR_3177, scrContext, "Invalid match data definition specified. The attachments field must be an indexed array of enumerations");
            DDL_SetEnumByHash(&toState, buffer, RawHash);
            if ( ++v14 >= 6 )
              break;
          }
        }
      }
      else
      {
        DDL_MoveToNameByHash(lifeState, &toState, weaponStringHash, NULL);
        DDL_SetEnum(&toState, buffer, dest);
      }
    }
    else
    {
      DDL_MoveToNameByHash(lifeState, &toState, weaponStringHash, NULL);
      DDL_SetEnum(&toState, buffer, "none");
    }
  }
  else
  {
    DDL_MoveToNameByHash(lifeState, &toState, weaponStringHash, NULL);
    DDL_SetEnum(&toState, buffer, "destructible");
  }
}

/*
==============
LogMatchDataDeathWhileReloadingHelper
==============
*/
void LogMatchDataDeathWhileReloadingHelper(scrContext_t *scrContext, DDLState *lifeState, DDLContext *buffer, const gentity_s *victim)
{
  gclient_s *client; 
  int v8; 
  GWeaponMap *Instance; 
  bool v11; 
  PlayerHandIndex v12; 
  PlayerHandIndex v13; 
  int *p_weaponState; 
  unsigned int RawHash; 
  const Weapon *Weapon; 
  bool v17; 
  unsigned int v20; 
  WeaponSlot *p_slot; 
  BgWeaponHandle *weaponsEquipped; 
  const Weapon *v23; 
  int v24; 
  unsigned int v25; 
  bool inAltMode; 
  __int64 v29; 
  __int64 v30; 
  DDLState toState; 

  if ( !victim && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7248, ASSERT_TYPE_ASSERT, "( victim )", (const char *)&queryFormat, "victim") )
    __debugbreak();
  if ( !victim->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7249, ASSERT_TYPE_ASSERT, "( victim->client )", (const char *)&queryFormat, "victim->client") )
    __debugbreak();
  client = victim->client;
  v8 = 0;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  toState.offset = 0;
  *(_OWORD *)&toState.member = _XMM0;
  toState.isValid = 0;
  toState.arrayIndex = -1;
  Instance = GWeaponMap::GetInstance();
  if ( !Instance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7256, ASSERT_TYPE_ASSERT, "( weaponMap )", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  v11 = 0;
  v12 = WEAPON_HAND_DEFAULT;
  v13 = WEAPON_HAND_DEFAULT;
  if ( BG_PlayerLastWeaponHand(Instance, &client->ps) >= WEAPON_HAND_DEFAULT )
  {
    p_weaponState = &client->ps.weapState[0].weaponState;
    while ( (unsigned int)(*p_weaponState - 18) > 3 )
    {
      ++v13;
      p_weaponState += 20;
      if ( v13 > BG_PlayerLastWeaponHand(Instance, &client->ps) )
        goto LABEL_16;
    }
    v11 = 1;
    v12 = v13;
  }
LABEL_16:
  RawHash = j_SL_GetRawHash(scr_const.diedWhileReloading);
  DDL_MoveToNameByHash(lifeState, &toState, RawHash, NULL);
  DDL_SetBool(&toState, buffer, v11);
  if ( !Instance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 885, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 886, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  Weapon = BgWeaponMap::GetWeapon(Instance, client->ps.weapCommon.weaponHandle);
  v17 = !GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&client->ps.weapCommon.weapFlags, ACTIVE, 0x22u) && (GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&client->ps.weapCommon.weapFlags, ACTIVE, 0x11u) || GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&client->ps.weapCommon.weapFlags, ACTIVE, 0x1Bu));
  BG_GetAmmoInClip(&client->ps, Weapon, v17, v12);
  BG_GetClipSize(&client->ps, Weapon, v17);
  _XMM0 = 0i64;
  __asm { vroundss xmm0, xmm0, xmm1, 1; val }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, 0.0, 100.0);
  v20 = j_SL_GetRawHash(scr_const.clipRemainingPercentCurrent);
  DDL_MoveToNameByHash(lifeState, &toState, v20, NULL);
  DDL_SetByte(&toState, buffer, (int)*(float *)&_XMM0);
  p_slot = &client->ps.weapEquippedData[0].slot;
  weaponsEquipped = client->ps.weaponsEquipped;
  while ( 1 )
  {
    if ( weaponsEquipped->m_mapEntryId )
    {
      if ( !Instance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 839, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
        __debugbreak();
      if ( (unsigned int)v8 >= 0xF )
      {
        LODWORD(v30) = 15;
        LODWORD(v29) = v8;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 841, ASSERT_TYPE_ASSERT, "(unsigned)( equippedIndex ) < (unsigned)( 15 )", "equippedIndex doesn't index MAX_EQUIPPED_WEAPONS\n\t%i not in [0, %i)", v29, v30) )
          __debugbreak();
      }
      v23 = BgWeaponMap::GetWeapon(Instance, client->ps.weaponsEquipped[v8]);
      if ( memcmp_0(Weapon, v23, 0x3Cui64) )
      {
        if ( *p_slot == WEAPON_SLOT_PRIMARY )
          break;
      }
    }
    ++v8;
    ++weaponsEquipped;
    p_slot += 4;
    if ( v8 >= 15 )
    {
      LOBYTE(v24) = 0;
      goto LABEL_39;
    }
  }
  inAltMode = client->ps.weapEquippedData[v8].inAltMode;
  BG_GetAmmoInClip(&client->ps, v23, inAltMode, WEAPON_HAND_DEFAULT);
  BG_GetClipSize(&client->ps, v23, inAltMode);
  _XMM0 = 0i64;
  __asm { vroundss xmm0, xmm0, xmm3, 1; val }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, 0.0, 100.0);
  v24 = (int)*(float *)&_XMM0;
LABEL_39:
  v25 = j_SL_GetRawHash(scr_const.clipRemainingPercentOther);
  DDL_MoveToNameByHash(lifeState, &toState, v25, NULL);
  DDL_SetByte(&toState, buffer, v24);
}

/*
==============
NormalizePosition
==============
*/
void NormalizePosition(scrContext_t *scrContext, const vec3_t *position, vec2_t *result)
{
  float v5; 
  float v6; 
  float v7; 
  float v8; 
  float v9; 
  float v10; 

  v5 = level.compassMapWorldSize.v[0];
  if ( level.compassMapWorldSize.v[0] <= 0.0 || (v6 = level.compassMapWorldSize.v[1], level.compassMapWorldSize.v[1] <= 0.0) )
  {
    Scr_Error(COM_ERR_3197, scrContext, "level compassMapWorldSize is not set or cannot be 0");
    v6 = level.compassMapWorldSize.v[1];
    v5 = level.compassMapWorldSize.v[0];
  }
  v7 = position->v[0] - level.compassMapUpperLeft.v[0];
  v8 = position->v[1] - level.compassMapUpperLeft.v[1];
  v9 = v8 * level.compassNorth.v[0];
  v10 = COERCE_FLOAT(COERCE_UNSIGNED_INT(v8 * level.compassNorth.v[1]) ^ _xmm) - (float)(v7 * level.compassNorth.v[0]);
  result->v[0] = (float)((float)((float)(v7 * level.compassNorth.v[1]) - v9) / v5) * 255.0;
  result->v[1] = (float)(v10 * (float)(1.0 / v6)) * 255.0;
}

/*
==============
ScrCmd_PlaySoundAtPosInternal
==============
*/
gentity_s *ScrCmd_PlaySoundAtPosInternal(scrContext_t *scrContext, const vec3_t *pos, const char *soundName)
{
  const SndAliasList *Alias; 
  const char *v7; 
  const char *v8; 
  unsigned __int16 v9; 
  const char *v10; 
  gentity_s *result; 

  Alias = SND_FindAlias(soundName);
  if ( !Alias )
  {
    v7 = j_va("unknown sound alias '%s'", soundName);
    Scr_ParamError(COM_ERR_2997, scrContext, 0, v7);
  }
  if ( Com_IsSoundAliasLooping(Alias) )
  {
    v8 = j_va("'%s' is a looping alias, use 'playloopsound' instead", soundName);
    Scr_ParamError(COM_ERR_2998, scrContext, 0, v8);
  }
  v9 = G_CStringMP_SoundAliasIndex(soundName);
  if ( (unsigned __int16)(v9 - 1) > 0x7FFFu )
  {
    v10 = j_va("'%s' does has not have a valid index (%i)", soundName, v9);
    Scr_ParamError(COM_ERR_2999, scrContext, 0, v10);
  }
  result = G_Utils_SpawnEventEntity(pos, 3);
  result->s.eventParm2 = 0;
  result->s.eventParm = v9;
  return result;
}

/*
==============
Scr_AgentAdded
==============
*/
void Scr_AgentAdded(gentity_s *self)
{
  GameScriptDataMP *GameScriptDataMP; 
  scrContext_t *v3; 
  unsigned int v4; 

  GameScriptDataMP = GameScriptDataMP::GetGameScriptDataMP();
  v3 = ScriptContext_Server();
  v4 = GScr_ExecEntThread(self, GameScriptDataMP->agentAdded, 0);
  Scr_FreeThread(v3, v4);
}

/*
==============
Scr_AgentDamage
==============
*/
void Scr_AgentDamage(gentity_s *self, const gentity_s *inflictor, gentity_s *attacker, int damage, int dflags, int meansOfDeath, const Weapon *r_weapon, bool isAlternate, const vec3_t *vPoint, const vec3_t *vDir, const hitLocation_t hitLoc, int timeOffset, int modelIndex, scr_string_t partName)
{
  scrContext_t *v18; 
  scrContext_t *v19; 
  scr_string_t HitLocationString; 
  scrContext_t *v21; 
  scrContext_t *v22; 
  GameScriptDataMP *GameScriptDataMP; 
  unsigned int v24; 

  v18 = ScriptContext_Server();
  v19 = v18;
  if ( partName )
    Scr_AddConstString(v18, partName);
  else
    Scr_AddUndefined(v18);
  Scr_AddInt(v19, modelIndex);
  Scr_AddInt(v19, timeOffset);
  HitLocationString = G_Combat_GetHitLocationString(hitLoc);
  Scr_AddConstString(v19, HitLocationString);
  if ( vDir )
    Scr_AddVector(v19, vDir->v);
  else
    Scr_AddUndefined(v19);
  if ( vPoint )
    Scr_AddVector(v19, vPoint->v);
  else
    Scr_AddUndefined(v19);
  GScr_Weapon_AddParam(v19, r_weapon, isAlternate);
  if ( (unsigned int)meansOfDeath > 0x18 )
    Scr_AddString(v19, "badMOD");
  else
    Scr_AddConstString(v19, *g_combat_modNames[meansOfDeath]);
  Scr_AddInt(v19, dflags);
  Scr_AddInt(v19, damage);
  v21 = ScriptContext_Server();
  if ( attacker )
    GScr_AddEntity(attacker);
  else
    Scr_AddUndefined(v21);
  v22 = ScriptContext_Server();
  if ( inflictor )
    GScr_AddEntity(inflictor);
  else
    Scr_AddUndefined(v22);
  GameScriptDataMP = GameScriptDataMP::GetGameScriptDataMP();
  v24 = GScr_ExecEntThread(self, GameScriptDataMP->agentDamaged, 0xCu);
  Scr_FreeThread(v19, v24);
}

/*
==============
Scr_AgentGameTypeMain
==============
*/
void Scr_AgentGameTypeMain(void)
{
  GameScriptDataMP *GameScriptDataMP; 
  scrContext_t *v1; 
  unsigned int v2; 

  GameScriptDataMP = GameScriptDataMP::GetGameScriptDataMP();
  if ( GameScriptDataMP->agentGameTypeMain )
  {
    v1 = ScriptContext_Server();
    v2 = Scr_ExecThread(v1, GameScriptDataMP->agentGameTypeMain, 0);
    Scr_FreeThread(v1, v2);
  }
}

/*
==============
Scr_AgentKilled
==============
*/
void Scr_AgentKilled(gentity_s *self, const gentity_s *inflictor, gentity_s *attacker, int damage, int damageFlags, int meansOfDeath, const Weapon *r_weapon, bool isAlternate, const vec3_t *vDir, const hitLocation_t hitLoc, int psTimeOffset, int deathAnimDuration)
{
  scrContext_t *v16; 
  scr_string_t HitLocationString; 
  scrContext_t *v18; 
  scrContext_t *v19; 
  GameScriptDataMP *GameScriptDataMP; 
  unsigned int v21; 

  v16 = ScriptContext_Server();
  Scr_AddInt(v16, deathAnimDuration);
  Scr_AddInt(v16, psTimeOffset);
  HitLocationString = G_Combat_GetHitLocationString(hitLoc);
  Scr_AddConstString(v16, HitLocationString);
  if ( vDir )
    Scr_AddVector(v16, vDir->v);
  else
    Scr_AddUndefined(v16);
  GScr_Weapon_AddParam(v16, r_weapon, isAlternate);
  if ( (unsigned int)meansOfDeath > 0x18 )
    Scr_AddString(v16, "badMOD");
  else
    Scr_AddConstString(v16, *g_combat_modNames[meansOfDeath]);
  Scr_AddInt(v16, damageFlags);
  Scr_AddInt(v16, damage);
  v18 = ScriptContext_Server();
  if ( attacker )
    GScr_AddEntity(attacker);
  else
    Scr_AddUndefined(v18);
  v19 = ScriptContext_Server();
  if ( inflictor )
    GScr_AddEntity(inflictor);
  else
    Scr_AddUndefined(v19);
  GameScriptDataMP = GameScriptDataMP::GetGameScriptDataMP();
  v21 = GScr_ExecEntThread(self, GameScriptDataMP->agentKilled, 0xAu);
  Scr_FreeThread(v16, v21);
}

/*
==============
Scr_AgentMain
==============
*/
void Scr_AgentMain(void)
{
  GameScriptDataMP *GameScriptDataMP; 
  scrContext_t *v1; 
  unsigned int v2; 

  GameScriptDataMP = GameScriptDataMP::GetGameScriptDataMP();
  if ( !GameScriptDataMP->agentMain && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 12685, ASSERT_TYPE_ASSERT, "(gScrData->agentMain)", (const char *)&queryFormat, "gScrData->agentMain") )
    __debugbreak();
  v1 = ScriptContext_Server();
  v2 = Scr_ExecThread(v1, GameScriptDataMP->agentMain, 0);
  Scr_FreeThread(v1, v2);
}

/*
==============
Scr_BotGameTypeMain
==============
*/
void Scr_BotGameTypeMain(void)
{
  GameScriptDataMP *GameScriptDataMP; 
  scrContext_t *v1; 
  unsigned int v2; 

  GameScriptDataMP = GameScriptDataMP::GetGameScriptDataMP();
  if ( GameScriptDataMP->botGameTypeMain )
  {
    v1 = ScriptContext_Server();
    v2 = Scr_ExecThread(v1, GameScriptDataMP->botGameTypeMain, 0);
    Scr_FreeThread(v1, v2);
  }
}

/*
==============
Scr_BotMain
==============
*/
void Scr_BotMain(void)
{
  GameScriptDataMP *GameScriptDataMP; 
  scrContext_t *v1; 
  unsigned int v2; 

  GameScriptDataMP = GameScriptDataMP::GetGameScriptDataMP();
  if ( !GameScriptDataMP->botMain && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 12659, ASSERT_TYPE_ASSERT, "(gScrData->botMain)", (const char *)&queryFormat, "gScrData->botMain") )
    __debugbreak();
  v1 = ScriptContext_Server();
  v2 = Scr_ExecThread(v1, GameScriptDataMP->botMain, 0);
  Scr_FreeThread(v1, v2);
}

/*
==============
Scr_HostMigration
==============
*/
void Scr_HostMigration(void)
{
  GameScriptDataMP *GameScriptDataMP; 
  scrContext_t *v1; 
  unsigned int v2; 

  GameScriptDataMP = GameScriptDataMP::GetGameScriptDataMP();
  v1 = ScriptContext_Server();
  v2 = Scr_ExecThread(v1, GameScriptDataMP->gametype.hostmigration, 0);
  Scr_FreeThread(v1, v2);
}

/*
==============
Scr_LeaderDialog
==============
*/
void Scr_LeaderDialog(gentity_s *self, const scr_string_t dialog, const vec3_t *location)
{
  GameScriptDataMP *GameScriptDataMP; 
  scrContext_t *v7; 
  unsigned int v8; 

  GameScriptDataMP = GameScriptDataMP::GetGameScriptDataMP();
  if ( GameScriptDataMP->leaderDialog )
  {
    v7 = ScriptContext_Server();
    Scr_AddVector(v7, location->v);
    Scr_AddConstString(v7, dialog);
    v8 = GScr_ExecEntThread(self, GameScriptDataMP->leaderDialog, 2u);
    Scr_FreeThread(v7, v8);
  }
}

/*
==============
Scr_LoadGameType
==============
*/
void Scr_LoadGameType(void)
{
  const dvar_t *v0; 
  GameScriptDataMP *GameScriptDataMP; 
  scrContext_t *v2; 
  unsigned int v3; 

  v0 = DVARBOOL_bot_spawnControlledByDvar;
  if ( !DVARBOOL_bot_spawnControlledByDvar && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar_api.h", 759, ASSERT_TYPE_ASSERT, "( dvar )", "Dvar accessed after deregistration") )
    __debugbreak();
  Dvar_Reset(v0, DVAR_SOURCE_INTERNAL);
  level.teammode = TEAMMODE_AXIS_ALLIES;
  GameScriptDataMP = GameScriptDataMP::GetGameScriptDataMP();
  if ( !GameScriptDataMP && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 12645, ASSERT_TYPE_ASSERT, "(gScrData)", (const char *)&queryFormat, "gScrData") )
    __debugbreak();
  if ( !GameScriptDataMP->gametype.main && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 12646, ASSERT_TYPE_ASSERT, "(gScrData->gametype.main != 0)", (const char *)&queryFormat, "gScrData->gametype.main != 0") )
    __debugbreak();
  v2 = ScriptContext_Server();
  v3 = Scr_ExecThread(v2, GameScriptDataMP->gametype.main, 0);
  Scr_FreeThread(v2, v3);
}

/*
==============
Scr_LoadRead
==============
*/
void *Scr_LoadRead(int len)
{
  return 0i64;
}

/*
==============
Scr_PlayerActive
==============
*/
void Scr_PlayerActive(gentity_s *self)
{
  int playeractive; 
  scrContext_t *v3; 
  unsigned int v4; 

  playeractive = GameScriptDataMP::GetGameScriptDataMP()->gametype.playeractive;
  v3 = ScriptContext_Server();
  v4 = GScr_ExecEntThread(self, playeractive, 0);
  Scr_FreeThread(v3, v4);
}

/*
==============
Scr_PlayerConnect
==============
*/
void Scr_PlayerConnect(gentity_s *self)
{
  int playerconnect; 
  scrContext_t *v3; 
  unsigned int v4; 

  playerconnect = GameScriptDataMP::GetGameScriptDataMP()->gametype.playerconnect;
  v3 = ScriptContext_Server();
  v4 = GScr_ExecEntThread(self, playerconnect, 0);
  Scr_FreeThread(v3, v4);
}

/*
==============
Scr_PlayerDamage
==============
*/
void Scr_PlayerDamage(gentity_s *self, const gentity_s *inflictor, gentity_s *attacker, int damage, int dflags, int meansOfDeath, const Weapon *r_weapon, bool isAlternate, const vec3_t *vPoint, const vec3_t *vDir, const hitLocation_t hitLoc, int timeOffset, int modelIndex, scr_string_t partName, const GExtraDamageParams *extraParams, int unscaledDamage)
{
  scrContext_t *v20; 
  scr_string_t HitLocationString; 
  scrContext_t *v22; 
  scrContext_t *v23; 
  GameScriptDataMP *GameScriptDataMP; 
  unsigned int v25; 

  v20 = ScriptContext_Server();
  Scr_AddInt(v20, unscaledDamage);
  Scr_AddBool(v20, extraParams->m_isHitScanBulletDamage);
  if ( partName )
    Scr_AddConstString(v20, partName);
  else
    Scr_AddUndefined(v20);
  Scr_AddInt(v20, modelIndex);
  Scr_AddInt(v20, timeOffset);
  HitLocationString = G_Combat_GetHitLocationString(hitLoc);
  Scr_AddConstString(v20, HitLocationString);
  if ( vDir )
    Scr_AddVector(v20, vDir->v);
  else
    Scr_AddUndefined(v20);
  if ( vPoint )
    Scr_AddVector(v20, vPoint->v);
  else
    Scr_AddUndefined(v20);
  GScr_Weapon_AddParam(v20, r_weapon, isAlternate);
  if ( (unsigned int)meansOfDeath > 0x18 )
    Scr_AddString(v20, "badMOD");
  else
    Scr_AddConstString(v20, *g_combat_modNames[meansOfDeath]);
  Scr_AddInt(v20, dflags);
  Scr_AddInt(v20, damage);
  v22 = ScriptContext_Server();
  if ( attacker )
    GScr_AddEntity(attacker);
  else
    Scr_AddUndefined(v22);
  v23 = ScriptContext_Server();
  if ( inflictor )
    GScr_AddEntity(inflictor);
  else
    Scr_AddUndefined(v23);
  GameScriptDataMP = GameScriptDataMP::GetGameScriptDataMP();
  v25 = GScr_ExecEntThread(self, GameScriptDataMP->gametype.playerdamage, 0xEu);
  Scr_FreeThread(v20, v25);
}

/*
==============
Scr_PlayerDisconnect
==============
*/
void Scr_PlayerDisconnect(gentity_s *self, const char *reason)
{
  scrContext_t *v4; 
  char *v5; 
  GameScriptDataMP *GameScriptDataMP; 
  unsigned int v7; 
  char dest[32]; 

  v4 = ScriptContext_Server();
  if ( reason )
  {
    Core_strcpy_truncate(dest, 0x1Aui64, reason);
    v5 = dest;
  }
  else
  {
    v5 = "NULL";
  }
  Scr_AddString(v4, v5);
  GameScriptDataMP = GameScriptDataMP::GetGameScriptDataMP();
  v7 = GScr_ExecEntThread(self, GameScriptDataMP->gametype.playerdisconnect, 1u);
  Scr_FreeThread(v4, v7);
}

/*
==============
Scr_PlayerKilled
==============
*/
void Scr_PlayerKilled(gentity_s *self, const gentity_s *inflictor, gentity_s *attacker, int damage, int damageFlags, int meansOfDeath, const Weapon *r_weapon, bool isAlternate, const vec3_t *vDir, const hitLocation_t hitLoc, int psTimeOffset, int deathAnimDuration)
{
  scrContext_t *v16; 
  scr_string_t HitLocationString; 
  scrContext_t *v18; 
  scrContext_t *v19; 
  GameScriptDataMP *GameScriptDataMP; 
  unsigned int v21; 

  v16 = ScriptContext_Server();
  Scr_AddInt(v16, deathAnimDuration);
  Scr_AddInt(v16, psTimeOffset);
  HitLocationString = G_Combat_GetHitLocationString(hitLoc);
  Scr_AddConstString(v16, HitLocationString);
  if ( vDir )
    Scr_AddVector(v16, vDir->v);
  else
    Scr_AddUndefined(v16);
  GScr_Weapon_AddParam(v16, r_weapon, isAlternate);
  if ( (unsigned int)meansOfDeath > 0x18 )
    Scr_AddString(v16, "badMOD");
  else
    Scr_AddConstString(v16, *g_combat_modNames[meansOfDeath]);
  Scr_AddInt(v16, damageFlags);
  Scr_AddInt(v16, damage);
  v18 = ScriptContext_Server();
  if ( attacker )
    GScr_AddEntity(attacker);
  else
    Scr_AddUndefined(v18);
  v19 = ScriptContext_Server();
  if ( inflictor )
    GScr_AddEntity(inflictor);
  else
    Scr_AddUndefined(v19);
  GameScriptDataMP = GameScriptDataMP::GetGameScriptDataMP();
  v21 = GScr_ExecEntThread(self, GameScriptDataMP->gametype.playerkilled, 0xAu);
  Scr_FreeThread(v16, v21);
}

/*
==============
Scr_PlayerLastStand
==============
*/
bool Scr_PlayerLastStand(gentity_s *self, gentity_s *inflictor, gentity_s *attacker, int damage, int meansOfDeath, const Weapon *r_weapon, bool isAlternate, const vec3_t *vDir, const hitLocation_t hitLoc, int psTimeOffset)
{
  scrContext_t *v14; 
  scr_string_t HitLocationString; 
  scrContext_t *v16; 
  scrContext_t *v17; 
  GameScriptDataMP *GameScriptDataMP; 
  unsigned int v19; 
  int outReturnValue; 

  v14 = ScriptContext_Server();
  Scr_AddInt(v14, 0);
  Scr_AddInt(v14, psTimeOffset);
  HitLocationString = G_Combat_GetHitLocationString(hitLoc);
  Scr_AddConstString(v14, HitLocationString);
  Scr_AddVector(v14, vDir->v);
  GScr_Weapon_AddParam(v14, r_weapon, isAlternate);
  if ( (unsigned int)meansOfDeath > 0x18 )
    Scr_AddString(v14, "badMOD");
  else
    Scr_AddConstString(v14, *g_combat_modNames[meansOfDeath]);
  Scr_AddInt(v14, damage);
  v16 = ScriptContext_Server();
  if ( attacker )
    GScr_AddEntity(attacker);
  else
    Scr_AddUndefined(v16);
  v17 = ScriptContext_Server();
  if ( inflictor )
    GScr_AddEntity(inflictor);
  else
    Scr_AddUndefined(v17);
  GameScriptDataMP = GameScriptDataMP::GetGameScriptDataMP();
  v19 = GScr_ExecEntThreadWithReturnValue(self, GameScriptDataMP->gametype.playerlaststand, 9u, Scr_ExecThreadCallback_Unsigned, NULL, &outReturnValue);
  Scr_FreeThread(v14, v19);
  return outReturnValue != 0;
}

/*
==============
Scr_PlayerMigrated
==============
*/
void Scr_PlayerMigrated(gentity_s *self)
{
  GameScriptDataMP *GameScriptDataMP; 
  scrContext_t *v3; 
  unsigned int v4; 

  GameScriptDataMP = GameScriptDataMP::GetGameScriptDataMP();
  v3 = ScriptContext_Server();
  v4 = GScr_ExecEntThread(self, GameScriptDataMP->gametype.playermigrated, 0);
  Scr_FreeThread(v3, v4);
}

/*
==============
Scr_PlayerVote
==============
*/
void Scr_PlayerVote(gentity_s *self, char *option)
{
  scrContext_t *v4; 

  v4 = ScriptContext_Server();
  Scr_AddString(v4, option);
  GScr_Notify(self, scr_const.vote, 1u);
}

/*
==============
Scr_SpawnFXInternal
==============
*/
gentity_s *Scr_SpawnFXInternal(scrContext_t *scrContext, int fxId, const vec3_t *pos, int givenAxisCount, tmat33_t<vec3_t> *axis)
{
  gentity_s *v9; 
  __int64 v11; 
  int v12; 
  int v13; 

  if ( fxId <= 0 )
    goto LABEL_17;
  if ( !BgDynamicLimits::IsValidGameMode() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_dynamic_limits.h", 98, ASSERT_TYPE_ASSERT, "(IsValidGameMode())", "%s\n\tAccessing BgDynamicLimits during invalid game mode", "IsValidGameMode()") )
    __debugbreak();
  if ( fxId >= BgDynamicLimits::ms_data.m_effectNamesCount )
  {
LABEL_17:
    if ( !BgDynamicLimits::IsValidGameMode() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_dynamic_limits.h", 98, ASSERT_TYPE_ASSERT, "(IsValidGameMode())", "%s\n\tAccessing BgDynamicLimits during invalid game mode", "IsValidGameMode()") )
      __debugbreak();
    v13 = BgDynamicLimits::ms_data.m_effectNamesCount - 1;
    v12 = fxId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 10635, ASSERT_TYPE_ASSERT, "(FX_IsValidFxId( fxId ))", "%s\n\tInvalid fxId %d. Max effect ID is %d", "FX_IsValidFxId( fxId )", v12, v13) )
      __debugbreak();
  }
  Sys_ProfBeginNamedEvent(0xFFFF0000, "Scr_SpawnFXInternal");
  v9 = G_Utils_SpawnEntity();
  v9->s.eType = ET_FX;
  v9->s.staticState.general.xmodel = fxId;
  G_SetOrigin(v9, pos, 1, 1);
  Scr_SetFxAngles(scrContext, givenAxisCount, axis, &v9->s.lerp.apos.trBase, fxId);
  if ( v9->s.time2 )
  {
    LODWORD(v11) = v9->s.time2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 10646, ASSERT_TYPE_SANITY, "( ( ent->s.time2 == 0 ) )", "( ent->s.time2 ) = %i", v11) )
      __debugbreak();
  }
  SV_LinkEntity(v9);
  Sys_ProfEndNamedEvent();
  return v9;
}

/*
==============
Scr_StartupGameType
==============
*/
void Scr_StartupGameType(void)
{
  GameScriptDataMP *GameScriptDataMP; 
  scrContext_t *v1; 
  unsigned int v2; 

  GameScriptDataMP = GameScriptDataMP::GetGameScriptDataMP();
  if ( !GameScriptDataMP->gametype.startupgametype && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 12815, ASSERT_TYPE_ASSERT, "(gScrData->gametype.startupgametype != 0)", (const char *)&queryFormat, "gScrData->gametype.startupgametype != 0") )
    __debugbreak();
  v1 = ScriptContext_Server();
  v2 = Scr_ExecThread(v1, GameScriptDataMP->gametype.startupgametype, 0);
  Scr_FreeThread(v1, v2);
}

/*
==============
Scr_VisionSetForPlayer_Internal
==============
*/
void Scr_VisionSetForPlayer_Internal(scrContext_t *scrContext, scr_entref_t entref, visionSetMode_t visMode)
{
  __int64 v3; 
  unsigned int entnum; 
  gentity_s *v6; 
  const char *v7; 
  int number; 
  const char *v9; 
  unsigned int v10; 
  unsigned int v11; 
  scr_string_t ConstLowercaseString; 
  const char *v15; 
  const char *v16; 
  const char *v17; 
  const char *v18; 
  const char *v19; 
  SvClient *CommonClient; 
  int outControllingClientNum[10]; 
  unsigned int outVisionSetIndex; 

  v3 = visMode;
  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3678, scrContext, "not an entity");
    v6 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5031, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v6 = &g_entities[entnum];
    if ( !v6->client && !v6->agent )
    {
      v7 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3677, scrContext, v7);
    }
  }
  number = v6->s.number;
  outControllingClientNum[0] = number;
  if ( SV_IsAgent(number) && !SV_GetAgentControlledByPlayerNum(outControllingClientNum[0], outControllingClientNum) )
  {
    v9 = j_va("entity %i is not a player or player-controlled agent", entnum);
    Scr_ObjectError(COM_ERR_3095, scrContext, v9);
    return;
  }
  v10 = 1000;
  v11 = Scr_GetNumParam(scrContext) - 1;
  if ( v11 )
  {
    if ( v11 != 1 )
    {
      Scr_Error(COM_ERR_3096, scrContext, "USAGE: <player> VisionSetForPlayer( <visionset name>, <transition time> )\n");
      return;
    }
    Scr_GetFloat(scrContext, 1u);
    _XMM0 = 0i64;
    __asm { vroundss xmm1, xmm0, xmm4, 1 }
    v10 = (int)*(float *)&_XMM1;
  }
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  v15 = SL_ConvertToString(ConstLowercaseString);
  v16 = v15;
  if ( *v15 )
  {
    if ( !NetConstStrings_GetVisionSetIndex(v15, &outVisionSetIndex) )
    {
      v17 = j_va("visionset %s has not been precached, include with precache_vision", v16);
      Scr_Error(COM_ERR_3097, scrContext, v17);
    }
    if ( !outVisionSetIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5066, ASSERT_TYPE_ASSERT, "( visionIndex != 0 )", (const char *)&queryFormat, "visionIndex != 0") )
      __debugbreak();
  }
  else
  {
    outVisionSetIndex = 0;
  }
  v18 = j_va("%c %d %i", (unsigned int)MY_CMDS[v3], outVisionSetIndex, v10);
  v19 = v18;
  if ( outControllingClientNum[0] == -1 )
  {
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v18);
  }
  else
  {
    CommonClient = SvClient::GetCommonClient(outControllingClientNum[0]);
    CommonClient->SendServerCommand(CommonClient, SV_CMD_RELIABLE, v19);
  }
}

/*
==============
Scr_VoteCalled
==============
*/
void Scr_VoteCalled(gentity_s *self, char *command, char *param1, char *param2)
{
  scrContext_t *v8; 

  v8 = ScriptContext_Server();
  Scr_AddString(v8, param2);
  Scr_AddString(v8, param1);
  Scr_AddString(v8, command);
  GScr_Notify(self, scr_const.call_vote, 3u);
}

