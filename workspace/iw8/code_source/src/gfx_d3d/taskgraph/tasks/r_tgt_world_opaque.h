/*
==============
Util_KickoffToken
==============
*/

void __fastcall Util_KickoffToken(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?Util_KickoffToken@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RT_DrawOpaqueSetup
==============
*/

void __fastcall RT_DrawOpaqueSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  ?RT_DrawOpaqueSetup@@YAXPEBUGfxTaskInfo@@PEAUGfxViewInfo@@@Z(taskInfo, viewInfo);
}

/*
==============
cRBT_DrawOpaque<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_DrawOpaque<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>, const R_TG_Handle *<args_11>, const R_TG_Handle *<args_12>, const R_TG_Handle *<args_13>, const R_TG_Handle *<args_14>, const R_TG_Handle *<args_15>, const R_TG_Handle *<args_16>, const R_TG_Handle *<args_17>, const R_TG_Handle *<args_18>, const R_TG_Handle *<args_19>, const R_TG_Handle *<args_20>, const R_TG_Handle *<args_21>, const R_TG_Handle *<args_22>, const R_TG_Handle *<args_23>, const R_TG_Handle *<args_24>, const R_TG_Handle *<args_25>)
{
  return ??$cRBT_DrawOpaque@UR_TG_Handle@@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1111111111111111111111111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>, <args_11>, <args_12>, <args_13>, <args_14>, <args_15>, <args_16>, <args_17>, <args_18>, <args_19>, <args_20>, <args_21>, <args_22>, <args_23>, <args_24>, <args_25>);
}

/*
==============
RBT_DrawDecal
==============
*/

void __fastcall RBT_DrawDecal(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DrawDecal@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBT_DrawDecal<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_DrawDecal<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>, const R_TG_Handle *<args_11>, const R_TG_Handle *<args_12>, const R_TG_Handle *<args_13>, const R_TG_Handle *<args_14>, const R_TG_Handle *<args_15>, const R_TG_Handle *<args_16>, const R_TG_Handle *<args_17>, const R_TG_Handle *<args_18>, const R_TG_Handle *<args_19>, const R_TG_Handle *<args_20>, const R_TG_Handle *<args_21>, const R_TG_Handle *<args_22>, const R_TG_Handle *<args_23>)
{
  return ??$cRBT_DrawDecal@UR_TG_Handle@@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11111111111111111111111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>, <args_11>, <args_12>, <args_13>, <args_14>, <args_15>, <args_16>, <args_17>, <args_18>, <args_19>, <args_20>, <args_21>, <args_22>, <args_23>);
}

/*
==============
cUtil_KickoffToken<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cUtil_KickoffToken<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cUtil_KickoffToken@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
RT_DrawDecalSetup
==============
*/

void __fastcall RT_DrawDecalSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  ?RT_DrawDecalSetup@@YAXPEBUGfxTaskInfo@@PEAUGfxViewInfo@@@Z(taskInfo, viewInfo);
}

/*
==============
RBT_DrawOpaque
==============
*/

void __fastcall RBT_DrawOpaque(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DrawOpaque@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBT_DrawDecal<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_DrawDecal<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>, const R_TG_Handle *<args_11>, const R_TG_Handle *<args_12>, const R_TG_Handle *<args_13>, const R_TG_Handle *<args_14>, const R_TG_Handle *<args_15>, const R_TG_Handle *<args_16>, const R_TG_Handle *<args_17>, const R_TG_Handle *<args_18>, const R_TG_Handle *<args_19>, const R_TG_Handle *<args_20>, const R_TG_Handle *<args_21>, const R_TG_Handle *<args_22>, const R_TG_Handle *<args_23>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(context, g_R_TG_Def_RBT_DrawDecal.m_index, &arguments, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>, <args_11>, <args_12>, <args_13>, <args_14>, <args_15>, <args_16>, <args_17>, <args_18>, <args_19>, <args_20>, <args_21>, <args_22>, <args_23>);
}

/*
==============
cRBT_DrawOpaque<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_DrawOpaque<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>, const R_TG_Handle *<args_11>, const R_TG_Handle *<args_12>, const R_TG_Handle *<args_13>, const R_TG_Handle *<args_14>, const R_TG_Handle *<args_15>, const R_TG_Handle *<args_16>, const R_TG_Handle *<args_17>, const R_TG_Handle *<args_18>, const R_TG_Handle *<args_19>, const R_TG_Handle *<args_20>, const R_TG_Handle *<args_21>, const R_TG_Handle *<args_22>, const R_TG_Handle *<args_23>, const R_TG_Handle *<args_24>, const R_TG_Handle *<args_25>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(context, g_R_TG_Def_RBT_DrawOpaque.m_index, &arguments, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>, <args_11>, <args_12>, <args_13>, <args_14>, <args_15>, <args_16>, <args_17>, <args_18>, <args_19>, <args_20>, <args_21>, <args_22>, <args_23>, <args_24>, <args_25>);
}

/*
==============
cUtil_KickoffToken<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cUtil_KickoffToken<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_Util_KickoffToken.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
RBT_DrawDecal
==============
*/
void RBT_DrawDecal(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  RB_RunDrawList(viewInfo, data, &taskInfo->rtGroup, DRAWLIST_LIT_DECAL);
}

/*
==============
RBT_DrawOpaque
==============
*/
void RBT_DrawOpaque(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  const dvar_t *v4; 
  unsigned int taskFlags; 
  __int64 v9; 
  __int64 v10; 
  const R_TG_DrawList *v11; 
  const dvar_t *v12; 

  v4 = r_flushCommandListsAt_Flags;
  taskFlags = taskInfo->pGraphInfo->taskFlags;
  if ( !r_flushCommandListsAt_Flags && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 627, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar accessed after deregistration", "dvar") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v4);
  v9 = 0i64;
  v10 = 13i64;
  do
  {
    v11 = &g_R_TG_opaqueGroups[0].drawLists[v9];
    if ( (taskFlags & g_R_TG_opaqueGroups[0].drawLists[v9].enableFlags) == g_R_TG_opaqueGroups[0].drawLists[v9].enableFlags && (taskFlags & v11->disableFlags) == 0 )
      RB_RunDrawList(viewInfo, data, &taskInfo->rtGroup, v11->type);
    ++v9;
    --v10;
  }
  while ( v10 );
  v12 = r_flushCommandListsAt_Flags;
  if ( !r_flushCommandListsAt_Flags && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 627, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar accessed after deregistration", "dvar") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v12);
}

/*
==============
RT_DrawDecalSetup
==============
*/
void RT_DrawDecalSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  __int16 v2; 
  R_RT_Image *blackImage3D; 
  R_RT_Image *whiteImage3D; 
  R_RT_Image *whiteImage; 
  R_RT_Image *defaultWaveWaterFloatZImage; 
  R_RT_Image *p_m_image; 
  R_RT_Handle v10; 

  blackImage3D = (R_RT_Image *)rgp.blackImage3D;
  v10 = taskInfo->attachments[7];
  if ( v2 )
  {
    R_RT_Handle::GetSurface(&v10);
    blackImage3D = &R_RT_Handle::GetSurface(&v10)->m_image;
  }
  else if ( v10.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v10.m_surfaceID) )
  {
    __debugbreak();
  }
  if ( viewInfo == (GfxViewInfo *)-3760i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1482, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  viewInfo->input.codePersistentImages[25] = &blackImage3D->m_base;
  whiteImage3D = (R_RT_Image *)rgp.whiteImage3D;
  v10 = taskInfo->attachments[8];
  if ( v2 )
  {
    R_RT_Handle::GetSurface(&v10);
    whiteImage3D = &R_RT_Handle::GetSurface(&v10)->m_image;
  }
  else if ( v10.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v10.m_surfaceID) )
  {
    __debugbreak();
  }
  if ( viewInfo == (GfxViewInfo *)-3760i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1482, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  viewInfo->input.codePersistentImages[26] = &whiteImage3D->m_base;
  whiteImage = (R_RT_Image *)rgp.whiteImage;
  v10 = taskInfo->attachments[9];
  if ( v2 )
  {
    R_RT_Handle::GetSurface(&v10);
    whiteImage = &R_RT_Handle::GetSurface(&v10)->m_image;
  }
  else if ( v10.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v10.m_surfaceID) )
  {
    __debugbreak();
  }
  if ( viewInfo == (GfxViewInfo *)-3760i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1482, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  viewInfo->input.codePersistentImages[27] = &whiteImage->m_base;
  defaultWaveWaterFloatZImage = (R_RT_Image *)rgp.defaultWaveWaterFloatZImage;
  v10 = taskInfo->attachments[21];
  if ( v2 )
  {
    R_RT_Handle::GetSurface(&v10);
    defaultWaveWaterFloatZImage = &R_RT_Handle::GetSurface(&v10)->m_image;
  }
  else if ( v10.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v10.m_surfaceID) )
  {
    __debugbreak();
  }
  if ( viewInfo == (GfxViewInfo *)-3760i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1482, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  viewInfo->input.codePersistentImages[15] = &defaultWaveWaterFloatZImage->m_base;
  p_m_image = (R_RT_Image *)rgp.defaultWaveWaterFloatZImage;
  v10 = taskInfo->attachments[21];
  if ( v2 )
  {
    R_RT_Handle::GetSurface(&v10);
    p_m_image = &R_RT_Handle::GetSurface(&v10)->m_image;
  }
  else if ( v10.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v10.m_surfaceID) )
  {
    __debugbreak();
  }
  if ( viewInfo == (GfxViewInfo *)-3760i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  viewInfo->input.codeImages[77] = &p_m_image->m_base;
  R_AddDrawCall(viewInfo, &taskInfo->rtGroup, DRAWLIST_LIT_DECAL, 0x5Du);
}

/*
==============
RT_DrawOpaqueSetup
==============
*/
void RT_DrawOpaqueSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  __int16 v2; 
  GfxCmdBufInput *p_input; 
  R_RT_Image *blackImage3D; 
  R_RT_Image *p_m_image; 
  R_RT_Image *blackImage; 
  R_RT_Image *whiteImage; 
  R_RT_Image *v10; 
  bool v11; 
  R_RT_Image *blackShadowImage; 
  bool v13; 
  R_RT_Image *whiteUintImage; 
  R_RT_Image *v15; 
  R_RT_Image *v16; 
  R_RT_Image *v17; 
  GfxImage *v18; 
  GfxWrappedBuffer *p_dummyDataBufferR32UINT; 
  const R_RT_Surface *Surface; 
  GfxWrappedBuffer *p_dummyStructuredBuffer8; 
  const R_RT_Surface *v22; 
  __int64 v23; 
  __int64 v24; 
  unsigned int taskFlags; 
  const R_TG_DrawList *v26; 
  R_RT_Handle v27; 

  p_input = &viewInfo->input;
  v27 = *taskInfo->attachments;
  R_SetInputCodePersistentBuffer(&viewInfo->input, 0xAu, &v27);
  v27 = taskInfo->attachments[1];
  R_SetInputCodePersistentBuffer(p_input, 0xBu, &v27);
  v27 = taskInfo->attachments[2];
  R_SetInputCodePersistentBuffer(p_input, 6u, &v27);
  blackImage3D = (R_RT_Image *)rgp.blackImage3D;
  v27 = taskInfo->attachments[3];
  if ( v2 )
  {
    R_RT_Handle::GetSurface(&v27);
    blackImage3D = &R_RT_Handle::GetSurface(&v27)->m_image;
  }
  else if ( v27.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v27.m_surfaceID) )
  {
    __debugbreak();
  }
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1482, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codePersistentImages[21] = &blackImage3D->m_base;
  p_m_image = (R_RT_Image *)rgp.blackImage3D;
  v27 = taskInfo->attachments[4];
  if ( v2 )
  {
    R_RT_Handle::GetSurface(&v27);
    p_m_image = &R_RT_Handle::GetSurface(&v27)->m_image;
  }
  else if ( v27.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v27.m_surfaceID) )
  {
    __debugbreak();
  }
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1482, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codePersistentImages[22] = &p_m_image->m_base;
  blackImage = (R_RT_Image *)rgp.blackImage;
  v27 = taskInfo->attachments[5];
  if ( v2 )
  {
    R_RT_Handle::GetSurface(&v27);
    blackImage = &R_RT_Handle::GetSurface(&v27)->m_image;
  }
  else if ( v27.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v27.m_surfaceID) )
  {
    __debugbreak();
  }
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codeImages[0] = &blackImage->m_base;
  whiteImage = (R_RT_Image *)rgp.whiteImage;
  v27 = taskInfo->attachments[6];
  if ( v2 )
  {
    R_RT_Handle::GetSurface(&v27);
    whiteImage = &R_RT_Handle::GetSurface(&v27)->m_image;
  }
  else if ( v27.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v27.m_surfaceID) )
  {
    __debugbreak();
  }
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1482, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codePersistentImages[10] = &whiteImage->m_base;
  v27 = taskInfo->attachments[10];
  R_SetInputCodePersistentBuffer(p_input, 0x11u, &v27);
  v27 = taskInfo->attachments[11];
  R_SetInputCodePersistentBuffer(p_input, 0x10u, &v27);
  v10 = (R_RT_Image *)rgp.whiteImage;
  v11 = (*((_DWORD *)&viewInfo->viewportFeatures + 11) & 4) != 0;
  v27 = taskInfo->attachments[12];
  if ( v2 )
  {
    R_RT_Handle::GetSurface(&v27);
    if ( v11 )
      v10 = &R_RT_Handle::GetSurface(&v27)->m_image;
  }
  else if ( v27.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v27.m_surfaceID) )
  {
    __debugbreak();
  }
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1482, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codePersistentImages[0] = &v10->m_base;
  blackShadowImage = (R_RT_Image *)rgp.blackShadowImage;
  v13 = (*((_DWORD *)&viewInfo->viewportFeatures + 11) & 2) != 0;
  v27 = taskInfo->attachments[13];
  if ( v2 )
  {
    R_RT_Handle::GetSurface(&v27);
    if ( v13 )
      blackShadowImage = &R_RT_Handle::GetSurface(&v27)->m_image;
  }
  else if ( v27.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v27.m_surfaceID) )
  {
    __debugbreak();
  }
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1482, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codePersistentImages[8] = &blackShadowImage->m_base;
  whiteUintImage = (R_RT_Image *)rgp.whiteUintImage;
  v27 = taskInfo->attachments[14];
  if ( v2 )
  {
    R_RT_Handle::GetSurface(&v27);
    whiteUintImage = &R_RT_Handle::GetSurface(&v27)->m_image;
  }
  else if ( v27.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v27.m_surfaceID) )
  {
    __debugbreak();
  }
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1482, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codePersistentImages[9] = &whiteUintImage->m_base;
  v15 = (R_RT_Image *)rgp.blackImage;
  v27 = taskInfo->attachments[15];
  if ( v2 )
  {
    R_RT_Handle::GetSurface(&v27);
    v15 = &R_RT_Handle::GetSurface(&v27)->m_image;
  }
  else if ( v27.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v27.m_surfaceID) )
  {
    __debugbreak();
  }
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codeImages[7] = &v15->m_base;
  v16 = (R_RT_Image *)rgp.blackImage;
  v27 = taskInfo->attachments[16];
  if ( v2 )
  {
    R_RT_Handle::GetSurface(&v27);
    v16 = &R_RT_Handle::GetSurface(&v27)->m_image;
  }
  else if ( v27.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v27.m_surfaceID) )
  {
    __debugbreak();
  }
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1482, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codePersistentImages[11] = &v16->m_base;
  v17 = (R_RT_Image *)rgp.blackImage;
  v27 = taskInfo->attachments[19];
  if ( v2 )
  {
    R_RT_Handle::GetSurface(&v27);
    v17 = &R_RT_Handle::GetSurface(&v27)->m_image;
  }
  else if ( v27.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v27.m_surfaceID) )
  {
    __debugbreak();
  }
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codeImages[80] = &v17->m_base;
  v18 = rgp.blackImage;
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1482, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codePersistentImages[12] = v18;
  v27 = taskInfo->attachments[20];
  if ( v2 )
  {
    R_RT_Handle::GetSurface(&v27);
    Surface = R_RT_Handle::GetSurface(&v27);
    if ( (Surface->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer", *(_QWORD *)&v27.m_surfaceID) )
      __debugbreak();
    p_dummyDataBufferR32UINT = (GfxWrappedBuffer *)&Surface->1080;
  }
  else
  {
    if ( v27.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v27.m_surfaceID) )
      __debugbreak();
    p_dummyDataBufferR32UINT = &gfxBuf.dummyDataBufferR32UINT;
  }
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1503, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codePersistentBuffers[14] = p_dummyDataBufferR32UINT;
  v27 = taskInfo->attachments[21];
  if ( v2 )
  {
    R_RT_Handle::GetSurface(&v27);
    v22 = R_RT_Handle::GetSurface(&v27);
    if ( (v22->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer", *(_QWORD *)&v27.m_surfaceID) )
      __debugbreak();
    p_dummyStructuredBuffer8 = (GfxWrappedBuffer *)&v22->1080;
  }
  else
  {
    if ( v27.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v27.m_surfaceID) )
      __debugbreak();
    p_dummyStructuredBuffer8 = &gfxBuf.dummyStructuredBuffer8;
  }
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1494, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codeBuffers[43] = p_dummyStructuredBuffer8;
  v23 = 0i64;
  v24 = 13i64;
  taskFlags = taskInfo->pGraphInfo->taskFlags;
  do
  {
    v26 = &g_R_TG_opaqueGroups[0].drawLists[v23];
    if ( (taskFlags & g_R_TG_opaqueGroups[0].drawLists[v23].enableFlags) == g_R_TG_opaqueGroups[0].drawLists[v23].enableFlags && (taskFlags & v26->disableFlags) == 0 )
      R_AddDrawCall(viewInfo, &taskInfo->rtGroup, v26->type, 0x5Du);
    ++v23;
    --v24;
  }
  while ( v24 );
}

/*
==============
Util_KickoffToken
==============
*/
void Util_KickoffToken(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ;
}

