/*
==============
SV_TransientsSP_Process
==============
*/

void SV_TransientsSP_Process(void)
{
  ?SV_TransientsSP_Process@@YAXXZ();
}

/*
==============
SV_TransientsSP_DumpTransientSets_f
==============
*/

void SV_TransientsSP_DumpTransientSets_f(void)
{
  ?SV_TransientsSP_DumpTransientSets_f@@YAXXZ();
}

/*
==============
Scr_TransientsSP_IsTransientQueued
==============
*/

void __fastcall Scr_TransientsSP_IsTransientQueued(scrContext_t *scrContext)
{
  ?Scr_TransientsSP_IsTransientQueued@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
SV_TransientsSP_ShutdownAll
==============
*/

void SV_TransientsSP_ShutdownAll(void)
{
  ?SV_TransientsSP_ShutdownAll@@YAXXZ();
}

/*
==============
Scr_TransientsSP_GetQueuedSPLevelTransients
==============
*/

void __fastcall Scr_TransientsSP_GetQueuedSPLevelTransients(scrContext_t *scrContext)
{
  ?Scr_TransientsSP_GetQueuedSPLevelTransients@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
SV_TransientsSP_ShutdownLevel
==============
*/

void SV_TransientsSP_ShutdownLevel(void)
{
  ?SV_TransientsSP_ShutdownLevel@@YAXXZ();
}

/*
==============
SV_TransientsSP_SyncForSpawnServer
==============
*/

void SV_TransientsSP_SyncForSpawnServer(void)
{
  ?SV_TransientsSP_SyncForSpawnServer@@YAXXZ();
}

/*
==============
SV_TransientsSP_SyncForDemoSave
==============
*/

void SV_TransientsSP_SyncForDemoSave(void)
{
  ?SV_TransientsSP_SyncForDemoSave@@YAXXZ();
}

/*
==============
Scr_TransientsSP_LoadTransient
==============
*/

void __fastcall Scr_TransientsSP_LoadTransient(scrContext_t *scrContext)
{
  ?Scr_TransientsSP_LoadTransient@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_TransientsSP_SyncTransients
==============
*/

void __fastcall Scr_TransientsSP_SyncTransients(scrContext_t *scrContext)
{
  ?Scr_TransientsSP_SyncTransients@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_TransientsSP_SwitchTransientSet
==============
*/

void __fastcall Scr_TransientsSP_SwitchTransientSet(scrContext_t *scrContext)
{
  ?Scr_TransientsSP_SwitchTransientSet@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_TransientsSP_IsSPLevelTransient
==============
*/

void __fastcall Scr_TransientsSP_IsSPLevelTransient(scrContext_t *scrContext)
{
  ?Scr_TransientsSP_IsSPLevelTransient@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
SV_TransientsSP_SetSavegameTransientState
==============
*/

void __fastcall SV_TransientsSP_SetSavegameTransientState(const bitarray<32> *state)
{
  ?SV_TransientsSP_SetSavegameTransientState@@YAXAEBV?$bitarray@$0CA@@@@Z(state);
}

/*
==============
SV_TransientsSP_LoadWeaponTransient_f
==============
*/

void SV_TransientsSP_LoadWeaponTransient_f(void)
{
  ?SV_TransientsSP_LoadWeaponTransient_f@@YAXXZ();
}

/*
==============
SV_TransientsSP_Init
==============
*/

void SV_TransientsSP_Init(void)
{
  ?SV_TransientsSP_Init@@YAXXZ();
}

/*
==============
SV_TransientsSP_SyncForLoadLevel
==============
*/

void SV_TransientsSP_SyncForLoadLevel(void)
{
  ?SV_TransientsSP_SyncForLoadLevel@@YAXXZ();
}

/*
==============
SV_TransientsSP_LoadTransientDependencies
==============
*/

void SV_TransientsSP_LoadTransientDependencies(void)
{
  ?SV_TransientsSP_LoadTransientDependencies@@YAXXZ();
}

/*
==============
Scr_TransientsSP_GetTransientSetNames
==============
*/

void __fastcall Scr_TransientsSP_GetTransientSetNames(scrContext_t *scrContext)
{
  ?Scr_TransientsSP_GetTransientSetNames@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_TransientsSP_WaitForTransient
==============
*/

void __fastcall Scr_TransientsSP_WaitForTransient(scrContext_t *scrContext)
{
  ?Scr_TransientsSP_WaitForTransient@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_TransientsSP_UnloadAllTransients
==============
*/

void __fastcall Scr_TransientsSP_UnloadAllTransients(scrContext_t *scrContext)
{
  ?Scr_TransientsSP_UnloadAllTransients@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_TransientsSP_GetAllSPLevelTransients
==============
*/

void __fastcall Scr_TransientsSP_GetAllSPLevelTransients(scrContext_t *scrContext)
{
  ?Scr_TransientsSP_GetAllSPLevelTransients@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_TransientsSP_GetTransientsInSet
==============
*/

void __fastcall Scr_TransientsSP_GetTransientsInSet(scrContext_t *scrContext)
{
  ?Scr_TransientsSP_GetTransientsInSet@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
SV_TransientsSP_InitLevel
==============
*/

void SV_TransientsSP_InitLevel(void)
{
  ?SV_TransientsSP_InitLevel@@YAXXZ();
}

/*
==============
Scr_TransientsSP_GetLoadedSPLevelTransients
==============
*/

void __fastcall Scr_TransientsSP_GetLoadedSPLevelTransients(scrContext_t *scrContext)
{
  ?Scr_TransientsSP_GetLoadedSPLevelTransients@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_TransientsSP_IsTransientLoaded
==============
*/

void __fastcall Scr_TransientsSP_IsTransientLoaded(scrContext_t *scrContext)
{
  ?Scr_TransientsSP_IsTransientLoaded@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_TransientsSP_IsLoadingAnyTransients
==============
*/

void __fastcall Scr_TransientsSP_IsLoadingAnyTransients(scrContext_t *scrContext)
{
  ?Scr_TransientsSP_IsLoadingAnyTransients@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_TransientsSP_SetTransientVisibility
==============
*/

void __fastcall Scr_TransientsSP_SetTransientVisibility(scrContext_t *scrContext)
{
  ?Scr_TransientsSP_SetTransientVisibility@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_TransientsSP_ClearStartPointTransients
==============
*/

void __fastcall Scr_TransientsSP_ClearStartPointTransients(scrContext_t *scrContext)
{
  ?Scr_TransientsSP_ClearStartPointTransients@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_TransientsSP_WaitForAllTransients
==============
*/

void __fastcall Scr_TransientsSP_WaitForAllTransients(scrContext_t *scrContext)
{
  ?Scr_TransientsSP_WaitForAllTransients@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_TransientsSP_UnloadTransient
==============
*/

void __fastcall Scr_TransientsSP_UnloadTransient(scrContext_t *scrContext)
{
  ?Scr_TransientsSP_UnloadTransient@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
SV_TransientsSP_ErrorCleanup
==============
*/

void SV_TransientsSP_ErrorCleanup(void)
{
  ?SV_TransientsSP_ErrorCleanup@@YAXXZ();
}

/*
==============
SV_TransientsSP_UnloadWeaponTransient_f
==============
*/

void SV_TransientsSP_UnloadWeaponTransient_f(void)
{
  ?SV_TransientsSP_UnloadWeaponTransient_f@@YAXXZ();
}

/*
==============
Scr_TransientsSP_IsLoadingSavegame
==============
*/

void __fastcall Scr_TransientsSP_IsLoadingSavegame(scrContext_t *scrContext)
{
  ?Scr_TransientsSP_IsLoadingSavegame@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_TransientsSP_GetSavegameTransients
==============
*/

void __fastcall Scr_TransientsSP_GetSavegameTransients(scrContext_t *scrContext)
{
  ?Scr_TransientsSP_GetSavegameTransients@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_TransientsSP_LoadStartPointTransients
==============
*/

void __fastcall Scr_TransientsSP_LoadStartPointTransients(scrContext_t *scrContext)
{
  ?Scr_TransientsSP_LoadStartPointTransients@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
SV_TransientsSP_DumpBusyTransients
==============
*/

void SV_TransientsSP_DumpBusyTransients(void)
{
  ?SV_TransientsSP_DumpBusyTransients@@YAXXZ();
}

/*
==============
Scr_TransientsSP_LoadStartPointTransientSet
==============
*/

void __fastcall Scr_TransientsSP_LoadStartPointTransientSet(scrContext_t *scrContext)
{
  ?Scr_TransientsSP_LoadStartPointTransientSet@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
SV_TransientsSP_SyncForLoadSavegame
==============
*/

void SV_TransientsSP_SyncForLoadSavegame(void)
{
  ?SV_TransientsSP_SyncForLoadSavegame@@YAXXZ();
}

/*
==============
SV_TransientsSP_IsSafeToSave
==============
*/

bool __fastcall SV_TransientsSP_IsSafeToSave()
{
  return ?SV_TransientsSP_IsSafeToSave@@YA_NXZ();
}

/*
==============
SV_TransientsSP_BeginUnloadingInternal
==============
*/
void SV_TransientsSP_BeginUnloadingInternal(const int transientIndex)
{
  __int64 v1; 
  int v3; 

  v1 = transientIndex;
  if ( (unsigned int)transientIndex >= 0x20 )
  {
    v3 = 32;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 96, ASSERT_TYPE_ASSERT, "(unsigned)( transientIndex ) < (unsigned)( MAX_TRANSIENT_SP_FASTFILES )", "transientIndex doesn't index MAX_TRANSIENT_SP_FASTFILES\n\t%i not in [0, %i)", transientIndex, v3) )
      __debugbreak();
  }
  if ( !level.transientLoaded[v1] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 98, ASSERT_TYPE_ASSERT, "(level.transientLoaded[transientIndex])", (const char *)&queryFormat, "level.transientLoaded[transientIndex]") )
    __debugbreak();
  s_svTransients.clientBusyFlags[v1] = 1;
  level.transientLoaded[v1] = 0;
}

/*
==============
SV_TransientsSP_CheckTransientSets
==============
*/
void SV_TransientsSP_CheckTransientSets()
{
  unsigned int v0; 
  unsigned __int64 v1; 
  bool *transientLoaded; 
  bool *v3; 
  int v4; 
  int *v5; 
  unsigned int v6; 
  unsigned int usedTransientSetCount; 
  __int64 i; 
  int v9; 
  int *v10; 
  const TransientSets *SPTransientSets; 
  __int64 v12; 
  __int64 v13; 
  const TransientSets *j; 
  int v15; 
  int *k; 
  int v17; 
  __int64 m; 
  _BYTE *integer64; 
  unsigned int n; 
  const char *SPTransientName; 
  __int64 ii; 
  unsigned int v23; 
  unsigned __int64 v24; 
  __int64 v25; 
  const char *v26; 
  unsigned int v27; 

  v0 = 0;
  v27 = 0;
  v1 = 0i64;
  transientLoaded = level.transientLoaded;
  v3 = level.transientLoaded;
  do
  {
    if ( *v3 )
      *(&v27 + (v1 >> 5)) |= 0x80000000 >> (v0 & 0x1F);
    else
      *(&v27 + (v1 >> 5)) &= ~(0x80000000 >> (v0 & 0x1F));
    ++v0;
    ++v1;
    ++v3;
  }
  while ( v0 < 0x20 );
  v4 = 0;
  v5 = (int *)&v27;
  while ( 1 )
  {
    v6 = v27;
    if ( *v5 )
      break;
    ++v4;
    ++v5;
    if ( v4 )
      goto LABEL_21;
  }
  usedTransientSetCount = s_svTransients.usedTransientSetCount;
  for ( i = 0i64; (unsigned int)i < s_svTransients.usedTransientSetCount; i = (unsigned int)(i + 1) )
  {
    v9 = 0;
    v10 = (int *)&v27;
    while ( *(int *)((char *)v10 + (char *)&s_svTransients.usedTransientSets[i] - (char *)&v27) == *v10 )
    {
      ++v9;
      ++v10;
      if ( v9 )
        goto LABEL_21;
    }
  }
  if ( s_svTransients.usedTransientSetCount >= 0x40 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 283, ASSERT_TYPE_ASSERT, "(unsigned)( s_svTransients.usedTransientSetCount ) < (unsigned)( ( sizeof( *array_counter( s_svTransients.usedTransientSets ) ) + 0 ) )", "s_svTransients.usedTransientSetCount doesn't index ARRAY_COUNT( s_svTransients.usedTransientSets )\n\t%i not in [0, %i)", s_svTransients.usedTransientSetCount, 64) )
      __debugbreak();
    usedTransientSetCount = s_svTransients.usedTransientSetCount;
  }
  s_svTransients.usedTransientSets[usedTransientSetCount].array[0] = v6;
  ++s_svTransients.usedTransientSetCount;
LABEL_21:
  if ( DB_Transients_UsingSPTransientSets() )
  {
    SPTransientSets = DB_Transients_GetSPTransientSets();
    v13 = 0i64;
    for ( j = SPTransientSets; (unsigned int)v13 < SPTransientSets->count; v13 = (unsigned int)(v13 + 1) )
    {
      v15 = 0;
      v12 = (char *)&SPTransientSets->masks[v13] - (char *)&v27;
      for ( k = (int *)&v27; *(int *)((char *)k + v12) == *k; ++k )
      {
        if ( ++v15 )
          return;
      }
    }
    v17 = 0;
    for ( m = 0i64; s_svTransients.lastTransientSetWarning.array[m] == *(unsigned int *)((char *)&v27 + m * 4); ++m )
    {
      if ( ++v17 )
        return;
    }
    s_svTransients.lastTransientSetWarning.array[0] = v6;
    integer64 = (_BYTE *)createfx->current.integer64;
    if ( integer64 && *integer64 )
    {
      Com_Printf(15, "In createfx mode, so allowing us to have an invalid transient set.\n", v12, v13);
    }
    else
    {
      Com_Printf(15, "\nLoaded transients (server):\n", v12, v13);
      for ( n = 0; n < 0x20; ++n )
      {
        if ( *transientLoaded )
        {
          SPTransientName = DB_Transients_GetSPTransientName(n);
          Com_Printf(15, "- %s\n", SPTransientName);
        }
        ++transientLoaded;
      }
      Com_Printf(15, "\nPossible sets:\n");
      for ( ii = 0i64; (unsigned int)ii < j->count; ii = (unsigned int)(ii + 1) )
      {
        Com_Printf(15, "- %-16s", j->names[ii]);
        v23 = 0;
        v24 = 0i64;
        v25 = (__int64)&j->masks[ii];
        do
        {
          if ( ((0x80000000 >> (v23 & 0x1F)) & *(_DWORD *)(v25 + 4 * (v24 >> 5))) != 0 )
          {
            v26 = DB_Transients_GetSPTransientName(v23);
            Com_Printf(15, ",%s", v26);
          }
          ++v23;
          ++v24;
        }
        while ( v23 < 0x20 );
        Com_Printf(15, "\n");
      }
      Com_Error_impl(ERR_SCRIPT, (const ObfuscateErrorText)&stru_1444D9420);
    }
  }
}

/*
==============
SV_TransientsSP_DumpBusyTransients
==============
*/
void SV_TransientsSP_DumpBusyTransients(void)
{
  unsigned int v0; 
  bool *clientBusyFlags; 
  const char *SPTransientName; 

  v0 = 0;
  clientBusyFlags = s_svTransients.clientBusyFlags;
  do
  {
    if ( *clientBusyFlags )
    {
      SPTransientName = DB_Transients_GetSPTransientName(v0);
      Com_Printf(15, "Busy transient: %s\n", SPTransientName);
    }
    ++v0;
    ++clientBusyFlags;
  }
  while ( v0 < 0x20 );
}

/*
==============
SV_TransientsSP_DumpTransientSets_f
==============
*/
void SV_TransientsSP_DumpTransientSets_f(void)
{
  __int64 i; 
  unsigned int v1; 
  unsigned __int64 v2; 
  const char *SPTransientName; 

  Com_Printf(15, "\n");
  for ( i = 0i64; (unsigned int)i < s_svTransients.usedTransientSetCount; i = (unsigned int)(i + 1) )
  {
    Com_Printf(15, "set%i", (unsigned int)i);
    v1 = 0;
    v2 = 0i64;
    do
    {
      if ( ((0x80000000 >> (v1 & 0x1F)) & s_svTransients.usedTransientSets[i + (v2 >> 5)].array[0]) != 0 )
      {
        SPTransientName = DB_Transients_GetSPTransientName(v1);
        Com_Printf(15, ",%s", SPTransientName);
      }
      ++v1;
      ++v2;
    }
    while ( v1 < 0x20 );
    Com_Printf(15, "\n");
  }
  Com_Printf(15, "\n");
}

/*
==============
SV_TransientsSP_ErrorCleanup
==============
*/
void SV_TransientsSP_ErrorCleanup(void)
{
  unsigned int v0; 
  bool *transientLoaded; 

  if ( s_svTransients.inited )
  {
    if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 505, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
      __debugbreak();
    if ( s_svTransients.inited )
    {
      CL_TransientsSP_CancelAllLoads();
      CL_TransientsSP_HardSyncNow();
      SV_MainSP_DemoPlaybackForwardFrame();
      if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 140, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
        __debugbreak();
      CL_TransientsSP_QueueUnloadAll();
      v0 = 0;
      transientLoaded = level.transientLoaded;
      do
      {
        if ( *transientLoaded )
          SV_TransientsSP_BeginUnloadingInternal(v0);
        ++v0;
        ++transientLoaded;
      }
      while ( v0 < 0x20 );
      SV_TransientsSP_ResetState();
      CL_TransientsSP_GameSystemsShutdown();
    }
  }
}

/*
==============
SV_TransientsSP_HardSyncInternal
==============
*/
__int64 SV_TransientsSP_HardSyncInternal()
{
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 362, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  SV_TransientsSP_CheckTransientSets();
  CL_TransientsSP_HardSyncNow();
  return SV_TransientsSP_UpdateStateFromClient();
}

/*
==============
SV_TransientsSP_Init
==============
*/
void SV_TransientsSP_Init(void)
{
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 440, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  if ( s_svTransients.inited && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 441, ASSERT_TYPE_ASSERT, "(!s_svTransients.inited)", (const char *)&queryFormat, "!s_svTransients.inited") )
    __debugbreak();
  SV_TransientsSP_ResetState();
  s_svTransients.inited = 1;
}

/*
==============
SV_TransientsSP_InitLevel
==============
*/
void SV_TransientsSP_InitLevel(void)
{
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 450, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  if ( !s_svTransients.inited && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 451, ASSERT_TYPE_ASSERT, "(s_svTransients.inited)", (const char *)&queryFormat, "s_svTransients.inited") )
    __debugbreak();
  SV_TransientsSP_ResetLevelState();
}

/*
==============
SV_TransientsSP_IsSafeToSave
==============
*/
char SV_TransientsSP_IsSafeToSave()
{
  int v0; 
  bool *i; 

  v0 = 0;
  for ( i = s_svTransients.clientBusyFlags; !*i; ++i )
  {
    if ( (unsigned int)++v0 >= 0x20 )
      return 1;
  }
  return 0;
}

/*
==============
SV_TransientsSP_LoadInternal
==============
*/
void SV_TransientsSP_LoadInternal(const bool sync, const int transientIndex)
{
  __int64 v2; 
  bool v4; 
  const char *v5; 
  __int64 v6; 
  __int64 v7; 

  v2 = transientIndex;
  v4 = SV_MainSP_DemoPlaybackForwardFrame() != 0;
  if ( (unsigned int)v2 >= 0x20 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 239, ASSERT_TYPE_ASSERT, "(unsigned)( transientIndex ) < (unsigned)( MAX_TRANSIENT_SP_FASTFILES )", "transientIndex doesn't index MAX_TRANSIENT_SP_FASTFILES\n\t%i not in [0, %i)", v2, 32) )
    __debugbreak();
  if ( sync || v4 )
  {
    if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 243, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
      __debugbreak();
    CL_TransientsSP_QueueLoad(v2);
  }
  else
  {
    v5 = j_va("transient load %d", (unsigned int)v2);
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v5);
  }
  if ( (unsigned int)v2 >= 0x20 )
  {
    LODWORD(v7) = 32;
    LODWORD(v6) = v2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 82, ASSERT_TYPE_ASSERT, "(unsigned)( transientIndex ) < (unsigned)( MAX_TRANSIENT_SP_FASTFILES )", "transientIndex doesn't index MAX_TRANSIENT_SP_FASTFILES\n\t%i not in [0, %i)", v6, v7) )
      __debugbreak();
  }
  if ( level.transientLoaded[v2] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 84, ASSERT_TYPE_ASSERT, "(!level.transientLoaded[transientIndex])", (const char *)&queryFormat, "!level.transientLoaded[transientIndex]") )
    __debugbreak();
  s_svTransients.clientBusyFlags[v2] = 1;
  s_svTransients.isDevLoad[v2] = 0;
  level.transientLoaded[v2] = 1;
}

/*
==============
SV_TransientsSP_LoadTransientDependencies
==============
*/
void SV_TransientsSP_LoadTransientDependencies(void)
{
  CL_TransientsSP_PushIgnoreLevelTransientUnloads();
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 362, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  SV_TransientsSP_CheckTransientSets();
  CL_TransientsSP_HardSyncNow();
  SV_TransientsSP_UpdateStateFromClient();
  CL_TransientsSP_GameSystemsInit();
  CL_TransientsSP_PopIgnoreLevelTransientUnloads();
}

/*
==============
SV_TransientsSP_LoadWeaponTransient_f
==============
*/
void SV_TransientsSP_LoadWeaponTransient_f(void)
{
  const char *v0; 
  const char *v1; 
  unsigned int SPTransientIndex; 
  __int64 v3; 
  unsigned int v4; 

  v0 = SV_Cmd_Argv(1);
  v1 = v0;
  if ( v0 )
  {
    if ( DB_Zones_IsTransientZoneName(v0) )
    {
      SPTransientIndex = DB_Transients_GetSPTransientIndex(v1);
      v3 = (int)SPTransientIndex;
      if ( SPTransientIndex < 0x20 )
      {
        if ( (DB_Transients_GetSPTransientZoneFlags(SPTransientIndex) & 0x1000) != 0 )
        {
          v4 = DB_Transients_GetSPTransientIndex(v1);
          if ( v4 < 0x20 && level.transientLoaded[v4] )
          {
            Com_PrintError(1, "Weapon transient '%s' already loaded", v1);
          }
          else
          {
            if ( DB_Transients_VerbosePrint() )
              Com_Printf(15, "TRANSIENT_SV: Dev-load of transient '%s'.\n", v1);
            SV_TransientsSP_LoadInternal(1, v3);
            s_svTransients.isDevLoad[v3] = 1;
            SV_TransientsSP_HardSyncInternal();
            CL_TransientsSP_GameSystemsInit();
          }
        }
        else
        {
          Com_PrintError(1, "Weapon transient '%s' is not a weapon transient", v1);
        }
      }
      else
      {
        Com_PrintError(1, "Unknown weapon transient '%s'", v1);
      }
    }
    else
    {
      Com_PrintError(1, "Bad weapon transient name '%s'. Make sure you are using the name of the transient fastfile.", v1);
    }
  }
  else
  {
    Com_PrintError(1, "No weapon transient specified");
  }
}

/*
==============
SV_TransientsSP_Print
==============
*/
void SV_TransientsSP_Print()
{
  unsigned int v0; 
  __int64 v1; 
  const char *v2; 
  const char *SPTransientName; 

  Com_Printf(15, "Server: Currently loaded fastfiles:\n");
  v0 = 0;
  v1 = 0i64;
  do
  {
    if ( level.transientLoaded[v1] )
    {
      v2 = "Loaded";
      if ( s_svTransients.clientBusyFlags[v1] )
        v2 = "Loading";
      SPTransientName = DB_Transients_GetSPTransientName(v0);
      Com_Printf(15, "[%d] %s (%s)\n", v0, SPTransientName, v2);
    }
    ++v0;
    ++v1;
  }
  while ( v0 < 0x20 );
}

/*
==============
SV_TransientsSP_Process
==============
*/
void SV_TransientsSP_Process(void)
{
  TransientDemoSyncType TransientState; 
  TransientDemoSyncType v1; 
  TransientDemoSyncType SyncResult; 
  TransientDemoSyncType v3; 
  TransientDemoSyncType v4; 

  if ( level.loading && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 679, ASSERT_TYPE_ASSERT, "(level.loading == LOADING_DONE)", (const char *)&queryFormat, "level.loading == LOADING_DONE") )
    __debugbreak();
  SV_TransientsSP_CheckTransientSets();
  if ( !SV_IsDemoPlaying() )
  {
    CL_TransientsSP_DemoSetSync(NONE);
    if ( !CL_TransientsSP_TrySyncClient() || (Sys_ProcessWorkerCmdsWithTimeout(CL_TransientsSP_SyncingIsIdle, NULL), (SyncResult = CL_TransientsSP_DemoGetSyncResult()) == NONE) )
    {
      SV_DemoSP_RecordTransientState(0);
      return;
    }
    goto LABEL_20;
  }
  TransientState = SV_DemoSP_GetTransientState();
  CL_TransientsSP_DemoSetSync(TransientState);
  if ( TransientState )
  {
    if ( DB_Transients_VerbosePrint() )
      Com_Printf(15, "TRANSIENT_SV: ProcessTransients() Sync Request %d\n", (unsigned int)TransientState);
    CL_TransientsSP_DemoPlaybackSyncBegin();
    if ( SV_MainSP_DemoPlaybackForwardFrame() )
    {
      CL_TransientsSP_ForceSyncClient();
      CL_TransientsSP_Process();
    }
    else
    {
      while ( !CL_TransientsSP_TrySyncClient() )
      {
        Sys_CheckQuitRequest();
        Sys_Sleep(0);
      }
      Sys_ProcessWorkerCmdsWithTimeout(CL_TransientsSP_SyncingIsIdle, NULL);
    }
    CL_TransientsSP_DemoPlaybackSyncEnd();
    v1 = CL_TransientsSP_DemoGetSyncResult();
    SyncResult = v1;
    if ( TransientState != v1 )
    {
      v4 = v1;
      v3 = TransientState;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 722, ASSERT_TYPE_ASSERT, "( syncRequest ) == ( syncResult )", "%s == %s\n\t%i, %i", "syncRequest", "syncResult", v3, v4) )
        __debugbreak();
    }
    if ( SyncResult )
    {
LABEL_20:
      if ( DB_Transients_VerbosePrint() )
        Com_Printf(15, "TRANSIENT_SV: ProcessTransients() Sync Result %d\n", (unsigned int)SyncResult);
      SV_TransientsSP_UpdateStateFromClient();
    }
  }
}

/*
==============
SV_TransientsSP_ResetLevelState
==============
*/
void SV_TransientsSP_ResetLevelState()
{
  unsigned int v0; 
  unsigned int v1; 
  __int64 v2; 
  bool *transientVisibility; 

  v0 = 0;
  v1 = 0;
  v2 = 0i64;
  do
  {
    if ( s_svTransients.clientBusyFlags[v2] && (DB_Transients_GetSPTransientZoneFlags(v1) & 0x4000) != 0 )
    {
      if ( level.transientLoaded[v2] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 412, ASSERT_TYPE_ASSERT, "(!level.transientLoaded[i])", (const char *)&queryFormat, "!level.transientLoaded[i]") )
        __debugbreak();
      s_svTransients.clientBusyFlags[v2] = 0;
    }
    s_svTransients.isDependency[v2] = 0;
    ++v1;
    ++v2;
  }
  while ( v1 < 0x20 );
  transientVisibility = level.transientVisibility;
  do
  {
    *transientVisibility = 1;
    CL_TransientsWorld_SetVisibility(LOCAL_CLIENT_0, v0++, 1);
    ++transientVisibility;
  }
  while ( v0 < 0x20 );
}

/*
==============
SV_TransientsSP_ResetState
==============
*/
void *SV_TransientsSP_ResetState()
{
  bool *transientLoaded; 
  __int64 v1; 
  unsigned int v2; 
  bool *transientVisibility; 

  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 384, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  transientLoaded = level.transientLoaded;
  v1 = 32i64;
  do
  {
    if ( *transientLoaded && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 390, ASSERT_TYPE_ASSERT, "(!level.transientLoaded[i])", (const char *)&queryFormat, "!level.transientLoaded[i]") )
      __debugbreak();
    ++transientLoaded;
    --v1;
  }
  while ( v1 );
  v2 = 0;
  transientVisibility = level.transientVisibility;
  do
  {
    *transientVisibility = 1;
    CL_TransientsWorld_SetVisibility(LOCAL_CLIENT_0, v2++, 1);
    ++transientVisibility;
  }
  while ( v2 < 0x20 );
  return memset_0(&s_svTransients, 0, sizeof(s_svTransients));
}

/*
==============
SV_TransientsSP_SetSavegameTransientState
==============
*/
void SV_TransientsSP_SetSavegameTransientState(const bitarray<32> *state)
{
  unsigned int v1; 
  bool *v2; 
  unsigned __int64 v3; 
  bool v4; 

  v1 = 0;
  v2 = s_svTransientSavegameState;
  v3 = 0i64;
  do
  {
    v4 = ((0x80000000 >> (v1++ & 0x1F)) & state[v3 >> 5].array[0]) != 0;
    *v2 = v4;
    ++v3;
    ++v2;
  }
  while ( v1 < 0x20 );
}

/*
==============
SV_TransientsSP_ShutdownAll
==============
*/
void SV_TransientsSP_ShutdownAll(void)
{
  unsigned int v0; 
  bool *transientLoaded; 

  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 505, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  if ( s_svTransients.inited )
  {
    CL_TransientsSP_CancelAllLoads();
    CL_TransientsSP_HardSyncNow();
    SV_MainSP_DemoPlaybackForwardFrame();
    if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 140, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
      __debugbreak();
    CL_TransientsSP_QueueUnloadAll();
    v0 = 0;
    transientLoaded = level.transientLoaded;
    do
    {
      if ( *transientLoaded )
        SV_TransientsSP_BeginUnloadingInternal(v0);
      ++v0;
      ++transientLoaded;
    }
    while ( v0 < 0x20 );
    SV_TransientsSP_ResetState();
    CL_TransientsSP_GameSystemsShutdown();
  }
}

/*
==============
SV_TransientsSP_ShutdownLevel
==============
*/
void SV_TransientsSP_ShutdownLevel(void)
{
  unsigned int v0; 
  bool *transientLoaded; 

  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 471, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  if ( s_svTransients.inited )
  {
    CL_TransientsSP_CancelAllLoads();
    CL_TransientsSP_HardSyncNow();
    SV_MainSP_DemoPlaybackForwardFrame();
    if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 168, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
      __debugbreak();
    CL_TransientsSP_QueueUnloadLevel();
    v0 = 0;
    transientLoaded = level.transientLoaded;
    do
    {
      if ( *transientLoaded && (DB_Transients_GetSPTransientZoneFlags(v0) & 0x4000) != 0 )
        SV_TransientsSP_BeginUnloadingInternal(v0);
      ++v0;
      ++transientLoaded;
    }
    while ( v0 < 0x20 );
    SV_TransientsSP_ResetLevelState();
    CL_TransientsSP_GameSystemsShutdown();
    s_svTransients.usedTransientSetCount = 0;
  }
}

/*
==============
SV_TransientsSP_SwitchTransientSet
==============
*/
void SV_TransientsSP_SwitchTransientSet(const char *const setName, const bool sync)
{
  bool v2; 
  unsigned int v4; 
  unsigned int v5; 
  const TransientSets *SPTransientSets; 
  __int64 v7; 
  const char *v8; 
  const char *v9; 
  signed __int64 v10; 
  int v11; 
  __int64 v12; 
  int v13; 
  int v14; 
  int v15; 
  __int64 v16; 
  bool *transientLoaded; 
  unsigned __int64 v18; 
  __int64 v19; 
  unsigned int v20; 
  const char *SPTransientName; 
  const char *v22; 

  v2 = sync;
  if ( !setName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 933, ASSERT_TYPE_ASSERT, "(setName)", (const char *)&queryFormat, "setName") )
    __debugbreak();
  if ( DB_Transients_UsingSPTransientSets() )
  {
    v4 = 0;
    v5 = 0;
    SPTransientSets = DB_Transients_GetSPTransientSets();
    if ( !SPTransientSets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 949, ASSERT_TYPE_ASSERT, "(sets)", (const char *)&queryFormat, "sets") )
      __debugbreak();
    if ( SPTransientSets->count )
    {
LABEL_10:
      v7 = 0x7FFFFFFFi64;
      v8 = setName;
      v9 = SPTransientSets->names[v5];
      if ( !v9 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
        __debugbreak();
      if ( !setName && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 213, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
        __debugbreak();
      v10 = v9 - setName;
      do
      {
        v11 = (unsigned __int8)v8[v10];
        v12 = v7;
        v13 = *(unsigned __int8 *)v8++;
        --v7;
        if ( !v12 )
          break;
        if ( v11 != v13 )
        {
          v14 = v11 + 32;
          if ( (unsigned int)(v11 - 65) > 0x19 )
            v14 = v11;
          v11 = v14;
          v15 = v13 + 32;
          if ( (unsigned int)(v13 - 65) > 0x19 )
            v15 = v13;
          if ( v11 != v15 )
          {
            if ( ++v5 < SPTransientSets->count )
              goto LABEL_10;
            break;
          }
        }
      }
      while ( v11 );
      v2 = sync;
      v4 = 0;
    }
    if ( v5 < SPTransientSets->count )
    {
      v16 = v5;
      transientLoaded = level.transientLoaded;
      v18 = 0i64;
      v19 = v16;
      do
      {
        v20 = SPTransientSets->masks[v19 + (v18 >> 5)].array[0] & (0x80000000 >> (v4 & 0x1F));
        if ( *transientLoaded )
        {
          if ( !v20 )
          {
            if ( DB_Transients_VerbosePrint() )
            {
              SPTransientName = DB_Transients_GetSPTransientName(v4);
              Com_Printf(15, "TRANSIENT_SV: Queueing transient unload of '%s'.\n", SPTransientName);
            }
            SV_TransientsSP_UnloadInternal(v2, v4);
          }
        }
        else if ( v20 )
        {
          if ( DB_Transients_VerbosePrint() )
          {
            v22 = DB_Transients_GetSPTransientName(v4);
            Com_Printf(15, "TRANSIENT_SV: Queueing transient load of '%s'.\n", v22);
          }
          SV_TransientsSP_LoadInternal(v2, v4);
        }
        ++v4;
        ++v18;
        ++transientLoaded;
      }
      while ( v4 < 0x20 );
    }
    else
    {
      Com_PrintError(24, "Could not find a transient set named '%s'.\n", setName);
    }
  }
  else
  {
    Com_PrintError(24, "This level is not setup to use transient sets.\n");
  }
}

/*
==============
SV_TransientsSP_SyncForDemoSave
==============
*/
void SV_TransientsSP_SyncForDemoSave(void)
{
  int v0; 
  bool *i; 

  if ( Sys_IsMainThread() )
  {
    v0 = 0;
    for ( i = s_svTransients.clientBusyFlags; !*i; ++i )
    {
      if ( (unsigned int)++v0 >= 0x20 )
        return;
    }
    Com_PrintWarning(15, "WARNING: Had to sync transients to safely save serverdemo replay.\n");
    CL_TransientsSP_PushImmediateProcessTransients();
    SV_TransientsSP_HardSyncInternal();
    CL_TransientsSP_PopImmediateProcessTransients();
  }
}

/*
==============
SV_TransientsSP_SyncForLoadLevel
==============
*/
void SV_TransientsSP_SyncForLoadLevel(void)
{
  int v0; 
  bool *i; 

  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 780, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  v0 = 0;
  for ( i = s_svTransients.clientBusyFlags; !*i; ++i )
  {
    if ( (unsigned int)++v0 >= 0x20 )
      return;
  }
  CL_TransientsSP_PushImmediateProcessTransients();
  SV_TransientsSP_HardSyncInternal();
  CL_TransientsSP_PopImmediateProcessTransients();
}

/*
==============
SV_TransientsSP_SyncForLoadSavegame
==============
*/
void SV_TransientsSP_SyncForLoadSavegame(void)
{
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 793, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  if ( !level.initializing && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 794, ASSERT_TYPE_ASSERT, "(level.initializing)", (const char *)&queryFormat, "level.initializing") )
    __debugbreak();
  CL_TransientsSP_PushImmediateProcessTransients();
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 362, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  SV_TransientsSP_CheckTransientSets();
  CL_TransientsSP_HardSyncNow();
  SV_TransientsSP_UpdateStateFromClient();
  CL_TransientsSP_PopImmediateProcessTransients();
  CL_TransientsSP_GameSystemsInit();
}

/*
==============
SV_TransientsSP_SyncForSpawnServer
==============
*/
void SV_TransientsSP_SyncForSpawnServer(void)
{
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 820, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  Stream_PushSyncDisable();
  CL_StreamViews_Init();
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 362, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  SV_TransientsSP_CheckTransientSets();
  CL_TransientsSP_HardSyncNow();
  SV_TransientsSP_UpdateStateFromClient();
  Stream_PopSyncDisable();
}

/*
==============
SV_TransientsSP_UnloadAllInternal
==============
*/
void SV_TransientsSP_UnloadAllInternal(const bool sync)
{
  bool v2; 
  const char *v3; 
  unsigned int v4; 
  bool *transientLoaded; 

  v2 = SV_MainSP_DemoPlaybackForwardFrame() != 0;
  if ( sync || v2 )
  {
    if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 140, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
      __debugbreak();
    CL_TransientsSP_QueueUnloadAll();
  }
  else
  {
    v3 = j_va("transient unloadall");
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v3);
  }
  v4 = 0;
  transientLoaded = level.transientLoaded;
  do
  {
    if ( *transientLoaded )
      SV_TransientsSP_BeginUnloadingInternal(v4);
    ++v4;
    ++transientLoaded;
  }
  while ( v4 < 0x20 );
}

/*
==============
SV_TransientsSP_UnloadInternal
==============
*/
void SV_TransientsSP_UnloadInternal(const bool sync, const int transientIndex)
{
  bool v4; 
  const char *v5; 

  v4 = SV_MainSP_DemoPlaybackForwardFrame() != 0;
  if ( (unsigned int)transientIndex >= 0x20 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 200, ASSERT_TYPE_ASSERT, "(unsigned)( transientIndex ) < (unsigned)( MAX_TRANSIENT_SP_FASTFILES )", "transientIndex doesn't index MAX_TRANSIENT_SP_FASTFILES\n\t%i not in [0, %i)", transientIndex, 32) )
    __debugbreak();
  if ( sync || v4 )
  {
    if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 204, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
      __debugbreak();
    if ( DB_Transients_VerbosePrint() )
      Com_Printf(0, "SV_TransientsSP_UnloadInternal: %d (CL_TransientsSP_QueueUnload)\n", (unsigned int)transientIndex);
    CL_TransientsSP_QueueUnload(transientIndex);
  }
  else
  {
    if ( DB_Transients_VerbosePrint() )
      Com_Printf(0, "SV_TransientsSP_UnloadInternal: %d (SendServerCommand)\n", (unsigned int)transientIndex);
    v5 = j_va("transient unload %d", (unsigned int)transientIndex);
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v5);
  }
  SV_TransientsSP_BeginUnloadingInternal(transientIndex);
}

/*
==============
SV_TransientsSP_UnloadWeaponTransient_f
==============
*/
void SV_TransientsSP_UnloadWeaponTransient_f(void)
{
  const char *v0; 
  const char *v1; 
  unsigned int SPTransientIndex; 
  __int64 v3; 

  v0 = SV_Cmd_Argv(1);
  v1 = v0;
  if ( v0 )
  {
    if ( DB_Zones_IsTransientZoneName(v0) )
    {
      SPTransientIndex = DB_Transients_GetSPTransientIndex(v1);
      v3 = (int)SPTransientIndex;
      if ( SPTransientIndex >= 0x20 )
      {
        Com_PrintError(1, "Unknown weapon transient '%s'", v1);
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 2145, ASSERT_TYPE_ASSERT, "(unsigned)( transientSlot ) < (unsigned)( MAX_TRANSIENT_SP_FASTFILES )", "transientSlot doesn't index MAX_TRANSIENT_SP_FASTFILES\n\t%i not in [0, %i)", v3, 32) )
          __debugbreak();
      }
      if ( s_svTransients.isDevLoad[v3] )
      {
        if ( level.transientLoaded[v3] )
        {
          if ( s_svTransients.isDependency[v3] )
          {
            Com_PrintError(24, "Weapon transient '%s' cannot be unloaded because level assets depend on it.\n", v1);
          }
          else
          {
            if ( DB_Transients_VerbosePrint() )
              Com_Printf(15, "TRANSIENT_SV: Queuing transient unload of '%s'.\n", v1);
            SV_TransientsSP_UnloadInternal(0, v3);
          }
        }
        else
        {
          SV_TransientsSP_Print();
          Com_PrintError(1, "Weapon transient '%s' is already unloaded, or unloading.\n", v1);
        }
      }
      else
      {
        Com_PrintError(1, "Weapon transient '%s' was loaded by script and cannot be unloaded by console command.\n", v1);
      }
    }
    else
    {
      Com_PrintError(1, "Bad weapon transient name '%s'. Make sure you are using the name of the transient fastfile.", v1);
    }
  }
  else
  {
    Com_PrintError(1, "No weapon transient specified");
  }
}

/*
==============
SV_TransientsSP_UpdateStateFromClient
==============
*/
char SV_TransientsSP_UpdateStateFromClient()
{
  unsigned int v0; 
  __int64 v1; 
  bool v2; 
  TransientSPZoneState ZoneModeByIndex; 
  __int64 v5; 
  __int64 v6; 

  v0 = 0;
  v1 = 0i64;
  do
  {
    v2 = s_svTransients.clientBusyFlags[v1];
    ZoneModeByIndex = CL_TransientsSP_GetZoneModeByIndex(v0);
    if ( v2 )
    {
      if ( ZoneModeByIndex )
      {
        if ( ZoneModeByIndex == 4 && level.transientLoaded[v1] )
        {
          if ( !s_svTransients.clientBusyFlags[v1] )
          {
            LOBYTE(ZoneModeByIndex) = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 110, ASSERT_TYPE_ASSERT, "(s_svTransients.clientBusyFlags[transientIndex])", (const char *)&queryFormat, "s_svTransients.clientBusyFlags[transientIndex]");
            if ( (_BYTE)ZoneModeByIndex )
              __debugbreak();
          }
          s_svTransients.clientBusyFlags[v1] = 0;
        }
      }
      else if ( !level.transientLoaded[v1] )
      {
        if ( !s_svTransients.clientBusyFlags[v1] )
        {
          LOBYTE(ZoneModeByIndex) = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 121, ASSERT_TYPE_ASSERT, "(s_svTransients.clientBusyFlags[transientIndex])", (const char *)&queryFormat, "s_svTransients.clientBusyFlags[transientIndex]");
          if ( (_BYTE)ZoneModeByIndex )
            __debugbreak();
        }
        s_svTransients.clientBusyFlags[v1] = 0;
        s_svTransients.isDevLoad[v1] = 0;
      }
    }
    else if ( (ZoneModeByIndex & 0xFFFFFFFB) != 0 )
    {
      LODWORD(v6) = v0;
      LODWORD(v5) = ZoneModeByIndex;
      LOBYTE(ZoneModeByIndex) = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 655, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Bad state %d for slot %d", v5, v6);
      if ( (_BYTE)ZoneModeByIndex )
        __debugbreak();
    }
    ++v0;
    ++v1;
  }
  while ( v0 < 0x20 );
  return ZoneModeByIndex;
}

/*
==============
SV_TransientsSP_WaitForTransientInternal
==============
*/
void SV_TransientsSP_WaitForTransientInternal(const int transientIndex, const char *filename)
{
  bool v4; 
  const char *v5; 

  v4 = SV_MainSP_DemoPlaybackForwardFrame() != 0;
  if ( DB_Transients_VerbosePrint() )
  {
    if ( transientIndex == -1 )
      Com_Printf(15, "TRANSIENT_SV: Script requested pausing the game until all transients are loaded.\n");
    else
      Com_Printf(15, "TRANSIENT_SV: Script requested pausing the game until transient '%s' is loaded.\n", filename);
  }
  if ( v4 )
  {
    if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 1073, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
      __debugbreak();
    CL_TransientsSP_PauseGameWaitFor(transientIndex);
  }
  else
  {
    v5 = j_va("transient pausegame %d", (unsigned int)transientIndex);
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v5);
  }
}

/*
==============
Scr_TransientsSP_ClearStartPointTransients
==============
*/
void Scr_TransientsSP_ClearStartPointTransients(scrContext_t *scrContext)
{
  unsigned int v2; 
  bool *transientLoaded; 

  if ( !Sys_IsMainThread() || !level.initializing )
    Scr_Error(COM_ERR_1609, scrContext, "ClearStartPointTransients should only be called on a MapRestart. Talk to a coder before adding anything to call this.");
  if ( Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_1610, scrContext, "Incorrect ClearStartPointTransients() call.");
  SV_MainSP_DemoPlaybackForwardFrame();
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 140, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  CL_TransientsSP_QueueUnloadAll();
  v2 = 0;
  transientLoaded = level.transientLoaded;
  do
  {
    if ( *transientLoaded )
      SV_TransientsSP_BeginUnloadingInternal(v2);
    ++v2;
    ++transientLoaded;
  }
  while ( v2 < 0x20 );
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 362, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  SV_TransientsSP_CheckTransientSets();
  CL_TransientsSP_HardSyncNow();
  SV_TransientsSP_UpdateStateFromClient();
  CL_TransientsSP_GameSystemsInit();
  if ( (DB_Zones_GetInUseFlags() & 0x600000) != 0 )
  {
    SV_PreloadSP_DumpDBPreloadZoneNames();
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1444D9920);
  }
  Scr_AddBool(scrContext, 1);
}

/*
==============
Scr_TransientsSP_GetAllSPLevelTransients
==============
*/
void Scr_TransientsSP_GetAllSPLevelTransients(scrContext_t *scrContext)
{
  unsigned int i; 
  const char *SPTransientName; 

  if ( Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_1620, scrContext, "Incorrect number of parameters\n");
  Scr_MakeArray(scrContext);
  for ( i = 0; i < 0x20; ++i )
  {
    SPTransientName = DB_Transients_GetSPTransientName(i);
    if ( SPTransientName )
    {
      Scr_AddString(scrContext, SPTransientName);
      Scr_AddArray(scrContext);
    }
  }
}

/*
==============
Scr_TransientsSP_GetLoadedSPLevelTransients
==============
*/
void Scr_TransientsSP_GetLoadedSPLevelTransients(scrContext_t *scrContext)
{
  unsigned int v2; 
  __int64 v3; 
  const char *SPTransientName; 

  if ( Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_1619, scrContext, "Incorrect number of parameters\n");
  Scr_MakeArray(scrContext);
  v2 = 0;
  v3 = 0i64;
  do
  {
    if ( level.transientLoaded[v3] && !s_svTransients.clientBusyFlags[v3] )
    {
      SPTransientName = DB_Transients_GetSPTransientName(v2);
      Scr_AddString(scrContext, SPTransientName);
      Scr_AddArray(scrContext);
    }
    ++v2;
    ++v3;
  }
  while ( v2 < 0x20 );
}

/*
==============
Scr_TransientsSP_GetQueuedSPLevelTransients
==============
*/
void Scr_TransientsSP_GetQueuedSPLevelTransients(scrContext_t *scrContext)
{
  unsigned int v2; 
  bool *transientLoaded; 
  const char *SPTransientName; 

  if ( Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_1618, scrContext, "Incorrect number of parameters\n");
  Scr_MakeArray(scrContext);
  v2 = 0;
  transientLoaded = level.transientLoaded;
  do
  {
    if ( *transientLoaded )
    {
      SPTransientName = DB_Transients_GetSPTransientName(v2);
      Scr_AddString(scrContext, SPTransientName);
      Scr_AddArray(scrContext);
    }
    ++v2;
    ++transientLoaded;
  }
  while ( v2 < 0x20 );
}

/*
==============
Scr_TransientsSP_GetSavegameTransients
==============
*/
void Scr_TransientsSP_GetSavegameTransients(scrContext_t *scrContext)
{
  unsigned int v2; 
  bool *v3; 
  const char *String; 

  if ( !Sys_IsMainThread() || !level.initializing )
    Scr_Error(COM_ERR_1613, scrContext, "GetSavegameTransients should only be called on a MapRestart. Talk to a coder before adding anything to call this.");
  if ( Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_1614, scrContext, "Incorrect GetSavegameTransients() call.");
  if ( level.loading != LOADING_SAVEGAME && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 1755, ASSERT_TYPE_ASSERT, "(level.loading == LOADING_SAVEGAME)", (const char *)&queryFormat, "level.loading == LOADING_SAVEGAME") )
    __debugbreak();
  Scr_MakeArray(scrContext);
  v2 = 0;
  v3 = s_svTransientSavegameState;
  do
  {
    if ( SV_IsDemoPlaying() )
    {
      String = SV_Demo_GetString();
    }
    else
    {
      if ( *v3 )
        String = DB_Transients_GetSPTransientName(v2);
      else
        String = (char *)&queryFormat.fmt + 3;
      SV_Record_GetString(String);
    }
    if ( *String )
    {
      Scr_AddString(scrContext, String);
      Scr_AddArray(scrContext);
    }
    ++v2;
    ++v3;
  }
  while ( v2 < 0x20 );
}

/*
==============
Scr_TransientsSP_GetTransientSetNames
==============
*/
void Scr_TransientsSP_GetTransientSetNames(scrContext_t *scrContext)
{
  const TransientSets *SPTransientSets; 
  const TransientSets *v3; 
  __int64 v4; 
  const char *v5; 

  if ( Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_1623, scrContext, "Incorrect number of parameters\n");
  Scr_MakeArray(scrContext);
  SPTransientSets = DB_Transients_GetSPTransientSets();
  v3 = SPTransientSets;
  if ( SPTransientSets )
  {
    v4 = 0i64;
    if ( SPTransientSets->count )
    {
      do
      {
        v5 = v3->names[v4];
        if ( !v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 2060, ASSERT_TYPE_ASSERT, "(setName)", (const char *)&queryFormat, "setName") )
          __debugbreak();
        Scr_AddString(scrContext, v5);
        Scr_AddArray(scrContext);
        v4 = (unsigned int)(v4 + 1);
      }
      while ( (unsigned int)v4 < v3->count );
    }
  }
}

/*
==============
Scr_TransientsSP_GetTransientsInSet
==============
*/
void Scr_TransientsSP_GetTransientsInSet(scrContext_t *scrContext)
{
  const char *String; 
  const TransientSets *SPTransientSets; 
  unsigned int v4; 
  unsigned int v5; 
  const char *v6; 
  __int64 v7; 
  signed __int64 v8; 
  int v9; 
  __int64 v10; 
  int v11; 
  int v12; 
  int v13; 
  unsigned __int64 v14; 
  const char *SPTransientName; 
  const char *v16; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_1621, scrContext, "Incorrect number of parameters\n");
  String = Scr_GetString(scrContext, 0);
  if ( !String && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 1993, ASSERT_TYPE_ASSERT, "(trSetName)", (const char *)&queryFormat, "trSetName") )
    __debugbreak();
  SPTransientSets = DB_Transients_GetSPTransientSets();
  if ( !SPTransientSets && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 1997, ASSERT_TYPE_ASSERT, "(sets)", (const char *)&queryFormat, "sets") )
    __debugbreak();
  v4 = 0;
  v5 = 0;
  if ( SPTransientSets->count )
  {
    while ( 2 )
    {
      v6 = SPTransientSets->names[v5];
      if ( !v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 2002, ASSERT_TYPE_ASSERT, "(thisSetName)", (const char *)&queryFormat, "thisSetName") )
        __debugbreak();
      v7 = 0x7FFFFFFFi64;
      if ( !String && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
        __debugbreak();
      if ( !v6 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 213, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
        __debugbreak();
      v8 = String - v6;
      while ( 1 )
      {
        v9 = (unsigned __int8)v6[v8];
        v10 = v7;
        v11 = *(unsigned __int8 *)v6++;
        --v7;
        if ( !v10 )
        {
LABEL_28:
          Scr_MakeArray(scrContext);
          v14 = 0i64;
          do
          {
            if ( ((0x80000000 >> (v4 & 0x1F)) & SPTransientSets->masks[v5 + (v14 >> 5)].array[0]) != 0 )
            {
              SPTransientName = DB_Transients_GetSPTransientName(v4);
              Scr_AddString(scrContext, SPTransientName);
              Scr_AddArray(scrContext);
            }
            ++v4;
            ++v14;
          }
          while ( v4 < 0x20 );
          return;
        }
        if ( v9 != v11 )
        {
          v12 = v9 + 32;
          if ( (unsigned int)(v9 - 65) > 0x19 )
            v12 = v9;
          v9 = v12;
          v13 = v11 + 32;
          if ( (unsigned int)(v11 - 65) > 0x19 )
            v13 = v11;
          if ( v9 != v13 )
            break;
        }
        if ( !v9 )
          goto LABEL_28;
      }
      if ( ++v5 < SPTransientSets->count )
        continue;
      break;
    }
  }
  v16 = j_va("Unknown transient set '%s'\n", String);
  Scr_Error(COM_ERR_1622, scrContext, v16);
}

/*
==============
Scr_TransientsSP_IsLoadingAnyTransients
==============
*/
void Scr_TransientsSP_IsLoadingAnyTransients(scrContext_t *scrContext)
{
  bool *clientBusyFlags; 
  unsigned int v2; 

  clientBusyFlags = s_svTransients.clientBusyFlags;
  v2 = 0;
  while ( !*clientBusyFlags )
  {
    ++v2;
    ++clientBusyFlags;
    if ( v2 >= 0x20 )
    {
      Scr_AddBool(scrContext, 0);
      return;
    }
  }
  Scr_AddBool(scrContext, 1);
}

/*
==============
Scr_TransientsSP_IsLoadingSavegame
==============
*/
void Scr_TransientsSP_IsLoadingSavegame(scrContext_t *scrContext)
{
  if ( !Sys_IsMainThread() || !level.initializing )
    Scr_Error(COM_ERR_1611, scrContext, "GetSavegameTransients should only be called on a MapRestart. Talk to a coder before adding anything to call this.");
  if ( Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_1612, scrContext, "Incorrect GetSavegameTransients() call.");
  Scr_AddBool(scrContext, level.loading == LOADING_SAVEGAME);
}

/*
==============
Scr_TransientsSP_IsSPLevelTransient
==============
*/
void Scr_TransientsSP_IsSPLevelTransient(scrContext_t *scrContext)
{
  const char *String; 
  unsigned int SPTransientIndex; 

  String = Scr_GetString(scrContext, 0);
  if ( !String && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 1855, ASSERT_TYPE_ASSERT, "(filename)", (const char *)&queryFormat, "filename") )
    __debugbreak();
  SPTransientIndex = DB_Transients_GetSPTransientIndex(String);
  Scr_AddBool(scrContext, SPTransientIndex < 0x20);
}

/*
==============
Scr_TransientsSP_IsTransientLoaded
==============
*/
void Scr_TransientsSP_IsTransientLoaded(scrContext_t *scrContext)
{
  const char *String; 
  unsigned int SPTransientIndex; 
  int v4; 
  const char *v5; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_1599, scrContext, "Incorrect istransientqueued() call.");
  String = Scr_GetString(scrContext, 0);
  if ( !String && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 1505, ASSERT_TYPE_ASSERT, "(filename)", (const char *)&queryFormat, "filename") )
    __debugbreak();
  SPTransientIndex = DB_Transients_GetSPTransientIndex(String);
  if ( SPTransientIndex < 0x20 && level.transientLoaded[SPTransientIndex] )
  {
    v4 = !s_svTransients.clientBusyFlags[SPTransientIndex];
  }
  else
  {
    v4 = 0;
    if ( SPTransientIndex >= 0x20 )
    {
      v5 = j_va("Transient zone '%s' does not exist\n", String);
      Scr_Error(COM_ERR_1600, scrContext, v5);
    }
  }
  Scr_AddBool(scrContext, v4);
}

/*
==============
Scr_TransientsSP_IsTransientQueued
==============
*/
void Scr_TransientsSP_IsTransientQueued(scrContext_t *scrContext)
{
  const char *String; 
  unsigned int SPTransientIndex; 
  int v4; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_1598, scrContext, "Incorrect istransientqueued() call.");
  String = Scr_GetString(scrContext, 0);
  if ( !String && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 1473, ASSERT_TYPE_ASSERT, "(filename)", (const char *)&queryFormat, "filename") )
    __debugbreak();
  SPTransientIndex = DB_Transients_GetSPTransientIndex(String);
  v4 = 0;
  if ( SPTransientIndex < 0x20 )
    LOBYTE(v4) = level.transientLoaded[SPTransientIndex];
  Scr_AddBool(scrContext, v4);
}

/*
==============
Scr_TransientsSP_LoadStartPointTransientSet
==============
*/
void Scr_TransientsSP_LoadStartPointTransientSet(scrContext_t *scrContext)
{
  const char *String; 
  unsigned int v3; 
  bool *transientLoaded; 

  if ( !Sys_IsMainThread() || !level.initializing )
    Scr_Error(COM_ERR_1601, scrContext, "LoadStartPointTransientSet should only be called on a MapRestart. Talk to a coder before adding anything to call this.");
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_1602, scrContext, "Incorrect LoadStartPointTransientSet() call.");
  String = Scr_GetString(scrContext, 0);
  if ( !String && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 1571, ASSERT_TYPE_ASSERT, "(setName)", (const char *)&queryFormat, "setName") )
    __debugbreak();
  SV_MainSP_DemoPlaybackForwardFrame();
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 140, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  CL_TransientsSP_QueueUnloadAll();
  v3 = 0;
  transientLoaded = level.transientLoaded;
  do
  {
    if ( *transientLoaded )
      SV_TransientsSP_BeginUnloadingInternal(v3);
    ++v3;
    ++transientLoaded;
  }
  while ( v3 < 0x20 );
  SV_TransientsSP_SwitchTransientSet(String, 1);
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 362, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  SV_TransientsSP_CheckTransientSets();
  CL_TransientsSP_HardSyncNow();
  SV_TransientsSP_UpdateStateFromClient();
  CL_TransientsSP_GameSystemsInit();
  if ( (DB_Zones_GetInUseFlags() & 0x600000) != 0 )
  {
    SV_PreloadSP_DumpDBPreloadZoneNames();
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1444D9920);
  }
  Scr_AddBool(scrContext, 1);
}

/*
==============
Scr_TransientsSP_LoadStartPointTransients
==============
*/
void Scr_TransientsSP_LoadStartPointTransients(scrContext_t *scrContext)
{
  unsigned int ArrayObject; 
  unsigned int ArraySize; 
  unsigned int v4; 
  unsigned int v5; 
  bool *transientLoaded; 
  unsigned int ArrayVariable; 
  scr_string_t *VariableValueAddress; 
  const char *v9; 
  const char *v10; 
  unsigned int SPTransientIndex; 
  __int64 v12; 
  const char *v13; 
  const char *v14; 
  __int64 v15; 
  __int64 v16; 

  if ( !Sys_IsMainThread() || !level.initializing )
    Scr_Error(COM_ERR_1603, scrContext, "LoadStartPointTransients should only be called on a MapRestart. Talk to a coder before adding anything to call this.");
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_1604, scrContext, "Incorrect LoadStartPointTransients() call.");
  ArrayObject = BGScr_Main_GetArrayObject(scrContext, 0);
  ArraySize = GetArraySize(scrContext, ArrayObject);
  SV_MainSP_DemoPlaybackForwardFrame();
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 140, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  CL_TransientsSP_QueueUnloadAll();
  v4 = 0;
  v5 = 0;
  transientLoaded = level.transientLoaded;
  do
  {
    if ( *transientLoaded )
      SV_TransientsSP_BeginUnloadingInternal(v5);
    ++v5;
    ++transientLoaded;
  }
  while ( v5 < 0x20 );
  if ( ArraySize )
  {
    do
    {
      ArrayVariable = GetArrayVariable(scrContext, ArrayObject, v4);
      if ( GetValueType(scrContext, ArrayVariable) != VAR_STRING )
        Scr_ParamError(COM_ERR_1605, scrContext, v4, "All array elements need to be strings.");
      VariableValueAddress = (scr_string_t *)GetVariableValueAddress(scrContext, ArrayVariable);
      v9 = SL_ConvertToString(*VariableValueAddress);
      if ( !v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 1629, ASSERT_TYPE_ASSERT, "(transientName)", (const char *)&queryFormat, "transientName") )
        __debugbreak();
      if ( !DB_Zones_IsTransientZoneName(v9) )
      {
        Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1444D95B0, 19i64, v9, "_tr");
        v10 = j_va("Bad transient name '%s'", v9);
        Scr_Error(COM_ERR_1606, scrContext, v10);
      }
      SPTransientIndex = DB_Transients_GetSPTransientIndex(v9);
      v12 = (int)SPTransientIndex;
      if ( SPTransientIndex >= 0x20 )
      {
        v13 = j_va("Unknown transient '%s'", v9);
        Scr_Error(COM_ERR_1607, scrContext, v13);
        LODWORD(v16) = 32;
        LODWORD(v15) = v12;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 1645, ASSERT_TYPE_ASSERT, "(unsigned)( transientSlot ) < (unsigned)( ( sizeof( *array_counter( level.transientLoaded ) ) + 0 ) )", "transientSlot doesn't index ARRAY_COUNT( level.transientLoaded )\n\t%i not in [0, %i)", v15, v16) )
          __debugbreak();
      }
      if ( level.transientLoaded[v12] )
      {
        v14 = j_va("Transient '%s' listed twice in LoadStartPointTransients() call", v9);
        Scr_Error(COM_ERR_1608, scrContext, v14);
      }
      if ( DB_Transients_VerbosePrint() )
        Com_Printf(15, "TRANSIENT_SV: Hard-load of transient '%s'.\n", v9);
      SV_TransientsSP_LoadInternal(1, v12);
      ++v4;
    }
    while ( v4 < ArraySize );
  }
  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 362, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  SV_TransientsSP_CheckTransientSets();
  CL_TransientsSP_HardSyncNow();
  SV_TransientsSP_UpdateStateFromClient();
  CL_TransientsSP_GameSystemsInit();
  if ( (DB_Zones_GetInUseFlags() & 0x600000) != 0 )
  {
    SV_PreloadSP_DumpDBPreloadZoneNames();
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1444D9920);
  }
  Scr_AddBool(scrContext, 1);
}

/*
==============
Scr_TransientsSP_LoadTransient
==============
*/
void Scr_TransientsSP_LoadTransient(scrContext_t *scrContext)
{
  const char *String; 
  int v3; 
  const char *v4; 
  unsigned int SPTransientIndex; 
  __int64 v6; 
  const char *v7; 
  __int64 v8; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_1589, scrContext, "Incorrect loadtransient() call.");
  String = Scr_GetString(scrContext, 0);
  if ( !String && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 1202, ASSERT_TYPE_ASSERT, "(filename)", (const char *)&queryFormat, "filename") )
    __debugbreak();
  v3 = 1;
  if ( !DB_Zones_IsTransientZoneName(String) )
  {
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1444D95B0, 19i64, String, "_tr");
    v4 = j_va("Bad transient name '%s'", String);
    Scr_Error(COM_ERR_1590, scrContext, v4);
  }
  if ( Sys_IsMainThread() && level.initializing && !SV_IsDemoPlaying() )
    Scr_Error(COM_ERR_1591, scrContext, "Cannot use loadtransient() in the first frame of a level script. Use add_start() to setup start transient(s) instead.");
  SPTransientIndex = DB_Transients_GetSPTransientIndex(String);
  v6 = (int)SPTransientIndex;
  if ( SPTransientIndex >= 0x20 )
  {
    v7 = j_va("Unknown transient '%s'", String);
    Scr_Error(COM_ERR_1592, scrContext, v7);
    LODWORD(v8) = v6;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 1224, ASSERT_TYPE_ASSERT, "(unsigned)( transientSlot ) < (unsigned)( MAX_TRANSIENT_SP_FASTFILES )", "transientSlot doesn't index MAX_TRANSIENT_SP_FASTFILES\n\t%i not in [0, %i)", v8, 32) )
      __debugbreak();
  }
  if ( level.transientLoaded[v6] )
  {
    if ( s_svTransients.isDevLoad[v6] )
    {
      if ( DB_Transients_VerbosePrint() )
        Com_Printf(15, "TRANSIENT_SV: Script requesting transient loaded from console: '%s'.\n", String);
      s_svTransients.isDevLoad[v6] = 0;
    }
    else
    {
      SV_TransientsSP_Print();
      Com_PrintError(24, "Fastfile '%s' is already loaded, or loading.\n", String);
      v3 = 0;
    }
  }
  else
  {
    Com_Printf(15, "TRANSIENT_SV: Queueing transient load of '%s'.\n", String);
    SV_TransientsSP_LoadInternal(0, v6);
  }
  Scr_AddBool(scrContext, v3);
}

/*
==============
Scr_TransientsSP_SetTransientVisibility
==============
*/
void Scr_TransientsSP_SetTransientVisibility(scrContext_t *scrContext)
{
  const char *String; 
  int Int; 
  unsigned int SPTransientIndex; 
  const char *v5; 
  const char *v6; 

  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_Error(COM_ERR_1615, scrContext, "Incorrect SetTransientVisibility() call.");
  String = Scr_GetString(scrContext, 0);
  if ( !String && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 1815, ASSERT_TYPE_ASSERT, "(filename)", (const char *)&queryFormat, "filename") )
    __debugbreak();
  Int = Scr_GetInt(scrContext, 1u);
  SPTransientIndex = DB_Transients_GetSPTransientIndex(String);
  if ( SPTransientIndex >= 0x20 )
  {
    v6 = j_va("Transient '%s' does not exist\n", String);
    Scr_Error(COM_ERR_1616, scrContext, v6);
  }
  else if ( level.transientLoaded[SPTransientIndex] )
  {
    level.transientVisibility[SPTransientIndex] = Int != 0;
    v5 = j_va("transient setvis %d %d", SPTransientIndex, Int != 0);
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v5);
  }
  else
  {
    Com_Printf(15, "Transient world zone '%s' is not loaded.", String);
  }
}

/*
==============
Scr_TransientsSP_SwitchTransientSet
==============
*/
void Scr_TransientsSP_SwitchTransientSet(scrContext_t *scrContext)
{
  const char *String; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_1581, scrContext, "Incorrect switchtransientset() call.");
  String = Scr_GetString(scrContext, 0);
  if ( !String && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 1033, ASSERT_TYPE_ASSERT, "(setName)", (const char *)&queryFormat, "setName") )
    __debugbreak();
  if ( Sys_IsMainThread() && level.initializing && !SV_IsDemoPlaying() )
    Scr_Error(COM_ERR_1582, scrContext, "Cannot use switchtransientset() in the first frame of a level script. Use add_start() to setup start transient(s) instead.");
  SV_TransientsSP_SwitchTransientSet(String, 0);
}

/*
==============
Scr_TransientsSP_SyncTransients
==============
*/
void Scr_TransientsSP_SyncTransients(scrContext_t *scrContext)
{
  int v2; 
  bool *clientBusyFlags; 
  unsigned int v4; 
  const char *v5; 

  if ( DB_Transients_VerbosePrint() )
    Com_Printf(15, "TRANSIENT_SV: Queuing transient sync.\n");
  if ( Scr_GetNumParam(scrContext) > 1 )
    Scr_Error(COM_ERR_1597, scrContext, "Incorrect synctransients() call.");
  v2 = 0;
  clientBusyFlags = s_svTransients.clientBusyFlags;
  v4 = 0;
  while ( !*clientBusyFlags )
  {
    ++v4;
    ++clientBusyFlags;
    if ( v4 >= 0x20 )
    {
      s_svTransients.syncStallWarningShown = 0;
      v2 = 1;
      goto LABEL_14;
    }
  }
  if ( !s_svTransients.syncStallWarningShown )
  {
    s_svTransients.syncStallWarningShown = 1;
    Com_Error_impl(ERR_SCRIPT, (const ObfuscateErrorText)&stru_1444DA230);
  }
  if ( SV_MainSP_DemoPlaybackForwardFrame() )
  {
    CL_TransientsSP_QueueSoftSync();
  }
  else
  {
    v5 = j_va("transient sync");
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v5);
  }
LABEL_14:
  Scr_AddBool(scrContext, v2);
}

/*
==============
Scr_TransientsSP_UnloadAllTransients
==============
*/
void Scr_TransientsSP_UnloadAllTransients(scrContext_t *scrContext)
{
  char v2; 
  char v3; 
  unsigned int v4; 
  unsigned int v5; 
  __int64 v6; 
  __int64 v7; 

  if ( Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_1596, scrContext, "Incorrect unloadalltransients() call.");
  v2 = 0;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  v6 = 0i64;
  do
  {
    if ( level.transientLoaded[v6] )
    {
      if ( s_svTransients.isDependency[v6] )
        v3 = 1;
      else
        v2 = 1;
    }
    if ( level.transientVisibility[v6 - 31] )
    {
      if ( s_svTransients.clientBusyFlags[v6 - 31] )
        v3 = 1;
      else
        v2 = 1;
    }
    if ( level.transientVisibility[v6 - 30] )
    {
      if ( s_svTransients.clientBusyFlags[v6 - 30] )
        v3 = 1;
      else
        v2 = 1;
    }
    if ( level.transientVisibility[v6 - 29] )
    {
      if ( s_svTransients.clientBusyFlags[v6 - 29] )
        v3 = 1;
      else
        v2 = 1;
    }
    if ( level.transientVisibility[v6 - 28] )
    {
      if ( s_svTransients.clientBusyFlags[v6 - 28] )
        v3 = 1;
      else
        v2 = 1;
    }
    if ( level.transientVisibility[v6 - 27] )
    {
      if ( s_svTransients.clientBusyFlags[v6 - 27] )
        v3 = 1;
      else
        v2 = 1;
    }
    if ( level.transientVisibility[v6 - 26] )
    {
      if ( s_svTransients.clientBusyFlags[v6 - 26] )
        v3 = 1;
      else
        v2 = 1;
    }
    if ( level.transientVisibility[v6 - 25] )
    {
      if ( s_svTransients.clientBusyFlags[v6 - 25] )
        v3 = 1;
      else
        v2 = 1;
    }
    if ( level.transientVisibility[v6 - 24] )
    {
      if ( s_svTransients.clientBusyFlags[v6 - 24] )
        v3 = 1;
      else
        v2 = 1;
    }
    if ( level.transientVisibility[v6 - 23] )
    {
      if ( s_svTransients.clientBusyFlags[v6 - 23] )
        v3 = 1;
      else
        v2 = 1;
    }
    if ( level.transientVisibility[v6 - 22] )
    {
      if ( s_svTransients.clientBusyFlags[v6 - 22] )
        v3 = 1;
      else
        v2 = 1;
    }
    if ( level.transientVisibility[v6 - 21] )
    {
      if ( s_svTransients.clientBusyFlags[v6 - 21] )
        v3 = 1;
      else
        v2 = 1;
    }
    if ( level.transientVisibility[v6 - 20] )
    {
      if ( s_svTransients.clientBusyFlags[v6 - 20] )
        v3 = 1;
      else
        v2 = 1;
    }
    if ( level.transientVisibility[v6 - 19] )
    {
      if ( s_svTransients.clientBusyFlags[v6 - 19] )
        v3 = 1;
      else
        v2 = 1;
    }
    if ( level.transientVisibility[v6 - 18] )
    {
      if ( s_svTransients.clientBusyFlags[v6 - 18] )
        v3 = 1;
      else
        v2 = 1;
    }
    if ( level.transientVisibility[v6 - 17] )
    {
      if ( s_svTransients.clientBusyFlags[v6 - 17] )
        v3 = 1;
      else
        v2 = 1;
    }
    if ( level.transientVisibility[v6 - 16] )
    {
      if ( s_svTransients.clientBusyFlags[v6 - 16] )
        v3 = 1;
      else
        v2 = 1;
    }
    if ( level.transientVisibility[v6 - 15] )
    {
      if ( s_svTransients.clientBusyFlags[v6 - 15] )
        v3 = 1;
      else
        v2 = 1;
    }
    if ( level.transientVisibility[v6 - 14] )
    {
      if ( s_svTransients.clientBusyFlags[v6 - 14] )
        v3 = 1;
      else
        v2 = 1;
    }
    if ( level.transientVisibility[v6 - 13] )
    {
      if ( s_svTransients.clientBusyFlags[v6 - 13] )
        v3 = 1;
      else
        v2 = 1;
    }
    if ( level.transientVisibility[v6 - 12] )
    {
      if ( s_svTransients.clientBusyFlags[v6 - 12] )
        v3 = 1;
      else
        v2 = 1;
    }
    if ( level.transientVisibility[v6 - 11] )
    {
      if ( s_svTransients.clientBusyFlags[v6 - 11] )
        v3 = 1;
      else
        v2 = 1;
    }
    if ( level.transientVisibility[v6 - 10] )
    {
      if ( s_svTransients.clientBusyFlags[v6 - 10] )
        v3 = 1;
      else
        v2 = 1;
    }
    if ( level.transientVisibility[v6 - 9] )
    {
      if ( s_svTransients.clientBusyFlags[v6 - 9] )
        v3 = 1;
      else
        v2 = 1;
    }
    if ( level.transientVisibility[v6 - 8] )
    {
      if ( s_svTransients.clientBusyFlags[v6 - 8] )
        v3 = 1;
      else
        v2 = 1;
    }
    if ( level.transientVisibility[v6 - 7] )
    {
      if ( s_svTransients.clientBusyFlags[v6 - 7] )
        v3 = 1;
      else
        v2 = 1;
    }
    if ( level.transientVisibility[v6 - 6] )
    {
      if ( s_svTransients.clientBusyFlags[v6 - 6] )
        v3 = 1;
      else
        v2 = 1;
    }
    if ( level.transientVisibility[v6 - 5] )
    {
      if ( s_svTransients.clientBusyFlags[v6 - 5] )
        v3 = 1;
      else
        v2 = 1;
    }
    if ( level.transientVisibility[v6 - 4] )
    {
      if ( s_svTransients.clientBusyFlags[v6 - 4] )
        v3 = 1;
      else
        v2 = 1;
    }
    if ( level.transientVisibility[v6 - 3] )
    {
      if ( s_svTransients.clientBusyFlags[v6 - 3] )
        v3 = 1;
      else
        v2 = 1;
    }
    if ( level.transientVisibility[v6 - 2] )
    {
      if ( s_svTransients.clientBusyFlags[v6 - 2] )
        v3 = 1;
      else
        v2 = 1;
    }
    if ( level.transientVisibility[v6 - 1] )
    {
      if ( s_svTransients.clientBusyFlags[v6 - 1] )
        v3 = 1;
      else
        v2 = 1;
    }
    v5 += 32;
    v6 += 32i64;
  }
  while ( v5 < 0x20 );
  if ( v2 )
  {
    Com_Printf(15, "TRANSIENT_SV: Queuing transient unloads of all fastfiles.\n");
    if ( v3 )
    {
      v7 = 0i64;
      do
      {
        if ( level.transientLoaded[v7] && !s_svTransients.isDependency[v7] )
          SV_TransientsSP_UnloadInternal(0, v4);
        ++v4;
        ++v7;
      }
      while ( v4 < 0x20 );
      v4 = 1;
    }
    else
    {
      SV_TransientsSP_UnloadAllInternal(0);
      v4 = 1;
    }
  }
  else
  {
    Com_Printf(15, "TRANSIENT_SV: All transients are already unloaded\n");
  }
  Scr_AddBool(scrContext, v4);
}

/*
==============
Scr_TransientsSP_UnloadTransient
==============
*/
void Scr_TransientsSP_UnloadTransient(scrContext_t *scrContext)
{
  const char *String; 
  int v3; 
  const char *v4; 
  unsigned int SPTransientIndex; 
  __int64 v6; 
  const char *v7; 
  __int64 v8; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_1593, scrContext, "Incorrect unloadtransient() call.");
  String = Scr_GetString(scrContext, 0);
  if ( !String && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 1277, ASSERT_TYPE_ASSERT, "(filename)", (const char *)&queryFormat, "filename") )
    __debugbreak();
  v3 = 1;
  if ( !DB_Zones_IsTransientZoneName(String) )
  {
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1444D95B0, 19i64, String, "_tr");
    v4 = j_va("Bad transient name '%s'", String);
    Scr_Error(COM_ERR_1594, scrContext, v4);
  }
  SPTransientIndex = DB_Transients_GetSPTransientIndex(String);
  v6 = (int)SPTransientIndex;
  if ( SPTransientIndex >= 0x20 )
  {
    v7 = j_va("Unknown transient '%s'", String);
    Scr_Error(COM_ERR_1595, scrContext, v7);
    LODWORD(v8) = v6;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 1289, ASSERT_TYPE_ASSERT, "(unsigned)( transientSlot ) < (unsigned)( MAX_TRANSIENT_SP_FASTFILES )", "transientSlot doesn't index MAX_TRANSIENT_SP_FASTFILES\n\t%i not in [0, %i)", v8, 32) )
      __debugbreak();
  }
  if ( s_svTransients.isDevLoad[v6] )
  {
    Com_PrintError(24, "Fastfile '%s' cannot be unloaded because it was loaded by the developer console.\n", String);
    v3 = 0;
  }
  else if ( level.transientLoaded[v6] )
  {
    if ( s_svTransients.isDependency[v6] )
    {
      SV_TransientsSP_Print();
      Com_PrintError(24, "Fastfile '%s' cannot be unloaded because level assets depend on it.\n", String);
      v3 = 0;
    }
    else
    {
      Com_Printf(15, "TRANSIENT_SV: Queuing transient unload of '%s'.\n", String);
      SV_TransientsSP_UnloadInternal(0, v6);
    }
  }
  else
  {
    SV_TransientsSP_Print();
    Com_PrintError(24, "Fastfile '%s' is already unloaded, or unloading.\n", String);
    v3 = 0;
  }
  Scr_AddBool(scrContext, v3);
}

/*
==============
Scr_TransientsSP_WaitForAllTransients
==============
*/
void Scr_TransientsSP_WaitForAllTransients(scrContext_t *scrContext)
{
  const dvar_t *v1; 

  v1 = DVARBOOL_transient_auto_pause;
  if ( !DVARBOOL_transient_auto_pause && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "transient_auto_pause") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  if ( v1->current.enabled )
  {
    if ( Scr_GetNumParam(scrContext) )
      Scr_Error(COM_ERR_1583, scrContext, "Incorrect WaitForAllTransients() call.");
    if ( Sys_IsMainThread() && level.initializing && !SV_IsDemoPlaying() )
      Scr_Error(COM_ERR_1584, scrContext, "Cannot use WaitForAllTransients() in the first frame of a level script.");
    SV_TransientsSP_WaitForTransientInternal(-1, NULL);
  }
}

/*
==============
Scr_TransientsSP_WaitForTransient
==============
*/
void Scr_TransientsSP_WaitForTransient(scrContext_t *scrContext)
{
  const dvar_t *v1; 
  const char *String; 
  const char *v4; 
  unsigned int SPTransientIndex; 
  const char *v6; 
  __int64 v7; 
  __int64 v8; 

  v1 = DVARBOOL_transient_auto_pause;
  if ( !DVARBOOL_transient_auto_pause && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "transient_auto_pause") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  if ( v1->current.enabled )
  {
    if ( Scr_GetNumParam(scrContext) != 1 )
      Scr_Error(COM_ERR_1585, scrContext, "Incorrect WaitForTransient() call.");
    String = Scr_GetString(scrContext, 0);
    if ( !String && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 1151, ASSERT_TYPE_ASSERT, "(filename)", (const char *)&queryFormat, "filename") )
      __debugbreak();
    if ( !DB_Zones_IsTransientZoneName(String) )
    {
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1444D95B0, 19i64, String, "_tr");
      v4 = j_va("WaitForTransient: Bad transient name '%s'", String);
      Scr_Error(COM_ERR_1586, scrContext, v4);
    }
    if ( Sys_IsMainThread() && level.initializing && !SV_IsDemoPlaying() )
      Scr_Error(COM_ERR_1587, scrContext, "Cannot use WaitForTransient() in the first frame of a level script.");
    SPTransientIndex = DB_Transients_GetSPTransientIndex(String);
    if ( SPTransientIndex >= 0x20 )
    {
      v6 = j_va("WaitForTransient: Unknown transient '%s'", String);
      Scr_Error(COM_ERR_1588, scrContext, v6);
      LODWORD(v8) = 32;
      LODWORD(v7) = SPTransientIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_sp\\sv_transients_sp.cpp", 1174, ASSERT_TYPE_ASSERT, "(unsigned)( transientSlot ) < (unsigned)( MAX_TRANSIENT_SP_FASTFILES )", "transientSlot doesn't index MAX_TRANSIENT_SP_FASTFILES\n\t%i not in [0, %i)", v7, v8) )
        __debugbreak();
    }
    SV_TransientsSP_WaitForTransientInternal(SPTransientIndex, String);
  }
}

