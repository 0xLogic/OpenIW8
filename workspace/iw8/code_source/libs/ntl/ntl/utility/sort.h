/*
==============
ntl::sort<IWMemAllocator * *,AllocatorSortFunctor>
==============
*/

void __fastcall ntl::sort<IWMemAllocator * *,AllocatorSortFunctor>(IWMemAllocator **first, IWMemAllocator **last, AllocatorSortFunctor compare, ntl::random_access_iterator_tag __formal)
{
  ??$sort@PEAPEAVIWMemAllocator@@UAllocatorSortFunctor@@@ntl@@YAXPEAPEAVIWMemAllocator@@0UAllocatorSortFunctor@@Urandom_access_iterator_tag@0@@Z(first, last, compare, __formal);
}

/*
==============
ntl::sort<EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge>
==============
*/

void __fastcall ntl::sort<EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge>(EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *first, EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *last, EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *compare)
{
  ??$sort@PEAUSelectedEdge@?$EdgeOctreeQuery@VEdgeOctreeQueryFrustum@@@@U12@@ntl@@YAXPEAUSelectedEdge@?$EdgeOctreeQuery@VEdgeOctreeQueryFrustum@@@@0U12@@Z(first, last, compare);
}

/*
==============
ntl::internal::introsort_loop<CachedLookup::Entry *,CachedLookup::SortFunc>
==============
*/

void __fastcall ntl::internal::introsort_loop<CachedLookup::Entry *,CachedLookup::SortFunc>(CachedLookup::Entry *const *r_iBegin, CachedLookup::Entry *iEnd, unsigned __int64 depthLimit, CachedLookup::SortFunc predicate)
{
  ??$introsort_loop@PEAUEntry@CachedLookup@@VSortFunc@2@@internal@ntl@@YAXAEBQEAUEntry@CachedLookup@@PEAU23@_KVSortFunc@3@@Z(r_iBegin, iEnd, depthLimit, predicate);
}

/*
==============
ntl::internal::introsort_loop<EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge>
==============
*/

void __fastcall ntl::internal::introsort_loop<EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge>(EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *const *r_iBegin, EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *iEnd, unsigned __int64 depthLimit, EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *predicate)
{
  ??$introsort_loop@PEAUSelectedEdge@?$EdgeOctreeQuery@VEdgeOctreeQuerySphere@@@@U12@@internal@ntl@@YAXAEBQEAUSelectedEdge@?$EdgeOctreeQuery@VEdgeOctreeQuerySphere@@@@PEAU23@_KU23@@Z(r_iBegin, iEnd, depthLimit, predicate);
}

/*
==============
ntl::sort<dropBagPlayerInfo_t * *,PlayerPotentialPartnersPredicate>
==============
*/

void __fastcall ntl::sort<dropBagPlayerInfo_t * *,PlayerPotentialPartnersPredicate>(dropBagPlayerInfo_t **first, dropBagPlayerInfo_t **last, PlayerPotentialPartnersPredicate compare)
{
  ??$sort@PEAPEAUdropBagPlayerInfo_t@@VPlayerPotentialPartnersPredicate@@@ntl@@YAXPEAPEAUdropBagPlayerInfo_t@@0VPlayerPotentialPartnersPredicate@@@Z(first, last, compare);
}

/*
==============
ntl::sort<CachedLookup::Entry *,CachedLookup::SortFunc>
==============
*/

void __fastcall ntl::sort<CachedLookup::Entry *,CachedLookup::SortFunc>(CachedLookup::Entry *first, CachedLookup::Entry *last, CachedLookup::SortFunc compare, ntl::random_access_iterator_tag __formal)
{
  ??$sort@PEAUEntry@CachedLookup@@VSortFunc@2@@ntl@@YAXPEAUEntry@CachedLookup@@0VSortFunc@2@Urandom_access_iterator_tag@0@@Z(first, last, compare, __formal);
}

/*
==============
ntl::sort<ConeTargetHitInfo *>
==============
*/

void __fastcall ntl::sort<ConeTargetHitInfo *>(ConeTargetHitInfo *first, ConeTargetHitInfo *last)
{
  ??$sort@PEAUConeTargetHitInfo@@@ntl@@YAXPEAUConeTargetHitInfo@@0@Z(first, last);
}

/*
==============
ntl::sort<CAssistTarget *>
==============
*/

void __fastcall ntl::sort<CAssistTarget *>(CAssistTarget *first, CAssistTarget *last)
{
  ??$sort@PEAVCAssistTarget@@@ntl@@YAXPEAVCAssistTarget@@0@Z(first, last);
}

/*
==============
ntl::internal::introsort_loop<IWMemAllocator * *,AllocatorSortFunctor>
==============
*/

void __fastcall ntl::internal::introsort_loop<IWMemAllocator * *,AllocatorSortFunctor>(IWMemAllocator **const *r_iBegin, IWMemAllocator **iEnd, unsigned __int64 depthLimit, AllocatorSortFunctor predicate)
{
  ??$introsort_loop@PEAPEAVIWMemAllocator@@UAllocatorSortFunctor@@@internal@ntl@@YAXAEBQEAPEAVIWMemAllocator@@PEAPEAV2@_KUAllocatorSortFunctor@@@Z(r_iBegin, iEnd, depthLimit, predicate);
}

/*
==============
ntl::sort<dropBagClusterInfo_t * *,ClusterPotentialPlayersPredicate>
==============
*/

void __fastcall ntl::sort<dropBagClusterInfo_t * *,ClusterPotentialPlayersPredicate>(dropBagClusterInfo_t **first, dropBagClusterInfo_t **last, ClusterPotentialPlayersPredicate compare)
{
  ??$sort@PEAPEAUdropBagClusterInfo_t@@VClusterPotentialPlayersPredicate@@@ntl@@YAXPEAPEAUdropBagClusterInfo_t@@0VClusterPotentialPlayersPredicate@@@Z(first, last, compare);
}

/*
==============
ntl::sort<GAssistTarget *>
==============
*/

void __fastcall ntl::sort<GAssistTarget *>(GAssistTarget *first, GAssistTarget *last)
{
  ??$sort@PEAVGAssistTarget@@@ntl@@YAXPEAVGAssistTarget@@0@Z(first, last);
}

/*
==============
ntl::internal::introsort_loop<EdgePropertyTuple *,EdgePropertyTuple>
==============
*/

void __fastcall ntl::internal::introsort_loop<EdgePropertyTuple *,EdgePropertyTuple>(EdgePropertyTuple *const *r_iBegin, EdgePropertyTuple *iEnd, unsigned __int64 depthLimit, EdgePropertyTuple *predicate)
{
  ??$introsort_loop@PEAUEdgePropertyTuple@@U1@@internal@ntl@@YAXAEBQEAUEdgePropertyTuple@@PEAU2@_KU2@@Z(r_iBegin, iEnd, depthLimit, predicate);
}

/*
==============
ntl::sort<dropBagPlayerInfo_t * *,PlayerPotentialPartnersPredicate>
==============
*/

void __fastcall ntl::sort<dropBagPlayerInfo_t * *,PlayerPotentialPartnersPredicate>(dropBagPlayerInfo_t **first, dropBagPlayerInfo_t **last, PlayerPotentialPartnersPredicate compare, ntl::random_access_iterator_tag __formal)
{
  ??$sort@PEAPEAUdropBagPlayerInfo_t@@VPlayerPotentialPartnersPredicate@@@ntl@@YAXPEAPEAUdropBagPlayerInfo_t@@0VPlayerPotentialPartnersPredicate@@Urandom_access_iterator_tag@0@@Z(first, last, compare, __formal);
}

/*
==============
ntl::sort<IWMemAllocator * *,AllocatorSortFunctor>
==============
*/

void __fastcall ntl::sort<IWMemAllocator * *,AllocatorSortFunctor>(IWMemAllocator **first, IWMemAllocator **last, AllocatorSortFunctor compare)
{
  ??$sort@PEAPEAVIWMemAllocator@@UAllocatorSortFunctor@@@ntl@@YAXPEAPEAVIWMemAllocator@@0UAllocatorSortFunctor@@@Z(first, last, compare);
}

/*
==============
ntl::sort<EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge>
==============
*/

void __fastcall ntl::sort<EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge>(EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *first, EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *last, EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *compare, ntl::random_access_iterator_tag __formal)
{
  ??$sort@PEAUSelectedEdge@?$EdgeOctreeQuery@VEdgeOctreeQueryFrustum@@@@U12@@ntl@@YAXPEAUSelectedEdge@?$EdgeOctreeQuery@VEdgeOctreeQueryFrustum@@@@0U12@Urandom_access_iterator_tag@0@@Z(first, last, compare, __formal);
}

/*
==============
ntl::internal::introsort_loop<dropBagClusterInfo_t * *,ClusterPotentialPlayersPredicate>
==============
*/

void __fastcall ntl::internal::introsort_loop<dropBagClusterInfo_t * *,ClusterPotentialPlayersPredicate>(dropBagClusterInfo_t **const *r_iBegin, dropBagClusterInfo_t **iEnd, unsigned __int64 depthLimit, ClusterPotentialPlayersPredicate predicate)
{
  ??$introsort_loop@PEAPEAUdropBagClusterInfo_t@@VClusterPotentialPlayersPredicate@@@internal@ntl@@YAXAEBQEAPEAUdropBagClusterInfo_t@@PEAPEAU2@_KVClusterPotentialPlayersPredicate@@@Z(r_iBegin, iEnd, depthLimit, predicate);
}

/*
==============
ntl::sort<EdgePropertyTuple *,EdgePropertyTuple>
==============
*/

void __fastcall ntl::sort<EdgePropertyTuple *,EdgePropertyTuple>(EdgePropertyTuple *first, EdgePropertyTuple *last, EdgePropertyTuple *compare, ntl::random_access_iterator_tag __formal)
{
  ??$sort@PEAUEdgePropertyTuple@@U1@@ntl@@YAXPEAUEdgePropertyTuple@@0U1@Urandom_access_iterator_tag@0@@Z(first, last, compare, __formal);
}

/*
==============
ntl::sort<CachedLookup::Entry *,CachedLookup::SortFunc>
==============
*/

void __fastcall ntl::sort<CachedLookup::Entry *,CachedLookup::SortFunc>(CachedLookup::Entry *first, CachedLookup::Entry *last, CachedLookup::SortFunc compare)
{
  ??$sort@PEAUEntry@CachedLookup@@VSortFunc@2@@ntl@@YAXPEAUEntry@CachedLookup@@0VSortFunc@2@@Z(first, last, compare);
}

/*
==============
ntl::sort<dropBagClusterInfo_t * *,ClusterPotentialPlayersPredicate>
==============
*/

void __fastcall ntl::sort<dropBagClusterInfo_t * *,ClusterPotentialPlayersPredicate>(dropBagClusterInfo_t **first, dropBagClusterInfo_t **last, ClusterPotentialPlayersPredicate compare, ntl::random_access_iterator_tag __formal)
{
  ??$sort@PEAPEAUdropBagClusterInfo_t@@VClusterPotentialPlayersPredicate@@@ntl@@YAXPEAPEAUdropBagClusterInfo_t@@0VClusterPotentialPlayersPredicate@@Urandom_access_iterator_tag@0@@Z(first, last, compare, __formal);
}

/*
==============
ntl::internal::introsort_loop<EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge>
==============
*/

void __fastcall ntl::internal::introsort_loop<EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge>(EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *const *r_iBegin, EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *iEnd, unsigned __int64 depthLimit, EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *predicate)
{
  ??$introsort_loop@PEAUSelectedEdge@?$EdgeOctreeQuery@VEdgeOctreeQueryFrustum@@@@U12@@internal@ntl@@YAXAEBQEAUSelectedEdge@?$EdgeOctreeQuery@VEdgeOctreeQueryFrustum@@@@PEAU23@_KU23@@Z(r_iBegin, iEnd, depthLimit, predicate);
}

/*
==============
ntl::sort<EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge>
==============
*/

void __fastcall ntl::sort<EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge>(EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *first, EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *last, EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *compare)
{
  ??$sort@PEAUSelectedEdge@?$EdgeOctreeQuery@VEdgeOctreeQuerySphere@@@@U12@@ntl@@YAXPEAUSelectedEdge@?$EdgeOctreeQuery@VEdgeOctreeQuerySphere@@@@0U12@@Z(first, last, compare);
}

/*
==============
ntl::sort<EdgePropertyTuple *,EdgePropertyTuple>
==============
*/

void __fastcall ntl::sort<EdgePropertyTuple *,EdgePropertyTuple>(EdgePropertyTuple *first, EdgePropertyTuple *last, EdgePropertyTuple *compare)
{
  ??$sort@PEAUEdgePropertyTuple@@U1@@ntl@@YAXPEAUEdgePropertyTuple@@0U1@@Z(first, last, compare);
}

/*
==============
ntl::sort<EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge>
==============
*/

void __fastcall ntl::sort<EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge>(EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *first, EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *last, EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *compare, ntl::random_access_iterator_tag __formal)
{
  ??$sort@PEAUSelectedEdge@?$EdgeOctreeQuery@VEdgeOctreeQuerySphere@@@@U12@@ntl@@YAXPEAUSelectedEdge@?$EdgeOctreeQuery@VEdgeOctreeQuerySphere@@@@0U12@Urandom_access_iterator_tag@0@@Z(first, last, compare, __formal);
}

/*
==============
ntl::internal::introsort_loop<dropBagPlayerInfo_t * *,PlayerPotentialPartnersPredicate>
==============
*/

void __fastcall ntl::internal::introsort_loop<dropBagPlayerInfo_t * *,PlayerPotentialPartnersPredicate>(dropBagPlayerInfo_t **const *r_iBegin, dropBagPlayerInfo_t **iEnd, unsigned __int64 depthLimit, PlayerPotentialPartnersPredicate predicate)
{
  ??$introsort_loop@PEAPEAUdropBagPlayerInfo_t@@VPlayerPotentialPartnersPredicate@@@internal@ntl@@YAXAEBQEAPEAUdropBagPlayerInfo_t@@PEAPEAU2@_KVPlayerPotentialPartnersPredicate@@@Z(r_iBegin, iEnd, depthLimit, predicate);
}

/*
==============
ntl::internal::introsort_loop<EdgePropertyTuple *,EdgePropertyTuple>
==============
*/
void ntl::internal::introsort_loop<EdgePropertyTuple *,EdgePropertyTuple>(EdgePropertyTuple *const *r_iBegin, EdgePropertyTuple *iEnd, unsigned __int64 depthLimit, EdgePropertyTuple *predicate)
{
  EdgePropertyTuple *v9; 
  __int64 v14; 
  bool v15; 
  bool v21; 
  EdgePropertyTuple *v34; 
  signed __int64 v35; 
  __int64 v36; 
  __int64 i; 
  __int64 v40; 
  __int64 v41; 
  __int64 v47; 
  __int64 v62; 
  EdgePropertyTuple *v73; 
  EdgePropertyTuple *v74; 
  __int64 v81; 
  __int64 v82; 
  signed __int64 v88; 
  bool v89; 
  __int64 v91; 
  __int64 v106; 
  EdgePropertyTuple v121; 
  void *retaddr; 
  EdgePropertyTuple *v125; 

  _R11 = &retaddr;
  _R10 = *r_iBegin;
  _RSI = predicate;
  v9 = iEnd;
  if ( (char *)iEnd - (char *)*r_iBegin < 1768 )
    return;
  __asm { vmovaps xmmword ptr [r11-38h], xmm6 }
  while ( depthLimit )
  {
    __asm { vmovss  xmm1, dword ptr [r10+60h] }
    _R8 = v9 - 1;
    __asm { vmovss  xmm0, dword ptr [r8+60h] }
    --depthLimit;
    v14 = ((char *)v9 - (char *)_R10) / 208;
    v15 = __CFADD__(_R10, 104 * v14);
    _RAX = &_R10[v14];
    __asm
    {
      vmovss  xmm2, dword ptr [rax+60h]
      vcomiss xmm1, xmm2
    }
    if ( v15 || _RAX == NULL )
    {
      __asm { vcomiss xmm1, xmm0 }
      if ( __CFADD__(_R10, 104 * v14) || &_R10[v14] == NULL )
      {
        __asm { vcomiss xmm2, xmm0 }
LABEL_10:
        if ( !__CFADD__(_R10, 104 * v14) && &_R10[v14] != NULL )
          _RAX = v9 - 1;
        goto LABEL_12;
      }
      _RAX = _R10;
    }
    else
    {
      __asm { vcomiss xmm2, xmm0 }
      if ( __CFADD__(_R10, 104 * v14) || &_R10[v14] == NULL )
      {
        _RAX = _R10;
        __asm { vcomiss xmm1, xmm0 }
        goto LABEL_10;
      }
    }
LABEL_12:
    __asm
    {
      vmovsd  xmm1, qword ptr [rax+60h]
      vmovsd  [rsp+1A8h+var_48], xmm1
      vmovss  xmm6, dword ptr [rsp+1A8h+var_48]
    }
    _RAX = (unsigned __int64)v9;
    while ( 1 )
    {
      __asm { vcomiss xmm6, dword ptr [r10+60h] }
      while ( v15 )
      {
        v15 = __CFADD__(_R10++, 104i64);
        __asm { vcomiss xmm6, dword ptr [r10+60h] }
      }
      v21 = _RAX <= 0x68;
      _RAX -= 104i64;
      __asm { vcomiss xmm6, dword ptr [rax+60h] }
      while ( !v21 )
      {
        v21 = _RAX <= 0x68;
        _RAX -= 104i64;
        __asm { vcomiss xmm6, dword ptr [rax+60h] }
      }
      if ( (unsigned __int64)_R10 >= _RAX )
        break;
      __asm
      {
        vmovups ymm0, ymmword ptr [rax]
        vmovups ymm3, ymmword ptr [r10]
        vmovups ymm4, ymmword ptr [r10+20h]
        vmovups ymm5, ymmword ptr [r10+40h]
        vmovsd  xmm2, qword ptr [r10+60h]
        vmovups ymmword ptr [r10], ymm0
        vmovups ymm1, ymmword ptr [rax+20h]
        vmovups ymmword ptr [r10+20h], ymm1
        vmovups ymm0, ymmword ptr [rax+40h]
        vmovups ymmword ptr [r10+40h], ymm0
        vmovsd  xmm1, qword ptr [rax+60h]
        vmovsd  qword ptr [r10+60h], xmm1
        vmovups ymmword ptr [rax], ymm3
        vmovups ymmword ptr [rax+20h], ymm4
        vmovups ymmword ptr [rax+40h], ymm5
        vmovsd  qword ptr [rax+60h], xmm2
      }
      v15 = __CFADD__(_R10++, 104i64);
    }
    __asm
    {
      vmovups ymm0, ymmword ptr [rsi]
      vmovups ymm1, ymmword ptr [rsi+20h]
      vmovups [rsp+1A8h+var_118], ymm0
      vmovups ymm0, ymmword ptr [rsi+40h]
      vmovups [rsp+1A8h+var_F8], ymm1
      vmovsd  xmm1, qword ptr [rsi+60h]
    }
    v125 = _R10;
    __asm
    {
      vmovups [rsp+1A8h+var_D8], ymm0
      vmovsd  [rsp+1A8h+var_B8], xmm1
    }
    ntl::internal::introsort_loop<EdgePropertyTuple *,EdgePropertyTuple>(&v125, v9, depthLimit, &v121);
    v9 = v125;
    _R10 = *r_iBegin;
    if ( (char *)v125 - (char *)*r_iBegin < 1768 )
      goto LABEL_57;
  }
  if ( _R10 > v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\utility\\sort.h", 121, ASSERT_TYPE_ASSERT, "( r_iBegin <= r_iMid )", (const char *)&queryFormat, "r_iBegin <= r_iMid") )
    __debugbreak();
  v34 = *r_iBegin;
  v35 = v9 - *r_iBegin;
  if ( v35 >= 2 )
  {
    v36 = (v35 - 2) / 2;
    _R11 = 104 * v36;
    for ( i = 2 * v36 + 2; ; i -= 2i64 )
    {
      _RDX = *r_iBegin;
      v40 = v36;
      v41 = i;
      __asm
      {
        vmovsd  xmm3, qword ptr [rdx+r11+60h]
        vmovups ymm4, ymmword ptr [rdx+r11]
        vmovups ymm5, ymmword ptr [rdx+r11+20h]
        vmovups ymm6, ymmword ptr [rdx+r11+40h]
        vmovsd  [rsp+1A8h+var_B8], xmm3
      }
      if ( i < v35 )
      {
        do
        {
          _R8 = *r_iBegin;
          v47 = v41 - 1;
          _RAX = 104 * v41;
          __asm
          {
            vmovss  xmm0, dword ptr [rax+r8+60h]
            vcomiss xmm0, dword ptr [rax+r8-8]
          }
          if ( (unsigned __int128)(104 * (__int128)v41) >> 64 != 0 || v89 )
            v47 = v41;
          _RCX = 104 * v40;
          _RAX = 104 * v47;
          v41 = 2 * v47 + 2;
          __asm
          {
            vmovups ymm0, ymmword ptr [rax+r8]
            vmovups ymmword ptr [rcx+r8], ymm0
            vmovups ymm1, ymmword ptr [rax+r8+20h]
            vmovups ymmword ptr [rcx+r8+20h], ymm1
            vmovups ymm0, ymmword ptr [rax+r8+40h]
            vmovups ymmword ptr [rcx+r8+40h], ymm0
            vmovsd  xmm1, qword ptr [rax+r8+60h]
            vmovsd  qword ptr [rcx+r8+60h], xmm1
          }
          v40 = v47;
        }
        while ( v41 < v35 );
        _RDX = *r_iBegin;
      }
      if ( v41 == v35 )
      {
        _RAX = 104 * v41;
        _RCX = 104 * v40;
        __asm
        {
          vmovups ymm0, ymmword ptr [rax+rdx-68h]
          vmovups ymmword ptr [rcx+rdx], ymm0
          vmovups ymm1, ymmword ptr [rax+rdx-48h]
          vmovups ymmword ptr [rcx+rdx+20h], ymm1
          vmovups ymm0, ymmword ptr [rax+rdx-28h]
          vmovups ymmword ptr [rcx+rdx+40h], ymm0
          vmovsd  xmm1, qword ptr [rax+rdx-8]
          vmovsd  qword ptr [rcx+rdx+60h], xmm1
        }
        v40 = v41 - 1;
      }
      v62 = (v40 - 1) / 2;
      if ( v40 > v36 )
      {
        __asm { vmovss  xmm2, dword ptr [rsp+1A8h+var_B8] }
        do
        {
          _RDX = *r_iBegin;
          _R8 = 104 * v62;
          __asm { vcomiss xmm2, dword ptr [r8+rdx+60h] }
          if ( is_mul_ok(0x68ui64, v62) )
            break;
          __asm { vmovups ymm0, ymmword ptr [r8+rdx] }
          _RCX = 104 * v40;
          __asm
          {
            vmovups ymmword ptr [rcx+rdx], ymm0
            vmovups ymm1, ymmword ptr [r8+rdx+20h]
            vmovups ymmword ptr [rcx+rdx+20h], ymm1
            vmovups ymm0, ymmword ptr [r8+rdx+40h]
            vmovups ymmword ptr [rcx+rdx+40h], ymm0
            vmovsd  xmm1, qword ptr [r8+rdx+60h]
            vmovsd  qword ptr [rcx+rdx+60h], xmm1
          }
          v40 = v62;
          v62 = (v62 - 1) / 2;
        }
        while ( v40 > v36 );
      }
      _RAX = *r_iBegin;
      _RCX = 104 * v40;
      __asm
      {
        vmovups ymmword ptr [rcx+rax], ymm4
        vmovups ymmword ptr [rcx+rax+20h], ymm5
        vmovups ymmword ptr [rcx+rax+40h], ymm6
        vmovsd  qword ptr [rcx+rax+60h], xmm3
      }
      if ( !v36 )
        break;
      --v36;
      _R11 -= 104i64;
    }
    v34 = *r_iBegin;
  }
  v73 = v34 + 1;
  while ( v9 > v73 )
  {
    v74 = v9--;
    _RDI = v74 - 1;
    __asm
    {
      vmovups ymm3, ymmword ptr [rdi]
      vmovups ymm4, ymmword ptr [rdi+20h]
      vmovups ymm5, ymmword ptr [rdi+40h]
      vmovsd  xmm6, qword ptr [rdi+60h]
      vmovups [rsp+1A8h+var_178], ymm3
      vmovups [rsp+1A8h+var_158], ymm4
      vmovups [rsp+1A8h+var_138], ymm5
      vmovsd  [rsp+1A8h+var_B8], xmm6
    }
    if ( _RDI < *r_iBegin )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\utility\\heap_sort.h", 206, ASSERT_TYPE_ASSERT, "( r_iEnd >= r_iBegin )", (const char *)&queryFormat, "r_iEnd >= r_iBegin") )
        __debugbreak();
      __asm
      {
        vmovups ymm5, [rsp+1A8h+var_138]
        vmovups ymm4, [rsp+1A8h+var_158]
        vmovups ymm3, [rsp+1A8h+var_178]
      }
    }
    _RAX = *r_iBegin;
    v81 = 0i64;
    v82 = 2i64;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovups ymmword ptr [rdi], ymm0
      vmovups ymm1, ymmword ptr [rax+20h]
      vmovups ymmword ptr [rdi+20h], ymm1
      vmovups ymm0, ymmword ptr [rax+40h]
      vmovups ymmword ptr [rdi+40h], ymm0
      vmovsd  xmm1, qword ptr [rax+60h]
      vmovsd  qword ptr [rdi+60h], xmm1
    }
    _R8 = *r_iBegin;
    v88 = _RDI - *r_iBegin;
    v89 = v88 == 2;
    if ( v88 > 2 )
    {
      do
      {
        _R8 = *r_iBegin;
        v91 = v82 - 1;
        _RAX = 104 * v82;
        __asm
        {
          vmovss  xmm0, dword ptr [rax+r8+60h]
          vcomiss xmm0, dword ptr [rax+r8-8]
        }
        if ( (unsigned __int128)(104 * (__int128)v82) >> 64 != 0 || v89 )
          v91 = v82;
        _RCX = 104 * v81;
        _RAX = 104 * v91;
        v82 = 2 * v91 + 2;
        __asm
        {
          vmovups ymm0, ymmword ptr [rax+r8]
          vmovups ymmword ptr [rcx+r8], ymm0
          vmovups ymm1, ymmword ptr [rax+r8+20h]
          vmovups ymmword ptr [rcx+r8+20h], ymm1
          vmovups ymm0, ymmword ptr [rax+r8+40h]
          vmovups ymmword ptr [rcx+r8+40h], ymm0
          vmovsd  xmm1, qword ptr [rax+r8+60h]
          vmovsd  qword ptr [rcx+r8+60h], xmm1
        }
        v81 = v91;
        v89 = v82 == v88;
      }
      while ( v82 < v88 );
      _R8 = *r_iBegin;
    }
    if ( v89 )
    {
      _RAX = 104 * v82;
      _RCX = 104 * v81;
      __asm
      {
        vmovups ymm0, ymmword ptr [rax+r8-68h]
        vmovups ymmword ptr [rcx+r8], ymm0
        vmovups ymm1, ymmword ptr [rax+r8-48h]
        vmovups ymmword ptr [rcx+r8+20h], ymm1
        vmovups ymm0, ymmword ptr [rax+r8-28h]
        vmovups ymmword ptr [rcx+r8+40h], ymm0
        vmovsd  xmm1, qword ptr [rax+r8-8]
        vmovsd  qword ptr [rcx+r8+60h], xmm1
      }
      v81 = v82 - 1;
    }
    v106 = (v81 - 1) / 2;
    if ( v81 > 0 )
    {
      __asm { vmovss  xmm2, dword ptr [rsp+1A8h+var_B8] }
      do
      {
        _RDX = *r_iBegin;
        _R8 = 104 * v106;
        __asm { vcomiss xmm2, dword ptr [r8+rdx+60h] }
        if ( is_mul_ok(0x68ui64, v106) )
          break;
        __asm { vmovups ymm0, ymmword ptr [r8+rdx] }
        _RCX = 104 * v81;
        __asm
        {
          vmovups ymmword ptr [rcx+rdx], ymm0
          vmovups ymm1, ymmword ptr [r8+rdx+20h]
          vmovups ymmword ptr [rcx+rdx+20h], ymm1
          vmovups ymm0, ymmword ptr [r8+rdx+40h]
          vmovups ymmword ptr [rcx+rdx+40h], ymm0
          vmovsd  xmm1, qword ptr [r8+rdx+60h]
          vmovsd  qword ptr [rcx+rdx+60h], xmm1
        }
        v81 = v106;
        v106 = (v106 - 1) / 2;
      }
      while ( v81 > 0 );
    }
    _RAX = *r_iBegin;
    _RCX = 104 * v81;
    __asm
    {
      vmovups ymmword ptr [rcx+rax], ymm3
      vmovups ymmword ptr [rcx+rax+20h], ymm4
      vmovups ymmword ptr [rcx+rax+40h], ymm5
      vmovsd  qword ptr [rcx+rax+60h], xmm6
    }
  }
LABEL_57:
  __asm { vmovaps xmm6, [rsp+1A8h+var_38] }
}

/*
==============
ntl::internal::introsort_loop<EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge>
==============
*/
void ntl::internal::introsort_loop<EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge>(EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *const *r_iBegin, EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *iEnd, unsigned __int64 depthLimit, EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *predicate)
{
  EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *v8; 
  __int64 v13; 
  bool v14; 
  bool v15; 
  EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *v24; 
  __int64 v25; 
  __int64 v26; 
  __int64 v27; 
  __int64 i; 
  __int64 v31; 
  __int64 v32; 
  __int64 v35; 
  __int64 v44; 
  EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *v52; 
  EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *v53; 
  __int64 v57; 
  __int64 v58; 
  __int64 v61; 
  bool v62; 
  __int64 v64; 
  __int64 v73; 
  EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge v82; 
  EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *v84; 

  _R10 = *r_iBegin;
  _RSI = predicate;
  v8 = iEnd;
  if ( (__int64)(((char *)iEnd - (char *)*r_iBegin) & 0xFFFFFFFFFFFFFFF0ui64) <= 256 )
    return;
  while ( depthLimit )
  {
    __asm { vmovss  xmm1, dword ptr [r10+8] }
    _RCX = v8 - 1;
    __asm { vmovss  xmm0, dword ptr [rcx+8] }
    --depthLimit;
    v13 = (v8 - _R10) / 2;
    v14 = __CFADD__(_R10, v13 * 16);
    v15 = __CFADD__(_R10, v13 * 16) || &_R10[v13] == NULL;
    _RAX = &_R10[v13];
    __asm
    {
      vmovss  xmm2, dword ptr [rax+8]
      vcomiss xmm1, xmm2
    }
    if ( v14 )
    {
      __asm { vcomiss xmm2, xmm0 }
      if ( !v14 )
      {
        _RAX = _R10;
        __asm { vcomiss xmm0, xmm1 }
        goto LABEL_9;
      }
    }
    else
    {
      __asm { vcomiss xmm1, xmm0 }
      if ( !v14 )
      {
        __asm { vcomiss xmm0, xmm2 }
LABEL_9:
        if ( !v15 )
          _RAX = v8 - 1;
        goto LABEL_11;
      }
      _RAX = _R10;
    }
LABEL_11:
    __asm
    {
      vmovups xmm0, xmmword ptr [rax]
      vmovups [rsp+68h+var_38], xmm0
      vmovss  xmm2, dword ptr [rsp+68h+var_38+8]
    }
    _RAX = (unsigned __int64)v8;
    while ( 1 )
    {
      __asm { vcomiss xmm2, dword ptr [r10+8] }
      while ( !v15 )
      {
        v15 = __CFADD__(_R10, 16i64) || &_R10[1] == NULL;
        ++_R10;
        __asm { vcomiss xmm2, dword ptr [r10+8] }
      }
      v14 = _RAX < 0x10;
      _RAX -= 16i64;
      __asm { vcomiss xmm2, dword ptr [rax+8] }
      while ( v14 )
      {
        v14 = _RAX < 0x10;
        _RAX -= 16i64;
        __asm { vcomiss xmm2, dword ptr [rax+8] }
      }
      if ( (unsigned __int64)_R10 >= _RAX )
        break;
      __asm
      {
        vmovups xmm1, xmmword ptr [r10]
        vmovups xmm0, xmmword ptr [rax]
        vmovups xmmword ptr [r10], xmm0
        vmovups xmmword ptr [rax], xmm1
      }
      v15 = __CFADD__(_R10, 16i64) || &_R10[1] == NULL;
      ++_R10;
    }
    __asm { vmovups xmm0, xmmword ptr [rsi] }
    v84 = _R10;
    __asm { vmovups [rsp+68h+var_38], xmm0 }
    ntl::internal::introsort_loop<EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge>(&v84, v8, depthLimit, &v82);
    v8 = v84;
    _R10 = *r_iBegin;
    if ( (__int64)(((char *)v84 - (char *)*r_iBegin) & 0xFFFFFFFFFFFFFFF0ui64) <= 256 )
      return;
  }
  if ( _R10 > v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\utility\\sort.h", 121, ASSERT_TYPE_ASSERT, "( r_iBegin <= r_iMid )", (const char *)&queryFormat, "r_iBegin <= r_iMid") )
    __debugbreak();
  v24 = *r_iBegin;
  v25 = v8 - *r_iBegin;
  if ( v25 >= 2 )
  {
    v26 = (v25 - 2) / 2;
    v27 = v26;
    _RSI = 16 * v26;
    for ( i = 2 * v26 + 2; ; i -= 2i64 )
    {
      _RCX = *r_iBegin;
      v31 = v27;
      v32 = i;
      __asm
      {
        vmovups xmm2, xmmword ptr [rsi+rcx]
        vmovups [rsp+68h+var_38], xmm2
      }
      if ( i < v25 )
      {
        do
        {
          _RDX = *r_iBegin;
          v35 = v32 - 1;
          _RAX = 2 * v32;
          __asm
          {
            vmovss  xmm0, dword ptr [rdx+rax*8-8]
            vcomiss xmm0, dword ptr [rdx+rax*8+8]
          }
          if ( __CFADD__(v32, v32) || 2 * v32 == 0 )
            v35 = v32;
          _R8 = 2 * v31;
          _RAX = 2 * v35;
          v32 = 2 * v35 + 2;
          __asm
          {
            vmovups xmm0, xmmword ptr [rdx+rax*8]
            vmovups xmmword ptr [rdx+r8*8], xmm0
          }
          v31 = v35;
        }
        while ( v32 < v25 );
        _RCX = *r_iBegin;
      }
      if ( v32 == v25 )
      {
        _RAX = 2 * v32;
        _R8 = 2 * v31;
        __asm
        {
          vmovups xmm0, xmmword ptr [rcx+rax*8-10h]
          vmovups xmmword ptr [rcx+r8*8], xmm0
        }
        v31 = v32 - 1;
      }
      v44 = (v31 - 1) / 2;
      if ( v31 > v27 )
      {
        __asm { vmovss  xmm1, dword ptr [rsp+68h+var_38+8] }
        do
        {
          _RDX = *r_iBegin;
          _RCX = 2 * v44;
          __asm { vcomiss xmm1, dword ptr [rdx+rcx*8+8] }
          if ( __CFADD__(v44, v44) || 2 * v44 == 0 )
            break;
          __asm { vmovups xmm0, xmmword ptr [rdx+rcx*8] }
          _R8 = 2 * v31;
          __asm { vmovups xmmword ptr [rdx+r8*8], xmm0 }
          v31 = v44;
          v44 = (v44 - 1) / 2;
        }
        while ( v31 > v27 );
      }
      _RAX = *r_iBegin;
      _R8 = 2 * v31;
      __asm { vmovups xmmword ptr [rax+r8*8], xmm2 }
      if ( !v27 )
        break;
      --v27;
      _RSI -= 16i64;
    }
    v24 = *r_iBegin;
  }
  v52 = v24 + 1;
  if ( v8 > &v24[1] )
  {
    __asm { vmovaps [rsp+68h+var_28], xmm6 }
    do
    {
      v53 = v8--;
      _RDI = v53 - 1;
      __asm
      {
        vmovups xmm6, xmmword ptr [rdi]
        vmovups [rsp+68h+var_38], xmm6
      }
      if ( _RDI < *r_iBegin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\utility\\heap_sort.h", 206, ASSERT_TYPE_ASSERT, "( r_iEnd >= r_iBegin )", (const char *)&queryFormat, "r_iEnd >= r_iBegin", *(_QWORD *)&v82.edgeId) )
        __debugbreak();
      _RAX = *r_iBegin;
      v57 = 0i64;
      v58 = 2i64;
      __asm
      {
        vmovups xmm0, xmmword ptr [rax]
        vmovups xmmword ptr [rdi], xmm0
      }
      _RCX = *r_iBegin;
      v61 = _RDI - *r_iBegin;
      v62 = v61 == 2;
      if ( v61 > 2 )
      {
        do
        {
          _RDX = *r_iBegin;
          v64 = v58 - 1;
          _RAX = 2 * v58;
          __asm
          {
            vmovss  xmm0, dword ptr [rdx+rax*8-8]
            vcomiss xmm0, dword ptr [rdx+rax*8+8]
          }
          if ( __CFADD__(v58, v58) || 2 * v58 == 0 )
            v64 = v58;
          _R8 = 2 * v57;
          _RAX = 2 * v64;
          v58 = 2 * v64 + 2;
          __asm
          {
            vmovups xmm0, xmmword ptr [rdx+rax*8]
            vmovups xmmword ptr [rdx+r8*8], xmm0
          }
          v57 = v64;
          v62 = v58 == v61;
        }
        while ( v58 < v61 );
        _RCX = *r_iBegin;
      }
      if ( v62 )
      {
        _RAX = 2 * v58;
        _R8 = 2 * v57;
        __asm
        {
          vmovups xmm0, xmmword ptr [rcx+rax*8-10h]
          vmovups xmmword ptr [rcx+r8*8], xmm0
        }
        v57 = v58 - 1;
      }
      v73 = (v57 - 1) / 2;
      if ( v57 > 0 )
      {
        __asm { vmovss  xmm1, dword ptr [rsp+68h+var_38+8] }
        do
        {
          _RDX = *r_iBegin;
          _RCX = 2 * v73;
          __asm { vcomiss xmm1, dword ptr [rdx+rcx*8+8] }
          if ( __CFADD__(v73, v73) || 2 * v73 == 0 )
            break;
          __asm { vmovups xmm0, xmmword ptr [rdx+rcx*8] }
          _R8 = 2 * v57;
          __asm { vmovups xmmword ptr [rdx+r8*8], xmm0 }
          v57 = v73;
          v73 = (v73 - 1) / 2;
        }
        while ( v57 > 0 );
      }
      _RAX = *r_iBegin;
      _R8 = 2 * v57;
      __asm { vmovups xmmword ptr [rax+r8*8], xmm6 }
    }
    while ( v8 > v52 );
    __asm { vmovaps xmm6, [rsp+68h+var_28] }
  }
}

/*
==============
ntl::internal::introsort_loop<EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge>
==============
*/
void ntl::internal::introsort_loop<EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge>(EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *const *r_iBegin, EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *iEnd, unsigned __int64 depthLimit, EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *predicate)
{
  EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *v8; 
  __int64 v13; 
  bool v14; 
  bool v15; 
  EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *v24; 
  __int64 v25; 
  __int64 v26; 
  __int64 v27; 
  __int64 i; 
  __int64 v31; 
  __int64 v32; 
  __int64 v35; 
  __int64 v44; 
  EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *v52; 
  EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *v53; 
  __int64 v57; 
  __int64 v58; 
  __int64 v61; 
  bool v62; 
  __int64 v64; 
  __int64 v73; 
  EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge v82; 
  EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *v84; 

  _R10 = *r_iBegin;
  _RSI = predicate;
  v8 = iEnd;
  if ( (__int64)(((char *)iEnd - (char *)*r_iBegin) & 0xFFFFFFFFFFFFFFF0ui64) <= 256 )
    return;
  while ( depthLimit )
  {
    __asm { vmovss  xmm1, dword ptr [r10+8] }
    _RCX = v8 - 1;
    __asm { vmovss  xmm0, dword ptr [rcx+8] }
    --depthLimit;
    v13 = (v8 - _R10) / 2;
    v14 = __CFADD__(_R10, v13 * 16);
    v15 = __CFADD__(_R10, v13 * 16) || &_R10[v13] == NULL;
    _RAX = &_R10[v13];
    __asm
    {
      vmovss  xmm2, dword ptr [rax+8]
      vcomiss xmm1, xmm2
    }
    if ( v14 )
    {
      __asm { vcomiss xmm2, xmm0 }
      if ( !v14 )
      {
        _RAX = _R10;
        __asm { vcomiss xmm0, xmm1 }
        goto LABEL_9;
      }
    }
    else
    {
      __asm { vcomiss xmm1, xmm0 }
      if ( !v14 )
      {
        __asm { vcomiss xmm0, xmm2 }
LABEL_9:
        if ( !v15 )
          _RAX = v8 - 1;
        goto LABEL_11;
      }
      _RAX = _R10;
    }
LABEL_11:
    __asm
    {
      vmovups xmm0, xmmword ptr [rax]
      vmovups [rsp+68h+var_38], xmm0
      vmovss  xmm2, dword ptr [rsp+68h+var_38+8]
    }
    _RAX = (unsigned __int64)v8;
    while ( 1 )
    {
      __asm { vcomiss xmm2, dword ptr [r10+8] }
      while ( !v15 )
      {
        v15 = __CFADD__(_R10, 16i64) || &_R10[1] == NULL;
        ++_R10;
        __asm { vcomiss xmm2, dword ptr [r10+8] }
      }
      v14 = _RAX < 0x10;
      _RAX -= 16i64;
      __asm { vcomiss xmm2, dword ptr [rax+8] }
      while ( v14 )
      {
        v14 = _RAX < 0x10;
        _RAX -= 16i64;
        __asm { vcomiss xmm2, dword ptr [rax+8] }
      }
      if ( (unsigned __int64)_R10 >= _RAX )
        break;
      __asm
      {
        vmovups xmm1, xmmword ptr [r10]
        vmovups xmm0, xmmword ptr [rax]
        vmovups xmmword ptr [r10], xmm0
        vmovups xmmword ptr [rax], xmm1
      }
      v15 = __CFADD__(_R10, 16i64) || &_R10[1] == NULL;
      ++_R10;
    }
    __asm { vmovups xmm0, xmmword ptr [rsi] }
    v84 = _R10;
    __asm { vmovups [rsp+68h+var_38], xmm0 }
    ntl::internal::introsort_loop<EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge>(&v84, v8, depthLimit, &v82);
    v8 = v84;
    _R10 = *r_iBegin;
    if ( (__int64)(((char *)v84 - (char *)*r_iBegin) & 0xFFFFFFFFFFFFFFF0ui64) <= 256 )
      return;
  }
  if ( _R10 > v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\utility\\sort.h", 121, ASSERT_TYPE_ASSERT, "( r_iBegin <= r_iMid )", (const char *)&queryFormat, "r_iBegin <= r_iMid") )
    __debugbreak();
  v24 = *r_iBegin;
  v25 = v8 - *r_iBegin;
  if ( v25 >= 2 )
  {
    v26 = (v25 - 2) / 2;
    v27 = v26;
    _RSI = 16 * v26;
    for ( i = 2 * v26 + 2; ; i -= 2i64 )
    {
      _RCX = *r_iBegin;
      v31 = v27;
      v32 = i;
      __asm
      {
        vmovups xmm2, xmmword ptr [rsi+rcx]
        vmovups [rsp+68h+var_38], xmm2
      }
      if ( i < v25 )
      {
        do
        {
          _RDX = *r_iBegin;
          v35 = v32 - 1;
          _RAX = 2 * v32;
          __asm
          {
            vmovss  xmm0, dword ptr [rdx+rax*8-8]
            vcomiss xmm0, dword ptr [rdx+rax*8+8]
          }
          if ( __CFADD__(v32, v32) || 2 * v32 == 0 )
            v35 = v32;
          _R8 = 2 * v31;
          _RAX = 2 * v35;
          v32 = 2 * v35 + 2;
          __asm
          {
            vmovups xmm0, xmmword ptr [rdx+rax*8]
            vmovups xmmword ptr [rdx+r8*8], xmm0
          }
          v31 = v35;
        }
        while ( v32 < v25 );
        _RCX = *r_iBegin;
      }
      if ( v32 == v25 )
      {
        _RAX = 2 * v32;
        _R8 = 2 * v31;
        __asm
        {
          vmovups xmm0, xmmword ptr [rcx+rax*8-10h]
          vmovups xmmword ptr [rcx+r8*8], xmm0
        }
        v31 = v32 - 1;
      }
      v44 = (v31 - 1) / 2;
      if ( v31 > v27 )
      {
        __asm { vmovss  xmm1, dword ptr [rsp+68h+var_38+8] }
        do
        {
          _RDX = *r_iBegin;
          _RCX = 2 * v44;
          __asm { vcomiss xmm1, dword ptr [rdx+rcx*8+8] }
          if ( __CFADD__(v44, v44) || 2 * v44 == 0 )
            break;
          __asm { vmovups xmm0, xmmword ptr [rdx+rcx*8] }
          _R8 = 2 * v31;
          __asm { vmovups xmmword ptr [rdx+r8*8], xmm0 }
          v31 = v44;
          v44 = (v44 - 1) / 2;
        }
        while ( v31 > v27 );
      }
      _RAX = *r_iBegin;
      _R8 = 2 * v31;
      __asm { vmovups xmmword ptr [rax+r8*8], xmm2 }
      if ( !v27 )
        break;
      --v27;
      _RSI -= 16i64;
    }
    v24 = *r_iBegin;
  }
  v52 = v24 + 1;
  if ( v8 > &v24[1] )
  {
    __asm { vmovaps [rsp+68h+var_28], xmm6 }
    do
    {
      v53 = v8--;
      _RDI = v53 - 1;
      __asm
      {
        vmovups xmm6, xmmword ptr [rdi]
        vmovups [rsp+68h+var_38], xmm6
      }
      if ( _RDI < *r_iBegin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\utility\\heap_sort.h", 206, ASSERT_TYPE_ASSERT, "( r_iEnd >= r_iBegin )", (const char *)&queryFormat, "r_iEnd >= r_iBegin", *(_QWORD *)&v82.edgeId) )
        __debugbreak();
      _RAX = *r_iBegin;
      v57 = 0i64;
      v58 = 2i64;
      __asm
      {
        vmovups xmm0, xmmword ptr [rax]
        vmovups xmmword ptr [rdi], xmm0
      }
      _RCX = *r_iBegin;
      v61 = _RDI - *r_iBegin;
      v62 = v61 == 2;
      if ( v61 > 2 )
      {
        do
        {
          _RDX = *r_iBegin;
          v64 = v58 - 1;
          _RAX = 2 * v58;
          __asm
          {
            vmovss  xmm0, dword ptr [rdx+rax*8-8]
            vcomiss xmm0, dword ptr [rdx+rax*8+8]
          }
          if ( __CFADD__(v58, v58) || 2 * v58 == 0 )
            v64 = v58;
          _R8 = 2 * v57;
          _RAX = 2 * v64;
          v58 = 2 * v64 + 2;
          __asm
          {
            vmovups xmm0, xmmword ptr [rdx+rax*8]
            vmovups xmmword ptr [rdx+r8*8], xmm0
          }
          v57 = v64;
          v62 = v58 == v61;
        }
        while ( v58 < v61 );
        _RCX = *r_iBegin;
      }
      if ( v62 )
      {
        _RAX = 2 * v58;
        _R8 = 2 * v57;
        __asm
        {
          vmovups xmm0, xmmword ptr [rcx+rax*8-10h]
          vmovups xmmword ptr [rcx+r8*8], xmm0
        }
        v57 = v58 - 1;
      }
      v73 = (v57 - 1) / 2;
      if ( v57 > 0 )
      {
        __asm { vmovss  xmm1, dword ptr [rsp+68h+var_38+8] }
        do
        {
          _RDX = *r_iBegin;
          _RCX = 2 * v73;
          __asm { vcomiss xmm1, dword ptr [rdx+rcx*8+8] }
          if ( __CFADD__(v73, v73) || 2 * v73 == 0 )
            break;
          __asm { vmovups xmm0, xmmword ptr [rdx+rcx*8] }
          _R8 = 2 * v57;
          __asm { vmovups xmmword ptr [rdx+r8*8], xmm0 }
          v57 = v73;
          v73 = (v73 - 1) / 2;
        }
        while ( v57 > 0 );
      }
      _RAX = *r_iBegin;
      _R8 = 2 * v57;
      __asm { vmovups xmmword ptr [rax+r8*8], xmm6 }
    }
    while ( v8 > v52 );
    __asm { vmovaps xmm6, [rsp+68h+var_28] }
  }
}

/*
==============
ntl::sort<EdgePropertyTuple *,EdgePropertyTuple>
==============
*/
void ntl::sort<EdgePropertyTuple *,EdgePropertyTuple>(EdgePropertyTuple *first, EdgePropertyTuple *last, EdgePropertyTuple *compare)
{
  EdgePropertyTuple v8; 
  void *retaddr; 
  ntl::random_access_iterator_tag v10; 

  _RAX = &retaddr;
  __asm
  {
    vmovups ymm0, ymmword ptr [r8]
    vmovups ymm1, ymmword ptr [r8+20h]
    vmovups ymmword ptr [rax-78h], ymm0
    vmovups ymm0, ymmword ptr [r8+40h]
    vmovups ymmword ptr [rax-58h], ymm1
    vmovsd  xmm1, qword ptr [r8+60h]
    vmovups ymmword ptr [rax-38h], ymm0
    vmovsd  qword ptr [rax-18h], xmm1
  }
  ntl::sort<EdgePropertyTuple *,EdgePropertyTuple>(first, last, &v8, v10);
}

/*
==============
ntl::sort<EdgePropertyTuple *,EdgePropertyTuple>
==============
*/
void ntl::sort<EdgePropertyTuple *,EdgePropertyTuple>(EdgePropertyTuple *first, EdgePropertyTuple *last, EdgePropertyTuple *compare, ntl::random_access_iterator_tag __formal)
{
  signed __int64 v5; 
  unsigned __int64 v8; 
  unsigned __int64 v9; 
  unsigned __int64 v10; 
  bool j; 
  bool k; 
  bool i; 
  EdgePropertyTuple v61; 
  EdgePropertyTuple *v62; 

  if ( first != last )
  {
    v62 = first;
    v5 = (char *)last - (char *)first;
    _R9 = compare;
    _RBX = first;
    v8 = (__int64)((unsigned __int128)(((char *)last - (char *)first) * (__int128)0x4EC4EC4EC4EC4EC5i64) >> 64) >> 5;
    v9 = (v8 >> 63) + v8;
    if ( v9 )
      v10 = 63 - __lzcnt(v9);
    else
      v10 = 0i64;
    __asm
    {
      vmovups ymm0, ymmword ptr [r9]
      vmovups ymm1, ymmword ptr [r9+20h]
      vmovups [rsp+98h+var_78], ymm0
      vmovups ymm0, ymmword ptr [r9+40h]
      vmovups [rsp+98h+var_58], ymm1
      vmovsd  xmm1, qword ptr [r9+60h]
      vmovups [rsp+98h+var_38], ymm0
      vmovsd  [rsp+98h+var_18], xmm1
    }
    ntl::internal::introsort_loop<EdgePropertyTuple *,EdgePropertyTuple>(&v62, last, 2 * v10, &v61);
    if ( v5 < 1768 )
    {
      _RDX = _RBX + 1;
      for ( i = &_RBX[1] <= last; _RDX != last; i = _RDX <= last )
      {
        __asm
        {
          vmovsd  xmm2, qword ptr [rdx+60h]
          vcomiss xmm2, dword ptr [rbx+60h]
          vmovups ymm3, ymmword ptr [rdx]
          vmovups ymm4, ymmword ptr [rdx+20h]
          vmovups ymm5, ymmword ptr [rdx+40h]
        }
        if ( i )
        {
          __asm { vcomiss xmm2, dword ptr [rdx-8] }
          _RCX = (unsigned __int64)_RDX;
          _RAX = (unsigned __int64)&_RDX[-1];
          if ( !i )
          {
            do
            {
              __asm
              {
                vmovups ymm0, ymmword ptr [rax]
                vmovups ymmword ptr [rcx], ymm0
                vmovups ymm1, ymmword ptr [rax+20h]
                vmovups ymmword ptr [rcx+20h], ymm1
                vmovups ymm0, ymmword ptr [rax+40h]
                vmovups ymmword ptr [rcx+40h], ymm0
                vmovsd  xmm1, qword ptr [rax+60h]
                vmovsd  qword ptr [rcx+60h], xmm1
              }
              _RCX = _RAX;
              j = _RAX <= 0x68;
              _RAX -= 104i64;
              __asm { vcomiss xmm2, dword ptr [rax+60h] }
            }
            while ( !j );
          }
          __asm
          {
            vmovups ymmword ptr [rcx], ymm3
            vmovups ymmword ptr [rcx+20h], ymm4
            vmovups ymmword ptr [rcx+40h], ymm5
            vmovsd  qword ptr [rcx+60h], xmm2
          }
        }
        else
        {
          _RAX = _RDX;
          while ( _RAX != _RBX )
          {
            __asm { vmovups ymm0, ymmword ptr [rax-68h] }
            --_RAX;
            __asm
            {
              vmovups ymmword ptr [rax+68h], ymm0
              vmovups ymm1, ymmword ptr [rax+20h]
              vmovups ymmword ptr [rax+88h], ymm1
              vmovups ymm0, ymmword ptr [rax+40h]
              vmovups ymmword ptr [rax+0A8h], ymm0
              vmovsd  xmm1, qword ptr [rax+60h]
              vmovsd  qword ptr [rax+0C8h], xmm1
            }
          }
          __asm
          {
            vmovups ymmword ptr [rbx], ymm3
            vmovups ymmword ptr [rbx+20h], ymm4
            vmovups ymmword ptr [rbx+40h], ymm5
            vmovsd  qword ptr [rbx+60h], xmm2
          }
        }
        ++_RDX;
      }
    }
    else
    {
      _R8 = _RBX + 16;
      if ( _RBX != &_RBX[16] )
      {
        _RCX = _RBX + 1;
        for ( j = &_RBX[1] <= _R8; _RCX != _R8; j = _RCX <= _R8 )
        {
          __asm
          {
            vmovsd  xmm2, qword ptr [rcx+60h]
            vcomiss xmm2, dword ptr [rbx+60h]
            vmovups ymm3, ymmword ptr [rcx]
            vmovups ymm4, ymmword ptr [rcx+20h]
            vmovups ymm5, ymmword ptr [rcx+40h]
          }
          if ( j )
          {
            __asm { vcomiss xmm2, dword ptr [rcx-8] }
            _RDX = (unsigned __int64)_RCX;
            _RAX = (unsigned __int64)&_RCX[-1];
            while ( !j )
            {
              __asm
              {
                vmovups ymm0, ymmword ptr [rax]
                vmovups ymmword ptr [rdx], ymm0
                vmovups ymm1, ymmword ptr [rax+20h]
                vmovups ymmword ptr [rdx+20h], ymm1
                vmovups ymm0, ymmword ptr [rax+40h]
                vmovups ymmword ptr [rdx+40h], ymm0
                vmovsd  xmm1, qword ptr [rax+60h]
                vmovsd  qword ptr [rdx+60h], xmm1
              }
              _RDX = _RAX;
              j = _RAX <= 0x68;
              _RAX -= 104i64;
              __asm { vcomiss xmm2, dword ptr [rax+60h] }
            }
            __asm
            {
              vmovups ymmword ptr [rdx], ymm3
              vmovups ymmword ptr [rdx+20h], ymm4
              vmovups ymmword ptr [rdx+40h], ymm5
              vmovsd  qword ptr [rdx+60h], xmm2
            }
          }
          else
          {
            _RAX = _RCX;
            while ( _RAX != _RBX )
            {
              __asm { vmovups ymm0, ymmword ptr [rax-68h] }
              --_RAX;
              __asm
              {
                vmovups ymmword ptr [rax+68h], ymm0
                vmovups ymm1, ymmword ptr [rax+20h]
                vmovups ymmword ptr [rax+88h], ymm1
                vmovups ymm0, ymmword ptr [rax+40h]
                vmovups ymmword ptr [rax+0A8h], ymm0
                vmovsd  xmm1, qword ptr [rax+60h]
                vmovsd  qword ptr [rax+0C8h], xmm1
              }
            }
            __asm
            {
              vmovups ymmword ptr [rbx], ymm3
              vmovups ymmword ptr [rbx+20h], ymm4
              vmovups ymmword ptr [rbx+40h], ymm5
              vmovsd  qword ptr [rbx+60h], xmm2
            }
          }
          ++_RCX;
        }
      }
      for ( k = _R8 <= last; _R8 != last; k = _R8 <= last )
      {
        __asm
        {
          vmovsd  xmm2, qword ptr [r8+60h]
          vcomiss xmm2, dword ptr [r8-8]
          vmovups ymm3, ymmword ptr [r8]
          vmovups ymm4, ymmword ptr [r8+20h]
          vmovups ymm5, ymmword ptr [r8+40h]
        }
        _RCX = (unsigned __int64)_R8;
        _RAX = (unsigned __int64)&_R8[-1];
        if ( !k )
        {
          do
          {
            __asm
            {
              vmovups ymm0, ymmword ptr [rax]
              vmovups ymmword ptr [rcx], ymm0
              vmovups ymm1, ymmword ptr [rax+20h]
              vmovups ymmword ptr [rcx+20h], ymm1
              vmovups ymm0, ymmword ptr [rax+40h]
              vmovups ymmword ptr [rcx+40h], ymm0
              vmovsd  xmm1, qword ptr [rax+60h]
              vmovsd  qword ptr [rcx+60h], xmm1
            }
            _RCX = _RAX;
            j = _RAX <= 0x68;
            _RAX -= 104i64;
            __asm { vcomiss xmm2, dword ptr [rax+60h] }
          }
          while ( !j );
        }
        __asm
        {
          vmovups ymmword ptr [rcx], ymm3
          vmovups ymmword ptr [rcx+20h], ymm4
        }
        ++_R8;
        __asm
        {
          vmovups ymmword ptr [rcx+40h], ymm5
          vmovsd  qword ptr [rcx+60h], xmm2
        }
      }
    }
  }
}

/*
==============
ntl::sort<EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge>
==============
*/
void ntl::sort<EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge>(EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *first, EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *last, EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *compare)
{
  EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge v4; 
  ntl::random_access_iterator_tag v5; 

  __asm
  {
    vmovups xmm0, xmmword ptr [r8]
    vmovups xmmword ptr [rsp+38h+var_18.edgeId.m_edgeIndex], xmm0
  }
  ntl::sort<EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge>(first, last, &v4, v5);
}

/*
==============
ntl::sort<EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge>
==============
*/
void ntl::sort<EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge>(EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *first, EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *last, EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *compare, ntl::random_access_iterator_tag __formal)
{
  signed __int64 v7; 
  unsigned __int64 v8; 
  bool j; 
  bool k; 
  bool i; 
  EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge v35; 
  EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *v36; 

  if ( first != last )
  {
    v36 = first;
    _R9 = compare;
    _RBX = first;
    v7 = last - first;
    if ( v7 )
      v8 = 63 - __lzcnt(v7);
    else
      v8 = 0i64;
    __asm
    {
      vmovups xmm0, xmmword ptr [r9]
      vmovups xmmword ptr [rsp+38h+var_18.edgeId.m_edgeIndex], xmm0
    }
    ntl::internal::introsort_loop<EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQueryFrustum>::SelectedEdge>(&v36, last, 2 * v8, &v35);
    if ( v7 <= 16 )
    {
      _RCX = _RBX + 1;
      for ( i = &_RBX[1] < last; _RCX != last; i = _RCX < last )
      {
        __asm
        {
          vmovups xmm2, xmmword ptr [rcx]
          vshufps xmm1, xmm2, xmm2, 0AAh ; ''
          vcomiss xmm1, dword ptr [rbx+8]
        }
        if ( i )
        {
          _RAX = _RCX;
          while ( _RAX != _RBX )
          {
            __asm { vmovups xmm0, xmmword ptr [rax-10h] }
            --_RAX;
            __asm { vmovups xmmword ptr [rax+10h], xmm0 }
          }
          __asm { vmovups xmmword ptr [rbx], xmm2 }
        }
        else
        {
          __asm { vcomiss xmm1, dword ptr [rcx-8] }
          _RDX = (unsigned __int64)_RCX;
          _RAX = (unsigned __int64)&_RCX[-1];
          if ( i )
          {
            do
            {
              __asm
              {
                vmovups xmm0, xmmword ptr [rax]
                vmovups xmmword ptr [rdx], xmm0
              }
              _RDX = _RAX;
              j = _RAX < 0x10;
              _RAX -= 16i64;
              __asm { vcomiss xmm1, dword ptr [rax+8] }
            }
            while ( j );
          }
          __asm { vmovups xmmword ptr [rdx], xmm2 }
        }
        ++_RCX;
      }
    }
    else
    {
      _RDX = _RBX + 16;
      if ( _RBX != &_RBX[16] )
      {
        _RCX = _RBX + 1;
        for ( j = &_RBX[1] < _RDX; _RCX != _RDX; j = _RCX < _RDX )
        {
          __asm
          {
            vmovups xmm2, xmmword ptr [rcx]
            vshufps xmm1, xmm2, xmm2, 0AAh ; ''
            vcomiss xmm1, dword ptr [rbx+8]
          }
          if ( j )
          {
            _RAX = _RCX;
            while ( _RAX != _RBX )
            {
              __asm { vmovups xmm0, xmmword ptr [rax-10h] }
              --_RAX;
              __asm { vmovups xmmword ptr [rax+10h], xmm0 }
            }
            __asm { vmovups xmmword ptr [rbx], xmm2 }
          }
          else
          {
            __asm { vcomiss xmm1, dword ptr [rcx-8] }
            _R8 = (unsigned __int64)_RCX;
            _RAX = (unsigned __int64)&_RCX[-1];
            while ( j )
            {
              __asm
              {
                vmovups xmm0, xmmword ptr [rax]
                vmovups xmmword ptr [r8], xmm0
              }
              _R8 = _RAX;
              j = _RAX < 0x10;
              _RAX -= 16i64;
              __asm { vcomiss xmm1, dword ptr [rax+8] }
            }
            __asm { vmovups xmmword ptr [r8], xmm2 }
          }
          ++_RCX;
        }
      }
      for ( k = _RDX < last; _RDX != last; k = _RDX < last )
      {
        __asm
        {
          vmovups xmm2, xmmword ptr [rdx]
          vshufps xmm1, xmm2, xmm2, 0AAh ; ''
          vcomiss xmm1, dword ptr [rdx-8]
        }
        _RCX = (unsigned __int64)_RDX;
        _RAX = (unsigned __int64)&_RDX[-1];
        if ( k )
        {
          do
          {
            __asm
            {
              vmovups xmm0, xmmword ptr [rax]
              vmovups xmmword ptr [rcx], xmm0
            }
            _RCX = _RAX;
            j = _RAX < 0x10;
            _RAX -= 16i64;
            __asm { vcomiss xmm1, dword ptr [rax+8] }
          }
          while ( j );
        }
        ++_RDX;
        __asm { vmovups xmmword ptr [rcx], xmm2 }
      }
    }
  }
}

/*
==============
ntl::sort<EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge>
==============
*/
void ntl::sort<EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge>(EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *first, EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *last, EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *compare)
{
  EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge v4; 
  ntl::random_access_iterator_tag v5; 

  __asm
  {
    vmovups xmm0, xmmword ptr [r8]
    vmovups xmmword ptr [rsp+38h+var_18.edgeId.m_edgeIndex], xmm0
  }
  ntl::sort<EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge>(first, last, &v4, v5);
}

/*
==============
ntl::sort<EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge>
==============
*/
void ntl::sort<EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge>(EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *first, EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *last, EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *compare, ntl::random_access_iterator_tag __formal)
{
  signed __int64 v7; 
  unsigned __int64 v8; 
  bool j; 
  bool k; 
  bool i; 
  EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge v35; 
  EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *v36; 

  if ( first != last )
  {
    v36 = first;
    _R9 = compare;
    _RBX = first;
    v7 = last - first;
    if ( v7 )
      v8 = 63 - __lzcnt(v7);
    else
      v8 = 0i64;
    __asm
    {
      vmovups xmm0, xmmword ptr [r9]
      vmovups xmmword ptr [rsp+38h+var_18.edgeId.m_edgeIndex], xmm0
    }
    ntl::internal::introsort_loop<EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge *,EdgeOctreeQuery<EdgeOctreeQuerySphere>::SelectedEdge>(&v36, last, 2 * v8, &v35);
    if ( v7 <= 16 )
    {
      _RCX = _RBX + 1;
      for ( i = &_RBX[1] < last; _RCX != last; i = _RCX < last )
      {
        __asm
        {
          vmovups xmm2, xmmword ptr [rcx]
          vshufps xmm1, xmm2, xmm2, 0AAh ; ''
          vcomiss xmm1, dword ptr [rbx+8]
        }
        if ( i )
        {
          _RAX = _RCX;
          while ( _RAX != _RBX )
          {
            __asm { vmovups xmm0, xmmword ptr [rax-10h] }
            --_RAX;
            __asm { vmovups xmmword ptr [rax+10h], xmm0 }
          }
          __asm { vmovups xmmword ptr [rbx], xmm2 }
        }
        else
        {
          __asm { vcomiss xmm1, dword ptr [rcx-8] }
          _RDX = (unsigned __int64)_RCX;
          _RAX = (unsigned __int64)&_RCX[-1];
          if ( i )
          {
            do
            {
              __asm
              {
                vmovups xmm0, xmmword ptr [rax]
                vmovups xmmword ptr [rdx], xmm0
              }
              _RDX = _RAX;
              j = _RAX < 0x10;
              _RAX -= 16i64;
              __asm { vcomiss xmm1, dword ptr [rax+8] }
            }
            while ( j );
          }
          __asm { vmovups xmmword ptr [rdx], xmm2 }
        }
        ++_RCX;
      }
    }
    else
    {
      _RDX = _RBX + 16;
      if ( _RBX != &_RBX[16] )
      {
        _RCX = _RBX + 1;
        for ( j = &_RBX[1] < _RDX; _RCX != _RDX; j = _RCX < _RDX )
        {
          __asm
          {
            vmovups xmm2, xmmword ptr [rcx]
            vshufps xmm1, xmm2, xmm2, 0AAh ; ''
            vcomiss xmm1, dword ptr [rbx+8]
          }
          if ( j )
          {
            _RAX = _RCX;
            while ( _RAX != _RBX )
            {
              __asm { vmovups xmm0, xmmword ptr [rax-10h] }
              --_RAX;
              __asm { vmovups xmmword ptr [rax+10h], xmm0 }
            }
            __asm { vmovups xmmword ptr [rbx], xmm2 }
          }
          else
          {
            __asm { vcomiss xmm1, dword ptr [rcx-8] }
            _R8 = (unsigned __int64)_RCX;
            _RAX = (unsigned __int64)&_RCX[-1];
            while ( j )
            {
              __asm
              {
                vmovups xmm0, xmmword ptr [rax]
                vmovups xmmword ptr [r8], xmm0
              }
              _R8 = _RAX;
              j = _RAX < 0x10;
              _RAX -= 16i64;
              __asm { vcomiss xmm1, dword ptr [rax+8] }
            }
            __asm { vmovups xmmword ptr [r8], xmm2 }
          }
          ++_RCX;
        }
      }
      for ( k = _RDX < last; _RDX != last; k = _RDX < last )
      {
        __asm
        {
          vmovups xmm2, xmmword ptr [rdx]
          vshufps xmm1, xmm2, xmm2, 0AAh ; ''
          vcomiss xmm1, dword ptr [rdx-8]
        }
        _RCX = (unsigned __int64)_RDX;
        _RAX = (unsigned __int64)&_RDX[-1];
        if ( k )
        {
          do
          {
            __asm
            {
              vmovups xmm0, xmmword ptr [rax]
              vmovups xmmword ptr [rcx], xmm0
            }
            _RCX = _RAX;
            j = _RAX < 0x10;
            _RAX -= 16i64;
            __asm { vcomiss xmm1, dword ptr [rax+8] }
          }
          while ( j );
        }
        ++_RDX;
        __asm { vmovups xmmword ptr [rcx], xmm2 }
      }
    }
  }
}

/*
==============
ntl::internal::introsort_loop<CachedLookup::Entry *,CachedLookup::SortFunc>
==============
*/
void ntl::internal::introsort_loop<CachedLookup::Entry *,CachedLookup::SortFunc>(CachedLookup::Entry *const *r_iBegin, CachedLookup::Entry *iEnd, unsigned __int64 depthLimit, CachedLookup::SortFunc predicate)
{
  CachedLookup::Entry *v7; 
  unsigned __int64 address; 
  unsigned __int64 v10; 
  unsigned __int64 v12; 
  bool v13; 
  CachedLookup::Entry *v18; 
  __int64 v19; 
  __int64 v20; 
  __int64 v21; 
  __int64 i; 
  __int64 v25; 
  __int64 v26; 
  __int64 v29; 
  __int64 j; 
  CachedLookup::Entry *v43; 
  CachedLookup::Entry *v44; 
  __int64 v48; 
  __int64 v49; 
  __int64 v52; 
  bool v53; 
  __int64 v55; 
  __int64 k; 
  __int128 v69; 
  __int128 v70; 
  __int128 v72; 
  CachedLookup::Entry *r_iBegina; 

  _R9 = *r_iBegin;
  v7 = iEnd;
  if ( (__int64)(((char *)iEnd - (char *)*r_iBegin) & 0xFFFFFFFFFFFFFFF0ui64) <= 256 )
    return;
  while ( depthLimit )
  {
    address = v7[-1].address;
    --depthLimit;
    v10 = _R9->address;
    _RAX = &_R9[(v7 - _R9) / 2];
    v12 = _RAX->address;
    if ( _R9->address >= _RAX->address )
    {
      if ( v10 >= address )
      {
        v13 = v12 < address;
LABEL_9:
        if ( v13 )
          _RAX = v7 - 1;
        goto LABEL_11;
      }
      _RAX = _R9;
    }
    else if ( v12 >= address )
    {
      _RAX = _R9;
      v13 = v10 < address;
      goto LABEL_9;
    }
LABEL_11:
    __asm
    {
      vmovups xmm0, xmmword ptr [rax]
      vmovups [rsp+68h+var_38], xmm0
    }
    _RAX = v7;
    while ( 1 )
    {
      if ( v10 < (unsigned __int64)v69 )
      {
        do
          ++_R9;
        while ( _R9->address < (unsigned __int64)v69 );
      }
      for ( --_RAX; (unsigned __int64)v69 < _RAX->address; --_RAX )
        ;
      if ( _R9 >= _RAX )
        break;
      __asm
      {
        vmovups xmm1, xmmword ptr [r9]
        vmovups xmm0, xmmword ptr [rax]
        vmovups xmmword ptr [r9], xmm0
      }
      ++_R9;
      __asm { vmovups xmmword ptr [rax], xmm1 }
      v10 = _R9->address;
    }
    r_iBegina = _R9;
    ntl::internal::introsort_loop<CachedLookup::Entry *,CachedLookup::SortFunc>(&r_iBegina, v7, depthLimit, predicate);
    v7 = r_iBegina;
    _R9 = *r_iBegin;
    if ( (__int64)(((char *)r_iBegina - (char *)*r_iBegin) & 0xFFFFFFFFFFFFFFF0ui64) <= 256 )
      return;
  }
  if ( _R9 > v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\utility\\sort.h", 121, ASSERT_TYPE_ASSERT, "( r_iBegin <= r_iMid )", (const char *)&queryFormat, "r_iBegin <= r_iMid") )
    __debugbreak();
  v18 = *r_iBegin;
  v19 = v7 - *r_iBegin;
  if ( v19 >= 2 )
  {
    v20 = (v19 - 2) / 2;
    v21 = v20;
    _RBP = 16 * v20;
    for ( i = 2 * v20 + 2; ; i -= 2i64 )
    {
      _RCX = *r_iBegin;
      v25 = v21;
      v26 = i;
      __asm
      {
        vmovups xmm1, xmmword ptr [rcx+rbp]
        vmovups [rsp+68h+var_38], xmm1
      }
      if ( i < v19 )
      {
        do
        {
          _R8 = *r_iBegin;
          v29 = v26 - 1;
          if ( (*r_iBegin)[v26].address >= (*r_iBegin)[v26 - 1].address )
            v29 = v26;
          _R9 = 2 * v25;
          _RAX = 2 * v29;
          v26 = 2 * v29 + 2;
          __asm
          {
            vmovups xmm0, xmmword ptr [r8+rax*8]
            vmovups xmmword ptr [r8+r9*8], xmm0
          }
          v25 = v29;
        }
        while ( v26 < v19 );
        _RCX = *r_iBegin;
      }
      if ( v26 == v19 )
      {
        _RAX = 2 * v26;
        _R9 = 2 * v25;
        __asm
        {
          vmovups xmm0, xmmword ptr [rcx+rax*8-10h]
          vmovups xmmword ptr [rcx+r9*8], xmm0
        }
        v25 = v26 - 1;
      }
      for ( j = (v25 - 1) / 2; v25 > v21; j = (j - 1) / 2 )
      {
        _RDX = *r_iBegin;
        _RCX = 2 * j;
        if ( (*r_iBegin)[j].address >= (unsigned __int64)v70 )
          break;
        __asm { vmovups xmm0, xmmword ptr [rdx+rcx*8] }
        _R9 = 2 * v25;
        __asm { vmovups xmmword ptr [rdx+r9*8], xmm0 }
        v25 = j;
      }
      _RAX = *r_iBegin;
      _R9 = 2 * v25;
      __asm { vmovups xmmword ptr [rax+r9*8], xmm1 }
      if ( !v21 )
        break;
      --v21;
      _RBP -= 16i64;
    }
    v18 = *r_iBegin;
  }
  v43 = v18 + 1;
  while ( v7 > v43 )
  {
    v44 = v7--;
    _RBX = v44 - 1;
    __asm
    {
      vmovups xmm1, xmmword ptr [rbx]
      vmovups [rsp+68h+var_38], xmm1
      vmovups [rsp+68h+var_28], xmm1
    }
    if ( _RBX < *r_iBegin )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\utility\\heap_sort.h", 206, ASSERT_TYPE_ASSERT, "( r_iEnd >= r_iBegin )", (const char *)&queryFormat, "r_iEnd >= r_iBegin") )
        __debugbreak();
      __asm { vmovups xmm1, [rsp+68h+var_38] }
    }
    _RAX = *r_iBegin;
    v48 = 0i64;
    v49 = 2i64;
    __asm
    {
      vmovups xmm0, xmmword ptr [rax]
      vmovups xmmword ptr [rbx], xmm0
    }
    _RCX = *r_iBegin;
    v52 = _RBX - *r_iBegin;
    v53 = v52 == 2;
    if ( v52 > 2 )
    {
      do
      {
        _R8 = *r_iBegin;
        v55 = v49 - 1;
        if ( (*r_iBegin)[v49].address >= (*r_iBegin)[v49 - 1].address )
          v55 = v49;
        _R9 = 2 * v48;
        _RAX = 2 * v55;
        v49 = 2 * v55 + 2;
        __asm
        {
          vmovups xmm0, xmmword ptr [r8+rax*8]
          vmovups xmmword ptr [r8+r9*8], xmm0
        }
        v48 = v55;
        v53 = v49 == v52;
      }
      while ( v49 < v52 );
      _RCX = *r_iBegin;
    }
    if ( v53 )
    {
      _RAX = 2 * v49;
      _R9 = 2 * v48;
      __asm
      {
        vmovups xmm0, xmmword ptr [rcx+rax*8-10h]
        vmovups xmmword ptr [rcx+r9*8], xmm0
      }
      v48 = v49 - 1;
    }
    for ( k = (v48 - 1) / 2; v48 > 0; k = (k - 1) / 2 )
    {
      _RDX = *r_iBegin;
      _RCX = 2 * k;
      if ( (*r_iBegin)[k].address >= (unsigned __int64)v72 )
        break;
      __asm { vmovups xmm0, xmmword ptr [rdx+rcx*8] }
      _R9 = 2 * v48;
      __asm { vmovups xmmword ptr [rdx+r9*8], xmm0 }
      v48 = k;
    }
    _RAX = *r_iBegin;
    _R9 = 2 * v48;
    __asm { vmovups xmmword ptr [rax+r9*8], xmm1 }
  }
}

/*
==============
ntl::sort<CachedLookup::Entry *,CachedLookup::SortFunc>
==============
*/
void ntl::sort<CachedLookup::Entry *,CachedLookup::SortFunc>(CachedLookup::Entry *first, CachedLookup::Entry *last, CachedLookup::SortFunc compare)
{
  ntl::random_access_iterator_tag v3; 

  ntl::sort<CachedLookup::Entry *,CachedLookup::SortFunc>(first, last, compare, v3);
}

/*
==============
ntl::sort<CachedLookup::Entry *,CachedLookup::SortFunc>
==============
*/
void ntl::sort<CachedLookup::Entry *,CachedLookup::SortFunc>(CachedLookup::Entry *first, CachedLookup::Entry *last, CachedLookup::SortFunc compare, ntl::random_access_iterator_tag __formal)
{
  signed __int64 v7; 
  unsigned __int64 v8; 
  CachedLookup::Entry *r_iBegin; 

  if ( first != last )
  {
    r_iBegin = first;
    _RBX = first;
    v7 = last - first;
    if ( v7 )
      v8 = 63 - __lzcnt(v7);
    else
      v8 = 0i64;
    ntl::internal::introsort_loop<CachedLookup::Entry *,CachedLookup::SortFunc>(&r_iBegin, last, 2 * v8, compare);
    if ( v7 <= 16 )
    {
      for ( _RCX = _RBX + 1; _RCX != last; ++_RCX )
      {
        __asm
        {
          vmovups xmm1, xmmword ptr [rcx]
          vmovq   rax, xmm1
        }
        if ( _RAX >= _RBX->address )
        {
          _RAX = _RCX - 1;
          _RDX = _RCX;
          __asm { vmovq   r8, xmm1 }
          if ( _R8 < _RCX[-1].address )
          {
            do
            {
              __asm
              {
                vmovups xmm0, xmmword ptr [rax]
                vmovups xmmword ptr [rdx], xmm0
              }
              _RDX = _RAX--;
            }
            while ( _R8 < _RAX->address );
          }
          __asm { vmovups xmmword ptr [rdx], xmm1 }
        }
        else
        {
          _RAX = _RCX;
          while ( _RAX != _RBX )
          {
            __asm { vmovups xmm0, xmmword ptr [rax-10h] }
            --_RAX;
            __asm { vmovups xmmword ptr [rax+10h], xmm0 }
          }
          __asm { vmovups xmmword ptr [rbx], xmm1 }
        }
      }
    }
    else
    {
      _RDX = _RBX + 16;
      if ( _RBX != &_RBX[16] )
      {
        for ( _RCX = _RBX + 1; _RCX != _RDX; ++_RCX )
        {
          __asm
          {
            vmovups xmm1, xmmword ptr [rcx]
            vmovq   rax, xmm1
          }
          if ( _RAX >= _RBX->address )
          {
            _RAX = _RCX - 1;
            _R8 = _RCX;
            __asm { vmovq   r9, xmm1 }
            if ( _R9 < _RCX[-1].address )
            {
              do
              {
                __asm
                {
                  vmovups xmm0, xmmword ptr [rax]
                  vmovups xmmword ptr [r8], xmm0
                }
                _R8 = _RAX--;
              }
              while ( _R9 < _RAX->address );
            }
            __asm { vmovups xmmword ptr [r8], xmm1 }
          }
          else
          {
            _RAX = _RCX;
            while ( _RAX != _RBX )
            {
              __asm { vmovups xmm0, xmmword ptr [rax-10h] }
              --_RAX;
              __asm { vmovups xmmword ptr [rax+10h], xmm0 }
            }
            __asm { vmovups xmmword ptr [rbx], xmm1 }
          }
        }
      }
      while ( _RDX != last )
      {
        __asm
        {
          vmovups xmm1, xmmword ptr [rdx]
          vmovq   r8, xmm1
        }
        _RAX = _RDX - 1;
        for ( _RCX = _RDX; _R8 < _RAX->address; --_RAX )
        {
          __asm
          {
            vmovups xmm0, xmmword ptr [rax]
            vmovups xmmword ptr [rcx], xmm0
          }
          _RCX = _RAX;
        }
        ++_RDX;
        __asm { vmovups xmmword ptr [rcx], xmm1 }
      }
    }
  }
}

/*
==============
ntl::internal::introsort_loop<dropBagClusterInfo_t * *,ClusterPotentialPlayersPredicate>
==============
*/
void ntl::internal::introsort_loop<dropBagClusterInfo_t * *,ClusterPotentialPlayersPredicate>(dropBagClusterInfo_t **const *r_iBegin, dropBagClusterInfo_t **iEnd, unsigned __int64 depthLimit, ClusterPotentialPlayersPredicate predicate)
{
  dropBagClusterInfo_t **v4; 
  dropBagClusterInfo_t **v7; 
  dropBagClusterInfo_t *v9; 
  unsigned __int64 m_size; 
  dropBagClusterInfo_t *v11; 
  unsigned __int64 v12; 
  unsigned __int64 v13; 
  bool v14; 
  dropBagClusterInfo_t **v15; 
  unsigned __int64 v16; 
  dropBagClusterInfo_t *v17; 
  __int64 v18; 
  __int64 v19; 
  dropBagClusterInfo_t *v20; 
  dropBagClusterInfo_t **v21; 
  __int64 v22; 
  __int64 v23; 
  __int64 i; 
  dropBagClusterInfo_t **v25; 
  __int64 v26; 
  __int64 v27; 
  dropBagClusterInfo_t *v28; 
  __int64 v29; 
  __int64 j; 
  dropBagClusterInfo_t *v31; 
  dropBagClusterInfo_t **k; 
  dropBagClusterInfo_t **v33; 
  dropBagClusterInfo_t **v34; 
  dropBagClusterInfo_t *v35; 
  __int64 v36; 
  __int64 v37; 
  dropBagClusterInfo_t **v38; 
  __int64 v39; 
  bool v40; 
  __int64 v41; 
  __int64 m; 
  dropBagClusterInfo_t *v43; 
  dropBagClusterInfo_t **r_iBegina; 

  v4 = *r_iBegin;
  v7 = iEnd;
  if ( (__int64)(((char *)iEnd - (char *)*r_iBegin) & 0xFFFFFFFFFFFFFFF8ui64) <= 128 )
    return;
  while ( depthLimit )
  {
    --depthLimit;
    v9 = *v4;
    m_size = (*v4)->potentialPlayers.m_size;
    v11 = v4[(v7 - v4) / 2];
    v12 = (*(v7 - 1))->potentialPlayers.m_size;
    v13 = v11->potentialPlayers.m_size;
    if ( m_size >= v13 )
    {
      if ( m_size >= v12 )
      {
        v14 = v13 < v12;
LABEL_9:
        if ( v14 )
          v11 = *(v7 - 1);
        goto LABEL_11;
      }
      v11 = *v4;
    }
    else if ( v13 >= v12 )
    {
      v11 = *v4;
      v14 = m_size < v12;
      goto LABEL_9;
    }
LABEL_11:
    v15 = v7;
    while ( 1 )
    {
      v16 = v11->potentialPlayers.m_size;
      if ( v9->potentialPlayers.m_size < v16 )
      {
        do
        {
          v17 = v4[1];
          ++v4;
        }
        while ( v17->potentialPlayers.m_size < v16 );
      }
      v18 = (__int64)*--v15;
      if ( v16 < *(_QWORD *)(v18 + 272) )
      {
        do
          v19 = (__int64)*--v15;
        while ( v16 < *(_QWORD *)(v19 + 272) );
      }
      if ( v4 >= v15 )
        break;
      v20 = *v4;
      *v4++ = *v15;
      *v15 = v20;
      v9 = *v4;
    }
    r_iBegina = v4;
    ntl::internal::introsort_loop<dropBagClusterInfo_t * *,ClusterPotentialPlayersPredicate>(&r_iBegina, v7, depthLimit, predicate);
    v7 = r_iBegina;
    v4 = *r_iBegin;
    if ( (__int64)(((char *)r_iBegina - (char *)*r_iBegin) & 0xFFFFFFFFFFFFFFF8ui64) <= 128 )
      return;
  }
  if ( v4 > v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\utility\\sort.h", 121, ASSERT_TYPE_ASSERT, "( r_iBegin <= r_iMid )", (const char *)&queryFormat, "r_iBegin <= r_iMid") )
    __debugbreak();
  v21 = *r_iBegin;
  v22 = v7 - *r_iBegin;
  if ( v22 >= 2 )
  {
    v23 = (v22 - 2) / 2;
    for ( i = 2 * v23 + 2; ; i -= 2i64 )
    {
      v25 = *r_iBegin;
      v26 = v23;
      v27 = i;
      v28 = (*r_iBegin)[v23];
      if ( i < v22 )
      {
        do
        {
          v29 = v27 - 1;
          if ( (*r_iBegin)[v27]->potentialPlayers.m_size >= (*r_iBegin)[v27 - 1]->potentialPlayers.m_size )
            v29 = v27;
          v27 = 2 * v29 + 2;
          (*r_iBegin)[v26] = (*r_iBegin)[v29];
          v26 = v29;
        }
        while ( v27 < v22 );
        v25 = *r_iBegin;
      }
      if ( v27 == v22 )
      {
        v25[v26] = v25[v27 - 1];
        v26 = v27 - 1;
      }
      for ( j = (v26 - 1) / 2; v26 > v23; j = (j - 1) / 2 )
      {
        v31 = (*r_iBegin)[j];
        if ( v31->potentialPlayers.m_size >= v28->potentialPlayers.m_size )
          break;
        (*r_iBegin)[v26] = v31;
        v26 = j;
      }
      (*r_iBegin)[v26] = v28;
      if ( !v23 )
        break;
      --v23;
    }
    v21 = *r_iBegin;
  }
  for ( k = v21 + 1; v7 > k; (*r_iBegin)[v36] = v35 )
  {
    v33 = v7--;
    v34 = v33 - 1;
    v35 = *v34;
    if ( v34 < *r_iBegin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\utility\\heap_sort.h", 206, ASSERT_TYPE_ASSERT, "( r_iEnd >= r_iBegin )", (const char *)&queryFormat, "r_iEnd >= r_iBegin") )
      __debugbreak();
    v36 = 0i64;
    v37 = 2i64;
    *v34 = **r_iBegin;
    v38 = *r_iBegin;
    v39 = v34 - *r_iBegin;
    v40 = v39 == 2;
    if ( v39 > 2 )
    {
      do
      {
        v41 = v37 - 1;
        if ( (*r_iBegin)[v37]->potentialPlayers.m_size >= (*r_iBegin)[v37 - 1]->potentialPlayers.m_size )
          v41 = v37;
        v37 = 2 * v41 + 2;
        (*r_iBegin)[v36] = (*r_iBegin)[v41];
        v36 = v41;
        v40 = v37 == v39;
      }
      while ( v37 < v39 );
      v38 = *r_iBegin;
    }
    if ( v40 )
    {
      v38[v36] = v38[v37 - 1];
      v36 = v37 - 1;
    }
    for ( m = (v36 - 1) / 2; v36 > 0; m = (m - 1) / 2 )
    {
      v43 = (*r_iBegin)[m];
      if ( v43->potentialPlayers.m_size >= v35->potentialPlayers.m_size )
        break;
      (*r_iBegin)[v36] = v43;
      v36 = m;
    }
  }
}

/*
==============
ntl::internal::introsort_loop<dropBagPlayerInfo_t * *,PlayerPotentialPartnersPredicate>
==============
*/
void ntl::internal::introsort_loop<dropBagPlayerInfo_t * *,PlayerPotentialPartnersPredicate>(dropBagPlayerInfo_t **const *r_iBegin, dropBagPlayerInfo_t **iEnd, unsigned __int64 depthLimit, PlayerPotentialPartnersPredicate predicate)
{
  dropBagPlayerInfo_t **v4; 
  dropBagPlayerInfo_t **v7; 
  dropBagPlayerInfo_t *v9; 
  unsigned __int64 m_size; 
  dropBagPlayerInfo_t *v11; 
  unsigned __int64 v12; 
  unsigned __int64 v13; 
  bool v14; 
  dropBagPlayerInfo_t **v15; 
  unsigned __int64 v16; 
  dropBagPlayerInfo_t *v17; 
  __int64 v18; 
  __int64 v19; 
  dropBagPlayerInfo_t *v20; 
  dropBagPlayerInfo_t **v21; 
  __int64 v22; 
  __int64 v23; 
  __int64 i; 
  dropBagPlayerInfo_t **v25; 
  __int64 v26; 
  __int64 v27; 
  dropBagPlayerInfo_t *v28; 
  __int64 v29; 
  __int64 j; 
  dropBagPlayerInfo_t *v31; 
  dropBagPlayerInfo_t **k; 
  dropBagPlayerInfo_t **v33; 
  dropBagPlayerInfo_t **v34; 
  dropBagPlayerInfo_t *v35; 
  __int64 v36; 
  __int64 v37; 
  dropBagPlayerInfo_t **v38; 
  __int64 v39; 
  bool v40; 
  __int64 v41; 
  __int64 m; 
  dropBagPlayerInfo_t *v43; 
  dropBagPlayerInfo_t **r_iBegina; 

  v4 = *r_iBegin;
  v7 = iEnd;
  if ( (__int64)(((char *)iEnd - (char *)*r_iBegin) & 0xFFFFFFFFFFFFFFF8ui64) <= 128 )
    return;
  while ( depthLimit )
  {
    --depthLimit;
    v9 = *v4;
    m_size = (*v4)->potentialPartners.m_size;
    v11 = v4[(v7 - v4) / 2];
    v12 = (*(v7 - 1))->potentialPartners.m_size;
    v13 = v11->potentialPartners.m_size;
    if ( m_size >= v13 )
    {
      if ( m_size >= v12 )
      {
        v14 = v13 < v12;
LABEL_9:
        if ( v14 )
          v11 = *(v7 - 1);
        goto LABEL_11;
      }
      v11 = *v4;
    }
    else if ( v13 >= v12 )
    {
      v11 = *v4;
      v14 = m_size < v12;
      goto LABEL_9;
    }
LABEL_11:
    v15 = v7;
    while ( 1 )
    {
      v16 = v11->potentialPartners.m_size;
      if ( v9->potentialPartners.m_size < v16 )
      {
        do
        {
          v17 = v4[1];
          ++v4;
        }
        while ( v17->potentialPartners.m_size < v16 );
      }
      v18 = (__int64)*--v15;
      if ( v16 < *(_QWORD *)(v18 + 176) )
      {
        do
          v19 = (__int64)*--v15;
        while ( v16 < *(_QWORD *)(v19 + 176) );
      }
      if ( v4 >= v15 )
        break;
      v20 = *v4;
      *v4++ = *v15;
      *v15 = v20;
      v9 = *v4;
    }
    r_iBegina = v4;
    ntl::internal::introsort_loop<dropBagPlayerInfo_t * *,PlayerPotentialPartnersPredicate>(&r_iBegina, v7, depthLimit, predicate);
    v7 = r_iBegina;
    v4 = *r_iBegin;
    if ( (__int64)(((char *)r_iBegina - (char *)*r_iBegin) & 0xFFFFFFFFFFFFFFF8ui64) <= 128 )
      return;
  }
  if ( v4 > v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\utility\\sort.h", 121, ASSERT_TYPE_ASSERT, "( r_iBegin <= r_iMid )", (const char *)&queryFormat, "r_iBegin <= r_iMid") )
    __debugbreak();
  v21 = *r_iBegin;
  v22 = v7 - *r_iBegin;
  if ( v22 >= 2 )
  {
    v23 = (v22 - 2) / 2;
    for ( i = 2 * v23 + 2; ; i -= 2i64 )
    {
      v25 = *r_iBegin;
      v26 = v23;
      v27 = i;
      v28 = (*r_iBegin)[v23];
      if ( i < v22 )
      {
        do
        {
          v29 = v27 - 1;
          if ( (*r_iBegin)[v27]->potentialPartners.m_size >= (*r_iBegin)[v27 - 1]->potentialPartners.m_size )
            v29 = v27;
          v27 = 2 * v29 + 2;
          (*r_iBegin)[v26] = (*r_iBegin)[v29];
          v26 = v29;
        }
        while ( v27 < v22 );
        v25 = *r_iBegin;
      }
      if ( v27 == v22 )
      {
        v25[v26] = v25[v27 - 1];
        v26 = v27 - 1;
      }
      for ( j = (v26 - 1) / 2; v26 > v23; j = (j - 1) / 2 )
      {
        v31 = (*r_iBegin)[j];
        if ( v31->potentialPartners.m_size >= v28->potentialPartners.m_size )
          break;
        (*r_iBegin)[v26] = v31;
        v26 = j;
      }
      (*r_iBegin)[v26] = v28;
      if ( !v23 )
        break;
      --v23;
    }
    v21 = *r_iBegin;
  }
  for ( k = v21 + 1; v7 > k; (*r_iBegin)[v36] = v35 )
  {
    v33 = v7--;
    v34 = v33 - 1;
    v35 = *v34;
    if ( v34 < *r_iBegin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\utility\\heap_sort.h", 206, ASSERT_TYPE_ASSERT, "( r_iEnd >= r_iBegin )", (const char *)&queryFormat, "r_iEnd >= r_iBegin") )
      __debugbreak();
    v36 = 0i64;
    v37 = 2i64;
    *v34 = **r_iBegin;
    v38 = *r_iBegin;
    v39 = v34 - *r_iBegin;
    v40 = v39 == 2;
    if ( v39 > 2 )
    {
      do
      {
        v41 = v37 - 1;
        if ( (*r_iBegin)[v37]->potentialPartners.m_size >= (*r_iBegin)[v37 - 1]->potentialPartners.m_size )
          v41 = v37;
        v37 = 2 * v41 + 2;
        (*r_iBegin)[v36] = (*r_iBegin)[v41];
        v36 = v41;
        v40 = v37 == v39;
      }
      while ( v37 < v39 );
      v38 = *r_iBegin;
    }
    if ( v40 )
    {
      v38[v36] = v38[v37 - 1];
      v36 = v37 - 1;
    }
    for ( m = (v36 - 1) / 2; v36 > 0; m = (m - 1) / 2 )
    {
      v43 = (*r_iBegin)[m];
      if ( v43->potentialPartners.m_size >= v35->potentialPartners.m_size )
        break;
      (*r_iBegin)[v36] = v43;
      v36 = m;
    }
  }
}

/*
==============
ntl::sort<dropBagClusterInfo_t * *,ClusterPotentialPlayersPredicate>
==============
*/
void ntl::sort<dropBagClusterInfo_t * *,ClusterPotentialPlayersPredicate>(dropBagClusterInfo_t **first, dropBagClusterInfo_t **last, ClusterPotentialPlayersPredicate compare)
{
  ntl::random_access_iterator_tag v3; 

  ntl::sort<dropBagClusterInfo_t * *,ClusterPotentialPlayersPredicate>(first, last, compare, v3);
}

/*
==============
ntl::sort<dropBagClusterInfo_t * *,ClusterPotentialPlayersPredicate>
==============
*/
void ntl::sort<dropBagClusterInfo_t * *,ClusterPotentialPlayersPredicate>(dropBagClusterInfo_t **first, dropBagClusterInfo_t **last, ClusterPotentialPlayersPredicate compare, ntl::random_access_iterator_tag __formal)
{
  signed __int64 v7; 
  unsigned __int64 v8; 
  dropBagClusterInfo_t **v9; 
  dropBagClusterInfo_t **k; 
  dropBagClusterInfo_t *v11; 
  unsigned __int64 v12; 
  dropBagClusterInfo_t **m; 
  dropBagClusterInfo_t *v14; 
  dropBagClusterInfo_t *v15; 
  dropBagClusterInfo_t **v16; 
  dropBagClusterInfo_t **v17; 
  dropBagClusterInfo_t *v18; 
  dropBagClusterInfo_t **v19; 
  dropBagClusterInfo_t *v20; 
  dropBagClusterInfo_t **n; 
  dropBagClusterInfo_t **i; 
  dropBagClusterInfo_t *v23; 
  unsigned __int64 m_size; 
  dropBagClusterInfo_t **j; 
  dropBagClusterInfo_t *v26; 
  dropBagClusterInfo_t *v27; 
  dropBagClusterInfo_t **v28; 
  dropBagClusterInfo_t **v29; 
  dropBagClusterInfo_t **r_iBegin; 

  if ( first != last )
  {
    r_iBegin = first;
    v7 = last - first;
    if ( v7 )
      v8 = 63 - __lzcnt(v7);
    else
      v8 = 0i64;
    ntl::internal::introsort_loop<dropBagClusterInfo_t * *,ClusterPotentialPlayersPredicate>(&r_iBegin, last, 2 * v8, compare);
    if ( v7 <= 16 )
    {
      for ( i = first + 1; i != last; ++i )
      {
        v23 = *i;
        m_size = (*i)->potentialPlayers.m_size;
        if ( m_size >= (*first)->potentialPlayers.m_size )
        {
          v27 = *(i - 1);
          v28 = i - 1;
          v29 = i;
          if ( m_size < v27->potentialPlayers.m_size )
          {
            do
            {
              *v29 = v27;
              v29 = v28;
              v27 = *--v28;
            }
            while ( v23->potentialPlayers.m_size < v27->potentialPlayers.m_size );
          }
          *v29 = v23;
        }
        else
        {
          for ( j = i; j != first; j[1] = v26 )
            v26 = *--j;
          *first = v23;
        }
      }
    }
    else
    {
      v9 = first + 16;
      if ( first != first + 16 )
      {
        for ( k = first + 1; k != v9; ++k )
        {
          v11 = *k;
          v12 = (*k)->potentialPlayers.m_size;
          if ( v12 >= (*first)->potentialPlayers.m_size )
          {
            v15 = *(k - 1);
            v16 = k - 1;
            v17 = k;
            if ( v12 < v15->potentialPlayers.m_size )
            {
              do
              {
                *v17 = v15;
                v17 = v16;
                v15 = *--v16;
              }
              while ( v11->potentialPlayers.m_size < v15->potentialPlayers.m_size );
            }
            *v17 = v11;
          }
          else
          {
            for ( m = k; m != first; m[1] = v14 )
              v14 = *--m;
            *first = v11;
          }
        }
      }
      for ( ; v9 != last; *n = v20 )
      {
        v18 = *(v9 - 1);
        v19 = v9 - 1;
        v20 = *v9;
        for ( n = v9; v20->potentialPlayers.m_size < v18->potentialPlayers.m_size; --v19 )
        {
          *n = v18;
          n = v19;
          v18 = *(v19 - 1);
        }
        ++v9;
      }
    }
  }
}

/*
==============
ntl::sort<dropBagPlayerInfo_t * *,PlayerPotentialPartnersPredicate>
==============
*/
void ntl::sort<dropBagPlayerInfo_t * *,PlayerPotentialPartnersPredicate>(dropBagPlayerInfo_t **first, dropBagPlayerInfo_t **last, PlayerPotentialPartnersPredicate compare)
{
  ntl::random_access_iterator_tag v3; 

  ntl::sort<dropBagPlayerInfo_t * *,PlayerPotentialPartnersPredicate>(first, last, compare, v3);
}

/*
==============
ntl::sort<dropBagPlayerInfo_t * *,PlayerPotentialPartnersPredicate>
==============
*/
void ntl::sort<dropBagPlayerInfo_t * *,PlayerPotentialPartnersPredicate>(dropBagPlayerInfo_t **first, dropBagPlayerInfo_t **last, PlayerPotentialPartnersPredicate compare, ntl::random_access_iterator_tag __formal)
{
  signed __int64 v7; 
  unsigned __int64 v8; 
  dropBagPlayerInfo_t **v9; 
  dropBagPlayerInfo_t **k; 
  dropBagPlayerInfo_t *v11; 
  unsigned __int64 v12; 
  dropBagPlayerInfo_t **m; 
  dropBagPlayerInfo_t *v14; 
  dropBagPlayerInfo_t *v15; 
  dropBagPlayerInfo_t **v16; 
  dropBagPlayerInfo_t **v17; 
  dropBagPlayerInfo_t *v18; 
  dropBagPlayerInfo_t **v19; 
  dropBagPlayerInfo_t *v20; 
  dropBagPlayerInfo_t **n; 
  dropBagPlayerInfo_t **i; 
  dropBagPlayerInfo_t *v23; 
  unsigned __int64 m_size; 
  dropBagPlayerInfo_t **j; 
  dropBagPlayerInfo_t *v26; 
  dropBagPlayerInfo_t *v27; 
  dropBagPlayerInfo_t **v28; 
  dropBagPlayerInfo_t **v29; 
  dropBagPlayerInfo_t **r_iBegin; 

  if ( first != last )
  {
    r_iBegin = first;
    v7 = last - first;
    if ( v7 )
      v8 = 63 - __lzcnt(v7);
    else
      v8 = 0i64;
    ntl::internal::introsort_loop<dropBagPlayerInfo_t * *,PlayerPotentialPartnersPredicate>(&r_iBegin, last, 2 * v8, compare);
    if ( v7 <= 16 )
    {
      for ( i = first + 1; i != last; ++i )
      {
        v23 = *i;
        m_size = (*i)->potentialPartners.m_size;
        if ( m_size >= (*first)->potentialPartners.m_size )
        {
          v27 = *(i - 1);
          v28 = i - 1;
          v29 = i;
          if ( m_size < v27->potentialPartners.m_size )
          {
            do
            {
              *v29 = v27;
              v29 = v28;
              v27 = *--v28;
            }
            while ( v23->potentialPartners.m_size < v27->potentialPartners.m_size );
          }
          *v29 = v23;
        }
        else
        {
          for ( j = i; j != first; j[1] = v26 )
            v26 = *--j;
          *first = v23;
        }
      }
    }
    else
    {
      v9 = first + 16;
      if ( first != first + 16 )
      {
        for ( k = first + 1; k != v9; ++k )
        {
          v11 = *k;
          v12 = (*k)->potentialPartners.m_size;
          if ( v12 >= (*first)->potentialPartners.m_size )
          {
            v15 = *(k - 1);
            v16 = k - 1;
            v17 = k;
            if ( v12 < v15->potentialPartners.m_size )
            {
              do
              {
                *v17 = v15;
                v17 = v16;
                v15 = *--v16;
              }
              while ( v11->potentialPartners.m_size < v15->potentialPartners.m_size );
            }
            *v17 = v11;
          }
          else
          {
            for ( m = k; m != first; m[1] = v14 )
              v14 = *--m;
            *first = v11;
          }
        }
      }
      for ( ; v9 != last; *n = v20 )
      {
        v18 = *(v9 - 1);
        v19 = v9 - 1;
        v20 = *v9;
        for ( n = v9; v20->potentialPartners.m_size < v18->potentialPartners.m_size; --v19 )
        {
          *n = v18;
          n = v19;
          v18 = *(v19 - 1);
        }
        ++v9;
      }
    }
  }
}

/*
==============
ntl::internal::introsort_loop<IWMemAllocator * *,AllocatorSortFunctor>
==============
*/
void ntl::internal::introsort_loop<IWMemAllocator * *,AllocatorSortFunctor>(IWMemAllocator **const *r_iBegin, IWMemAllocator **iEnd, unsigned __int64 depthLimit, AllocatorSortFunctor predicate)
{
  const IWMemAllocator **v4; 
  IWMemAllocator **v6; 
  IWMemAllocator **const *v7; 
  const IWMemAllocator **v8; 
  const IWMemAllocator **v9; 
  bool v10; 
  const IWMemAllocator *v11; 
  bool v12; 
  const IWMemAllocator *v13; 
  IWMemAllocator **v14; 
  IWMemAllocator **i; 
  IWMemAllocator *v16; 
  unsigned __int64 m_address; 
  IWMemAllocatorType m_type; 
  unsigned __int64 v19; 
  unsigned __int64 v20; 
  IWMemAllocatorType v21; 
  IWMemAllocator *v22; 
  IWMemAllocator **v23; 
  __int64 v24; 
  __int64 v25; 
  __int64 j; 
  IWMemAllocator **v27; 
  __int64 v28; 
  __int64 v29; 
  unsigned __int64 v30; 
  IWMemAllocator *v31; 
  IWMemAllocator *v32; 
  unsigned __int64 v33; 
  bool v34; 
  IWMemAllocatorType v35; 
  __int64 v36; 
  __int64 v37; 
  IWMemAllocator *v38; 
  unsigned __int64 v39; 
  IWMemAllocatorType v40; 
  IWMemAllocator **const *v41; 
  IWMemAllocator **v42; 
  IWMemAllocator **v43; 
  unsigned __int64 v44; 
  __int64 v45; 
  __int64 v46; 
  IWMemAllocator **v47; 
  __int64 v48; 
  bool v49; 
  IWMemAllocator *v50; 
  IWMemAllocator *v51; 
  unsigned __int64 v52; 
  bool v53; 
  IWMemAllocatorType v54; 
  __int64 v55; 
  __int64 v56; 
  IWMemAllocator *v57; 
  unsigned __int64 v58; 
  IWMemAllocatorType v59; 
  AllocatorSortFunctor v60; 
  AllocatorSortFunctor v61; 
  __int64 v62; 
  IWMemAllocator **r_iBegina; 
  __int64 v64; 
  unsigned __int64 v65; 
  unsigned __int64 v66; 
  IWMemAllocator **v68; 
  IWMemAllocator **iEnda; 
  IWMemAllocator **iEndb; 

  iEnda = iEnd;
  v61 = predicate;
  v4 = (const IWMemAllocator **)*r_iBegin;
  v6 = iEnd;
  v7 = r_iBegin;
  if ( (__int64)(((char *)iEnd - (char *)*r_iBegin) & 0xFFFFFFFFFFFFFFF8ui64) <= 128 )
    return;
  while ( depthLimit )
  {
    v8 = (const IWMemAllocator **)(v6 - 1);
    --depthLimit;
    v9 = &v4[(((char *)v6 - (char *)v4) >> 3) / 2];
    v10 = AllocatorSortFunctor::operator()(&v60, *v4, *v9);
    v11 = *(v6 - 1);
    if ( v10 )
    {
      if ( !AllocatorSortFunctor::operator()(&v60, *v9, v11) )
      {
        v12 = AllocatorSortFunctor::operator()(&v60, *v4, *v8);
        v9 = v4;
        goto LABEL_9;
      }
    }
    else
    {
      if ( !AllocatorSortFunctor::operator()(&v60, *v4, v11) )
      {
        v12 = AllocatorSortFunctor::operator()(&v60, *v9, *v8);
LABEL_9:
        if ( v12 )
          v9 = (const IWMemAllocator **)(v6 - 1);
        goto LABEL_11;
      }
      v9 = v4;
    }
LABEL_11:
    v13 = *v9;
    v14 = v6;
    for ( i = *r_iBegin; ; ++i )
    {
      while ( 1 )
      {
        v16 = *i;
        if ( !*i && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\iwmem\\gamelog\\iwmem_allocator_manager.cpp", 74, ASSERT_TYPE_ASSERT, "(first)", (const char *)&queryFormat, "first") )
          __debugbreak();
        if ( !v13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\iwmem\\gamelog\\iwmem_allocator_manager.cpp", 75, ASSERT_TYPE_ASSERT, "(second)", (const char *)&queryFormat, "second") )
          __debugbreak();
        m_address = v16->m_ownedRange.m_address;
        if ( m_address >= v13->m_ownedRange.m_address )
        {
          if ( m_address > v13->m_ownedRange.m_address )
            break;
          if ( AllocatorSortFunctor::IsParentOf(v16, v13) )
            break;
          if ( !AllocatorSortFunctor::IsParentOf(v13, v16) )
          {
            m_type = v16->m_type;
            if ( m_type >= v13->m_type && (m_type > v13->m_type || v16 >= v13) )
              break;
          }
        }
        ++i;
      }
      while ( 1 )
      {
        v19 = (unsigned __int64)*--v14;
        if ( !v19 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\iwmem\\gamelog\\iwmem_allocator_manager.cpp", 75, ASSERT_TYPE_ASSERT, "(second)", (const char *)&queryFormat, "second") )
          __debugbreak();
        v20 = v13->m_ownedRange.m_address;
        if ( v20 >= *(_QWORD *)(v19 + 64) )
        {
          if ( v20 > *(_QWORD *)(v19 + 64) )
            break;
          if ( AllocatorSortFunctor::IsParentOf(v13, (const IWMemAllocator *)v19) )
            break;
          if ( !AllocatorSortFunctor::IsParentOf((const IWMemAllocator *)v19, v13) )
          {
            v21 = v13->m_type;
            if ( v21 >= *(_DWORD *)(v19 + 136) && (v21 > *(_DWORD *)(v19 + 136) || (unsigned __int64)v13 >= v19) )
              break;
          }
        }
      }
      if ( i >= v14 )
        break;
      v22 = *i;
      *i = *v14;
      *v14 = v22;
    }
    r_iBegina = i;
    ntl::internal::introsort_loop<IWMemAllocator * *,AllocatorSortFunctor>(&r_iBegina, iEnda, depthLimit, v61);
    v6 = r_iBegina;
    v7 = r_iBegin;
    iEnda = r_iBegina;
    v4 = (const IWMemAllocator **)*r_iBegin;
    if ( (__int64)(((char *)r_iBegina - (char *)*r_iBegin) & 0xFFFFFFFFFFFFFFF8ui64) <= 128 )
      return;
  }
  if ( v4 > (const IWMemAllocator **)v6 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\utility\\sort.h", 121, ASSERT_TYPE_ASSERT, "( r_iBegin <= r_iMid )", (const char *)&queryFormat, "r_iBegin <= r_iMid") )
      __debugbreak();
    v7 = r_iBegin;
  }
  v23 = *v7;
  v24 = v6 - *v7;
  v66 = v24;
  if ( v24 < 2 )
  {
    v41 = r_iBegin;
  }
  else
  {
    v25 = (v24 - 2) / 2;
    v64 = v25;
    for ( j = 2 * v25 + 2; ; j -= 2i64 )
    {
      v27 = *v7;
      v28 = v25;
      v62 = j;
      v29 = j;
      v30 = (unsigned __int64)v27[v25];
      v65 = v30;
      if ( j < v24 )
      {
        do
        {
          v31 = (*r_iBegin)[v29];
          v32 = (*r_iBegin)[v29 - 1];
          if ( !v31 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\iwmem\\gamelog\\iwmem_allocator_manager.cpp", 74, ASSERT_TYPE_ASSERT, "(first)", (const char *)&queryFormat, "first") )
            __debugbreak();
          if ( !v32 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\iwmem\\gamelog\\iwmem_allocator_manager.cpp", 75, ASSERT_TYPE_ASSERT, "(second)", (const char *)&queryFormat, "second") )
            __debugbreak();
          v33 = v31->m_ownedRange.m_address;
          if ( v33 >= v32->m_ownedRange.m_address )
          {
            if ( v33 <= v32->m_ownedRange.m_address )
            {
              if ( AllocatorSortFunctor::IsParentOf(v31, v32) )
              {
                v34 = 0;
              }
              else if ( AllocatorSortFunctor::IsParentOf(v32, v31) )
              {
                v34 = 1;
              }
              else
              {
                v35 = v31->m_type;
                v34 = v35 < v32->m_type || v35 <= v32->m_type && v31 < v32;
              }
            }
            else
            {
              v34 = 0;
            }
          }
          else
          {
            v34 = 1;
          }
          v36 = v29 - 1;
          if ( !v34 )
            v36 = v29;
          v29 = 2 * v36 + 2;
          (*r_iBegin)[v28] = (*r_iBegin)[v36];
          v28 = v36;
        }
        while ( v29 < v24 );
        v7 = r_iBegin;
        v30 = v65;
        v25 = v64;
        j = v62;
        v27 = *r_iBegin;
      }
      if ( v29 == v24 )
      {
        v27[v28] = v27[v29 - 1];
        v28 = v29 - 1;
      }
      v37 = (v28 - 1) / 2;
      if ( v28 > v25 )
      {
        while ( 1 )
        {
          v38 = (*v7)[v37];
          if ( !v38 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\iwmem\\gamelog\\iwmem_allocator_manager.cpp", 74, ASSERT_TYPE_ASSERT, "(first)", (const char *)&queryFormat, "first") )
            __debugbreak();
          if ( !v30 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\iwmem\\gamelog\\iwmem_allocator_manager.cpp", 75, ASSERT_TYPE_ASSERT, "(second)", (const char *)&queryFormat, "second") )
            __debugbreak();
          v39 = v38->m_ownedRange.m_address;
          if ( v39 >= *(_QWORD *)(v30 + 64) )
          {
            if ( v39 > *(_QWORD *)(v30 + 64) )
              break;
            if ( AllocatorSortFunctor::IsParentOf(v38, (const IWMemAllocator *)v30) )
              break;
            if ( !AllocatorSortFunctor::IsParentOf((const IWMemAllocator *)v30, v38) )
            {
              v40 = v38->m_type;
              if ( v40 >= *(_DWORD *)(v30 + 136) && (v40 > *(_DWORD *)(v30 + 136) || (unsigned __int64)v38 >= v30) )
                break;
            }
          }
          v7 = r_iBegin;
          (*r_iBegin)[v28] = (*r_iBegin)[v37];
          v28 = v37;
          v37 = (v37 - 1) / 2;
          if ( v28 <= v25 )
            goto LABEL_89;
        }
        v7 = r_iBegin;
LABEL_89:
        v24 = v66;
        j = v62;
      }
      (*v7)[v28] = (IWMemAllocator *)v30;
      if ( !v25 )
        break;
      v64 = --v25;
    }
    v41 = r_iBegin;
    v6 = iEnda;
    v23 = *r_iBegin;
  }
  v42 = v23 + 1;
  v68 = v23 + 1;
  if ( v6 > v23 + 1 )
  {
    do
    {
      v43 = v6 - 1;
      iEndb = v6 - 1;
      v44 = (unsigned __int64)*(v6 - 1);
      v66 = v44;
      if ( v6 - 1 < *v41 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\utility\\heap_sort.h", 206, ASSERT_TYPE_ASSERT, "( r_iEnd >= r_iBegin )", (const char *)&queryFormat, "r_iEnd >= r_iBegin") )
        __debugbreak();
      v45 = 0i64;
      v46 = 2i64;
      *v43 = **v41;
      v47 = *v41;
      v48 = v43 - *v41;
      v49 = v48 == 2;
      if ( v48 > 2 )
      {
        do
        {
          v50 = (*v41)[v46];
          v51 = (*v41)[v46 - 1];
          if ( !v50 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\iwmem\\gamelog\\iwmem_allocator_manager.cpp", 74, ASSERT_TYPE_ASSERT, "(first)", (const char *)&queryFormat, "first") )
            __debugbreak();
          if ( !v51 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\iwmem\\gamelog\\iwmem_allocator_manager.cpp", 75, ASSERT_TYPE_ASSERT, "(second)", (const char *)&queryFormat, "second") )
            __debugbreak();
          v52 = v50->m_ownedRange.m_address;
          if ( v52 >= v51->m_ownedRange.m_address )
          {
            if ( v52 <= v51->m_ownedRange.m_address )
            {
              if ( AllocatorSortFunctor::IsParentOf(v50, v51) )
              {
                v53 = 0;
              }
              else if ( AllocatorSortFunctor::IsParentOf(v51, v50) )
              {
                v53 = 1;
              }
              else
              {
                v54 = v50->m_type;
                v53 = v54 < v51->m_type || v54 <= v51->m_type && v50 < v51;
              }
            }
            else
            {
              v53 = 0;
            }
          }
          else
          {
            v53 = 1;
          }
          v55 = v46 - 1;
          if ( !v53 )
            v55 = v46;
          v46 = 2 * v55 + 2;
          (*v41)[v45] = (*v41)[v55];
          v45 = v55;
          v49 = v46 == v48;
        }
        while ( v46 < v48 );
        v47 = *v41;
        v44 = v66;
        v42 = v68;
      }
      if ( v49 )
      {
        v47[v45] = v47[v46 - 1];
        v45 = v46 - 1;
      }
      v56 = (v45 - 1) / 2;
      if ( v45 > 0 )
      {
        do
        {
          v57 = (*v41)[v56];
          if ( !v57 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\iwmem\\gamelog\\iwmem_allocator_manager.cpp", 74, ASSERT_TYPE_ASSERT, "(first)", (const char *)&queryFormat, "first") )
            __debugbreak();
          if ( !v44 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\iwmem\\gamelog\\iwmem_allocator_manager.cpp", 75, ASSERT_TYPE_ASSERT, "(second)", (const char *)&queryFormat, "second") )
            __debugbreak();
          v58 = v57->m_ownedRange.m_address;
          if ( v58 >= *(_QWORD *)(v44 + 64) )
          {
            if ( v58 > *(_QWORD *)(v44 + 64) )
              break;
            if ( AllocatorSortFunctor::IsParentOf(v57, (const IWMemAllocator *)v44) )
              break;
            if ( !AllocatorSortFunctor::IsParentOf((const IWMemAllocator *)v44, v57) )
            {
              v59 = v57->m_type;
              if ( v59 >= *(_DWORD *)(v44 + 136) && (v59 > *(_DWORD *)(v44 + 136) || (unsigned __int64)v57 >= v44) )
                break;
            }
          }
          (*v41)[v45] = (*v41)[v56];
          v45 = v56;
          v56 = (v56 - 1) / 2;
        }
        while ( v45 > 0 );
        v42 = v68;
      }
      (*v41)[v45] = (IWMemAllocator *)v44;
      v6 = iEndb;
    }
    while ( iEndb > v42 );
  }
}

/*
==============
ntl::sort<IWMemAllocator * *,AllocatorSortFunctor>
==============
*/
void ntl::sort<IWMemAllocator * *,AllocatorSortFunctor>(IWMemAllocator **first, IWMemAllocator **last, AllocatorSortFunctor compare)
{
  ntl::random_access_iterator_tag v3; 

  ntl::sort<IWMemAllocator * *,AllocatorSortFunctor>(first, last, compare, v3);
}

/*
==============
ntl::sort<IWMemAllocator * *,AllocatorSortFunctor>
==============
*/
void ntl::sort<IWMemAllocator * *,AllocatorSortFunctor>(IWMemAllocator **first, IWMemAllocator **last, AllocatorSortFunctor compare, ntl::random_access_iterator_tag __formal)
{
  IWMemAllocator **v5; 
  signed __int64 v6; 
  IWMemAllocator **v7; 
  unsigned __int64 v8; 
  const IWMemAllocator **v9; 
  const IWMemAllocator **v10; 
  const IWMemAllocator *v11; 
  const IWMemAllocator **k; 
  const IWMemAllocator *v13; 
  const IWMemAllocator **v14; 
  const IWMemAllocator **m; 
  unsigned __int64 v16; 
  unsigned __int64 v17; 
  IWMemAllocatorType v18; 
  IWMemAllocator **v19; 
  IWMemAllocator **v20; 
  IWMemAllocator *v21; 
  IWMemAllocator **v22; 
  IWMemAllocator **n; 
  unsigned __int64 v24; 
  unsigned __int64 v25; 
  IWMemAllocatorType v26; 
  const IWMemAllocator **v27; 
  const IWMemAllocator *v28; 
  const IWMemAllocator **i; 
  const IWMemAllocator *v30; 
  const IWMemAllocator **v31; 
  const IWMemAllocator **j; 
  unsigned __int64 v33; 
  unsigned __int64 m_address; 
  IWMemAllocatorType v35; 
  __int64 v36; 
  AllocatorSortFunctor v37; 
  IWMemAllocator **r_iBegin; 
  IWMemAllocator **v39; 

  if ( first != last )
  {
    v39 = last;
    r_iBegin = first;
    LOBYTE(v36) = compare;
    v5 = last;
    v6 = last - first;
    v7 = first;
    if ( v6 )
      v8 = 63 - __lzcnt(v6);
    else
      v8 = 0i64;
    ntl::internal::introsort_loop<IWMemAllocator * *,AllocatorSortFunctor>(&r_iBegin, last, 2 * v8, compare);
    if ( v6 <= 16 )
    {
      v27 = (const IWMemAllocator **)(v7 + 1);
      if ( v7 + 1 != v5 )
      {
        do
        {
          v28 = *v27;
          if ( AllocatorSortFunctor::operator()(&v37, *v27, *v7) )
          {
            for ( i = v27; i != (const IWMemAllocator **)v7; i[1] = v30 )
              v30 = *--i;
            *v7 = (IWMemAllocator *)v28;
          }
          else
          {
            v31 = v27;
            for ( j = v27 - 1; ; --j )
            {
              v33 = (unsigned __int64)*j;
              if ( !v28 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\iwmem\\gamelog\\iwmem_allocator_manager.cpp", 74, ASSERT_TYPE_ASSERT, "(first)", (const char *)&queryFormat, "first", v36) )
                __debugbreak();
              if ( !v33 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\iwmem\\gamelog\\iwmem_allocator_manager.cpp", 75, ASSERT_TYPE_ASSERT, "(second)", (const char *)&queryFormat, "second") )
                __debugbreak();
              m_address = v28->m_ownedRange.m_address;
              if ( m_address >= *(_QWORD *)(v33 + 64) )
              {
                if ( m_address > *(_QWORD *)(v33 + 64) )
                  break;
                if ( AllocatorSortFunctor::IsParentOf(v28, (const IWMemAllocator *)v33) )
                  break;
                if ( !AllocatorSortFunctor::IsParentOf((const IWMemAllocator *)v33, v28) )
                {
                  v35 = *(_DWORD *)(v33 + 136);
                  if ( v28->m_type >= v35 && (v28->m_type > v35 || (unsigned __int64)v28 >= v33) )
                    break;
                }
              }
              *v31 = *j;
              v31 = j;
            }
            v7 = r_iBegin;
            *v31 = v28;
          }
          ++v27;
        }
        while ( v27 != (const IWMemAllocator **)v39 );
      }
    }
    else
    {
      v9 = (const IWMemAllocator **)(v7 + 16);
      if ( v7 != v7 + 16 )
      {
        v10 = (const IWMemAllocator **)(v7 + 1);
        if ( v7 + 1 != (IWMemAllocator **)v9 )
        {
          do
          {
            v11 = *v10;
            if ( AllocatorSortFunctor::operator()(&v37, *v10, *v7) )
            {
              for ( k = v10; k != (const IWMemAllocator **)v7; k[1] = v13 )
                v13 = *--k;
              *v7 = (IWMemAllocator *)v11;
            }
            else
            {
              v14 = v10;
              for ( m = v10 - 1; ; --m )
              {
                v16 = (unsigned __int64)*m;
                if ( !v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\iwmem\\gamelog\\iwmem_allocator_manager.cpp", 74, ASSERT_TYPE_ASSERT, "(first)", (const char *)&queryFormat, "first", v36) )
                  __debugbreak();
                if ( !v16 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\iwmem\\gamelog\\iwmem_allocator_manager.cpp", 75, ASSERT_TYPE_ASSERT, "(second)", (const char *)&queryFormat, "second") )
                  __debugbreak();
                v17 = v11->m_ownedRange.m_address;
                if ( v17 >= *(_QWORD *)(v16 + 64) )
                {
                  if ( v17 > *(_QWORD *)(v16 + 64) )
                    break;
                  if ( AllocatorSortFunctor::IsParentOf(v11, (const IWMemAllocator *)v16) )
                    break;
                  if ( !AllocatorSortFunctor::IsParentOf((const IWMemAllocator *)v16, v11) )
                  {
                    v18 = *(_DWORD *)(v16 + 136);
                    if ( v11->m_type >= v18 && (v11->m_type > v18 || (unsigned __int64)v11 >= v16) )
                      break;
                  }
                }
                *v14 = *m;
                v14 = m;
              }
              v7 = r_iBegin;
              *v14 = v11;
              v9 = (const IWMemAllocator **)(v7 + 16);
            }
            ++v10;
          }
          while ( v10 != v9 );
          v5 = v39;
        }
      }
      v19 = v7 + 16;
      r_iBegin = v7 + 16;
      if ( v7 + 16 != v5 )
      {
        v20 = v39;
        do
        {
          v21 = *v19;
          v22 = v19 - 1;
          for ( n = v19; ; n = v22-- )
          {
            v24 = (unsigned __int64)*v22;
            if ( !v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\iwmem\\gamelog\\iwmem_allocator_manager.cpp", 74, ASSERT_TYPE_ASSERT, "(first)", (const char *)&queryFormat, "first") )
              __debugbreak();
            if ( !v24 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\iwmem\\gamelog\\iwmem_allocator_manager.cpp", 75, ASSERT_TYPE_ASSERT, "(second)", (const char *)&queryFormat, "second") )
              __debugbreak();
            v25 = v21->m_ownedRange.m_address;
            if ( v25 >= *(_QWORD *)(v24 + 64) )
            {
              if ( v25 > *(_QWORD *)(v24 + 64) )
                break;
              if ( AllocatorSortFunctor::IsParentOf(v21, (const IWMemAllocator *)v24) )
                break;
              if ( !AllocatorSortFunctor::IsParentOf((const IWMemAllocator *)v24, v21) )
              {
                v26 = *(_DWORD *)(v24 + 136);
                if ( v21->m_type >= v26 && (v21->m_type > v26 || (unsigned __int64)v21 >= v24) )
                  break;
              }
            }
            *n = *v22;
          }
          v19 = r_iBegin + 1;
          *n = v21;
          r_iBegin = v19;
        }
        while ( v19 != v20 );
      }
    }
  }
}

/*
==============
ntl::sort<ConeTargetHitInfo *>
==============
*/
void ntl::sort<ConeTargetHitInfo *>(ConeTargetHitInfo *first, ConeTargetHitInfo *last)
{
  ntl::random_access_iterator_tag v2; 

  ntl::sort<ConeTargetHitInfo *,ntl::less<ConeTargetHitInfo,ConeTargetHitInfo>>(first, last, (ntl::less<ConeTargetHitInfo,ConeTargetHitInfo>)v2.ntl::input_iterator_tag, v2);
}

/*
==============
ntl::sort<GAssistTarget *>
==============
*/
void ntl::sort<GAssistTarget *>(GAssistTarget *first, GAssistTarget *last)
{
  ntl::random_access_iterator_tag v2; 

  ntl::sort<GAssistTarget *,ntl::less<GAssistTarget,GAssistTarget>>(first, last, (ntl::less<GAssistTarget,GAssistTarget>)v2.ntl::input_iterator_tag, v2);
}

/*
==============
ntl::sort<CAssistTarget *>
==============
*/
void ntl::sort<CAssistTarget *>(CAssistTarget *first, CAssistTarget *last)
{
  ntl::random_access_iterator_tag v2; 

  ntl::sort<CAssistTarget *,ntl::less<CAssistTarget,CAssistTarget>>(first, last, (ntl::less<CAssistTarget,CAssistTarget>)v2.ntl::input_iterator_tag, v2);
}

