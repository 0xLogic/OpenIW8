/*
==============
bdArray<bdClansGroupIdentifier>::operator=
==============
*/

void __fastcall bdArray<bdClansGroupIdentifier>::operator=(bdArray<bdClansGroupIdentifier> *this, const bdArray<bdClansGroupIdentifier> *a)
{
  ??4?$bdArray@VbdClansGroupIdentifier@@@@QEAAXAEBV0@@Z(this, a);
}

/*
==============
bdArray<bdClansRemovedMembershipProposal>::uninitializedCopy
==============
*/

bdClansRemovedMembershipProposal *__fastcall bdArray<bdClansRemovedMembershipProposal>::uninitializedCopy(bdArray<bdClansRemovedMembershipProposal> *this, const bdArray<bdClansRemovedMembershipProposal> *a)
{
  return ?uninitializedCopy@?$bdArray@VbdClansRemovedMembershipProposal@@@@IEBAPEAVbdClansRemovedMembershipProposal@@AEBV1@@Z(this, a);
}

/*
==============
bdArray<bdObjectStoreTag>::uninitializedCopy
==============
*/

bdObjectStoreTag *__fastcall bdArray<bdObjectStoreTag>::uninitializedCopy(bdArray<bdObjectStoreTag> *this, const bdArray<bdObjectStoreTag> *a)
{
  return ?uninitializedCopy@?$bdArray@VbdObjectStoreTag@@@@IEBAPEAVbdObjectStoreTag@@AEBV1@@Z(this, a);
}

/*
==============
bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>::copyConstructArrayObject
==============
*/

void __fastcall bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>::copyConstructArrayObject(bdArray<bdQoSProbe::bdQoSProbeEntryWrapper> *this, bdQoSProbe::bdQoSProbeEntryWrapper *dest, const bdQoSProbe::bdQoSProbeEntryWrapper *src, const unsigned int n)
{
  ?copyConstructArrayObject@?$bdArray@UbdQoSProbeEntryWrapper@bdQoSProbe@@@@IEBAXPEAUbdQoSProbeEntryWrapper@bdQoSProbe@@AEBU23@I@Z(this, dest, src, n);
}

/*
==============
bdArray<bdClansFailedMembershipProposal>::destruct
==============
*/

void __fastcall bdArray<bdClansFailedMembershipProposal>::destruct(bdArray<bdClansFailedMembershipProposal> *this, bdClansFailedMembershipProposal *src, const unsigned int n)
{
  ?destruct@?$bdArray@VbdClansFailedMembershipProposal@@@@IEBAXPEAVbdClansFailedMembershipProposal@@I@Z(this, src, n);
}

/*
==============
bdArray<bdSockAddr>::copyConstructArrayArray
==============
*/

void __fastcall bdArray<bdSockAddr>::copyConstructArrayArray(bdArray<bdSockAddr> *this, bdSockAddr *dest, const bdSockAddr *src, const unsigned int n)
{
  ?copyConstructArrayArray@?$bdArray@VbdSockAddr@@@@IEBAXPEAVbdSockAddr@@PEBV2@I@Z(this, dest, src, n);
}

/*
==============
bdArray<bdJSONValue>::operator=
==============
*/

void __fastcall bdArray<bdJSONValue>::operator=(bdArray<bdJSONValue> *this, const bdArray<bdJSONValue> *a)
{
  ??4?$bdArray@VbdJSONValue@@@@QEAAXAEBV0@@Z(this, a);
}

/*
==============
bdArray<bdObjectStoreCacheAwareObjectID>::operator=
==============
*/

void __fastcall bdArray<bdObjectStoreCacheAwareObjectID>::operator=(bdArray<bdObjectStoreCacheAwareObjectID> *this, const bdArray<bdObjectStoreCacheAwareObjectID> *a)
{
  ??4?$bdArray@VbdObjectStoreCacheAwareObjectID@@@@QEAAXAEBV0@@Z(this, a);
}

/*
==============
bdArray<bdSockAddr>::~bdArray<bdSockAddr>
==============
*/

void __fastcall bdArray<bdSockAddr>::~bdArray<bdSockAddr>(bdArray<bdSockAddr> *this)
{
  ??1?$bdArray@VbdSockAddr@@@@QEAA@XZ(this);
}

/*
==============
bdArray<bdQoSProbeInfo>::~bdArray<bdQoSProbeInfo>
==============
*/

void __fastcall bdArray<bdQoSProbeInfo>::~bdArray<bdQoSProbeInfo>(bdArray<bdQoSProbeInfo> *this)
{
  ??1?$bdArray@VbdQoSProbeInfo@@@@QEAA@XZ(this);
}

/*
==============
bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>::operator=
==============
*/

void __fastcall bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>::operator=(bdArray<bdQoSProbe::bdQoSProbeEntryWrapper> *this, const bdArray<bdQoSProbe::bdQoSProbeEntryWrapper> *a)
{
  ??4?$bdArray@UbdQoSProbeEntryWrapper@bdQoSProbe@@@@QEAAXAEBV0@@Z(this, a);
}

/*
==============
bdArray<bdJSONValue>::~bdArray<bdJSONValue>
==============
*/

void __fastcall bdArray<bdJSONValue>::~bdArray<bdJSONValue>(bdArray<bdJSONValue> *this)
{
  ??1?$bdArray@VbdJSONValue@@@@QEAA@XZ(this);
}

/*
==============
bdArray<bdObjectStoreValidationToken>::increaseCapacity
==============
*/

void __fastcall bdArray<bdObjectStoreValidationToken>::increaseCapacity(bdArray<bdObjectStoreValidationToken> *this, const unsigned int increase)
{
  ?increaseCapacity@?$bdArray@VbdObjectStoreValidationToken@@@@QEAAXI@Z(this, increase);
}

/*
==============
bdArray<bdObjectStoreObject>::copyConstructArrayArray
==============
*/

void __fastcall bdArray<bdObjectStoreObject>::copyConstructArrayArray(bdArray<bdObjectStoreObject> *this, bdObjectStoreObject *dest, const bdObjectStoreObject *src, const unsigned int n)
{
  ?copyConstructArrayArray@?$bdArray@VbdObjectStoreObject@@@@IEBAXPEAVbdObjectStoreObject@@PEBV2@I@Z(this, dest, src, n);
}

/*
==============
bdArray<bdObjectStoreObject>::destruct
==============
*/

void __fastcall bdArray<bdObjectStoreObject>::destruct(bdArray<bdObjectStoreObject> *this, bdObjectStoreObject *src, const unsigned int n)
{
  ?destruct@?$bdArray@VbdObjectStoreObject@@@@IEBAXPEAVbdObjectStoreObject@@I@Z(this, src, n);
}

/*
==============
bdArray<bdClansGroupMembershipProposal>::get
==============
*/

bool __fastcall bdArray<bdClansGroupMembershipProposal>::get(bdArray<bdClansGroupMembershipProposal> *this, const unsigned int i, bdClansGroupMembershipProposal *value)
{
  return ?get@?$bdArray@VbdClansGroupMembershipProposal@@@@QEBA_NIAEAVbdClansGroupMembershipProposal@@@Z(this, i, value);
}

/*
==============
bdArray<bdClansFailedMembershipProposal>::get
==============
*/

bool __fastcall bdArray<bdClansFailedMembershipProposal>::get(bdArray<bdClansFailedMembershipProposal> *this, const unsigned int i, bdClansFailedMembershipProposal *value)
{
  return ?get@?$bdArray@VbdClansFailedMembershipProposal@@@@QEBA_NIAEAVbdClansFailedMembershipProposal@@@Z(this, i, value);
}

/*
==============
bdArray<bdClansRemovedMembershipProposal>::copyConstructArrayArray
==============
*/

void __fastcall bdArray<bdClansRemovedMembershipProposal>::copyConstructArrayArray(bdArray<bdClansRemovedMembershipProposal> *this, bdClansRemovedMembershipProposal *dest, const bdClansRemovedMembershipProposal *src, const unsigned int n)
{
  ?copyConstructArrayArray@?$bdArray@VbdClansRemovedMembershipProposal@@@@IEBAXPEAVbdClansRemovedMembershipProposal@@PEBV2@I@Z(this, dest, src, n);
}

/*
==============
bdArray<bdObjectStoreObject>::increaseCapacity
==============
*/

void __fastcall bdArray<bdObjectStoreObject>::increaseCapacity(bdArray<bdObjectStoreObject> *this, const unsigned int increase)
{
  ?increaseCapacity@?$bdArray@VbdObjectStoreObject@@@@QEAAXI@Z(this, increase);
}

/*
==============
bdArray<bdObjectStoreHTTPHeader>::destruct
==============
*/

void __fastcall bdArray<bdObjectStoreHTTPHeader>::destruct(bdArray<bdObjectStoreHTTPHeader> *this, bdObjectStoreHTTPHeader *src, const unsigned int n)
{
  ?destruct@?$bdArray@VbdObjectStoreHTTPHeader@@@@IEBAXPEAVbdObjectStoreHTTPHeader@@I@Z(this, src, n);
}

/*
==============
bdArray<bdObjectStoreCacheAwareObjectID>::~bdArray<bdObjectStoreCacheAwareObjectID>
==============
*/

void __fastcall bdArray<bdObjectStoreCacheAwareObjectID>::~bdArray<bdObjectStoreCacheAwareObjectID>(bdArray<bdObjectStoreCacheAwareObjectID> *this)
{
  ??1?$bdArray@VbdObjectStoreCacheAwareObjectID@@@@QEAA@XZ(this);
}

/*
==============
bdArray<bdSockAddr>::uninitializedCopy
==============
*/

bdSockAddr *__fastcall bdArray<bdSockAddr>::uninitializedCopy(bdArray<bdSockAddr> *this, const bdArray<bdSockAddr> *a)
{
  return ?uninitializedCopy@?$bdArray@VbdSockAddr@@@@IEBAPEAVbdSockAddr@@AEBV1@@Z(this, a);
}

/*
==============
bdArray<GeneralChannelRequest>::pushBack
==============
*/

void __fastcall bdArray<GeneralChannelRequest>::pushBack(bdArray<GeneralChannelRequest> *this, const GeneralChannelRequest *value)
{
  ?pushBack@?$bdArray@VGeneralChannelRequest@@@@QEAAXAEBVGeneralChannelRequest@@@Z(this, value);
}

/*
==============
bdArray<bdUserAccountID>::~bdArray<bdUserAccountID>
==============
*/

void __fastcall bdArray<bdUserAccountID>::~bdArray<bdUserAccountID>(bdArray<bdUserAccountID> *this)
{
  ??1?$bdArray@VbdUserAccountID@@@@QEAA@XZ(this);
}

/*
==============
bdArray<bdString>::increaseCapacity
==============
*/

void __fastcall bdArray<bdString>::increaseCapacity(bdArray<bdString> *this, const unsigned int increase)
{
  ?increaseCapacity@?$bdArray@VbdString@@@@QEAAXI@Z(this, increase);
}

/*
==============
bdArray<bdObjectStoreErrorWrappedObject>::~bdArray<bdObjectStoreErrorWrappedObject>
==============
*/

void __fastcall bdArray<bdObjectStoreErrorWrappedObject>::~bdArray<bdObjectStoreErrorWrappedObject>(bdArray<bdObjectStoreErrorWrappedObject> *this)
{
  ??1?$bdArray@VbdObjectStoreErrorWrappedObject@@@@QEAA@XZ(this);
}

/*
==============
bdArray<bdObjectStoreValidationToken>::operator[]
==============
*/

const bdObjectStoreValidationToken *__fastcall bdArray<bdObjectStoreValidationToken>::operator[](bdArray<bdObjectStoreValidationToken> *this, const unsigned int i)
{
  return ??A?$bdArray@VbdObjectStoreValidationToken@@@@QEBAAEBVbdObjectStoreValidationToken@@I@Z(this, i);
}

/*
==============
bdArray<bdObjectStoreObject>::~bdArray<bdObjectStoreObject>
==============
*/

void __fastcall bdArray<bdObjectStoreObject>::~bdArray<bdObjectStoreObject>(bdArray<bdObjectStoreObject> *this)
{
  ??1?$bdArray@VbdObjectStoreObject@@@@QEAA@XZ(this);
}

/*
==============
bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>::clear
==============
*/

void __fastcall bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>::clear(bdArray<bdQoSProbe::bdQoSProbeEntryWrapper> *this)
{
  ?clear@?$bdArray@UbdQoSProbeEntryWrapper@bdQoSProbe@@@@QEAAXXZ(this);
}

/*
==============
bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>::decreaseCapacity
==============
*/

void __fastcall bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>::decreaseCapacity(bdArray<bdQoSProbe::bdQoSProbeEntryWrapper> *this, const unsigned int decrease)
{
  ?decreaseCapacity@?$bdArray@UbdQoSProbeEntryWrapper@bdQoSProbe@@@@QEAAXI@Z(this, decrease);
}

/*
==============
bdArray<bdObjectStoreErrorWrappedObject>::destruct
==============
*/

void __fastcall bdArray<bdObjectStoreErrorWrappedObject>::destruct(bdArray<bdObjectStoreErrorWrappedObject> *this, bdObjectStoreErrorWrappedObject *src, const unsigned int n)
{
  ?destruct@?$bdArray@VbdObjectStoreErrorWrappedObject@@@@IEBAXPEAVbdObjectStoreErrorWrappedObject@@I@Z(this, src, n);
}

/*
==============
bdArray<bdQoSRemoteAddr>::~bdArray<bdQoSRemoteAddr>
==============
*/

void __fastcall bdArray<bdQoSRemoteAddr>::~bdArray<bdQoSRemoteAddr>(bdArray<bdQoSRemoteAddr> *this)
{
  ??1?$bdArray@VbdQoSRemoteAddr@@@@QEAA@XZ(this);
}

/*
==============
bdArray<bdString>::operator[]
==============
*/

bdString *__fastcall bdArray<bdString>::operator[](bdArray<bdString> *this, const unsigned int i)
{
  return ??A?$bdArray@VbdString@@@@QEAAAEAVbdString@@I@Z(this, i);
}

/*
==============
bdArray<bdClansGroupInfo>::~bdArray<bdClansGroupInfo>
==============
*/

void __fastcall bdArray<bdClansGroupInfo>::~bdArray<bdClansGroupInfo>(bdArray<bdClansGroupInfo> *this)
{
  ??1?$bdArray@VbdClansGroupInfo@@@@QEAA@XZ(this);
}

/*
==============
bdArray<bdObjectStoreMetadata>::~bdArray<bdObjectStoreMetadata>
==============
*/

void __fastcall bdArray<bdObjectStoreMetadata>::~bdArray<bdObjectStoreMetadata>(bdArray<bdObjectStoreMetadata> *this)
{
  ??1?$bdArray@VbdObjectStoreMetadata@@@@QEAA@XZ(this);
}

/*
==============
bdArray<bdClansUserMembershipProposal>::copyConstructArrayArray
==============
*/

void __fastcall bdArray<bdClansUserMembershipProposal>::copyConstructArrayArray(bdArray<bdClansUserMembershipProposal> *this, bdClansUserMembershipProposal *dest, const bdClansUserMembershipProposal *src, const unsigned int n)
{
  ?copyConstructArrayArray@?$bdArray@VbdClansUserMembershipProposal@@@@IEBAXPEAVbdClansUserMembershipProposal@@PEBV2@I@Z(this, dest, src, n);
}

/*
==============
bdArray<bdClansGroupMembershipInfo>::copyConstructArrayArray
==============
*/

void __fastcall bdArray<bdClansGroupMembershipInfo>::copyConstructArrayArray(bdArray<bdClansGroupMembershipInfo> *this, bdClansGroupMembershipInfo *dest, const bdClansGroupMembershipInfo *src, const unsigned int n)
{
  ?copyConstructArrayArray@?$bdArray@VbdClansGroupMembershipInfo@@@@IEBAXPEAVbdClansGroupMembershipInfo@@PEBV2@I@Z(this, dest, src, n);
}

/*
==============
bdArray<bdClansGroupMembershipInfo>::destruct
==============
*/

void __fastcall bdArray<bdClansGroupMembershipInfo>::destruct(bdArray<bdClansGroupMembershipInfo> *this, bdClansGroupMembershipInfo *src, const unsigned int n)
{
  ?destruct@?$bdArray@VbdClansGroupMembershipInfo@@@@IEBAXPEAVbdClansGroupMembershipInfo@@I@Z(this, src, n);
}

/*
==============
bdArray<bdObjectStoreErrorWrappedObject>::pushBack
==============
*/

void __fastcall bdArray<bdObjectStoreErrorWrappedObject>::pushBack(bdArray<bdObjectStoreErrorWrappedObject> *this, const bdObjectStoreErrorWrappedObject *value)
{
  ?pushBack@?$bdArray@VbdObjectStoreErrorWrappedObject@@@@QEAAXAEBVbdObjectStoreErrorWrappedObject@@@Z(this, value);
}

/*
==============
bdArray<GeneralChannelRequest>::destruct
==============
*/

void __fastcall bdArray<GeneralChannelRequest>::destruct(bdArray<GeneralChannelRequest> *this, GeneralChannelRequest *src, const unsigned int n)
{
  ?destruct@?$bdArray@VGeneralChannelRequest@@@@IEBAXPEAVGeneralChannelRequest@@I@Z(this, src, n);
}

/*
==============
bdArray<bdClansUserMembershipProposal>::operator=
==============
*/

void __fastcall bdArray<bdClansUserMembershipProposal>::operator=(bdArray<bdClansUserMembershipProposal> *this, const bdArray<bdClansUserMembershipProposal> *a)
{
  ??4?$bdArray@VbdClansUserMembershipProposal@@@@QEAAXAEBV0@@Z(this, a);
}

/*
==============
bdArray<bdString>::uninitializedCopy
==============
*/

bdString *__fastcall bdArray<bdString>::uninitializedCopy(bdArray<bdString> *this, const bdArray<bdString> *a)
{
  return ?uninitializedCopy@?$bdArray@VbdString@@@@IEBAPEAVbdString@@AEBV1@@Z(this, a);
}

/*
==============
bdArray<bdAchievementState>::destruct
==============
*/

void __fastcall bdArray<bdAchievementState>::destruct(bdArray<bdAchievementState> *this, bdAchievementState *src, const unsigned int n)
{
  ?destruct@?$bdArray@VbdAchievementState@@@@IEBAXPEAVbdAchievementState@@I@Z(this, src, n);
}

/*
==============
bdArray<bdClansGroupMemberInfo>::get
==============
*/

bool __fastcall bdArray<bdClansGroupMemberInfo>::get(bdArray<bdClansGroupMemberInfo> *this, const unsigned int i, bdClansGroupMemberInfo *value)
{
  return ?get@?$bdArray@VbdClansGroupMemberInfo@@@@QEBA_NIAEAVbdClansGroupMemberInfo@@@Z(this, i, value);
}

/*
==============
bdArray<bdAntiCheatChallengeParam>::copyConstructArrayArray
==============
*/

void __fastcall bdArray<bdAntiCheatChallengeParam>::copyConstructArrayArray(bdArray<bdAntiCheatChallengeParam> *this, bdAntiCheatChallengeParam *dest, const bdAntiCheatChallengeParam *src, const unsigned int n)
{
  ?copyConstructArrayArray@?$bdArray@VbdAntiCheatChallengeParam@@@@IEBAXPEAVbdAntiCheatChallengeParam@@PEBV2@I@Z(this, dest, src, n);
}

/*
==============
bdArray<bdClansGroupMemberInfo>::destruct
==============
*/

void __fastcall bdArray<bdClansGroupMemberInfo>::destruct(bdArray<bdClansGroupMemberInfo> *this, bdClansGroupMemberInfo *src, const unsigned int n)
{
  ?destruct@?$bdArray@VbdClansGroupMemberInfo@@@@IEBAXPEAVbdClansGroupMemberInfo@@I@Z(this, src, n);
}

/*
==============
bdArray<bdSockAddr>::operator[]
==============
*/

bdSockAddr *__fastcall bdArray<bdSockAddr>::operator[](bdArray<bdSockAddr> *this, const unsigned int i)
{
  return ??A?$bdArray@VbdSockAddr@@@@QEAAAEAVbdSockAddr@@I@Z(this, i);
}

/*
==============
bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>::copyConstructArrayArray
==============
*/

void __fastcall bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>::copyConstructArrayArray(bdArray<bdQoSProbe::bdQoSProbeEntryWrapper> *this, bdQoSProbe::bdQoSProbeEntryWrapper *dest, const bdQoSProbe::bdQoSProbeEntryWrapper *src, const unsigned int n)
{
  ?copyConstructArrayArray@?$bdArray@UbdQoSProbeEntryWrapper@bdQoSProbe@@@@IEBAXPEAUbdQoSProbeEntryWrapper@bdQoSProbe@@PEBU23@I@Z(this, dest, src, n);
}

/*
==============
bdArray<bdClansGroupMembershipProposal>::destruct
==============
*/

void __fastcall bdArray<bdClansGroupMembershipProposal>::destruct(bdArray<bdClansGroupMembershipProposal> *this, bdClansGroupMembershipProposal *src, const unsigned int n)
{
  ?destruct@?$bdArray@VbdClansGroupMembershipProposal@@@@IEBAXPEAVbdClansGroupMembershipProposal@@I@Z(this, src, n);
}

/*
==============
bdArray<bdObjectStoreErrorWrappedObject>::copyConstructArrayArray
==============
*/

void __fastcall bdArray<bdObjectStoreErrorWrappedObject>::copyConstructArrayArray(bdArray<bdObjectStoreErrorWrappedObject> *this, bdObjectStoreErrorWrappedObject *dest, const bdObjectStoreErrorWrappedObject *src, const unsigned int n)
{
  ?copyConstructArrayArray@?$bdArray@VbdObjectStoreErrorWrappedObject@@@@IEBAXPEAVbdObjectStoreErrorWrappedObject@@PEBV2@I@Z(this, dest, src, n);
}

/*
==============
bdArray<bdObjectStoreErrorWrappedMetadata>::copyConstructArrayArray
==============
*/

void __fastcall bdArray<bdObjectStoreErrorWrappedMetadata>::copyConstructArrayArray(bdArray<bdObjectStoreErrorWrappedMetadata> *this, bdObjectStoreErrorWrappedMetadata *dest, const bdObjectStoreErrorWrappedMetadata *src, const unsigned int n)
{
  ?copyConstructArrayArray@?$bdArray@VbdObjectStoreErrorWrappedMetadata@@@@IEBAXPEAVbdObjectStoreErrorWrappedMetadata@@PEBV2@I@Z(this, dest, src, n);
}

/*
==============
bdArray<bdUserAccountID>::destruct
==============
*/

void __fastcall bdArray<bdUserAccountID>::destruct(bdArray<bdUserAccountID> *this, bdUserAccountID *src, const unsigned int n)
{
  ?destruct@?$bdArray@VbdUserAccountID@@@@IEBAXPEAVbdUserAccountID@@I@Z(this, src, n);
}

/*
==============
bdArray<bdObjectStoreCacheAwareObjectID>::clear
==============
*/

void __fastcall bdArray<bdObjectStoreCacheAwareObjectID>::clear(bdArray<bdObjectStoreCacheAwareObjectID> *this)
{
  ?clear@?$bdArray@VbdObjectStoreCacheAwareObjectID@@@@QEAAXXZ(this);
}

/*
==============
bdArray<bdChannelInfo>::destruct
==============
*/

void __fastcall bdArray<bdChannelInfo>::destruct(bdArray<bdChannelInfo> *this, bdChannelInfo *src, const unsigned int n)
{
  ?destruct@?$bdArray@VbdChannelInfo@@@@IEBAXPEAVbdChannelInfo@@I@Z(this, src, n);
}

/*
==============
bdArray<bdUserAccountID>::copyConstructArrayArray
==============
*/

void __fastcall bdArray<bdUserAccountID>::copyConstructArrayArray(bdArray<bdUserAccountID> *this, bdUserAccountID *dest, const bdUserAccountID *src, const unsigned int n)
{
  ?copyConstructArrayArray@?$bdArray@VbdUserAccountID@@@@IEBAXPEAVbdUserAccountID@@PEBV2@I@Z(this, dest, src, n);
}

/*
==============
bdArray<bdClansRemovedMembershipProposal>::get
==============
*/

bool __fastcall bdArray<bdClansRemovedMembershipProposal>::get(bdArray<bdClansRemovedMembershipProposal> *this, const unsigned int i, bdClansRemovedMembershipProposal *value)
{
  return ?get@?$bdArray@VbdClansRemovedMembershipProposal@@@@QEBA_NIAEAVbdClansRemovedMembershipProposal@@@Z(this, i, value);
}

/*
==============
bdArray<bdChannelInfo>::increaseCapacity
==============
*/

void __fastcall bdArray<bdChannelInfo>::increaseCapacity(bdArray<bdChannelInfo> *this, const unsigned int increase)
{
  ?increaseCapacity@?$bdArray@VbdChannelInfo@@@@QEAAXI@Z(this, increase);
}

/*
==============
bdArray<bdChannelInfo>::~bdArray<bdChannelInfo>
==============
*/

void __fastcall bdArray<bdChannelInfo>::~bdArray<bdChannelInfo>(bdArray<bdChannelInfo> *this)
{
  ??1?$bdArray@VbdChannelInfo@@@@QEAA@XZ(this);
}

/*
==============
bdArray<bdAntiCheatChallengeParam>::~bdArray<bdAntiCheatChallengeParam>
==============
*/

void __fastcall bdArray<bdAntiCheatChallengeParam>::~bdArray<bdAntiCheatChallengeParam>(bdArray<bdAntiCheatChallengeParam> *this)
{
  ??1?$bdArray@VbdAntiCheatChallengeParam@@@@QEAA@XZ(this);
}

/*
==============
bdArray<bdAddr>::operator[]
==============
*/

bdAddr *__fastcall bdArray<bdAddr>::operator[](bdArray<bdAddr> *this, const unsigned int i)
{
  return ??A?$bdArray@VbdAddr@@@@QEAAAEAVbdAddr@@I@Z(this, i);
}

/*
==============
bdArray<bdClansGroupMembershipInfo>::~bdArray<bdClansGroupMembershipInfo>
==============
*/

void __fastcall bdArray<bdClansGroupMembershipInfo>::~bdArray<bdClansGroupMembershipInfo>(bdArray<bdClansGroupMembershipInfo> *this)
{
  ??1?$bdArray@VbdClansGroupMembershipInfo@@@@QEAA@XZ(this);
}

/*
==============
bdArray<bdClansFailedMembershipProposal>::copyConstructArrayArray
==============
*/

void __fastcall bdArray<bdClansFailedMembershipProposal>::copyConstructArrayArray(bdArray<bdClansFailedMembershipProposal> *this, bdClansFailedMembershipProposal *dest, const bdClansFailedMembershipProposal *src, const unsigned int n)
{
  ?copyConstructArrayArray@?$bdArray@VbdClansFailedMembershipProposal@@@@IEBAXPEAVbdClansFailedMembershipProposal@@PEBV2@I@Z(this, dest, src, n);
}

/*
==============
bdArray<bdStructUserAccountID>::~bdArray<bdStructUserAccountID>
==============
*/

void __fastcall bdArray<bdStructUserAccountID>::~bdArray<bdStructUserAccountID>(bdArray<bdStructUserAccountID> *this)
{
  ??1?$bdArray@VbdStructUserAccountID@@@@QEAA@XZ(this);
}

/*
==============
bdArray<bdObjectStoreErrorWrappedObject>::operator=
==============
*/

void __fastcall bdArray<bdObjectStoreErrorWrappedObject>::operator=(bdArray<bdObjectStoreErrorWrappedObject> *this, const bdArray<bdObjectStoreErrorWrappedObject> *a)
{
  ??4?$bdArray@VbdObjectStoreErrorWrappedObject@@@@QEAAXAEBV0@@Z(this, a);
}

/*
==============
bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>::uninitializedCopy
==============
*/

bdQoSProbe::bdQoSProbeEntryWrapper *__fastcall bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>::uninitializedCopy(bdArray<bdQoSProbe::bdQoSProbeEntryWrapper> *this, const bdArray<bdQoSProbe::bdQoSProbeEntryWrapper> *a)
{
  return ?uninitializedCopy@?$bdArray@UbdQoSProbeEntryWrapper@bdQoSProbe@@@@IEBAPEAUbdQoSProbeEntryWrapper@bdQoSProbe@@AEBV1@@Z(this, a);
}

/*
==============
bdArray<bdClansRemovedMembershipProposal>::destruct
==============
*/

void __fastcall bdArray<bdClansRemovedMembershipProposal>::destruct(bdArray<bdClansRemovedMembershipProposal> *this, bdClansRemovedMembershipProposal *src, const unsigned int n)
{
  ?destruct@?$bdArray@VbdClansRemovedMembershipProposal@@@@IEBAXPEAVbdClansRemovedMembershipProposal@@I@Z(this, src, n);
}

/*
==============
bdArray<bdString>::clear
==============
*/

void __fastcall bdArray<bdString>::clear(bdArray<bdString> *this)
{
  ?clear@?$bdArray@VbdString@@@@QEAAXXZ(this);
}

/*
==============
bdArray<bdClansRemovedMembershipProposal>::operator=
==============
*/

void __fastcall bdArray<bdClansRemovedMembershipProposal>::operator=(bdArray<bdClansRemovedMembershipProposal> *this, const bdArray<bdClansRemovedMembershipProposal> *a)
{
  ??4?$bdArray@VbdClansRemovedMembershipProposal@@@@QEAAXAEBV0@@Z(this, a);
}

/*
==============
bdArray<bdObjectStoreTag>::increaseCapacity
==============
*/

void __fastcall bdArray<bdObjectStoreTag>::increaseCapacity(bdArray<bdObjectStoreTag> *this, const unsigned int increase)
{
  ?increaseCapacity@?$bdArray@VbdObjectStoreTag@@@@QEAAXI@Z(this, increase);
}

/*
==============
bdArray<bdObjectStoreCacheAwareObjectID>::copyConstructArrayArray
==============
*/

void __fastcall bdArray<bdObjectStoreCacheAwareObjectID>::copyConstructArrayArray(bdArray<bdObjectStoreCacheAwareObjectID> *this, bdObjectStoreCacheAwareObjectID *dest, const bdObjectStoreCacheAwareObjectID *src, const unsigned int n)
{
  ?copyConstructArrayArray@?$bdArray@VbdObjectStoreCacheAwareObjectID@@@@IEBAXPEAVbdObjectStoreCacheAwareObjectID@@PEBV2@I@Z(this, dest, src, n);
}

/*
==============
bdArray<bdString>::pushBack
==============
*/

void __fastcall bdArray<bdString>::pushBack(bdArray<bdString> *this, const bdString *value)
{
  ?pushBack@?$bdArray@VbdString@@@@QEAAXAEBVbdString@@@Z(this, value);
}

/*
==============
bdArray<bdClansGroupMemberInfo>::copyConstructArrayArray
==============
*/

void __fastcall bdArray<bdClansGroupMemberInfo>::copyConstructArrayArray(bdArray<bdClansGroupMemberInfo> *this, bdClansGroupMemberInfo *dest, const bdClansGroupMemberInfo *src, const unsigned int n)
{
  ?copyConstructArrayArray@?$bdArray@VbdClansGroupMemberInfo@@@@IEBAXPEAVbdClansGroupMemberInfo@@PEBV2@I@Z(this, dest, src, n);
}

/*
==============
bdArray<bdRESTInternalResponse>::increaseCapacity
==============
*/

void __fastcall bdArray<bdRESTInternalResponse>::increaseCapacity(bdArray<bdRESTInternalResponse> *this, const unsigned int increase)
{
  ?increaseCapacity@?$bdArray@VbdRESTInternalResponse@@@@QEAAXI@Z(this, increase);
}

/*
==============
bdArray<bdJSONValue>::copyConstructArrayArray
==============
*/

void __fastcall bdArray<bdJSONValue>::copyConstructArrayArray(bdArray<bdJSONValue> *this, bdJSONValue *dest, const bdJSONValue *src, const unsigned int n)
{
  ?copyConstructArrayArray@?$bdArray@VbdJSONValue@@@@IEBAXPEAVbdJSONValue@@PEBV2@I@Z(this, dest, src, n);
}

/*
==============
bdArray<bdClansGroupMembershipProposal>::~bdArray<bdClansGroupMembershipProposal>
==============
*/

void __fastcall bdArray<bdClansGroupMembershipProposal>::~bdArray<bdClansGroupMembershipProposal>(bdArray<bdClansGroupMembershipProposal> *this)
{
  ??1?$bdArray@VbdClansGroupMembershipProposal@@@@QEAA@XZ(this);
}

/*
==============
bdArray<bdClansGroupIdentifier>::~bdArray<bdClansGroupIdentifier>
==============
*/

void __fastcall bdArray<bdClansGroupIdentifier>::~bdArray<bdClansGroupIdentifier>(bdArray<bdClansGroupIdentifier> *this)
{
  ??1?$bdArray@VbdClansGroupIdentifier@@@@QEAA@XZ(this);
}

/*
==============
bdArray<bdAddr>::operator=
==============
*/

void __fastcall bdArray<bdAddr>::operator=(bdArray<bdAddr> *this, const bdArray<bdAddr> *a)
{
  ??4?$bdArray@VbdAddr@@@@QEAAXAEBV0@@Z(this, a);
}

/*
==============
bdArray<bdObjectStoreMetadata>::increaseCapacity
==============
*/

void __fastcall bdArray<bdObjectStoreMetadata>::increaseCapacity(bdArray<bdObjectStoreMetadata> *this, const unsigned int increase)
{
  ?increaseCapacity@?$bdArray@VbdObjectStoreMetadata@@@@QEAAXI@Z(this, increase);
}

/*
==============
bdArray<bdObjectStoreObject>::operator=
==============
*/

void __fastcall bdArray<bdObjectStoreObject>::operator=(bdArray<bdObjectStoreObject> *this, const bdArray<bdObjectStoreObject> *a)
{
  ??4?$bdArray@VbdObjectStoreObject@@@@QEAAXAEBV0@@Z(this, a);
}

/*
==============
bdArray<GeneralChannelRequest>::~bdArray<GeneralChannelRequest>
==============
*/

void __fastcall bdArray<GeneralChannelRequest>::~bdArray<GeneralChannelRequest>(bdArray<GeneralChannelRequest> *this)
{
  ??1?$bdArray@VGeneralChannelRequest@@@@QEAA@XZ(this);
}

/*
==============
bdArray<bdString>::operator=
==============
*/

void __fastcall bdArray<bdString>::operator=(bdArray<bdString> *this, const bdArray<bdString> *a)
{
  ??4?$bdArray@VbdString@@@@QEAAXAEBV0@@Z(this, a);
}

/*
==============
bdArray<bdObjectStoreErrorWrappedMetadata>::~bdArray<bdObjectStoreErrorWrappedMetadata>
==============
*/

void __fastcall bdArray<bdObjectStoreErrorWrappedMetadata>::~bdArray<bdObjectStoreErrorWrappedMetadata>(bdArray<bdObjectStoreErrorWrappedMetadata> *this)
{
  ??1?$bdArray@VbdObjectStoreErrorWrappedMetadata@@@@QEAA@XZ(this);
}

/*
==============
bdArray<bdClansGroupInfo>::destruct
==============
*/

void __fastcall bdArray<bdClansGroupInfo>::destruct(bdArray<bdClansGroupInfo> *this, bdClansGroupInfo *src, const unsigned int n)
{
  ?destruct@?$bdArray@VbdClansGroupInfo@@@@IEBAXPEAVbdClansGroupInfo@@I@Z(this, src, n);
}

/*
==============
bdArray<bdJSONValue>::clear
==============
*/

void __fastcall bdArray<bdJSONValue>::clear(bdArray<bdJSONValue> *this)
{
  ?clear@?$bdArray@VbdJSONValue@@@@QEAAXXZ(this);
}

/*
==============
bdArray<bdAddr>::pushBack
==============
*/

void __fastcall bdArray<bdAddr>::pushBack(bdArray<bdAddr> *this, const bdAddr *value)
{
  ?pushBack@?$bdArray@VbdAddr@@@@QEAAXAEBVbdAddr@@@Z(this, value);
}

/*
==============
bdArray<bdChannelMember>::~bdArray<bdChannelMember>
==============
*/

void __fastcall bdArray<bdChannelMember>::~bdArray<bdChannelMember>(bdArray<bdChannelMember> *this)
{
  ??1?$bdArray@VbdChannelMember@@@@QEAA@XZ(this);
}

/*
==============
bdArray<bdClansRemovedMembershipProposal>::~bdArray<bdClansRemovedMembershipProposal>
==============
*/

void __fastcall bdArray<bdClansRemovedMembershipProposal>::~bdArray<bdClansRemovedMembershipProposal>(bdArray<bdClansRemovedMembershipProposal> *this)
{
  ??1?$bdArray@VbdClansRemovedMembershipProposal@@@@QEAA@XZ(this);
}

/*
==============
bdArray<bdRESTInternalResponse>::copyConstructArrayArray
==============
*/

void __fastcall bdArray<bdRESTInternalResponse>::copyConstructArrayArray(bdArray<bdRESTInternalResponse> *this, bdRESTInternalResponse *dest, const bdRESTInternalResponse *src, const unsigned int n)
{
  ?copyConstructArrayArray@?$bdArray@VbdRESTInternalResponse@@@@IEBAXPEAVbdRESTInternalResponse@@PEBV2@I@Z(this, dest, src, n);
}

/*
==============
bdArray<bdJSONValue>::uninitializedCopy
==============
*/

bdJSONValue *__fastcall bdArray<bdJSONValue>::uninitializedCopy(bdArray<bdJSONValue> *this, const bdArray<bdJSONValue> *a)
{
  return ?uninitializedCopy@?$bdArray@VbdJSONValue@@@@IEBAPEAVbdJSONValue@@AEBV1@@Z(this, a);
}

/*
==============
bdArray<bdString>::copyConstructArrayArray
==============
*/

void __fastcall bdArray<bdString>::copyConstructArrayArray(bdArray<bdString> *this, bdString *dest, const bdString *src, const unsigned int n)
{
  ?copyConstructArrayArray@?$bdArray@VbdString@@@@IEBAXPEAVbdString@@PEBV2@I@Z(this, dest, src, n);
}

/*
==============
bdArray<bdClansGroupIdentifier>::copyConstructArrayArray
==============
*/

void __fastcall bdArray<bdClansGroupIdentifier>::copyConstructArrayArray(bdArray<bdClansGroupIdentifier> *this, bdClansGroupIdentifier *dest, const bdClansGroupIdentifier *src, const unsigned int n)
{
  ?copyConstructArrayArray@?$bdArray@VbdClansGroupIdentifier@@@@IEBAXPEAVbdClansGroupIdentifier@@PEBV2@I@Z(this, dest, src, n);
}

/*
==============
bdArray<bdClansUserMembershipProposal>::uninitializedCopy
==============
*/

bdClansUserMembershipProposal *__fastcall bdArray<bdClansUserMembershipProposal>::uninitializedCopy(bdArray<bdClansUserMembershipProposal> *this, const bdArray<bdClansUserMembershipProposal> *a)
{
  return ?uninitializedCopy@?$bdArray@VbdClansUserMembershipProposal@@@@IEBAPEAVbdClansUserMembershipProposal@@AEBV1@@Z(this, a);
}

/*
==============
bdArray<bdClansUserMembershipProposal>::destruct
==============
*/

void __fastcall bdArray<bdClansUserMembershipProposal>::destruct(bdArray<bdClansUserMembershipProposal> *this, bdClansUserMembershipProposal *src, const unsigned int n)
{
  ?destruct@?$bdArray@VbdClansUserMembershipProposal@@@@IEBAXPEAVbdClansUserMembershipProposal@@I@Z(this, src, n);
}

/*
==============
bdArray<bdObjectStoreObject>::clear
==============
*/

void __fastcall bdArray<bdObjectStoreObject>::clear(bdArray<bdObjectStoreObject> *this)
{
  ?clear@?$bdArray@VbdObjectStoreObject@@@@QEAAXXZ(this);
}

/*
==============
bdArray<bdChannelMember>::destruct
==============
*/

void __fastcall bdArray<bdChannelMember>::destruct(bdArray<bdChannelMember> *this, bdChannelMember *src, const unsigned int n)
{
  ?destruct@?$bdArray@VbdChannelMember@@@@IEBAXPEAVbdChannelMember@@I@Z(this, src, n);
}

/*
==============
bdArray<bdClansGroupInfo>::copyConstructArrayArray
==============
*/

void __fastcall bdArray<bdClansGroupInfo>::copyConstructArrayArray(bdArray<bdClansGroupInfo> *this, bdClansGroupInfo *dest, const bdClansGroupInfo *src, const unsigned int n)
{
  ?copyConstructArrayArray@?$bdArray@VbdClansGroupInfo@@@@IEBAXPEAVbdClansGroupInfo@@PEBV2@I@Z(this, dest, src, n);
}

/*
==============
bdArray<bdAchievementState>::pushBack
==============
*/

void __fastcall bdArray<bdAchievementState>::pushBack(bdArray<bdAchievementState> *this, const bdAchievementState *value)
{
  ?pushBack@?$bdArray@VbdAchievementState@@@@QEAAXAEBVbdAchievementState@@@Z(this, value);
}

/*
==============
bdArray<bdStructUserAccountID>::destruct
==============
*/

void __fastcall bdArray<bdStructUserAccountID>::destruct(bdArray<bdStructUserAccountID> *this, bdStructUserAccountID *src, const unsigned int n)
{
  ?destruct@?$bdArray@VbdStructUserAccountID@@@@IEBAXPEAVbdStructUserAccountID@@I@Z(this, src, n);
}

/*
==============
bdArray<bdRESTInternalResponse>::~bdArray<bdRESTInternalResponse>
==============
*/

void __fastcall bdArray<bdRESTInternalResponse>::~bdArray<bdRESTInternalResponse>(bdArray<bdRESTInternalResponse> *this)
{
  ??1?$bdArray@VbdRESTInternalResponse@@@@QEAA@XZ(this);
}

/*
==============
bdArray<bdObjectStoreTag>::operator=
==============
*/

void __fastcall bdArray<bdObjectStoreTag>::operator=(bdArray<bdObjectStoreTag> *this, const bdArray<bdObjectStoreTag> *a)
{
  ??4?$bdArray@VbdObjectStoreTag@@@@QEAAXAEBV0@@Z(this, a);
}

/*
==============
bdArray<bdObjectStoreValidationToken>::clear
==============
*/

void __fastcall bdArray<bdObjectStoreValidationToken>::clear(bdArray<bdObjectStoreValidationToken> *this)
{
  ?clear@?$bdArray@VbdObjectStoreValidationToken@@@@QEAAXXZ(this);
}

/*
==============
bdArray<bdAddr>::copyConstructArrayArray
==============
*/

void __fastcall bdArray<bdAddr>::copyConstructArrayArray(bdArray<bdAddr> *this, bdAddr *dest, const bdAddr *src, const unsigned int n)
{
  ?copyConstructArrayArray@?$bdArray@VbdAddr@@@@IEBAXPEAVbdAddr@@PEBV2@I@Z(this, dest, src, n);
}

/*
==============
bdArray<bdAntiCheatChallengeParam>::ensureCapacity
==============
*/

void __fastcall bdArray<bdAntiCheatChallengeParam>::ensureCapacity(bdArray<bdAntiCheatChallengeParam> *this, const unsigned int capacity)
{
  ?ensureCapacity@?$bdArray@VbdAntiCheatChallengeParam@@@@QEAAXI@Z(this, capacity);
}

/*
==============
bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>::~bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>
==============
*/

void __fastcall bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>::~bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>(bdArray<bdQoSProbe::bdQoSProbeEntryWrapper> *this)
{
  ??1?$bdArray@UbdQoSProbeEntryWrapper@bdQoSProbe@@@@QEAA@XZ(this);
}

/*
==============
bdArray<bdClansUserMembershipProposal>::~bdArray<bdClansUserMembershipProposal>
==============
*/

void __fastcall bdArray<bdClansUserMembershipProposal>::~bdArray<bdClansUserMembershipProposal>(bdArray<bdClansUserMembershipProposal> *this)
{
  ??1?$bdArray@VbdClansUserMembershipProposal@@@@QEAA@XZ(this);
}

/*
==============
bdArray<bdClansGroupIdentifier>::uninitializedCopy
==============
*/

bdClansGroupIdentifier *__fastcall bdArray<bdClansGroupIdentifier>::uninitializedCopy(bdArray<bdClansGroupIdentifier> *this, const bdArray<bdClansGroupIdentifier> *a)
{
  return ?uninitializedCopy@?$bdArray@VbdClansGroupIdentifier@@@@IEBAPEAVbdClansGroupIdentifier@@AEBV1@@Z(this, a);
}

/*
==============
bdArray<bdObjectStoreMetadata>::clear
==============
*/

void __fastcall bdArray<bdObjectStoreMetadata>::clear(bdArray<bdObjectStoreMetadata> *this)
{
  ?clear@?$bdArray@VbdObjectStoreMetadata@@@@QEAAXXZ(this);
}

/*
==============
bdArray<bdClansGroupMemberInfo>::~bdArray<bdClansGroupMemberInfo>
==============
*/

void __fastcall bdArray<bdClansGroupMemberInfo>::~bdArray<bdClansGroupMemberInfo>(bdArray<bdClansGroupMemberInfo> *this)
{
  ??1?$bdArray@VbdClansGroupMemberInfo@@@@QEAA@XZ(this);
}

/*
==============
bdArray<bdObjectStoreHTTPHeader>::operator[]
==============
*/

const bdObjectStoreHTTPHeader *__fastcall bdArray<bdObjectStoreHTTPHeader>::operator[](bdArray<bdObjectStoreHTTPHeader> *this, const unsigned int i)
{
  return ??A?$bdArray@VbdObjectStoreHTTPHeader@@@@QEBAAEBVbdObjectStoreHTTPHeader@@I@Z(this, i);
}

/*
==============
bdArray<bdQoSHostStats>::~bdArray<bdQoSHostStats>
==============
*/

void __fastcall bdArray<bdQoSHostStats>::~bdArray<bdQoSHostStats>(bdArray<bdQoSHostStats> *this)
{
  ??1?$bdArray@UbdQoSHostStats@@@@QEAA@XZ(this);
}

/*
==============
bdArray<bdClansGroupMembershipInfo>::bdArray<bdClansGroupMembershipInfo>
==============
*/

void __fastcall bdArray<bdClansGroupMembershipInfo>::bdArray<bdClansGroupMembershipInfo>(bdArray<bdClansGroupMembershipInfo> *this, const bdArray<bdClansGroupMembershipInfo> *a)
{
  ??0?$bdArray@VbdClansGroupMembershipInfo@@@@QEAA@AEBV0@@Z(this, a);
}

/*
==============
bdArray<bdQoSProbeInfo>::destruct
==============
*/

void __fastcall bdArray<bdQoSProbeInfo>::destruct(bdArray<bdQoSProbeInfo> *this, bdQoSProbeInfo *src, const unsigned int n)
{
  ?destruct@?$bdArray@VbdQoSProbeInfo@@@@IEBAXPEAVbdQoSProbeInfo@@I@Z(this, src, n);
}

/*
==============
bdArray<bdObjectStoreErrorWrappedMetadata>::clear
==============
*/

void __fastcall bdArray<bdObjectStoreErrorWrappedMetadata>::clear(bdArray<bdObjectStoreErrorWrappedMetadata> *this)
{
  ?clear@?$bdArray@VbdObjectStoreErrorWrappedMetadata@@@@QEAAXXZ(this);
}

/*
==============
bdArray<bdClansRemovedMembershipProposal>::pushBack
==============
*/

void __fastcall bdArray<bdClansRemovedMembershipProposal>::pushBack(bdArray<bdClansRemovedMembershipProposal> *this, const bdClansRemovedMembershipProposal *value)
{
  ?pushBack@?$bdArray@VbdClansRemovedMembershipProposal@@@@QEAAXAEBVbdClansRemovedMembershipProposal@@@Z(this, value);
}

/*
==============
bdArray<bdObjectStoreValidationToken>::~bdArray<bdObjectStoreValidationToken>
==============
*/

void __fastcall bdArray<bdObjectStoreValidationToken>::~bdArray<bdObjectStoreValidationToken>(bdArray<bdObjectStoreValidationToken> *this)
{
  ??1?$bdArray@VbdObjectStoreValidationToken@@@@QEAA@XZ(this);
}

/*
==============
bdArray<bdChannelMember>::pushBack
==============
*/

void __fastcall bdArray<bdChannelMember>::pushBack(bdArray<bdChannelMember> *this, const bdChannelMember *value)
{
  ?pushBack@?$bdArray@VbdChannelMember@@@@QEAAXAEBVbdChannelMember@@@Z(this, value);
}

/*
==============
bdArray<bdClansFailedMembershipProposal>::~bdArray<bdClansFailedMembershipProposal>
==============
*/

void __fastcall bdArray<bdClansFailedMembershipProposal>::~bdArray<bdClansFailedMembershipProposal>(bdArray<bdClansFailedMembershipProposal> *this)
{
  ??1?$bdArray@VbdClansFailedMembershipProposal@@@@QEAA@XZ(this);
}

/*
==============
bdArray<bdSockAddr>::operator=
==============
*/

void __fastcall bdArray<bdSockAddr>::operator=(bdArray<bdSockAddr> *this, const bdArray<bdSockAddr> *a)
{
  ??4?$bdArray@VbdSockAddr@@@@QEAAXAEBV0@@Z(this, a);
}

/*
==============
bdArray<bdObjectStoreHTTPHeader>::~bdArray<bdObjectStoreHTTPHeader>
==============
*/

void __fastcall bdArray<bdObjectStoreHTTPHeader>::~bdArray<bdObjectStoreHTTPHeader>(bdArray<bdObjectStoreHTTPHeader> *this)
{
  ??1?$bdArray@VbdObjectStoreHTTPHeader@@@@QEAA@XZ(this);
}

/*
==============
bdArray<bdAchievementState>::copyConstructArrayArray
==============
*/

void __fastcall bdArray<bdAchievementState>::copyConstructArrayArray(bdArray<bdAchievementState> *this, bdAchievementState *dest, const bdAchievementState *src, const unsigned int n)
{
  ?copyConstructArrayArray@?$bdArray@VbdAchievementState@@@@IEBAXPEAVbdAchievementState@@PEBV2@I@Z(this, dest, src, n);
}

/*
==============
bdArray<bdObjectStoreErrorWrappedMetadata>::increaseCapacity
==============
*/

void __fastcall bdArray<bdObjectStoreErrorWrappedMetadata>::increaseCapacity(bdArray<bdObjectStoreErrorWrappedMetadata> *this, const unsigned int increase)
{
  ?increaseCapacity@?$bdArray@VbdObjectStoreErrorWrappedMetadata@@@@QEAAXI@Z(this, increase);
}

/*
==============
bdArray<bdClansUserMembershipProposal>::pushBack
==============
*/

void __fastcall bdArray<bdClansUserMembershipProposal>::pushBack(bdArray<bdClansUserMembershipProposal> *this, const bdClansUserMembershipProposal *value)
{
  ?pushBack@?$bdArray@VbdClansUserMembershipProposal@@@@QEAAXAEBVbdClansUserMembershipProposal@@@Z(this, value);
}

/*
==============
bdArray<bdClansGroupIdentifier>::destruct
==============
*/

void __fastcall bdArray<bdClansGroupIdentifier>::destruct(bdArray<bdClansGroupIdentifier> *this, bdClansGroupIdentifier *src, const unsigned int n)
{
  ?destruct@?$bdArray@VbdClansGroupIdentifier@@@@IEBAXPEAVbdClansGroupIdentifier@@I@Z(this, src, n);
}

/*
==============
bdArray<bdAntiCheatChallengeParam>::operator=
==============
*/

void __fastcall bdArray<bdAntiCheatChallengeParam>::operator=(bdArray<bdAntiCheatChallengeParam> *this, const bdArray<bdAntiCheatChallengeParam> *a)
{
  ??4?$bdArray@VbdAntiCheatChallengeParam@@@@QEAAXAEBV0@@Z(this, a);
}

/*
==============
bdArray<bdObjectStoreErrorWrappedObject>::clear
==============
*/

void __fastcall bdArray<bdObjectStoreErrorWrappedObject>::clear(bdArray<bdObjectStoreErrorWrappedObject> *this)
{
  ?clear@?$bdArray@VbdObjectStoreErrorWrappedObject@@@@QEAAXXZ(this);
}

/*
==============
bdArray<bdClansGroupMembershipProposal>::copyConstructArrayArray
==============
*/

void __fastcall bdArray<bdClansGroupMembershipProposal>::copyConstructArrayArray(bdArray<bdClansGroupMembershipProposal> *this, bdClansGroupMembershipProposal *dest, const bdClansGroupMembershipProposal *src, const unsigned int n)
{
  ?copyConstructArrayArray@?$bdArray@VbdClansGroupMembershipProposal@@@@IEBAXPEAVbdClansGroupMembershipProposal@@PEBV2@I@Z(this, dest, src, n);
}

/*
==============
bdArray<bdString>::~bdArray<bdString>
==============
*/

void __fastcall bdArray<bdString>::~bdArray<bdString>(bdArray<bdString> *this)
{
  ??1?$bdArray@VbdString@@@@QEAA@XZ(this);
}

/*
==============
bdArray<bdObjectStoreTag>::~bdArray<bdObjectStoreTag>
==============
*/

void __fastcall bdArray<bdObjectStoreTag>::~bdArray<bdObjectStoreTag>(bdArray<bdObjectStoreTag> *this)
{
  ??1?$bdArray@VbdObjectStoreTag@@@@QEAA@XZ(this);
}

/*
==============
bdArray<bdAddr>::~bdArray<bdAddr>
==============
*/

void __fastcall bdArray<bdAddr>::~bdArray<bdAddr>(bdArray<bdAddr> *this)
{
  ??1?$bdArray@VbdAddr@@@@QEAA@XZ(this);
}

/*
==============
bdArray<bdClansGroupMembershipInfo>::operator=
==============
*/

void __fastcall bdArray<bdClansGroupMembershipInfo>::operator=(bdArray<bdClansGroupMembershipInfo> *this, const bdArray<bdClansGroupMembershipInfo> *a)
{
  ??4?$bdArray@VbdClansGroupMembershipInfo@@@@QEAAXAEBV0@@Z(this, a);
}

/*
==============
bdArray<bdAchievementState>::~bdArray<bdAchievementState>
==============
*/

void __fastcall bdArray<bdAchievementState>::~bdArray<bdAchievementState>(bdArray<bdAchievementState> *this)
{
  ??1?$bdArray@VbdAchievementState@@@@QEAA@XZ(this);
}

/*
==============
bdArray<bdAntiCheatChallengeParam>::operator=
==============
*/
void bdArray<bdAntiCheatChallengeParam>::operator=(bdArray<bdAntiCheatChallengeParam> *this, const bdArray<bdAntiCheatChallengeParam> *a)
{
  __int64 m_size; 
  unsigned int v5; 
  bdAntiCheatChallengeParam *v6; 
  bdAntiCheatChallengeParam *v7; 
  __int64 v8; 
  bdAntiCheatChallengeParam *v9; 
  __int64 v10; 
  unsigned int v11; 
  bdAntiCheatChallengeParam *v12; 
  char *v13; 
  __int64 v14; 
  unsigned int v15; 
  bdAntiCheatChallengeParam *v16; 
  bdAntiCheatChallengeParam *v17; 
  bdAntiCheatChallengeParam *v18; 
  signed __int64 v19; 
  __int64 v20; 
  unsigned int v21; 
  __int64 v22; 
  unsigned int v23; 
  bdAntiCheatChallengeParam *v24; 
  bdAntiCheatChallengeParam *v25; 
  __int64 v26; 
  unsigned int m_capacity; 
  unsigned int v28; 
  bdAntiCheatChallengeParam *m_data; 
  bdAntiCheatChallengeParam *v30; 
  __int64 v31; 

  if ( this != a )
  {
    v31 = -2i64;
    m_size = a->m_size;
    if ( (unsigned int)m_size <= this->m_capacity )
    {
      v15 = this->m_size;
      v16 = NULL;
      if ( (unsigned int)m_size <= v15 )
      {
        v21 = 0;
        if ( (_DWORD)m_size )
        {
          v22 = 0i64;
          do
          {
            bdHandleAssert(v21 < a->m_size, "rangeCheck(i)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdarray.inl", "bdArray<class bdAntiCheatChallengeParam>::operator []", 0x70u, "bdArray<T>::operator[], rangecheck failed", v31);
            bdAntiCheatChallengeParam::operator=(&this->m_data[v22], &a->m_data[v22]);
            ++v21;
            ++v22;
          }
          while ( v21 < (unsigned int)m_size );
          v15 = this->m_size;
        }
        v23 = v15 - m_size;
        v24 = &this->m_data[m_size];
        if ( v23 )
        {
          v25 = &this->m_data[m_size];
          v26 = v23;
          do
          {
            ((void (__fastcall *)(bdAntiCheatChallengeParam *, _QWORD))v24->~bdAntiCheatChallengeParam)(v25++, 0i64);
            ++v24;
            --v26;
          }
          while ( v26 );
        }
        this->m_size = m_size;
        m_capacity = this->m_capacity;
        if ( m_capacity > 4 * (int)m_size )
        {
          v28 = m_capacity - (m_capacity >> 1);
          this->m_capacity = v28;
          if ( v28 )
          {
            v16 = (bdAntiCheatChallengeParam *)bdMemory::allocate(24i64 * v28);
            bdArray<bdAntiCheatChallengeParam>::copyConstructArrayArray(this, v16, this->m_data, this->m_size);
            m_size = this->m_size;
          }
          m_data = this->m_data;
          if ( (_DWORD)m_size )
          {
            v30 = this->m_data;
            do
            {
              ((void (__fastcall *)(bdAntiCheatChallengeParam *, _QWORD))m_data->~bdAntiCheatChallengeParam)(v30++, 0i64);
              ++m_data;
              --m_size;
            }
            while ( m_size );
            m_data = this->m_data;
          }
          bdMemory::deallocate(m_data);
          this->m_data = v16;
        }
      }
      else
      {
        if ( v15 )
        {
          do
          {
            bdHandleAssert((unsigned int)v16 < a->m_size, "rangeCheck(i)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdarray.inl", "bdArray<class bdAntiCheatChallengeParam>::operator []", 0x70u, "bdArray<T>::operator[], rangecheck failed", v31);
            bdAntiCheatChallengeParam::operator=(&this->m_data[(unsigned int)v16], &a->m_data[(unsigned int)v16]);
            LODWORD(v16) = (_DWORD)v16 + 1;
            v15 = this->m_size;
          }
          while ( (unsigned int)v16 < v15 );
        }
        v17 = &a->m_data[v15];
        v18 = &this->m_data[v15];
        if ( (_DWORD)m_size != v15 )
        {
          v19 = (char *)v17 - (char *)v18;
          v20 = (unsigned int)m_size - v15;
          do
          {
            if ( v18 )
              bdAntiCheatChallengeParam::bdAntiCheatChallengeParam(v18, (bdAntiCheatChallengeParam *)((char *)v18 + v19));
            ++v18;
            --v20;
          }
          while ( v20 );
        }
        this->m_size = m_size;
      }
    }
    else
    {
      v5 = this->m_size;
      v6 = this->m_data;
      if ( v5 )
      {
        v7 = this->m_data;
        v8 = v5;
        do
        {
          ((void (__fastcall *)(bdAntiCheatChallengeParam *, _QWORD))v6->~bdAntiCheatChallengeParam)(v7++, 0i64);
          ++v6;
          --v8;
        }
        while ( v8 );
        v6 = this->m_data;
      }
      bdMemory::deallocate(v6);
      v9 = NULL;
      this->m_data = NULL;
      *(_QWORD *)&this->m_capacity = 0i64;
      v10 = a->m_capacity;
      if ( (_DWORD)v10 )
      {
        v9 = (bdAntiCheatChallengeParam *)bdMemory::allocate(24 * v10);
        v11 = a->m_size;
        if ( v11 )
        {
          v12 = v9;
          v13 = (char *)((char *)a->m_data - (char *)v9);
          v14 = v11;
          do
          {
            if ( v12 )
              bdAntiCheatChallengeParam::bdAntiCheatChallengeParam(v12, (const bdAntiCheatChallengeParam *)((char *)v12 + (_QWORD)v13));
            ++v12;
            --v14;
          }
          while ( v14 );
        }
      }
      this->m_data = v9;
      this->m_capacity = a->m_capacity;
      this->m_size = m_size;
    }
  }
}

/*
==============
bdArray<bdAntiCheatChallengeParam>::copyConstructArrayArray
==============
*/
void bdArray<bdAntiCheatChallengeParam>::copyConstructArrayArray(bdArray<bdAntiCheatChallengeParam> *this, bdAntiCheatChallengeParam *dest, const bdAntiCheatChallengeParam *src, const unsigned int n)
{
  bdAntiCheatChallengeParam *v4; 
  signed __int64 v5; 
  __int64 v6; 

  if ( n )
  {
    v4 = dest;
    v5 = (char *)src - (char *)dest;
    v6 = n;
    do
    {
      if ( v4 )
        bdAntiCheatChallengeParam::bdAntiCheatChallengeParam(v4, (bdAntiCheatChallengeParam *)((char *)v4 + v5));
      ++v4;
      --v6;
    }
    while ( v6 );
  }
}

/*
==============
bdArray<bdClansFailedMembershipProposal>::~bdArray<bdClansFailedMembershipProposal>
==============
*/
void bdArray<bdClansFailedMembershipProposal>::~bdArray<bdClansFailedMembershipProposal>(bdArray<bdClansFailedMembershipProposal> *this)
{
  unsigned int m_size; 
  bdClansFailedMembershipProposal *m_data; 
  __int64 v4; 
  __int64 v5; 
  __int64 v6; 
  __int64 v7; 

  m_size = this->m_size;
  m_data = this->m_data;
  if ( m_size )
  {
    v4 = 0i64;
    v5 = 0i64;
    v6 = m_size;
    do
    {
      v7 = *(int *)(*((_QWORD *)&m_data[v4].__vftable + 1) + 4i64);
      (**(void (__fastcall ***)(__int64, _QWORD))((char *)&m_data->__vftable + v7 + v4 * 264 + 8))((__int64)&m_data->__vftable + v7 + v5 + 8, 0i64);
      v5 += 264i64;
      ++v4;
      --v6;
    }
    while ( v6 );
    m_data = this->m_data;
  }
  bdMemory::deallocate(m_data);
  this->m_data = NULL;
  *(_QWORD *)&this->m_capacity = 0i64;
}

/*
==============
bdArray<bdClansGroupInfo>::~bdArray<bdClansGroupInfo>
==============
*/
void bdArray<bdClansGroupInfo>::~bdArray<bdClansGroupInfo>(bdArray<bdClansGroupInfo> *this)
{
  unsigned int m_size; 
  bdClansGroupInfo *m_data; 
  __int64 v4; 
  __int64 v5; 
  __int64 v6; 
  __int64 v7; 

  m_size = this->m_size;
  m_data = this->m_data;
  if ( m_size )
  {
    v4 = 0i64;
    v5 = 0i64;
    v6 = m_size;
    do
    {
      v7 = *(int *)(*((_QWORD *)&m_data[v4].__vftable + 1) + 4i64);
      (**(void (__fastcall ***)(__int64, _QWORD))((char *)&m_data->__vftable + v7 + v4 * 696 + 8))((__int64)&m_data->__vftable + v7 + v5 + 8, 0i64);
      v5 += 696i64;
      ++v4;
      --v6;
    }
    while ( v6 );
    m_data = this->m_data;
  }
  bdMemory::deallocate(m_data);
  this->m_data = NULL;
  *(_QWORD *)&this->m_capacity = 0i64;
}

/*
==============
bdArray<bdClansGroupMemberInfo>::~bdArray<bdClansGroupMemberInfo>
==============
*/
void bdArray<bdClansGroupMemberInfo>::~bdArray<bdClansGroupMemberInfo>(bdArray<bdClansGroupMemberInfo> *this)
{
  unsigned int m_size; 
  bdClansGroupMemberInfo *m_data; 
  __int64 v4; 
  __int64 v5; 
  __int64 v6; 
  __int64 v7; 

  m_size = this->m_size;
  m_data = this->m_data;
  if ( m_size )
  {
    v4 = 0i64;
    v5 = 0i64;
    v6 = m_size;
    do
    {
      v7 = *(int *)(*((_QWORD *)&m_data[v4].__vftable + 1) + 4i64);
      (**(void (__fastcall ***)(__int64, _QWORD))((char *)&m_data->__vftable + v7 + v4 * 216 + 8))((__int64)&m_data->__vftable + v7 + v5 + 8, 0i64);
      v5 += 216i64;
      ++v4;
      --v6;
    }
    while ( v6 );
    m_data = this->m_data;
  }
  bdMemory::deallocate(m_data);
  this->m_data = NULL;
  *(_QWORD *)&this->m_capacity = 0i64;
}

/*
==============
bdArray<bdClansGroupMembershipInfo>::~bdArray<bdClansGroupMembershipInfo>
==============
*/
void bdArray<bdClansGroupMembershipInfo>::~bdArray<bdClansGroupMembershipInfo>(bdArray<bdClansGroupMembershipInfo> *this)
{
  bdArray<bdClansGroupMembershipInfo>::destruct(this, this->m_data, this->m_size);
  bdMemory::deallocate(this->m_data);
  this->m_data = NULL;
  *(_QWORD *)&this->m_capacity = 0i64;
}

/*
==============
bdArray<bdClansGroupMembershipProposal>::~bdArray<bdClansGroupMembershipProposal>
==============
*/
void bdArray<bdClansGroupMembershipProposal>::~bdArray<bdClansGroupMembershipProposal>(bdArray<bdClansGroupMembershipProposal> *this)
{
  unsigned int m_size; 
  bdClansGroupMembershipProposal *m_data; 
  __int64 v4; 
  __int64 v5; 
  __int64 v6; 
  __int64 v7; 

  m_size = this->m_size;
  m_data = this->m_data;
  if ( m_size )
  {
    v4 = 0i64;
    v5 = 0i64;
    v6 = m_size;
    do
    {
      v7 = *(int *)(*((_QWORD *)&m_data[v4].__vftable + 1) + 4i64);
      (**(void (__fastcall ***)(__int64, _QWORD))((char *)&m_data->__vftable + v7 + v4 * 1472 + 8))((__int64)&m_data->__vftable + v7 + v5 + 8, 0i64);
      v5 += 1472i64;
      ++v4;
      --v6;
    }
    while ( v6 );
    m_data = this->m_data;
  }
  bdMemory::deallocate(m_data);
  this->m_data = NULL;
  *(_QWORD *)&this->m_capacity = 0i64;
}

/*
==============
bdArray<bdClansRemovedMembershipProposal>::~bdArray<bdClansRemovedMembershipProposal>
==============
*/
void bdArray<bdClansRemovedMembershipProposal>::~bdArray<bdClansRemovedMembershipProposal>(bdArray<bdClansRemovedMembershipProposal> *this)
{
  unsigned int m_size; 
  bdClansRemovedMembershipProposal *m_data; 
  __int64 v4; 
  __int64 v5; 
  __int64 v6; 
  __int64 v7; 

  m_size = this->m_size;
  m_data = this->m_data;
  if ( m_size )
  {
    v4 = 0i64;
    v5 = 0i64;
    v6 = m_size;
    do
    {
      v7 = *(int *)(*((_QWORD *)&m_data[v4].__vftable + 1) + 4i64);
      (**(void (__fastcall ***)(__int64, _QWORD))((char *)&m_data->__vftable + v7 + v4 * 272 + 8))((__int64)&m_data->__vftable + v7 + v5 + 8, 0i64);
      v5 += 272i64;
      ++v4;
      --v6;
    }
    while ( v6 );
    m_data = this->m_data;
  }
  bdMemory::deallocate(m_data);
  this->m_data = NULL;
  *(_QWORD *)&this->m_capacity = 0i64;
}

/*
==============
bdArray<bdClansGroupMembershipInfo>::operator=
==============
*/
void bdArray<bdClansGroupMembershipInfo>::operator=(bdArray<bdClansGroupMembershipInfo> *this, const bdArray<bdClansGroupMembershipInfo> *a)
{
  unsigned int m_size; 
  __int64 v5; 
  bdClansGroupMembershipInfo *v6; 
  __int64 v7; 
  unsigned int v8; 
  bdClansGroupMembershipInfo *v9; 
  unsigned int v10; 
  __int64 v11; 
  unsigned int m_capacity; 
  unsigned int v13; 

  if ( this != a )
  {
    m_size = this->m_size;
    v5 = a->m_size;
    if ( (unsigned int)v5 <= this->m_capacity )
    {
      v9 = NULL;
      if ( (unsigned int)v5 <= m_size )
      {
        v10 = 0;
        if ( (_DWORD)v5 )
        {
          v11 = 0i64;
          do
          {
            bdHandleAssert(v10 < a->m_size, "rangeCheck(i)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdarray.inl", "bdArray<class bdClansGroupMembershipInfo>::operator []", 0x70u, "bdArray<T>::operator[], rangecheck failed");
            bdClansGroupMembershipInfo::operator=(&this->m_data[v11], &a->m_data[v11]);
            ++v10;
            ++v11;
          }
          while ( v10 < (unsigned int)v5 );
          m_size = this->m_size;
        }
        bdArray<bdClansGroupMembershipInfo>::destruct(this, &this->m_data[v5], m_size - v5);
        m_capacity = this->m_capacity;
        this->m_size = v5;
        if ( m_capacity > 4 * (int)v5 )
        {
          v13 = m_capacity - (m_capacity >> 1);
          this->m_capacity = v13;
          if ( v13 )
          {
            v9 = (bdClansGroupMembershipInfo *)bdMemory::allocate(112i64 * v13);
            bdArray<bdClansGroupMembershipInfo>::copyConstructArrayArray(this, v9, this->m_data, this->m_size);
            LODWORD(v5) = this->m_size;
          }
          bdArray<bdClansGroupMembershipInfo>::destruct(this, this->m_data, v5);
          bdMemory::deallocate(this->m_data);
          this->m_data = v9;
        }
      }
      else
      {
        if ( m_size )
        {
          do
          {
            bdHandleAssert((unsigned int)v9 < a->m_size, "rangeCheck(i)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdarray.inl", "bdArray<class bdClansGroupMembershipInfo>::operator []", 0x70u, "bdArray<T>::operator[], rangecheck failed");
            bdClansGroupMembershipInfo::operator=(&this->m_data[(unsigned int)v9], &a->m_data[(unsigned int)v9]);
            m_size = this->m_size;
            LODWORD(v9) = (_DWORD)v9 + 1;
          }
          while ( (unsigned int)v9 < m_size );
        }
        bdArray<bdClansGroupMembershipInfo>::copyConstructArrayArray(this, &this->m_data[m_size], &a->m_data[m_size], v5 - m_size);
        this->m_size = v5;
      }
    }
    else
    {
      bdArray<bdClansGroupMembershipInfo>::destruct(this, this->m_data, m_size);
      bdMemory::deallocate(this->m_data);
      v6 = NULL;
      this->m_data = NULL;
      *(_QWORD *)&this->m_capacity = 0i64;
      v7 = a->m_capacity;
      if ( (_DWORD)v7 )
      {
        v6 = (bdClansGroupMembershipInfo *)bdMemory::allocate(112 * v7);
        bdArray<bdClansGroupMembershipInfo>::copyConstructArrayArray(this, v6, a->m_data, a->m_size);
      }
      this->m_data = v6;
      v8 = a->m_capacity;
      this->m_size = v5;
      this->m_capacity = v8;
    }
  }
}

/*
==============
bdArray<bdClansGroupMembershipInfo>::copyConstructArrayArray
==============
*/
void bdArray<bdClansGroupMembershipInfo>::copyConstructArrayArray(bdArray<bdClansGroupMembershipInfo> *this, bdClansGroupMembershipInfo *dest, const bdClansGroupMembershipInfo *src, const unsigned int n)
{
  int v4; 
  bdReferencable *m_group; 
  signed __int64 v6; 
  signed __int64 v7; 
  __int64 v8; 
  bdReferencable *v9; 

  if ( n )
  {
    v4 = 0;
    m_group = (bdReferencable *)dest->m_group;
    v6 = (char *)dest - (char *)src;
    v7 = (char *)src - (char *)dest;
    v8 = n;
    do
    {
      v9 = m_group - 2;
      if ( m_group != (bdReferencable *)32 )
      {
        *(_QWORD *)&m_group[-2].m_refCount.m_value._My_val = &bdClansGroupMembershipInfo::`vbtable';
        bdReferencable::bdReferencable(m_group + 4, (const bdReferencable *)((char *)&m_group->m_refCount + v7 + *(int *)(*(_QWORD *)((char *)&m_group[-1] + v7 - 8) + 4i64) - 32));
        bdStructBufferSerializable::bdStructBufferSerializable((bdStructBufferSerializable *)&m_group[-2], (const bdStructBufferSerializable *)((char *)&m_group[-2] + v7));
        v9->__vftable = (bdReferencable_vtbl *)&bdClansGroupMembershipInfo::`vftable'{for `bdStructBufferSerializable'};
        *(_QWORD *)((char *)&v9->m_refCount.m_value._My_val + *(int *)(*(_QWORD *)&m_group[-2].m_refCount.m_value._My_val + 4i64)) = &bdClansGroupMembershipInfo::`vftable'{for `bdReferencable'};
        LOWORD(m_group[-1].__vftable) = *(_WORD *)((char *)&m_group[-1].__vftable + v7);
        m_group->__vftable = (bdReferencable_vtbl *)&bdClansGroupIdentifier::`vbtable';
        bdReferencable::bdReferencable((bdReferencable *)((char *)m_group + v7 + v6 + 40), (bdReferencable *)((char *)m_group + v7 + SHIDWORD((*(bdReferencable_vtbl **)((char *)&m_group->__vftable + v7))->~bdReferencable)));
        v4 |= 3u;
        bdStructBufferSerializable::bdStructBufferSerializable((bdStructBufferSerializable *)&m_group[-1].m_refCount, (const bdStructBufferSerializable *)((char *)m_group + v7 - 8));
        *(_QWORD *)&m_group[-1].m_refCount.m_value._My_val = &bdClansGroupIdentifier::`vftable'{for `bdStructBufferSerializable'};
        *(bdReferencable_vtbl **)((char *)&m_group->__vftable + SHIDWORD(m_group->~bdReferencable)) = (bdReferencable_vtbl *)&bdClansGroupIdentifier::`vftable'{for `bdReferencable'};
        LOWORD(m_group->m_refCount.m_value._My_val) = *(_WORD *)((char *)&m_group->m_refCount.m_value._My_val + v7);
        m_group[1].__vftable = *(bdReferencable_vtbl **)((char *)&m_group[1].__vftable + v7);
        LOWORD(m_group[1].m_refCount.m_value._My_val) = *(_WORD *)((char *)&m_group[1].m_refCount.m_value._My_val + v7);
        m_group[2].__vftable = *(bdReferencable_vtbl **)((char *)&m_group[2].__vftable + v7);
        LOBYTE(m_group[3].m_refCount.m_value._My_val) = *((_BYTE *)&m_group[3].m_refCount.m_value._My_val + v7);
      }
      m_group += 7;
      --v8;
    }
    while ( v8 );
  }
}

/*
==============
bdArray<bdClansGroupMembershipInfo>::destruct
==============
*/
void bdArray<bdClansGroupMembershipInfo>::destruct(bdArray<bdClansGroupMembershipInfo> *this, bdClansGroupMembershipInfo *src, const unsigned int n)
{
  __int64 v4; 
  __int64 v5; 
  __int64 v6; 
  __int64 v7; 

  if ( n )
  {
    v4 = 0i64;
    v5 = 0i64;
    v6 = n;
    do
    {
      v7 = *(int *)(*((_QWORD *)&src[v4].__vftable + 1) + 4i64);
      (**(void (__fastcall ***)(char *, _QWORD))((char *)&src->__vftable + v7 + v4 * 112 + 8))((char *)&src->__vftable + v7 + v5 + 8, 0i64);
      v5 += 112i64;
      ++v4;
      --v6;
    }
    while ( v6 );
  }
}

/*
==============
bdArray<bdClansFailedMembershipProposal>::get
==============
*/
_BOOL8 bdArray<bdClansFailedMembershipProposal>::get(bdArray<bdClansFailedMembershipProposal> *this, const unsigned int i, bdClansFailedMembershipProposal *value)
{
  unsigned int m_size; 
  bool v5; 
  bdClansFailedMembershipProposal *v6; 

  m_size = this->m_size;
  v5 = i < m_size;
  if ( i < m_size )
  {
    v6 = &this->m_data[i];
    bdReferencable::operator=((bdReferencable *)((char *)&value->__vftable + *(int *)(*((_QWORD *)&value->__vftable + 1) + 4i64) + 8), (const bdReferencable *)((char *)&v6->__vftable + *(int *)(*((_QWORD *)&v6->__vftable + 1) + 4i64) + 8));
    bdUserDetails::operator=((bdUserDetails *)(&value->__vftable + 2), (const bdUserDetails *)(&v6->__vftable + 2));
    bdReferencable::operator=((bdReferencable *)&value->m_user[*(int *)(*(_QWORD *)&value->m_user[120] + 4i64) + 120], (const bdReferencable *)&v6->m_user[*(int *)(*(_QWORD *)&v6->m_user[120] + 4i64) + 120]);
    bdReferencable::operator=((bdReferencable *)((char *)&value->m_group.__vftable + *(int *)(*((_QWORD *)&value->m_group.__vftable + 1) + 4i64) + 8), (const bdReferencable *)((char *)&v6->m_group.__vftable + *(int *)(*((_QWORD *)&v6->m_group.__vftable + 1) + 4i64) + 8));
    *((_WORD *)&value->m_group.__vftable + 8) = *((_WORD *)&v6->m_group.__vftable + 8);
    *((_QWORD *)&value->m_group.__vftable + 3) = *((_QWORD *)&v6->m_group.__vftable + 3);
    value->m_group.m_rootKind = v6->m_group.m_rootKind;
    value->m_group.m_rootID = v6->m_group.m_rootID;
    value->m_reason = v6->m_reason;
  }
  return v5;
}

/*
==============
bdArray<bdClansGroupMembershipProposal>::get
==============
*/
_BOOL8 bdArray<bdClansGroupMembershipProposal>::get(bdArray<bdClansGroupMembershipProposal> *this, const unsigned int i, bdClansGroupMembershipProposal *value)
{
  unsigned int m_size; 
  bool v5; 
  bdClansGroupMembershipProposal *v6; 
  unsigned __int8 *m_attachment; 
  signed __int64 v8; 
  __int64 v9; 

  m_size = this->m_size;
  v5 = i < m_size;
  if ( i < m_size )
  {
    v6 = &this->m_data[i];
    bdReferencable::operator=((bdReferencable *)((char *)&value->__vftable + *(int *)(*((_QWORD *)&value->__vftable + 1) + 4i64) + 8), (const bdReferencable *)((char *)&v6->__vftable + *(int *)(*((_QWORD *)&v6->__vftable + 1) + 4i64) + 8));
    bdUserDetails::operator=((bdUserDetails *)(&value->__vftable + 2), (const bdUserDetails *)(&v6->__vftable + 2));
    bdReferencable::operator=((bdReferencable *)&value->m_proposingUser[*(int *)(*(_QWORD *)&value->m_proposingUser[120] + 4i64) + 120], (const bdReferencable *)&v6->m_proposingUser[*(int *)(*(_QWORD *)&v6->m_proposingUser[120] + 4i64) + 120]);
    bdUserDetails::operator=(&value->m_targetUser, &v6->m_targetUser);
    bdReferencable::operator=((bdReferencable *)&value->m_targetUser.gap79[*(int *)(*(_QWORD *)&value->m_targetUser.gap79[15] + 4i64) + 15], (const bdReferencable *)&v6->m_targetUser.gap79[*(int *)(*(_QWORD *)&v6->m_targetUser.gap79[15] + 4i64) + 15]);
    value->m_role = v6->m_role;
    bdReferencable::operator=((bdReferencable *)((char *)&value->m_group.__vftable + *(int *)(*((_QWORD *)&value->m_group.__vftable + 1) + 4i64) + 8), (const bdReferencable *)((char *)&v6->m_group.__vftable + *(int *)(*((_QWORD *)&v6->m_group.__vftable + 1) + 4i64) + 8));
    m_attachment = value->m_attachment;
    v8 = (char *)v6 - (char *)value;
    *((_WORD *)&value->m_group.__vftable + 8) = *((_WORD *)&v6->m_group.__vftable + 8);
    v9 = 512i64;
    *((_QWORD *)&value->m_group.__vftable + 3) = *((_QWORD *)&v6->m_group.__vftable + 3);
    value->m_group.m_rootKind = v6->m_group.m_rootKind;
    value->m_group.m_rootID = v6->m_group.m_rootID;
    value->m_replacesGroupID = v6->m_replacesGroupID;
    value->m_attachmentSize = v6->m_attachmentSize;
    do
    {
      *m_attachment = m_attachment[v8];
      m_attachment[1] = m_attachment[v8 + 1];
      m_attachment += 2;
      --v9;
    }
    while ( v9 );
    value->m_updatedTimestamp = v6->m_updatedTimestamp;
  }
  return v5;
}

/*
==============
bdArray<bdClansRemovedMembershipProposal>::get
==============
*/
_BOOL8 bdArray<bdClansRemovedMembershipProposal>::get(bdArray<bdClansRemovedMembershipProposal> *this, const unsigned int i, bdClansRemovedMembershipProposal *value)
{
  unsigned int m_size; 
  bool v5; 
  bdClansRemovedMembershipProposal *v6; 
  bdClansRemovedMembershipProposal_vtbl **v7; 

  m_size = this->m_size;
  v5 = i < m_size;
  if ( i < m_size )
  {
    v6 = &this->m_data[i];
    bdReferencable::operator=((bdReferencable *)((char *)&value->__vftable + *(int *)(*((_QWORD *)&value->__vftable + 1) + 4i64) + 8), (const bdReferencable *)((char *)&v6->__vftable + *(int *)(*((_QWORD *)&v6->__vftable + 1) + 4i64) + 8));
    v7 = &value->__vftable + 2;
    if ( &value->__vftable + 2 != &v6->__vftable + 2 )
    {
      *(_BYTE *)v7 = *((_BYTE *)&v6->__vftable + 16);
      bdUserDetails::operator=((bdUserDetails *)(&value->__vftable + 3), (const bdUserDetails *)(&v6->__vftable + 3));
      bdReferencable::operator=((bdReferencable *)((char *)v7 + *(int *)(*(_QWORD *)&value->m_targetUser[128] + 4i64) + 144), (const bdReferencable *)&v6->m_targetUser[*(int *)(*(_QWORD *)&v6->m_targetUser[128] + 4i64) + 128]);
    }
    bdReferencable::operator=((bdReferencable *)((char *)&value->m_group.__vftable + *(int *)(*((_QWORD *)&value->m_group.__vftable + 1) + 4i64) + 8), (const bdReferencable *)((char *)&v6->m_group.__vftable + *(int *)(*((_QWORD *)&v6->m_group.__vftable + 1) + 4i64) + 8));
    *((_WORD *)&value->m_group.__vftable + 8) = *((_WORD *)&v6->m_group.__vftable + 8);
    *((_QWORD *)&value->m_group.__vftable + 3) = *((_QWORD *)&v6->m_group.__vftable + 3);
    value->m_group.m_rootKind = v6->m_group.m_rootKind;
    value->m_group.m_rootID = v6->m_group.m_rootID;
    value->m_cooldown = v6->m_cooldown;
  }
  return v5;
}

/*
==============
bdArray<bdClansGroupMemberInfo>::get
==============
*/
_BOOL8 bdArray<bdClansGroupMemberInfo>::get(bdArray<bdClansGroupMemberInfo> *this, const unsigned int i, bdClansGroupMemberInfo *value)
{
  unsigned int m_size; 
  bool v5; 
  bdClansGroupMemberInfo *v6; 

  m_size = this->m_size;
  v5 = i < m_size;
  if ( i < m_size )
  {
    v6 = &this->m_data[i];
    bdReferencable::operator=((bdReferencable *)((char *)&value->__vftable + *(int *)(*((_QWORD *)&value->__vftable + 1) + 4i64) + 8), (const bdReferencable *)((char *)&v6->__vftable + *(int *)(*((_QWORD *)&v6->__vftable + 1) + 4i64) + 8));
    bdUserDetails::operator=((bdUserDetails *)(&value->__vftable + 2), (const bdUserDetails *)(&v6->__vftable + 2));
    bdReferencable::operator=((bdReferencable *)&value->m_user[*(int *)(*(_QWORD *)&value->m_user[120] + 4i64) + 120], (const bdReferencable *)&v6->m_user[*(int *)(*(_QWORD *)&v6->m_user[120] + 4i64) + 120]);
    bdArray<bdClansGroupMembershipInfo>::operator=(&value->m_memberships, &v6->m_memberships);
    value->m_onlineStatus = v6->m_onlineStatus;
  }
  return v5;
}

/*
==============
bdArray<bdQoSProbeInfo>::~bdArray<bdQoSProbeInfo>
==============
*/
void bdArray<bdQoSProbeInfo>::~bdArray<bdQoSProbeInfo>(bdArray<bdQoSProbeInfo> *this)
{
  bdArray<bdQoSProbeInfo>::destruct(this, this->m_data, this->m_size);
  bdMemory::deallocate(this->m_data);
  this->m_data = NULL;
  *(_QWORD *)&this->m_capacity = 0i64;
}

/*
==============
bdArray<bdQoSRemoteAddr>::~bdArray<bdQoSRemoteAddr>
==============
*/
void bdArray<bdQoSRemoteAddr>::~bdArray<bdQoSRemoteAddr>(bdArray<bdQoSRemoteAddr> *this)
{
  unsigned int m_size; 
  bdQoSRemoteAddr *m_data; 
  __int64 v4; 

  m_size = this->m_size;
  m_data = this->m_data;
  if ( m_size )
  {
    v4 = m_size;
    do
    {
      bdSecurityKey::~bdSecurityKey(&m_data->m_key);
      bdSecurityID::~bdSecurityID(&m_data->m_id);
      if ( m_data->m_addr.m_ptr && _InterlockedExchangeAdd((volatile signed __int32 *)&m_data->m_addr.m_ptr->m_refCount, 0xFFFFFFFF) == 1 )
      {
        if ( m_data->m_addr.m_ptr )
          ((void (__fastcall *)(bdCommonAddr *, __int64))m_data->m_addr.m_ptr->~bdReferencable)(m_data->m_addr.m_ptr, 1i64);
        m_data->m_addr.m_ptr = NULL;
      }
      ++m_data;
      --v4;
    }
    while ( v4 );
    m_data = this->m_data;
  }
  bdMemory::deallocate(m_data);
  this->m_data = NULL;
  *(_QWORD *)&this->m_capacity = 0i64;
}

/*
==============
bdArray<bdQoSProbeInfo>::destruct
==============
*/
void bdArray<bdQoSProbeInfo>::destruct(bdArray<bdQoSProbeInfo> *this, bdQoSProbeInfo *src, const unsigned int n)
{
  __int64 v4; 

  if ( n )
  {
    v4 = n;
    do
    {
      if ( src->m_addr.m_ptr && _InterlockedExchangeAdd((volatile signed __int32 *)&src->m_addr.m_ptr->m_refCount, 0xFFFFFFFF) == 1 )
      {
        if ( src->m_addr.m_ptr )
          ((void (__fastcall *)(bdCommonAddr *, __int64))src->m_addr.m_ptr->~bdReferencable)(src->m_addr.m_ptr, 1i64);
        src->m_addr.m_ptr = NULL;
      }
      ++src;
      --v4;
    }
    while ( v4 );
  }
}

/*
==============
bdArray<bdObjectStoreErrorWrappedObject>::~bdArray<bdObjectStoreErrorWrappedObject>
==============
*/
void bdArray<bdObjectStoreErrorWrappedObject>::~bdArray<bdObjectStoreErrorWrappedObject>(bdArray<bdObjectStoreErrorWrappedObject> *this)
{
  unsigned int m_size; 
  bdObjectStoreErrorWrappedObject *m_data; 
  bdArray<bdObjectStoreTag> *p_m_tags; 
  __int64 v5; 

  m_size = this->m_size;
  m_data = this->m_data;
  if ( m_size )
  {
    p_m_tags = &m_data->m_object.m_metadata.m_tags;
    v5 = m_size;
    do
    {
      bdMemory::deallocate(p_m_tags->m_data);
      p_m_tags->m_data = NULL;
      *(_QWORD *)&p_m_tags->m_capacity = 0i64;
      bdObjectStoreACL::~bdObjectStoreACL((bdObjectStoreACL *)&p_m_tags[-201]);
      p_m_tags = (bdArray<bdObjectStoreTag> *)((char *)p_m_tags + 3528);
      --v5;
    }
    while ( v5 );
    m_data = this->m_data;
  }
  bdMemory::deallocate(m_data);
  this->m_data = NULL;
  *(_QWORD *)&this->m_capacity = 0i64;
}

/*
==============
bdArray<bdObjectStoreErrorWrappedObject>::copyConstructArrayArray
==============
*/
void bdArray<bdObjectStoreErrorWrappedObject>::copyConstructArrayArray(bdArray<bdObjectStoreErrorWrappedObject> *this, bdObjectStoreErrorWrappedObject *dest, const bdObjectStoreErrorWrappedObject *src, const unsigned int n)
{
  signed __int64 v5; 
  signed __int64 v6; 
  signed __int64 v8; 
  signed __int64 v9; 
  signed __int64 v10; 
  signed __int64 v13; 
  signed __int64 v14; 
  __int64 v15; 
  __int64 v28; 
  void *v41; 
  __int64 v42; 
  void *v43; 
  __int64 v44; 
  signed __int64 v50; 
  signed __int64 v51; 
  signed __int64 v52; 
  signed __int64 v53; 
  signed __int64 v54; 
  signed __int64 v55; 
  signed __int64 v56; 
  signed __int64 v57; 
  signed __int64 v58; 
  signed __int64 v59; 
  signed __int64 v60; 
  signed __int64 v61; 
  signed __int64 v62; 
  signed __int64 v63; 
  signed __int64 v64; 
  signed __int64 v65; 
  signed __int64 v66; 
  signed __int64 v67; 
  signed __int64 v68; 
  signed __int64 v69; 
  signed __int64 v70; 

  if ( n )
  {
    _RBX = &src->m_object.m_metadata.m_tags.m_capacity;
    v5 = (char *)dest - (char *)src;
    v62 = v5 + 4;
    v6 = v5 + 8;
    _RBP = v5 + 12;
    v8 = v5 + 48;
    v9 = v5 + 56;
    v10 = v5 + 64;
    v64 = v5 + 72;
    v65 = v5 + 76;
    v66 = v5 + 80;
    v67 = v5 + 84;
    _R11 = v5 - 3424;
    v70 = v5 - 3424;
    v50 = v5 - 3312;
    v51 = v5 - 3279;
    v52 = v5 - 3240;
    v53 = v5 - 3232;
    v54 = v5 - 3224;
    v55 = v5 - 3216;
    v56 = v5 - 3208;
    v57 = v5 - 3200;
    _R8 = v5 - 2176;
    v68 = v5 - 2176;
    v13 = v5 - 2111;
    v69 = v5 - 2111;
    v58 = v5 - 60;
    v59 = v5 - 56;
    v60 = v5 - 48;
    v61 = v5 - 15;
    v63 = v5 - 8;
    v14 = v5 - 3440;
    v15 = n;
    do
    {
      _RAX = (char *)_RBX + v14;
      if ( (unsigned int *)((char *)_RBX + v14) )
      {
        __asm
        {
          vmovups xmm0, xmmword ptr [rbx-0D70h]
          vmovups xmmword ptr [rax], xmm0
          vmovups ymm0, ymmword ptr [rbx-0D60h]
          vmovups ymmword ptr [r11+rbx], ymm0
          vmovups ymm1, ymmword ptr [rbx-0D40h]
          vmovups ymmword ptr [r11+rbx+20h], ymm1
          vmovups ymm0, ymmword ptr [rbx-0D20h]
          vmovups ymmword ptr [r11+rbx+40h], ymm0
          vmovups xmm1, xmmword ptr [rbx-0D00h]
          vmovups xmmword ptr [r11+rbx+60h], xmm1
          vmovups ymm0, ymmword ptr [rbx-0CF0h]
        }
        _RCX = v50;
        __asm { vmovups ymmword ptr [rcx+rbx], ymm0 }
        *((_BYTE *)_RBX + v50 + 32) = *((_BYTE *)_RBX - 3280);
        __asm { vmovups ymm0, ymmword ptr [rbx-0CCFh] }
        _RCX = v51;
        __asm { vmovups ymmword ptr [rcx+rbx], ymm0 }
        *((_BYTE *)_RBX + v51 + 32) = *((_BYTE *)_RBX - 3247);
        *(_QWORD *)((char *)_RBX + v52) = *((_QWORD *)_RBX - 405);
        *(_QWORD *)((char *)_RBX + v53) = *((_QWORD *)_RBX - 404);
        *(unsigned int *)((char *)_RBX + v54) = *(_RBX - 806);
        *(_QWORD *)((char *)_RBX + v55) = *((_QWORD *)_RBX - 402);
        *(_QWORD *)((char *)_RBX + v56) = *((_QWORD *)_RBX - 401);
        _RCX = (char *)_RBX + v57;
        _RAX = _RBX - 800;
        v28 = 8i64;
        do
        {
          __asm
          {
            vmovups xmm0, xmmword ptr [rax]
            vmovups xmmword ptr [rcx], xmm0
            vmovups xmm1, xmmword ptr [rax+10h]
            vmovups xmmword ptr [rcx+10h], xmm1
            vmovups xmm0, xmmword ptr [rax+20h]
            vmovups xmmword ptr [rcx+20h], xmm0
            vmovups xmm1, xmmword ptr [rax+30h]
            vmovups xmmword ptr [rcx+30h], xmm1
            vmovups xmm0, xmmword ptr [rax+40h]
            vmovups xmmword ptr [rcx+40h], xmm0
            vmovups xmm1, xmmword ptr [rax+50h]
            vmovups xmmword ptr [rcx+50h], xmm1
            vmovups xmm0, xmmword ptr [rax+60h]
            vmovups xmmword ptr [rcx+60h], xmm0
          }
          _RCX += 128;
          __asm
          {
            vmovups xmm1, xmmword ptr [rax+70h]
            vmovups xmmword ptr [rcx-10h], xmm1
          }
          _RAX += 32;
          --v28;
        }
        while ( v28 );
        __asm
        {
          vmovups ymm0, ymmword ptr [rbx-880h]
          vmovups ymmword ptr [r8+rbx], ymm0
          vmovups ymm1, ymmword ptr [rbx-860h]
          vmovups ymmword ptr [r8+rbx+20h], ymm1
        }
        *((_BYTE *)_RBX + _R8 + 64) = *((_BYTE *)_RBX - 2112);
        memcpy_0((char *)_RBX + v13, (char *)_RBX - 2111, 0x800ui64);
        *(unsigned int *)((char *)_RBX + v58) = *(_RBX - 15);
        *(_QWORD *)((char *)_RBX + v59) = *((_QWORD *)_RBX - 7);
        __asm { vmovups ymm0, ymmword ptr [rbx-30h] }
        _R11 = v60;
        __asm { vmovups ymmword ptr [rbx+r11], ymm0 }
        *((_BYTE *)_RBX + v60 + 32) = *((_BYTE *)_RBX - 16);
        *((_BYTE *)_RBX + v61) = *((_BYTE *)_RBX - 15);
        *(unsigned int *)((char *)_RBX + v62 - 4) = *_RBX;
        *(unsigned int *)((char *)_RBX + v62) = _RBX[1];
        v41 = NULL;
        v42 = *_RBX;
        if ( (_DWORD)v42 )
        {
          v43 = bdMemory::allocate(66 * v42);
          v41 = v43;
          v44 = _RBX[1];
          if ( (_DWORD)v44 )
          {
            _RCX = v43;
            _R8 = *((_QWORD *)_RBX - 1) - (_QWORD)v43;
            do
            {
              if ( _RCX )
              {
                __asm
                {
                  vmovups ymm0, ymmword ptr [r8+rcx]
                  vmovups ymmword ptr [rcx], ymm0
                  vmovups ymm1, ymmword ptr [r8+rcx+20h]
                  vmovups ymmword ptr [rcx+20h], ymm1
                }
                _RCX[32] = *(_WORD *)((char *)_RCX + _R8 + 64);
              }
              _RCX += 33;
              --v44;
            }
            while ( v44 );
          }
        }
        *(_QWORD *)((char *)_RBX + v63) = v41;
        *(unsigned int *)((char *)_RBX + v6) = _RBX[2];
        __asm
        {
          vmovups ymm0, ymmword ptr [rbx+0Ch]
          vmovups ymmword ptr [rbx+rbp], ymm0
        }
        *(_QWORD *)((char *)_RBX + v8) = *((_QWORD *)_RBX + 6);
        *(_QWORD *)((char *)_RBX + v9) = *((_QWORD *)_RBX + 7);
        *(_QWORD *)((char *)_RBX + v10) = *((_QWORD *)_RBX + 8);
        *(unsigned int *)((char *)_RBX + v64) = _RBX[18];
        *((_BYTE *)_RBX + v65) = *((_BYTE *)_RBX + 76);
        *(unsigned int *)((char *)_RBX + v66) = _RBX[20];
        *(unsigned int *)((char *)_RBX + v67) = _RBX[21];
        _R8 = v68;
        v13 = v69;
        _R11 = v70;
      }
      _RBX += 882;
      --v15;
    }
    while ( v15 );
  }
}

/*
==============
bdArray<bdClansGroupIdentifier>::~bdArray<bdClansGroupIdentifier>
==============
*/
void bdArray<bdClansGroupIdentifier>::~bdArray<bdClansGroupIdentifier>(bdArray<bdClansGroupIdentifier> *this)
{
  bdArray<bdClansGroupIdentifier>::destruct(this, this->m_data, this->m_size);
  bdMemory::deallocate(this->m_data);
  this->m_data = NULL;
  *(_QWORD *)&this->m_capacity = 0i64;
}

/*
==============
bdArray<bdClansUserMembershipProposal>::~bdArray<bdClansUserMembershipProposal>
==============
*/
void bdArray<bdClansUserMembershipProposal>::~bdArray<bdClansUserMembershipProposal>(bdArray<bdClansUserMembershipProposal> *this)
{
  bdArray<bdClansUserMembershipProposal>::destruct(this, this->m_data, this->m_size);
  bdMemory::deallocate(this->m_data);
  this->m_data = NULL;
  *(_QWORD *)&this->m_capacity = 0i64;
}

/*
==============
bdArray<bdStructUserAccountID>::~bdArray<bdStructUserAccountID>
==============
*/
void bdArray<bdStructUserAccountID>::~bdArray<bdStructUserAccountID>(bdArray<bdStructUserAccountID> *this)
{
  unsigned int m_size; 
  bdStructUserAccountID *m_data; 
  __int64 v4; 
  __int64 v5; 
  __int64 v6; 
  __int64 v7; 

  m_size = this->m_size;
  m_data = this->m_data;
  if ( m_size )
  {
    v4 = 0i64;
    v5 = 0i64;
    v6 = m_size;
    do
    {
      v7 = *(int *)(*((_QWORD *)&m_data[v4].__vftable + 1) + 4i64);
      (**(void (__fastcall ***)(__int64, _QWORD))((char *)&m_data->__vftable + v7 + v4 * 88 + 8))((__int64)&m_data->__vftable + v7 + v5 + 8, 0i64);
      v5 += 88i64;
      ++v4;
      --v6;
    }
    while ( v6 );
    m_data = this->m_data;
  }
  bdMemory::deallocate(m_data);
  this->m_data = NULL;
  *(_QWORD *)&this->m_capacity = 0i64;
}

/*
==============
bdArray<bdUserAccountID>::~bdArray<bdUserAccountID>
==============
*/
void bdArray<bdUserAccountID>::~bdArray<bdUserAccountID>(bdArray<bdUserAccountID> *this)
{
  bdArray<bdUserAccountID>::destruct(this, this->m_data, this->m_size);
  bdMemory::deallocate(this->m_data);
  this->m_data = NULL;
  *(_QWORD *)&this->m_capacity = 0i64;
}

/*
==============
bdArray<bdClansGroupIdentifier>::copyConstructArrayArray
==============
*/
void bdArray<bdClansGroupIdentifier>::copyConstructArrayArray(bdArray<bdClansGroupIdentifier> *this, bdClansGroupIdentifier *dest, const bdClansGroupIdentifier *src, const unsigned int n)
{
  int v4; 
  bdClansGroupIdentifier_vtbl **v5; 
  signed __int64 v6; 
  signed __int64 v7; 
  __int64 v8; 

  if ( n )
  {
    v4 = 0;
    v5 = &dest->__vftable + 1;
    v6 = (char *)dest - (char *)src;
    v7 = (char *)src - (char *)dest;
    v8 = n;
    do
    {
      if ( v5 != (bdClansGroupIdentifier_vtbl **)8 )
      {
        *v5 = (bdClansGroupIdentifier_vtbl *)&bdClansGroupIdentifier::`vbtable';
        bdReferencable::bdReferencable((bdReferencable *)((char *)v5 + v7 + v6 + 40), (const bdReferencable *)((char *)v5 + v7 + SHIDWORD((*(bdClansGroupIdentifier_vtbl **)((char *)v5 + v7))->serialize)));
        v4 |= 1u;
        bdStructBufferSerializable::bdStructBufferSerializable((bdStructBufferSerializable *)(v5 - 1), (const bdStructBufferSerializable *)((char *)v5 + v7 - 8));
        *(v5 - 1) = (bdClansGroupIdentifier_vtbl *)&bdClansGroupIdentifier::`vftable'{for `bdStructBufferSerializable'};
        *(bdClansGroupIdentifier_vtbl **)((char *)v5 + SHIDWORD((*v5)->serialize)) = (bdClansGroupIdentifier_vtbl *)&bdClansGroupIdentifier::`vftable'{for `bdReferencable'};
        *((_WORD *)v5 + 4) = *(_WORD *)((char *)v5 + v7 + 8);
        v5[2] = *(bdClansGroupIdentifier_vtbl **)((char *)v5 + v7 + 16);
        *((_WORD *)v5 + 12) = *(_WORD *)((char *)v5 + v7 + 24);
        v5[4] = *(bdClansGroupIdentifier_vtbl **)((char *)v5 + v7 + 32);
      }
      v5 += 8;
      --v8;
    }
    while ( v8 );
  }
}

/*
==============
bdArray<bdUserAccountID>::copyConstructArrayArray
==============
*/
void bdArray<bdUserAccountID>::copyConstructArrayArray(bdArray<bdUserAccountID> *this, bdUserAccountID *dest, const bdUserAccountID *src, const unsigned int n)
{
  bdUserAccountID *v4; 
  signed __int64 v5; 
  __int64 v6; 

  if ( n )
  {
    v4 = dest;
    v5 = (char *)src - (char *)dest;
    v6 = n;
    do
    {
      if ( v4 )
        bdUserAccountID::bdUserAccountID(v4, (bdUserAccountID *)((char *)v4 + v5));
      ++v4;
      --v6;
    }
    while ( v6 );
  }
}

/*
==============
bdArray<bdClansGroupIdentifier>::destruct
==============
*/
void bdArray<bdClansGroupIdentifier>::destruct(bdArray<bdClansGroupIdentifier> *this, bdClansGroupIdentifier *src, const unsigned int n)
{
  __int64 v4; 
  __int64 v5; 
  __int64 v6; 
  __int64 v7; 

  if ( n )
  {
    v4 = 0i64;
    v5 = 0i64;
    v6 = n;
    do
    {
      v7 = *(int *)(*((_QWORD *)&src[v4].__vftable + 1) + 4i64);
      (**(void (__fastcall ***)(char *, _QWORD))((char *)&src->__vftable + v7 + v4 * 64 + 8))((char *)&src->__vftable + v7 + v5 + 8, 0i64);
      v5 += 64i64;
      ++v4;
      --v6;
    }
    while ( v6 );
  }
}

/*
==============
bdArray<bdClansRemovedMembershipProposal>::destruct
==============
*/
void bdArray<bdClansRemovedMembershipProposal>::destruct(bdArray<bdClansRemovedMembershipProposal> *this, bdClansRemovedMembershipProposal *src, const unsigned int n)
{
  __int64 v4; 
  __int64 v5; 
  __int64 v6; 
  __int64 v7; 

  if ( n )
  {
    v4 = 0i64;
    v5 = 0i64;
    v6 = n;
    do
    {
      v7 = *(int *)(*((_QWORD *)&src[v4].__vftable + 1) + 4i64);
      (**(void (__fastcall ***)(char *, _QWORD))((char *)&src->__vftable + v7 + v4 * 272 + 8))((char *)&src->__vftable + v7 + v5 + 8, 0i64);
      v5 += 272i64;
      ++v4;
      --v6;
    }
    while ( v6 );
  }
}

/*
==============
bdArray<bdClansUserMembershipProposal>::destruct
==============
*/
void bdArray<bdClansUserMembershipProposal>::destruct(bdArray<bdClansUserMembershipProposal> *this, bdClansUserMembershipProposal *src, const unsigned int n)
{
  __int64 v4; 
  __int64 v5; 
  __int64 v6; 
  __int64 v7; 

  if ( n )
  {
    v4 = 0i64;
    v5 = 0i64;
    v6 = n;
    do
    {
      v7 = *(int *)(*((_QWORD *)&src[v4].__vftable + 1) + 4i64);
      (**(void (__fastcall ***)(char *, _QWORD))((char *)&src->__vftable + v7 + v4 * 1224 + 8))((char *)&src->__vftable + v7 + v5 + 8, 0i64);
      v5 += 1224i64;
      ++v4;
      --v6;
    }
    while ( v6 );
  }
}

/*
==============
bdArray<bdUserAccountID>::destruct
==============
*/
void bdArray<bdUserAccountID>::destruct(bdArray<bdUserAccountID> *this, bdUserAccountID *src, const unsigned int n)
{
  __int64 v4; 
  __int64 v5; 
  __int64 v6; 
  __int64 v7; 

  if ( n )
  {
    v4 = 0i64;
    v5 = 0i64;
    v6 = n;
    do
    {
      v7 = *(int *)(*((_QWORD *)&src[v4].__vftable + 1) + 4i64);
      (**(void (__fastcall ***)(char *, _QWORD))((char *)&src->__vftable + v7 + v4 * 72 + 8))((char *)&src->__vftable + v7 + v5 + 8, 0i64);
      v5 += 72i64;
      ++v4;
      --v6;
    }
    while ( v6 );
  }
}

/*
==============
bdArray<bdClansRemovedMembershipProposal>::pushBack
==============
*/
void bdArray<bdClansRemovedMembershipProposal>::pushBack(bdArray<bdClansRemovedMembershipProposal> *this, const bdClansRemovedMembershipProposal *value)
{
  bdArray<bdClansRemovedMembershipProposal> *v2; 
  int v3; 
  unsigned int m_size; 
  unsigned int m_capacity; 
  int v6; 
  bool v7; 
  __int64 v8; 
  bdClansRemovedMembershipProposal *v9; 
  bdClansRemovedMembershipProposal *m_data; 
  bdClansRemovedMembershipProposal_vtbl **v11; 
  char *v12; 
  __int64 v13; 
  char *v14; 
  unsigned int v15; 
  bdClansRemovedMembershipProposal *v16; 
  bdClansRemovedMembershipProposal *__that; 
  unsigned int v19; 

  __that = (bdClansRemovedMembershipProposal *)value;
  v2 = this;
  v3 = 0;
  m_size = this->m_size;
  m_capacity = v2->m_capacity;
  if ( m_size == m_capacity )
  {
    v6 = v2->m_capacity;
    if ( !m_capacity )
      v6 = 1;
    v7 = m_capacity + v6 == 0;
    v8 = m_capacity + v6;
    v19 = v8;
    v9 = NULL;
    if ( !v7 )
    {
      v9 = (bdClansRemovedMembershipProposal *)bdMemory::allocate(272 * v8);
      m_size = v2->m_size;
      m_data = v2->m_data;
      if ( m_size )
      {
        v11 = &m_data->__vftable + 3;
        v12 = (char *)((char *)v9 - (char *)m_data);
        v13 = m_size;
        do
        {
          v14 = (char *)v11 + (_QWORD)v12 - 24;
          if ( (bdClansRemovedMembershipProposal_vtbl **)((char *)v11 + (_QWORD)v12) != (bdClansRemovedMembershipProposal_vtbl **)24 )
          {
            *(bdClansRemovedMembershipProposal_vtbl **)((char *)v11 + (_QWORD)v12 - 16) = (bdClansRemovedMembershipProposal_vtbl *)&bdClansRemovedMembershipProposal::`vbtable';
            bdReferencable::bdReferencable((bdReferencable *)((char *)v11 + (_QWORD)v12 + 232), (const bdReferencable *)((char *)v11 + SHIDWORD((*(v11 - 2))->serialize) - 16));
            v3 |= 1u;
            bdStructBufferSerializable::bdStructBufferSerializable((bdStructBufferSerializable *)((char *)v11 + (_QWORD)v12 - 24), (const bdStructBufferSerializable *)(v11 - 3));
            *(_QWORD *)v14 = &bdClansRemovedMembershipProposal::`vftable'{for `bdStructBufferSerializable'};
            *(_QWORD *)&v14[SHIDWORD((*(bdClansRemovedMembershipProposal_vtbl **)((char *)v11 + (_QWORD)v12 - 16))->serialize) + 8] = &bdClansRemovedMembershipProposal::`vftable'{for `bdReferencable'};
            *((_BYTE *)v11 + (_QWORD)v12 - 8) = *((_BYTE *)v11 - 8);
            bdStructUserDetails::bdStructUserDetails((bdStructUserDetails *)((char *)v11 + (_QWORD)v12), (const bdStructUserDetails *)v11);
            bdClansGroupIdentifier::bdClansGroupIdentifier((bdClansGroupIdentifier *)((char *)v11 + (_QWORD)v12 + 160), (const bdClansGroupIdentifier *)(v11 + 20));
            *(_DWORD *)((char *)v11 + (_QWORD)v12 + 224) = *((_DWORD *)v11 + 56);
          }
          v11 += 34;
          --v13;
        }
        while ( v13 );
        v2 = this;
        m_size = this->m_size;
      }
    }
    bdArray<bdClansRemovedMembershipProposal>::destruct(v2, v2->m_data, m_size);
    bdMemory::deallocate(v2->m_data);
    v2->m_data = v9;
    v2->m_capacity = v19;
    m_size = v2->m_size;
    value = __that;
  }
  else
  {
    v9 = v2->m_data;
  }
  v15 = m_size;
  v16 = &v9[m_size];
  if ( v16 )
  {
    bdClansRemovedMembershipProposal::bdClansRemovedMembershipProposal(v16, value);
    v15 = v2->m_size;
  }
  v2->m_size = v15 + 1;
}

/*
==============
bdArray<bdClansUserMembershipProposal>::pushBack
==============
*/
void bdArray<bdClansUserMembershipProposal>::pushBack(bdArray<bdClansUserMembershipProposal> *this, const bdClansUserMembershipProposal *value)
{
  bdArray<bdClansUserMembershipProposal> *v2; 
  int v3; 
  unsigned int m_size; 
  unsigned int m_capacity; 
  int v6; 
  bool v7; 
  __int64 v8; 
  bdClansUserMembershipProposal *v9; 
  char *v10; 
  bdClansUserMembershipProposal *m_data; 
  char *v12; 
  char *v13; 
  __int64 v14; 
  __int64 v15; 
  __int64 v18; 
  unsigned int v27; 
  bdClansUserMembershipProposal *v28; 
  bdClansUserMembershipProposal *v29; 
  bdClansUserMembershipProposal *__that; 
  unsigned int v32; 

  __that = (bdClansUserMembershipProposal *)value;
  v2 = this;
  v3 = 0;
  m_size = this->m_size;
  m_capacity = this->m_capacity;
  if ( m_size == m_capacity )
  {
    v6 = m_capacity;
    if ( !m_capacity )
      v6 = 1;
    v7 = m_capacity + v6 == 0;
    v8 = m_capacity + v6;
    v32 = v8;
    v9 = NULL;
    if ( !v7 )
    {
      v10 = (char *)bdMemory::allocate(1224 * v8);
      v9 = (bdClansUserMembershipProposal *)v10;
      v29 = (bdClansUserMembershipProposal *)v10;
      m_size = v2->m_size;
      m_data = v2->m_data;
      if ( m_size )
      {
        v12 = v10 + 8;
        v13 = (char *)(v10 - (char *)m_data);
        v14 = (char *)m_data - v10;
        v15 = m_size;
        do
        {
          if ( v12 != (char *)8 )
          {
            *(_QWORD *)v12 = &bdClansUserMembershipProposal::`vbtable';
            bdReferencable::bdReferencable((bdReferencable *)&v12[v14 + 1200 + (_QWORD)v13], (const bdReferencable *)&v12[v14 + *(int *)(*(_QWORD *)&v12[v14] + 4i64)]);
            v3 |= 1u;
            bdStructBufferSerializable::bdStructBufferSerializable((bdStructBufferSerializable *)(v12 - 8), (const bdStructBufferSerializable *)&v12[v14 - 8]);
            *((_QWORD *)v12 - 1) = &bdClansUserMembershipProposal::`vftable'{for `bdStructBufferSerializable'};
            *(_QWORD *)&v12[*(int *)(*(_QWORD *)v12 + 4i64)] = &bdClansUserMembershipProposal::`vftable'{for `bdReferencable'};
            bdStructUserDetails::bdStructUserDetails((bdStructUserDetails *)(v12 + 8), (const bdStructUserDetails *)&v12[v14 + 8]);
            *((_WORD *)v12 + 84) = *(_WORD *)&v12[v14 + 168];
            *((_DWORD *)v12 + 43) = *(_DWORD *)&v12[v14 + 172];
            _RCX = v12 + 176;
            _RAX = (__int64)&v12[v14 + 176];
            v18 = 8i64;
            do
            {
              __asm
              {
                vmovups xmm0, xmmword ptr [rax]
                vmovups xmmword ptr [rcx], xmm0
                vmovups xmm1, xmmword ptr [rax+10h]
                vmovups xmmword ptr [rcx+10h], xmm1
                vmovups xmm0, xmmword ptr [rax+20h]
                vmovups xmmword ptr [rcx+20h], xmm0
                vmovups xmm1, xmmword ptr [rax+30h]
                vmovups xmmword ptr [rcx+30h], xmm1
                vmovups xmm0, xmmword ptr [rax+40h]
                vmovups xmmword ptr [rcx+40h], xmm0
                vmovups xmm1, xmmword ptr [rax+50h]
                vmovups xmmword ptr [rcx+50h], xmm1
                vmovups xmm0, xmmword ptr [rax+60h]
                vmovups xmmword ptr [rcx+60h], xmm0
              }
              _RCX += 128;
              __asm
              {
                vmovups xmm1, xmmword ptr [rax+70h]
                vmovups xmmword ptr [rcx-10h], xmm1
              }
              _RAX += 128i64;
              --v18;
            }
            while ( v18 );
          }
          v12 += 1224;
          --v15;
        }
        while ( v15 );
        v2 = this;
        m_size = this->m_size;
        v9 = v29;
      }
    }
    bdArray<bdClansUserMembershipProposal>::destruct(v2, v2->m_data, m_size);
    bdMemory::deallocate(v2->m_data);
    v2->m_data = v9;
    v2->m_capacity = v32;
    m_size = v2->m_size;
    value = __that;
  }
  else
  {
    v9 = v2->m_data;
  }
  v27 = m_size;
  v28 = &v9[m_size];
  if ( v28 )
  {
    bdClansUserMembershipProposal::bdClansUserMembershipProposal(v28, value);
    v27 = v2->m_size;
  }
  v2->m_size = v27 + 1;
}

/*
==============
bdArray<bdObjectStoreCacheAwareObjectID>::~bdArray<bdObjectStoreCacheAwareObjectID>
==============
*/
void bdArray<bdObjectStoreCacheAwareObjectID>::~bdArray<bdObjectStoreCacheAwareObjectID>(bdArray<bdObjectStoreCacheAwareObjectID> *this)
{
  unsigned int m_size; 
  bdObjectStoreCacheAwareObjectID *m_data; 
  __int64 v4; 

  m_size = this->m_size;
  m_data = this->m_data;
  if ( m_size )
  {
    v4 = m_size;
    do
    {
      bdObjectStoreCacheAwareObjectID::~bdObjectStoreCacheAwareObjectID(m_data++);
      --v4;
    }
    while ( v4 );
    m_data = this->m_data;
  }
  bdMemory::deallocate(m_data);
  this->m_data = NULL;
  *(_QWORD *)&this->m_capacity = 0i64;
}

/*
==============
bdArray<bdObjectStoreTag>::operator=
==============
*/
void bdArray<bdObjectStoreTag>::operator=(bdArray<bdObjectStoreTag> *this, const bdArray<bdObjectStoreTag> *a)
{
  unsigned int m_size; 
  unsigned int m_capacity; 
  unsigned int v6; 
  __int64 v7; 
  bdObjectStoreTag *v8; 
  __int64 v9; 
  __int16 v14; 
  __int64 v16; 
  bdObjectStoreTag *v17; 
  unsigned int v22; 
  __int16 v25; 
  unsigned int v29; 
  unsigned int v30; 
  __int64 v33; 

  if ( this != a )
  {
    m_size = a->m_size;
    m_capacity = this->m_capacity;
    if ( m_size <= m_capacity )
    {
      v7 = this->m_size;
      v8 = NULL;
      if ( m_size <= (unsigned int)v7 )
      {
        v22 = 0;
        if ( m_size )
        {
          _R15 = 0i64;
          do
          {
            bdHandleAssert(v22 < a->m_size, "rangeCheck(i)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdarray.inl", "bdArray<class bdObjectStoreTag>::operator []", 0x70u, "bdArray<T>::operator[], rangecheck failed");
            _RAX = a->m_data;
            ++_R15;
            ++v22;
            v25 = *(_WORD *)&a->m_data[_R15 - 1].m_value[31];
            __asm
            {
              vmovups ymm0, ymmword ptr [r15+rax-42h]
              vmovups ymm1, ymmword ptr [r15+rax-22h]
            }
            _RAX = this->m_data;
            __asm
            {
              vmovups ymmword ptr [r15+rax-42h], ymm0
              vmovups ymmword ptr [r15+rax-22h], ymm1
            }
            *(_WORD *)&_RAX[_R15 - 1].m_value[31] = v25;
          }
          while ( v22 < m_size );
          m_capacity = this->m_capacity;
        }
        this->m_size = m_size;
        if ( m_capacity > 4 * m_size )
        {
          v29 = m_capacity - (m_capacity >> 1);
          this->m_capacity = v29;
          if ( v29 )
          {
            v8 = (bdObjectStoreTag *)bdMemory::allocate(66i64 * v29);
            v30 = this->m_size;
            if ( v30 )
            {
              _RCX = v8;
              _R8 = (char *)this->m_data - (char *)v8;
              v33 = v30;
              do
              {
                if ( _RCX )
                {
                  __asm
                  {
                    vmovups ymm0, ymmword ptr [r8+rcx]
                    vmovups ymmword ptr [rcx], ymm0
                    vmovups ymm1, ymmword ptr [r8+rcx+20h]
                    vmovups ymmword ptr [rcx+20h], ymm1
                  }
                  *(_WORD *)&_RCX->m_value[31] = *(_WORD *)&_RCX->m_value[_R8 + 31];
                }
                ++_RCX;
                --v33;
              }
              while ( v33 );
            }
          }
          bdMemory::deallocate(this->m_data);
          this->m_data = v8;
        }
      }
      else
      {
        if ( (_DWORD)v7 )
        {
          do
          {
            bdHandleAssert((unsigned int)v8 < a->m_size, "rangeCheck(i)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdarray.inl", "bdArray<class bdObjectStoreTag>::operator []", 0x70u, "bdArray<T>::operator[], rangecheck failed");
            v9 = (unsigned int)v8;
            LODWORD(v8) = (_DWORD)v8 + 1;
            _RDX = v9;
            _RAX = a->m_data;
            __asm
            {
              vmovups ymm0, ymmword ptr [rdx+rax]
              vmovups ymm1, ymmword ptr [rdx+rax+20h]
            }
            v14 = *(_WORD *)&a->m_data[_RDX].m_value[31];
            _RAX = this->m_data;
            __asm
            {
              vmovups ymmword ptr [rdx+rax], ymm0
              vmovups ymmword ptr [rdx+rax+20h], ymm1
            }
            *(_WORD *)&_RAX[_RDX].m_value[31] = v14;
            v7 = this->m_size;
          }
          while ( (unsigned int)v8 < (unsigned int)v7 );
        }
        v16 = m_size - (unsigned int)v7;
        v17 = &a->m_data[v7];
        _RAX = &this->m_data[v7];
        if ( (_DWORD)v16 )
        {
          _R8 = (char *)v17 - (char *)_RAX;
          do
          {
            if ( _RAX )
            {
              __asm
              {
                vmovups ymm0, ymmword ptr [r8+rax]
                vmovups ymmword ptr [rax], ymm0
                vmovups ymm1, ymmword ptr [r8+rax+20h]
                vmovups ymmword ptr [rax+20h], ymm1
              }
              *(_WORD *)&_RAX->m_value[31] = *(_WORD *)&_RAX->m_value[_R8 + 31];
            }
            ++_RAX;
            --v16;
          }
          while ( v16 );
        }
        this->m_size = m_size;
      }
    }
    else
    {
      bdMemory::deallocate(this->m_data);
      this->m_data = NULL;
      *(_QWORD *)&this->m_capacity = 0i64;
      this->m_data = bdArray<bdObjectStoreTag>::uninitializedCopy(this, a);
      v6 = a->m_capacity;
      this->m_size = m_size;
      this->m_capacity = v6;
    }
  }
}

/*
==============
bdArray<bdObjectStoreTag>::uninitializedCopy
==============
*/
bdObjectStoreTag *bdArray<bdObjectStoreTag>::uninitializedCopy(bdArray<bdObjectStoreTag> *this, const bdArray<bdObjectStoreTag> *a)
{
  __int64 m_capacity; 
  bdObjectStoreTag *result; 
  unsigned int m_size; 
  bdObjectStoreTag *v6; 
  __int64 v8; 

  m_capacity = a->m_capacity;
  if ( !(_DWORD)m_capacity )
    return 0i64;
  result = (bdObjectStoreTag *)bdMemory::allocate(66 * m_capacity);
  m_size = a->m_size;
  v6 = result;
  if ( m_size )
  {
    _R9 = (char *)a->m_data - (char *)result;
    v8 = m_size;
    do
    {
      if ( result )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [r9+rax]
          vmovups ymmword ptr [rax], ymm0
          vmovups ymm1, ymmword ptr [r9+rax+20h]
          vmovups ymmword ptr [rax+20h], ymm1
        }
        *(_WORD *)&result->m_value[31] = *(_WORD *)&result->m_value[_R9 + 31];
      }
      ++result;
      --v8;
    }
    while ( v8 );
    return v6;
  }
  return result;
}

/*
==============
bdArray<bdObjectStoreErrorWrappedObject>::pushBack
==============
*/
void bdArray<bdObjectStoreErrorWrappedObject>::pushBack(bdArray<bdObjectStoreErrorWrappedObject> *this, const bdObjectStoreErrorWrappedObject *value)
{
  unsigned int m_size; 
  unsigned int m_capacity; 
  int v6; 
  bdObjectStoreErrorWrappedObject *v7; 
  unsigned int v8; 
  bdObjectStoreErrorWrappedObject *m_data; 
  bdArray<bdObjectStoreTag> *p_m_tags; 
  __int64 v11; 
  __int64 v12; 

  m_size = this->m_size;
  m_capacity = this->m_capacity;
  if ( m_size == m_capacity )
  {
    v6 = m_capacity;
    if ( !m_capacity )
      v6 = 1;
    v7 = NULL;
    v8 = m_capacity + v6;
    if ( v8 )
    {
      v7 = (bdObjectStoreErrorWrappedObject *)bdMemory::allocate(3528i64 * v8);
      bdArray<bdObjectStoreErrorWrappedObject>::copyConstructArrayArray(this, v7, this->m_data, this->m_size);
      m_size = this->m_size;
    }
    m_data = this->m_data;
    if ( m_size )
    {
      p_m_tags = &m_data->m_object.m_metadata.m_tags;
      v11 = m_size;
      do
      {
        bdMemory::deallocate(p_m_tags->m_data);
        p_m_tags->m_data = NULL;
        *(_QWORD *)&p_m_tags->m_capacity = 0i64;
        bdObjectStoreACL::~bdObjectStoreACL((bdObjectStoreACL *)&p_m_tags[-201]);
        p_m_tags = (bdArray<bdObjectStoreTag> *)((char *)p_m_tags + 3528);
        --v11;
      }
      while ( v11 );
      m_data = this->m_data;
    }
    bdMemory::deallocate(m_data);
    this->m_data = v7;
    this->m_capacity = v8;
  }
  else
  {
    v7 = this->m_data;
  }
  v12 = this->m_size;
  if ( &v7[v12] )
  {
    bdObjectStoreErrorWrappedObject::bdObjectStoreErrorWrappedObject(&v7[v12], value);
    LODWORD(v12) = this->m_size;
  }
  this->m_size = v12 + 1;
}

/*
==============
bdArray<bdObjectStoreValidationToken>::operator[]
==============
*/
bdObjectStoreValidationToken *bdArray<bdObjectStoreValidationToken>::operator[](bdArray<bdObjectStoreValidationToken> *this, const unsigned int i)
{
  __int64 v3; 

  v3 = i;
  bdHandleAssert(i < this->m_size, "rangeCheck(i)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdarray.inl", "bdArray<class bdObjectStoreValidationToken>::operator []", 0x70u, "bdArray<T>::operator[], rangecheck failed");
  return &this->m_data[v3];
}

/*
==============
bdArray<bdString>::pushBack
==============
*/
void bdArray<bdString>::pushBack(bdArray<bdString> *this, const bdString *value)
{
  unsigned int m_size; 
  unsigned int m_capacity; 
  unsigned int v6; 
  bdString *v7; 
  unsigned int v8; 
  unsigned int v9; 
  bdString *v10; 
  char *v11; 
  __int64 v12; 
  bdString *m_data; 
  __int64 v14; 
  __int64 v15; 
  bdString *v16; 

  m_size = this->m_size;
  m_capacity = this->m_capacity;
  if ( m_size == m_capacity )
  {
    v6 = this->m_capacity;
    if ( !m_capacity )
      v6 = 1;
    v7 = NULL;
    v8 = m_capacity + v6;
    if ( v8 )
    {
      v7 = (bdString *)bdMemory::allocate(8i64 * v8);
      v9 = this->m_size;
      m_size = v9;
      if ( v9 )
      {
        v10 = v7;
        v11 = (char *)((char *)this->m_data - (char *)v7);
        v12 = v9;
        do
        {
          if ( v10 )
            bdString::bdString(v10, (const bdString *)((char *)v10 + (_QWORD)v11));
          ++v10;
          --v12;
        }
        while ( v12 );
        m_size = this->m_size;
      }
    }
    m_data = this->m_data;
    if ( m_size )
    {
      v14 = m_size;
      do
      {
        bdString::~bdString(m_data++);
        --v14;
      }
      while ( v14 );
      m_data = this->m_data;
    }
    bdMemory::deallocate(m_data);
    this->m_data = v7;
    this->m_capacity = v8;
  }
  else
  {
    v7 = this->m_data;
  }
  v15 = this->m_size;
  v16 = &v7[v15];
  if ( v16 )
  {
    bdString::bdString(v16, value);
    LODWORD(v15) = this->m_size;
  }
  this->m_size = v15 + 1;
}

/*
==============
bdArray<bdString>::increaseCapacity
==============
*/
void bdArray<bdString>::increaseCapacity(bdArray<bdString> *this, const unsigned int increase)
{
  unsigned int m_capacity; 
  unsigned int v4; 
  bdString *v5; 
  unsigned int v6; 
  bdString *v7; 
  unsigned int m_size; 
  bdString *v9; 
  char *v10; 
  __int64 v11; 
  unsigned int v12; 
  bdString *m_data; 
  __int64 v14; 

  m_capacity = this->m_capacity;
  v4 = m_capacity;
  if ( increase > m_capacity )
    v4 = increase;
  v5 = NULL;
  v6 = m_capacity + v4;
  if ( v6 )
  {
    v7 = (bdString *)bdMemory::allocate(8i64 * v6);
    v5 = v7;
    m_size = this->m_size;
    if ( m_size )
    {
      v9 = v7;
      v10 = (char *)((char *)this->m_data - (char *)v7);
      v11 = m_size;
      do
      {
        if ( v9 )
          bdString::bdString(v9, (const bdString *)((char *)v9 + (_QWORD)v10));
        ++v9;
        --v11;
      }
      while ( v11 );
    }
  }
  v12 = this->m_size;
  m_data = this->m_data;
  if ( v12 )
  {
    v14 = v12;
    do
    {
      bdString::~bdString(m_data++);
      --v14;
    }
    while ( v14 );
    m_data = this->m_data;
  }
  bdMemory::deallocate(m_data);
  this->m_data = v5;
  this->m_capacity = v6;
}

/*
==============
bdArray<bdJSONValue>::~bdArray<bdJSONValue>
==============
*/
void bdArray<bdJSONValue>::~bdArray<bdJSONValue>(bdArray<bdJSONValue> *this)
{
  unsigned int m_size; 
  bdJSONValue *m_data; 
  __int64 v4; 

  m_size = this->m_size;
  m_data = this->m_data;
  if ( m_size )
  {
    v4 = m_size;
    do
    {
      bdJSONValue::~bdJSONValue(m_data++);
      --v4;
    }
    while ( v4 );
    m_data = this->m_data;
  }
  bdMemory::deallocate(m_data);
  this->m_data = NULL;
  *(_QWORD *)&this->m_capacity = 0i64;
}

/*
==============
bdArray<bdJSONValue>::operator=
==============
*/
void bdArray<bdJSONValue>::operator=(bdArray<bdJSONValue> *this, const bdArray<bdJSONValue> *a)
{
  __int64 m_size; 
  unsigned int v5; 
  bdJSONValue *v6; 
  __int64 v7; 
  bdJSONValue *v8; 
  bdJSONValue *v9; 
  signed __int64 v10; 
  __int64 v11; 
  unsigned int v12; 
  __int64 v13; 
  bdJSONValue *v14; 
  unsigned int v15; 
  __int64 v16; 
  unsigned int m_capacity; 
  unsigned int v18; 
  bdJSONValue *m_data; 
  __int64 v20; 

  if ( this != a )
  {
    v20 = -2i64;
    m_size = a->m_size;
    if ( (unsigned int)m_size <= this->m_capacity )
    {
      v5 = this->m_size;
      v6 = NULL;
      if ( (unsigned int)m_size <= v5 )
      {
        v12 = 0;
        if ( (_DWORD)m_size )
        {
          v13 = 0i64;
          do
          {
            bdHandleAssert(v12 < a->m_size, "rangeCheck(i)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdarray.inl", "bdArray<class bdJSONValue>::operator []", 0x70u, "bdArray<T>::operator[], rangecheck failed", v20);
            bdJSONValue::operator=(&this->m_data[v13], &a->m_data[v13]);
            ++v12;
            ++v13;
          }
          while ( v12 < (unsigned int)m_size );
          v5 = this->m_size;
        }
        v14 = &this->m_data[m_size];
        v15 = v5 - m_size;
        if ( v15 )
        {
          v16 = v15;
          do
          {
            bdJSONValue::~bdJSONValue(v14++);
            --v16;
          }
          while ( v16 );
        }
        this->m_size = m_size;
        m_capacity = this->m_capacity;
        if ( m_capacity > 4 * (int)m_size )
        {
          v18 = m_capacity - (m_capacity >> 1);
          this->m_capacity = v18;
          if ( v18 )
          {
            v6 = (bdJSONValue *)bdMemory::allocate(16i64 * v18);
            bdArray<bdJSONValue>::copyConstructArrayArray(this, v6, this->m_data, this->m_size);
            m_size = this->m_size;
          }
          m_data = this->m_data;
          if ( (_DWORD)m_size )
          {
            do
            {
              bdJSONValue::~bdJSONValue(m_data++);
              --m_size;
            }
            while ( m_size );
            m_data = this->m_data;
          }
          bdMemory::deallocate(m_data);
          this->m_data = v6;
        }
      }
      else
      {
        if ( v5 )
        {
          do
          {
            bdHandleAssert((unsigned int)v6 < a->m_size, "rangeCheck(i)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdarray.inl", "bdArray<class bdJSONValue>::operator []", 0x70u, "bdArray<T>::operator[], rangecheck failed", v20);
            bdJSONValue::operator=(&this->m_data[(unsigned int)v6], &a->m_data[(unsigned int)v6]);
            LODWORD(v6) = (_DWORD)v6 + 1;
            v5 = this->m_size;
          }
          while ( (unsigned int)v6 < v5 );
        }
        v7 = v5;
        v8 = &a->m_data[v7];
        v9 = &this->m_data[v7];
        if ( (_DWORD)m_size != v5 )
        {
          v10 = (char *)v8 - (char *)v9;
          v11 = (unsigned int)m_size - v5;
          do
          {
            if ( v9 )
              bdJSONValue::bdJSONValue(v9, (bdJSONValue *)((char *)v9 + v10));
            ++v9;
            --v11;
          }
          while ( v11 );
        }
        this->m_size = m_size;
      }
    }
    else
    {
      bdArray<bdJSONValue>::clear(this);
      this->m_data = bdArray<bdJSONValue>::uninitializedCopy(this, a);
      this->m_capacity = a->m_capacity;
      this->m_size = m_size;
    }
  }
}

/*
==============
bdArray<bdJSONValue>::clear
==============
*/
void bdArray<bdJSONValue>::clear(bdArray<bdJSONValue> *this)
{
  unsigned int m_size; 
  bdJSONValue *m_data; 
  __int64 v4; 

  m_size = this->m_size;
  m_data = this->m_data;
  if ( m_size )
  {
    v4 = m_size;
    do
    {
      bdJSONValue::~bdJSONValue(m_data++);
      --v4;
    }
    while ( v4 );
    m_data = this->m_data;
  }
  bdMemory::deallocate(m_data);
  this->m_data = NULL;
  *(_QWORD *)&this->m_capacity = 0i64;
}

/*
==============
bdArray<bdJSONValue>::copyConstructArrayArray
==============
*/
void bdArray<bdJSONValue>::copyConstructArrayArray(bdArray<bdJSONValue> *this, bdJSONValue *dest, const bdJSONValue *src, const unsigned int n)
{
  bdJSONValue *v4; 
  signed __int64 v5; 
  __int64 v6; 

  if ( n )
  {
    v4 = dest;
    v5 = (char *)src - (char *)dest;
    v6 = n;
    do
    {
      if ( v4 )
        bdJSONValue::bdJSONValue(v4, (bdJSONValue *)((char *)v4 + v5));
      ++v4;
      --v6;
    }
    while ( v6 );
  }
}

/*
==============
bdArray<bdJSONValue>::uninitializedCopy
==============
*/
bdJSONValue *bdArray<bdJSONValue>::uninitializedCopy(bdArray<bdJSONValue> *this, const bdArray<bdJSONValue> *a)
{
  unsigned int m_capacity; 
  bdJSONValue *v4; 
  unsigned int m_size; 
  bdJSONValue *m_data; 
  bdJSONValue *v7; 
  signed __int64 v8; 
  __int64 v9; 

  m_capacity = a->m_capacity;
  if ( !m_capacity )
    return 0i64;
  v4 = (bdJSONValue *)bdMemory::allocate(16i64 * m_capacity);
  m_size = a->m_size;
  m_data = a->m_data;
  if ( m_size )
  {
    v7 = v4;
    v8 = (char *)m_data - (char *)v4;
    v9 = m_size;
    do
    {
      if ( v7 )
        bdJSONValue::bdJSONValue(v7, (bdJSONValue *)((char *)v7 + v8));
      ++v7;
      --v9;
    }
    while ( v9 );
  }
  return v4;
}

/*
==============
bdArray<bdAddr>::~bdArray<bdAddr>
==============
*/
void bdArray<bdAddr>::~bdArray<bdAddr>(bdArray<bdAddr> *this)
{
  bdMemory::deallocate(this->m_data);
  this->m_data = NULL;
  *(_QWORD *)&this->m_capacity = 0i64;
}

/*
==============
bdArray<bdAntiCheatChallengeParam>::~bdArray<bdAntiCheatChallengeParam>
==============
*/
void bdArray<bdAntiCheatChallengeParam>::~bdArray<bdAntiCheatChallengeParam>(bdArray<bdAntiCheatChallengeParam> *this)
{
  unsigned int m_size; 
  bdAntiCheatChallengeParam *m_data; 
  bdAntiCheatChallengeParam *v4; 
  __int64 v5; 

  m_size = this->m_size;
  m_data = this->m_data;
  if ( m_size )
  {
    v4 = this->m_data;
    v5 = m_size;
    do
    {
      ((void (__fastcall *)(bdAntiCheatChallengeParam *, _QWORD))m_data->~bdAntiCheatChallengeParam)(v4++, 0i64);
      ++m_data;
      --v5;
    }
    while ( v5 );
    m_data = this->m_data;
  }
  bdMemory::deallocate(m_data);
  this->m_data = NULL;
  *(_QWORD *)&this->m_capacity = 0i64;
}

/*
==============
bdArray<bdAntiCheatChallengeParam>::ensureCapacity
==============
*/
void bdArray<bdAntiCheatChallengeParam>::ensureCapacity(bdArray<bdAntiCheatChallengeParam> *this, const unsigned int capacity)
{
  __int64 v2; 
  unsigned int m_capacity; 
  bdAntiCheatChallengeParam *v5; 
  bdAntiCheatChallengeParam *v6; 
  unsigned int m_size; 
  bdAntiCheatChallengeParam *v8; 
  char *v9; 
  __int64 v10; 
  unsigned int v11; 
  bdAntiCheatChallengeParam *m_data; 
  bdAntiCheatChallengeParam *v13; 
  __int64 v14; 

  v2 = capacity;
  m_capacity = this->m_capacity;
  if ( m_capacity < capacity )
  {
    if ( capacity - m_capacity <= m_capacity )
      v2 = 2 * m_capacity;
    v5 = NULL;
    if ( (_DWORD)v2 )
    {
      v6 = (bdAntiCheatChallengeParam *)bdMemory::allocate(24 * v2);
      v5 = v6;
      m_size = this->m_size;
      if ( m_size )
      {
        v8 = v6;
        v9 = (char *)((char *)this->m_data - (char *)v6);
        v10 = m_size;
        do
        {
          if ( v8 )
            bdAntiCheatChallengeParam::bdAntiCheatChallengeParam(v8, (const bdAntiCheatChallengeParam *)((char *)v8 + (_QWORD)v9));
          ++v8;
          --v10;
        }
        while ( v10 );
      }
    }
    v11 = this->m_size;
    m_data = this->m_data;
    if ( v11 )
    {
      v13 = this->m_data;
      v14 = v11;
      do
      {
        ((void (__fastcall *)(bdAntiCheatChallengeParam *, _QWORD))m_data->~bdAntiCheatChallengeParam)(v13++, 0i64);
        ++m_data;
        --v14;
      }
      while ( v14 );
      m_data = this->m_data;
    }
    bdMemory::deallocate(m_data);
    this->m_data = v5;
    this->m_capacity = v2;
  }
}

/*
==============
bdArray<bdChannelInfo>::~bdArray<bdChannelInfo>
==============
*/
void bdArray<bdChannelInfo>::~bdArray<bdChannelInfo>(bdArray<bdChannelInfo> *this)
{
  bdArray<bdChannelInfo>::destruct(this, this->m_data, this->m_size);
  bdMemory::deallocate(this->m_data);
  this->m_data = NULL;
  *(_QWORD *)&this->m_capacity = 0i64;
}

/*
==============
bdArray<bdChannelInfo>::destruct
==============
*/
void bdArray<bdChannelInfo>::destruct(bdArray<bdChannelInfo> *this, bdChannelInfo *src, const unsigned int n)
{
  __int64 v4; 
  __int64 v5; 
  __int64 v6; 
  __int64 v7; 

  if ( n )
  {
    v4 = 0i64;
    v5 = 0i64;
    v6 = n;
    do
    {
      v7 = *(int *)(*((_QWORD *)&src[v4].__vftable + 1) + 4i64);
      (**(void (__fastcall ***)(char *, _QWORD))((char *)&src->__vftable + v7 + v4 * 96 + 8))((char *)&src->__vftable + v7 + v5 + 8, 0i64);
      v5 += 96i64;
      ++v4;
      --v6;
    }
    while ( v6 );
  }
}

/*
==============
bdArray<bdChannelInfo>::increaseCapacity
==============
*/
void bdArray<bdChannelInfo>::increaseCapacity(bdArray<bdChannelInfo> *this, const unsigned int increase)
{
  bdArray<bdChannelInfo> *v2; 
  int v3; 
  unsigned int m_capacity; 
  unsigned int v5; 
  bool v6; 
  __int64 v7; 
  char *v8; 
  unsigned int m_size; 
  __int64 v12; 
  bdReferencable *v13; 
  unsigned int v16; 

  v2 = this;
  v3 = 0;
  m_capacity = this->m_capacity;
  v5 = m_capacity;
  if ( increase > m_capacity )
    v5 = increase;
  v6 = m_capacity + v5 == 0;
  v7 = m_capacity + v5;
  v16 = v7;
  v8 = NULL;
  if ( !v6 )
  {
    v8 = (char *)bdMemory::allocate(96 * v7);
    m_size = v2->m_size;
    if ( m_size )
    {
      _RBX = (bdReferencable *)(v8 + 80);
      _RBP = (char *)v2->m_data - v8;
      v12 = m_size;
      do
      {
        v13 = _RBX - 5;
        if ( _RBX != (bdReferencable *)80 )
        {
          *(_QWORD *)&_RBX[-5].m_refCount.m_value._My_val = &bdChannelInfo::`vbtable'{for `bdTaskResult'};
          *(_QWORD *)&_RBX[-4].m_refCount.m_value._My_val = &bdChannelInfo::`vbtable'{for `bdStructBufferSerializable'};
          bdReferencable::bdReferencable(_RBX, (const bdReferencable *)((char *)&_RBX->m_refCount + _RBP + *(int *)(*(_QWORD *)((char *)&_RBX[-4] + _RBP - 8) + 4i64) - 80));
          v3 |= 1u;
          bdTaskResult::bdTaskResult((bdTaskResult *)&_RBX[-5], (const bdTaskResult *)((char *)&_RBX[-5] + _RBP));
          bdStructBufferSerializable::bdStructBufferSerializable((bdStructBufferSerializable *)&_RBX[-4], (const bdStructBufferSerializable *)((char *)&_RBX[-4] + _RBP));
          v13->__vftable = (bdReferencable_vtbl *)&bdChannelInfo::`vftable'{for `bdTaskResult'};
          _RBX[-4].__vftable = (bdReferencable_vtbl *)&bdChannelInfo::`vftable'{for `bdStructBufferSerializable'};
          *(_QWORD *)((char *)&v13->m_refCount.m_value._My_val + *(int *)(*(_QWORD *)&_RBX[-5].m_refCount.m_value._My_val + 4i64)) = &bdChannelInfo::`vftable'{for `bdReferencable'};
          __asm
          {
            vmovups xmm0, xmmword ptr [rbx+rbp-30h]
            vmovups xmmword ptr [rbx-30h], xmm0
          }
          _RBX[-2].__vftable = *(bdReferencable_vtbl **)((char *)&_RBX[-2].__vftable + _RBP);
          _RBX[-2].m_refCount.m_value._My_val = *(_DWORD *)((char *)&_RBX[-1] + _RBP - 8);
          *((_DWORD *)&_RBX[-2].m_refCount + 1) = *(_DWORD *)((char *)&_RBX[-1] + _RBP - 4);
          _RBX[-1].__vftable = *(bdReferencable_vtbl **)((char *)&_RBX[-1].__vftable + _RBP);
          LOBYTE(_RBX[-1].m_refCount.m_value._My_val) = *((_BYTE *)_RBX + _RBP - 8);
          BYTE1(_RBX[-1].m_refCount.m_value._My_val) = *((_BYTE *)_RBX + _RBP - 7);
          *((_DWORD *)&_RBX[-1].m_refCount + 1) = *(_DWORD *)((char *)_RBX + _RBP - 4);
        }
        _RBX += 6;
        --v12;
      }
      while ( v12 );
      v2 = this;
    }
  }
  bdArray<bdChannelInfo>::destruct(v2, v2->m_data, v2->m_size);
  bdMemory::deallocate(v2->m_data);
  v2->m_data = (bdChannelInfo *)v8;
  v2->m_capacity = v16;
}

/*
==============
bdArray<bdChannelMember>::~bdArray<bdChannelMember>
==============
*/
void bdArray<bdChannelMember>::~bdArray<bdChannelMember>(bdArray<bdChannelMember> *this)
{
  bdArray<bdChannelMember>::destruct(this, this->m_data, this->m_size);
  bdMemory::deallocate(this->m_data);
  this->m_data = NULL;
  *(_QWORD *)&this->m_capacity = 0i64;
}

/*
==============
bdArray<bdChannelMember>::destruct
==============
*/
void bdArray<bdChannelMember>::destruct(bdArray<bdChannelMember> *this, bdChannelMember *src, const unsigned int n)
{
  __int64 v4; 
  __int64 v5; 
  __int64 v6; 
  __int64 v7; 

  if ( n )
  {
    v4 = 0i64;
    v5 = 0i64;
    v6 = n;
    do
    {
      v7 = *(int *)(*((_QWORD *)&src[v4].__vftable + 1) + 4i64);
      (**(void (__fastcall ***)(char *, _QWORD))((char *)&src->__vftable + v7 + v4 * 128 + 8))((char *)&src->__vftable + v7 + v5 + 8, 0i64);
      v5 += 128i64;
      ++v4;
      --v6;
    }
    while ( v6 );
  }
}

/*
==============
bdArray<bdChannelMember>::pushBack
==============
*/
void bdArray<bdChannelMember>::pushBack(bdArray<bdChannelMember> *this, const bdChannelMember *value)
{
  bdArray<bdChannelMember> *v2; 
  int v3; 
  __int64 m_size; 
  unsigned int m_capacity; 
  int v6; 
  bool v7; 
  unsigned int v8; 
  bdChannelMember *m_data; 
  char *v10; 
  signed __int64 v12; 
  signed __int64 v13; 
  signed __int64 v14; 
  __int64 v15; 
  signed __int64 v16; 
  signed __int64 v17; 
  bdReferencable *v18; 
  const bdTaskResult *v19; 
  unsigned int v23; 
  bdChannelMember *v24; 
  signed __int64 v25; 
  signed __int64 v26; 
  signed __int64 v27; 
  bdChannelMember *v28; 
  bdChannelMember *__that; 
  unsigned int v31; 

  __that = (bdChannelMember *)value;
  v2 = this;
  v3 = 0;
  m_size = this->m_size;
  m_capacity = v2->m_capacity;
  if ( (_DWORD)m_size == m_capacity )
  {
    v6 = v2->m_capacity;
    if ( !m_capacity )
      v6 = 1;
    v7 = m_capacity + v6 == 0;
    v8 = m_capacity + v6;
    v31 = v8;
    m_data = NULL;
    if ( !v7 )
    {
      v10 = (char *)bdMemory::allocate((unsigned __int64)v8 << 7);
      m_data = (bdChannelMember *)v10;
      v28 = (bdChannelMember *)v10;
      LODWORD(m_size) = v2->m_size;
      if ( (_DWORD)m_size )
      {
        _RBX = (bdReferencable *)(v10 + 112);
        v12 = (char *)v2->m_data - v10;
        v13 = v12 - 104;
        v25 = v12 - 72;
        v26 = v12 - 8;
        v14 = v12 - 112;
        v27 = v12 - 112;
        v15 = (unsigned int)m_size;
        v16 = v12 - 96;
        v17 = v12 - 80;
        do
        {
          v18 = _RBX - 7;
          if ( _RBX != (bdReferencable *)112 )
          {
            *(_QWORD *)&_RBX[-7].m_refCount.m_value._My_val = &bdChannelMember::`vbtable'{for `bdTaskResult'};
            *(_QWORD *)&_RBX[-6].m_refCount.m_value._My_val = &bdChannelMember::`vbtable'{for `bdStructBufferSerializable'};
            v19 = (const bdTaskResult *)((char *)_RBX + v14);
            bdReferencable::bdReferencable(_RBX, (const bdReferencable *)((char *)&_RBX->m_refCount + v14 + SHIDWORD((*(bdReferencable_vtbl **)((char *)&_RBX->__vftable + v13))->~bdReferencable)));
            v3 |= 1u;
            bdTaskResult::bdTaskResult((bdTaskResult *)&_RBX[-7], v19);
            bdStructBufferSerializable::bdStructBufferSerializable((bdStructBufferSerializable *)&_RBX[-6], (const bdStructBufferSerializable *)((char *)_RBX + v16));
            v18->__vftable = (bdReferencable_vtbl *)&bdChannelMember::`vftable'{for `bdTaskResult'};
            _RBX[-6].__vftable = (bdReferencable_vtbl *)&bdChannelMember::`vftable'{for `bdStructBufferSerializable'};
            *(_QWORD *)((char *)&v18->m_refCount.m_value._My_val + *(int *)(*(_QWORD *)&_RBX[-7].m_refCount.m_value._My_val + 4i64)) = &bdChannelMember::`vftable'{for `bdReferencable'};
            _RBX[-5].__vftable = *(bdReferencable_vtbl **)((char *)&_RBX->__vftable + v17);
            _R8 = v25;
            __asm
            {
              vmovups ymm0, ymmword ptr [r8+rbx]
              vmovups ymmword ptr [rbx-48h], ymm0
              vmovups ymm1, ymmword ptr [r8+rbx+20h]
              vmovups ymmword ptr [rbx-28h], ymm1
            }
            _RBX[-1].m_refCount.m_value._My_val = *(_DWORD *)((char *)&_RBX->__vftable + v26);
            v14 = v27;
          }
          _RBX += 8;
          --v15;
        }
        while ( v15 );
        v2 = this;
        LODWORD(m_size) = this->m_size;
        m_data = v28;
        v8 = v31;
      }
    }
    bdArray<bdChannelMember>::destruct(v2, v2->m_data, m_size);
    bdMemory::deallocate(v2->m_data);
    v2->m_data = m_data;
    v2->m_capacity = v8;
    m_size = v2->m_size;
    value = __that;
  }
  else
  {
    m_data = v2->m_data;
  }
  v23 = m_size;
  v24 = &m_data[m_size];
  if ( v24 )
  {
    bdChannelMember::bdChannelMember(v24, value);
    v23 = v2->m_size;
  }
  v2->m_size = v23 + 1;
}

/*
==============
bdArray<bdClansGroupInfo>::copyConstructArrayArray
==============
*/
void bdArray<bdClansGroupInfo>::copyConstructArrayArray(bdArray<bdClansGroupInfo> *this, bdClansGroupInfo *dest, const bdClansGroupInfo *src, const unsigned int n)
{
  int v4; 
  bdStructUserAccountID *p_m_value; 
  signed __int64 v6; 
  __int64 v7; 
  _QWORD *v8; 
  __int64 v11; 
  __int64 v22; 

  if ( n )
  {
    v4 = 0;
    p_m_value = &src->m_owner.m_value;
    v6 = (char *)dest - (char *)src;
    v7 = n;
    do
    {
      v8 = (_QWORD *)((char *)&p_m_value[-6] + v6 - 48);
      if ( (bdStructUserAccountID *)((char *)p_m_value + v6) != (bdStructUserAccountID *)576 )
      {
        *(_QWORD *)((char *)&p_m_value[-6] + v6 - 40) = &bdClansGroupInfo::`vbtable';
        bdReferencable::bdReferencable((bdReferencable *)((char *)&p_m_value[1].__vftable + v6 + 16), (const bdReferencable *)((char *)&p_m_value[-6] + *(int *)(p_m_value[-7].m_userID + 4) - 40));
        v4 |= 1u;
        bdStructBufferSerializable::bdStructBufferSerializable((bdStructBufferSerializable *)((char *)&p_m_value[-6] + v6 - 48), (const bdStructBufferSerializable *)&p_m_value[-7]._bytes_20[8]);
        *v8 = &bdClansGroupIdentifier::`vftable'{for `bdStructBufferSerializable'};
        *(_QWORD *)((char *)v8 + *(int *)(*(_QWORD *)((char *)&p_m_value[-6] + v6 - 40) + 4i64) + 8) = &bdClansGroupIdentifier::`vftable'{for `bdReferencable'};
        *(_WORD *)((char *)&p_m_value[-6] + v6 - 32) = *(_WORD *)p_m_value[-7].gap38;
        *(_QWORD *)((char *)&p_m_value[-6] + v6 - 24) = *(_QWORD *)&p_m_value[-7].gap38[8];
        *(_WORD *)((char *)&p_m_value[-6] + v6 - 16) = *(_WORD *)p_m_value[-7]._bytes_48;
        *(_QWORD *)((char *)&p_m_value[-6] + v6 - 8) = *(_QWORD *)&p_m_value[-7]._bytes_48[8];
        *v8 = &bdClansGroupInfo::`vftable'{for `bdStructBufferSerializable'};
        *(_QWORD *)((char *)v8 + *(int *)(*(_QWORD *)((char *)&p_m_value[-6] + v6 - 40) + 4i64) + 8) = &bdClansGroupInfo::`vftable'{for `bdReferencable'};
        _RAX = (__int64)&p_m_value[-6] + v6;
        _RCX = p_m_value - 6;
        v11 = 2i64;
        do
        {
          __asm
          {
            vmovups xmm0, xmmword ptr [rcx]
            vmovups xmmword ptr [rax], xmm0
            vmovups xmm1, xmmword ptr [rcx+10h]
            vmovups xmmword ptr [rax+10h], xmm1
            vmovups xmm0, xmmword ptr [rcx+20h]
            vmovups xmmword ptr [rax+20h], xmm0
            vmovups xmm1, xmmword ptr [rcx+30h]
            vmovups xmmword ptr [rax+30h], xmm1
            vmovups xmm0, xmmword ptr [rcx+40h]
            vmovups xmmword ptr [rax+40h], xmm0
            vmovups xmm1, xmmword ptr [rcx+50h]
            vmovups xmmword ptr [rax+50h], xmm1
            vmovups xmm0, xmmword ptr [rcx+60h]
            vmovups xmmword ptr [rax+60h], xmm0
          }
          _RAX += 128i64;
          __asm
          {
            vmovups xmm1, xmmword ptr [rcx+70h]
            vmovups xmmword ptr [rax-10h], xmm1
          }
          _RCX = (bdStructUserAccountID *)((char *)_RCX + 128);
          --v11;
        }
        while ( v11 );
        _RCX = (__int64)&p_m_value[-3] + v6 - 8;
        _RAX = &p_m_value[-4]._bytes_48[8];
        v22 = 2i64;
        do
        {
          __asm
          {
            vmovups xmm0, xmmword ptr [rax]
            vmovups xmmword ptr [rcx], xmm0
            vmovups xmm1, xmmword ptr [rax+10h]
            vmovups xmmword ptr [rcx+10h], xmm1
            vmovups xmm0, xmmword ptr [rax+20h]
            vmovups xmmword ptr [rcx+20h], xmm0
            vmovups xmm1, xmmword ptr [rax+30h]
            vmovups xmmword ptr [rcx+30h], xmm1
            vmovups xmm0, xmmword ptr [rax+40h]
            vmovups xmmword ptr [rcx+40h], xmm0
            vmovups xmm1, xmmword ptr [rax+50h]
            vmovups xmmword ptr [rcx+50h], xmm1
            vmovups xmm0, xmmword ptr [rax+60h]
            vmovups xmmword ptr [rcx+60h], xmm0
          }
          _RCX += 128i64;
          __asm
          {
            vmovups xmm1, xmmword ptr [rax+70h]
            vmovups xmmword ptr [rcx-10h], xmm1
          }
          _RAX += 128;
          --v22;
        }
        while ( v22 );
        *(_WORD *)((char *)p_m_value + v6 - 16) = *(_WORD *)p_m_value[-1]._bytes_48;
        *((_BYTE *)p_m_value + v6 - 8) = p_m_value[-1]._bytes_48[8];
        bdStructUserAccountID::bdStructUserAccountID((bdStructUserAccountID *)((char *)p_m_value + v6), p_m_value);
        *(_DWORD *)((char *)&p_m_value[1].__vftable + v6) = p_m_value[1].__vftable;
        *(_DWORD *)((char *)&p_m_value[1].__vftable + v6 + 4) = HIDWORD(p_m_value[1].__vftable);
        *(_DWORD *)((char *)&p_m_value[1].__vftable + v6 + 8) = *((_DWORD *)&p_m_value[1].__vftable + 2);
        *(_DWORD *)((char *)&p_m_value[1].__vftable + v6 + 12) = *((_DWORD *)&p_m_value[1].__vftable + 3);
      }
      p_m_value = (bdStructUserAccountID *)((char *)p_m_value + 696);
      --v7;
    }
    while ( v7 );
  }
}

/*
==============
bdArray<bdClansGroupInfo>::destruct
==============
*/
void bdArray<bdClansGroupInfo>::destruct(bdArray<bdClansGroupInfo> *this, bdClansGroupInfo *src, const unsigned int n)
{
  __int64 v4; 
  __int64 v5; 
  __int64 v6; 
  __int64 v7; 

  if ( n )
  {
    v4 = 0i64;
    v5 = 0i64;
    v6 = n;
    do
    {
      v7 = *(int *)(*((_QWORD *)&src[v4].__vftable + 1) + 4i64);
      (**(void (__fastcall ***)(char *, _QWORD))((char *)&src->__vftable + v7 + v4 * 696 + 8))((char *)&src->__vftable + v7 + v5 + 8, 0i64);
      v5 += 696i64;
      ++v4;
      --v6;
    }
    while ( v6 );
  }
}

/*
==============
bdArray<bdClansGroupMembershipInfo>::bdArray<bdClansGroupMembershipInfo>
==============
*/
void bdArray<bdClansGroupMembershipInfo>::bdArray<bdClansGroupMembershipInfo>(bdArray<bdClansGroupMembershipInfo> *this, const bdArray<bdClansGroupMembershipInfo> *a)
{
  bdArray<bdClansGroupMembershipInfo> *v3; 
  int v4; 
  __int64 m_capacity; 
  bdClansGroupMembershipInfo *v6; 
  unsigned int m_size; 
  bdClansGroupMembershipInfo *m_data; 
  bdReferencable *m_group; 
  __int64 v10; 
  signed __int64 v11; 
  __int64 v12; 
  __int64 v13; 
  char *v14; 

  v3 = this;
  v4 = 0;
  this->m_capacity = a->m_capacity;
  this->m_size = a->m_size;
  m_capacity = a->m_capacity;
  if ( (_DWORD)m_capacity )
  {
    v6 = (bdClansGroupMembershipInfo *)bdMemory::allocate(112 * m_capacity);
    m_size = a->m_size;
    m_data = a->m_data;
    if ( m_size )
    {
      m_group = (bdReferencable *)v6->m_group;
      v10 = (char *)v6 - (char *)m_data + 40;
      v11 = (char *)m_data - (char *)v6;
      v12 = m_size;
      v13 = v10;
      do
      {
        v14 = (char *)&m_group[-2];
        if ( m_group != (bdReferencable *)32 )
        {
          *(_QWORD *)&m_group[-2].m_refCount.m_value._My_val = &bdClansGroupMembershipInfo::`vbtable';
          bdReferencable::bdReferencable(m_group + 4, (const bdReferencable *)((char *)&m_group->m_refCount + v11 + *(int *)(*(_QWORD *)((char *)&m_group[-1] + v11 - 8) + 4i64) - 32));
          bdStructBufferSerializable::bdStructBufferSerializable((bdStructBufferSerializable *)&m_group[-2], (const bdStructBufferSerializable *)((char *)&m_group[-2] + v11));
          *(_QWORD *)v14 = &bdClansGroupMembershipInfo::`vftable'{for `bdStructBufferSerializable'};
          *(_QWORD *)&v14[*(int *)(*(_QWORD *)&m_group[-2].m_refCount.m_value._My_val + 4i64) + 8] = &bdClansGroupMembershipInfo::`vftable'{for `bdReferencable'};
          LOWORD(m_group[-1].__vftable) = *(_WORD *)((char *)&m_group[-1].__vftable + v11);
          m_group->__vftable = (bdReferencable_vtbl *)&bdClansGroupIdentifier::`vbtable';
          bdReferencable::bdReferencable((bdReferencable *)((char *)m_group + v11 + v13), (bdReferencable *)((char *)m_group + v11 + SHIDWORD((*(bdReferencable_vtbl **)((char *)&m_group->__vftable + v11))->~bdReferencable)));
          v4 |= 3u;
          bdStructBufferSerializable::bdStructBufferSerializable((bdStructBufferSerializable *)&m_group[-1].m_refCount, (const bdStructBufferSerializable *)((char *)m_group + v11 - 8));
          *(_QWORD *)&m_group[-1].m_refCount.m_value._My_val = &bdClansGroupIdentifier::`vftable'{for `bdStructBufferSerializable'};
          *(bdReferencable_vtbl **)((char *)&m_group->__vftable + SHIDWORD(m_group->~bdReferencable)) = (bdReferencable_vtbl *)&bdClansGroupIdentifier::`vftable'{for `bdReferencable'};
          LOWORD(m_group->m_refCount.m_value._My_val) = *(_WORD *)((char *)&m_group->m_refCount.m_value._My_val + v11);
          m_group[1].__vftable = *(bdReferencable_vtbl **)((char *)&m_group[1].__vftable + v11);
          LOWORD(m_group[1].m_refCount.m_value._My_val) = *(_WORD *)((char *)&m_group[1].m_refCount.m_value._My_val + v11);
          m_group[2].__vftable = *(bdReferencable_vtbl **)((char *)&m_group[2].__vftable + v11);
          LOBYTE(m_group[3].m_refCount.m_value._My_val) = *((_BYTE *)&m_group[3].m_refCount.m_value._My_val + v11);
        }
        m_group += 7;
        --v12;
      }
      while ( v12 );
      v3 = this;
    }
    v3->m_data = v6;
  }
  else
  {
    this->m_data = NULL;
  }
}

/*
==============
bdArray<bdClansGroupMemberInfo>::copyConstructArrayArray
==============
*/
void bdArray<bdClansGroupMemberInfo>::copyConstructArrayArray(bdArray<bdClansGroupMemberInfo> *this, bdClansGroupMemberInfo *dest, const bdClansGroupMemberInfo *src, const unsigned int n)
{
  int v4; 
  bdClansGroupMemberInfo_vtbl **v5; 
  signed __int64 v6; 
  signed __int64 v7; 
  __int64 v8; 

  if ( n )
  {
    v4 = 0;
    v5 = &dest->__vftable + 1;
    v6 = (char *)dest - (char *)src;
    v7 = (char *)src - (char *)dest;
    v8 = n;
    do
    {
      if ( v5 != (bdClansGroupMemberInfo_vtbl **)8 )
      {
        *v5 = (bdClansGroupMemberInfo_vtbl *)&bdClansGroupMemberInfo::`vbtable';
        bdReferencable::bdReferencable((bdReferencable *)((char *)v5 + v7 + v6 + 192), (const bdReferencable *)((char *)v5 + v7 + SHIDWORD((*(bdClansGroupMemberInfo_vtbl **)((char *)v5 + v7))->serialize)));
        v4 |= 1u;
        bdStructBufferSerializable::bdStructBufferSerializable((bdStructBufferSerializable *)(v5 - 1), (const bdStructBufferSerializable *)((char *)v5 + v7 - 8));
        *(v5 - 1) = (bdClansGroupMemberInfo_vtbl *)&bdClansGroupMemberInfo::`vftable'{for `bdStructBufferSerializable'};
        *(bdClansGroupMemberInfo_vtbl **)((char *)v5 + SHIDWORD((*v5)->serialize)) = (bdClansGroupMemberInfo_vtbl *)&bdClansGroupMemberInfo::`vftable'{for `bdReferencable'};
        bdStructUserDetails::bdStructUserDetails((bdStructUserDetails *)(v5 + 1), (const bdStructUserDetails *)((char *)v5 + v7 + 8));
        bdArray<bdClansGroupMembershipInfo>::bdArray<bdClansGroupMembershipInfo>((bdArray<bdClansGroupMembershipInfo> *)(v5 + 21), (const bdArray<bdClansGroupMembershipInfo> *)((char *)v5 + v7 + 168));
        *((_BYTE *)v5 + 184) = *((_BYTE *)v5 + v7 + 184);
      }
      v5 += 27;
      --v8;
    }
    while ( v8 );
  }
}

/*
==============
bdArray<bdClansGroupMemberInfo>::destruct
==============
*/
void bdArray<bdClansGroupMemberInfo>::destruct(bdArray<bdClansGroupMemberInfo> *this, bdClansGroupMemberInfo *src, const unsigned int n)
{
  __int64 v4; 
  __int64 v5; 
  __int64 v6; 
  __int64 v7; 

  if ( n )
  {
    v4 = 0i64;
    v5 = 0i64;
    v6 = n;
    do
    {
      v7 = *(int *)(*((_QWORD *)&src[v4].__vftable + 1) + 4i64);
      (**(void (__fastcall ***)(char *, _QWORD))((char *)&src->__vftable + v7 + v4 * 216 + 8))((char *)&src->__vftable + v7 + v5 + 8, 0i64);
      v5 += 216i64;
      ++v4;
      --v6;
    }
    while ( v6 );
  }
}

/*
==============
bdArray<bdClansGroupMembershipProposal>::copyConstructArrayArray
==============
*/
void bdArray<bdClansGroupMembershipProposal>::copyConstructArrayArray(bdArray<bdClansGroupMembershipProposal> *this, bdClansGroupMembershipProposal *dest, const bdClansGroupMembershipProposal *src, const unsigned int n)
{
  int v4; 
  bdClansGroupIdentifier_vtbl **v5; 
  signed __int64 v6; 
  signed __int64 v7; 
  __int64 v8; 
  bdClansGroupIdentifier_vtbl **v9; 
  __int64 v12; 

  if ( n )
  {
    v4 = 0;
    v5 = &dest->m_group.__vftable + 1;
    v6 = (char *)dest - (char *)src;
    v7 = (char *)src - (char *)dest;
    v8 = n;
    do
    {
      v9 = v5 - 44;
      if ( v5 != (bdClansGroupIdentifier_vtbl **)352 )
      {
        *(v5 - 43) = (bdClansGroupIdentifier_vtbl *)&bdClansGroupMembershipProposal::`vbtable';
        bdReferencable::bdReferencable((bdReferencable *)v5 + 69, (const bdReferencable *)((char *)v5 + v7 + SHIDWORD((*(bdClansGroupIdentifier_vtbl **)((char *)v5 + v7 - 344))->serialize) - 344));
        bdStructBufferSerializable::bdStructBufferSerializable((bdStructBufferSerializable *)v5 - 11, (const bdStructBufferSerializable *)((char *)v5 + v7 - 352));
        *v9 = (bdClansGroupIdentifier_vtbl *)&bdClansGroupMembershipProposal::`vftable'{for `bdStructBufferSerializable'};
        *(bdClansGroupIdentifier_vtbl **)((char *)v9 + SHIDWORD((*(v5 - 43))->serialize) + 8) = (bdClansGroupIdentifier_vtbl *)&bdClansGroupMembershipProposal::`vftable'{for `bdReferencable'};
        bdStructUserDetails::bdStructUserDetails((bdStructUserDetails *)(v5 - 42), (const bdStructUserDetails *)((char *)v5 + v7 - 336));
        bdStructUserDetails::bdStructUserDetails((bdStructUserDetails *)(v5 - 22), (const bdStructUserDetails *)((char *)v5 + v7 - 176));
        *((_WORD *)v5 - 8) = *(_WORD *)((char *)v5 + v7 - 16);
        *v5 = (bdClansGroupIdentifier_vtbl *)&bdClansGroupIdentifier::`vbtable';
        bdReferencable::bdReferencable((bdReferencable *)((char *)v5 + v7 + v6 + 40), (const bdReferencable *)((char *)v5 + v7 + SHIDWORD((*(bdClansGroupIdentifier_vtbl **)((char *)v5 + v7))->serialize)));
        v4 |= 3u;
        bdStructBufferSerializable::bdStructBufferSerializable((bdStructBufferSerializable *)(v5 - 1), (const bdStructBufferSerializable *)((char *)v5 + v7 - 8));
        *(v5 - 1) = (bdClansGroupIdentifier_vtbl *)&bdClansGroupIdentifier::`vftable'{for `bdStructBufferSerializable'};
        *(bdClansGroupIdentifier_vtbl **)((char *)v5 + SHIDWORD((*v5)->serialize)) = (bdClansGroupIdentifier_vtbl *)&bdClansGroupIdentifier::`vftable'{for `bdReferencable'};
        *((_WORD *)v5 + 4) = *(_WORD *)((char *)v5 + v7 + 8);
        v5[2] = *(bdClansGroupIdentifier_vtbl **)((char *)v5 + v7 + 16);
        *((_WORD *)v5 + 12) = *(_WORD *)((char *)v5 + v7 + 24);
        v5[4] = *(bdClansGroupIdentifier_vtbl **)((char *)v5 + v7 + 32);
        v5[7] = *(bdClansGroupIdentifier_vtbl **)((char *)v5 + v7 + 56);
        *((_DWORD *)v5 + 16) = *(_DWORD *)((char *)v5 + v7 + 64);
        _RCX = (char *)v5 + 68;
        _RAX = (__int64)v5 + v7 + 68;
        v12 = 8i64;
        do
        {
          __asm
          {
            vmovups xmm0, xmmword ptr [rax]
            vmovups xmmword ptr [rcx], xmm0
            vmovups xmm1, xmmword ptr [rax+10h]
            vmovups xmmword ptr [rcx+10h], xmm1
            vmovups xmm0, xmmword ptr [rax+20h]
            vmovups xmmword ptr [rcx+20h], xmm0
            vmovups xmm1, xmmword ptr [rax+30h]
            vmovups xmmword ptr [rcx+30h], xmm1
            vmovups xmm0, xmmword ptr [rax+40h]
            vmovups xmmword ptr [rcx+40h], xmm0
            vmovups xmm1, xmmword ptr [rax+50h]
            vmovups xmmword ptr [rcx+50h], xmm1
            vmovups xmm0, xmmword ptr [rax+60h]
            vmovups xmmword ptr [rcx+60h], xmm0
          }
          _RCX += 128;
          __asm
          {
            vmovups xmm1, xmmword ptr [rax+70h]
            vmovups xmmword ptr [rcx-10h], xmm1
          }
          _RAX += 128i64;
          --v12;
        }
        while ( v12 );
        v5[137] = *(bdClansGroupIdentifier_vtbl **)((char *)v5 + v7 + 1096);
      }
      v5 += 184;
      --v8;
    }
    while ( v8 );
  }
}

/*
==============
bdArray<bdClansGroupMembershipProposal>::destruct
==============
*/
void bdArray<bdClansGroupMembershipProposal>::destruct(bdArray<bdClansGroupMembershipProposal> *this, bdClansGroupMembershipProposal *src, const unsigned int n)
{
  __int64 v4; 
  __int64 v5; 
  __int64 v6; 
  __int64 v7; 

  if ( n )
  {
    v4 = 0i64;
    v5 = 0i64;
    v6 = n;
    do
    {
      v7 = *(int *)(*((_QWORD *)&src[v4].__vftable + 1) + 4i64);
      (**(void (__fastcall ***)(char *, _QWORD))((char *)&src->__vftable + v7 + v4 * 1472 + 8))((char *)&src->__vftable + v7 + v5 + 8, 0i64);
      v5 += 1472i64;
      ++v4;
      --v6;
    }
    while ( v6 );
  }
}

/*
==============
bdArray<bdClansFailedMembershipProposal>::copyConstructArrayArray
==============
*/
void bdArray<bdClansFailedMembershipProposal>::copyConstructArrayArray(bdArray<bdClansFailedMembershipProposal> *this, bdClansFailedMembershipProposal *dest, const bdClansFailedMembershipProposal *src, const unsigned int n)
{
  int v4; 
  bdClansFailedMembershipProposal_vtbl **v5; 
  signed __int64 v6; 
  signed __int64 v7; 
  __int64 v8; 

  if ( n )
  {
    v4 = 0;
    v5 = &dest->__vftable + 1;
    v6 = (char *)dest - (char *)src;
    v7 = (char *)src - (char *)dest;
    v8 = n;
    do
    {
      if ( v5 != (bdClansFailedMembershipProposal_vtbl **)8 )
      {
        *v5 = (bdClansFailedMembershipProposal_vtbl *)&bdClansFailedMembershipProposal::`vbtable';
        bdReferencable::bdReferencable((bdReferencable *)((char *)v5 + v7 + v6 + 240), (const bdReferencable *)((char *)v5 + v7 + SHIDWORD((*(bdClansFailedMembershipProposal_vtbl **)((char *)v5 + v7))->serialize)));
        v4 |= 1u;
        bdStructBufferSerializable::bdStructBufferSerializable((bdStructBufferSerializable *)(v5 - 1), (const bdStructBufferSerializable *)((char *)v5 + v7 - 8));
        *(v5 - 1) = (bdClansFailedMembershipProposal_vtbl *)&bdClansFailedMembershipProposal::`vftable'{for `bdStructBufferSerializable'};
        *(bdClansFailedMembershipProposal_vtbl **)((char *)v5 + SHIDWORD((*v5)->serialize)) = (bdClansFailedMembershipProposal_vtbl *)&bdClansFailedMembershipProposal::`vftable'{for `bdReferencable'};
        bdStructUserDetails::bdStructUserDetails((bdStructUserDetails *)(v5 + 1), (const bdStructUserDetails *)((char *)v5 + v7 + 8));
        bdClansGroupIdentifier::bdClansGroupIdentifier((bdClansGroupIdentifier *)(v5 + 21), (const bdClansGroupIdentifier *)((char *)v5 + v7 + 168));
        *((_DWORD *)v5 + 58) = *(_DWORD *)((char *)v5 + v7 + 232);
      }
      v5 += 33;
      --v8;
    }
    while ( v8 );
  }
}

/*
==============
bdArray<bdClansUserMembershipProposal>::copyConstructArrayArray
==============
*/
void bdArray<bdClansUserMembershipProposal>::copyConstructArrayArray(bdArray<bdClansUserMembershipProposal> *this, bdClansUserMembershipProposal *dest, const bdClansUserMembershipProposal *src, const unsigned int n)
{
  int v4; 
  bdClansUserMembershipProposal_vtbl **v5; 
  signed __int64 v6; 
  signed __int64 v7; 
  __int64 v8; 
  __int64 v11; 

  if ( n )
  {
    v4 = 0;
    v5 = &dest->__vftable + 1;
    v6 = (char *)dest - (char *)src;
    v7 = (char *)src - (char *)dest;
    v8 = n;
    do
    {
      if ( v5 != (bdClansUserMembershipProposal_vtbl **)8 )
      {
        *v5 = (bdClansUserMembershipProposal_vtbl *)&bdClansUserMembershipProposal::`vbtable';
        bdReferencable::bdReferencable((bdReferencable *)((char *)v5 + v7 + v6 + 1200), (const bdReferencable *)((char *)v5 + v7 + SHIDWORD((*(bdClansUserMembershipProposal_vtbl **)((char *)v5 + v7))->serialize)));
        v4 |= 1u;
        bdStructBufferSerializable::bdStructBufferSerializable((bdStructBufferSerializable *)(v5 - 1), (const bdStructBufferSerializable *)((char *)v5 + v7 - 8));
        *(v5 - 1) = (bdClansUserMembershipProposal_vtbl *)&bdClansUserMembershipProposal::`vftable'{for `bdStructBufferSerializable'};
        *(bdClansUserMembershipProposal_vtbl **)((char *)v5 + SHIDWORD((*v5)->serialize)) = (bdClansUserMembershipProposal_vtbl *)&bdClansUserMembershipProposal::`vftable'{for `bdReferencable'};
        bdStructUserDetails::bdStructUserDetails((bdStructUserDetails *)(v5 + 1), (const bdStructUserDetails *)((char *)v5 + v7 + 8));
        *((_WORD *)v5 + 84) = *(_WORD *)((char *)v5 + v7 + 168);
        *((_DWORD *)v5 + 43) = *(_DWORD *)((char *)v5 + v7 + 172);
        _RCX = v5 + 22;
        _RAX = (__int64)v5 + v7 + 176;
        v11 = 8i64;
        do
        {
          __asm
          {
            vmovups xmm0, xmmword ptr [rax]
            vmovups xmmword ptr [rcx], xmm0
            vmovups xmm1, xmmword ptr [rax+10h]
            vmovups xmmword ptr [rcx+10h], xmm1
            vmovups xmm0, xmmword ptr [rax+20h]
            vmovups xmmword ptr [rcx+20h], xmm0
            vmovups xmm1, xmmword ptr [rax+30h]
            vmovups xmmword ptr [rcx+30h], xmm1
            vmovups xmm0, xmmword ptr [rax+40h]
            vmovups xmmword ptr [rcx+40h], xmm0
            vmovups xmm1, xmmword ptr [rax+50h]
            vmovups xmmword ptr [rcx+50h], xmm1
            vmovups xmm0, xmmword ptr [rax+60h]
            vmovups xmmword ptr [rcx+60h], xmm0
          }
          _RCX += 16;
          __asm
          {
            vmovups xmm1, xmmword ptr [rax+70h]
            vmovups xmmword ptr [rcx-10h], xmm1
          }
          _RAX += 128i64;
          --v11;
        }
        while ( v11 );
      }
      v5 += 153;
      --v8;
    }
    while ( v8 );
  }
}

/*
==============
bdArray<bdClansFailedMembershipProposal>::destruct
==============
*/
void bdArray<bdClansFailedMembershipProposal>::destruct(bdArray<bdClansFailedMembershipProposal> *this, bdClansFailedMembershipProposal *src, const unsigned int n)
{
  __int64 v4; 
  __int64 v5; 
  __int64 v6; 
  __int64 v7; 

  if ( n )
  {
    v4 = 0i64;
    v5 = 0i64;
    v6 = n;
    do
    {
      v7 = *(int *)(*((_QWORD *)&src[v4].__vftable + 1) + 4i64);
      (**(void (__fastcall ***)(char *, _QWORD))((char *)&src->__vftable + v7 + v4 * 264 + 8))((char *)&src->__vftable + v7 + v5 + 8, 0i64);
      v5 += 264i64;
      ++v4;
      --v6;
    }
    while ( v6 );
  }
}

/*
==============
bdArray<bdClansRemovedMembershipProposal>::copyConstructArrayArray
==============
*/
void bdArray<bdClansRemovedMembershipProposal>::copyConstructArrayArray(bdArray<bdClansRemovedMembershipProposal> *this, bdClansRemovedMembershipProposal *dest, const bdClansRemovedMembershipProposal *src, const unsigned int n)
{
  int v4; 
  bdClansRemovedMembershipProposal_vtbl **v5; 
  signed __int64 v6; 
  __int64 v7; 
  _QWORD *v8; 

  if ( n )
  {
    v4 = 0;
    v5 = &src->__vftable + 3;
    v6 = (char *)dest - (char *)src;
    v7 = n;
    do
    {
      v8 = (bdClansRemovedMembershipProposal_vtbl **)((char *)v5 + v6 - 24);
      if ( (bdClansRemovedMembershipProposal_vtbl **)((char *)v5 + v6) != (bdClansRemovedMembershipProposal_vtbl **)24 )
      {
        *(bdClansRemovedMembershipProposal_vtbl **)((char *)v5 + v6 - 16) = (bdClansRemovedMembershipProposal_vtbl *)&bdClansRemovedMembershipProposal::`vbtable';
        bdReferencable::bdReferencable((bdReferencable *)((char *)v5 + v6 + 232), (const bdReferencable *)((char *)v5 + SHIDWORD((*(v5 - 2))->serialize) - 16));
        v4 |= 1u;
        bdStructBufferSerializable::bdStructBufferSerializable((bdStructBufferSerializable *)((char *)v5 + v6 - 24), (const bdStructBufferSerializable *)(v5 - 3));
        *v8 = &bdClansRemovedMembershipProposal::`vftable'{for `bdStructBufferSerializable'};
        *(_QWORD *)((char *)v8 + SHIDWORD((*(bdClansRemovedMembershipProposal_vtbl **)((char *)v5 + v6 - 16))->serialize) + 8) = &bdClansRemovedMembershipProposal::`vftable'{for `bdReferencable'};
        *((_BYTE *)v5 + v6 - 8) = *((_BYTE *)v5 - 8);
        bdStructUserDetails::bdStructUserDetails((bdStructUserDetails *)((char *)v5 + v6), (const bdStructUserDetails *)v5);
        bdClansGroupIdentifier::bdClansGroupIdentifier((bdClansGroupIdentifier *)((char *)v5 + v6 + 160), (const bdClansGroupIdentifier *)(v5 + 20));
        *(_DWORD *)((char *)v5 + v6 + 224) = *((_DWORD *)v5 + 56);
      }
      v5 += 34;
      --v7;
    }
    while ( v7 );
  }
}

/*
==============
bdArray<bdObjectStoreHTTPHeader>::operator[]
==============
*/
bdObjectStoreHTTPHeader *bdArray<bdObjectStoreHTTPHeader>::operator[](bdArray<bdObjectStoreHTTPHeader> *this, const unsigned int i)
{
  __int64 v3; 

  v3 = i;
  bdHandleAssert(i < this->m_size, "rangeCheck(i)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdarray.inl", "bdArray<class bdObjectStoreHTTPHeader>::operator []", 0x70u, "bdArray<T>::operator[], rangecheck failed");
  return &this->m_data[v3];
}

/*
==============
bdArray<bdObjectStoreErrorWrappedObject>::operator=
==============
*/
void bdArray<bdObjectStoreErrorWrappedObject>::operator=(bdArray<bdObjectStoreErrorWrappedObject> *this, const bdArray<bdObjectStoreErrorWrappedObject> *a)
{
  __int64 m_size; 
  __int64 v5; 
  bdObjectStoreErrorWrappedObject *v6; 
  unsigned int v7; 
  unsigned int v8; 
  bdObjectStoreErrorWrappedObject *v9; 
  unsigned int v10; 
  __int64 v11; 
  unsigned int m_capacity; 
  unsigned int v13; 

  if ( this != a )
  {
    m_size = a->m_size;
    if ( (unsigned int)m_size <= this->m_capacity )
    {
      v8 = this->m_size;
      v9 = NULL;
      if ( (unsigned int)m_size <= v8 )
      {
        v10 = 0;
        if ( (_DWORD)m_size )
        {
          v11 = 0i64;
          do
          {
            bdHandleAssert(v10 < a->m_size, "rangeCheck(i)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdarray.inl", "bdArray<class bdObjectStoreErrorWrappedObject>::operator []", 0x70u, "bdArray<T>::operator[], rangecheck failed");
            bdObjectStoreErrorWrappedObject::operator=(&this->m_data[v11], &a->m_data[v11]);
            ++v10;
            ++v11;
          }
          while ( v10 < (unsigned int)m_size );
          v8 = this->m_size;
        }
        bdArray<bdObjectStoreErrorWrappedObject>::destruct(this, &this->m_data[m_size], v8 - m_size);
        m_capacity = this->m_capacity;
        this->m_size = m_size;
        if ( m_capacity > 4 * (int)m_size )
        {
          v13 = m_capacity - (m_capacity >> 1);
          this->m_capacity = v13;
          if ( v13 )
          {
            v9 = (bdObjectStoreErrorWrappedObject *)bdMemory::allocate(3528i64 * v13);
            bdArray<bdObjectStoreErrorWrappedObject>::copyConstructArrayArray(this, v9, this->m_data, this->m_size);
            LODWORD(m_size) = this->m_size;
          }
          bdArray<bdObjectStoreErrorWrappedObject>::destruct(this, this->m_data, m_size);
          bdMemory::deallocate(this->m_data);
          this->m_data = v9;
        }
      }
      else
      {
        if ( v8 )
        {
          do
          {
            bdHandleAssert((unsigned int)v9 < a->m_size, "rangeCheck(i)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdarray.inl", "bdArray<class bdObjectStoreErrorWrappedObject>::operator []", 0x70u, "bdArray<T>::operator[], rangecheck failed");
            bdObjectStoreErrorWrappedObject::operator=(&this->m_data[(unsigned int)v9], &a->m_data[(unsigned int)v9]);
            v8 = this->m_size;
            LODWORD(v9) = (_DWORD)v9 + 1;
          }
          while ( (unsigned int)v9 < v8 );
        }
        bdArray<bdObjectStoreErrorWrappedObject>::copyConstructArrayArray(this, &this->m_data[v8], &a->m_data[v8], m_size - v8);
        this->m_size = m_size;
      }
    }
    else
    {
      bdArray<bdObjectStoreErrorWrappedObject>::clear(this);
      v5 = a->m_capacity;
      v6 = NULL;
      if ( (_DWORD)v5 )
      {
        v6 = (bdObjectStoreErrorWrappedObject *)bdMemory::allocate(3528 * v5);
        bdArray<bdObjectStoreErrorWrappedObject>::copyConstructArrayArray(this, v6, a->m_data, a->m_size);
      }
      this->m_data = v6;
      v7 = a->m_capacity;
      this->m_size = m_size;
      this->m_capacity = v7;
    }
  }
}

/*
==============
bdArray<bdObjectStoreErrorWrappedObject>::clear
==============
*/
void bdArray<bdObjectStoreErrorWrappedObject>::clear(bdArray<bdObjectStoreErrorWrappedObject> *this)
{
  unsigned int m_size; 
  bdObjectStoreErrorWrappedObject *m_data; 
  bdArray<bdObjectStoreTag> *p_m_tags; 
  __int64 v5; 

  m_size = this->m_size;
  m_data = this->m_data;
  if ( m_size )
  {
    p_m_tags = &m_data->m_object.m_metadata.m_tags;
    v5 = m_size;
    do
    {
      bdMemory::deallocate(p_m_tags->m_data);
      p_m_tags->m_data = NULL;
      *(_QWORD *)&p_m_tags->m_capacity = 0i64;
      bdObjectStoreACL::~bdObjectStoreACL((bdObjectStoreACL *)&p_m_tags[-201]);
      p_m_tags = (bdArray<bdObjectStoreTag> *)((char *)p_m_tags + 3528);
      --v5;
    }
    while ( v5 );
    m_data = this->m_data;
  }
  bdMemory::deallocate(m_data);
  this->m_data = NULL;
  *(_QWORD *)&this->m_capacity = 0i64;
}

/*
==============
bdArray<bdObjectStoreErrorWrappedObject>::destruct
==============
*/
void bdArray<bdObjectStoreErrorWrappedObject>::destruct(bdArray<bdObjectStoreErrorWrappedObject> *this, bdObjectStoreErrorWrappedObject *src, const unsigned int n)
{
  bdArray<bdObjectStoreTag> *p_m_tags; 
  __int64 v4; 

  if ( n )
  {
    p_m_tags = &src->m_object.m_metadata.m_tags;
    v4 = n;
    do
    {
      bdMemory::deallocate(p_m_tags->m_data);
      p_m_tags->m_data = NULL;
      *(_QWORD *)&p_m_tags->m_capacity = 0i64;
      bdObjectStoreACL::~bdObjectStoreACL((bdObjectStoreACL *)&p_m_tags[-201]);
      p_m_tags = (bdArray<bdObjectStoreTag> *)((char *)p_m_tags + 3528);
      --v4;
    }
    while ( v4 );
  }
}

/*
==============
bdArray<bdObjectStoreErrorWrappedMetadata>::~bdArray<bdObjectStoreErrorWrappedMetadata>
==============
*/
void bdArray<bdObjectStoreErrorWrappedMetadata>::~bdArray<bdObjectStoreErrorWrappedMetadata>(bdArray<bdObjectStoreErrorWrappedMetadata> *this)
{
  bdArray<bdObjectStoreErrorWrappedMetadata>::clear(this);
}

/*
==============
bdArray<bdObjectStoreValidationToken>::~bdArray<bdObjectStoreValidationToken>
==============
*/
void bdArray<bdObjectStoreValidationToken>::~bdArray<bdObjectStoreValidationToken>(bdArray<bdObjectStoreValidationToken> *this)
{
  bdArray<bdObjectStoreValidationToken>::clear(this);
}

/*
==============
bdArray<bdObjectStoreErrorWrappedMetadata>::clear
==============
*/
void bdArray<bdObjectStoreErrorWrappedMetadata>::clear(bdArray<bdObjectStoreErrorWrappedMetadata> *this)
{
  unsigned int m_size; 
  bdObjectStoreErrorWrappedMetadata *m_data; 
  bdArray<bdObjectStoreTag> *p_m_tags; 
  __int64 v5; 

  m_size = this->m_size;
  m_data = this->m_data;
  if ( m_size )
  {
    p_m_tags = &m_data->m_metadata.m_tags;
    v5 = m_size;
    do
    {
      bdMemory::deallocate(p_m_tags->m_data);
      p_m_tags->m_data = NULL;
      *(_QWORD *)&p_m_tags->m_capacity = 0i64;
      bdObjectStoreACL::~bdObjectStoreACL((bdObjectStoreACL *)&p_m_tags[-201]);
      p_m_tags += 219;
      --v5;
    }
    while ( v5 );
    m_data = this->m_data;
  }
  bdMemory::deallocate(m_data);
  this->m_data = NULL;
  *(_QWORD *)&this->m_capacity = 0i64;
}

/*
==============
bdArray<bdObjectStoreValidationToken>::clear
==============
*/
void bdArray<bdObjectStoreValidationToken>::clear(bdArray<bdObjectStoreValidationToken> *this)
{
  unsigned int m_size; 
  bdObjectStoreValidationToken *m_data; 
  bdValidationTokenResult *v4; 
  __int64 v5; 

  m_size = this->m_size;
  m_data = this->m_data;
  if ( m_size )
  {
    v4 = (bdValidationTokenResult *)&m_data->m_validationTokenResult.gap2824[4];
    v5 = m_size;
    do
    {
      bdValidationTokenResult::~bdValidationTokenResult(v4);
      bdReferencable::~bdReferencable((bdReferencable *)v4);
      v4 = (bdValidationTokenResult *)((char *)v4 + 10408);
      --v5;
    }
    while ( v5 );
    m_data = this->m_data;
  }
  bdMemory::deallocate(m_data);
  this->m_data = NULL;
  *(_QWORD *)&this->m_capacity = 0i64;
}

/*
==============
bdArray<bdObjectStoreErrorWrappedMetadata>::copyConstructArrayArray
==============
*/
void bdArray<bdObjectStoreErrorWrappedMetadata>::copyConstructArrayArray(bdArray<bdObjectStoreErrorWrappedMetadata> *this, bdObjectStoreErrorWrappedMetadata *dest, const bdObjectStoreErrorWrappedMetadata *src, const unsigned int n)
{
  signed __int64 v5; 
  signed __int64 v6; 
  signed __int64 v8; 
  signed __int64 v9; 
  signed __int64 v10; 
  signed __int64 v13; 
  signed __int64 v14; 
  __int64 v15; 
  __int64 v28; 
  void *v41; 
  __int64 v42; 
  void *v43; 
  __int64 v44; 
  signed __int64 v50; 
  signed __int64 v51; 
  signed __int64 v52; 
  signed __int64 v53; 
  signed __int64 v54; 
  signed __int64 v55; 
  signed __int64 v56; 
  signed __int64 v57; 
  signed __int64 v58; 
  signed __int64 v59; 
  signed __int64 v60; 
  signed __int64 v61; 
  signed __int64 v62; 
  signed __int64 v63; 
  signed __int64 v64; 
  signed __int64 v65; 
  signed __int64 v66; 

  if ( n )
  {
    _RBX = &src->m_metadata.m_tags.m_capacity;
    v5 = (char *)dest - (char *)src;
    v62 = v5 + 4;
    v6 = v5 + 8;
    _RBP = v5 + 12;
    v8 = v5 + 48;
    v9 = v5 + 52;
    v10 = v5 + 56;
    _R11 = v5 - 3424;
    v66 = v5 - 3424;
    v50 = v5 - 3312;
    v51 = v5 - 3279;
    v52 = v5 - 3240;
    v53 = v5 - 3232;
    v54 = v5 - 3224;
    v55 = v5 - 3216;
    v56 = v5 - 3208;
    v57 = v5 - 3200;
    _R8 = v5 - 2176;
    v64 = v5 - 2176;
    v13 = v5 - 2111;
    v65 = v5 - 2111;
    v58 = v5 - 60;
    v59 = v5 - 56;
    v60 = v5 - 48;
    v61 = v5 - 15;
    v63 = v5 - 8;
    v14 = v5 - 3440;
    v15 = n;
    do
    {
      _RAX = (char *)_RBX + v14;
      if ( (unsigned int *)((char *)_RBX + v14) )
      {
        __asm
        {
          vmovups xmm0, xmmword ptr [rbx-0D70h]
          vmovups xmmword ptr [rax], xmm0
          vmovups ymm0, ymmword ptr [rbx-0D60h]
          vmovups ymmword ptr [r11+rbx], ymm0
          vmovups ymm1, ymmword ptr [rbx-0D40h]
          vmovups ymmword ptr [r11+rbx+20h], ymm1
          vmovups ymm0, ymmword ptr [rbx-0D20h]
          vmovups ymmword ptr [r11+rbx+40h], ymm0
          vmovups xmm1, xmmword ptr [rbx-0D00h]
          vmovups xmmword ptr [r11+rbx+60h], xmm1
          vmovups ymm0, ymmword ptr [rbx-0CF0h]
        }
        _RCX = v50;
        __asm { vmovups ymmword ptr [rcx+rbx], ymm0 }
        *((_BYTE *)_RBX + v50 + 32) = *((_BYTE *)_RBX - 3280);
        __asm { vmovups ymm0, ymmword ptr [rbx-0CCFh] }
        _RCX = v51;
        __asm { vmovups ymmword ptr [rcx+rbx], ymm0 }
        *((_BYTE *)_RBX + v51 + 32) = *((_BYTE *)_RBX - 3247);
        *(_QWORD *)((char *)_RBX + v52) = *((_QWORD *)_RBX - 405);
        *(_QWORD *)((char *)_RBX + v53) = *((_QWORD *)_RBX - 404);
        *(unsigned int *)((char *)_RBX + v54) = *(_RBX - 806);
        *(_QWORD *)((char *)_RBX + v55) = *((_QWORD *)_RBX - 402);
        *(_QWORD *)((char *)_RBX + v56) = *((_QWORD *)_RBX - 401);
        _RCX = (char *)_RBX + v57;
        _RAX = _RBX - 800;
        v28 = 8i64;
        do
        {
          __asm
          {
            vmovups xmm0, xmmword ptr [rax]
            vmovups xmmword ptr [rcx], xmm0
            vmovups xmm1, xmmword ptr [rax+10h]
            vmovups xmmword ptr [rcx+10h], xmm1
            vmovups xmm0, xmmword ptr [rax+20h]
            vmovups xmmword ptr [rcx+20h], xmm0
            vmovups xmm1, xmmword ptr [rax+30h]
            vmovups xmmword ptr [rcx+30h], xmm1
            vmovups xmm0, xmmword ptr [rax+40h]
            vmovups xmmword ptr [rcx+40h], xmm0
            vmovups xmm1, xmmword ptr [rax+50h]
            vmovups xmmword ptr [rcx+50h], xmm1
            vmovups xmm0, xmmword ptr [rax+60h]
            vmovups xmmword ptr [rcx+60h], xmm0
          }
          _RCX += 128;
          __asm
          {
            vmovups xmm1, xmmword ptr [rax+70h]
            vmovups xmmword ptr [rcx-10h], xmm1
          }
          _RAX += 32;
          --v28;
        }
        while ( v28 );
        __asm
        {
          vmovups ymm0, ymmword ptr [rbx-880h]
          vmovups ymmword ptr [r8+rbx], ymm0
          vmovups ymm1, ymmword ptr [rbx-860h]
          vmovups ymmword ptr [r8+rbx+20h], ymm1
        }
        *((_BYTE *)_RBX + _R8 + 64) = *((_BYTE *)_RBX - 2112);
        memcpy_0((char *)_RBX + v13, (char *)_RBX - 2111, 0x800ui64);
        *(unsigned int *)((char *)_RBX + v58) = *(_RBX - 15);
        *(_QWORD *)((char *)_RBX + v59) = *((_QWORD *)_RBX - 7);
        __asm { vmovups ymm0, ymmword ptr [rbx-30h] }
        _R11 = v60;
        __asm { vmovups ymmword ptr [r11+rbx], ymm0 }
        *((_BYTE *)_RBX + v60 + 32) = *((_BYTE *)_RBX - 16);
        *((_BYTE *)_RBX + v61) = *((_BYTE *)_RBX - 15);
        *(unsigned int *)((char *)_RBX + v62 - 4) = *_RBX;
        *(unsigned int *)((char *)_RBX + v62) = _RBX[1];
        v41 = NULL;
        v42 = *_RBX;
        if ( (_DWORD)v42 )
        {
          v43 = bdMemory::allocate(66 * v42);
          v41 = v43;
          v44 = _RBX[1];
          if ( (_DWORD)v44 )
          {
            _RCX = v43;
            _R8 = *((_QWORD *)_RBX - 1) - (_QWORD)v43;
            do
            {
              if ( _RCX )
              {
                __asm
                {
                  vmovups ymm0, ymmword ptr [r8+rcx]
                  vmovups ymmword ptr [rcx], ymm0
                  vmovups ymm1, ymmword ptr [r8+rcx+20h]
                  vmovups ymmword ptr [rcx+20h], ymm1
                }
                _RCX[32] = *(_WORD *)((char *)_RCX + _R8 + 64);
              }
              _RCX += 33;
              --v44;
            }
            while ( v44 );
          }
        }
        *(_QWORD *)((char *)_RBX + v63) = v41;
        *(unsigned int *)((char *)_RBX + v6) = _RBX[2];
        __asm
        {
          vmovups ymm0, ymmword ptr [rbx+0Ch]
          vmovups ymmword ptr [rbx+rbp], ymm0
        }
        *(unsigned int *)((char *)_RBX + v8) = _RBX[12];
        *(unsigned int *)((char *)_RBX + v9) = _RBX[13];
        *((_BYTE *)_RBX + v10) = *((_BYTE *)_RBX + 56);
        _R8 = v64;
        v13 = v65;
        _R11 = v66;
      }
      _RBX += 876;
      --v15;
    }
    while ( v15 );
  }
}

/*
==============
bdArray<bdObjectStoreErrorWrappedMetadata>::increaseCapacity
==============
*/
void bdArray<bdObjectStoreErrorWrappedMetadata>::increaseCapacity(bdArray<bdObjectStoreErrorWrappedMetadata> *this, const unsigned int increase)
{
  unsigned int m_capacity; 
  unsigned int v4; 
  bdObjectStoreErrorWrappedMetadata *v5; 
  unsigned int v6; 
  unsigned int m_size; 
  bdObjectStoreErrorWrappedMetadata *m_data; 
  bdArray<bdObjectStoreTag> *p_m_tags; 
  __int64 v10; 

  m_capacity = this->m_capacity;
  v4 = m_capacity;
  if ( increase > m_capacity )
    v4 = increase;
  v5 = NULL;
  v6 = m_capacity + v4;
  if ( v6 )
  {
    v5 = (bdObjectStoreErrorWrappedMetadata *)bdMemory::allocate(3504i64 * v6);
    bdArray<bdObjectStoreErrorWrappedMetadata>::copyConstructArrayArray(this, v5, this->m_data, this->m_size);
  }
  m_size = this->m_size;
  m_data = this->m_data;
  if ( m_size )
  {
    p_m_tags = &m_data->m_metadata.m_tags;
    v10 = m_size;
    do
    {
      bdMemory::deallocate(p_m_tags->m_data);
      p_m_tags->m_data = NULL;
      *(_QWORD *)&p_m_tags->m_capacity = 0i64;
      bdObjectStoreACL::~bdObjectStoreACL((bdObjectStoreACL *)&p_m_tags[-201]);
      p_m_tags += 219;
      --v10;
    }
    while ( v10 );
    m_data = this->m_data;
  }
  bdMemory::deallocate(m_data);
  this->m_data = v5;
  this->m_capacity = v6;
}

/*
==============
bdArray<bdObjectStoreValidationToken>::increaseCapacity
==============
*/
void bdArray<bdObjectStoreValidationToken>::increaseCapacity(bdArray<bdObjectStoreValidationToken> *this, const unsigned int increase)
{
  bdArray<bdObjectStoreValidationToken> *v2; 
  int v3; 
  unsigned int m_capacity; 
  unsigned int v5; 
  bool v6; 
  unsigned int v7; 
  bdObjectStoreValidationToken *v8; 
  unsigned int m_size; 
  bdObjectStoreValidationToken *m_data; 
  signed __int64 v12; 
  __int64 v14; 
  unsigned int v19; 
  bdObjectStoreValidationToken *v20; 
  bdValidationTokenResult *v21; 
  __int64 v22; 

  v2 = this;
  v3 = 0;
  m_capacity = this->m_capacity;
  v5 = m_capacity;
  if ( increase > m_capacity )
    v5 = increase;
  v6 = m_capacity + v5 == 0;
  v7 = m_capacity + v5;
  v8 = NULL;
  if ( !v6 )
  {
    v8 = (bdObjectStoreValidationToken *)bdMemory::allocate(10408i64 * v7);
    m_size = v2->m_size;
    m_data = v2->m_data;
    if ( m_size )
    {
      _RDI = (char *)(&v8->m_validationTokenResult.__vftable + 1);
      v12 = (char *)v8 - (char *)m_data;
      _R15 = (char *)m_data - (char *)v8;
      v14 = m_size;
      do
      {
        if ( _RDI != (char *)8 )
        {
          *(_QWORD *)_RDI = &bdValidationTokenResult::`vbtable';
          bdReferencable::bdReferencable((bdReferencable *)&_RDI[_R15 + 10272 + v12], (const bdReferencable *)&_RDI[_R15 + *(int *)(*(_QWORD *)&_RDI[_R15] + 4i64)]);
          v3 |= 1u;
          bdTaskResult::bdTaskResult((bdTaskResult *)(_RDI - 8), (const bdTaskResult *)&_RDI[_R15 - 8]);
          *((_QWORD *)_RDI - 1) = &bdValidationTokenResult::`vftable'{for `bdTaskResult'};
          *(_QWORD *)&_RDI[*(int *)(*(_QWORD *)_RDI + 4i64)] = &bdValidationTokenResult::`vftable'{for `bdReferencable'};
          *((_QWORD *)_RDI + 1) = *(_QWORD *)&_RDI[_R15 + 8];
          *((_QWORD *)_RDI + 2) = *(_QWORD *)&_RDI[_R15 + 16];
          memcpy_0(_RDI + 24, &_RDI[_R15 + 24], 0x2800ui64);
          *((_DWORD *)_RDI + 2566) = *(_DWORD *)&_RDI[_R15 + 10264];
          __asm
          {
            vmovups ymm0, ymmword ptr [r15+rdi+2830h]
            vmovups ymmword ptr [rdi+2830h], ymm0
            vmovups ymm1, ymmword ptr [r15+rdi+2850h]
            vmovups ymmword ptr [rdi+2850h], ymm1
            vmovups ymm0, ymmword ptr [r15+rdi+2870h]
            vmovups ymmword ptr [rdi+2870h], ymm0
            vmovups xmm1, xmmword ptr [r15+rdi+2890h]
            vmovups xmmword ptr [rdi+2890h], xmm1
          }
        }
        _RDI += 10408;
        --v14;
      }
      while ( v14 );
      v2 = this;
    }
  }
  v19 = v2->m_size;
  v20 = v2->m_data;
  if ( v19 )
  {
    v21 = (bdValidationTokenResult *)&v20->m_validationTokenResult.gap2824[4];
    v22 = v19;
    do
    {
      bdValidationTokenResult::~bdValidationTokenResult(v21);
      bdReferencable::~bdReferencable((bdReferencable *)v21);
      v21 = (bdValidationTokenResult *)((char *)v21 + 10408);
      --v22;
    }
    while ( v22 );
    v20 = v2->m_data;
  }
  bdMemory::deallocate(v20);
  v2->m_data = v8;
  v2->m_capacity = v7;
}

/*
==============
bdArray<GeneralChannelRequest>::~bdArray<GeneralChannelRequest>
==============
*/
void bdArray<GeneralChannelRequest>::~bdArray<GeneralChannelRequest>(bdArray<GeneralChannelRequest> *this)
{
  unsigned int m_size; 
  GeneralChannelRequest *m_data; 
  __int64 v4; 
  __int64 v5; 
  __int64 v6; 
  __int64 v7; 

  m_size = this->m_size;
  m_data = this->m_data;
  if ( m_size )
  {
    v4 = 0i64;
    v5 = 0i64;
    v6 = m_size;
    do
    {
      v7 = *(int *)(*((_QWORD *)&m_data[v4].__vftable + 1) + 4i64);
      (**(void (__fastcall ***)(__int64, _QWORD))((char *)&m_data->__vftable + v7 + v4 * 64 + 8))((__int64)&m_data->__vftable + v7 + v5 + 8, 0i64);
      v5 += 64i64;
      ++v4;
      --v6;
    }
    while ( v6 );
    m_data = this->m_data;
  }
  bdMemory::deallocate(m_data);
  this->m_data = NULL;
  *(_QWORD *)&this->m_capacity = 0i64;
}

/*
==============
bdArray<bdString>::~bdArray<bdString>
==============
*/
void bdArray<bdString>::~bdArray<bdString>(bdArray<bdString> *this)
{
  unsigned int m_size; 
  bdString *m_data; 
  __int64 v4; 

  m_size = this->m_size;
  m_data = this->m_data;
  if ( m_size )
  {
    v4 = m_size;
    do
    {
      bdString::~bdString(m_data++);
      --v4;
    }
    while ( v4 );
    m_data = this->m_data;
  }
  bdMemory::deallocate(m_data);
  this->m_data = NULL;
  *(_QWORD *)&this->m_capacity = 0i64;
}

/*
==============
bdArray<bdClansGroupIdentifier>::operator=
==============
*/
void bdArray<bdClansGroupIdentifier>::operator=(bdArray<bdClansGroupIdentifier> *this, const bdArray<bdClansGroupIdentifier> *a)
{
  unsigned int m_size; 
  __int64 v5; 
  unsigned int v6; 
  bdClansGroupIdentifier *v7; 
  unsigned __int64 v8; 
  char *v9; 
  char *v10; 
  unsigned int v11; 
  char *v12; 
  char *v13; 
  unsigned int m_capacity; 
  unsigned int v15; 

  if ( this != a )
  {
    m_size = this->m_size;
    v5 = a->m_size;
    if ( (unsigned int)v5 <= this->m_capacity )
    {
      v7 = NULL;
      if ( (unsigned int)v5 <= m_size )
      {
        v11 = 0;
        if ( (_DWORD)v5 )
        {
          do
          {
            bdHandleAssert(v11 < a->m_size, "rangeCheck(i)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdarray.inl", "bdArray<class bdClansGroupIdentifier>::operator []", 0x70u, "bdArray<T>::operator[], rangecheck failed");
            v12 = (char *)v7 + (unsigned __int64)a->m_data;
            v13 = (char *)v7 + (unsigned __int64)this->m_data;
            bdReferencable::operator=((bdReferencable *)&v13[*(int *)(*((_QWORD *)v13 + 1) + 4i64) + 8], (const bdReferencable *)&v12[*(int *)(*((_QWORD *)v12 + 1) + 4i64) + 8]);
            ++v11;
            *((_WORD *)v13 + 8) = *((_WORD *)v12 + 8);
            ++v7;
            *((_QWORD *)v13 + 3) = *((_QWORD *)v12 + 3);
            *((_WORD *)v13 + 16) = *((_WORD *)v12 + 16);
            *((_QWORD *)v13 + 5) = *((_QWORD *)v12 + 5);
          }
          while ( v11 < (unsigned int)v5 );
          m_size = this->m_size;
          v7 = NULL;
        }
        bdArray<bdClansGroupIdentifier>::destruct(this, &this->m_data[v5], m_size - v5);
        m_capacity = this->m_capacity;
        this->m_size = v5;
        if ( m_capacity > 4 * (int)v5 )
        {
          v15 = m_capacity - (m_capacity >> 1);
          this->m_capacity = v15;
          if ( v15 )
          {
            v7 = (bdClansGroupIdentifier *)bdMemory::allocate((unsigned __int64)v15 << 6);
            bdArray<bdClansGroupIdentifier>::copyConstructArrayArray(this, v7, this->m_data, this->m_size);
            LODWORD(v5) = this->m_size;
          }
          bdArray<bdClansGroupIdentifier>::destruct(this, this->m_data, v5);
          bdMemory::deallocate(this->m_data);
          this->m_data = v7;
        }
      }
      else
      {
        if ( m_size )
        {
          do
          {
            bdHandleAssert((unsigned int)v7 < a->m_size, "rangeCheck(i)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdarray.inl", "bdArray<class bdClansGroupIdentifier>::operator []", 0x70u, "bdArray<T>::operator[], rangecheck failed");
            v8 = (unsigned __int64)(unsigned int)v7 << 6;
            v9 = (char *)a->m_data + v8;
            v10 = (char *)this->m_data + v8;
            bdReferencable::operator=((bdReferencable *)&v10[*(int *)(*((_QWORD *)v10 + 1) + 4i64) + 8], (const bdReferencable *)&v9[*(int *)(*((_QWORD *)v9 + 1) + 4i64) + 8]);
            LODWORD(v7) = (_DWORD)v7 + 1;
            *((_WORD *)v10 + 8) = *((_WORD *)v9 + 8);
            *((_QWORD *)v10 + 3) = *((_QWORD *)v9 + 3);
            *((_WORD *)v10 + 16) = *((_WORD *)v9 + 16);
            *((_QWORD *)v10 + 5) = *((_QWORD *)v9 + 5);
            m_size = this->m_size;
          }
          while ( (unsigned int)v7 < m_size );
        }
        bdArray<bdClansGroupIdentifier>::copyConstructArrayArray(this, &this->m_data[(unsigned __int64)m_size], &a->m_data[(unsigned __int64)m_size], v5 - m_size);
        this->m_size = v5;
      }
    }
    else
    {
      bdArray<bdClansGroupIdentifier>::destruct(this, this->m_data, m_size);
      bdMemory::deallocate(this->m_data);
      this->m_data = NULL;
      *(_QWORD *)&this->m_capacity = 0i64;
      this->m_data = bdArray<bdClansGroupIdentifier>::uninitializedCopy(this, a);
      v6 = a->m_capacity;
      this->m_size = v5;
      this->m_capacity = v6;
    }
  }
}

/*
==============
bdArray<bdClansGroupIdentifier>::uninitializedCopy
==============
*/
bdClansGroupIdentifier *bdArray<bdClansGroupIdentifier>::uninitializedCopy(bdArray<bdClansGroupIdentifier> *this, const bdArray<bdClansGroupIdentifier> *a)
{
  unsigned int m_capacity; 
  bdClansGroupIdentifier *v5; 

  m_capacity = a->m_capacity;
  if ( !m_capacity )
    return 0i64;
  v5 = (bdClansGroupIdentifier *)bdMemory::allocate((unsigned __int64)m_capacity << 6);
  bdArray<bdClansGroupIdentifier>::copyConstructArrayArray(this, v5, a->m_data, a->m_size);
  return v5;
}

/*
==============
bdArray<bdClansUserMembershipProposal>::operator=
==============
*/
void bdArray<bdClansUserMembershipProposal>::operator=(bdArray<bdClansUserMembershipProposal> *this, const bdArray<bdClansUserMembershipProposal> *a)
{
  unsigned int m_size; 
  __int64 v5; 
  unsigned int v6; 
  bdClansUserMembershipProposal *v7; 
  unsigned int v8; 
  __int64 v9; 
  unsigned int m_capacity; 
  unsigned int v11; 

  if ( this != a )
  {
    m_size = this->m_size;
    v5 = a->m_size;
    if ( (unsigned int)v5 <= this->m_capacity )
    {
      v7 = NULL;
      if ( (unsigned int)v5 <= m_size )
      {
        v8 = 0;
        if ( (_DWORD)v5 )
        {
          v9 = 0i64;
          do
          {
            bdHandleAssert(v8 < a->m_size, "rangeCheck(i)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdarray.inl", "bdArray<class bdClansUserMembershipProposal>::operator []", 0x70u, "bdArray<T>::operator[], rangecheck failed");
            bdClansUserMembershipProposal::operator=(&this->m_data[v9], &a->m_data[v9]);
            ++v8;
            ++v9;
          }
          while ( v8 < (unsigned int)v5 );
          m_size = this->m_size;
        }
        bdArray<bdClansUserMembershipProposal>::destruct(this, &this->m_data[v5], m_size - v5);
        m_capacity = this->m_capacity;
        this->m_size = v5;
        if ( m_capacity > 4 * (int)v5 )
        {
          v11 = m_capacity - (m_capacity >> 1);
          this->m_capacity = v11;
          if ( v11 )
          {
            v7 = (bdClansUserMembershipProposal *)bdMemory::allocate(1224i64 * v11);
            bdArray<bdClansUserMembershipProposal>::copyConstructArrayArray(this, v7, this->m_data, this->m_size);
            LODWORD(v5) = this->m_size;
          }
          bdArray<bdClansUserMembershipProposal>::destruct(this, this->m_data, v5);
          bdMemory::deallocate(this->m_data);
          this->m_data = v7;
        }
      }
      else
      {
        if ( m_size )
        {
          do
          {
            bdHandleAssert((unsigned int)v7 < a->m_size, "rangeCheck(i)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdarray.inl", "bdArray<class bdClansUserMembershipProposal>::operator []", 0x70u, "bdArray<T>::operator[], rangecheck failed");
            bdClansUserMembershipProposal::operator=(&this->m_data[(unsigned int)v7], &a->m_data[(unsigned int)v7]);
            m_size = this->m_size;
            LODWORD(v7) = (_DWORD)v7 + 1;
          }
          while ( (unsigned int)v7 < m_size );
        }
        bdArray<bdClansUserMembershipProposal>::copyConstructArrayArray(this, &this->m_data[m_size], &a->m_data[m_size], v5 - m_size);
        this->m_size = v5;
      }
    }
    else
    {
      bdArray<bdClansUserMembershipProposal>::destruct(this, this->m_data, m_size);
      bdMemory::deallocate(this->m_data);
      this->m_data = NULL;
      *(_QWORD *)&this->m_capacity = 0i64;
      this->m_data = bdArray<bdClansUserMembershipProposal>::uninitializedCopy(this, a);
      v6 = a->m_capacity;
      this->m_size = v5;
      this->m_capacity = v6;
    }
  }
}

/*
==============
bdArray<bdClansUserMembershipProposal>::uninitializedCopy
==============
*/
bdClansUserMembershipProposal *bdArray<bdClansUserMembershipProposal>::uninitializedCopy(bdArray<bdClansUserMembershipProposal> *this, const bdArray<bdClansUserMembershipProposal> *a)
{
  __int64 m_capacity; 
  bdClansUserMembershipProposal *v5; 

  m_capacity = a->m_capacity;
  if ( !(_DWORD)m_capacity )
    return 0i64;
  v5 = (bdClansUserMembershipProposal *)bdMemory::allocate(1224 * m_capacity);
  bdArray<bdClansUserMembershipProposal>::copyConstructArrayArray(this, v5, a->m_data, a->m_size);
  return v5;
}

/*
==============
bdArray<bdClansRemovedMembershipProposal>::operator=
==============
*/
void bdArray<bdClansRemovedMembershipProposal>::operator=(bdArray<bdClansRemovedMembershipProposal> *this, const bdArray<bdClansRemovedMembershipProposal> *a)
{
  unsigned int m_size; 
  __int64 v5; 
  unsigned int v6; 
  bdClansRemovedMembershipProposal *v7; 
  unsigned int v8; 
  __int64 v9; 
  unsigned int m_capacity; 
  unsigned int v11; 

  if ( this != a )
  {
    m_size = this->m_size;
    v5 = a->m_size;
    if ( (unsigned int)v5 <= this->m_capacity )
    {
      v7 = NULL;
      if ( (unsigned int)v5 <= m_size )
      {
        v8 = 0;
        if ( (_DWORD)v5 )
        {
          v9 = 0i64;
          do
          {
            bdHandleAssert(v8 < a->m_size, "rangeCheck(i)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdarray.inl", "bdArray<class bdClansRemovedMembershipProposal>::operator []", 0x70u, "bdArray<T>::operator[], rangecheck failed");
            bdClansRemovedMembershipProposal::operator=(&this->m_data[v9], &a->m_data[v9]);
            ++v8;
            ++v9;
          }
          while ( v8 < (unsigned int)v5 );
          m_size = this->m_size;
        }
        bdArray<bdClansRemovedMembershipProposal>::destruct(this, &this->m_data[v5], m_size - v5);
        m_capacity = this->m_capacity;
        this->m_size = v5;
        if ( m_capacity > 4 * (int)v5 )
        {
          v11 = m_capacity - (m_capacity >> 1);
          this->m_capacity = v11;
          if ( v11 )
          {
            v7 = (bdClansRemovedMembershipProposal *)bdMemory::allocate(272i64 * v11);
            bdArray<bdClansRemovedMembershipProposal>::copyConstructArrayArray(this, v7, this->m_data, this->m_size);
            LODWORD(v5) = this->m_size;
          }
          bdArray<bdClansRemovedMembershipProposal>::destruct(this, this->m_data, v5);
          bdMemory::deallocate(this->m_data);
          this->m_data = v7;
        }
      }
      else
      {
        if ( m_size )
        {
          do
          {
            bdHandleAssert((unsigned int)v7 < a->m_size, "rangeCheck(i)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdarray.inl", "bdArray<class bdClansRemovedMembershipProposal>::operator []", 0x70u, "bdArray<T>::operator[], rangecheck failed");
            bdClansRemovedMembershipProposal::operator=(&this->m_data[(unsigned int)v7], &a->m_data[(unsigned int)v7]);
            m_size = this->m_size;
            LODWORD(v7) = (_DWORD)v7 + 1;
          }
          while ( (unsigned int)v7 < m_size );
        }
        bdArray<bdClansRemovedMembershipProposal>::copyConstructArrayArray(this, &this->m_data[m_size], &a->m_data[m_size], v5 - m_size);
        this->m_size = v5;
      }
    }
    else
    {
      bdArray<bdClansRemovedMembershipProposal>::destruct(this, this->m_data, m_size);
      bdMemory::deallocate(this->m_data);
      this->m_data = NULL;
      *(_QWORD *)&this->m_capacity = 0i64;
      this->m_data = bdArray<bdClansRemovedMembershipProposal>::uninitializedCopy(this, a);
      v6 = a->m_capacity;
      this->m_size = v5;
      this->m_capacity = v6;
    }
  }
}

/*
==============
bdArray<bdClansRemovedMembershipProposal>::uninitializedCopy
==============
*/
bdClansRemovedMembershipProposal *bdArray<bdClansRemovedMembershipProposal>::uninitializedCopy(bdArray<bdClansRemovedMembershipProposal> *this, const bdArray<bdClansRemovedMembershipProposal> *a)
{
  __int64 m_capacity; 
  bdClansRemovedMembershipProposal *v5; 

  m_capacity = a->m_capacity;
  if ( !(_DWORD)m_capacity )
    return 0i64;
  v5 = (bdClansRemovedMembershipProposal *)bdMemory::allocate(272 * m_capacity);
  bdArray<bdClansRemovedMembershipProposal>::copyConstructArrayArray(this, v5, a->m_data, a->m_size);
  return v5;
}

/*
==============
bdArray<bdStructUserAccountID>::destruct
==============
*/
void bdArray<bdStructUserAccountID>::destruct(bdArray<bdStructUserAccountID> *this, bdStructUserAccountID *src, const unsigned int n)
{
  __int64 v4; 
  __int64 v5; 
  __int64 v6; 
  __int64 v7; 

  if ( n )
  {
    v4 = 0i64;
    v5 = 0i64;
    v6 = n;
    do
    {
      v7 = *(int *)(*((_QWORD *)&src[v4].__vftable + 1) + 4i64);
      (**(void (__fastcall ***)(char *, _QWORD))((char *)&src->__vftable + v7 + v4 * 88 + 8))((char *)&src->__vftable + v7 + v5 + 8, 0i64);
      v5 += 88i64;
      ++v4;
      --v6;
    }
    while ( v6 );
  }
}

/*
==============
bdArray<bdObjectStoreTag>::~bdArray<bdObjectStoreTag>
==============
*/
void bdArray<bdObjectStoreTag>::~bdArray<bdObjectStoreTag>(bdArray<bdObjectStoreTag> *this)
{
  bdMemory::deallocate(this->m_data);
  this->m_data = NULL;
  *(_QWORD *)&this->m_capacity = 0i64;
}

/*
==============
bdArray<bdObjectStoreTag>::increaseCapacity
==============
*/
void bdArray<bdObjectStoreTag>::increaseCapacity(bdArray<bdObjectStoreTag> *this, const unsigned int increase)
{
  unsigned int m_capacity; 
  unsigned int v4; 
  bdObjectStoreTag *v5; 
  unsigned int v6; 
  unsigned int m_size; 
  __int64 v10; 

  m_capacity = this->m_capacity;
  v4 = m_capacity;
  if ( increase > m_capacity )
    v4 = increase;
  v5 = NULL;
  v6 = m_capacity + v4;
  if ( v6 )
  {
    v5 = (bdObjectStoreTag *)bdMemory::allocate(66i64 * v6);
    m_size = this->m_size;
    if ( m_size )
    {
      _RCX = v5;
      _R8 = (char *)this->m_data - (char *)v5;
      v10 = m_size;
      do
      {
        if ( _RCX )
        {
          __asm
          {
            vmovups ymm0, ymmword ptr [r8+rcx]
            vmovups ymmword ptr [rcx], ymm0
            vmovups ymm1, ymmword ptr [r8+rcx+20h]
            vmovups ymmword ptr [rcx+20h], ymm1
          }
          *(_WORD *)&_RCX->m_value[31] = *(_WORD *)&_RCX->m_value[_R8 + 31];
        }
        ++_RCX;
        --v10;
      }
      while ( v10 );
    }
  }
  bdMemory::deallocate(this->m_data);
  this->m_capacity = v6;
  this->m_data = v5;
}

/*
==============
bdArray<bdObjectStoreCacheAwareObjectID>::operator=
==============
*/
void bdArray<bdObjectStoreCacheAwareObjectID>::operator=(bdArray<bdObjectStoreCacheAwareObjectID> *this, const bdArray<bdObjectStoreCacheAwareObjectID> *a)
{
  __int64 m_size; 
  __int64 v5; 
  bdObjectStoreCacheAwareObjectID *v6; 
  unsigned int v7; 
  bdObjectStoreCacheAwareObjectID *v8; 
  __int64 v10; 
  __int64 v18; 
  __int64 v27; 
  unsigned int v28; 
  __int64 v29; 
  __int64 v38; 
  __int64 v47; 
  bdObjectStoreCacheAwareObjectID *v48; 
  unsigned int v49; 
  __int64 v50; 
  unsigned int m_capacity; 
  unsigned int v52; 
  bdObjectStoreCacheAwareObjectID *m_data; 
  char v54[176]; 
  __int64 v55; 

  if ( this != a )
  {
    m_size = a->m_size;
    if ( (unsigned int)m_size <= this->m_capacity )
    {
      v7 = this->m_size;
      v8 = NULL;
      if ( (unsigned int)m_size <= v7 )
      {
        v28 = 0;
        if ( (_DWORD)m_size )
        {
          v29 = 0i64;
          do
          {
            bdHandleAssert(v28 < a->m_size, "rangeCheck(i)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdarray.inl", "bdArray<class bdObjectStoreCacheAwareObjectID>::operator []", 0x70u, "bdArray<T>::operator[], rangecheck failed");
            _RCX = v54;
            _RAX = &a->m_data[v29];
            ++v28;
            __asm
            {
              vmovups ymm0, ymmword ptr [rax]
              vmovups ymmword ptr [rcx], ymm0
              vmovups ymm0, ymmword ptr [rax+20h]
              vmovups ymmword ptr [rcx+20h], ymm0
              vmovups ymm0, ymmword ptr [rax+40h]
              vmovups ymmword ptr [rcx+40h], ymm0
              vmovups ymm0, ymmword ptr [rax+60h]
              vmovups ymmword ptr [rcx+60h], ymm0
              vmovups ymm0, ymmword ptr [rax+80h]
              vmovups ymmword ptr [rcx+80h], ymm0
              vmovups xmm0, xmmword ptr [rax+0A0h]
            }
            v38 = *(_QWORD *)&_RAX->m_cachedChecksum[31];
            __asm { vmovups xmmword ptr [rcx+0A0h], xmm0 }
            v55 = v38;
            _RAX = v54;
            __asm { vmovups ymm0, ymmword ptr [rax] }
            _RCX = &this->m_data[v29++];
            __asm
            {
              vmovups ymmword ptr [rcx], ymm0
              vmovups ymm0, ymmword ptr [rax+20h]
              vmovups ymmword ptr [rcx+20h], ymm0
              vmovups ymm0, ymmword ptr [rax+40h]
              vmovups ymmword ptr [rcx+40h], ymm0
              vmovups ymm0, ymmword ptr [rax+60h]
              vmovups ymmword ptr [rcx+60h], ymm0
              vmovups ymm0, ymmword ptr [rax+80h]
              vmovups ymmword ptr [rcx+80h], ymm0
              vmovups xmm0, xmmword ptr [rax+0A0h]
            }
            v47 = v55;
            __asm { vmovups xmmword ptr [rcx+0A0h], xmm0 }
            *(_QWORD *)&_RCX->m_cachedChecksum[31] = v47;
          }
          while ( v28 < (unsigned int)m_size );
          v7 = this->m_size;
        }
        v48 = &this->m_data[m_size];
        v49 = v7 - m_size;
        if ( v49 )
        {
          v50 = v49;
          do
          {
            bdObjectStoreCacheAwareObjectID::~bdObjectStoreCacheAwareObjectID(v48++);
            --v50;
          }
          while ( v50 );
        }
        m_capacity = this->m_capacity;
        this->m_size = m_size;
        if ( m_capacity > 4 * (int)m_size )
        {
          v52 = m_capacity - (m_capacity >> 1);
          this->m_capacity = v52;
          if ( v52 )
          {
            v8 = (bdObjectStoreCacheAwareObjectID *)bdMemory::allocate(184i64 * v52);
            bdArray<bdObjectStoreCacheAwareObjectID>::copyConstructArrayArray(this, v8, this->m_data, this->m_size);
            m_size = this->m_size;
          }
          m_data = this->m_data;
          if ( (_DWORD)m_size )
          {
            do
            {
              bdObjectStoreCacheAwareObjectID::~bdObjectStoreCacheAwareObjectID(m_data++);
              --m_size;
            }
            while ( m_size );
            m_data = this->m_data;
          }
          bdMemory::deallocate(m_data);
          this->m_data = v8;
        }
      }
      else
      {
        if ( v7 )
        {
          do
          {
            bdHandleAssert((unsigned int)v8 < a->m_size, "rangeCheck(i)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdarray.inl", "bdArray<class bdObjectStoreCacheAwareObjectID>::operator []", 0x70u, "bdArray<T>::operator[], rangecheck failed");
            _RCX = v54;
            v10 = (unsigned int)v8;
            LODWORD(v8) = (_DWORD)v8 + 1;
            _RAX = &a->m_data[v10];
            __asm
            {
              vmovups ymm0, ymmword ptr [rax]
              vmovups ymmword ptr [rcx], ymm0
              vmovups ymm0, ymmword ptr [rax+20h]
              vmovups ymmword ptr [rcx+20h], ymm0
              vmovups ymm0, ymmword ptr [rax+40h]
              vmovups ymmword ptr [rcx+40h], ymm0
              vmovups ymm0, ymmword ptr [rax+60h]
              vmovups ymmword ptr [rcx+60h], ymm0
              vmovups ymm0, ymmword ptr [rax+80h]
              vmovups ymmword ptr [rcx+80h], ymm0
              vmovups xmm0, xmmword ptr [rax+0A0h]
            }
            v18 = *(_QWORD *)&_RAX->m_cachedChecksum[31];
            __asm { vmovups xmmword ptr [rcx+0A0h], xmm0 }
            v55 = v18;
            _RAX = v54;
            __asm { vmovups ymm0, ymmword ptr [rax] }
            _RCX = &this->m_data[v10];
            __asm
            {
              vmovups ymmword ptr [rcx], ymm0
              vmovups ymm0, ymmword ptr [rax+20h]
              vmovups ymmword ptr [rcx+20h], ymm0
              vmovups ymm0, ymmword ptr [rax+40h]
              vmovups ymmword ptr [rcx+40h], ymm0
              vmovups ymm0, ymmword ptr [rax+60h]
              vmovups ymmword ptr [rcx+60h], ymm0
              vmovups ymm0, ymmword ptr [rax+80h]
              vmovups ymmword ptr [rcx+80h], ymm0
              vmovups xmm0, xmmword ptr [rax+0A0h]
            }
            v27 = v55;
            __asm { vmovups xmmword ptr [rcx+0A0h], xmm0 }
            *(_QWORD *)&_RCX->m_cachedChecksum[31] = v27;
            v7 = this->m_size;
          }
          while ( (unsigned int)v8 < v7 );
        }
        bdArray<bdObjectStoreCacheAwareObjectID>::copyConstructArrayArray(this, &this->m_data[v7], &a->m_data[v7], m_size - v7);
        this->m_size = m_size;
      }
    }
    else
    {
      bdArray<bdObjectStoreCacheAwareObjectID>::clear(this);
      v5 = a->m_capacity;
      v6 = NULL;
      if ( (_DWORD)v5 )
      {
        v6 = (bdObjectStoreCacheAwareObjectID *)bdMemory::allocate(184 * v5);
        bdArray<bdObjectStoreCacheAwareObjectID>::copyConstructArrayArray(this, v6, a->m_data, a->m_size);
      }
      this->m_data = v6;
      this->m_capacity = a->m_capacity;
      this->m_size = m_size;
    }
  }
}

/*
==============
bdArray<bdObjectStoreCacheAwareObjectID>::clear
==============
*/
void bdArray<bdObjectStoreCacheAwareObjectID>::clear(bdArray<bdObjectStoreCacheAwareObjectID> *this)
{
  unsigned int m_size; 
  bdObjectStoreCacheAwareObjectID *m_data; 
  __int64 v4; 

  m_size = this->m_size;
  m_data = this->m_data;
  if ( m_size )
  {
    v4 = m_size;
    do
    {
      bdObjectStoreCacheAwareObjectID::~bdObjectStoreCacheAwareObjectID(m_data++);
      --v4;
    }
    while ( v4 );
    m_data = this->m_data;
  }
  bdMemory::deallocate(m_data);
  this->m_data = NULL;
  *(_QWORD *)&this->m_capacity = 0i64;
}

/*
==============
bdArray<bdObjectStoreCacheAwareObjectID>::copyConstructArrayArray
==============
*/
void bdArray<bdObjectStoreCacheAwareObjectID>::copyConstructArrayArray(bdArray<bdObjectStoreCacheAwareObjectID> *this, bdObjectStoreCacheAwareObjectID *dest, const bdObjectStoreCacheAwareObjectID *src, __int64 n)
{
  if ( (_DWORD)n )
  {
    _R8 = (char *)src - (char *)dest;
    n = (unsigned int)n;
    do
    {
      if ( dest )
      {
        __asm
        {
          vmovups xmm0, xmmword ptr [r8+rdx]
          vmovups xmmword ptr [rdx], xmm0
          vmovups xmm1, xmmword ptr [r8+rdx+10h]
          vmovups xmmword ptr [rdx+10h], xmm1
          vmovups xmm0, xmmword ptr [r8+rdx+20h]
          vmovups xmmword ptr [rdx+20h], xmm0
          vmovups xmm1, xmmword ptr [r8+rdx+30h]
          vmovups xmmword ptr [rdx+30h], xmm1
          vmovups xmm0, xmmword ptr [r8+rdx+40h]
          vmovups xmmword ptr [rdx+40h], xmm0
          vmovups xmm1, xmmword ptr [r8+rdx+50h]
        }
        _RAX = (char *)dest + _R8;
        __asm
        {
          vmovups xmmword ptr [rdx+50h], xmm1
          vmovups xmm0, xmmword ptr [rax+60h]
          vmovups xmmword ptr [rdx+60h], xmm0
          vmovups xmm1, xmmword ptr [rax+70h]
          vmovups xmmword ptr [rdx+70h], xmm1
          vmovups xmm0, xmmword ptr [rax+80h]
          vmovups xmmword ptr [rdx+80h], xmm0
          vmovups xmm1, xmmword ptr [rax+90h]
          vmovups xmmword ptr [rdx+90h], xmm1
          vmovups xmm0, xmmword ptr [rax+0A0h]
          vmovups xmmword ptr [rdx+0A0h], xmm0
        }
        *(_QWORD *)&dest->m_cachedChecksum[31] = *(_QWORD *)&dest->m_cachedChecksum[_R8 + 31];
      }
      ++dest;
      --n;
    }
    while ( n );
  }
}

/*
==============
bdArray<bdObjectStoreObject>::~bdArray<bdObjectStoreObject>
==============
*/
void bdArray<bdObjectStoreObject>::~bdArray<bdObjectStoreObject>(bdArray<bdObjectStoreObject> *this)
{
  bdArray<bdObjectStoreObject>::clear(this);
}

/*
==============
bdArray<bdObjectStoreObject>::operator=
==============
*/
void bdArray<bdObjectStoreObject>::operator=(bdArray<bdObjectStoreObject> *this, const bdArray<bdObjectStoreObject> *a)
{
  __int64 m_size; 
  __int64 v5; 
  bdObjectStoreObject *v6; 
  unsigned int v7; 
  unsigned int v8; 
  bdObjectStoreObject *v9; 
  __int64 v10; 
  bdObjectStoreObject *v11; 
  bdObjectStoreObject *v12; 
  unsigned int v13; 
  const bdObjectStoreMetadata *v14; 
  bdObjectStoreMetadata *v15; 
  unsigned int m_capacity; 
  unsigned int v17; 

  if ( this != a )
  {
    m_size = a->m_size;
    if ( (unsigned int)m_size <= this->m_capacity )
    {
      v8 = this->m_size;
      v9 = NULL;
      if ( (unsigned int)m_size <= v8 )
      {
        v13 = 0;
        if ( (_DWORD)m_size )
        {
          do
          {
            bdHandleAssert(v13 < a->m_size, "rangeCheck(i)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdarray.inl", "bdArray<class bdObjectStoreObject>::operator []", 0x70u, "bdArray<T>::operator[], rangecheck failed");
            v14 = (bdObjectStoreMetadata *)((char *)&v9->m_metadata + (unsigned __int64)a->m_data);
            v15 = (bdObjectStoreMetadata *)((char *)&v9->m_metadata + (unsigned __int64)this->m_data);
            bdObjectStoreMetadata::operator=(v15, v14);
            ++v13;
            *(_QWORD *)v15[1].m_context = *(_QWORD *)v14[1].m_context;
            ++v9;
            *(_QWORD *)&v15[1].m_context[8] = *(_QWORD *)&v14[1].m_context[8];
            *(_QWORD *)&v15[1].m_objectID.m_ownerType = *(_QWORD *)&v14[1].m_objectID.m_ownerType;
          }
          while ( v13 < (unsigned int)m_size );
          v8 = this->m_size;
          v9 = NULL;
        }
        bdArray<bdObjectStoreObject>::destruct(this, &this->m_data[m_size], v8 - m_size);
        m_capacity = this->m_capacity;
        this->m_size = m_size;
        if ( m_capacity > 4 * (int)m_size )
        {
          v17 = m_capacity - (m_capacity >> 1);
          this->m_capacity = v17;
          if ( v17 )
          {
            v9 = (bdObjectStoreObject *)bdMemory::allocate(3512i64 * v17);
            bdArray<bdObjectStoreObject>::copyConstructArrayArray(this, v9, this->m_data, this->m_size);
            LODWORD(m_size) = this->m_size;
          }
          bdArray<bdObjectStoreObject>::destruct(this, this->m_data, m_size);
          bdMemory::deallocate(this->m_data);
          this->m_data = v9;
        }
      }
      else
      {
        if ( v8 )
        {
          do
          {
            bdHandleAssert((unsigned int)v9 < a->m_size, "rangeCheck(i)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdarray.inl", "bdArray<class bdObjectStoreObject>::operator []", 0x70u, "bdArray<T>::operator[], rangecheck failed");
            v10 = (unsigned int)v9;
            v11 = &a->m_data[v10];
            v12 = &this->m_data[v10];
            bdObjectStoreMetadata::operator=(&v12->m_metadata, &v11->m_metadata);
            LODWORD(v9) = (_DWORD)v9 + 1;
            v12->m_contentPtr = v11->m_contentPtr;
            v12->m_contentSize = v11->m_contentSize;
            v12->m_downloadInterceptor = v11->m_downloadInterceptor;
            v8 = this->m_size;
          }
          while ( (unsigned int)v9 < v8 );
        }
        bdArray<bdObjectStoreObject>::copyConstructArrayArray(this, &this->m_data[v8], &a->m_data[v8], m_size - v8);
        this->m_size = m_size;
      }
    }
    else
    {
      bdArray<bdObjectStoreObject>::clear(this);
      v5 = a->m_capacity;
      v6 = NULL;
      if ( (_DWORD)v5 )
      {
        v6 = (bdObjectStoreObject *)bdMemory::allocate(3512 * v5);
        bdArray<bdObjectStoreObject>::copyConstructArrayArray(this, v6, a->m_data, a->m_size);
      }
      this->m_data = v6;
      v7 = a->m_capacity;
      this->m_size = m_size;
      this->m_capacity = v7;
    }
  }
}

/*
==============
bdArray<bdObjectStoreObject>::clear
==============
*/
void bdArray<bdObjectStoreObject>::clear(bdArray<bdObjectStoreObject> *this)
{
  unsigned int m_size; 
  bdObjectStoreObject *m_data; 
  bdArray<bdObjectStoreTag> *p_m_tags; 
  __int64 v5; 

  m_size = this->m_size;
  m_data = this->m_data;
  if ( m_size )
  {
    p_m_tags = &m_data->m_metadata.m_tags;
    v5 = m_size;
    do
    {
      bdMemory::deallocate(p_m_tags->m_data);
      p_m_tags->m_data = NULL;
      *(_QWORD *)&p_m_tags->m_capacity = 0i64;
      bdObjectStoreACL::~bdObjectStoreACL((bdObjectStoreACL *)&p_m_tags[-201]);
      p_m_tags = (bdArray<bdObjectStoreTag> *)((char *)p_m_tags + 3512);
      --v5;
    }
    while ( v5 );
    m_data = this->m_data;
  }
  bdMemory::deallocate(m_data);
  this->m_data = NULL;
  *(_QWORD *)&this->m_capacity = 0i64;
}

/*
==============
bdArray<bdObjectStoreObject>::copyConstructArrayArray
==============
*/
void bdArray<bdObjectStoreObject>::copyConstructArrayArray(bdArray<bdObjectStoreObject> *this, bdObjectStoreObject *dest, const bdObjectStoreObject *src, const unsigned int n)
{
  __int64 v6; 
  __int64 v17; 

  if ( n )
  {
    _RDI = &dest->m_metadata.m_tags.m_capacity;
    _RSI = (char *)src - (char *)dest;
    v6 = n;
    do
    {
      _RAX = _RDI - 860;
      if ( _RDI != (unsigned int *)3440 )
      {
        __asm
        {
          vmovups xmm0, xmmword ptr [rsi+rdi-0D70h]
          vmovups xmmword ptr [rax], xmm0
          vmovups ymm0, ymmword ptr [rsi+rdi-0D60h]
          vmovups ymmword ptr [rdi-0D60h], ymm0
          vmovups ymm1, ymmword ptr [rsi+rdi-0D40h]
          vmovups ymmword ptr [rdi-0D40h], ymm1
          vmovups ymm0, ymmword ptr [rsi+rdi-0D20h]
          vmovups ymmword ptr [rdi-0D20h], ymm0
          vmovups xmm1, xmmword ptr [rsi+rdi-0D00h]
          vmovups xmmword ptr [rdi-0D00h], xmm1
          vmovups ymm0, ymmword ptr [rsi+rdi-0CF0h]
          vmovups ymmword ptr [rdi-0CF0h], ymm0
        }
        *((_BYTE *)_RDI - 3280) = *((_BYTE *)_RDI + _RSI - 3280);
        __asm
        {
          vmovups ymm0, ymmword ptr [rsi+rdi-0CCFh]
          vmovups ymmword ptr [rdi-0CCFh], ymm0
        }
        *((_BYTE *)_RDI - 3247) = *((_BYTE *)_RDI + _RSI - 3247);
        *((_QWORD *)_RDI - 405) = *(_QWORD *)((char *)_RDI + _RSI - 3240);
        *((_QWORD *)_RDI - 404) = *(_QWORD *)((char *)_RDI + _RSI - 3232);
        *(_RDI - 806) = *(unsigned int *)((char *)_RDI + _RSI - 3224);
        *((_QWORD *)_RDI - 402) = *(_QWORD *)((char *)_RDI + _RSI - 3216);
        *((_QWORD *)_RDI - 401) = *(_QWORD *)((char *)_RDI + _RSI - 3208);
        _RCX = _RDI - 800;
        _RAX = (__int64)_RDI + _RSI - 3200;
        v17 = 8i64;
        do
        {
          __asm
          {
            vmovups xmm0, xmmword ptr [rax]
            vmovups xmmword ptr [rcx], xmm0
            vmovups xmm1, xmmword ptr [rax+10h]
            vmovups xmmword ptr [rcx+10h], xmm1
            vmovups xmm0, xmmword ptr [rax+20h]
            vmovups xmmword ptr [rcx+20h], xmm0
            vmovups xmm1, xmmword ptr [rax+30h]
            vmovups xmmword ptr [rcx+30h], xmm1
            vmovups xmm0, xmmword ptr [rax+40h]
            vmovups xmmword ptr [rcx+40h], xmm0
            vmovups xmm1, xmmword ptr [rax+50h]
            vmovups xmmword ptr [rcx+50h], xmm1
            vmovups xmm0, xmmword ptr [rax+60h]
            vmovups xmmword ptr [rcx+60h], xmm0
          }
          _RCX += 32;
          __asm
          {
            vmovups xmm1, xmmword ptr [rax+70h]
            vmovups xmmword ptr [rcx-10h], xmm1
          }
          _RAX += 128i64;
          --v17;
        }
        while ( v17 );
        __asm
        {
          vmovups ymm0, ymmword ptr [rsi+rdi-880h]
          vmovups ymmword ptr [rdi-880h], ymm0
          vmovups ymm1, ymmword ptr [rsi+rdi-860h]
          vmovups ymmword ptr [rdi-860h], ymm1
        }
        *((_BYTE *)_RDI - 2112) = *((_BYTE *)_RDI + _RSI - 2112);
        memcpy_0((char *)_RDI - 2111, (char *)_RDI + _RSI - 2111, 0x800ui64);
        *(_RDI - 15) = *(unsigned int *)((char *)_RDI + _RSI - 60);
        *((_QWORD *)_RDI - 7) = *(_QWORD *)((char *)_RDI + _RSI - 56);
        __asm
        {
          vmovups ymm0, ymmword ptr [rsi+rdi-30h]
          vmovups ymmword ptr [rdi-30h], ymm0
        }
        *((_BYTE *)_RDI - 16) = *((_BYTE *)_RDI + _RSI - 16);
        *((_BYTE *)_RDI - 15) = *((_BYTE *)_RDI + _RSI - 15);
        *_RDI = *(unsigned int *)((char *)_RDI + _RSI);
        _RDI[1] = *(unsigned int *)((char *)_RDI + _RSI + 4);
        *((_QWORD *)_RDI - 1) = bdArray<bdObjectStoreTag>::uninitializedCopy((bdArray<bdObjectStoreTag> *)(_RDI - 2), (const bdArray<bdObjectStoreTag> *)((char *)_RDI + _RSI - 8));
        _RDI[2] = *(unsigned int *)((char *)_RDI + _RSI + 8);
        __asm
        {
          vmovups ymm0, ymmword ptr [rsi+rdi+0Ch]
          vmovups ymmword ptr [rdi+0Ch], ymm0
        }
        *((_QWORD *)_RDI + 6) = *(_QWORD *)((char *)_RDI + _RSI + 48);
        *((_QWORD *)_RDI + 7) = *(_QWORD *)((char *)_RDI + _RSI + 56);
        *((_QWORD *)_RDI + 8) = *(_QWORD *)((char *)_RDI + _RSI + 64);
      }
      _RDI += 878;
      --v6;
    }
    while ( v6 );
  }
}

/*
==============
bdArray<bdObjectStoreObject>::destruct
==============
*/
void bdArray<bdObjectStoreObject>::destruct(bdArray<bdObjectStoreObject> *this, bdObjectStoreObject *src, const unsigned int n)
{
  bdArray<bdObjectStoreTag> *p_m_tags; 
  __int64 v4; 

  if ( n )
  {
    p_m_tags = &src->m_metadata.m_tags;
    v4 = n;
    do
    {
      bdMemory::deallocate(p_m_tags->m_data);
      p_m_tags->m_data = NULL;
      *(_QWORD *)&p_m_tags->m_capacity = 0i64;
      bdObjectStoreACL::~bdObjectStoreACL((bdObjectStoreACL *)&p_m_tags[-201]);
      p_m_tags = (bdArray<bdObjectStoreTag> *)((char *)p_m_tags + 3512);
      --v4;
    }
    while ( v4 );
  }
}

/*
==============
bdArray<bdObjectStoreObject>::increaseCapacity
==============
*/
void bdArray<bdObjectStoreObject>::increaseCapacity(bdArray<bdObjectStoreObject> *this, const unsigned int increase)
{
  unsigned int m_capacity; 
  unsigned int v4; 
  bdObjectStoreObject *v5; 
  unsigned int v6; 
  unsigned int m_size; 
  bdObjectStoreObject *m_data; 
  bdArray<bdObjectStoreTag> *p_m_tags; 
  __int64 v10; 

  m_capacity = this->m_capacity;
  v4 = m_capacity;
  if ( increase > m_capacity )
    v4 = increase;
  v5 = NULL;
  v6 = m_capacity + v4;
  if ( v6 )
  {
    v5 = (bdObjectStoreObject *)bdMemory::allocate(3512i64 * v6);
    bdArray<bdObjectStoreObject>::copyConstructArrayArray(this, v5, this->m_data, this->m_size);
  }
  m_size = this->m_size;
  m_data = this->m_data;
  if ( m_size )
  {
    p_m_tags = &m_data->m_metadata.m_tags;
    v10 = m_size;
    do
    {
      bdMemory::deallocate(p_m_tags->m_data);
      p_m_tags->m_data = NULL;
      *(_QWORD *)&p_m_tags->m_capacity = 0i64;
      bdObjectStoreACL::~bdObjectStoreACL((bdObjectStoreACL *)&p_m_tags[-201]);
      p_m_tags = (bdArray<bdObjectStoreTag> *)((char *)p_m_tags + 3512);
      --v10;
    }
    while ( v10 );
    m_data = this->m_data;
  }
  bdMemory::deallocate(m_data);
  this->m_data = v5;
  this->m_capacity = v6;
}

/*
==============
bdArray<bdRESTInternalResponse>::~bdArray<bdRESTInternalResponse>
==============
*/
void bdArray<bdRESTInternalResponse>::~bdArray<bdRESTInternalResponse>(bdArray<bdRESTInternalResponse> *this)
{
  unsigned int m_size; 
  bdRESTInternalResponse *m_data; 
  __int64 v4; 

  m_size = this->m_size;
  m_data = this->m_data;
  if ( m_size )
  {
    v4 = m_size;
    do
    {
      bdRESTInternalResponse::`vbase destructor(m_data++);
      --v4;
    }
    while ( v4 );
    m_data = this->m_data;
  }
  bdMemory::deallocate(m_data);
  this->m_data = NULL;
  *(_QWORD *)&this->m_capacity = 0i64;
}

/*
==============
bdArray<bdRESTInternalResponse>::copyConstructArrayArray
==============
*/
void bdArray<bdRESTInternalResponse>::copyConstructArrayArray(bdArray<bdRESTInternalResponse> *this, bdRESTInternalResponse *dest, const bdRESTInternalResponse *src, const unsigned int n)
{
  bdRESTInternalResponse_vtbl **v4; 
  signed __int64 v5; 
  signed __int64 v6; 
  __int64 v7; 
  __int64 v8; 
  __int64 v9; 
  __int64 v10; 
  int v11; 

  if ( n )
  {
    v11 = 0;
    v4 = &dest->__vftable + 1;
    v5 = (char *)dest - (char *)src;
    v6 = (char *)src - (char *)dest;
    v7 = n;
    do
    {
      if ( v4 != (bdRESTInternalResponse_vtbl **)8 )
      {
        *v4 = (bdRESTInternalResponse_vtbl *)&bdRESTInternalResponse::`vbtable';
        bdReferencable::bdReferencable((bdReferencable *)((char *)v4 + v6 + v5 + 88), (const bdReferencable *)((char *)v4 + v6 + SHIDWORD((*(bdRESTInternalResponse_vtbl **)((char *)v4 + v6))->deserialize)));
        v11 |= 1u;
        bdTaskResult::bdTaskResult((bdTaskResult *)(v4 - 1), (const bdTaskResult *)((char *)v4 + v6 - 8));
        *(v4 - 1) = (bdRESTInternalResponse_vtbl *)&bdRESTInternalResponse::`vftable'{for `bdTaskResult'};
        *(bdRESTInternalResponse_vtbl **)((char *)v4 + SHIDWORD((*v4)->deserialize)) = (bdRESTInternalResponse_vtbl *)&bdRESTInternalResponse::`vftable'{for `bdReferencable'};
        v4[1] = *(bdRESTInternalResponse_vtbl **)((char *)v4 + v6 + 8);
        v4[2] = *(bdRESTInternalResponse_vtbl **)((char *)v4 + v6 + 16);
        v8 = *(__int64 *)((char *)v4 + v6 + 24);
        v4[3] = (bdRESTInternalResponse_vtbl *)v8;
        if ( v8 )
          _InterlockedExchangeAdd((volatile signed __int32 *)(v8 + 8), 1u);
        v9 = *(__int64 *)((char *)v4 + v6 + 32);
        v4[4] = (bdRESTInternalResponse_vtbl *)v9;
        if ( v9 )
          _InterlockedExchangeAdd((volatile signed __int32 *)(v9 + 8), 1u);
        v10 = *(__int64 *)((char *)v4 + v6 + 40);
        v4[5] = (bdRESTInternalResponse_vtbl *)v10;
        if ( v10 )
          _InterlockedExchangeAdd((volatile signed __int32 *)(v10 + 8), 1u);
        *((_DWORD *)v4 + 12) = *(_DWORD *)((char *)v4 + v6 + 48);
        v4[7] = *(bdRESTInternalResponse_vtbl **)((char *)v4 + v6 + 56);
        *((_DWORD *)v4 + 16) = *(_DWORD *)((char *)v4 + v6 + 64);
        *((_DWORD *)v4 + 17) = *(_DWORD *)((char *)v4 + v6 + 68);
        *((_DWORD *)v4 + 18) = *(_DWORD *)((char *)v4 + v6 + 72);
        *((_DWORD *)v4 + 19) = *(_DWORD *)((char *)v4 + v6 + 76);
        *((_DWORD *)v4 + 20) = *(_DWORD *)((char *)v4 + v6 + 80);
        *((_DWORD *)v4 + 21) = *(_DWORD *)((char *)v4 + v6 + 84);
      }
      v4 += 14;
      --v7;
    }
    while ( v7 );
  }
}

/*
==============
bdArray<bdRESTInternalResponse>::increaseCapacity
==============
*/
void bdArray<bdRESTInternalResponse>::increaseCapacity(bdArray<bdRESTInternalResponse> *this, const unsigned int increase)
{
  unsigned int m_capacity; 
  unsigned int v4; 
  bdRESTInternalResponse *v5; 
  unsigned int v6; 
  unsigned int m_size; 
  bdRESTInternalResponse *m_data; 
  __int64 v9; 

  m_capacity = this->m_capacity;
  v4 = m_capacity;
  if ( increase > m_capacity )
    v4 = increase;
  v5 = NULL;
  v6 = m_capacity + v4;
  if ( v6 )
  {
    v5 = (bdRESTInternalResponse *)bdMemory::allocate(112i64 * v6);
    bdArray<bdRESTInternalResponse>::copyConstructArrayArray(this, v5, this->m_data, this->m_size);
  }
  m_size = this->m_size;
  m_data = this->m_data;
  if ( m_size )
  {
    v9 = m_size;
    do
    {
      bdRESTInternalResponse::`vbase destructor(m_data++);
      --v9;
    }
    while ( v9 );
    m_data = this->m_data;
  }
  bdMemory::deallocate(m_data);
  this->m_capacity = v6;
  this->m_data = v5;
}

/*
==============
bdArray<bdAchievementState>::~bdArray<bdAchievementState>
==============
*/
void bdArray<bdAchievementState>::~bdArray<bdAchievementState>(bdArray<bdAchievementState> *this)
{
  bdArray<bdAchievementState>::destruct(this, this->m_data, this->m_size);
  bdMemory::deallocate(this->m_data);
  this->m_data = NULL;
  *(_QWORD *)&this->m_capacity = 0i64;
}

/*
==============
bdArray<bdAchievementState>::copyConstructArrayArray
==============
*/
void bdArray<bdAchievementState>::copyConstructArrayArray(bdArray<bdAchievementState> *this, bdAchievementState *dest, const bdAchievementState *src, const unsigned int n)
{
  int v4; 
  __int64 v7; 
  unsigned int *v8; 
  unsigned int *v12; 
  unsigned int v13; 
  unsigned int i; 
  __int64 v15; 

  if ( n )
  {
    v4 = 0;
    _RBX = &dest->m_multiProgress.m_size;
    _R14 = (char *)src - (char *)dest;
    v7 = n;
    do
    {
      v8 = _RBX - 132;
      if ( _RBX != (unsigned int *)528 )
      {
        *((_QWORD *)_RBX - 65) = &bdAchievementState::`vbtable';
        bdReferencable::bdReferencable((bdReferencable *)(_RBX + 2), (const bdReferencable *)((char *)_RBX + _R14 + *(int *)(*(_QWORD *)((char *)_RBX + _R14 - 520) + 4i64) - 520));
        v4 |= 1u;
        bdStructBufferSerializable::bdStructBufferSerializable((bdStructBufferSerializable *)(_RBX - 132), (const bdStructBufferSerializable *)((char *)_RBX + _R14 - 528));
        *(_QWORD *)v8 = &bdAchievementState::`vftable'{for `bdStructBufferSerializable'};
        *(_QWORD *)((char *)v8 + *(int *)(*((_QWORD *)_RBX - 65) + 4i64) + 8) = &bdAchievementState::`vftable'{for `bdReferencable'};
        *((_QWORD *)_RBX - 64) = *(_QWORD *)((char *)_RBX + _R14 - 512);
        __asm
        {
          vmovups ymm0, ymmword ptr [r14+rbx-1F8h]
          vmovups ymmword ptr [rbx-1F8h], ymm0
          vmovups ymm1, ymmword ptr [r14+rbx-1D8h]
          vmovups ymmword ptr [rbx-1D8h], ymm1
          vmovups ymm0, ymmword ptr [r14+rbx-1B8h]
          vmovups ymmword ptr [rbx-1B8h], ymm0
        }
        *(_RBX - 102) = *(unsigned int *)((char *)_RBX + _R14 - 408);
        *((_BYTE *)_RBX - 404) = *((_BYTE *)_RBX + _R14 - 404);
        *((_WORD *)_RBX - 201) = *(_WORD *)((char *)_RBX + _R14 - 402);
        *(_RBX - 100) = *(unsigned int *)((char *)_RBX + _R14 - 400);
        *(_RBX - 99) = *(unsigned int *)((char *)_RBX + _R14 - 396);
        *(_RBX - 98) = *(unsigned int *)((char *)_RBX + _R14 - 392);
        *((_QWORD *)_RBX - 48) = *(_QWORD *)((char *)_RBX + _R14 - 384);
        *((_QWORD *)_RBX - 47) = *(_QWORD *)((char *)_RBX + _R14 - 376);
        *((_QWORD *)_RBX - 46) = *(_QWORD *)((char *)_RBX + _R14 - 368);
        *(_RBX - 90) = *(unsigned int *)((char *)_RBX + _R14 - 360);
        v12 = _RBX - 88;
        `eh vector vbase constructor iterator'(_RBX - 88, 0x58ui64, 4ui64, (void (__fastcall *)(void *))bdAchievementProgress::bdAchievementProgress, (void (__fastcall *)(void *))bdAchievementProgress::`vbase destructor);
        *_RBX = 0;
        v13 = *(unsigned int *)((char *)_RBX + _R14);
        *_RBX = v13;
        for ( i = 0; i < *_RBX; ++i )
        {
          v15 = 22i64 * i;
          _RDI = (__int64)&_RBX[v15 - 88] + _R14;
          _RSI = &v12[v15];
          bdReferencable::operator=((bdReferencable *)((char *)&v12[v15 + 2] + *(int *)(*(_QWORD *)&v12[v15 + 2] + 4i64)), (const bdReferencable *)(*(int *)(*(_QWORD *)(_RDI + 8) + 4i64) + _RDI + 8));
          __asm
          {
            vmovups ymm0, ymmword ptr [rdi+10h]
            vmovups ymmword ptr [rsi+10h], ymm0
          }
          *((_BYTE *)_RSI + 48) = *(_BYTE *)(_RDI + 48);
          *((_QWORD *)_RSI + 7) = *(_QWORD *)(_RDI + 56);
          *((_QWORD *)_RSI + 8) = *(_QWORD *)(_RDI + 64);
        }
      }
      _RBX += 138;
      --v7;
    }
    while ( v7 );
  }
}

/*
==============
bdArray<bdAchievementState>::destruct
==============
*/
void bdArray<bdAchievementState>::destruct(bdArray<bdAchievementState> *this, bdAchievementState *src, const unsigned int n)
{
  __int64 v4; 
  __int64 v5; 
  __int64 v6; 
  __int64 v7; 

  if ( n )
  {
    v4 = 0i64;
    v5 = 0i64;
    v6 = n;
    do
    {
      v7 = *(int *)(*((_QWORD *)&src[v4].__vftable + 1) + 4i64);
      (**(void (__fastcall ***)(char *, _QWORD))((char *)&src->__vftable + v7 + v4 * 552 + 8))((char *)&src->__vftable + v7 + v5 + 8, 0i64);
      v5 += 552i64;
      ++v4;
      --v6;
    }
    while ( v6 );
  }
}

/*
==============
bdArray<bdAchievementState>::pushBack
==============
*/
void bdArray<bdAchievementState>::pushBack(bdArray<bdAchievementState> *this, const bdAchievementState *value)
{
  unsigned int m_size; 
  unsigned int m_capacity; 
  int v6; 
  bdAchievementState *m_data; 
  unsigned int v8; 
  unsigned int v9; 
  bdAchievementState *v10; 

  m_size = this->m_size;
  m_capacity = this->m_capacity;
  if ( m_size == m_capacity )
  {
    v6 = m_capacity;
    if ( !m_capacity )
      v6 = 1;
    m_data = NULL;
    v8 = m_capacity + v6;
    if ( v8 )
    {
      m_data = (bdAchievementState *)bdMemory::allocate(552i64 * v8);
      bdArray<bdAchievementState>::copyConstructArrayArray(this, m_data, this->m_data, this->m_size);
      m_size = this->m_size;
    }
    bdArray<bdAchievementState>::destruct(this, this->m_data, m_size);
    bdMemory::deallocate(this->m_data);
    this->m_data = m_data;
    this->m_capacity = v8;
    m_size = this->m_size;
  }
  else
  {
    m_data = this->m_data;
  }
  v9 = m_size;
  v10 = &m_data[m_size];
  if ( v10 )
  {
    bdAchievementState::bdAchievementState(v10, value);
    v9 = this->m_size;
  }
  this->m_size = v9 + 1;
}

/*
==============
bdArray<bdObjectStoreMetadata>::~bdArray<bdObjectStoreMetadata>
==============
*/
void bdArray<bdObjectStoreMetadata>::~bdArray<bdObjectStoreMetadata>(bdArray<bdObjectStoreMetadata> *this)
{
  bdArray<bdObjectStoreMetadata>::clear(this);
}

/*
==============
bdArray<bdObjectStoreMetadata>::clear
==============
*/
void bdArray<bdObjectStoreMetadata>::clear(bdArray<bdObjectStoreMetadata> *this)
{
  unsigned int m_size; 
  bdObjectStoreMetadata *m_data; 
  bdArray<bdObjectStoreTag> *p_m_tags; 
  __int64 v5; 

  m_size = this->m_size;
  m_data = this->m_data;
  if ( m_size )
  {
    p_m_tags = &m_data->m_tags;
    v5 = m_size;
    do
    {
      bdMemory::deallocate(p_m_tags->m_data);
      p_m_tags->m_data = NULL;
      *(_QWORD *)&p_m_tags->m_capacity = 0i64;
      bdObjectStoreACL::~bdObjectStoreACL((bdObjectStoreACL *)&p_m_tags[-201]);
      p_m_tags += 218;
      --v5;
    }
    while ( v5 );
    m_data = this->m_data;
  }
  bdMemory::deallocate(m_data);
  this->m_data = NULL;
  *(_QWORD *)&this->m_capacity = 0i64;
}

/*
==============
bdArray<bdObjectStoreMetadata>::increaseCapacity
==============
*/
void bdArray<bdObjectStoreMetadata>::increaseCapacity(bdArray<bdObjectStoreMetadata> *this, const unsigned int increase)
{
  unsigned int m_capacity; 
  unsigned int v4; 
  bdObjectStoreMetadata *v5; 
  unsigned int v6; 
  bdObjectStoreMetadata *v7; 
  unsigned int m_size; 
  bdObjectStoreMetadata *v9; 
  char *v10; 
  __int64 v11; 
  unsigned int v12; 
  bdObjectStoreMetadata *m_data; 
  bdArray<bdObjectStoreTag> *p_m_tags; 
  __int64 v15; 

  m_capacity = this->m_capacity;
  v4 = m_capacity;
  if ( increase > m_capacity )
    v4 = increase;
  v5 = NULL;
  v6 = m_capacity + v4;
  if ( v6 )
  {
    v7 = (bdObjectStoreMetadata *)bdMemory::allocate(3488i64 * v6);
    v5 = v7;
    m_size = this->m_size;
    if ( m_size )
    {
      v9 = v7;
      v10 = (char *)((char *)this->m_data - (char *)v7);
      v11 = m_size;
      do
      {
        if ( v9 )
          bdObjectStoreMetadata::bdObjectStoreMetadata(v9, (const bdObjectStoreMetadata *)((char *)v9 + (_QWORD)v10));
        ++v9;
        --v11;
      }
      while ( v11 );
    }
  }
  v12 = this->m_size;
  m_data = this->m_data;
  if ( v12 )
  {
    p_m_tags = &m_data->m_tags;
    v15 = v12;
    do
    {
      bdMemory::deallocate(p_m_tags->m_data);
      p_m_tags->m_data = NULL;
      *(_QWORD *)&p_m_tags->m_capacity = 0i64;
      bdObjectStoreACL::~bdObjectStoreACL((bdObjectStoreACL *)&p_m_tags[-201]);
      p_m_tags += 218;
      --v15;
    }
    while ( v15 );
    m_data = this->m_data;
  }
  bdMemory::deallocate(m_data);
  this->m_data = v5;
  this->m_capacity = v6;
}

/*
==============
bdArray<GeneralChannelRequest>::destruct
==============
*/
void bdArray<GeneralChannelRequest>::destruct(bdArray<GeneralChannelRequest> *this, GeneralChannelRequest *src, const unsigned int n)
{
  __int64 v4; 
  __int64 v5; 
  __int64 v6; 
  __int64 v7; 

  if ( n )
  {
    v4 = 0i64;
    v5 = 0i64;
    v6 = n;
    do
    {
      v7 = *(int *)(*((_QWORD *)&src[v4].__vftable + 1) + 4i64);
      (**(void (__fastcall ***)(char *, _QWORD))((char *)&src->__vftable + v7 + v4 * 64 + 8))((char *)&src->__vftable + v7 + v5 + 8, 0i64);
      v5 += 64i64;
      ++v4;
      --v6;
    }
    while ( v6 );
  }
}

/*
==============
bdArray<GeneralChannelRequest>::pushBack
==============
*/
void bdArray<GeneralChannelRequest>::pushBack(bdArray<GeneralChannelRequest> *this, const GeneralChannelRequest *value)
{
  bdArray<GeneralChannelRequest> *v2; 
  int v3; 
  unsigned int m_size; 
  unsigned int m_capacity; 
  int v6; 
  bool v7; 
  unsigned int v8; 
  GeneralChannelRequest *v9; 
  char *v10; 
  GeneralChannelRequest *m_data; 
  char *v13; 
  __int64 v15; 
  unsigned int v17; 
  GeneralChannelRequest *v18; 
  GeneralChannelRequest *v19; 
  GeneralChannelRequest *__that; 
  unsigned int v22; 

  __that = (GeneralChannelRequest *)value;
  v2 = this;
  v3 = 0;
  m_size = this->m_size;
  m_capacity = this->m_capacity;
  if ( m_size == m_capacity )
  {
    v6 = m_capacity;
    if ( !m_capacity )
      v6 = 1;
    v7 = m_capacity + v6 == 0;
    v8 = m_capacity + v6;
    v22 = v8;
    v9 = NULL;
    if ( !v7 )
    {
      v10 = (char *)bdMemory::allocate((unsigned __int64)v8 << 6);
      v9 = (GeneralChannelRequest *)v10;
      v19 = (GeneralChannelRequest *)v10;
      m_size = v2->m_size;
      m_data = v2->m_data;
      if ( m_size )
      {
        _RBX = v10 + 8;
        v13 = (char *)(v10 - (char *)m_data);
        _R12 = (char *)m_data - v10;
        v15 = m_size;
        do
        {
          if ( _RBX != (_QWORD *)8 )
          {
            *_RBX = &GeneralChannelRequest::`vbtable';
            bdReferencable::bdReferencable((bdReferencable *)&v13[(_QWORD)_RBX + _R12 + 40], (const bdReferencable *)((char *)_RBX + _R12 + *(int *)(*(_QWORD *)((char *)_RBX + _R12) + 4i64)));
            v3 |= 1u;
            bdStructBufferSerializable::bdStructBufferSerializable((bdStructBufferSerializable *)(_RBX - 1), (const bdStructBufferSerializable *)((char *)_RBX + _R12 - 8));
            *(_RBX - 1) = &GeneralChannelRequest::`vftable'{for `bdStructBufferSerializable'};
            *(_QWORD *)((char *)_RBX + *(int *)(*_RBX + 4i64)) = &GeneralChannelRequest::`vftable'{for `bdReferencable'};
            __asm
            {
              vmovups xmm0, xmmword ptr [r12+rbx+8]
              vmovups xmmword ptr [rbx+8], xmm0
            }
            _RBX[3] = *(_QWORD *)((char *)_RBX + _R12 + 24);
            _RBX[4] = *(_QWORD *)((char *)_RBX + _R12 + 32);
          }
          _RBX += 8;
          --v15;
        }
        while ( v15 );
        v2 = this;
        m_size = this->m_size;
        v9 = v19;
      }
    }
    bdArray<GeneralChannelRequest>::destruct(v2, v2->m_data, m_size);
    bdMemory::deallocate(v2->m_data);
    v2->m_data = v9;
    v2->m_capacity = v22;
    m_size = v2->m_size;
    value = __that;
  }
  else
  {
    v9 = v2->m_data;
  }
  v17 = m_size;
  v18 = &v9[(unsigned __int64)m_size];
  if ( v18 )
  {
    GeneralChannelRequest::GeneralChannelRequest(v18, value);
    v17 = v2->m_size;
  }
  v2->m_size = v17 + 1;
}

/*
==============
bdArray<bdObjectStoreHTTPHeader>::~bdArray<bdObjectStoreHTTPHeader>
==============
*/
void bdArray<bdObjectStoreHTTPHeader>::~bdArray<bdObjectStoreHTTPHeader>(bdArray<bdObjectStoreHTTPHeader> *this)
{
  bdArray<bdObjectStoreHTTPHeader>::destruct(this, this->m_data, this->m_size);
  bdMemory::deallocate(this->m_data);
  this->m_data = NULL;
  *(_QWORD *)&this->m_capacity = 0i64;
}

/*
==============
bdArray<bdObjectStoreHTTPHeader>::destruct
==============
*/
void bdArray<bdObjectStoreHTTPHeader>::destruct(bdArray<bdObjectStoreHTTPHeader> *this, bdObjectStoreHTTPHeader *src, const unsigned int n)
{
  __int64 v4; 
  __int64 v5; 
  __int64 v6; 
  __int64 v7; 

  if ( n )
  {
    v4 = 0i64;
    v5 = 0i64;
    v6 = n;
    do
    {
      v7 = *(int *)(*((_QWORD *)&src[v4].__vftable + 1) + 4i64);
      (**(void (__fastcall ***)(char *, _QWORD))((char *)&src->__vftable + v7 + v4 * 4232 + 8))((char *)&src->__vftable + v7 + v5 + 8, 0i64);
      v5 += 4232i64;
      ++v4;
      --v6;
    }
    while ( v6 );
  }
}

/*
==============
bdArray<bdSockAddr>::~bdArray<bdSockAddr>
==============
*/
void bdArray<bdSockAddr>::~bdArray<bdSockAddr>(bdArray<bdSockAddr> *this)
{
  bdMemory::deallocate(this->m_data);
  this->m_data = NULL;
  *(_QWORD *)&this->m_capacity = 0i64;
}

/*
==============
bdArray<bdSockAddr>::operator=
==============
*/
void bdArray<bdSockAddr>::operator=(bdArray<bdSockAddr> *this, const bdArray<bdSockAddr> *a)
{
  unsigned int m_size; 
  unsigned int m_capacity; 
  unsigned int v6; 
  bdSockAddr *v7; 
  bdSockAddr *v15; 
  signed __int64 v16; 
  __int64 v17; 
  unsigned int v18; 
  unsigned int v26; 
  __int64 v27; 

  if ( this != a )
  {
    v27 = -2i64;
    m_size = a->m_size;
    m_capacity = this->m_capacity;
    if ( m_size <= m_capacity )
    {
      v6 = this->m_size;
      v7 = NULL;
      if ( m_size <= v6 )
      {
        v18 = 0;
        if ( m_size )
        {
          _R12 = 0i64;
          do
          {
            bdHandleAssert(v18 < a->m_size, "rangeCheck(i)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdarray.inl", "bdArray<class bdSockAddr>::operator []", 0x70u, "bdArray<T>::operator[], rangecheck failed", v27);
            _RAX = a->m_data;
            __asm
            {
              vmovups ymm0, ymmword ptr [r12+rax]
              vmovups ymm1, ymmword ptr [r12+rax+20h]
              vmovups ymm2, ymmword ptr [r12+rax+40h]
              vmovups ymm3, ymmword ptr [r12+rax+60h]
            }
            _RAX = this->m_data;
            __asm
            {
              vmovups ymmword ptr [r12+rax], ymm0
              vmovups ymmword ptr [r12+rax+20h], ymm1
              vmovups ymmword ptr [r12+rax+40h], ymm2
              vmovups ymmword ptr [r12+rax+60h], ymm3
            }
            ++v18;
            _R12 += 128i64;
          }
          while ( v18 < m_size );
          m_capacity = this->m_capacity;
        }
        this->m_size = m_size;
        if ( m_capacity > 4 * m_size )
        {
          v26 = m_capacity - (m_capacity >> 1);
          this->m_capacity = v26;
          if ( v26 )
          {
            v7 = (bdSockAddr *)bdMemory::allocate((unsigned __int64)v26 << 7);
            bdArray<bdSockAddr>::copyConstructArrayArray(this, v7, this->m_data, this->m_size);
          }
          bdMemory::deallocate(this->m_data);
          this->m_data = v7;
        }
      }
      else
      {
        if ( v6 )
        {
          do
          {
            bdHandleAssert((unsigned int)v7 < a->m_size, "rangeCheck(i)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdarray.inl", "bdArray<class bdSockAddr>::operator []", 0x70u, "bdArray<T>::operator[], rangecheck failed", v27);
            _RCX = (unsigned __int64)(unsigned int)v7 << 7;
            _RAX = a->m_data;
            __asm
            {
              vmovups ymm0, ymmword ptr [rcx+rax]
              vmovups ymm1, ymmword ptr [rcx+rax+20h]
              vmovups ymm2, ymmword ptr [rcx+rax+40h]
              vmovups ymm3, ymmword ptr [rcx+rax+60h]
            }
            _RAX = this->m_data;
            __asm
            {
              vmovups ymmword ptr [rcx+rax], ymm0
              vmovups ymmword ptr [rcx+rax+20h], ymm1
              vmovups ymmword ptr [rcx+rax+40h], ymm2
              vmovups ymmword ptr [rcx+rax+60h], ymm3
            }
            LODWORD(v7) = (_DWORD)v7 + 1;
            v6 = this->m_size;
          }
          while ( (unsigned int)v7 < v6 );
        }
        v15 = &this->m_data[(unsigned __int64)v6];
        if ( m_size != v6 )
        {
          v16 = (char *)a->m_data - (char *)this->m_data;
          v17 = m_size - v6;
          do
          {
            if ( v15 )
              bdSockAddr::bdSockAddr(v15, (bdSockAddr *)((char *)v15 + v16));
            ++v15;
            --v17;
          }
          while ( v17 );
        }
        this->m_size = m_size;
      }
    }
    else
    {
      bdMemory::deallocate(this->m_data);
      this->m_data = NULL;
      *(_QWORD *)&this->m_capacity = 0i64;
      this->m_data = bdArray<bdSockAddr>::uninitializedCopy(this, a);
      this->m_capacity = a->m_capacity;
      this->m_size = m_size;
    }
  }
}

/*
==============
bdArray<bdString>::operator=
==============
*/
void bdArray<bdString>::operator=(bdArray<bdString> *this, const bdArray<bdString> *a)
{
  __int64 m_size; 
  unsigned int v5; 
  bdString *v6; 
  bdString *v7; 
  bdString *v8; 
  signed __int64 v9; 
  __int64 v10; 
  unsigned int v11; 
  __int64 v12; 
  unsigned int v13; 
  bdString *v14; 
  __int64 v15; 
  unsigned int m_capacity; 
  unsigned int v17; 
  bdString *m_data; 
  __int64 v19; 

  if ( this != a )
  {
    v19 = -2i64;
    m_size = a->m_size;
    if ( (unsigned int)m_size <= this->m_capacity )
    {
      v5 = this->m_size;
      v6 = NULL;
      if ( (unsigned int)m_size <= v5 )
      {
        v11 = 0;
        if ( (_DWORD)m_size )
        {
          v12 = 0i64;
          do
          {
            bdHandleAssert(v11 < a->m_size, "rangeCheck(i)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdarray.inl", "bdArray<class bdString>::operator []", 0x70u, "bdArray<T>::operator[], rangecheck failed", v19);
            bdString::operator=(&this->m_data[v12], &a->m_data[v12]);
            ++v11;
            ++v12;
          }
          while ( v11 < (unsigned int)m_size );
          v5 = this->m_size;
        }
        v13 = v5 - m_size;
        v14 = &this->m_data[m_size];
        if ( v13 )
        {
          v15 = v13;
          do
          {
            bdString::~bdString(v14++);
            --v15;
          }
          while ( v15 );
        }
        this->m_size = m_size;
        m_capacity = this->m_capacity;
        if ( m_capacity > 4 * (int)m_size )
        {
          v17 = m_capacity - (m_capacity >> 1);
          this->m_capacity = v17;
          if ( v17 )
          {
            v6 = (bdString *)bdMemory::allocate(8i64 * v17);
            bdArray<bdString>::copyConstructArrayArray(this, v6, this->m_data, this->m_size);
            m_size = this->m_size;
          }
          m_data = this->m_data;
          if ( (_DWORD)m_size )
          {
            do
            {
              bdString::~bdString(m_data++);
              --m_size;
            }
            while ( m_size );
            m_data = this->m_data;
          }
          bdMemory::deallocate(m_data);
          this->m_data = v6;
        }
      }
      else
      {
        if ( v5 )
        {
          do
          {
            bdHandleAssert((unsigned int)v6 < a->m_size, "rangeCheck(i)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdarray.inl", "bdArray<class bdString>::operator []", 0x70u, "bdArray<T>::operator[], rangecheck failed", v19);
            bdString::operator=(&this->m_data[(unsigned int)v6], &a->m_data[(unsigned int)v6]);
            LODWORD(v6) = (_DWORD)v6 + 1;
            v5 = this->m_size;
          }
          while ( (unsigned int)v6 < v5 );
        }
        v7 = &a->m_data[v5];
        v8 = &this->m_data[v5];
        if ( (_DWORD)m_size != v5 )
        {
          v9 = (char *)v7 - (char *)v8;
          v10 = (unsigned int)m_size - v5;
          do
          {
            if ( v8 )
              bdString::bdString(v8, (bdString *)((char *)v8 + v9));
            ++v8;
            --v10;
          }
          while ( v10 );
        }
        this->m_size = m_size;
      }
    }
    else
    {
      bdArray<bdString>::clear(this);
      this->m_data = bdArray<bdString>::uninitializedCopy(this, a);
      this->m_capacity = a->m_capacity;
      this->m_size = m_size;
    }
  }
}

/*
==============
bdArray<bdAddr>::operator[]
==============
*/
bdAddr *bdArray<bdAddr>::operator[](bdArray<bdAddr> *this, const unsigned int i)
{
  __int64 v3; 

  v3 = i;
  bdHandleAssert(i < this->m_size, "rangeCheck(i)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdarray.inl", "bdArray<class bdAddr>::operator []", 0x68u, "bdArray<T>::operator[], rangecheck failed");
  return &this->m_data[v3];
}

/*
==============
bdArray<bdSockAddr>::operator[]
==============
*/
bdSockAddr *bdArray<bdSockAddr>::operator[](bdArray<bdSockAddr> *this, const unsigned int i)
{
  bdHandleAssert(i < this->m_size, "rangeCheck(i)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdarray.inl", "bdArray<class bdSockAddr>::operator []", 0x68u, "bdArray<T>::operator[], rangecheck failed");
  return &this->m_data[(unsigned __int64)i];
}

/*
==============
bdArray<bdString>::operator[]
==============
*/
bdString *bdArray<bdString>::operator[](bdArray<bdString> *this, const unsigned int i)
{
  __int64 v3; 

  v3 = i;
  bdHandleAssert(i < this->m_size, "rangeCheck(i)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdarray.inl", "bdArray<class bdString>::operator []", 0x68u, "bdArray<T>::operator[], rangecheck failed");
  return &this->m_data[v3];
}

/*
==============
bdArray<bdString>::clear
==============
*/
void bdArray<bdString>::clear(bdArray<bdString> *this)
{
  unsigned int m_size; 
  bdString *m_data; 
  __int64 v4; 

  m_size = this->m_size;
  m_data = this->m_data;
  if ( m_size )
  {
    v4 = m_size;
    do
    {
      bdString::~bdString(m_data++);
      --v4;
    }
    while ( v4 );
    m_data = this->m_data;
  }
  bdMemory::deallocate(m_data);
  this->m_data = NULL;
  *(_QWORD *)&this->m_capacity = 0i64;
}

/*
==============
bdArray<bdSockAddr>::copyConstructArrayArray
==============
*/
void bdArray<bdSockAddr>::copyConstructArrayArray(bdArray<bdSockAddr> *this, bdSockAddr *dest, const bdSockAddr *src, const unsigned int n)
{
  bdSockAddr *v4; 
  signed __int64 v5; 
  __int64 v6; 

  if ( n )
  {
    v4 = dest;
    v5 = (char *)src - (char *)dest;
    v6 = n;
    do
    {
      if ( v4 )
        bdSockAddr::bdSockAddr(v4, (bdSockAddr *)((char *)v4 + v5));
      ++v4;
      --v6;
    }
    while ( v6 );
  }
}

/*
==============
bdArray<bdString>::copyConstructArrayArray
==============
*/
void bdArray<bdString>::copyConstructArrayArray(bdArray<bdString> *this, bdString *dest, const bdString *src, const unsigned int n)
{
  bdString *v4; 
  signed __int64 v5; 
  __int64 v6; 

  if ( n )
  {
    v4 = dest;
    v5 = (char *)src - (char *)dest;
    v6 = n;
    do
    {
      if ( v4 )
        bdString::bdString(v4, (bdString *)((char *)v4 + v5));
      ++v4;
      --v6;
    }
    while ( v6 );
  }
}

/*
==============
bdArray<bdAddr>::pushBack
==============
*/
void bdArray<bdAddr>::pushBack(bdArray<bdAddr> *this, const bdAddr *value)
{
  unsigned int m_size; 
  unsigned int m_capacity; 
  unsigned int v6; 
  bdAddr *m_data; 
  unsigned int v8; 
  unsigned int v9; 
  bdAddr *v10; 
  char *v11; 
  __int64 v12; 
  bdAddr *v13; 

  m_size = this->m_size;
  m_capacity = this->m_capacity;
  if ( m_size == m_capacity )
  {
    v6 = this->m_capacity;
    if ( !m_capacity )
      v6 = 1;
    m_data = NULL;
    v8 = m_capacity + v6;
    if ( v8 )
    {
      m_data = (bdAddr *)bdMemory::allocate(152i64 * v8);
      v9 = this->m_size;
      if ( v9 )
      {
        v10 = m_data;
        v11 = (char *)((char *)this->m_data - (char *)m_data);
        v12 = v9;
        do
        {
          if ( v10 )
            bdAddr::bdAddr(v10, (const bdAddr *)((char *)v10 + (_QWORD)v11));
          ++v10;
          --v12;
        }
        while ( v12 );
      }
    }
    bdMemory::deallocate(this->m_data);
    this->m_data = m_data;
    this->m_capacity = v8;
    m_size = this->m_size;
  }
  else
  {
    m_data = this->m_data;
  }
  v13 = &m_data[m_size];
  if ( v13 )
  {
    bdAddr::bdAddr(v13, value);
    m_size = this->m_size;
  }
  this->m_size = m_size + 1;
}

/*
==============
bdArray<bdSockAddr>::uninitializedCopy
==============
*/
bdSockAddr *bdArray<bdSockAddr>::uninitializedCopy(bdArray<bdSockAddr> *this, const bdArray<bdSockAddr> *a)
{
  unsigned int m_capacity; 
  bdSockAddr *v4; 
  unsigned int m_size; 
  bdSockAddr *m_data; 
  bdSockAddr *v7; 
  signed __int64 v8; 
  __int64 v9; 

  m_capacity = a->m_capacity;
  if ( !m_capacity )
    return 0i64;
  v4 = (bdSockAddr *)bdMemory::allocate((unsigned __int64)m_capacity << 7);
  m_size = a->m_size;
  m_data = a->m_data;
  if ( m_size )
  {
    v7 = v4;
    v8 = (char *)m_data - (char *)v4;
    v9 = m_size;
    do
    {
      if ( v7 )
        bdSockAddr::bdSockAddr(v7, (bdSockAddr *)((char *)v7 + v8));
      ++v7;
      --v9;
    }
    while ( v9 );
  }
  return v4;
}

/*
==============
bdArray<bdString>::uninitializedCopy
==============
*/
bdString *bdArray<bdString>::uninitializedCopy(bdArray<bdString> *this, const bdArray<bdString> *a)
{
  __int64 m_capacity; 
  bdString *v4; 
  unsigned int m_size; 
  bdString *m_data; 
  bdString *v7; 
  signed __int64 v8; 
  __int64 v9; 

  m_capacity = a->m_capacity;
  if ( !(_DWORD)m_capacity )
    return 0i64;
  v4 = (bdString *)bdMemory::allocate(8 * m_capacity);
  m_size = a->m_size;
  m_data = a->m_data;
  if ( m_size )
  {
    v7 = v4;
    v8 = (char *)m_data - (char *)v4;
    v9 = m_size;
    do
    {
      if ( v7 )
        bdString::bdString(v7, (bdString *)((char *)v7 + v8));
      ++v7;
      --v9;
    }
    while ( v9 );
  }
  return v4;
}

/*
==============
bdArray<bdQoSHostStats>::~bdArray<bdQoSHostStats>
==============
*/
void bdArray<bdQoSHostStats>::~bdArray<bdQoSHostStats>(bdArray<bdQoSHostStats> *this)
{
  bdMemory::deallocate(this->m_data);
  this->m_data = NULL;
  *(_QWORD *)&this->m_capacity = 0i64;
}

/*
==============
bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>::~bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>
==============
*/
void bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>::~bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>(bdArray<bdQoSProbe::bdQoSProbeEntryWrapper> *this)
{
  unsigned int m_size; 
  bdQoSProbe::bdQoSProbeEntryWrapper *m_data; 
  __int64 v4; 

  m_size = this->m_size;
  m_data = this->m_data;
  if ( m_size )
  {
    v4 = m_size;
    do
    {
      bdQoSProbe::bdQoSProbeEntryWrapper::~bdQoSProbeEntryWrapper(m_data++);
      --v4;
    }
    while ( v4 );
    m_data = this->m_data;
  }
  bdMemory::deallocate(m_data);
  this->m_data = NULL;
  *(_QWORD *)&this->m_capacity = 0i64;
}

/*
==============
bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>::operator=
==============
*/
void bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>::operator=(bdArray<bdQoSProbe::bdQoSProbeEntryWrapper> *this, const bdArray<bdQoSProbe::bdQoSProbeEntryWrapper> *a)
{
  __int64 m_size; 
  unsigned int m_capacity; 
  unsigned int v6; 
  unsigned int v7; 
  __int64 v8; 
  bdQoSProbe::bdQoSProbeEntryWrapper *v9; 
  unsigned int v10; 
  __int64 v11; 

  if ( this != a )
  {
    m_size = a->m_size;
    if ( (unsigned int)m_size <= this->m_capacity )
    {
      v6 = this->m_size;
      v7 = 0;
      if ( (unsigned int)m_size <= v6 )
      {
        if ( (_DWORD)m_size )
        {
          v8 = 0i64;
          do
          {
            bdHandleAssert(v7 < a->m_size, "rangeCheck(i)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdarray.inl", "bdArray<struct bdQoSProbe::bdQoSProbeEntryWrapper>::operator []", 0x70u, "bdArray<T>::operator[], rangecheck failed");
            bdQoSProbe::bdQoSProbeEntryWrapper::operator=(&this->m_data[v8], &a->m_data[v8]);
            ++v7;
            ++v8;
          }
          while ( v7 < (unsigned int)m_size );
          v6 = this->m_size;
        }
        v9 = &this->m_data[m_size];
        v10 = v6 - m_size;
        if ( v10 )
        {
          v11 = v10;
          do
          {
            bdQoSProbe::bdQoSProbeEntryWrapper::~bdQoSProbeEntryWrapper(v9++);
            --v11;
          }
          while ( v11 );
        }
        this->m_size = m_size;
        bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>::decreaseCapacity(this, 0);
      }
      else
      {
        if ( v6 )
        {
          do
          {
            bdHandleAssert(v7 < a->m_size, "rangeCheck(i)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdarray.inl", "bdArray<struct bdQoSProbe::bdQoSProbeEntryWrapper>::operator []", 0x70u, "bdArray<T>::operator[], rangecheck failed");
            bdQoSProbe::bdQoSProbeEntryWrapper::operator=(&this->m_data[v7], &a->m_data[v7]);
            v6 = this->m_size;
            ++v7;
          }
          while ( v7 < v6 );
        }
        bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>::copyConstructArrayArray(this, &this->m_data[v6], &a->m_data[v6], m_size - v6);
        this->m_size = m_size;
      }
    }
    else
    {
      bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>::clear(this);
      this->m_data = bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>::uninitializedCopy(this, a);
      m_capacity = a->m_capacity;
      this->m_size = m_size;
      this->m_capacity = m_capacity;
    }
  }
}

/*
==============
bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>::clear
==============
*/
void bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>::clear(bdArray<bdQoSProbe::bdQoSProbeEntryWrapper> *this)
{
  unsigned int m_size; 
  bdQoSProbe::bdQoSProbeEntryWrapper *m_data; 
  __int64 v4; 

  m_size = this->m_size;
  m_data = this->m_data;
  if ( m_size )
  {
    v4 = m_size;
    do
    {
      bdQoSProbe::bdQoSProbeEntryWrapper::~bdQoSProbeEntryWrapper(m_data++);
      --v4;
    }
    while ( v4 );
    m_data = this->m_data;
  }
  bdMemory::deallocate(m_data);
  this->m_data = NULL;
  *(_QWORD *)&this->m_capacity = 0i64;
}

/*
==============
bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>::copyConstructArrayArray
==============
*/
void bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>::copyConstructArrayArray(bdArray<bdQoSProbe::bdQoSProbeEntryWrapper> *this, bdQoSProbe::bdQoSProbeEntryWrapper *dest, const bdQoSProbe::bdQoSProbeEntryWrapper *src, const unsigned int n)
{
  __int64 v6; 
  __int64 v7; 
  __int64 v11; 

  if ( n )
  {
    _RBX = &src->m_telemetry.m_probeInfo.m_realAddr;
    _RDI = (char *)dest - (char *)src;
    v6 = n;
    do
    {
      if ( (bdAddr *)((char *)_RBX + _RDI) != (bdAddr *)360 )
      {
        v7 = *((_QWORD *)&_RBX[-3].m_address.inUn.m_ipv6Sockaddr + 12);
        *(_QWORD *)((char *)&_RBX[-2] + _RDI - 56) = v7;
        if ( v7 )
          _InterlockedExchangeAdd((volatile signed __int32 *)(v7 + 8), 1u);
        bdSecurityID::bdSecurityID((bdSecurityID *)((char *)&_RBX[-2] + _RDI - 48), (const bdSecurityID *)&_RBX[-3].m_address.inUn.m_ipv6Sockaddr + 13);
        bdSecurityKey::bdSecurityKey((bdSecurityKey *)((char *)&_RBX[-2] + _RDI - 40), (const bdSecurityKey *)&_RBX[-3].m_address.inUn.m_ipv6Sockaddr + 7);
        *(_QWORD *)((char *)&_RBX[-2] + _RDI - 24) = _RBX[-3].m_relayRoute.m_relayID;
        bdAddr::bdAddr((bdAddr *)((char *)_RBX + _RDI - 320), (bdAddr *)((char *)_RBX - 320));
        *(_DWORD *)((char *)&_RBX[-1] + _RDI - 16) = _RBX[-2].m_relayRoute.m_relayRoutingID;
        *(_QWORD *)((char *)&_RBX[-1] + _RDI - 8) = *(_QWORD *)&_RBX[-2].m_type;
        *(_DWORD *)((char *)&_RBX[-1].m_address.inUn.m_sockaddrStorage.ss_family + _RDI) = *(_DWORD *)&_RBX[-1].m_address.inUn.m_sockaddrStorage.ss_family;
        *(_DWORD *)((char *)_RBX + _RDI - 148) = _RBX[-1].m_address.inUn.m_ipv4Sockaddr.sin_addr.S_un.S_addr;
        *(_DWORD *)((char *)_RBX + _RDI - 144) = *(_DWORD *)_RBX[-1].m_address.inUn.m_ipv6Sockaddr.sin6_addr.u.Byte;
        *(_DWORD *)((char *)_RBX + _RDI - 140) = *(_DWORD *)&_RBX[-1].m_address.inUn.m_ipv6Sockaddr.sin6_addr.u.Word[2];
        __asm
        {
          vmovups ymm0, ymmword ptr [rbx-88h]
          vmovups ymmword ptr [rdi+rbx-88h], ymm0
          vmovups ymm1, ymmword ptr [rbx-68h]
          vmovups ymmword ptr [rdi+rbx-68h], ymm1
        }
        *(_DWORD *)((char *)_RBX + _RDI - 72) = *((_DWORD *)&_RBX[-1].m_address.inUn.m_ipv6Sockaddr + 20);
        *(_DWORD *)((char *)_RBX + _RDI - 68) = *((_DWORD *)&_RBX[-1].m_address.inUn.m_ipv6Sockaddr + 21);
        __asm
        {
          vmovups ymm0, ymmword ptr [rbx-40h]
          vmovups ymmword ptr [rdi+rbx-40h], ymm0
        }
        *(_QWORD *)((char *)_RBX + _RDI - 32) = *((_QWORD *)&_RBX[-1].m_address.inUn.m_ipv6Sockaddr + 15);
        *(_DWORD *)((char *)_RBX + _RDI - 24) = _RBX[-1].m_relayRoute.m_relayID;
        *(_DWORD *)((char *)_RBX + _RDI - 20) = HIDWORD(_RBX[-1].m_relayRoute.m_relayID);
        *(_DWORD *)((char *)_RBX + _RDI - 16) = _RBX[-1].m_relayRoute.m_relayRoutingID;
        v11 = *(_QWORD *)&_RBX[-1].m_type;
        *(_QWORD *)((char *)_RBX + _RDI - 8) = v11;
        if ( v11 )
          _InterlockedExchangeAdd((volatile signed __int32 *)(v11 + 8), 1u);
        bdAddr::bdAddr((bdAddr *)((char *)_RBX + _RDI), _RBX);
        *(_DWORD *)((char *)&_RBX[1].m_address.inUn.m_sockaddrStorage.ss_family + _RDI) = *(_DWORD *)&_RBX[1].m_address.inUn.m_sockaddrStorage.ss_family;
        *(_QWORD *)&_RBX[1].m_address.inUn.m_sockaddrStorage.__ss_pad1[_RDI + 6] = _RBX[1].m_address.inUn.m_sockaddrStorage.__ss_align;
        *(_DWORD *)((char *)&_RBX[1].m_address.inUn.m_ipv6Sockaddr.sin6_addr.u.Word[4] + _RDI) = *(_DWORD *)&_RBX[1].m_address.inUn.m_ipv6Sockaddr.sin6_addr.u.Word[4];
        _RBX[1].m_address.inUn.m_sockaddrStorage.__ss_pad2[_RDI + 4] = _RBX[1].m_address.inUn.m_sockaddrStorage.__ss_pad2[4];
        *(unsigned int *)((char *)&_RBX[1].m_address.inUn.m_ipv6Sockaddr.sin6_scope_id + _RDI) = _RBX[1].m_address.inUn.m_ipv6Sockaddr.sin6_scope_id;
        *(_DWORD *)((char *)&_RBX[1].m_address.inUn.m_ipv6Sockaddr + _RDI + 28) = *((_DWORD *)&_RBX[1].m_address.inUn.m_ipv6Sockaddr + 7);
        *(_DWORD *)((char *)&_RBX[1].m_address.inUn.m_ipv6Sockaddr + _RDI + 32) = *((_DWORD *)&_RBX[1].m_address.inUn.m_ipv6Sockaddr + 8);
        *(_DWORD *)((char *)&_RBX[1].m_address.inUn.m_ipv6Sockaddr + _RDI + 36) = *((_DWORD *)&_RBX[1].m_address.inUn.m_ipv6Sockaddr + 9);
        __asm
        {
          vmovups ymm0, ymmword ptr [rbx+0C0h]
          vmovups ymmword ptr [rdi+rbx+0C0h], ymm0
          vmovups ymm1, ymmword ptr [rbx+0E0h]
          vmovups ymmword ptr [rdi+rbx+0E0h], ymm1
        }
        *(_DWORD *)((char *)&_RBX[1].m_address.inUn.m_ipv6Sockaddr + _RDI + 104) = *((_DWORD *)&_RBX[1].m_address.inUn.m_ipv6Sockaddr + 26);
        *(_DWORD *)((char *)&_RBX[1].m_address.inUn.m_ipv6Sockaddr + _RDI + 108) = *((_DWORD *)&_RBX[1].m_address.inUn.m_ipv6Sockaddr + 27);
        *(_DWORD *)((char *)&_RBX[1].m_address.inUn.m_ipv6Sockaddr + _RDI + 112) = *((_DWORD *)&_RBX[1].m_address.inUn.m_ipv6Sockaddr + 28);
        *(_DWORD *)((char *)&_RBX[1].m_address.inUn.m_ipv6Sockaddr + _RDI + 116) = *((_DWORD *)&_RBX[1].m_address.inUn.m_ipv6Sockaddr + 29);
        _RBX[1].m_address.inUn.m_sockaddrStorage.__ss_pad2[_RDI + 104] = _RBX[1].m_address.inUn.m_sockaddrStorage.__ss_pad2[104];
      }
      _RBX = (bdAddr *)((char *)_RBX + 640);
      --v6;
    }
    while ( v6 );
  }
}

/*
==============
bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>::copyConstructArrayObject
==============
*/
void bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>::copyConstructArrayObject(bdArray<bdQoSProbe::bdQoSProbeEntryWrapper> *this, bdQoSProbe::bdQoSProbeEntryWrapper *dest, const bdQoSProbe::bdQoSProbeEntryWrapper *src, const unsigned int n)
{
  unsigned int v6; 
  bdCommonAddr *m_ptr; 
  bdCommonAddr *v12; 

  if ( n )
  {
    _RDI = src;
    v6 = 0;
    _RBX = &dest->m_telemetry.m_probeInfo.m_latency;
    do
    {
      if ( _RBX != (float *)512 )
      {
        m_ptr = _RDI->m_addr.m_ptr;
        *((_QWORD *)_RBX - 64) = _RDI->m_addr.m_ptr;
        if ( m_ptr )
          _InterlockedExchangeAdd((volatile signed __int32 *)&m_ptr->m_refCount, 1u);
        bdSecurityID::bdSecurityID((bdSecurityID *)_RBX - 63, &_RDI->m_id);
        bdSecurityKey::bdSecurityKey((bdSecurityKey *)_RBX - 31, &_RDI->m_key);
        *((_QWORD *)_RBX - 60) = _RDI->m_listener;
        bdAddr::bdAddr((bdAddr *)(_RBX - 118), &_RDI->m_realAddr);
        *(_RBX - 80) = *(float *)&_RDI->m_retries;
        *((_QWORD *)_RBX - 39) = _RDI->m_lastTry.m_start;
        *(_RBX - 76) = *(float *)&_RDI->m_numRepliesReceived;
        *(_RBX - 75) = *(float *)&_RDI->m_numRepliesExpected;
        *(_RBX - 74) = _RDI->m_latency;
        *(_RBX - 73) = _RDI->m_minLatency;
        __asm
        {
          vmovups ymm0, ymmword ptr [rdi+0E0h]
          vmovups ymmword ptr [rbx-120h], ymm0
          vmovups ymm1, ymmword ptr [rdi+100h]
          vmovups ymmword ptr [rbx-100h], ymm1
        }
        *(_RBX - 56) = *(float *)&_RDI->m_bandwidthUp;
        *(_RBX - 55) = *(float *)&_RDI->m_bandwidthDown;
        __asm
        {
          vmovups ymm0, ymmword ptr [rdi+128h]
          vmovups ymmword ptr [rbx-0D8h], ymm0
        }
        *((_QWORD *)_RBX - 23) = _RDI->m_telemetry.m_age.m_start;
        *(_RBX - 44) = *(float *)&_RDI->m_telemetry.m_duration;
        *(_RBX - 43) = *(float *)&_RDI->m_telemetry.m_msToNatTravResolve;
        *(_RBX - 42) = *(float *)&_RDI->m_telemetry.m_msToRelayEstablished;
        v12 = _RDI->m_telemetry.m_probeInfo.m_addr.m_ptr;
        *((_QWORD *)_RBX - 20) = v12;
        if ( v12 )
          _InterlockedExchangeAdd((volatile signed __int32 *)&v12->m_refCount, 1u);
        bdAddr::bdAddr((bdAddr *)_RBX - 1, &_RDI->m_telemetry.m_probeInfo.m_realAddr);
        *_RBX = _RDI->m_telemetry.m_probeInfo.m_latency;
        *((_QWORD *)_RBX + 1) = _RDI->m_telemetry.m_probeInfo.m_data;
        _RBX[4] = *(float *)&_RDI->m_telemetry.m_probeInfo.m_dataSize;
        *((_BYTE *)_RBX + 20) = _RDI->m_telemetry.m_probeInfo.m_disabled;
        _RBX[6] = *(float *)&_RDI->m_telemetry.m_probeInfo.m_bandwidthDown;
        _RBX[7] = *(float *)&_RDI->m_telemetry.m_probeInfo.m_bandwidthUp;
        _RBX[8] = _RDI->m_telemetry.m_probeInfo.m_minLatency;
        _RBX[9] = *(float *)&_RDI->m_telemetry.m_probeInfo.m_numReplies;
        __asm
        {
          vmovups ymm0, ymmword ptr [rdi+228h]
          vmovups ymmword ptr [rbx+28h], ymm0
          vmovups ymm1, ymmword ptr [rdi+248h]
          vmovups ymmword ptr [rbx+48h], ymm1
        }
        _RBX[26] = *(float *)&_RDI->m_telemetry.m_probeInfo.m_numProbesReceived;
        _RBX[27] = *(float *)&_RDI->m_telemetry.m_probeInfo.m_numProbesExpected;
        _RBX[28] = *(float *)&_RDI->m_telemetry.m_probeInfo.m_numRetries;
        _RBX[29] = *(float *)&_RDI->m_telemetry.m_probeInfo.m_failureReason;
        *((_BYTE *)_RBX + 120) = _RDI->m_telemetry.m_result;
      }
      ++v6;
      _RBX += 160;
    }
    while ( v6 < n );
  }
}

/*
==============
bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>::decreaseCapacity
==============
*/
void bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>::decreaseCapacity(bdArray<bdQoSProbe::bdQoSProbeEntryWrapper> *this, const unsigned int decrease)
{
  unsigned int m_size; 
  unsigned int m_capacity; 
  bdQoSProbe::bdQoSProbeEntryWrapper *v5; 
  unsigned int v6; 
  bdQoSProbe::bdQoSProbeEntryWrapper *m_data; 
  __int64 v8; 

  m_size = this->m_size;
  m_capacity = this->m_capacity;
  if ( m_capacity > 4 * m_size )
  {
    v5 = NULL;
    if ( decrease > m_capacity - m_size )
      decrease = m_capacity - m_size;
    if ( decrease <= m_capacity >> 1 )
      decrease = m_capacity >> 1;
    v6 = m_capacity - decrease;
    this->m_capacity = v6;
    if ( v6 )
    {
      v5 = (bdQoSProbe::bdQoSProbeEntryWrapper *)bdMemory::allocate(640i64 * v6);
      bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>::copyConstructArrayArray(this, v5, this->m_data, this->m_size);
      m_size = this->m_size;
    }
    m_data = this->m_data;
    if ( m_size )
    {
      v8 = m_size;
      do
      {
        bdQoSProbe::bdQoSProbeEntryWrapper::~bdQoSProbeEntryWrapper(m_data++);
        --v8;
      }
      while ( v8 );
      m_data = this->m_data;
    }
    bdMemory::deallocate(m_data);
    this->m_data = v5;
  }
}

/*
==============
bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>::uninitializedCopy
==============
*/
bdQoSProbe::bdQoSProbeEntryWrapper *bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>::uninitializedCopy(bdArray<bdQoSProbe::bdQoSProbeEntryWrapper> *this, const bdArray<bdQoSProbe::bdQoSProbeEntryWrapper> *a)
{
  __int64 m_capacity; 
  bdQoSProbe::bdQoSProbeEntryWrapper *v5; 

  m_capacity = a->m_capacity;
  if ( !(_DWORD)m_capacity )
    return 0i64;
  v5 = (bdQoSProbe::bdQoSProbeEntryWrapper *)bdMemory::allocate(640 * m_capacity);
  bdArray<bdQoSProbe::bdQoSProbeEntryWrapper>::copyConstructArrayArray(this, v5, a->m_data, a->m_size);
  return v5;
}

/*
==============
bdArray<bdAddr>::operator=
==============
*/
void bdArray<bdAddr>::operator=(bdArray<bdAddr> *this, const bdArray<bdAddr> *a)
{
  unsigned int m_size; 
  unsigned int m_capacity; 
  bdAddr *v6; 
  __int64 v7; 
  unsigned int v8; 
  bdAddr *v9; 
  char *v10; 
  __int64 v11; 
  __int64 v12; 
  bdAddr *v13; 
  bdAddr *v23; 
  bdAddr *v24; 
  signed __int64 v25; 
  __int64 v26; 
  unsigned int v27; 
  unsigned int v37; 
  __int64 v38; 

  if ( this != a )
  {
    v38 = -2i64;
    m_size = a->m_size;
    m_capacity = this->m_capacity;
    if ( m_size <= m_capacity )
    {
      v12 = this->m_size;
      v13 = NULL;
      if ( m_size <= (unsigned int)v12 )
      {
        v27 = 0;
        if ( m_size )
        {
          _R12 = 0i64;
          do
          {
            bdHandleAssert(v27 < a->m_size, "rangeCheck(i)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdarray.inl", "bdArray<class bdAddr>::operator []", 0x70u, "bdArray<T>::operator[], rangecheck failed", v38);
            _RAX = a->m_data;
            __asm
            {
              vmovups ymm1, ymmword ptr [r12+rax]
              vmovups ymm2, ymmword ptr [r12+rax+20h]
              vmovups ymm3, ymmword ptr [r12+rax+40h]
              vmovups ymm4, ymmword ptr [r12+rax+60h]
              vmovups xmm5, xmmword ptr [r12+rax+80h]
              vmovsd  xmm0, qword ptr [r12+rax+90h]
            }
            _RAX = this->m_data;
            __asm
            {
              vmovups ymmword ptr [r12+rax], ymm1
              vmovups ymmword ptr [r12+rax+20h], ymm2
              vmovups ymmword ptr [r12+rax+40h], ymm3
              vmovups ymmword ptr [r12+rax+60h], ymm4
              vmovups xmmword ptr [r12+rax+80h], xmm5
              vmovsd  qword ptr [r12+rax+90h], xmm0
            }
            ++v27;
            _R12 += 152i64;
          }
          while ( v27 < m_size );
          m_capacity = this->m_capacity;
        }
        this->m_size = m_size;
        if ( m_capacity > 4 * m_size )
        {
          v37 = m_capacity - (m_capacity >> 1);
          this->m_capacity = v37;
          if ( v37 )
          {
            v13 = (bdAddr *)bdMemory::allocate(152i64 * v37);
            bdArray<bdAddr>::copyConstructArrayArray(this, v13, this->m_data, this->m_size);
          }
          bdMemory::deallocate(this->m_data);
          this->m_data = v13;
        }
      }
      else
      {
        if ( (_DWORD)v12 )
        {
          do
          {
            bdHandleAssert((unsigned int)v13 < a->m_size, "rangeCheck(i)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdcore\\bdcontainers\\bdarray.inl", "bdArray<class bdAddr>::operator []", 0x70u, "bdArray<T>::operator[], rangecheck failed", v38);
            _RCX = 152i64 * (unsigned int)v13;
            _RAX = a->m_data;
            __asm
            {
              vmovups ymm1, ymmword ptr [rcx+rax]
              vmovups ymm2, ymmword ptr [rcx+rax+20h]
              vmovups ymm3, ymmword ptr [rcx+rax+40h]
              vmovups ymm4, ymmword ptr [rcx+rax+60h]
              vmovups xmm5, xmmword ptr [rcx+rax+80h]
              vmovsd  xmm0, qword ptr [rcx+rax+90h]
            }
            _RAX = this->m_data;
            __asm
            {
              vmovups ymmword ptr [rcx+rax], ymm1
              vmovups ymmword ptr [rcx+rax+20h], ymm2
              vmovups ymmword ptr [rcx+rax+40h], ymm3
              vmovups ymmword ptr [rcx+rax+60h], ymm4
              vmovups xmmword ptr [rcx+rax+80h], xmm5
              vmovsd  qword ptr [rcx+rax+90h], xmm0
            }
            LODWORD(v13) = (_DWORD)v13 + 1;
            v12 = this->m_size;
          }
          while ( (unsigned int)v13 < (unsigned int)v12 );
        }
        v23 = &a->m_data[v12];
        v24 = &this->m_data[v12];
        if ( m_size != (_DWORD)v12 )
        {
          v25 = (char *)v23 - (char *)v24;
          v26 = m_size - (unsigned int)v12;
          do
          {
            if ( v24 )
              bdAddr::bdAddr(v24, (bdAddr *)((char *)v24 + v25));
            ++v24;
            --v26;
          }
          while ( v26 );
        }
        this->m_size = m_size;
      }
    }
    else
    {
      bdMemory::deallocate(this->m_data);
      v6 = NULL;
      this->m_data = NULL;
      *(_QWORD *)&this->m_capacity = 0i64;
      v7 = a->m_capacity;
      if ( (_DWORD)v7 )
      {
        v6 = (bdAddr *)bdMemory::allocate(152 * v7);
        v8 = a->m_size;
        if ( v8 )
        {
          v9 = v6;
          v10 = (char *)((char *)a->m_data - (char *)v6);
          v11 = v8;
          do
          {
            if ( v9 )
              bdAddr::bdAddr(v9, (const bdAddr *)((char *)v9 + (_QWORD)v10));
            ++v9;
            --v11;
          }
          while ( v11 );
        }
      }
      this->m_data = v6;
      this->m_capacity = a->m_capacity;
      this->m_size = m_size;
    }
  }
}

/*
==============
bdArray<bdAddr>::copyConstructArrayArray
==============
*/
void bdArray<bdAddr>::copyConstructArrayArray(bdArray<bdAddr> *this, bdAddr *dest, const bdAddr *src, const unsigned int n)
{
  bdAddr *v4; 
  signed __int64 v5; 
  __int64 v6; 

  if ( n )
  {
    v4 = dest;
    v5 = (char *)src - (char *)dest;
    v6 = n;
    do
    {
      if ( v4 )
        bdAddr::bdAddr(v4, (bdAddr *)((char *)v4 + v5));
      ++v4;
      --v6;
    }
    while ( v6 );
  }
}

