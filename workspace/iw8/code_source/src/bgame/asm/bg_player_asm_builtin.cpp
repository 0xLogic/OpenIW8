/*
==============
PlayerASM_Transition_ReturnTrue
==============
*/

int __fastcall PlayerASM_Transition_ReturnTrue(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_Transition_ReturnTrue@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsWalking
==============
*/

int __fastcall PlayerASM_IsWalking(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsWalking@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsMovingBackwardMoveType
==============
*/

int __fastcall PlayerASM_IsMovingBackwardMoveType(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsMovingBackwardMoveType@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_SkipHipFlipBackwardToForwardCrouch
==============
*/

int __fastcall PlayerASM_SkipHipFlipBackwardToForwardCrouch(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_SkipHipFlipBackwardToForwardCrouch@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsTransitionFromNoUpdate
==============
*/

int __fastcall PlayerASM_IsTransitionFromNoUpdate(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsTransitionFromNoUpdate@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_ClearAnimState
==============
*/

int __fastcall PlayerASM_ClearAnimState(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_ClearAnimState@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsAnimationTimerBiggerThan
==============
*/

int __fastcall PlayerASM_IsAnimationTimerBiggerThan(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsAnimationTimerBiggerThan@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsStopBackwardTransition
==============
*/

int __fastcall PlayerASM_IsStopBackwardTransition(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsStopBackwardTransition@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_ChooseAnim
==============
*/

int __fastcall PlayerASM_ChooseAnim(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_ChooseAnim@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsAnimationTimerLessThan
==============
*/

int __fastcall PlayerASM_IsAnimationTimerLessThan(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsAnimationTimerLessThan@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_PlayAnimState
==============
*/

int __fastcall PlayerASM_PlayAnimState(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_PlayAnimState@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_Transition_ReturnFalse
==============
*/

int __fastcall PlayerASM_Transition_ReturnFalse(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_Transition_ReturnFalse@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsStickMovingBackward
==============
*/

int __fastcall PlayerASM_IsStickMovingBackward(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsStickMovingBackward@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsTurningRight
==============
*/

int __fastcall PlayerASM_IsTurningRight(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsTurningRight@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsTransitionReverse
==============
*/

int __fastcall PlayerASM_IsTransitionReverse(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsTransitionReverse@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsStopForwardTransition
==============
*/

int __fastcall PlayerASM_IsStopForwardTransition(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsStopForwardTransition@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsTransitionFrom
==============
*/

int __fastcall PlayerASM_IsTransitionFrom(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsTransitionFrom@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsMovingMoveType
==============
*/

int __fastcall PlayerASM_IsMovingMoveType(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsMovingMoveType@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsMoving
==============
*/

int __fastcall PlayerASM_IsMoving(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsMoving@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_GetBuiltinFunc
==============
*/

int (__fastcall *__fastcall PlayerASM_GetBuiltinFunc(int i))(const PlayerASM_Context *, const PlayerASM_Parameters *)
{
  return ?PlayerASM_GetBuiltinFunc@@YAP6AHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@ZH@Z(i);
}

/*
==============
PlayerASM_ChooseRandomAnimInternal
==============
*/

unsigned int __fastcall PlayerASM_ChooseRandomAnimInternal(const PlayerASM_Context *context, BgPlayer_Asm *pAsm, int entNum, const scr_string_t asmName, const scr_string_t stateName)
{
  return ?PlayerASM_ChooseRandomAnimInternal@@YAIPEBUPlayerASM_Context@@PEAVBgPlayer_Asm@@HW4scr_string_t@@2@Z(context, pAsm, entNum, asmName, stateName);
}

/*
==============
PlayerASM_UpdateAnimChoice
==============
*/

int __fastcall PlayerASM_UpdateAnimChoice(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_UpdateAnimChoice@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsMovingForward
==============
*/

int __fastcall PlayerASM_IsMovingForward(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsMovingForward@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_PlayPredictedAnim
==============
*/

int __fastcall PlayerASM_PlayPredictedAnim(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_PlayPredictedAnim@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_EventFired
==============
*/

int __fastcall PlayerASM_EventFired(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_EventFired@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsRunning
==============
*/

int __fastcall PlayerASM_IsRunning(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsRunning@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsStopSpeedGreaterThanThreshold
==============
*/

int __fastcall PlayerASM_IsStopSpeedGreaterThanThreshold(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsStopSpeedGreaterThanThreshold@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsMovingForwardMoveType
==============
*/

int __fastcall PlayerASM_IsMovingForwardMoveType(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsMovingForwardMoveType@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsStopping
==============
*/

int __fastcall PlayerASM_IsStopping(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsStopping@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_SkipHipFlipForwardToBackwardCrouch
==============
*/

int __fastcall PlayerASM_SkipHipFlipForwardToBackwardCrouch(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_SkipHipFlipForwardToBackwardCrouch@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsInAir
==============
*/

int __fastcall PlayerASM_IsInAir(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsInAir@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_AnimationFinished
==============
*/

int __fastcall PlayerASM_AnimationFinished(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_AnimationFinished@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsMovingBackward
==============
*/

int __fastcall PlayerASM_IsMovingBackward(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsMovingBackward@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_GetAnim
==============
*/

int __fastcall PlayerASM_GetAnim(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_GetAnim@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_ChooseRandomAnim
==============
*/

int __fastcall PlayerASM_ChooseRandomAnim(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_ChooseRandomAnim@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsForwardToBackTransition
==============
*/

int __fastcall PlayerASM_IsForwardToBackTransition(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsForwardToBackTransition@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsTurning
==============
*/

int __fastcall PlayerASM_IsTurning(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsTurning@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsStickMovingForward
==============
*/

int __fastcall PlayerASM_IsStickMovingForward(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsStickMovingForward@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsTurningLeft
==============
*/

int __fastcall PlayerASM_IsTurningLeft(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsTurningLeft@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_LoopAnimState
==============
*/

int __fastcall PlayerASM_LoopAnimState(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_LoopAnimState@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_IsBackToForwardTransition
==============
*/

int __fastcall PlayerASM_IsBackToForwardTransition(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return ?PlayerASM_IsBackToForwardTransition@@YAHPEBUPlayerASM_Context@@PEBUPlayerASM_Parameters@@@Z(context, parameters);
}

/*
==============
PlayerASM_Transition_ReturnTrue
==============
*/
__int64 PlayerASM_Transition_ReturnTrue(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return 1i64;
}

/*
==============
PlayerASM_Transition_ReturnFalse
==============
*/
__int64 PlayerASM_Transition_ReturnFalse(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return 0i64;
}

/*
==============
PlayerASM_IsInAir
==============
*/
int PlayerASM_IsInAir(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  const playerState_s *PlayerState; 
  bool v5; 
  entityState_t *EntityState; 

  PlayerState = BG_PlayerASM_GetPlayerState(context);
  if ( PlayerState )
  {
    v5 = BG_IsInAir(PlayerState, 0);
  }
  else
  {
    EntityState = BG_PlayerASM_GetEntityState(context);
    if ( !EntityState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 67, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
      __debugbreak();
    v5 = EntityState->groundEntityNum == 2047;
  }
  return PlayerASM_TestBool(v5, context, parameters);
}

/*
==============
PlayerASM_IsWalking
==============
*/
int PlayerASM_IsWalking(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  characterInfo_t *ci; 
  unsigned int *v5; 
  int v6; 
  signed __int64 v7; 
  __int64 *i; 
  bool v9; 
  __int64 v11; 
  __int64 v12; 
  __int64 v13; 
  __int64 v14; 

  ci = parameters->ci;
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 82, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  v11 = 1008i64;
  v12 = 0i64;
  v13 = 0i64;
  v14 = 0i64;
  v5 = ci->clientConditions[3];
  if ( !v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_animation_mp.h", 1041, ASSERT_TYPE_ASSERT, "(array)", (const char *)&queryFormat, "array", v11, v12, v13, v14) )
    __debugbreak();
  v6 = 0;
  v7 = (char *)v5 - (char *)&v11;
  for ( i = &v11; (*(_DWORD *)((_BYTE *)i + v7) & *(_DWORD *)i) == 0; i = (__int64 *)((char *)i + 4) )
  {
    if ( (unsigned int)++v6 >= 8 )
    {
      v9 = 0;
      return PlayerASM_TestBool(v9, context, parameters);
    }
  }
  v9 = 1;
  return PlayerASM_TestBool(v9, context, parameters);
}

/*
==============
PlayerASM_IsRunning
==============
*/
int PlayerASM_IsRunning(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  characterInfo_t *ci; 
  unsigned int *v5; 
  int v6; 
  signed __int64 v7; 
  __int64 *i; 
  bool v9; 
  __int64 v11; 
  __int64 v12; 
  __int64 v13; 
  __int64 v14; 

  ci = parameters->ci;
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 104, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  v11 = 15360i64;
  v12 = 0i64;
  v13 = 0i64;
  v14 = 0i64;
  v5 = ci->clientConditions[3];
  if ( !v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_animation_mp.h", 1041, ASSERT_TYPE_ASSERT, "(array)", (const char *)&queryFormat, "array", v11, v12, v13, v14) )
    __debugbreak();
  v6 = 0;
  v7 = (char *)v5 - (char *)&v11;
  for ( i = &v11; (*(_DWORD *)((_BYTE *)i + v7) & *(_DWORD *)i) == 0; i = (__int64 *)((char *)i + 4) )
  {
    if ( (unsigned int)++v6 >= 8 )
    {
      v9 = 0;
      return PlayerASM_TestBool(v9, context, parameters);
    }
  }
  v9 = 1;
  return PlayerASM_TestBool(v9, context, parameters);
}

/*
==============
PlayerASM_IsMoving
==============
*/
_BOOL8 PlayerASM_IsMoving(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  characterInfo_t *ci; 

  ci = parameters->ci;
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 122, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  return ci->speed > 0;
}

/*
==============
PlayerASM_IsMovingForward
==============
*/
_BOOL8 PlayerASM_IsMovingForward(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  characterInfo_t *ci; 
  characterInfo_t *v4; 

  ci = parameters->ci;
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 674, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  v4 = parameters->ci;
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 122, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  return v4->speed > 0 && PlayerASM_IsForwardAngle(ci->playerASMLocomotion.strafeAngle);
}

/*
==============
PlayerASM_IsMovingBackward
==============
*/
_BOOL8 PlayerASM_IsMovingBackward(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  characterInfo_t *ci; 
  characterInfo_t *v4; 

  ci = parameters->ci;
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 689, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  v4 = parameters->ci;
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 122, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  return v4->speed > 0 && PlayerASM_IsBackwardAngle(ci->playerASMLocomotion.strafeAngle);
}

/*
==============
PlayerASM_IsStopping
==============
*/
_BOOL8 PlayerASM_IsStopping(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  characterInfo_t *ci; 

  ci = parameters->ci;
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 131, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  return !ci->speed || (float)ci->playerASMLocomotion.cmdBuffer[0].length == 0.0 && (float)ci->playerASMLocomotion.cmdBuffer[1].length == 0.0;
}

/*
==============
PlayerASM_IsTurning
==============
*/
__int64 PlayerASM_IsTurning(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  playerState_s *PlayerState; 
  characterInfo_t *ci; 

  PlayerState = BG_PlayerASM_GetPlayerState(context);
  if ( PlayerState )
    return (unsigned int)PlayerState->turnRemaining;
  ci = parameters->ci;
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 149, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  return ci->legs.yawing != 0;
}

/*
==============
PlayerASM_IsTurningLeft
==============
*/
_BOOL8 PlayerASM_IsTurningLeft(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  playerState_s *PlayerState; 
  characterInfo_t *ci; 

  PlayerState = BG_PlayerASM_GetPlayerState(context);
  if ( PlayerState )
    return PlayerState->turnRemaining && PlayerState->turnDirection;
  ci = parameters->ci;
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 169, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  return ci->deltaLerpMoveDir > 0.001;
}

/*
==============
PlayerASM_IsTurningRight
==============
*/
_BOOL8 PlayerASM_IsTurningRight(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  playerState_s *PlayerState; 
  characterInfo_t *ci; 

  PlayerState = BG_PlayerASM_GetPlayerState(context);
  if ( PlayerState )
    return PlayerState->turnRemaining && !PlayerState->turnDirection;
  ci = parameters->ci;
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 189, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  return ci->deltaLerpMoveDir < -0.001;
}

/*
==============
PlayerASM_IsTransitionFrom
==============
*/
int PlayerASM_IsTransitionFrom(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return PlayerASM_IsTransitionFromInternal(context, parameters, 1);
}

/*
==============
PlayerASM_IsTransitionFromNoUpdate
==============
*/
int PlayerASM_IsTransitionFromNoUpdate(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return PlayerASM_IsTransitionFromInternal(context, parameters, 0);
}

/*
==============
PlayerASM_EventFired
==============
*/
_BOOL8 PlayerASM_EventFired(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  PlayerASM_Instance *InstanceBySlot; 
  scr_string_t StringParam; 
  unsigned __int8 m_NumEvents; 

  InstanceBySlot = BgPlayer_Asm::GetInstanceBySlot(parameters->pAsm, context, (const PlayerASM_AnimSlot)(unsigned __int8)parameters->slot[0]);
  if ( !InstanceBySlot && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 201, ASSERT_TYPE_ASSERT, "(pInst)", (const char *)&queryFormat, "pInst") )
    __debugbreak();
  StringParam = PlayerASM_Builtin_GetStringParam(0, parameters->pParams, parameters->numParams);
  if ( !StringParam && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 204, ASSERT_TYPE_ASSERT, "(eventName != ( static_cast< scr_string_t >( 0 ) ))", (const char *)&queryFormat, "eventName != NULL_SCR_STRING") )
    __debugbreak();
  m_NumEvents = InstanceBySlot->m_NumEvents;
  return m_NumEvents && Common_Asm::Utils::EventFired(InstanceBySlot, m_NumEvents, StringParam);
}

/*
==============
PlayerASM_ChooseAnim
==============
*/
int PlayerASM_ChooseAnim(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  int numParams; 
  scr_string_t StringParam; 

  numParams = parameters->numParams;
  if ( !numParams )
    return PlayerASM_ChooseRandomAnimInternal(context, parameters->pAsm, parameters->entNum, (const scr_string_t)parameters->asmName, (const scr_string_t)parameters->stateName);
  StringParam = PlayerASM_Builtin_GetStringParam(0, parameters->pParams, numParams);
  return BG_PlayerASM_LookupAnimFromAlias(context, parameters->pAsm, parameters->entNum, (const scr_string_t)parameters->stateName, StringParam);
}

/*
==============
PlayerASM_UpdateAnimChoice
==============
*/
__int64 PlayerASM_UpdateAnimChoice(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  int entryIndex; 
  char v5; 
  int gameTime; 
  PlayerASM_AnimSlot slot; 

  if ( PlayerASM_IsAnimChoiceUpdateNeeded(context, parameters->asmName, parameters->entNum, (const PlayerASM_AnimSlot)(unsigned __int8)parameters->slot[0]) )
  {
    entryIndex = PlayerASM_GetAnim(context, parameters);
    v5 = parameters->slot[0];
    gameTime = parameters->pAsm->GetGameTime(parameters->pAsm);
    LOBYTE(slot) = v5;
    BG_PlayerASM_SetAnimState(context, parameters->pAsm, parameters->entNum, (const scr_string_t)parameters->asmName, parameters->stateName, entryIndex, gameTime, 1.0, slot);
  }
  return 0i64;
}

/*
==============
PlayerASM_PlayAnimState
==============
*/
__int64 PlayerASM_PlayAnimState(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  int entryIndex; 
  char v5; 
  int gameTime; 
  PlayerASM_AnimSlot slot; 

  entryIndex = PlayerASM_GetAnim(context, parameters);
  v5 = parameters->slot[0];
  gameTime = parameters->pAsm->GetGameTime(parameters->pAsm);
  LOBYTE(slot) = v5;
  BG_PlayerASM_SetAnimState(context, parameters->pAsm, parameters->entNum, (const scr_string_t)parameters->asmName, parameters->stateName, entryIndex, gameTime, 1.0, slot);
  return 0i64;
}

/*
==============
PlayerASM_LoopAnimState
==============
*/
__int64 PlayerASM_LoopAnimState(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  PlayerASM_Instance *InstanceBySlot; 
  scr_string_t StringParam; 
  unsigned __int8 m_NumEvents; 
  BgStatic *ActiveStatics; 
  characterInfo_t *CharacterInfo; 
  int entryIndex; 
  char v10; 
  int gameTime; 
  PlayerASM_AnimSlot slot; 
  PlayerASM_Parameters parametersa; 

  InstanceBySlot = BgPlayer_Asm::GetInstanceBySlot(parameters->pAsm, context, (const PlayerASM_AnimSlot)(unsigned __int8)parameters->slot[0]);
  if ( !InstanceBySlot && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 201, ASSERT_TYPE_ASSERT, "(pInst)", (const char *)&queryFormat, "pInst") )
    __debugbreak();
  StringParam = PlayerASM_Builtin_GetStringParam(0, parameters->pParams, parameters->numParams);
  if ( !StringParam && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 204, ASSERT_TYPE_ASSERT, "(eventName != ( static_cast< scr_string_t >( 0 ) ))", (const char *)&queryFormat, "eventName != NULL_SCR_STRING") )
    __debugbreak();
  m_NumEvents = InstanceBySlot->m_NumEvents;
  if ( m_NumEvents && Common_Asm::Utils::EventFired(InstanceBySlot, m_NumEvents, StringParam) )
  {
    ActiveStatics = BgStatic::GetActiveStatics();
    CharacterInfo = BG_GetCharacterInfo(ActiveStatics, parameters->entNum);
    if ( !CharacterInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 530, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
      __debugbreak();
    parametersa.pAsm = parameters->pAsm;
    parametersa.entNum = parameters->entNum;
    parametersa.asmName = parameters->asmName;
    *(_QWORD *)&parametersa.noteName = 0i64;
    parametersa.pParams = NULL;
    parametersa.slot[0] = parameters->slot[0];
    parametersa.stateName = parameters->stateName;
    parametersa.ci = CharacterInfo;
    entryIndex = PlayerASM_GetAnim(context, &parametersa);
    v10 = parameters->slot[0];
    gameTime = parameters->pAsm->GetGameTime(parameters->pAsm);
    LOBYTE(slot) = v10;
    BG_PlayerASM_SetAnimState(context, parameters->pAsm, parameters->entNum, (const scr_string_t)parameters->asmName, parameters->stateName, entryIndex, gameTime, 1.0, slot);
  }
  return 0i64;
}

/*
==============
PlayerASM_AnimationFinished
==============
*/
_BOOL8 PlayerASM_AnimationFinished(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  PlayerASM_Instance *InstanceBySlot; 
  unsigned __int8 m_NumEvents; 

  InstanceBySlot = BgPlayer_Asm::GetInstanceBySlot(parameters->pAsm, context, (const PlayerASM_AnimSlot)(unsigned __int8)parameters->slot[0]);
  if ( !InstanceBySlot && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 301, ASSERT_TYPE_ASSERT, "(pInst)", (const char *)&queryFormat, "pInst") )
    __debugbreak();
  m_NumEvents = InstanceBySlot->m_NumEvents;
  return m_NumEvents && Common_Asm::Utils::EventFired(InstanceBySlot, m_NumEvents, (const scr_string_t)scr_const.end);
}

/*
==============
PlayerASM_ClearAnimState
==============
*/
__int64 PlayerASM_ClearAnimState(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  BG_PlayerASM_ClearState(context, (const PlayerASM_AnimSlot)(unsigned __int8)parameters->slot[0]);
  return 0i64;
}

/*
==============
PlayerASM_IsForwardToBackTransition
==============
*/
__int64 PlayerASM_IsForwardToBackTransition(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  characterInfo_t *ci; 
  const dvar_t *v3; 
  float value; 
  const dvar_t *v5; 
  float v6; 
  const dvar_t *v7; 
  float strafeAngle; 
  float v9; 

  ci = parameters->ci;
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 705, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  v3 = DCONST_DVARFLT_playerasm_loco_transition_ccw_angle;
  if ( !DCONST_DVARFLT_playerasm_loco_transition_ccw_angle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "playerasm_loco_transition_ccw_angle") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v3);
  value = v3->current.value;
  v5 = DCONST_DVARFLT_playerasm_loco_transition_cw_angle;
  if ( !DCONST_DVARFLT_playerasm_loco_transition_cw_angle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "playerasm_loco_transition_cw_angle") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v5);
  v6 = v5->current.value;
  v7 = DCONST_DVARFLT_playerasm_loco_transition_overlap_range;
  if ( !DCONST_DVARFLT_playerasm_loco_transition_overlap_range && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "playerasm_loco_transition_overlap_range") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v7);
  strafeAngle = ci->playerASMLocomotion.strafeAngle;
  v9 = v7->current.value;
  if ( strafeAngle >= 0.0 )
    goto LABEL_16;
  if ( strafeAngle < (float)(v6 - v9) )
    return 1i64;
  if ( strafeAngle >= 0.0 )
  {
LABEL_16:
    if ( strafeAngle > (float)(v9 + value) )
      return 1i64;
  }
  return 0i64;
}

/*
==============
PlayerASM_IsBackToForwardTransition
==============
*/
__int64 PlayerASM_IsBackToForwardTransition(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  characterInfo_t *ci; 
  const dvar_t *v3; 
  float value; 
  const dvar_t *v5; 
  float v6; 
  const dvar_t *v7; 
  float strafeAngle; 
  float v9; 

  ci = parameters->ci;
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 728, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  v3 = DCONST_DVARFLT_playerasm_loco_transition_ccw_angle;
  if ( !DCONST_DVARFLT_playerasm_loco_transition_ccw_angle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "playerasm_loco_transition_ccw_angle") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v3);
  value = v3->current.value;
  v5 = DCONST_DVARFLT_playerasm_loco_transition_cw_angle;
  if ( !DCONST_DVARFLT_playerasm_loco_transition_cw_angle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "playerasm_loco_transition_cw_angle") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v5);
  v6 = v5->current.value;
  v7 = DCONST_DVARFLT_playerasm_loco_transition_overlap_range;
  if ( !DCONST_DVARFLT_playerasm_loco_transition_overlap_range && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "playerasm_loco_transition_overlap_range") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v7);
  strafeAngle = ci->playerASMLocomotion.strafeAngle;
  v9 = v7->current.value;
  if ( strafeAngle >= 0.0 )
    goto LABEL_16;
  if ( strafeAngle > (float)(v9 + v6) )
    return 1i64;
  if ( strafeAngle >= 0.0 )
  {
LABEL_16:
    if ( strafeAngle < (float)(value - v9) )
      return 1i64;
  }
  return 0i64;
}

/*
==============
PlayerASM_IsTransitionReverse
==============
*/
_BOOL8 PlayerASM_IsTransitionReverse(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  characterInfo_t *ci; 
  int v5; 
  const dvar_t *v6; 
  const char *v7; 
  float value; 
  const dvar_t *v9; 
  float v10; 
  playerASMCmdBufferEntry *v11; 
  __int64 v12; 
  int time; 
  double v14; 

  ci = parameters->ci;
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 895, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  v5 = context->const_ps->serverTime - 250;
  if ( v5 < 0 )
    v5 = 0;
  if ( ci->clientConditions[4][0] == 1 )
  {
    v6 = DCONST_DVARFLT_playerasm_loco_reverse_min_strength_crouch;
    if ( DCONST_DVARFLT_playerasm_loco_reverse_min_strength_crouch )
      goto LABEL_13;
    v7 = "playerasm_loco_reverse_min_strength_crouch";
  }
  else
  {
    v6 = DCONST_DVARFLT_playerasm_loco_reverse_min_strength;
    if ( DCONST_DVARFLT_playerasm_loco_reverse_min_strength )
      goto LABEL_13;
    v7 = "playerasm_loco_reverse_min_strength";
  }
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", v7) )
    __debugbreak();
LABEL_13:
  Dvar_CheckFrontendServerThread(v6);
  value = v6->current.value;
  v9 = DCONST_DVARFLT_playerasm_loco_reverse_angle_delta;
  if ( !DCONST_DVARFLT_playerasm_loco_reverse_angle_delta && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "playerasm_loco_reverse_angle_delta") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v9);
  v10 = v9->current.value;
  if ( !ci->playerASMLocomotion.cmdBuffer[0].time )
    return 1i64;
  if ( ci->playerASMLocomotion.cmdBuffer[1].time > 0 )
  {
    v11 = &ci->playerASMLocomotion.cmdBuffer[1];
    v12 = 1i64;
    time = ci->playerASMLocomotion.cmdBuffer[1].time;
    while ( time >= v5 && v12 < 6 )
    {
      if ( (float)ci->playerASMLocomotion.cmdBuffer[0].length >= value && (float)v11->length >= value )
      {
        v14 = AngleDelta((float)ci->playerASMLocomotion.cmdBuffer[0].angle, (float)v11->angle);
        if ( COERCE_FLOAT(LODWORD(v14) & _xmm) > v10 )
          return !PlayerASM_ET_IsAnyStanceTransition(context, parameters);
      }
      v11 = &ci->playerASMLocomotion.cmdBuffer[++v12];
      time = ci->playerASMLocomotion.cmdBuffer[v12].time;
      if ( time <= 0 )
        return 0i64;
    }
  }
  return 0i64;
}

/*
==============
PlayerASM_IsStickMovingForward
==============
*/
_BOOL8 PlayerASM_IsStickMovingForward(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  characterInfo_t *ci; 
  unsigned __int16 angle; 

  ci = parameters->ci;
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 816, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  angle = ci->playerASMLocomotion.cmdBuffer[0].angle;
  if ( !angle )
    return 0i64;
  if ( !ci->playerASMLocomotion.cmdBuffer[0].length )
    return 0i64;
  _XMM0 = 0i64;
  __asm { vroundss xmm4, xmm0, xmm2, 1 }
  return PlayerASM_IsForwardAngle((float)((float)((float)(_mm_cvtepi32_ps((__m128i)angle).m128_f32[0] * 0.0027777778) - *(float *)&_XMM4) * 360.0) - 90.0);
}

/*
==============
PlayerASM_IsStickMovingBackward
==============
*/
_BOOL8 PlayerASM_IsStickMovingBackward(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  characterInfo_t *ci; 
  unsigned __int16 angle; 

  ci = parameters->ci;
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 796, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  angle = ci->playerASMLocomotion.cmdBuffer[0].angle;
  if ( !angle )
    return 0i64;
  if ( !ci->playerASMLocomotion.cmdBuffer[0].length )
    return 0i64;
  _XMM0 = 0i64;
  __asm { vroundss xmm4, xmm0, xmm2, 1 }
  return PlayerASM_IsBackwardAngle((float)((float)((float)(_mm_cvtepi32_ps((__m128i)angle).m128_f32[0] * 0.0027777778) - *(float *)&_XMM4) * 360.0) - 90.0);
}

/*
==============
PlayerASM_IsStopForwardTransition
==============
*/
_BOOL8 PlayerASM_IsStopForwardTransition(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  characterInfo_t *ci; 
  float strafeAngle; 
  _BOOL8 result; 

  ci = parameters->ci;
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 946, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  result = 0;
  if ( ci->speed > 0 )
  {
    strafeAngle = ci->playerASMLocomotion.strafeAngle;
    if ( strafeAngle < 135.0 && strafeAngle > -134.0 )
      return 1;
  }
  return result;
}

/*
==============
PlayerASM_IsStopBackwardTransition
==============
*/
_BOOL8 PlayerASM_IsStopBackwardTransition(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  characterInfo_t *ci; 
  float strafeAngle; 
  _BOOL8 result; 

  ci = parameters->ci;
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 962, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  result = 0;
  if ( ci->speed > 0 )
  {
    strafeAngle = ci->playerASMLocomotion.strafeAngle;
    if ( strafeAngle >= 135.0 || strafeAngle <= -135.0 )
      return 1;
  }
  return result;
}

/*
==============
PlayerASM_SkipHipFlipForwardToBackwardCrouch
==============
*/
int PlayerASM_SkipHipFlipForwardToBackwardCrouch(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  characterInfo_t *ci; 
  const dvar_t *v3; 
  float value; 
  const dvar_t *v5; 
  float v6; 
  int result; 
  float strafeAngle; 

  ci = parameters->ci;
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 751, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  v3 = DCONST_DVARFLT_playerasm_loco_transition_ccw_angle;
  if ( !DCONST_DVARFLT_playerasm_loco_transition_ccw_angle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "playerasm_loco_transition_ccw_angle") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v3);
  value = v3->current.value;
  v5 = DCONST_DVARFLT_playerasm_loco_transition_overlap_range;
  if ( !DCONST_DVARFLT_playerasm_loco_transition_overlap_range && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "playerasm_loco_transition_overlap_range") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v5);
  v6 = v5->current.value;
  result = BG_GetConditionValue(ci, 4);
  if ( result != 1 )
    return 0;
  strafeAngle = ci->playerASMLocomotion.strafeAngle;
  if ( strafeAngle < 0.0 || strafeAngle <= (float)(v6 + value) )
    return 0;
  return result;
}

/*
==============
PlayerASM_SkipHipFlipBackwardToForwardCrouch
==============
*/
int PlayerASM_SkipHipFlipBackwardToForwardCrouch(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  characterInfo_t *ci; 
  const dvar_t *v3; 
  float value; 
  const dvar_t *v5; 
  float v6; 
  int result; 
  float strafeAngle; 

  ci = parameters->ci;
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 773, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  v3 = DCONST_DVARFLT_playerasm_loco_transition_ccw_angle;
  if ( !DCONST_DVARFLT_playerasm_loco_transition_ccw_angle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "playerasm_loco_transition_ccw_angle") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v3);
  value = v3->current.value;
  v5 = DCONST_DVARFLT_playerasm_loco_transition_overlap_range;
  if ( !DCONST_DVARFLT_playerasm_loco_transition_overlap_range && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "playerasm_loco_transition_overlap_range") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v5);
  v6 = v5->current.value;
  result = BG_GetConditionValue(ci, 4);
  if ( result != 1 )
    return 0;
  strafeAngle = ci->playerASMLocomotion.strafeAngle;
  if ( strafeAngle < 0.0 || strafeAngle >= (float)(value - v6) )
    return 0;
  return result;
}

/*
==============
PlayerASM_IsStopSpeedGreaterThanThreshold
==============
*/
_BOOL8 PlayerASM_IsStopSpeedGreaterThanThreshold(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  characterInfo_t *ci; 
  const dvar_t *v3; 

  ci = parameters->ci;
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 983, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  v3 = DCONST_DVARFLT_playerasm_loco_stop_speed_threshold;
  if ( !DCONST_DVARFLT_playerasm_loco_stop_speed_threshold && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "playerasm_loco_stop_speed_threshold") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v3);
  return v3->current.value < ci->playerASMLocomotion.stopSpeed;
}

/*
==============
PlayerASM_IsMovingForwardMoveType
==============
*/
int PlayerASM_IsMovingForwardMoveType(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  characterInfo_t *ci; 
  unsigned int *v5; 
  int v6; 
  signed __int64 v7; 
  __int64 *i; 
  bool v9; 
  __int64 v11; 
  __int64 v12; 
  __int64 v13; 
  __int64 v14; 

  ci = parameters->ci;
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 562, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  v11 = 922960i64;
  v12 = 0i64;
  v13 = 0i64;
  v14 = 0i64;
  v5 = ci->clientConditions[3];
  if ( !v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_animation_mp.h", 1041, ASSERT_TYPE_ASSERT, "(array)", (const char *)&queryFormat, "array", v11, v12, v13, v14) )
    __debugbreak();
  v6 = 0;
  v7 = (char *)v5 - (char *)&v11;
  for ( i = &v11; (*(_DWORD *)((_BYTE *)i + v7) & *(_DWORD *)i) == 0; i = (__int64 *)((char *)i + 4) )
  {
    if ( (unsigned int)++v6 >= 8 )
    {
      v9 = 0;
      return PlayerASM_TestBool(v9, context, parameters);
    }
  }
  v9 = 1;
  return PlayerASM_TestBool(v9, context, parameters);
}

/*
==============
PlayerASM_IsMovingBackwardMoveType
==============
*/
int PlayerASM_IsMovingBackwardMoveType(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  characterInfo_t *ci; 
  unsigned int *v5; 
  int v6; 
  signed __int64 v7; 
  __int64 *i; 
  bool v9; 
  __int64 v11; 
  __int64 v12; 
  __int64 v13; 
  __int64 v14; 

  ci = parameters->ci;
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 586, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  v11 = 10912i64;
  v12 = 0i64;
  v13 = 0i64;
  v14 = 0i64;
  v5 = ci->clientConditions[3];
  if ( !v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_animation_mp.h", 1041, ASSERT_TYPE_ASSERT, "(array)", (const char *)&queryFormat, "array", v11, v12, v13, v14) )
    __debugbreak();
  v6 = 0;
  v7 = (char *)v5 - (char *)&v11;
  for ( i = &v11; (*(_DWORD *)((_BYTE *)i + v7) & *(_DWORD *)i) == 0; i = (__int64 *)((char *)i + 4) )
  {
    if ( (unsigned int)++v6 >= 8 )
    {
      v9 = 0;
      return PlayerASM_TestBool(v9, context, parameters);
    }
  }
  v9 = 1;
  return PlayerASM_TestBool(v9, context, parameters);
}

/*
==============
PlayerASM_IsMovingMoveType
==============
*/
int PlayerASM_IsMovingMoveType(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  characterInfo_t *ci; 
  unsigned int *v5; 
  int v6; 
  signed __int64 v7; 
  __int64 *i; 
  bool v9; 
  __int64 v11; 
  __int64 v12; 
  __int64 v13; 
  __int64 v14; 

  ci = parameters->ci;
  if ( !ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 607, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  v11 = 933872i64;
  v12 = 0i64;
  v13 = 0i64;
  v14 = 0i64;
  v5 = ci->clientConditions[3];
  if ( !v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_animation_mp.h", 1041, ASSERT_TYPE_ASSERT, "(array)", (const char *)&queryFormat, "array", v11, v12, v13, v14) )
    __debugbreak();
  v6 = 0;
  v7 = (char *)v5 - (char *)&v11;
  for ( i = &v11; (*(_DWORD *)((_BYTE *)i + v7) & *(_DWORD *)i) == 0; i = (__int64 *)((char *)i + 4) )
  {
    if ( (unsigned int)++v6 >= 8 )
    {
      v9 = 0;
      return PlayerASM_TestBool(v9, context, parameters);
    }
  }
  v9 = 1;
  return PlayerASM_TestBool(v9, context, parameters);
}

/*
==============
PlayerASM_IsAnimationTimerBiggerThan
==============
*/
_BOOL8 PlayerASM_IsAnimationTimerBiggerThan(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  float TimerThreshold; 
  unsigned __int8 v4; 
  __int64 v6; 
  int v7; 

  if ( context->useEntityState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 854, ASSERT_TYPE_ASSERT, "(!context->useEntityState)", "%s\n\tPlayerASM_IsAnimationTimerBiggerThan() can be used only inside pmove execution path.", "!context->useEntityState") )
    __debugbreak();
  TimerThreshold = PlayerASM_GetTimerThreshold(parameters);
  v4 = parameters->slot[0];
  if ( v4 >= 2u )
  {
    v7 = 2;
    LODWORD(v6) = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 858, ASSERT_TYPE_ASSERT, "(unsigned)( parameters->slot ) < (unsigned)( PlayerASM_AnimSlot::COUNT )", "parameters->slot doesn't index PlayerASM_AnimSlot::COUNT\n\t%i not in [0, %i)", v6, v7) )
      __debugbreak();
  }
  if ( !parameters->ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 859, ASSERT_TYPE_ASSERT, "(parameters->ci)", (const char *)&queryFormat, "parameters->ci") )
    __debugbreak();
  return TimerThreshold < parameters->ci->playerASMLocomotion.animCache[(unsigned __int8)parameters->slot[0]].animTimer;
}

/*
==============
PlayerASM_IsAnimationTimerLessThan
==============
*/
_BOOL8 PlayerASM_IsAnimationTimerLessThan(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  float TimerThreshold; 
  unsigned __int8 v4; 
  __int64 v6; 
  int v7; 

  if ( context->useEntityState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 874, ASSERT_TYPE_ASSERT, "(!context->useEntityState)", "%s\n\tPlayerASM_IsAnimationTimerLessThan() can be used only inside pmove execution path.", "!context->useEntityState") )
    __debugbreak();
  TimerThreshold = PlayerASM_GetTimerThreshold(parameters);
  v4 = parameters->slot[0];
  if ( v4 >= 2u )
  {
    v7 = 2;
    LODWORD(v6) = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 878, ASSERT_TYPE_ASSERT, "(unsigned)( parameters->slot ) < (unsigned)( PlayerASM_AnimSlot::COUNT )", "parameters->slot doesn't index PlayerASM_AnimSlot::COUNT\n\t%i not in [0, %i)", v6, v7) )
      __debugbreak();
  }
  if ( !parameters->ci && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 879, ASSERT_TYPE_ASSERT, "(parameters->ci)", (const char *)&queryFormat, "parameters->ci") )
    __debugbreak();
  return TimerThreshold > parameters->ci->playerASMLocomotion.animCache[(unsigned __int8)parameters->slot[0]].animTimer;
}

/*
==============
PlayerASM_ChooseRandomAnim
==============
*/
unsigned int PlayerASM_ChooseRandomAnim(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  return PlayerASM_ChooseRandomAnimInternal(context, parameters->pAsm, parameters->entNum, (const scr_string_t)parameters->asmName, (const scr_string_t)parameters->stateName);
}

/*
==============
PlayerASM_ChooseRandomAnimInternal
==============
*/
__int64 PlayerASM_ChooseRandomAnimInternal(const PlayerASM_Context *context, BgPlayer_Asm *pAsm, int entNum, const scr_string_t asmName, const scr_string_t stateName)
{
  unsigned int AnimEntryCount; 
  unsigned int *holdrand; 
  BgPlayer_Asm_vtbl *v11; 
  ASM_Instance *v12; 

  AnimEntryCount = BG_PlayerASM_GetAnimEntryCount(context, stateName);
  if ( AnimEntryCount == 1 )
    return 0i64;
  holdrand = context->holdrand;
  v11 = pAsm->__vftable;
  v12 = pAsm->GetInstance(pAsm, context, (unsigned int)entNum);
  return ((__int64 (__fastcall *)(BgPlayer_Asm *, ASM_Instance *, _QWORD, _QWORD, unsigned int *))v11->irand)(pAsm, v12, 0i64, AnimEntryCount, holdrand);
}

/*
==============
PlayerASM_GetAnim
==============
*/
__int64 PlayerASM_GetAnim(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  int numParamsOverride; 
  BgPlayer_Asm *pAsm; 
  scr_string_t asmName; 
  int entNum; 
  ASM_Error v7; 
  const char *v9; 
  const char *v10; 
  int v11; 
  const char *v12; 
  __int64 stateName; 
  int outEntryIndex; 

  numParamsOverride = parameters->numParams;
  pAsm = parameters->pAsm;
  asmName = parameters->asmName;
  entNum = parameters->entNum;
  if ( numParamsOverride <= 0 )
    v7 = Common_Asm::ChooseAnim(pAsm, context, entNum, asmName, (const scr_string_t)parameters->stateName, &outEntryIndex);
  else
    v7 = Common_Asm::ChooseAnimWithParamOverride(pAsm, context, entNum, asmName, (const scr_string_t)parameters->stateName, numParamsOverride, parameters->pParams, &outEntryIndex);
  if ( v7 == ASM_ERR_NO_INST )
  {
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143CB26F8, 1076i64, (unsigned int)parameters->entNum);
    return (unsigned int)outEntryIndex;
  }
  else if ( v7 == ASM_ERR_NO_SUBTREE )
  {
    v9 = SL_ConvertToString(parameters->asmName);
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143CB2730, 1077i64, (unsigned int)parameters->entNum, v9);
    return (unsigned int)outEntryIndex;
  }
  else
  {
    if ( v7 == ASM_ERR_NO_STATE )
    {
      v10 = SL_ConvertToString(parameters->asmName);
      v11 = parameters->entNum;
      v12 = SL_ConvertToString(parameters->stateName);
      LODWORD(stateName) = v11;
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143CB2778, 1078i64, v12, stateName, v10);
    }
    return (unsigned int)outEntryIndex;
  }
}

/*
==============
PlayerASM_GetBuiltinFunc
==============
*/
int (*PlayerASM_GetBuiltinFunc(int i))(const PlayerASM_Context *, const PlayerASM_Parameters *)
{
  __int64 v1; 
  int v4; 

  v1 = i;
  if ( (unsigned int)i >= 0xC7 )
  {
    v4 = 199;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 315, ASSERT_TYPE_ASSERT, "(unsigned)( i ) < (unsigned)( numFuncs )", "i doesn't index numFuncs\n\t%i not in [0, %i)", i, v4) )
      __debugbreak();
  }
  return s_PlayerASMBuiltinFuncs_7[v1].m_Func;
}

/*
==============
PlayerASM_GetStateNameTransitionFrom
==============
*/
__int64 PlayerASM_GetStateNameTransitionFrom(const PlayerASM_Context *context, const PlayerASM_AnimSlot slot)
{
  bool v2; 
  const playerState_s *const_ps; 
  unsigned int v4; 
  unsigned int v5; 
  const Animset *AnimsetByIndex; 
  AnimsetAlias *v7; 
  unsigned int v8; 
  __int64 m_FuncID; 
  __int64 v11; 
  __int64 v12; 
  __int64 v13; 
  AnimsetAlias *ppOutAlias; 
  AnimsetAnim *ppOutAnim; 
  unsigned int animsetIndex; 
  int entryIndex; 
  int stateIndex; 

  v2 = !context->useEntityState;
  const_ps = context->const_ps;
  if ( v2 )
    v4 = BG_PlayerASM_UnpackAnimFromPs(const_ps, slot, &animsetIndex, (unsigned int *)&stateIndex, (unsigned int *)&entryIndex);
  else
    v4 = BG_PlayerASM_UnpackAnimFromEntity((const entityState_t *)const_ps, slot, &animsetIndex, (unsigned int *)&stateIndex, (unsigned int *)&entryIndex);
  if ( !v4 )
    return 0i64;
  v5 = animsetIndex;
  if ( animsetIndex >= 4 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 232, ASSERT_TYPE_ASSERT, "(unsigned)( animsetIndex ) < (unsigned)( (1 << 2) )", "animsetIndex doesn't index MAX_PLAYERANIM_ANIMSET_COUNT\n\t%i not in [0, %i)", animsetIndex, 4) )
      __debugbreak();
    v5 = animsetIndex;
  }
  AnimsetByIndex = BG_PlayerASM_GetAnimsetByIndex(v5);
  if ( !AnimsetByIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 235, ASSERT_TYPE_ASSERT, "(pAnimset)", (const char *)&queryFormat, "pAnimset") )
    __debugbreak();
  BG_Animset_GetAliasAndAnimFromStateIndexAndEntry(AnimsetByIndex, stateIndex, entryIndex, (const AnimsetAlias **)&ppOutAlias, (const AnimsetAnim **)&ppOutAnim);
  v7 = ppOutAlias;
  v8 = 0;
  if ( !ppOutAlias->numFuncs )
    return 0i64;
  while ( 1 )
  {
    m_FuncID = v7->funcs[v8].m_FuncID;
    if ( (unsigned int)m_FuncID >= 0xC7 )
    {
      LODWORD(v13) = 199;
      LODWORD(v12) = v7->funcs[v8].m_FuncID;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 315, ASSERT_TYPE_ASSERT, "(unsigned)( i ) < (unsigned)( numFuncs )", "i doesn't index numFuncs\n\t%i not in [0, %i)", v12, v13) )
        __debugbreak();
      v7 = ppOutAlias;
    }
    if ( s_PlayerASMBuiltinFuncs_7[m_FuncID].m_Func == PlayerASM_IsTransitionFrom )
      break;
    if ( ++v8 >= v7->numFuncs )
      return 0i64;
  }
  v11 = v8;
  if ( v7->funcs[v11].m_NumParams <= 0 )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 244, ASSERT_TYPE_ASSERT, "(animsetAlias->funcs[funcIndex].m_NumParams > 0)", (const char *)&queryFormat, "animsetAlias->funcs[funcIndex].m_NumParams > 0") )
      __debugbreak();
    v7 = ppOutAlias;
  }
  return *(_DWORD *)v7->funcs[v11].m_Params;
}

/*
==============
PlayerASM_GetTimerThreshold
==============
*/
float PlayerASM_GetTimerThreshold(const PlayerASM_Parameters *parameters)
{
  ASM_Function_Param *pParams; 
  float m_Float; 

  if ( !parameters && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 834, ASSERT_TYPE_ASSERT, "(parameters)", (const char *)&queryFormat, "parameters") )
    __debugbreak();
  if ( parameters->numParams != 1 || (unsigned int)(parameters->pParams->m_Type - 3) > 1 )
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143CB2850, 6010i64);
  pParams = parameters->pParams;
  if ( pParams->m_Type == ParamType_Float )
    m_Float = pParams->u.m_Float;
  else
    m_Float = (float)pParams->u.m_Int;
  if ( m_Float < 0.0 || m_Float > 1.0 )
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143CB28B0, 6011i64);
  return m_Float;
}

/*
==============
PlayerASM_IsAnimChoiceUpdateNeeded
==============
*/
char PlayerASM_IsAnimChoiceUpdateNeeded(const PlayerASM_Context *context, scr_string_t asmName, int entNum, const PlayerASM_AnimSlot animSlot)
{
  unsigned __int8 v4; 
  const dvar_t *v7; 
  BgStatic *ActiveStatics; 
  characterInfo_t *CharacterInfo; 
  const Animset *AnimsetByIndex; 
  PlayerASM_Instance *InstanceBySlot; 
  const char *v12; 
  const char *v13; 
  AnimsetAlias *v14; 
  AnimsetState *v15; 
  bool v16; 
  const char *v17; 
  const char *v18; 
  unsigned __int8 m_NumEvents; 
  const char *v21; 
  const char *v22; 
  const char *v23; 
  const char *v24; 
  unsigned int outAnimSetIndex; 
  unsigned int outAnimEntry; 
  AnimsetState *outState; 
  AnimsetAlias *ppOutAlias; 
  AnimsetAnim *ppOutAnim; 
  unsigned int outAnimState; 

  v4 = animSlot;
  if ( (unsigned __int8)animSlot >= (unsigned int)COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 361, ASSERT_TYPE_ASSERT, "(unsigned)( animSlot ) < (unsigned)( PlayerASM_AnimSlot::COUNT )", "animSlot doesn't index PlayerASM_AnimSlot::COUNT\n\t%i not in [0, %i)", (unsigned __int8)animSlot, 2) )
    __debugbreak();
  v7 = DCONST_DVARBOOL_playerasm_enableConditionMask;
  if ( !DCONST_DVARBOOL_playerasm_enableConditionMask && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "playerasm_enableConditionMask") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v7);
  if ( !v7->current.enabled || context->disableCache )
    return 1;
  ActiveStatics = BgStatic::GetActiveStatics();
  CharacterInfo = BG_GetCharacterInfo(ActiveStatics, entNum);
  if ( !CharacterInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 375, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
    __debugbreak();
  if ( !BG_PlayerASM_UnpackAnimFromPs(context->ps, (const PlayerASM_AnimSlot)v4, &outAnimSetIndex, &outAnimState, &outAnimEntry) )
    return 1;
  AnimsetByIndex = BG_PlayerASM_GetAnimsetByIndex(outAnimSetIndex);
  if ( !AnimsetByIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 386, ASSERT_TYPE_ASSERT, "(pAnimset)", (const char *)&queryFormat, "pAnimset") )
    __debugbreak();
  if ( !BG_PlayerASM_IsAnimEntryValid(AnimsetByIndex, outAnimState, outAnimEntry) )
    return 1;
  InstanceBySlot = BgPlayer_Asm::GetInstanceBySlot(context->playerAsm, context, (const PlayerASM_AnimSlot)v4);
  if ( !InstanceBySlot && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 395, ASSERT_TYPE_ASSERT, "(pInst)", (const char *)&queryFormat, "pInst") )
    __debugbreak();
  BG_PlayerASM_GetStateInfoByIndex(outAnimSetIndex, outAnimState, &outState);
  if ( !outState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 398, ASSERT_TYPE_ASSERT, "(animsetState)", (const char *)&queryFormat, "animsetState") )
    __debugbreak();
  if ( *outState->u.m_AIAnimsetState )
  {
    if ( Dvar_GetInt_Internal_DebugName(DVARINT_playerasm_condition_mask_debug, "playerasm_condition_mask_debug") == 3 )
    {
      v12 = "Server";
      if ( CharacterInfo->pXAnimTree->owner[0] == 1 )
        v12 = "Client";
      v13 = SL_ConvertToString(outState->name);
      Com_PrintWarning(19, "PlayerASM: Updating alias: '%s' on '%s' - invalid mask found. \n", v13, v12);
    }
    return 1;
  }
  BG_Animset_GetAliasAndAnimFromStateIndexAndEntry(AnimsetByIndex, outAnimState, outAnimEntry, (const AnimsetAlias **)&ppOutAlias, (const AnimsetAnim **)&ppOutAnim);
  v14 = ppOutAlias;
  if ( !ppOutAlias )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 413, ASSERT_TYPE_ASSERT, "(animsetAlias)", (const char *)&queryFormat, "animsetAlias") )
      __debugbreak();
    v14 = ppOutAlias;
  }
  v15 = outState;
  if ( outState->numAnimAliases != 1 )
  {
    v16 = v14->numAnims <= 1;
LABEL_39:
    if ( !v16 )
    {
      m_NumEvents = InstanceBySlot->m_NumEvents;
      if ( m_NumEvents )
      {
        if ( Common_Asm::Utils::EventFired(InstanceBySlot, m_NumEvents, (const scr_string_t)scr_const.end) )
        {
          if ( Dvar_GetInt_Internal_DebugName(DVARINT_playerasm_condition_mask_debug, "playerasm_condition_mask_debug") == 3 )
          {
            v21 = "Server";
            if ( CharacterInfo->pXAnimTree->owner[0] == 1 )
              v21 = "Client";
            v22 = SL_ConvertToString(outState->name);
            Com_PrintWarning(19, "PlayerASM: Updating alias: '%s' on '%s' - notetrack event found. \n", v22, v21);
          }
          return 1;
        }
        v15 = outState;
      }
    }
    if ( !BG_PlayerASM_EvalConditionMasks(CharacterInfo, InstanceBySlot, (const PlayerASM_ConditionMask *)v15->u.m_AIAnimsetState, v15->name) )
    {
      if ( Dvar_GetInt_Internal_DebugName(DVARINT_playerasm_condition_mask_debug, "playerasm_condition_mask_debug") == 3 )
      {
        v23 = "Server";
        if ( CharacterInfo->pXAnimTree->owner[0] == 1 )
          v23 = "Client";
        v24 = SL_ConvertToString(outState->name);
        Com_PrintWarning(19, "PlayerASM: Updating alias: '%s' on '%s'.\n", v24, v23);
      }
      return 1;
    }
    return 0;
  }
  v16 = v14->numAnims <= 1;
  if ( v14->numAnims != 1 )
    goto LABEL_39;
  if ( Dvar_GetInt_Internal_DebugName(DVARINT_playerasm_condition_mask_debug, "playerasm_condition_mask_debug") != 1 )
    return 0;
  v17 = "Server";
  if ( CharacterInfo->pXAnimTree->owner[0] == 1 )
    v17 = "Client";
  v18 = SL_ConvertToString(outState->name);
  Com_PrintWarning(19, "PlayerASM: Skipped update alias: '%s' on '%s' - single animation found. \n", v18, v17);
  return 0;
}

/*
==============
PlayerASM_IsBackwardAngle
==============
*/
bool PlayerASM_IsBackwardAngle(const float angle)
{
  const dvar_t *v1; 
  float value; 
  const dvar_t *v3; 

  v1 = DCONST_DVARFLT_playerasm_loco_transition_ccw_angle;
  if ( !DCONST_DVARFLT_playerasm_loco_transition_ccw_angle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "playerasm_loco_transition_ccw_angle") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  value = v1->current.value;
  v3 = DCONST_DVARFLT_playerasm_loco_transition_cw_angle;
  if ( !DCONST_DVARFLT_playerasm_loco_transition_cw_angle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "playerasm_loco_transition_cw_angle") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v3);
  return angle > value || angle < v3->current.value;
}

/*
==============
PlayerASM_IsForwardAngle
==============
*/
char PlayerASM_IsForwardAngle(const float angle)
{
  const dvar_t *v1; 
  float value; 
  const dvar_t *v3; 

  v1 = DCONST_DVARFLT_playerasm_loco_transition_ccw_angle;
  if ( !DCONST_DVARFLT_playerasm_loco_transition_ccw_angle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "playerasm_loco_transition_ccw_angle") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  value = v1->current.value;
  v3 = DCONST_DVARFLT_playerasm_loco_transition_cw_angle;
  if ( !DCONST_DVARFLT_playerasm_loco_transition_cw_angle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "playerasm_loco_transition_cw_angle") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v3);
  if ( angle >= 0.0 )
    goto LABEL_10;
  if ( angle > v3->current.value )
    return 1;
  if ( angle >= 0.0 )
  {
LABEL_10:
    if ( angle < value )
      return 1;
  }
  return 0;
}

/*
==============
PlayerASM_IsTransitionFromInternal
==============
*/
_BOOL8 PlayerASM_IsTransitionFromInternal(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters, const bool update)
{
  ASM_Instance *Subtree; 
  scr_string_t asmName; 
  scr_string_t StringParam; 
  int m_PrevState; 
  const ASM_State *State; 

  Subtree = parameters->pAsm->GetInstance(parameters->pAsm, context, (unsigned int)parameters->entNum);
  if ( !Subtree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 257, ASSERT_TYPE_ASSERT, "(pInst)", (const char *)&queryFormat, "pInst") )
    __debugbreak();
  asmName = parameters->asmName;
  if ( Subtree->m_pASM->m_Name != asmName )
  {
    Subtree = Common_Asm::Utils::GetSubtree(Subtree, asmName);
    if ( !Subtree && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 262, ASSERT_TYPE_ASSERT, "(pInst)", (const char *)&queryFormat, "pInst") )
      __debugbreak();
  }
  StringParam = PlayerASM_Builtin_GetStringParam(0, parameters->pParams, parameters->numParams);
  if ( !StringParam && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 266, ASSERT_TYPE_ASSERT, "(stateName != ( static_cast< scr_string_t >( 0 ) ))", (const char *)&queryFormat, "stateName != NULL_SCR_STRING") )
    __debugbreak();
  m_PrevState = Subtree->m_PrevState;
  if ( m_PrevState == -1 )
  {
    return update && (unsigned int)PlayerASM_GetStateNameTransitionFrom(context, (const PlayerASM_AnimSlot)(unsigned __int8)parameters->slot[0]) == StringParam;
  }
  else
  {
    State = Common_Asm::Utils::GetState(Subtree->m_pASM, m_PrevState);
    if ( !State && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 271, ASSERT_TYPE_ASSERT, "( pState )", (const char *)&queryFormat, "pState") )
      __debugbreak();
    return State->m_Name == StringParam;
  }
}

/*
==============
PlayerASM_PlayPredictedAnim
==============
*/
__int64 PlayerASM_PlayPredictedAnim(const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  int entryIndex; 
  char v5; 
  int gameTime; 
  PlayerASM_AnimSlot slot; 

  entryIndex = PlayerASM_ChooseAnimByConditions<1>(context, parameters);
  if ( !entryIndex )
    return 0i64;
  v5 = parameters->slot[0];
  gameTime = parameters->pAsm->GetGameTime(parameters->pAsm);
  LOBYTE(slot) = v5;
  BG_PlayerASM_SetAnimState(context, parameters->pAsm, parameters->entNum, (const scr_string_t)parameters->asmName, parameters->stateName, entryIndex, gameTime, 1.0, slot);
  return 1i64;
}

/*
==============
PlayerASM_TestBool
==============
*/
_BOOL8 PlayerASM_TestBool(bool b, const PlayerASM_Context *context, const PlayerASM_Parameters *parameters)
{
  if ( parameters->numParams != 1 )
    return b;
  if ( parameters->pParams->m_Type != ParamType_Bool && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\asm\\bg_player_asm_builtin.cpp", 45, ASSERT_TYPE_ASSERT, "(parameters->pParams[0].m_Type == ParamType_Bool)", (const char *)&queryFormat, "parameters->pParams[0].m_Type == ParamType_Bool") )
    __debugbreak();
  return parameters->pParams->u.m_Bool == b;
}

