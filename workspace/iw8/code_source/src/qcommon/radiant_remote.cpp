/*
==============
CG_ProcessReflectionVolumeUnregisterCommand
==============
*/

void __fastcall CG_ProcessReflectionVolumeUnregisterCommand(SpawnVar *spawnVar)
{
  ?CG_ProcessReflectionVolumeUnregisterCommand@@YAXPEAUSpawnVar@@@Z(spawnVar);
}

/*
==============
CG_ProcessCameraCommand
==============
*/

void __fastcall CG_ProcessCameraCommand(RadiantCommandData *commandData)
{
  ?CG_ProcessCameraCommand@@YAXURadiantCommandData@@@Z(commandData);
}

/*
==============
CG_ProcessLocatorReadCommand
==============
*/

void __fastcall CG_ProcessLocatorReadCommand(RadiantCommandData *commandData)
{
  ?CG_ProcessLocatorReadCommand@@YAXURadiantCommandData@@@Z(commandData);
}

/*
==============
CG_FreeRadiantReflectionVolume
==============
*/

void __fastcall CG_FreeRadiantReflectionVolume(RadiantRemoteReflectionVolume *radiantReflectionVolume)
{
  ?CG_FreeRadiantReflectionVolume@@YAXPEAURadiantRemoteReflectionVolume@@@Z(radiantReflectionVolume);
}

/*
==============
BG_RadiantLiveEnable
==============
*/

void __fastcall BG_RadiantLiveEnable(bool enable)
{
  ?BG_RadiantLiveEnable@@YAX_N@Z(enable);
}

/*
==============
CG_FindRadiantReflectionVolume
==============
*/

RadiantRemoteReflectionVolume *__fastcall CG_FindRadiantReflectionVolume(const char *livePath)
{
  return ?CG_FindRadiantReflectionVolume@@YAPEAURadiantRemoteReflectionVolume@@PEBD@Z(livePath);
}

/*
==============
CG_GetRadiantSyncActive
==============
*/

unsigned int __fastcall CG_GetRadiantSyncActive()
{
  return ?CG_GetRadiantSyncActive@@YAIXZ();
}

/*
==============
CG_ProcessReflectionVolumeCommand
==============
*/

void __fastcall CG_ProcessReflectionVolumeCommand(RadiantCommandData *commandData)
{
  ?CG_ProcessReflectionVolumeCommand@@YAXURadiantCommandData@@@Z(commandData);
}

/*
==============
CG_SetRadiantStatusOff
==============
*/

void CG_SetRadiantStatusOff(void)
{
  ?CG_SetRadiantStatusOff@@YAXXZ();
}

/*
==============
CG_ProcessLocatorUpdateCommand
==============
*/

void __fastcall CG_ProcessLocatorUpdateCommand(RadiantCommandData *commandData)
{
  ?CG_ProcessLocatorUpdateCommand@@YAXURadiantCommandData@@@Z(commandData);
}

/*
==============
CG_IsRadiantSyncAny
==============
*/

bool __fastcall CG_IsRadiantSyncAny()
{
  return ?CG_IsRadiantSyncAny@@YA_NXZ();
}

/*
==============
CG_IsRadiantSync
==============
*/

bool __fastcall CG_IsRadiantSync(ERadiantSyncType syncType)
{
  return ?CG_IsRadiantSync@@YA_NW4ERadiantSyncType@@@Z(syncType);
}

/*
==============
CG_ProcessSyncTypeStatusCommand
==============
*/

void __fastcall CG_ProcessSyncTypeStatusCommand(RadiantCommandData *commandData)
{
  ?CG_ProcessSyncTypeStatusCommand@@YAXURadiantCommandData@@@Z(commandData);
}

/*
==============
CG_ProcessReflectionVolumeDeleteCommand
==============
*/

void __fastcall CG_ProcessReflectionVolumeDeleteCommand(SpawnVar *spawnVar)
{
  ?CG_ProcessReflectionVolumeDeleteCommand@@YAXPEAUSpawnVar@@@Z(spawnVar);
}

/*
==============
CG_ShowWorldReflectionVolume
==============
*/

void __fastcall CG_ShowWorldReflectionVolume(const char *livePath, bool show)
{
  ?CG_ShowWorldReflectionVolume@@YAXPEBD_N@Z(livePath, show);
}

/*
==============
CG_ProcessVolumetricRegisterCommand
==============
*/

void __fastcall CG_ProcessVolumetricRegisterCommand(SpawnVar *spawnVar)
{
  ?CG_ProcessVolumetricRegisterCommand@@YAXPEAUSpawnVar@@@Z(spawnVar);
}

/*
==============
R_DrawRadiantLiveConnectionStatus
==============
*/

void R_DrawRadiantLiveConnectionStatus(void)
{
  ?R_DrawRadiantLiveConnectionStatus@@YAXXZ();
}

/*
==============
CG_ProcessReflectionVolumeUpdateCommand
==============
*/

void __fastcall CG_ProcessReflectionVolumeUpdateCommand(SpawnVar *spawnVar)
{
  ?CG_ProcessReflectionVolumeUpdateCommand@@YAXPEAUSpawnVar@@@Z(spawnVar);
}

/*
==============
CG_ProcessDecalVolumeDeleteCommand
==============
*/

void __fastcall CG_ProcessDecalVolumeDeleteCommand(const SpawnVar *spawnVar)
{
  ?CG_ProcessDecalVolumeDeleteCommand@@YAXAEBUSpawnVar@@@Z(spawnVar);
}

/*
==============
CG_ProcessVolumetricDeleteCommand
==============
*/

void __fastcall CG_ProcessVolumetricDeleteCommand(SpawnVar *spawnVar)
{
  ?CG_ProcessVolumetricDeleteCommand@@YAXPEAUSpawnVar@@@Z(spawnVar);
}

/*
==============
R_RadiantRemoteGetGfxReflectionProbeInstance
==============
*/

bool __fastcall R_RadiantRemoteGetGfxReflectionProbeInstance(const char *livePath, GfxReflectionProbeInstance *outReflectionProbeInstance)
{
  return ?R_RadiantRemoteGetGfxReflectionProbeInstance@@YA_NPEBDPEAUGfxReflectionProbeInstance@@@Z(livePath, outReflectionProbeInstance);
}

/*
==============
CG_ShowWorldVolumetric
==============
*/

void __fastcall CG_ShowWorldVolumetric(const char *livePath, bool show)
{
  ?CG_ShowWorldVolumetric@@YAXPEBD_N@Z(livePath, show);
}

/*
==============
CG_GetDecalVolume
==============
*/

bool __fastcall CG_GetDecalVolume(const SpawnVar *spawnVar, unsigned int *outUid, unsigned int *outIndex, bool *outIsDynamic)
{
  return ?CG_GetDecalVolume@@YA_NAEBUSpawnVar@@PEAI1PEA_N@Z(spawnVar, outUid, outIndex, outIsDynamic);
}

/*
==============
BG_IsRadiantLiveFlowing
==============
*/

bool __fastcall BG_IsRadiantLiveFlowing()
{
  return ?BG_IsRadiantLiveFlowing@@YA_NXZ();
}

/*
==============
CG_ProcessDecalVolumeCommand
==============
*/

void __fastcall CG_ProcessDecalVolumeCommand(RadiantCommandData *commandData)
{
  ?CG_ProcessDecalVolumeCommand@@YAXURadiantCommandData@@@Z(commandData);
}

/*
==============
CG_ProcessDecalVolumeRegisterCommand
==============
*/

void __fastcall CG_ProcessDecalVolumeRegisterCommand(const SpawnVar *spawnVar)
{
  ?CG_ProcessDecalVolumeRegisterCommand@@YAXAEBUSpawnVar@@@Z(spawnVar);
}

/*
==============
CG_ProcessRadiantCmds
==============
*/

void __fastcall CG_ProcessRadiantCmds(RadiantLiveGameMode inMode)
{
  ?CG_ProcessRadiantCmds@@YAXW4RadiantLiveGameMode@@@Z(inMode);
}

/*
==============
CG_AllocRadiantReflectionVolume
==============
*/

RadiantRemoteReflectionVolume *__fastcall CG_AllocRadiantReflectionVolume()
{
  return ?CG_AllocRadiantReflectionVolume@@YAPEAURadiantRemoteReflectionVolume@@XZ();
}

/*
==============
CG_AddRadiantCmd
==============
*/

bool __fastcall CG_AddRadiantCmd(const char *command)
{
  return ?CG_AddRadiantCmd@@YA_NPEBD@Z(command);
}

/*
==============
CG_IsRadiantConnected
==============
*/

bool __fastcall CG_IsRadiantConnected()
{
  return ?CG_IsRadiantConnected@@YA_NXZ();
}

/*
==============
CG_ProcessReflectionVolumeSetSelectionCommand
==============
*/

void __fastcall CG_ProcessReflectionVolumeSetSelectionCommand(SpawnVar *spawnVar)
{
  ?CG_ProcessReflectionVolumeSetSelectionCommand@@YAXPEAUSpawnVar@@@Z(spawnVar);
}

/*
==============
CG_ProcessVolumetricCommand
==============
*/

void __fastcall CG_ProcessVolumetricCommand(RadiantCommandData *commandData)
{
  ?CG_ProcessVolumetricCommand@@YAXURadiantCommandData@@@Z(commandData);
}

/*
==============
CG_SetRadiantStatus
==============
*/

void __fastcall CG_SetRadiantStatus(unsigned int inMask)
{
  ?CG_SetRadiantStatus@@YAXI@Z(inMask);
}

/*
==============
CG_FreeRadiantVolumetric
==============
*/

void __fastcall CG_FreeRadiantVolumetric(RadiantRemoteVolumetric *radiantVolumetric)
{
  ?CG_FreeRadiantVolumetric@@YAXPEAURadiantRemoteVolumetric@@@Z(radiantVolumetric);
}

/*
==============
CG_MakeReflectionProbeInstanceFeatherPositive
==============
*/

void __fastcall CG_MakeReflectionProbeInstanceFeatherPositive(GfxReflectionProbeInstance *reflectionProbeInstance)
{
  ?CG_MakeReflectionProbeInstanceFeatherPositive@@YAXPEAUGfxReflectionProbeInstance@@@Z(reflectionProbeInstance);
}

/*
==============
CG_ProcessReflectionVolumeRegisterCommand
==============
*/

void __fastcall CG_ProcessReflectionVolumeRegisterCommand(SpawnVar *spawnVar)
{
  ?CG_ProcessReflectionVolumeRegisterCommand@@YAXPEAUSpawnVar@@@Z(spawnVar);
}

/*
==============
CG_ProcessLocatorDeleteCommand
==============
*/

void __fastcall CG_ProcessLocatorDeleteCommand(RadiantCommandData *commandData)
{
  ?CG_ProcessLocatorDeleteCommand@@YAXURadiantCommandData@@@Z(commandData);
}

/*
==============
CG_ProcessLocatorCreateCommand
==============
*/

void __fastcall CG_ProcessLocatorCreateCommand(RadiantCommandData *commandData)
{
  ?CG_ProcessLocatorCreateCommand@@YAXURadiantCommandData@@@Z(commandData);
}

/*
==============
CG_DrawRadiantReflectionVolumes
==============
*/

void CG_DrawRadiantReflectionVolumes(void)
{
  ?CG_DrawRadiantReflectionVolumes@@YAXXZ();
}

/*
==============
BG_IsRadiantLiveEnabled
==============
*/

bool __fastcall BG_IsRadiantLiveEnabled()
{
  return ?BG_IsRadiantLiveEnabled@@YA_NXZ();
}

/*
==============
CG_ProcessExposureCommand
==============
*/

void __fastcall CG_ProcessExposureCommand(RadiantCommandData *commandData)
{
  ?CG_ProcessExposureCommand@@YAXURadiantCommandData@@@Z(commandData);
}

/*
==============
CG_AllocRadiantVolumetric
==============
*/

RadiantRemoteVolumetric *__fastcall CG_AllocRadiantVolumetric()
{
  return ?CG_AllocRadiantVolumetric@@YAPEAURadiantRemoteVolumetric@@XZ();
}

/*
==============
CG_ProcessVolumetricUpdateCommand
==============
*/

void __fastcall CG_ProcessVolumetricUpdateCommand(SpawnVar *spawnVar)
{
  ?CG_ProcessVolumetricUpdateCommand@@YAXPEAUSpawnVar@@@Z(spawnVar);
}

/*
==============
CG_DrawRadiantVolumetrics
==============
*/

void CG_DrawRadiantVolumetrics(void)
{
  ?CG_DrawRadiantVolumetrics@@YAXXZ();
}

/*
==============
CG_ProcessDecalVolumeUpdateCommand
==============
*/

void __fastcall CG_ProcessDecalVolumeUpdateCommand(const SpawnVar *spawnVar)
{
  ?CG_ProcessDecalVolumeUpdateCommand@@YAXAEBUSpawnVar@@@Z(spawnVar);
}

/*
==============
CG_GetRadiantStatus
==============
*/

unsigned int __fastcall CG_GetRadiantStatus()
{
  return ?CG_GetRadiantStatus@@YAIXZ();
}

/*
==============
CG_GetReflectionProbeIndexFromLivePath
==============
*/

unsigned int __fastcall CG_GetReflectionProbeIndexFromLivePath(const char *livePath)
{
  return ?CG_GetReflectionProbeIndexFromLivePath@@YAIPEBD@Z(livePath);
}

/*
==============
CG_ProcessVolumetricSetSelectionCommand
==============
*/

void __fastcall CG_ProcessVolumetricSetSelectionCommand(SpawnVar *spawnVar)
{
  ?CG_ProcessVolumetricSetSelectionCommand@@YAXPEAUSpawnVar@@@Z(spawnVar);
}

/*
==============
CG_ProcessVolumetricUnregisterCommand
==============
*/

void __fastcall CG_ProcessVolumetricUnregisterCommand(SpawnVar *spawnVar)
{
  ?CG_ProcessVolumetricUnregisterCommand@@YAXPEAUSpawnVar@@@Z(spawnVar);
}

/*
==============
CG_GetDecalVolumeUid
==============
*/

unsigned int __fastcall CG_GetDecalVolumeUid(const SpawnVar *spawnVar)
{
  return ?CG_GetDecalVolumeUid@@YAIAEBUSpawnVar@@@Z(spawnVar);
}

/*
==============
CG_ProcessDecalVolumeSetSelectionCommand
==============
*/

void __fastcall CG_ProcessDecalVolumeSetSelectionCommand(const SpawnVar *spawnVar)
{
  ?CG_ProcessDecalVolumeSetSelectionCommand@@YAXAEBUSpawnVar@@@Z(spawnVar);
}

/*
==============
CG_FindRadiantVolumetric
==============
*/

RadiantRemoteVolumetric *__fastcall CG_FindRadiantVolumetric(const char *livePath)
{
  return ?CG_FindRadiantVolumetric@@YAPEAURadiantRemoteVolumetric@@PEBD@Z(livePath);
}

/*
==============
G_ProcessRadiantCmds
==============
*/

void __fastcall G_ProcessRadiantCmds(RadiantLiveGameMode inMode)
{
  ?G_ProcessRadiantCmds@@YAXW4RadiantLiveGameMode@@@Z(inMode);
}

/*
==============
CG_ProcessCameraCommand
==============
*/
void CG_ProcessCameraCommand(RadiantCommandData *commandData)
{
  LocalClientNum_t FirstActiveGameLocalClient; 
  SpawnVar *spawnVar; 
  const char *PairValue; 
  const char *v5; 
  cg_t *LocalClientGlobals; 
  float v7; 
  float v8; 
  float v9; 
  float v10; 
  float v11; 
  float v12; 

  FirstActiveGameLocalClient = ClStatic::GetFirstActiveGameLocalClient(&cls);
  if ( CL_IsLocalClientConnectedToAnyServer(FirstActiveGameLocalClient) )
  {
    spawnVar = commandData->spawnVar;
    PairValue = GetPairValue(spawnVar, "origin");
    v5 = GetPairValue(spawnVar, "angles");
    LocalClientGlobals = CG_GetLocalClientGlobals(FirstActiveGameLocalClient);
    if ( LocalClientGlobals )
    {
      if ( PairValue )
        j_sscanf(PairValue, "%f %f %f", &v10, &v11, &v12);
      if ( v5 )
        j_sscanf(v5, "%f %f %f", &v7, &v8, &v9);
      LODWORD(v7) ^= _xmm;
      LocalClientGlobals->radiantCameraOrigin.v[0] = v10;
      LocalClientGlobals->radiantCameraOrigin.v[1] = v11;
      LocalClientGlobals->radiantCameraOrigin.v[2] = v12;
      LocalClientGlobals->radiantCameraAngles.v[0] = v7;
      LocalClientGlobals->radiantCameraAngles.v[1] = v8;
      LocalClientGlobals->radiantCameraAngles.v[2] = v9;
      LocalClientGlobals->radiantCamReceived = 1;
      LocalClientGlobals->radiantCamInUse = 1;
    }
  }
}

/*
==============
CG_ProcessLocatorCreateCommand
==============
*/
void CG_ProcessLocatorCreateCommand(RadiantCommandData *commandData)
{
  ;
}

/*
==============
CG_ProcessLocatorReadCommand
==============
*/
void CG_ProcessLocatorReadCommand(RadiantCommandData *commandData)
{
  ;
}

/*
==============
CG_ProcessLocatorUpdateCommand
==============
*/
void CG_ProcessLocatorUpdateCommand(RadiantCommandData *commandData)
{
  ;
}

/*
==============
CG_ProcessLocatorDeleteCommand
==============
*/
void CG_ProcessLocatorDeleteCommand(RadiantCommandData *commandData)
{
  ;
}

/*
==============
CG_ProcessDecalVolumeCommand
==============
*/
void CG_ProcessDecalVolumeCommand(RadiantCommandData *commandData)
{
  LocalClientNum_t FirstActiveGameLocalClient; 
  SpawnVar *spawnVar; 
  const char *v4; 
  const char *PairValue; 
  unsigned int i; 
  __int64 v7; 
  unsigned int v8; 
  __int64 v9; 
  const char *v10; 
  unsigned int v11; 
  GfxDynamicDecalVolumeIndex DynamicIndex; 
  unsigned int v13; 
  unsigned int DecalVolumeUid; 
  GfxDynamicDecalVolumeIndex Dynamic; 
  bool outIsDynamic[4]; 
  unsigned int outIndex; 
  float outEdgeFeatherZ; 
  vec3_t outBlendMapAdjust; 
  GfxStaticDecalVolumePacked dst; 
  GfxStaticDecalVolumeUnpacked decalVolume; 

  FirstActiveGameLocalClient = ClStatic::GetFirstActiveGameLocalClient(&cls);
  if ( !CL_IsLocalClientConnectedToAnyServer(FirstActiveGameLocalClient) || !CG_GetLocalClientGlobals(FirstActiveGameLocalClient) )
    return;
  spawnVar = commandData->spawnVar;
  switch ( commandData->radiantCommand->type )
  {
    case RADIANT_COMMAND_DECAL_VOLUME_REGISTER:
      DecalVolumeUid = CG_GetDecalVolumeUid(commandData->spawnVar);
      if ( !R_DecalVolumes_GetUID(DecalVolumeUid, &outIndex, outIsDynamic) )
      {
        Dynamic = R_DecalVolumes_AllocateDynamic(DecalVolumeUid);
        if ( Dynamic == DECAL_VOLUMES_INVALID_DYNAMIC_INDEX )
          return;
        outIndex = (unsigned __int16)Dynamic;
        outIsDynamic[0] = 1;
      }
LABEL_19:
      CG_UpdateDecalVolumeObb(spawnVar, &decalVolume);
      CG_UpdateDecalVolumeMaterial(spawnVar, &decalVolume, &outBlendMapAdjust, &outEdgeFeatherZ, outIndex, outIsDynamic[0]);
      R_DecalVolumes_PackOBB(&dst, &decalVolume.obb);
      R_DecalVolumes_PackUVTransform(&dst, &decalVolume.uvMatrix, &decalVolume.uvOffset);
      R_DecalVolumes_PackOpacityParams(&dst, &outBlendMapAdjust, outEdgeFeatherZ);
      R_DecalVolumes_PackMaterialInfo(&dst, decalVolume.packedMaterialInfo);
      R_DecalVolumes_DecalUpdate(outIndex, outIsDynamic[0], &dst);
      return;
    case RADIANT_COMMAND_DECAL_VOLUME_UPDATE:
      v13 = CG_GetDecalVolumeUid(commandData->spawnVar);
      if ( !R_DecalVolumes_GetUID(v13, &outIndex, outIsDynamic) )
        return;
      goto LABEL_19;
    case RADIANT_COMMAND_DECAL_VOLUME_DELETE:
      v11 = CG_GetDecalVolumeUid(commandData->spawnVar);
      DynamicIndex = R_DecalVolumes_GetDynamicIndex(v11);
      if ( DynamicIndex != DECAL_VOLUMES_INVALID_DYNAMIC_INDEX )
        R_DecalVolumes_ReleaseDynamic(DynamicIndex);
      break;
    case RADIANT_COMMAND_DECAL_VOLUME_SET_SELECTION:
      R_DecalVolumes_ClearSelection();
      v4 = j_va("uid%u", 0i64);
      PairValue = GetPairValue(spawnVar, v4);
      for ( i = 1; PairValue; PairValue = GetPairValue(spawnVar, v10) )
      {
        v7 = -1i64;
        v8 = -1;
        do
          ++v7;
        while ( PairValue[v7] );
        for ( ; v7; --v7 )
        {
          v9 = *(unsigned __int8 *)PairValue++;
          v8 = (v8 >> 8) ^ g_crc32Table[v9 ^ (unsigned __int8)v8];
        }
        if ( R_DecalVolumes_GetUID(~v8, &outIndex, outIsDynamic) && !R_DecalVolumes_SetSelected(outIndex, outIsDynamic[0], 1) )
          break;
        v10 = j_va("uid%u", i++);
      }
      break;
  }
}

/*
==============
CG_ProcessExposureCommand
==============
*/
void CG_ProcessExposureCommand(RadiantCommandData *commandData)
{
  const char *PairValue; 

  PairValue = GetPairValue(commandData->spawnVar, "exposure");
  if ( PairValue )
  {
    *(double *)&_XMM0 = strtod(PairValue, NULL);
    __asm { vcvtsd2ss xmm6, xmm0, xmm0 }
    Dvar_SetBool_Internal(DVARBOOL_r_tonemapUseTweaks, 1);
    Dvar_SetFloat_Internal(DVARFLT_r_tonemapExposure, *(float *)&_XMM6);
  }
}

/*
==============
CG_ProcessSyncTypeStatusCommand
==============
*/
void CG_ProcessSyncTypeStatusCommand(RadiantCommandData *commandData)
{
  const char *PairValue; 
  __int16 v2; 
  __int16 v3; 
  int v4; 

  PairValue = GetPairValue(commandData->spawnVar, "mask");
  if ( PairValue )
  {
    v2 = strtol(PairValue, NULL, 10);
    v3 = v2 ^ cgRadiantLiveStatus;
    v4 = v2 & 0x7FF;
    cgRadiantLiveStatus = v4;
    if ( (v3 & 0x7FF) != 0 || !triggerCnt )
    {
      cgRadiantLiveProcessStatus = v4 | 0x800;
      Sys_EnterCriticalSection(CRITSECT_RADIANT_SERVER_COMMAND);
      gRadiantLiveProcessStatus = cgRadiantLiveStatus | 0x800;
      Sys_LeaveCriticalSection(CRITSECT_RADIANT_SERVER_COMMAND);
      triggerCnt = 4;
    }
    else
    {
      --triggerCnt;
    }
  }
}

/*
==============
CG_ProcessReflectionVolumeCommand
==============
*/
void CG_ProcessReflectionVolumeCommand(RadiantCommandData *commandData)
{
  LocalClientNum_t FirstActiveGameLocalClient; 
  SpawnVar *spawnVar; 
  RadiantRemoteReflectionVolume *v4; 
  int v5; 
  const char *v6; 
  const char *j; 
  RadiantRemoteReflectionVolume *RadiantReflectionVolume; 
  const char *v9; 
  const char *v10; 
  RadiantRemoteReflectionVolume *v11; 
  RadiantRemoteReflectionVolume *v12; 
  const char *PairValue; 
  const char *v14; 
  int v15; 
  RadiantRemoteReflectionVolume *i; 

  FirstActiveGameLocalClient = ClStatic::GetFirstActiveGameLocalClient(&cls);
  if ( !CL_IsLocalClientConnectedToAnyServer(FirstActiveGameLocalClient) || !CG_GetLocalClientGlobals(FirstActiveGameLocalClient) )
    return;
  spawnVar = commandData->spawnVar;
  if ( commandData->radiantCommand->type == RADIANT_COMMAND_REFLECTION_VOLUME_REGISTER )
  {
    PairValue = GetPairValue(spawnVar, "livePath");
    v14 = PairValue;
    if ( PairValue )
    {
      if ( !CG_FindRadiantReflectionVolume(PairValue) )
      {
        v15 = 0;
        for ( i = s_radiantReflectionVolumes; i->active; ++i )
        {
          if ( (unsigned int)++v15 >= 0x80 )
          {
            Com_PrintWarning(14, "Radiant Live: Too many selected reflection volume entities (max is %i), %s will not be tracked.\n", 128i64, v14);
            return;
          }
        }
        memset_0(&i->selected, 0, 0xD7ui64);
        i->active = 1;
        Core_strcpy(i->livePath, 0x40ui64, v14);
        CG_ShowWorldReflectionVolume(v14, 0);
        CG_ProcessReflectionVolumeUpdateCommand(spawnVar);
      }
    }
    else
    {
      Com_PrintWarning(14, "Radiant Live: Reflection volume select command has no livePath KVP.\n");
    }
  }
  else
  {
    if ( commandData->radiantCommand->type != RADIANT_COMMAND_REFLECTION_VOLUME_UNREGISTER )
    {
      if ( commandData->radiantCommand->type == RADIANT_COMMAND_REFLECTION_VOLUME_UPDATE )
      {
        CG_ProcessReflectionVolumeUpdateCommand(commandData->spawnVar);
        return;
      }
      if ( commandData->radiantCommand->type != RADIANT_COMMAND_REFLECTION_VOLUME_DELETE )
      {
        if ( commandData->radiantCommand->type == RADIANT_COMMAND_REFLECTION_VOLUME_SET_SELECTION )
        {
          v4 = s_radiantReflectionVolumes;
          do
          {
            v4->selected = 0;
            ++v4;
          }
          while ( v4 < (RadiantRemoteReflectionVolume *)&VFX_RAY_CAST_REST_VELOCITY_SQ_FLOAT4_693 );
          v5 = 0;
          v6 = j_va("livePath%d", 0i64);
          for ( j = GetPairValue(spawnVar, v6); j; j = GetPairValue(spawnVar, v9) )
          {
            RadiantReflectionVolume = CG_FindRadiantReflectionVolume(j);
            if ( RadiantReflectionVolume )
              RadiantReflectionVolume->selected = 1;
            v9 = j_va("livePath%d", (unsigned int)++v5);
          }
        }
        return;
      }
      v10 = GetPairValue(commandData->spawnVar, "livePath");
      if ( !v10 )
        return;
      goto LABEL_16;
    }
    v10 = GetPairValue(commandData->spawnVar, "livePath");
    if ( v10 )
    {
LABEL_16:
      v11 = CG_FindRadiantReflectionVolume(v10);
      if ( v11 )
      {
        CG_FreeRadiantReflectionVolume(v11);
        CG_ShowWorldReflectionVolume(v10, 1);
      }
      return;
    }
    v12 = s_radiantReflectionVolumes;
    do
    {
      if ( v12->active )
      {
        CG_FreeRadiantReflectionVolume(v12);
        CG_ShowWorldReflectionVolume(v12->livePath, 1);
      }
      ++v12;
    }
    while ( v12 != (RadiantRemoteReflectionVolume *)&VFX_RAY_CAST_REST_VELOCITY_SQ_FLOAT4_693 );
  }
}

/*
==============
CG_ProcessVolumetricCommand
==============
*/
void CG_ProcessVolumetricCommand(RadiantCommandData *commandData)
{
  LocalClientNum_t FirstActiveGameLocalClient; 
  SpawnVar *spawnVar; 
  RadiantRemoteVolumetric *v4; 
  int v5; 
  const char *v6; 
  const char *j; 
  RadiantRemoteVolumetric *v8; 
  const char *v9; 
  const char *v10; 
  const char *v11; 
  RadiantRemoteVolumetric *v12; 
  const char *v13; 
  const char *v14; 
  RadiantRemoteVolumetric *RadiantVolumetric; 
  RadiantRemoteVolumetric *v16; 
  const char *PairValue; 
  const char *v18; 
  int v19; 
  RadiantRemoteVolumetric *i; 

  FirstActiveGameLocalClient = ClStatic::GetFirstActiveGameLocalClient(&cls);
  if ( CL_IsLocalClientConnectedToAnyServer(FirstActiveGameLocalClient) && CG_GetLocalClientGlobals(FirstActiveGameLocalClient) )
  {
    spawnVar = commandData->spawnVar;
    switch ( commandData->radiantCommand->type )
    {
      case RADIANT_COMMAND_VOLUMETRIC_REGISTER:
        PairValue = GetPairValue(spawnVar, "livePath");
        v18 = PairValue;
        if ( PairValue )
        {
          if ( !CG_FindRadiantVolumetric(PairValue) )
          {
            v19 = 0;
            for ( i = s_radiantVolumetrics; i->active; ++i )
            {
              if ( (unsigned int)++v19 >= 0x80 )
              {
                Com_PrintWarning(14, "Radiant Live: Too many selected volumetric entities (max is %i), %s will not be tracked.\n", 128i64, v18);
                return;
              }
            }
            memset_0(&i->selected, 0, 0x14Fui64);
            i->active = 1;
            Core_strcpy(i->livePath, 0x40ui64, v18);
            CG_ShowWorldVolumetric(v18, 0);
            CG_ProcessVolumetricUpdateCommand(spawnVar);
          }
        }
        else
        {
          Com_PrintWarning(14, "Radiant Live: Volumetric select command has no livePath KVP.\n");
        }
        break;
      case RADIANT_COMMAND_VOLUMETRIC_UNREGISTER:
        v13 = GetPairValue(commandData->spawnVar, "livePath");
        v14 = v13;
        if ( v13 )
        {
          RadiantVolumetric = CG_FindRadiantVolumetric(v13);
          if ( RadiantVolumetric )
          {
            CG_FreeRadiantVolumetric(RadiantVolumetric);
            CG_ShowWorldVolumetric(v14, 1);
          }
        }
        else
        {
          v16 = s_radiantVolumetrics;
          do
          {
            if ( v16->active )
            {
              CG_FreeRadiantVolumetric(v16);
              CG_ShowWorldVolumetric(v16->livePath, 1);
            }
            ++v16;
          }
          while ( v16 != (RadiantRemoteVolumetric *)s_radiantReflectionVolumes );
        }
        break;
      case RADIANT_COMMAND_VOLUMETRIC_UPDATE:
        CG_ProcessVolumetricUpdateCommand(commandData->spawnVar);
        break;
      case RADIANT_COMMAND_VOLUMETRIC_DELETE:
        v10 = GetPairValue(commandData->spawnVar, "livePath");
        v11 = v10;
        if ( v10 )
        {
          v12 = CG_FindRadiantVolumetric(v10);
          if ( v12 )
            CG_FreeRadiantVolumetric(v12);
          CG_ShowWorldVolumetric(v11, 0);
        }
        break;
      case RADIANT_COMMAND_VOLUMETRIC_SET_SELECTION:
        v4 = s_radiantVolumetrics;
        do
        {
          v4->selected = 0;
          ++v4;
        }
        while ( v4 < (RadiantRemoteVolumetric *)s_radiantReflectionVolumes );
        v5 = 0;
        v6 = j_va("livePath%d", 0i64);
        for ( j = GetPairValue(spawnVar, v6); j; j = GetPairValue(spawnVar, v9) )
        {
          v8 = CG_FindRadiantVolumetric(j);
          if ( v8 )
            v8->selected = 1;
          v9 = j_va("livePath%d", (unsigned int)++v5);
        }
        break;
    }
  }
}

/*
==============
BG_IsRadiantLiveEnabled
==============
*/
_BOOL8 BG_IsRadiantLiveEnabled()
{
  return bgRadiantLiveEnabled;
}

/*
==============
BG_IsRadiantLiveFlowing
==============
*/
_BOOL8 BG_IsRadiantLiveFlowing()
{
  return cgRadiantLiveFlowing;
}

/*
==============
BG_RadiantLiveEnable
==============
*/
void BG_RadiantLiveEnable(bool enable)
{
  Sys_EnterCriticalSection(CRITSECT_RADIANT_CLIENT_COMMAND);
  Sys_EnterCriticalSection(CRITSECT_RADIANT_SERVER_COMMAND);
  bgRadiantLiveEnabled = enable;
  Sys_LeaveCriticalSection(CRITSECT_RADIANT_SERVER_COMMAND);
  Sys_LeaveCriticalSection(CRITSECT_RADIANT_CLIENT_COMMAND);
}

/*
==============
CG_AddRadiantCmd
==============
*/
char CG_AddRadiantCmd(const char *command)
{
  const char *v2; 
  char v4; 
  char v5; 
  __int64 v6; 
  int v7; 
  __int64 v8; 
  const char *v9; 
  bool v10; 
  __int64 v11; 
  char v12; 
  __int64 v13; 
  char v14; 
  RadiantCommandType v15; 
  const char *v16; 
  CommandProcessorType v17; 
  const char *v18; 
  unsigned int *v19; 
  size_t v20; 
  char *v21; 
  __int64 v22; 
  RadiantCommandType v23; 
  unsigned int v24; 
  char s0[512]; 

  j_sscanf(command + 6, "%d", &v24);
  v2 = I_stristr(command + 6, " ") + 1;
  if ( v24 != 4 )
  {
    Com_PrintWarning(14, "Radiant Live Update: Radiant (%d) and game (%d) are out of sync.  Dropping command.\n", v24, 4i64);
    return 0;
  }
  if ( clientUIActives[0].connectionState != CA_ACTIVE || cg_t::ms_allocatedType == GLOB_TYPE_UNKNOWN )
    return 0;
  v4 = *v2;
  v5 = 0;
  v6 = 0i64;
  v7 = 0;
  if ( *v2 != 32 )
  {
    v8 = 0i64;
    do
    {
      if ( v4 == 46 )
      {
        v5 = 1;
      }
      else if ( !v5 && v8 < 511 )
      {
        ++v7;
        s0[v8++] = v4;
      }
      v4 = *++v2;
    }
    while ( v4 != 32 );
  }
  v9 = v2 + 1;
  v10 = cls.m_activeGameMapName[0] == 0;
  s0[v7] = 0;
  if ( v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\client\\cl_static.h", 295, ASSERT_TYPE_ASSERT, "(m_activeGameMapName[0])", "%s\n\tRequested mapname before it was set", "m_activeGameMapName[0]") )
    __debugbreak();
  if ( I_strcmp(s0, cls.m_activeGameMapName) )
  {
    v11 = 0x7FFFFFFFi64;
    do
    {
      v12 = s0[v6];
      v13 = v11;
      v14 = aRelaxed[v6++];
      --v11;
      if ( !v13 )
        break;
      if ( v12 != v14 )
      {
        Com_PrintWarning(14, "Radiant Live Update: maps do not match %s and %s\n", cls.m_activeGameMapName, s0);
        return 0;
      }
    }
    while ( v12 );
  }
  j_sscanf(v9, "%d", &v23);
  v15 = v23;
  if ( !s_isCommandBinary[v23] )
  {
    v16 = I_stristr(v9, " ");
    v15 = v23;
    v9 = v16 + 1;
  }
  if ( (unsigned int)v15 >= RADIANT_COMMAND_COUNT )
  {
    LODWORD(v22) = v15;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\radiant_remote.cpp", 2236, ASSERT_TYPE_ASSERT, "(unsigned)( commandType ) < (unsigned)( RADIANT_COMMAND_COUNT )", "commandType doesn't index RADIANT_COMMAND_COUNT\n\t%i not in [0, %i)", v22, 28) )
      __debugbreak();
    v15 = v23;
  }
  v17 = s_commandProcessorType[v15];
  if ( (unsigned int)(v17 - 3) <= 1 )
    return 1;
  if ( (unsigned int)(v17 - 1) > 1 )
  {
LABEL_47:
    if ( (v17 & 0xFFFFFFFD) == 0 )
    {
      Sys_EnterCriticalSection(CRITSECT_RADIANT_SERVER_COMMAND);
      if ( gCommandCount < 24 )
      {
        Core_strcpy_truncate(gCommands[gCommandCount].command, 0x8100ui64, v9);
        gCommands[gCommandCount++].type = v23;
        Sys_LeaveCriticalSection(CRITSECT_RADIANT_SERVER_COMMAND);
        return 1;
      }
      Com_PrintWarning(15, "Radiant Live Update: Too many server commands\n");
      Sys_LeaveCriticalSection(CRITSECT_RADIANT_SERVER_COMMAND);
    }
    return 1;
  }
  Sys_EnterCriticalSection(CRITSECT_RADIANT_CLIENT_COMMAND);
  if ( cgCommandCount >= 24 )
  {
    Com_PrintWarning(14, "Radiant Live Update: Too many client commands\n");
    goto LABEL_46;
  }
  if ( !s_isCommandBinary[v23] )
  {
    Core_strcpy_truncate(cgCommands[cgCommandCount].command, 0x8100ui64, v9);
LABEL_44:
    cgCommands[cgCommandCount++].type = v23;
LABEL_46:
    Sys_LeaveCriticalSection(CRITSECT_RADIANT_CLIENT_COMMAND);
    goto LABEL_47;
  }
  v18 = v9;
  if ( !*v9 )
  {
LABEL_35:
    v19 = (unsigned int *)(v18 + 1);
    v20 = *v19 + 4i64;
    v21 = cgCommands[cgCommandCount].command;
    if ( v21 )
    {
      if ( v20 > 0x8100 )
      {
        memset_0(v21, 0, 0x8100ui64);
        *_errno() = 34;
        _invalid_parameter_noinfo();
      }
      else
      {
        memcpy_0(v21, v19, v20);
      }
    }
    else
    {
      *_errno() = 22;
      _invalid_parameter_noinfo();
    }
    goto LABEL_44;
  }
  while ( ++v18 < v9 + 33024 )
  {
    if ( !*v18 )
      goto LABEL_35;
  }
  Com_PrintWarning(14, "Radiant Live Update: Binary message is invalid\n");
  Sys_LeaveCriticalSection(CRITSECT_RADIANT_CLIENT_COMMAND);
  return 0;
}

/*
==============
CG_AllocRadiantReflectionVolume
==============
*/
RadiantRemoteReflectionVolume *CG_AllocRadiantReflectionVolume()
{
  int v0; 
  RadiantRemoteReflectionVolume *i; 
  RadiantRemoteReflectionVolume *result; 

  v0 = 0;
  for ( i = s_radiantReflectionVolumes; i->active; ++i )
  {
    if ( (unsigned int)++v0 >= 0x80 )
      return 0i64;
  }
  memset_0(&i->selected, 0, 0xD7ui64);
  result = i;
  i->active = 1;
  return result;
}

/*
==============
CG_AllocRadiantVolumetric
==============
*/
RadiantRemoteVolumetric *CG_AllocRadiantVolumetric()
{
  int v0; 
  RadiantRemoteVolumetric *i; 
  RadiantRemoteVolumetric *result; 

  v0 = 0;
  for ( i = s_radiantVolumetrics; i->active; ++i )
  {
    if ( (unsigned int)++v0 >= 0x80 )
      return 0i64;
  }
  memset_0(&i->selected, 0, 0x14Fui64);
  result = i;
  i->active = 1;
  return result;
}

/*
==============
CG_DrawRadiantReflectionVolumes
==============
*/
void CG_DrawRadiantReflectionVolumes(void)
{
  float *v0; 
  __int64 v1; 
  float v2; 
  bool v3; 
  float v4; 
  float v5; 
  const vec4_t *v6; 
  Bounds bounds; 
  tmat33_t<vec3_t> rotation; 

  v0 = &s_radiantReflectionVolumes[0].reflectionProbeInstance.volumeObb.halfSize.v[2];
  v1 = 128i64;
  do
  {
    if ( *((_BYTE *)v0 - 168) )
    {
      v2 = *(v0 - 2);
      v3 = *((_BYTE *)v0 - 167) == 0;
      bounds.halfSize.v[1] = *(v0 - 1);
      *(__m256i *)rotation.m[0].v = *(__m256i *)(v0 - 11);
      v4 = *(v0 - 3);
      bounds.halfSize.v[0] = v2;
      v5 = *v0;
      v6 = &colorRed;
      if ( v3 )
        v6 = &colorWhite;
      rotation.m[2].v[2] = v4;
      bounds.midPoint.v[0] = 0.0;
      bounds.midPoint.v[1] = 0.0;
      bounds.midPoint.v[2] = 0.0;
      bounds.halfSize.v[2] = v5;
      CG_DebugBoxOriented((const vec3_t *)(v0 - 14), &bounds, &rotation, v6, 1, 0);
      R_AddReflectionProbeInstanceToScene((const GfxReflectionProbeInstance *)(v0 - 24));
    }
    v0 += 54;
    --v1;
  }
  while ( v1 );
}

/*
==============
CG_DrawRadiantVolumetrics
==============
*/
void CG_DrawRadiantVolumetrics(void)
{
  float *v0; 
  __int64 v1; 
  float v2; 
  bool v3; 
  float v4; 
  float v5; 
  const vec4_t *v6; 
  Bounds bounds; 
  tmat33_t<vec3_t> rotation; 

  v0 = &s_radiantVolumetrics[0].volumetric.obb.halfSize.v[2];
  v1 = 128i64;
  do
  {
    if ( *((_BYTE *)v0 - 140) )
    {
      v2 = *(v0 - 2);
      v3 = *((_BYTE *)v0 - 139) == 0;
      bounds.halfSize.v[1] = *(v0 - 1);
      *(__m256i *)rotation.m[0].v = *(__m256i *)(v0 - 11);
      v4 = *(v0 - 3);
      bounds.halfSize.v[0] = v2;
      v5 = *v0;
      v6 = &colorRed;
      if ( v3 )
        v6 = &colorWhite;
      rotation.m[2].v[2] = v4;
      bounds.midPoint.v[0] = 0.0;
      bounds.midPoint.v[1] = 0.0;
      bounds.midPoint.v[2] = 0.0;
      bounds.halfSize.v[2] = v5;
      CG_DebugBoxOriented((const vec3_t *)(v0 - 14), &bounds, &rotation, v6, 1, 0);
      R_AddVolumetricToScene((const GfxVolumetric *)(v0 - 17));
    }
    v0 += 84;
    --v1;
  }
  while ( v1 );
}

/*
==============
CG_FindRadiantReflectionVolume
==============
*/
RadiantRemoteReflectionVolume *CG_FindRadiantReflectionVolume(const char *livePath)
{
  RadiantRemoteReflectionVolume *v2; 
  unsigned int v3; 
  __int64 v4; 
  const char *v5; 
  char v6; 
  __int64 v7; 
  char v8; 

  v2 = s_radiantReflectionVolumes;
  v3 = 0;
  while ( !v2->active )
  {
LABEL_13:
    ++v3;
    ++v2;
    if ( v3 >= 0x80 )
      return 0i64;
  }
  v4 = 0x7FFFFFFFi64;
  v5 = livePath;
  if ( v2 == (RadiantRemoteReflectionVolume *)-2i64 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 181, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
    __debugbreak();
  if ( !livePath && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
    __debugbreak();
  do
  {
    v6 = v5[v2->livePath - livePath];
    v7 = v4;
    v8 = *v5++;
    --v4;
    if ( !v7 )
      break;
    if ( v6 != v8 )
      goto LABEL_13;
  }
  while ( v6 );
  return v2;
}

/*
==============
CG_FindRadiantVolumetric
==============
*/
RadiantRemoteVolumetric *CG_FindRadiantVolumetric(const char *livePath)
{
  RadiantRemoteVolumetric *v2; 
  unsigned int v3; 
  __int64 v4; 
  const char *v5; 
  char v6; 
  __int64 v7; 
  char v8; 

  v2 = s_radiantVolumetrics;
  v3 = 0;
  while ( !v2->active )
  {
LABEL_13:
    ++v3;
    ++v2;
    if ( v3 >= 0x80 )
      return 0i64;
  }
  v4 = 0x7FFFFFFFi64;
  v5 = livePath;
  if ( v2 == (RadiantRemoteVolumetric *)-2i64 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 181, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
    __debugbreak();
  if ( !livePath && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
    __debugbreak();
  do
  {
    v6 = v5[v2->livePath - livePath];
    v7 = v4;
    v8 = *v5++;
    --v4;
    if ( !v7 )
      break;
    if ( v6 != v8 )
      goto LABEL_13;
  }
  while ( v6 );
  return v2;
}

/*
==============
CG_FreeRadiantReflectionVolume
==============
*/
void CG_FreeRadiantReflectionVolume(RadiantRemoteReflectionVolume *radiantReflectionVolume)
{
  if ( !radiantReflectionVolume && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\radiant_remote.cpp", 1324, ASSERT_TYPE_ASSERT, "(radiantReflectionVolume)", (const char *)&queryFormat, "radiantReflectionVolume") )
    __debugbreak();
  if ( !radiantReflectionVolume->active && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\radiant_remote.cpp", 1325, ASSERT_TYPE_ASSERT, "(radiantReflectionVolume->active)", (const char *)&queryFormat, "radiantReflectionVolume->active") )
    __debugbreak();
  radiantReflectionVolume->active = 0;
}

/*
==============
CG_FreeRadiantVolumetric
==============
*/
void CG_FreeRadiantVolumetric(RadiantRemoteVolumetric *radiantVolumetric)
{
  if ( !radiantVolumetric && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\radiant_remote.cpp", 414, ASSERT_TYPE_ASSERT, "(radiantVolumetric)", (const char *)&queryFormat, "radiantVolumetric") )
    __debugbreak();
  if ( !radiantVolumetric->active && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\radiant_remote.cpp", 415, ASSERT_TYPE_ASSERT, "(radiantVolumetric->active)", (const char *)&queryFormat, "radiantVolumetric->active") )
    __debugbreak();
  radiantVolumetric->active = 0;
}

/*
==============
CG_GetDecalVolume
==============
*/
bool CG_GetDecalVolume(const SpawnVar *spawnVar, unsigned int *outUid, unsigned int *outIndex, bool *outIsDynamic)
{
  unsigned int DecalVolumeUid; 

  DecalVolumeUid = CG_GetDecalVolumeUid(spawnVar);
  if ( outUid )
    *outUid = DecalVolumeUid;
  return R_DecalVolumes_GetUID(DecalVolumeUid, outIndex, outIsDynamic);
}

/*
==============
CG_GetDecalVolumeUid
==============
*/
__int64 CG_GetDecalVolumeUid(const SpawnVar *spawnVar)
{
  const char *PairValue; 
  checksum128_t checksumOut; 

  PairValue = GetPairValue(spawnVar, "uid");
  if ( !PairValue && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\radiant_remote.cpp", 1007, ASSERT_TYPE_ASSERT, "(uid_string)", (const char *)&queryFormat, "uid_string") )
    __debugbreak();
  Core_StringToChecksum(PairValue, &checksumOut);
  return checksumOut.hash[0] ^ ((checksumOut.hash[0] >> 2) + checksumOut.hash[1] + (checksumOut.hash[0] << 6) - 1640531527) ^ (((checksumOut.hash[0] ^ ((checksumOut.hash[0] >> 2) + checksumOut.hash[1] + (checksumOut.hash[0] << 6) - 1640531527)) << 6) + (checksumOut.hash[2] ^ ((checksumOut.hash[2] >> 2) + checksumOut.hash[3] + (checksumOut.hash[2] << 6) - 1640531527)) + ((checksumOut.hash[0] ^ ((checksumOut.hash[0] >> 2) + checksumOut.hash[1] + (checksumOut.hash[0] << 6) - 1640531527)) >> 2) - 1640531527);
}

/*
==============
CG_GetRadiantStatus
==============
*/
__int64 CG_GetRadiantStatus()
{
  return cgRadiantLiveStatus;
}

/*
==============
CG_GetRadiantSyncActive
==============
*/
__int64 CG_GetRadiantSyncActive()
{
  return cgRadiantLiveStatus & 0x3F;
}

/*
==============
CG_GetReflectionProbeIndexFromLivePath
==============
*/
__int64 CG_GetReflectionProbeIndexFromLivePath(const char *livePath)
{
  GfxWorld *world; 
  __int64 v2; 
  char *v4; 
  __int64 v5; 
  const char *v6; 
  char v7; 
  __int64 v8; 
  char v9; 

  world = rgp.world;
  v2 = 0i64;
  if ( !rgp.world->draw.reflectionProbeData.reflectionProbeCount )
    return 0i64;
  while ( 1 )
  {
    v4 = world->draw.reflectionProbeData.reflectionProbes[v2].livePath;
    if ( v4 )
      break;
LABEL_11:
    v2 = (unsigned int)(v2 + 1);
    if ( (unsigned int)v2 >= world->draw.reflectionProbeData.reflectionProbeCount )
      return 0i64;
  }
  v5 = 0x7FFFFFFFi64;
  if ( !livePath && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 181, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
    __debugbreak();
  v6 = (const char *)(livePath - v4);
  do
  {
    v7 = v4[(_QWORD)v6];
    v8 = v5;
    v9 = *v4++;
    --v5;
    if ( !v8 )
      break;
    if ( v7 != v9 )
      goto LABEL_11;
  }
  while ( v7 );
  return (unsigned int)v2;
}

/*
==============
CG_IsRadiantConnected
==============
*/
bool CG_IsRadiantConnected()
{
  return rdbgClientIsConnected(RDBG_CLIENTTYPE_RADIANT);
}

/*
==============
CG_IsRadiantSync
==============
*/
bool CG_IsRadiantSync(ERadiantSyncType syncType)
{
  return ((1 << syncType) & cgRadiantLiveStatus) == 1 << syncType;
}

/*
==============
CG_IsRadiantSyncAny
==============
*/
bool CG_IsRadiantSyncAny()
{
  return (cgRadiantLiveStatus & 0x3F) != 0;
}

/*
==============
CG_MakeReflectionProbeInstanceFeatherPositive
==============
*/
void CG_MakeReflectionProbeInstanceFeatherPositive(GfxReflectionProbeInstance *reflectionProbeInstance)
{
  unsigned int i; 

  for ( i = 0; i < 3; ++i )
  {
    if ( reflectionProbeInstance->feather.v[i] < 0.0 )
    {
      reflectionProbeInstance->feather.v[i] = COERCE_FLOAT(LODWORD(reflectionProbeInstance->feather.v[i]) & _xmm);
      reflectionProbeInstance->volumeObb.halfSize.v[i] = reflectionProbeInstance->feather.v[i] + reflectionProbeInstance->volumeObb.halfSize.v[i];
    }
    if ( reflectionProbeInstance->feather.v[i] < 0.1 )
      reflectionProbeInstance->feather.v[i] = 0.1;
  }
}

/*
==============
CG_ProcessDecalVolumeDeleteCommand
==============
*/
void CG_ProcessDecalVolumeDeleteCommand(const SpawnVar *spawnVar)
{
  unsigned int DecalVolumeUid; 
  GfxDynamicDecalVolumeIndex DynamicIndex; 

  DecalVolumeUid = CG_GetDecalVolumeUid(spawnVar);
  DynamicIndex = R_DecalVolumes_GetDynamicIndex(DecalVolumeUid);
  if ( DynamicIndex != DECAL_VOLUMES_INVALID_DYNAMIC_INDEX )
    R_DecalVolumes_ReleaseDynamic(DynamicIndex);
}

/*
==============
CG_ProcessDecalVolumeRegisterCommand
==============
*/
void CG_ProcessDecalVolumeRegisterCommand(const SpawnVar *spawnVar)
{
  unsigned int DecalVolumeUid; 
  GfxDynamicDecalVolumeIndex Dynamic; 
  bool outIsDynamic; 
  unsigned int outIndex; 
  float outEdgeFeatherZ; 
  vec3_t outBlendMapAdjust; 
  GfxStaticDecalVolumePacked dst; 
  GfxStaticDecalVolumeUnpacked decalVolume; 

  DecalVolumeUid = CG_GetDecalVolumeUid(spawnVar);
  if ( !R_DecalVolumes_GetUID(DecalVolumeUid, &outIndex, &outIsDynamic) )
  {
    Dynamic = R_DecalVolumes_AllocateDynamic(DecalVolumeUid);
    if ( Dynamic == DECAL_VOLUMES_INVALID_DYNAMIC_INDEX )
      return;
    outIndex = (unsigned __int16)Dynamic;
    outIsDynamic = 1;
  }
  CG_UpdateDecalVolumeObb(spawnVar, &decalVolume);
  CG_UpdateDecalVolumeMaterial(spawnVar, &decalVolume, &outBlendMapAdjust, &outEdgeFeatherZ, outIndex, outIsDynamic);
  R_DecalVolumes_PackOBB(&dst, &decalVolume.obb);
  R_DecalVolumes_PackUVTransform(&dst, &decalVolume.uvMatrix, &decalVolume.uvOffset);
  R_DecalVolumes_PackOpacityParams(&dst, &outBlendMapAdjust, outEdgeFeatherZ);
  R_DecalVolumes_PackMaterialInfo(&dst, decalVolume.packedMaterialInfo);
  R_DecalVolumes_DecalUpdate(outIndex, outIsDynamic, &dst);
}

/*
==============
CG_ProcessDecalVolumeSetSelectionCommand
==============
*/
void CG_ProcessDecalVolumeSetSelectionCommand(const SpawnVar *spawnVar)
{
  const char *v2; 
  const char *PairValue; 
  unsigned int i; 
  __int64 v5; 
  unsigned int v6; 
  __int64 v7; 
  const char *v8; 
  bool outIsDynamic; 
  unsigned int outIndex; 

  R_DecalVolumes_ClearSelection();
  v2 = j_va("uid%u", 0i64);
  PairValue = GetPairValue(spawnVar, v2);
  for ( i = 1; PairValue; PairValue = GetPairValue(spawnVar, v8) )
  {
    v5 = -1i64;
    v6 = -1;
    do
      ++v5;
    while ( PairValue[v5] );
    for ( ; v5; --v5 )
    {
      v7 = *(unsigned __int8 *)PairValue++;
      v6 = (v6 >> 8) ^ g_crc32Table[v7 ^ (unsigned __int8)v6];
    }
    if ( R_DecalVolumes_GetUID(~v6, &outIndex, &outIsDynamic) && !R_DecalVolumes_SetSelected(outIndex, outIsDynamic, 1) )
      break;
    v8 = j_va("uid%u", i++);
  }
}

/*
==============
CG_ProcessDecalVolumeUpdateCommand
==============
*/
void CG_ProcessDecalVolumeUpdateCommand(const SpawnVar *spawnVar)
{
  unsigned int DecalVolumeUid; 
  bool outIsDynamic; 
  unsigned int outIndex; 
  float outEdgeFeatherZ; 
  vec3_t outBlendMapAdjust; 
  GfxStaticDecalVolumePacked dst; 
  GfxStaticDecalVolumeUnpacked decalVolume; 

  DecalVolumeUid = CG_GetDecalVolumeUid(spawnVar);
  if ( R_DecalVolumes_GetUID(DecalVolumeUid, &outIndex, &outIsDynamic) )
  {
    CG_UpdateDecalVolumeObb(spawnVar, &decalVolume);
    CG_UpdateDecalVolumeMaterial(spawnVar, &decalVolume, &outBlendMapAdjust, &outEdgeFeatherZ, outIndex, outIsDynamic);
    R_DecalVolumes_PackOBB(&dst, &decalVolume.obb);
    R_DecalVolumes_PackUVTransform(&dst, &decalVolume.uvMatrix, &decalVolume.uvOffset);
    R_DecalVolumes_PackOpacityParams(&dst, &outBlendMapAdjust, outEdgeFeatherZ);
    R_DecalVolumes_PackMaterialInfo(&dst, decalVolume.packedMaterialInfo);
    R_DecalVolumes_DecalUpdate(outIndex, outIsDynamic, &dst);
  }
}

/*
==============
CG_ProcessRadiantCmd
==============
*/
void CG_ProcessRadiantCmd(RadiantCommand *command)
{
  unsigned __int64 v2; 
  void *v3; 
  RadiantCommandData v4; 
  SpawnVar spawnVar; 

  if ( s_isCommandBinary[command->type] )
  {
    if ( command->command[1] == 123 )
    {
      v2 = *(unsigned int *)&command->command[2];
      v3 = operator new[](v2);
      memcpy_0(v3, &command->command[6], (unsigned int)v2);
      if ( command->command[v2 + 6] != 125 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\radiant_remote.cpp", 1984, ASSERT_TYPE_ASSERT, "(*curr == '}')", (const char *)&queryFormat, "*curr == '}'") )
        __debugbreak();
    }
  }
  else
  {
    Com_BeginParseSession("RadiantCmd");
    ParseRadiantSpawnVars(command->command, &spawnVar);
    Com_EndParseSession();
  }
  v4.radiantCommand = command;
  v4.spawnVar = &spawnVar;
  ((void (__fastcall *)(RadiantCommandData *))g_radiantCommandTable[command->type])(&v4);
}

/*
==============
CG_ProcessRadiantCmds
==============
*/
void CG_ProcessRadiantCmds(RadiantLiveGameMode inMode)
{
  unsigned int TimeAsSeconds; 
  unsigned int v3; 
  unsigned int v4; 
  volatile int i; 
  bool v6; 
  __int64 v7; 
  float *v8; 
  __int64 v9; 
  float v10; 
  bool v11; 
  float v12; 
  float v13; 
  const vec4_t *v14; 
  float *v15; 
  float v16; 
  float v17; 
  float v18; 
  const vec4_t *v19; 
  char v20; 
  Bounds bounds; 
  Bounds v22; 
  tmat33_t<vec3_t> rotation; 
  tmat33_t<vec3_t> v24; 

  Sys_EnterCriticalSection(CRITSECT_RADIANT_CLIENT_COMMAND);
  if ( bgRadiantLiveEnabled )
  {
    TimeAsSeconds = Sys_GetTimeAsSeconds();
    v3 = lastSec;
    v4 = TimeAsSeconds;
    if ( !lastSec )
      v3 = TimeAsSeconds;
    lastSec = v3;
    if ( cgCommandCount )
    {
      Stream_ImageRecord_Disable("radiant_live_cmd");
      for ( i = 0; i < cgCommandCount; ++i )
        CG_ProcessRadiantCmd(&cgCommands[i]);
      cgRadiantLiveFlowing = 1;
      lastSec = v4;
    }
    else if ( (cgRadiantLiveStatus & 0x3F) != 0 )
    {
      v6 = cgRadiantLiveFlowing;
      if ( TimeAsSeconds > lastSec + 2 )
        v6 = 0;
      cgRadiantLiveFlowing = v6;
    }
    v7 = 128i64;
    v8 = &s_radiantVolumetrics[0].volumetric.obb.halfSize.v[2];
    v9 = 128i64;
    do
    {
      if ( *((_BYTE *)v8 - 140) )
      {
        v10 = *(v8 - 2);
        v11 = *((_BYTE *)v8 - 139) == 0;
        bounds.halfSize.v[1] = *(v8 - 1);
        *(__m256i *)rotation.m[0].v = *(__m256i *)(v8 - 11);
        v12 = *(v8 - 3);
        bounds.halfSize.v[0] = v10;
        v13 = *v8;
        v14 = &colorRed;
        if ( v11 )
          v14 = &colorWhite;
        rotation.m[2].v[2] = v12;
        bounds.midPoint.v[0] = 0.0;
        bounds.midPoint.v[1] = 0.0;
        bounds.midPoint.v[2] = 0.0;
        bounds.halfSize.v[2] = v13;
        CG_DebugBoxOriented((const vec3_t *)(v8 - 14), &bounds, &rotation, v14, 1, 0);
        R_AddVolumetricToScene((const GfxVolumetric *)(v8 - 17));
      }
      v8 += 84;
      --v9;
    }
    while ( v9 );
    v15 = &s_radiantReflectionVolumes[0].reflectionProbeInstance.volumeObb.halfSize.v[2];
    do
    {
      if ( *((_BYTE *)v15 - 168) )
      {
        v16 = *(v15 - 2);
        v11 = *((_BYTE *)v15 - 167) == 0;
        v22.halfSize.v[1] = *(v15 - 1);
        *(__m256i *)v24.m[0].v = *(__m256i *)(v15 - 11);
        v17 = *(v15 - 3);
        v22.halfSize.v[0] = v16;
        v18 = *v15;
        v19 = &colorRed;
        if ( v11 )
          v19 = &colorWhite;
        v24.m[2].v[2] = v17;
        v22.midPoint.v[0] = 0.0;
        v22.midPoint.v[1] = 0.0;
        v22.midPoint.v[2] = 0.0;
        v22.halfSize.v[2] = v18;
        CG_DebugBoxOriented((const vec3_t *)(v15 - 14), &v22, &v24, v19, 1, 0);
        R_AddReflectionProbeInstanceToScene((const GfxReflectionProbeInstance *)(v15 - 24));
      }
      v15 += 54;
      --v7;
    }
    while ( v7 );
    if ( cgRadiantLiveProcessStatus )
    {
      Stream_ImageRecord_Disable("radiant_live");
      v20 = cgRadiantLiveProcessStatus;
      if ( (cgRadiantLiveProcessStatus & 1) != 0 && (cgRadiantLiveStatus & 0x400) != 0 && inMode == RADIANT_GAMEMODE_SP )
      {
        Dvar_SetIntByName("LTNQQOMQSO", 2);
        v20 = cgRadiantLiveProcessStatus;
      }
      if ( (v20 & 2) != 0 )
      {
        Dvar_SetBoolByName("TLMMOPMSK", 1);
        Dvar_SetIntByName("PNSPTQSLN", 0);
      }
      cgRadiantLiveProcessStatus = 0;
    }
    CG_UpdateRadiantLightEffects();
  }
  cgCommandCount = 0;
  Sys_LeaveCriticalSection(CRITSECT_RADIANT_CLIENT_COMMAND);
}

/*
==============
CG_ProcessReflectionVolumeDeleteCommand
==============
*/
void CG_ProcessReflectionVolumeDeleteCommand(SpawnVar *spawnVar)
{
  const char *PairValue; 
  const char *v2; 
  RadiantRemoteReflectionVolume *RadiantReflectionVolume; 

  PairValue = GetPairValue(spawnVar, "livePath");
  v2 = PairValue;
  if ( PairValue )
  {
    RadiantReflectionVolume = CG_FindRadiantReflectionVolume(PairValue);
    if ( RadiantReflectionVolume )
    {
      CG_FreeRadiantReflectionVolume(RadiantReflectionVolume);
      CG_ShowWorldReflectionVolume(v2, 1);
    }
  }
}

/*
==============
CG_ProcessReflectionVolumeRegisterCommand
==============
*/
void CG_ProcessReflectionVolumeRegisterCommand(SpawnVar *spawnVar)
{
  const char *PairValue; 
  const char *v3; 
  RadiantRemoteReflectionVolume *RadiantReflectionVolume; 
  RadiantRemoteReflectionVolume *i; 

  PairValue = GetPairValue(spawnVar, "livePath");
  v3 = PairValue;
  if ( PairValue )
  {
    RadiantReflectionVolume = CG_FindRadiantReflectionVolume(PairValue);
    if ( !RadiantReflectionVolume )
    {
      for ( i = s_radiantReflectionVolumes; i->active; ++i )
      {
        LODWORD(RadiantReflectionVolume) = (_DWORD)RadiantReflectionVolume + 1;
        if ( (unsigned int)RadiantReflectionVolume >= 0x80 )
        {
          Com_PrintWarning(14, "Radiant Live: Too many selected reflection volume entities (max is %i), %s will not be tracked.\n", 128i64, v3);
          return;
        }
      }
      memset_0(&i->selected, 0, 0xD7ui64);
      i->active = 1;
      Core_strcpy(i->livePath, 0x40ui64, v3);
      CG_ShowWorldReflectionVolume(v3, 0);
      CG_ProcessReflectionVolumeUpdateCommand(spawnVar);
    }
  }
  else
  {
    Com_PrintWarning(14, "Radiant Live: Reflection volume select command has no livePath KVP.\n");
  }
}

/*
==============
CG_ProcessReflectionVolumeSetSelectionCommand
==============
*/
void CG_ProcessReflectionVolumeSetSelectionCommand(SpawnVar *spawnVar)
{
  RadiantRemoteReflectionVolume *v2; 
  int v3; 
  const char *v4; 
  const char *i; 
  RadiantRemoteReflectionVolume *RadiantReflectionVolume; 
  const char *v7; 

  v2 = s_radiantReflectionVolumes;
  do
  {
    v2->selected = 0;
    ++v2;
  }
  while ( v2 < (RadiantRemoteReflectionVolume *)&VFX_RAY_CAST_REST_VELOCITY_SQ_FLOAT4_693 );
  v3 = 0;
  v4 = j_va("livePath%d", 0i64);
  for ( i = GetPairValue(spawnVar, v4); i; i = GetPairValue(spawnVar, v7) )
  {
    RadiantReflectionVolume = CG_FindRadiantReflectionVolume(i);
    if ( RadiantReflectionVolume )
      RadiantReflectionVolume->selected = 1;
    v7 = j_va("livePath%d", (unsigned int)++v3);
  }
}

/*
==============
CG_ProcessReflectionVolumeUnregisterCommand
==============
*/
void CG_ProcessReflectionVolumeUnregisterCommand(SpawnVar *spawnVar)
{
  const char *PairValue; 
  const char *v2; 
  RadiantRemoteReflectionVolume *RadiantReflectionVolume; 
  RadiantRemoteReflectionVolume *v4; 

  PairValue = GetPairValue(spawnVar, "livePath");
  v2 = PairValue;
  if ( PairValue )
  {
    RadiantReflectionVolume = CG_FindRadiantReflectionVolume(PairValue);
    if ( RadiantReflectionVolume )
    {
      CG_FreeRadiantReflectionVolume(RadiantReflectionVolume);
      CG_ShowWorldReflectionVolume(v2, 1);
    }
  }
  else
  {
    v4 = s_radiantReflectionVolumes;
    do
    {
      if ( v4->active )
      {
        CG_FreeRadiantReflectionVolume(v4);
        CG_ShowWorldReflectionVolume(v4->livePath, 1);
      }
      ++v4;
    }
    while ( v4 != (RadiantRemoteReflectionVolume *)&VFX_RAY_CAST_REST_VELOCITY_SQ_FLOAT4_693 );
  }
}

/*
==============
CG_ProcessReflectionVolumeUpdateCommand
==============
*/
void CG_ProcessReflectionVolumeUpdateCommand(SpawnVar *spawnVar)
{
  const char *PairValue; 
  RadiantRemoteReflectionVolume *RadiantReflectionVolume; 
  GfxReflectionProbeInstance *p_reflectionProbeInstance; 
  const char *v5; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  const char *v9; 
  const char *v10; 
  float v11; 
  const char *v12; 
  float v13; 
  const char *v14; 
  const char *v15; 
  const char *v16; 
  const char *v17; 
  float v18; 
  float v19; 
  const char *v20; 
  float v21; 
  float v22; 
  const char *v23; 
  unsigned int v24; 
  unsigned int reflectionProbeCount; 
  char *livePath; 
  __int64 v27; 
  signed __int64 v28; 
  char v29; 
  __int64 v30; 
  char v31; 
  float v32; 
  int v33; 
  int v34; 
  float v35; 
  float v36; 
  float v37; 
  float v38; 
  float v39; 
  float v40; 
  float v41; 
  float v42; 
  float v43; 

  PairValue = GetPairValue(spawnVar, "livePath");
  if ( PairValue )
  {
    RadiantReflectionVolume = CG_FindRadiantReflectionVolume(PairValue);
    if ( RadiantReflectionVolume )
    {
      p_reflectionProbeInstance = &RadiantReflectionVolume->reflectionProbeInstance;
      memset_0(&RadiantReflectionVolume->reflectionProbeInstance, 0, sizeof(RadiantReflectionVolume->reflectionProbeInstance));
      p_reflectionProbeInstance->flags = 0;
      p_reflectionProbeInstance->probeRotation = quat_identity;
      v5 = GetPairValue(spawnVar, "obb_origin");
      if ( v5 )
        j_sscanf(v5, "%f %f %f", &p_reflectionProbeInstance->volumeObb, &p_reflectionProbeInstance->volumeObb.center.y, &p_reflectionProbeInstance->volumeObb.center.z);
      v6 = GetPairValue(spawnVar, "obb_xAxis");
      if ( v6 )
        j_sscanf(v6, "%f %f %f", &p_reflectionProbeInstance->volumeObb.xAxis, &p_reflectionProbeInstance->volumeObb.xAxis.y, &p_reflectionProbeInstance->volumeObb.xAxis.z);
      v7 = GetPairValue(spawnVar, "obb_yAxis");
      if ( v7 )
        j_sscanf(v7, "%f %f %f", &p_reflectionProbeInstance->volumeObb.yAxis, &p_reflectionProbeInstance->volumeObb.yAxis.y, &p_reflectionProbeInstance->volumeObb.yAxis.z);
      v8 = GetPairValue(spawnVar, "obb_zAxis");
      if ( v8 )
        j_sscanf(v8, "%f %f %f", &p_reflectionProbeInstance->volumeObb.zAxis, &p_reflectionProbeInstance->volumeObb.zAxis.y, &p_reflectionProbeInstance->volumeObb.zAxis.z);
      v9 = GetPairValue(spawnVar, "obb_halfSize");
      if ( v9 )
        j_sscanf(v9, "%f %f %f", &p_reflectionProbeInstance->volumeObb.halfSize, &p_reflectionProbeInstance->volumeObb.halfSize.y, &p_reflectionProbeInstance->volumeObb.halfSize.z);
      *(_QWORD *)p_reflectionProbeInstance->expandProjectionNeg.v = 0i64;
      p_reflectionProbeInstance->expandProjectionNeg.v[2] = 0.0;
      v10 = GetPairValue(spawnVar, "expandProjectionNeg");
      if ( v10 && j_sscanf(v10, "%f %f %f", &v41, &v42, &v43) == 3 )
      {
        v11 = v42;
        p_reflectionProbeInstance->expandProjectionNeg.v[0] = v41;
        p_reflectionProbeInstance->expandProjectionNeg.v[2] = v43;
        p_reflectionProbeInstance->expandProjectionNeg.v[1] = v11;
      }
      *(_QWORD *)p_reflectionProbeInstance->expandProjectionPos.v = 0i64;
      p_reflectionProbeInstance->expandProjectionPos.v[2] = 0.0;
      v12 = GetPairValue(spawnVar, "expandProjectionPos");
      if ( v12 && j_sscanf(v12, "%f %f %f", &v41, &v42, &v43) == 3 )
      {
        v13 = v42;
        p_reflectionProbeInstance->expandProjectionPos.v[0] = v41;
        p_reflectionProbeInstance->expandProjectionPos.v[2] = v43;
        p_reflectionProbeInstance->expandProjectionPos.v[1] = v13;
      }
      v14 = GetPairValue(spawnVar, "priority");
      p_reflectionProbeInstance->priority = -1.0;
      if ( v14 && j_sscanf(v14, "%f", &v32) == 1 )
        p_reflectionProbeInstance->priority = v32;
      v15 = GetPairValue(spawnVar, "noParallax");
      if ( v15 && j_sscanf(v15, "%d", &v33) == 1 && v33 == 1 )
        p_reflectionProbeInstance->flags |= 1u;
      v16 = GetPairValue(spawnVar, "overrideLightgrid");
      if ( v16 && j_sscanf(v16, "%d", &v34) == 1 && v34 == 1 )
        p_reflectionProbeInstance->flags |= 4u;
      p_reflectionProbeInstance->feather.v[0] = 8.0;
      p_reflectionProbeInstance->feather.v[1] = 8.0;
      p_reflectionProbeInstance->feather.v[2] = 8.0;
      v17 = GetPairValue(spawnVar, "feather");
      if ( v17 && j_sscanf(v17, "%f %f %f", &v37, &v36, &v35) == 3 )
      {
        v18 = v35;
        v19 = v36;
        p_reflectionProbeInstance->feather.v[0] = v37;
        p_reflectionProbeInstance->feather.v[1] = v19;
        p_reflectionProbeInstance->feather.v[2] = v18;
      }
      *(_QWORD *)p_reflectionProbeInstance->probePosition.v = 0i64;
      p_reflectionProbeInstance->probePosition.v[2] = 0.0;
      v20 = GetPairValue(spawnVar, "probePosition");
      if ( v20 )
      {
        if ( j_sscanf(v20, "%f %f %f", &v40, &v39, &v38) == 3 )
        {
          v21 = v38;
          v22 = v39;
          p_reflectionProbeInstance->probePosition.v[0] = v40;
          p_reflectionProbeInstance->probePosition.v[1] = v22;
          p_reflectionProbeInstance->probePosition.v[2] = v21;
        }
      }
      v23 = GetPairValue(spawnVar, "reflectionProbeLivePath");
      if ( v23 )
      {
        v24 = 0;
        reflectionProbeCount = rgp.world->draw.reflectionProbeData.reflectionProbeCount;
        if ( reflectionProbeCount )
        {
          while ( 1 )
          {
            livePath = rgp.world->draw.reflectionProbeData.reflectionProbes[v24].livePath;
            if ( livePath )
              break;
LABEL_45:
            if ( ++v24 >= reflectionProbeCount )
              goto LABEL_46;
          }
          v27 = 0x7FFFFFFFi64;
          v28 = v23 - livePath;
          do
          {
            v29 = livePath[v28];
            v30 = v27;
            v31 = *livePath++;
            --v27;
            if ( !v30 )
              break;
            if ( v29 != v31 )
              goto LABEL_45;
          }
          while ( v29 );
        }
        else
        {
LABEL_46:
          v24 = 0;
        }
        p_reflectionProbeInstance->probeImageIndex = truncate_cast<unsigned short,unsigned int>(v24);
      }
      CG_MakeReflectionProbeInstanceFeatherPositive(p_reflectionProbeInstance);
    }
  }
  else
  {
    Com_PrintWarning(14, "Radiant Live: Reflection volume update command has no livePath KVP.\n");
  }
}

/*
==============
CG_ProcessVolumetricDeleteCommand
==============
*/
void CG_ProcessVolumetricDeleteCommand(SpawnVar *spawnVar)
{
  const char *PairValue; 
  const char *v2; 
  RadiantRemoteVolumetric *RadiantVolumetric; 

  PairValue = GetPairValue(spawnVar, "livePath");
  v2 = PairValue;
  if ( PairValue )
  {
    RadiantVolumetric = CG_FindRadiantVolumetric(PairValue);
    if ( RadiantVolumetric )
      CG_FreeRadiantVolumetric(RadiantVolumetric);
    CG_ShowWorldVolumetric(v2, 0);
  }
}

/*
==============
CG_ProcessVolumetricRegisterCommand
==============
*/
void CG_ProcessVolumetricRegisterCommand(SpawnVar *spawnVar)
{
  const char *PairValue; 
  const char *v3; 
  RadiantRemoteVolumetric *RadiantVolumetric; 
  RadiantRemoteVolumetric *i; 

  PairValue = GetPairValue(spawnVar, "livePath");
  v3 = PairValue;
  if ( PairValue )
  {
    RadiantVolumetric = CG_FindRadiantVolumetric(PairValue);
    if ( !RadiantVolumetric )
    {
      for ( i = s_radiantVolumetrics; i->active; ++i )
      {
        LODWORD(RadiantVolumetric) = (_DWORD)RadiantVolumetric + 1;
        if ( (unsigned int)RadiantVolumetric >= 0x80 )
        {
          Com_PrintWarning(14, "Radiant Live: Too many selected volumetric entities (max is %i), %s will not be tracked.\n", 128i64, v3);
          return;
        }
      }
      memset_0(&i->selected, 0, 0x14Fui64);
      i->active = 1;
      Core_strcpy(i->livePath, 0x40ui64, v3);
      CG_ShowWorldVolumetric(v3, 0);
      CG_ProcessVolumetricUpdateCommand(spawnVar);
    }
  }
  else
  {
    Com_PrintWarning(14, "Radiant Live: Volumetric select command has no livePath KVP.\n");
  }
}

/*
==============
CG_ProcessVolumetricSetSelectionCommand
==============
*/
void CG_ProcessVolumetricSetSelectionCommand(SpawnVar *spawnVar)
{
  RadiantRemoteVolumetric *v2; 
  int v3; 
  const char *v4; 
  const char *i; 
  RadiantRemoteVolumetric *RadiantVolumetric; 
  const char *v7; 

  v2 = s_radiantVolumetrics;
  do
  {
    v2->selected = 0;
    ++v2;
  }
  while ( v2 < (RadiantRemoteVolumetric *)s_radiantReflectionVolumes );
  v3 = 0;
  v4 = j_va("livePath%d", 0i64);
  for ( i = GetPairValue(spawnVar, v4); i; i = GetPairValue(spawnVar, v7) )
  {
    RadiantVolumetric = CG_FindRadiantVolumetric(i);
    if ( RadiantVolumetric )
      RadiantVolumetric->selected = 1;
    v7 = j_va("livePath%d", (unsigned int)++v3);
  }
}

/*
==============
CG_ProcessVolumetricUnregisterCommand
==============
*/
void CG_ProcessVolumetricUnregisterCommand(SpawnVar *spawnVar)
{
  const char *PairValue; 
  const char *v2; 
  RadiantRemoteVolumetric *RadiantVolumetric; 
  RadiantRemoteVolumetric *v4; 

  PairValue = GetPairValue(spawnVar, "livePath");
  v2 = PairValue;
  if ( PairValue )
  {
    RadiantVolumetric = CG_FindRadiantVolumetric(PairValue);
    if ( RadiantVolumetric )
    {
      CG_FreeRadiantVolumetric(RadiantVolumetric);
      CG_ShowWorldVolumetric(v2, 1);
    }
  }
  else
  {
    v4 = s_radiantVolumetrics;
    do
    {
      if ( v4->active )
      {
        CG_FreeRadiantVolumetric(v4);
        CG_ShowWorldVolumetric(v4->livePath, 1);
      }
      ++v4;
    }
    while ( v4 != (RadiantRemoteVolumetric *)s_radiantReflectionVolumes );
  }
}

/*
==============
CG_ProcessVolumetricUpdateCommand
==============
*/
void CG_ProcessVolumetricUpdateCommand(SpawnVar *spawnVar)
{
  SpawnVar *v1; 
  const char *PairValue; 
  RadiantRemoteVolumetric *RadiantVolumetric; 
  const char *v4; 
  const char *v5; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  const char *v9; 
  float v10; 
  double v11; 
  const char *v12; 
  const char *v17; 
  float v18; 
  double v20; 
  const char *v21; 
  float v22; 
  double v23; 
  const char *v24; 
  int v25; 
  unsigned int flags; 
  unsigned int v27; 
  int v28; 
  const char *v29; 
  float v30; 
  const char *v31; 
  int v32; 
  float *v33; 
  VolumetricMaskKey *v34; 
  unsigned int v35; 
  unsigned int v36; 
  const char **v37; 
  unsigned int v38; 
  const char *v39; 
  const char *v40; 
  XAssetHeader v41; 
  const char *v42; 
  const char *v43; 
  unsigned int i; 
  const char *name; 
  __int64 v46; 
  const char *v47; 
  signed __int64 v48; 
  int v49; 
  __int64 v50; 
  int v51; 
  int v52; 
  int v53; 
  const char *v54; 
  const char *v55; 
  float v56; 
  const char *v61; 
  const char *v62; 
  float v63; 
  const char *v64; 
  const char *v65; 
  float v66; 
  float v67; 
  float v68; 
  unsigned int v69; 
  float v70; 
  float v71; 
  int v72; 
  int v73; 
  SpawnVar *spawnVara; 
  float v75; 
  float v76; 
  float v77; 
  float v78; 
  float v79; 
  float v80; 
  float v81; 
  float v82; 
  float v83; 

  spawnVara = spawnVar;
  v1 = spawnVar;
  PairValue = GetPairValue(spawnVar, "livePath");
  if ( !PairValue )
  {
    Com_PrintWarning(14, "Radiant Live: Volumetric update command has no livePath KVP.\n");
    return;
  }
  RadiantVolumetric = CG_FindRadiantVolumetric(PairValue);
  if ( RadiantVolumetric )
  {
    v4 = GetPairValue(v1, "obb_origin");
    if ( !v4 || j_sscanf(v4, "%f %f %f", &RadiantVolumetric->volumetric.obb, &RadiantVolumetric->volumetric.obb.center.y, &RadiantVolumetric->volumetric.obb.center.z) != 3 )
      Com_PrintWarning(14, "Radiant Live: Volumetric missing or incomplete origin.\n");
    v5 = GetPairValue(v1, "obb_xAxis");
    if ( !v5 || j_sscanf(v5, "%f %f %f", &RadiantVolumetric->volumetric.obb.xAxis, &RadiantVolumetric->volumetric.obb.xAxis.y, &RadiantVolumetric->volumetric.obb.xAxis.z) != 3 )
      Com_PrintWarning(14, "Radiant Live: Volumetric missing or incomplete xAxis.\n");
    v6 = GetPairValue(v1, "obb_yAxis");
    if ( !v6 || j_sscanf(v6, "%f %f %f", &RadiantVolumetric->volumetric.obb.yAxis, &RadiantVolumetric->volumetric.obb.yAxis.y, &RadiantVolumetric->volumetric.obb.yAxis.z) != 3 )
      Com_PrintWarning(14, "Radiant Live: Volumetric missing or incomplete yAxis.\n");
    v7 = GetPairValue(v1, "obb_zAxis");
    if ( !v7 || j_sscanf(v7, "%f %f %f", &RadiantVolumetric->volumetric.obb.zAxis, &RadiantVolumetric->volumetric.obb.zAxis.y, &RadiantVolumetric->volumetric.obb.zAxis.z) != 3 )
      Com_PrintWarning(14, "Radiant Live: Volumetric missing or incomplete zAxis.\n");
    v8 = GetPairValue(v1, "obb_halfSize");
    if ( !v8 || j_sscanf(v8, "%f %f %f", &RadiantVolumetric->volumetric.obb.halfSize, &RadiantVolumetric->volumetric.obb.halfSize.y, &RadiantVolumetric->volumetric.obb.halfSize.z) != 3 )
      Com_PrintWarning(14, "Radiant Live: Volumetric missing or incomplete halfSize.\n");
    v9 = GetPairValue(v1, "density");
    if ( v9 && j_sscanf(v9, "%f", &v70) == 1 )
    {
      v10 = v70;
    }
    else
    {
      Com_PrintWarning(14, "Radiant Live: Volumetric is missing density, will use default: %.2f\n", DOUBLE_0_1000000014901161);
      v10 = FLOAT_0_1;
      v70 = FLOAT_0_1;
    }
    v11 = I_fclamp(v10 * 0.0099999998, 0.0, 1.0);
    RadiantVolumetric->volumetric.density = *(float *)&v11;
    v12 = GetPairValue(v1, "falloff");
    if ( v12 && j_sscanf(v12, "%f", &v67) == 1 )
    {
      if ( v67 > 0.0 )
      {
LABEL_29:
        _XMM0 = LODWORD(RadiantVolumetric->volumetric.obb.halfSize.v[1]);
        __asm
        {
          vminss  xmm1, xmm0, dword ptr [rbx+84h]
          vminss  xmm2, xmm1, dword ptr [rbx+8Ch]
          vminss  xmm3, xmm2, xmm3
        }
        RadiantVolumetric->volumetric.falloff = *(float *)&_XMM3;
        v17 = GetPairValue(v1, "height_fade");
        if ( v17 && j_sscanf(v17, "%f", &v68) == 1 )
        {
          v18 = v68;
          if ( v68 >= 0.0 )
          {
LABEL_35:
            v20 = I_fclamp(v18, 0.0, 1.0);
            RadiantVolumetric->volumetric.heightFade = *(float *)&v20;
            v21 = GetPairValue(v1, "anisotropy");
            if ( v21 && j_sscanf(v21, "%f", &v71) == 1 )
            {
              v22 = v71;
            }
            else
            {
              Com_PrintWarning(14, "Radiant Live: Volumetric is missing anisotropy, will be disabled.\n");
              v22 = 0.0;
              v71 = 0.0;
            }
            v23 = I_fclamp(v22, -1.0, 1.0);
            RadiantVolumetric->volumetric.anisotropy = *(float *)&v23;
            v24 = GetPairValue(v1, "anisotropy_enabled");
            if ( v24 && j_sscanf(v24, "%i", &v72) == 1 )
            {
              v25 = v72;
            }
            else
            {
              Com_PrintWarning(14, "Radiant Live: Volumetric is missing anisotropy_enabled, will be disabled.\n");
              v25 = 0;
              v72 = 0;
            }
            flags = RadiantVolumetric->volumetric.flags;
            v27 = flags & 0xFFFFFFFD;
            v28 = flags | 2;
            if ( v25 )
              v27 = v28;
            RadiantVolumetric->volumetric.flags = v27;
            v29 = GetPairValue(v1, "color");
            if ( v29 && j_sscanf(v29, "%f %f %f", &v81, &v82, &v83) == 3 )
            {
              v30 = v81;
            }
            else
            {
              Com_PrintWarning(14, "Radiant Live: Volumetric color missing or incomplete, will use [%.1f %.1f %.1f]\n", DOUBLE_1_0, DOUBLE_1_0, DOUBLE_1_0);
              v30 = FLOAT_1_0;
              v81 = FLOAT_1_0;
              v82 = FLOAT_1_0;
              v83 = FLOAT_1_0;
            }
            RadiantVolumetric->volumetric.color.v[0] = v30;
            RadiantVolumetric->volumetric.color.v[1] = v82;
            RadiantVolumetric->volumetric.color.v[2] = v83;
            v31 = GetPairValue(v1, "color_enabled");
            if ( v31 && j_sscanf(v31, "%i", &v73) == 1 )
            {
              v32 = v73;
            }
            else
            {
              Com_PrintWarning(14, "Radiant Live: Volumetric is missing color_enabled, will be disabled.\n");
              v32 = 0;
              v73 = 0;
            }
            v33 = (float *)&RadiantVolumetric->volumetric.masks[0].offset + 1;
            v34 = s_maskAxes;
            v35 = RadiantVolumetric->volumetric.flags & 0xFFFFFFFB;
            if ( v32 )
              v35 = RadiantVolumetric->volumetric.flags | 4;
            v36 = 0;
            v69 = 0;
            RadiantVolumetric->volumetric.flags = v35;
            do
            {
              *(v33 - 7) = 0.0;
              v37 = s_maskTypes;
              v38 = 0;
              *(_QWORD *)(v33 - 5) = rgp.whiteImage;
              while ( 1 )
              {
                v39 = j_va("mask%d%s", v36, *v37);
                v40 = GetPairValue(v1, v39);
                if ( v40 )
                {
                  if ( *v40 )
                  {
                    v41.physicsLibrary = DB_FindXAssetHeader(ASSET_TYPE_IMAGE, v40, 0).physicsLibrary;
                    if ( v41.physicsLibrary )
                      break;
                  }
                }
                ++v38;
                ++v37;
                if ( v38 >= 3 )
                  goto LABEL_63;
              }
              *((_DWORD *)v33 - 7) = v38;
              *(XAssetHeader *)(v33 - 5) = v41;
LABEL_63:
              if ( v38 == 3 )
              {
                Com_PrintWarning(14, "Radiant Live: Volumetric mask %d type not specified, this mask will be ignored.\n", v36);
              }
              else if ( v38 )
              {
                *((_DWORD *)v33 - 6) = 2;
                v42 = j_va("mask%daxis", v36);
                v43 = GetPairValue(v1, v42);
                if ( v43 )
                {
                  for ( i = 0; i < 6; ++i )
                  {
                    name = v34->name;
                    v46 = 0x7FFFFFFFi64;
                    v47 = v43;
                    if ( !v34->name && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 213, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
                      __debugbreak();
                    v48 = name - v43;
                    while ( 1 )
                    {
                      v49 = *(unsigned __int8 *)v47;
                      v50 = v46;
                      v51 = (unsigned __int8)(v47++)[v48];
                      --v46;
                      if ( !v50 )
                      {
LABEL_80:
                        v34 = s_maskAxes;
                        *(v33 - 6) = *(float *)&s_maskAxes[i].value;
                        goto LABEL_83;
                      }
                      if ( v49 != v51 )
                      {
                        v52 = v49 + 32;
                        if ( (unsigned int)(v49 - 65) > 0x19 )
                          v52 = v49;
                        v49 = v52;
                        v53 = v51 + 32;
                        if ( (unsigned int)(v51 - 65) > 0x19 )
                          v53 = v51;
                        if ( v49 != v53 )
                          break;
                      }
                      if ( !v49 )
                        goto LABEL_80;
                    }
                    ++v34;
                  }
                  v34 = s_maskAxes;
LABEL_83:
                  v36 = v69;
                  if ( i == 6 )
                    Com_PrintWarning(14, "Radiant Live: Volumetric mask %d has invalid axis: %s, using +Z axis instead, but this will fail map compile!.\n", v69, v43);
                }
                else
                {
                  Com_PrintWarning(14, "Radiant Live: Volumetric mask %d axis not specified, will use +Z axis.\n", v36);
                }
                v54 = j_va("mask%dscale", v36);
                v1 = spawnVara;
                v55 = GetPairValue(spawnVara, v54);
                if ( v55 && j_sscanf(v55, "%f %f", &v75, &v76) == 2 )
                {
                  v56 = v75;
                }
                else
                {
                  Com_PrintWarning(14, "Radiant Live: Volumetric mask %d scale missing or incomplete, will use [%.1f %.1f]\n", v36, DOUBLE_1_0, DOUBLE_1_0);
                  v56 = FLOAT_1_0;
                  v75 = FLOAT_1_0;
                  v76 = FLOAT_1_0;
                }
                *(v33 - 3) = v56;
                _XMM1 = *((unsigned int *)v33 - 3);
                *(v33 - 2) = v76;
                if ( *(float *)&_XMM1 < 1.0 || v76 < 1.0 )
                {
                  Com_PrintWarning(14, "Radiant Live: Volumetric scale is smaller than the minimum, this will fail the map compile.\n");
                  _XMM1 = *((unsigned int *)v33 - 3);
                }
                __asm { vmaxss  xmm0, xmm1, xmm6 }
                *(v33 - 3) = *(float *)&_XMM0;
                _XMM1 = *((unsigned int *)v33 - 2);
                __asm { vmaxss  xmm2, xmm1, xmm6 }
                *(v33 - 2) = *(float *)&_XMM2;
                v61 = j_va("mask%doffset", v36);
                v62 = GetPairValue(v1, v61);
                if ( v62 && j_sscanf(v62, "%f %f", &v77, &v78) == 2 )
                {
                  v63 = v77;
                }
                else
                {
                  Com_PrintWarning(14, "Radiant Live: Volumetric mask %d offset missing or incomplete, will use [0 0]\n", v36);
                  v63 = 0.0;
                  v77 = 0.0;
                  v78 = 0.0;
                }
                *(v33 - 1) = v63;
                *v33 = v78;
                v64 = j_va("mask%dscroll", v36);
                v65 = GetPairValue(v1, v64);
                if ( v65 && j_sscanf(v65, "%f %f", &v79, &v80) == 2 )
                {
                  v66 = v79;
                }
                else
                {
                  Com_PrintWarning(14, "Radiant Live: Volumetric mask %d scroll missing or incomplete, will use [0 0]\n", v36);
                  v66 = 0.0;
                  v79 = 0.0;
                  v80 = 0.0;
                }
                v33[1] = v66;
                v33[2] = v80;
              }
              ++v36;
              v33 += 10;
              v69 = v36;
            }
            while ( v36 < 4 );
            return;
          }
          Com_PrintWarning(14, "Radiant Live: Volumetric has negative height_fade, using default, but this will fail map compile!.\n");
        }
        else
        {
          __asm { vxorpd  xmm2, xmm2, xmm2 }
          Com_PrintWarning(14, "Radiant Live: Volumetric is missing height_fade, will use default: %.2f.\n", (_QWORD)_XMM2);
        }
        v18 = 0.0;
        v68 = 0.0;
        goto LABEL_35;
      }
      Com_PrintWarning(14, "Radiant Live: Volumetric has zero or negative falloff, using default, but this will fail map compile!.\n");
    }
    else
    {
      Com_PrintWarning(14, "Radiant Live: Volumetric is missing falloff, will use default: %.2f.\n", DOUBLE_20_0);
    }
    v67 = FLOAT_20_0;
    goto LABEL_29;
  }
}

/*
==============
CG_SetRadiantStatus
==============
*/
void CG_SetRadiantStatus(unsigned int inMask)
{
  __int16 v1; 
  unsigned int v2; 

  v1 = inMask ^ cgRadiantLiveStatus;
  v2 = inMask & 0x7FF;
  cgRadiantLiveStatus = v2;
  if ( (v1 & 0x7FF) != 0 || !triggerCnt )
  {
    cgRadiantLiveProcessStatus = v2 | 0x800;
    Sys_EnterCriticalSection(CRITSECT_RADIANT_SERVER_COMMAND);
    gRadiantLiveProcessStatus = cgRadiantLiveStatus | 0x800;
    Sys_LeaveCriticalSection(CRITSECT_RADIANT_SERVER_COMMAND);
    triggerCnt = 4;
  }
  else
  {
    --triggerCnt;
  }
}

/*
==============
CG_SetRadiantStatusOff
==============
*/
void CG_SetRadiantStatusOff(void)
{
  cgRadiantLiveStatus = 0;
  cgRadiantLiveProcessStatus = 0;
  Sys_EnterCriticalSection(CRITSECT_RADIANT_SERVER_COMMAND);
  gRadiantLiveProcessStatus = 0;
  Sys_LeaveCriticalSection(CRITSECT_RADIANT_SERVER_COMMAND);
}

/*
==============
CG_ShowWorldReflectionVolume
==============
*/
void CG_ShowWorldReflectionVolume(const char *livePath, bool show)
{
  __int64 v2; 
  __int64 v5; 
  GfxReflectionProbeInstance *v6; 
  char *v7; 
  const char *v8; 
  char v9; 
  __int64 v10; 
  char v11; 
  unsigned __int8 flags; 
  unsigned __int8 v13; 

  v2 = 0i64;
  if ( rgp.world->draw.reflectionProbeData.reflectionProbeInstanceCount )
  {
LABEL_2:
    v5 = 0x7FFFFFFFi64;
    v6 = &rgp.world->draw.reflectionProbeData.reflectionProbeInstances[v2];
    v7 = v6->livePath;
    if ( !livePath && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 181, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
      __debugbreak();
    if ( !v7 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
      __debugbreak();
    v8 = (const char *)(livePath - v7);
    do
    {
      v9 = v7[(_QWORD)v8];
      v10 = v5;
      v11 = *v7++;
      --v5;
      if ( !v10 )
        break;
      if ( v9 != v11 )
      {
        v2 = (unsigned int)(v2 + 1);
        if ( (unsigned int)v2 >= rgp.world->draw.reflectionProbeData.reflectionProbeInstanceCount )
          return;
        goto LABEL_2;
      }
    }
    while ( v9 );
    flags = v6->flags;
    if ( show )
      v13 = flags & 0x7F;
    else
      v13 = flags | 0x80;
    v6->flags = v13;
  }
}

/*
==============
CG_ShowWorldVolumetric
==============
*/
void CG_ShowWorldVolumetric(const char *livePath, bool show)
{
  int v2; 
  __int64 v5; 
  GfxVolumetric *v6; 
  char *v7; 
  const char *v8; 
  char v9; 
  __int64 v10; 
  char v11; 
  unsigned int flags; 
  unsigned int v13; 

  v2 = 0;
  if ( rgp.world->draw.volumetrics.volumetricCount )
  {
LABEL_2:
    v5 = 0x7FFFFFFFi64;
    v6 = &rgp.world->draw.volumetrics.volumetrics[v2];
    v7 = v6->livePath;
    if ( !livePath && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 181, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
      __debugbreak();
    if ( !v7 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 182, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
      __debugbreak();
    v8 = (const char *)(livePath - v7);
    do
    {
      v9 = v7[(_QWORD)v8];
      v10 = v5;
      v11 = *v7++;
      --v5;
      if ( !v10 )
        break;
      if ( v9 != v11 )
      {
        if ( ++v2 >= rgp.world->draw.volumetrics.volumetricCount )
          return;
        goto LABEL_2;
      }
    }
    while ( v9 );
    flags = v6->flags;
    if ( show )
      v13 = flags & 0xFFFFFFFE;
    else
      v13 = flags | 1;
    v6->flags = v13;
  }
}

/*
==============
CG_UpdateDecalVolumeMaterial
==============
*/
void CG_UpdateDecalVolumeMaterial(const SpawnVar *spawnVar, GfxStaticDecalVolumeUnpacked *decalVolume, vec3_t *outBlendMapAdjust, float *outEdgeFeatherZ, unsigned int decalIndex, bool isDynamic)
{
  const char *PairValue; 
  Material *v11; 
  GfxDecalVolumeMaterial *v12; 
  Material *v13; 
  GfxDecalVolumeMaterial *decalVolumeMaterial; 
  const char *v15; 
  int v16; 
  const char *v17; 
  GfxDecalVolumeMask *v18; 
  const char *v19; 
  const char *v20; 
  unsigned __int8 v21; 
  const char *v22; 
  float v23; 
  double v24; 
  const char *v25; 
  const char *v26; 
  const char *v27; 
  const char *v28; 
  float v29; 
  float v31; 
  float v32; 
  float v34; 
  const char *v35; 
  const char *v36; 
  const char *v37; 
  const char *v38; 
  const char *v39; 
  const char *v40; 
  const char *v41; 
  const char *v42; 
  const char *v43; 
  GfxImage **i; 
  GfxImage *v45; 
  unsigned __int16 width; 
  unsigned __int16 height; 
  float v48; 
  vec4_t v49; 
  DecalVolumesNormalBlendMode outNormalBlendMode; 
  float v51; 
  GfxDecalVolumeMaterial *outMaterial; 
  float v53; 
  float v54; 
  float v55; 
  float v56; 
  vec2_t v57; 
  float v58; 
  GfxDecalVolumeMask *outMask; 
  unsigned int drawOrder; 
  unsigned int mapIndex; 
  vec2_t uvShift; 
  vec2_t uvScale; 
  vec3_t size_max; 
  vec3_t v65; 
  vec2_t outUvOffset; 
  vec3_t v67; 
  vec3_t _size_min; 
  vec4_t outUvMatrix; 
  char dest[512]; 

  R_DecalVolumes_GetMaterialInfo(decalIndex, isDynamic, &outMaterial, &outMask, &outNormalBlendMode, &mapIndex, &drawOrder);
  PairValue = GetPairValue(spawnVar, "modeloverridematerial");
  if ( PairValue )
  {
    Com_sprintf(dest, 0x1FFui64, "%s/%s", "i", PairValue);
    dest[511] = 0;
    if ( outMaterial )
    {
      if ( I_strcmp(outMaterial->name, dest) )
      {
        v13 = Material_Register(dest, IMAGE_TRACK_EMBLEM);
        if ( v13 )
        {
          decalVolumeMaterial = v13->decalVolumeMaterial;
          v12 = outMaterial;
          if ( decalVolumeMaterial )
            v12 = decalVolumeMaterial;
          goto LABEL_9;
        }
      }
    }
    else
    {
      v11 = Material_Register(dest, IMAGE_TRACK_EMBLEM);
      if ( v11 )
      {
        v12 = v11->decalVolumeMaterial;
LABEL_9:
        outMaterial = v12;
      }
    }
  }
  v15 = GetPairValue(spawnVar, "blendMapImageName");
  v16 = 0;
  v17 = v15;
  if ( v15 && *v15 )
  {
    if ( !outMask || !outMask->blendMap || I_strcmp(outMask->name, v15) )
    {
      v18 = R_DecalVolume_RegisterMask(v17, IMAGE_TRACK_EMBLEM);
      outMask = v18;
      if ( v18 )
        R_DecalVolumes_StartStreaming(v18->blendMap);
    }
  }
  else
  {
    outMask = NULL;
  }
  v19 = GetPairValue(spawnVar, "normalBlendModeOverride");
  v20 = v19;
  if ( v19 && *v19 )
  {
    v21 = outNormalBlendMode;
    if ( I_stricmp(v19, "blend") )
    {
      if ( I_stricmp(v20, "add") )
      {
        if ( I_stricmp(v20, "no_override") )
        {
          Com_PrintWarning(8, "WARNING: Invalid normal blend mode for decal volume: '%s'\n", v20);
          LOBYTE(outNormalBlendMode) = v21;
        }
        else
        {
          v21 = 2;
          LOBYTE(outNormalBlendMode) = 2;
        }
      }
      else
      {
        v21 = 1;
        LOBYTE(outNormalBlendMode) = 1;
      }
    }
    else
    {
      v21 = 0;
      LOBYTE(outNormalBlendMode) = 0;
    }
  }
  else
  {
    v21 = outNormalBlendMode;
  }
  decalVolume->packedMaterialInfo = R_DecalVolumes_RadiantLive_PackMaterialInfo(outMaterial, outMask, (DecalVolumesNormalBlendMode)v21, mapIndex, drawOrder).packed;
  v22 = GetPairValue(spawnVar, "edgeFeatherZ");
  if ( v22 )
  {
    v53 = 0.0;
    j_sscanf(v22, "%f", &v53);
    v23 = v53;
    *outEdgeFeatherZ = v53;
    v24 = R_DecalVolumes_CalculateZFeatherRcp(v23, decalVolume->obb.halfSize.v[0]);
  }
  else
  {
    *(float *)&v24 = FLOAT_N100000_0;
  }
  decalVolume->zFeatherRcp = *(float *)&v24;
  v25 = GetPairValue(spawnVar, "blendMapAdjustEdge0");
  v26 = GetPairValue(spawnVar, "blendMapAdjustEdge1");
  v27 = GetPairValue(spawnVar, "blendMapAdjustScale");
  v28 = v27;
  if ( v25 && v26 && v27 )
  {
    v29 = FLOAT_1_0;
    v55 = FLOAT_1_0;
    v56 = FLOAT_1_0;
    v54 = 0.0;
    j_sscanf(v25, "%f", &v54);
    j_sscanf(v26, "%f", &v55);
    j_sscanf(v28, "%f", &v56);
    _XMM0 = LODWORD(v54);
    v31 = v55;
    v32 = v56;
    __asm { vunpcklps xmm3, xmm0, xmm1 }
    v58 = v56;
    v34 = v56;
    *(double *)outBlendMapAdjust->v = *(double *)&_XMM3;
    outBlendMapAdjust->v[2] = v34;
    R_DecalVolumes_PrecalculateBlendMapAdjust(*(float *)&_XMM0, v31, v32, &decalVolume->blendMapAdjust);
  }
  else
  {
    v29 = FLOAT_1_0;
    v57.v[0] = FLOAT_1_0;
    v57.v[1] = 0.0;
    decalVolume->blendMapAdjust = v57;
  }
  v35 = GetPairValue(spawnVar, "explicitUVShift");
  v36 = GetPairValue(spawnVar, "explicitUVScale");
  v37 = GetPairValue(spawnVar, "explicitUVRotateDeg");
  v38 = GetPairValue(spawnVar, "uvAutoTiling");
  v39 = v38;
  if ( v35 && v36 && v37 && v38 )
  {
    uvShift.v[0] = 0.0;
    uvShift.v[1] = 0.0;
    uvScale.v[0] = v29;
    uvScale.v[1] = v29;
    v51 = 0.0;
    j_sscanf(v35, "%f %f", &uvShift, &uvShift.y);
    j_sscanf(v36, "%f %f", &uvScale, &uvScale.y);
    j_sscanf(v37, "%f", &v51);
    BYTE1(outNormalBlendMode) = 0;
    GetBoolFromString(v39, (bool *)&outNormalBlendMode + 1);
    if ( !BYTE1(outNormalBlendMode) || !outMaterial )
    {
      v67.v[0] = 0.0;
      v67.v[1] = 0.0;
      v67.v[2] = 0.0;
      _size_min.v[0] = 0.0;
      _size_min.v[1] = 0.0;
      _size_min.v[2] = 0.0;
      R_DecalVolumes_CalculateUVTranform(&uvScale, &uvShift, v51, &_size_min, &v67, 0, 0, 0.0, 0, &outUvMatrix, &outUvOffset);
      goto LABEL_53;
    }
    v40 = GetPairValue(spawnVar, "RadiantDefaultTextureDensity");
    v41 = GetPairValue(spawnVar, "size_min");
    v42 = GetPairValue(spawnVar, "size_max");
    v43 = v42;
    if ( v40 && v41 && v42 )
    {
      for ( i = outMaterial->channels; !*i; ++i )
      {
        if ( (unsigned int)++v16 >= 4 )
          return;
      }
      v45 = outMaterial->channels[v16];
      width = v45->width;
      height = v45->height;
      if ( width )
      {
        if ( height )
        {
          LODWORD(v57.v[0]) = 16;
          v65.v[0] = 0.0;
          v65.v[1] = 0.0;
          v65.v[2] = 0.0;
          size_max.v[0] = 0.0;
          size_max.v[1] = 0.0;
          size_max.v[2] = 0.0;
          j_sscanf(v40, "%u", &v57);
          j_sscanf(v41, "%f %f %f", &v65, &v65.y, &v65.z);
          j_sscanf(v43, "%f %f %f", &size_max, &size_max.y, &size_max.z);
          v48 = (float)LODWORD(v57.v[0]);
          R_DecalVolumes_CalculateUVTranform(&uvScale, &uvShift, v51, &v65, &size_max, width, height, v48, 1, &outUvMatrix, &outUvOffset);
LABEL_53:
          v49 = outUvMatrix;
          decalVolume->uvOffset = outUvOffset;
          decalVolume->uvMatrix = v49;
        }
      }
    }
  }
}

/*
==============
CG_UpdateDecalVolumeObb
==============
*/
void CG_UpdateDecalVolumeObb(const SpawnVar *spawnVar, GfxStaticDecalVolumeUnpacked *decalVolume)
{
  const char *PairValue; 
  const char *v5; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  __int128 v19; 
  __int128 v22; 
  __int128 v25; 
  const char *v27; 
  float v28; 
  float v29; 
  float v30; 
  float v31; 
  float v32; 
  float v33; 
  __int128 v34; 
  float v35; 
  float v36; 
  float v37; 
  float v38; 
  __int64 v39; 
  vec3_t v40; 
  int v41; 
  int v42; 
  int v43; 
  unsigned int v44; 
  unsigned int v45; 
  __int64 v46; 
  tmat33_t<vec3_t> axis; 
  vec3_t angles; 
  vec3_t in1; 
  tmat43_t<vec3_t> in2; 

  PairValue = GetPairValue(spawnVar, "origin");
  v5 = GetPairValue(spawnVar, "angles");
  j_sscanf(PairValue, "%f %f %f", &v40, &v40.y, &v40.z);
  j_sscanf(v5, "%f %f %f", &angles, &angles.y, &angles.z);
  AnglesToAxis(&angles, &axis);
  v6 = GetPairValue(spawnVar, "size_min");
  v7 = GetPairValue(spawnVar, "size_max");
  v8 = v7;
  if ( v6 && v7 )
  {
    j_sscanf(v6, "%f %f %f", &v41, &v42, &v43);
    j_sscanf(v8, "%f %f %f", &v44, &v45, &v46);
    _XMM2 = v44;
    _XMM0 = (unsigned int)v46;
    __asm
    {
      vminss  xmm8, xmm0, xmm3
      vmaxss  xmm3, xmm0, xmm3
    }
    _XMM1 = v45;
    __asm
    {
      vminss  xmm6, xmm2, xmm5
      vminss  xmm7, xmm1, xmm4
      vmaxss  xmm5, xmm2, xmm5
      vmaxss  xmm4, xmm1, xmm4
    }
    in2.m[0].v[2] = axis.m[0].v[2];
    in1.v[0] = (float)(*(float *)&_XMM5 + *(float *)&_XMM6) * 0.5;
    in1.v[1] = (float)(*(float *)&_XMM4 + *(float *)&_XMM7) * 0.5;
    in1.v[2] = (float)(*(float *)&_XMM3 + *(float *)&_XMM8) * 0.5;
    v19 = _XMM5;
    *(float *)&v19 = *(float *)&_XMM5 - *(float *)&_XMM6;
    _XMM0 = v19;
    __asm { vmaxss  xmm1, xmm0, xmm9 }
    v22 = _XMM4;
    *(float *)&v22 = *(float *)&_XMM4 - *(float *)&_XMM7;
    _XMM2 = v22;
    __asm { vmaxss  xmm0, xmm2, xmm9 }
    v38 = *(float *)&_XMM0;
    *(double *)in2.m[0].v = *(double *)axis.m[0].v;
    in2.m[1] = axis.m[1];
    v37 = *(float *)&_XMM1;
    v25 = _XMM3;
    *(float *)&v25 = *(float *)&_XMM3 - *(float *)&_XMM8;
    _XMM1 = v25;
    in2.m[2] = axis.m[2];
    __asm { vmaxss  xmm2, xmm1, xmm9 }
    in2.m[3] = v40;
    *(float *)&v39 = *(float *)&_XMM2;
    MatrixTransformVector43(&in1, &in2, &decalVolume->obb.center);
  }
  else
  {
    v27 = GetPairValue(spawnVar, "decalsize");
    j_sscanf(v27, "%f %f %f", &v37, &v38, &v39);
    v28 = v40.v[1];
    decalVolume->obb.center.v[0] = v40.v[0];
    decalVolume->obb.center.v[2] = v40.v[2];
    decalVolume->obb.center.v[1] = v28;
  }
  v29 = 0.5 * v37;
  v30 = 0.5 * *(float *)&v39;
  decalVolume->obb.halfSize.v[1] = 0.5 * v38;
  v31 = axis.m[0].v[0];
  decalVolume->obb.halfSize.v[0] = v29;
  decalVolume->obb.halfSize.v[2] = v30;
  v32 = axis.m[0].v[1];
  decalVolume->obb.axes.m[0].v[0] = COERCE_FLOAT(LODWORD(v31) ^ _xmm);
  v33 = axis.m[0].v[2];
  decalVolume->obb.axes.m[0].v[1] = COERCE_FLOAT(LODWORD(v32) ^ _xmm);
  v34 = *(_OWORD *)axis.row1.v;
  LODWORD(v35) = LODWORD(v33) ^ _xmm;
  v36 = axis.m[2].v[2];
  decalVolume->obb.axes.m[0].v[2] = v35;
  *(_OWORD *)decalVolume->obb.axes.row1.v = v34;
  decalVolume->obb.axes.m[2].v[1] = axis.m[2].v[1];
  decalVolume->obb.axes.m[2].v[2] = v36;
}

/*
==============
G_ProcessRadiantCmd
==============
*/
void G_ProcessRadiantCmd(RadiantCommand *command)
{
  RadiantCommandType type; 
  int v3; 
  RadiantCommandData v4; 
  SpawnVar spawnVar; 

  Com_BeginParseSession("G_ProcessRadiantCmd");
  ParseRadiantSpawnVars(command->command, &spawnVar);
  Com_EndParseSession();
  v4.radiantCommand = command;
  v4.spawnVar = &spawnVar;
  if ( command->type >= (unsigned int)RADIANT_COMMAND_COUNT )
  {
    v3 = 28;
    type = command->type;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\radiant_remote.cpp", 2098, ASSERT_TYPE_ASSERT, "(unsigned)( command->type ) < (unsigned)( RADIANT_COMMAND_COUNT )", "command->type doesn't index RADIANT_COMMAND_COUNT\n\t%i not in [0, %i)", type, v3) )
      __debugbreak();
  }
  if ( !g_radiantCommandTable[command->type] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\radiant_remote.cpp", 2099, ASSERT_TYPE_ASSERT, "(g_radiantCommandTable[command->type])", (const char *)&queryFormat, "g_radiantCommandTable[command->type]") )
    __debugbreak();
  ((void (__fastcall *)(RadiantCommandData *))g_radiantCommandTable[command->type])(&v4);
}

/*
==============
G_ProcessRadiantCmds
==============
*/
void G_ProcessRadiantCmds(RadiantLiveGameMode inMode)
{
  volatile int i; 
  gentity_s *v2; 
  gclient_s *client; 

  Sys_EnterCriticalSection(CRITSECT_RADIANT_SERVER_COMMAND);
  if ( bgRadiantLiveEnabled )
  {
    if ( gCommandCount )
    {
      Stream_ImageRecord_Disable("radiant_live_cmd");
      for ( i = 0; i < gCommandCount; ++i )
        G_ProcessRadiantCmd(&gCommands[i]);
    }
    if ( gRadiantLiveProcessStatus )
    {
      Stream_ImageRecord_Disable("radiant_live");
      if ( (gRadiantLiveProcessStatus & 1) != 0 && (cgRadiantLiveStatus & 0x400) != 0 )
      {
        v2 = g_entities;
        if ( G_Cmds_AreCheatsOk_NoHealthCheck(g_entities) )
        {
          client = v2->client;
          if ( client )
            client->flags |= 2u;
        }
      }
      gRadiantLiveProcessStatus = 0;
    }
  }
  gCommandCount = 0;
  Sys_LeaveCriticalSection(CRITSECT_RADIANT_SERVER_COMMAND);
}

/*
==============
GetPairValue
==============
*/
char *GetPairValue(const SpawnVar *spawnVar, const char *key)
{
  int v2; 
  char *(*spawnVars)[2]; 
  const char *v6; 
  __int64 v7; 
  const char *v8; 
  int v9; 
  __int64 v10; 
  int v11; 
  int v12; 
  int v13; 

  v2 = 0;
  if ( spawnVar->numSpawnVars > 0 )
  {
    spawnVars = spawnVar->spawnVars;
    do
    {
      v6 = (*spawnVars)[0];
      v7 = 0x7FFFFFFFi64;
      if ( !key && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
        __debugbreak();
      if ( !v6 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 213, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
        __debugbreak();
      v8 = (const char *)(key - v6);
      while ( 1 )
      {
        v9 = (unsigned __int8)v6[(_QWORD)v8];
        v10 = v7;
        v11 = *(unsigned __int8 *)v6++;
        --v7;
        if ( !v10 )
          return spawnVar->spawnVars[v2][1];
        if ( v9 != v11 )
        {
          v12 = v9 + 32;
          if ( (unsigned int)(v9 - 65) > 0x19 )
            v12 = v9;
          v9 = v12;
          v13 = v11 + 32;
          if ( (unsigned int)(v11 - 65) > 0x19 )
            v13 = v11;
          if ( v9 != v13 )
            break;
        }
        if ( !v9 )
          return spawnVar->spawnVars[v2][1];
      }
      ++v2;
      ++spawnVars;
    }
    while ( v2 < spawnVar->numSpawnVars );
  }
  return 0i64;
}

/*
==============
ParseRadiantSpawnVars
==============
*/
void ParseRadiantSpawnVars(const char *command, SpawnVar *spawnVar)
{
  const char *v3; 
  const char *v4; 
  const char *v5; 
  __int64 v6; 
  __int64 numSpawnVarChars; 
  size_t v8; 
  char *v9; 
  __int64 v10; 
  __int64 v11; 
  size_t v12; 
  char *v13; 
  __int64 numSpawnVars; 
  char *data_p[2]; 
  char dest[1024]; 
  char s[1024]; 

  data_p[0] = (char *)command;
  spawnVar->numSpawnVars = 0;
  spawnVar->numSpawnVarChars = 0;
  spawnVar->spawnVarsValid = 0;
  v3 = Com_Parse((const char **)data_p);
  Core_strcpy(dest, 0x400ui64, v3);
  if ( dest[0] != 123 )
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_14401CE70, 1091i64, dest);
  while ( 1 )
  {
    v4 = Com_Parse((const char **)data_p);
    Core_strcpy(s, 0x400ui64, v4);
    if ( !data_p[0] )
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_14401CEC0, 1092i64);
    if ( s[0] == 125 )
      break;
    I_strlwr(s);
    v5 = Com_Parse((const char **)data_p);
    Core_strcpy(dest, 0x400ui64, v5);
    if ( !data_p[0] )
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_14401CEC0, 1093i64);
    if ( dest[0] == 125 )
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_14401CF10, 1094i64);
    if ( spawnVar->numSpawnVars == 64 )
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_14401CF60, 1095i64);
    v6 = -1i64;
    do
      ++v6;
    while ( s[v6] );
    numSpawnVarChars = spawnVar->numSpawnVarChars;
    if ( (unsigned __int64)(numSpawnVarChars + v6 + 1) > 0x2000 )
    {
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_14401CE18, 1090i64);
      LODWORD(numSpawnVarChars) = spawnVar->numSpawnVarChars;
    }
    v8 = v6 + 1;
    v9 = &spawnVar->spawnVarChars[(int)numSpawnVarChars];
    memcpy_0(v9, s, v8);
    if ( (v8 > 0x7FFFFFFFFFFFFFFFi64 || v8 + 0x80000000 > 0xFFFFFFFF) && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "int __cdecl truncate_cast_impl<int,unsigned __int64>(unsigned __int64)", "signed", (int)v8, "unsigned", v8) )
      __debugbreak();
    spawnVar->numSpawnVarChars += v8;
    v10 = -1i64;
    spawnVar->spawnVars[spawnVar->numSpawnVars][0] = v9;
    do
      ++v10;
    while ( dest[v10] );
    v11 = spawnVar->numSpawnVarChars;
    if ( (unsigned __int64)(v11 + v10 + 1) > 0x2000 )
    {
      Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_14401CE18, 1090i64);
      LODWORD(v11) = spawnVar->numSpawnVarChars;
    }
    v12 = v10 + 1;
    v13 = &spawnVar->spawnVarChars[(int)v11];
    memcpy_0(v13, dest, v12);
    if ( (v12 > 0x7FFFFFFFFFFFFFFFi64 || v12 + 0x80000000 > 0xFFFFFFFF) && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "int __cdecl truncate_cast_impl<int,unsigned __int64>(unsigned __int64)", "signed", (int)v12, "unsigned", v12) )
      __debugbreak();
    numSpawnVars = spawnVar->numSpawnVars;
    spawnVar->numSpawnVarChars += v12;
    spawnVar->spawnVars[numSpawnVars][1] = v13;
    ++spawnVar->numSpawnVars;
  }
  spawnVar->spawnVarsValid = 1;
}

/*
==============
R_DrawRadiantLiveConnectionStatus
==============
*/
void R_DrawRadiantLiveConnectionStatus(void)
{
  float v0; 
  int v1; 
  __m256i verts_8; 

  if ( (cgRadiantLiveStatus & 0x3F) != 0 )
  {
    v0 = FLOAT_100_0;
    *(float *)&v1 = FLOAT_60_0;
    verts_8 = _ymm;
    R_AddCmdDrawQuadPicST((const vec2_t *)&verts_8, 0.0, 0.0, 0.25, 1.0, &color, rgp.radiantLiveDebugConnectionMaterial);
    if ( (cgRadiantLiveStatus & 1) != 0 )
    {
      verts_8 = _ymm;
      R_AddCmdDrawQuadPicST((const vec2_t *)&verts_8, 0.25, 0.0, 0.375, 0.5, &color, rgp.radiantLiveDebugConnectionMaterial);
      *(float *)&v1 = FLOAT_76_0;
    }
    if ( (cgRadiantLiveStatus & 2) != 0 )
    {
      verts_8.m256i_i32[1] = v1;
      verts_8.m256i_i32[3] = v1;
      *(float *)&v1 = *(float *)&v1 + 16.0;
      *(float *)verts_8.m256i_i32 = FLOAT_100_0;
      *(float *)&verts_8.m256i_i32[2] = FLOAT_116_0;
      *(float *)&verts_8.m256i_i32[4] = FLOAT_116_0;
      verts_8.m256i_i32[5] = v1;
      *(float *)&verts_8.m256i_i32[6] = FLOAT_100_0;
      verts_8.m256i_i32[7] = v1;
      R_AddCmdDrawQuadPicST((const vec2_t *)&verts_8, 0.25, 0.5, 0.375, 1.0, &color, rgp.radiantLiveDebugConnectionMaterial);
      if ( *(float *)&v1 >= 124.0 )
      {
        *(float *)&v1 = FLOAT_60_0;
        v0 = FLOAT_116_0;
      }
    }
    if ( (cgRadiantLiveStatus & 4) != 0 )
    {
      verts_8.m256i_i32[1] = v1;
      verts_8.m256i_i32[3] = v1;
      *(float *)&v1 = *(float *)&v1 + 16.0;
      *(float *)verts_8.m256i_i32 = v0;
      *(float *)&verts_8.m256i_i32[2] = v0 + 16.0;
      *(float *)&verts_8.m256i_i32[4] = v0 + 16.0;
      verts_8.m256i_i32[5] = v1;
      *(float *)&verts_8.m256i_i32[6] = v0;
      verts_8.m256i_i32[7] = v1;
      R_AddCmdDrawQuadPicST((const vec2_t *)&verts_8, 0.375, 0.0, 0.5, 0.5, &color, rgp.radiantLiveDebugConnectionMaterial);
      if ( *(float *)&v1 >= 124.0 )
      {
        *(float *)&v1 = FLOAT_60_0;
        v0 = v0 + 16.0;
      }
    }
    if ( (cgRadiantLiveStatus & 8) != 0 )
    {
      verts_8.m256i_i32[1] = v1;
      verts_8.m256i_i32[3] = v1;
      *(float *)&v1 = *(float *)&v1 + 16.0;
      *(float *)verts_8.m256i_i32 = v0;
      *(float *)&verts_8.m256i_i32[2] = v0 + 16.0;
      *(float *)&verts_8.m256i_i32[4] = v0 + 16.0;
      verts_8.m256i_i32[5] = v1;
      *(float *)&verts_8.m256i_i32[6] = v0;
      verts_8.m256i_i32[7] = v1;
      R_AddCmdDrawQuadPicST((const vec2_t *)&verts_8, 0.375, 0.5, 0.5, 1.0, &color, rgp.radiantLiveDebugConnectionMaterial);
      if ( *(float *)&v1 >= 124.0 )
      {
        *(float *)&v1 = FLOAT_60_0;
        v0 = v0 + 16.0;
      }
    }
    if ( (cgRadiantLiveStatus & 0x10) != 0 )
    {
      verts_8.m256i_i32[1] = v1;
      verts_8.m256i_i32[3] = v1;
      *(float *)&v1 = *(float *)&v1 + 16.0;
      *(float *)verts_8.m256i_i32 = v0;
      *(float *)&verts_8.m256i_i32[2] = v0 + 16.0;
      *(float *)&verts_8.m256i_i32[4] = v0 + 16.0;
      verts_8.m256i_i32[5] = v1;
      *(float *)&verts_8.m256i_i32[6] = v0;
      verts_8.m256i_i32[7] = v1;
      R_AddCmdDrawQuadPicST((const vec2_t *)&verts_8, 0.5, 0.5, 0.625, 1.0, &color, rgp.radiantLiveDebugConnectionMaterial);
      if ( *(float *)&v1 >= 124.0 )
      {
        *(float *)&v1 = FLOAT_60_0;
        v0 = v0 + 16.0;
      }
    }
    if ( (cgRadiantLiveStatus & 0x20) != 0 )
    {
      verts_8.m256i_i32[1] = v1;
      verts_8.m256i_i32[3] = v1;
      *(float *)&v1 = *(float *)&v1 + 16.0;
      *(float *)verts_8.m256i_i32 = v0;
      *(float *)&verts_8.m256i_i32[2] = v0 + 16.0;
      *(float *)&verts_8.m256i_i32[4] = v0 + 16.0;
      verts_8.m256i_i32[5] = v1;
      *(float *)&verts_8.m256i_i32[6] = v0;
      verts_8.m256i_i32[7] = v1;
      R_AddCmdDrawQuadPicST((const vec2_t *)&verts_8, 0.75, 0.0, 0.875, 0.5, &color, rgp.radiantLiveDebugConnectionMaterial);
      if ( *(float *)&v1 >= 124.0 )
      {
        *(float *)&v1 = FLOAT_60_0;
        v0 = v0 + 16.0;
      }
    }
    if ( !cgRadiantLiveFlowing && (Sys_GetTimeAsSeconds() & 3) != 3 )
    {
      *(float *)verts_8.m256i_i32 = v0;
      verts_8.m256i_i32[1] = v1;
      *(float *)&verts_8.m256i_i32[2] = v0 + 16.0;
      verts_8.m256i_i32[3] = v1;
      *(float *)&verts_8.m256i_i32[4] = v0 + 16.0;
      *(float *)&verts_8.m256i_i32[5] = *(float *)&v1 + 16.0;
      *(float *)&verts_8.m256i_i32[6] = v0;
      *(float *)&verts_8.m256i_i32[7] = *(float *)&v1 + 16.0;
      R_AddCmdDrawQuadPicST((const vec2_t *)&verts_8, 0.625, 0.5, 0.75, 1.0, &color, rgp.radiantLiveDebugConnectionMaterial);
    }
  }
}

/*
==============
R_RadiantRemoteGetGfxReflectionProbeInstance
==============
*/
bool R_RadiantRemoteGetGfxReflectionProbeInstance(const char *livePath, GfxReflectionProbeInstance *outReflectionProbeInstance)
{
  RadiantRemoteReflectionVolume *RadiantReflectionVolume; 

  RadiantReflectionVolume = CG_FindRadiantReflectionVolume(livePath);
  if ( RadiantReflectionVolume )
  {
    *(__m256i *)&outReflectionProbeInstance->livePath = *(__m256i *)&RadiantReflectionVolume->reflectionProbeInstance.livePath;
    *(__m256i *)&outReflectionProbeInstance->probeRotation.xyz.z = *(__m256i *)&RadiantReflectionVolume->reflectionProbeInstance.probeRotation.xyz.z;
    *(__m256i *)outReflectionProbeInstance->volumeObb.yAxis.v = *(__m256i *)RadiantReflectionVolume->reflectionProbeInstance.volumeObb.yAxis.v;
    *(__m256i *)&outReflectionProbeInstance->volumeObb.halfSize.z = *(__m256i *)&RadiantReflectionVolume->reflectionProbeInstance.volumeObb.halfSize.z;
    *(_OWORD *)outReflectionProbeInstance->expandProjectionPos.v = *(_OWORD *)RadiantReflectionVolume->reflectionProbeInstance.expandProjectionPos.v;
    outReflectionProbeInstance->livePath = NULL;
    LOBYTE(RadiantReflectionVolume) = 1;
  }
  return (char)RadiantReflectionVolume;
}

