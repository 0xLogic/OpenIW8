/*
==============
Load_TransientInfoArray
==============
*/

void __fastcall Load_TransientInfoArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Load_TransientInfoArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Postload_TransientInfo_BitarrayStream
==============
*/

void __fastcall Postload_TransientInfo_BitarrayStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Postload_TransientInfo_BitarrayStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Load_StreamingContentSet
==============
*/

void __fastcall Load_StreamingContentSet(const DBStreamStart streamStart)
{
  ?Load_StreamingContentSet@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Load_TransientFileReferenceStream
==============
*/

void __fastcall Load_TransientFileReferenceStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Load_TransientFileReferenceStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
AllocLoad_TransientInfoFlags
==============
*/

TransientInfoFlags *__fastcall AllocLoad_TransientInfoFlags()
{
  return ?AllocLoad_TransientInfoFlags@@YAPEAW4TransientInfoFlags@@XZ();
}

/*
==============
Load_TransientInfoFlagsStream
==============
*/

void __fastcall Load_TransientInfoFlagsStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Load_TransientInfoFlagsStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
AllocPreload_StreamingItemContents
==============
*/

StreamingItemContents *__fastcall AllocPreload_StreamingItemContents()
{
  return ?AllocPreload_StreamingItemContents@@YAPEAUStreamingItemContents@@XZ();
}

/*
==============
Preload_StreamingContentSetStream
==============
*/

void __fastcall Preload_StreamingContentSetStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Preload_StreamingContentSetStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Preload_TransientAssetReference
==============
*/

void __fastcall Preload_TransientAssetReference(const DBStreamStart streamStart)
{
  ?Preload_TransientAssetReference@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Preload_TransientCostsArray
==============
*/

void __fastcall Preload_TransientCostsArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Preload_TransientCostsArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Preload_StreamingInfoPtrArray
==============
*/

void __fastcall Preload_StreamingInfoPtrArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Preload_StreamingInfoPtrArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Postload_AlwaysloadedFlagSetArray
==============
*/

void __fastcall Postload_AlwaysloadedFlagSetArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Postload_AlwaysloadedFlagSetArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
AllocPostload_TransientCosts
==============
*/

TransientCosts *__fastcall AllocPostload_TransientCosts()
{
  return ?AllocPostload_TransientCosts@@YAPEAUTransientCosts@@XZ();
}

/*
==============
Postload_AlwaysloadedFlagSet
==============
*/

void __fastcall Postload_AlwaysloadedFlagSet(const DBStreamStart streamStart)
{
  ?Postload_AlwaysloadedFlagSet@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Postload_StreamingContentSetStream
==============
*/

void __fastcall Postload_StreamingContentSetStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Postload_StreamingContentSetStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Mark_StreamingInfo
==============
*/

int __fastcall Mark_StreamingInfo()
{
  return ?Mark_StreamingInfo@@YAHXZ();
}

/*
==============
Postload_AlwaysloadedFlagsPerModel
==============
*/

void __fastcall Postload_AlwaysloadedFlagsPerModel(const DBStreamStart streamStart)
{
  ?Postload_AlwaysloadedFlagsPerModel@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Preload_TransientAssetReferenceArray
==============
*/

void __fastcall Preload_TransientAssetReferenceArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Preload_TransientAssetReferenceArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Load_TransientWorldGridTileMapStream
==============
*/

void __fastcall Load_TransientWorldGridTileMapStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Load_TransientWorldGridTileMapStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Load_TransientSets
==============
*/

void __fastcall Load_TransientSets(const DBStreamStart streamStart)
{
  ?Load_TransientSets@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Load_ProcessStructLayout_ForcedStubAssetReference
==============
*/

void Load_ProcessStructLayout_ForcedStubAssetReference(void)
{
  ?Load_ProcessStructLayout_ForcedStubAssetReference@@YAXXZ();
}

/*
==============
Preload_TransientWorldGridTileMap
==============
*/

void __fastcall Preload_TransientWorldGridTileMap(const DBStreamStart streamStart)
{
  ?Preload_TransientWorldGridTileMap@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Load_ProcessStructLayout_AlwaysloadedFlagSet
==============
*/

void Load_ProcessStructLayout_AlwaysloadedFlagSet(void)
{
  ?Load_ProcessStructLayout_AlwaysloadedFlagSet@@YAXXZ();
}

/*
==============
Postload_StreamingItemContentsStream
==============
*/

void __fastcall Postload_StreamingItemContentsStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Postload_StreamingItemContentsStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
AllocPreload_TransientSets
==============
*/

TransientSets *__fastcall AllocPreload_TransientSets()
{
  return ?AllocPreload_TransientSets@@YAPEAUTransientSets@@XZ();
}

/*
==============
Load_TransientFileReference
==============
*/

void __fastcall Load_TransientFileReference(const DBStreamStart streamStart)
{
  ?Load_TransientFileReference@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Preload_StreamingItemCostStream
==============
*/

void __fastcall Preload_StreamingItemCostStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Preload_StreamingItemCostStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Preload_TransientFileReferenceStream
==============
*/

void __fastcall Preload_TransientFileReferenceStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Preload_TransientFileReferenceStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Mark_TransientInfoFlagsArray
==============
*/

int __fastcall Mark_TransientInfoFlagsArray(const unsigned __int64 count)
{
  return ?Mark_TransientInfoFlagsArray@@YAH_K@Z(count);
}

/*
==============
Preload_transientSPWorldBitArray_tArray
==============
*/

void __fastcall Preload_transientSPWorldBitArray_tArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Preload_transientSPWorldBitArray_tArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Postload_StreamingContentSet
==============
*/

void __fastcall Postload_StreamingContentSet(const DBStreamStart streamStart)
{
  ?Postload_StreamingContentSet@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Load_StreamingInfoPtrStream
==============
*/

void __fastcall Load_StreamingInfoPtrStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Load_StreamingInfoPtrStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Load_StreamingInfo
==============
*/

void __fastcall Load_StreamingInfo(const DBStreamStart streamStart)
{
  ?Load_StreamingInfo@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
AllocPostload_StreamingInfoPtr
==============
*/

StreamingInfo **__fastcall AllocPostload_StreamingInfoPtr()
{
  return ?AllocPostload_StreamingInfoPtr@@YAPEAPEAUStreamingInfo@@XZ();
}

/*
==============
Preload_TransientSets
==============
*/

void __fastcall Preload_TransientSets(const DBStreamStart streamStart)
{
  ?Preload_TransientSets@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Preload_TransientInfo_Bitarray
==============
*/

void __fastcall Preload_TransientInfo_Bitarray(const DBStreamStart streamStart)
{
  ?Preload_TransientInfo_Bitarray@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Load_TransientInfo
==============
*/

void __fastcall Load_TransientInfo(const DBStreamStart streamStart)
{
  ?Load_TransientInfo@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Postload_TransientCostsArray
==============
*/

void __fastcall Postload_TransientCostsArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Postload_TransientCostsArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
AllocPreload_StreamingInfo
==============
*/

StreamingInfo *__fastcall AllocPreload_StreamingInfo()
{
  return ?AllocPreload_StreamingInfo@@YAPEAUStreamingInfo@@XZ();
}

/*
==============
Postload_StreamingInfoPtrArray
==============
*/

void __fastcall Postload_StreamingInfoPtrArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Postload_StreamingInfoPtrArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Load_ProcessStructLayout_StreamingItemContents
==============
*/

void Load_ProcessStructLayout_StreamingItemContents(void)
{
  ?Load_ProcessStructLayout_StreamingItemContents@@YAXXZ();
}

/*
==============
Load_TransientInfoStream
==============
*/

void __fastcall Load_TransientInfoStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Load_TransientInfoStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Preload_AlwaysloadedFlagSetStream
==============
*/

void __fastcall Preload_AlwaysloadedFlagSetStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Preload_AlwaysloadedFlagSetStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Preload_TransientInfo_BitarrayArray
==============
*/

void __fastcall Preload_TransientInfo_BitarrayArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Preload_TransientInfo_BitarrayArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Load_transientSPWorldBitArray_tArray
==============
*/

void __fastcall Load_transientSPWorldBitArray_tArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Load_transientSPWorldBitArray_tArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
AllocPostload_TransientSets
==============
*/

TransientSets *__fastcall AllocPostload_TransientSets()
{
  return ?AllocPostload_TransientSets@@YAPEAUTransientSets@@XZ();
}

/*
==============
AllocPostload_StreamingItemContents
==============
*/

StreamingItemContents *__fastcall AllocPostload_StreamingItemContents()
{
  return ?AllocPostload_StreamingItemContents@@YAPEAUStreamingItemContents@@XZ();
}

/*
==============
Postload_transientSPWorldBitArray_tStream
==============
*/

void __fastcall Postload_transientSPWorldBitArray_tStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Postload_transientSPWorldBitArray_tStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Load_ForcedStubAssetReference
==============
*/

void __fastcall Load_ForcedStubAssetReference(const DBStreamStart streamStart)
{
  ?Load_ForcedStubAssetReference@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Load_TransientFileReferenceArray
==============
*/

void __fastcall Load_TransientFileReferenceArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Load_TransientFileReferenceArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Load_ProcessStructLayout_AlwaysloadedFlagsPerModel
==============
*/

void Load_ProcessStructLayout_AlwaysloadedFlagsPerModel(void)
{
  ?Load_ProcessStructLayout_AlwaysloadedFlagsPerModel@@YAXXZ();
}

/*
==============
Postload_TransientFileReferenceArray
==============
*/

void __fastcall Postload_TransientFileReferenceArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Postload_TransientFileReferenceArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Load_TransientSetsStream
==============
*/

void __fastcall Load_TransientSetsStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Load_TransientSetsStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Load_StreamingItemContentsArray
==============
*/

void __fastcall Load_StreamingItemContentsArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Load_StreamingItemContentsArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Load_TransientInfo_Bitarray
==============
*/

void __fastcall Load_TransientInfo_Bitarray(const DBStreamStart streamStart)
{
  ?Load_TransientInfo_Bitarray@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Load_StreamingInfoArray
==============
*/

void __fastcall Load_StreamingInfoArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Load_StreamingInfoArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Load_TransientAssetReferenceStream
==============
*/

void __fastcall Load_TransientAssetReferenceStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Load_TransientAssetReferenceStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
AllocPreload_TransientInfo_Bitarray
==============
*/

bitarray_dynamic *__fastcall AllocPreload_TransientInfo_Bitarray()
{
  return ?AllocPreload_TransientInfo_Bitarray@@YAPEAVbitarray_dynamic@@XZ();
}

/*
==============
Mark_TransientInfo_Bitarray
==============
*/

int __fastcall Mark_TransientInfo_Bitarray()
{
  return ?Mark_TransientInfo_Bitarray@@YAHXZ();
}

/*
==============
Preload_StreamingContentSetArray
==============
*/

void __fastcall Preload_StreamingContentSetArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Preload_StreamingContentSetArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Mark_AlwaysloadedFlagsArray
==============
*/

int __fastcall Mark_AlwaysloadedFlagsArray(const unsigned __int64 count)
{
  return ?Mark_AlwaysloadedFlagsArray@@YAH_K@Z(count);
}

/*
==============
Load_AlwaysloadedFlags
==============
*/

void __fastcall Load_AlwaysloadedFlags(const DBStreamStart streamStart)
{
  ?Load_AlwaysloadedFlags@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Postload_TransientAssetReferenceArray
==============
*/

void __fastcall Postload_TransientAssetReferenceArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Postload_TransientAssetReferenceArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Preload_TransientInfoArray
==============
*/

void __fastcall Preload_TransientInfoArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Preload_TransientInfoArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Postload_TransientInfoFlagsStream
==============
*/

void __fastcall Postload_TransientInfoFlagsStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Postload_TransientInfoFlagsStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Postload_ForcedStubAssetReference
==============
*/

void __fastcall Postload_ForcedStubAssetReference(const DBStreamStart streamStart)
{
  ?Postload_ForcedStubAssetReference@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Postload_StreamingItemCost
==============
*/

void __fastcall Postload_StreamingItemCost(const DBStreamStart streamStart)
{
  ?Postload_StreamingItemCost@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Postload_AlwaysloadedFlagsPerModelStream
==============
*/

void __fastcall Postload_AlwaysloadedFlagsPerModelStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Postload_AlwaysloadedFlagsPerModelStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Load_StreamingItemContentsStream
==============
*/

void __fastcall Load_StreamingItemContentsStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Load_StreamingItemContentsStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Mark_StreamingInfoPtrArray
==============
*/

int __fastcall Mark_StreamingInfoPtrArray(const unsigned __int64 count)
{
  return ?Mark_StreamingInfoPtrArray@@YAH_K@Z(count);
}

/*
==============
Load_StreamingContentSetArray
==============
*/

void __fastcall Load_StreamingContentSetArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Load_StreamingContentSetArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Mark_StreamingItemCost
==============
*/

int __fastcall Mark_StreamingItemCost()
{
  return ?Mark_StreamingItemCost@@YAHXZ();
}

/*
==============
AllocPostload_StreamingContentSet
==============
*/

StreamingContentSet *__fastcall AllocPostload_StreamingContentSet()
{
  return ?AllocPostload_StreamingContentSet@@YAPEAUStreamingContentSet@@XZ();
}

/*
==============
Preload_AlwaysloadedFlagsPerModelArray
==============
*/

void __fastcall Preload_AlwaysloadedFlagsPerModelArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Preload_AlwaysloadedFlagsPerModelArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Postload_StreamingItemContentsArray
==============
*/

void __fastcall Postload_StreamingItemContentsArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Postload_StreamingItemContentsArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Postload_TransientInfo_Bitarray
==============
*/

void __fastcall Postload_TransientInfo_Bitarray(const DBStreamStart streamStart)
{
  ?Postload_TransientInfo_Bitarray@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Preload_TransientWorldGridTileMapStream
==============
*/

void __fastcall Preload_TransientWorldGridTileMapStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Preload_TransientWorldGridTileMapStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Mark_TransientInfo_BitarrayArray
==============
*/

int __fastcall Mark_TransientInfo_BitarrayArray(const unsigned __int64 count)
{
  return ?Mark_TransientInfo_BitarrayArray@@YAH_K@Z(count);
}

/*
==============
Preload_transientSPWorldBitArray_t
==============
*/

void __fastcall Preload_transientSPWorldBitArray_t(const DBStreamStart streamStart)
{
  ?Preload_transientSPWorldBitArray_t@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Preload_TransientInfoFlagsStream
==============
*/

void __fastcall Preload_TransientInfoFlagsStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Preload_TransientInfoFlagsStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
AllocPreload_StreamingItemCost
==============
*/

StreamingItemCost *__fastcall AllocPreload_StreamingItemCost()
{
  return ?AllocPreload_StreamingItemCost@@YAPEAUStreamingItemCost@@XZ();
}

/*
==============
Load_StreamingItemCostStream
==============
*/

void __fastcall Load_StreamingItemCostStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Load_StreamingItemCostStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Load_TransientCosts
==============
*/

void __fastcall Load_TransientCosts(const DBStreamStart streamStart)
{
  ?Load_TransientCosts@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Mark_StreamingContentSet
==============
*/

int __fastcall Mark_StreamingContentSet()
{
  return ?Mark_StreamingContentSet@@YAHXZ();
}

/*
==============
Preload_StreamingInfoPtrStream
==============
*/

void __fastcall Preload_StreamingInfoPtrStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Preload_StreamingInfoPtrStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Load_StreamingInfoStream
==============
*/

void __fastcall Load_StreamingInfoStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Load_StreamingInfoStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Load_StreamingInfoPtr
==============
*/

void __fastcall Load_StreamingInfoPtr(const DBStreamStart streamStart)
{
  ?Load_StreamingInfoPtr@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
AllocLoad_StreamingInfo
==============
*/

StreamingInfo *__fastcall AllocLoad_StreamingInfo()
{
  return ?AllocLoad_StreamingInfo@@YAPEAUStreamingInfo@@XZ();
}

/*
==============
Mark_AlwaysloadedFlagSetArray
==============
*/

int __fastcall Mark_AlwaysloadedFlagSetArray(const unsigned __int64 count)
{
  return ?Mark_AlwaysloadedFlagSetArray@@YAH_K@Z(count);
}

/*
==============
Postload_ForcedStubAssetReferenceStream
==============
*/

void __fastcall Postload_ForcedStubAssetReferenceStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Postload_ForcedStubAssetReferenceStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Load_AlwaysloadedFlagsArray
==============
*/

void __fastcall Load_AlwaysloadedFlagsArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Load_AlwaysloadedFlagsArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
AllocLoad_StreamingItemCost
==============
*/

StreamingItemCost *__fastcall AllocLoad_StreamingItemCost()
{
  return ?AllocLoad_StreamingItemCost@@YAPEAUStreamingItemCost@@XZ();
}

/*
==============
Load_ProcessStructLayout_TransientInfo
==============
*/

void Load_ProcessStructLayout_TransientInfo(void)
{
  ?Load_ProcessStructLayout_TransientInfo@@YAXXZ();
}

/*
==============
Postload_StreamingItemCostArray
==============
*/

void __fastcall Postload_StreamingItemCostArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Postload_StreamingItemCostArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Postload_TransientWorldGridTileMapArray
==============
*/

void __fastcall Postload_TransientWorldGridTileMapArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Postload_TransientWorldGridTileMapArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Load_ForcedStubAssetReferenceArray
==============
*/

void __fastcall Load_ForcedStubAssetReferenceArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Load_ForcedStubAssetReferenceArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Mark_TransientSetsArray
==============
*/

int __fastcall Mark_TransientSetsArray(const unsigned __int64 count)
{
  return ?Mark_TransientSetsArray@@YAH_K@Z(count);
}

/*
==============
Postload_ForcedStubAssetReferenceArray
==============
*/

void __fastcall Postload_ForcedStubAssetReferenceArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Postload_ForcedStubAssetReferenceArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Mark_StreamingContentSetArray
==============
*/

int __fastcall Mark_StreamingContentSetArray(const unsigned __int64 count)
{
  return ?Mark_StreamingContentSetArray@@YAH_K@Z(count);
}

/*
==============
Preload_StreamingItemCostArray
==============
*/

void __fastcall Preload_StreamingItemCostArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Preload_StreamingItemCostArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Preload_transientSPWorldBitArray_tStream
==============
*/

void __fastcall Preload_transientSPWorldBitArray_tStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Preload_transientSPWorldBitArray_tStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Postload_AlwaysloadedFlagsStream
==============
*/

void __fastcall Postload_AlwaysloadedFlagsStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Postload_AlwaysloadedFlagsStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Preload_TransientInfo
==============
*/

void __fastcall Preload_TransientInfo(const DBStreamStart streamStart)
{
  ?Preload_TransientInfo@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
AllocLoad_AlwaysloadedFlags
==============
*/

AlwaysloadedFlags *__fastcall AllocLoad_AlwaysloadedFlags()
{
  return ?AllocLoad_AlwaysloadedFlags@@YAPEAUAlwaysloadedFlags@@XZ();
}

/*
==============
AllocPreload_StreamingContentSet
==============
*/

StreamingContentSet *__fastcall AllocPreload_StreamingContentSet()
{
  return ?AllocPreload_StreamingContentSet@@YAPEAUStreamingContentSet@@XZ();
}

/*
==============
AllocPreload_TransientCosts
==============
*/

TransientCosts *__fastcall AllocPreload_TransientCosts()
{
  return ?AllocPreload_TransientCosts@@YAPEAUTransientCosts@@XZ();
}

/*
==============
Preload_StreamingInfoArray
==============
*/

void __fastcall Preload_StreamingInfoArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Preload_StreamingInfoArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Postload_TransientFileReference
==============
*/

void __fastcall Postload_TransientFileReference(const DBStreamStart streamStart)
{
  ?Postload_TransientFileReference@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
AllocPreload_TransientWorldGridTileMap
==============
*/

TransientWorldGridTileMap *__fastcall AllocPreload_TransientWorldGridTileMap()
{
  return ?AllocPreload_TransientWorldGridTileMap@@YAPEAUTransientWorldGridTileMap@@XZ();
}

/*
==============
AllocPostload_AlwaysloadedFlagsPerModel
==============
*/

AlwaysloadedFlagsPerModel *__fastcall AllocPostload_AlwaysloadedFlagsPerModel()
{
  return ?AllocPostload_AlwaysloadedFlagsPerModel@@YAPEAUAlwaysloadedFlagsPerModel@@XZ();
}

/*
==============
Mark_TransientFileReference
==============
*/

int __fastcall Mark_TransientFileReference()
{
  return ?Mark_TransientFileReference@@YAHXZ();
}

/*
==============
AllocLoad_transientSPWorldBitArray_t
==============
*/

bitarray<32> *__fastcall AllocLoad_transientSPWorldBitArray_t()
{
  return ?AllocLoad_transientSPWorldBitArray_t@@YAPEAV?$bitarray@$0CA@@@XZ();
}

/*
==============
Load_TransientCostsStream
==============
*/

void __fastcall Load_TransientCostsStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Load_TransientCostsStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Load_TransientInfo_BitarrayStream
==============
*/

void __fastcall Load_TransientInfo_BitarrayStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Load_TransientInfo_BitarrayStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Postload_TransientWorldGridTileMap
==============
*/

void __fastcall Postload_TransientWorldGridTileMap(const DBStreamStart streamStart)
{
  ?Postload_TransientWorldGridTileMap@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Load_ForcedStubAssetReferenceStream
==============
*/

void __fastcall Load_ForcedStubAssetReferenceStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Load_ForcedStubAssetReferenceStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Mark_ForcedStubAssetReferenceArray
==============
*/

int __fastcall Mark_ForcedStubAssetReferenceArray(const unsigned __int64 count)
{
  return ?Mark_ForcedStubAssetReferenceArray@@YAH_K@Z(count);
}

/*
==============
Load_StreamingItemCostArray
==============
*/

void __fastcall Load_StreamingItemCostArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Load_StreamingItemCostArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
AllocLoad_TransientAssetReference
==============
*/

TransientAssetReference *__fastcall AllocLoad_TransientAssetReference()
{
  return ?AllocLoad_TransientAssetReference@@YAPEAUTransientAssetReference@@XZ();
}

/*
==============
Preload_AlwaysloadedFlagSet
==============
*/

void __fastcall Preload_AlwaysloadedFlagSet(const DBStreamStart streamStart)
{
  ?Preload_AlwaysloadedFlagSet@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Load_AlwaysloadedFlagsPerModelArray
==============
*/

void __fastcall Load_AlwaysloadedFlagsPerModelArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Load_AlwaysloadedFlagsPerModelArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
AllocLoad_StreamingInfoPtr
==============
*/

StreamingInfo **__fastcall AllocLoad_StreamingInfoPtr()
{
  return ?AllocLoad_StreamingInfoPtr@@YAPEAPEAUStreamingInfo@@XZ();
}

/*
==============
Preload_StreamingInfoStream
==============
*/

void __fastcall Preload_StreamingInfoStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Preload_StreamingInfoStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
AllocPostload_StreamingInfo
==============
*/

StreamingInfo *__fastcall AllocPostload_StreamingInfo()
{
  return ?AllocPostload_StreamingInfo@@YAPEAUStreamingInfo@@XZ();
}

/*
==============
Load_AlwaysloadedFlagSetArray
==============
*/

void __fastcall Load_AlwaysloadedFlagSetArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Load_AlwaysloadedFlagSetArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Preload_TransientInfo_BitarrayStream
==============
*/

void __fastcall Preload_TransientInfo_BitarrayStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Preload_TransientInfo_BitarrayStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Mark_StreamingInfoArray
==============
*/

int __fastcall Mark_StreamingInfoArray(const unsigned __int64 count)
{
  return ?Mark_StreamingInfoArray@@YAH_K@Z(count);
}

/*
==============
Mark_TransientWorldGridTileMap
==============
*/

int __fastcall Mark_TransientWorldGridTileMap()
{
  return ?Mark_TransientWorldGridTileMap@@YAHXZ();
}

/*
==============
Mark_StreamingInfoPtr
==============
*/

int __fastcall Mark_StreamingInfoPtr()
{
  return ?Mark_StreamingInfoPtr@@YAHXZ();
}

/*
==============
Load_AlwaysloadedFlagsPerModelStream
==============
*/

void __fastcall Load_AlwaysloadedFlagsPerModelStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Load_AlwaysloadedFlagsPerModelStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
AllocLoad_StreamingItemContents
==============
*/

StreamingItemContents *__fastcall AllocLoad_StreamingItemContents()
{
  return ?AllocLoad_StreamingItemContents@@YAPEAUStreamingItemContents@@XZ();
}

/*
==============
Load_AlwaysloadedFlagsPerModel
==============
*/

void __fastcall Load_AlwaysloadedFlagsPerModel(const DBStreamStart streamStart)
{
  ?Load_AlwaysloadedFlagsPerModel@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Mark_TransientCostsArray
==============
*/

int __fastcall Mark_TransientCostsArray(const unsigned __int64 count)
{
  return ?Mark_TransientCostsArray@@YAH_K@Z(count);
}

/*
==============
Load_ProcessStructLayout_TransientInfo_Bitarray
==============
*/

void Load_ProcessStructLayout_TransientInfo_Bitarray(void)
{
  ?Load_ProcessStructLayout_TransientInfo_Bitarray@@YAXXZ();
}

/*
==============
Postload_StreamingInfoPtr
==============
*/

void __fastcall Postload_StreamingInfoPtr(const DBStreamStart streamStart)
{
  ?Postload_StreamingInfoPtr@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Preload_TransientInfoFlags
==============
*/

void __fastcall Preload_TransientInfoFlags(const DBStreamStart streamStart)
{
  ?Preload_TransientInfoFlags@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Preload_AlwaysloadedFlagsStream
==============
*/

void __fastcall Preload_AlwaysloadedFlagsStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Preload_AlwaysloadedFlagsStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Preload_TransientInfoStream
==============
*/

void __fastcall Preload_TransientInfoStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Preload_TransientInfoStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Preload_TransientCostsStream
==============
*/

void __fastcall Preload_TransientCostsStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Preload_TransientCostsStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
AllocPreload_StreamingInfoPtr
==============
*/

StreamingInfo **__fastcall AllocPreload_StreamingInfoPtr()
{
  return ?AllocPreload_StreamingInfoPtr@@YAPEAPEAUStreamingInfo@@XZ();
}

/*
==============
Postload_TransientAssetReferenceStream
==============
*/

void __fastcall Postload_TransientAssetReferenceStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Postload_TransientAssetReferenceStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
AllocPreload_TransientInfo
==============
*/

TransientInfo *__fastcall AllocPreload_TransientInfo()
{
  return ?AllocPreload_TransientInfo@@YAPEAUTransientInfo@@XZ();
}

/*
==============
Preload_AlwaysloadedFlagsPerModel
==============
*/

void __fastcall Preload_AlwaysloadedFlagsPerModel(const DBStreamStart streamStart)
{
  ?Preload_AlwaysloadedFlagsPerModel@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
AllocPreload_TransientFileReference
==============
*/

TransientFileReference *__fastcall AllocPreload_TransientFileReference()
{
  return ?AllocPreload_TransientFileReference@@YAPEAUTransientFileReference@@XZ();
}

/*
==============
Preload_StreamingItemContentsStream
==============
*/

void __fastcall Preload_StreamingItemContentsStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Preload_StreamingItemContentsStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
AllocPreload_AlwaysloadedFlagsPerModel
==============
*/

AlwaysloadedFlagsPerModel *__fastcall AllocPreload_AlwaysloadedFlagsPerModel()
{
  return ?AllocPreload_AlwaysloadedFlagsPerModel@@YAPEAUAlwaysloadedFlagsPerModel@@XZ();
}

/*
==============
AllocPreload_transientSPWorldBitArray_t
==============
*/

bitarray<32> *__fastcall AllocPreload_transientSPWorldBitArray_t()
{
  return ?AllocPreload_transientSPWorldBitArray_t@@YAPEAV?$bitarray@$0CA@@@XZ();
}

/*
==============
Load_StreamingContentSetStream
==============
*/

void __fastcall Load_StreamingContentSetStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Load_StreamingContentSetStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
AllocLoad_TransientCosts
==============
*/

TransientCosts *__fastcall AllocLoad_TransientCosts()
{
  return ?AllocLoad_TransientCosts@@YAPEAUTransientCosts@@XZ();
}

/*
==============
Load_AlwaysloadedFlagsStream
==============
*/

void __fastcall Load_AlwaysloadedFlagsStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Load_AlwaysloadedFlagsStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Preload_AlwaysloadedFlagsArray
==============
*/

void __fastcall Preload_AlwaysloadedFlagsArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Preload_AlwaysloadedFlagsArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Postload_transientSPWorldBitArray_t
==============
*/

void __fastcall Postload_transientSPWorldBitArray_t(const DBStreamStart streamStart)
{
  ?Postload_transientSPWorldBitArray_t@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Mark_TransientWorldGridTileMapArray
==============
*/

int __fastcall Mark_TransientWorldGridTileMapArray(const unsigned __int64 count)
{
  return ?Mark_TransientWorldGridTileMapArray@@YAH_K@Z(count);
}

/*
==============
Preload_StreamingInfo
==============
*/

void __fastcall Preload_StreamingInfo(const DBStreamStart streamStart)
{
  ?Preload_StreamingInfo@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Mark_TransientSets
==============
*/

int __fastcall Mark_TransientSets()
{
  return ?Mark_TransientSets@@YAHXZ();
}

/*
==============
AllocPreload_TransientAssetReference
==============
*/

TransientAssetReference *__fastcall AllocPreload_TransientAssetReference()
{
  return ?AllocPreload_TransientAssetReference@@YAPEAUTransientAssetReference@@XZ();
}

/*
==============
Postload_transientSPWorldBitArray_tArray
==============
*/

void __fastcall Postload_transientSPWorldBitArray_tArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Postload_transientSPWorldBitArray_tArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Postload_TransientInfoArray
==============
*/

void __fastcall Postload_TransientInfoArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Postload_TransientInfoArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Load_TransientWorldGridTileMapArray
==============
*/

void __fastcall Load_TransientWorldGridTileMapArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Load_TransientWorldGridTileMapArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Load_StreamingItemContents
==============
*/

void __fastcall Load_StreamingItemContents(const DBStreamStart streamStart)
{
  ?Load_StreamingItemContents@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Postload_AlwaysloadedFlagSetStream
==============
*/

void __fastcall Postload_AlwaysloadedFlagSetStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Postload_AlwaysloadedFlagSetStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Load_ProcessStructLayout_StreamingContentSet
==============
*/

void Load_ProcessStructLayout_StreamingContentSet(void)
{
  ?Load_ProcessStructLayout_StreamingContentSet@@YAXXZ();
}

/*
==============
Load_TransientWorldGridTileMap
==============
*/

void __fastcall Load_TransientWorldGridTileMap(const DBStreamStart streamStart)
{
  ?Load_TransientWorldGridTileMap@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
AllocPostload_TransientWorldGridTileMap
==============
*/

TransientWorldGridTileMap *__fastcall AllocPostload_TransientWorldGridTileMap()
{
  return ?AllocPostload_TransientWorldGridTileMap@@YAPEAUTransientWorldGridTileMap@@XZ();
}

/*
==============
Mark_AlwaysloadedFlagsPerModelArray
==============
*/

int __fastcall Mark_AlwaysloadedFlagsPerModelArray(const unsigned __int64 count)
{
  return ?Mark_AlwaysloadedFlagsPerModelArray@@YAH_K@Z(count);
}

/*
==============
Mark_AlwaysloadedFlags
==============
*/

int __fastcall Mark_AlwaysloadedFlags()
{
  return ?Mark_AlwaysloadedFlags@@YAHXZ();
}

/*
==============
Preload_StreamingItemCost
==============
*/

void __fastcall Preload_StreamingItemCost(const DBStreamStart streamStart)
{
  ?Preload_StreamingItemCost@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Mark_StreamingItemContents
==============
*/

int __fastcall Mark_StreamingItemContents()
{
  return ?Mark_StreamingItemContents@@YAHXZ();
}

/*
==============
Mark_StreamingItemContentsArray
==============
*/

int __fastcall Mark_StreamingItemContentsArray(const unsigned __int64 count)
{
  return ?Mark_StreamingItemContentsArray@@YAH_K@Z(count);
}

/*
==============
AllocPostload_ForcedStubAssetReference
==============
*/

ForcedStubAssetReference *__fastcall AllocPostload_ForcedStubAssetReference()
{
  return ?AllocPostload_ForcedStubAssetReference@@YAPEAUForcedStubAssetReference@@XZ();
}

/*
==============
Mark_transientSPWorldBitArray_tArray
==============
*/

int __fastcall Mark_transientSPWorldBitArray_tArray(const unsigned __int64 count)
{
  return ?Mark_transientSPWorldBitArray_tArray@@YAH_K@Z(count);
}

/*
==============
Mark_AlwaysloadedFlagsPerModel
==============
*/

int __fastcall Mark_AlwaysloadedFlagsPerModel()
{
  return ?Mark_AlwaysloadedFlagsPerModel@@YAHXZ();
}

/*
==============
AllocLoad_TransientInfo_Bitarray
==============
*/

bitarray_dynamic *__fastcall AllocLoad_TransientInfo_Bitarray()
{
  return ?AllocLoad_TransientInfo_Bitarray@@YAPEAVbitarray_dynamic@@XZ();
}

/*
==============
Load_TransientInfo_BitarrayArray
==============
*/

void __fastcall Load_TransientInfo_BitarrayArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Load_TransientInfo_BitarrayArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
AllocLoad_StreamingContentSet
==============
*/

StreamingContentSet *__fastcall AllocLoad_StreamingContentSet()
{
  return ?AllocLoad_StreamingContentSet@@YAPEAUStreamingContentSet@@XZ();
}

/*
==============
Postload_TransientAssetReference
==============
*/

void __fastcall Postload_TransientAssetReference(const DBStreamStart streamStart)
{
  ?Postload_TransientAssetReference@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Load_ProcessStructLayout_TransientInfoFlags
==============
*/

void Load_ProcessStructLayout_TransientInfoFlags(void)
{
  ?Load_ProcessStructLayout_TransientInfoFlags@@YAXXZ();
}

/*
==============
Mark_StreamingItemCostArray
==============
*/

int __fastcall Mark_StreamingItemCostArray(const unsigned __int64 count)
{
  return ?Mark_StreamingItemCostArray@@YAH_K@Z(count);
}

/*
==============
Preload_StreamingItemContents
==============
*/

void __fastcall Preload_StreamingItemContents(const DBStreamStart streamStart)
{
  ?Preload_StreamingItemContents@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Postload_TransientInfo
==============
*/

void __fastcall Postload_TransientInfo(const DBStreamStart streamStart)
{
  ?Postload_TransientInfo@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Mark_TransientInfoArray
==============
*/

int __fastcall Mark_TransientInfoArray(const unsigned __int64 count)
{
  return ?Mark_TransientInfoArray@@YAH_K@Z(count);
}

/*
==============
Load_TransientAssetReference
==============
*/

void __fastcall Load_TransientAssetReference(const DBStreamStart streamStart)
{
  ?Load_TransientAssetReference@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Preload_ForcedStubAssetReferenceArray
==============
*/

void __fastcall Preload_ForcedStubAssetReferenceArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Preload_ForcedStubAssetReferenceArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Preload_TransientFileReference
==============
*/

void __fastcall Preload_TransientFileReference(const DBStreamStart streamStart)
{
  ?Preload_TransientFileReference@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Preload_TransientInfoFlagsArray
==============
*/

void __fastcall Preload_TransientInfoFlagsArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Preload_TransientInfoFlagsArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Mark_TransientInfo
==============
*/

int __fastcall Mark_TransientInfo()
{
  return ?Mark_TransientInfo@@YAHXZ();
}

/*
==============
Preload_TransientCosts
==============
*/

void __fastcall Preload_TransientCosts(const DBStreamStart streamStart)
{
  ?Preload_TransientCosts@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Postload_TransientInfoStream
==============
*/

void __fastcall Postload_TransientInfoStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Postload_TransientInfoStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
AllocPostload_transientSPWorldBitArray_t
==============
*/

bitarray<32> *__fastcall AllocPostload_transientSPWorldBitArray_t()
{
  return ?AllocPostload_transientSPWorldBitArray_t@@YAPEAV?$bitarray@$0CA@@@XZ();
}

/*
==============
Postload_TransientFileReferenceStream
==============
*/

void __fastcall Postload_TransientFileReferenceStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Postload_TransientFileReferenceStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Preload_TransientSetsStream
==============
*/

void __fastcall Preload_TransientSetsStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Preload_TransientSetsStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Preload_StreamingContentSet
==============
*/

void __fastcall Preload_StreamingContentSet(const DBStreamStart streamStart)
{
  ?Preload_StreamingContentSet@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Load_TransientAssetReferenceArray
==============
*/

void __fastcall Load_TransientAssetReferenceArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Load_TransientAssetReferenceArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Preload_StreamingInfoPtr
==============
*/

void __fastcall Preload_StreamingInfoPtr(const DBStreamStart streamStart)
{
  ?Preload_StreamingInfoPtr@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Postload_TransientCostsStream
==============
*/

void __fastcall Postload_TransientCostsStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Postload_TransientCostsStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Load_ProcessStructLayout_StreamingItemCost
==============
*/

void Load_ProcessStructLayout_StreamingItemCost(void)
{
  ?Load_ProcessStructLayout_StreamingItemCost@@YAXXZ();
}

/*
==============
Load_ProcessStructLayout_transientSPWorldBitArray_t
==============
*/

void Load_ProcessStructLayout_transientSPWorldBitArray_t(void)
{
  ?Load_ProcessStructLayout_transientSPWorldBitArray_t@@YAXXZ();
}

/*
==============
Postload_TransientInfoFlags
==============
*/

void __fastcall Postload_TransientInfoFlags(const DBStreamStart streamStart)
{
  ?Postload_TransientInfoFlags@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Postload_TransientSets
==============
*/

void __fastcall Postload_TransientSets(const DBStreamStart streamStart)
{
  ?Postload_TransientSets@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Preload_AlwaysloadedFlagSetArray
==============
*/

void __fastcall Preload_AlwaysloadedFlagSetArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Preload_AlwaysloadedFlagSetArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
AllocPostload_TransientInfo
==============
*/

TransientInfo *__fastcall AllocPostload_TransientInfo()
{
  return ?AllocPostload_TransientInfo@@YAPEAUTransientInfo@@XZ();
}

/*
==============
Postload_StreamingContentSetArray
==============
*/

void __fastcall Postload_StreamingContentSetArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Postload_StreamingContentSetArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Postload_StreamingInfoStream
==============
*/

void __fastcall Postload_StreamingInfoStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Postload_StreamingInfoStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Mark_TransientCosts
==============
*/

int __fastcall Mark_TransientCosts()
{
  return ?Mark_TransientCosts@@YAHXZ();
}

/*
==============
AllocPostload_AlwaysloadedFlagSet
==============
*/

AlwaysloadedFlagSet *__fastcall AllocPostload_AlwaysloadedFlagSet()
{
  return ?AllocPostload_AlwaysloadedFlagSet@@YAPEAUAlwaysloadedFlagSet@@XZ();
}

/*
==============
AllocPreload_ForcedStubAssetReference
==============
*/

ForcedStubAssetReference *__fastcall AllocPreload_ForcedStubAssetReference()
{
  return ?AllocPreload_ForcedStubAssetReference@@YAPEAUForcedStubAssetReference@@XZ();
}

/*
==============
Load_ProcessStructLayout_TransientAssetReference
==============
*/

void Load_ProcessStructLayout_TransientAssetReference(void)
{
  ?Load_ProcessStructLayout_TransientAssetReference@@YAXXZ();
}

/*
==============
Mark_AlwaysloadedFlagSet
==============
*/

int __fastcall Mark_AlwaysloadedFlagSet()
{
  return ?Mark_AlwaysloadedFlagSet@@YAHXZ();
}

/*
==============
AllocLoad_AlwaysloadedFlagsPerModel
==============
*/

AlwaysloadedFlagsPerModel *__fastcall AllocLoad_AlwaysloadedFlagsPerModel()
{
  return ?AllocLoad_AlwaysloadedFlagsPerModel@@YAPEAUAlwaysloadedFlagsPerModel@@XZ();
}

/*
==============
Mark_TransientAssetReference
==============
*/

int __fastcall Mark_TransientAssetReference()
{
  return ?Mark_TransientAssetReference@@YAHXZ();
}

/*
==============
Load_ProcessStructLayout_TransientFileReference
==============
*/

void Load_ProcessStructLayout_TransientFileReference(void)
{
  ?Load_ProcessStructLayout_TransientFileReference@@YAXXZ();
}

/*
==============
Preload_AlwaysloadedFlagsPerModelStream
==============
*/

void __fastcall Preload_AlwaysloadedFlagsPerModelStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Preload_AlwaysloadedFlagsPerModelStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
AllocPostload_TransientAssetReference
==============
*/

TransientAssetReference *__fastcall AllocPostload_TransientAssetReference()
{
  return ?AllocPostload_TransientAssetReference@@YAPEAUTransientAssetReference@@XZ();
}

/*
==============
AllocPreload_AlwaysloadedFlagSet
==============
*/

AlwaysloadedFlagSet *__fastcall AllocPreload_AlwaysloadedFlagSet()
{
  return ?AllocPreload_AlwaysloadedFlagSet@@YAPEAUAlwaysloadedFlagSet@@XZ();
}

/*
==============
AllocPostload_TransientInfoFlags
==============
*/

TransientInfoFlags *__fastcall AllocPostload_TransientInfoFlags()
{
  return ?AllocPostload_TransientInfoFlags@@YAPEAW4TransientInfoFlags@@XZ();
}

/*
==============
Load_StreamingItemCost
==============
*/

void __fastcall Load_StreamingItemCost(const DBStreamStart streamStart)
{
  ?Load_StreamingItemCost@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Mark_TransientInfoFlags
==============
*/

int __fastcall Mark_TransientInfoFlags()
{
  return ?Mark_TransientInfoFlags@@YAHXZ();
}

/*
==============
Preload_ForcedStubAssetReferenceStream
==============
*/

void __fastcall Preload_ForcedStubAssetReferenceStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Preload_ForcedStubAssetReferenceStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Preload_AlwaysloadedFlags
==============
*/

void __fastcall Preload_AlwaysloadedFlags(const DBStreamStart streamStart)
{
  ?Preload_AlwaysloadedFlags@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Load_ProcessStructLayout_StreamingInfo
==============
*/

void Load_ProcessStructLayout_StreamingInfo(void)
{
  ?Load_ProcessStructLayout_StreamingInfo@@YAXXZ();
}

/*
==============
Mark_ForcedStubAssetReference
==============
*/

int __fastcall Mark_ForcedStubAssetReference()
{
  return ?Mark_ForcedStubAssetReference@@YAHXZ();
}

/*
==============
Load_ProcessStructLayout_TransientSets
==============
*/

void Load_ProcessStructLayout_TransientSets(void)
{
  ?Load_ProcessStructLayout_TransientSets@@YAXXZ();
}

/*
==============
Load_ProcessStructLayout_StreamingInfoPtr
==============
*/

void Load_ProcessStructLayout_StreamingInfoPtr(void)
{
  ?Load_ProcessStructLayout_StreamingInfoPtr@@YAXXZ();
}

/*
==============
Postload_TransientWorldGridTileMapStream
==============
*/

void __fastcall Postload_TransientWorldGridTileMapStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Postload_TransientWorldGridTileMapStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
AllocPostload_TransientFileReference
==============
*/

TransientFileReference *__fastcall AllocPostload_TransientFileReference()
{
  return ?AllocPostload_TransientFileReference@@YAPEAUTransientFileReference@@XZ();
}

/*
==============
AllocLoad_TransientSets
==============
*/

TransientSets *__fastcall AllocLoad_TransientSets()
{
  return ?AllocLoad_TransientSets@@YAPEAUTransientSets@@XZ();
}

/*
==============
AllocPreload_TransientInfoFlags
==============
*/

TransientInfoFlags *__fastcall AllocPreload_TransientInfoFlags()
{
  return ?AllocPreload_TransientInfoFlags@@YAPEAW4TransientInfoFlags@@XZ();
}

/*
==============
Load_TransientSetsArray
==============
*/

void __fastcall Load_TransientSetsArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Load_TransientSetsArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Load_TransientInfoFlags
==============
*/

void __fastcall Load_TransientInfoFlags(const DBStreamStart streamStart)
{
  ?Load_TransientInfoFlags@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Load_StreamingInfoPtrArray
==============
*/

void __fastcall Load_StreamingInfoPtrArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Load_StreamingInfoPtrArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Postload_TransientSetsStream
==============
*/

void __fastcall Postload_TransientSetsStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Postload_TransientSetsStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
AllocLoad_AlwaysloadedFlagSet
==============
*/

AlwaysloadedFlagSet *__fastcall AllocLoad_AlwaysloadedFlagSet()
{
  return ?AllocLoad_AlwaysloadedFlagSet@@YAPEAUAlwaysloadedFlagSet@@XZ();
}

/*
==============
Load_transientSPWorldBitArray_t
==============
*/

void __fastcall Load_transientSPWorldBitArray_t(const DBStreamStart streamStart)
{
  ?Load_transientSPWorldBitArray_t@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
AllocPostload_TransientInfo_Bitarray
==============
*/

bitarray_dynamic *__fastcall AllocPostload_TransientInfo_Bitarray()
{
  return ?AllocPostload_TransientInfo_Bitarray@@YAPEAVbitarray_dynamic@@XZ();
}

/*
==============
Postload_TransientSetsArray
==============
*/

void __fastcall Postload_TransientSetsArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Postload_TransientSetsArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Load_AlwaysloadedFlagSetStream
==============
*/

void __fastcall Load_AlwaysloadedFlagSetStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Load_AlwaysloadedFlagSetStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Postload_StreamingItemCostStream
==============
*/

void __fastcall Postload_StreamingItemCostStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Postload_StreamingItemCostStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Load_TransientCostsArray
==============
*/

void __fastcall Load_TransientCostsArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Load_TransientCostsArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Preload_TransientSetsArray
==============
*/

void __fastcall Preload_TransientSetsArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Preload_TransientSetsArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Postload_TransientInfo_BitarrayArray
==============
*/

void __fastcall Postload_TransientInfo_BitarrayArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Postload_TransientInfo_BitarrayArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
AllocPostload_StreamingItemCost
==============
*/

StreamingItemCost *__fastcall AllocPostload_StreamingItemCost()
{
  return ?AllocPostload_StreamingItemCost@@YAPEAUStreamingItemCost@@XZ();
}

/*
==============
Postload_TransientInfoFlagsArray
==============
*/

void __fastcall Postload_TransientInfoFlagsArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Postload_TransientInfoFlagsArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
AllocLoad_ForcedStubAssetReference
==============
*/

ForcedStubAssetReference *__fastcall AllocLoad_ForcedStubAssetReference()
{
  return ?AllocLoad_ForcedStubAssetReference@@YAPEAUForcedStubAssetReference@@XZ();
}

/*
==============
AllocLoad_TransientInfo
==============
*/

TransientInfo *__fastcall AllocLoad_TransientInfo()
{
  return ?AllocLoad_TransientInfo@@YAPEAUTransientInfo@@XZ();
}

/*
==============
Preload_TransientAssetReferenceStream
==============
*/

void __fastcall Preload_TransientAssetReferenceStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Preload_TransientAssetReferenceStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Preload_StreamingItemContentsArray
==============
*/

void __fastcall Preload_StreamingItemContentsArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Preload_StreamingItemContentsArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Load_ProcessStructLayout_TransientWorldGridTileMap
==============
*/

void Load_ProcessStructLayout_TransientWorldGridTileMap(void)
{
  ?Load_ProcessStructLayout_TransientWorldGridTileMap@@YAXXZ();
}

/*
==============
Mark_TransientAssetReferenceArray
==============
*/

int __fastcall Mark_TransientAssetReferenceArray(const unsigned __int64 count)
{
  return ?Mark_TransientAssetReferenceArray@@YAH_K@Z(count);
}

/*
==============
Postload_AlwaysloadedFlagsPerModelArray
==============
*/

void __fastcall Postload_AlwaysloadedFlagsPerModelArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Postload_AlwaysloadedFlagsPerModelArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Postload_StreamingInfoPtrStream
==============
*/

void __fastcall Postload_StreamingInfoPtrStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Postload_StreamingInfoPtrStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Preload_TransientWorldGridTileMapArray
==============
*/

void __fastcall Preload_TransientWorldGridTileMapArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Preload_TransientWorldGridTileMapArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Postload_AlwaysloadedFlagsArray
==============
*/

void __fastcall Postload_AlwaysloadedFlagsArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Postload_AlwaysloadedFlagsArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
AllocPreload_AlwaysloadedFlags
==============
*/

AlwaysloadedFlags *__fastcall AllocPreload_AlwaysloadedFlags()
{
  return ?AllocPreload_AlwaysloadedFlags@@YAPEAUAlwaysloadedFlags@@XZ();
}

/*
==============
Postload_StreamingInfoArray
==============
*/

void __fastcall Postload_StreamingInfoArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Postload_StreamingInfoArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Postload_AlwaysloadedFlags
==============
*/

void __fastcall Postload_AlwaysloadedFlags(const DBStreamStart streamStart)
{
  ?Postload_AlwaysloadedFlags@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Preload_TransientFileReferenceArray
==============
*/

void __fastcall Preload_TransientFileReferenceArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Preload_TransientFileReferenceArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
AllocLoad_TransientWorldGridTileMap
==============
*/

TransientWorldGridTileMap *__fastcall AllocLoad_TransientWorldGridTileMap()
{
  return ?AllocLoad_TransientWorldGridTileMap@@YAPEAUTransientWorldGridTileMap@@XZ();
}

/*
==============
Load_ProcessStructLayout_AlwaysloadedFlags
==============
*/

void Load_ProcessStructLayout_AlwaysloadedFlags(void)
{
  ?Load_ProcessStructLayout_AlwaysloadedFlags@@YAXXZ();
}

/*
==============
Postload_TransientCosts
==============
*/

void __fastcall Postload_TransientCosts(const DBStreamStart streamStart)
{
  ?Postload_TransientCosts@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Load_TransientInfoFlagsArray
==============
*/

void __fastcall Load_TransientInfoFlagsArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Load_TransientInfoFlagsArray@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Load_AlwaysloadedFlagSet
==============
*/

void __fastcall Load_AlwaysloadedFlagSet(const DBStreamStart streamStart)
{
  ?Load_AlwaysloadedFlagSet@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Postload_StreamingInfo
==============
*/

void __fastcall Postload_StreamingInfo(const DBStreamStart streamStart)
{
  ?Postload_StreamingInfo@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Preload_ForcedStubAssetReference
==============
*/

void __fastcall Preload_ForcedStubAssetReference(const DBStreamStart streamStart)
{
  ?Preload_ForcedStubAssetReference@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
Mark_transientSPWorldBitArray_t
==============
*/

int __fastcall Mark_transientSPWorldBitArray_t()
{
  return ?Mark_transientSPWorldBitArray_t@@YAHXZ();
}

/*
==============
Load_ProcessStructLayout_TransientCosts
==============
*/

void Load_ProcessStructLayout_TransientCosts(void)
{
  ?Load_ProcessStructLayout_TransientCosts@@YAXXZ();
}

/*
==============
Postload_StreamingItemContents
==============
*/

void __fastcall Postload_StreamingItemContents(const DBStreamStart streamStart)
{
  ?Postload_StreamingItemContents@@YAXW4DBStreamStart@@@Z(streamStart);
}

/*
==============
AllocLoad_TransientFileReference
==============
*/

TransientFileReference *__fastcall AllocLoad_TransientFileReference()
{
  return ?AllocLoad_TransientFileReference@@YAPEAUTransientFileReference@@XZ();
}

/*
==============
AllocPostload_AlwaysloadedFlags
==============
*/

AlwaysloadedFlags *__fastcall AllocPostload_AlwaysloadedFlags()
{
  return ?AllocPostload_AlwaysloadedFlags@@YAPEAUAlwaysloadedFlags@@XZ();
}

/*
==============
Load_transientSPWorldBitArray_tStream
==============
*/

void __fastcall Load_transientSPWorldBitArray_tStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  ?Load_transientSPWorldBitArray_tStream@@YAXW4DBStreamStart@@_K@Z(streamStart, count);
}

/*
==============
Mark_TransientFileReferenceArray
==============
*/

int __fastcall Mark_TransientFileReferenceArray(const unsigned __int64 count)
{
  return ?Mark_TransientFileReferenceArray@@YAH_K@Z(count);
}

/*
==============
AllocLoad_AlwaysloadedFlagSet
==============
*/
AlwaysloadedFlagSet *AllocLoad_AlwaysloadedFlagSet()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (AlwaysloadedFlagSet *)g_streamPosGlob.pos;
}

/*
==============
AllocLoad_AlwaysloadedFlags
==============
*/
AlwaysloadedFlags *AllocLoad_AlwaysloadedFlags()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (AlwaysloadedFlags *)g_streamPosGlob.pos;
}

/*
==============
AllocLoad_AlwaysloadedFlagsPerModel
==============
*/
AlwaysloadedFlagsPerModel *AllocLoad_AlwaysloadedFlagsPerModel()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (AlwaysloadedFlagsPerModel *)g_streamPosGlob.pos;
}

/*
==============
AllocLoad_ForcedStubAssetReference
==============
*/
ForcedStubAssetReference *AllocLoad_ForcedStubAssetReference()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (ForcedStubAssetReference *)g_streamPosGlob.pos;
}

/*
==============
AllocLoad_StreamingContentSet
==============
*/
StreamingContentSet *AllocLoad_StreamingContentSet()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (StreamingContentSet *)g_streamPosGlob.pos;
}

/*
==============
AllocLoad_StreamingInfo
==============
*/
StreamingInfo *AllocLoad_StreamingInfo()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (StreamingInfo *)g_streamPosGlob.pos;
}

/*
==============
AllocLoad_StreamingInfoPtr
==============
*/
StreamingInfo **AllocLoad_StreamingInfoPtr()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (StreamingInfo **)g_streamPosGlob.pos;
}

/*
==============
AllocLoad_StreamingItemContents
==============
*/
StreamingItemContents *AllocLoad_StreamingItemContents()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (StreamingItemContents *)g_streamPosGlob.pos;
}

/*
==============
AllocLoad_StreamingItemCost
==============
*/
StreamingItemCost *AllocLoad_StreamingItemCost()
{
  DB_PatchMem_FixStreamAlignment(3ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (StreamingItemCost *)g_streamPosGlob.pos;
}

/*
==============
AllocLoad_TransientAssetReference
==============
*/
TransientAssetReference *AllocLoad_TransientAssetReference()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (TransientAssetReference *)g_streamPosGlob.pos;
}

/*
==============
AllocLoad_TransientCosts
==============
*/
TransientCosts *AllocLoad_TransientCosts()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (TransientCosts *)g_streamPosGlob.pos;
}

/*
==============
AllocLoad_TransientFileReference
==============
*/
TransientFileReference *AllocLoad_TransientFileReference()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (TransientFileReference *)g_streamPosGlob.pos;
}

/*
==============
AllocLoad_TransientInfo
==============
*/
TransientInfo *AllocLoad_TransientInfo()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (TransientInfo *)g_streamPosGlob.pos;
}

/*
==============
AllocLoad_TransientInfoFlags
==============
*/
TransientInfoFlags *AllocLoad_TransientInfoFlags()
{
  return (TransientInfoFlags *)g_streamPosGlob.pos;
}

/*
==============
AllocLoad_TransientInfo_Bitarray
==============
*/
bitarray_dynamic *AllocLoad_TransientInfo_Bitarray()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (bitarray_dynamic *)g_streamPosGlob.pos;
}

/*
==============
AllocLoad_TransientSets
==============
*/
TransientSets *AllocLoad_TransientSets()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (TransientSets *)g_streamPosGlob.pos;
}

/*
==============
AllocLoad_TransientWorldGridTileMap
==============
*/
TransientWorldGridTileMap *AllocLoad_TransientWorldGridTileMap()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (TransientWorldGridTileMap *)g_streamPosGlob.pos;
}

/*
==============
AllocLoad_transientSPWorldBitArray_t
==============
*/
bitarray<32> *AllocLoad_transientSPWorldBitArray_t()
{
  DB_PatchMem_FixStreamAlignment(3ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (bitarray<32> *)g_streamPosGlob.pos;
}

/*
==============
AllocPostload_AlwaysloadedFlagSet
==============
*/
AlwaysloadedFlagSet *AllocPostload_AlwaysloadedFlagSet()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (AlwaysloadedFlagSet *)g_streamPosGlob.pos;
}

/*
==============
AllocPostload_AlwaysloadedFlags
==============
*/
AlwaysloadedFlags *AllocPostload_AlwaysloadedFlags()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (AlwaysloadedFlags *)g_streamPosGlob.pos;
}

/*
==============
AllocPostload_AlwaysloadedFlagsPerModel
==============
*/
AlwaysloadedFlagsPerModel *AllocPostload_AlwaysloadedFlagsPerModel()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (AlwaysloadedFlagsPerModel *)g_streamPosGlob.pos;
}

/*
==============
AllocPostload_ForcedStubAssetReference
==============
*/
ForcedStubAssetReference *AllocPostload_ForcedStubAssetReference()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (ForcedStubAssetReference *)g_streamPosGlob.pos;
}

/*
==============
AllocPostload_StreamingContentSet
==============
*/
StreamingContentSet *AllocPostload_StreamingContentSet()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (StreamingContentSet *)g_streamPosGlob.pos;
}

/*
==============
AllocPostload_StreamingInfo
==============
*/
StreamingInfo *AllocPostload_StreamingInfo()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (StreamingInfo *)g_streamPosGlob.pos;
}

/*
==============
AllocPostload_StreamingInfoPtr
==============
*/
StreamingInfo **AllocPostload_StreamingInfoPtr()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (StreamingInfo **)g_streamPosGlob.pos;
}

/*
==============
AllocPostload_StreamingItemContents
==============
*/
StreamingItemContents *AllocPostload_StreamingItemContents()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (StreamingItemContents *)g_streamPosGlob.pos;
}

/*
==============
AllocPostload_StreamingItemCost
==============
*/
StreamingItemCost *AllocPostload_StreamingItemCost()
{
  DB_PatchMem_FixStreamAlignment(3ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (StreamingItemCost *)g_streamPosGlob.pos;
}

/*
==============
AllocPostload_TransientAssetReference
==============
*/
TransientAssetReference *AllocPostload_TransientAssetReference()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (TransientAssetReference *)g_streamPosGlob.pos;
}

/*
==============
AllocPostload_TransientCosts
==============
*/
TransientCosts *AllocPostload_TransientCosts()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (TransientCosts *)g_streamPosGlob.pos;
}

/*
==============
AllocPostload_TransientFileReference
==============
*/
TransientFileReference *AllocPostload_TransientFileReference()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (TransientFileReference *)g_streamPosGlob.pos;
}

/*
==============
AllocPostload_TransientInfo
==============
*/
TransientInfo *AllocPostload_TransientInfo()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (TransientInfo *)g_streamPosGlob.pos;
}

/*
==============
AllocPostload_TransientInfoFlags
==============
*/
TransientInfoFlags *AllocPostload_TransientInfoFlags()
{
  return (TransientInfoFlags *)g_streamPosGlob.pos;
}

/*
==============
AllocPostload_TransientInfo_Bitarray
==============
*/
bitarray_dynamic *AllocPostload_TransientInfo_Bitarray()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (bitarray_dynamic *)g_streamPosGlob.pos;
}

/*
==============
AllocPostload_TransientSets
==============
*/
TransientSets *AllocPostload_TransientSets()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (TransientSets *)g_streamPosGlob.pos;
}

/*
==============
AllocPostload_TransientWorldGridTileMap
==============
*/
TransientWorldGridTileMap *AllocPostload_TransientWorldGridTileMap()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (TransientWorldGridTileMap *)g_streamPosGlob.pos;
}

/*
==============
AllocPostload_transientSPWorldBitArray_t
==============
*/
bitarray<32> *AllocPostload_transientSPWorldBitArray_t()
{
  DB_PatchMem_FixStreamAlignment(3ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (bitarray<32> *)g_streamPosGlob.pos;
}

/*
==============
AllocPreload_AlwaysloadedFlagSet
==============
*/
AlwaysloadedFlagSet *AllocPreload_AlwaysloadedFlagSet()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (AlwaysloadedFlagSet *)g_streamPosGlob.pos;
}

/*
==============
AllocPreload_AlwaysloadedFlags
==============
*/
AlwaysloadedFlags *AllocPreload_AlwaysloadedFlags()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (AlwaysloadedFlags *)g_streamPosGlob.pos;
}

/*
==============
AllocPreload_AlwaysloadedFlagsPerModel
==============
*/
AlwaysloadedFlagsPerModel *AllocPreload_AlwaysloadedFlagsPerModel()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (AlwaysloadedFlagsPerModel *)g_streamPosGlob.pos;
}

/*
==============
AllocPreload_ForcedStubAssetReference
==============
*/
ForcedStubAssetReference *AllocPreload_ForcedStubAssetReference()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (ForcedStubAssetReference *)g_streamPosGlob.pos;
}

/*
==============
AllocPreload_StreamingContentSet
==============
*/
StreamingContentSet *AllocPreload_StreamingContentSet()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (StreamingContentSet *)g_streamPosGlob.pos;
}

/*
==============
AllocPreload_StreamingInfo
==============
*/
StreamingInfo *AllocPreload_StreamingInfo()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (StreamingInfo *)g_streamPosGlob.pos;
}

/*
==============
AllocPreload_StreamingInfoPtr
==============
*/
StreamingInfo **AllocPreload_StreamingInfoPtr()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (StreamingInfo **)g_streamPosGlob.pos;
}

/*
==============
AllocPreload_StreamingItemContents
==============
*/
StreamingItemContents *AllocPreload_StreamingItemContents()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (StreamingItemContents *)g_streamPosGlob.pos;
}

/*
==============
AllocPreload_StreamingItemCost
==============
*/
StreamingItemCost *AllocPreload_StreamingItemCost()
{
  DB_PatchMem_FixStreamAlignment(3ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (StreamingItemCost *)g_streamPosGlob.pos;
}

/*
==============
AllocPreload_TransientAssetReference
==============
*/
TransientAssetReference *AllocPreload_TransientAssetReference()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (TransientAssetReference *)g_streamPosGlob.pos;
}

/*
==============
AllocPreload_TransientCosts
==============
*/
TransientCosts *AllocPreload_TransientCosts()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (TransientCosts *)g_streamPosGlob.pos;
}

/*
==============
AllocPreload_TransientFileReference
==============
*/
TransientFileReference *AllocPreload_TransientFileReference()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (TransientFileReference *)g_streamPosGlob.pos;
}

/*
==============
AllocPreload_TransientInfo
==============
*/
TransientInfo *AllocPreload_TransientInfo()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (TransientInfo *)g_streamPosGlob.pos;
}

/*
==============
AllocPreload_TransientInfoFlags
==============
*/
TransientInfoFlags *AllocPreload_TransientInfoFlags()
{
  return (TransientInfoFlags *)g_streamPosGlob.pos;
}

/*
==============
AllocPreload_TransientInfo_Bitarray
==============
*/
bitarray_dynamic *AllocPreload_TransientInfo_Bitarray()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (bitarray_dynamic *)g_streamPosGlob.pos;
}

/*
==============
AllocPreload_TransientSets
==============
*/
TransientSets *AllocPreload_TransientSets()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (TransientSets *)g_streamPosGlob.pos;
}

/*
==============
AllocPreload_TransientWorldGridTileMap
==============
*/
TransientWorldGridTileMap *AllocPreload_TransientWorldGridTileMap()
{
  DB_PatchMem_FixStreamAlignment(7ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (TransientWorldGridTileMap *)g_streamPosGlob.pos;
}

/*
==============
AllocPreload_transientSPWorldBitArray_t
==============
*/
bitarray<32> *AllocPreload_transientSPWorldBitArray_t()
{
  DB_PatchMem_FixStreamAlignment(3ui64);
  DB_CheckCanIncStreamPos(0i64);
  return (bitarray<32> *)g_streamPosGlob.pos;
}

/*
==============
Load_AlwaysloadedFlagSet
==============
*/
void Load_AlwaysloadedFlagSet(const DBStreamStart streamStart)
{
  AlwaysloadedFlags *v1; 
  AlwaysloadedFlagSet *v2; 
  AlwaysloadedFlagsPerModel *v3; 
  __int64 modelCount; 
  AlwaysloadedFlagsPerModel *i; 
  XModel **v6; 
  AlwaysloadedFlags *v7; 
  XModelSurfs **v8; 
  XModelSurfs **XModelSurfsPtr; 

  Load_Stream(streamStart, varAlwaysloadedFlagSet, 0x38ui64);
  v1 = varAlwaysloadedFlags;
  varAlwaysloadedFlags = &varAlwaysloadedFlagSet->globalFlags;
  Load_AlwaysloadedFlags(NotAtStart);
  v2 = varAlwaysloadedFlagSet;
  varAlwaysloadedFlags = v1;
  if ( varAlwaysloadedFlagSet->perModelFlags )
  {
    v3 = varAlwaysloadedFlagsPerModel;
    DB_PatchMem_FixStreamAlignment(7ui64);
    DB_CheckCanIncStreamPos(0i64);
    v2->perModelFlags = (AlwaysloadedFlagsPerModel *)g_streamPosGlob.pos;
    varAlwaysloadedFlagsPerModel = (AlwaysloadedFlagsPerModel *)g_streamPosGlob.pos;
    modelCount = varAlwaysloadedFlagSet->modelCount;
    Load_Stream(AtStart, g_streamPosGlob.pos, 32 * modelCount);
    for ( i = varAlwaysloadedFlagsPerModel; modelCount; --modelCount )
    {
      varAlwaysloadedFlagsPerModel = i;
      Load_Stream(NotAtStart, i, 0x20ui64);
      v6 = varXModelPtr;
      varXModelPtr = &varAlwaysloadedFlagsPerModel->model;
      Load_XModelPtr(NotAtStart);
      varXModelPtr = v6;
      v7 = varAlwaysloadedFlags;
      varAlwaysloadedFlags = &varAlwaysloadedFlagsPerModel->flags;
      Load_AlwaysloadedFlags(NotAtStart);
      ++i;
      varAlwaysloadedFlags = v7;
    }
    v2 = varAlwaysloadedFlagSet;
    varAlwaysloadedFlagsPerModel = v3;
  }
  if ( v2->modelSurfs )
  {
    v8 = varXModelSurfsPtr;
    XModelSurfsPtr = AllocLoad_XModelSurfsPtr();
    v2->modelSurfs = XModelSurfsPtr;
    varXModelSurfsPtr = XModelSurfsPtr;
    Load_XModelSurfsPtrArray(AtStart, varAlwaysloadedFlagSet->modelSurfCount);
    varXModelSurfsPtr = v8;
  }
}

/*
==============
Load_AlwaysloadedFlagSetArray
==============
*/
void Load_AlwaysloadedFlagSetArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  AlwaysloadedFlagSet *i; 
  AlwaysloadedFlags *v4; 
  AlwaysloadedFlagSet *v5; 
  AlwaysloadedFlagsPerModel *v6; 
  __int64 modelCount; 
  AlwaysloadedFlagsPerModel *j; 
  XModel **v9; 
  AlwaysloadedFlags *v10; 
  XModelSurfs **v11; 
  XModelSurfs **XModelSurfsPtr; 

  v2 = count;
  Load_Stream(streamStart, varAlwaysloadedFlagSet, 56 * count);
  for ( i = varAlwaysloadedFlagSet; v2; --v2 )
  {
    varAlwaysloadedFlagSet = i;
    Load_Stream(NotAtStart, i, 0x38ui64);
    v4 = varAlwaysloadedFlags;
    varAlwaysloadedFlags = &varAlwaysloadedFlagSet->globalFlags;
    Load_AlwaysloadedFlags(NotAtStart);
    v5 = varAlwaysloadedFlagSet;
    varAlwaysloadedFlags = v4;
    if ( varAlwaysloadedFlagSet->perModelFlags )
    {
      v6 = varAlwaysloadedFlagsPerModel;
      DB_PatchMem_FixStreamAlignment(7ui64);
      DB_CheckCanIncStreamPos(0i64);
      v5->perModelFlags = (AlwaysloadedFlagsPerModel *)g_streamPosGlob.pos;
      varAlwaysloadedFlagsPerModel = (AlwaysloadedFlagsPerModel *)g_streamPosGlob.pos;
      modelCount = varAlwaysloadedFlagSet->modelCount;
      Load_Stream(AtStart, g_streamPosGlob.pos, 32 * modelCount);
      for ( j = varAlwaysloadedFlagsPerModel; modelCount; --modelCount )
      {
        varAlwaysloadedFlagsPerModel = j;
        Load_Stream(NotAtStart, j, 0x20ui64);
        v9 = varXModelPtr;
        varXModelPtr = &varAlwaysloadedFlagsPerModel->model;
        Load_XModelPtr(NotAtStart);
        varXModelPtr = v9;
        v10 = varAlwaysloadedFlags;
        varAlwaysloadedFlags = &varAlwaysloadedFlagsPerModel->flags;
        Load_AlwaysloadedFlags(NotAtStart);
        ++j;
        varAlwaysloadedFlags = v10;
      }
      v5 = varAlwaysloadedFlagSet;
      varAlwaysloadedFlagsPerModel = v6;
    }
    if ( v5->modelSurfs )
    {
      v11 = varXModelSurfsPtr;
      XModelSurfsPtr = AllocLoad_XModelSurfsPtr();
      v5->modelSurfs = XModelSurfsPtr;
      varXModelSurfsPtr = XModelSurfsPtr;
      Load_XModelSurfsPtrArray(AtStart, varAlwaysloadedFlagSet->modelSurfCount);
      varXModelSurfsPtr = v11;
    }
    ++i;
  }
}

/*
==============
Load_AlwaysloadedFlagSetStream
==============
*/
void Load_AlwaysloadedFlagSetStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *pos; 
  AlwaysloadedFlags *v4; 
  AlwaysloadedFlagSet *v5; 
  AlwaysloadedFlagsPerModel *v6; 
  __int64 modelCount; 
  AlwaysloadedFlagsPerModel *i; 
  XModel **v9; 
  AlwaysloadedFlags *v10; 
  XModelSurfs **v11; 
  XModelSurfs **XModelSurfsPtr; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 1895, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    pos = (unsigned __int8 *)varAlwaysloadedFlagSet;
    do
    {
      Load_Stream(AtStart, pos, 0x38ui64);
      v4 = varAlwaysloadedFlags;
      varAlwaysloadedFlags = &varAlwaysloadedFlagSet->globalFlags;
      Load_AlwaysloadedFlags(NotAtStart);
      v5 = varAlwaysloadedFlagSet;
      varAlwaysloadedFlags = v4;
      if ( varAlwaysloadedFlagSet->perModelFlags )
      {
        v6 = varAlwaysloadedFlagsPerModel;
        DB_PatchMem_FixStreamAlignment(7ui64);
        DB_CheckCanIncStreamPos(0i64);
        v5->perModelFlags = (AlwaysloadedFlagsPerModel *)g_streamPosGlob.pos;
        varAlwaysloadedFlagsPerModel = (AlwaysloadedFlagsPerModel *)g_streamPosGlob.pos;
        modelCount = varAlwaysloadedFlagSet->modelCount;
        Load_Stream(AtStart, g_streamPosGlob.pos, 32 * modelCount);
        for ( i = varAlwaysloadedFlagsPerModel; modelCount; --modelCount )
        {
          varAlwaysloadedFlagsPerModel = i;
          Load_Stream(NotAtStart, i, 0x20ui64);
          v9 = varXModelPtr;
          varXModelPtr = &varAlwaysloadedFlagsPerModel->model;
          Load_XModelPtr(NotAtStart);
          varXModelPtr = v9;
          v10 = varAlwaysloadedFlags;
          varAlwaysloadedFlags = &varAlwaysloadedFlagsPerModel->flags;
          Load_AlwaysloadedFlags(NotAtStart);
          ++i;
          varAlwaysloadedFlags = v10;
        }
        v5 = varAlwaysloadedFlagSet;
        varAlwaysloadedFlagsPerModel = v6;
      }
      if ( v5->modelSurfs )
      {
        v11 = varXModelSurfsPtr;
        XModelSurfsPtr = AllocLoad_XModelSurfsPtr();
        v5->modelSurfs = XModelSurfsPtr;
        varXModelSurfsPtr = XModelSurfsPtr;
        Load_XModelSurfsPtrArray(AtStart, varAlwaysloadedFlagSet->modelSurfCount);
        varXModelSurfsPtr = v11;
      }
      pos = g_streamPosGlob.pos;
      varAlwaysloadedFlagSet = (AlwaysloadedFlagSet *)g_streamPosGlob.pos;
      --count;
    }
    while ( count );
  }
}

/*
==============
Load_AlwaysloadedFlags
==============
*/
void Load_AlwaysloadedFlags(const DBStreamStart streamStart)
{
  AlwaysloadedFlags *v1; 
  GfxImage **v2; 
  __int64 imageCount; 
  GfxImage **i; 
  unsigned int *v5; 
  unsigned int *uint; 
  unsigned int v7; 

  Load_Stream(streamStart, varAlwaysloadedFlags, 0x18ui64);
  v1 = varAlwaysloadedFlags;
  if ( varAlwaysloadedFlags->images )
  {
    v2 = varGfxImagePtr;
    DB_PatchMem_FixStreamAlignment(7ui64);
    DB_CheckCanIncStreamPos(0i64);
    v1->images = (GfxImage **)g_streamPosGlob.pos;
    varGfxImagePtr = (GfxImage **)g_streamPosGlob.pos;
    imageCount = varAlwaysloadedFlags->imageCount;
    Load_Stream(AtStart, g_streamPosGlob.pos, 8 * imageCount);
    for ( i = varGfxImagePtr; imageCount; --imageCount )
    {
      varGfxImagePtr = i;
      Load_GfxImagePtr(NotAtStart);
      ++i;
    }
    v1 = varAlwaysloadedFlags;
    varGfxImagePtr = v2;
  }
  if ( v1->imageFlags )
  {
    v5 = varuint;
    uint = AllocLoad_uint();
    v1->imageFlags = uint;
    varuint = uint;
    v7 = DB_StreamingInfo_CalcUIntsForImageFlags(varAlwaysloadedFlags->imageCount);
    Load_uintArray(AtStart, v7);
    varuint = v5;
  }
}

/*
==============
Load_AlwaysloadedFlagsArray
==============
*/
void Load_AlwaysloadedFlagsArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  AlwaysloadedFlags *i; 
  AlwaysloadedFlags *v4; 
  GfxImage **v5; 
  __int64 imageCount; 
  GfxImage **j; 
  unsigned int *v8; 
  unsigned int *uint; 
  unsigned int v10; 

  v2 = count;
  Load_Stream(streamStart, varAlwaysloadedFlags, 24 * count);
  for ( i = varAlwaysloadedFlags; v2; --v2 )
  {
    varAlwaysloadedFlags = i;
    Load_Stream(NotAtStart, i, 0x18ui64);
    v4 = varAlwaysloadedFlags;
    if ( varAlwaysloadedFlags->images )
    {
      v5 = varGfxImagePtr;
      DB_PatchMem_FixStreamAlignment(7ui64);
      DB_CheckCanIncStreamPos(0i64);
      v4->images = (GfxImage **)g_streamPosGlob.pos;
      varGfxImagePtr = (GfxImage **)g_streamPosGlob.pos;
      imageCount = varAlwaysloadedFlags->imageCount;
      Load_Stream(AtStart, g_streamPosGlob.pos, 8 * imageCount);
      for ( j = varGfxImagePtr; imageCount; --imageCount )
      {
        varGfxImagePtr = j;
        Load_GfxImagePtr(NotAtStart);
        ++j;
      }
      v4 = varAlwaysloadedFlags;
      varGfxImagePtr = v5;
    }
    if ( v4->imageFlags )
    {
      v8 = varuint;
      uint = AllocLoad_uint();
      v4->imageFlags = uint;
      varuint = uint;
      v10 = DB_StreamingInfo_CalcUIntsForImageFlags(varAlwaysloadedFlags->imageCount);
      Load_uintArray(AtStart, v10);
      varuint = v8;
    }
    ++i;
  }
}

/*
==============
Load_AlwaysloadedFlagsPerModel
==============
*/
void Load_AlwaysloadedFlagsPerModel(const DBStreamStart streamStart)
{
  XModel **v1; 
  AlwaysloadedFlags *v2; 

  Load_Stream(streamStart, varAlwaysloadedFlagsPerModel, 0x20ui64);
  v1 = varXModelPtr;
  varXModelPtr = &varAlwaysloadedFlagsPerModel->model;
  Load_XModelPtr(NotAtStart);
  varXModelPtr = v1;
  v2 = varAlwaysloadedFlags;
  varAlwaysloadedFlags = &varAlwaysloadedFlagsPerModel->flags;
  Load_AlwaysloadedFlags(NotAtStart);
  varAlwaysloadedFlags = v2;
}

/*
==============
Load_AlwaysloadedFlagsPerModelArray
==============
*/
void Load_AlwaysloadedFlagsPerModelArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  AlwaysloadedFlagsPerModel *i; 
  XModel **v4; 
  AlwaysloadedFlags *v5; 

  v2 = count;
  Load_Stream(streamStart, varAlwaysloadedFlagsPerModel, 32 * count);
  for ( i = varAlwaysloadedFlagsPerModel; v2; --v2 )
  {
    varAlwaysloadedFlagsPerModel = i;
    Load_Stream(NotAtStart, i, 0x20ui64);
    v4 = varXModelPtr;
    varXModelPtr = &varAlwaysloadedFlagsPerModel->model;
    Load_XModelPtr(NotAtStart);
    varXModelPtr = v4;
    v5 = varAlwaysloadedFlags;
    varAlwaysloadedFlags = &varAlwaysloadedFlagsPerModel->flags;
    Load_AlwaysloadedFlags(NotAtStart);
    ++i;
    varAlwaysloadedFlags = v5;
  }
}

/*
==============
Load_AlwaysloadedFlagsPerModelStream
==============
*/
void Load_AlwaysloadedFlagsPerModelStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *pos; 
  XModel **v4; 
  AlwaysloadedFlags *v5; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 1717, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    pos = (unsigned __int8 *)varAlwaysloadedFlagsPerModel;
    do
    {
      Load_Stream(AtStart, pos, 0x20ui64);
      v4 = varXModelPtr;
      varXModelPtr = &varAlwaysloadedFlagsPerModel->model;
      Load_XModelPtr(NotAtStart);
      varXModelPtr = v4;
      v5 = varAlwaysloadedFlags;
      varAlwaysloadedFlags = &varAlwaysloadedFlagsPerModel->flags;
      Load_AlwaysloadedFlags(NotAtStart);
      pos = g_streamPosGlob.pos;
      varAlwaysloadedFlagsPerModel = (AlwaysloadedFlagsPerModel *)g_streamPosGlob.pos;
      varAlwaysloadedFlags = v5;
      --count;
    }
    while ( count );
  }
}

/*
==============
Load_AlwaysloadedFlagsStream
==============
*/
void Load_AlwaysloadedFlagsStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *pos; 
  AlwaysloadedFlags *v4; 
  GfxImage **v5; 
  __int64 imageCount; 
  GfxImage **i; 
  unsigned int *v8; 
  unsigned int *uint; 
  unsigned int v10; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 1614, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    pos = (unsigned __int8 *)varAlwaysloadedFlags;
    do
    {
      Load_Stream(AtStart, pos, 0x18ui64);
      v4 = varAlwaysloadedFlags;
      if ( varAlwaysloadedFlags->images )
      {
        v5 = varGfxImagePtr;
        DB_PatchMem_FixStreamAlignment(7ui64);
        DB_CheckCanIncStreamPos(0i64);
        v4->images = (GfxImage **)g_streamPosGlob.pos;
        varGfxImagePtr = (GfxImage **)g_streamPosGlob.pos;
        imageCount = varAlwaysloadedFlags->imageCount;
        Load_Stream(AtStart, g_streamPosGlob.pos, 8 * imageCount);
        for ( i = varGfxImagePtr; imageCount; --imageCount )
        {
          varGfxImagePtr = i;
          Load_GfxImagePtr(NotAtStart);
          ++i;
        }
        v4 = varAlwaysloadedFlags;
        varGfxImagePtr = v5;
      }
      if ( v4->imageFlags )
      {
        v8 = varuint;
        uint = AllocLoad_uint();
        v4->imageFlags = uint;
        varuint = uint;
        v10 = DB_StreamingInfo_CalcUIntsForImageFlags(varAlwaysloadedFlags->imageCount);
        Load_uintArray(AtStart, v10);
        varuint = v8;
      }
      pos = g_streamPosGlob.pos;
      varAlwaysloadedFlags = (AlwaysloadedFlags *)g_streamPosGlob.pos;
      --count;
    }
    while ( count );
  }
}

/*
==============
Load_ForcedStubAssetReference
==============
*/
void Load_ForcedStubAssetReference(const DBStreamStart streamStart)
{
  const char **v1; 

  Load_Stream(streamStart, varForcedStubAssetReference, 0x10ui64);
  v1 = varXString;
  varXString = &varForcedStubAssetReference->name;
  Load_XString(NotAtStart);
  varXString = v1;
}

/*
==============
Load_ForcedStubAssetReferenceArray
==============
*/
void Load_ForcedStubAssetReferenceArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  ForcedStubAssetReference *i; 
  const char **v4; 

  v2 = count;
  Load_Stream(streamStart, varForcedStubAssetReference, 16 * count);
  for ( i = varForcedStubAssetReference; v2; --v2 )
  {
    varForcedStubAssetReference = i;
    Load_Stream(NotAtStart, i, 0x10ui64);
    v4 = varXString;
    varXString = &varForcedStubAssetReference->name;
    Load_XString(NotAtStart);
    ++i;
    varXString = v4;
  }
}

/*
==============
Load_ForcedStubAssetReferenceStream
==============
*/
void Load_ForcedStubAssetReferenceStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *pos; 
  const char **v4; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 1995, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    pos = (unsigned __int8 *)varForcedStubAssetReference;
    do
    {
      Load_Stream(AtStart, pos, 0x10ui64);
      v4 = varXString;
      varXString = &varForcedStubAssetReference->name;
      Load_XString(NotAtStart);
      pos = g_streamPosGlob.pos;
      varForcedStubAssetReference = (ForcedStubAssetReference *)g_streamPosGlob.pos;
      varXString = v4;
      --count;
    }
    while ( count );
  }
}

/*
==============
Load_ProcessStructLayout_AlwaysloadedFlagSet
==============
*/
void Load_ProcessStructLayout_AlwaysloadedFlagSet(void)
{
  if ( Load_RegisterStructSize("AlwaysloadedFlagSet", 0x5F07F6EEu, 0x38ui64, 8ui64) )
  {
    Load_RegisterStructMemberSize("AlwaysloadedFlagSet", 0x5F07F6EEu, "AlwaysloadedFlags", 0x7C52B039u, "globalFlags", 0x68FF4A0Au, 0i64, 0x18ui64, 0i64, 0, 0);
    Load_ProcessStructLayout_AlwaysloadedFlags();
    Load_RegisterStructMemberSize("AlwaysloadedFlagSet", 0x5F07F6EEu, "uint", 0x53A932A0u, "modelCount", 0xE01A1124, 0x18ui64, 4ui64, 0i64, 0, 0);
    Load_ProcessStructLayout_uint();
    Load_RegisterStructMemberSize("AlwaysloadedFlagSet", 0x5F07F6EEu, "AlwaysloadedFlagsPerModel", 0x77A7101Du, "perModelFlags", 0x4753290Du, 0x20ui64, 8ui64, 0i64, 1, 0);
    if ( Load_RegisterStructSize("AlwaysloadedFlagsPerModel", 0x77A7101Du, 0x20ui64, 8ui64) )
    {
      Load_RegisterStructMemberSize("AlwaysloadedFlagsPerModel", 0x77A7101Du, "XModelPtr", 0xC52046E3, "model", 0xEC5C307F, 0i64, 8ui64, 0i64, 0, 0);
      Load_ProcessStructLayout_XModelPtr();
      Load_RegisterStructMemberSize("AlwaysloadedFlagsPerModel", 0x77A7101Du, "AlwaysloadedFlags", 0x7C52B039u, "flags", 0x85A76201, 8ui64, 0x18ui64, 0i64, 0, 0);
      Load_ProcessStructLayout_AlwaysloadedFlags();
    }
    Load_RegisterStructMemberSize("AlwaysloadedFlagSet", 0x5F07F6EEu, "uint", 0x53A932A0u, "modelSurfCount", 0x1E18BFE8u, 0x28ui64, 4ui64, 0i64, 0, 0);
    Load_ProcessStructLayout_uint();
    Load_RegisterStructMemberSize("AlwaysloadedFlagSet", 0x5F07F6EEu, "XModelSurfsPtr", 0x64C1E118u, "modelSurfs", 0xAD2B8312, 0x30ui64, 8ui64, 0i64, 1, 0);
    Load_ProcessStructLayout_XModelSurfsPtr();
  }
}

/*
==============
Load_ProcessStructLayout_AlwaysloadedFlags
==============
*/
void Load_ProcessStructLayout_AlwaysloadedFlags(void)
{
  if ( Load_RegisterStructSize("AlwaysloadedFlags", 0x7C52B039u, 0x18ui64, 8ui64) )
  {
    Load_RegisterStructMemberSize("AlwaysloadedFlags", 0x7C52B039u, "uint", 0x53A932A0u, "imageCount", 0xD62769D4, 0x10ui64, 4ui64, 0i64, 0, 0);
    Load_ProcessStructLayout_uint();
    Load_RegisterStructMemberSize("AlwaysloadedFlags", 0x7C52B039u, "GfxImagePtr", 0x4A325366u, "images", 0x6904236Eu, 0i64, 8ui64, 0i64, 1, 0);
    if ( Load_RegisterStructSize("GfxImagePtr", 0x4A325366u, 8ui64, 8ui64) )
    {
      Load_RegisterStructMemberSize("GfxImagePtr", 0x4A325366u, "GfxImage", 0x3EDB84B8u, (const char *)&queryFormat.fmt + 3, 0, 0i64, 8ui64, 0i64, 1, 0);
      Load_ProcessStructLayout_GfxImage();
    }
    Load_RegisterStructMemberSize("AlwaysloadedFlags", 0x7C52B039u, "uint", 0x53A932A0u, "imageFlags", 0x1446900Cu, 8ui64, 8ui64, 0i64, 1, 0);
    Load_ProcessStructLayout_uint();
  }
}

/*
==============
Load_ProcessStructLayout_AlwaysloadedFlagsPerModel
==============
*/
void Load_ProcessStructLayout_AlwaysloadedFlagsPerModel(void)
{
  if ( Load_RegisterStructSize("AlwaysloadedFlagsPerModel", 0x77A7101Du, 0x20ui64, 8ui64) )
  {
    Load_RegisterStructMemberSize("AlwaysloadedFlagsPerModel", 0x77A7101Du, "XModelPtr", 0xC52046E3, "model", 0xEC5C307F, 0i64, 8ui64, 0i64, 0, 0);
    Load_ProcessStructLayout_XModelPtr();
    Load_RegisterStructMemberSize("AlwaysloadedFlagsPerModel", 0x77A7101Du, "AlwaysloadedFlags", 0x7C52B039u, "flags", 0x85A76201, 8ui64, 0x18ui64, 0i64, 0, 0);
    Load_ProcessStructLayout_AlwaysloadedFlags();
  }
}

/*
==============
Load_ProcessStructLayout_ForcedStubAssetReference
==============
*/
void Load_ProcessStructLayout_ForcedStubAssetReference(void)
{
  if ( Load_RegisterStructSize("ForcedStubAssetReference", 0x4A35FE20u, 0x10ui64, 8ui64) )
  {
    Load_RegisterStructMemberSize("ForcedStubAssetReference", 0x4A35FE20u, "XString", 0x6231894Bu, (const char *)&stru_143C9A1A4, 0x58737A51u, 0i64, 8ui64, 0i64, 0, 0);
    Load_ProcessStructLayout_XString();
    Load_RegisterStructMemberSize("ForcedStubAssetReference", 0x4A35FE20u, "byte", 0x363F8F7Eu, "type", 0xE73D75F8, 8ui64, 1ui64, 0i64, 0, 0);
    Load_ProcessStructLayout_byte();
  }
}

/*
==============
Load_ProcessStructLayout_StreamingContentSet
==============
*/
void Load_ProcessStructLayout_StreamingContentSet(void)
{
  if ( Load_RegisterStructSize("StreamingContentSet", 0xFB017C39, 0x10ui64, 8ui64) )
  {
    Load_RegisterStructMemberSize("StreamingContentSet", 0xFB017C39, "ushort", 0xB7BE387D, "contentCounts", 0x38A6DD47u, 0i64, 8ui64, 0i64, 1, 0);
    Load_ProcessStructLayout_ushort();
    Load_RegisterStructMemberSize("StreamingContentSet", 0xFB017C39, "StreamingItemContents", 0xD0C23BD3, "contents", 0x2DCB6256u, 8ui64, 8ui64, 0i64, 1, 0);
    if ( Load_RegisterStructSize("StreamingItemContents", 0xD0C23BD3, 8ui64, 8ui64) )
    {
      Load_RegisterStructMemberSize("StreamingItemContents", 0xD0C23BD3, "ushort", 0xB7BE387D, "contents", 0x2DCB6256u, 0i64, 8ui64, 0i64, 1, 0);
      Load_ProcessStructLayout_ushort();
    }
  }
}

/*
==============
Load_ProcessStructLayout_StreamingInfo
==============
*/
void Load_ProcessStructLayout_StreamingInfo(void)
{
  if ( Load_RegisterStructSize("StreamingInfo", 0x8DB9B39C, 0xB8ui64, 8ui64) )
  {
    Load_RegisterStructMemberSize("StreamingInfo", 0x8DB9B39C, "XString", 0x6231894Bu, (const char *)&stru_143C9A1A4, 0x58737A51u, 0i64, 8ui64, 0i64, 0, 0);
    Load_ProcessStructLayout_XString();
    Load_RegisterStructMemberSize("StreamingInfo", 0x8DB9B39C, "AlwaysloadedFlagSet", 0x5F07F6EEu, "alwaysloadedFlagSets", 0x99126379, 8ui64, 0xA8ui64, 3ui64, 0, 0);
    Load_ProcessStructLayout_AlwaysloadedFlagSet();
    Load_RegisterStructMemberSize("StreamingInfo", 0x8DB9B39C, "TransientInfo", 0x46ECDB0Au, "transientInfo", 0x36025A6Au, 0xB0ui64, 8ui64, 0i64, 1, 0);
    Load_ProcessStructLayout_TransientInfo();
  }
}

/*
==============
Load_ProcessStructLayout_StreamingInfoPtr
==============
*/
void Load_ProcessStructLayout_StreamingInfoPtr(void)
{
  if ( Load_RegisterStructSize("StreamingInfoPtr", 0x109D501Au, 8ui64, 8ui64) )
  {
    Load_RegisterStructMemberSize("StreamingInfoPtr", 0x109D501Au, "StreamingInfo", 0x8DB9B39C, (const char *)&queryFormat.fmt + 3, 0, 0i64, 8ui64, 0i64, 1, 0);
    if ( Load_RegisterStructSize("StreamingInfo", 0x8DB9B39C, 0xB8ui64, 8ui64) )
    {
      Load_RegisterStructMemberSize("StreamingInfo", 0x8DB9B39C, "XString", 0x6231894Bu, (const char *)&stru_143C9A1A4, 0x58737A51u, 0i64, 8ui64, 0i64, 0, 0);
      Load_ProcessStructLayout_XString();
      Load_RegisterStructMemberSize("StreamingInfo", 0x8DB9B39C, "AlwaysloadedFlagSet", 0x5F07F6EEu, "alwaysloadedFlagSets", 0x99126379, 8ui64, 0xA8ui64, 3ui64, 0, 0);
      Load_ProcessStructLayout_AlwaysloadedFlagSet();
      Load_RegisterStructMemberSize("StreamingInfo", 0x8DB9B39C, "TransientInfo", 0x46ECDB0Au, "transientInfo", 0x36025A6Au, 0xB0ui64, 8ui64, 0i64, 1, 0);
      Load_ProcessStructLayout_TransientInfo();
    }
  }
}

/*
==============
Load_ProcessStructLayout_StreamingItemContents
==============
*/
void Load_ProcessStructLayout_StreamingItemContents(void)
{
  if ( Load_RegisterStructSize("StreamingItemContents", 0xD0C23BD3, 8ui64, 8ui64) )
  {
    Load_RegisterStructMemberSize("StreamingItemContents", 0xD0C23BD3, "ushort", 0xB7BE387D, "contents", 0x2DCB6256u, 0i64, 8ui64, 0i64, 1, 0);
    Load_ProcessStructLayout_ushort();
  }
}

/*
==============
Load_ProcessStructLayout_StreamingItemCost
==============
*/
void Load_ProcessStructLayout_StreamingItemCost(void)
{
  if ( Load_RegisterStructSize("StreamingItemCost", 0xEBC95C9A, 4ui64, 4ui64) )
  {
    Load_RegisterStructMemberSize("StreamingItemCost", 0xEBC95C9A, "uint", 0x53A932A0u, "costInBytes", 0x2CA9A637u, 0i64, 4ui64, 0i64, 0, 0);
    Load_ProcessStructLayout_uint();
  }
}

/*
==============
Load_ProcessStructLayout_TransientAssetReference
==============
*/
void Load_ProcessStructLayout_TransientAssetReference(void)
{
  if ( Load_RegisterStructSize("TransientAssetReference", 0xA35E7CF5, 0x10ui64, 8ui64) )
  {
    Load_RegisterStructMemberSize("TransientAssetReference", 0xA35E7CF5, "XString", 0x6231894Bu, (const char *)&stru_143C9A1A4, 0x58737A51u, 0i64, 8ui64, 0i64, 0, 0);
    Load_ProcessStructLayout_XString();
    Load_RegisterStructMemberSize("TransientAssetReference", 0xA35E7CF5, "byte", 0x363F8F7Eu, "type", 0xE73D75F8, 8ui64, 1ui64, 0i64, 0, 0);
    Load_ProcessStructLayout_byte();
    Load_RegisterStructMemberSize("TransientAssetReference", 0xA35E7CF5, "uint", 0x53A932A0u, "mpParentIndex", 0xED282D31, 0xCui64, 4ui64, 0i64, 0, 0);
    Load_ProcessStructLayout_uint();
  }
}

/*
==============
Load_ProcessStructLayout_TransientCosts
==============
*/
void Load_ProcessStructLayout_TransientCosts(void)
{
  if ( Load_RegisterStructSize("TransientCosts", 0xF43663EC, 0x50ui64, 8ui64) )
  {
    Load_RegisterStructMemberSize("TransientCosts", 0xF43663EC, "uint", 0x53A932A0u, "streamingItemCount", 0x6E9A759Au, 0x48ui64, 4ui64, 0i64, 0, 0);
    Load_ProcessStructLayout_uint();
    Load_RegisterStructMemberSize("TransientCosts", 0xF43663EC, "uint", 0x53A932A0u, "transientCostCount", 0xC5107FC2, 0x4Cui64, 4ui64, 0i64, 0, 0);
    Load_ProcessStructLayout_uint();
    Load_RegisterStructMemberSize("TransientCosts", 0xF43663EC, "StreamingItemCost", 0xEBC95C9A, "streamingCosts", 0x9DB536BE, 0x30ui64, 8ui64, 0i64, 1, 0);
    if ( Load_RegisterStructSize("StreamingItemCost", 0xEBC95C9A, 4ui64, 4ui64) )
    {
      Load_RegisterStructMemberSize("StreamingItemCost", 0xEBC95C9A, "uint", 0x53A932A0u, "costInBytes", 0x2CA9A637u, 0i64, 4ui64, 0i64, 0, 0);
      Load_ProcessStructLayout_uint();
    }
    Load_RegisterStructMemberSize("TransientCosts", 0xF43663EC, "StreamingContentSet", 0xFB017C39, "streamContents", 0xA7F8BCD6, 0i64, 0x30ui64, 3ui64, 0, 0);
    if ( Load_RegisterStructSize("StreamingContentSet", 0xFB017C39, 0x10ui64, 8ui64) )
    {
      Load_RegisterStructMemberSize("StreamingContentSet", 0xFB017C39, "ushort", 0xB7BE387D, "contentCounts", 0x38A6DD47u, 0i64, 8ui64, 0i64, 1, 0);
      Load_ProcessStructLayout_ushort();
      Load_RegisterStructMemberSize("StreamingContentSet", 0xFB017C39, "StreamingItemContents", 0xD0C23BD3, "contents", 0x2DCB6256u, 8ui64, 8ui64, 0i64, 1, 0);
      if ( Load_RegisterStructSize("StreamingItemContents", 0xD0C23BD3, 8ui64, 8ui64) )
      {
        Load_RegisterStructMemberSize("StreamingItemContents", 0xD0C23BD3, "ushort", 0xB7BE387D, "contents", 0x2DCB6256u, 0i64, 8ui64, 0i64, 1, 0);
        Load_ProcessStructLayout_ushort();
      }
    }
    Load_RegisterStructMemberSize("TransientCosts", 0xF43663EC, "ushort", 0xB7BE387D, "residentPageSizes", 0xB2B45049, 0x38ui64, 8ui64, 0i64, 1, 0);
    Load_ProcessStructLayout_ushort();
    Load_RegisterStructMemberSize("TransientCosts", 0xF43663EC, "ushort", 0xB7BE387D, "tempPageSizes", 0x52AA5767u, 0x40ui64, 8ui64, 0i64, 1, 0);
    Load_ProcessStructLayout_ushort();
  }
}

/*
==============
Load_ProcessStructLayout_TransientFileReference
==============
*/
void Load_ProcessStructLayout_TransientFileReference(void)
{
  if ( Load_RegisterStructSize("TransientFileReference", 0x9E695B17, 0x10ui64, 8ui64) )
  {
    Load_RegisterStructMemberSize("TransientFileReference", 0x9E695B17, "XString", 0x6231894Bu, (const char *)&stru_143C9A1A4, 0x58737A51u, 0i64, 8ui64, 0i64, 0, 0);
    Load_ProcessStructLayout_XString();
    Load_RegisterStructMemberSize("TransientFileReference", 0x9E695B17, "byte", 0x363F8F7Eu, "type", 0xE73D75F8, 8ui64, 1ui64, 0i64, 0, 0);
    Load_ProcessStructLayout_byte();
  }
}

/*
==============
Load_ProcessStructLayout_TransientInfo
==============
*/
void Load_ProcessStructLayout_TransientInfo(void)
{
  if ( Load_RegisterStructSize("TransientInfo", 0x46ECDB0Au, 0xD8ui64, 8ui64) )
  {
    Load_RegisterStructMemberSize("TransientInfo", 0x46ECDB0Au, "TransientSets", 0x14913AF5u, "transientSets", 0x6212255u, 0i64, 0x18ui64, 0i64, 0, 0);
    if ( Load_RegisterStructSize("TransientSets", 0x14913AF5u, 0x18ui64, 8ui64) )
    {
      Load_RegisterStructMemberSize("TransientSets", 0x14913AF5u, "uint", 0x53A932A0u, "count", 0xACB3A915, 0i64, 4ui64, 0i64, 0, 0);
      Load_ProcessStructLayout_uint();
      Load_RegisterStructMemberSize("TransientSets", 0x14913AF5u, "XString", 0x6231894Bu, "names", 0x8EC98DF0, 8ui64, 8ui64, 0i64, 1, 0);
      Load_ProcessStructLayout_XString();
      Load_RegisterStructMemberSize("TransientSets", 0x14913AF5u, "transientSPWorldBitArray_t", 0x533D5F9Cu, "masks", 0x19497C2Bu, 0x10ui64, 8ui64, 0i64, 1, 0);
      if ( Load_RegisterStructSize("transientSPWorldBitArray_t", 0x533D5F9Cu, 4ui64, 4ui64) )
      {
        Load_RegisterStructMemberSize("transientSPWorldBitArray_t", 0x533D5F9Cu, "uint", 0x53A932A0u, "array", 0x3E5322Fu, 0i64, 4ui64, 1ui64, 0, 0);
        Load_ProcessStructLayout_uint();
      }
    }
    Load_RegisterStructMemberSize("TransientInfo", 0x46ECDB0Au, "TransientCosts", 0xF43663EC, "transientCosts", 0xB30C54CC, 0x18ui64, 0x50ui64, 0i64, 0, 0);
    Load_ProcessStructLayout_TransientCosts();
    Load_RegisterStructMemberSize("TransientInfo", 0x46ECDB0Au, "uint", 0x53A932A0u, "forcedStubAssetCount", 0xD10B898E, 0xC0ui64, 4ui64, 0i64, 0, 0);
    Load_ProcessStructLayout_uint();
    Load_RegisterStructMemberSize("TransientInfo", 0x46ECDB0Au, "ForcedStubAssetReference", 0x4A35FE20u, "forcedStubAssets", 0xFAAE81A8, 0x68ui64, 8ui64, 0i64, 1, 0);
    if ( Load_RegisterStructSize("ForcedStubAssetReference", 0x4A35FE20u, 0x10ui64, 8ui64) )
    {
      Load_RegisterStructMemberSize("ForcedStubAssetReference", 0x4A35FE20u, "XString", 0x6231894Bu, (const char *)&stru_143C9A1A4, 0x58737A51u, 0i64, 8ui64, 0i64, 0, 0);
      Load_ProcessStructLayout_XString();
      Load_RegisterStructMemberSize("ForcedStubAssetReference", 0x4A35FE20u, "byte", 0x363F8F7Eu, "type", 0xE73D75F8, 8ui64, 1ui64, 0i64, 0, 0);
      Load_ProcessStructLayout_byte();
    }
    Load_RegisterStructMemberSize("TransientInfo", 0x46ECDB0Au, "uint", 0x53A932A0u, "transientFileCount", 0xCFF2EB6D, 0xC4ui64, 4ui64, 0i64, 0, 0);
    Load_ProcessStructLayout_uint();
    Load_RegisterStructMemberSize("TransientInfo", 0x46ECDB0Au, "TransientFileReference", 0x9E695B17, "transientFiles", 0x706615EBu, 0x70ui64, 8ui64, 0i64, 1, 0);
    if ( Load_RegisterStructSize("TransientFileReference", 0x9E695B17, 0x10ui64, 8ui64) )
    {
      Load_RegisterStructMemberSize("TransientFileReference", 0x9E695B17, "XString", 0x6231894Bu, (const char *)&stru_143C9A1A4, 0x58737A51u, 0i64, 8ui64, 0i64, 0, 0);
      Load_ProcessStructLayout_XString();
      Load_RegisterStructMemberSize("TransientFileReference", 0x9E695B17, "byte", 0x363F8F7Eu, "type", 0xE73D75F8, 8ui64, 1ui64, 0i64, 0, 0);
      Load_ProcessStructLayout_byte();
    }
    Load_RegisterStructMemberSize("TransientInfo", 0x46ECDB0Au, "uint", 0x53A932A0u, "transientAssetCount", 0xF8A0200B, 0xC8ui64, 4ui64, 0i64, 0, 0);
    Load_ProcessStructLayout_uint();
    Load_RegisterStructMemberSize("TransientInfo", 0x46ECDB0Au, "TransientAssetReference", 0xA35E7CF5, "transientAssets", 0xC5B245A9, 0x78ui64, 8ui64, 0i64, 1, 0);
    if ( Load_RegisterStructSize("TransientAssetReference", 0xA35E7CF5, 0x10ui64, 8ui64) )
    {
      Load_RegisterStructMemberSize("TransientAssetReference", 0xA35E7CF5, "XString", 0x6231894Bu, (const char *)&stru_143C9A1A4, 0x58737A51u, 0i64, 8ui64, 0i64, 0, 0);
      Load_ProcessStructLayout_XString();
      Load_RegisterStructMemberSize("TransientAssetReference", 0xA35E7CF5, "byte", 0x363F8F7Eu, "type", 0xE73D75F8, 8ui64, 1ui64, 0i64, 0, 0);
      Load_ProcessStructLayout_byte();
      Load_RegisterStructMemberSize("TransientAssetReference", 0xA35E7CF5, "uint", 0x53A932A0u, "mpParentIndex", 0xED282D31, 0xCui64, 4ui64, 0i64, 0, 0);
      Load_ProcessStructLayout_uint();
    }
    Load_RegisterStructMemberSize("TransientInfo", 0x46ECDB0Au, "uint", 0x53A932A0u, "transientWorldGridTileMapCount", 0x4317799Du, 0xCCui64, 4ui64, 0i64, 0, 0);
    Load_ProcessStructLayout_uint();
    Load_RegisterStructMemberSize("TransientInfo", 0x46ECDB0Au, "TransientWorldGridTileMap", 0x18418D38u, "transientWorldGridTileMaps", 0x86AAE7FB, 0x80ui64, 8ui64, 0i64, 1, 0);
    Load_ProcessStructLayout_TransientWorldGridTileMap();
    Load_RegisterStructMemberSize("TransientInfo", 0x46ECDB0Au, "uint", 0x53A932A0u, "transientCollisionTileCount", 0x5920F84Bu, 0xD0ui64, 4ui64, 0i64, 0, 0);
    Load_ProcessStructLayout_uint();
    Load_RegisterStructMemberSize("TransientInfo", 0x46ECDB0Au, "uint", 0x53A932A0u, "transientMPCommonCount", 0x84B762DB, 0xD4ui64, 4ui64, 0i64, 0, 0);
    Load_ProcessStructLayout_uint();
    Load_RegisterStructMemberSize("TransientInfo", 0x46ECDB0Au, "SpatialPartition_Tree", 0x9861EC4D, "transientWorldGridSpatial", 0xE2D911F6, 0x88ui64, 8ui64, 0i64, 1, 0);
    Load_ProcessStructLayout_SpatialPartition_Tree();
    Load_RegisterStructMemberSize("TransientInfo", 0x46ECDB0Au, "Bounds", 0x1605EBBBu, "transientWorldGridBounds", 0x791C7BB9u, 0x90ui64, 8ui64, 0i64, 1, 0);
    Load_ProcessStructLayout_Bounds();
    Load_RegisterStructMemberSize("TransientInfo", 0x46ECDB0Au, "ushort", 0xB7BE387D, "transientWorldGridHighLodLookup", 0x7B80E54Du, 0x98ui64, 8ui64, 0i64, 1, 0);
    Load_ProcessStructLayout_ushort();
    Load_RegisterStructMemberSize("TransientInfo", 0x46ECDB0Au, "uint", 0x53A932A0u, "transientWorldGridBoundsCount", 0x88DBB26E, 0xA0ui64, 4ui64, 0i64, 0, 0);
    Load_ProcessStructLayout_uint();
    Load_RegisterStructMemberSize("TransientInfo", 0x46ECDB0Au, "uint", 0x53A932A0u, "transientWorldGridHighLodCount", 0xB60F4E98, 0xA4ui64, 4ui64, 0i64, 0, 0);
    Load_ProcessStructLayout_uint();
    Load_RegisterStructMemberSize("TransientInfo", 0x46ECDB0Au, "uint", 0x53A932A0u, "transientWorldGridHighLodLookupCount", 0x2A11335Au, 0xA8ui64, 4ui64, 0i64, 0, 0);
    Load_ProcessStructLayout_uint();
    Load_RegisterStructMemberSize("TransientInfo", 0x46ECDB0Au, "TransientInfoFlags", 0x2D4BCF63u, "transientInfoFlags", 0xFCCBBE03, 0xACui64, 1ui64, 0i64, 0, 0);
    if ( Load_RegisterStructSize("TransientInfoFlags", 0x2D4BCF63u, 1ui64, 1ui64) )
    {
      Load_RegisterStructMemberSize("TransientInfoFlags", 0x2D4BCF63u, "byte", 0x363F8F7Eu, (const char *)&queryFormat.fmt + 3, 0, 0i64, 1ui64, 0i64, 0, 0);
      Load_ProcessStructLayout_byte();
    }
    Load_RegisterStructMemberSize("TransientInfo", 0x46ECDB0Au, "TransientInfo_Bitarray", 0x7D4F617Du, "transientSkipLoading", 0x81963C1D, 0xB0ui64, 0x10ui64, 0i64, 0, 0);
    if ( Load_RegisterStructSize("TransientInfo_Bitarray", 0x7D4F617Du, 0x10ui64, 8ui64) )
    {
      Load_RegisterStructMemberSize("TransientInfo_Bitarray", 0x7D4F617Du, "uint", 0x53A932A0u, "array", 0x3E5322Fu, 0i64, 8ui64, 0i64, 1, 0);
      Load_ProcessStructLayout_uint();
      Load_RegisterStructMemberSize("TransientInfo_Bitarray", 0x7D4F617Du, "uint", 0x53A932A0u, "wordCount", 0x261576E5u, 8ui64, 4ui64, 0i64, 0, 0);
      Load_ProcessStructLayout_uint();
      Load_RegisterStructMemberSize("TransientInfo_Bitarray", 0x7D4F617Du, "uint", 0x53A932A0u, "bitCount", 0x208144DEu, 0xCui64, 4ui64, 0i64, 0, 0);
      Load_ProcessStructLayout_uint();
    }
  }
}

/*
==============
Load_ProcessStructLayout_TransientInfoFlags
==============
*/
void Load_ProcessStructLayout_TransientInfoFlags(void)
{
  if ( Load_RegisterStructSize("TransientInfoFlags", 0x2D4BCF63u, 1ui64, 1ui64) )
  {
    Load_RegisterStructMemberSize("TransientInfoFlags", 0x2D4BCF63u, "byte", 0x363F8F7Eu, (const char *)&queryFormat.fmt + 3, 0, 0i64, 1ui64, 0i64, 0, 0);
    Load_ProcessStructLayout_byte();
  }
}

/*
==============
Load_ProcessStructLayout_TransientInfo_Bitarray
==============
*/
void Load_ProcessStructLayout_TransientInfo_Bitarray(void)
{
  if ( Load_RegisterStructSize("TransientInfo_Bitarray", 0x7D4F617Du, 0x10ui64, 8ui64) )
  {
    Load_RegisterStructMemberSize("TransientInfo_Bitarray", 0x7D4F617Du, "uint", 0x53A932A0u, "array", 0x3E5322Fu, 0i64, 8ui64, 0i64, 1, 0);
    Load_ProcessStructLayout_uint();
    Load_RegisterStructMemberSize("TransientInfo_Bitarray", 0x7D4F617Du, "uint", 0x53A932A0u, "wordCount", 0x261576E5u, 8ui64, 4ui64, 0i64, 0, 0);
    Load_ProcessStructLayout_uint();
    Load_RegisterStructMemberSize("TransientInfo_Bitarray", 0x7D4F617Du, "uint", 0x53A932A0u, "bitCount", 0x208144DEu, 0xCui64, 4ui64, 0i64, 0, 0);
    Load_ProcessStructLayout_uint();
  }
}

/*
==============
Load_ProcessStructLayout_TransientSets
==============
*/
void Load_ProcessStructLayout_TransientSets(void)
{
  if ( Load_RegisterStructSize("TransientSets", 0x14913AF5u, 0x18ui64, 8ui64) )
  {
    Load_RegisterStructMemberSize("TransientSets", 0x14913AF5u, "uint", 0x53A932A0u, "count", 0xACB3A915, 0i64, 4ui64, 0i64, 0, 0);
    Load_ProcessStructLayout_uint();
    Load_RegisterStructMemberSize("TransientSets", 0x14913AF5u, "XString", 0x6231894Bu, "names", 0x8EC98DF0, 8ui64, 8ui64, 0i64, 1, 0);
    Load_ProcessStructLayout_XString();
    Load_RegisterStructMemberSize("TransientSets", 0x14913AF5u, "transientSPWorldBitArray_t", 0x533D5F9Cu, "masks", 0x19497C2Bu, 0x10ui64, 8ui64, 0i64, 1, 0);
    if ( Load_RegisterStructSize("transientSPWorldBitArray_t", 0x533D5F9Cu, 4ui64, 4ui64) )
    {
      Load_RegisterStructMemberSize("transientSPWorldBitArray_t", 0x533D5F9Cu, "uint", 0x53A932A0u, "array", 0x3E5322Fu, 0i64, 4ui64, 1ui64, 0, 0);
      Load_ProcessStructLayout_uint();
    }
  }
}

/*
==============
Load_ProcessStructLayout_TransientWorldGridTileMap
==============
*/
void Load_ProcessStructLayout_TransientWorldGridTileMap(void)
{
  if ( Load_RegisterStructSize("TransientWorldGridTileMap", 0x18418D38u, 0x28ui64, 8ui64) )
  {
    Load_RegisterStructMemberSize("TransientWorldGridTileMap", 0x18418D38u, "ushort", 0xB7BE387D, "spaceToTransientIndex", 0xF5347CFu, 0i64, 8ui64, 0i64, 1, 0);
    Load_ProcessStructLayout_ushort();
    Load_RegisterStructMemberSize("TransientWorldGridTileMap", 0x18418D38u, "uint", 0x53A932A0u, "indexCount", 0x75B69431u, 8ui64, 4ui64, 0i64, 0, 0);
    Load_ProcessStructLayout_uint();
    Load_RegisterStructMemberSize("TransientWorldGridTileMap", 0x18418D38u, "uint", 0x53A932A0u, "level", 0xB3A6E862, 0xCui64, 4ui64, 0i64, 0, 0);
    Load_ProcessStructLayout_uint();
    Load_RegisterStructMemberSize("TransientWorldGridTileMap", 0x18418D38u, "uint", 0x53A932A0u, "lodCount", 0xCEF995D2, 0x10ui64, 4ui64, 0i64, 0, 0);
    Load_ProcessStructLayout_uint();
    Load_RegisterStructMemberSize("TransientWorldGridTileMap", 0x18418D38u, "uint", 0x53A932A0u, "gridCountX", 0xB618AE87, 0x14ui64, 4ui64, 0i64, 0, 0);
    Load_ProcessStructLayout_uint();
    Load_RegisterStructMemberSize("TransientWorldGridTileMap", 0x18418D38u, "uint", 0x53A932A0u, "gridCountY", 0xB618AE86, 0x18ui64, 4ui64, 0i64, 0, 0);
    Load_ProcessStructLayout_uint();
    Load_RegisterStructMemberSize("TransientWorldGridTileMap", 0x18418D38u, "float", 0x9B987AFE, "cellSize", 0xB4B6FF67, 0x1Cui64, 4ui64, 0i64, 0, 0);
    Load_ProcessStructLayout_float();
    Load_RegisterStructMemberSize("TransientWorldGridTileMap", 0x18418D38u, "float", 0x9B987AFE, "minX", 0xED395B04, 0x20ui64, 4ui64, 0i64, 0, 0);
    Load_ProcessStructLayout_float();
    Load_RegisterStructMemberSize("TransientWorldGridTileMap", 0x18418D38u, "float", 0x9B987AFE, "minY", 0xED395B05, 0x24ui64, 4ui64, 0i64, 0, 0);
    Load_ProcessStructLayout_float();
  }
}

/*
==============
Load_ProcessStructLayout_transientSPWorldBitArray_t
==============
*/
void Load_ProcessStructLayout_transientSPWorldBitArray_t(void)
{
  if ( Load_RegisterStructSize("transientSPWorldBitArray_t", 0x533D5F9Cu, 4ui64, 4ui64) )
  {
    Load_RegisterStructMemberSize("transientSPWorldBitArray_t", 0x533D5F9Cu, "uint", 0x53A932A0u, "array", 0x3E5322Fu, 0i64, 4ui64, 1ui64, 0, 0);
    Load_ProcessStructLayout_uint();
  }
}

/*
==============
Load_StreamingContentSet
==============
*/
void Load_StreamingContentSet(const DBStreamStart streamStart)
{
  StreamingContentSet *v1; 
  unsigned __int16 *v2; 
  unsigned __int16 *ushort; 
  StreamingItemContents *v4; 
  __int64 transientCostCount; 
  StreamingItemContents *i; 
  StreamingItemContents *v7; 
  unsigned __int16 *v8; 
  unsigned __int16 *v9; 
  unsigned int CostItemIndex; 

  Load_Stream(streamStart, varStreamingContentSet, 0x10ui64);
  v1 = varStreamingContentSet;
  if ( varStreamingContentSet->contentCounts )
  {
    v2 = varushort;
    ushort = AllocLoad_ushort();
    v1->contentCounts = ushort;
    varushort = ushort;
    Load_ushortArray(AtStart, varTransientCosts->transientCostCount);
    v1 = varStreamingContentSet;
    varushort = v2;
  }
  if ( v1->contents )
  {
    v4 = varStreamingItemContents;
    DB_PatchMem_FixStreamAlignment(7ui64);
    DB_CheckCanIncStreamPos(0i64);
    v1->contents = (StreamingItemContents *)g_streamPosGlob.pos;
    varStreamingItemContents = (StreamingItemContents *)g_streamPosGlob.pos;
    transientCostCount = varTransientCosts->transientCostCount;
    Load_Stream(AtStart, g_streamPosGlob.pos, 8 * transientCostCount);
    for ( i = varStreamingItemContents; transientCostCount; --transientCostCount )
    {
      varStreamingItemContents = i;
      Load_Stream(NotAtStart, i, 8ui64);
      v7 = varStreamingItemContents;
      if ( varStreamingItemContents->contents )
      {
        v8 = varushort;
        v9 = AllocLoad_ushort();
        v7->contents = v9;
        varushort = v9;
        CostItemIndex = DB_StreamingInfo_GetCostItemIndex(varTransientCosts, varStreamingContentSet, varStreamingItemContents);
        Load_ushortArray(AtStart, CostItemIndex);
        varushort = v8;
      }
      ++i;
    }
    varStreamingItemContents = v4;
  }
}

/*
==============
Load_StreamingContentSetArray
==============
*/
void Load_StreamingContentSetArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  StreamingContentSet *i; 
  StreamingContentSet *v4; 
  unsigned __int16 *v5; 
  unsigned __int16 *ushort; 
  StreamingItemContents *v7; 
  __int64 transientCostCount; 
  StreamingItemContents *j; 
  StreamingItemContents *v10; 
  unsigned __int16 *v11; 
  unsigned __int16 *v12; 
  unsigned int CostItemIndex; 

  v2 = count;
  Load_Stream(streamStart, varStreamingContentSet, 16 * count);
  for ( i = varStreamingContentSet; v2; --v2 )
  {
    varStreamingContentSet = i;
    Load_Stream(NotAtStart, i, 0x10ui64);
    v4 = varStreamingContentSet;
    if ( varStreamingContentSet->contentCounts )
    {
      v5 = varushort;
      ushort = AllocLoad_ushort();
      v4->contentCounts = ushort;
      varushort = ushort;
      Load_ushortArray(AtStart, varTransientCosts->transientCostCount);
      v4 = varStreamingContentSet;
      varushort = v5;
    }
    if ( v4->contents )
    {
      v7 = varStreamingItemContents;
      DB_PatchMem_FixStreamAlignment(7ui64);
      DB_CheckCanIncStreamPos(0i64);
      v4->contents = (StreamingItemContents *)g_streamPosGlob.pos;
      varStreamingItemContents = (StreamingItemContents *)g_streamPosGlob.pos;
      transientCostCount = varTransientCosts->transientCostCount;
      Load_Stream(AtStart, g_streamPosGlob.pos, 8 * transientCostCount);
      for ( j = varStreamingItemContents; transientCostCount; --transientCostCount )
      {
        varStreamingItemContents = j;
        Load_Stream(NotAtStart, j, 8ui64);
        v10 = varStreamingItemContents;
        if ( varStreamingItemContents->contents )
        {
          v11 = varushort;
          v12 = AllocLoad_ushort();
          v10->contents = v12;
          varushort = v12;
          CostItemIndex = DB_StreamingInfo_GetCostItemIndex(varTransientCosts, varStreamingContentSet, varStreamingItemContents);
          Load_ushortArray(AtStart, CostItemIndex);
          varushort = v11;
        }
        ++j;
      }
      varStreamingItemContents = v7;
    }
    ++i;
  }
}

/*
==============
Load_StreamingContentSetStream
==============
*/
void Load_StreamingContentSetStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *pos; 
  StreamingContentSet *v4; 
  unsigned __int16 *v5; 
  unsigned __int16 *ushort; 
  StreamingItemContents *v7; 
  __int64 transientCostCount; 
  StreamingItemContents *i; 
  StreamingItemContents *v10; 
  unsigned __int16 *v11; 
  unsigned __int16 *v12; 
  unsigned int CostItemIndex; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 2874, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    pos = (unsigned __int8 *)varStreamingContentSet;
    do
    {
      Load_Stream(AtStart, pos, 0x10ui64);
      v4 = varStreamingContentSet;
      if ( varStreamingContentSet->contentCounts )
      {
        v5 = varushort;
        ushort = AllocLoad_ushort();
        v4->contentCounts = ushort;
        varushort = ushort;
        Load_ushortArray(AtStart, varTransientCosts->transientCostCount);
        v4 = varStreamingContentSet;
        varushort = v5;
      }
      if ( v4->contents )
      {
        v7 = varStreamingItemContents;
        DB_PatchMem_FixStreamAlignment(7ui64);
        DB_CheckCanIncStreamPos(0i64);
        v4->contents = (StreamingItemContents *)g_streamPosGlob.pos;
        varStreamingItemContents = (StreamingItemContents *)g_streamPosGlob.pos;
        transientCostCount = varTransientCosts->transientCostCount;
        Load_Stream(AtStart, g_streamPosGlob.pos, 8 * transientCostCount);
        for ( i = varStreamingItemContents; transientCostCount; --transientCostCount )
        {
          varStreamingItemContents = i;
          Load_Stream(NotAtStart, i, 8ui64);
          v10 = varStreamingItemContents;
          if ( varStreamingItemContents->contents )
          {
            v11 = varushort;
            v12 = AllocLoad_ushort();
            v10->contents = v12;
            varushort = v12;
            CostItemIndex = DB_StreamingInfo_GetCostItemIndex(varTransientCosts, varStreamingContentSet, varStreamingItemContents);
            Load_ushortArray(AtStart, CostItemIndex);
            varushort = v11;
          }
          ++i;
        }
        varStreamingItemContents = v7;
      }
      pos = g_streamPosGlob.pos;
      varStreamingContentSet = (StreamingContentSet *)g_streamPosGlob.pos;
      --count;
    }
    while ( count );
  }
}

/*
==============
Load_StreamingInfo
==============
*/
void Load_StreamingInfo(const DBStreamStart streamStart)
{
  const char **v2; 
  AlwaysloadedFlagSet *v3; 
  AlwaysloadedFlagSet *v4; 
  __int64 v5; 
  StreamingInfo *v6; 
  TransientInfo *v7; 

  DB_PatchMem_PushAsset(63, varStreamingInfo);
  Load_Stream(streamStart, varStreamingInfo, 0xB8ui64);
  DB_PushStreamPos(8u);
  v2 = varXString;
  varXString = &varStreamingInfo->name;
  Load_XString(NotAtStart);
  v3 = varAlwaysloadedFlagSet;
  varAlwaysloadedFlagSet = varStreamingInfo->alwaysloadedFlagSets;
  varXString = v2;
  Load_Stream(NotAtStart, varStreamingInfo->alwaysloadedFlagSets, 0xA8ui64);
  v4 = varAlwaysloadedFlagSet;
  v5 = 3i64;
  do
  {
    varAlwaysloadedFlagSet = v4;
    Load_AlwaysloadedFlagSet(NotAtStart);
    ++v4;
    --v5;
  }
  while ( v5 );
  v6 = varStreamingInfo;
  varAlwaysloadedFlagSet = v3;
  if ( varStreamingInfo->transientInfo )
  {
    v7 = varTransientInfo;
    DB_PatchMem_FixStreamAlignment(7ui64);
    DB_CheckCanIncStreamPos(0i64);
    v6->transientInfo = (TransientInfo *)g_streamPosGlob.pos;
    varTransientInfo = (TransientInfo *)g_streamPosGlob.pos;
    Load_TransientInfo(AtStart);
    varTransientInfo = v7;
  }
  DB_PopStreamPos();
  DB_PatchMem_PopAsset();
}

/*
==============
Load_StreamingInfoArray
==============
*/
void Load_StreamingInfoArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  StreamingInfo *i; 
  const char **v4; 
  AlwaysloadedFlagSet *v5; 
  AlwaysloadedFlagSet *v6; 
  __int64 v7; 
  StreamingInfo *v8; 
  TransientInfo *v9; 

  v2 = count;
  Load_Stream(streamStart, varStreamingInfo, 184 * count);
  for ( i = varStreamingInfo; v2; --v2 )
  {
    varStreamingInfo = i;
    DB_PatchMem_PushAsset(63, i);
    Load_Stream(NotAtStart, varStreamingInfo, 0xB8ui64);
    DB_PushStreamPos(8u);
    v4 = varXString;
    varXString = &varStreamingInfo->name;
    Load_XString(NotAtStart);
    v5 = varAlwaysloadedFlagSet;
    varAlwaysloadedFlagSet = varStreamingInfo->alwaysloadedFlagSets;
    varXString = v4;
    Load_Stream(NotAtStart, varStreamingInfo->alwaysloadedFlagSets, 0xA8ui64);
    v6 = varAlwaysloadedFlagSet;
    v7 = 3i64;
    do
    {
      varAlwaysloadedFlagSet = v6;
      Load_AlwaysloadedFlagSet(NotAtStart);
      ++v6;
      --v7;
    }
    while ( v7 );
    v8 = varStreamingInfo;
    varAlwaysloadedFlagSet = v5;
    if ( varStreamingInfo->transientInfo )
    {
      v9 = varTransientInfo;
      DB_PatchMem_FixStreamAlignment(7ui64);
      DB_CheckCanIncStreamPos(0i64);
      v8->transientInfo = (TransientInfo *)g_streamPosGlob.pos;
      varTransientInfo = (TransientInfo *)g_streamPosGlob.pos;
      Load_TransientInfo(AtStart);
      varTransientInfo = v9;
    }
    DB_PopStreamPos();
    DB_PatchMem_PopAsset();
    ++i;
  }
}

/*
==============
Load_StreamingInfoPtr
==============
*/
void Load_StreamingInfoPtr(const DBStreamStart streamStart)
{
  StreamingInfo **v1; 
  __int64 v2; 
  StreamingInfo *v3; 
  unsigned __int8 *inserted; 

  Load_Stream(streamStart, varStreamingInfoPtr, 8ui64);
  DB_PushStreamPos(1u);
  v1 = varStreamingInfoPtr;
  v2 = (__int64)*varStreamingInfoPtr;
  if ( *varStreamingInfoPtr )
  {
    if ( v2 == -1 )
    {
      DB_PushSharedData();
    }
    else if ( v2 != -2 && v2 != -3 )
    {
      DB_ConvertOffsetToAlias((unsigned __int64 *)varStreamingInfoPtr);
      goto LABEL_6;
    }
    v3 = varStreamingInfo;
    DB_PatchMem_FixStreamAlignment(7ui64);
    DB_CheckCanIncStreamPos(0i64);
    inserted = NULL;
    *v1 = (StreamingInfo *)g_streamPosGlob.pos;
    varStreamingInfo = (StreamingInfo *)g_streamPosGlob.pos;
    if ( v2 == -3 )
      inserted = DB_InsertPointer();
    Load_StreamingInfo(AtStart);
    Load_StreamingInfoAsset(v1);
    varStreamingInfo = v3;
    if ( inserted )
      *(_QWORD *)inserted = *v1;
    if ( v2 == -1 )
      DB_PopSharedData();
  }
LABEL_6:
  DB_PopStreamPos();
}

/*
==============
Load_StreamingInfoPtrArray
==============
*/
void Load_StreamingInfoPtrArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  StreamingInfo **i; 
  StreamingInfo **v4; 
  __int64 v5; 
  StreamingInfo *v6; 
  unsigned __int8 *inserted; 

  v2 = count;
  Load_Stream(streamStart, varStreamingInfoPtr, 8 * count);
  for ( i = varStreamingInfoPtr; v2; --v2 )
  {
    varStreamingInfoPtr = i;
    Load_Stream(NotAtStart, i, 8ui64);
    DB_PushStreamPos(1u);
    v4 = varStreamingInfoPtr;
    v5 = (__int64)*varStreamingInfoPtr;
    if ( *varStreamingInfoPtr )
    {
      if ( v5 == -1 )
      {
        DB_PushSharedData();
LABEL_8:
        v6 = varStreamingInfo;
        DB_PatchMem_FixStreamAlignment(7ui64);
        DB_CheckCanIncStreamPos(0i64);
        inserted = NULL;
        *v4 = (StreamingInfo *)g_streamPosGlob.pos;
        varStreamingInfo = (StreamingInfo *)g_streamPosGlob.pos;
        if ( v5 == -3 )
          inserted = DB_InsertPointer();
        Load_StreamingInfo(AtStart);
        Load_StreamingInfoAsset(v4);
        varStreamingInfo = v6;
        if ( inserted )
          *(_QWORD *)inserted = *v4;
        if ( v5 == -1 )
          DB_PopSharedData();
        goto LABEL_14;
      }
      if ( v5 == -2 || v5 == -3 )
        goto LABEL_8;
      DB_ConvertOffsetToAlias((unsigned __int64 *)varStreamingInfoPtr);
    }
LABEL_14:
    DB_PopStreamPos();
    ++i;
  }
}

/*
==============
Load_StreamingInfoPtrStream
==============
*/
void Load_StreamingInfoPtrStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *pos; 
  StreamingInfo **v4; 
  __int64 v5; 
  StreamingInfo *v6; 
  unsigned __int8 *inserted; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 4122, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    pos = (unsigned __int8 *)varStreamingInfoPtr;
    do
    {
      Load_Stream(AtStart, pos, 8ui64);
      DB_PushStreamPos(1u);
      v4 = varStreamingInfoPtr;
      v5 = (__int64)*varStreamingInfoPtr;
      if ( *varStreamingInfoPtr )
      {
        if ( v5 == -1 )
        {
          DB_PushSharedData();
LABEL_12:
          v6 = varStreamingInfo;
          DB_PatchMem_FixStreamAlignment(7ui64);
          DB_CheckCanIncStreamPos(0i64);
          inserted = NULL;
          *v4 = (StreamingInfo *)g_streamPosGlob.pos;
          varStreamingInfo = (StreamingInfo *)g_streamPosGlob.pos;
          if ( v5 == -3 )
            inserted = DB_InsertPointer();
          Load_StreamingInfo(AtStart);
          Load_StreamingInfoAsset(v4);
          varStreamingInfo = v6;
          if ( inserted )
            *(_QWORD *)inserted = *v4;
          if ( v5 == -1 )
            DB_PopSharedData();
          goto LABEL_18;
        }
        if ( v5 == -2 || v5 == -3 )
          goto LABEL_12;
        DB_ConvertOffsetToAlias((unsigned __int64 *)varStreamingInfoPtr);
      }
LABEL_18:
      DB_PopStreamPos();
      pos = g_streamPosGlob.pos;
      varStreamingInfoPtr = (StreamingInfo **)g_streamPosGlob.pos;
      --count;
    }
    while ( count );
  }
}

/*
==============
Load_StreamingInfoStream
==============
*/
void Load_StreamingInfoStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *pos; 
  const char **v4; 
  AlwaysloadedFlagSet *v5; 
  AlwaysloadedFlagSet *v6; 
  __int64 v7; 
  StreamingInfo *v8; 
  TransientInfo *v9; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 3998, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    pos = (unsigned __int8 *)varStreamingInfo;
    do
    {
      DB_PatchMem_PushAsset(63, pos);
      Load_Stream(AtStart, varStreamingInfo, 0xB8ui64);
      DB_PushStreamPos(8u);
      v4 = varXString;
      varXString = &varStreamingInfo->name;
      Load_XString(NotAtStart);
      v5 = varAlwaysloadedFlagSet;
      varAlwaysloadedFlagSet = varStreamingInfo->alwaysloadedFlagSets;
      varXString = v4;
      Load_Stream(NotAtStart, varStreamingInfo->alwaysloadedFlagSets, 0xA8ui64);
      v6 = varAlwaysloadedFlagSet;
      v7 = 3i64;
      do
      {
        varAlwaysloadedFlagSet = v6;
        Load_AlwaysloadedFlagSet(NotAtStart);
        ++v6;
        --v7;
      }
      while ( v7 );
      v8 = varStreamingInfo;
      varAlwaysloadedFlagSet = v5;
      if ( varStreamingInfo->transientInfo )
      {
        v9 = varTransientInfo;
        DB_PatchMem_FixStreamAlignment(7ui64);
        DB_CheckCanIncStreamPos(0i64);
        v8->transientInfo = (TransientInfo *)g_streamPosGlob.pos;
        varTransientInfo = (TransientInfo *)g_streamPosGlob.pos;
        Load_TransientInfo(AtStart);
        varTransientInfo = v9;
      }
      DB_PopStreamPos();
      DB_PatchMem_PopAsset();
      pos = g_streamPosGlob.pos;
      varStreamingInfo = (StreamingInfo *)g_streamPosGlob.pos;
      --count;
    }
    while ( count );
  }
}

/*
==============
Load_StreamingItemContents
==============
*/
void Load_StreamingItemContents(const DBStreamStart streamStart)
{
  StreamingItemContents *v1; 
  unsigned __int16 *v2; 
  unsigned __int16 *ushort; 
  unsigned int CostItemIndex; 

  Load_Stream(streamStart, varStreamingItemContents, 8ui64);
  v1 = varStreamingItemContents;
  if ( varStreamingItemContents->contents )
  {
    v2 = varushort;
    ushort = AllocLoad_ushort();
    v1->contents = ushort;
    varushort = ushort;
    CostItemIndex = DB_StreamingInfo_GetCostItemIndex(varTransientCosts, varStreamingContentSet, varStreamingItemContents);
    Load_ushortArray(AtStart, CostItemIndex);
    varushort = v2;
  }
}

/*
==============
Load_StreamingItemContentsArray
==============
*/
void Load_StreamingItemContentsArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  StreamingItemContents *i; 
  StreamingItemContents *v4; 
  unsigned __int16 *v5; 
  unsigned __int16 *ushort; 
  unsigned int CostItemIndex; 

  v2 = count;
  Load_Stream(streamStart, varStreamingItemContents, 8 * count);
  for ( i = varStreamingItemContents; v2; --v2 )
  {
    varStreamingItemContents = i;
    Load_Stream(NotAtStart, i, 8ui64);
    v4 = varStreamingItemContents;
    if ( varStreamingItemContents->contents )
    {
      v5 = varushort;
      ushort = AllocLoad_ushort();
      v4->contents = ushort;
      varushort = ushort;
      CostItemIndex = DB_StreamingInfo_GetCostItemIndex(varTransientCosts, varStreamingContentSet, varStreamingItemContents);
      Load_ushortArray(AtStart, CostItemIndex);
      varushort = v5;
    }
    ++i;
  }
}

/*
==============
Load_StreamingItemContentsStream
==============
*/
void Load_StreamingItemContentsStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *pos; 
  StreamingItemContents *v4; 
  unsigned __int16 *v5; 
  unsigned __int16 *ushort; 
  unsigned int CostItemIndex; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 2768, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    pos = (unsigned __int8 *)varStreamingItemContents;
    do
    {
      Load_Stream(AtStart, pos, 8ui64);
      v4 = varStreamingItemContents;
      if ( varStreamingItemContents->contents )
      {
        v5 = varushort;
        ushort = AllocLoad_ushort();
        v4->contents = ushort;
        varushort = ushort;
        CostItemIndex = DB_StreamingInfo_GetCostItemIndex(varTransientCosts, varStreamingContentSet, varStreamingItemContents);
        Load_ushortArray(AtStart, CostItemIndex);
        varushort = v5;
      }
      pos = g_streamPosGlob.pos;
      varStreamingItemContents = (StreamingItemContents *)g_streamPosGlob.pos;
      --count;
    }
    while ( count );
  }
}

/*
==============
Load_StreamingItemCost
==============
*/
void Load_StreamingItemCost(const DBStreamStart streamStart)
{
  Load_Stream(streamStart, varStreamingItemCost, 4ui64);
}

/*
==============
Load_StreamingItemCostArray
==============
*/
void Load_StreamingItemCostArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  Load_Stream(streamStart, varStreamingItemCost, 4 * count);
}

/*
==============
Load_StreamingItemCostStream
==============
*/
void Load_StreamingItemCostStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *pos; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 2688, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    pos = (unsigned __int8 *)varStreamingItemCost;
    do
    {
      Load_Stream(AtStart, pos, 4ui64);
      pos = g_streamPosGlob.pos;
      varStreamingItemCost = (StreamingItemCost *)g_streamPosGlob.pos;
      --count;
    }
    while ( count );
  }
}

/*
==============
Load_TransientAssetReference
==============
*/
void Load_TransientAssetReference(const DBStreamStart streamStart)
{
  const char **v1; 

  Load_Stream(streamStart, varTransientAssetReference, 0x10ui64);
  v1 = varXString;
  varXString = &varTransientAssetReference->name;
  Load_XString(NotAtStart);
  varXString = v1;
}

/*
==============
Load_TransientAssetReferenceArray
==============
*/
void Load_TransientAssetReferenceArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  TransientAssetReference *i; 
  const char **v4; 

  v2 = count;
  Load_Stream(streamStart, varTransientAssetReference, 16 * count);
  for ( i = varTransientAssetReference; v2; --v2 )
  {
    varTransientAssetReference = i;
    Load_Stream(NotAtStart, i, 0x10ui64);
    v4 = varXString;
    varXString = &varTransientAssetReference->name;
    Load_XString(NotAtStart);
    ++i;
    varXString = v4;
  }
}

/*
==============
Load_TransientAssetReferenceStream
==============
*/
void Load_TransientAssetReferenceStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *pos; 
  const char **v4; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 2118, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    pos = (unsigned __int8 *)varTransientAssetReference;
    do
    {
      Load_Stream(AtStart, pos, 0x10ui64);
      v4 = varXString;
      varXString = &varTransientAssetReference->name;
      Load_XString(NotAtStart);
      pos = g_streamPosGlob.pos;
      varTransientAssetReference = (TransientAssetReference *)g_streamPosGlob.pos;
      varXString = v4;
      --count;
    }
    while ( count );
  }
}

/*
==============
Load_TransientCosts
==============
*/
void Load_TransientCosts(const DBStreamStart streamStart)
{
  TransientCosts *v1; 
  __int64 v2; 
  StreamingItemCost *v3; 
  StreamingContentSet *v4; 
  StreamingContentSet *v5; 
  TransientCosts *v6; 
  unsigned __int16 *v7; 
  unsigned __int16 *ushort; 
  unsigned __int16 *v9; 

  Load_Stream(streamStart, varTransientCosts, 0x50ui64);
  v1 = varTransientCosts;
  v2 = 3i64;
  if ( varTransientCosts->streamingCosts )
  {
    v3 = varStreamingItemCost;
    DB_PatchMem_FixStreamAlignment(3ui64);
    DB_CheckCanIncStreamPos(0i64);
    v1->streamingCosts = (StreamingItemCost *)g_streamPosGlob.pos;
    varStreamingItemCost = (StreamingItemCost *)g_streamPosGlob.pos;
    Load_Stream(AtStart, g_streamPosGlob.pos, 4i64 * varTransientCosts->streamingItemCount);
    v1 = varTransientCosts;
    varStreamingItemCost = v3;
  }
  v4 = varStreamingContentSet;
  varStreamingContentSet = (StreamingContentSet *)v1;
  Load_Stream(NotAtStart, v1, 0x30ui64);
  v5 = varStreamingContentSet;
  do
  {
    varStreamingContentSet = v5;
    Load_StreamingContentSet(NotAtStart);
    ++v5;
    --v2;
  }
  while ( v2 );
  v6 = varTransientCosts;
  v7 = varushort;
  varStreamingContentSet = v4;
  if ( varTransientCosts->residentPageSizes )
  {
    ushort = AllocLoad_ushort();
    v6->residentPageSizes = ushort;
    varushort = ushort;
    Load_ushortArray(AtStart, varTransientCosts->transientCostCount);
    v6 = varTransientCosts;
    varushort = v7;
  }
  if ( v6->tempPageSizes )
  {
    v9 = AllocLoad_ushort();
    v6->tempPageSizes = v9;
    varushort = v9;
    Load_ushortArray(AtStart, varTransientCosts->transientCostCount);
    varushort = v7;
  }
}

/*
==============
Load_TransientCostsArray
==============
*/
void Load_TransientCostsArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  TransientCosts *i; 
  TransientCosts *v4; 
  StreamingItemCost *v5; 
  StreamingContentSet *v6; 
  StreamingContentSet *v7; 
  __int64 v8; 
  TransientCosts *v9; 
  unsigned __int16 *v10; 
  unsigned __int16 *ushort; 
  unsigned __int16 *v12; 

  v2 = count;
  Load_Stream(streamStart, varTransientCosts, 80 * count);
  for ( i = varTransientCosts; v2; --v2 )
  {
    varTransientCosts = i;
    Load_Stream(NotAtStart, i, 0x50ui64);
    v4 = varTransientCosts;
    if ( varTransientCosts->streamingCosts )
    {
      v5 = varStreamingItemCost;
      DB_PatchMem_FixStreamAlignment(3ui64);
      DB_CheckCanIncStreamPos(0i64);
      v4->streamingCosts = (StreamingItemCost *)g_streamPosGlob.pos;
      varStreamingItemCost = (StreamingItemCost *)g_streamPosGlob.pos;
      Load_Stream(AtStart, g_streamPosGlob.pos, 4i64 * varTransientCosts->streamingItemCount);
      v4 = varTransientCosts;
      varStreamingItemCost = v5;
    }
    v6 = varStreamingContentSet;
    varStreamingContentSet = (StreamingContentSet *)v4;
    Load_Stream(NotAtStart, v4, 0x30ui64);
    v7 = varStreamingContentSet;
    v8 = 3i64;
    do
    {
      varStreamingContentSet = v7;
      Load_StreamingContentSet(NotAtStart);
      ++v7;
      --v8;
    }
    while ( v8 );
    v9 = varTransientCosts;
    v10 = varushort;
    varStreamingContentSet = v6;
    if ( varTransientCosts->residentPageSizes )
    {
      ushort = AllocLoad_ushort();
      v9->residentPageSizes = ushort;
      varushort = ushort;
      Load_ushortArray(AtStart, varTransientCosts->transientCostCount);
      v9 = varTransientCosts;
      varushort = v10;
    }
    if ( v9->tempPageSizes )
    {
      v12 = AllocLoad_ushort();
      v9->tempPageSizes = v12;
      varushort = v12;
      Load_ushortArray(AtStart, varTransientCosts->transientCostCount);
      varushort = v10;
    }
    ++i;
  }
}

/*
==============
Load_TransientCostsStream
==============
*/
void Load_TransientCostsStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *pos; 
  TransientCosts *v4; 
  StreamingItemCost *v5; 
  StreamingContentSet *v6; 
  StreamingContentSet *v7; 
  __int64 v8; 
  TransientCosts *v9; 
  unsigned __int16 *v10; 
  unsigned __int16 *ushort; 
  unsigned __int16 *v12; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 3075, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    pos = (unsigned __int8 *)varTransientCosts;
    do
    {
      Load_Stream(AtStart, pos, 0x50ui64);
      v4 = varTransientCosts;
      if ( varTransientCosts->streamingCosts )
      {
        v5 = varStreamingItemCost;
        DB_PatchMem_FixStreamAlignment(3ui64);
        DB_CheckCanIncStreamPos(0i64);
        v4->streamingCosts = (StreamingItemCost *)g_streamPosGlob.pos;
        varStreamingItemCost = (StreamingItemCost *)g_streamPosGlob.pos;
        Load_Stream(AtStart, g_streamPosGlob.pos, 4i64 * varTransientCosts->streamingItemCount);
        v4 = varTransientCosts;
        varStreamingItemCost = v5;
      }
      v6 = varStreamingContentSet;
      varStreamingContentSet = (StreamingContentSet *)v4;
      Load_Stream(NotAtStart, v4, 0x30ui64);
      v7 = varStreamingContentSet;
      v8 = 3i64;
      do
      {
        varStreamingContentSet = v7;
        Load_StreamingContentSet(NotAtStart);
        ++v7;
        --v8;
      }
      while ( v8 );
      v9 = varTransientCosts;
      v10 = varushort;
      varStreamingContentSet = v6;
      if ( varTransientCosts->residentPageSizes )
      {
        ushort = AllocLoad_ushort();
        v9->residentPageSizes = ushort;
        varushort = ushort;
        Load_ushortArray(AtStart, varTransientCosts->transientCostCount);
        v9 = varTransientCosts;
        varushort = v10;
      }
      if ( v9->tempPageSizes )
      {
        v12 = AllocLoad_ushort();
        v9->tempPageSizes = v12;
        varushort = v12;
        Load_ushortArray(AtStart, varTransientCosts->transientCostCount);
        varushort = v10;
      }
      pos = g_streamPosGlob.pos;
      varTransientCosts = (TransientCosts *)g_streamPosGlob.pos;
      --count;
    }
    while ( count );
  }
}

/*
==============
Load_TransientFileReference
==============
*/
void Load_TransientFileReference(const DBStreamStart streamStart)
{
  const char **v1; 

  Load_Stream(streamStart, varTransientFileReference, 0x10ui64);
  v1 = varXString;
  varXString = &varTransientFileReference->name;
  Load_XString(NotAtStart);
  varXString = v1;
}

/*
==============
Load_TransientFileReferenceArray
==============
*/
void Load_TransientFileReferenceArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  TransientFileReference *i; 
  const char **v4; 

  v2 = count;
  Load_Stream(streamStart, varTransientFileReference, 16 * count);
  for ( i = varTransientFileReference; v2; --v2 )
  {
    varTransientFileReference = i;
    Load_Stream(NotAtStart, i, 0x10ui64);
    v4 = varXString;
    varXString = &varTransientFileReference->name;
    Load_XString(NotAtStart);
    ++i;
    varXString = v4;
  }
}

/*
==============
Load_TransientFileReferenceStream
==============
*/
void Load_TransientFileReferenceStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *pos; 
  const char **v4; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 2218, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    pos = (unsigned __int8 *)varTransientFileReference;
    do
    {
      Load_Stream(AtStart, pos, 0x10ui64);
      v4 = varXString;
      varXString = &varTransientFileReference->name;
      Load_XString(NotAtStart);
      pos = g_streamPosGlob.pos;
      varTransientFileReference = (TransientFileReference *)g_streamPosGlob.pos;
      varXString = v4;
      --count;
    }
    while ( count );
  }
}

/*
==============
Load_TransientInfo
==============
*/
void Load_TransientInfo(const DBStreamStart streamStart)
{
  TransientSets *v1; 
  TransientCosts *v2; 
  TransientInfo *v3; 
  ForcedStubAssetReference *v4; 
  __int64 forcedStubAssetCount; 
  ForcedStubAssetReference *i; 
  const char **v7; 
  TransientFileReference *v8; 
  __int64 transientFileCount; 
  TransientFileReference *j; 
  const char **v11; 
  TransientAssetReference *v12; 
  __int64 transientAssetCount; 
  TransientAssetReference *k; 
  const char **v15; 
  TransientWorldGridTileMap *v16; 
  __int64 transientWorldGridTileMapCount; 
  TransientWorldGridTileMap *m; 
  TransientWorldGridTileMap *v19; 
  unsigned __int16 *v20; 
  unsigned __int16 *ushort; 
  SpatialPartition_Tree *v22; 
  SpatialPartition_Tree *SpatialPartition_Tree; 
  Bounds *v24; 
  Bounds *Bounds; 
  unsigned __int16 *v26; 
  unsigned __int16 *v27; 
  bitarray_dynamic *v28; 
  bitarray_dynamic *v29; 
  unsigned int *v30; 
  unsigned int *uint; 

  Load_Stream(streamStart, varTransientInfo, 0xD8ui64);
  v1 = varTransientSets;
  varTransientSets = &varTransientInfo->transientSets;
  Load_TransientSets(NotAtStart);
  varTransientSets = v1;
  v2 = varTransientCosts;
  varTransientCosts = &varTransientInfo->transientCosts;
  Load_TransientCosts(NotAtStart);
  v3 = varTransientInfo;
  varTransientCosts = v2;
  if ( varTransientInfo->forcedStubAssets )
  {
    v4 = varForcedStubAssetReference;
    DB_PatchMem_FixStreamAlignment(7ui64);
    DB_CheckCanIncStreamPos(0i64);
    v3->forcedStubAssets = (ForcedStubAssetReference *)g_streamPosGlob.pos;
    varForcedStubAssetReference = (ForcedStubAssetReference *)g_streamPosGlob.pos;
    forcedStubAssetCount = varTransientInfo->forcedStubAssetCount;
    Load_Stream(AtStart, g_streamPosGlob.pos, 16 * forcedStubAssetCount);
    for ( i = varForcedStubAssetReference; forcedStubAssetCount; --forcedStubAssetCount )
    {
      varForcedStubAssetReference = i;
      Load_Stream(NotAtStart, i, 0x10ui64);
      v7 = varXString;
      varXString = &varForcedStubAssetReference->name;
      Load_XString(NotAtStart);
      ++i;
      varXString = v7;
    }
    v3 = varTransientInfo;
    varForcedStubAssetReference = v4;
  }
  if ( v3->transientFiles )
  {
    v8 = varTransientFileReference;
    DB_PatchMem_FixStreamAlignment(7ui64);
    DB_CheckCanIncStreamPos(0i64);
    v3->transientFiles = (TransientFileReference *)g_streamPosGlob.pos;
    varTransientFileReference = (TransientFileReference *)g_streamPosGlob.pos;
    transientFileCount = varTransientInfo->transientFileCount;
    Load_Stream(AtStart, g_streamPosGlob.pos, 16 * transientFileCount);
    for ( j = varTransientFileReference; transientFileCount; --transientFileCount )
    {
      varTransientFileReference = j;
      Load_Stream(NotAtStart, j, 0x10ui64);
      v11 = varXString;
      varXString = &varTransientFileReference->name;
      Load_XString(NotAtStart);
      ++j;
      varXString = v11;
    }
    v3 = varTransientInfo;
    varTransientFileReference = v8;
  }
  if ( v3->transientAssets )
  {
    v12 = varTransientAssetReference;
    DB_PatchMem_FixStreamAlignment(7ui64);
    DB_CheckCanIncStreamPos(0i64);
    v3->transientAssets = (TransientAssetReference *)g_streamPosGlob.pos;
    varTransientAssetReference = (TransientAssetReference *)g_streamPosGlob.pos;
    transientAssetCount = varTransientInfo->transientAssetCount;
    Load_Stream(AtStart, g_streamPosGlob.pos, 16 * transientAssetCount);
    for ( k = varTransientAssetReference; transientAssetCount; --transientAssetCount )
    {
      varTransientAssetReference = k;
      Load_Stream(NotAtStart, k, 0x10ui64);
      v15 = varXString;
      varXString = &varTransientAssetReference->name;
      Load_XString(NotAtStart);
      ++k;
      varXString = v15;
    }
    v3 = varTransientInfo;
    varTransientAssetReference = v12;
  }
  if ( v3->transientWorldGridTileMaps )
  {
    v16 = varTransientWorldGridTileMap;
    DB_PatchMem_FixStreamAlignment(7ui64);
    DB_CheckCanIncStreamPos(0i64);
    v3->transientWorldGridTileMaps = (TransientWorldGridTileMap *)g_streamPosGlob.pos;
    varTransientWorldGridTileMap = (TransientWorldGridTileMap *)g_streamPosGlob.pos;
    transientWorldGridTileMapCount = varTransientInfo->transientWorldGridTileMapCount;
    Load_Stream(AtStart, g_streamPosGlob.pos, 40 * transientWorldGridTileMapCount);
    for ( m = varTransientWorldGridTileMap; transientWorldGridTileMapCount; --transientWorldGridTileMapCount )
    {
      varTransientWorldGridTileMap = m;
      Load_Stream(NotAtStart, m, 0x28ui64);
      v19 = varTransientWorldGridTileMap;
      if ( varTransientWorldGridTileMap->spaceToTransientIndex )
      {
        v20 = varushort;
        ushort = AllocLoad_ushort();
        v19->spaceToTransientIndex = ushort;
        varushort = ushort;
        Load_ushortArray(AtStart, varTransientWorldGridTileMap->indexCount);
        varushort = v20;
      }
      ++m;
    }
    v3 = varTransientInfo;
    varTransientWorldGridTileMap = v16;
  }
  if ( v3->transientWorldGridSpatial )
  {
    v22 = varSpatialPartition_Tree;
    SpatialPartition_Tree = AllocLoad_SpatialPartition_Tree();
    v3->transientWorldGridSpatial = SpatialPartition_Tree;
    varSpatialPartition_Tree = SpatialPartition_Tree;
    Load_SpatialPartition_Tree(AtStart);
    v3 = varTransientInfo;
    varSpatialPartition_Tree = v22;
  }
  if ( v3->transientWorldGridBounds )
  {
    v24 = varBounds;
    Bounds = AllocLoad_Bounds();
    v3->transientWorldGridBounds = Bounds;
    varBounds = Bounds;
    Load_BoundsArray(AtStart, varTransientInfo->transientWorldGridBoundsCount);
    v3 = varTransientInfo;
    varBounds = v24;
  }
  if ( v3->transientWorldGridHighLodLookup )
  {
    v26 = varushort;
    v27 = AllocLoad_ushort();
    v3->transientWorldGridHighLodLookup = v27;
    varushort = v27;
    Load_ushortArray(AtStart, varTransientInfo->transientWorldGridHighLodLookupCount);
    v3 = varTransientInfo;
    varushort = v26;
  }
  v28 = varTransientInfo_Bitarray;
  varTransientInfo_Bitarray = &v3->transientSkipLoading;
  Load_Stream(NotAtStart, &v3->transientSkipLoading, 0x10ui64);
  v29 = varTransientInfo_Bitarray;
  if ( varTransientInfo_Bitarray->array )
  {
    v30 = varuint;
    uint = AllocLoad_uint();
    v29->array = uint;
    varuint = uint;
    Load_uintArray(AtStart, varTransientInfo_Bitarray->wordCount);
    varuint = v30;
  }
  varTransientInfo_Bitarray = v28;
}

/*
==============
Load_TransientInfoArray
==============
*/
void Load_TransientInfoArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  TransientInfo *i; 

  v2 = count;
  Load_Stream(streamStart, varTransientInfo, 216 * count);
  for ( i = varTransientInfo; v2; --v2 )
  {
    varTransientInfo = i;
    Load_TransientInfo(NotAtStart);
    ++i;
  }
}

/*
==============
Load_TransientInfoFlags
==============
*/
void Load_TransientInfoFlags(const DBStreamStart streamStart)
{
  Load_Stream(streamStart, varTransientInfoFlags, 1ui64);
}

/*
==============
Load_TransientInfoFlagsArray
==============
*/
void Load_TransientInfoFlagsArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  Load_Stream(streamStart, varTransientInfoFlags, count);
}

/*
==============
Load_TransientInfoFlagsStream
==============
*/
void Load_TransientInfoFlagsStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *pos; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 3278, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    pos = (unsigned __int8 *)varTransientInfoFlags;
    do
    {
      Load_Stream(AtStart, pos, 1ui64);
      pos = g_streamPosGlob.pos;
      varTransientInfoFlags = (TransientInfoFlags *)g_streamPosGlob.pos;
      --count;
    }
    while ( count );
  }
}

/*
==============
Load_TransientInfoStream
==============
*/
void Load_TransientInfoStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 3864, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  for ( ; count; --count )
  {
    Load_TransientInfo(AtStart);
    varTransientInfo = (TransientInfo *)g_streamPosGlob.pos;
  }
}

/*
==============
Load_TransientInfo_Bitarray
==============
*/
void Load_TransientInfo_Bitarray(const DBStreamStart streamStart)
{
  bitarray_dynamic *v1; 
  unsigned int *v2; 
  unsigned int *uint; 

  Load_Stream(streamStart, varTransientInfo_Bitarray, 0x10ui64);
  v1 = varTransientInfo_Bitarray;
  if ( varTransientInfo_Bitarray->array )
  {
    v2 = varuint;
    uint = AllocLoad_uint();
    v1->array = uint;
    varuint = uint;
    Load_uintArray(AtStart, varTransientInfo_Bitarray->wordCount);
    varuint = v2;
  }
}

/*
==============
Load_TransientInfo_BitarrayArray
==============
*/
void Load_TransientInfo_BitarrayArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  bitarray_dynamic *i; 
  bitarray_dynamic *v4; 
  unsigned int *v5; 
  unsigned int *uint; 

  v2 = count;
  Load_Stream(streamStart, varTransientInfo_Bitarray, 16 * count);
  for ( i = varTransientInfo_Bitarray; v2; --v2 )
  {
    varTransientInfo_Bitarray = i;
    Load_Stream(NotAtStart, i, 0x10ui64);
    v4 = varTransientInfo_Bitarray;
    if ( varTransientInfo_Bitarray->array )
    {
      v5 = varuint;
      uint = AllocLoad_uint();
      v4->array = uint;
      varuint = uint;
      Load_uintArray(AtStart, varTransientInfo_Bitarray->wordCount);
      varuint = v5;
    }
    ++i;
  }
}

/*
==============
Load_TransientInfo_BitarrayStream
==============
*/
void Load_TransientInfo_BitarrayStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *pos; 
  bitarray_dynamic *v4; 
  unsigned int *v5; 
  unsigned int *uint; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 3201, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    pos = (unsigned __int8 *)varTransientInfo_Bitarray;
    do
    {
      Load_Stream(AtStart, pos, 0x10ui64);
      v4 = varTransientInfo_Bitarray;
      if ( varTransientInfo_Bitarray->array )
      {
        v5 = varuint;
        uint = AllocLoad_uint();
        v4->array = uint;
        varuint = uint;
        Load_uintArray(AtStart, varTransientInfo_Bitarray->wordCount);
        varuint = v5;
      }
      pos = g_streamPosGlob.pos;
      varTransientInfo_Bitarray = (bitarray_dynamic *)g_streamPosGlob.pos;
      --count;
    }
    while ( count );
  }
}

/*
==============
Load_TransientSets
==============
*/
void Load_TransientSets(const DBStreamStart streamStart)
{
  TransientSets *v1; 
  const char **v2; 
  const char **XString; 
  bitarray<32> *v4; 

  Load_Stream(streamStart, varTransientSets, 0x18ui64);
  v1 = varTransientSets;
  if ( varTransientSets->names )
  {
    v2 = varXString;
    XString = AllocLoad_XString();
    v1->names = XString;
    varXString = XString;
    Load_XStringArray(AtStart, varTransientSets->count);
    v1 = varTransientSets;
    varXString = v2;
  }
  if ( v1->masks )
  {
    v4 = vartransientSPWorldBitArray_t;
    DB_PatchMem_FixStreamAlignment(3ui64);
    DB_CheckCanIncStreamPos(0i64);
    v1->masks = (bitarray<32> *)g_streamPosGlob.pos;
    vartransientSPWorldBitArray_t = (bitarray<32> *)g_streamPosGlob.pos;
    Load_Stream(AtStart, g_streamPosGlob.pos, 4i64 * varTransientSets->count);
    vartransientSPWorldBitArray_t = v4;
  }
}

/*
==============
Load_TransientSetsArray
==============
*/
void Load_TransientSetsArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  TransientSets *i; 
  TransientSets *v4; 
  const char **v5; 
  const char **XString; 
  bitarray<32> *v7; 

  v2 = count;
  Load_Stream(streamStart, varTransientSets, 24 * count);
  for ( i = varTransientSets; v2; --v2 )
  {
    varTransientSets = i;
    Load_Stream(NotAtStart, i, 0x18ui64);
    v4 = varTransientSets;
    if ( varTransientSets->names )
    {
      v5 = varXString;
      XString = AllocLoad_XString();
      v4->names = XString;
      varXString = XString;
      Load_XStringArray(AtStart, varTransientSets->count);
      v4 = varTransientSets;
      varXString = v5;
    }
    if ( v4->masks )
    {
      v7 = vartransientSPWorldBitArray_t;
      DB_PatchMem_FixStreamAlignment(3ui64);
      DB_CheckCanIncStreamPos(0i64);
      v4->masks = (bitarray<32> *)g_streamPosGlob.pos;
      vartransientSPWorldBitArray_t = (bitarray<32> *)g_streamPosGlob.pos;
      Load_Stream(AtStart, g_streamPosGlob.pos, 4i64 * varTransientSets->count);
      vartransientSPWorldBitArray_t = v7;
    }
    ++i;
  }
}

/*
==============
Load_TransientSetsStream
==============
*/
void Load_TransientSetsStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *pos; 
  TransientSets *v4; 
  const char **v5; 
  const char **XString; 
  bitarray<32> *v7; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 2347, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    pos = (unsigned __int8 *)varTransientSets;
    do
    {
      Load_Stream(AtStart, pos, 0x18ui64);
      v4 = varTransientSets;
      if ( varTransientSets->names )
      {
        v5 = varXString;
        XString = AllocLoad_XString();
        v4->names = XString;
        varXString = XString;
        Load_XStringArray(AtStart, varTransientSets->count);
        v4 = varTransientSets;
        varXString = v5;
      }
      if ( v4->masks )
      {
        v7 = vartransientSPWorldBitArray_t;
        DB_PatchMem_FixStreamAlignment(3ui64);
        DB_CheckCanIncStreamPos(0i64);
        v4->masks = (bitarray<32> *)g_streamPosGlob.pos;
        vartransientSPWorldBitArray_t = (bitarray<32> *)g_streamPosGlob.pos;
        Load_Stream(AtStart, g_streamPosGlob.pos, 4i64 * varTransientSets->count);
        vartransientSPWorldBitArray_t = v7;
      }
      pos = g_streamPosGlob.pos;
      varTransientSets = (TransientSets *)g_streamPosGlob.pos;
      --count;
    }
    while ( count );
  }
}

/*
==============
Load_TransientWorldGridTileMap
==============
*/
void Load_TransientWorldGridTileMap(const DBStreamStart streamStart)
{
  TransientWorldGridTileMap *v1; 
  unsigned __int16 *v2; 
  unsigned __int16 *ushort; 

  Load_Stream(streamStart, varTransientWorldGridTileMap, 0x28ui64);
  v1 = varTransientWorldGridTileMap;
  if ( varTransientWorldGridTileMap->spaceToTransientIndex )
  {
    v2 = varushort;
    ushort = AllocLoad_ushort();
    v1->spaceToTransientIndex = ushort;
    varushort = ushort;
    Load_ushortArray(AtStart, varTransientWorldGridTileMap->indexCount);
    varushort = v2;
  }
}

/*
==============
Load_TransientWorldGridTileMapArray
==============
*/
void Load_TransientWorldGridTileMapArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  TransientWorldGridTileMap *i; 
  TransientWorldGridTileMap *v4; 
  unsigned __int16 *v5; 
  unsigned __int16 *ushort; 

  v2 = count;
  Load_Stream(streamStart, varTransientWorldGridTileMap, 40 * count);
  for ( i = varTransientWorldGridTileMap; v2; --v2 )
  {
    varTransientWorldGridTileMap = i;
    Load_Stream(NotAtStart, i, 0x28ui64);
    v4 = varTransientWorldGridTileMap;
    if ( varTransientWorldGridTileMap->spaceToTransientIndex )
    {
      v5 = varushort;
      ushort = AllocLoad_ushort();
      v4->spaceToTransientIndex = ushort;
      varushort = ushort;
      Load_ushortArray(AtStart, varTransientWorldGridTileMap->indexCount);
      varushort = v5;
    }
    ++i;
  }
}

/*
==============
Load_TransientWorldGridTileMapStream
==============
*/
void Load_TransientWorldGridTileMapStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *pos; 
  TransientWorldGridTileMap *v4; 
  unsigned __int16 *v5; 
  unsigned __int16 *ushort; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 2611, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    pos = (unsigned __int8 *)varTransientWorldGridTileMap;
    do
    {
      Load_Stream(AtStart, pos, 0x28ui64);
      v4 = varTransientWorldGridTileMap;
      if ( varTransientWorldGridTileMap->spaceToTransientIndex )
      {
        v5 = varushort;
        ushort = AllocLoad_ushort();
        v4->spaceToTransientIndex = ushort;
        varushort = ushort;
        Load_ushortArray(AtStart, varTransientWorldGridTileMap->indexCount);
        varushort = v5;
      }
      pos = g_streamPosGlob.pos;
      varTransientWorldGridTileMap = (TransientWorldGridTileMap *)g_streamPosGlob.pos;
      --count;
    }
    while ( count );
  }
}

/*
==============
Load_transientSPWorldBitArray_t
==============
*/
void Load_transientSPWorldBitArray_t(const DBStreamStart streamStart)
{
  Load_Stream(streamStart, vartransientSPWorldBitArray_t, 4ui64);
}

/*
==============
Load_transientSPWorldBitArray_tArray
==============
*/
void Load_transientSPWorldBitArray_tArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  Load_Stream(streamStart, vartransientSPWorldBitArray_t, 4 * count);
}

/*
==============
Load_transientSPWorldBitArray_tStream
==============
*/
void Load_transientSPWorldBitArray_tStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *pos; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 1485, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    pos = (unsigned __int8 *)vartransientSPWorldBitArray_t;
    do
    {
      Load_Stream(AtStart, pos, 4ui64);
      pos = g_streamPosGlob.pos;
      vartransientSPWorldBitArray_t = (bitarray<32> *)g_streamPosGlob.pos;
      --count;
    }
    while ( count );
  }
}

/*
==============
Mark_AlwaysloadedFlagSet
==============
*/
__int64 Mark_AlwaysloadedFlagSet()
{
  AlwaysloadedFlags *v0; 
  int v1; 
  AlwaysloadedFlagSet *v2; 
  AlwaysloadedFlagsPerModel *perModelFlags; 
  AlwaysloadedFlagsPerModel *v4; 
  __int64 v5; 
  unsigned __int64 modelCount; 
  XModel **v7; 
  int v8; 
  AlwaysloadedFlags *v9; 
  int v10; 
  XModelSurfs **v11; 
  int v12; 

  v0 = marAlwaysloadedFlags;
  marAlwaysloadedFlags = &marAlwaysloadedFlagSet->globalFlags;
  v1 = Mark_AlwaysloadedFlags();
  marAlwaysloadedFlags = v0;
  if ( v1 )
  {
    v2 = marAlwaysloadedFlagSet;
    perModelFlags = marAlwaysloadedFlagSet->perModelFlags;
    if ( perModelFlags )
    {
      v4 = marAlwaysloadedFlagsPerModel;
      v5 = 0i64;
      marAlwaysloadedFlagsPerModel = marAlwaysloadedFlagSet->perModelFlags;
      modelCount = marAlwaysloadedFlagSet->modelCount;
      if ( marAlwaysloadedFlagSet->modelCount )
      {
        while ( 1 )
        {
          v7 = marXModelPtr;
          marXModelPtr = &perModelFlags->model;
          marAlwaysloadedFlagsPerModel = perModelFlags;
          v8 = Mark_XModelPtr();
          marXModelPtr = v7;
          if ( !v8 )
            break;
          v9 = marAlwaysloadedFlags;
          marAlwaysloadedFlags = &marAlwaysloadedFlagsPerModel->flags;
          v10 = Mark_AlwaysloadedFlags();
          marAlwaysloadedFlags = v9;
          if ( !v10 )
            break;
          ++perModelFlags;
          if ( ++v5 >= modelCount )
          {
            v2 = marAlwaysloadedFlagSet;
            goto LABEL_8;
          }
        }
        marAlwaysloadedFlagsPerModel = v4;
        return 0i64;
      }
LABEL_8:
      marAlwaysloadedFlagsPerModel = v4;
    }
    if ( !v2->modelSurfs )
      return 1i64;
    v11 = marXModelSurfsPtr;
    marXModelSurfsPtr = v2->modelSurfs;
    v12 = Mark_XModelSurfsPtrArray(v2->modelSurfCount);
    marXModelSurfsPtr = v11;
    if ( v12 )
      return 1i64;
  }
  return 0i64;
}

/*
==============
Mark_AlwaysloadedFlagSetArray
==============
*/
__int64 Mark_AlwaysloadedFlagSetArray(const unsigned __int64 count)
{
  AlwaysloadedFlagSet *v1; 
  __int64 v2; 
  AlwaysloadedFlags *v4; 
  int v5; 
  AlwaysloadedFlagSet *v6; 
  AlwaysloadedFlagsPerModel *perModelFlags; 
  AlwaysloadedFlagsPerModel *v8; 
  __int64 v9; 
  unsigned __int64 modelCount; 
  XModel **v11; 
  int v12; 
  AlwaysloadedFlags *v13; 
  int v14; 
  XModelSurfs **v15; 
  int v16; 

  v1 = marAlwaysloadedFlagSet;
  v2 = 0i64;
  if ( !count )
    return 1i64;
  while ( 1 )
  {
    v4 = marAlwaysloadedFlags;
    marAlwaysloadedFlags = &v1->globalFlags;
    marAlwaysloadedFlagSet = v1;
    v5 = Mark_AlwaysloadedFlags();
    marAlwaysloadedFlags = v4;
    if ( !v5 )
      return 0i64;
    v6 = marAlwaysloadedFlagSet;
    perModelFlags = marAlwaysloadedFlagSet->perModelFlags;
    if ( perModelFlags )
    {
      v8 = marAlwaysloadedFlagsPerModel;
      v9 = 0i64;
      marAlwaysloadedFlagsPerModel = marAlwaysloadedFlagSet->perModelFlags;
      modelCount = marAlwaysloadedFlagSet->modelCount;
      if ( marAlwaysloadedFlagSet->modelCount )
      {
        while ( 1 )
        {
          v11 = marXModelPtr;
          marXModelPtr = &perModelFlags->model;
          marAlwaysloadedFlagsPerModel = perModelFlags;
          v12 = Mark_XModelPtr();
          marXModelPtr = v11;
          if ( !v12 )
            break;
          v13 = marAlwaysloadedFlags;
          marAlwaysloadedFlags = &marAlwaysloadedFlagsPerModel->flags;
          v14 = Mark_AlwaysloadedFlags();
          marAlwaysloadedFlags = v13;
          if ( !v14 )
            break;
          ++perModelFlags;
          if ( ++v9 >= modelCount )
          {
            v6 = marAlwaysloadedFlagSet;
            goto LABEL_9;
          }
        }
        marAlwaysloadedFlagsPerModel = v8;
        return 0i64;
      }
LABEL_9:
      marAlwaysloadedFlagsPerModel = v8;
    }
    if ( v6->modelSurfs )
    {
      v15 = marXModelSurfsPtr;
      marXModelSurfsPtr = v6->modelSurfs;
      v16 = Mark_XModelSurfsPtrArray(v6->modelSurfCount);
      marXModelSurfsPtr = v15;
      if ( !v16 )
        return 0i64;
    }
    ++v1;
    if ( ++v2 >= count )
      return 1i64;
  }
}

/*
==============
Mark_AlwaysloadedFlags
==============
*/
__int64 Mark_AlwaysloadedFlags()
{
  GfxImage **images; 
  GfxImage **v1; 
  __int64 v2; 
  unsigned __int64 imageCount; 
  GfxImage *v4; 
  GfxImage *v5; 
  int v6; 

  images = marAlwaysloadedFlags->images;
  if ( !marAlwaysloadedFlags->images )
    return 1i64;
  v1 = marGfxImagePtr;
  v2 = 0i64;
  marGfxImagePtr = marAlwaysloadedFlags->images;
  imageCount = marAlwaysloadedFlags->imageCount;
  if ( !marAlwaysloadedFlags->imageCount )
  {
LABEL_9:
    marGfxImagePtr = v1;
    return 1i64;
  }
  v4 = marGfxImage;
  while ( 1 )
  {
    marGfxImagePtr = images;
    v5 = *images;
    if ( *images )
      break;
LABEL_8:
    ++images;
    if ( ++v2 >= imageCount )
      goto LABEL_9;
  }
  marGfxImage = *images;
  if ( Mark_GfxImageAsset(v5, 0) )
  {
    marGfxImage = v4;
    goto LABEL_8;
  }
  v6 = Mark_GfxImageAsset(marGfxImage, 1);
  marGfxImage = v4;
  if ( v6 )
    goto LABEL_8;
  marGfxImagePtr = v1;
  return 0i64;
}

/*
==============
Mark_AlwaysloadedFlagsArray
==============
*/
__int64 Mark_AlwaysloadedFlagsArray(const unsigned __int64 count)
{
  AlwaysloadedFlags *v1; 
  __int64 v2; 
  GfxImage **v4; 
  GfxImage *v5; 
  GfxImage **images; 
  __int64 v7; 
  unsigned __int64 imageCount; 
  GfxImage *v9; 
  int v10; 

  v1 = marAlwaysloadedFlags;
  v2 = 0i64;
  if ( !count )
    return 1i64;
  v4 = marGfxImagePtr;
  v5 = marGfxImage;
  while ( 1 )
  {
    marAlwaysloadedFlags = v1;
    images = v1->images;
    if ( v1->images )
      break;
LABEL_11:
    ++v1;
    if ( ++v2 >= count )
      return 1i64;
  }
  marGfxImagePtr = v1->images;
  v7 = 0i64;
  imageCount = v1->imageCount;
  if ( !v1->imageCount )
  {
LABEL_10:
    marGfxImagePtr = v4;
    goto LABEL_11;
  }
  while ( 1 )
  {
    marGfxImagePtr = images;
    v9 = *images;
    if ( *images )
      break;
LABEL_9:
    ++images;
    if ( ++v7 >= imageCount )
      goto LABEL_10;
  }
  marGfxImage = *images;
  if ( Mark_GfxImageAsset(v9, 0) )
  {
    marGfxImage = v5;
    goto LABEL_9;
  }
  v10 = Mark_GfxImageAsset(marGfxImage, 1);
  marGfxImage = v5;
  if ( v10 )
    goto LABEL_9;
  marGfxImagePtr = v4;
  return 0i64;
}

/*
==============
Mark_AlwaysloadedFlagsPerModel
==============
*/
_BOOL8 Mark_AlwaysloadedFlagsPerModel()
{
  XModel **v0; 
  int v1; 
  AlwaysloadedFlags *v2; 
  int v3; 
  _BOOL8 result; 

  v0 = marXModelPtr;
  marXModelPtr = &marAlwaysloadedFlagsPerModel->model;
  v1 = Mark_XModelPtr();
  marXModelPtr = v0;
  result = 0;
  if ( v1 )
  {
    v2 = marAlwaysloadedFlags;
    marAlwaysloadedFlags = &marAlwaysloadedFlagsPerModel->flags;
    v3 = Mark_AlwaysloadedFlags();
    marAlwaysloadedFlags = v2;
    if ( v3 )
      return 1;
  }
  return result;
}

/*
==============
Mark_AlwaysloadedFlagsPerModelArray
==============
*/
__int64 Mark_AlwaysloadedFlagsPerModelArray(const unsigned __int64 count)
{
  AlwaysloadedFlagsPerModel *v1; 
  __int64 v2; 
  XModel **v4; 
  int v5; 
  AlwaysloadedFlags *v6; 
  int v7; 

  v1 = marAlwaysloadedFlagsPerModel;
  v2 = 0i64;
  if ( !count )
    return 1i64;
  while ( 1 )
  {
    v4 = marXModelPtr;
    marXModelPtr = &v1->model;
    marAlwaysloadedFlagsPerModel = v1;
    v5 = Mark_XModelPtr();
    marXModelPtr = v4;
    if ( !v5 )
      break;
    v6 = marAlwaysloadedFlags;
    marAlwaysloadedFlags = &marAlwaysloadedFlagsPerModel->flags;
    v7 = Mark_AlwaysloadedFlags();
    marAlwaysloadedFlags = v6;
    if ( !v7 )
      break;
    ++v1;
    if ( ++v2 >= count )
      return 1i64;
  }
  return 0i64;
}

/*
==============
Mark_ForcedStubAssetReference
==============
*/
__int64 Mark_ForcedStubAssetReference()
{
  return 1i64;
}

/*
==============
Mark_ForcedStubAssetReferenceArray
==============
*/
__int64 Mark_ForcedStubAssetReferenceArray(const unsigned __int64 count)
{
  return 1i64;
}

/*
==============
Mark_StreamingContentSet
==============
*/
__int64 Mark_StreamingContentSet()
{
  return 1i64;
}

/*
==============
Mark_StreamingContentSetArray
==============
*/
__int64 Mark_StreamingContentSetArray(const unsigned __int64 count)
{
  return 1i64;
}

/*
==============
Mark_StreamingInfo
==============
*/
__int64 Mark_StreamingInfo()
{
  __int64 v0; 
  AlwaysloadedFlagSet *v1; 
  AlwaysloadedFlagSet *alwaysloadedFlagSets; 
  AlwaysloadedFlags *v3; 
  int v4; 
  AlwaysloadedFlagSet *v5; 
  AlwaysloadedFlagsPerModel *perModelFlags; 
  AlwaysloadedFlagsPerModel *v7; 
  __int64 v8; 
  unsigned __int64 modelCount; 
  XModel **v10; 
  int v11; 
  AlwaysloadedFlags *v12; 
  int v13; 
  XModelSurfs **v14; 
  int v15; 
  __int64 result; 

  v0 = 0i64;
  v1 = marAlwaysloadedFlagSet;
  alwaysloadedFlagSets = marStreamingInfo->alwaysloadedFlagSets;
  while ( 1 )
  {
    v3 = marAlwaysloadedFlags;
    marAlwaysloadedFlags = &alwaysloadedFlagSets->globalFlags;
    marAlwaysloadedFlagSet = alwaysloadedFlagSets;
    v4 = Mark_AlwaysloadedFlags();
    marAlwaysloadedFlags = v3;
    if ( !v4 )
      break;
    v5 = marAlwaysloadedFlagSet;
    perModelFlags = marAlwaysloadedFlagSet->perModelFlags;
    if ( perModelFlags )
    {
      v7 = marAlwaysloadedFlagsPerModel;
      v8 = 0i64;
      marAlwaysloadedFlagsPerModel = marAlwaysloadedFlagSet->perModelFlags;
      modelCount = marAlwaysloadedFlagSet->modelCount;
      if ( marAlwaysloadedFlagSet->modelCount )
      {
        while ( 1 )
        {
          v10 = marXModelPtr;
          marXModelPtr = &perModelFlags->model;
          marAlwaysloadedFlagsPerModel = perModelFlags;
          v11 = Mark_XModelPtr();
          marXModelPtr = v10;
          if ( !v11 )
            break;
          v12 = marAlwaysloadedFlags;
          marAlwaysloadedFlags = &marAlwaysloadedFlagsPerModel->flags;
          v13 = Mark_AlwaysloadedFlags();
          marAlwaysloadedFlags = v12;
          if ( !v13 )
            break;
          ++perModelFlags;
          if ( ++v8 >= modelCount )
          {
            v5 = marAlwaysloadedFlagSet;
            goto LABEL_9;
          }
        }
        marAlwaysloadedFlagsPerModel = v7;
        break;
      }
LABEL_9:
      marAlwaysloadedFlagsPerModel = v7;
    }
    if ( v5->modelSurfs )
    {
      v14 = marXModelSurfsPtr;
      marXModelSurfsPtr = v5->modelSurfs;
      v15 = Mark_XModelSurfsPtrArray(v5->modelSurfCount);
      marXModelSurfsPtr = v14;
      if ( !v15 )
        break;
    }
    ++alwaysloadedFlagSets;
    if ( (unsigned __int64)++v0 >= 3 )
    {
      result = 1i64;
      goto LABEL_16;
    }
  }
  result = 0i64;
LABEL_16:
  marAlwaysloadedFlagSet = v1;
  return result;
}

/*
==============
Mark_StreamingInfoArray
==============
*/
__int64 Mark_StreamingInfoArray(const unsigned __int64 count)
{
  StreamingInfo *v1; 
  AlwaysloadedFlagSet *v2; 
  AlwaysloadedFlagSet *alwaysloadedFlagSets; 
  unsigned __int64 i; 
  AlwaysloadedFlags *v5; 
  int v6; 
  AlwaysloadedFlagSet *v7; 
  AlwaysloadedFlagsPerModel *perModelFlags; 
  AlwaysloadedFlagsPerModel *v9; 
  __int64 v10; 
  unsigned __int64 modelCount; 
  XModel **v12; 
  int v13; 
  AlwaysloadedFlags *v14; 
  int v15; 
  XModelSurfs **v16; 
  int v17; 
  __int64 v20; 
  AlwaysloadedFlagSet *v21; 

  v1 = marStreamingInfo;
  v20 = 0i64;
  if ( count )
  {
    v2 = marAlwaysloadedFlagSet;
    while ( 2 )
    {
      marStreamingInfo = v1;
      alwaysloadedFlagSets = v1->alwaysloadedFlagSets;
      v21 = v2;
      for ( i = 0i64; i < 3; ++i )
      {
        v5 = marAlwaysloadedFlags;
        marAlwaysloadedFlags = &alwaysloadedFlagSets->globalFlags;
        marAlwaysloadedFlagSet = alwaysloadedFlagSets;
        v6 = Mark_AlwaysloadedFlags();
        marAlwaysloadedFlags = v5;
        if ( !v6 )
          goto LABEL_18;
        v7 = marAlwaysloadedFlagSet;
        perModelFlags = marAlwaysloadedFlagSet->perModelFlags;
        if ( perModelFlags )
        {
          v9 = marAlwaysloadedFlagsPerModel;
          v10 = 0i64;
          marAlwaysloadedFlagsPerModel = marAlwaysloadedFlagSet->perModelFlags;
          modelCount = marAlwaysloadedFlagSet->modelCount;
          if ( marAlwaysloadedFlagSet->modelCount )
          {
            while ( 1 )
            {
              v12 = marXModelPtr;
              marXModelPtr = &perModelFlags->model;
              marAlwaysloadedFlagsPerModel = perModelFlags;
              v13 = Mark_XModelPtr();
              marXModelPtr = v12;
              if ( !v13 )
                break;
              v14 = marAlwaysloadedFlags;
              marAlwaysloadedFlags = &marAlwaysloadedFlagsPerModel->flags;
              v15 = Mark_AlwaysloadedFlags();
              marAlwaysloadedFlags = v14;
              if ( !v15 )
                break;
              ++perModelFlags;
              if ( ++v10 >= modelCount )
              {
                v7 = marAlwaysloadedFlagSet;
                goto LABEL_11;
              }
            }
            marAlwaysloadedFlagsPerModel = v9;
LABEL_18:
            marAlwaysloadedFlagSet = v21;
            return 0i64;
          }
LABEL_11:
          marAlwaysloadedFlagsPerModel = v9;
        }
        if ( v7->modelSurfs )
        {
          v16 = marXModelSurfsPtr;
          marXModelSurfsPtr = v7->modelSurfs;
          v17 = Mark_XModelSurfsPtrArray(v7->modelSurfCount);
          marXModelSurfsPtr = v16;
          if ( !v17 )
            goto LABEL_18;
        }
        ++alwaysloadedFlagSets;
      }
      ++v1;
      v2 = v21;
      marAlwaysloadedFlagSet = v21;
      if ( ++v20 < count )
        continue;
      break;
    }
  }
  return 1i64;
}

/*
==============
Mark_StreamingInfoPtr
==============
*/
__int64 Mark_StreamingInfoPtr()
{
  StreamingInfo *v0; 
  StreamingInfo *v1; 
  int v3; 

  v0 = *marStreamingInfoPtr;
  if ( *marStreamingInfoPtr )
  {
    v1 = marStreamingInfo;
    marStreamingInfo = *marStreamingInfoPtr;
    if ( Mark_StreamingInfoAsset(v0, 0) )
    {
      marStreamingInfo = v1;
      return 1i64;
    }
    if ( !Mark_StreamingInfo() )
    {
      marStreamingInfo = v1;
      return 0i64;
    }
    v3 = Mark_StreamingInfoAsset(marStreamingInfo, 1);
    marStreamingInfo = v1;
    if ( !v3 )
      return 0i64;
  }
  return 1i64;
}

/*
==============
Mark_StreamingInfoPtrArray
==============
*/
__int64 Mark_StreamingInfoPtrArray(const unsigned __int64 count)
{
  StreamingInfo **v1; 
  __int64 v2; 
  StreamingInfo *v4; 
  StreamingInfo *v5; 
  int v6; 

  v1 = marStreamingInfoPtr;
  v2 = 0i64;
  if ( !count )
    return 1i64;
  v4 = marStreamingInfo;
  while ( 1 )
  {
    marStreamingInfoPtr = v1;
    v5 = *v1;
    if ( !*v1 )
      goto LABEL_8;
    marStreamingInfo = *v1;
    if ( Mark_StreamingInfoAsset(v5, 0) )
    {
      marStreamingInfo = v4;
      goto LABEL_8;
    }
    if ( !Mark_StreamingInfo() )
      break;
    v6 = Mark_StreamingInfoAsset(marStreamingInfo, 1);
    marStreamingInfo = v4;
    if ( !v6 )
      return 0i64;
LABEL_8:
    ++v1;
    if ( ++v2 >= count )
      return 1i64;
  }
  marStreamingInfo = v4;
  return 0i64;
}

/*
==============
Mark_StreamingItemContents
==============
*/
__int64 Mark_StreamingItemContents()
{
  return 1i64;
}

/*
==============
Mark_StreamingItemContentsArray
==============
*/
__int64 Mark_StreamingItemContentsArray(const unsigned __int64 count)
{
  return 1i64;
}

/*
==============
Mark_StreamingItemCost
==============
*/
__int64 Mark_StreamingItemCost()
{
  return 1i64;
}

/*
==============
Mark_StreamingItemCostArray
==============
*/
__int64 Mark_StreamingItemCostArray(const unsigned __int64 count)
{
  return 1i64;
}

/*
==============
Mark_TransientAssetReference
==============
*/
__int64 Mark_TransientAssetReference()
{
  return 1i64;
}

/*
==============
Mark_TransientAssetReferenceArray
==============
*/
__int64 Mark_TransientAssetReferenceArray(const unsigned __int64 count)
{
  return 1i64;
}

/*
==============
Mark_TransientCosts
==============
*/
__int64 Mark_TransientCosts()
{
  return 1i64;
}

/*
==============
Mark_TransientCostsArray
==============
*/
__int64 Mark_TransientCostsArray(const unsigned __int64 count)
{
  return 1i64;
}

/*
==============
Mark_TransientFileReference
==============
*/
__int64 Mark_TransientFileReference()
{
  return 1i64;
}

/*
==============
Mark_TransientFileReferenceArray
==============
*/
__int64 Mark_TransientFileReferenceArray(const unsigned __int64 count)
{
  return 1i64;
}

/*
==============
Mark_TransientInfo
==============
*/
__int64 Mark_TransientInfo()
{
  return 1i64;
}

/*
==============
Mark_TransientInfoArray
==============
*/
__int64 Mark_TransientInfoArray(const unsigned __int64 count)
{
  return 1i64;
}

/*
==============
Mark_TransientInfoFlags
==============
*/
__int64 Mark_TransientInfoFlags()
{
  return 1i64;
}

/*
==============
Mark_TransientInfoFlagsArray
==============
*/
__int64 Mark_TransientInfoFlagsArray(const unsigned __int64 count)
{
  return 1i64;
}

/*
==============
Mark_TransientInfo_Bitarray
==============
*/
__int64 Mark_TransientInfo_Bitarray()
{
  return 1i64;
}

/*
==============
Mark_TransientInfo_BitarrayArray
==============
*/
__int64 Mark_TransientInfo_BitarrayArray(const unsigned __int64 count)
{
  return 1i64;
}

/*
==============
Mark_TransientSets
==============
*/
__int64 Mark_TransientSets()
{
  return 1i64;
}

/*
==============
Mark_TransientSetsArray
==============
*/
__int64 Mark_TransientSetsArray(const unsigned __int64 count)
{
  return 1i64;
}

/*
==============
Mark_TransientWorldGridTileMap
==============
*/
__int64 Mark_TransientWorldGridTileMap()
{
  return 1i64;
}

/*
==============
Mark_TransientWorldGridTileMapArray
==============
*/
__int64 Mark_TransientWorldGridTileMapArray(const unsigned __int64 count)
{
  return 1i64;
}

/*
==============
Mark_transientSPWorldBitArray_t
==============
*/
__int64 Mark_transientSPWorldBitArray_t()
{
  return 1i64;
}

/*
==============
Mark_transientSPWorldBitArray_tArray
==============
*/
__int64 Mark_transientSPWorldBitArray_tArray(const unsigned __int64 count)
{
  return 1i64;
}

/*
==============
Postload_AlwaysloadedFlagSet
==============
*/
void Postload_AlwaysloadedFlagSet(const DBStreamStart streamStart)
{
  AlwaysloadedFlags *v2; 
  AlwaysloadedFlagSet *v3; 
  AlwaysloadedFlagsPerModel *v4; 
  __int64 modelCount; 
  unsigned __int64 v6; 
  AlwaysloadedFlagsPerModel *i; 
  AlwaysloadedFlagsPerModel *v8; 
  XModel **v9; 
  AlwaysloadedFlags *v10; 
  AlwaysloadedFlagSet *v11; 
  XModelSurfs **v12; 
  XModelSurfs **v13; 

  if ( streamStart != (varAlwaysloadedFlagSet != (AlwaysloadedFlagSet *)g_streamPosGlob.pos) )
    DB_PatchMem_ValidatePostloadStream(streamStart, varAlwaysloadedFlagSet, 0x38ui64);
  if ( streamStart != NotAtStart )
    DB_IncStreamPos(0x38ui64);
  v2 = varAlwaysloadedFlags;
  varAlwaysloadedFlags = &varAlwaysloadedFlagSet->globalFlags;
  Postload_AlwaysloadedFlags(NotAtStart);
  varAlwaysloadedFlags = v2;
  v3 = varAlwaysloadedFlagSet;
  if ( varAlwaysloadedFlagSet->perModelFlags )
  {
    v4 = varAlwaysloadedFlagsPerModel;
    DB_PatchMem_FixStreamAlignment(7ui64);
    DB_CheckCanIncStreamPos(0i64);
    v3->perModelFlags = (AlwaysloadedFlagsPerModel *)g_streamPosGlob.pos;
    varAlwaysloadedFlagsPerModel = (AlwaysloadedFlagsPerModel *)g_streamPosGlob.pos;
    modelCount = varAlwaysloadedFlagSet->modelCount;
    v6 = 32 * modelCount;
    if ( 32 * modelCount )
    {
      if ( v6 > 0x7FFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_preload_inline.h", 98, ASSERT_TYPE_ASSERT, "(size <= 2147483647i32)", (const char *)&queryFormat, "size <= INT32_MAX") )
        __debugbreak();
      DB_IncStreamPos(v6);
    }
    for ( i = varAlwaysloadedFlagsPerModel; modelCount; --modelCount )
    {
      v8 = i;
      varAlwaysloadedFlagsPerModel = i;
      if ( i == (AlwaysloadedFlagsPerModel *)g_streamPosGlob.pos )
      {
        DB_PatchMem_ValidatePostloadStream(NotAtStart, i, 0x20ui64);
        v8 = varAlwaysloadedFlagsPerModel;
      }
      v9 = varXModelPtr;
      varXModelPtr = &v8->model;
      Postload_XModelPtr(NotAtStart);
      varXModelPtr = v9;
      v10 = varAlwaysloadedFlags;
      varAlwaysloadedFlags = &varAlwaysloadedFlagsPerModel->flags;
      Postload_AlwaysloadedFlags(NotAtStart);
      ++i;
      varAlwaysloadedFlags = v10;
    }
    varAlwaysloadedFlagsPerModel = v4;
  }
  v11 = varAlwaysloadedFlagSet;
  if ( varAlwaysloadedFlagSet->modelSurfs )
  {
    v12 = varXModelSurfsPtr;
    v13 = AllocPostload_XModelSurfsPtr();
    v11->modelSurfs = v13;
    varXModelSurfsPtr = v13;
    Postload_XModelSurfsPtrArray(AtStart, varAlwaysloadedFlagSet->modelSurfCount);
    varXModelSurfsPtr = v12;
  }
}

/*
==============
Postload_AlwaysloadedFlagSetArray
==============
*/
void Postload_AlwaysloadedFlagSetArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  AlwaysloadedFlagSet *i; 

  v2 = count;
  Postload_Stream_10(streamStart, varAlwaysloadedFlagSet, 56 * count);
  for ( i = varAlwaysloadedFlagSet; v2; --v2 )
  {
    varAlwaysloadedFlagSet = i;
    Postload_AlwaysloadedFlagSet(NotAtStart);
    ++i;
  }
}

/*
==============
Postload_AlwaysloadedFlagSetStream
==============
*/
void Postload_AlwaysloadedFlagSetStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *pos; 
  AlwaysloadedFlags *v4; 
  AlwaysloadedFlagSet *v5; 
  AlwaysloadedFlagsPerModel *v6; 
  __int64 modelCount; 
  unsigned __int64 v8; 
  AlwaysloadedFlagsPerModel *i; 
  AlwaysloadedFlagsPerModel *v10; 
  XModel **v11; 
  AlwaysloadedFlags *v12; 
  AlwaysloadedFlagSet *v13; 
  XModelSurfs **v14; 
  XModelSurfs **v15; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 4612, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    pos = (unsigned __int8 *)varAlwaysloadedFlagSet;
    do
    {
      if ( pos != g_streamPosGlob.pos )
        DB_PatchMem_ValidatePostloadStream(AtStart, pos, 0x38ui64);
      if ( !g_streamPosGlob.pos && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_stream.h", 181, ASSERT_TYPE_ASSERT, "(g_streamPosGlob.pos)", (const char *)&queryFormat, "g_streamPosGlob.pos") )
        __debugbreak();
      DB_CheckCanIncStreamPos(0x38ui64);
      v4 = varAlwaysloadedFlags;
      g_streamPosGlob.pos += 56;
      varAlwaysloadedFlags = &varAlwaysloadedFlagSet->globalFlags;
      Postload_AlwaysloadedFlags(NotAtStart);
      varAlwaysloadedFlags = v4;
      v5 = varAlwaysloadedFlagSet;
      if ( varAlwaysloadedFlagSet->perModelFlags )
      {
        v6 = varAlwaysloadedFlagsPerModel;
        DB_PatchMem_FixStreamAlignment(7ui64);
        DB_CheckCanIncStreamPos(0i64);
        v5->perModelFlags = (AlwaysloadedFlagsPerModel *)g_streamPosGlob.pos;
        varAlwaysloadedFlagsPerModel = (AlwaysloadedFlagsPerModel *)g_streamPosGlob.pos;
        modelCount = varAlwaysloadedFlagSet->modelCount;
        v8 = 32 * modelCount;
        if ( 32 * modelCount )
        {
          if ( v8 > 0x7FFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_preload_inline.h", 98, ASSERT_TYPE_ASSERT, "(size <= 2147483647i32)", (const char *)&queryFormat, "size <= INT32_MAX") )
            __debugbreak();
          DB_IncStreamPos(v8);
        }
        for ( i = varAlwaysloadedFlagsPerModel; modelCount; --modelCount )
        {
          v10 = i;
          varAlwaysloadedFlagsPerModel = i;
          if ( i == (AlwaysloadedFlagsPerModel *)g_streamPosGlob.pos )
          {
            DB_PatchMem_ValidatePostloadStream(NotAtStart, i, 0x20ui64);
            v10 = varAlwaysloadedFlagsPerModel;
          }
          v11 = varXModelPtr;
          varXModelPtr = &v10->model;
          Postload_XModelPtr(NotAtStart);
          varXModelPtr = v11;
          v12 = varAlwaysloadedFlags;
          varAlwaysloadedFlags = &varAlwaysloadedFlagsPerModel->flags;
          Postload_AlwaysloadedFlags(NotAtStart);
          ++i;
          varAlwaysloadedFlags = v12;
        }
        varAlwaysloadedFlagsPerModel = v6;
      }
      v13 = varAlwaysloadedFlagSet;
      if ( varAlwaysloadedFlagSet->modelSurfs )
      {
        v14 = varXModelSurfsPtr;
        v15 = AllocPostload_XModelSurfsPtr();
        v13->modelSurfs = v15;
        varXModelSurfsPtr = v15;
        Postload_XModelSurfsPtrArray(AtStart, varAlwaysloadedFlagSet->modelSurfCount);
        varXModelSurfsPtr = v14;
      }
      pos = g_streamPosGlob.pos;
      varAlwaysloadedFlagSet = (AlwaysloadedFlagSet *)g_streamPosGlob.pos;
      --count;
    }
    while ( count );
  }
}

/*
==============
Postload_AlwaysloadedFlags
==============
*/
void Postload_AlwaysloadedFlags(const DBStreamStart streamStart)
{
  AlwaysloadedFlags *v2; 
  GfxImage **v3; 
  __int64 imageCount; 
  GfxImage **i; 
  AlwaysloadedFlags *v6; 
  unsigned int *v7; 
  unsigned int *v8; 
  unsigned int v9; 

  if ( streamStart != (varAlwaysloadedFlags != (AlwaysloadedFlags *)g_streamPosGlob.pos) )
    DB_PatchMem_ValidatePostloadStream(streamStart, varAlwaysloadedFlags, 0x18ui64);
  if ( streamStart != NotAtStart )
    DB_IncStreamPos(0x18ui64);
  v2 = varAlwaysloadedFlags;
  if ( varAlwaysloadedFlags->images )
  {
    v3 = varGfxImagePtr;
    DB_PatchMem_FixStreamAlignment(7ui64);
    DB_CheckCanIncStreamPos(0i64);
    v2->images = (GfxImage **)g_streamPosGlob.pos;
    varGfxImagePtr = (GfxImage **)g_streamPosGlob.pos;
    imageCount = varAlwaysloadedFlags->imageCount;
    if ( 8 * imageCount )
    {
      if ( (unsigned __int64)(8 * imageCount) > 0x7FFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_preload_inline.h", 98, ASSERT_TYPE_ASSERT, "(size <= 2147483647i32)", (const char *)&queryFormat, "size <= INT32_MAX") )
        __debugbreak();
      DB_IncStreamPos(8 * imageCount);
    }
    for ( i = varGfxImagePtr; imageCount; --imageCount )
    {
      varGfxImagePtr = i;
      if ( i == (GfxImage **)g_streamPosGlob.pos )
        DB_PatchMem_ValidatePostloadStream(NotAtStart, i, 8ui64);
      DB_WalkDataProcessedInPreload();
      ++i;
    }
    varGfxImagePtr = v3;
  }
  v6 = varAlwaysloadedFlags;
  if ( varAlwaysloadedFlags->imageFlags )
  {
    v7 = varuint;
    v8 = AllocPostload_uint();
    v6->imageFlags = v8;
    varuint = v8;
    v9 = DB_StreamingInfo_CalcUIntsForImageFlags(varAlwaysloadedFlags->imageCount);
    Postload_uintArray(AtStart, v9);
    varuint = v7;
  }
}

/*
==============
Postload_AlwaysloadedFlagsArray
==============
*/
void Postload_AlwaysloadedFlagsArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  AlwaysloadedFlags *i; 

  v2 = count;
  Postload_Stream_10(streamStart, varAlwaysloadedFlags, 24 * count);
  for ( i = varAlwaysloadedFlags; v2; --v2 )
  {
    varAlwaysloadedFlags = i;
    Postload_AlwaysloadedFlags(NotAtStart);
    ++i;
  }
}

/*
==============
Postload_AlwaysloadedFlagsPerModel
==============
*/
void Postload_AlwaysloadedFlagsPerModel(const DBStreamStart streamStart)
{
  XModel **v2; 
  AlwaysloadedFlags *v3; 

  if ( streamStart != (varAlwaysloadedFlagsPerModel != (AlwaysloadedFlagsPerModel *)g_streamPosGlob.pos) )
    DB_PatchMem_ValidatePostloadStream(streamStart, varAlwaysloadedFlagsPerModel, 0x20ui64);
  if ( streamStart != NotAtStart )
    DB_IncStreamPos(0x20ui64);
  v2 = varXModelPtr;
  varXModelPtr = &varAlwaysloadedFlagsPerModel->model;
  Postload_XModelPtr(NotAtStart);
  varXModelPtr = v2;
  v3 = varAlwaysloadedFlags;
  varAlwaysloadedFlags = &varAlwaysloadedFlagsPerModel->flags;
  Postload_AlwaysloadedFlags(NotAtStart);
  varAlwaysloadedFlags = v3;
}

/*
==============
Postload_AlwaysloadedFlagsPerModelArray
==============
*/
void Postload_AlwaysloadedFlagsPerModelArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  AlwaysloadedFlagsPerModel *i; 
  AlwaysloadedFlagsPerModel *v4; 
  XModel **v5; 
  AlwaysloadedFlags *v6; 

  v2 = count;
  Postload_Stream_10(streamStart, varAlwaysloadedFlagsPerModel, 32 * count);
  for ( i = varAlwaysloadedFlagsPerModel; v2; --v2 )
  {
    v4 = i;
    varAlwaysloadedFlagsPerModel = i;
    if ( i == (AlwaysloadedFlagsPerModel *)g_streamPosGlob.pos )
    {
      DB_PatchMem_ValidatePostloadStream(NotAtStart, i, 0x20ui64);
      v4 = varAlwaysloadedFlagsPerModel;
    }
    v5 = varXModelPtr;
    varXModelPtr = &v4->model;
    Postload_XModelPtr(NotAtStart);
    varXModelPtr = v5;
    v6 = varAlwaysloadedFlags;
    varAlwaysloadedFlags = &varAlwaysloadedFlagsPerModel->flags;
    Postload_AlwaysloadedFlags(NotAtStart);
    ++i;
    varAlwaysloadedFlags = v6;
  }
}

/*
==============
Postload_AlwaysloadedFlagsPerModelStream
==============
*/
void Postload_AlwaysloadedFlagsPerModelStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *v3; 
  unsigned __int8 *pos; 
  XModel **v5; 
  AlwaysloadedFlags *v6; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 4435, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    v3 = (unsigned __int8 *)varAlwaysloadedFlagsPerModel;
    pos = g_streamPosGlob.pos;
    do
    {
      if ( v3 != pos )
      {
        DB_PatchMem_ValidatePostloadStream(AtStart, v3, 0x20ui64);
        pos = g_streamPosGlob.pos;
      }
      if ( !pos && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_stream.h", 181, ASSERT_TYPE_ASSERT, "(g_streamPosGlob.pos)", (const char *)&queryFormat, "g_streamPosGlob.pos") )
        __debugbreak();
      DB_CheckCanIncStreamPos(0x20ui64);
      v5 = varXModelPtr;
      g_streamPosGlob.pos += 32;
      varXModelPtr = &varAlwaysloadedFlagsPerModel->model;
      Postload_XModelPtr(NotAtStart);
      varXModelPtr = v5;
      v6 = varAlwaysloadedFlags;
      varAlwaysloadedFlags = &varAlwaysloadedFlagsPerModel->flags;
      Postload_AlwaysloadedFlags(NotAtStart);
      pos = g_streamPosGlob.pos;
      varAlwaysloadedFlagsPerModel = (AlwaysloadedFlagsPerModel *)g_streamPosGlob.pos;
      v3 = g_streamPosGlob.pos;
      varAlwaysloadedFlags = v6;
      --count;
    }
    while ( count );
  }
}

/*
==============
Postload_AlwaysloadedFlagsStream
==============
*/
void Postload_AlwaysloadedFlagsStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *pos; 
  AlwaysloadedFlags *v4; 
  GfxImage **v5; 
  __int64 imageCount; 
  GfxImage **i; 
  AlwaysloadedFlags *v8; 
  unsigned int *v9; 
  unsigned int *v10; 
  unsigned int v11; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 4327, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    pos = (unsigned __int8 *)varAlwaysloadedFlags;
    do
    {
      if ( pos != g_streamPosGlob.pos )
        DB_PatchMem_ValidatePostloadStream(AtStart, pos, 0x18ui64);
      if ( !g_streamPosGlob.pos && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_stream.h", 181, ASSERT_TYPE_ASSERT, "(g_streamPosGlob.pos)", (const char *)&queryFormat, "g_streamPosGlob.pos") )
        __debugbreak();
      DB_CheckCanIncStreamPos(0x18ui64);
      v4 = varAlwaysloadedFlags;
      g_streamPosGlob.pos += 24;
      if ( varAlwaysloadedFlags->images )
      {
        v5 = varGfxImagePtr;
        DB_PatchMem_FixStreamAlignment(7ui64);
        DB_CheckCanIncStreamPos(0i64);
        v4->images = (GfxImage **)g_streamPosGlob.pos;
        varGfxImagePtr = (GfxImage **)g_streamPosGlob.pos;
        imageCount = varAlwaysloadedFlags->imageCount;
        if ( 8 * imageCount )
        {
          if ( (unsigned __int64)(8 * imageCount) > 0x7FFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_preload_inline.h", 98, ASSERT_TYPE_ASSERT, "(size <= 2147483647i32)", (const char *)&queryFormat, "size <= INT32_MAX") )
            __debugbreak();
          DB_IncStreamPos(8 * imageCount);
        }
        for ( i = varGfxImagePtr; imageCount; --imageCount )
        {
          varGfxImagePtr = i;
          if ( i == (GfxImage **)g_streamPosGlob.pos )
            DB_PatchMem_ValidatePostloadStream(NotAtStart, i, 8ui64);
          DB_WalkDataProcessedInPreload();
          ++i;
        }
        varGfxImagePtr = v5;
      }
      v8 = varAlwaysloadedFlags;
      if ( varAlwaysloadedFlags->imageFlags )
      {
        v9 = varuint;
        v10 = AllocPostload_uint();
        v8->imageFlags = v10;
        varuint = v10;
        v11 = DB_StreamingInfo_CalcUIntsForImageFlags(varAlwaysloadedFlags->imageCount);
        Postload_uintArray(AtStart, v11);
        varuint = v9;
      }
      pos = g_streamPosGlob.pos;
      varAlwaysloadedFlags = (AlwaysloadedFlags *)g_streamPosGlob.pos;
      --count;
    }
    while ( count );
  }
}

/*
==============
Postload_ForcedStubAssetReference
==============
*/
void Postload_ForcedStubAssetReference(const DBStreamStart streamStart)
{
  const char **v2; 

  if ( streamStart != (varForcedStubAssetReference != (ForcedStubAssetReference *)g_streamPosGlob.pos) )
    DB_PatchMem_ValidatePostloadStream(streamStart, varForcedStubAssetReference, 0x10ui64);
  if ( streamStart != NotAtStart )
    DB_IncStreamPos(0x10ui64);
  v2 = varXString;
  varXString = &varForcedStubAssetReference->name;
  Postload_XString(NotAtStart);
  varXString = v2;
}

/*
==============
Postload_ForcedStubAssetReferenceArray
==============
*/
void Postload_ForcedStubAssetReferenceArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  ForcedStubAssetReference *i; 
  ForcedStubAssetReference *v4; 
  const char **v5; 

  v2 = count;
  Postload_Stream_10(streamStart, varForcedStubAssetReference, 16 * count);
  for ( i = varForcedStubAssetReference; v2; --v2 )
  {
    v4 = i;
    varForcedStubAssetReference = i;
    if ( i == (ForcedStubAssetReference *)g_streamPosGlob.pos )
    {
      DB_PatchMem_ValidatePostloadStream(NotAtStart, i, 0x10ui64);
      v4 = varForcedStubAssetReference;
    }
    v5 = varXString;
    varXString = &v4->name;
    Postload_XString(NotAtStart);
    ++i;
    varXString = v5;
  }
}

/*
==============
Postload_ForcedStubAssetReferenceStream
==============
*/
void Postload_ForcedStubAssetReferenceStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *v3; 
  unsigned __int8 *pos; 
  const char **v5; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 4711, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    v3 = (unsigned __int8 *)varForcedStubAssetReference;
    pos = g_streamPosGlob.pos;
    do
    {
      if ( v3 != pos )
      {
        DB_PatchMem_ValidatePostloadStream(AtStart, v3, 0x10ui64);
        pos = g_streamPosGlob.pos;
      }
      if ( !pos && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_stream.h", 181, ASSERT_TYPE_ASSERT, "(g_streamPosGlob.pos)", (const char *)&queryFormat, "g_streamPosGlob.pos") )
        __debugbreak();
      DB_CheckCanIncStreamPos(0x10ui64);
      v5 = varXString;
      g_streamPosGlob.pos += 16;
      varXString = &varForcedStubAssetReference->name;
      Postload_XString(NotAtStart);
      pos = g_streamPosGlob.pos;
      varForcedStubAssetReference = (ForcedStubAssetReference *)g_streamPosGlob.pos;
      v3 = g_streamPosGlob.pos;
      varXString = v5;
      --count;
    }
    while ( count );
  }
}

/*
==============
Postload_StreamingContentSet
==============
*/
void Postload_StreamingContentSet(const DBStreamStart streamStart)
{
  StreamingContentSet *v2; 
  unsigned __int16 *v3; 
  unsigned __int16 *v4; 
  StreamingContentSet *v5; 
  StreamingItemContents *v6; 
  __int64 transientCostCount; 
  StreamingItemContents *i; 
  StreamingItemContents *v9; 
  unsigned __int16 *v10; 
  unsigned __int16 *v11; 
  unsigned int CostItemIndex; 

  if ( streamStart != (varStreamingContentSet != (StreamingContentSet *)g_streamPosGlob.pos) )
    DB_PatchMem_ValidatePostloadStream(streamStart, varStreamingContentSet, 0x10ui64);
  if ( streamStart != NotAtStart )
    DB_IncStreamPos(0x10ui64);
  v2 = varStreamingContentSet;
  if ( varStreamingContentSet->contentCounts )
  {
    v3 = varushort;
    v4 = AllocPostload_ushort();
    v2->contentCounts = v4;
    varushort = v4;
    Postload_ushortArray(AtStart, varTransientCosts->transientCostCount);
    varushort = v3;
  }
  v5 = varStreamingContentSet;
  if ( varStreamingContentSet->contents )
  {
    v6 = varStreamingItemContents;
    DB_PatchMem_FixStreamAlignment(7ui64);
    DB_CheckCanIncStreamPos(0i64);
    v5->contents = (StreamingItemContents *)g_streamPosGlob.pos;
    varStreamingItemContents = (StreamingItemContents *)g_streamPosGlob.pos;
    transientCostCount = varTransientCosts->transientCostCount;
    if ( 8 * transientCostCount )
    {
      if ( (unsigned __int64)(8 * transientCostCount) > 0x7FFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_preload_inline.h", 98, ASSERT_TYPE_ASSERT, "(size <= 2147483647i32)", (const char *)&queryFormat, "size <= INT32_MAX") )
        __debugbreak();
      DB_IncStreamPos(8 * transientCostCount);
    }
    for ( i = varStreamingItemContents; transientCostCount; --transientCostCount )
    {
      v9 = i;
      varStreamingItemContents = i;
      if ( i == (StreamingItemContents *)g_streamPosGlob.pos )
      {
        DB_PatchMem_ValidatePostloadStream(NotAtStart, i, 8ui64);
        v9 = varStreamingItemContents;
      }
      if ( v9->contents )
      {
        v10 = varushort;
        v11 = AllocPostload_ushort();
        v9->contents = v11;
        varushort = v11;
        CostItemIndex = DB_StreamingInfo_GetCostItemIndex(varTransientCosts, varStreamingContentSet, varStreamingItemContents);
        Postload_ushortArray(AtStart, CostItemIndex);
        varushort = v10;
      }
      ++i;
    }
    varStreamingItemContents = v6;
  }
}

/*
==============
Postload_StreamingContentSetArray
==============
*/
void Postload_StreamingContentSetArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  StreamingContentSet *i; 

  v2 = count;
  Postload_Stream_10(streamStart, varStreamingContentSet, 16 * count);
  for ( i = varStreamingContentSet; v2; --v2 )
  {
    varStreamingContentSet = i;
    Postload_StreamingContentSet(NotAtStart);
    ++i;
  }
}

/*
==============
Postload_StreamingContentSetStream
==============
*/
void Postload_StreamingContentSetStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *pos; 
  StreamingContentSet *v4; 
  unsigned __int16 *v5; 
  unsigned __int16 *v6; 
  StreamingItemContents *v7; 
  __int64 transientCostCount; 
  StreamingItemContents *i; 
  StreamingItemContents *v10; 
  unsigned __int16 *v11; 
  unsigned __int16 *v12; 
  unsigned int CostItemIndex; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 5583, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    pos = (unsigned __int8 *)varStreamingContentSet;
    do
    {
      if ( pos != g_streamPosGlob.pos )
        DB_PatchMem_ValidatePostloadStream(AtStart, pos, 0x10ui64);
      if ( !g_streamPosGlob.pos && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_stream.h", 181, ASSERT_TYPE_ASSERT, "(g_streamPosGlob.pos)", (const char *)&queryFormat, "g_streamPosGlob.pos") )
        __debugbreak();
      DB_CheckCanIncStreamPos(0x10ui64);
      v4 = varStreamingContentSet;
      g_streamPosGlob.pos += 16;
      if ( varStreamingContentSet->contentCounts )
      {
        v5 = varushort;
        v6 = AllocPostload_ushort();
        v4->contentCounts = v6;
        varushort = v6;
        Postload_ushortArray(AtStart, varTransientCosts->transientCostCount);
        v4 = varStreamingContentSet;
        varushort = v5;
      }
      if ( v4->contents )
      {
        v7 = varStreamingItemContents;
        DB_PatchMem_FixStreamAlignment(7ui64);
        DB_CheckCanIncStreamPos(0i64);
        v4->contents = (StreamingItemContents *)g_streamPosGlob.pos;
        varStreamingItemContents = (StreamingItemContents *)g_streamPosGlob.pos;
        transientCostCount = varTransientCosts->transientCostCount;
        if ( 8 * transientCostCount )
        {
          if ( (unsigned __int64)(8 * transientCostCount) > 0x7FFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_preload_inline.h", 98, ASSERT_TYPE_ASSERT, "(size <= 2147483647i32)", (const char *)&queryFormat, "size <= INT32_MAX") )
            __debugbreak();
          DB_IncStreamPos(8 * transientCostCount);
        }
        for ( i = varStreamingItemContents; transientCostCount; --transientCostCount )
        {
          v10 = i;
          varStreamingItemContents = i;
          if ( i == (StreamingItemContents *)g_streamPosGlob.pos )
          {
            DB_PatchMem_ValidatePostloadStream(NotAtStart, i, 8ui64);
            v10 = varStreamingItemContents;
          }
          if ( v10->contents )
          {
            v11 = varushort;
            v12 = AllocPostload_ushort();
            v10->contents = v12;
            varushort = v12;
            CostItemIndex = DB_StreamingInfo_GetCostItemIndex(varTransientCosts, varStreamingContentSet, varStreamingItemContents);
            Postload_ushortArray(AtStart, CostItemIndex);
            varushort = v11;
          }
          ++i;
        }
        varStreamingItemContents = v7;
      }
      pos = g_streamPosGlob.pos;
      varStreamingContentSet = (StreamingContentSet *)g_streamPosGlob.pos;
      --count;
    }
    while ( count );
  }
}

/*
==============
Postload_StreamingInfo
==============
*/
void Postload_StreamingInfo(const DBStreamStart streamStart)
{
  const char **v2; 
  AlwaysloadedFlagSet *v3; 
  AlwaysloadedFlagSet *alwaysloadedFlagSets; 
  __int64 v5; 
  StreamingInfo *v6; 
  TransientInfo *v7; 

  DB_PatchMem_PostLoad_PushAsset(63, varStreamingInfo);
  if ( streamStart != (varStreamingInfo != (StreamingInfo *)g_streamPosGlob.pos) )
    DB_PatchMem_ValidatePostloadStream(streamStart, varStreamingInfo, 0xB8ui64);
  if ( streamStart != NotAtStart )
    DB_IncStreamPos(0xB8ui64);
  DB_PushStreamPos(8u);
  v2 = varXString;
  varXString = &varStreamingInfo->name;
  Postload_XString(NotAtStart);
  v3 = varAlwaysloadedFlagSet;
  varXString = v2;
  alwaysloadedFlagSets = varStreamingInfo->alwaysloadedFlagSets;
  varAlwaysloadedFlagSet = varStreamingInfo->alwaysloadedFlagSets;
  if ( varStreamingInfo->alwaysloadedFlagSets == (AlwaysloadedFlagSet *)g_streamPosGlob.pos )
  {
    DB_PatchMem_ValidatePostloadStream(NotAtStart, varStreamingInfo->alwaysloadedFlagSets, 0xA8ui64);
    alwaysloadedFlagSets = varAlwaysloadedFlagSet;
  }
  v5 = 3i64;
  do
  {
    varAlwaysloadedFlagSet = alwaysloadedFlagSets;
    Postload_AlwaysloadedFlagSet(NotAtStart);
    ++alwaysloadedFlagSets;
    --v5;
  }
  while ( v5 );
  v6 = varStreamingInfo;
  varAlwaysloadedFlagSet = v3;
  if ( varStreamingInfo->transientInfo )
  {
    v7 = varTransientInfo;
    DB_PatchMem_FixStreamAlignment(7ui64);
    DB_CheckCanIncStreamPos(0i64);
    v6->transientInfo = (TransientInfo *)g_streamPosGlob.pos;
    varTransientInfo = (TransientInfo *)g_streamPosGlob.pos;
    Postload_TransientInfo(AtStart);
    varTransientInfo = v7;
  }
  DB_PopStreamPos();
  DB_PatchMem_PopAsset();
}

/*
==============
Postload_StreamingInfoArray
==============
*/
void Postload_StreamingInfoArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  StreamingInfo *i; 

  v2 = count;
  Postload_Stream_10(streamStart, varStreamingInfo, 184 * count);
  for ( i = varStreamingInfo; v2; --v2 )
  {
    varStreamingInfo = i;
    Postload_StreamingInfo(NotAtStart);
    ++i;
  }
}

/*
==============
Postload_StreamingInfoPtr
==============
*/
void Postload_StreamingInfoPtr(const DBStreamStart streamStart)
{
  if ( streamStart != (varStreamingInfoPtr != (StreamingInfo **)g_streamPosGlob.pos) )
    DB_PatchMem_ValidatePostloadStream(streamStart, varStreamingInfoPtr, 8ui64);
  if ( streamStart != NotAtStart )
    DB_IncStreamPos(8ui64);
  DB_WalkDataProcessedInPreload();
  Postload_StreamingInfoAsset(varStreamingInfoPtr);
}

/*
==============
Postload_StreamingInfoPtrArray
==============
*/
void Postload_StreamingInfoPtrArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  StreamingInfo **i; 

  v2 = count;
  Postload_Stream_10(streamStart, varStreamingInfoPtr, 8 * count);
  for ( i = varStreamingInfoPtr; v2; --v2 )
  {
    varStreamingInfoPtr = i;
    if ( i == (StreamingInfo **)g_streamPosGlob.pos )
      DB_PatchMem_ValidatePostloadStream(NotAtStart, i, 8ui64);
    DB_WalkDataProcessedInPreload();
    Postload_StreamingInfoAsset(varStreamingInfoPtr);
    ++i;
  }
}

/*
==============
Postload_StreamingInfoPtrStream
==============
*/
void Postload_StreamingInfoPtrStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *v3; 
  unsigned __int8 *pos; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 6757, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    v3 = (unsigned __int8 *)varStreamingInfoPtr;
    pos = g_streamPosGlob.pos;
    do
    {
      if ( v3 != pos )
      {
        DB_PatchMem_ValidatePostloadStream(AtStart, v3, 8ui64);
        pos = g_streamPosGlob.pos;
      }
      if ( !pos && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_stream.h", 181, ASSERT_TYPE_ASSERT, "(g_streamPosGlob.pos)", (const char *)&queryFormat, "g_streamPosGlob.pos") )
        __debugbreak();
      DB_CheckCanIncStreamPos(8ui64);
      g_streamPosGlob.pos += 8;
      DB_WalkDataProcessedInPreload();
      Postload_StreamingInfoAsset(varStreamingInfoPtr);
      pos = g_streamPosGlob.pos;
      varStreamingInfoPtr = (StreamingInfo **)g_streamPosGlob.pos;
      v3 = g_streamPosGlob.pos;
      --count;
    }
    while ( count );
  }
}

/*
==============
Postload_StreamingInfoStream
==============
*/
void Postload_StreamingInfoStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *v3; 
  unsigned __int8 *pos; 
  const char **v5; 
  AlwaysloadedFlagSet *v6; 
  AlwaysloadedFlagSet *alwaysloadedFlagSets; 
  __int64 v8; 
  StreamingInfo *v9; 
  TransientInfo *v10; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 6702, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    v3 = (unsigned __int8 *)varStreamingInfo;
    do
    {
      DB_PatchMem_PostLoad_PushAsset(63, v3);
      pos = g_streamPosGlob.pos;
      if ( varStreamingInfo != (StreamingInfo *)g_streamPosGlob.pos )
      {
        DB_PatchMem_ValidatePostloadStream(AtStart, varStreamingInfo, 0xB8ui64);
        pos = g_streamPosGlob.pos;
      }
      if ( !pos && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_stream.h", 181, ASSERT_TYPE_ASSERT, "(g_streamPosGlob.pos)", (const char *)&queryFormat, "g_streamPosGlob.pos") )
        __debugbreak();
      DB_CheckCanIncStreamPos(0xB8ui64);
      g_streamPosGlob.pos += 184;
      DB_PushStreamPos(8u);
      v5 = varXString;
      varXString = &varStreamingInfo->name;
      Postload_XString(NotAtStart);
      v6 = varAlwaysloadedFlagSet;
      varXString = v5;
      alwaysloadedFlagSets = varStreamingInfo->alwaysloadedFlagSets;
      varAlwaysloadedFlagSet = varStreamingInfo->alwaysloadedFlagSets;
      if ( varStreamingInfo->alwaysloadedFlagSets == (AlwaysloadedFlagSet *)g_streamPosGlob.pos )
      {
        DB_PatchMem_ValidatePostloadStream(NotAtStart, varStreamingInfo->alwaysloadedFlagSets, 0xA8ui64);
        alwaysloadedFlagSets = varAlwaysloadedFlagSet;
      }
      v8 = 3i64;
      do
      {
        varAlwaysloadedFlagSet = alwaysloadedFlagSets;
        Postload_AlwaysloadedFlagSet(NotAtStart);
        ++alwaysloadedFlagSets;
        --v8;
      }
      while ( v8 );
      v9 = varStreamingInfo;
      varAlwaysloadedFlagSet = v6;
      if ( varStreamingInfo->transientInfo )
      {
        v10 = varTransientInfo;
        DB_PatchMem_FixStreamAlignment(7ui64);
        DB_CheckCanIncStreamPos(0i64);
        v9->transientInfo = (TransientInfo *)g_streamPosGlob.pos;
        varTransientInfo = (TransientInfo *)g_streamPosGlob.pos;
        Postload_TransientInfo(AtStart);
        varTransientInfo = v10;
      }
      DB_PopStreamPos();
      DB_PatchMem_PopAsset();
      v3 = g_streamPosGlob.pos;
      varStreamingInfo = (StreamingInfo *)g_streamPosGlob.pos;
      --count;
    }
    while ( count );
  }
}

/*
==============
Postload_StreamingItemContents
==============
*/
void Postload_StreamingItemContents(const DBStreamStart streamStart)
{
  StreamingItemContents *v2; 
  unsigned __int16 *v3; 
  unsigned __int16 *v4; 
  unsigned int CostItemIndex; 

  if ( streamStart != (varStreamingItemContents != (StreamingItemContents *)g_streamPosGlob.pos) )
    DB_PatchMem_ValidatePostloadStream(streamStart, varStreamingItemContents, 8ui64);
  if ( streamStart != NotAtStart )
    DB_IncStreamPos(8ui64);
  v2 = varStreamingItemContents;
  if ( varStreamingItemContents->contents )
  {
    v3 = varushort;
    v4 = AllocPostload_ushort();
    v2->contents = v4;
    varushort = v4;
    CostItemIndex = DB_StreamingInfo_GetCostItemIndex(varTransientCosts, varStreamingContentSet, varStreamingItemContents);
    Postload_ushortArray(AtStart, CostItemIndex);
    varushort = v3;
  }
}

/*
==============
Postload_StreamingItemContentsArray
==============
*/
void Postload_StreamingItemContentsArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  StreamingItemContents *i; 
  StreamingItemContents *v4; 
  unsigned __int16 *v5; 
  unsigned __int16 *v6; 
  unsigned int CostItemIndex; 

  v2 = count;
  Postload_Stream_10(streamStart, varStreamingItemContents, 8 * count);
  for ( i = varStreamingItemContents; v2; --v2 )
  {
    v4 = i;
    varStreamingItemContents = i;
    if ( i == (StreamingItemContents *)g_streamPosGlob.pos )
    {
      DB_PatchMem_ValidatePostloadStream(NotAtStart, i, 8ui64);
      v4 = varStreamingItemContents;
    }
    if ( v4->contents )
    {
      v5 = varushort;
      v6 = AllocPostload_ushort();
      v4->contents = v6;
      varushort = v6;
      CostItemIndex = DB_StreamingInfo_GetCostItemIndex(varTransientCosts, varStreamingContentSet, varStreamingItemContents);
      Postload_ushortArray(AtStart, CostItemIndex);
      varushort = v5;
    }
    ++i;
  }
}

/*
==============
Postload_StreamingItemContentsStream
==============
*/
void Postload_StreamingItemContentsStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  StreamingItemContents *v3; 
  unsigned __int8 *pos; 
  StreamingItemContents *v5; 
  unsigned __int16 *v6; 
  unsigned __int16 *v7; 
  unsigned int CostItemIndex; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 5478, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    v3 = varStreamingItemContents;
    pos = g_streamPosGlob.pos;
    do
    {
      if ( v3 != (StreamingItemContents *)pos )
      {
        DB_PatchMem_ValidatePostloadStream(AtStart, v3, 8ui64);
        pos = g_streamPosGlob.pos;
      }
      if ( !pos && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_stream.h", 181, ASSERT_TYPE_ASSERT, "(g_streamPosGlob.pos)", (const char *)&queryFormat, "g_streamPosGlob.pos") )
        __debugbreak();
      DB_CheckCanIncStreamPos(8ui64);
      v5 = varStreamingItemContents;
      pos = g_streamPosGlob.pos + 8;
      g_streamPosGlob.pos += 8;
      if ( varStreamingItemContents->contents )
      {
        v6 = varushort;
        v7 = AllocPostload_ushort();
        v5->contents = v7;
        varushort = v7;
        CostItemIndex = DB_StreamingInfo_GetCostItemIndex(varTransientCosts, varStreamingContentSet, varStreamingItemContents);
        Postload_ushortArray(AtStart, CostItemIndex);
        pos = g_streamPosGlob.pos;
        varushort = v6;
      }
      varStreamingItemContents = (StreamingItemContents *)pos;
      v3 = (StreamingItemContents *)pos;
      --count;
    }
    while ( count );
  }
}

/*
==============
Postload_StreamingItemCost
==============
*/
void Postload_StreamingItemCost(const DBStreamStart streamStart)
{
  if ( streamStart != (varStreamingItemCost != (StreamingItemCost *)g_streamPosGlob.pos) )
    DB_PatchMem_ValidatePostloadStream(streamStart, varStreamingItemCost, 4ui64);
  if ( streamStart != NotAtStart )
    DB_IncStreamPos(4ui64);
}

/*
==============
Postload_StreamingItemCostArray
==============
*/
void Postload_StreamingItemCostArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  Postload_Stream_10(streamStart, varStreamingItemCost, 4 * count);
}

/*
==============
Postload_StreamingItemCostStream
==============
*/
void Postload_StreamingItemCostStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  StreamingItemCost *v3; 
  unsigned __int8 *pos; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 5399, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    v3 = varStreamingItemCost;
    pos = g_streamPosGlob.pos;
    do
    {
      if ( v3 != (StreamingItemCost *)pos )
      {
        DB_PatchMem_ValidatePostloadStream(AtStart, v3, 4ui64);
        pos = g_streamPosGlob.pos;
      }
      if ( !pos && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_stream.h", 181, ASSERT_TYPE_ASSERT, "(g_streamPosGlob.pos)", (const char *)&queryFormat, "g_streamPosGlob.pos") )
        __debugbreak();
      DB_CheckCanIncStreamPos(4ui64);
      pos = g_streamPosGlob.pos + 4;
      g_streamPosGlob.pos = pos;
      v3 = (StreamingItemCost *)pos;
      varStreamingItemCost = (StreamingItemCost *)pos;
      --count;
    }
    while ( count );
  }
}

/*
==============
Postload_TransientAssetReference
==============
*/
void Postload_TransientAssetReference(const DBStreamStart streamStart)
{
  const char **v2; 

  if ( streamStart != (varTransientAssetReference != (TransientAssetReference *)g_streamPosGlob.pos) )
    DB_PatchMem_ValidatePostloadStream(streamStart, varTransientAssetReference, 0x10ui64);
  if ( streamStart != NotAtStart )
    DB_IncStreamPos(0x10ui64);
  v2 = varXString;
  varXString = &varTransientAssetReference->name;
  Postload_XString(NotAtStart);
  varXString = v2;
}

/*
==============
Postload_TransientAssetReferenceArray
==============
*/
void Postload_TransientAssetReferenceArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  TransientAssetReference *i; 
  TransientAssetReference *v4; 
  const char **v5; 

  v2 = count;
  Postload_Stream_10(streamStart, varTransientAssetReference, 16 * count);
  for ( i = varTransientAssetReference; v2; --v2 )
  {
    v4 = i;
    varTransientAssetReference = i;
    if ( i == (TransientAssetReference *)g_streamPosGlob.pos )
    {
      DB_PatchMem_ValidatePostloadStream(NotAtStart, i, 0x10ui64);
      v4 = varTransientAssetReference;
    }
    v5 = varXString;
    varXString = &v4->name;
    Postload_XString(NotAtStart);
    ++i;
    varXString = v5;
  }
}

/*
==============
Postload_TransientAssetReferenceStream
==============
*/
void Postload_TransientAssetReferenceStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *v3; 
  unsigned __int8 *pos; 
  const char **v5; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 4833, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    v3 = (unsigned __int8 *)varTransientAssetReference;
    pos = g_streamPosGlob.pos;
    do
    {
      if ( v3 != pos )
      {
        DB_PatchMem_ValidatePostloadStream(AtStart, v3, 0x10ui64);
        pos = g_streamPosGlob.pos;
      }
      if ( !pos && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_stream.h", 181, ASSERT_TYPE_ASSERT, "(g_streamPosGlob.pos)", (const char *)&queryFormat, "g_streamPosGlob.pos") )
        __debugbreak();
      DB_CheckCanIncStreamPos(0x10ui64);
      v5 = varXString;
      g_streamPosGlob.pos += 16;
      varXString = &varTransientAssetReference->name;
      Postload_XString(NotAtStart);
      pos = g_streamPosGlob.pos;
      varTransientAssetReference = (TransientAssetReference *)g_streamPosGlob.pos;
      v3 = g_streamPosGlob.pos;
      varXString = v5;
      --count;
    }
    while ( count );
  }
}

/*
==============
Postload_TransientCosts
==============
*/
void Postload_TransientCosts(const DBStreamStart streamStart)
{
  TransientCosts *v2; 
  __int64 v3; 
  StreamingItemCost *v4; 
  unsigned __int64 v5; 
  TransientCosts *v6; 
  StreamingContentSet *v7; 
  TransientCosts *v8; 
  unsigned __int16 *v9; 
  unsigned __int16 *v10; 
  unsigned __int16 *v11; 

  if ( streamStart != (varTransientCosts != (TransientCosts *)g_streamPosGlob.pos) )
    DB_PatchMem_ValidatePostloadStream(streamStart, varTransientCosts, 0x50ui64);
  if ( streamStart != NotAtStart )
    DB_IncStreamPos(0x50ui64);
  v2 = varTransientCosts;
  v3 = 3i64;
  if ( varTransientCosts->streamingCosts )
  {
    v4 = varStreamingItemCost;
    DB_PatchMem_FixStreamAlignment(3ui64);
    DB_CheckCanIncStreamPos(0i64);
    v2->streamingCosts = (StreamingItemCost *)g_streamPosGlob.pos;
    varStreamingItemCost = (StreamingItemCost *)g_streamPosGlob.pos;
    v5 = 4i64 * varTransientCosts->streamingItemCount;
    if ( v5 )
    {
      if ( v5 > 0x7FFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_preload_inline.h", 98, ASSERT_TYPE_ASSERT, "(size <= 2147483647i32)", (const char *)&queryFormat, "size <= INT32_MAX") )
        __debugbreak();
      DB_IncStreamPos(v5);
    }
    varStreamingItemCost = v4;
  }
  v6 = varTransientCosts;
  v7 = varStreamingContentSet;
  varStreamingContentSet = (StreamingContentSet *)varTransientCosts;
  if ( varTransientCosts == (TransientCosts *)g_streamPosGlob.pos )
  {
    DB_PatchMem_ValidatePostloadStream(NotAtStart, varTransientCosts, 0x30ui64);
    v6 = (TransientCosts *)varStreamingContentSet;
  }
  do
  {
    varStreamingContentSet = (StreamingContentSet *)v6;
    Postload_StreamingContentSet(NotAtStart);
    v6 = (TransientCosts *)((char *)v6 + 16);
    --v3;
  }
  while ( v3 );
  v8 = varTransientCosts;
  v9 = varushort;
  varStreamingContentSet = v7;
  if ( varTransientCosts->residentPageSizes )
  {
    v10 = AllocPostload_ushort();
    v8->residentPageSizes = v10;
    varushort = v10;
    Postload_ushortArray(AtStart, varTransientCosts->transientCostCount);
    v8 = varTransientCosts;
    varushort = v9;
  }
  if ( v8->tempPageSizes )
  {
    v11 = AllocPostload_ushort();
    v8->tempPageSizes = v11;
    varushort = v11;
    Postload_ushortArray(AtStart, varTransientCosts->transientCostCount);
    varushort = v9;
  }
}

/*
==============
Postload_TransientCostsArray
==============
*/
void Postload_TransientCostsArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  TransientCosts *i; 

  v2 = count;
  Postload_Stream_10(streamStart, varTransientCosts, 80 * count);
  for ( i = varTransientCosts; v2; --v2 )
  {
    varTransientCosts = i;
    Postload_TransientCosts(NotAtStart);
    ++i;
  }
}

/*
==============
Postload_TransientCostsStream
==============
*/
void Postload_TransientCostsStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *v3; 
  unsigned __int8 *pos; 
  TransientCosts *v5; 
  unsigned __int8 *v6; 
  StreamingItemCost *v7; 
  unsigned __int64 v8; 
  StreamingContentSet *v9; 
  __int64 v10; 
  TransientCosts *v11; 
  unsigned __int16 *v12; 
  unsigned __int16 *v13; 
  unsigned __int16 *v14; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 5783, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    v3 = (unsigned __int8 *)varTransientCosts;
    pos = g_streamPosGlob.pos;
    do
    {
      if ( v3 != pos )
      {
        DB_PatchMem_ValidatePostloadStream(AtStart, v3, 0x50ui64);
        pos = g_streamPosGlob.pos;
      }
      if ( !pos && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_stream.h", 181, ASSERT_TYPE_ASSERT, "(g_streamPosGlob.pos)", (const char *)&queryFormat, "g_streamPosGlob.pos") )
        __debugbreak();
      DB_CheckCanIncStreamPos(0x50ui64);
      v5 = varTransientCosts;
      v6 = g_streamPosGlob.pos + 80;
      g_streamPosGlob.pos += 80;
      if ( varTransientCosts->streamingCosts )
      {
        v7 = varStreamingItemCost;
        DB_PatchMem_FixStreamAlignment(3ui64);
        DB_CheckCanIncStreamPos(0i64);
        v5->streamingCosts = (StreamingItemCost *)g_streamPosGlob.pos;
        v5 = varTransientCosts;
        v6 = g_streamPosGlob.pos;
        varStreamingItemCost = (StreamingItemCost *)g_streamPosGlob.pos;
        v8 = 4i64 * varTransientCosts->streamingItemCount;
        if ( v8 )
        {
          if ( v8 > 0x7FFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_preload_inline.h", 98, ASSERT_TYPE_ASSERT, "(size <= 2147483647i32)", (const char *)&queryFormat, "size <= INT32_MAX") )
            __debugbreak();
          DB_IncStreamPos(v8);
          v6 = g_streamPosGlob.pos;
          v5 = varTransientCosts;
        }
        varStreamingItemCost = v7;
      }
      v9 = varStreamingContentSet;
      varStreamingContentSet = (StreamingContentSet *)v5;
      if ( v5 == (TransientCosts *)v6 )
      {
        DB_PatchMem_ValidatePostloadStream(NotAtStart, v5, 0x30ui64);
        v5 = (TransientCosts *)varStreamingContentSet;
      }
      v10 = 3i64;
      do
      {
        varStreamingContentSet = (StreamingContentSet *)v5;
        Postload_StreamingContentSet(NotAtStart);
        v5 = (TransientCosts *)((char *)v5 + 16);
        --v10;
      }
      while ( v10 );
      v11 = varTransientCosts;
      v12 = varushort;
      varStreamingContentSet = v9;
      if ( varTransientCosts->residentPageSizes )
      {
        v13 = AllocPostload_ushort();
        v11->residentPageSizes = v13;
        varushort = v13;
        Postload_ushortArray(AtStart, varTransientCosts->transientCostCount);
        v11 = varTransientCosts;
        varushort = v12;
      }
      if ( v11->tempPageSizes )
      {
        v14 = AllocPostload_ushort();
        v11->tempPageSizes = v14;
        varushort = v14;
        Postload_ushortArray(AtStart, varTransientCosts->transientCostCount);
        varushort = v12;
      }
      pos = g_streamPosGlob.pos;
      varTransientCosts = (TransientCosts *)g_streamPosGlob.pos;
      v3 = g_streamPosGlob.pos;
      --count;
    }
    while ( count );
  }
}

/*
==============
Postload_TransientFileReference
==============
*/
void Postload_TransientFileReference(const DBStreamStart streamStart)
{
  const char **v2; 

  if ( streamStart != (varTransientFileReference != (TransientFileReference *)g_streamPosGlob.pos) )
    DB_PatchMem_ValidatePostloadStream(streamStart, varTransientFileReference, 0x10ui64);
  if ( streamStart != NotAtStart )
    DB_IncStreamPos(0x10ui64);
  v2 = varXString;
  varXString = &varTransientFileReference->name;
  Postload_XString(NotAtStart);
  varXString = v2;
}

/*
==============
Postload_TransientFileReferenceArray
==============
*/
void Postload_TransientFileReferenceArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  TransientFileReference *i; 
  TransientFileReference *v4; 
  const char **v5; 

  v2 = count;
  Postload_Stream_10(streamStart, varTransientFileReference, 16 * count);
  for ( i = varTransientFileReference; v2; --v2 )
  {
    v4 = i;
    varTransientFileReference = i;
    if ( i == (TransientFileReference *)g_streamPosGlob.pos )
    {
      DB_PatchMem_ValidatePostloadStream(NotAtStart, i, 0x10ui64);
      v4 = varTransientFileReference;
    }
    v5 = varXString;
    varXString = &v4->name;
    Postload_XString(NotAtStart);
    ++i;
    varXString = v5;
  }
}

/*
==============
Postload_TransientFileReferenceStream
==============
*/
void Postload_TransientFileReferenceStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *v3; 
  unsigned __int8 *pos; 
  const char **v5; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 4932, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    v3 = (unsigned __int8 *)varTransientFileReference;
    pos = g_streamPosGlob.pos;
    do
    {
      if ( v3 != pos )
      {
        DB_PatchMem_ValidatePostloadStream(AtStart, v3, 0x10ui64);
        pos = g_streamPosGlob.pos;
      }
      if ( !pos && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_stream.h", 181, ASSERT_TYPE_ASSERT, "(g_streamPosGlob.pos)", (const char *)&queryFormat, "g_streamPosGlob.pos") )
        __debugbreak();
      DB_CheckCanIncStreamPos(0x10ui64);
      v5 = varXString;
      g_streamPosGlob.pos += 16;
      varXString = &varTransientFileReference->name;
      Postload_XString(NotAtStart);
      pos = g_streamPosGlob.pos;
      varTransientFileReference = (TransientFileReference *)g_streamPosGlob.pos;
      v3 = g_streamPosGlob.pos;
      varXString = v5;
      --count;
    }
    while ( count );
  }
}

/*
==============
Postload_TransientInfo
==============
*/
void Postload_TransientInfo(const DBStreamStart streamStart)
{
  TransientSets *v2; 
  TransientCosts *v3; 
  TransientInfo *v4; 
  ForcedStubAssetReference *v5; 
  __int64 forcedStubAssetCount; 
  unsigned __int64 v7; 
  ForcedStubAssetReference *i; 
  ForcedStubAssetReference *v9; 
  const char **v10; 
  TransientInfo *v11; 
  TransientFileReference *v12; 
  __int64 transientFileCount; 
  unsigned __int64 v14; 
  TransientFileReference *j; 
  TransientFileReference *v16; 
  const char **v17; 
  TransientInfo *v18; 
  TransientAssetReference *v19; 
  __int64 transientAssetCount; 
  unsigned __int64 v21; 
  TransientAssetReference *k; 
  TransientAssetReference *v23; 
  const char **v24; 
  TransientInfo *v25; 
  TransientWorldGridTileMap *v26; 
  __int64 transientWorldGridTileMapCount; 
  TransientWorldGridTileMap *m; 
  TransientWorldGridTileMap *v29; 
  unsigned __int16 *v30; 
  unsigned __int16 *v31; 
  TransientInfo *v32; 
  SpatialPartition_Tree *v33; 
  SpatialPartition_Tree *v34; 
  TransientInfo *v35; 
  Bounds *v36; 
  Bounds *v37; 
  TransientInfo *v38; 
  unsigned __int16 *v39; 
  unsigned __int16 *v40; 
  bitarray_dynamic *v41; 
  bitarray_dynamic *p_transientSkipLoading; 
  unsigned int *v43; 
  unsigned int *v44; 

  if ( streamStart != (varTransientInfo != (TransientInfo *)g_streamPosGlob.pos) )
    DB_PatchMem_ValidatePostloadStream(streamStart, varTransientInfo, 0xD8ui64);
  if ( streamStart != NotAtStart )
    DB_IncStreamPos(0xD8ui64);
  v2 = varTransientSets;
  varTransientSets = &varTransientInfo->transientSets;
  Postload_TransientSets(NotAtStart);
  varTransientSets = v2;
  v3 = varTransientCosts;
  varTransientCosts = &varTransientInfo->transientCosts;
  Postload_TransientCosts(NotAtStart);
  varTransientCosts = v3;
  v4 = varTransientInfo;
  if ( varTransientInfo->forcedStubAssets )
  {
    v5 = varForcedStubAssetReference;
    DB_PatchMem_FixStreamAlignment(7ui64);
    DB_CheckCanIncStreamPos(0i64);
    v4->forcedStubAssets = (ForcedStubAssetReference *)g_streamPosGlob.pos;
    varForcedStubAssetReference = (ForcedStubAssetReference *)g_streamPosGlob.pos;
    forcedStubAssetCount = varTransientInfo->forcedStubAssetCount;
    v7 = 16 * forcedStubAssetCount;
    if ( 16 * forcedStubAssetCount )
    {
      if ( v7 > 0x7FFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_preload_inline.h", 98, ASSERT_TYPE_ASSERT, "(size <= 2147483647i32)", (const char *)&queryFormat, "size <= INT32_MAX") )
        __debugbreak();
      DB_IncStreamPos(v7);
    }
    for ( i = varForcedStubAssetReference; forcedStubAssetCount; --forcedStubAssetCount )
    {
      v9 = i;
      varForcedStubAssetReference = i;
      if ( i == (ForcedStubAssetReference *)g_streamPosGlob.pos )
      {
        DB_PatchMem_ValidatePostloadStream(NotAtStart, i, 0x10ui64);
        v9 = varForcedStubAssetReference;
      }
      v10 = varXString;
      varXString = &v9->name;
      Postload_XString(NotAtStart);
      ++i;
      varXString = v10;
    }
    varForcedStubAssetReference = v5;
  }
  v11 = varTransientInfo;
  if ( varTransientInfo->transientFiles )
  {
    v12 = varTransientFileReference;
    DB_PatchMem_FixStreamAlignment(7ui64);
    DB_CheckCanIncStreamPos(0i64);
    v11->transientFiles = (TransientFileReference *)g_streamPosGlob.pos;
    varTransientFileReference = (TransientFileReference *)g_streamPosGlob.pos;
    transientFileCount = varTransientInfo->transientFileCount;
    v14 = 16 * transientFileCount;
    if ( 16 * transientFileCount )
    {
      if ( v14 > 0x7FFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_preload_inline.h", 98, ASSERT_TYPE_ASSERT, "(size <= 2147483647i32)", (const char *)&queryFormat, "size <= INT32_MAX") )
        __debugbreak();
      DB_IncStreamPos(v14);
    }
    for ( j = varTransientFileReference; transientFileCount; --transientFileCount )
    {
      v16 = j;
      varTransientFileReference = j;
      if ( j == (TransientFileReference *)g_streamPosGlob.pos )
      {
        DB_PatchMem_ValidatePostloadStream(NotAtStart, j, 0x10ui64);
        v16 = varTransientFileReference;
      }
      v17 = varXString;
      varXString = &v16->name;
      Postload_XString(NotAtStart);
      ++j;
      varXString = v17;
    }
    varTransientFileReference = v12;
  }
  v18 = varTransientInfo;
  if ( varTransientInfo->transientAssets )
  {
    v19 = varTransientAssetReference;
    DB_PatchMem_FixStreamAlignment(7ui64);
    DB_CheckCanIncStreamPos(0i64);
    v18->transientAssets = (TransientAssetReference *)g_streamPosGlob.pos;
    varTransientAssetReference = (TransientAssetReference *)g_streamPosGlob.pos;
    transientAssetCount = varTransientInfo->transientAssetCount;
    v21 = 16 * transientAssetCount;
    if ( 16 * transientAssetCount )
    {
      if ( v21 > 0x7FFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_preload_inline.h", 98, ASSERT_TYPE_ASSERT, "(size <= 2147483647i32)", (const char *)&queryFormat, "size <= INT32_MAX") )
        __debugbreak();
      DB_IncStreamPos(v21);
    }
    for ( k = varTransientAssetReference; transientAssetCount; --transientAssetCount )
    {
      v23 = k;
      varTransientAssetReference = k;
      if ( k == (TransientAssetReference *)g_streamPosGlob.pos )
      {
        DB_PatchMem_ValidatePostloadStream(NotAtStart, k, 0x10ui64);
        v23 = varTransientAssetReference;
      }
      v24 = varXString;
      varXString = &v23->name;
      Postload_XString(NotAtStart);
      ++k;
      varXString = v24;
    }
    varTransientAssetReference = v19;
  }
  v25 = varTransientInfo;
  if ( varTransientInfo->transientWorldGridTileMaps )
  {
    v26 = varTransientWorldGridTileMap;
    DB_PatchMem_FixStreamAlignment(7ui64);
    DB_CheckCanIncStreamPos(0i64);
    v25->transientWorldGridTileMaps = (TransientWorldGridTileMap *)g_streamPosGlob.pos;
    varTransientWorldGridTileMap = (TransientWorldGridTileMap *)g_streamPosGlob.pos;
    transientWorldGridTileMapCount = varTransientInfo->transientWorldGridTileMapCount;
    if ( 40 * transientWorldGridTileMapCount )
    {
      if ( (unsigned __int64)(40 * transientWorldGridTileMapCount) > 0x7FFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_preload_inline.h", 98, ASSERT_TYPE_ASSERT, "(size <= 2147483647i32)", (const char *)&queryFormat, "size <= INT32_MAX") )
        __debugbreak();
      DB_IncStreamPos(40 * transientWorldGridTileMapCount);
    }
    for ( m = varTransientWorldGridTileMap; transientWorldGridTileMapCount; --transientWorldGridTileMapCount )
    {
      v29 = m;
      varTransientWorldGridTileMap = m;
      if ( m == (TransientWorldGridTileMap *)g_streamPosGlob.pos )
      {
        DB_PatchMem_ValidatePostloadStream(NotAtStart, m, 0x28ui64);
        v29 = varTransientWorldGridTileMap;
      }
      if ( v29->spaceToTransientIndex )
      {
        v30 = varushort;
        v31 = AllocPostload_ushort();
        v29->spaceToTransientIndex = v31;
        varushort = v31;
        Postload_ushortArray(AtStart, varTransientWorldGridTileMap->indexCount);
        varushort = v30;
      }
      ++m;
    }
    varTransientWorldGridTileMap = v26;
  }
  v32 = varTransientInfo;
  if ( varTransientInfo->transientWorldGridSpatial )
  {
    v33 = varSpatialPartition_Tree;
    v34 = AllocPostload_SpatialPartition_Tree();
    v32->transientWorldGridSpatial = v34;
    varSpatialPartition_Tree = v34;
    Postload_SpatialPartition_Tree(AtStart);
    varSpatialPartition_Tree = v33;
  }
  v35 = varTransientInfo;
  if ( varTransientInfo->transientWorldGridBounds )
  {
    v36 = varBounds;
    v37 = AllocPostload_Bounds();
    v35->transientWorldGridBounds = v37;
    varBounds = v37;
    Postload_BoundsArray(AtStart, varTransientInfo->transientWorldGridBoundsCount);
    varBounds = v36;
  }
  v38 = varTransientInfo;
  if ( varTransientInfo->transientWorldGridHighLodLookup )
  {
    v39 = varushort;
    v40 = AllocPostload_ushort();
    v38->transientWorldGridHighLodLookup = v40;
    varushort = v40;
    Postload_ushortArray(AtStart, varTransientInfo->transientWorldGridHighLodLookupCount);
    varushort = v39;
  }
  v41 = varTransientInfo_Bitarray;
  p_transientSkipLoading = &varTransientInfo->transientSkipLoading;
  varTransientInfo_Bitarray = &varTransientInfo->transientSkipLoading;
  if ( &varTransientInfo->transientSkipLoading == (bitarray_dynamic *)g_streamPosGlob.pos )
  {
    DB_PatchMem_ValidatePostloadStream(NotAtStart, &varTransientInfo->transientSkipLoading, 0x10ui64);
    p_transientSkipLoading = varTransientInfo_Bitarray;
  }
  if ( p_transientSkipLoading->array )
  {
    v43 = varuint;
    v44 = AllocPostload_uint();
    p_transientSkipLoading->array = v44;
    varuint = v44;
    Postload_uintArray(AtStart, varTransientInfo_Bitarray->wordCount);
    varuint = v43;
  }
  varTransientInfo_Bitarray = v41;
}

/*
==============
Postload_TransientInfoArray
==============
*/
void Postload_TransientInfoArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  TransientInfo *i; 

  v2 = count;
  Postload_Stream_10(streamStart, varTransientInfo, 216 * count);
  for ( i = varTransientInfo; v2; --v2 )
  {
    varTransientInfo = i;
    Postload_TransientInfo(NotAtStart);
    ++i;
  }
}

/*
==============
Postload_TransientInfoFlags
==============
*/
void Postload_TransientInfoFlags(const DBStreamStart streamStart)
{
  if ( streamStart != (varTransientInfoFlags != (TransientInfoFlags *)g_streamPosGlob.pos) )
    DB_PatchMem_ValidatePostloadStream(streamStart, varTransientInfoFlags, 1ui64);
  if ( streamStart != NotAtStart )
    DB_IncStreamPos(1ui64);
}

/*
==============
Postload_TransientInfoFlagsArray
==============
*/
void Postload_TransientInfoFlagsArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  Postload_Stream_10(streamStart, varTransientInfoFlags, count);
}

/*
==============
Postload_TransientInfoFlagsStream
==============
*/
void Postload_TransientInfoFlagsStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  TransientInfoFlags *v3; 
  unsigned __int8 *pos; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 5984, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    v3 = varTransientInfoFlags;
    pos = g_streamPosGlob.pos;
    do
    {
      if ( v3 != (TransientInfoFlags *)pos )
      {
        DB_PatchMem_ValidatePostloadStream(AtStart, v3, 1ui64);
        pos = g_streamPosGlob.pos;
      }
      if ( !pos && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_stream.h", 181, ASSERT_TYPE_ASSERT, "(g_streamPosGlob.pos)", (const char *)&queryFormat, "g_streamPosGlob.pos") )
        __debugbreak();
      DB_CheckCanIncStreamPos(1ui64);
      pos = g_streamPosGlob.pos + 1;
      g_streamPosGlob.pos = pos;
      v3 = (TransientInfoFlags *)pos;
      varTransientInfoFlags = (TransientInfoFlags *)pos;
      --count;
    }
    while ( count );
  }
}

/*
==============
Postload_TransientInfoStream
==============
*/
void Postload_TransientInfoStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 6569, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  for ( ; count; --count )
  {
    Postload_TransientInfo(AtStart);
    varTransientInfo = (TransientInfo *)g_streamPosGlob.pos;
  }
}

/*
==============
Postload_TransientInfo_Bitarray
==============
*/
void Postload_TransientInfo_Bitarray(const DBStreamStart streamStart)
{
  bitarray_dynamic *v2; 
  unsigned int *v3; 
  unsigned int *v4; 

  if ( streamStart != (varTransientInfo_Bitarray != (bitarray_dynamic *)g_streamPosGlob.pos) )
    DB_PatchMem_ValidatePostloadStream(streamStart, varTransientInfo_Bitarray, 0x10ui64);
  if ( streamStart != NotAtStart )
    DB_IncStreamPos(0x10ui64);
  v2 = varTransientInfo_Bitarray;
  if ( varTransientInfo_Bitarray->array )
  {
    v3 = varuint;
    v4 = AllocPostload_uint();
    v2->array = v4;
    varuint = v4;
    Postload_uintArray(AtStart, varTransientInfo_Bitarray->wordCount);
    varuint = v3;
  }
}

/*
==============
Postload_TransientInfo_BitarrayArray
==============
*/
void Postload_TransientInfo_BitarrayArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  bitarray_dynamic *i; 
  bitarray_dynamic *v4; 
  unsigned int *v5; 
  unsigned int *v6; 

  v2 = count;
  Postload_Stream_10(streamStart, varTransientInfo_Bitarray, 16 * count);
  for ( i = varTransientInfo_Bitarray; v2; --v2 )
  {
    v4 = i;
    varTransientInfo_Bitarray = i;
    if ( i == (bitarray_dynamic *)g_streamPosGlob.pos )
    {
      DB_PatchMem_ValidatePostloadStream(NotAtStart, i, 0x10ui64);
      v4 = varTransientInfo_Bitarray;
    }
    if ( v4->array )
    {
      v5 = varuint;
      v6 = AllocPostload_uint();
      v4->array = v6;
      varuint = v6;
      Postload_uintArray(AtStart, varTransientInfo_Bitarray->wordCount);
      varuint = v5;
    }
    ++i;
  }
}

/*
==============
Postload_TransientInfo_BitarrayStream
==============
*/
void Postload_TransientInfo_BitarrayStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  bitarray_dynamic *v3; 
  unsigned __int8 *pos; 
  bitarray_dynamic *v5; 
  unsigned int *v6; 
  unsigned int *v7; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 5908, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    v3 = varTransientInfo_Bitarray;
    pos = g_streamPosGlob.pos;
    do
    {
      if ( v3 != (bitarray_dynamic *)pos )
      {
        DB_PatchMem_ValidatePostloadStream(AtStart, v3, 0x10ui64);
        pos = g_streamPosGlob.pos;
      }
      if ( !pos && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_stream.h", 181, ASSERT_TYPE_ASSERT, "(g_streamPosGlob.pos)", (const char *)&queryFormat, "g_streamPosGlob.pos") )
        __debugbreak();
      DB_CheckCanIncStreamPos(0x10ui64);
      v5 = varTransientInfo_Bitarray;
      pos = g_streamPosGlob.pos + 16;
      g_streamPosGlob.pos += 16;
      if ( varTransientInfo_Bitarray->array )
      {
        v6 = varuint;
        v7 = AllocPostload_uint();
        v5->array = v7;
        varuint = v7;
        Postload_uintArray(AtStart, varTransientInfo_Bitarray->wordCount);
        pos = g_streamPosGlob.pos;
        varuint = v6;
      }
      varTransientInfo_Bitarray = (bitarray_dynamic *)pos;
      v3 = (bitarray_dynamic *)pos;
      --count;
    }
    while ( count );
  }
}

/*
==============
Postload_TransientSets
==============
*/
void Postload_TransientSets(const DBStreamStart streamStart)
{
  TransientSets *v2; 
  const char **v3; 
  const char **v4; 
  TransientSets *v5; 
  bitarray<32> *v6; 
  unsigned __int64 v7; 

  if ( streamStart != (varTransientSets != (TransientSets *)g_streamPosGlob.pos) )
    DB_PatchMem_ValidatePostloadStream(streamStart, varTransientSets, 0x18ui64);
  if ( streamStart != NotAtStart )
    DB_IncStreamPos(0x18ui64);
  v2 = varTransientSets;
  if ( varTransientSets->names )
  {
    v3 = varXString;
    v4 = AllocPostload_XString();
    v2->names = v4;
    varXString = v4;
    Postload_XStringArray(AtStart, varTransientSets->count);
    varXString = v3;
  }
  v5 = varTransientSets;
  if ( varTransientSets->masks )
  {
    v6 = vartransientSPWorldBitArray_t;
    DB_PatchMem_FixStreamAlignment(3ui64);
    DB_CheckCanIncStreamPos(0i64);
    v5->masks = (bitarray<32> *)g_streamPosGlob.pos;
    vartransientSPWorldBitArray_t = (bitarray<32> *)g_streamPosGlob.pos;
    v7 = 4i64 * varTransientSets->count;
    if ( v7 )
    {
      if ( v7 > 0x7FFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_preload_inline.h", 98, ASSERT_TYPE_ASSERT, "(size <= 2147483647i32)", (const char *)&queryFormat, "size <= INT32_MAX") )
        __debugbreak();
      DB_IncStreamPos(v7);
    }
    vartransientSPWorldBitArray_t = v6;
  }
}

/*
==============
Postload_TransientSetsArray
==============
*/
void Postload_TransientSetsArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  TransientSets *i; 

  v2 = count;
  Postload_Stream_10(streamStart, varTransientSets, 24 * count);
  for ( i = varTransientSets; v2; --v2 )
  {
    varTransientSets = i;
    Postload_TransientSets(NotAtStart);
    ++i;
  }
}

/*
==============
Postload_TransientSetsStream
==============
*/
void Postload_TransientSetsStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *pos; 
  TransientSets *v4; 
  const char **v5; 
  const char **v6; 
  bitarray<32> *v7; 
  unsigned __int64 v8; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 5060, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    pos = (unsigned __int8 *)varTransientSets;
    do
    {
      if ( pos != g_streamPosGlob.pos )
        DB_PatchMem_ValidatePostloadStream(AtStart, pos, 0x18ui64);
      if ( !g_streamPosGlob.pos && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_stream.h", 181, ASSERT_TYPE_ASSERT, "(g_streamPosGlob.pos)", (const char *)&queryFormat, "g_streamPosGlob.pos") )
        __debugbreak();
      DB_CheckCanIncStreamPos(0x18ui64);
      v4 = varTransientSets;
      g_streamPosGlob.pos += 24;
      if ( varTransientSets->names )
      {
        v5 = varXString;
        v6 = AllocPostload_XString();
        v4->names = v6;
        varXString = v6;
        Postload_XStringArray(AtStart, varTransientSets->count);
        v4 = varTransientSets;
        varXString = v5;
      }
      if ( v4->masks )
      {
        v7 = vartransientSPWorldBitArray_t;
        DB_PatchMem_FixStreamAlignment(3ui64);
        DB_CheckCanIncStreamPos(0i64);
        v4->masks = (bitarray<32> *)g_streamPosGlob.pos;
        vartransientSPWorldBitArray_t = (bitarray<32> *)g_streamPosGlob.pos;
        v8 = 4i64 * varTransientSets->count;
        if ( v8 )
        {
          if ( v8 > 0x7FFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_preload_inline.h", 98, ASSERT_TYPE_ASSERT, "(size <= 2147483647i32)", (const char *)&queryFormat, "size <= INT32_MAX") )
            __debugbreak();
          DB_IncStreamPos(v8);
        }
        vartransientSPWorldBitArray_t = v7;
      }
      pos = g_streamPosGlob.pos;
      varTransientSets = (TransientSets *)g_streamPosGlob.pos;
      --count;
    }
    while ( count );
  }
}

/*
==============
Postload_TransientWorldGridTileMap
==============
*/
void Postload_TransientWorldGridTileMap(const DBStreamStart streamStart)
{
  TransientWorldGridTileMap *v2; 
  unsigned __int16 *v3; 
  unsigned __int16 *v4; 

  if ( streamStart != (varTransientWorldGridTileMap != (TransientWorldGridTileMap *)g_streamPosGlob.pos) )
    DB_PatchMem_ValidatePostloadStream(streamStart, varTransientWorldGridTileMap, 0x28ui64);
  if ( streamStart != NotAtStart )
    DB_IncStreamPos(0x28ui64);
  v2 = varTransientWorldGridTileMap;
  if ( varTransientWorldGridTileMap->spaceToTransientIndex )
  {
    v3 = varushort;
    v4 = AllocPostload_ushort();
    v2->spaceToTransientIndex = v4;
    varushort = v4;
    Postload_ushortArray(AtStart, varTransientWorldGridTileMap->indexCount);
    varushort = v3;
  }
}

/*
==============
Postload_TransientWorldGridTileMapArray
==============
*/
void Postload_TransientWorldGridTileMapArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  TransientWorldGridTileMap *i; 
  TransientWorldGridTileMap *v4; 
  unsigned __int16 *v5; 
  unsigned __int16 *v6; 

  v2 = count;
  Postload_Stream_10(streamStart, varTransientWorldGridTileMap, 40 * count);
  for ( i = varTransientWorldGridTileMap; v2; --v2 )
  {
    v4 = i;
    varTransientWorldGridTileMap = i;
    if ( i == (TransientWorldGridTileMap *)g_streamPosGlob.pos )
    {
      DB_PatchMem_ValidatePostloadStream(NotAtStart, i, 0x28ui64);
      v4 = varTransientWorldGridTileMap;
    }
    if ( v4->spaceToTransientIndex )
    {
      v5 = varushort;
      v6 = AllocPostload_ushort();
      v4->spaceToTransientIndex = v6;
      varushort = v6;
      Postload_ushortArray(AtStart, varTransientWorldGridTileMap->indexCount);
      varushort = v5;
    }
    ++i;
  }
}

/*
==============
Postload_TransientWorldGridTileMapStream
==============
*/
void Postload_TransientWorldGridTileMapStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  TransientWorldGridTileMap *v3; 
  unsigned __int8 *pos; 
  TransientWorldGridTileMap *v5; 
  unsigned __int16 *v6; 
  unsigned __int16 *v7; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 5323, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    v3 = varTransientWorldGridTileMap;
    pos = g_streamPosGlob.pos;
    do
    {
      if ( v3 != (TransientWorldGridTileMap *)pos )
      {
        DB_PatchMem_ValidatePostloadStream(AtStart, v3, 0x28ui64);
        pos = g_streamPosGlob.pos;
      }
      if ( !pos && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_stream.h", 181, ASSERT_TYPE_ASSERT, "(g_streamPosGlob.pos)", (const char *)&queryFormat, "g_streamPosGlob.pos") )
        __debugbreak();
      DB_CheckCanIncStreamPos(0x28ui64);
      v5 = varTransientWorldGridTileMap;
      pos = g_streamPosGlob.pos + 40;
      g_streamPosGlob.pos += 40;
      if ( varTransientWorldGridTileMap->spaceToTransientIndex )
      {
        v6 = varushort;
        v7 = AllocPostload_ushort();
        v5->spaceToTransientIndex = v7;
        varushort = v7;
        Postload_ushortArray(AtStart, varTransientWorldGridTileMap->indexCount);
        pos = g_streamPosGlob.pos;
        varushort = v6;
      }
      varTransientWorldGridTileMap = (TransientWorldGridTileMap *)pos;
      v3 = (TransientWorldGridTileMap *)pos;
      --count;
    }
    while ( count );
  }
}

/*
==============
Postload_transientSPWorldBitArray_t
==============
*/
void Postload_transientSPWorldBitArray_t(const DBStreamStart streamStart)
{
  if ( streamStart != (vartransientSPWorldBitArray_t != (bitarray<32> *)g_streamPosGlob.pos) )
    DB_PatchMem_ValidatePostloadStream(streamStart, vartransientSPWorldBitArray_t, 4ui64);
  if ( streamStart != NotAtStart )
    DB_IncStreamPos(4ui64);
}

/*
==============
Postload_transientSPWorldBitArray_tArray
==============
*/
void Postload_transientSPWorldBitArray_tArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  Postload_Stream_10(streamStart, vartransientSPWorldBitArray_t, 4 * count);
}

/*
==============
Postload_transientSPWorldBitArray_tStream
==============
*/
void Postload_transientSPWorldBitArray_tStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  bitarray<32> *v3; 
  unsigned __int8 *pos; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 4199, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    v3 = vartransientSPWorldBitArray_t;
    pos = g_streamPosGlob.pos;
    do
    {
      if ( v3 != (bitarray<32> *)pos )
      {
        DB_PatchMem_ValidatePostloadStream(AtStart, v3, 4ui64);
        pos = g_streamPosGlob.pos;
      }
      if ( !pos && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\database\\db_stream.h", 181, ASSERT_TYPE_ASSERT, "(g_streamPosGlob.pos)", (const char *)&queryFormat, "g_streamPosGlob.pos") )
        __debugbreak();
      DB_CheckCanIncStreamPos(4ui64);
      pos = g_streamPosGlob.pos + 4;
      g_streamPosGlob.pos = pos;
      v3 = (bitarray<32> *)pos;
      vartransientSPWorldBitArray_t = (bitarray<32> *)pos;
      --count;
    }
    while ( count );
  }
}

/*
==============
Preload_AlwaysloadedFlagSet
==============
*/
void Preload_AlwaysloadedFlagSet(const DBStreamStart streamStart)
{
  AlwaysloadedFlags *v1; 
  AlwaysloadedFlagSet *v2; 
  AlwaysloadedFlagsPerModel *v3; 
  __int64 modelCount; 
  AlwaysloadedFlagsPerModel *i; 
  XModel **v6; 
  AlwaysloadedFlags *v7; 
  XModelSurfs **v8; 

  Load_Stream(streamStart, varAlwaysloadedFlagSet, 0x38ui64);
  v1 = varAlwaysloadedFlags;
  varAlwaysloadedFlags = &varAlwaysloadedFlagSet->globalFlags;
  Preload_AlwaysloadedFlags(NotAtStart);
  v2 = varAlwaysloadedFlagSet;
  varAlwaysloadedFlags = v1;
  if ( varAlwaysloadedFlagSet->perModelFlags )
  {
    v3 = varAlwaysloadedFlagsPerModel;
    DB_PatchMem_FixStreamAlignment(7ui64);
    DB_CheckCanIncStreamPos(0i64);
    varAlwaysloadedFlagsPerModel = (AlwaysloadedFlagsPerModel *)g_streamPosGlob.pos;
    modelCount = varAlwaysloadedFlagSet->modelCount;
    Load_Stream(AtStart, g_streamPosGlob.pos, 32 * modelCount);
    for ( i = varAlwaysloadedFlagsPerModel; modelCount; --modelCount )
    {
      varAlwaysloadedFlagsPerModel = i;
      Load_Stream(NotAtStart, i, 0x20ui64);
      v6 = varXModelPtr;
      varXModelPtr = &varAlwaysloadedFlagsPerModel->model;
      Preload_XModelPtr(NotAtStart);
      varXModelPtr = v6;
      v7 = varAlwaysloadedFlags;
      varAlwaysloadedFlags = &varAlwaysloadedFlagsPerModel->flags;
      Preload_AlwaysloadedFlags(NotAtStart);
      ++i;
      varAlwaysloadedFlags = v7;
    }
    v2 = varAlwaysloadedFlagSet;
    varAlwaysloadedFlagsPerModel = v3;
  }
  if ( v2->modelSurfs )
  {
    v8 = varXModelSurfsPtr;
    varXModelSurfsPtr = AllocPreload_XModelSurfsPtr();
    Preload_XModelSurfsPtrArray(AtStart, varAlwaysloadedFlagSet->modelSurfCount);
    varXModelSurfsPtr = v8;
  }
}

/*
==============
Preload_AlwaysloadedFlagSetArray
==============
*/
void Preload_AlwaysloadedFlagSetArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  AlwaysloadedFlagSet *i; 
  AlwaysloadedFlags *v4; 
  AlwaysloadedFlagSet *v5; 
  AlwaysloadedFlagsPerModel *v6; 
  __int64 modelCount; 
  AlwaysloadedFlagsPerModel *j; 
  XModel **v9; 
  AlwaysloadedFlags *v10; 
  XModelSurfs **v11; 

  v2 = count;
  Load_Stream(streamStart, varAlwaysloadedFlagSet, 56 * count);
  for ( i = varAlwaysloadedFlagSet; v2; --v2 )
  {
    varAlwaysloadedFlagSet = i;
    Load_Stream(NotAtStart, i, 0x38ui64);
    v4 = varAlwaysloadedFlags;
    varAlwaysloadedFlags = &varAlwaysloadedFlagSet->globalFlags;
    Preload_AlwaysloadedFlags(NotAtStart);
    v5 = varAlwaysloadedFlagSet;
    varAlwaysloadedFlags = v4;
    if ( varAlwaysloadedFlagSet->perModelFlags )
    {
      v6 = varAlwaysloadedFlagsPerModel;
      DB_PatchMem_FixStreamAlignment(7ui64);
      DB_CheckCanIncStreamPos(0i64);
      varAlwaysloadedFlagsPerModel = (AlwaysloadedFlagsPerModel *)g_streamPosGlob.pos;
      modelCount = varAlwaysloadedFlagSet->modelCount;
      Load_Stream(AtStart, g_streamPosGlob.pos, 32 * modelCount);
      for ( j = varAlwaysloadedFlagsPerModel; modelCount; --modelCount )
      {
        varAlwaysloadedFlagsPerModel = j;
        Load_Stream(NotAtStart, j, 0x20ui64);
        v9 = varXModelPtr;
        varXModelPtr = &varAlwaysloadedFlagsPerModel->model;
        Preload_XModelPtr(NotAtStart);
        varXModelPtr = v9;
        v10 = varAlwaysloadedFlags;
        varAlwaysloadedFlags = &varAlwaysloadedFlagsPerModel->flags;
        Preload_AlwaysloadedFlags(NotAtStart);
        ++j;
        varAlwaysloadedFlags = v10;
      }
      v5 = varAlwaysloadedFlagSet;
      varAlwaysloadedFlagsPerModel = v6;
    }
    if ( v5->modelSurfs )
    {
      v11 = varXModelSurfsPtr;
      varXModelSurfsPtr = AllocPreload_XModelSurfsPtr();
      Preload_XModelSurfsPtrArray(AtStart, varAlwaysloadedFlagSet->modelSurfCount);
      varXModelSurfsPtr = v11;
    }
    ++i;
  }
}

/*
==============
Preload_AlwaysloadedFlagSetStream
==============
*/
void Preload_AlwaysloadedFlagSetStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *pos; 
  AlwaysloadedFlags *v4; 
  AlwaysloadedFlagSet *v5; 
  AlwaysloadedFlagsPerModel *v6; 
  __int64 modelCount; 
  AlwaysloadedFlagsPerModel *i; 
  XModel **v9; 
  AlwaysloadedFlags *v10; 
  XModelSurfs **v11; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 7242, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    pos = (unsigned __int8 *)varAlwaysloadedFlagSet;
    do
    {
      Load_Stream(AtStart, pos, 0x38ui64);
      v4 = varAlwaysloadedFlags;
      varAlwaysloadedFlags = &varAlwaysloadedFlagSet->globalFlags;
      Preload_AlwaysloadedFlags(NotAtStart);
      v5 = varAlwaysloadedFlagSet;
      varAlwaysloadedFlags = v4;
      if ( varAlwaysloadedFlagSet->perModelFlags )
      {
        v6 = varAlwaysloadedFlagsPerModel;
        DB_PatchMem_FixStreamAlignment(7ui64);
        DB_CheckCanIncStreamPos(0i64);
        varAlwaysloadedFlagsPerModel = (AlwaysloadedFlagsPerModel *)g_streamPosGlob.pos;
        modelCount = varAlwaysloadedFlagSet->modelCount;
        Load_Stream(AtStart, g_streamPosGlob.pos, 32 * modelCount);
        for ( i = varAlwaysloadedFlagsPerModel; modelCount; --modelCount )
        {
          varAlwaysloadedFlagsPerModel = i;
          Load_Stream(NotAtStart, i, 0x20ui64);
          v9 = varXModelPtr;
          varXModelPtr = &varAlwaysloadedFlagsPerModel->model;
          Preload_XModelPtr(NotAtStart);
          varXModelPtr = v9;
          v10 = varAlwaysloadedFlags;
          varAlwaysloadedFlags = &varAlwaysloadedFlagsPerModel->flags;
          Preload_AlwaysloadedFlags(NotAtStart);
          ++i;
          varAlwaysloadedFlags = v10;
        }
        v5 = varAlwaysloadedFlagSet;
        varAlwaysloadedFlagsPerModel = v6;
      }
      if ( v5->modelSurfs )
      {
        v11 = varXModelSurfsPtr;
        varXModelSurfsPtr = AllocPreload_XModelSurfsPtr();
        Preload_XModelSurfsPtrArray(AtStart, varAlwaysloadedFlagSet->modelSurfCount);
        varXModelSurfsPtr = v11;
      }
      pos = g_streamPosGlob.pos;
      varAlwaysloadedFlagSet = (AlwaysloadedFlagSet *)g_streamPosGlob.pos;
      --count;
    }
    while ( count );
  }
}

/*
==============
Preload_AlwaysloadedFlags
==============
*/
void Preload_AlwaysloadedFlags(const DBStreamStart streamStart)
{
  AlwaysloadedFlags *v1; 
  GfxImage **v2; 
  __int64 imageCount; 
  GfxImage **i; 
  unsigned int *v5; 
  unsigned int v6; 

  Load_Stream(streamStart, varAlwaysloadedFlags, 0x18ui64);
  v1 = varAlwaysloadedFlags;
  if ( varAlwaysloadedFlags->images )
  {
    v2 = varGfxImagePtr;
    DB_PatchMem_FixStreamAlignment(7ui64);
    DB_CheckCanIncStreamPos(0i64);
    varGfxImagePtr = (GfxImage **)g_streamPosGlob.pos;
    imageCount = varAlwaysloadedFlags->imageCount;
    Load_Stream(AtStart, g_streamPosGlob.pos, 8 * imageCount);
    for ( i = varGfxImagePtr; imageCount; --imageCount )
    {
      varGfxImagePtr = i;
      Preload_GfxImagePtr(NotAtStart);
      ++i;
    }
    v1 = varAlwaysloadedFlags;
    varGfxImagePtr = v2;
  }
  if ( v1->imageFlags )
  {
    v5 = varuint;
    varuint = AllocPreload_uint();
    v6 = DB_StreamingInfo_CalcUIntsForImageFlags(varAlwaysloadedFlags->imageCount);
    Preload_uintArray(AtStart, v6);
    varuint = v5;
  }
}

/*
==============
Preload_AlwaysloadedFlagsArray
==============
*/
void Preload_AlwaysloadedFlagsArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  AlwaysloadedFlags *i; 
  AlwaysloadedFlags *v4; 
  GfxImage **v5; 
  __int64 imageCount; 
  GfxImage **j; 
  unsigned int *v8; 
  unsigned int v9; 

  v2 = count;
  Load_Stream(streamStart, varAlwaysloadedFlags, 24 * count);
  for ( i = varAlwaysloadedFlags; v2; --v2 )
  {
    varAlwaysloadedFlags = i;
    Load_Stream(NotAtStart, i, 0x18ui64);
    v4 = varAlwaysloadedFlags;
    if ( varAlwaysloadedFlags->images )
    {
      v5 = varGfxImagePtr;
      DB_PatchMem_FixStreamAlignment(7ui64);
      DB_CheckCanIncStreamPos(0i64);
      varGfxImagePtr = (GfxImage **)g_streamPosGlob.pos;
      imageCount = varAlwaysloadedFlags->imageCount;
      Load_Stream(AtStart, g_streamPosGlob.pos, 8 * imageCount);
      for ( j = varGfxImagePtr; imageCount; --imageCount )
      {
        varGfxImagePtr = j;
        Preload_GfxImagePtr(NotAtStart);
        ++j;
      }
      v4 = varAlwaysloadedFlags;
      varGfxImagePtr = v5;
    }
    if ( v4->imageFlags )
    {
      v8 = varuint;
      varuint = AllocPreload_uint();
      v9 = DB_StreamingInfo_CalcUIntsForImageFlags(varAlwaysloadedFlags->imageCount);
      Preload_uintArray(AtStart, v9);
      varuint = v8;
    }
    ++i;
  }
}

/*
==============
Preload_AlwaysloadedFlagsPerModel
==============
*/
void Preload_AlwaysloadedFlagsPerModel(const DBStreamStart streamStart)
{
  XModel **v1; 
  AlwaysloadedFlags *v2; 

  Load_Stream(streamStart, varAlwaysloadedFlagsPerModel, 0x20ui64);
  v1 = varXModelPtr;
  varXModelPtr = &varAlwaysloadedFlagsPerModel->model;
  Preload_XModelPtr(NotAtStart);
  varXModelPtr = v1;
  v2 = varAlwaysloadedFlags;
  varAlwaysloadedFlags = &varAlwaysloadedFlagsPerModel->flags;
  Preload_AlwaysloadedFlags(NotAtStart);
  varAlwaysloadedFlags = v2;
}

/*
==============
Preload_AlwaysloadedFlagsPerModelArray
==============
*/
void Preload_AlwaysloadedFlagsPerModelArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  AlwaysloadedFlagsPerModel *i; 
  XModel **v4; 
  AlwaysloadedFlags *v5; 

  v2 = count;
  Load_Stream(streamStart, varAlwaysloadedFlagsPerModel, 32 * count);
  for ( i = varAlwaysloadedFlagsPerModel; v2; --v2 )
  {
    varAlwaysloadedFlagsPerModel = i;
    Load_Stream(NotAtStart, i, 0x20ui64);
    v4 = varXModelPtr;
    varXModelPtr = &varAlwaysloadedFlagsPerModel->model;
    Preload_XModelPtr(NotAtStart);
    varXModelPtr = v4;
    v5 = varAlwaysloadedFlags;
    varAlwaysloadedFlags = &varAlwaysloadedFlagsPerModel->flags;
    Preload_AlwaysloadedFlags(NotAtStart);
    ++i;
    varAlwaysloadedFlags = v5;
  }
}

/*
==============
Preload_AlwaysloadedFlagsPerModelStream
==============
*/
void Preload_AlwaysloadedFlagsPerModelStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *pos; 
  XModel **v4; 
  AlwaysloadedFlags *v5; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 7067, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    pos = (unsigned __int8 *)varAlwaysloadedFlagsPerModel;
    do
    {
      Load_Stream(AtStart, pos, 0x20ui64);
      v4 = varXModelPtr;
      varXModelPtr = &varAlwaysloadedFlagsPerModel->model;
      Preload_XModelPtr(NotAtStart);
      varXModelPtr = v4;
      v5 = varAlwaysloadedFlags;
      varAlwaysloadedFlags = &varAlwaysloadedFlagsPerModel->flags;
      Preload_AlwaysloadedFlags(NotAtStart);
      pos = g_streamPosGlob.pos;
      varAlwaysloadedFlagsPerModel = (AlwaysloadedFlagsPerModel *)g_streamPosGlob.pos;
      varAlwaysloadedFlags = v5;
      --count;
    }
    while ( count );
  }
}

/*
==============
Preload_AlwaysloadedFlagsStream
==============
*/
void Preload_AlwaysloadedFlagsStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *pos; 
  AlwaysloadedFlags *v4; 
  GfxImage **v5; 
  __int64 imageCount; 
  GfxImage **i; 
  unsigned int *v8; 
  unsigned int v9; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 6959, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    pos = (unsigned __int8 *)varAlwaysloadedFlags;
    do
    {
      Load_Stream(AtStart, pos, 0x18ui64);
      v4 = varAlwaysloadedFlags;
      if ( varAlwaysloadedFlags->images )
      {
        v5 = varGfxImagePtr;
        DB_PatchMem_FixStreamAlignment(7ui64);
        DB_CheckCanIncStreamPos(0i64);
        varGfxImagePtr = (GfxImage **)g_streamPosGlob.pos;
        imageCount = varAlwaysloadedFlags->imageCount;
        Load_Stream(AtStart, g_streamPosGlob.pos, 8 * imageCount);
        for ( i = varGfxImagePtr; imageCount; --imageCount )
        {
          varGfxImagePtr = i;
          Preload_GfxImagePtr(NotAtStart);
          ++i;
        }
        v4 = varAlwaysloadedFlags;
        varGfxImagePtr = v5;
      }
      if ( v4->imageFlags )
      {
        v8 = varuint;
        varuint = AllocPreload_uint();
        v9 = DB_StreamingInfo_CalcUIntsForImageFlags(varAlwaysloadedFlags->imageCount);
        Preload_uintArray(AtStart, v9);
        varuint = v8;
      }
      pos = g_streamPosGlob.pos;
      varAlwaysloadedFlags = (AlwaysloadedFlags *)g_streamPosGlob.pos;
      --count;
    }
    while ( count );
  }
}

/*
==============
Preload_ForcedStubAssetReference
==============
*/
void Preload_ForcedStubAssetReference(const DBStreamStart streamStart)
{
  const char **v1; 

  Load_Stream(streamStart, varForcedStubAssetReference, 0x10ui64);
  v1 = varXString;
  varXString = &varForcedStubAssetReference->name;
  Preload_XString(NotAtStart);
  varXString = v1;
}

/*
==============
Preload_ForcedStubAssetReferenceArray
==============
*/
void Preload_ForcedStubAssetReferenceArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  ForcedStubAssetReference *i; 
  const char **v4; 

  v2 = count;
  Load_Stream(streamStart, varForcedStubAssetReference, 16 * count);
  for ( i = varForcedStubAssetReference; v2; --v2 )
  {
    varForcedStubAssetReference = i;
    Load_Stream(NotAtStart, i, 0x10ui64);
    v4 = varXString;
    varXString = &varForcedStubAssetReference->name;
    Preload_XString(NotAtStart);
    ++i;
    varXString = v4;
  }
}

/*
==============
Preload_ForcedStubAssetReferenceStream
==============
*/
void Preload_ForcedStubAssetReferenceStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *pos; 
  const char **v4; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 7341, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    pos = (unsigned __int8 *)varForcedStubAssetReference;
    do
    {
      Load_Stream(AtStart, pos, 0x10ui64);
      v4 = varXString;
      varXString = &varForcedStubAssetReference->name;
      Preload_XString(NotAtStart);
      pos = g_streamPosGlob.pos;
      varForcedStubAssetReference = (ForcedStubAssetReference *)g_streamPosGlob.pos;
      varXString = v4;
      --count;
    }
    while ( count );
  }
}

/*
==============
Preload_StreamingContentSet
==============
*/
void Preload_StreamingContentSet(const DBStreamStart streamStart)
{
  StreamingContentSet *v1; 
  unsigned __int16 *v2; 
  StreamingItemContents *v3; 
  __int64 transientCostCount; 
  StreamingItemContents *i; 
  unsigned __int16 *v6; 
  unsigned int CostItemIndex; 

  Load_Stream(streamStart, varStreamingContentSet, 0x10ui64);
  v1 = varStreamingContentSet;
  if ( varStreamingContentSet->contentCounts )
  {
    v2 = varushort;
    varushort = AllocPreload_ushort();
    Preload_ushortArray(AtStart, varTransientCosts->transientCostCount);
    v1 = varStreamingContentSet;
    varushort = v2;
  }
  if ( v1->contents )
  {
    v3 = varStreamingItemContents;
    DB_PatchMem_FixStreamAlignment(7ui64);
    DB_CheckCanIncStreamPos(0i64);
    varStreamingItemContents = (StreamingItemContents *)g_streamPosGlob.pos;
    transientCostCount = varTransientCosts->transientCostCount;
    Load_Stream(AtStart, g_streamPosGlob.pos, 8 * transientCostCount);
    for ( i = varStreamingItemContents; transientCostCount; --transientCostCount )
    {
      varStreamingItemContents = i;
      Load_Stream(NotAtStart, i, 8ui64);
      if ( varStreamingItemContents->contents )
      {
        v6 = varushort;
        varushort = AllocPreload_ushort();
        CostItemIndex = DB_StreamingInfo_GetCostItemIndex(varTransientCosts, varStreamingContentSet, varStreamingItemContents);
        Preload_ushortArray(AtStart, CostItemIndex);
        varushort = v6;
      }
      ++i;
    }
    varStreamingItemContents = v3;
  }
}

/*
==============
Preload_StreamingContentSetArray
==============
*/
void Preload_StreamingContentSetArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  StreamingContentSet *i; 
  StreamingContentSet *v4; 
  unsigned __int16 *v5; 
  StreamingItemContents *v6; 
  __int64 transientCostCount; 
  StreamingItemContents *j; 
  unsigned __int16 *v9; 
  unsigned int CostItemIndex; 

  v2 = count;
  Load_Stream(streamStart, varStreamingContentSet, 16 * count);
  for ( i = varStreamingContentSet; v2; --v2 )
  {
    varStreamingContentSet = i;
    Load_Stream(NotAtStart, i, 0x10ui64);
    v4 = varStreamingContentSet;
    if ( varStreamingContentSet->contentCounts )
    {
      v5 = varushort;
      varushort = AllocPreload_ushort();
      Preload_ushortArray(AtStart, varTransientCosts->transientCostCount);
      v4 = varStreamingContentSet;
      varushort = v5;
    }
    if ( v4->contents )
    {
      v6 = varStreamingItemContents;
      DB_PatchMem_FixStreamAlignment(7ui64);
      DB_CheckCanIncStreamPos(0i64);
      varStreamingItemContents = (StreamingItemContents *)g_streamPosGlob.pos;
      transientCostCount = varTransientCosts->transientCostCount;
      Load_Stream(AtStart, g_streamPosGlob.pos, 8 * transientCostCount);
      for ( j = varStreamingItemContents; transientCostCount; --transientCostCount )
      {
        varStreamingItemContents = j;
        Load_Stream(NotAtStart, j, 8ui64);
        if ( varStreamingItemContents->contents )
        {
          v9 = varushort;
          varushort = AllocPreload_ushort();
          CostItemIndex = DB_StreamingInfo_GetCostItemIndex(varTransientCosts, varStreamingContentSet, varStreamingItemContents);
          Preload_ushortArray(AtStart, CostItemIndex);
          varushort = v9;
        }
        ++j;
      }
      varStreamingItemContents = v6;
    }
    ++i;
  }
}

/*
==============
Preload_StreamingContentSetStream
==============
*/
void Preload_StreamingContentSetStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *pos; 
  StreamingContentSet *v4; 
  unsigned __int16 *v5; 
  StreamingItemContents *v6; 
  __int64 transientCostCount; 
  StreamingItemContents *i; 
  unsigned __int16 *v9; 
  unsigned int CostItemIndex; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 8207, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    pos = (unsigned __int8 *)varStreamingContentSet;
    do
    {
      Load_Stream(AtStart, pos, 0x10ui64);
      v4 = varStreamingContentSet;
      if ( varStreamingContentSet->contentCounts )
      {
        v5 = varushort;
        varushort = AllocPreload_ushort();
        Preload_ushortArray(AtStart, varTransientCosts->transientCostCount);
        v4 = varStreamingContentSet;
        varushort = v5;
      }
      if ( v4->contents )
      {
        v6 = varStreamingItemContents;
        DB_PatchMem_FixStreamAlignment(7ui64);
        DB_CheckCanIncStreamPos(0i64);
        varStreamingItemContents = (StreamingItemContents *)g_streamPosGlob.pos;
        transientCostCount = varTransientCosts->transientCostCount;
        Load_Stream(AtStart, g_streamPosGlob.pos, 8 * transientCostCount);
        for ( i = varStreamingItemContents; transientCostCount; --transientCostCount )
        {
          varStreamingItemContents = i;
          Load_Stream(NotAtStart, i, 8ui64);
          if ( varStreamingItemContents->contents )
          {
            v9 = varushort;
            varushort = AllocPreload_ushort();
            CostItemIndex = DB_StreamingInfo_GetCostItemIndex(varTransientCosts, varStreamingContentSet, varStreamingItemContents);
            Preload_ushortArray(AtStart, CostItemIndex);
            varushort = v9;
          }
          ++i;
        }
        varStreamingItemContents = v6;
      }
      pos = g_streamPosGlob.pos;
      varStreamingContentSet = (StreamingContentSet *)g_streamPosGlob.pos;
      --count;
    }
    while ( count );
  }
}

/*
==============
Preload_StreamingInfo
==============
*/
void Preload_StreamingInfo(const DBStreamStart streamStart)
{
  const char **v2; 
  AlwaysloadedFlagSet *v3; 
  AlwaysloadedFlagSet *v4; 
  __int64 v5; 
  TransientInfo *v6; 

  DB_PatchMem_PushAsset(63, varStreamingInfo);
  Load_Stream(streamStart, varStreamingInfo, 0xB8ui64);
  DB_PushStreamPos(8u);
  v2 = varXString;
  varXString = &varStreamingInfo->name;
  Preload_XString(NotAtStart);
  v3 = varAlwaysloadedFlagSet;
  varAlwaysloadedFlagSet = varStreamingInfo->alwaysloadedFlagSets;
  varXString = v2;
  Load_Stream(NotAtStart, varStreamingInfo->alwaysloadedFlagSets, 0xA8ui64);
  v4 = varAlwaysloadedFlagSet;
  v5 = 3i64;
  do
  {
    varAlwaysloadedFlagSet = v4;
    Preload_AlwaysloadedFlagSet(NotAtStart);
    ++v4;
    --v5;
  }
  while ( v5 );
  varAlwaysloadedFlagSet = v3;
  if ( varStreamingInfo->transientInfo )
  {
    v6 = varTransientInfo;
    DB_PatchMem_FixStreamAlignment(7ui64);
    DB_CheckCanIncStreamPos(0i64);
    varTransientInfo = (TransientInfo *)g_streamPosGlob.pos;
    Preload_TransientInfo(AtStart);
    varTransientInfo = v6;
  }
  DB_PopStreamPos();
  DB_PatchMem_PopAsset();
}

/*
==============
Preload_StreamingInfoArray
==============
*/
void Preload_StreamingInfoArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  StreamingInfo *i; 
  const char **v4; 
  AlwaysloadedFlagSet *v5; 
  AlwaysloadedFlagSet *v6; 
  __int64 v7; 
  TransientInfo *v8; 

  v2 = count;
  Load_Stream(streamStart, varStreamingInfo, 184 * count);
  for ( i = varStreamingInfo; v2; --v2 )
  {
    varStreamingInfo = i;
    DB_PatchMem_PushAsset(63, i);
    Load_Stream(NotAtStart, varStreamingInfo, 0xB8ui64);
    DB_PushStreamPos(8u);
    v4 = varXString;
    varXString = &varStreamingInfo->name;
    Preload_XString(NotAtStart);
    v5 = varAlwaysloadedFlagSet;
    varAlwaysloadedFlagSet = varStreamingInfo->alwaysloadedFlagSets;
    varXString = v4;
    Load_Stream(NotAtStart, varStreamingInfo->alwaysloadedFlagSets, 0xA8ui64);
    v6 = varAlwaysloadedFlagSet;
    v7 = 3i64;
    do
    {
      varAlwaysloadedFlagSet = v6;
      Preload_AlwaysloadedFlagSet(NotAtStart);
      ++v6;
      --v7;
    }
    while ( v7 );
    varAlwaysloadedFlagSet = v5;
    if ( varStreamingInfo->transientInfo )
    {
      v8 = varTransientInfo;
      DB_PatchMem_FixStreamAlignment(7ui64);
      DB_CheckCanIncStreamPos(0i64);
      varTransientInfo = (TransientInfo *)g_streamPosGlob.pos;
      Preload_TransientInfo(AtStart);
      varTransientInfo = v8;
    }
    DB_PopStreamPos();
    DB_PatchMem_PopAsset();
    ++i;
  }
}

/*
==============
Preload_StreamingInfoPtr
==============
*/
void Preload_StreamingInfoPtr(const DBStreamStart streamStart)
{
  StreamingInfo **v1; 
  __int64 v2; 
  StreamingInfo *v3; 
  unsigned __int8 *inserted; 

  Load_Stream(streamStart, varStreamingInfoPtr, 8ui64);
  DB_PushPreloadProcessing();
  DB_PushStreamPos(1u);
  v1 = varStreamingInfoPtr;
  v2 = (__int64)*varStreamingInfoPtr;
  if ( *varStreamingInfoPtr )
  {
    if ( v2 == -1 )
    {
      DB_PushSharedData();
    }
    else if ( v2 != -2 && v2 != -3 )
    {
      DB_ConvertOffsetToAlias((unsigned __int64 *)varStreamingInfoPtr);
      goto LABEL_13;
    }
    v3 = varStreamingInfo;
    DB_PatchMem_FixStreamAlignment(7ui64);
    DB_CheckCanIncStreamPos(0i64);
    inserted = NULL;
    *v1 = (StreamingInfo *)g_streamPosGlob.pos;
    varStreamingInfo = (StreamingInfo *)g_streamPosGlob.pos;
    if ( v2 == -3 )
      inserted = DB_InsertPointer();
    Load_StreamingInfo(AtStart);
    Load_StreamingInfoAsset(v1);
    varStreamingInfo = v3;
    if ( inserted )
      *(_QWORD *)inserted = *v1;
    if ( v2 == -1 )
      DB_PopSharedData();
  }
LABEL_13:
  DB_PopStreamPos();
  DB_PopPreloadProcessing();
}

/*
==============
Preload_StreamingInfoPtrArray
==============
*/
void Preload_StreamingInfoPtrArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  StreamingInfo **i; 
  StreamingInfo **v4; 
  __int64 v5; 
  StreamingInfo *v6; 
  unsigned __int8 *inserted; 

  v2 = count;
  Load_Stream(streamStart, varStreamingInfoPtr, 8 * count);
  for ( i = varStreamingInfoPtr; v2; --v2 )
  {
    varStreamingInfoPtr = i;
    Load_Stream(NotAtStart, i, 8ui64);
    DB_PushPreloadProcessing();
    DB_PushStreamPos(1u);
    v4 = varStreamingInfoPtr;
    v5 = (__int64)*varStreamingInfoPtr;
    if ( *varStreamingInfoPtr )
    {
      if ( v5 == -1 )
      {
        DB_PushSharedData();
LABEL_8:
        v6 = varStreamingInfo;
        DB_PatchMem_FixStreamAlignment(7ui64);
        DB_CheckCanIncStreamPos(0i64);
        inserted = NULL;
        *v4 = (StreamingInfo *)g_streamPosGlob.pos;
        varStreamingInfo = (StreamingInfo *)g_streamPosGlob.pos;
        if ( v5 == -3 )
          inserted = DB_InsertPointer();
        Load_StreamingInfo(AtStart);
        Load_StreamingInfoAsset(v4);
        varStreamingInfo = v6;
        if ( inserted )
          *(_QWORD *)inserted = *v4;
        if ( v5 == -1 )
          DB_PopSharedData();
        goto LABEL_14;
      }
      if ( v5 == -2 || v5 == -3 )
        goto LABEL_8;
      DB_ConvertOffsetToAlias((unsigned __int64 *)varStreamingInfoPtr);
    }
LABEL_14:
    DB_PopStreamPos();
    DB_PopPreloadProcessing();
    ++i;
  }
}

/*
==============
Preload_StreamingInfoPtrStream
==============
*/
void Preload_StreamingInfoPtrStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *pos; 
  StreamingInfo **v4; 
  __int64 v5; 
  StreamingInfo *v6; 
  unsigned __int8 *inserted; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 9448, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    pos = (unsigned __int8 *)varStreamingInfoPtr;
    do
    {
      Load_Stream(AtStart, pos, 8ui64);
      DB_PushPreloadProcessing();
      DB_PushStreamPos(1u);
      v4 = varStreamingInfoPtr;
      v5 = (__int64)*varStreamingInfoPtr;
      if ( *varStreamingInfoPtr )
      {
        if ( v5 == -1 )
        {
          DB_PushSharedData();
LABEL_12:
          v6 = varStreamingInfo;
          DB_PatchMem_FixStreamAlignment(7ui64);
          DB_CheckCanIncStreamPos(0i64);
          inserted = NULL;
          *v4 = (StreamingInfo *)g_streamPosGlob.pos;
          varStreamingInfo = (StreamingInfo *)g_streamPosGlob.pos;
          if ( v5 == -3 )
            inserted = DB_InsertPointer();
          Load_StreamingInfo(AtStart);
          Load_StreamingInfoAsset(v4);
          varStreamingInfo = v6;
          if ( inserted )
            *(_QWORD *)inserted = *v4;
          if ( v5 == -1 )
            DB_PopSharedData();
          goto LABEL_18;
        }
        if ( v5 == -2 || v5 == -3 )
          goto LABEL_12;
        DB_ConvertOffsetToAlias((unsigned __int64 *)varStreamingInfoPtr);
      }
LABEL_18:
      DB_PopStreamPos();
      DB_PopPreloadProcessing();
      pos = g_streamPosGlob.pos;
      varStreamingInfoPtr = (StreamingInfo **)g_streamPosGlob.pos;
      --count;
    }
    while ( count );
  }
}

/*
==============
Preload_StreamingInfoStream
==============
*/
void Preload_StreamingInfoStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *pos; 
  const char **v4; 
  AlwaysloadedFlagSet *v5; 
  AlwaysloadedFlagSet *v6; 
  __int64 v7; 
  TransientInfo *v8; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 9313, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    pos = (unsigned __int8 *)varStreamingInfo;
    do
    {
      DB_PatchMem_PushAsset(63, pos);
      Load_Stream(AtStart, varStreamingInfo, 0xB8ui64);
      DB_PushStreamPos(8u);
      v4 = varXString;
      varXString = &varStreamingInfo->name;
      Preload_XString(NotAtStart);
      v5 = varAlwaysloadedFlagSet;
      varAlwaysloadedFlagSet = varStreamingInfo->alwaysloadedFlagSets;
      varXString = v4;
      Load_Stream(NotAtStart, varStreamingInfo->alwaysloadedFlagSets, 0xA8ui64);
      v6 = varAlwaysloadedFlagSet;
      v7 = 3i64;
      do
      {
        varAlwaysloadedFlagSet = v6;
        Preload_AlwaysloadedFlagSet(NotAtStart);
        ++v6;
        --v7;
      }
      while ( v7 );
      varAlwaysloadedFlagSet = v5;
      if ( varStreamingInfo->transientInfo )
      {
        v8 = varTransientInfo;
        DB_PatchMem_FixStreamAlignment(7ui64);
        DB_CheckCanIncStreamPos(0i64);
        varTransientInfo = (TransientInfo *)g_streamPosGlob.pos;
        Preload_TransientInfo(AtStart);
        varTransientInfo = v8;
      }
      DB_PopStreamPos();
      DB_PatchMem_PopAsset();
      pos = g_streamPosGlob.pos;
      varStreamingInfo = (StreamingInfo *)g_streamPosGlob.pos;
      --count;
    }
    while ( count );
  }
}

/*
==============
Preload_StreamingItemContents
==============
*/
void Preload_StreamingItemContents(const DBStreamStart streamStart)
{
  unsigned __int16 *v1; 
  unsigned int CostItemIndex; 

  Load_Stream(streamStart, varStreamingItemContents, 8ui64);
  if ( varStreamingItemContents->contents )
  {
    v1 = varushort;
    varushort = AllocPreload_ushort();
    CostItemIndex = DB_StreamingInfo_GetCostItemIndex(varTransientCosts, varStreamingContentSet, varStreamingItemContents);
    Preload_ushortArray(AtStart, CostItemIndex);
    varushort = v1;
  }
}

/*
==============
Preload_StreamingItemContentsArray
==============
*/
void Preload_StreamingItemContentsArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  StreamingItemContents *i; 
  unsigned __int16 *v4; 
  unsigned int CostItemIndex; 

  v2 = count;
  Load_Stream(streamStart, varStreamingItemContents, 8 * count);
  for ( i = varStreamingItemContents; v2; --v2 )
  {
    varStreamingItemContents = i;
    Load_Stream(NotAtStart, i, 8ui64);
    if ( varStreamingItemContents->contents )
    {
      v4 = varushort;
      varushort = AllocPreload_ushort();
      CostItemIndex = DB_StreamingInfo_GetCostItemIndex(varTransientCosts, varStreamingContentSet, varStreamingItemContents);
      Preload_ushortArray(AtStart, CostItemIndex);
      varushort = v4;
    }
    ++i;
  }
}

/*
==============
Preload_StreamingItemContentsStream
==============
*/
void Preload_StreamingItemContentsStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *pos; 
  unsigned __int16 *v4; 
  unsigned int CostItemIndex; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 8104, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    pos = (unsigned __int8 *)varStreamingItemContents;
    do
    {
      Load_Stream(AtStart, pos, 8ui64);
      if ( varStreamingItemContents->contents )
      {
        v4 = varushort;
        varushort = AllocPreload_ushort();
        CostItemIndex = DB_StreamingInfo_GetCostItemIndex(varTransientCosts, varStreamingContentSet, varStreamingItemContents);
        Preload_ushortArray(AtStart, CostItemIndex);
        varushort = v4;
      }
      pos = g_streamPosGlob.pos;
      varStreamingItemContents = (StreamingItemContents *)g_streamPosGlob.pos;
      --count;
    }
    while ( count );
  }
}

/*
==============
Preload_StreamingItemCost
==============
*/
void Preload_StreamingItemCost(const DBStreamStart streamStart)
{
  Load_Stream(streamStart, varStreamingItemCost, 4ui64);
}

/*
==============
Preload_StreamingItemCostArray
==============
*/
void Preload_StreamingItemCostArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  Load_Stream(streamStart, varStreamingItemCost, 4 * count);
}

/*
==============
Preload_StreamingItemCostStream
==============
*/
void Preload_StreamingItemCostStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *pos; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 8026, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    pos = (unsigned __int8 *)varStreamingItemCost;
    do
    {
      Load_Stream(AtStart, pos, 4ui64);
      pos = g_streamPosGlob.pos;
      varStreamingItemCost = (StreamingItemCost *)g_streamPosGlob.pos;
      --count;
    }
    while ( count );
  }
}

/*
==============
Preload_TransientAssetReference
==============
*/
void Preload_TransientAssetReference(const DBStreamStart streamStart)
{
  const char **v1; 

  Load_Stream(streamStart, varTransientAssetReference, 0x10ui64);
  v1 = varXString;
  varXString = &varTransientAssetReference->name;
  Preload_XString(NotAtStart);
  varXString = v1;
}

/*
==============
Preload_TransientAssetReferenceArray
==============
*/
void Preload_TransientAssetReferenceArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  TransientAssetReference *i; 
  const char **v4; 

  v2 = count;
  Load_Stream(streamStart, varTransientAssetReference, 16 * count);
  for ( i = varTransientAssetReference; v2; --v2 )
  {
    varTransientAssetReference = i;
    Load_Stream(NotAtStart, i, 0x10ui64);
    v4 = varXString;
    varXString = &varTransientAssetReference->name;
    Preload_XString(NotAtStart);
    ++i;
    varXString = v4;
  }
}

/*
==============
Preload_TransientAssetReferenceStream
==============
*/
void Preload_TransientAssetReferenceStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *pos; 
  const char **v4; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 7463, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    pos = (unsigned __int8 *)varTransientAssetReference;
    do
    {
      Load_Stream(AtStart, pos, 0x10ui64);
      v4 = varXString;
      varXString = &varTransientAssetReference->name;
      Preload_XString(NotAtStart);
      pos = g_streamPosGlob.pos;
      varTransientAssetReference = (TransientAssetReference *)g_streamPosGlob.pos;
      varXString = v4;
      --count;
    }
    while ( count );
  }
}

/*
==============
Preload_TransientCosts
==============
*/
void Preload_TransientCosts(const DBStreamStart streamStart)
{
  TransientCosts *v1; 
  __int64 v2; 
  StreamingItemCost *v3; 
  StreamingContentSet *v4; 
  StreamingContentSet *v5; 
  TransientCosts *v6; 
  unsigned __int16 *v7; 

  Load_Stream(streamStart, varTransientCosts, 0x50ui64);
  v1 = varTransientCosts;
  v2 = 3i64;
  if ( varTransientCosts->streamingCosts )
  {
    v3 = varStreamingItemCost;
    DB_PatchMem_FixStreamAlignment(3ui64);
    DB_CheckCanIncStreamPos(0i64);
    varStreamingItemCost = (StreamingItemCost *)g_streamPosGlob.pos;
    Load_Stream(AtStart, g_streamPosGlob.pos, 4i64 * varTransientCosts->streamingItemCount);
    v1 = varTransientCosts;
    varStreamingItemCost = v3;
  }
  v4 = varStreamingContentSet;
  varStreamingContentSet = (StreamingContentSet *)v1;
  Load_Stream(NotAtStart, v1, 0x30ui64);
  v5 = varStreamingContentSet;
  do
  {
    varStreamingContentSet = v5;
    Preload_StreamingContentSet(NotAtStart);
    ++v5;
    --v2;
  }
  while ( v2 );
  v6 = varTransientCosts;
  v7 = varushort;
  varStreamingContentSet = v4;
  if ( varTransientCosts->residentPageSizes )
  {
    varushort = AllocPreload_ushort();
    Preload_ushortArray(AtStart, varTransientCosts->transientCostCount);
    v6 = varTransientCosts;
    varushort = v7;
  }
  if ( v6->tempPageSizes )
  {
    varushort = AllocPreload_ushort();
    Preload_ushortArray(AtStart, varTransientCosts->transientCostCount);
    varushort = v7;
  }
}

/*
==============
Preload_TransientCostsArray
==============
*/
void Preload_TransientCostsArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  TransientCosts *i; 
  TransientCosts *v4; 
  StreamingItemCost *v5; 
  StreamingContentSet *v6; 
  StreamingContentSet *v7; 
  __int64 v8; 
  TransientCosts *v9; 
  unsigned __int16 *v10; 

  v2 = count;
  Load_Stream(streamStart, varTransientCosts, 80 * count);
  for ( i = varTransientCosts; v2; --v2 )
  {
    varTransientCosts = i;
    Load_Stream(NotAtStart, i, 0x50ui64);
    v4 = varTransientCosts;
    if ( varTransientCosts->streamingCosts )
    {
      v5 = varStreamingItemCost;
      DB_PatchMem_FixStreamAlignment(3ui64);
      DB_CheckCanIncStreamPos(0i64);
      varStreamingItemCost = (StreamingItemCost *)g_streamPosGlob.pos;
      Load_Stream(AtStart, g_streamPosGlob.pos, 4i64 * varTransientCosts->streamingItemCount);
      v4 = varTransientCosts;
      varStreamingItemCost = v5;
    }
    v6 = varStreamingContentSet;
    varStreamingContentSet = (StreamingContentSet *)v4;
    Load_Stream(NotAtStart, v4, 0x30ui64);
    v7 = varStreamingContentSet;
    v8 = 3i64;
    do
    {
      varStreamingContentSet = v7;
      Preload_StreamingContentSet(NotAtStart);
      ++v7;
      --v8;
    }
    while ( v8 );
    v9 = varTransientCosts;
    v10 = varushort;
    varStreamingContentSet = v6;
    if ( varTransientCosts->residentPageSizes )
    {
      varushort = AllocPreload_ushort();
      Preload_ushortArray(AtStart, varTransientCosts->transientCostCount);
      v9 = varTransientCosts;
      varushort = v10;
    }
    if ( v9->tempPageSizes )
    {
      varushort = AllocPreload_ushort();
      Preload_ushortArray(AtStart, varTransientCosts->transientCostCount);
      varushort = v10;
    }
    ++i;
  }
}

/*
==============
Preload_TransientCostsStream
==============
*/
void Preload_TransientCostsStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *pos; 
  TransientCosts *v4; 
  StreamingItemCost *v5; 
  StreamingContentSet *v6; 
  StreamingContentSet *v7; 
  __int64 v8; 
  TransientCosts *v9; 
  unsigned __int16 *v10; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 8404, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    pos = (unsigned __int8 *)varTransientCosts;
    do
    {
      Load_Stream(AtStart, pos, 0x50ui64);
      v4 = varTransientCosts;
      if ( varTransientCosts->streamingCosts )
      {
        v5 = varStreamingItemCost;
        DB_PatchMem_FixStreamAlignment(3ui64);
        DB_CheckCanIncStreamPos(0i64);
        varStreamingItemCost = (StreamingItemCost *)g_streamPosGlob.pos;
        Load_Stream(AtStart, g_streamPosGlob.pos, 4i64 * varTransientCosts->streamingItemCount);
        v4 = varTransientCosts;
        varStreamingItemCost = v5;
      }
      v6 = varStreamingContentSet;
      varStreamingContentSet = (StreamingContentSet *)v4;
      Load_Stream(NotAtStart, v4, 0x30ui64);
      v7 = varStreamingContentSet;
      v8 = 3i64;
      do
      {
        varStreamingContentSet = v7;
        Preload_StreamingContentSet(NotAtStart);
        ++v7;
        --v8;
      }
      while ( v8 );
      v9 = varTransientCosts;
      v10 = varushort;
      varStreamingContentSet = v6;
      if ( varTransientCosts->residentPageSizes )
      {
        varushort = AllocPreload_ushort();
        Preload_ushortArray(AtStart, varTransientCosts->transientCostCount);
        v9 = varTransientCosts;
        varushort = v10;
      }
      if ( v9->tempPageSizes )
      {
        varushort = AllocPreload_ushort();
        Preload_ushortArray(AtStart, varTransientCosts->transientCostCount);
        varushort = v10;
      }
      pos = g_streamPosGlob.pos;
      varTransientCosts = (TransientCosts *)g_streamPosGlob.pos;
      --count;
    }
    while ( count );
  }
}

/*
==============
Preload_TransientFileReference
==============
*/
void Preload_TransientFileReference(const DBStreamStart streamStart)
{
  const char **v1; 

  Load_Stream(streamStart, varTransientFileReference, 0x10ui64);
  v1 = varXString;
  varXString = &varTransientFileReference->name;
  Preload_XString(NotAtStart);
  varXString = v1;
}

/*
==============
Preload_TransientFileReferenceArray
==============
*/
void Preload_TransientFileReferenceArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  TransientFileReference *i; 
  const char **v4; 

  v2 = count;
  Load_Stream(streamStart, varTransientFileReference, 16 * count);
  for ( i = varTransientFileReference; v2; --v2 )
  {
    varTransientFileReference = i;
    Load_Stream(NotAtStart, i, 0x10ui64);
    v4 = varXString;
    varXString = &varTransientFileReference->name;
    Preload_XString(NotAtStart);
    ++i;
    varXString = v4;
  }
}

/*
==============
Preload_TransientFileReferenceStream
==============
*/
void Preload_TransientFileReferenceStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *pos; 
  const char **v4; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 7562, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    pos = (unsigned __int8 *)varTransientFileReference;
    do
    {
      Load_Stream(AtStart, pos, 0x10ui64);
      v4 = varXString;
      varXString = &varTransientFileReference->name;
      Preload_XString(NotAtStart);
      pos = g_streamPosGlob.pos;
      varTransientFileReference = (TransientFileReference *)g_streamPosGlob.pos;
      varXString = v4;
      --count;
    }
    while ( count );
  }
}

/*
==============
Preload_TransientInfo
==============
*/
void Preload_TransientInfo(const DBStreamStart streamStart)
{
  TransientSets *v1; 
  TransientCosts *v2; 
  TransientInfo *v3; 
  ForcedStubAssetReference *v4; 
  __int64 forcedStubAssetCount; 
  ForcedStubAssetReference *i; 
  const char **v7; 
  TransientFileReference *v8; 
  __int64 transientFileCount; 
  TransientFileReference *j; 
  const char **v11; 
  TransientAssetReference *v12; 
  __int64 transientAssetCount; 
  TransientAssetReference *k; 
  const char **v15; 
  TransientWorldGridTileMap *v16; 
  __int64 transientWorldGridTileMapCount; 
  TransientWorldGridTileMap *m; 
  unsigned __int16 *v19; 
  SpatialPartition_Tree *v20; 
  Bounds *v21; 
  unsigned __int16 *v22; 
  bitarray_dynamic *v23; 
  unsigned int *v24; 

  Load_Stream(streamStart, varTransientInfo, 0xD8ui64);
  v1 = varTransientSets;
  varTransientSets = &varTransientInfo->transientSets;
  Preload_TransientSets(NotAtStart);
  varTransientSets = v1;
  v2 = varTransientCosts;
  varTransientCosts = &varTransientInfo->transientCosts;
  Preload_TransientCosts(NotAtStart);
  v3 = varTransientInfo;
  varTransientCosts = v2;
  if ( varTransientInfo->forcedStubAssets )
  {
    v4 = varForcedStubAssetReference;
    DB_PatchMem_FixStreamAlignment(7ui64);
    DB_CheckCanIncStreamPos(0i64);
    varForcedStubAssetReference = (ForcedStubAssetReference *)g_streamPosGlob.pos;
    forcedStubAssetCount = varTransientInfo->forcedStubAssetCount;
    Load_Stream(AtStart, g_streamPosGlob.pos, 16 * forcedStubAssetCount);
    for ( i = varForcedStubAssetReference; forcedStubAssetCount; --forcedStubAssetCount )
    {
      varForcedStubAssetReference = i;
      Load_Stream(NotAtStart, i, 0x10ui64);
      v7 = varXString;
      varXString = &varForcedStubAssetReference->name;
      Preload_XString(NotAtStart);
      ++i;
      varXString = v7;
    }
    v3 = varTransientInfo;
    varForcedStubAssetReference = v4;
  }
  if ( v3->transientFiles )
  {
    v8 = varTransientFileReference;
    DB_PatchMem_FixStreamAlignment(7ui64);
    DB_CheckCanIncStreamPos(0i64);
    varTransientFileReference = (TransientFileReference *)g_streamPosGlob.pos;
    transientFileCount = varTransientInfo->transientFileCount;
    Load_Stream(AtStart, g_streamPosGlob.pos, 16 * transientFileCount);
    for ( j = varTransientFileReference; transientFileCount; --transientFileCount )
    {
      varTransientFileReference = j;
      Load_Stream(NotAtStart, j, 0x10ui64);
      v11 = varXString;
      varXString = &varTransientFileReference->name;
      Preload_XString(NotAtStart);
      ++j;
      varXString = v11;
    }
    v3 = varTransientInfo;
    varTransientFileReference = v8;
  }
  if ( v3->transientAssets )
  {
    v12 = varTransientAssetReference;
    DB_PatchMem_FixStreamAlignment(7ui64);
    DB_CheckCanIncStreamPos(0i64);
    varTransientAssetReference = (TransientAssetReference *)g_streamPosGlob.pos;
    transientAssetCount = varTransientInfo->transientAssetCount;
    Load_Stream(AtStart, g_streamPosGlob.pos, 16 * transientAssetCount);
    for ( k = varTransientAssetReference; transientAssetCount; --transientAssetCount )
    {
      varTransientAssetReference = k;
      Load_Stream(NotAtStart, k, 0x10ui64);
      v15 = varXString;
      varXString = &varTransientAssetReference->name;
      Preload_XString(NotAtStart);
      ++k;
      varXString = v15;
    }
    v3 = varTransientInfo;
    varTransientAssetReference = v12;
  }
  if ( v3->transientWorldGridTileMaps )
  {
    v16 = varTransientWorldGridTileMap;
    DB_PatchMem_FixStreamAlignment(7ui64);
    DB_CheckCanIncStreamPos(0i64);
    varTransientWorldGridTileMap = (TransientWorldGridTileMap *)g_streamPosGlob.pos;
    transientWorldGridTileMapCount = varTransientInfo->transientWorldGridTileMapCount;
    Load_Stream(AtStart, g_streamPosGlob.pos, 40 * transientWorldGridTileMapCount);
    for ( m = varTransientWorldGridTileMap; transientWorldGridTileMapCount; --transientWorldGridTileMapCount )
    {
      varTransientWorldGridTileMap = m;
      Load_Stream(NotAtStart, m, 0x28ui64);
      if ( varTransientWorldGridTileMap->spaceToTransientIndex )
      {
        v19 = varushort;
        varushort = AllocPreload_ushort();
        Preload_ushortArray(AtStart, varTransientWorldGridTileMap->indexCount);
        varushort = v19;
      }
      ++m;
    }
    v3 = varTransientInfo;
    varTransientWorldGridTileMap = v16;
  }
  if ( v3->transientWorldGridSpatial )
  {
    v20 = varSpatialPartition_Tree;
    varSpatialPartition_Tree = AllocPreload_SpatialPartition_Tree();
    Preload_SpatialPartition_Tree(AtStart);
    v3 = varTransientInfo;
    varSpatialPartition_Tree = v20;
  }
  if ( v3->transientWorldGridBounds )
  {
    v21 = varBounds;
    varBounds = AllocPreload_Bounds();
    Preload_BoundsArray(AtStart, varTransientInfo->transientWorldGridBoundsCount);
    v3 = varTransientInfo;
    varBounds = v21;
  }
  if ( v3->transientWorldGridHighLodLookup )
  {
    v22 = varushort;
    varushort = AllocPreload_ushort();
    Preload_ushortArray(AtStart, varTransientInfo->transientWorldGridHighLodLookupCount);
    v3 = varTransientInfo;
    varushort = v22;
  }
  v23 = varTransientInfo_Bitarray;
  varTransientInfo_Bitarray = &v3->transientSkipLoading;
  Load_Stream(NotAtStart, &v3->transientSkipLoading, 0x10ui64);
  if ( varTransientInfo_Bitarray->array )
  {
    v24 = varuint;
    varuint = AllocPreload_uint();
    Preload_uintArray(AtStart, varTransientInfo_Bitarray->wordCount);
    varuint = v24;
  }
  varTransientInfo_Bitarray = v23;
}

/*
==============
Preload_TransientInfoArray
==============
*/
void Preload_TransientInfoArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  TransientInfo *i; 

  v2 = count;
  Load_Stream(streamStart, varTransientInfo, 216 * count);
  for ( i = varTransientInfo; v2; --v2 )
  {
    varTransientInfo = i;
    Preload_TransientInfo(NotAtStart);
    ++i;
  }
}

/*
==============
Preload_TransientInfoFlags
==============
*/
void Preload_TransientInfoFlags(const DBStreamStart streamStart)
{
  Load_Stream(streamStart, varTransientInfoFlags, 1ui64);
}

/*
==============
Preload_TransientInfoFlagsArray
==============
*/
void Preload_TransientInfoFlagsArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  Load_Stream(streamStart, varTransientInfoFlags, count);
}

/*
==============
Preload_TransientInfoFlagsStream
==============
*/
void Preload_TransientInfoFlagsStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *pos; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 8604, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    pos = (unsigned __int8 *)varTransientInfoFlags;
    do
    {
      Load_Stream(AtStart, pos, 1ui64);
      pos = g_streamPosGlob.pos;
      varTransientInfoFlags = (TransientInfoFlags *)g_streamPosGlob.pos;
      --count;
    }
    while ( count );
  }
}

/*
==============
Preload_TransientInfoStream
==============
*/
void Preload_TransientInfoStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 9181, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  for ( ; count; --count )
  {
    Preload_TransientInfo(AtStart);
    varTransientInfo = (TransientInfo *)g_streamPosGlob.pos;
  }
}

/*
==============
Preload_TransientInfo_Bitarray
==============
*/
void Preload_TransientInfo_Bitarray(const DBStreamStart streamStart)
{
  unsigned int *v1; 

  Load_Stream(streamStart, varTransientInfo_Bitarray, 0x10ui64);
  if ( varTransientInfo_Bitarray->array )
  {
    v1 = varuint;
    varuint = AllocPreload_uint();
    Preload_uintArray(AtStart, varTransientInfo_Bitarray->wordCount);
    varuint = v1;
  }
}

/*
==============
Preload_TransientInfo_BitarrayArray
==============
*/
void Preload_TransientInfo_BitarrayArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  bitarray_dynamic *i; 
  unsigned int *v4; 

  v2 = count;
  Load_Stream(streamStart, varTransientInfo_Bitarray, 16 * count);
  for ( i = varTransientInfo_Bitarray; v2; --v2 )
  {
    varTransientInfo_Bitarray = i;
    Load_Stream(NotAtStart, i, 0x10ui64);
    if ( varTransientInfo_Bitarray->array )
    {
      v4 = varuint;
      varuint = AllocPreload_uint();
      Preload_uintArray(AtStart, varTransientInfo_Bitarray->wordCount);
      varuint = v4;
    }
    ++i;
  }
}

/*
==============
Preload_TransientInfo_BitarrayStream
==============
*/
void Preload_TransientInfo_BitarrayStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *pos; 
  unsigned int *v4; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 8528, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    pos = (unsigned __int8 *)varTransientInfo_Bitarray;
    do
    {
      Load_Stream(AtStart, pos, 0x10ui64);
      if ( varTransientInfo_Bitarray->array )
      {
        v4 = varuint;
        varuint = AllocPreload_uint();
        Preload_uintArray(AtStart, varTransientInfo_Bitarray->wordCount);
        varuint = v4;
      }
      pos = g_streamPosGlob.pos;
      varTransientInfo_Bitarray = (bitarray_dynamic *)g_streamPosGlob.pos;
      --count;
    }
    while ( count );
  }
}

/*
==============
Preload_TransientSets
==============
*/
void Preload_TransientSets(const DBStreamStart streamStart)
{
  TransientSets *v1; 
  const char **v2; 
  bitarray<32> *v3; 

  Load_Stream(streamStart, varTransientSets, 0x18ui64);
  v1 = varTransientSets;
  if ( varTransientSets->names )
  {
    v2 = varXString;
    varXString = AllocPreload_XString();
    Preload_XStringArray(AtStart, varTransientSets->count);
    v1 = varTransientSets;
    varXString = v2;
  }
  if ( v1->masks )
  {
    v3 = vartransientSPWorldBitArray_t;
    DB_PatchMem_FixStreamAlignment(3ui64);
    DB_CheckCanIncStreamPos(0i64);
    vartransientSPWorldBitArray_t = (bitarray<32> *)g_streamPosGlob.pos;
    Load_Stream(AtStart, g_streamPosGlob.pos, 4i64 * varTransientSets->count);
    vartransientSPWorldBitArray_t = v3;
  }
}

/*
==============
Preload_TransientSetsArray
==============
*/
void Preload_TransientSetsArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  TransientSets *i; 
  TransientSets *v4; 
  const char **v5; 
  bitarray<32> *v6; 

  v2 = count;
  Load_Stream(streamStart, varTransientSets, 24 * count);
  for ( i = varTransientSets; v2; --v2 )
  {
    varTransientSets = i;
    Load_Stream(NotAtStart, i, 0x18ui64);
    v4 = varTransientSets;
    if ( varTransientSets->names )
    {
      v5 = varXString;
      varXString = AllocPreload_XString();
      Preload_XStringArray(AtStart, varTransientSets->count);
      v4 = varTransientSets;
      varXString = v5;
    }
    if ( v4->masks )
    {
      v6 = vartransientSPWorldBitArray_t;
      DB_PatchMem_FixStreamAlignment(3ui64);
      DB_CheckCanIncStreamPos(0i64);
      vartransientSPWorldBitArray_t = (bitarray<32> *)g_streamPosGlob.pos;
      Load_Stream(AtStart, g_streamPosGlob.pos, 4i64 * varTransientSets->count);
      vartransientSPWorldBitArray_t = v6;
    }
    ++i;
  }
}

/*
==============
Preload_TransientSetsStream
==============
*/
void Preload_TransientSetsStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *pos; 
  TransientSets *v4; 
  const char **v5; 
  bitarray<32> *v6; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 7688, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    pos = (unsigned __int8 *)varTransientSets;
    do
    {
      Load_Stream(AtStart, pos, 0x18ui64);
      v4 = varTransientSets;
      if ( varTransientSets->names )
      {
        v5 = varXString;
        varXString = AllocPreload_XString();
        Preload_XStringArray(AtStart, varTransientSets->count);
        v4 = varTransientSets;
        varXString = v5;
      }
      if ( v4->masks )
      {
        v6 = vartransientSPWorldBitArray_t;
        DB_PatchMem_FixStreamAlignment(3ui64);
        DB_CheckCanIncStreamPos(0i64);
        vartransientSPWorldBitArray_t = (bitarray<32> *)g_streamPosGlob.pos;
        Load_Stream(AtStart, g_streamPosGlob.pos, 4i64 * varTransientSets->count);
        vartransientSPWorldBitArray_t = v6;
      }
      pos = g_streamPosGlob.pos;
      varTransientSets = (TransientSets *)g_streamPosGlob.pos;
      --count;
    }
    while ( count );
  }
}

/*
==============
Preload_TransientWorldGridTileMap
==============
*/
void Preload_TransientWorldGridTileMap(const DBStreamStart streamStart)
{
  unsigned __int16 *v1; 

  Load_Stream(streamStart, varTransientWorldGridTileMap, 0x28ui64);
  if ( varTransientWorldGridTileMap->spaceToTransientIndex )
  {
    v1 = varushort;
    varushort = AllocPreload_ushort();
    Preload_ushortArray(AtStart, varTransientWorldGridTileMap->indexCount);
    varushort = v1;
  }
}

/*
==============
Preload_TransientWorldGridTileMapArray
==============
*/
void Preload_TransientWorldGridTileMapArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int64 v2; 
  TransientWorldGridTileMap *i; 
  unsigned __int16 *v4; 

  v2 = count;
  Load_Stream(streamStart, varTransientWorldGridTileMap, 40 * count);
  for ( i = varTransientWorldGridTileMap; v2; --v2 )
  {
    varTransientWorldGridTileMap = i;
    Load_Stream(NotAtStart, i, 0x28ui64);
    if ( varTransientWorldGridTileMap->spaceToTransientIndex )
    {
      v4 = varushort;
      varushort = AllocPreload_ushort();
      Preload_ushortArray(AtStart, varTransientWorldGridTileMap->indexCount);
      varushort = v4;
    }
    ++i;
  }
}

/*
==============
Preload_TransientWorldGridTileMapStream
==============
*/
void Preload_TransientWorldGridTileMapStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *pos; 
  unsigned __int16 *v4; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 7950, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    pos = (unsigned __int8 *)varTransientWorldGridTileMap;
    do
    {
      Load_Stream(AtStart, pos, 0x28ui64);
      if ( varTransientWorldGridTileMap->spaceToTransientIndex )
      {
        v4 = varushort;
        varushort = AllocPreload_ushort();
        Preload_ushortArray(AtStart, varTransientWorldGridTileMap->indexCount);
        varushort = v4;
      }
      pos = g_streamPosGlob.pos;
      varTransientWorldGridTileMap = (TransientWorldGridTileMap *)g_streamPosGlob.pos;
      --count;
    }
    while ( count );
  }
}

/*
==============
Preload_transientSPWorldBitArray_t
==============
*/
void Preload_transientSPWorldBitArray_t(const DBStreamStart streamStart)
{
  Load_Stream(streamStart, vartransientSPWorldBitArray_t, 4ui64);
}

/*
==============
Preload_transientSPWorldBitArray_tArray
==============
*/
void Preload_transientSPWorldBitArray_tArray(const DBStreamStart streamStart, const unsigned __int64 count)
{
  Load_Stream(streamStart, vartransientSPWorldBitArray_t, 4 * count);
}

/*
==============
Preload_transientSPWorldBitArray_tStream
==============
*/
void Preload_transientSPWorldBitArray_tStream(const DBStreamStart streamStart, const unsigned __int64 count)
{
  unsigned __int8 *pos; 

  if ( streamStart && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\db_generated\\load\\impl\\archive_impl_db_streaming_info_db.h", 6833, ASSERT_TYPE_ASSERT, "(streamStart == DBStreamStart::AtStart)", (const char *)&queryFormat, "streamStart == DBStreamStart::AtStart") )
    __debugbreak();
  if ( count )
  {
    pos = (unsigned __int8 *)vartransientSPWorldBitArray_t;
    do
    {
      Load_Stream(AtStart, pos, 4ui64);
      pos = g_streamPosGlob.pos;
      vartransientSPWorldBitArray_t = (bitarray<32> *)g_streamPosGlob.pos;
      --count;
    }
    while ( count );
  }
}

