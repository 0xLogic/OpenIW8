/*
==============
AIScriptedInterface::OnScrCmd_CodeMoveRequested
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_CodeMoveRequested(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_CodeMoveRequested@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_FlagEnemyUnattackable
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_FlagEnemyUnattackable(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_FlagEnemyUnattackable@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_ForceThreatUpdate
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ForceThreatUpdate(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ForceThreatUpdate@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_FinishTraverse
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_FinishTraverse(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_FinishTraverse@AIScriptedInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearBTGoal
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ClearBTGoal(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ClearBTGoal@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AICommonInterface::OnScrCmd_GetPosOnPath
==============
*/

void __fastcall AICommonInterface::OnScrCmd_GetPosOnPath(AICommonInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetPosOnPath@AICommonInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_IW7ShipHack_SetMayMoveTime
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_IW7ShipHack_SetMayMoveTime(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_IW7ShipHack_SetMayMoveTime@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::CalcAnimStartPos
==============
*/

void __fastcall AIScriptedInterface::CalcAnimStartPos(const vec3_t *stopPos, const float stopYaw, const vec3_t *animDelta, const float animAngleDelta, vec3_t *outPos)
{
  ?CalcAnimStartPos@AIScriptedInterface@@SAXAEBTvec3_t@@M0MAEAT2@@Z(stopPos, stopYaw, animDelta, animAngleDelta, outPos);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsInGoal
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_IsInGoal(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_IsInGoal@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AICommonInterface::OnScrCmd_FindLastPointOnPathWithinVolume
==============
*/

void __fastcall AICommonInterface::OnScrCmd_FindLastPointOnPathWithinVolume(AICommonInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_FindLastPointOnPathWithinVolume@AICommonInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::CanSuppressEnemy
==============
*/

bool __fastcall AIScriptedInterface::CanSuppressEnemy(AIScriptedInterface *this)
{
  return ?CanSuppressEnemy@AIScriptedInterface@@IEBA_NXZ(this);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsStanceAllowed
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_IsStanceAllowed(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_IsStanceAllowed@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_StartCoverArrival
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_StartCoverArrival(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_StartCoverArrival@AIScriptedInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AICommonInterface::OnScrCmd_ClearPath
==============
*/

void __fastcall AICommonInterface::OnScrCmd_ClearPath(AICommonInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ClearPath@AICommonInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_ShouldCautiousStrafe
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ShouldCautiousStrafe(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ShouldCautiousStrafe@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_CalcSharpTurnAnim
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_CalcSharpTurnAnim(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_CalcSharpTurnAnim@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetGoalPath
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetGoalPath(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetGoalPath@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetGoalPos
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetGoalPos(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetGoalPos@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_Melee
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_Melee(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_Melee@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetBTGoalRadius
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetBTGoalRadius(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetBTGoalRadius@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_UpdateLastCoverTime
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_UpdateLastCoverTime(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_UpdateLastCoverTime@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetBaseArchetype
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetBaseArchetype(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetBaseArchetype@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetMotionAngle3D
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetMotionAngle3D(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetMotionAngle3D@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_CanSee
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_CanSee(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_CanSee@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetupDoorOpen
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetupDoorOpen(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetupDoorOpen@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsSuppressed
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_IsSuppressed(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_IsSuppressed@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetCoverSelectionFocusEnt
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetCoverSelectionFocusEnt(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetCoverSelectionFocusEnt@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetNodeHideYaw
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetNodeHideYaw(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetNodeHideYaw@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::ClearIdleFacingUseAlliesPos
==============
*/

void __fastcall AIScriptedInterface::ClearIdleFacingUseAlliesPos(AIScriptedInterface *this)
{
  ?ClearIdleFacingUseAlliesPos@AIScriptedInterface@@IEBAXXZ(this);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetGunAdditive
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetGunAdditive(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetGunAdditive@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetStrafeReverse
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetStrafeReverse(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetStrafeReverse@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_AIPlayGesture
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_AIPlayGesture(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AIPlayGesture@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearPotentialThreat
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ClearPotentialThreat(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ClearPotentialThreat@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_ChooseArrivalType
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ChooseArrivalType(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ChooseArrivalType@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::HasSuppressableEnemy
==============
*/

bool __fastcall AIScriptedInterface::HasSuppressableEnemy(AIScriptedInterface *this)
{
  return ?HasSuppressableEnemy@AIScriptedInterface@@IEBA_NXZ(this);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsSuppressionWaiting
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_IsSuppressionWaiting(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_IsSuppressionWaiting@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetCoverTacPoint
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetCoverTacPoint(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetCoverTacPoint@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_AmbushGetNextAmbushNode
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_AmbushGetNextAmbushNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AmbushGetNextAmbushNode@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AICommonInterface::OnScrCmd_GetLastPathPointWithinGoal
==============
*/

void __fastcall AICommonInterface::OnScrCmd_GetLastPathPointWithinGoal(AICommonInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetLastPathPointWithinGoal@AICommonInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_DropWeaponNoVelocity
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_DropWeaponNoVelocity(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_DropWeaponNoVelocity@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::CalculateSharpTurnAnim
==============
*/

bool __fastcall AIScriptedInterface::CalculateSharpTurnAnim(AIScriptedInterface *this, unsigned int angleIndexCount, int *angleIndices, scr_string_t animsetName, scr_string_t stateName, const vec3_t *corner, const vec3_t *nextPathPoint, const char *footPrefix, const char *optionalPrefix, const char *optionalSuffix, scr_anim_t *outAnim, int *outAngleIndex, int *outAnimEntryIndex)
{
  return ?CalculateSharpTurnAnim@AIScriptedInterface@@QEBA_NIPEAHW4scr_string_t@@1Tvec3_t@@2PEBD33PEAUscr_anim_t@@00@Z(this, angleIndexCount, angleIndices, animsetName, stateName, corner, nextPathPoint, footPrefix, optionalPrefix, optionalSuffix, outAnim, outAngleIndex, outAnimEntryIndex);
}

/*
==============
AIScriptedInterface::OnScrCmd_ForceUpdateGoalPos
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ForceUpdateGoalPos(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ForceUpdateGoalPos@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearDesiredSpeed
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ClearDesiredSpeed(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ClearDesiredSpeed@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsGunBlockedByWall
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_IsGunBlockedByWall(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_IsGunBlockedByWall@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::CheckPitchVisibility
==============
*/

bool __fastcall AIScriptedInterface::CheckPitchVisibility(AIScriptedInterface *this, const vec3_t *fromPoint, const vec3_t *toPoint, const pathnode_t *pNode)
{
  return ?CheckPitchVisibility@AIScriptedInterface@@IEBA_NAEBTvec3_t@@0PEBUpathnode_t@@@Z(this, fromPoint, toPoint, pNode);
}

/*
==============
AIScriptedInterface::OnScrCmd_CanShoot
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_CanShoot(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_CanShoot@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetPitchOrient
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetPitchOrient(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetPitchOrient@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_UpdateAimInfo
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_UpdateAimInfo(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_UpdateAimInfo@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_BTGoalValid
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_BTGoalValid(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_BTGoalValid@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AICommonInterface::OnScrCmd_GetNegotiationStartNode
==============
*/

void __fastcall AICommonInterface::OnScrCmd_GetNegotiationStartNode(AICommonInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetNegotiationStartNode@AICommonInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_AIGetAnimTime
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_AIGetAnimTime(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AIGetAnimTime@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AICommonInterface::OnScrCmd_IsInBadplace
==============
*/

void __fastcall AICommonInterface::OnScrCmd_IsInBadplace(AICommonInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_IsInBadplace@AICommonInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_FinishCoverArrival
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_FinishCoverArrival(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_FinishCoverArrival@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetFixedNodeSafeVolume
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetFixedNodeSafeVolume(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetFixedNodeSafeVolume@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetGroundSlope
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetGroundSlope(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetGroundSlope@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetDesiredSpeed
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetDesiredSpeed(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetDesiredSpeed@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AICommonInterface::OnScrCmd_GetNearbyNegotiationInfo
==============
*/

void __fastcall AICommonInterface::OnScrCmd_GetNearbyNegotiationInfo(AICommonInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetNearbyNegotiationInfo@AICommonInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_ReacquireClear
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ReacquireClear(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ReacquireClear@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::GetEnemySuppressPos
==============
*/

void __fastcall AIScriptedInterface::GetEnemySuppressPos(AIScriptedInterface *this, vec3_t *outEnemyEyePos)
{
  ?GetEnemySuppressPos@AIScriptedInterface@@IEBAXAEATvec3_t@@@Z(this, outEnemyEyePos);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsCoverValidAgainstEnemy
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_IsCoverValidAgainstEnemy(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_IsCoverValidAgainstEnemy@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_PreCalcShouldStartArrival
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_PreCalcShouldStartArrival(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_PreCalcShouldStartArrival@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetDesiredSpeed
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetDesiredSpeed(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetDesiredSpeed@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AICommonInterface::OnScrCmd_EnableTraversals
==============
*/

void __fastcall AICommonInterface::OnScrCmd_EnableTraversals(AICommonInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_EnableTraversals@AICommonInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_CanShootEnemy
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_CanShootEnemy(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_CanShootEnemy@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_NearClaimNodeAndAngle
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_NearClaimNodeAndAngle(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_NearClaimNodeAndAngle@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetBaseArchetype
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetBaseArchetype(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetBaseArchetype@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetReacquireState
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetReacquireState(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetReacquireState@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetDefaultAimLimits
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetDefaultAimLimits(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetDefaultAimLimits@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsLegacyAgent
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_IsLegacyAgent(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_IsLegacyAgent@AIScriptedInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetSpeedScaleMode
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetSpeedScaleMode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetSpeedScaleMode@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AICommonInterface::OnScrCmd_GetSecondaryTargets
==============
*/

void __fastcall AICommonInterface::OnScrCmd_GetSecondaryTargets(AICommonInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetSecondaryTargets@AICommonInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetOverrideArchetype
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetOverrideArchetype(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetOverrideArchetype@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetBTGoalPos
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetBTGoalPos(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetBTGoalPos@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_AmbushIsCurrentNodeValid
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_AmbushIsCurrentNodeValid(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AmbushIsCurrentNodeValid@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetAdjustedExitDirection
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetAdjustedExitDirection(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetAdjustedExitDirection@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsMoveSuppressed
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_IsMoveSuppressed(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_IsMoveSuppressed@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_ReacquireMove
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ReacquireMove(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ReacquireMove@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetFacialIndexFromASM
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetFacialIndexFromASM(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetFacialIndexFromASM@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetBTGoalEnt
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetBTGoalEnt(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetBTGoalEnt@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetGoalVolume
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetGoalVolume(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetGoalVolume@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetFacialIndex
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetFacialIndex(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetFacialIndex@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_MayMoveCheckFriendlyFire
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_MayMoveCheckFriendlyFire(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_MayMoveCheckFriendlyFire@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AICommonInterface::OnScrCmd_GetPathDistToGoal
==============
*/

void __fastcall AICommonInterface::OnScrCmd_GetPathDistToGoal(AICommonInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetPathDistToGoal@AICommonInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetPotentialThreat
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetPotentialThreat(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetPotentialThreat@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearPitchOrient
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ClearPitchOrient(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ClearPitchOrient@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AICommonInterface::OnScrCmd_SetC8ObstacleFlag
==============
*/

void __fastcall AICommonInterface::OnScrCmd_SetC8ObstacleFlag(AICommonInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetC8ObstacleFlag@AICommonInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AICommonInterface::OnScrCmd_EnableTeamwalking
==============
*/

void __fastcall AICommonInterface::OnScrCmd_EnableTeamwalking(AICommonInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_EnableTeamwalking@AICommonInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetNodeHideYawOffset
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetNodeHideYawOffset(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetNodeHideYawOffset@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::AISuppressAI
==============
*/

bool __fastcall AIScriptedInterface::AISuppressAI(AIScriptedInterface *this)
{
  return ?AISuppressAI@AIScriptedInterface@@QEBA_NXZ(this);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetWorldWeaponOffset
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetWorldWeaponOffset(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetWorldWeaponOffset@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetNodeLeanAimPitchOffset
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetNodeLeanAimPitchOffset(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetNodeLeanAimPitchOffset@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_CanAimWhileMoving
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_CanAimWhileMoving(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_CanAimWhileMoving@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsAtValidLongDeathSpot
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_IsAtValidLongDeathSpot(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_IsAtValidLongDeathSpot@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsWithinScriptGoalRadius
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_IsWithinScriptGoalRadius(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_IsWithinScriptGoalRadius@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_FindBestCoverList
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_FindBestCoverList(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_FindBestCoverList@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetTargetSpeed
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetTargetSpeed(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetTargetSpeed@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetAnglesToLikelyEnemyPath
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetAnglesToLikelyEnemyPath(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetAnglesToLikelyEnemyPath@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetGoalNode
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetGoalNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetGoalNode@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_FinishZeroArrival
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_FinishZeroArrival(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_FinishZeroArrival@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::CanDoTurnAnim
==============
*/

bool __fastcall AIScriptedInterface::CanDoTurnAnim(AIScriptedInterface *this, scr_anim_t turnAnim, const vec3_t *corner, const vec3_t *nextPathPoint)
{
  return ?CanDoTurnAnim@AIScriptedInterface@@QEBA_NUscr_anim_t@@Tvec3_t@@1@Z(this, turnAnim, corner, nextPathPoint);
}

/*
==============
AIScriptedInterface::OnScrCmd_CanBoundingOverwatchMove
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_CanBoundingOverwatchMove(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_CanBoundingOverwatchMove@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AICommonInterface::OnScrCmd_GetPosOutsideBadplace
==============
*/

void __fastcall AICommonInterface::OnScrCmd_GetPosOutsideBadplace(AICommonInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetPosOutsideBadplace@AICommonInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AICommonInterface::OnScrCmd_IsNodeInBadplace
==============
*/

void __fastcall AICommonInterface::OnScrCmd_IsNodeInBadplace(AICommonInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_IsNodeInBadplace@AICommonInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetApproxEyePos
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetApproxEyePos(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetApproxEyePos@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::CanSeeEnemyFromExposed
==============
*/

bool __fastcall AIScriptedInterface::CanSeeEnemyFromExposed(AIScriptedInterface *this, const pathnode_t *pNode)
{
  return ?CanSeeEnemyFromExposed@AIScriptedInterface@@IEBA_NPEBUpathnode_t@@@Z(this, pNode);
}

/*
==============
AICommonInterface::OnScrCmd_GetNegotiationEndPos
==============
*/

void __fastcall AICommonInterface::OnScrCmd_GetNegotiationEndPos(AICommonInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetNegotiationEndPos@AICommonInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_PointInFOV
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_PointInFOV(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_PointInFOV@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_ReacquireStep
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ReacquireStep(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ReacquireStep@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SeeRecently
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SeeRecently(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SeeRecently@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetNodeLeanAimPitch
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetNodeLeanAimPitch(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetNodeLeanAimPitch@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_StartTraverseArrival
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_StartTraverseArrival(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_StartTraverseArrival@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::CanSeeAndShootPoint
==============
*/

bool __fastcall AIScriptedInterface::CanSeeAndShootPoint(AIScriptedInterface *this, const vec3_t *vPoint)
{
  return ?CanSeeAndShootPoint@AIScriptedInterface@@IEBA_NAEBTvec3_t@@@Z(this, vPoint);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetBlackboard
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetBlackboard(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetBlackboard@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetBTGoalVolume
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetBTGoalVolume(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetBTGoalVolume@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetNodeSnapYawOffset
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetNodeSnapYawOffset(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetNodeSnapYawOffset@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetEngagementMinDist
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetEngagementMinDist(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetEngagementMinDist@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsPathDirect
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_IsPathDirect(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_IsPathDirect@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearEnemy
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ClearEnemy(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ClearEnemy@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetMotionAngle
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetMotionAngle(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetMotionAngle@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearGoalVolume
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ClearGoalVolume(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ClearGoalVolume@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_DropWeapon
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_DropWeapon(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_DropWeapon@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetDesiredScaledSpeedForPosAlongPath
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetDesiredScaledSpeedForPosAlongPath(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetDesiredScaledSpeedForPosAlongPath@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::CalcGoodShootPos
==============
*/

bool __fastcall AIScriptedInterface::CalcGoodShootPos(AIScriptedInterface *this)
{
  return ?CalcGoodShootPos@AIScriptedInterface@@IEBA_NXZ(this);
}

/*
==============
AIScriptedInterface::OnScrCmd_UpdateCoverExposeType
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_UpdateCoverExposeType(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_UpdateCoverExposeType@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::CalculateSharpTurnExitAnim
==============
*/

bool __fastcall AIScriptedInterface::CalculateSharpTurnExitAnim(AIScriptedInterface *this, int *angleIndices, unsigned int angleIndexCount, scr_string_t animsetName, scr_string_t stateName, const char *prefix, const char *suffix, scr_anim_t *outAnim, int *outAngleIndex, int *outAnimEntryIndex)
{
  return ?CalculateSharpTurnExitAnim@AIScriptedInterface@@QEBA_NQEAHIW4scr_string_t@@1PEBD2PEAUscr_anim_t@@PEAH4@Z(this, angleIndices, angleIndexCount, animsetName, stateName, prefix, suffix, outAnim, outAngleIndex, outAnimEntryIndex);
}

/*
==============
AIScriptedInterface::OnScrCmd_ConstrainToScriptGoalRadius
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ConstrainToScriptGoalRadius(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ConstrainToScriptGoalRadius@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_AISuppressAI
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_AISuppressAI(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AISuppressAI@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AICommonInterface::OnScrCmd_SetNavLayer
==============
*/

void __fastcall AICommonInterface::OnScrCmd_SetNavLayer(AICommonInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetNavLayer@AICommonInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetRiotshieldWeapon
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetRiotshieldWeapon(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetRiotshieldWeapon@AIScriptedInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::CalculateStopAnim
==============
*/

scr_anim_t __fastcall AIScriptedInterface::CalculateStopAnim(AIScriptedInterface *this, int angleIndex, scr_string_t animsetName, scr_string_t stateName, const char *footPrefix, const char *optionalPrefix, const char *speedString, int *outAnimEntryIndex)
{
  return ?CalculateStopAnim@AIScriptedInterface@@QEBA?AUscr_anim_t@@HW4scr_string_t@@0PEBD11PEAH@Z(this, angleIndex, animsetName, stateName, footPrefix, optionalPrefix, speedString, outAnimEntryIndex);
}

/*
==============
AIScriptedInterface::OnScrCmd_AnimMode
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_AnimMode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AnimMode@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_FindOverrideArchetype
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_FindOverrideArchetype(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_FindOverrideArchetype@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_AtDangerousNode
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_AtDangerousNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AtDangerousNode@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AICommonInterface::OnScrCmd_GetStairsStateAtDist
==============
*/

void __fastcall AICommonInterface::OnScrCmd_GetStairsStateAtDist(AICommonInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetStairsStateAtDist@AICommonInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsCurrentEnemyValid
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_IsCurrentEnemyValid(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_IsCurrentEnemyValid@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_AllowedStances
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_AllowedStances(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AllowedStances@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_FindBestCoverNode
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_FindBestCoverNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_FindBestCoverNode@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_CanDoRetreat
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_CanDoRetreat(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_CanDoRetreat@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_NearClaimNode
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_NearClaimNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_NearClaimNode@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::CalcStopData
==============
*/

bool __fastcall AIScriptedInterface::CalcStopData(AIScriptedInterface *this, const vec3_t *targetPos, const vec3_t *targetAngles, const vec3_t *animTargetAngles, const vec3_t *codeApproachDir, bool bApproachDirValid, const scr_string_t *stateName, const char *footPrefix, const char *optionalPrefix, float maxLerpScale, float overShootRatio, const scr_string_t *nodeType, const scr_string_t *startNotetrack, const scr_string_t *endNotetrack, const char *speedString, AIAnimStopData *outStopData)
{
  return ?CalcStopData@AIScriptedInterface@@QEBA_NAEBTvec3_t@@000_NAEBW4scr_string_t@@PEBD3MM2223AEAUAIAnimStopData@@@Z(this, targetPos, targetAngles, animTargetAngles, codeApproachDir, bApproachDirValid, stateName, footPrefix, optionalPrefix, maxLerpScale, overShootRatio, nodeType, startNotetrack, endNotetrack, speedString, outStopData);
}

/*
==============
AIScriptedInterface::SetupMotionWarpForTurn
==============
*/

bool __fastcall AIScriptedInterface::SetupMotionWarpForTurn(AIScriptedInterface *this, const vec3_t *corner, const vec3_t *nextPathPoint, const vec3_t *turnStartAnimTranslation, const vec3_t *turnStartAnimRot, float turnStartSecs)
{
  return ?SetupMotionWarpForTurn@AIScriptedInterface@@QEBA_NTvec3_t@@000M@Z(this, corner, nextPathPoint, turnStartAnimTranslation, turnStartAnimRot, turnStartSecs);
}

/*
==============
AIScriptedInterface::OnScrCmd_FindCoverNode
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_FindCoverNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_FindCoverNode@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::CanSeePointFromExposedAtNode
==============
*/

bool __fastcall AIScriptedInterface::CanSeePointFromExposedAtNode(AIScriptedInterface *this, const vec3_t *point, const pathnode_t *pNode, ai_stance_e stance)
{
  return ?CanSeePointFromExposedAtNode@AIScriptedInterface@@IEBA_NAEBTvec3_t@@PEBUpathnode_t@@W4ai_stance_e@@@Z(this, point, pNode, stance);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetFlashBanged
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetFlashBanged(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetFlashBanged@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearFixedNodeSafeVolume
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ClearFixedNodeSafeVolume(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ClearFixedNodeSafeVolume@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetPointAfterNegotiation
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetPointAfterNegotiation(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetPointAfterNegotiation@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_MayMoveFromPointToPoint
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_MayMoveFromPointToPoint(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_MayMoveFromPointToPoint@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AICommonInterface::OnScrCmd_StairsWithinDistance
==============
*/

void __fastcall AICommonInterface::OnScrCmd_StairsWithinDistance(AICommonInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_StairsWithinDistance@AICommonInterface@@UEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetFixedNodeSafeVolume
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetFixedNodeSafeVolume(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetFixedNodeSafeVolume@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_CalcStopData
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_CalcStopData(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_CalcStopData@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetAimAngles
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetAimAngles(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetAimAngles@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_FindNearbyCoverNode
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_FindNearbyCoverNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_FindNearbyCoverNode@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearEntityTarget
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ClearEntityTarget(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ClearEntityTarget@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetupMotionWarpForTurn
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetupMotionWarpForTurn(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetupMotionWarpForTurn@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsKnownEnemyInVolume
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_IsKnownEnemyInVolume(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_IsKnownEnemyInVolume@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetBTGoalHeight
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetBTGoalHeight(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetBTGoalHeight@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetEngagementMaxDist
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetEngagementMaxDist(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetEngagementMaxDist@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_UseCoverNode
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_UseCoverNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_UseCoverNode@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_PushPlayer
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_PushPlayer(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_PushPlayer@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_StartZeroArrival
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_StartZeroArrival(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_StartZeroArrival@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetBTGoalNode
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetBTGoalNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetBTGoalNode@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::SetIdleFacingUseAlliesPos
==============
*/

void __fastcall AIScriptedInterface::SetIdleFacingUseAlliesPos(AIScriptedInterface *this, const vec3_t *pos)
{
  ?SetIdleFacingUseAlliesPos@AIScriptedInterface@@IEBAXAEBTvec3_t@@@Z(this, pos);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetCoverNode
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetCoverNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetCoverNode@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsInScriptedState
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_IsInScriptedState(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_IsInScriptedState@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_FindReacquireDirectPath
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_FindReacquireDirectPath(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_FindReacquireDirectPath@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_OrientMode
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_OrientMode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_OrientMode@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetTargetSpeed
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetTargetSpeed(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetTargetSpeed@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_AIGetAnimWeight
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_AIGetAnimWeight(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AIGetAnimWeight@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_ResetThreatUpdate
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ResetThreatUpdate(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ResetThreatUpdate@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearBlackboard
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ClearBlackboard(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ClearBlackboard@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetNodeLeanAimYaw
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetNodeLeanAimYaw(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetNodeLeanAimYaw@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_AmbushCheckPath
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_AmbushCheckPath(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AmbushCheckPath@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearOverrideArchetype
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ClearOverrideArchetype(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ClearOverrideArchetype@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AICommonInterface::OnScrCmd_GetNegotiationEndNode
==============
*/

void __fastcall AICommonInterface::OnScrCmd_GetNegotiationEndNode(AICommonInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetNegotiationEndNode@AICommonInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_CanSeePeripheral
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_CanSeePeripheral(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_CanSeePeripheral@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetAimAngle
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetAimAngle(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetAimAngle@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetGoalVolumeAuto
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetGoalVolumeAuto(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetGoalVolumeAuto@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetEntityTarget
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetEntityTarget(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetEntityTarget@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_ShootBlank
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ShootBlank(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ShootBlank@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsKnownEnemyInRadius
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_IsKnownEnemyInRadius(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_IsKnownEnemyInRadius@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::FindGoodSuppressSpot
==============
*/

bool __fastcall AIScriptedInterface::FindGoodSuppressSpot(AIScriptedInterface *this, const vec3_t *startOffset)
{
  return ?FindGoodSuppressSpot@AIScriptedInterface@@IEBA_NAEBTvec3_t@@@Z(this, startOffset);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetGroundEntType
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetGroundEntType(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetGroundEntType@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetGoalEntity
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetGoalEntity(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetGoalEntity@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_StartBeam
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_StartBeam(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_StartBeam@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetGoalVolume
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetGoalVolume(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetGoalVolume@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::NeedRecalculateSuppressSpot
==============
*/

bool __fastcall AIScriptedInterface::NeedRecalculateSuppressSpot(AIScriptedInterface *this)
{
  return ?NeedRecalculateSuppressSpot@AIScriptedInterface@@IEBA_NXZ(this);
}

/*
==============
AIScriptedInterface::OnScrCmd_AIClearGesture
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_AIClearGesture(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_AIClearGesture@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearDoorOpen
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ClearDoorOpen(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_ClearDoorOpen@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetNodeLeanAimYawOffset
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_GetNodeLeanAimYawOffset(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_GetNodeLeanAimYawOffset@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetBackupCoverFromPos
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_SetBackupCoverFromPos(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_SetBackupCoverFromPos@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_StopBeam
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_StopBeam(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_StopBeam@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_FindShuffleCoverNode
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_FindShuffleCoverNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_FindShuffleCoverNode@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
AIScriptedInterface::OnScrCmd_MayMoveToPoint
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_MayMoveToPoint(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ?OnScrCmd_MayMoveToPoint@AIScriptedInterface@@QEBAXAEAUscrContext_t@@@Z(this, scrContext);
}

/*
==============
ChooseArrivalPose
==============
*/
__int64 ChooseArrivalPose(const AIScriptedInterface *pAI, const pathnode_t *pNode, const vec3_t *nodePos)
{
  int v7; 
  bool v8; 
  bool v9; 
  __int64 result; 
  char v11; 

  _R14 = nodePos;
  v7 = *(_DWORD *)(pAI->GetAI(&pAI->AICommonInterface) + 480);
  v8 = (!pNode || Path_DoesNodeAllowStance(pNode, (const scr_string_t)scr_const.stand)) && AIScriptedInterface::IsStanceAllowed((AIScriptedInterface *)pAI, STANCE_STAND);
  v9 = (!pNode || Path_DoesNodeAllowStance(pNode, (const scr_string_t)scr_const.crouch)) && AIScriptedInterface::IsStanceAllowed((AIScriptedInterface *)pAI, STANCE_CROUCH) && v7 != scr_const.casual && v7 != scr_const.casual_gun;
  if ( v8 )
  {
    *(double *)&_XMM0 = AIScriptedInterface::GetTargetSpeed((AIScriptedInterface *)pAI);
    __asm { vcomiss xmm0, cs:__real@42e60000 }
    if ( v11 )
      return 1i64;
  }
  else if ( !v9 )
  {
    return 4i64;
  }
  __asm
  {
    vmovss  xmm0, dword ptr [r14+4]
    vaddss  xmm1, xmm0, dword ptr [r14]
    vaddss  xmm2, xmm1, dword ptr [r14+8]
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, ecx
    vaddss  xmm1, xmm2, xmm0
    vcvttss2si eax, xmm1
  }
  if ( (_EAX & 1) == 0 && v8 )
    return 1i64;
  result = 2i64;
  if ( !v9 )
    return 1i64;
  return result;
}

/*
==============
GScr_BtRegisterTree
==============
*/
void GScr_BtRegisterTree(scrContext_t *scrContext)
{
  const char *String; 

  String = Scr_GetString(scrContext, 0);
  AI_BT_RegisterBehaviorTree(String);
}

/*
==============
AIScr_SetSpeedThreshold
==============
*/
void AIScr_SetSpeedThreshold(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  scr_string_t v3; 
  int Int; 

  ConstString = Scr_GetConstString(scrContext, 0);
  v3 = Scr_GetConstString(scrContext, 1u);
  Int = Scr_GetInt(scrContext, 2u);
  if ( Int <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 110, ASSERT_TYPE_ASSERT, "(thresholdValue > 0)", "%s\n\tSpeed threshold values need to be greater than 0", "thresholdValue > 0") )
    __debugbreak();
  SetSpeedThresholdEntry(ConstString, v3, Int);
}

/*
==============
AIScr_InitMaxSpeedForPathLengthTable
==============
*/

void __fastcall AIScr_InitMaxSpeedForPathLengthTable(scrContext_t *scrContext)
{
  InitializeMaxSpeedForPathLengthTable();
}

/*
==============
AIScr_AnimSpeedThresholdsExist
==============
*/
void AIScr_AnimSpeedThresholdsExist(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  bool v3; 

  ConstString = Scr_GetConstString(scrContext, 0);
  v3 = HasAnimSpeedThresholdsForArchetype(ConstString);
  Scr_AddBool(scrContext, v3);
}

/*
==============
AIScr_HasAnimSpeedThresholdString
==============
*/
void AIScr_HasAnimSpeedThresholdString(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  scr_string_t v3; 
  bool v4; 

  ConstString = Scr_GetConstString(scrContext, 0);
  v3 = Scr_GetConstString(scrContext, 1u);
  v4 = HasAnimSpeedThresholdEntryForArchetype(ConstString, v3);
  Scr_AddBool(scrContext, v4);
}

/*
==============
AIScr_GetAnimSpeedThreshold
==============
*/
void AIScr_GetAnimSpeedThreshold(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  scr_string_t v3; 
  int AnimSpeedThresholdValue; 

  ConstString = Scr_GetConstString(scrContext, 0);
  v3 = Scr_GetConstString(scrContext, 1u);
  AnimSpeedThresholdValue = GetAnimSpeedThresholdValue(ConstString, v3);
  if ( AnimSpeedThresholdValue < 0 )
    Scr_AddUndefined(scrContext);
  else
    Scr_AddInt(scrContext, AnimSpeedThresholdValue);
}

/*
==============
AIScr_GetNearestSpeedThresholdName
==============
*/
void AIScr_GetNearestSpeedThresholdName(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  scr_string_t NearestSpeedThresholdString; 

  ConstString = Scr_GetConstString(scrContext, 0);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm { vmovaps xmm1, xmm0; desiredSpeed }
  NearestSpeedThresholdString = GetNearestSpeedThresholdString(ConstString, *(float *)&_XMM1);
  if ( NearestSpeedThresholdString )
    Scr_AddConstString(scrContext, NearestSpeedThresholdString);
  else
    Scr_AddUndefined(scrContext);
}

/*
==============
AIScr_GetNextLowestSpeedThresholdString
==============
*/
void AIScr_GetNextLowestSpeedThresholdString(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  scr_string_t NextLowestSpeedThresholdName; 

  ConstString = Scr_GetConstString(scrContext, 0);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm { vmovaps xmm1, xmm0; desiredSpeed }
  NextLowestSpeedThresholdName = GetNextLowestSpeedThresholdName(ConstString, *(float *)&_XMM1);
  if ( NextLowestSpeedThresholdName )
    Scr_AddConstString(scrContext, NextLowestSpeedThresholdName);
  else
    Scr_AddUndefined(scrContext);
}

/*
==============
AIScr_GetAnimSpeedBetweenThresholds
==============
*/

void __fastcall AIScr_GetAnimSpeedBetweenThresholds(scrContext_t *scrContext, double _XMM1_8)
{
  scr_string_t ConstString; 
  scr_string_t v5; 
  scr_string_t v6; 
  char v9; 

  ConstString = Scr_GetConstString(scrContext, 0);
  v5 = Scr_GetConstString(scrContext, 1u);
  v6 = Scr_GetConstString(scrContext, 2u);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
  __asm { vmovaps xmm3, xmm0; fractionValue }
  *(double *)&_XMM0 = GetAnimSpeedBetweenThresholdEntries(ConstString, v5, v6, *(float *)&_XMM3);
  __asm
  {
    vxorps  xmm1, xmm1, xmm1
    vcomiss xmm0, xmm1
  }
  if ( v9 )
  {
    Scr_AddUndefined(scrContext);
  }
  else
  {
    __asm { vmovaps xmm1, xmm0; value }
    Scr_AddFloat(scrContext, *(float *)&_XMM1);
  }
}

/*
==============
AIScr_GetCoverAngleLimits
==============
*/
void AIScr_GetCoverAngleLimits(scrContext_t *scrContext)
{
  pathnode_t *Pathnode; 
  ai_stance_e v3; 
  int v4; 
  unsigned __int16 type; 
  unsigned __int16 coverMultiType; 
  const char *v7; 
  unsigned __int16 v8; 
  const char *v9; 
  int outLimitsCount; 
  vec3_t pos; 

  Pathnode = Scr_GetPathnode(scrContext, 0);
  v3 = STANCE_ANY;
  if ( Scr_GetConstString(scrContext, 1u) == scr_const.stand )
    v3 = STANCE_STAND;
  v4 = 0;
  outLimitsCount = 0;
  type = Pathnode->constant.type;
  if ( type == 31 )
    coverMultiType = Pathnode->dynamic.coverMultiType;
  else
    coverMultiType = Pathnode->constant.type;
  if ( ((1 << type) & 0x1E300000) != 0 || ((1 << type) & 0x400000) != 0 )
  {
    pathnode_t::GetPos(Pathnode, &pos);
    v7 = vtos(&pos);
    v8 = Path_ConvertNodeToIndex(Pathnode);
    v9 = j_va("Cannot get cover angle limits for 3D node %d at %s", v8, v7);
    Scr_Error(COM_ERR_5903, scrContext, v9);
  }
  _RBX = GetCoverAngleLimits(coverMultiType, v3, &outLimitsCount);
  Scr_MakeArray(scrContext);
  if ( outLimitsCount > 0 )
  {
    do
    {
      __asm { vmovss  xmm1, dword ptr [rbx]; value }
      Scr_AddFloat(scrContext, *(float *)&_XMM1);
      Scr_AddArray(scrContext);
      ++v4;
      ++_RBX;
    }
    while ( v4 < outLimitsCount );
  }
}

/*
==============
AIScr_Get3DCoverAngleLimits
==============
*/
void AIScr_Get3DCoverAngleLimits(scrContext_t *scrContext)
{
  pathnode_t *Pathnode; 
  int v3; 
  int outLimitsCount; 

  Pathnode = Scr_GetPathnode(scrContext, 0);
  v3 = 0;
  outLimitsCount = 0;
  _RDI = Get3DCoverAngleLimits(Pathnode->constant.type, &outLimitsCount);
  Scr_MakeArray(scrContext);
  if ( outLimitsCount > 0 )
  {
    do
    {
      __asm { vmovss  xmm1, dword ptr [rdi]; value }
      Scr_AddFloat(scrContext, *(float *)&_XMM1);
      Scr_AddArray(scrContext);
      ++v3;
      ++_RDI;
    }
    while ( v3 < outLimitsCount );
  }
}

/*
==============
AIScr_GetCoverCrouchAngleLimits
==============
*/
void AIScr_GetCoverCrouchAngleLimits(scrContext_t *scrContext)
{
  scr_string_t ConstLowercaseString; 
  int v3; 
  int outLimitsCount; 

  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  v3 = 0;
  outLimitsCount = 0;
  _RDI = GetCoverCrouchAngleLimits(ConstLowercaseString, &outLimitsCount);
  Scr_MakeArray(scrContext);
  if ( outLimitsCount > 0 )
  {
    do
    {
      __asm { vmovss  xmm1, dword ptr [rdi]; value }
      Scr_AddFloat(scrContext, *(float *)&_XMM1);
      Scr_AddArray(scrContext);
      ++v3;
      ++_RDI;
    }
    while ( v3 < outLimitsCount );
  }
}

/*
==============
GScr_GetAngleIndices
==============
*/
void GScr_GetAngleIndices(scrContext_t *scrContext)
{
  __int64 v6; 
  unsigned int outAngleIndexCount; 
  int outAngleIndices[4]; 

  __asm { vmovaps [rsp+58h+var_18], xmm6 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm { vmovaps xmm6, xmm0 }
  if ( Scr_GetNumParam(scrContext) == 2 )
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  else
    __asm { vmovss  xmm0, cs:__real@41200000 }
  __asm { vmovaps xmm1, xmm0; threshold }
  v6 = 0i64;
  __asm { vmovaps xmm0, xmm6; angle }
  outAngleIndexCount = 0;
  G_GetAngleIndices(*(const float *)&_XMM0, *(const float *)&_XMM1, outAngleIndices, &outAngleIndexCount);
  Scr_MakeArray(scrContext);
  if ( outAngleIndexCount )
  {
    do
    {
      Scr_AddInt(scrContext, outAngleIndices[v6]);
      Scr_AddArray(scrContext);
      v6 = (unsigned int)(v6 + 1);
    }
    while ( (unsigned int)v6 < outAngleIndexCount );
  }
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
}

/*
==============
GScr_GetAngleIndex
==============
*/
void GScr_GetAngleIndex(scrContext_t *scrContext)
{
  int AngleIndex; 

  __asm { vmovaps [rsp+38h+var_18], xmm6 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm { vmovaps xmm6, xmm0 }
  if ( Scr_GetNumParam(scrContext) == 2 )
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  else
    __asm { vmovss  xmm0, cs:__real@41200000 }
  __asm
  {
    vmovaps xmm1, xmm0; threshold
    vmovaps xmm0, xmm6; angle
  }
  AngleIndex = G_GetAngleIndex(*(const float *)&_XMM0, *(const float *)&_XMM1);
  __asm { vmovaps xmm6, [rsp+38h+var_18] }
  Scr_AddInt(scrContext, AngleIndex);
}

/*
==============
GScr_HasRoomToPlayPeekout
==============
*/
void GScr_HasRoomToPlayPeekout(scrContext_t *scrContext)
{
  pathnode_t *Pathnode; 
  int v3; 
  scr_string_t dir; 

  Pathnode = Scr_GetPathnode(scrContext, 0);
  v3 = 1;
  if ( Pathnode->constant.totalLinkCount )
  {
    dir = Scr_GetConstString(scrContext, 1u);
    v3 = HasRoomToPlayPeekout(Pathnode, &dir);
  }
  Scr_AddBool(scrContext, v3);
}

/*
==============
AIScr_FindClosestLOSPointWithinVolume
==============
*/
void AIScr_FindClosestLOSPointWithinVolume(scrContext_t *scrContext)
{
  int numIgnoreVecs; 
  const gentity_s *Entity; 
  const tacpoint_t *ClosestPoint; 
  const tacpoint_t *ClosestPointWithVisWithinVolumeIgnorePoints; 
  float v7; 
  vec3_t pos; 
  vec3_t vectorValue; 
  vec3_t outPos; 
  vec3_t pVecArray; 

  numIgnoreVecs = 1;
  Entity = GScr_GetEntity(0);
  Scr_GetVector(scrContext, 1u, &vectorValue);
  ClosestPoint = TacGraph_FindClosestPoint(&vectorValue);
  if ( ClosestPoint )
  {
    Scr_GetVector(scrContext, 2u, &pos);
    if ( (int)Scr_GetNumParam(scrContext) <= 3 || Scr_GetType(scrContext, 3u) == VAR_UNDEFINED )
      goto LABEL_9;
    if ( Scr_GetType(scrContext, 3u) == VAR_VECTOR )
      Scr_GetVector(scrContext, 3u, &pVecArray);
    else
      numIgnoreVecs = GetVectorArray(scrContext, 3, &pVecArray, 128);
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 4u);
    if ( numIgnoreVecs )
    {
      __asm { vmovss  [rsp+678h+var_650], xmm0 }
      ClosestPointWithVisWithinVolumeIgnorePoints = TacGraph_FindClosestPointWithVisWithinVolumeIgnorePoints(Entity, &pos, ClosestPoint, &pVecArray, numIgnoreVecs, v7);
    }
    else
    {
LABEL_9:
      ClosestPointWithVisWithinVolumeIgnorePoints = TacGraph_FindClosestPointWithVisWithinVolume(Entity, &pos, ClosestPoint);
    }
    if ( ClosestPointWithVisWithinVolumeIgnorePoints )
    {
      TacGraph_GetApproxGroundPosForPoint(ClosestPointWithVisWithinVolumeIgnorePoints, &outPos);
      Scr_AddVector(scrContext, outPos.v);
    }
  }
}

/*
==============
AIScr_FindClosestLOSPointWithinRadius
==============
*/
void AIScr_FindClosestLOSPointWithinRadius(scrContext_t *scrContext)
{
  int numIgnoreVecs; 
  const tacpoint_t *ClosestPoint; 
  const tacpoint_t *ClosestPointWithVisWithinRadiusIgnorePoints; 
  float v12; 
  vec3_t v13; 
  vec3_t vectorValue; 
  vec3_t pos; 
  vec3_t outPos; 
  vec3_t pVecArray; 
  char v19; 

  __asm { vmovaps [rsp+3A8h+var_18], xmm6 }
  Scr_GetVector(scrContext, 0, &vectorValue);
  numIgnoreVecs = 1;
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm { vmovaps xmm6, xmm0 }
  Scr_GetVector(scrContext, 2u, &pos);
  ClosestPoint = TacGraph_FindClosestPoint(&pos);
  if ( ClosestPoint )
  {
    Scr_GetVector(scrContext, 3u, &v13);
    if ( (int)Scr_GetNumParam(scrContext) <= 4 || Scr_GetType(scrContext, 4u) == VAR_UNDEFINED )
      goto LABEL_9;
    if ( Scr_GetType(scrContext, 4u) == VAR_VECTOR )
      Scr_GetVector(scrContext, 4u, &pVecArray);
    else
      numIgnoreVecs = GetVectorArray(scrContext, 4, &pVecArray, 64);
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 5u);
    if ( numIgnoreVecs )
    {
      __asm
      {
        vmovss  [rsp+3A8h+var_378], xmm0
        vmovaps xmm1, xmm6; radius
      }
      ClosestPointWithVisWithinRadiusIgnorePoints = TacGraph_FindClosestPointWithVisWithinRadiusIgnorePoints(&vectorValue, *(float *)&_XMM1, &v13, ClosestPoint, &pVecArray, numIgnoreVecs, v12);
    }
    else
    {
LABEL_9:
      __asm { vmovaps xmm1, xmm6; radius }
      ClosestPointWithVisWithinRadiusIgnorePoints = TacGraph_FindClosestPointWithVisWithinRadius(&vectorValue, *(float *)&_XMM1, &v13, ClosestPoint);
    }
    if ( ClosestPointWithVisWithinRadiusIgnorePoints )
    {
      TacGraph_GetApproxGroundPosForPoint(ClosestPointWithVisWithinRadiusIgnorePoints, &outPos);
      Scr_AddVector(scrContext, outPos.v);
    }
  }
  _R11 = &v19;
  __asm { vmovaps xmm6, xmmword ptr [r11-10h] }
}

/*
==============
AIScr_FindClosestNonLOSPointWithinVolume
==============
*/

void __fastcall AIScr_FindClosestNonLOSPointWithinVolume(scrContext_t *scrContext, double _XMM1_8)
{
  int VectorArray; 
  const gentity_s *Entity; 
  const tacpoint_t *ClosestPoint; 
  int NumParam; 
  char v11; 
  char v12; 
  const tacpoint_t *ClosestPointWithoutVisWithinVolume; 
  int numIgnoreVecs; 
  float v17; 
  vec3_t pos; 
  vec3_t vectorValue; 
  vec3_t dir; 
  vec3_t outPos; 
  vec3_t pVecArray; 

  __asm
  {
    vmovaps [rsp+528h+var_28], xmm6
    vmovss  xmm6, cs:__real@bf800000
  }
  VectorArray = 0;
  Entity = GScr_GetEntity(0);
  Scr_GetVector(scrContext, 1u, &vectorValue);
  ClosestPoint = TacGraph_FindClosestPoint(&vectorValue);
  if ( ClosestPoint )
  {
    Scr_GetVector(scrContext, 2u, &pos);
    NumParam = Scr_GetNumParam(scrContext);
    if ( NumParam > 3 && Scr_GetType(scrContext, 3u) )
    {
      if ( NumParam < 5 )
        Scr_Error(COM_ERR_3814, scrContext, "ignore points specified without providing radius.");
      *(double *)&_XMM0 = Scr_GetFloat(scrContext, 4u);
      __asm
      {
        vxorps  xmm1, xmm1, xmm1
        vcomiss xmm0, xmm1
        vmovaps xmm6, xmm0
      }
      if ( v11 | v12 )
        Scr_Error(COM_ERR_3815, scrContext, "ignore radius must be > 0");
      if ( Scr_GetType(scrContext, 3u) == VAR_VECTOR )
      {
        Scr_GetVector(scrContext, 3u, &pVecArray);
        VectorArray = 1;
      }
      else
      {
        VectorArray = GetVectorArray(scrContext, 3, &pVecArray, 96);
      }
    }
    if ( NumParam <= 5 )
    {
      if ( VectorArray <= 0 )
      {
        ClosestPointWithoutVisWithinVolume = TacGraph_FindClosestPointWithoutVisWithinVolume(Entity, &pos, ClosestPoint);
      }
      else
      {
        __asm { vmovss  [rsp+528h+var_500], xmm6 }
        ClosestPointWithoutVisWithinVolume = TacGraph_FindClosestPointWithoutVisWithinVolumeIgnorePoints(Entity, &pos, ClosestPoint, &pVecArray, VectorArray, v17);
      }
    }
    else
    {
      if ( NumParam < 7 )
        Scr_Error(COM_ERR_3816, scrContext, "direction specified without providing weight.");
      Scr_GetVector(scrContext, 5u, &dir);
      *(double *)&_XMM0 = Scr_GetFloat(scrContext, 6u);
      __asm { vmovaps xmm6, xmm0 }
      if ( VectorArray > 0 )
        Scr_Error(COM_ERR_3817, scrContext, "no one was using this function, so did not bother implementing an ignorepoints version.");
      __asm { vmovss  [rsp+528h+numIgnoreVecs], xmm6 }
      ClosestPointWithoutVisWithinVolume = TacGraph_FindClosestPointWithoutVisNearConeWithinVolume(Entity, &pos, ClosestPoint, &dir, *(float *)&numIgnoreVecs);
    }
    if ( ClosestPointWithoutVisWithinVolume )
    {
      TacGraph_GetApproxGroundPosForPoint(ClosestPointWithoutVisWithinVolume, &outPos);
      Scr_AddVector(scrContext, outPos.v);
    }
  }
  __asm { vmovaps xmm6, [rsp+528h+var_28] }
}

/*
==============
AIScr_FindClosestNonLOSPointWithinRadius
==============
*/

void __fastcall AIScr_FindClosestNonLOSPointWithinRadius(scrContext_t *scrContext, double _XMM1_8)
{
  int VectorArray; 
  const tacpoint_t *ClosestPoint; 
  int NumParam; 
  char v13; 
  char v14; 
  const tacpoint_t *ClosestPointWithoutVisWithinRadius; 
  int numIgnoreVecs; 
  float v23; 
  vec3_t v24; 
  vec3_t vectorValue; 
  vec3_t pos; 
  vec3_t dir; 
  vec3_t outPos; 
  vec3_t pVecArray; 
  char v30; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-18h], xmm6
    vmovaps xmmword ptr [rax-28h], xmm7
    vmovss  xmm6, cs:__real@bf800000
  }
  VectorArray = 0;
  Scr_GetVector(scrContext, 0, &vectorValue);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm { vmovaps xmm7, xmm0 }
  Scr_GetVector(scrContext, 2u, &pos);
  ClosestPoint = TacGraph_FindClosestPoint(&pos);
  if ( ClosestPoint )
  {
    Scr_GetVector(scrContext, 3u, &v24);
    NumParam = Scr_GetNumParam(scrContext);
    if ( NumParam > 4 && Scr_GetType(scrContext, 4u) )
    {
      *(double *)&_XMM0 = Scr_GetFloat(scrContext, 5u);
      __asm
      {
        vxorps  xmm1, xmm1, xmm1
        vcomiss xmm0, xmm1
        vmovaps xmm6, xmm0
      }
      if ( v13 | v14 )
        Scr_Error(COM_ERR_3819, scrContext, "ignore radius must be > 0");
      if ( Scr_GetType(scrContext, 4u) == VAR_VECTOR )
      {
        Scr_GetVector(scrContext, 4u, &pVecArray);
        VectorArray = 1;
      }
      else
      {
        VectorArray = GetVectorArray(scrContext, 4, &pVecArray, 64);
      }
    }
    if ( NumParam <= 6 )
    {
      __asm { vmovaps xmm1, xmm7; radius }
      if ( VectorArray <= 0 )
      {
        ClosestPointWithoutVisWithinRadius = TacGraph_FindClosestPointWithoutVisWithinRadius(&vectorValue, *(float *)&_XMM1, &v24, ClosestPoint);
      }
      else
      {
        __asm { vmovss  [rsp+3C8h+var_398], xmm6 }
        ClosestPointWithoutVisWithinRadius = TacGraph_FindClosestPointWithoutVisWithinRadiusIgnorePoints(&vectorValue, *(float *)&_XMM1, &v24, ClosestPoint, &pVecArray, VectorArray, v23);
      }
    }
    else
    {
      if ( NumParam < 8 )
        Scr_Error(COM_ERR_3820, scrContext, "direction specified without providing weight.");
      Scr_GetVector(scrContext, 6u, &dir);
      *(double *)&_XMM0 = Scr_GetFloat(scrContext, 7u);
      __asm { vmovaps xmm6, xmm0 }
      if ( VectorArray > 0 )
        Scr_Error(COM_ERR_3821, scrContext, "no one was using this function, so did not bother implementing an ignorepoints version.");
      __asm
      {
        vmovss  [rsp+3C8h+numIgnoreVecs], xmm6
        vmovaps xmm1, xmm7; radius
      }
      ClosestPointWithoutVisWithinRadius = TacGraph_FindClosestPointWithoutVisNearConeWithinRadius(&vectorValue, *(float *)&_XMM1, &v24, ClosestPoint, &dir, *(float *)&numIgnoreVecs);
    }
    if ( ClosestPointWithoutVisWithinRadius )
    {
      TacGraph_GetApproxGroundPosForPoint(ClosestPointWithoutVisWithinRadius, &outPos);
      Scr_AddVector(scrContext, outPos.v);
    }
  }
  _R11 = &v30;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
  }
}

/*
==============
AIScr_FindOpenLookDir
==============
*/
void AIScr_FindOpenLookDir(scrContext_t *scrContext)
{
  gentity_s *Entity; 
  ai_common_t *AICommon; 
  AINavigator *pNavigator; 
  AINavigator2D *v13; 
  const bfx::AreaHandle *CurArea; 
  int BestSlice; 
  vec3_t angles; 
  vec3_t vectorValue; 
  vec3_t forward; 
  float pResults[16]; 
  void *retaddr; 

  _R11 = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [r11-18h], xmm6
    vmovaps xmmword ptr [r11-28h], xmm7
    vmovaps xmmword ptr [r11-38h], xmm8
  }
  Entity = NULL;
  if ( Scr_GetType(scrContext, 0) == VAR_VECTOR )
    Scr_GetVector(scrContext, 0, &vectorValue);
  else
    Entity = GScr_GetEntity(0);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm
  {
    vmovaps xmm8, xmm0
    vxorps  xmm6, xmm6, xmm6
    vxorps  xmm7, xmm7, xmm7
  }
  if ( Scr_GetNumParam(scrContext) > 2 && Scr_GetType(scrContext, 2u) )
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
    __asm { vmovaps xmm7, xmm0 }
  }
  if ( Entity )
  {
    AICommon = AI_GetAICommon(Entity);
    if ( !AICommon )
      Scr_Error(COM_ERR_3822, scrContext, "ent (arg1) was not an AI");
    pNavigator = AICommon->pNavigator;
    if ( !pNavigator )
    {
      Scr_Error(COM_ERR_3823, scrContext, "AI (arg1) does not have a navigator");
      pNavigator = AICommon->pNavigator;
    }
    v13 = pNavigator->Get2DNavigator(pNavigator);
    if ( !v13 )
      Scr_Error(COM_ERR_3824, scrContext, "FindOpenLookDir only works with AI with 2D nav");
    CurArea = AINavigator2D::GetCurArea(v13);
    __asm { vmovaps xmm1, xmm8; radius }
    TacGraph_CalcOpenView(&Entity->r.currentOrigin, *(float *)&_XMM1, CurArea, pResults, 16);
  }
  else
  {
    __asm { vmovaps xmm1, xmm8; radius }
    TacGraph_CalcOpenView(&vectorValue, *(float *)&_XMM1, pResults, 16);
  }
  __asm { vmovaps xmm2, xmm7; minDist }
  BestSlice = FindBestSlice(pResults, 16, *(float *)&_XMM2);
  __asm
  {
    vmovaps xmm8, [rsp+0E8h+var_38]
    vmovaps xmm7, [rsp+0E8h+var_28]
  }
  if ( BestSlice >= 0 )
    goto LABEL_18;
  __asm { vxorps  xmm2, xmm2, xmm2; minDist }
  if ( FindBestSlice(pResults, 16, *(float *)&_XMM2) >= 0 )
  {
LABEL_18:
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, eax
      vmulss  xmm1, xmm0, cs:__real@41b40000
      vaddss  xmm2, xmm1, cs:__real@41340000
      vmovss  dword ptr [rsp+0E8h+angles+4], xmm2
      vmovss  dword ptr [rsp+0E8h+angles], xmm6
      vmovss  dword ptr [rsp+0E8h+angles+8], xmm6
    }
    AngleVectors(&angles, &forward, NULL, NULL);
    Scr_AddVector(scrContext, forward.v);
  }
  __asm { vmovaps xmm6, [rsp+0E8h+var_18] }
}

/*
==============
AIScr_FindClosestPointByApproxPathDist
==============
*/
void AIScr_FindClosestPointByApproxPathDist(scrContext_t *scrContext)
{
  unsigned int ArrayObject; 
  const char *v13; 
  unsigned int FirstSibling; 
  char v16; 
  VariableType type; 
  unsigned int EntNum; 
  __int64 v21; 
  __int64 v22; 
  ai_common_t *AICommon; 
  ai_common_t *v24; 
  AINavigator *pNavigator; 
  AINavigator2D *v27; 
  const bfx::AreaHandle *CurArea; 
  bfx::AreaHandle *pOutArea; 
  bfx::AreaHandle *pOutAreaa; 
  __int64 numGoals; 
  __int64 numGoalsa; 
  bfx::Vector3 startPos; 
  VariableValue out; 
  bfx::AreaHandle startArea; 
  bfx::MultiPathSpec multiPathSpec; 
  bfx::MultiPathRCPtr result; 
  bfx::MultiPathGoal pGoalArray; 
  __int64 v51; 
  bfx::MultiPathGoalOutput goalOut; 
  vec3_t vectorValue; 
  vec3_t pos; 
  vec3_t outPos; 
  vec3_t v56; 
  bfx::PathSpec pathSpec; 
  bfx::PathSpec pPathSpec; 
  char v59; 
  void *retaddr; 

  _RAX = &retaddr;
  v51 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm6
    vmovaps xmmword ptr [rax-48h], xmm7
    vmovaps xmmword ptr [rax-58h], xmm8
  }
  pPathSpec.m_obstacleMode = BLOCKED_IF_ANY_MATCH;
  *(_QWORD *)&pPathSpec.m_obstacleBlockageFlags = -1i64;
  *(_QWORD *)&pPathSpec.m_areaPenaltyFlags = -1i64;
  pPathSpec.m_usePathSharingPenalty = 0;
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vmovss  [rbp+140h+pPathSpec.m_pathSharingPenalty], xmm6
    vmovss  [rbp+140h+pPathSpec.m_maxPathSharingPenalty], xmm6
    vmovss  [rbp+140h+pPathSpec.m_maxSearchDist], xmm6
  }
  bfx::PenaltyTable::PenaltyTable(&pPathSpec.m_penaltyTable);
  pPathSpec.m_snapMode = SNAP_CLOSEST;
  multiPathSpec.m_generatePaths = 0;
  multiPathSpec.m_maxNumCorners = -1;
  bfx::MultiPathGoal::MultiPathGoal(&pGoalArray);
  Scr_GetVector(scrContext, 1u, &vectorValue);
  __asm
  {
    vmovss  xmm8, cs:__real@bf800000
    vmovaps xmm2, xmm8; radius
  }
  Nav_GetClosestVerticalPosInMostLikelySpace(&vectorValue, NAV_LAYER_HUMAN, *(float *)&_XMM2, &pPathSpec, &vectorValue, &pGoalArray.m_goalArea);
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+140h+vectorValue]
    vmovss  [rbp+140h+pGoalArray.m_goalPos.m_x], xmm0
    vmovss  xmm1, dword ptr [rbp+140h+vectorValue+4]
    vmovss  [rbp+140h+pGoalArray.m_goalPos.m_y], xmm1
    vmovss  xmm0, dword ptr [rbp+140h+vectorValue+8]
    vmovss  [rbp+140h+pGoalArray.m_goalPos.m_z], xmm0
  }
  ArrayObject = BGScr_Main_GetArrayObject(scrContext, 0);
  if ( GetArraySize(scrContext, ArrayObject) > 0x10 )
  {
    v13 = j_va("Exceeded max number of elements (%d).", 16i64);
    Scr_ParamError(COM_ERR_5904, scrContext, 0, v13);
  }
  __asm { vmovss  xmm7, cs:__real@497423f0 }
  bfx::AreaHandle::AreaHandle(&startArea);
  FirstSibling = FindFirstSibling(scrContext, ArrayObject);
  if ( FirstSibling )
  {
    while ( 1 )
    {
      pathSpec.m_obstacleMode = BLOCKED_IF_ANY_MATCH;
      *(_QWORD *)&pathSpec.m_obstacleBlockageFlags = -1i64;
      *(_QWORD *)&pathSpec.m_areaPenaltyFlags = -1i64;
      pathSpec.m_usePathSharingPenalty = 0;
      __asm
      {
        vmovss  [rbp+140h+pathSpec.m_pathSharingPenalty], xmm6
        vmovss  [rbp+140h+pathSpec.m_maxPathSharingPenalty], xmm6
        vmovss  [rbp+140h+pathSpec.m_maxSearchDist], xmm6
      }
      bfx::PenaltyTable::PenaltyTable(&pathSpec.m_penaltyTable);
      pathSpec.m_snapMode = SNAP_CLOSEST;
      v16 = 1;
      Scr_EvalVariable_Out(scrContext, FirstSibling, &out);
      type = out.type;
      if ( out.type == VAR_VECTOR )
      {
        __asm { vmovaps xmm2, xmm8; radius }
        Nav_GetClosestVerticalPosInMostLikelySpace((const vec3_t *)out.u.vectorValue, NAV_LAYER_HUMAN, *(float *)&_XMM2, &pPathSpec, &outPos, &startArea);
        __asm
        {
          vmovsd  xmm0, qword ptr [rbp+140h+var_138]
          vmovsd  qword ptr [rsp+240h+startPos.m_x], xmm0
        }
        startPos.m_z = outPos.v[2];
      }
      else
      {
        if ( out.type == VAR_POINTER )
        {
          if ( GetObjectType(scrContext, out.u.uintValue) == VAR_ENTITY )
          {
            EntNum = Scr_GetEntNum(scrContext, out.u.uintValue);
            v21 = (int)EntNum;
            if ( EntNum >= 0x800 )
            {
              LODWORD(numGoals) = 2048;
              LODWORD(pOutArea) = EntNum;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 1026, ASSERT_TYPE_ASSERT, "(unsigned)( testEntNum ) < (unsigned)( ( 2048 ) )", "testEntNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", pOutArea, numGoals) )
                __debugbreak();
              LODWORD(numGoalsa) = 2048;
              LODWORD(pOutAreaa) = v21;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", pOutAreaa, numGoalsa) )
                __debugbreak();
            }
            if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
              __debugbreak();
            v22 = v21;
            if ( g_entities[v21].r.isInUse != g_entityIsInUse[v21] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
              __debugbreak();
            if ( !g_entityIsInUse[v21] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 1027, ASSERT_TYPE_ASSERT, "(G_IsEntityInUse( testEntNum ))", (const char *)&queryFormat, "G_IsEntityInUse( testEntNum )") )
              __debugbreak();
            AICommon = AI_GetAICommon(&g_entities[v22]);
            v24 = AICommon;
            if ( AICommon && (pNavigator = AICommon->pNavigator) != NULL )
            {
              pNavigator->GetCurPos(pNavigator, &pos);
              __asm
              {
                vmovsd  xmm0, qword ptr [rbp+140h+pos]
                vmovsd  qword ptr [rsp+240h+startPos.m_x], xmm0
              }
              startPos.m_z = pos.v[2];
              v27 = v24->pNavigator->Get2DNavigator(v24->pNavigator);
              _RBX = v27;
              if ( v27 )
              {
                CurArea = AINavigator2D::GetCurArea(v27);
                bfx::AreaHandle::operator=(&startArea, CurArea);
                __asm
                {
                  vmovups ymm0, ymmword ptr [rbx+4A4h]
                  vmovups ymmword ptr [rbp+140h+pathSpec.m_obstacleMode], ymm0
                  vmovups ymm1, ymmword ptr [rbx+4C4h]
                  vmovups ymmword ptr [rbp+140h+pathSpec.m_maxSearchDist], ymm1
                  vmovups xmm0, xmmword ptr [rbx+4E4h]
                  vmovups xmmword ptr [rbp+80h], xmm0
                }
                if ( !bfx::AreaHandle::IsUsable(&pGoalArray.m_goalArea, &pathSpec) )
                  v16 = 0;
              }
              else
              {
                __asm { vmovaps xmm2, xmm8; radius }
                Nav_GetClosestVerticalPosInMostLikelySpace(&pos, NAV_LAYER_HUMAN, *(float *)&_XMM2, &pPathSpec, &pos, &startArea);
              }
            }
            else
            {
              __asm { vmovaps xmm2, xmm8; radius }
              Nav_GetClosestVerticalPosInMostLikelySpace(&g_entities[v22].r.currentOrigin, NAV_LAYER_HUMAN, *(float *)&_XMM2, &pPathSpec, &v56, &startArea);
              __asm
              {
                vmovsd  xmm0, qword ptr [rbp+140h+var_128]
                vmovsd  qword ptr [rsp+240h+startPos.m_x], xmm0
              }
              startPos.m_z = v56.v[2];
            }
            goto LABEL_31;
          }
          type = out.type;
        }
        RemoveRefToValue(scrContext, (unsigned __int8)type, out.u);
        Scr_Error(COM_ERR_5905, scrContext, "Some element of array is neither a vector nor an entity.");
      }
LABEL_31:
      RemoveRefToValue(scrContext, (unsigned __int8)out.type, out.u);
      if ( v16 )
      {
        bfx::SearchToMultipleGoals(&result, &startArea, &startPos, &pathSpec, &multiPathSpec, &pGoalArray, 1);
        bfx::MultiPathGoalOutput::MultiPathGoalOutput(&goalOut);
        if ( bfx::MultiPathRCPtr::GetGoalOutput(&result, 0, &goalOut) && goalOut.m_goalReached )
        {
          __asm
          {
            vmovss  xmm0, [rbp+140h+goalOut.m_approxPathCost]
            vcomiss xmm0, xmm7
          }
        }
        bfx::PolylinePathRCPtr::~PolylinePathRCPtr(&goalOut.m_path);
        bfx::AreaHandle::~AreaHandle(&goalOut.m_goalArea);
        bfx::MultiPathRCPtr::~MultiPathRCPtr(&result);
      }
      FirstSibling = FindNextSibling(scrContext, FirstSibling);
      if ( !FirstSibling )
      {
        __asm { vcomiss xmm7, cs:__real@497423f0 }
        break;
      }
    }
  }
  bfx::AreaHandle::~AreaHandle(&startArea);
  bfx::AreaHandle::~AreaHandle(&pGoalArray.m_goalArea);
  _R11 = &v59;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
  }
}

/*
==============
AICallback_OnScrCmd_SetBTGoalPos
==============
*/
void AICallback_OnScrCmd_SetBTGoalPos(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetBTGoalPos(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetBTGoalNode
==============
*/
void AICallback_OnScrCmd_SetBTGoalNode(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetBTGoalNode(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetBTGoalEnt
==============
*/
void AICallback_OnScrCmd_SetBTGoalEnt(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetBTGoalEnt(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetBTGoalVolume
==============
*/
void AICallback_OnScrCmd_SetBTGoalVolume(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetBTGoalVolume(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ClearBTGoal
==============
*/
void AICallback_OnScrCmd_ClearBTGoal(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ClearBTGoal(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetBTGoalRadius
==============
*/
void AICallback_OnScrCmd_SetBTGoalRadius(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetBTGoalRadius(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetBTGoalHeight
==============
*/
void AICallback_OnScrCmd_SetBTGoalHeight(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetBTGoalHeight(m_pAI, scrContext);
}

/*
==============
AICommonInterface::OnScrCmd_StairsWithinDistance
==============
*/
void AICommonInterface::OnScrCmd_StairsWithinDistance(AICommonInterface *this, scrContext_t *scrContext)
{
  AINavigator *Navigator; 
  gentity_s *v6; 
  const char *v7; 
  unsigned __int8 v9; 

  Navigator = AICommonInterface::GetNavigator(this);
  if ( !Navigator )
  {
    v6 = this->GetEntity(this);
    v7 = j_va("StairsWithinDistance: Entity %d must have a navigator.", (unsigned int)v6->s.number);
    Scr_Error(COM_ERR_5907, scrContext, v7);
  }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm { vmovaps xmm1, xmm0 }
  v9 = ((__int64 (__fastcall *)(AINavigator *))Navigator->GetStairsWithinDist)(Navigator);
  Scr_AddBool(scrContext, v9);
}

/*
==============
AICommonInterface::OnScrCmd_ClearPath
==============
*/
void AICommonInterface::OnScrCmd_ClearPath(AICommonInterface *this, scrContext_t *scrContext)
{
  ((void (__fastcall *)(AICommonInterface *, scrContext_t *))this->ClearPath)(this, scrContext);
}

/*
==============
AICallback_OnScrCmd_BTGoalValid
==============
*/
void AICallback_OnScrCmd_BTGoalValid(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_BTGoalValid(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_IsWithinScriptGoalRadius
==============
*/
void AICallback_OnScrCmd_IsWithinScriptGoalRadius(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_IsWithinScriptGoalRadius(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ConstrainToScriptGoalRadius
==============
*/
void AICallback_OnScrCmd_ConstrainToScriptGoalRadius(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ConstrainToScriptGoalRadius(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_FindLastPointOnPathWithinVolume
==============
*/
void AICallback_OnScrCmd_FindLastPointOnPathWithinVolume(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AICommonInterface *m_pAI; 
  const char *v6; 
  AICommonWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botInterface);
  v7.m_botInterface.__vftable = (AIBotInterface_vtbl *)&AIBotInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botAgentInterface);
  v7.m_pAI = NULL;
  v7.m_botAgentInterface.__vftable = (AIBotAgentInterface_vtbl *)&AIBotAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AICommonWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3805, scrContext, v6);
  }
  AICommonInterface::OnScrCmd_FindLastPointOnPathWithinVolume(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetLastPathPointWithinGoal
==============
*/
void AICallback_OnScrCmd_GetLastPathPointWithinGoal(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AICommonInterface *m_pAI; 
  const char *v6; 
  AICommonWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botInterface);
  v7.m_botInterface.__vftable = (AIBotInterface_vtbl *)&AIBotInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botAgentInterface);
  v7.m_pAI = NULL;
  v7.m_botAgentInterface.__vftable = (AIBotAgentInterface_vtbl *)&AIBotAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AICommonWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3805, scrContext, v6);
  }
  AICommonInterface::OnScrCmd_GetLastPathPointWithinGoal(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetPosOnPath
==============
*/
void AICallback_OnScrCmd_GetPosOnPath(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AICommonInterface *m_pAI; 
  const char *v6; 
  AICommonWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botInterface);
  v7.m_botInterface.__vftable = (AIBotInterface_vtbl *)&AIBotInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botAgentInterface);
  v7.m_pAI = NULL;
  v7.m_botAgentInterface.__vftable = (AIBotAgentInterface_vtbl *)&AIBotAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AICommonWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3805, scrContext, v6);
  }
  AICommonInterface::OnScrCmd_GetPosOnPath(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_IsAtValidLongDeathSpot
==============
*/
void AICallback_OnScrCmd_IsAtValidLongDeathSpot(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_IsAtValidLongDeathSpot(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetStairsStateAtDist
==============
*/
void AICallback_OnScrCmd_GetStairsStateAtDist(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AICommonInterface *m_pAI; 
  const char *v6; 
  AICommonWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botInterface);
  v7.m_botInterface.__vftable = (AIBotInterface_vtbl *)&AIBotInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botAgentInterface);
  v7.m_pAI = NULL;
  v7.m_botAgentInterface.__vftable = (AIBotAgentInterface_vtbl *)&AIBotAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AICommonWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3805, scrContext, v6);
  }
  AICommonInterface::OnScrCmd_GetStairsStateAtDist(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_StairsWithinDistance
==============
*/
void AICallback_OnScrCmd_StairsWithinDistance(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AICommonInterface *m_pAI; 
  const char *v6; 
  AICommonWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botInterface);
  v7.m_botInterface.__vftable = (AIBotInterface_vtbl *)&AIBotInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botAgentInterface);
  v7.m_pAI = NULL;
  v7.m_botAgentInterface.__vftable = (AIBotAgentInterface_vtbl *)&AIBotAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AICommonWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3805, scrContext, v6);
  }
   AICommonInterface::`vcall'{440,{flat}}(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetPathDistToGoal
==============
*/
void AICallback_OnScrCmd_GetPathDistToGoal(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AICommonInterface *m_pAI; 
  const char *v6; 
  AICommonWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botInterface);
  v7.m_botInterface.__vftable = (AIBotInterface_vtbl *)&AIBotInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botAgentInterface);
  v7.m_pAI = NULL;
  v7.m_botAgentInterface.__vftable = (AIBotAgentInterface_vtbl *)&AIBotAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AICommonWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3805, scrContext, v6);
  }
  AICommonInterface::OnScrCmd_GetPathDistToGoal(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_EnableTeamwalking
==============
*/
void AICallback_OnScrCmd_EnableTeamwalking(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AICommonInterface *m_pAI; 
  const char *v6; 
  AICommonWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botInterface);
  v7.m_botInterface.__vftable = (AIBotInterface_vtbl *)&AIBotInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botAgentInterface);
  v7.m_pAI = NULL;
  v7.m_botAgentInterface.__vftable = (AIBotAgentInterface_vtbl *)&AIBotAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AICommonWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3805, scrContext, v6);
  }
  AICommonInterface::OnScrCmd_EnableTeamwalking(m_pAI, scrContext);
}

/*
==============
GScr_BtRegisterTreeInstance
==============
*/
void GScr_BtRegisterTreeInstance(scrContext_t *scrContext, scr_entref_t entref)
{
  scr_string_t ConstString; 
  const char *v5; 
  gentity_s *Entity; 

  ConstString = Scr_GetConstString(scrContext, 0);
  v5 = SL_ConvertToString(ConstString);
  SL_AddRefToString(ConstString);
  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 1651, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  AI_BT_CreateBehaviorTreeInstance(v5, Entity->s.number, 1);
  SL_RemoveRefToString(ConstString);
  Scr_AddInt(scrContext, 1);
}

/*
==============
GScr_BtTerminateTreeInstance
==============
*/
void GScr_BtTerminateTreeInstance(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int number; 

  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 1673, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  number = Entity->s.number;
  AI_BT_Terminate(number);
  AI_BT_FreeTreeInstance(number);
}

/*
==============
GScr_BtTick
==============
*/
void GScr_BtTick(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  AI_BT_Tick(Entity->s.number);
}

/*
==============
AICallback_OnScrCmd_GetSecondaryTargets
==============
*/
void AICallback_OnScrCmd_GetSecondaryTargets(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AICommonInterface *m_pAI; 
  const char *v6; 
  AICommonWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botInterface);
  v7.m_botInterface.__vftable = (AIBotInterface_vtbl *)&AIBotInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botAgentInterface);
  v7.m_pAI = NULL;
  v7.m_botAgentInterface.__vftable = (AIBotAgentInterface_vtbl *)&AIBotAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AICommonWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3805, scrContext, v6);
  }
  AICommonInterface::OnScrCmd_GetSecondaryTargets(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetNegotiationStartNode
==============
*/
void AICallback_OnScrCmd_GetNegotiationStartNode(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AICommonInterface *m_pAI; 
  const char *v6; 
  AICommonWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botInterface);
  v7.m_botInterface.__vftable = (AIBotInterface_vtbl *)&AIBotInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botAgentInterface);
  v7.m_pAI = NULL;
  v7.m_botAgentInterface.__vftable = (AIBotAgentInterface_vtbl *)&AIBotAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AICommonWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3805, scrContext, v6);
  }
  AICommonInterface::OnScrCmd_GetNegotiationStartNode(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetNearbyNegotiationInfo
==============
*/
void AICallback_OnScrCmd_GetNearbyNegotiationInfo(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AICommonInterface *m_pAI; 
  const char *v6; 
  AICommonWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botInterface);
  v7.m_botInterface.__vftable = (AIBotInterface_vtbl *)&AIBotInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botAgentInterface);
  v7.m_pAI = NULL;
  v7.m_botAgentInterface.__vftable = (AIBotAgentInterface_vtbl *)&AIBotAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AICommonWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3805, scrContext, v6);
  }
  AICommonInterface::OnScrCmd_GetNearbyNegotiationInfo(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetNegotiationEndNode
==============
*/
void AICallback_OnScrCmd_GetNegotiationEndNode(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AICommonInterface *m_pAI; 
  const char *v6; 
  AICommonWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botInterface);
  v7.m_botInterface.__vftable = (AIBotInterface_vtbl *)&AIBotInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botAgentInterface);
  v7.m_pAI = NULL;
  v7.m_botAgentInterface.__vftable = (AIBotAgentInterface_vtbl *)&AIBotAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AICommonWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3805, scrContext, v6);
  }
  AICommonInterface::OnScrCmd_GetNegotiationEndNode(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetNegotiationEndPos
==============
*/
void AICallback_OnScrCmd_GetNegotiationEndPos(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AICommonInterface *m_pAI; 
  const char *v6; 
  AICommonWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botInterface);
  v7.m_botInterface.__vftable = (AIBotInterface_vtbl *)&AIBotInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botAgentInterface);
  v7.m_pAI = NULL;
  v7.m_botAgentInterface.__vftable = (AIBotAgentInterface_vtbl *)&AIBotAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AICommonWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3805, scrContext, v6);
  }
  AICommonInterface::OnScrCmd_GetNegotiationEndPos(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_FindBestCoverNode
==============
*/
void AICallback_OnScrCmd_FindBestCoverNode(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_FindBestCoverNode(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_AmbushIsCurrentNodeValid
==============
*/
void AICallback_OnScrCmd_AmbushIsCurrentNodeValid(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_AmbushIsCurrentNodeValid(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_AmbushGetNextAmbushNode
==============
*/
void AICallback_OnScrCmd_AmbushGetNextAmbushNode(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_AmbushGetNextAmbushNode(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_AmbushCheckPath
==============
*/
void AICallback_OnScrCmd_AmbushCheckPath(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_AmbushCheckPath(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_FindBestCoverList
==============
*/
void AICallback_OnScrCmd_FindBestCoverList(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_FindBestCoverList(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_UseCoverNode
==============
*/
void AICallback_OnScrCmd_UseCoverNode(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_UseCoverNode(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_IsCoverValidAgainstEnemy
==============
*/
void AICallback_OnScrCmd_IsCoverValidAgainstEnemy(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_IsCoverValidAgainstEnemy(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_IsSuppressed
==============
*/
void AICallback_OnScrCmd_IsSuppressed(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_IsSuppressed(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_IsMoveSuppressed
==============
*/
void AICallback_OnScrCmd_IsMoveSuppressed(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_IsMoveSuppressed(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_CanDoRetreat
==============
*/
void AICallback_OnScrCmd_CanDoRetreat(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_CanDoRetreat(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_FindShuffleCoverNode
==============
*/
void AICallback_OnScrCmd_FindShuffleCoverNode(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_FindShuffleCoverNode(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_FindNearbyCoverNode
==============
*/
void AICallback_OnScrCmd_FindNearbyCoverNode(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_FindNearbyCoverNode(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_FindCoverNode
==============
*/
void AICallback_OnScrCmd_FindCoverNode(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_FindCoverNode(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetCoverNode
==============
*/
void AICallback_OnScrCmd_GetCoverNode(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetCoverNode(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SeeRecently
==============
*/
void AICallback_OnScrCmd_SeeRecently(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SeeRecently(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_IsStanceAllowed
==============
*/
void AICallback_OnScrCmd_IsStanceAllowed(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_IsStanceAllowed(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_UpdateLastCoverTime
==============
*/
void AICallback_OnScrCmd_UpdateLastCoverTime(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_UpdateLastCoverTime(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetGoalNode
==============
*/
void AICallback_OnScrCmd_SetGoalNode(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetGoalNode(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetGoalPos
==============
*/
void AICallback_OnScrCmd_SetGoalPos(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetGoalPos(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetGoalEntity
==============
*/
void AICallback_OnScrCmd_SetGoalEntity(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetGoalEntity(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetGoalPath
==============
*/
void AICallback_OnScrCmd_SetGoalPath(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetGoalPath(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetGoalVolume
==============
*/
void AICallback_OnScrCmd_SetGoalVolume(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetGoalVolume(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetGoalVolumeAuto
==============
*/
void AICallback_OnScrCmd_SetGoalVolumeAuto(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetGoalVolumeAuto(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetGoalVolume
==============
*/
void AICallback_OnScrCmd_GetGoalVolume(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetGoalVolume(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ClearGoalVolume
==============
*/
void AICallback_OnScrCmd_ClearGoalVolume(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ClearGoalVolume(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetCoverTacPoint
==============
*/
void AICallback_OnScrCmd_GetCoverTacPoint(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetCoverTacPoint(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_IsInGoal
==============
*/
void AICallback_OnScrCmd_IsInGoal(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_IsInGoal(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetBackupCoverFromPos
==============
*/
void AICallback_OnScrCmd_SetBackupCoverFromPos(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetBackupCoverFromPos(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_CanShootEnemy
==============
*/
void AICallback_OnScrCmd_CanShootEnemy(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_CanShootEnemy(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_IsGunBlockedByWall
==============
*/
void AICallback_OnScrCmd_IsGunBlockedByWall(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_IsGunBlockedByWall(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_EnableTraversals
==============
*/
void AICallback_OnScrCmd_EnableTraversals(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AICommonInterface::OnScrCmd_EnableTraversals(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetC8ObstacleFlag
==============
*/
void AICallback_OnScrCmd_SetC8ObstacleFlag(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AICommonInterface *m_pAI; 
  const char *v6; 
  AICommonWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botInterface);
  v7.m_botInterface.__vftable = (AIBotInterface_vtbl *)&AIBotInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botAgentInterface);
  v7.m_pAI = NULL;
  v7.m_botAgentInterface.__vftable = (AIBotAgentInterface_vtbl *)&AIBotAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AICommonWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3805, scrContext, v6);
  }
  AICommonInterface::OnScrCmd_SetC8ObstacleFlag(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetNavLayer
==============
*/
void AICallback_OnScrCmd_SetNavLayer(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AICommonInterface *m_pAI; 
  const char *v6; 
  AICommonWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botInterface);
  v7.m_botInterface.__vftable = (AIBotInterface_vtbl *)&AIBotInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botAgentInterface);
  v7.m_pAI = NULL;
  v7.m_botAgentInterface.__vftable = (AIBotAgentInterface_vtbl *)&AIBotAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AICommonWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3805, scrContext, v6);
  }
  AICommonInterface::OnScrCmd_SetNavLayer(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_IsInBadplace
==============
*/
void AICallback_OnScrCmd_IsInBadplace(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AICommonInterface *m_pAI; 
  const char *v6; 
  AICommonWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botInterface);
  v7.m_botInterface.__vftable = (AIBotInterface_vtbl *)&AIBotInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botAgentInterface);
  v7.m_pAI = NULL;
  v7.m_botAgentInterface.__vftable = (AIBotAgentInterface_vtbl *)&AIBotAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AICommonWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3805, scrContext, v6);
  }
  AICommonInterface::OnScrCmd_IsInBadplace(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetPosOutsideBadplace
==============
*/
void AICallback_OnScrCmd_GetPosOutsideBadplace(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AICommonInterface *m_pAI; 
  const char *v6; 
  AICommonWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botInterface);
  v7.m_botInterface.__vftable = (AIBotInterface_vtbl *)&AIBotInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botAgentInterface);
  v7.m_pAI = NULL;
  v7.m_botAgentInterface.__vftable = (AIBotAgentInterface_vtbl *)&AIBotAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AICommonWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3805, scrContext, v6);
  }
  AICommonInterface::OnScrCmd_GetPosOutsideBadplace(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_IsNodeInBadplace
==============
*/
void AICallback_OnScrCmd_IsNodeInBadplace(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AICommonInterface *m_pAI; 
  const char *v6; 
  AICommonWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botInterface);
  v7.m_botInterface.__vftable = (AIBotInterface_vtbl *)&AIBotInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botAgentInterface);
  v7.m_pAI = NULL;
  v7.m_botAgentInterface.__vftable = (AIBotAgentInterface_vtbl *)&AIBotAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AICommonWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3805, scrContext, v6);
  }
  AICommonInterface::OnScrCmd_IsNodeInBadplace(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_CodeMoveRequested
==============
*/
void AICallback_OnScrCmd_CodeMoveRequested(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_CodeMoveRequested(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetDesiredSpeed
==============
*/
void AICallback_OnScrCmd_SetDesiredSpeed(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetDesiredSpeed(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ClearDesiredSpeed
==============
*/
void AICallback_OnScrCmd_ClearDesiredSpeed(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ClearDesiredSpeed(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetDesiredSpeed
==============
*/
void AICallback_OnScrCmd_GetDesiredSpeed(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetDesiredSpeed(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetSpeedScaleMode
==============
*/
void AICallback_OnScrCmd_SetSpeedScaleMode(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetSpeedScaleMode(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetTargetSpeed
==============
*/
void AICallback_OnScrCmd_GetTargetSpeed(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetTargetSpeed(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetTargetSpeed
==============
*/
void AICallback_OnScrCmd_SetTargetSpeed(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetTargetSpeed(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetDesiredScaledSpeedForPosAlongPath
==============
*/
void AICallback_OnScrCmd_GetDesiredScaledSpeedForPosAlongPath(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetDesiredScaledSpeedForPosAlongPath(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_CanBoundingOverwatchMove
==============
*/
void AICallback_OnScrCmd_CanBoundingOverwatchMove(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_CanBoundingOverwatchMove(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetCoverSelectionFocusEnt
==============
*/
void AICallback_OnScrCmd_SetCoverSelectionFocusEnt(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetCoverSelectionFocusEnt(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_OrientMode
==============
*/
void AICallback_OnScrCmd_OrientMode(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_OrientMode(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_AnimMode
==============
*/
void AICallback_OnScrCmd_AnimMode(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_AnimMode(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_CanShoot
==============
*/
void AICallback_OnScrCmd_CanShoot(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_CanShoot(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_CanSee
==============
*/
void AICallback_OnScrCmd_CanSee(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_CanSee(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_CanSeePeripheral
==============
*/
void AICallback_OnScrCmd_CanSeePeripheral(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_CanSeePeripheral(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ShootBlank
==============
*/
void AICallback_OnScrCmd_ShootBlank(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ShootBlank(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_Melee
==============
*/
void AICallback_OnScrCmd_Melee(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_Melee(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_NearClaimNode
==============
*/
void AICallback_OnScrCmd_NearClaimNode(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_NearClaimNode(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_NearClaimNodeAndAngle
==============
*/
void AICallback_OnScrCmd_NearClaimNodeAndAngle(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_NearClaimNodeAndAngle(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetDefaultAimLimits
==============
*/
void AICallback_OnScrCmd_SetDefaultAimLimits(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetDefaultAimLimits(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_IsSuppressionWaiting
==============
*/
void AICallback_OnScrCmd_IsSuppressionWaiting(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_IsSuppressionWaiting(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetMotionAngle
==============
*/
void AICallback_OnScrCmd_GetMotionAngle(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetMotionAngle(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetMotionAngle3D
==============
*/
void AICallback_OnScrCmd_GetMotionAngle3D(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetMotionAngle3D(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetFlashBanged
==============
*/
void AICallback_OnScrCmd_SetFlashBanged(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetFlashBanged(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_FlagEnemyUnattackable
==============
*/
void AICallback_OnScrCmd_FlagEnemyUnattackable(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_FlagEnemyUnattackable(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_MayMoveToPoint
==============
*/
void AICallback_OnScrCmd_MayMoveToPoint(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_MayMoveToPoint(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_AtDangerousNode
==============
*/
void AICallback_OnScrCmd_AtDangerousNode(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_AtDangerousNode(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_MayMoveCheckFriendlyFire
==============
*/
void AICallback_OnScrCmd_MayMoveCheckFriendlyFire(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_MayMoveCheckFriendlyFire(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_MayMoveFromPointToPoint
==============
*/
void AICallback_OnScrCmd_MayMoveFromPointToPoint(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_MayMoveFromPointToPoint(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_IsKnownEnemyInVolume
==============
*/
void AICallback_OnScrCmd_IsKnownEnemyInVolume(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_IsKnownEnemyInVolume(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_IsKnownEnemyInRadius
==============
*/
void AICallback_OnScrCmd_IsKnownEnemyInRadius(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_IsKnownEnemyInRadius(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_IsPathDirect
==============
*/
void AICallback_OnScrCmd_IsPathDirect(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_IsPathDirect(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ClearPath
==============
*/
void AICallback_OnScrCmd_ClearPath(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AICommonInterface *m_pAI; 
  const char *v6; 
  AICommonWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botInterface);
  v7.m_botInterface.__vftable = (AIBotInterface_vtbl *)&AIBotInterface::`vftable';
  AICommonInterface::AICommonInterface(&v7.m_botAgentInterface);
  v7.m_pAI = NULL;
  v7.m_botAgentInterface.__vftable = (AIBotAgentInterface_vtbl *)&AIBotAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AICommonWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3805, scrContext, v6);
  }
   AICommonInterface::`vcall'{448,{flat}}(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ClearEnemy
==============
*/
void AICallback_OnScrCmd_ClearEnemy(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ClearEnemy(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetGroundEntType
==============
*/
void AICallback_OnScrCmd_GetGroundEntType(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetGroundEntType(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ClearEntityTarget
==============
*/
void AICallback_OnScrCmd_ClearEntityTarget(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ClearEntityTarget(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ClearPotentialThreat
==============
*/
void AICallback_OnScrCmd_ClearPotentialThreat(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ClearPotentialThreat(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetPotentialThreat
==============
*/
void AICallback_OnScrCmd_SetPotentialThreat(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetPotentialThreat(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_PointInFOV
==============
*/
void AICallback_OnScrCmd_PointInFOV(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_PointInFOV(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_AllowedStances
==============
*/
void AICallback_OnScrCmd_AllowedStances(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_AllowedStances(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetEngagementMinDist
==============
*/
void AICallback_OnScrCmd_SetEngagementMinDist(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetEngagementMinDist(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetEngagementMaxDist
==============
*/
void AICallback_OnScrCmd_SetEngagementMaxDist(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetEngagementMaxDist(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetAnglesToLikelyEnemyPath
==============
*/
void AICallback_OnScrCmd_GetAnglesToLikelyEnemyPath(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetAnglesToLikelyEnemyPath(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_UpdateAimInfo
==============
*/
void AICallback_OnScrCmd_UpdateAimInfo(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_UpdateAimInfo(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetGunAdditive
==============
*/
void AICallback_OnScrCmd_SetGunAdditive(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetGunAdditive(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetFacialIndex
==============
*/
void AICallback_OnScrCmd_SetFacialIndex(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetFacialIndex(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetFacialIndexFromASM
==============
*/
void AICallback_OnScrCmd_SetFacialIndexFromASM(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetFacialIndexFromASM(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_IsCurrentEnemyValid
==============
*/
void AICallback_OnScrCmd_IsCurrentEnemyValid(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_IsCurrentEnemyValid(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetAimAngle
==============
*/
void AICallback_OnScrCmd_GetAimAngle(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetAimAngle(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetAimAngles
==============
*/
void AICallback_OnScrCmd_SetAimAngles(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetAimAngles(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetFixedNodeSafeVolume
==============
*/
void AICallback_OnScrCmd_SetFixedNodeSafeVolume(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetFixedNodeSafeVolume(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetFixedNodeSafeVolume
==============
*/
void AICallback_OnScrCmd_GetFixedNodeSafeVolume(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetFixedNodeSafeVolume(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ClearFixedNodeSafeVolume
==============
*/
void AICallback_OnScrCmd_ClearFixedNodeSafeVolume(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ClearFixedNodeSafeVolume(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetEntityTarget
==============
*/
void AICallback_OnScrCmd_SetEntityTarget(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetEntityTarget(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ResetThreatUpdate
==============
*/
void AICallback_OnScrCmd_ResetThreatUpdate(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ResetThreatUpdate(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ReacquireClear
==============
*/
void AICallback_OnScrCmd_ReacquireClear(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ReacquireClear(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ReacquireStep
==============
*/
void AICallback_OnScrCmd_ReacquireStep(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ReacquireStep(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_FindReacquireDirectPath
==============
*/
void AICallback_OnScrCmd_FindReacquireDirectPath(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_FindReacquireDirectPath(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ReacquireMove
==============
*/
void AICallback_OnScrCmd_ReacquireMove(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ReacquireMove(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetReacquireState
==============
*/
void AICallback_OnScrCmd_GetReacquireState(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetReacquireState(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_StartCoverArrival
==============
*/
void AICallback_OnScrCmd_StartCoverArrival(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
   AIScriptedInterface::`vcall'{1312,{flat}}(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_FinishCoverArrival
==============
*/
void AICallback_OnScrCmd_FinishCoverArrival(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_FinishCoverArrival(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_StartZeroArrival
==============
*/
void AICallback_OnScrCmd_StartZeroArrival(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_StartZeroArrival(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_FinishZeroArrival
==============
*/
void AICallback_OnScrCmd_FinishZeroArrival(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_FinishZeroArrival(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_StartTraverseArrival
==============
*/
void AICallback_OnScrCmd_StartTraverseArrival(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_StartTraverseArrival(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetPointAfterNegotiation
==============
*/
void AICallback_OnScrCmd_GetPointAfterNegotiation(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetPointAfterNegotiation(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_DropWeapon
==============
*/
void AICallback_OnScrCmd_DropWeapon(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_DropWeapon(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_DropWeaponNoVelocity
==============
*/
void AICallback_OnScrCmd_DropWeaponNoVelocity(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_DropWeaponNoVelocity(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ClearPitchOrient
==============
*/
void AICallback_OnScrCmd_ClearPitchOrient(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ClearPitchOrient(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetPitchOrient
==============
*/
void AICallback_OnScrCmd_SetPitchOrient(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetPitchOrient(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetNodeHideYaw
==============
*/
void AICallback_OnScrCmd_GetNodeHideYaw(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetNodeHideYaw(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetNodeHideYawOffset
==============
*/
void AICallback_OnScrCmd_GetNodeHideYawOffset(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetNodeHideYawOffset(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetNodeSnapYawOffset
==============
*/
void AICallback_OnScrCmd_GetNodeSnapYawOffset(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetNodeSnapYawOffset(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetNodeLeanAimYaw
==============
*/
void AICallback_OnScrCmd_GetNodeLeanAimYaw(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetNodeLeanAimYaw(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetNodeLeanAimPitch
==============
*/
void AICallback_OnScrCmd_GetNodeLeanAimPitch(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetNodeLeanAimPitch(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetNodeLeanAimYawOffset
==============
*/
void AICallback_OnScrCmd_GetNodeLeanAimYawOffset(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetNodeLeanAimYawOffset(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetNodeLeanAimPitchOffset
==============
*/
void AICallback_OnScrCmd_GetNodeLeanAimPitchOffset(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetNodeLeanAimPitchOffset(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ChooseArrivalType
==============
*/
void AICallback_OnScrCmd_ChooseArrivalType(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ChooseArrivalType(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_IW7ShipHack_SetMayMoveTime
==============
*/
void AICallback_OnScrCmd_IW7ShipHack_SetMayMoveTime(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_IW7ShipHack_SetMayMoveTime(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_CalcSharpTurnAnim
==============
*/
void AICallback_OnScrCmd_CalcSharpTurnAnim(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_CalcSharpTurnAnim(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_PreCalcShouldStartArrival
==============
*/
void AICallback_OnScrCmd_PreCalcShouldStartArrival(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_PreCalcShouldStartArrival(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_CalcStopData
==============
*/
void AICallback_OnScrCmd_CalcStopData(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_CalcStopData(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetupMotionWarpForTurn
==============
*/
void AICallback_OnScrCmd_SetupMotionWarpForTurn(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetupMotionWarpForTurn(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetGroundSlope
==============
*/
void AICallback_OnScrCmd_GetGroundSlope(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetGroundSlope(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_PushPlayer
==============
*/
void AICallback_OnScrCmd_PushPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_PushPlayer(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_IsInScriptedState
==============
*/
void AICallback_OnScrCmd_IsInScriptedState(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_IsInScriptedState(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetBlackboard
==============
*/
void AICallback_OnScrCmd_GetBlackboard(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetBlackboard(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ClearBlackboard
==============
*/
void AICallback_OnScrCmd_ClearBlackboard(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ClearBlackboard(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_IsLegacyAgent
==============
*/
void AICallback_OnScrCmd_IsLegacyAgent(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
   AIScriptedInterface::`vcall'{1328,{flat}}(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_AIGetAnimWeight
==============
*/
void AICallback_OnScrCmd_AIGetAnimWeight(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_AIGetAnimWeight(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_AIGetAnimTime
==============
*/
void AICallback_OnScrCmd_AIGetAnimTime(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_AIGetAnimTime(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_FinishTraverse
==============
*/
void AICallback_OnScrCmd_FinishTraverse(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
   AIScriptedInterface::`vcall'{1320,{flat}}(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ForceUpdateGoalPos
==============
*/
void AICallback_OnScrCmd_ForceUpdateGoalPos(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ForceUpdateGoalPos(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetApproxEyePos
==============
*/
void AICallback_OnScrCmd_GetApproxEyePos(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetApproxEyePos(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_StartBeam
==============
*/
void AICallback_OnScrCmd_StartBeam(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_StartBeam(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_StopBeam
==============
*/
void AICallback_OnScrCmd_StopBeam(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_StopBeam(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_AIPlayGesture
==============
*/
void AICallback_OnScrCmd_AIPlayGesture(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_AIPlayGesture(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_AIClearGesture
==============
*/
void AICallback_OnScrCmd_AIClearGesture(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_AIClearGesture(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetWorldWeaponOffset
==============
*/
void AICallback_OnScrCmd_GetWorldWeaponOffset(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetWorldWeaponOffset(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ForceThreatUpdate
==============
*/
void AICallback_OnScrCmd_ForceThreatUpdate(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ForceThreatUpdate(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetupDoorOpen
==============
*/
void AICallback_OnScrCmd_SetupDoorOpen(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetupDoorOpen(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ClearDoorOpen
==============
*/
void AICallback_OnScrCmd_ClearDoorOpen(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ClearDoorOpen(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ShouldCautiousStrafe
==============
*/
void AICallback_OnScrCmd_ShouldCautiousStrafe(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ShouldCautiousStrafe(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetAdjustedExitDirection
==============
*/
void AICallback_OnScrCmd_GetAdjustedExitDirection(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetAdjustedExitDirection(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_UpdateCoverExposeType
==============
*/
void AICallback_OnScrCmd_UpdateCoverExposeType(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_UpdateCoverExposeType(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetStrafeReverse
==============
*/
void AICallback_OnScrCmd_SetStrafeReverse(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetStrafeReverse(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetRiotshieldWeapon
==============
*/
void AICallback_OnScrCmd_SetRiotshieldWeapon(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
   AIScriptedInterface::`vcall'{936,{flat}}(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_AISuppressAI
==============
*/
void AICallback_OnScrCmd_AISuppressAI(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_AISuppressAI(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetOverrideArchetype
==============
*/
void AICallback_OnScrCmd_SetOverrideArchetype(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetOverrideArchetype(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_ClearOverrideArchetype
==============
*/
void AICallback_OnScrCmd_ClearOverrideArchetype(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_ClearOverrideArchetype(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_FindOverrideArchetype
==============
*/
void AICallback_OnScrCmd_FindOverrideArchetype(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_FindOverrideArchetype(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_GetBaseArchetype
==============
*/
void AICallback_OnScrCmd_GetBaseArchetype(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_GetBaseArchetype(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_SetBaseArchetype
==============
*/
void AICallback_OnScrCmd_SetBaseArchetype(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_SetBaseArchetype(m_pAI, scrContext);
}

/*
==============
AICallback_OnScrCmd_CanAimWhileMoving
==============
*/
void AICallback_OnScrCmd_CanAimWhileMoving(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  const char *v6; 
  AIWrapper v7; 

  AIActorInterface::AIActorInterface(&v7.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v7.m_newAgentInterface);
  v7.m_pAI = NULL;
  v7.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v7, Entity);
  m_pAI = v7.m_pAI;
  if ( !v7.m_pAI )
  {
    v6 = j_va("Entity %d does not have a valid AI type for this function.", entref.entnum);
    Scr_Error(COM_ERR_3804, scrContext, v6);
  }
  AIScriptedInterface::OnScrCmd_CanAimWhileMoving(m_pAI, scrContext);
}

/*
==============
AIScriptedInterface::AISuppressAI
==============
*/
char AIScriptedInterface::AISuppressAI(AIScriptedInterface *this)
{
  sentient_s *TargetSentient; 
  sentient_s *v4; 
  ai_scripted_t *AIScripted; 
  const gentity_s *ent; 
  AIScriptedInterface *m_pAI; 
  const pathnode_t *CoverNode; 
  pathnode_t *v10; 
  bool CanShoot; 
  AIWrapper v25; 
  vec3_t outEyePos; 
  vec3_t outOffset; 
  vec3_t pos; 
  vec3_t muzzleOffset; 

  TargetSentient = AICommonInterface::GetTargetSentient(this);
  if ( !TargetSentient )
    return 0;
  v4 = this->GetSentient(this);
  if ( !Sentient_HasDecentVis(v4, TargetSentient) && !this->m_pAI->bForceSuppressAI )
    return 0;
  __asm
  {
    vmovaps [rsp+0D0h+var_10], xmm6
    vxorps  xmm6, xmm6, xmm6
    vmovss  dword ptr [rbp+57h+outEyePos], xmm6
    vmovss  dword ptr [rbp+57h+outEyePos+4], xmm6
    vmovss  dword ptr [rbp+57h+outEyePos+8], xmm6
  }
  AIScripted = AI_GetAIScripted(TargetSentient->ent);
  if ( AIScripted )
  {
    AIActorInterface::AIActorInterface(&v25.m_actorInterface);
    AIAgentInterface::AIAgentInterface(&v25.m_newAgentInterface);
    ent = AIScripted->ent;
    v25.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
    v25.m_pAI = NULL;
    AIWrapper::Setup(&v25, ent);
    m_pAI = v25.m_pAI;
    CoverNode = AIScriptedInterface::GetCoverNode(v25.m_pAI);
    v10 = (pathnode_t *)CoverNode;
    if ( CoverNode )
    {
      GetNodeExposedOffset(CoverNode, &outOffset);
      pathnode_t::GetPos(v10, &pos);
      __asm
      {
        vmovss  xmm0, dword ptr [rbp+57h+pos]
        vaddss  xmm1, xmm0, dword ptr [rbp+57h+outOffset]
        vmovss  xmm2, dword ptr [rbp+57h+pos+4]
        vaddss  xmm0, xmm2, dword ptr [rbp+57h+outOffset+4]
        vmovss  dword ptr [rbp+57h+outEyePos], xmm1
        vmovss  xmm1, dword ptr [rbp+57h+pos+8]
        vaddss  xmm2, xmm1, dword ptr [rbp+57h+outOffset+8]
        vmovss  dword ptr [rbp+57h+outEyePos+8], xmm2
        vmovss  dword ptr [rbp+57h+outEyePos+4], xmm0
      }
    }
    else
    {
      AIScriptedInterface::GetApproxEyePos(m_pAI, &outEyePos, 0);
    }
  }
  else
  {
    Sentient_GetEyePosition(TargetSentient, &outEyePos);
  }
  __asm
  {
    vunpcklps xmm0, xmm6, xmm6
    vmovss  dword ptr [rbp+57h+outOffset+8], xmm6
  }
  muzzleOffset.v[2] = outOffset.v[2];
  __asm { vmovsd  qword ptr [rbp+57h+muzzleOffset], xmm0 }
  CanShoot = AIScriptedInterface::CanShoot(this, &outEyePos, &muzzleOffset, 0);
  __asm { vmovaps xmm6, [rsp+0D0h+var_10] }
  if ( !CanShoot && !this->m_pAI->bForceSuppressAI )
    return 0;
  _RAX = this->m_pAI;
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+57h+outEyePos]
    vmovss  dword ptr [rax+0DDCh], xmm0
    vmovss  xmm1, dword ptr [rbp+57h+outEyePos+4]
    vmovss  dword ptr [rax+0DE0h], xmm1
    vmovss  xmm0, dword ptr [rbp+57h+outEyePos+8]
    vmovss  dword ptr [rax+0DE4h], xmm0
  }
  this->m_pAI->bGoodShootPos = 1;
  return 1;
}

/*
==============
AIScriptedInterface::CalcAnimStartPos
==============
*/

void __fastcall AIScriptedInterface::CalcAnimStartPos(const vec3_t *stopPos, double stopYaw, const vec3_t *animDelta, const float animAngleDelta, vec3_t *outPos)
{
  vec3_t v39; 
  tmat33_t<vec3_t> v40; 
  char v41; 
  char v42; 
  void *retaddr; 

  _R11 = &retaddr;
  __asm { vmovaps xmmword ptr [r11-18h], xmm6 }
  _RSI = outPos;
  __asm { vxorps  xmm2, xmm2, xmm2 }
  _RDI = stopPos;
  _RBX = (char *)animDelta;
  __asm
  {
    vsubss  xmm0, xmm1, xmm3
    vmovss  [rsp+98h+var_68], xmm2
    vmovss  [rsp+98h+var_64], xmm0
    vmovss  [rsp+98h+var_60], xmm2
  }
  AnglesToAxis(&v39, &v40);
  if ( _RBX == &v41 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_math.h", 470, ASSERT_TYPE_SANITY, "( &in1 != &out )", (const char *)&queryFormat, "&in1 != &out") )
    __debugbreak();
  __asm
  {
    vmovss  xmm5, dword ptr [rbx+4]
    vmovss  xmm4, dword ptr [rbx]
    vmovss  xmm6, dword ptr [rbx+8]
    vmulss  xmm1, xmm4, [rsp+98h+var_58]
    vmulss  xmm0, xmm5, [rsp+98h+var_4C]
    vaddss  xmm2, xmm1, xmm0
    vmovss  xmm0, dword ptr [rdi]
    vmulss  xmm1, xmm6, [rsp+98h+var_40]
    vaddss  xmm3, xmm2, xmm1
    vmulss  xmm1, xmm4, [rsp+98h+var_54]
    vsubss  xmm2, xmm0, xmm3
    vmulss  xmm0, xmm5, [rsp+98h+var_48]
    vmovss  dword ptr [rsi], xmm2
    vaddss  xmm2, xmm1, xmm0
    vmovss  xmm0, dword ptr [rdi+4]
    vmulss  xmm1, xmm6, [rsp+98h+var_3C]
    vaddss  xmm3, xmm2, xmm1
    vmulss  xmm1, xmm4, [rsp+98h+var_50]
    vsubss  xmm2, xmm0, xmm3
    vmulss  xmm0, xmm5, [rsp+98h+var_44]
    vmovss  dword ptr [rsi+4], xmm2
    vaddss  xmm2, xmm1, xmm0
    vmovss  xmm0, dword ptr [rdi+8]
    vmulss  xmm1, xmm6, [rsp+98h+var_38]
    vaddss  xmm3, xmm2, xmm1
    vsubss  xmm2, xmm0, xmm3
    vmovss  dword ptr [rsi+8], xmm2
  }
  _R11 = &v42;
  __asm { vmovaps xmm6, xmmword ptr [r11-10h] }
}

/*
==============
AIScriptedInterface::CalcGoodShootPos
==============
*/
char AIScriptedInterface::CalcGoodShootPos(AIScriptedInterface *this)
{
  const sentient_s *TargetSentient; 
  gentity_s *TargetEntity; 
  bool GoodSuppressSpot; 
  bool v6; 
  const dvar_t *v7; 
  vec3_t outEyePos; 

  TargetSentient = AICommonInterface::GetTargetSentient(this);
  if ( this->CanSee(this, TargetSentient->ent, -1) && AIScriptedInterface::CanShootEnemy(this, 250, 0, 0) )
  {
    Sentient_GetEyePosition(TargetSentient, &this->m_pAI->vGoodShootPos);
    this->m_pAI->bGoodShootPos = 1;
    return 1;
  }
  if ( !AICommonInterface::GetTargetSentient(this) || !this->m_pAI->sight.lastEnemySightPosValid || !AIScriptedInterface::IsCurrentEnemyValid(this) || !this->m_pAI->bGoodShootPos && !AIScriptedInterface::NeedRecalculateSuppressSpot(this) || this->m_pAI->combat.doingAmbush )
  {
    this->m_pAI->bGoodShootPos = 0;
    goto LABEL_18;
  }
  TargetEntity = AICommonInterface::GetTargetEntity(this);
  if ( TargetEntity && !TargetEntity->client )
  {
    GoodSuppressSpot = AIScriptedInterface::AISuppressAI(this);
    goto LABEL_15;
  }
  AIScriptedInterface::GetApproxEyePos(this, &outEyePos, 0);
  if ( !AIScriptedInterface::CheckPitchVisibility(this, &outEyePos, &this->m_pAI->sight.lastEnemySightPos, NULL) )
  {
LABEL_18:
    v6 = 0;
    goto LABEL_19;
  }
  GoodSuppressSpot = AIScriptedInterface::FindGoodSuppressSpot(this, &outEyePos);
LABEL_15:
  v6 = GoodSuppressSpot;
  if ( !GoodSuppressSpot )
  {
LABEL_19:
    v7 = DVARBOOL_ai_whyaminotshooting;
    if ( !DVARBOOL_ai_whyaminotshooting && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "ai_whyaminotshooting") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v7);
    if ( v7->current.enabled )
    {
      _RCX = this->m_pAI->ent;
      __asm
      {
        vmovss  xmm0, dword ptr [rcx+130h]
        vmovss  dword ptr [rsp+68h+outEyePos], xmm0
        vmovss  xmm1, dword ptr [rcx+134h]
        vmovss  dword ptr [rsp+68h+outEyePos+4], xmm1
        vmovss  xmm0, dword ptr [rcx+138h]
        vsubss  xmm2, xmm0, cs:__real@41400000
        vmovss  dword ptr [rsp+68h+outEyePos+8], xmm2
        vmovss  xmm2, cs:__real@3f400000; scale
      }
      G_Main_AddDebugStringWithDuration(&outEyePos, &colorRed, *(float *)&_XMM2, "cant suppr", 1);
    }
  }
  return v6;
}

/*
==============
AIScriptedInterface::CalcStopData
==============
*/
bool AIScriptedInterface::CalcStopData(AIScriptedInterface *this, const vec3_t *targetPos, const vec3_t *targetAngles, const vec3_t *animTargetAngles, const vec3_t *codeApproachDir, bool bApproachDirValid, const scr_string_t *stateName, const char *footPrefix, const char *optionalPrefix, float maxLerpScale, float overShootRatio, const scr_string_t *nodeType, const scr_string_t *startNotetrack, const scr_string_t *endNotetrack, const char *speedString)
{
  ai_scripted_t *m_pAI; 
  const entityState_t *p_s; 
  scr_string_t AnimsetName; 
  unsigned int AngleIndex; 
  scr_string_t v53; 
  bool result; 
  char *fmt; 
  int entryIndex; 
  scr_string_t name; 
  vec3_t *v73; 
  int *outAnimEntryIndex; 
  char *v75; 
  char *v76; 
  const scr_string_t *v77; 
  const vec3_t *v78; 
  vec3_t end; 
  vec3_t vec; 
  vec3_t angles; 
  char v82; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-58h], xmm6
    vmovaps xmmword ptr [rax-68h], xmm7
    vmovaps xmmword ptr [rax-78h], xmm8
    vmovaps xmmword ptr [rax-88h], xmm9
    vmovaps xmmword ptr [rax-98h], xmm10
    vmovaps xmmword ptr [rax-0A8h], xmm11
  }
  m_pAI = this->m_pAI;
  _RBX = targetAngles;
  _R15 = targetPos;
  v73 = (vec3_t *)codeApproachDir;
  p_s = &m_pAI->ent->s;
  v75 = (char *)footPrefix;
  v76 = (char *)optionalPrefix;
  v77 = startNotetrack;
  *(_QWORD *)end.v = endNotetrack;
  outAnimEntryIndex = (int *)speedString;
  v78 = targetAngles;
  AnimsetName = BG_AnimationState_GetAnimsetName(p_s);
  __asm { vmovss  xmm0, dword ptr [r15] }
  name = AnimsetName;
  __asm
  {
    vsubss  xmm2, xmm0, dword ptr [rdx+130h]
    vmovss  xmm0, dword ptr [r15+4]
    vmovss  dword ptr [rbp+120h+vec], xmm2
    vsubss  xmm1, xmm0, dword ptr [rdx+134h]
    vmovss  xmm0, dword ptr [r15+8]
    vmovss  dword ptr [rbp+120h+vec+4], xmm1
    vsubss  xmm3, xmm0, dword ptr [rdx+138h]
    vmulss  xmm1, xmm1, xmm1
    vmulss  xmm0, xmm2, xmm2
    vaddss  xmm2, xmm1, xmm0
    vmulss  xmm1, xmm3, xmm3
    vaddss  xmm11, xmm2, xmm1
    vmovss  dword ptr [rbp+120h+vec+8], xmm3
  }
  vectoangles(&vec, &angles);
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vsubss  xmm1, xmm0, dword ptr [rbp+120h+angles+4]
    vmovss  xmm7, cs:__real@3b360b61
    vmovss  xmm9, cs:__real@3f000000
    vmovss  xmm10, cs:__real@43b40000
    vmovss  xmm6, cs:__real@41b40000
    vmulss  xmm3, xmm1, xmm7
    vaddss  xmm1, xmm3, xmm9
    vxorps  xmm8, xmm8, xmm8
    vroundss xmm2, xmm8, xmm1, 1
    vsubss  xmm0, xmm3, xmm2
    vmulss  xmm0, xmm0, xmm10; angle
    vmovaps xmm1, xmm6; threshold
  }
  AngleIndex = G_GetAngleIndex(*(const float *)&_XMM0, *(const float *)&_XMM1);
  v53 = AngleIndex;
  if ( bApproachDirValid )
  {
    __asm { vcomiss xmm11, cs:__real@45afc800 }
    if ( AngleIndex <= 1 || AngleIndex - 7 <= 1 )
    {
      vectoangles(v73, &angles);
      __asm
      {
        vmovss  xmm0, dword ptr [rbx+4]
        vsubss  xmm2, xmm0, dword ptr [rbp+120h+angles+4]
        vmulss  xmm5, xmm2, xmm7
        vaddss  xmm3, xmm5, xmm9
        vroundss xmm4, xmm8, xmm3, 1
        vsubss  xmm0, xmm5, xmm4
        vmulss  xmm0, xmm0, xmm10; angle
        vmovaps xmm1, xmm6; threshold
      }
      v53 = G_GetAngleIndex(*(const float *)&_XMM0, *(const float *)&_XMM1);
    }
  }
  if ( DebugArrivalsOnActor(this->m_pAI->ent->s.number) )
    Com_Printf(18, "Trying arrival index %d.\n", (unsigned int)v53);
  SLODWORD(fmt) = *stateName;
  entryIndex = -1;
  AIScriptedInterface::CalculateStopAnim(this, (int)&v75, v53, name, fmt, v75, v76, outAnimEntryIndex);
  this->m_pAI->bArrivalFailed = 1;
  result = 0;
  _R11 = &v82;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-18h]
    vmovaps xmm7, xmmword ptr [r11-28h]
    vmovaps xmm8, xmmword ptr [r11-38h]
    vmovaps xmm9, xmmword ptr [r11-48h]
    vmovaps xmm10, xmmword ptr [r11-58h]
    vmovaps xmm11, xmmword ptr [r11-68h]
  }
  return result;
}

/*
==============
AIScriptedInterface::CalculateSharpTurnAnim
==============
*/
char AIScriptedInterface::CalculateSharpTurnAnim(AIScriptedInterface *this, unsigned int angleIndexCount, int *angleIndices, scr_string_t animsetName, scr_string_t stateName, const vec3_t *corner, const vec3_t *nextPathPoint, const char *footPrefix, const char *optionalPrefix, const char *optionalSuffix, scr_anim_t *outAnim, int *outAngleIndex, int *outAnimEntryIndex)
{
  int *v14; 
  unsigned int v17; 
  __int64 v18; 
  int v19; 
  const char *v20; 
  scr_string_t String; 
  const char *v22; 
  scr_string_t v23; 
  int *v29; 
  int *v34; 
  vec3_t s1; 
  unsigned int v37; 
  int v38; 
  int v39; 
  vec3_t v40; 
  vec3_t v41; 
  const char *v42; 
  scr_anim_t *v43; 
  int *v44; 
  int *v45; 
  __m256i v46; 
  int v47; 

  v14 = angleIndices;
  v42 = optionalSuffix;
  v43 = outAnim;
  v44 = outAngleIndex;
  v45 = outAnimEntryIndex;
  v37 = angleIndexCount;
  *(_QWORD *)s1.v = footPrefix;
  if ( !angleIndices && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 6023, ASSERT_TYPE_ASSERT, "(angleIndices)", (const char *)&queryFormat, "angleIndices") )
    __debugbreak();
  if ( !footPrefix && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 6024, ASSERT_TYPE_ASSERT, "(footPrefix)", (const char *)&queryFormat, "footPrefix") )
    __debugbreak();
  __asm { vmovdqu ymm0, cs:__ymm@000000010000000400000007ffffffff00000009000000060000000300000002 }
  v17 = 0;
  v47 = 2;
  __asm { vmovdqu [rbp+37h+var_60], ymm0 }
  if ( angleIndexCount )
  {
    while ( 1 )
    {
      v18 = *v14;
      if ( (unsigned int)v18 > 2 && (unsigned int)(v18 - 6) > 2 )
        return 0;
      v19 = v46.m256i_i32[v18];
      if ( v19 <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 6038, ASSERT_TYPE_ASSERT, "(keyPadDirection[angleIndex] > 0)", (const char *)&queryFormat, "keyPadDirection[angleIndex] > 0") )
        __debugbreak();
      v20 = j_va("%s%d%s", *(const char **)s1.v, (unsigned int)v19, v42);
      String = SL_FindString(v20);
      if ( String )
      {
        ((void (__fastcall *)(AIScriptedInterface *, vec3_t *, _QWORD, _QWORD, scr_string_t, int *))this->GetRandomAlias)(this, &v40, (unsigned int)animsetName, (unsigned int)stateName, String, &v38);
        if ( *(_QWORD *)v40.v )
          break;
      }
      if ( optionalPrefix )
      {
        if ( *optionalPrefix )
        {
          if ( I_stricmp(optionalPrefix, *(const char **)s1.v) )
          {
            v22 = j_va("%s%d%s", optionalPrefix, (unsigned int)v19, v42);
            v23 = SL_FindString(v22);
            if ( v23 )
            {
              ((void (__fastcall *)(AIScriptedInterface *, vec3_t *, _QWORD, _QWORD, scr_string_t, int *))this->GetRandomAlias)(this, &v41, (unsigned int)animsetName, (unsigned int)stateName, v23, &v39);
              if ( *(_QWORD *)v41.v )
              {
                _RAX = nextPathPoint;
                __asm { vmovsd  xmm0, qword ptr [rax] }
                s1.v[2] = nextPathPoint->v[2];
                _RAX = corner;
                __asm
                {
                  vmovsd  [rsp+100h+s1], xmm0
                  vmovsd  xmm0, qword ptr [rax]
                }
                *(float *)&_RAX = corner->v[2];
                __asm { vmovsd  [rbp+37h+var_A0], xmm0 }
                LODWORD(v40.v[2]) = (_DWORD)_RAX;
                if ( !AIScriptedInterface::CanDoTurnAnim(this, *(scr_anim_t *)v41.v, &v40, &s1) )
                  return 0;
                *v43 = *(scr_anim_t *)v41.v;
                v34 = v45;
                *v44 = v18;
                if ( v34 )
                  *v34 = v39;
                return 1;
              }
            }
          }
        }
      }
      ++v17;
      ++v14;
      if ( v17 >= v37 )
        return 0;
    }
    _RAX = nextPathPoint;
    __asm { vmovsd  xmm0, qword ptr [rax] }
    s1.v[2] = nextPathPoint->v[2];
    _RAX = corner;
    __asm
    {
      vmovsd  [rsp+100h+s1], xmm0
      vmovsd  xmm0, qword ptr [rax]
    }
    *(float *)&_RAX = corner->v[2];
    __asm { vmovsd  [rbp+37h+var_90], xmm0 }
    LODWORD(v41.v[2]) = (_DWORD)_RAX;
    if ( !AIScriptedInterface::CanDoTurnAnim(this, *(scr_anim_t *)v40.v, &v41, &s1) )
      return 0;
    *v43 = *(scr_anim_t *)v40.v;
    v29 = v45;
    *v44 = v18;
    if ( v29 )
    {
      *v29 = v38;
      return 1;
    }
    return 1;
  }
  return 0;
}

/*
==============
AIScriptedInterface::CalculateSharpTurnExitAnim
==============
*/
bool AIScriptedInterface::CalculateSharpTurnExitAnim(AIScriptedInterface *this, int *angleIndices, unsigned int angleIndexCount, scr_string_t animsetName, scr_string_t stateName, const char *prefix, const char *suffix, scr_anim_t *outAnim, int *outAngleIndex, int *outAnimEntryIndex)
{
  gentity_s *v19; 
  bool result; 
  vec3_t forward; 
  const char *v61; 
  const char *v62; 
  const char *v63; 
  __int64 v64; 
  const char *v66; 
  const char *v67; 
  __int64 v68; 
  char v69; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
    vmovaps xmmword ptr [rax-88h], xmm10
    vmovaps xmmword ptr [rax-98h], xmm11
  }
  v19 = this->GetEntity(this);
  v61 = "exit2";
  v62 = "exit3";
  v63 = "exit6";
  v64 = 0i64;
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovdqu [rbp+0D0h+var_D0], xmm0
  }
  v66 = "exit4";
  v67 = "exit1";
  v68 = 0i64;
  AngleVectors(&v19->r.currentAngles, &forward, NULL, NULL);
  _RAX = &this->m_pAI->Physics.vVelocity;
  __asm
  {
    vmovss  xmm2, dword ptr [rax+4]
    vmovss  xmm0, dword ptr [rax]
    vmovss  xmm3, dword ptr [rax+8]
    vmulss  xmm1, xmm0, xmm0
    vmulss  xmm0, xmm2, xmm2
    vaddss  xmm2, xmm1, xmm0
    vmulss  xmm1, xmm3, xmm3
    vaddss  xmm7, xmm2, xmm1
  }
  if ( !outAnimEntryIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 5964, ASSERT_TYPE_ASSERT, "(outAnimEntryIndex)", (const char *)&queryFormat, "outAnimEntryIndex") )
    __debugbreak();
  *outAnimEntryIndex = -1;
  _RCX = this->m_pAI;
  __asm
  {
    vmovss  xmm6, dword ptr [rcx+83Ch]
    vmovss  xmm4, dword ptr [rcx+838h]
    vmovss  xmm5, dword ptr [rcx+840h]
    vmulss  xmm1, xmm4, xmm4
    vmulss  xmm0, xmm6, xmm6
    vaddss  xmm2, xmm1, xmm0
    vmulss  xmm1, xmm5, xmm5
    vaddss  xmm2, xmm2, xmm1
    vsqrtss xmm3, xmm2, xmm2
    vcmpless xmm0, xmm3, cs:__real@80000000
    vmovss  xmm10, cs:__real@3f800000
    vblendvps xmm1, xmm3, xmm10, xmm0
    vdivss  xmm0, xmm10, xmm1
    vmulss  xmm2, xmm4, xmm0
    vmulss  xmm3, xmm6, xmm0
    vmulss  xmm5, xmm5, xmm0
    vcomiss xmm7, xmm10
    vmulss  xmm3, xmm3, dword ptr [rbp+0D0h+forward+4]
    vmulss  xmm2, xmm2, dword ptr [rbp+0D0h+forward]
    vaddss  xmm4, xmm3, xmm2
    vmulss  xmm1, xmm5, dword ptr [rbp+0D0h+forward+8]
    vaddss  xmm2, xmm4, xmm1
    vcomiss xmm2, cs:__real@3e3126e9
  }
  result = 0;
  _R11 = &v69;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
  }
  return result;
}

/*
==============
AIScriptedInterface::CalculateStopAnim
==============
*/
scr_anim_t AIScriptedInterface::CalculateStopAnim(AIScriptedInterface *this, unsigned __int64 *angleIndex, scr_string_t animsetName, scr_string_t stateName, const char *footPrefix, const char *optionalPrefix, const char *speedString, int *outAnimEntryIndex, __int64 a9)
{
  __int64 v9; 
  const char **v12; 
  scr_string_t String; 
  const dvar_t *v14; 
  scr_string_t v16; 
  char *fmt; 
  char *fmta; 
  __int64 v22; 
  __int64 v23[2]; 
  char dest[136]; 

  v23[1] = -2i64;
  v9 = animsetName;
  v22 = a9;
  Sys_ProfBeginNamedEvent(0xFF808080, "CalculateStopAnim");
  if ( keyPadDirection[v9] <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 6175, ASSERT_TYPE_ASSERT, "(keyPadDirection[angleIndex] > 0)", (const char *)&queryFormat, "keyPadDirection[angleIndex] > 0") )
    __debugbreak();
  if ( outAnimEntryIndex && *(_BYTE *)outAnimEntryIndex )
  {
    v12 = &keyPadModifier[v9];
    LODWORD(fmt) = keyPadDirection[v9];
    Com_sprintf(dest, 0x80ui64, "%s%d%s%s", optionalPrefix, fmt, *v12, (const char *)outAnimEntryIndex);
  }
  else
  {
    v12 = &keyPadModifier[v9];
    LODWORD(fmt) = keyPadDirection[v9];
    Com_sprintf(dest, 0x80ui64, "%s%d%s", optionalPrefix, fmt, *v12);
  }
  String = SL_FindString(dest);
  if ( String && (((void (__fastcall *)(AIScriptedInterface *, __int64 *, _QWORD, _QWORD, scr_string_t, __int64))this->GetRandomAlias)(this, v23, (unsigned int)stateName, (unsigned int)footPrefix, String, v22), v23[0]) )
  {
    v14 = DCONST_DVARBOOL_ai_showArrivalCalcInfo;
    if ( !DCONST_DVARBOOL_ai_showArrivalCalcInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "ai_showArrivalCalcInfo") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v14);
    if ( v14->current.enabled )
    {
      __asm { vmovss  xmm2, cs:__real@3f800000; scale }
      G_DebugString(&this->m_pAI->ent->r.currentOrigin, &colorGreen, *(float *)&_XMM2, dest, 1);
    }
    *angleIndex = v23[0];
    Sys_ProfEndNamedEvent();
  }
  else
  {
    if ( !speedString || speedString == optionalPrefix )
      goto LABEL_27;
    if ( outAnimEntryIndex && *(_BYTE *)outAnimEntryIndex )
    {
      LODWORD(fmta) = keyPadDirection[v9];
      Com_sprintf(dest, 0x80ui64, "%s%d%s%s", speedString, fmta, *v12, (const char *)outAnimEntryIndex);
    }
    else
    {
      LODWORD(fmta) = keyPadDirection[v9];
      Com_sprintf(dest, 0x80ui64, "%s%d%s", speedString, fmta, *v12);
    }
    v16 = SL_FindString(dest);
    if ( v16 && (((void (__fastcall *)(AIScriptedInterface *, __int64 *, _QWORD, _QWORD, scr_string_t, __int64))this->GetRandomAlias)(this, &v22, (unsigned int)stateName, (unsigned int)footPrefix, v16, v22), v22) )
    {
      if ( Dvar_GetBool_Internal_DebugName(DCONST_DVARBOOL_ai_showArrivalCalcInfo, "ai_showArrivalCalcInfo") )
      {
        __asm { vmovss  xmm2, cs:__real@3f800000; scale }
        G_DebugString(&this->m_pAI->ent->r.currentOrigin, &colorGreen, *(float *)&_XMM2, dest, 1);
      }
      *angleIndex = v22;
      Sys_ProfEndNamedEvent();
    }
    else
    {
LABEL_27:
      *angleIndex = UNDEFINED_ANIM_3.linkPointer;
      Sys_ProfEndNamedEvent();
    }
  }
  return (scr_anim_t)angleIndex;
}

/*
==============
AIScriptedInterface::CanDoTurnAnim
==============
*/
bool AIScriptedInterface::CanDoTurnAnim(AIScriptedInterface *this, scr_anim_t turnAnim, const vec3_t *corner, const vec3_t *nextPathPoint)
{
  unsigned __int64 v18; 
  const scrContext_t *v22; 
  scr_string_t code_move; 
  scrContext_t *v24; 
  const XAnim_s *Anims; 
  scr_string_t v26; 
  const XAnim_s *v28; 
  char v29; 
  char v30; 
  const XAnim_s *v34; 
  const char *AnimName; 
  const char *v36; 
  char v44; 
  const dvar_t *v78; 
  const vec4_t *v103; 
  bool result; 
  vec3_t end; 
  vec3_t outMoveDelta; 
  vec3_t local; 
  vec3_t outWorld; 
  char v128; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
    vmovaps xmmword ptr [rax-88h], xmm10
    vmovaps xmmword ptr [rax-98h], xmm11
    vmovaps xmmword ptr [rax-0A8h], xmm12
    vmovaps xmmword ptr [rax-0B8h], xmm13
    vmovaps xmmword ptr [rax-0C8h], xmm14
    vmovaps xmmword ptr [rax-0D8h], xmm15
  }
  _R12 = corner;
  v18 = turnAnim.linkPointer >> 16;
  _R13 = (const gentity_s *)((__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD))this->GetEntity)(this, turnAnim, corner, nextPathPoint);
  v22 = ScriptContext_Server();
  code_move = scr_const.code_move;
  v24 = (scrContext_t *)v22;
  Anims = Scr_GetAnims(v22, (unsigned __int16)v18);
  *(double *)&_XMM0 = XAnimGetNotetrackTime(Anims, turnAnim.index, code_move);
  v26 = scr_const.corner;
  __asm { vmovaps xmm6, xmm0 }
  v28 = Scr_GetAnims(v24, (unsigned __int16)v18);
  *(double *)&_XMM0 = XAnimGetNotetrackTime(v28, turnAnim.index, v26);
  __asm
  {
    vmovss  xmm8, cs:__real@3f800000
    vxorps  xmm9, xmm9, xmm9
    vcomiss xmm6, xmm9
    vmovaps xmm7, xmm0
  }
  if ( v29 )
  {
    v34 = Scr_GetAnims(v24, (unsigned __int16)v18);
    AnimName = XAnimGetAnimName(v34, turnAnim.index);
    v36 = j_va("Turn anim %s does not have code_move notetrack!", AnimName);
    Scr_Error(COM_ERR_3901, v24, v36);
    __asm { vmovaps xmm6, xmm8 }
  }
  __asm
  {
    vcomiss xmm6, xmm8
    vmovss  xmm0, cs:__real@3f19999a
    vcmpltss xmm1, xmm7, xmm9
    vblendvps xmm0, xmm7, xmm0, xmm1
    vmovss  [rsp+168h+var_128], xmm0
  }
  if ( !(v29 | v30) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 5891, ASSERT_TYPE_ASSERT, "(codeMoveTime <= 1.f)", (const char *)&queryFormat, "codeMoveTime <= 1.f") )
    __debugbreak();
  __asm
  {
    vmovaps xmm3, xmm6; endTime
    vxorps  xmm2, xmm2, xmm2; startTime
  }
  G_GetMoveDelta(v24, turnAnim, *(const float *)&_XMM2, *(const float *)&_XMM3, &outMoveDelta);
  G_LocalToWorldCoords(_R13, &outMoveDelta, &outWorld);
  __asm
  {
    vmovss  xmm3, [rsp+168h+var_128]; endTime
    vxorps  xmm2, xmm2, xmm2; startTime
  }
  G_GetMoveDelta(v24, turnAnim, *(const float *)&_XMM2, *(const float *)&_XMM3, &local);
  G_LocalToWorldCoords(_R13, &local, &end);
  _RAX = this->m_pAI;
  __asm
  {
    vmovss  xmm5, dword ptr [r13+130h]
    vmovss  xmm13, dword ptr [r13+134h]
    vmovss  xmm14, dword ptr [r13+138h]
    vmovss  xmm0, dword ptr [rax+888h]
    vmovss  xmm2, dword ptr [rax+88Ch]
    vmovss  xmm3, dword ptr [rax+890h]
  }
  _RAX = _RAX->pNavigator;
  __asm
  {
    vmulss  xmm1, xmm0, xmm0
    vmulss  xmm0, xmm2, xmm2
    vaddss  xmm2, xmm1, xmm0
    vmovss  xmm0, dword ptr [r12]
    vsubss  xmm10, xmm0, xmm5
    vmovss  xmm0, dword ptr [r12+8]
    vmulss  xmm1, xmm3, xmm3
    vaddss  xmm2, xmm2, xmm1
    vmovss  xmm1, dword ptr [r12+4]
    vsqrtss xmm4, xmm2, xmm2
    vsubss  xmm11, xmm1, xmm13
    vsubss  xmm12, xmm0, xmm14
    vmulss  xmm2, xmm11, xmm11
    vmulss  xmm1, xmm10, xmm10
    vaddss  xmm3, xmm2, xmm1
    vmovd   xmm1, cs:?level@@3Ulevel_locals_t@@A.time; level_locals_t level
    vmulss  xmm0, xmm12, xmm12
    vaddss  xmm2, xmm3, xmm0
    vmovd   xmm0, dword ptr [rax+74h]
    vsqrtss xmm15, xmm2, xmm2
    vpcmpeqd xmm2, xmm0, xmm1
    vblendvps xmm0, xmm9, xmm4, xmm2
    vaddss  xmm1, xmm0, xmm8
    vcomiss xmm15, xmm1
    vmovss  [rsp+168h+var_128], xmm4
  }
  if ( v44 )
    goto LABEL_26;
  __asm
  {
    vmovss  xmm0, dword ptr [rsp+168h+end]
    vmovss  xmm1, dword ptr [rsp+168h+end+4]
  }
  v78 = DVARBOOL_ai_debugTurns;
  __asm
  {
    vsubss  xmm6, xmm0, xmm5
    vmovss  xmm0, dword ptr [rsp+168h+end+8]
    vsubss  xmm4, xmm1, xmm13
    vsubss  xmm5, xmm0, xmm14
    vdivss  xmm7, xmm8, xmm15
    vmulss  xmm2, xmm4, xmm4
    vmulss  xmm1, xmm6, xmm6
    vaddss  xmm3, xmm2, xmm1
    vmulss  xmm0, xmm5, xmm5
    vaddss  xmm2, xmm3, xmm0
    vsqrtss xmm9, xmm2, xmm2
    vdivss  xmm0, xmm8, xmm9
    vmulss  xmm13, xmm4, xmm0
    vmulss  xmm8, xmm6, xmm0
    vmulss  xmm14, xmm5, xmm0
    vmulss  xmm0, xmm11, xmm7
    vmulss  xmm3, xmm0, xmm4
    vmulss  xmm1, xmm10, xmm7
    vmulss  xmm2, xmm1, xmm6
    vaddss  xmm4, xmm3, xmm2
    vsubss  xmm2, xmm15, [rsp+168h+var_128]
    vmulss  xmm0, xmm12, xmm7
    vmulss  xmm1, xmm0, xmm5
    vaddss  xmm3, xmm4, xmm1
    vcomiss xmm3, xmm2
  }
  if ( !v44 )
  {
    __asm
    {
      vmulss  xmm1, xmm13, xmm11
      vmulss  xmm0, xmm8, xmm10
      vaddss  xmm2, xmm1, xmm0
      vmulss  xmm0, xmm9, cs:__real@3f000000
      vmulss  xmm1, xmm12, xmm14
      vaddss  xmm3, xmm2, xmm1
      vcomiss xmm3, xmm0
    }
    if ( v44 )
    {
      if ( !DVARBOOL_ai_debugTurns && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "ai_debugTurns") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v78);
      if ( !v78->current.enabled )
        goto LABEL_20;
      v103 = &colorRedHeat;
      goto LABEL_19;
    }
    if ( !DVARBOOL_ai_debugTurns && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "ai_debugTurns") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v78);
    if ( v78->current.enabled )
      G_DebugLineWithDuration(&_R13->r.currentOrigin, &end, &colorTeal, 0, 10);
LABEL_26:
    result = 1;
    goto LABEL_27;
  }
  if ( !DVARBOOL_ai_debugTurns && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "ai_debugTurns") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v78);
  if ( !v78->current.enabled )
    goto LABEL_20;
  v103 = &colorOrangeHeat;
LABEL_19:
  G_DebugLineWithDuration(&_R13->r.currentOrigin, &end, v103, 0, 10);
LABEL_20:
  result = 0;
LABEL_27:
  _R11 = &v128;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
    vmovaps xmm13, xmmword ptr [r11-80h]
    vmovaps xmm14, xmmword ptr [r11-90h]
    vmovaps xmm15, xmmword ptr [r11-0A0h]
  }
  return result;
}

/*
==============
AIScriptedInterface::CanSeeAndShootPoint
==============
*/
bool AIScriptedInterface::CanSeeAndShootPoint(AIScriptedInterface *this, const vec3_t *vPoint)
{
  bool result; 
  vec3_t outEyePos; 
  vec3_t outOrigin; 

  result = 0;
  if ( this->GetEquippedWeapon(this)->weaponIdx )
  {
    AIScriptedInterface::GetApproxEyePos(this, &outEyePos, 0);
    if ( AICommonInterface::SightTrace(this, &outEyePos, vPoint, 2047, NORMAL_FOLIAGE_CHECKS) )
    {
      AIScriptedInterface::GetMuzzlePosApprox(this, &outOrigin);
      if ( AICommonInterface::SightTrace(this, &outOrigin, vPoint, 2047, NORMAL_FOLIAGE_CHECKS) )
        return 1;
    }
  }
  return result;
}

/*
==============
AIScriptedInterface::CanSeeEnemyFromExposed
==============
*/
_BOOL8 AIScriptedInterface::CanSeeEnemyFromExposed(AIScriptedInterface *this, const pathnode_t *pNode)
{
  gentity_s *TargetEntity; 
  bool CanSeePointFromExposedAtNode; 
  const sentient_s *sentient; 
  int v7; 
  AIWrapper v19; 
  vec3_t outEyePos; 

  Sys_ProfBeginNamedEvent(0xFF808080, "AIScr_CanSeeEnemyFromExposed");
  TargetEntity = AICommonInterface::GetTargetEntity(this);
  if ( TargetEntity )
  {
    AIActorInterface::AIActorInterface(&v19.m_actorInterface);
    AIAgentInterface::AIAgentInterface(&v19.m_newAgentInterface);
    v19.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
    v19.m_pAI = NULL;
    AIWrapper::Setup(&v19, TargetEntity);
    if ( pNode )
    {
      if ( v19.m_pAI )
      {
        AIScriptedInterface::GetApproxEyePos(v19.m_pAI, &outEyePos, 0);
      }
      else
      {
        sentient = TargetEntity->sentient;
        if ( sentient )
          Sentient_GetEyePosition(sentient, &outEyePos);
        else
          G_Utils_EntityCentroid(TargetEntity, &outEyePos);
      }
      if ( this->Is3D(this) )
      {
        v7 = 1 << LOBYTE(pNode->constant.type);
        if ( (v7 & 0x1E300000) != 0 || (v7 & 0x400000) != 0 )
        {
          CanSeePointFromExposedAtNode = AIScriptedInterface::CanSeePointFromExposedAtNode(this, &outEyePos, pNode, this->m_pAI->eCurrentStance);
          if ( CanSeePointFromExposedAtNode )
            goto LABEL_16;
          __asm
          {
            vmovss  xmm0, dword ptr [rsp+0B8h+outEyePos]
            vaddss  xmm1, xmm0, dword ptr [rsi+130h]
            vmovss  xmm3, cs:__real@3f000000
            vmulss  xmm1, xmm1, xmm3
            vmovss  dword ptr [rsp+0B8h+outEyePos], xmm1
            vmovss  xmm0, dword ptr [rsp+0B8h+outEyePos+4]
            vaddss  xmm2, xmm0, dword ptr [rsi+134h]
            vmulss  xmm1, xmm2, xmm3
            vmovss  dword ptr [rsp+0B8h+outEyePos+4], xmm1
            vmovss  xmm0, dword ptr [rsp+0B8h+outEyePos+8]
            vaddss  xmm2, xmm0, dword ptr [rsi+138h]
            vmulss  xmm1, xmm2, xmm3
            vmovss  dword ptr [rsp+0B8h+outEyePos+8], xmm1
          }
        }
      }
      CanSeePointFromExposedAtNode = AIScriptedInterface::CanSeePointFromExposedAtNode(this, &outEyePos, pNode, this->m_pAI->eCurrentStance);
      goto LABEL_16;
    }
    CanSeePointFromExposedAtNode = AICommonInterface::CanSeeEnemy(this) != 0;
  }
  else
  {
    CanSeePointFromExposedAtNode = 0;
  }
LABEL_16:
  Sys_ProfEndNamedEvent();
  return CanSeePointFromExposedAtNode;
}

/*
==============
AIScriptedInterface::CanSeePointFromExposedAtNode
==============
*/
bool AIScriptedInterface::CanSeePointFromExposedAtNode(AIScriptedInterface *this, const vec3_t *point, const pathnode_t *pNode, ai_stance_e stance)
{
  unsigned __int16 type; 
  char v28; 
  char v29; 
  gentity_s *TargetEntity; 
  int v37; 
  int number; 
  ai_scripted_t *m_pAI; 
  int ignoreEnt2; 
  vec3_t pos; 
  vec3_t fromPoint; 
  vec2_t vec; 
  vec3_t out; 
  vec3_t vector; 
  vec3_t outEyeOffset; 
  vec4_t quat; 

  _R15 = point;
  pathnode_t::GetPos((pathnode_t *)pNode, &pos);
  type = pNode->constant.type;
  if ( type == 31 )
    type = pNode->dynamic.coverMultiType;
  if ( (unsigned int)type - 6 <= 1 )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [r15]
      vsubss  xmm1, xmm0, dword ptr [rbp+57h+pos]
      vmovss  xmm2, dword ptr [r15+4]
      vsubss  xmm0, xmm2, dword ptr [rbp+57h+pos+4]
      vmovss  dword ptr [rbp+57h+vec], xmm1
      vmovss  xmm1, dword ptr [r15+8]
      vsubss  xmm2, xmm1, dword ptr [rbp+57h+pos+8]
      vmovaps [rsp+100h+var_40], xmm6
      vmovss  [rbp+57h+var_98], xmm2
      vmovss  dword ptr [rbp+57h+vec+4], xmm0
    }
    *(double *)&_XMM0 = vectoyaw(&vec);
    __asm { vmovaps xmm6, xmm0 }
    *(double *)&_XMM0 = pathnode_t::GetAngle((pathnode_t *)pNode);
    __asm
    {
      vsubss  xmm1, xmm6, xmm0
      vmulss  xmm5, xmm1, cs:__real@3b360b61
      vaddss  xmm2, xmm5, cs:__real@3f000000
      vmovaps xmm6, [rsp+100h+var_40]
      vxorps  xmm0, xmm0, xmm0
      vmovss  xmm3, xmm0, xmm2
      vxorps  xmm1, xmm1, xmm1
      vroundss xmm4, xmm1, xmm3, 1
      vsubss  xmm0, xmm5, xmm4
      vmulss  xmm2, xmm0, cs:__real@43b40000
      vandps  xmm1, xmm2, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
      vcomiss xmm1, cs:__real@42700000
    }
    if ( !(v28 | v29) )
      return 0;
    if ( type == 7 )
      __asm { vcomiss xmm2, cs:__real@c1600000 }
    __asm { vcomiss xmm2, cs:__real@41400000 }
    if ( type > 7u )
      return 0;
  }
  GetNodeExposedEyeOffset(type, stance, &outEyeOffset);
  pathnode_t::GetAngles((pathnode_t *)pNode, &vector);
  AnglesToQuat(&vector, &quat);
  QuatTransform(&quat, &outEyeOffset, &out);
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+57h+out]
    vaddss  xmm1, xmm0, dword ptr [rbp+57h+pos]
    vmovss  xmm2, dword ptr [rbp+57h+out+4]
    vaddss  xmm0, xmm2, dword ptr [rbp+57h+pos+4]
    vmovss  dword ptr [rbp+57h+fromPoint], xmm1
    vmovss  xmm1, dword ptr [rbp+57h+out+8]
    vaddss  xmm2, xmm1, dword ptr [rbp+57h+pos+8]
    vmovss  dword ptr [rbp+57h+fromPoint+8], xmm2
    vmovss  dword ptr [rbp+57h+fromPoint+4], xmm0
  }
  if ( !AIScriptedInterface::CheckPitchVisibility(this, &fromPoint, _R15, pNode) )
    return 0;
  TargetEntity = AICommonInterface::GetTargetEntity(this);
  v37 = 2047;
  if ( TargetEntity )
    number = TargetEntity->s.number;
  else
    number = 2047;
  if ( AIScriptedInterface::SightTracePassed(this, &fromPoint, _R15, number, this->m_pAI->ent->s.number, 1, 0, 0) )
    return 1;
  if ( (unsigned __int16)(pNode->constant.type - 3) > 1u )
    return 0;
  m_pAI = this->m_pAI;
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+57h+pos]
    vmovss  xmm1, dword ptr [rbp+57h+pos+4]
    vmovss  dword ptr [rbp+57h+fromPoint], xmm0
    vmovss  xmm0, dword ptr [rbp+57h+pos+8]
    vaddss  xmm2, xmm0, cs:__real@42800000
    vmovss  dword ptr [rbp+57h+fromPoint+8], xmm2
    vmovss  dword ptr [rbp+57h+fromPoint+4], xmm1
  }
  ignoreEnt2 = m_pAI->ent->s.number;
  if ( TargetEntity )
    v37 = TargetEntity->s.number;
  return AIScriptedInterface::SightTracePassed(this, &fromPoint, _R15, v37, ignoreEnt2, 1, 0, 0);
}

/*
==============
AIScriptedInterface::CanSuppressEnemy
==============
*/
bool AIScriptedInterface::CanSuppressEnemy(AIScriptedInterface *this)
{
  gentity_s *TargetEntity; 
  vec3_t outEyePos; 

  if ( AICommonInterface::GetTargetSentient(this) && this->m_pAI->sight.lastEnemySightPosValid && AIScriptedInterface::IsCurrentEnemyValid(this) && (this->m_pAI->bGoodShootPos || AIScriptedInterface::NeedRecalculateSuppressSpot(this)) && !this->m_pAI->combat.doingAmbush )
  {
    TargetEntity = AICommonInterface::GetTargetEntity(this);
    if ( TargetEntity && !TargetEntity->client )
      return AIScriptedInterface::AISuppressAI(this);
    AIScriptedInterface::GetApproxEyePos(this, &outEyePos, 0);
    if ( AIScriptedInterface::CheckPitchVisibility(this, &outEyePos, &this->m_pAI->sight.lastEnemySightPos, NULL) )
      return AIScriptedInterface::FindGoodSuppressSpot(this, &outEyePos);
  }
  else
  {
    this->m_pAI->bGoodShootPos = 0;
  }
  return 0;
}

/*
==============
AIScriptedInterface::CheckPitchVisibility
==============
*/
bool AIScriptedInterface::CheckPitchVisibility(AIScriptedInterface *this, const vec3_t *fromPoint, const vec3_t *toPoint, const pathnode_t *pNode)
{
  AIScriptedInterface_vtbl *v13; 
  int v21; 
  char v33; 
  char v34; 
  bool v43; 
  unsigned __int16 type; 
  bool result; 
  vec3_t in; 
  vec3_t vector; 
  vec4_t quat; 
  vec4_t v53; 
  vec3_t out; 
  char vars0; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-18h], xmm6
    vmovaps xmmword ptr [rax-28h], xmm7
  }
  _RAX = this->m_pAI;
  __asm
  {
    vmovss  xmm1, cs:__real@41a00000
    vmovss  xmm0, dword ptr [rax+0E8h]
    vaddss  xmm6, xmm1, dword ptr [rax+0ECh]
  }
  v13 = this->__vftable;
  __asm
  {
    vsubss  xmm7, xmm0, xmm1
    vmovss  xmm1, dword ptr [r8]
    vsubss  xmm2, xmm1, dword ptr [rdx]
    vmovss  xmm0, dword ptr [r8+4]
    vsubss  xmm1, xmm0, dword ptr [rdx+4]
    vmovss  dword ptr [rbp+57h+in], xmm2
    vmovss  xmm2, dword ptr [r8+8]
    vsubss  xmm0, xmm2, dword ptr [rdx+8]
    vmovss  dword ptr [rbp+57h+in+8], xmm0
    vmovss  dword ptr [rbp+57h+in+4], xmm1
  }
  if ( v13->Is3D(this) )
  {
    if ( pNode && ((v21 = 1 << LOBYTE(pNode->constant.type), (v21 & 0x1E300000) != 0) || (v21 & 0x400000) != 0) )
    {
      pathnode_t::GetAngles((pathnode_t *)pNode, &vector);
    }
    else
    {
      _RCX = this->m_pAI->ent;
      __asm
      {
        vmovss  xmm0, dword ptr [rcx+13Ch]
        vmovss  dword ptr [rbp+57h+vector], xmm0
        vmovss  xmm1, dword ptr [rcx+140h]
        vmovss  dword ptr [rbp+57h+vector+4], xmm1
        vmovss  xmm0, dword ptr [rcx+144h]
        vmovss  dword ptr [rbp+57h+vector+8], xmm0
      }
    }
    AnglesToQuat(&vector, &quat);
    __asm
    {
      vmovss  xmm3, dword ptr cs:__xmm@80000000800000008000000080000000
      vmovss  xmm0, dword ptr [rbp+57h+quat]
      vmovss  xmm2, dword ptr [rbp+57h+quat+4]
      vxorps  xmm1, xmm0, xmm3
      vxorps  xmm0, xmm2, xmm3
      vmovss  dword ptr [rbp+57h+var_50], xmm1
      vmovss  xmm1, dword ptr [rbp+57h+quat+8]
      vmovss  dword ptr [rbp+57h+var_50+4], xmm0
      vmovss  xmm0, dword ptr [rbp+57h+quat+0Ch]
      vxorps  xmm2, xmm1, xmm3
      vmovss  dword ptr [rbp+57h+var_50+8], xmm2
      vmovss  dword ptr [rbp+57h+var_50+0Ch], xmm0
    }
    QuatTransform(&v53, &in, &out);
    __asm
    {
      vmovsd  xmm0, qword ptr [rbp+57h+out]
      vmovsd  qword ptr [rbp+57h+in], xmm0
    }
    in.v[2] = out.v[2];
  }
  *(double *)&_XMM0 = vectopitch(&in);
  __asm
  {
    vmulss  xmm5, xmm0, cs:__real@3b360b61
    vaddss  xmm2, xmm5, cs:__real@3f000000
    vxorps  xmm1, xmm1, xmm1
    vmovss  xmm3, xmm1, xmm2
    vxorps  xmm0, xmm0, xmm0
    vroundss xmm4, xmm0, xmm3, 1
    vsubss  xmm1, xmm5, xmm4
    vmulss  xmm2, xmm1, cs:__real@43b40000
    vcomiss xmm2, xmm7
  }
  if ( v33 )
    goto LABEL_14;
  __asm { vcomiss xmm2, xmm6 }
  if ( v33 | v34 )
    goto LABEL_13;
  v43 = pNode == NULL;
  if ( pNode )
  {
    type = pNode->constant.type;
    v43 = (unsigned __int16)(type - 3) <= 1u;
    if ( (unsigned __int16)(type - 3) > 1u )
      goto LABEL_14;
  }
  __asm
  {
    vaddss  xmm0, xmm6, cs:__real@425c0000
    vcomiss xmm2, xmm0
  }
  if ( !v43 )
LABEL_14:
    result = 0;
  else
LABEL_13:
    result = 1;
  _R11 = &vars0;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
  }
  return result;
}

/*
==============
AIScriptedInterface::ClearIdleFacingUseAlliesPos
==============
*/
void AIScriptedInterface::ClearIdleFacingUseAlliesPos(AIScriptedInterface *this)
{
  this->m_pAI->bCachedIdleFacingPosValid = 0;
}

/*
==============
CullCoverPosesForShort
==============
*/
__int64 CullCoverPosesForShort(ai_scripted_t *pScripted, const pathnode_t *pNode, scr_string_t *possiblePoses, int numPossiblePoses, const scr_string_t *curCoverPose)
{
  __int64 v8; 
  __int16 type; 
  __m256i *v18; 
  unsigned int v19; 
  __int64 v20; 
  __int64 v21; 
  __int64 v22; 
  scr_string_t v24; 
  bool v25; 
  __int64 v26; 
  const vec4_t *v40; 
  const dvar_t *v41; 
  __int64 result; 
  __m256i *v46; 
  AIScriptedInterface *m_pAI; 
  AIWrapper v49; 
  vec3_t out; 
  vec3_t endPos; 
  vec3_t pos; 
  vec3_t vector; 
  tmat33_t<vec3_t> axis; 
  __m256i v55; 
  __m256i v57; 
  __m256i v59; 
  char v61; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
  }
  v8 = (unsigned int)numPossiblePoses;
  Sys_ProfBeginNamedEvent(0xFF808080, "AIScr_CullCoverPosesForShort");
  __asm
  {
    vmovups ymm0, cs:__ymm@0000000000000000000000000000000000000000423800000000000000000000
    vmovups [rbp+0F0h+var_D8], ymm0
    vxorps  xmm6, xmm6, xmm6
    vmovss  [rbp+0F0h+var_B8], xmm6
    vmovups ymm0, cs:__ymm@c200000000000000421000004200000000000000421000000000000000000000
    vmovups [rbp+0F0h+var_B0], ymm0
    vmovss  xmm1, cs:__real@42100000
    vmovss  [rbp+0F0h+var_90], xmm1
    vmovups ymm0, cs:__ymm@0000000000000000000000000000000000000000421000000000000000000000
    vmovups [rbp+0F0h+var_88], ymm0
    vmovss  [rbp+0F0h+var_68], xmm6
  }
  type = pNode->constant.type;
  if ( type == 31 )
    type = pNode->dynamic.turretEntNumber;
  switch ( type )
  {
    case 2:
    case 10:
      v18 = &v55;
      goto LABEL_7;
    case 3:
    case 4:
    case 11:
      v18 = &v57;
      goto LABEL_7;
    case 6:
    case 7:
      v18 = &v59;
LABEL_7:
      v46 = v18;
      pathnode_t::GetPos((pathnode_t *)pNode, &pos);
      pathnode_t::GetAngles((pathnode_t *)pNode, &vector);
      AnglesToAxis(&vector, &axis);
      AIActorInterface::AIActorInterface(&v49.m_actorInterface);
      AIAgentInterface::AIAgentInterface(&v49.m_newAgentInterface);
      v49.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
      v49.m_pAI = NULL;
      AIWrapper::Setup(&v49, pScripted->ent);
      m_pAI = v49.m_pAI;
      if ( !v49.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 7700, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
        __debugbreak();
      v19 = 0;
      if ( (int)v8 <= 0 )
        goto LABEL_41;
      v20 = 0i64;
      v21 = 0i64;
      v22 = v8;
      __asm { vmovss  xmm7, cs:__real@42000000 }
      break;
    default:
      v19 = v8;
      goto LABEL_41;
  }
  do
  {
    v24 = possiblePoses[v21];
    if ( v24 == scr_const.full_exposed || v24 == *curCoverPose )
    {
      if ( v20 <= v21 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 7709, ASSERT_TYPE_ASSERT, "(numPoses <= iPose)", (const char *)&queryFormat, "numPoses <= iPose") )
        goto LABEL_24;
      __debugbreak();
      possiblePoses[v20] = possiblePoses[v21];
      ++v19;
      ++v20;
    }
    else
    {
      v25 = v24 == scr_const.left;
      if ( v24 == scr_const.left )
      {
        v26 = 1i64;
      }
      else
      {
        v26 = 0i64;
        v25 = v24 == scr_const.right;
        if ( v24 == scr_const.right )
          v26 = 2i64;
      }
      _RCX = (const vec3_t *)((char *)v18 + 12 * v26);
      __asm { vucomiss xmm6, dword ptr [rcx] }
      if ( v25 )
      {
        __asm { vucomiss xmm6, dword ptr [rcx+4] }
        if ( v25 )
        {
          __asm { vucomiss xmm6, dword ptr [rcx+8] }
          if ( v25 )
          {
            if ( v20 > v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 7752, ASSERT_TYPE_ASSERT, "(numPoses <= iPose)", (const char *)&queryFormat, "numPoses <= iPose") )
              __debugbreak();
LABEL_24:
            possiblePoses[v20] = possiblePoses[v21];
            ++v19;
            ++v20;
            goto LABEL_35;
          }
        }
      }
      MatrixTransformVector(_RCX, &axis, &out);
      __asm
      {
        vmovss  xmm0, dword ptr [rbp+0F0h+pos]
        vaddss  xmm2, xmm0, dword ptr [rbp+0F0h+out]
        vmovss  dword ptr [rbp+0F0h+out], xmm2
        vmovss  xmm1, dword ptr [rbp+0F0h+pos+4]
        vaddss  xmm3, xmm1, dword ptr [rbp+0F0h+out+4]
        vmovss  dword ptr [rbp+0F0h+out+4], xmm3
        vmovss  xmm0, dword ptr [rbp+0F0h+pos+8]
        vaddss  xmm4, xmm0, dword ptr [rbp+0F0h+out+8]
        vmovss  dword ptr [rbp+0F0h+out+8], xmm4
        vmulss  xmm0, xmm7, dword ptr [rbp+0F0h+axis]
        vaddss  xmm2, xmm0, xmm2
        vmovss  dword ptr [rbp+0F0h+endPos], xmm2
        vmulss  xmm0, xmm7, dword ptr [rbp+0F0h+axis+4]
        vaddss  xmm2, xmm0, xmm3
        vmovss  dword ptr [rbp+0F0h+endPos+4], xmm2
        vmulss  xmm0, xmm7, dword ptr [rbp+0F0h+axis+8]
        vaddss  xmm2, xmm0, xmm4
        vmovss  dword ptr [rbp+0F0h+endPos+8], xmm2
      }
      v40 = &colorRed;
      if ( AIScriptedInterface::SightTracePassed(m_pAI, &out, &endPos, pScripted->ent->s.number, 2047, 1, 0, 1) )
      {
        if ( v20 > v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 7736, ASSERT_TYPE_ASSERT, "(numPoses <= iPose)", (const char *)&queryFormat, "numPoses <= iPose") )
          __debugbreak();
        possiblePoses[v20] = possiblePoses[v21];
        ++v19;
        ++v20;
        v40 = &colorGreen;
      }
      v41 = DVARBOOL_ai_debugShort;
      if ( !DVARBOOL_ai_debugShort && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "ai_debugShort") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v41);
      if ( v41->current.enabled )
        G_DebugLineWithDuration(&out, &endPos, v40, 0, 20);
    }
LABEL_35:
    ++v21;
    --v22;
    v18 = v46;
  }
  while ( v22 );
LABEL_41:
  Sys_ProfEndNamedEvent();
  result = v19;
  _R11 = &v61;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
  }
  return result;
}

/*
==============
DebugArrivalPosition
==============
*/
void DebugArrivalPosition(const gentity_s *const pEnt, const vec3_t *goalOrigin, const vec3_t *arrivalAngles)
{
  vec3_t end; 
  vec3_t forward; 
  vec4_t color; 

  _RBX = goalOrigin;
  if ( DebugArrivalsOnActor(pEnt->s.number) )
  {
    AngleVectors(arrivalAngles, &forward, NULL, NULL);
    __asm
    {
      vmovss  xmm3, cs:__real@41800000
      vmovups xmm0, cs:__xmm@3f800000000000003ecccccd3f800000
      vmulss  xmm1, xmm3, dword ptr [rsp+78h+forward+4]
      vmovups xmmword ptr [rsp+78h+color], xmm0
      vmulss  xmm0, xmm3, dword ptr [rsp+78h+forward]
      vaddss  xmm2, xmm0, dword ptr [rbx]
      vmovss  dword ptr [rsp+78h+end], xmm2
      vaddss  xmm2, xmm1, dword ptr [rbx+4]
      vmulss  xmm1, xmm3, dword ptr [rsp+78h+forward+8]
      vmovss  dword ptr [rsp+78h+end+4], xmm2
      vaddss  xmm2, xmm1, dword ptr [rbx+8]
      vmovss  dword ptr [rsp+78h+end+8], xmm2
    }
    G_DebugLineWithDuration(_RBX, &end, &color, 0, 1);
    __asm
    {
      vmovss  xmm0, dword ptr [rbx]
      vmovss  xmm1, dword ptr [rbx+4]
      vmovss  dword ptr [rsp+78h+end], xmm0
      vmovss  xmm0, dword ptr [rbx+8]
      vaddss  xmm2, xmm0, cs:__real@42800000
      vmovss  dword ptr [rsp+78h+end+8], xmm2
      vmovss  dword ptr [rsp+78h+end+4], xmm1
    }
    G_DebugLineWithDuration(_RBX, &end, &color, 0, 1);
  }
}

/*
==============
DebugArrivalsOnActor
==============
*/
bool DebugArrivalsOnActor(const int entnum)
{
  const dvar_t *v1; 
  const char *string; 

  v1 = DVARSTR_debug_arrivals;
  if ( !DVARSTR_debug_arrivals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 748, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "debug_arrivals") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  string = v1->current.string;
  return I_strcmp(string, "off") && (!I_strcmp(string, "on") || atoi(string) == entnum);
}

/*
==============
FindBestSlice
==============
*/

__int64 __fastcall FindBestSlice(const float *results, int maxSlices, double minDist, double _XMM3_8)
{
  unsigned int v6; 
  __int64 v7; 
  int v8; 
  signed int v9; 
  int v10; 
  int v12; 
  bool v16; 
  char v17; 
  int v20; 
  bool v21; 
  bool v22; 
  int v23; 
  int v26; 
  bool v27; 

  v6 = 0;
  v7 = maxSlices;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v12 = -1;
  __asm
  {
    vxorps  xmm1, xmm1, xmm1
    vxorps  xmm4, xmm4, xmm4
    vxorps  xmm3, xmm3, xmm3
  }
  v16 = maxSlices == 0;
  v17 = maxSlices == 0;
  if ( maxSlices <= 0 )
    return (unsigned int)v12;
  _RBP = results;
  while ( 1 )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rbp+0]
      vcomiss xmm0, xmm2
    }
    if ( !v17 )
    {
      ++v9;
      __asm { vmaxss  xmm3, xmm0, xmm3 }
      if ( !v8 )
      {
        v20 = v7 - 1;
        v21 = 0;
        v22 = (_DWORD)v7 == 1;
        if ( (_DWORD)v7 != 1 )
        {
          v23 = -1;
          _RAX = &results[v7 - 1];
          do
          {
            __asm
            {
              vmovss  xmm0, dword ptr [rax]
              vcomiss xmm0, xmm1
            }
            v26 = v9;
            if ( v22 )
            {
              if ( v21 )
                goto LABEL_24;
            }
            else
            {
              __asm { vmaxss  xmm3, xmm0, xmm3 }
            }
            ++v9;
            v21 = (unsigned __int64)_RAX-- < 4;
            v10 = v23;
            v17 = v21 | (v23-- == 1);
            __asm { vcomiss xmm0, xmm1 }
            if ( v17 )
              v9 = v26;
            v21 = v20-- == 0;
            v22 = v21 || v20 == 0;
          }
          while ( v20 );
        }
      }
      goto LABEL_24;
    }
    __asm { vucomiss xmm0, xmm1 }
    if ( !v16 || v8 == (_DWORD)v7 - 1 && v9 >= (int)v6 )
      break;
LABEL_24:
    ++v8;
    ++_RBP;
    v16 = v8 == (_DWORD)v7;
    v17 = v8 <= (unsigned int)v7;
    if ( v8 >= (int)v7 )
      return (unsigned int)v12;
  }
  if ( v9 != (_DWORD)v7 )
  {
    v27 = v9 > (int)v6;
    if ( v9 == v6 )
    {
      __asm { vcomiss xmm3, xmm4 }
      v27 = v9 > v6;
    }
    if ( v27 )
    {
      v6 = v9;
      v12 = (v10 + v8) / 2;
      __asm { vmovaps xmm4, xmm3 }
      if ( v12 < 0 )
        v12 += v7;
    }
    v10 = v8 + 1;
    v9 = 0;
    __asm { vmovaps xmm3, xmm1 }
    goto LABEL_24;
  }
  return 0xFFFFFFFFi64;
}

/*
==============
AIScriptedInterface::FindGoodSuppressSpot
==============
*/
char AIScriptedInterface::FindGoodSuppressSpot(AIScriptedInterface *this, const vec3_t *startOffset)
{
  ai_scripted_t *m_pAI; 
  ai_scripted_t *v19; 
  gentity_s *ent; 
  ai_scripted_t *v21; 
  ai_scripted_t *v22; 
  const sentient_s *TargetSentient; 
  ai_scripted_t *v28; 
  int lastEnemySuppressTime; 
  bool PathGoalPos; 
  bool v44; 
  ai_scripted_t *v56; 
  vec3_t outEyePos; 
  vec3_t vEyePosOut; 

  _RAX = AICommonInterface::GetTargetSentient(this);
  if ( _RAX )
  {
    __asm { vmovss  xmm0, dword ptr [rax+30h] }
    _RCX = _RAX->ent;
    __asm
    {
      vminss  xmm1, xmm0, cs:__real@44800000
      vaddss  xmm5, xmm1, cs:__real@44400000
    }
    m_pAI = this->m_pAI;
    __asm
    {
      vmovss  xmm0, dword ptr [rcx+130h]
      vmovss  xmm1, dword ptr [rcx+134h]
      vsubss  xmm4, xmm0, dword ptr [rax]
      vsubss  xmm2, xmm1, dword ptr [rax+4]
      vmulss  xmm3, xmm2, xmm2
      vmulss  xmm0, xmm4, xmm4
      vaddss  xmm4, xmm3, xmm0
      vmulss  xmm1, xmm5, xmm5
      vcomiss xmm4, xmm1
    }
    if ( m_pAI->ent < (gentity_s *)0xFFFFFFFFFFFFFED0i64 && m_pAI->ent != (gentity_s *)-304i64 )
    {
      m_pAI->bGoodShootPos = 0;
      return 0;
    }
  }
  if ( AIScriptedInterface::NeedRecalculateSuppressSpot(this) )
  {
    v19 = this->m_pAI;
    ent = v19->ent;
    v19->sight.vLastEnemySightPosSelfOrigin.v[0] = v19->ent->r.currentOrigin.v[0];
    v19->sight.vLastEnemySightPosSelfOrigin.v[1] = ent->r.currentOrigin.v[1];
    v19->sight.vLastEnemySightPosSelfOrigin.v[2] = ent->r.currentOrigin.v[2];
    this->m_pAI->sight.bLastEnemySightPosSelfOrigin = 1;
    v21 = this->m_pAI;
    v21->sight.vLastEnemySightPosOld.v[0] = v21->sight.lastEnemySightPos.v[0];
    v21->sight.vLastEnemySightPosOld.v[1] = v21->sight.lastEnemySightPos.v[1];
    v21->sight.vLastEnemySightPosOld.v[2] = v21->sight.lastEnemySightPos.v[2];
    this->m_pAI->sight.bLastEnemySightPosOld = 1;
    v22 = this->m_pAI;
    if ( v22->bSuppressUseLastEnemySightPos )
    {
      v22->vGoodShootPos.v[0] = v22->sight.lastEnemySightPos.v[0];
      v22->vGoodShootPos.v[1] = v22->sight.lastEnemySightPos.v[1];
      v22->vGoodShootPos.v[2] = v22->sight.lastEnemySightPos.v[2];
      return 1;
    }
    TargetSentient = AICommonInterface::GetTargetSentient(this);
    if ( TargetSentient )
    {
      Sentient_GetEyePosition(TargetSentient, &vEyePosOut);
      _RAX = this->m_pAI;
      __asm
      {
        vmovss  xmm0, dword ptr [rsp+68h+vEyePosOut]
        vmovss  dword ptr [rax+0DE8h], xmm0
        vmovss  xmm1, dword ptr [rsp+68h+vEyePosOut+4]
        vmovss  dword ptr [rax+0DECh], xmm1
        vmovss  xmm0, dword ptr [rsp+68h+vEyePosOut+8]
        vmovss  dword ptr [rax+0DF0h], xmm0
      }
      v28 = this->m_pAI;
      __asm { vmovsd  xmm1, qword ptr [rsp+68h+vEyePosOut] }
      outEyePos.v[2] = vEyePosOut.v[2];
      __asm { vmovsd  qword ptr [rsp+68h+outEyePos], xmm1 }
      v28->lastEnemySuppressTime = level.time;
      _RCX = this->m_pAI;
    }
    else
    {
      _RCX = this->m_pAI;
      lastEnemySuppressTime = _RCX->lastEnemySuppressTime;
      if ( lastEnemySuppressTime <= 0 || lastEnemySuppressTime + 3000 >= level.time )
      {
        AIScriptedInterface::GetApproxEyePos(this, &outEyePos, 0);
        _RCX = this->m_pAI;
        __asm
        {
          vmovss  xmm4, cs:__real@43440000
          vmulss  xmm1, xmm4, dword ptr [rcx+15Ch]
          vaddss  xmm1, xmm1, dword ptr [rsp+68h+outEyePos]
          vmovss  dword ptr [rsp+68h+outEyePos], xmm1
          vmulss  xmm3, xmm4, dword ptr [rcx+160h]
          vaddss  xmm1, xmm3, dword ptr [rsp+68h+outEyePos+4]
          vmovss  dword ptr [rsp+68h+outEyePos+4], xmm1
          vmulss  xmm3, xmm4, dword ptr [rcx+164h]
          vaddss  xmm1, xmm3, dword ptr [rsp+68h+outEyePos+8]
          vmovss  dword ptr [rsp+68h+outEyePos+8], xmm1
        }
      }
      else
      {
        __asm
        {
          vmovss  xmm0, dword ptr [rcx+0DE8h]
          vmovss  dword ptr [rsp+68h+outEyePos], xmm0
          vmovss  xmm1, dword ptr [rcx+0DECh]
          vmovss  dword ptr [rsp+68h+outEyePos+4], xmm1
          vmovss  xmm0, dword ptr [rcx+0DF0h]
          vmovss  dword ptr [rsp+68h+outEyePos+8], xmm0
        }
      }
    }
    this->m_pAI->bGoodShootPos = this->CalcSuppressSpot(this, startOffset, &outEyePos, -1, &_RCX->vGoodShootPos);
    v56 = this->m_pAI;
  }
  else
  {
    PathGoalPos = AIScriptedInterface::GetPathGoalPos(this, &vEyePosOut);
    _RCX = this->m_pAI;
    v44 = PathGoalPos;
    v56 = _RCX;
    if ( _RCX->bGoodShootPos && v44 )
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rcx+0DDCh]
        vmovss  xmm1, dword ptr [rcx+0DE0h]
        vsubss  xmm2, xmm1, dword ptr [rax+134h]
        vsubss  xmm4, xmm0, dword ptr [rax+130h]
        vmovss  xmm0, dword ptr [rcx+0DE4h]
        vsubss  xmm3, xmm0, dword ptr [rax+138h]
        vmulss  xmm1, xmm2, xmm2
        vmulss  xmm0, xmm4, xmm4
        vaddss  xmm2, xmm1, xmm0
        vmulss  xmm1, xmm3, xmm3
        vaddss  xmm2, xmm2, xmm1
        vcomiss xmm2, cs:__real@44800000
      }
      v56 = this->m_pAI;
    }
  }
  return v56->bGoodShootPos;
}

/*
==============
AIScriptedInterface::GetEnemySuppressPos
==============
*/
void AIScriptedInterface::GetEnemySuppressPos(AIScriptedInterface *this, vec3_t *outEnemyEyePos)
{
  const sentient_s *TargetSentient; 
  ai_scripted_t *m_pAI; 
  int lastEnemySuppressTime; 
  vec3_t vEyePosOut; 

  _RBX = outEnemyEyePos;
  TargetSentient = AICommonInterface::GetTargetSentient(this);
  if ( TargetSentient )
  {
    Sentient_GetEyePosition(TargetSentient, &vEyePosOut);
    _RAX = this->m_pAI;
    __asm
    {
      vmovss  xmm0, dword ptr [rsp+48h+vEyePosOut]
      vmovss  dword ptr [rax+0DE8h], xmm0
      vmovss  xmm1, dword ptr [rsp+48h+vEyePosOut+4]
      vmovss  dword ptr [rax+0DECh], xmm1
      vmovss  xmm0, dword ptr [rsp+48h+vEyePosOut+8]
      vmovss  dword ptr [rax+0DF0h], xmm0
      vmovss  xmm1, dword ptr [rsp+48h+vEyePosOut]
      vmovss  xmm0, dword ptr [rsp+48h+vEyePosOut+4]
      vmovss  dword ptr [rbx], xmm1
      vmovss  xmm1, dword ptr [rsp+48h+vEyePosOut+8]
      vmovss  dword ptr [rbx+8], xmm1
      vmovss  dword ptr [rbx+4], xmm0
    }
    this->m_pAI->lastEnemySuppressTime = level.time;
  }
  else
  {
    m_pAI = this->m_pAI;
    lastEnemySuppressTime = m_pAI->lastEnemySuppressTime;
    if ( lastEnemySuppressTime <= 0 || lastEnemySuppressTime + 3000 >= level.time )
    {
      AIScriptedInterface::GetApproxEyePos(this, _RBX, 0);
      __asm
      {
        vmovss  xmm3, cs:__real@43440000
        vmulss  xmm0, xmm3, dword ptr [rax+15Ch]
        vaddss  xmm1, xmm0, dword ptr [rbx]
        vmovss  dword ptr [rbx], xmm1
        vmulss  xmm1, xmm3, dword ptr [rax+160h]
        vaddss  xmm2, xmm1, dword ptr [rbx+4]
        vmovss  dword ptr [rbx+4], xmm2
        vmulss  xmm1, xmm3, dword ptr [rax+164h]
        vaddss  xmm2, xmm1, dword ptr [rbx+8]
        vmovss  dword ptr [rbx+8], xmm2
      }
    }
    else
    {
      _RBX->v[0] = m_pAI->vLastEnemySuppressPos.v[0];
      _RBX->v[1] = m_pAI->vLastEnemySuppressPos.v[1];
      _RBX->v[2] = m_pAI->vLastEnemySuppressPos.v[2];
    }
  }
}

/*
==============
GetVectorArray
==============
*/
__int64 GetVectorArray(scrContext_t *scrContext, int argIdx, vec3_t *pVecArray, int maxNumVecs)
{
  unsigned int v8; 
  const char *v9; 
  unsigned int Object; 
  int ArraySize; 
  const char *v12; 
  unsigned int FirstSibling; 
  float *v15; 
  VariableType type; 
  const char *v17; 
  VariableUnion u; 
  VariableValue out; 

  if ( !pVecArray && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 510, ASSERT_TYPE_ASSERT, "(pVecArray)", (const char *)&queryFormat, "pVecArray") )
    __debugbreak();
  if ( maxNumVecs <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 511, ASSERT_TYPE_ASSERT, "(maxNumVecs > 0)", (const char *)&queryFormat, "maxNumVecs > 0") )
    __debugbreak();
  v8 = 0;
  if ( Scr_GetPointerType(scrContext, argIdx) != VAR_ARRAY )
  {
    v9 = j_va("arg %d expecting array.", (unsigned int)argIdx);
    Scr_Error(COM_ERR_3811, scrContext, v9);
  }
  Object = Scr_GetObject(scrContext, argIdx);
  ArraySize = GetArraySize(scrContext, Object);
  if ( ArraySize > maxNumVecs )
  {
    v12 = j_va("exceeded max number of points (%d)", (unsigned int)maxNumVecs);
    Scr_Error(COM_ERR_3812, scrContext, v12);
  }
  if ( !ArraySize )
    return 0i64;
  FirstSibling = FindFirstSibling(scrContext, Object);
  if ( FirstSibling )
  {
    v15 = &pVecArray->v[2];
    do
    {
      Scr_EvalVariable_Out(scrContext, FirstSibling, &out);
      type = out.type;
      if ( out.type != VAR_VECTOR )
      {
        v17 = j_va("element %d in array is not a valid vector.", v8);
        Scr_Error(COM_ERR_3813, scrContext, v17);
        type = out.type;
      }
      u = out.u;
      *(v15 - 2) = *out.u.vectorValue;
      *(v15 - 1) = *(float *)(u.scriptCodePosValue + 4);
      *v15 = *(float *)(u.scriptCodePosValue + 8);
      RemoveRefToValue(scrContext, (unsigned __int8)type, u);
      ++v8;
      v15 += 3;
      FirstSibling = FindNextSibling(scrContext, FirstSibling);
    }
    while ( FirstSibling );
  }
  return v8;
}

/*
==============
HasRoomToPlayPeekout
==============
*/
bool HasRoomToPlayPeekout(const pathnode_t *pNode, const scr_string_t *dir)
{
  unsigned __int16 totalLinkCount; 
  unsigned __int16 v14; 
  __int64 nodeNum; 
  bool v25; 
  bool result; 
  vec2_t forward; 
  char v54; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-18h], xmm6
    vmovaps xmmword ptr [rax-28h], xmm7
    vmovaps xmmword ptr [rax-38h], xmm8
    vmovaps xmmword ptr [rax-48h], xmm9
    vmovaps xmmword ptr [rax-58h], xmm10
    vmovaps xmmword ptr [rax-68h], xmm11
    vmovaps xmmword ptr [rax-78h], xmm12
    vmovaps [rsp+0C8h+var_88], xmm13
  }
  _RBX = pNode;
  pathnode_t::GetForward((pathnode_t *)pNode, &forward);
  totalLinkCount = _RBX->constant.totalLinkCount;
  v14 = 0;
  __asm
  {
    vxorps  xmm5, xmm5, xmm5
    vmovss  [rsp+0C8h+var_A0], xmm5
  }
  if ( totalLinkCount )
  {
    __asm
    {
      vmovss  xmm10, dword ptr [rbx+20h]
      vmovss  xmm11, dword ptr [rbx+24h]
      vmovss  xmm12, dword ptr [rbx+28h]
      vmovss  xmm8, dword ptr [rsp+0C8h+forward+4]
      vmovss  xmm9, dword ptr [rsp+0C8h+forward]
    }
    _R11 = pathData.nodes;
    __asm { vmovss  xmm13, cs:__real@460a1000 }
    while ( 1 )
    {
      nodeNum = _RBX->constant.Links[v14].nodeNum;
      v25 = __CFSHL__(3 * nodeNum, 6);
      _RCX = 192 * nodeNum;
      __asm
      {
        vmovss  xmm0, dword ptr [rcx+r11+20h]
        vmovss  xmm1, dword ptr [rcx+r11+24h]
        vsubss  xmm6, xmm0, xmm10
        vmovss  xmm0, dword ptr [rcx+r11+28h]
        vsubss  xmm7, xmm1, xmm11
        vmulss  xmm2, xmm7, xmm7
        vsubss  xmm4, xmm0, xmm12
        vmulss  xmm1, xmm6, xmm6
        vmulss  xmm0, xmm4, xmm4
        vaddss  xmm3, xmm2, xmm1
        vaddss  xmm2, xmm3, xmm0
        vcomiss xmm2, xmm13
      }
      if ( v25 )
      {
        __asm
        {
          vmulss  xmm1, xmm9, xmm7
          vmulss  xmm0, xmm8, xmm6
          vsubss  xmm2, xmm1, xmm0
          vcomiss xmm2, xmm5
        }
        if ( !__CFSHL__(3 * nodeNum, 6) && 192 * nodeNum != 0 )
        {
          v25 = *dir < (unsigned int)scr_const.left;
          if ( *dir == scr_const.left )
            break;
          __asm { vcomiss xmm2, xmm5 }
        }
        if ( v25 && *dir == scr_const.right )
          break;
      }
      if ( ++v14 >= totalLinkCount )
        goto LABEL_10;
    }
    result = 0;
  }
  else
  {
LABEL_10:
    result = 1;
  }
  _R11 = &v54;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
    vmovaps xmm13, xmmword ptr [r11-80h]
  }
  return result;
}

/*
==============
AIScriptedInterface::HasSuppressableEnemy
==============
*/
bool AIScriptedInterface::HasSuppressableEnemy(AIScriptedInterface *this)
{
  return AICommonInterface::GetTargetSentient(this) && this->m_pAI->sight.lastEnemySightPosValid && AIScriptedInterface::IsCurrentEnemyValid(this) && (this->m_pAI->bGoodShootPos || AIScriptedInterface::NeedRecalculateSuppressSpot(this));
}

/*
==============
AIScriptedInterface::NeedRecalculateSuppressSpot
==============
*/
char AIScriptedInterface::NeedRecalculateSuppressSpot(AIScriptedInterface *this)
{
  const vec3_t *p_vGoodShootPos; 
  vec3_t outEyePos; 
  vec3_t outOrigin; 

  _RCX = this->m_pAI;
  if ( _RCX->bGoodShootPos )
  {
    p_vGoodShootPos = &_RCX->vGoodShootPos;
    if ( !this->GetEquippedWeapon(this)->weaponIdx )
      return 0;
    AIScriptedInterface::GetApproxEyePos(this, &outEyePos, 0);
    if ( !AICommonInterface::SightTrace(this, &outEyePos, p_vGoodShootPos, 2047, NORMAL_FOLIAGE_CHECKS) )
      return 0;
    AIScriptedInterface::GetMuzzlePosApprox(this, &outOrigin);
    if ( !AICommonInterface::SightTrace(this, &outOrigin, p_vGoodShootPos, 2047, NORMAL_FOLIAGE_CHECKS) )
      return 0;
    _RCX = this->m_pAI;
  }
  if ( _RCX->sight.bLastEnemySightPosOld )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rcx+0B8h]
      vsubss  xmm3, xmm0, dword ptr [rcx+0FCh]
      vmovss  xmm1, dword ptr [rcx+0BCh]
      vsubss  xmm2, xmm1, dword ptr [rcx+100h]
      vmovss  xmm0, dword ptr [rcx+0C0h]
      vsubss  xmm4, xmm0, dword ptr [rcx+104h]
      vmulss  xmm2, xmm2, xmm2
      vmulss  xmm1, xmm3, xmm3
      vmulss  xmm0, xmm4, xmm4
      vaddss  xmm3, xmm2, xmm1
      vaddss  xmm2, xmm3, xmm0
      vcomiss xmm2, cs:__real@43800000
    }
    if ( !_RCX->sight.bLastEnemySightPosOld )
    {
      _RAX = (__int64)&_RCX->ent->r.currentOrigin;
      __asm
      {
        vmovss  xmm0, dword ptr [rax]
        vsubss  xmm3, xmm0, dword ptr [rcx+10Ch]
        vmovss  xmm1, dword ptr [rax+4]
        vsubss  xmm2, xmm1, dword ptr [rcx+110h]
        vmovss  xmm0, dword ptr [rax+8]
        vsubss  xmm4, xmm0, dword ptr [rcx+114h]
        vmulss  xmm2, xmm2, xmm2
        vmulss  xmm1, xmm3, xmm3
        vmulss  xmm0, xmm4, xmm4
        vaddss  xmm3, xmm2, xmm1
        vaddss  xmm2, xmm3, xmm0
        vcomiss xmm2, cs:__real@44800000
      }
      if ( _RCX->ent >= (gentity_s *)0xFFFFFFFFFFFFFED0i64 || _RAX == 0 )
        return 0;
    }
  }
  return 1;
}

/*
==============
AIScriptedInterface::OnScrCmd_AIClearGesture
==============
*/
void AIScriptedInterface::OnScrCmd_AIClearGesture(AIScriptedInterface *this, scrContext_t *scrContext)
{
  this->m_pAI->animData.gestureIndex = 0;
}

/*
==============
AIScriptedInterface::OnScrCmd_AIGetAnimTime
==============
*/
void AIScriptedInterface::OnScrCmd_AIGetAnimTime(AIScriptedInterface *this, scrContext_t *scrContext)
{
  gentity_s *v5; 
  XAnimTree *v6; 
  scr_string_t ConstString; 
  int Int; 
  scr_string_t AnimsetName; 
  unsigned int v10; 
  const XAnim_s *SubTreeAnims; 
  int pOutStateIndex; 
  AnimsetState *outState; 
  XAnimSubTreeID outSubTreeID; 
  unsigned int pOutAnimIndex; 
  unsigned int outGraftAnimIndex; 

  if ( !Com_GameMode_SupportsFeature(WEAPON_OFFHAND_INIT) )
    Scr_Error(COM_ERR_3912, scrContext, "AnimScripted entities are not supported in this game mode");
  v5 = this->GetEntity(this);
  v6 = this->GetAnimTree(this);
  if ( !v6 )
    Scr_Error(COM_ERR_6352, scrContext, "ent does not have a valid anim tree.");
  if ( Scr_GetType(scrContext, 0) == VAR_STRING )
  {
    ConstString = Scr_GetConstString(scrContext, 0);
    Int = Scr_GetInt(scrContext, 1u);
    AnimsetName = BG_AnimationState_GetAnimsetName(&v5->s);
    BG_Animset_GetStateInfoByName(AnimsetName, ConstString, &outState, &pOutStateIndex);
    BG_Animset_GetAnimIndexFromStateIndexAndEntry(AnimsetName, pOutStateIndex, Int, &pOutAnimIndex, &outGraftAnimIndex, &outSubTreeID, NULL);
  }
  else
  {
    pOutAnimIndex = Scr_GetAnim(scrContext, 0, v6).index;
    AIScriptedInterface::FixupExtraAnimParams(scrContext, 1u, &outGraftAnimIndex, &outSubTreeID, &pOutAnimIndex, NULL);
  }
  v10 = pOutAnimIndex;
  SubTreeAnims = XAnimGetSubTreeAnims(v6, outSubTreeID);
  if ( !XAnimHasTime(SubTreeAnims, v10) )
    Scr_ParamError(COM_ERR_3913, scrContext, 0, "blended nonsynchronized animation has no concept of time");
  *(double *)&_XMM0 = XAnimGetTime(v6, outGraftAnimIndex, outSubTreeID, pOutAnimIndex);
  __asm { vmovaps xmm1, xmm0; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
AIScriptedInterface::OnScrCmd_AIGetAnimWeight
==============
*/
void AIScriptedInterface::OnScrCmd_AIGetAnimWeight(AIScriptedInterface *this, scrContext_t *scrContext)
{
  XAnimTree *v5; 
  gentity_s *v6; 
  scr_string_t ConstString; 
  int Int; 
  scr_string_t AnimsetName; 
  scr_string_t v10; 
  int pOutStateIndex; 
  AnimsetState *outState; 
  XAnimSubTreeID outSubTreeID; 
  unsigned int pOutAnimIndex; 
  unsigned int pOutGraftNode; 

  if ( !Com_GameMode_SupportsFeature(WEAPON_OFFHAND_INIT) )
    Scr_Error(COM_ERR_3911, scrContext, "AnimScripted entities are not supported in this game mode");
  v5 = this->GetAnimTree(this);
  if ( !v5 )
    Scr_Error(COM_ERR_6351, scrContext, "ent does not have a valid anim tree.");
  if ( Scr_GetType(scrContext, 0) == VAR_STRING )
  {
    v6 = this->GetEntity(this);
    ConstString = Scr_GetConstString(scrContext, 0);
    Int = Scr_GetInt(scrContext, 1u);
    AnimsetName = BG_AnimationState_GetAnimsetName(&v6->s);
    outState = NULL;
    v10 = AnimsetName;
    BG_Animset_GetStateInfoByName(AnimsetName, ConstString, &outState, &pOutStateIndex);
    if ( !outState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 6988, ASSERT_TYPE_ASSERT, "(pState)", (const char *)&queryFormat, "pState") )
      __debugbreak();
    BG_Animset_GetAnimIndexFromStateIndexAndEntry(v10, pOutStateIndex, Int, &pOutAnimIndex, &pOutGraftNode, &outSubTreeID, NULL);
  }
  else
  {
    pOutAnimIndex = Scr_GetAnim(scrContext, 0, v5).index;
    AIScriptedInterface::FixupExtraAnimParams(scrContext, 1u, &pOutGraftNode, &outSubTreeID, &pOutAnimIndex, NULL);
  }
  *(double *)&_XMM0 = XAnimGetWeight(v5, pOutGraftNode, outSubTreeID, pOutAnimIndex);
  __asm { vmovaps xmm1, xmm0; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
AIScriptedInterface::OnScrCmd_AIPlayGesture
==============
*/
void AIScriptedInterface::OnScrCmd_AIPlayGesture(AIScriptedInterface *this, scrContext_t *scrContext)
{
  const XAnimTree *v4; 
  scr_string_t ConstString; 
  __int64 v6; 
  __int64 v7; 
  unsigned __int16 *v8; 
  unsigned __int16 *v9; 
  scr_string_t AnimsetNameByIndex; 
  signed int v11; 
  const XAnim_s *SubTreeAnims; 
  unsigned int ChildAt; 
  XAnimSubTreeID outSubtreeID; 
  scr_anim_t outAnim; 
  scr_anim_t value; 

  if ( Scr_GetNumParam(scrContext) != 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 7196, ASSERT_TYPE_ASSERT, "(Scr_GetNumParam( scrContext ) == 1)", (const char *)&queryFormat, "Scr_GetNumParam( scrContext ) == 1") )
    __debugbreak();
  v4 = this->GetAnimTree(this);
  if ( !v4 )
    Scr_Error(COM_ERR_6353, scrContext, "ent does not have a valid anim tree.");
  ConstString = Scr_GetConstString(scrContext, 0);
  v6 = tls_index;
  if ( !*(_QWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 272i64) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_static.h", 169, ASSERT_TYPE_ASSERT, "(ms_activeBgs)", (const char *)&queryFormat, "ms_activeBgs") )
    __debugbreak();
  v7 = *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + v6) + 272i64);
  v8 = (unsigned __int16 *)(*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v7 + 32i64))(v7, (unsigned int)this->m_pAI->ent->s.number);
  v9 = v8;
  if ( v8 )
  {
    AnimsetNameByIndex = BG_AnimationState_GetAnimsetNameByIndex(*v8);
    v11 = 0;
    if ( BG_Animset_GetAddonAnimFromBlendtree(AnimsetNameByIndex, v9[1], v9[2], ANIMSTATE_GESTURE, (const scr_string_t)scr_const.gesture_knob, (const scr_string_t)scr_const.gesture, &outAnim, NULL) && BG_Animset_GetAddonAnimFromBlendtree(AnimsetNameByIndex, v9[1], v9[2], ANIMSTATE_GESTURE, ConstString, (const scr_string_t)scr_const.gesture, &value, &outSubtreeID) )
    {
      SubTreeAnims = XAnimGetSubTreeAnims(v4, outSubtreeID);
      if ( XAnimGetNumChildren(SubTreeAnims, outAnim.index) > 0 )
      {
        while ( 1 )
        {
          ChildAt = XAnimGetChildAt(SubTreeAnims, outAnim.index, v11);
          if ( value.index == ChildAt )
            break;
          if ( ++v11 >= XAnimGetNumChildren(SubTreeAnims, outAnim.index) )
            return;
        }
        if ( v11 >= 128 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 7229, ASSERT_TYPE_ASSERT, "(childIndex < 2 << 6)", (const char *)&queryFormat, "childIndex < 2 << NUM_AI_GESTURE_BITS") )
          __debugbreak();
        this->m_pAI->animData.gestureIndex = v11 + 1;
        Scr_AddAnim(scrContext, value);
      }
    }
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_AISuppressAI
==============
*/
void AIScriptedInterface::OnScrCmd_AISuppressAI(AIScriptedInterface *this, scrContext_t *scrContext)
{
  bool v3; 

  v3 = AIScriptedInterface::AISuppressAI(this);
  Scr_AddBool(scrContext, v3);
}

/*
==============
AIScriptedInterface::OnScrCmd_AllowedStances
==============
*/
void AIScriptedInterface::OnScrCmd_AllowedStances(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int NumParam; 
  signed int v5; 
  scr_string_t ConstString; 
  const char *v7; 
  const char *v8; 
  ai_scripted_t *m_pAI; 

  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam < 1 )
    Scr_Error(COM_ERR_3892, scrContext, "no stances given in allowedStances()\n");
  v5 = 0;
  for ( this->m_pAI->eAllowedStances = STANCE_BAD; v5 < NumParam; ++v5 )
  {
    ConstString = Scr_GetConstString(scrContext, v5);
    if ( ConstString == scr_const.stand )
    {
      this->m_pAI->eAllowedStances |= 1u;
    }
    else if ( ConstString == scr_const.crouch )
    {
      this->m_pAI->eAllowedStances |= 2u;
    }
    else if ( ConstString == scr_const.prone )
    {
      this->m_pAI->eAllowedStances |= 4u;
    }
    else
    {
      v7 = SL_ConvertToString(ConstString);
      v8 = j_va("invalid stance '%s' in allowedStances()\n", v7);
      Scr_Error(COM_ERR_3893, scrContext, v8);
    }
  }
  m_pAI = this->m_pAI;
  if ( m_pAI->eAllowedStances == STANCE_BAD )
  {
    m_pAI->eAllowedStances = STANCE_ANY;
    Scr_Error(COM_ERR_3894, scrContext, "no allowed stances given");
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_AmbushCheckPath
==============
*/
void AIScriptedInterface::OnScrCmd_AmbushCheckPath(AIScriptedInterface *this, scrContext_t *scrContext)
{
  const pathnode_t *Pathnode; 
  bool v5; 

  Pathnode = Scr_GetPathnode(scrContext, 0);
  v5 = AIScriptedInterface::Ambush_CheckPathToNode(this, Pathnode);
  Scr_AddBool(scrContext, v5);
}

/*
==============
AIScriptedInterface::OnScrCmd_AmbushGetNextAmbushNode
==============
*/
void AIScriptedInterface::OnScrCmd_AmbushGetNextAmbushNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  const pathnode_t *AmbushNode; 

  AmbushNode = AIScriptedInterface::Ambush_GetAmbushNode(this);
  if ( AmbushNode )
    Scr_AddPathnode(AmbushNode);
}

/*
==============
AIScriptedInterface::OnScrCmd_AmbushIsCurrentNodeValid
==============
*/
void AIScriptedInterface::OnScrCmd_AmbushIsCurrentNodeValid(AIScriptedInterface *this, scrContext_t *scrContext)
{
  AIScriptedInterface::Ambush_IsCurrentNodeValid(this);
  Scr_AddBool(scrContext, this->m_pAI->combat.currentAmbushNodeValid);
}

/*
==============
AIScriptedInterface::OnScrCmd_AnimMode
==============
*/
void AIScriptedInterface::OnScrCmd_AnimMode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  __int64 ConstString; 
  const char *v5; 
  const char *v6; 

  ConstString = (unsigned int)Scr_GetConstString(scrContext, 0);
  if ( !this->SetAnimMode(this, (scr_string_t)ConstString) )
  {
    v5 = SL_ConvertToString((scr_string_t)ConstString);
    v6 = j_va("illegal call to animmode(%s)", v5);
    Scr_Error(COM_ERR_3882, scrContext, v6);
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_AtDangerousNode
==============
*/
void AIScriptedInterface::OnScrCmd_AtDangerousNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  sentient_s *v4; 
  unsigned __int64 eTeam; 
  const bitarray<224> *AllCombatTeamFlags; 
  const bitarray<224> *v7; 
  int IsReallyDangerousNode; 
  __int64 v9; 

  v4 = this->GetSentient(this);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 3877, ASSERT_TYPE_ASSERT, "(sentient)", (const char *)&queryFormat, "sentient") )
    __debugbreak();
  if ( !AIScriptedInterface::AtClaimNode(this) )
    goto LABEL_16;
  eTeam = (unsigned int)v4->eTeam;
  if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_WEAPON_DROP|0x80) )
    AllCombatTeamFlags = Com_TeamsSP_GetAllCombatTeamFlags();
  else
    AllCombatTeamFlags = Com_TeamsMP_GetAllTeamFlags();
  v7 = AllCombatTeamFlags;
  if ( (unsigned int)eTeam >= 0xE0 )
  {
    LODWORD(v9) = eTeam;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v9, 224) )
      __debugbreak();
  }
  if ( ((0x80000000 >> (eTeam & 0x1F)) & v7->array[eTeam >> 5]) != 0 )
  {
    if ( !v4->pClaimedNode && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 3881, ASSERT_TYPE_ASSERT, "(sentient->pClaimedNode)", (const char *)&queryFormat, "sentient->pClaimedNode") )
      __debugbreak();
    IsReallyDangerousNode = Path_ActorIsReallyDangerousNode(v4->pClaimedNode, v4->eTeam);
  }
  else
  {
LABEL_16:
    IsReallyDangerousNode = 0;
  }
  Scr_AddBool(scrContext, IsReallyDangerousNode);
}

/*
==============
AIScriptedInterface::OnScrCmd_BTGoalValid
==============
*/
void AIScriptedInterface::OnScrCmd_BTGoalValid(AIScriptedInterface *this, scrContext_t *scrContext)
{
  bool IsBTGoalValid; 

  IsBTGoalValid = AIScriptedInterface::IsBTGoalValid(this);
  Scr_AddBool(scrContext, IsBTGoalValid);
}

/*
==============
AIScriptedInterface::OnScrCmd_CalcSharpTurnAnim
==============
*/
void AIScriptedInterface::OnScrCmd_CalcSharpTurnAnim(AIScriptedInterface *this, scrContext_t *scrContext)
{
  gentity_s *v6; 
  ai_scripted_t *m_pAI; 
  scr_string_t AnimsetName; 
  scr_string_t stateName; 
  const char *String; 
  const char *suffix; 
  const char *prefix; 
  scrContext_t *v29; 
  bool v32; 
  int value; 
  unsigned int outAngleIndexCount; 
  int outAngleIndex[2]; 
  scr_anim_t outAnim; 
  vec3_t v38; 
  vec3_t v39; 
  vec3_t v40; 
  vec3_t vectorValue; 
  vec3_t vec; 
  vec3_t angles; 
  int outAngleIndices[4]; 

  __asm { vmovaps [rsp+150h+var_40], xmm6 }
  v6 = this->GetEntity(this);
  m_pAI = this->m_pAI;
  *(_QWORD *)outAngleIndex = v6;
  AnimsetName = BG_AnimationState_GetAnimsetName(&m_pAI->ent->s);
  stateName = Scr_GetConstString(scrContext, 0);
  Scr_GetVector(scrContext, 1u, &vectorValue);
  Scr_GetVector(scrContext, 2u, &v40);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
  __asm { vmovaps xmm6, xmm0 }
  String = Scr_GetString(scrContext, 4u);
  suffix = (char *)&queryFormat.fmt + 3;
  if ( Scr_GetType(scrContext, 5u) )
    prefix = Scr_GetString(scrContext, 5u);
  else
    prefix = (char *)&queryFormat.fmt + 3;
  if ( Scr_GetType(scrContext, 6u) )
    suffix = Scr_GetString(scrContext, 6u);
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+50h+var_A0]
    vsubss  xmm1, xmm0, dword ptr [rbp+50h+vectorValue]
    vmovss  xmm2, dword ptr [rbp+50h+var_A0+4]
    vsubss  xmm0, xmm2, dword ptr [rbp+50h+vectorValue+4]
    vmovss  dword ptr [rbp+50h+vec], xmm1
    vmovss  xmm1, dword ptr [rbp+50h+var_A0+8]
    vsubss  xmm2, xmm1, dword ptr [rbp+50h+vectorValue+8]
    vmovss  dword ptr [rbp+50h+vec+8], xmm2
    vmovss  dword ptr [rbp+50h+vec+4], xmm0
  }
  vectoangles(&vec, &angles);
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+50h+angles+4]
    vsubss  xmm1, xmm0, dword ptr [rax+140h]
    vmulss  xmm4, xmm1, cs:__real@3b360b61
    vaddss  xmm2, xmm4, cs:__real@3f000000
    vxorps  xmm1, xmm1, xmm1
    vroundss xmm3, xmm1, xmm2, 1
    vsubss  xmm0, xmm4, xmm3
    vmulss  xmm0, xmm0, cs:__real@43b40000; angle
    vmovaps xmm1, xmm6; threshold
  }
  outAngleIndexCount = 0;
  value = -1;
  G_GetAngleIndices(*(const float *)&_XMM0, *(const float *)&_XMM1, outAngleIndices, &outAngleIndexCount);
  if ( AIScriptedInterface::CalculateSharpTurnExitAnim(this, outAngleIndices, outAngleIndexCount, AnimsetName, stateName, prefix, suffix, &outAnim, outAngleIndex, &value) )
  {
    Scr_MakeArray(scrContext);
    v29 = scrContext;
  }
  else
  {
    __asm { vmovsd  xmm0, qword ptr [rbp+50h+var_A0] }
    v38.v[2] = v40.v[2];
    v39.v[2] = vectorValue.v[2];
    __asm
    {
      vmovsd  [rbp+50h+var_C0], xmm0
      vmovsd  xmm0, qword ptr [rbp+50h+vectorValue]
      vmovsd  [rbp+50h+var_B0], xmm0
    }
    v32 = AIScriptedInterface::CalculateSharpTurnAnim(this, outAngleIndexCount, outAngleIndices, AnimsetName, stateName, &v39, &v38, String, prefix, suffix, &outAnim, outAngleIndex, &value);
    Scr_MakeArray(scrContext);
    v29 = scrContext;
    if ( !v32 )
    {
      Scr_AddUndefined(scrContext);
      Scr_AddArray(scrContext);
      Scr_AddUndefined(scrContext);
      goto LABEL_11;
    }
  }
  Scr_AddInt(v29, value);
  Scr_AddArray(scrContext);
  Scr_AddInt(scrContext, outAngleIndex[0]);
LABEL_11:
  Scr_AddArray(scrContext);
  __asm { vmovaps xmm6, [rsp+150h+var_40] }
}

/*
==============
AIScriptedInterface::OnScrCmd_CalcStopData
==============
*/
void AIScriptedInterface::OnScrCmd_CalcStopData(AIScriptedInterface *this, scrContext_t *scrContext)
{
  const gentity_s *v7; 
  bool v8; 
  int Int; 
  bool v10; 
  vec3_t *p_currentAngles; 
  scr_string_t ConstString; 
  __int64 v25; 
  __int64 v26; 
  const char *footPrefix; 
  const char *optionalPrefix; 
  scr_string_t v34; 
  const char *speedString; 
  VariableType Type; 
  bool bApproachDirValid; 
  float v43; 
  float v44; 
  scr_string_t endNotetrack; 
  scr_string_t startNotetrack; 
  scr_string_t nodeType; 
  scr_string_t stateName; 
  __int64 v49; 
  vec3_t vectorValue; 
  vec3_t animTargetAngles; 
  vec3_t v52; 
  vec3_t angles; 
  vec3_t v54; 
  vec3_t vec; 
  vec3_t v56; 
  vec2_t v57; 
  vec3_t vFinalGoal; 
  vec3_t codeApproachDir; 
  int v61; 
  bfx::AreaHandle v62; 
  bfx::LinkHandle v63; 
  AIAnimStopData pStopData; 
  char v65; 
  void *retaddr; 

  _RAX = &retaddr;
  v49 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
  }
  v7 = this->GetEntity(this);
  Scr_GetVector(scrContext, 0, &vectorValue);
  v8 = Scr_GetType(scrContext, 2u) != VAR_UNDEFINED;
  Int = Scr_GetInt(scrContext, 4u);
  v10 = Int != 0;
  if ( Int )
    Scr_GetVector(scrContext, 1u, &v54);
  if ( v8 )
    Scr_GetVector(scrContext, 2u, &v56);
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+110h+vectorValue]
    vsubss  xmm1, xmm0, dword ptr [rsi+130h]
    vmovss  dword ptr [rbp+110h+vec], xmm1
    vmovss  xmm2, dword ptr [rbp+110h+vectorValue+4]
    vsubss  xmm0, xmm2, dword ptr [rsi+134h]
    vmovss  dword ptr [rbp+110h+vec+4], xmm0
    vmovss  xmm1, dword ptr [rbp+110h+vectorValue+8]
    vsubss  xmm2, xmm1, dword ptr [rsi+138h]
    vmovss  dword ptr [rbp+110h+vec+8], xmm2
  }
  if ( v8 )
  {
    __asm { vmovss  xmm6, dword ptr [rbp+110h+var_118+4] }
    p_currentAngles = &v56;
  }
  else if ( v10 )
  {
    __asm { vmovss  xmm6, dword ptr [rbp+110h+var_138+4] }
    p_currentAngles = &v54;
  }
  else
  {
    vectoangles(&vec, &angles);
    __asm { vmovss  xmm6, dword ptr [rbp+110h+angles+4] }
    p_currentAngles = &v7->r.currentAngles;
  }
  DebugArrivalPosition(v7, &vectorValue, p_currentAngles);
  __asm
  {
    vxorps  xmm7, xmm7, xmm7
    vmovss  dword ptr [rbp+110h+angles], xmm7
    vmovss  dword ptr [rbp+110h+angles+4], xmm6
    vmovss  dword ptr [rbp+110h+angles+8], xmm7
  }
  stateName = Scr_GetConstString(scrContext, 5u);
  if ( v10 )
  {
    __asm
    {
      vmovsd  xmm0, qword ptr [rbp+110h+vectorValue]
      vmovsd  qword ptr [rbp+110h+vFinalGoal], xmm0
    }
    vFinalGoal.v[2] = vectorValue.v[2];
    __asm
    {
      vmovsd  xmm0, qword ptr [rbp+110h+var_138]
      vmovsd  qword ptr [rbp+110h+var_158], xmm0
    }
    v52.v[2] = v54.v[2];
    __asm
    {
      vmovss  dword ptr [rbp+110h+animTargetAngles], xmm7
      vmovss  dword ptr [rbp+110h+animTargetAngles+8], xmm7
    }
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 6u);
    __asm { vmovss  dword ptr [rbp+110h+animTargetAngles+4], xmm0 }
  }
  else
  {
    AICommonInterface::GetPathFinalGoal(this, &vFinalGoal);
    vectoangles(&vec, &v52);
    __asm
    {
      vmovsd  xmm0, qword ptr [rbp+110h+var_158]
      vmovsd  qword ptr [rbp+110h+animTargetAngles], xmm0
    }
    animTargetAngles.v[2] = v52.v[2];
  }
  if ( v8 )
  {
    __asm
    {
      vmovsd  xmm0, qword ptr [rbp+110h+var_118]
      vmovsd  qword ptr [rbp+110h+var_158], xmm0
    }
    v52.v[2] = v56.v[2];
    __asm { vmovsd  qword ptr [rbp+110h+animTargetAngles], xmm0 }
    animTargetAngles.v[2] = v56.v[2];
  }
  ConstString = Scr_GetConstString(scrContext, 0xBu);
  nodeType = ConstString;
  if ( (ConstString == scr_const.exposed_cc || ConstString == scr_const.exposed_crouch_cc) && !v8 && !v10 )
  {
    *(double *)&_XMM0 = ((double (__fastcall *)(AINavigator *))this->m_pAI->pNavigator->GetPathDistToGoal)(this->m_pAI->pNavigator);
    __asm { vmovaps xmm6, xmm0 }
    bfx::AreaHandle::AreaHandle(&v62);
    bfx::LinkHandle::LinkHandle(&v63);
    __asm { vmulss  xmm1, xmm6, cs:__real@3ecccccd }
    LOBYTE(v25) = 1;
    ((void (__fastcall *)(AINavigator *, __int64, __int64, int *, _BYTE))this->m_pAI->pNavigator->GetPosAlongPath)(this->m_pAI->pNavigator, v26, v25, &v61, 0);
    __asm
    {
      vmovss  xmm0, dword ptr [rbp+110h+vectorValue]
      vsubss  xmm1, xmm0, [rbp+110h+var_D8]
      vmovss  dword ptr [rbp+110h+var_108], xmm1
      vmovss  xmm2, dword ptr [rbp+110h+vectorValue+4]
      vsubss  xmm0, xmm2, [rbp+110h+var_D4]
      vmovss  dword ptr [rbp+110h+var_108+4], xmm0
      vmovss  xmm1, dword ptr [rbp+110h+vectorValue+8]
      vsubss  xmm2, xmm1, [rbp+110h+var_D0]
      vmovss  [rbp+110h+var_100], xmm2
    }
    *(double *)&_XMM0 = vectoyaw(&v57);
    __asm
    {
      vmovss  dword ptr [rbp+110h+animTargetAngles], xmm7
      vmovss  dword ptr [rbp+110h+animTargetAngles+4], xmm0
      vmovss  dword ptr [rbp+110h+animTargetAngles+8], xmm7
      vmovss  dword ptr [rbp+110h+var_158], xmm7
      vmovss  dword ptr [rbp+110h+var_158+4], xmm0
      vmovss  dword ptr [rbp+110h+var_158+8], xmm7
    }
    bfx::LinkHandle::~LinkHandle(&v63);
    bfx::AreaHandle::~AreaHandle(&v62);
  }
  footPrefix = Scr_GetString(scrContext, 7u);
  optionalPrefix = Scr_GetString(scrContext, 8u);
  v34 = Scr_GetConstString(scrContext, 8u);
  speedString = NULL;
  if ( Scr_GetConstString(scrContext, 7u) == v34 )
    optionalPrefix = NULL;
  Type = Scr_GetType(scrContext, 3u);
  bApproachDirValid = Type != VAR_UNDEFINED;
  if ( Type )
    Scr_GetVector(scrContext, 3u, &codeApproachDir);
  __asm { vmovss  xmm6, cs:__real@bf800000 }
  if ( Scr_GetType(scrContext, 9u) )
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 9u);
    __asm { vmovaps xmm7, xmm0 }
  }
  else
  {
    __asm { vmovaps xmm7, xmm6 }
  }
  if ( Scr_GetType(scrContext, 0xAu) )
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0xAu);
    __asm { vmovaps xmm6, xmm0 }
  }
  startNotetrack = 0;
  endNotetrack = 0;
  if ( Scr_GetType(scrContext, 0xCu) )
    startNotetrack = Scr_GetConstString(scrContext, 0xCu);
  if ( Scr_GetType(scrContext, 0xDu) )
    endNotetrack = Scr_GetConstString(scrContext, 0xDu);
  if ( Scr_GetNumParam(scrContext) > 0xE && Scr_GetType(scrContext, 0xEu) )
    speedString = Scr_GetString(scrContext, 0xEu);
  __asm
  {
    vmovss  dword ptr [rsp+210h+var_1C0], xmm6
    vmovss  [rsp+210h+var_1C8], xmm7
  }
  if ( AIScriptedInterface::CalcStopData(this, &vectorValue, &angles, &animTargetAngles, &codeApproachDir, bApproachDirValid, &stateName, footPrefix, optionalPrefix, v43, v44, &nodeType, &startNotetrack, &endNotetrack, speedString, &pStopData) )
    PushStopDataToScript(scrContext, v7, &pStopData);
  _R11 = &v65;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_CanAimWhileMoving
==============
*/
void AIScriptedInterface::OnScrCmd_CanAimWhileMoving(AIScriptedInterface *this, scrContext_t *scrContext)
{
  bool CanAimWhileMoving; 

  CanAimWhileMoving = AIScriptedInterface::CanAimWhileMoving(this);
  Scr_AddBool(scrContext, CanAimWhileMoving);
}

/*
==============
AIScriptedInterface::OnScrCmd_CanBoundingOverwatchMove
==============
*/
void AIScriptedInterface::OnScrCmd_CanBoundingOverwatchMove(AIScriptedInterface *this, scrContext_t *scrContext)
{
  bool CanBoundingOverwatchMove; 

  CanBoundingOverwatchMove = AIScriptedInterface::CanBoundingOverwatchMove(this);
  Scr_AddBool(scrContext, CanBoundingOverwatchMove);
}

/*
==============
AIScriptedInterface::OnScrCmd_CanDoRetreat
==============
*/
void AIScriptedInterface::OnScrCmd_CanDoRetreat(AIScriptedInterface *this, scrContext_t *scrContext)
{
  this->m_pAI->1 = ($100FDAAC881F89A16E895B934846A44F)(this->m_pAI->postGoldPadding & 0xFD | (Scr_GetInt(scrContext, 0) != 0 ? 2 : 0));
}

/*
==============
AIScriptedInterface::OnScrCmd_CanSee
==============
*/
void AIScriptedInterface::OnScrCmd_CanSee(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int Int; 
  gentity_s *Entity; 
  bool v6; 

  Int = -1;
  Entity = GScr_GetEntity(0);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 3500, ASSERT_TYPE_ASSERT, "(pOther)", (const char *)&queryFormat, "pOther") )
    __debugbreak();
  if ( Scr_GetNumParam(scrContext) > 1 )
    Int = Scr_GetInt(scrContext, 1u);
  v6 = this->CanSee(this, Entity, Int);
  Scr_AddBool(scrContext, v6);
}

/*
==============
AIScriptedInterface::OnScrCmd_CanSeePeripheral
==============
*/
void AIScriptedInterface::OnScrCmd_CanSeePeripheral(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int Int; 
  gentity_s *Entity; 
  bool v6; 

  Int = -1;
  Entity = GScr_GetEntity(0);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 3528, ASSERT_TYPE_ASSERT, "(pOther)", (const char *)&queryFormat, "pOther") )
    __debugbreak();
  if ( !Entity->sentient )
    Scr_Error(COM_ERR_3883, scrContext, "Sorry, CanSeePeripheral only works with sentient targets.");
  if ( Scr_GetNumParam(scrContext) > 1 )
    Int = Scr_GetInt(scrContext, 1u);
  v6 = this->CanSeePeripheral(this, Entity, Int);
  Scr_AddBool(scrContext, v6);
}

/*
==============
AIScriptedInterface::OnScrCmd_CanShoot
==============
*/
void AIScriptedInterface::OnScrCmd_CanShoot(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int NumParam; 
  bool v7; 
  bool CanShoot; 
  vec3_t muzzleOffset; 
  vec3_t vectorValue; 

  NumParam = Scr_GetNumParam(scrContext);
  Scr_GetVector(scrContext, 0, &vectorValue);
  if ( NumParam > 1 && Scr_GetType(scrContext, 1u) )
  {
    Scr_GetVector(scrContext, 1u, &muzzleOffset);
  }
  else
  {
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vmovss  dword ptr [rsp+68h+muzzleOffset], xmm0
      vmovss  dword ptr [rsp+68h+muzzleOffset+4], xmm0
      vmovss  dword ptr [rsp+68h+muzzleOffset+8], xmm0
    }
  }
  v7 = 0;
  if ( NumParam > 2 && Scr_GetType(scrContext, 2u) )
    v7 = Scr_GetInt(scrContext, 2u) != 0;
  CanShoot = AIScriptedInterface::CanShoot(this, &vectorValue, &muzzleOffset, v7);
  Scr_AddInt(scrContext, CanShoot);
}

/*
==============
AIScriptedInterface::OnScrCmd_CanShootEnemy
==============
*/
void AIScriptedInterface::OnScrCmd_CanShootEnemy(AIScriptedInterface *this, scrContext_t *scrContext)
{
  sentient_s *v4; 
  gentity_s *v5; 
  const char *v6; 
  int NumParam; 
  int Int; 
  bool v9; 
  bool v10; 
  bool CanShootEnemy; 

  if ( !this->GetEntity(this) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 2753, ASSERT_TYPE_ASSERT, "(GetEntity())", (const char *)&queryFormat, "GetEntity()") )
    __debugbreak();
  if ( !this->GetSentient(this) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 2754, ASSERT_TYPE_ASSERT, "(GetSentient())", (const char *)&queryFormat, "GetSentient()") )
    __debugbreak();
  v4 = this->GetSentient(this);
  if ( !EntHandle::isDefined(&v4->targetEnt) )
  {
    v5 = this->GetEntity(this);
    v6 = j_va("CanShootEnemy() called with no enemy set for entity %d", (unsigned int)v5->s.number);
    Scr_Error(COM_ERR_3861, scrContext, v6);
  }
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam > 0 && Scr_GetType(scrContext, 0) )
    Int = Scr_GetInt(scrContext, 0);
  else
    Int = 250;
  v9 = 0;
  if ( NumParam > 1 && Scr_GetType(scrContext, 1u) )
    v9 = Scr_GetInt(scrContext, 1u) != 0;
  v10 = 0;
  if ( NumParam > 2 && Scr_GetType(scrContext, 2u) )
    v10 = Scr_GetInt(scrContext, 2u) != 0;
  CanShootEnemy = AIScriptedInterface::CanShootEnemy(this, Int, v9, v10);
  Scr_AddInt(scrContext, CanShootEnemy);
}

/*
==============
AIScriptedInterface::OnScrCmd_ChooseArrivalType
==============
*/
void AIScriptedInterface::OnScrCmd_ChooseArrivalType(AIScriptedInterface *this, scrContext_t *scrContext)
{
  const pathnode_t *Pathnode; 
  scr_string_t ConstString; 
  unsigned int Object; 
  scr_string_t cover_crouch_cc; 
  ai_stance_e v8; 
  scrContext_t *v9; 
  ai_stance_e v10; 
  ai_stance_e v11; 
  vec3_t origin; 

  Sys_ProfBeginNamedEvent(0xFF808080, "ScrCmd_ChooseArrivalType");
  Pathnode = NULL;
  if ( (unsigned __int8)*(_DWORD *)&Scr_GetEntityRef(scrContext, 0).entclass == 2 )
    Pathnode = Scr_GetPathnode(scrContext, 0);
  ConstString = Scr_GetConstString(scrContext, 1u);
  Object = Scr_GetObject(scrContext, 0);
  AddRefToObject(scrContext, Object);
  Scr_ClearOutParams(scrContext);
  Scr_GetObjectOrigin(scrContext, Object, &origin);
  RemoveRefToObject(scrContext, Object);
  cover_crouch_cc = scr_const.cover_crouch_cc;
  if ( ConstString == scr_const.cover_crouch_cc )
    goto LABEL_21;
  if ( ConstString == scr_const.conceal_crouch_cc )
    goto LABEL_21;
  if ( ConstString == scr_const.cover_crouch_window_cc )
    goto LABEL_21;
  cover_crouch_cc = scr_const.cover_stand_cc;
  if ( ConstString == scr_const.cover_stand_cc )
    goto LABEL_21;
  if ( ConstString == scr_const.conceal_stand_cc )
    goto LABEL_21;
  cover_crouch_cc = scr_const.cover_prone_cc;
  if ( ConstString == scr_const.cover_prone_cc || ConstString == scr_const.conceal_prone_cc )
    goto LABEL_21;
  if ( ConstString != scr_const.path_cc && ConstString != scr_const.exposed_cc )
  {
    if ( ConstString == scr_const.cover_right_cc )
    {
      v8 = ChooseArrivalPose_0(this, Pathnode, &origin);
      v9 = scrContext;
      if ( v8 == STANCE_CROUCH )
        cover_crouch_cc = scr_const.cover_right_crouch_cc;
      else
        cover_crouch_cc = scr_const.cover_right_cc;
      goto LABEL_22;
    }
    if ( ConstString == scr_const.cover_left_cc )
    {
      v10 = ChooseArrivalPose_0(this, Pathnode, &origin);
      v9 = scrContext;
      if ( v10 == STANCE_CROUCH )
        cover_crouch_cc = scr_const.cover_left_crouch_cc;
      else
        cover_crouch_cc = scr_const.cover_left_cc;
      goto LABEL_22;
    }
    cover_crouch_cc = ConstString;
LABEL_21:
    v9 = scrContext;
    goto LABEL_22;
  }
  v11 = ChooseArrivalPose_0(this, Pathnode, &origin);
  if ( v11 == STANCE_PRONE )
  {
    cover_crouch_cc = scr_const.cover_prone_cc;
    goto LABEL_21;
  }
  v9 = scrContext;
  if ( v11 == STANCE_CROUCH )
    cover_crouch_cc = scr_const.exposed_crouch_cc;
  else
    cover_crouch_cc = scr_const.exposed_cc;
LABEL_22:
  Scr_AddConstString(v9, cover_crouch_cc);
  Sys_ProfEndNamedEvent();
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearBTGoal
==============
*/
void AIScriptedInterface::OnScrCmd_ClearBTGoal(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int Int; 

  Int = Scr_GetInt(scrContext, 0);
  if ( Int >= 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 1215, ASSERT_TYPE_ASSERT, "(priority < AI_BT_GOAL_PRIORITY_COUNT)", (const char *)&queryFormat, "priority < AI_BT_GOAL_PRIORITY_COUNT") )
    __debugbreak();
  AIScriptedInterface::ClearBTGoal(this, (ai_bt_goal_priority_t)Int);
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearBlackboard
==============
*/
void AIScriptedInterface::OnScrCmd_ClearBlackboard(AIScriptedInterface *this, scrContext_t *scrContext)
{
  __int16 *v3; 

  v3 = (__int16 *)((__int64 (__fastcall *)(AIScriptedInterface *, scrContext_t *))this->GetEntity)(this, scrContext);
  Scr_ClearBlackboard(*v3);
  this->InitBlackboard(this);
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearDesiredSpeed
==============
*/
void AIScriptedInterface::OnScrCmd_ClearDesiredSpeed(AIScriptedInterface *this, scrContext_t *scrContext)
{
  this->m_pAI->script_desiredSpeedEnabled = 0;
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearDoorOpen
==============
*/
void AIScriptedInterface::OnScrCmd_ClearDoorOpen(AIScriptedInterface *this, scrContext_t *scrContext)
{
  this->m_pAI->animData.doorIndex = 0;
  this->m_pAI->animData.doorSpeedIndex = 0;
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearEnemy
==============
*/
void AIScriptedInterface::OnScrCmd_ClearEnemy(AIScriptedInterface *this, scrContext_t *scrContext)
{
  sentient_s *v3; 
  sentient_s *TargetSentient; 
  gentity_s *v5; 

  v3 = (sentient_s *)((__int64 (__fastcall *)(AIScriptedInterface *, scrContext_t *))this->GetSentient)(this, scrContext);
  if ( !v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 4077, ASSERT_TYPE_ASSERT, "(pSentient)", (const char *)&queryFormat, "pSentient") )
    __debugbreak();
  TargetSentient = AICommonInterface::GetTargetSentient(this);
  if ( TargetSentient )
  {
    if ( !this->m_pAI->sentientInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 4083, ASSERT_TYPE_ASSERT, "( m_pAI->sentientInfo )", (const char *)&queryFormat, "m_pAI->sentientInfo") )
      __debugbreak();
    this->m_pAI->sentientInfo[TargetSentient - level.sentients].lastKnownPosTime = 0;
  }
  if ( EntHandle::isDefined(&v3->scriptTargetEnt) )
  {
    v5 = EntHandle::ent(&v3->scriptTargetEnt);
    if ( AICommonInterface::GetTargetEntity(this) == v5 )
    {
      EntHandle::setEnt(&v3->scriptTargetEnt, NULL);
      v3->scriptTargetHasTagEye = 0;
    }
  }
  Sentient_SetEnemy(v3, NULL, 1, 0);
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearEntityTarget
==============
*/
void AIScriptedInterface::OnScrCmd_ClearEntityTarget(AIScriptedInterface *this, scrContext_t *scrContext)
{
  sentient_s *v3; 
  gentity_s *v4; 

  v3 = (sentient_s *)((__int64 (__fastcall *)(AIScriptedInterface *, scrContext_t *))this->GetSentient)(this, scrContext);
  if ( EntHandle::isDefined(&v3->scriptTargetEnt) )
  {
    v4 = EntHandle::ent(&v3->scriptTargetEnt);
    if ( AICommonInterface::GetTargetEntity(this) == v4 )
      Sentient_SetEnemy(v3, NULL, 1, 1);
  }
  EntHandle::setEnt(&v3->scriptTargetEnt, NULL);
  v3->scriptTargetHasTagEye = 0;
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearFixedNodeSafeVolume
==============
*/
void AIScriptedInterface::OnScrCmd_ClearFixedNodeSafeVolume(AIScriptedInterface *this, scrContext_t *scrContext)
{
  EntHandle::setEnt(&this->m_pAI->fixedNodeSafeVolume, NULL);
  this->m_pAI->fixedNodeSafeVolumeRadiusSq = 0.0;
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearGoalVolume
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ClearGoalVolume(AIScriptedInterface *this, scrContext_t *scrContext)
{
  AIScriptedInterface::ClearGoalVolume(this);
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearOverrideArchetype
==============
*/
void AIScriptedInterface::OnScrCmd_ClearOverrideArchetype(AIScriptedInterface *this, scrContext_t *scrContext)
{
  bool v4; 
  bool v5; 
  unsigned int v6; 
  unsigned int v7; 
  scr_string_t ConstString; 
  ArcOverridePriority v9; 

  v4 = 0;
  v5 = 0;
  v6 = Scr_GetNumParam(scrContext) - 1;
  if ( v6 )
  {
    v7 = v6 - 1;
    if ( v7 )
    {
      if ( v7 != 1 )
      {
        Scr_Error(COM_ERR_6529, scrContext, "Invalid parameter count to setoverridearchetype");
        return;
      }
      v5 = Scr_GetType(scrContext, 2u) && Scr_GetInt(scrContext, 2u);
    }
    v4 = Scr_GetType(scrContext, 1u) && Scr_GetInt(scrContext, 1u);
  }
  ConstString = Scr_GetConstString(scrContext, 0);
  v9 = AI_StringToArcOverridePriority(ConstString);
  if ( v9 == ARC_PRIORITY_COUNT )
    Scr_Error(COM_ERR_6530, scrContext, "invalid priority string");
  else
    AIScriptedInterface::ClearOverrideArchetype(this, v9, v4, v5);
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearPitchOrient
==============
*/
void AIScriptedInterface::OnScrCmd_ClearPitchOrient(AIScriptedInterface *this, scrContext_t *scrContext)
{
  this->m_pAI->ProneInfo.prone = 0;
  this->m_pAI->ProneInfo.orientPitch = 0;
}

/*
==============
AIScriptedInterface::OnScrCmd_ClearPotentialThreat
==============
*/
void AIScriptedInterface::OnScrCmd_ClearPotentialThreat(AIScriptedInterface *this, scrContext_t *scrContext)
{
  if ( !this->m_pAI || Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_3888, scrContext, "illegal call to ClearPotentialThreat()");
  if ( this->Is3D(this) )
    Scr_Error(COM_ERR_3889, scrContext, "3D actors cannot use ClearPotentialThreat()");
  AIScriptedInterface::ClearPotentialThreat(this);
}

/*
==============
AIScriptedInterface::OnScrCmd_CodeMoveRequested
==============
*/
void AIScriptedInterface::OnScrCmd_CodeMoveRequested(AIScriptedInterface *this, scrContext_t *scrContext)
{
  bool v3; 

  v3 = this->IsCodeMoveRequested(this);
  Scr_AddBool(scrContext, v3);
}

/*
==============
AIScriptedInterface::OnScrCmd_ConstrainToScriptGoalRadius
==============
*/
void AIScriptedInterface::OnScrCmd_ConstrainToScriptGoalRadius(AIScriptedInterface *this, scrContext_t *scrContext)
{
  vec3_t vectorValue; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  AIScriptedInterface::ConstrainToScriptGoalRadius(this, &vectorValue);
  Scr_AddVector(scrContext, vectorValue.v);
}

/*
==============
AIScriptedInterface::OnScrCmd_DropWeapon
==============
*/
void AIScriptedInterface::OnScrCmd_DropWeapon(AIScriptedInterface *this, scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  scr_string_t tag_weapon_left; 
  ai_scripted_t *m_pAI; 
  float *p_speedScaleMultiplier; 
  gentity_s *v17; 
  ai_scripted_t *v19; 
  char v21; 
  char v24; 
  unsigned __int16 weaponIdx; 
  __int64 v61; 
  __int64 v62; 
  int v63; 
  int v64; 
  int v65; 
  bool outIsAlternate; 
  Weapon outWeapon; 
  tmat43_t<vec3_t> matrix; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( outWeapon.weaponIdx )
  {
    __asm { vmovaps [rsp+108h+var_28], xmm6 }
    ConstString = Scr_GetConstString(scrContext, 1u);
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
    __asm { vmovaps xmm6, xmm0 }
    if ( ConstString == scr_const.left )
    {
      tag_weapon_left = scr_const.tag_weapon_left;
    }
    else if ( ConstString == scr_const.right )
    {
      tag_weapon_left = scr_const.tag_weapon_right;
    }
    else if ( ConstString == scr_const.chest )
    {
      tag_weapon_left = scr_const.tag_weapon_chest;
    }
    else if ( ConstString == scr_const.back )
    {
      tag_weapon_left = scr_const.tag_stowed_back;
    }
    else
    {
      if ( ConstString != scr_const.thigh )
      {
        tag_weapon_left = 0;
        goto LABEL_20;
      }
      tag_weapon_left = scr_const.tag_stowed_thigh;
    }
    if ( tag_weapon_left )
    {
      if ( !BGMovingPlatforms::IsMovingPlatform(this->m_pAI->Physics.groundEntNum) )
      {
        m_pAI = this->m_pAI;
        _RCX = (float *)m_pAI->weapDrops;
        p_speedScaleMultiplier = &m_pAI->speedScaleMultiplier;
        if ( _RCX != p_speedScaleMultiplier )
        {
          while ( *((_DWORD *)_RCX + 14) )
          {
            _RCX += 30;
            if ( _RCX == p_speedScaleMultiplier )
              goto LABEL_20;
          }
          __asm
          {
            vmovups ymm0, ymmword ptr [rsp+108h+outWeapon.weaponIdx]
            vmovups ymmword ptr [rcx+3Ch], ymm0
            vmovups xmm1, xmmword ptr [rsp+108h+outWeapon.attachmentVariationIndices+5]
            vmovups xmmword ptr [rcx+5Ch], xmm1
            vmovsd  xmm0, qword ptr [rsp+108h+outWeapon.attachmentVariationIndices+15h]
            vmovsd  qword ptr [rcx+6Ch], xmm0
          }
          _RCX[29] = *(float *)&outWeapon.weaponCamo;
          *((_DWORD *)_RCX + 13) = tag_weapon_left;
          *((_DWORD *)_RCX + 14) = 1;
          goto LABEL_44;
        }
      }
    }
LABEL_20:
    G_Items_GetStateFromTag(this->m_pAI->ent, tag_weapon_left, NULL, &matrix, 0);
    v17 = G_Items_DropWeapon(this->m_pAI->ent, &outWeapon, 1, 1, &matrix);
    _RBX = v17;
    if ( v17 )
    {
      v19 = this->m_pAI;
      __asm { vmovaps [rsp+108h+var_38], xmm7 }
      G_Items_SetStateFromTag(v19->ent, tag_weapon_left, v17, 0);
      __asm
      {
        vxorps  xmm7, xmm7, xmm7
        vucomiss xmm6, xmm7
      }
      if ( v21 )
      {
        *(_QWORD *)_RBX->s.lerp.pos.trDelta.v = 0i64;
        _RBX->s.lerp.pos.trDelta.v[2] = 0.0;
      }
      else
      {
        _RDI = DVARFLT_actorDropItemMaxVelocity;
        __asm { vmovaps [rsp+108h+var_48], xmm8 }
        if ( !DVARFLT_actorDropItemMaxVelocity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "actorDropItemMaxVelocity") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(_RDI);
        __asm
        {
          vcomiss xmm6, xmm7
          vmovss  xmm0, dword ptr [rdi+28h]
        }
        if ( v24 )
        {
          __asm
          {
            vxorps  xmm0, xmm0, cs:__xmm@80000000800000008000000080000000
            vmaxss  xmm8, xmm0, xmm6
          }
        }
        else
        {
          __asm { vminss  xmm8, xmm0, xmm6 }
        }
        __asm
        {
          vmovss  xmm0, dword ptr [rbx+130h]
          vmovss  xmm1, dword ptr [rbx+134h]
        }
        _RCX = this->m_pAI->ent;
        __asm
        {
          vsubss  xmm7, xmm1, dword ptr [rcx+134h]
          vsubss  xmm6, xmm0, dword ptr [rcx+130h]
          vmovss  xmm0, dword ptr [rcx+114h]
          vaddss  xmm2, xmm0, dword ptr [rcx+138h]
          vmovss  xmm1, dword ptr [rbx+138h]
          vsubss  xmm2, xmm1, xmm2
          vaddss  xmm5, xmm2, cs:__real@40000000
          vmulss  xmm0, xmm6, xmm6
          vmulss  xmm3, xmm7, xmm7
          vaddss  xmm2, xmm3, xmm0
          vmulss  xmm1, xmm5, xmm5
          vaddss  xmm2, xmm2, xmm1
          vmovss  xmm1, cs:__real@3f800000
          vsqrtss xmm3, xmm2, xmm2
          vcmpless xmm0, xmm3, cs:__real@80000000
          vblendvps xmm0, xmm3, xmm1, xmm0
          vdivss  xmm4, xmm1, xmm0
          vmulss  xmm0, xmm6, xmm4
          vmulss  xmm1, xmm0, xmm8
          vmulss  xmm2, xmm7, xmm4
          vmulss  xmm0, xmm2, xmm8
          vmovss  dword ptr [rbx+28h], xmm1
          vmulss  xmm1, xmm5, xmm4
          vmulss  xmm2, xmm1, xmm8
          vmovaps xmm8, [rsp+108h+var_48]
          vmovss  dword ptr [rbx+30h], xmm2
          vmovss  dword ptr [rbx+2Ch], xmm0
        }
      }
      __asm { vmovaps xmm7, [rsp+108h+var_38] }
      _RBX->s.lerp.pos.trTime = level.time;
      __asm
      {
        vmovss  xmm0, dword ptr [rbx+28h]
        vmovss  [rsp+108h+var_C8], xmm0
      }
      if ( (v63 & 0x7F800000) == 2139095040 )
        goto LABEL_47;
      __asm
      {
        vmovss  xmm0, dword ptr [rbx+2Ch]
        vmovss  [rsp+108h+var_C8], xmm0
      }
      if ( (v64 & 0x7F800000) == 2139095040 )
        goto LABEL_47;
      __asm
      {
        vmovss  xmm0, dword ptr [rbx+30h]
        vmovss  [rsp+108h+var_C8], xmm0
      }
      if ( (v65 & 0x7F800000) == 2139095040 )
      {
LABEL_47:
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 5370, ASSERT_TYPE_SANITY, "( !IS_NAN( ( weapEnt->s.lerp.pos.trDelta )[0] ) && !IS_NAN( ( weapEnt->s.lerp.pos.trDelta )[1] ) && !IS_NAN( ( weapEnt->s.lerp.pos.trDelta )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( weapEnt->s.lerp.pos.trDelta )[0] ) && !IS_NAN( ( weapEnt->s.lerp.pos.trDelta )[1] ) && !IS_NAN( ( weapEnt->s.lerp.pos.trDelta )[2] )") )
          __debugbreak();
      }
      weaponIdx = outWeapon.weaponIdx;
      if ( outWeapon.weaponIdx > bg_lastParsedWeaponIndex )
      {
        LODWORD(v62) = bg_lastParsedWeaponIndex;
        LODWORD(v61) = outWeapon.weaponIdx;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1203, ASSERT_TYPE_ASSERT, "( weaponIdx ) <= ( bg_lastParsedWeaponIndex )", "weaponIdx not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", v61, v62) )
          __debugbreak();
      }
      if ( !bg_weaponDefs[weaponIdx] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1204, ASSERT_TYPE_ASSERT, "(bg_weaponDefs[weaponIdx])", (const char *)&queryFormat, "bg_weaponDefs[weaponIdx]") )
        __debugbreak();
      if ( !GMovingPlatformEntityTracking::DropItem(&_RBX->movingPlatformTrack, this->m_pAI->Physics.groundEntNum) )
        G_Items_EnablePhysics(_RBX);
      GScr_AddEntity(_RBX);
      GScr_Notify(this->m_pAI->ent, scr_const.weapon_dropped, 1u);
    }
LABEL_44:
    __asm { vmovaps xmm6, [rsp+108h+var_28] }
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_DropWeaponNoVelocity
==============
*/
void AIScriptedInterface::OnScrCmd_DropWeaponNoVelocity(AIScriptedInterface *this, scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  scr_string_t tag_weapon_left; 
  gentity_s *v6; 
  int v11; 
  int v12; 
  int v13; 
  bool outIsAlternate; 
  Weapon outWeapon; 
  tmat43_t<vec3_t> matrix; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( outWeapon.weaponIdx )
  {
    ConstString = Scr_GetConstString(scrContext, 1u);
    if ( ConstString == scr_const.left )
    {
      tag_weapon_left = scr_const.tag_weapon_left;
    }
    else if ( ConstString == scr_const.right )
    {
      tag_weapon_left = scr_const.tag_weapon_right;
    }
    else if ( ConstString == scr_const.chest )
    {
      tag_weapon_left = scr_const.tag_weapon_chest;
    }
    else
    {
      tag_weapon_left = 0;
      if ( ConstString == scr_const.back )
        tag_weapon_left = scr_const.tag_stowed_back;
    }
    G_Items_GetStateFromTag(this->m_pAI->ent, tag_weapon_left, NULL, &matrix, 0);
    v6 = G_Items_DropWeapon(this->m_pAI->ent, &outWeapon, 1, 1, &matrix);
    _RBX = v6;
    if ( v6 )
    {
      G_Items_SetStateFromTag(this->m_pAI->ent, tag_weapon_left, v6, 0);
      *(_QWORD *)_RBX->s.lerp.pos.trDelta.v = 0i64;
      _RBX->s.lerp.pos.trDelta.v[2] = 0.0;
      _RBX->s.lerp.pos.trTime = level.time;
      __asm
      {
        vmovss  xmm0, dword ptr [rbx+28h]
        vmovss  [rsp+0B8h+var_88], xmm0
      }
      if ( (v11 & 0x7F800000) == 2139095040 )
        goto LABEL_21;
      __asm
      {
        vmovss  xmm0, dword ptr [rbx+2Ch]
        vmovss  [rsp+0B8h+var_88], xmm0
      }
      if ( (v12 & 0x7F800000) == 2139095040 )
        goto LABEL_21;
      __asm
      {
        vmovss  xmm0, dword ptr [rbx+30h]
        vmovss  [rsp+0B8h+var_88], xmm0
      }
      if ( (v13 & 0x7F800000) == 2139095040 )
      {
LABEL_21:
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 5440, ASSERT_TYPE_SANITY, "( !IS_NAN( ( weapEnt->s.lerp.pos.trDelta )[0] ) && !IS_NAN( ( weapEnt->s.lerp.pos.trDelta )[1] ) && !IS_NAN( ( weapEnt->s.lerp.pos.trDelta )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( weapEnt->s.lerp.pos.trDelta )[0] ) && !IS_NAN( ( weapEnt->s.lerp.pos.trDelta )[1] ) && !IS_NAN( ( weapEnt->s.lerp.pos.trDelta )[2] )") )
          __debugbreak();
      }
      BG_WeaponDef(&outWeapon, 0);
      if ( !GMovingPlatformEntityTracking::DropItem(&_RBX->movingPlatformTrack, this->m_pAI->Physics.groundEntNum) )
        G_Items_EnablePhysics(_RBX);
      GScr_AddEntity(_RBX);
      GScr_Notify(this->m_pAI->ent, scr_const.weapon_dropped, 1u);
    }
  }
}

/*
==============
AICommonInterface::OnScrCmd_EnableTeamwalking
==============
*/
void AICommonInterface::OnScrCmd_EnableTeamwalking(AICommonInterface *this, scrContext_t *scrContext)
{
  AINavigator *Navigator; 
  gentity_s *v5; 
  const char *v6; 
  bool v7; 

  Navigator = AICommonInterface::GetNavigator(this);
  if ( !Navigator )
  {
    v5 = this->GetEntity(this);
    v6 = j_va("EnableTeamwalking: Entity %d does not have a navigator.", (unsigned int)v5->s.number);
    Scr_Error(COM_ERR_3833, scrContext, v6);
  }
  v7 = 1;
  if ( Scr_GetNumParam(scrContext) && Scr_GetType(scrContext, 0) )
    v7 = Scr_GetInt(scrContext, 0) != 0;
  Navigator->EnableTeamWalking(Navigator, v7);
}

/*
==============
AICommonInterface::OnScrCmd_EnableTraversals
==============
*/
void AICommonInterface::OnScrCmd_EnableTraversals(AICommonInterface *this, scrContext_t *scrContext)
{
  bool v4; 
  ai_common_t *m_pAI; 
  const char *v6; 
  unsigned int v7; 
  unsigned int i; 
  scr_string_t ConstLowercaseString; 
  const char **v10; 
  char v11; 
  gentity_s *ent; 
  ai_common_t *v13; 
  AIWrapper v14; 

  v4 = 1;
  if ( Scr_GetNumParam(scrContext) && Scr_GetType(scrContext, 0) )
    v4 = Scr_GetInt(scrContext, 0) != 0;
  m_pAI = this->m_pAI;
  if ( !m_pAI->pNavigator )
  {
    v6 = j_va("EnableTraversals: AI %d does not have a valid navigator.", (unsigned int)m_pAI->ent->s.number);
    Scr_Error(COM_ERR_3862, scrContext, v6);
    m_pAI = this->m_pAI;
  }
  if ( v4 )
  {
    if ( SV_BotIsBotEnt(m_pAI->ent) )
    {
      this->m_pAI->pNavigator->SetLinkUsageFlags(this->m_pAI->pNavigator, 1792u);
    }
    else
    {
      v7 = 0;
      for ( i = 1; Scr_GetNumParam(scrContext) > i; ++i )
      {
        ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, i);
        v10 = g_AILinkUsageNames;
        v11 = 0;
        while ( SL_FindLowercaseString(*v10) != ConstLowercaseString )
        {
          ++v11;
          if ( (__int64)++v10 >= (__int64)&unk_147926BF0 )
            goto LABEL_16;
        }
        v7 |= 1 << v11;
LABEL_16:
        ;
      }
      ent = this->m_pAI->ent;
      AIActorInterface::AIActorInterface(&v14.m_actorInterface);
      AIAgentInterface::AIAgentInterface(&v14.m_newAgentInterface);
      v14.m_pAI = NULL;
      v14.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
      AIWrapper::Setup(&v14, ent);
      if ( v7 )
      {
        Nav_SetLinkUsageFlags(this->m_pAI->pNavigator, v7);
      }
      else if ( v14.m_pAI )
      {
        v13 = v14.m_pAI->GetAI(v14.m_pAI);
        Nav_SetLinkUsageFlagsForUnitType(this->m_pAI->pNavigator, LODWORD(v13[6].sight.fovDotPeriph));
      }
      else
      {
        Scr_Error(COM_ERR_3863, scrContext, "EnableTraversals: improper usageflag set.");
      }
    }
  }
  else
  {
    m_pAI->pNavigator->SetLinkUsageFlags(m_pAI->pNavigator, 0);
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_FindBestCoverList
==============
*/
void AIScriptedInterface::OnScrCmd_FindBestCoverList(AIScriptedInterface *this, scrContext_t *scrContext)
{
  sentient_s *v4; 
  bool searchCenteredOnAI; 
  __int64 v6; 
  __int64 BestCoverList; 
  float outBestScore[4]; 
  CoverNodeMetricParams metricParams; 
  pathnode_t *bestNodes[256]; 

  AIScriptedInterface::GetCoverNodeMetricParams(this, &metricParams);
  v4 = this->GetSentient(this);
  if ( v4 && v4->eTeam == TEAM_FIVE && Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_WEAPON_DROP|0x80) )
    Scr_Error(COM_ERR_3838, scrContext, "FindBestCoverList: Called on a dead actor!");
  searchCenteredOnAI = 0;
  if ( Scr_GetNumParam(scrContext) && Scr_GetType(scrContext, 0) )
    searchCenteredOnAI = Scr_GetInt(scrContext, 0) != 0;
  v6 = 0i64;
  BestCoverList = AIScriptedInterface::Cover_FindBestCoverList(this, bestNodes, 256, this->m_pAI->combat.combatMode, searchCenteredOnAI, (scr_string_t)0, &metricParams, outBestScore);
  Scr_MakeArray(scrContext);
  if ( BestCoverList > 0 )
  {
    do
    {
      Scr_AddPathnode(bestNodes[v6]);
      Scr_AddArray(scrContext);
      ++v6;
    }
    while ( v6 < BestCoverList );
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_FindBestCoverNode
==============
*/
void AIScriptedInterface::OnScrCmd_FindBestCoverNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  sentient_s *v4; 
  bool v5; 
  bool v6; 
  scr_string_t ConstString; 
  const pathnode_t *BestCover; 
  float outBestScore[4]; 
  CoverNodeMetricParams metricParams; 

  v4 = this->GetSentient(this);
  if ( v4 && v4->eTeam == TEAM_FIVE && Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_WEAPON_DROP|0x80) )
    Scr_Error(COM_ERR_3837, scrContext, "FindBestCoverNode: Called on a dead actor!");
  v5 = 0;
  v6 = 0;
  ConstString = 0;
  AIScriptedInterface::GetCoverNodeMetricParams(this, &metricParams);
  if ( Scr_GetNumParam(scrContext) && Scr_GetType(scrContext, 0) == VAR_STRING )
    ConstString = Scr_GetConstString(scrContext, 0);
  if ( Scr_GetNumParam(scrContext) > 1 && Scr_GetType(scrContext, 1u) == VAR_INTEGER )
    v5 = Scr_GetInt(scrContext, 1u) != 0;
  if ( Scr_GetNumParam(scrContext) > 2 && Scr_GetType(scrContext, 2u) == VAR_VECTOR )
  {
    Scr_GetVector(scrContext, 2u, &metricParams.lastKnownEnemyOrigin);
    metricParams.lastKnownValid = 1;
  }
  if ( Scr_GetNumParam(scrContext) > 3 && Scr_GetType(scrContext, 3u) == VAR_INTEGER )
    v6 = Scr_GetInt(scrContext, 3u) != 0;
  BestCover = AIScriptedInterface::Cover_FindBestCover(this, ConstString, v5, v6, &metricParams, outBestScore);
  if ( BestCover )
    Scr_AddPathnode(BestCover);
}

/*
==============
AIScriptedInterface::OnScrCmd_FindCoverNode
==============
*/
void AIScriptedInterface::OnScrCmd_FindCoverNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  AIScriptedInterface::Cover_FindCoverNode(this, this->m_pAI->combat.combatMode);
}

/*
==============
AICommonInterface::OnScrCmd_FindLastPointOnPathWithinVolume
==============
*/
void AICommonInterface::OnScrCmd_FindLastPointOnPathWithinVolume(AICommonInterface *this, scrContext_t *scrContext)
{
  AINavigator *Navigator; 
  gentity_s *v5; 
  const char *v6; 
  gentity_s *Entity; 
  vec3_t vectorValue; 
  vec3_t value; 

  Navigator = AICommonInterface::GetNavigator(this);
  if ( !Navigator )
  {
    v5 = this->GetEntity(this);
    v6 = j_va("FindLastPointOnPathWithinVolume: Entity %d must have a navigator.", (unsigned int)v5->s.number);
    Scr_Error(COM_ERR_3828, scrContext, v6);
  }
  Scr_GetVector(scrContext, 0, &vectorValue);
  Entity = GScr_GetEntity(1u);
  if ( Navigator->FindLastPointOnPathWithinRegion(Navigator, &vectorValue, Entity, &value) )
    Scr_AddVector(scrContext, value.v);
}

/*
==============
AIScriptedInterface::OnScrCmd_FindNearbyCoverNode
==============
*/
void AIScriptedInterface::OnScrCmd_FindNearbyCoverNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  gentity_s *v6; 
  const pathnode_t *v8; 

  __asm { vmovaps [rsp+48h+var_18], xmm6 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm { vmovaps xmm6, xmm0 }
  v6 = this->GetEntity(this);
  if ( !v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 2191, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  __asm { vmovaps xmm2, xmm6; searchRadius }
  v8 = AIScriptedInterface::Cover_FindNearByCoverNode(this, &v6->r.currentOrigin, *(float *)&_XMM2, this->m_pAI->combat.combatMode);
  if ( v8 )
    Scr_AddPathnode(v8);
  __asm { vmovaps xmm6, [rsp+48h+var_18] }
}

/*
==============
AIScriptedInterface::OnScrCmd_FindOverrideArchetype
==============
*/
void AIScriptedInterface::OnScrCmd_FindOverrideArchetype(AIScriptedInterface *this, scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  ArcOverridePriority v5; 
  scr_string_t OverrideArchetype; 

  ConstString = Scr_GetConstString(scrContext, 0);
  v5 = AI_StringToArcOverridePriority(ConstString);
  if ( v5 == ARC_PRIORITY_COUNT )
  {
    Scr_Error(COM_ERR_6531, scrContext, "invalid priority string");
  }
  else
  {
    OverrideArchetype = AIScriptedInterface::FindOverrideArchetype(this, v5);
    if ( OverrideArchetype )
      Scr_AddConstString(scrContext, OverrideArchetype);
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_FindReacquireDirectPath
==============
*/
void AIScriptedInterface::OnScrCmd_FindReacquireDirectPath(AIScriptedInterface *this, scrContext_t *scrContext)
{
  if ( Scr_GetNumParam(scrContext) )
    Scr_GetInt(scrContext, 0);
  AIScriptedInterface::Behave_FindReacquireDirectPath(this, 1);
}

/*
==============
AIScriptedInterface::OnScrCmd_FindShuffleCoverNode
==============
*/
void AIScriptedInterface::OnScrCmd_FindShuffleCoverNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  const pathnode_t *ShuffleCoverNode; 

  ShuffleCoverNode = AIScriptedInterface::Cover_FindShuffleCoverNode(this);
  if ( ShuffleCoverNode )
    Scr_AddPathnode(ShuffleCoverNode);
}

/*
==============
AIScriptedInterface::OnScrCmd_FinishCoverArrival
==============
*/
void AIScriptedInterface::OnScrCmd_FinishCoverArrival(AIScriptedInterface *this, scrContext_t *scrContext)
{
  this->m_pAI->arrivalInfo.arriving = 0;
  this->m_pAI->pushable = 1;
  this->m_pAI->bUseGoalWeight = 0;
}

/*
==============
AIScriptedInterface::OnScrCmd_FinishTraverse
==============
*/
void AIScriptedInterface::OnScrCmd_FinishTraverse(AIScriptedInterface *this, scrContext_t *scrContext)
{
  if ( AIScriptedInterface::IsTraversing(this) )
    Scr_SetString(&this->m_pAI->traverseName, (scr_string_t)0);
}

/*
==============
AIScriptedInterface::OnScrCmd_FinishZeroArrival
==============
*/
void AIScriptedInterface::OnScrCmd_FinishZeroArrival(AIScriptedInterface *this, scrContext_t *scrContext)
{
  this->m_pAI->arrivalInfo.arrivalTimeLeft = 0;
}

/*
==============
AIScriptedInterface::OnScrCmd_FlagEnemyUnattackable
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_FlagEnemyUnattackable(AIScriptedInterface *this, scrContext_t *scrContext)
{
  AIScriptedInterface::FlagEnemyUnattackable(this);
}

/*
==============
AIScriptedInterface::OnScrCmd_ForceThreatUpdate
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_ForceThreatUpdate(AIScriptedInterface *this, scrContext_t *scrContext)
{
  AIScriptedInterface::UpdateThreatImmediate(this);
}

/*
==============
AIScriptedInterface::OnScrCmd_ForceUpdateGoalPos
==============
*/
void AIScriptedInterface::OnScrCmd_ForceUpdateGoalPos(AIScriptedInterface *this, scrContext_t *scrContext)
{
  pathnode_t *node; 
  pathnode_t *v12; 
  bool v13; 
  char v14; 
  char v15; 
  ai_scripted_t *m_pAI; 
  bool fixedNodeNudged; 
  ai_scripted_t *v18; 

  _RAX = this->m_pAI;
  __asm
  {
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps [rsp+58h+var_28], xmm7
    vmovaps [rsp+58h+var_38], xmm8
    vmovss  xmm7, dword ptr [rax+258h]
    vmovss  xmm8, dword ptr [rax+25Ch]
    vmovss  xmm6, dword ptr [rax+260h]
  }
  node = _RAX->codeGoal.node;
  AIScriptedInterface::UpdateGoalPos(this);
  _RAX = this->m_pAI;
  v12 = _RAX->codeGoal.node;
  v13 = v12 == NULL;
  if ( v12 && (v13 = v12 == node) )
  {
    v14 = 0;
    v13 = 1;
  }
  else
  {
    v14 = 1;
  }
  __asm { vucomiss xmm7, dword ptr [rax+258h] }
  if ( v13 )
  {
    __asm { vucomiss xmm8, dword ptr [rax+25Ch] }
    if ( v13 )
    {
      __asm { vucomiss xmm6, dword ptr [rax+260h] }
      if ( v13 )
        goto LABEL_10;
    }
  }
  if ( !v14 )
LABEL_10:
    v15 = 0;
  else
    v15 = 1;
  _RAX->goalPosChanged = v15;
  m_pAI = this->m_pAI;
  if ( m_pAI->goalPosChanged )
  {
    fixedNodeNudged = m_pAI->fixedNodeNudged;
    m_pAI->nodeSelect.nextFindBestCoverTime = 0;
    AIScriptedInterface::GoalChanged(this);
    v18 = this->m_pAI;
    if ( v18->fixedNode )
    {
      v18->fixedNodeNudged = fixedNodeNudged;
      this->m_pAI->commitToFixedNode = 0;
    }
  }
  __asm
  {
    vmovaps xmm6, [rsp+58h+var_18]
    vmovaps xmm7, [rsp+58h+var_28]
    vmovaps xmm8, [rsp+58h+var_38]
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_GetAdjustedExitDirection
==============
*/
void AIScriptedInterface::OnScrCmd_GetAdjustedExitDirection(AIScriptedInterface *this, scrContext_t *scrContext)
{
  unsigned int NumParam; 
  int avoidance_active; 
  unsigned int v15; 
  bool AvoidanceDelta; 
  vec3_t velocity; 
  vec3_t vectorValue; 

  __asm { vmovaps [rsp+88h+var_28], xmm6 }
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam - 1 > 2 )
    Scr_Error(COM_ERR_6049, scrContext, "GetAdjustedExitDirection takes between 1 and 4 args.");
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm { vmovaps xmm6, xmm0 }
  *(double *)&_XMM0 = AIScriptedInterface::GetTargetSpeed(this);
  _RAX = this->m_pAI;
  avoidance_active = 2;
  __asm { vmovss  dword ptr [rax+0B54h], xmm0 }
  _RAX = this->m_pAI;
  __asm
  {
    vmovss  xmm3, dword ptr [rax+838h]
    vmovss  dword ptr [rsp+88h+velocity], xmm3
    vmovss  xmm2, dword ptr [rax+83Ch]
    vmovss  dword ptr [rsp+88h+velocity+4], xmm2
    vmovss  xmm1, dword ptr [rax+840h]
    vunpcklps xmm0, xmm3, xmm2
    vmovss  dword ptr [rsp+88h+velocity+8], xmm1
  }
  vectorValue.v[2] = velocity.v[2];
  __asm
  {
    vmovsd  qword ptr [rsp+88h+velocity], xmm0
    vmovsd  qword ptr [rsp+88h+vectorValue], xmm0
  }
  v15 = NumParam - 2;
  if ( v15 )
  {
    if ( v15 != 1 )
      goto LABEL_7;
    Scr_GetVector(scrContext, 2u, &vectorValue);
  }
  Scr_GetVector(scrContext, 1u, &velocity);
LABEL_7:
  __asm { vmovaps xmm1, xmm6; fMoveDist }
  AvoidanceDelta = AIScriptedInterface::GetAvoidanceDelta(this, *(const float *)&_XMM1, 0, &velocity, &vectorValue);
  Scr_MakeArray(scrContext);
  if ( !AvoidanceDelta )
    avoidance_active = this->m_pAI->avoidance_active;
  Scr_AddInt(scrContext, avoidance_active);
  Scr_AddArray(scrContext);
  Scr_AddVector(scrContext, vectorValue.v);
  Scr_AddArray(scrContext);
  __asm { vmovaps xmm6, [rsp+88h+var_28] }
}

/*
==============
AIScriptedInterface::OnScrCmd_GetAimAngle
==============
*/
void AIScriptedInterface::OnScrCmd_GetAimAngle(AIScriptedInterface *this, scrContext_t *scrContext)
{
  Scr_AddVector(scrContext, this->m_pAI->aimAngles.v);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetAnglesToLikelyEnemyPath
==============
*/
void AIScriptedInterface::OnScrCmd_GetAnglesToLikelyEnemyPath(AIScriptedInterface *this, scrContext_t *scrContext)
{
  if ( AIScriptedInterface::GetAnglesToLikelyEnemyPath(this) )
    Scr_AddVector(scrContext, this->m_pAI->sight.anglesToLikelyEnemyPath.v);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetApproxEyePos
==============
*/
void AIScriptedInterface::OnScrCmd_GetApproxEyePos(AIScriptedInterface *this, scrContext_t *scrContext)
{
  vec3_t outEyePos; 

  AIScriptedInterface::GetApproxEyePos(this, &outEyePos, 0);
  Scr_AddVector(scrContext, outEyePos.v);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetBaseArchetype
==============
*/
void AIScriptedInterface::OnScrCmd_GetBaseArchetype(AIScriptedInterface *this, scrContext_t *scrContext)
{
  scr_string_t BaseOverrideArchetype; 

  BaseOverrideArchetype = AIScriptedInterface::GetBaseOverrideArchetype(this);
  if ( BaseOverrideArchetype )
    Scr_AddConstString(scrContext, BaseOverrideArchetype);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetBlackboard
==============
*/
void AIScriptedInterface::OnScrCmd_GetBlackboard(AIScriptedInterface *this, scrContext_t *scrContext)
{
  __int16 *v2; 

  v2 = (__int16 *)((__int64 (__fastcall *)(AIScriptedInterface *, scrContext_t *))this->GetEntity)(this, scrContext);
  Scr_AddBlackboard(*v2);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetCoverNode
==============
*/
void AIScriptedInterface::OnScrCmd_GetCoverNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  const pathnode_t *CoverNode; 

  CoverNode = AIScriptedInterface::Cover_GetCoverNode(this);
  if ( CoverNode )
    Scr_AddPathnode(CoverNode);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetCoverTacPoint
==============
*/
void AIScriptedInterface::OnScrCmd_GetCoverTacPoint(AIScriptedInterface *this, scrContext_t *scrContext)
{
  vec3_t outPos; 

  _RBX = AIScriptedInterface::GetCoverTacPoint(this);
  if ( _RBX )
  {
    if ( Scr_GetNumParam(scrContext) && Scr_GetInt(scrContext, 0) )
    {
      TacGraph_GetApproxGroundPosForPoint(_RBX, &outPos);
    }
    else
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rbx]
        vmovss  dword ptr [rsp+48h+outPos], xmm0
        vmovss  xmm1, dword ptr [rbx+4]
        vmovss  dword ptr [rsp+48h+outPos+4], xmm1
        vmovss  xmm0, dword ptr [rbx+8]
        vmovss  dword ptr [rsp+48h+outPos+8], xmm0
      }
    }
    Scr_AddVector(scrContext, outPos.v);
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_GetDesiredScaledSpeedForPosAlongPath
==============
*/
void AIScriptedInterface::OnScrCmd_GetDesiredScaledSpeedForPosAlongPath(AIScriptedInterface *this, scrContext_t *scrContext)
{
  bool outUsingCachedValue; 
  float outTargetSpeed; 
  vec3_t outNextCorner; 

  if ( Scr_GetNumParam(scrContext) )
  {
    if ( AICommonInterface::HasPath(this) )
    {
      __asm { vmovaps [rsp+68h+var_18], xmm6 }
      *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
      __asm { vmovaps xmm6, xmm0 }
      *(double *)&_XMM0 = AIScriptedInterface::GetTargetSpeed(this);
      __asm
      {
        vmovaps xmm1, xmm6; distanceAlongPath
        vmovss  [rsp+68h+outTargetSpeed], xmm0
      }
      AIScriptedInterface::ProcessSharpTurnSpeedScale(this, *(float *)&_XMM1, &outNextCorner, &outTargetSpeed, &outUsingCachedValue);
      __asm { vmovss  xmm1, [rsp+68h+outTargetSpeed]; value }
      Scr_AddFloat(scrContext, *(float *)&_XMM1);
      __asm { vmovaps xmm6, [rsp+68h+var_18] }
    }
    else
    {
      Scr_Error(COM_ERR_3873, scrContext, "GetDesiredScaledSpeedForPosAlongPath: AI doesn't have path yet");
    }
  }
  else
  {
    Scr_Error(COM_ERR_3872, scrContext, "GetDesiredScaledSpeedForPosAlongPath: Invalid argument count");
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_GetDesiredSpeed
==============
*/
void AIScriptedInterface::OnScrCmd_GetDesiredSpeed(AIScriptedInterface *this, scrContext_t *scrContext)
{
  *(double *)&_XMM0 = AIScriptedInterface::GetDefaultSpeed(this);
  __asm { vmovaps xmm1, xmm0; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetFixedNodeSafeVolume
==============
*/
void AIScriptedInterface::OnScrCmd_GetFixedNodeSafeVolume(AIScriptedInterface *this, scrContext_t *scrContext)
{
  const gentity_s *v3; 

  if ( EntHandle::isDefined(&this->m_pAI->fixedNodeSafeVolume) )
  {
    v3 = EntHandle::ent(&this->m_pAI->fixedNodeSafeVolume);
    GScr_AddEntity(v3);
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_GetGoalVolume
==============
*/
void AIScriptedInterface::OnScrCmd_GetGoalVolume(AIScriptedInterface *this, scrContext_t *scrContext)
{
  const gentity_s *v3; 

  if ( EntHandle::isDefined(&this->m_pAI->scriptGoal.hVolume) )
  {
    v3 = EntHandle::ent(&this->m_pAI->scriptGoal.hVolume);
    GScr_AddEntity(v3);
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_GetGroundEntType
==============
*/
void AIScriptedInterface::OnScrCmd_GetGroundEntType(AIScriptedInterface *this, scrContext_t *scrContext)
{
  unsigned __int16 GroundEntNum; 
  scr_string_t world; 

  GroundEntNum = AIScriptedInterface::GetGroundEntNum(this);
  if ( GroundEntNum == 2047 )
  {
    Scr_AddConstString(scrContext, scr_const.none);
  }
  else
  {
    world = scr_const.world;
    if ( (level.gentities[GroundEntNum].flags.m_flags[0] & 0x100) != 0 )
      world = scr_const.obstacle;
    Scr_AddConstString(scrContext, world);
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_GetGroundSlope
==============
*/
void AIScriptedInterface::OnScrCmd_GetGroundSlope(AIScriptedInterface *this, scrContext_t *scrContext)
{
  _RAX = this->m_pAI;
  __asm { vmovss  xmm1, dword ptr [rax+850h]; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
AICommonInterface::OnScrCmd_GetLastPathPointWithinGoal
==============
*/
void AICommonInterface::OnScrCmd_GetLastPathPointWithinGoal(AICommonInterface *this, scrContext_t *scrContext)
{
  AINavigator *Navigator; 
  gentity_s *v5; 
  const char *v6; 
  float value[4]; 

  Navigator = AICommonInterface::GetNavigator(this);
  if ( !Navigator )
  {
    v5 = this->GetEntity(this);
    v6 = j_va("GetLastPathPointWithinGoal: Entity %d must have a navigator.", (unsigned int)v5->s.number);
    Scr_Error(COM_ERR_3829, scrContext, v6);
  }
  _RAX = this->GetScriptGoal(this);
  if ( _RAX )
  {
    __asm { vmovss  xmm2, dword ptr [rax+0Ch] }
    if ( ((unsigned __int8 (__fastcall *)(AINavigator *, ai_goal_t *, bool (__fastcall *)(AINavigator *, const vec3_t *, float, vec3_t *), float *))Navigator->GetLastPathPointWithinRadius)(Navigator, _RAX, Navigator->GetLastPathPointWithinRadius, value) )
      Scr_AddVector(scrContext, value);
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_GetMotionAngle3D
==============
*/
void AIScriptedInterface::OnScrCmd_GetMotionAngle3D(AIScriptedInterface *this, scrContext_t *scrContext)
{
  float value[4]; 

  this->GetMotionAngles(this, (vec3_t *)value);
  Scr_AddVector(scrContext, value);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetMotionAngle
==============
*/
void AIScriptedInterface::OnScrCmd_GetMotionAngle(AIScriptedInterface *this, scrContext_t *scrContext)
{
  char v4[4]; 

  this->GetMotionAngles(this, (vec3_t *)v4);
  __asm { vmovss  xmm1, [rsp+48h+var_24]; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
AICommonInterface::OnScrCmd_GetNearbyNegotiationInfo
==============
*/
void AICommonInterface::OnScrCmd_GetNearbyNegotiationInfo(AICommonInterface *this, scrContext_t *scrContext)
{
  const pathnode_t *StartNodeFromLink; 
  const pathnode_t *EndNodeFromLink; 
  vec3_t outEndPos; 
  nav_posAlongPathResults_t pResults; 
  char v15; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm { vmovaps xmmword ptr [rax-18h], xmm6 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm { vmovaps xmm6, xmm0 }
  bfx::AreaHandle::AreaHandle(&pResults.m_hArea);
  bfx::LinkHandle::LinkHandle(&pResults.m_hLink);
  __asm { vmovaps xmm1, xmm6; dist }
  if ( Nav_GetPosAlongPath(this->m_pAI->pNavigator, *(float *)&_XMM1, 1, &pResults) && pResults.m_PosType == POS_ON_LINK )
  {
    StartNodeFromLink = Nav_GetStartNodeFromLink(&pResults.m_hLink);
    if ( StartNodeFromLink )
    {
      Nav_GetEndPosFromLink(&pResults.m_hLink, &outEndPos);
      EndNodeFromLink = Nav_GetEndNodeFromLink(&pResults.m_hLink);
      Scr_MakeArray(scrContext);
      Scr_AddPathnode(StartNodeFromLink);
      Scr_AddArrayStringIndexed(scrContext, scr_const.node);
      Scr_AddVector(scrContext, outEndPos.v);
      Scr_AddArrayStringIndexed(scrContext, scr_const.position);
      if ( EndNodeFromLink )
      {
        Scr_AddPathnode(EndNodeFromLink);
        Scr_AddArrayStringIndexed(scrContext, scr_const.finish);
      }
    }
  }
  bfx::LinkHandle::~LinkHandle(&pResults.m_hLink);
  bfx::AreaHandle::~AreaHandle(&pResults.m_hArea);
  _R11 = &v15;
  __asm { vmovaps xmm6, xmmword ptr [r11-10h] }
}

/*
==============
AICommonInterface::OnScrCmd_GetNegotiationEndNode
==============
*/
void AICommonInterface::OnScrCmd_GetNegotiationEndNode(AICommonInterface *this, scrContext_t *scrContext)
{
  const pathnode_t *EndNodeFromLink; 

  if ( bfx::LinkHandle::IsValid(&this->m_pAI->pNavigator->m_hLink) )
  {
    EndNodeFromLink = Nav_GetEndNodeFromLink(&this->m_pAI->pNavigator->m_hLink);
    if ( EndNodeFromLink )
      Scr_AddPathnode(EndNodeFromLink);
  }
}

/*
==============
AICommonInterface::OnScrCmd_GetNegotiationEndPos
==============
*/
void AICommonInterface::OnScrCmd_GetNegotiationEndPos(AICommonInterface *this, scrContext_t *scrContext)
{
  vec3_t outEndPos; 

  if ( !this->m_pAI->pNavigator && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 1838, ASSERT_TYPE_ASSERT, "( m_pAI->pNavigator )", (const char *)&queryFormat, "m_pAI->pNavigator") )
    __debugbreak();
  if ( bfx::LinkHandle::IsValid(&this->m_pAI->pNavigator->m_hLink) )
  {
    Nav_GetEndPosFromLink(&this->m_pAI->pNavigator->m_hLink, &outEndPos);
    Scr_AddVector(scrContext, outEndPos.v);
  }
}

/*
==============
AICommonInterface::OnScrCmd_GetNegotiationStartNode
==============
*/
void AICommonInterface::OnScrCmd_GetNegotiationStartNode(AICommonInterface *this, scrContext_t *scrContext)
{
  const pathnode_t *StartNodeFromLink; 

  if ( bfx::LinkHandle::IsValid(&this->m_pAI->pNavigator->m_hLink) )
  {
    StartNodeFromLink = Nav_GetStartNodeFromLink(&this->m_pAI->pNavigator->m_hLink);
    if ( StartNodeFromLink )
      Scr_AddPathnode(StartNodeFromLink);
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_GetNodeHideYaw
==============
*/
void AIScriptedInterface::OnScrCmd_GetNodeHideYaw(AIScriptedInterface *this, scrContext_t *scrContext)
{
  scr_string_t HighestNodeStance; 
  const pathnode_t *Pathnode; 
  scr_string_t ConstString; 
  int NumParam; 
  scr_string_t v9; 
  scr_string_t v10; 
  scr_string_t AnimsetName; 

  HighestNodeStance = 0;
  Pathnode = NULL;
  if ( (unsigned __int8)*(_DWORD *)&Scr_GetEntityRef(scrContext, 0).entclass == 2 )
    Pathnode = Scr_GetPathnode(scrContext, 0);
  ConstString = Scr_GetConstString(scrContext, 1u);
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam > 2 && Scr_GetType(scrContext, 2u) )
    HighestNodeStance = Scr_GetConstString(scrContext, 2u);
  if ( NumParam <= 3 || Scr_GetType(scrContext, 3u) == VAR_UNDEFINED || Scr_GetInt(scrContext, 3u) )
  {
    v9 = AI_StanceToString(this->m_pAI->eCurrentStance);
    v10 = v9;
    if ( !HighestNodeStance )
    {
      if ( !Pathnode || Path_DoesNodeAllowStance(Pathnode, v9) )
        HighestNodeStance = v10;
      else
        HighestNodeStance = Path_GetHighestNodeStance(Pathnode);
    }
    if ( ConstString == scr_const.cover_left_cc && HighestNodeStance == scr_const.crouch )
    {
      ConstString = scr_const.cover_left_crouch_cc;
    }
    else if ( ConstString == scr_const.cover_right_cc && HighestNodeStance == scr_const.crouch )
    {
      ConstString = scr_const.cover_right_crouch_cc;
    }
  }
  AnimsetName = BG_AnimationState_GetAnimsetName((const entityState_t *)this->m_pAI->ent);
  *(double *)&_XMM0 = BG_Animset_GetNodeHideYawOffset(AnimsetName, ConstString);
  __asm { vmovaps xmm1, xmm0; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetNodeHideYawOffset
==============
*/
void AIScriptedInterface::OnScrCmd_GetNodeHideYawOffset(AIScriptedInterface *this, scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  scr_string_t AnimsetName; 

  ConstString = Scr_GetConstString(scrContext, 0);
  AnimsetName = BG_AnimationState_GetAnimsetName((const entityState_t *)this->m_pAI->ent);
  *(double *)&_XMM0 = BG_Animset_GetNodeHideYawOffset(AnimsetName, ConstString);
  __asm { vmovaps xmm1, xmm0; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetNodeLeanAimPitch
==============
*/
void AIScriptedInterface::OnScrCmd_GetNodeLeanAimPitch(AIScriptedInterface *this, scrContext_t *scrContext)
{
  scr_string_t HighestNodeStance; 
  const pathnode_t *Pathnode; 
  scr_string_t ConstString; 
  int NumParam; 
  scr_string_t v9; 
  scr_string_t v10; 
  scr_string_t AnimsetName; 

  HighestNodeStance = 0;
  Pathnode = NULL;
  if ( (unsigned __int8)*(_DWORD *)&Scr_GetEntityRef(scrContext, 0).entclass == 2 )
    Pathnode = Scr_GetPathnode(scrContext, 0);
  ConstString = Scr_GetConstString(scrContext, 1u);
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam > 2 && Scr_GetType(scrContext, 2u) )
    HighestNodeStance = Scr_GetConstString(scrContext, 2u);
  if ( NumParam <= 3 || Scr_GetType(scrContext, 3u) == VAR_UNDEFINED || Scr_GetInt(scrContext, 3u) )
  {
    v9 = AI_StanceToString(this->m_pAI->eCurrentStance);
    v10 = v9;
    if ( !HighestNodeStance )
    {
      if ( !Pathnode || Path_DoesNodeAllowStance(Pathnode, v9) )
        HighestNodeStance = v10;
      else
        HighestNodeStance = Path_GetHighestNodeStance(Pathnode);
    }
    if ( ConstString == scr_const.cover_left_cc && HighestNodeStance == scr_const.crouch )
    {
      ConstString = scr_const.cover_left_crouch_cc;
    }
    else if ( ConstString == scr_const.cover_right_cc && HighestNodeStance == scr_const.crouch )
    {
      ConstString = scr_const.cover_right_crouch_cc;
    }
  }
  AnimsetName = BG_AnimationState_GetAnimsetName((const entityState_t *)this->m_pAI->ent);
  *(double *)&_XMM0 = BG_Animset_GetNodeLeanAimPitchOffset(AnimsetName, ConstString);
  __asm { vmovaps xmm1, xmm0; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetNodeLeanAimPitchOffset
==============
*/
void AIScriptedInterface::OnScrCmd_GetNodeLeanAimPitchOffset(AIScriptedInterface *this, scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  scr_string_t AnimsetName; 

  ConstString = Scr_GetConstString(scrContext, 0);
  AnimsetName = BG_AnimationState_GetAnimsetName((const entityState_t *)this->m_pAI->ent);
  *(double *)&_XMM0 = BG_Animset_GetNodeLeanAimPitchOffset(AnimsetName, ConstString);
  __asm { vmovaps xmm1, xmm0; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetNodeLeanAimYaw
==============
*/
void AIScriptedInterface::OnScrCmd_GetNodeLeanAimYaw(AIScriptedInterface *this, scrContext_t *scrContext)
{
  scr_string_t HighestNodeStance; 
  const pathnode_t *Pathnode; 
  scr_string_t ConstString; 
  int NumParam; 
  scr_string_t v9; 
  scr_string_t v10; 
  scr_string_t AnimsetName; 

  HighestNodeStance = 0;
  Pathnode = NULL;
  if ( (unsigned __int8)*(_DWORD *)&Scr_GetEntityRef(scrContext, 0).entclass == 2 )
    Pathnode = Scr_GetPathnode(scrContext, 0);
  ConstString = Scr_GetConstString(scrContext, 1u);
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam > 2 && Scr_GetType(scrContext, 2u) )
    HighestNodeStance = Scr_GetConstString(scrContext, 2u);
  if ( NumParam <= 3 || Scr_GetType(scrContext, 3u) == VAR_UNDEFINED || Scr_GetInt(scrContext, 3u) )
  {
    v9 = AI_StanceToString(this->m_pAI->eCurrentStance);
    v10 = v9;
    if ( !HighestNodeStance )
    {
      if ( !Pathnode || Path_DoesNodeAllowStance(Pathnode, v9) )
        HighestNodeStance = v10;
      else
        HighestNodeStance = Path_GetHighestNodeStance(Pathnode);
    }
    if ( ConstString == scr_const.cover_left_cc && HighestNodeStance == scr_const.crouch )
    {
      ConstString = scr_const.cover_left_crouch_cc;
    }
    else if ( ConstString == scr_const.cover_right_cc && HighestNodeStance == scr_const.crouch )
    {
      ConstString = scr_const.cover_right_crouch_cc;
    }
  }
  AnimsetName = BG_AnimationState_GetAnimsetName((const entityState_t *)this->m_pAI->ent);
  *(double *)&_XMM0 = BG_Animset_GetNodeLeanAimYawOffset(AnimsetName, ConstString);
  __asm { vmovaps xmm1, xmm0; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetNodeLeanAimYawOffset
==============
*/
void AIScriptedInterface::OnScrCmd_GetNodeLeanAimYawOffset(AIScriptedInterface *this, scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  scr_string_t AnimsetName; 

  ConstString = Scr_GetConstString(scrContext, 0);
  AnimsetName = BG_AnimationState_GetAnimsetName((const entityState_t *)this->m_pAI->ent);
  *(double *)&_XMM0 = BG_Animset_GetNodeLeanAimYawOffset(AnimsetName, ConstString);
  __asm { vmovaps xmm1, xmm0; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetNodeSnapYawOffset
==============
*/
void AIScriptedInterface::OnScrCmd_GetNodeSnapYawOffset(AIScriptedInterface *this, scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  scr_string_t AnimsetName; 

  ConstString = Scr_GetConstString(scrContext, 0);
  AnimsetName = BG_AnimationState_GetAnimsetName((const entityState_t *)this->m_pAI->ent);
  *(double *)&_XMM0 = BG_Animset_GetNodeSnapYawOffset(AnimsetName, ConstString);
  __asm { vmovaps xmm1, xmm0; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
AICommonInterface::OnScrCmd_GetPathDistToGoal
==============
*/
void AICommonInterface::OnScrCmd_GetPathDistToGoal(AICommonInterface *this, scrContext_t *scrContext)
{
  AINavigator *Navigator; 
  gentity_s *v6; 
  const char *v7; 
  bool v8; 
  AINavigator_vtbl *v9; 

  Navigator = AICommonInterface::GetNavigator(this);
  if ( !Navigator )
  {
    v6 = this->GetEntity(this);
    v7 = j_va("PathDistToGoal: Entity %d must have a navigator.", (unsigned int)v6->s.number);
    Scr_Error(COM_ERR_3832, scrContext, v7);
  }
  v8 = 0;
  if ( Scr_GetNumParam(scrContext) )
    v8 = Scr_GetInt(scrContext, 0) != 0;
  v9 = Navigator->__vftable;
  if ( v8 )
    v9->GetPathDistToGoalOrLink(Navigator);
  else
    *(double *)&_XMM0 = ((double (__fastcall *)(AINavigator *))v9->GetPathDistToGoal)(Navigator);
  __asm { vmovaps xmm1, xmm0; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetPointAfterNegotiation
==============
*/
void AIScriptedInterface::OnScrCmd_GetPointAfterNegotiation(AIScriptedInterface *this, scrContext_t *scrContext)
{
  float value[4]; 

  if ( this->m_pAI->pNavigator->HasPath(this->m_pAI->pNavigator) && this->m_pAI->pNavigator->GetNextCornerAfterLink(this->m_pAI->pNavigator, (vec3_t *)value) )
    Scr_AddVector(scrContext, value);
}

/*
==============
AICommonInterface::OnScrCmd_GetPosOnPath
==============
*/
void AICommonInterface::OnScrCmd_GetPosOnPath(AICommonInterface *this, scrContext_t *scrContext)
{
  AINavigator *Navigator; 
  gentity_s *v8; 
  const char *v9; 
  __int64 v11; 
  __int64 v13; 
  float value[5]; 
  bfx::AreaHandle v17; 
  bfx::LinkHandle v18; 
  char v19; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm { vmovaps xmmword ptr [rax-18h], xmm6 }
  Navigator = AICommonInterface::GetNavigator(this);
  if ( !Navigator )
  {
    v8 = this->GetEntity(this);
    v9 = j_va("GetPosOnPath: Entity %d must have a navigator.", (unsigned int)v8->s.number);
    Scr_Error(COM_ERR_3830, scrContext, v9);
  }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm { vmovaps xmm6, xmm0 }
  bfx::AreaHandle::AreaHandle(&v17);
  bfx::LinkHandle::LinkHandle(&v18);
  LOBYTE(v11) = 1;
  __asm { vmovaps xmm1, xmm6 }
  ((void (__fastcall *)(AINavigator *, __int64, __int64, float *, _BYTE))Navigator->GetPosAlongPath)(Navigator, v13, v11, value, 0);
  Scr_AddVector(scrContext, value);
  bfx::LinkHandle::~LinkHandle(&v18);
  bfx::AreaHandle::~AreaHandle(&v17);
  _R11 = &v19;
  __asm { vmovaps xmm6, xmmword ptr [r11-10h] }
}

/*
==============
AICommonInterface::OnScrCmd_GetPosOutsideBadplace
==============
*/
void AICommonInterface::OnScrCmd_GetPosOutsideBadplace(AICommonInterface *this, scrContext_t *scrContext)
{
  ai_common_t *m_pAI; 
  vec3_t outPos; 

  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  m_pAI = this->m_pAI;
  __asm
  {
    vmovss  dword ptr [rsp+48h+outPos], xmm0
    vmovss  dword ptr [rsp+48h+outPos+4], xmm0
    vxorps  xmm1, xmm1, xmm1
    vmovss  dword ptr [rsp+48h+outPos+8], xmm1
  }
  _RDX = m_pAI->ent;
  __asm
  {
    vaddss  xmm1, xmm0, dword ptr [rdx+130h]
    vmovss  dword ptr [rsp+48h+outPos], xmm1
    vaddss  xmm2, xmm0, dword ptr [rdx+134h]
    vmovss  dword ptr [rsp+48h+outPos+4], xmm2
    vmovss  xmm1, dword ptr [rdx+138h]
    vmovss  dword ptr [rsp+48h+outPos+8], xmm1
    vmovaps xmm1, xmm0; safeDist
  }
  if ( AICommonInterface::FindSafePosOutsideBadplace(this, *(float *)&_XMM1, &outPos) )
    Scr_AddVector(scrContext, outPos.v);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetReacquireState
==============
*/
void AIScriptedInterface::OnScrCmd_GetReacquireState(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ai_reacquire_state_t Reacquire; 
  __int64 v4; 

  Reacquire = AIScriptedInterface::GetReacquire(this);
  v4 = Reacquire;
  if ( (unsigned int)Reacquire >= AI_REACQUIRE_COUNT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 5128, ASSERT_TYPE_ASSERT, "(unsigned)( reacquireState ) < (unsigned)( AI_REACQUIRE_COUNT )", "reacquireState doesn't index AI_REACQUIRE_COUNT\n\t%i not in [0, %i)", Reacquire, 4) )
    __debugbreak();
  Scr_AddConstString(scrContext, *AIReacquireStateStrings[v4]);
}

/*
==============
AICommonInterface::OnScrCmd_GetSecondaryTargets
==============
*/
void AICommonInterface::OnScrCmd_GetSecondaryTargets(AICommonInterface *this, scrContext_t *scrContext)
{
  ai_common_t *m_pAI; 
  int v5; 
  __int64 v6; 
  AISecondaryTarget *v7; 
  unsigned __int16 number; 
  __int64 v9; 
  unsigned int v10; 
  __int64 v11; 
  ai_common_t *v12; 
  int v13; 
  AISecondaryTarget *v14; 
  __int64 v15; 
  __int64 v16; 
  __int64 v17; 
  __int64 v18; 

  if ( this->m_pAI->threat.numSecondaryTarget > 0 )
  {
    Scr_MakeArray(scrContext);
    m_pAI = this->m_pAI;
    v5 = 0;
    if ( m_pAI->threat.numSecondaryTarget > 0 )
    {
      v6 = 0i64;
      do
      {
        v7 = &m_pAI->threat.secondaryTargets[v6];
        number = v7->entity.number;
        if ( v7->entity.number )
        {
          v9 = number;
          v10 = number - 1;
          if ( v10 >= 0x800 )
          {
            LODWORD(v18) = 2048;
            LODWORD(v17) = v10;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v17, v18) )
              __debugbreak();
          }
          if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
            __debugbreak();
          v11 = v9 - 1;
          if ( g_entities[v11].r.isInUse != g_entityIsInUse[v11] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
            __debugbreak();
          if ( !g_entityIsInUse[v11] )
          {
            LODWORD(v18) = v7->entity.number - 1;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 216, ASSERT_TYPE_ASSERT, "( ( !number || G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( !number || G_IsEntityInUse( number - 1 ) )", v18) )
              __debugbreak();
          }
          if ( v7->entity.number )
          {
            v12 = this->m_pAI;
            v13 = v12->threat.secondaryTargets[v6].entity.number;
            v14 = &v12->threat.secondaryTargets[v6];
            if ( (unsigned int)(v13 - 1) >= 0x7FF )
            {
              LODWORD(v18) = 2047;
              LODWORD(v17) = v13 - 1;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 223, ASSERT_TYPE_ASSERT, "(unsigned)( number - 1 ) < (unsigned)( ENTITYNUM_NONE )", "number - 1 doesn't index ENTITYNUM_NONE\n\t%i not in [0, %i)", v17, v18) )
                __debugbreak();
            }
            v15 = v14->entity.number;
            if ( (unsigned int)(v15 - 1) >= 0x800 )
            {
              LODWORD(v18) = 2048;
              LODWORD(v17) = v15 - 1;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v17, v18) )
                __debugbreak();
            }
            if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
              __debugbreak();
            v16 = v15 - 1;
            if ( g_entities[v16].r.isInUse != g_entityIsInUse[v16] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
              __debugbreak();
            if ( !g_entityIsInUse[v16] )
            {
              LODWORD(v18) = v14->entity.number - 1;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 224, ASSERT_TYPE_ASSERT, "( ( G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( G_IsEntityInUse( number - 1 ) )", v18) )
                __debugbreak();
            }
            GScr_AddEntity(&g_entities[v14->entity.number - 1]);
            Scr_AddArray(scrContext);
          }
        }
        m_pAI = this->m_pAI;
        ++v5;
        ++v6;
      }
      while ( v5 < m_pAI->threat.numSecondaryTarget );
    }
  }
}

/*
==============
AICommonInterface::OnScrCmd_GetStairsStateAtDist
==============
*/
void AICommonInterface::OnScrCmd_GetStairsStateAtDist(AICommonInterface *this, scrContext_t *scrContext)
{
  gentity_s *v7; 
  AINavigator *Navigator; 
  const char *v9; 
  const nav_space_s **v10; 
  __int64 v12; 
  int v13; 
  int skipEntity; 
  bool v31; 
  scrContext_t *v34; 
  scr_string_t up; 
  int v36; 
  int v37; 
  int v38; 
  int v39; 
  vec3_t outUp; 
  vec3_t end; 
  vec3_t start; 
  trace_t results; 

  v7 = this->GetEntity(this);
  Navigator = AICommonInterface::GetNavigator(this);
  if ( !Navigator )
  {
    v9 = j_va("GetStairsStateAtDist: Entity %d must have a navigator.", (unsigned int)v7->s.number);
    Scr_Error(COM_ERR_5906, scrContext, v9);
  }
  v10 = (const nav_space_s **)Navigator->Get2DNavigator(Navigator);
  if ( v10 )
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
    __asm { vmovaps xmm1, xmm0 }
    v13 = (*(__int64 (__fastcall **)(const nav_space_s **, __int64, int *))&(*v10)->obstacleList.m_BoundaryPlanes[8].m_DistFromCenter)(v10, v12, &v39);
    if ( !v13 )
      goto LABEL_15;
    __asm
    {
      vmovss  xmm0, [rsp+158h+var_F0]
      vmovss  [rsp+158h+var_F8], xmm0
      vmovaps [rsp+158h+var_28], xmm6
      vmovaps [rsp+158h+var_38], xmm7
    }
    if ( (v36 & 0x7F800000) == 2139095040 )
      goto LABEL_19;
    __asm
    {
      vmovss  xmm0, [rsp+158h+var_EC]
      vmovss  [rsp+158h+var_F8], xmm0
    }
    if ( (v37 & 0x7F800000) == 2139095040 )
      goto LABEL_19;
    __asm
    {
      vmovss  xmm0, [rsp+158h+var_E8]
      vmovss  [rsp+158h+var_F8], xmm0
    }
    if ( (v38 & 0x7F800000) == 2139095040 )
    {
LABEL_19:
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 1515, ASSERT_TYPE_SANITY, "( !IS_NAN( ( posAtDist )[0] ) && !IS_NAN( ( posAtDist )[1] ) && !IS_NAN( ( posAtDist )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( posAtDist )[0] ) && !IS_NAN( ( posAtDist )[1] ) && !IS_NAN( ( posAtDist )[2] )") )
        __debugbreak();
    }
    Nav_GetSpaceUp(v10[2], &outUp);
    __asm
    {
      vmovss  xmm2, cs:__real@42000000
      vmulss  xmm7, xmm2, dword ptr [rsp+158h+outUp]
      vmulss  xmm5, xmm2, dword ptr [rsp+158h+outUp+4]
      vmulss  xmm3, xmm2, dword ptr [rsp+158h+outUp+8]
      vmovss  xmm6, [rsp+158h+var_F0]
      vmovss  xmm4, [rsp+158h+var_EC]
      vmovss  xmm2, [rsp+158h+var_E8]
    }
    skipEntity = v7->s.number;
    __asm
    {
      vaddss  xmm1, xmm7, xmm6
      vmovss  dword ptr [rsp+158h+start], xmm1
      vaddss  xmm1, xmm5, xmm4
      vmovss  dword ptr [rsp+158h+start+4], xmm1
      vaddss  xmm1, xmm3, xmm2
      vsubss  xmm0, xmm6, xmm7
      vmovss  dword ptr [rsp+158h+start+8], xmm1
      vmovss  dword ptr [rsp+158h+end], xmm0
      vsubss  xmm1, xmm4, xmm5
      vsubss  xmm0, xmm2, xmm3
      vmovss  dword ptr [rsp+158h+end+4], xmm1
      vmovss  dword ptr [rsp+158h+end+8], xmm0
    }
    PhysicsQuery_LegacyTrace(PHYSICS_WORLD_ID_FIRST, &results, &start, &end, &bounds_origin, skipEntity, 1, 33685521, 0, NULL, All);
    v31 = Path_TraceHitStairs(&results);
    __asm
    {
      vmovaps xmm7, [rsp+158h+var_38]
      vmovaps xmm6, [rsp+158h+var_28]
    }
    if ( v31 )
    {
      v34 = scrContext;
      if ( v13 == 1 )
        up = scr_const.up;
      else
        up = scr_const.down;
    }
    else
    {
LABEL_15:
      up = scr_const.none;
      v34 = scrContext;
    }
    Scr_AddConstString(v34, up);
  }
  else
  {
    Scr_AddConstString(scrContext, scr_const.none);
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_GetTargetSpeed
==============
*/
void AIScriptedInterface::OnScrCmd_GetTargetSpeed(AIScriptedInterface *this, scrContext_t *scrContext)
{
  _RAX = this->m_pAI;
  __asm { vmovss  xmm1, dword ptr [rax+0D4Ch]; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
AIScriptedInterface::OnScrCmd_GetWorldWeaponOffset
==============
*/
void AIScriptedInterface::OnScrCmd_GetWorldWeaponOffset(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ApproxGunParams pOutGunParams; 
  float value[4]; 
  tmat33_t<vec3_t> axis; 

  AIScriptedInterface::GetApproxAdjustedGunParams(this, &pOutGunParams);
  AnglesToAxis(&this->m_pAI->ent->r.currentAngles, &axis);
  __asm
  {
    vmovss  xmm5, dword ptr [rsp+78h+pOutGunParams.m_offset+8]
    vmovss  xmm0, dword ptr [rsp+78h+axis]
    vmulss  xmm2, xmm0, dword ptr [rsp+78h+pOutGunParams.m_offset]
    vmovss  xmm1, dword ptr [rsp+78h+axis+0Ch]
    vmulss  xmm0, xmm1, dword ptr [rsp+78h+pOutGunParams.m_offset+4]
    vmulss  xmm1, xmm5, dword ptr [rsp+78h+axis+18h]
    vaddss  xmm2, xmm2, xmm0
    vaddss  xmm0, xmm2, xmm1
    vmovss  xmm2, dword ptr [rsp+78h+axis+4]
    vmulss  xmm3, xmm2, dword ptr [rsp+78h+pOutGunParams.m_offset]
    vmovss  xmm2, dword ptr [rsp+78h+axis+8]
    vmovss  [rsp+78h+value], xmm0
    vmovss  xmm0, dword ptr [rsp+78h+axis+10h]
    vmulss  xmm1, xmm0, dword ptr [rsp+78h+pOutGunParams.m_offset+4]
    vmulss  xmm0, xmm5, dword ptr [rsp+78h+axis+1Ch]
    vaddss  xmm4, xmm3, xmm1
    vmulss  xmm3, xmm2, dword ptr [rsp+78h+pOutGunParams.m_offset]
    vaddss  xmm1, xmm4, xmm0
    vmovss  xmm0, dword ptr [rsp+78h+axis+14h]
    vmovss  [rsp+78h+var_44], xmm1
    vmulss  xmm1, xmm0, dword ptr [rsp+78h+pOutGunParams.m_offset+4]
    vmulss  xmm0, xmm5, dword ptr [rsp+78h+axis+20h]
    vaddss  xmm4, xmm3, xmm1
    vaddss  xmm1, xmm4, xmm0
    vmovss  [rsp+78h+var_40], xmm1
  }
  Scr_AddVector(scrContext, value);
}

/*
==============
AIScriptedInterface::OnScrCmd_IW7ShipHack_SetMayMoveTime
==============
*/
void AIScriptedInterface::OnScrCmd_IW7ShipHack_SetMayMoveTime(AIScriptedInterface *this, scrContext_t *scrContext)
{
  this->m_pAI->mayMoveTime = Scr_GetInt(scrContext, 0);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsAtValidLongDeathSpot
==============
*/
void AIScriptedInterface::OnScrCmd_IsAtValidLongDeathSpot(AIScriptedInterface *this, scrContext_t *scrContext)
{
  gentity_s *v9; 
  gentity_s *v10; 
  const char *v11; 
  int v27; 
  char v38; 
  vec3_t outUp; 
  vec3_t vectorValue; 
  vec3_t end; 
  vec3_t start; 
  trace_t results; 
  char v50; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-28h], xmm6
    vmovaps xmmword ptr [rax-38h], xmm7
    vmovaps xmmword ptr [rax-48h], xmm8
    vmovaps xmmword ptr [rax-58h], xmm9
  }
  v9 = this->GetEntity(this);
  v10 = v9;
  if ( !this->m_pAI->pNavigator )
  {
    v11 = j_va("IsAtValidLongDeathSpot: Entity %d must have a navigator.", (unsigned int)v9->s.number);
    Scr_Error(COM_ERR_3831, scrContext, v11);
  }
  if ( Scr_GetNumParam(scrContext) && Scr_GetType(scrContext, 0) == VAR_VECTOR )
    Scr_GetVector(scrContext, 0, &vectorValue);
  else
    this->m_pAI->pNavigator->GetCurPos(this->m_pAI->pNavigator, &vectorValue);
  Nav_GetSpaceUp(this->m_pAI->pNavigator->m_pSpace, &outUp);
  __asm
  {
    vmovss  xmm2, cs:__real@42000000
    vmulss  xmm0, xmm2, dword ptr [rsp+160h+outUp]
    vmulss  xmm1, xmm2, dword ptr [rsp+160h+outUp+4]
    vmovss  xmm3, cs:__real@41000000
    vmovss  xmm8, dword ptr [rsp+160h+vectorValue]
    vmovss  xmm6, dword ptr [rsp+160h+vectorValue+4]
    vmovss  xmm4, dword ptr [rsp+160h+vectorValue+8]
    vaddss  xmm0, xmm0, xmm8
    vmovss  dword ptr [rbp+60h+start], xmm0
    vaddss  xmm0, xmm1, xmm6
    vmulss  xmm1, xmm2, dword ptr [rsp+160h+outUp+8]
    vmulss  xmm2, xmm3, dword ptr [rsp+160h+outUp+4]
    vmovss  dword ptr [rbp+60h+start+4], xmm0
    vaddss  xmm0, xmm1, xmm4
    vmulss  xmm1, xmm3, dword ptr [rsp+160h+outUp]
    vmovss  dword ptr [rbp+60h+start+8], xmm0
    vsubss  xmm0, xmm8, xmm1
    vmovss  dword ptr [rbp+60h+end], xmm0
    vmulss  xmm0, xmm3, dword ptr [rsp+160h+outUp+8]
  }
  v27 = 0;
  __asm
  {
    vsubss  xmm1, xmm6, xmm2
    vsubss  xmm2, xmm4, xmm0
    vmovss  dword ptr [rbp+60h+end+8], xmm2
    vmovss  dword ptr [rbp+60h+end+4], xmm1
  }
  PhysicsQuery_LegacyTrace(PHYSICS_WORLD_ID_FIRST, &results, &start, &end, &bounds_origin, v10->s.number, 1, 33685521, 0, NULL, All);
  __asm
  {
    vmovss  xmm0, dword ptr [rbp+60h+results.normal+4]
    vmovss  xmm1, dword ptr [rbp+60h+results.normal]
    vmulss  xmm2, xmm1, dword ptr [rsp+160h+outUp]
    vmulss  xmm3, xmm0, dword ptr [rsp+160h+outUp+4]
    vmovss  xmm0, dword ptr [rbp+60h+results.normal+8]
    vmulss  xmm1, xmm0, dword ptr [rsp+160h+outUp+8]
    vaddss  xmm4, xmm3, xmm2
    vaddss  xmm2, xmm4, xmm1
    vcomiss xmm2, cs:__real@3f770a3d
  }
  if ( !v38 && !Path_TraceHitStairs(&results) )
  {
    __asm
    {
      vmovss  xmm0, [rbp+60h+results.fraction]
      vcomiss xmm0, cs:__real@3f800000
    }
    LOBYTE(v27) = 0;
  }
  Scr_AddBool(scrContext, v27);
  _R11 = &v50;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_IsCoverValidAgainstEnemy
==============
*/
void AIScriptedInterface::OnScrCmd_IsCoverValidAgainstEnemy(AIScriptedInterface *this, scrContext_t *scrContext)
{
  sentient_s *v4; 
  const pathnode_t *pClaimedNode; 
  int NumParam; 
  int IsValidAgainstEnemy; 
  bool v8; 

  v4 = this->GetSentient(this);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 2070, ASSERT_TYPE_ASSERT, "(sentient)", (const char *)&queryFormat, "sentient") )
    __debugbreak();
  pClaimedNode = v4->pClaimedNode;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam > 0 && Scr_GetType(scrContext, 0) )
    pClaimedNode = Scr_GetPathnode(scrContext, 0);
  if ( pClaimedNode )
  {
    v8 = 1;
    if ( NumParam > 1 && Scr_GetType(scrContext, 1u) )
      v8 = Scr_GetInt(scrContext, 1u) != 0;
    IsValidAgainstEnemy = AIScriptedInterface::Cover_IsValidAgainstEnemy(this, pClaimedNode, v8);
  }
  else
  {
    IsValidAgainstEnemy = 0;
  }
  Scr_AddBool(scrContext, IsValidAgainstEnemy);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsCurrentEnemyValid
==============
*/
void AIScriptedInterface::OnScrCmd_IsCurrentEnemyValid(AIScriptedInterface *this, scrContext_t *scrContext)
{
  bool IsCurrentEnemyValid; 

  IsCurrentEnemyValid = AIScriptedInterface::IsCurrentEnemyValid(this);
  Scr_AddBool(scrContext, IsCurrentEnemyValid);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsGunBlockedByWall
==============
*/
void AIScriptedInterface::OnScrCmd_IsGunBlockedByWall(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int IsGunBlockedByWall; 

  __asm
  {
    vmovaps [rsp+38h+var_18], xmm6
    vmovss  xmm6, cs:__real@41400000
  }
  if ( Scr_GetNumParam(scrContext) )
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
    __asm { vmovaps xmm6, xmm0 }
  }
  __asm { vmovaps xmm1, xmm6; bufferDist }
  IsGunBlockedByWall = AIScriptedInterface::IsGunBlockedByWall(this, *(float *)&_XMM1);
  __asm { vmovaps xmm6, [rsp+38h+var_18] }
  Scr_AddInt(scrContext, IsGunBlockedByWall);
}

/*
==============
AICommonInterface::OnScrCmd_IsInBadplace
==============
*/
void AICommonInterface::OnScrCmd_IsInBadplace(AICommonInterface *this, scrContext_t *scrContext)
{
  ai_common_t *m_pAI; 
  bool isInBadPlace; 

  m_pAI = this->m_pAI;
  isInBadPlace = m_pAI->navigation.isInBadPlace;
  if ( m_pAI->ent && m_pAI->ent->tagInfo )
    isInBadPlace = 0;
  Scr_AddBool(scrContext, isInBadPlace);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsInGoal
==============
*/
void AIScriptedInterface::OnScrCmd_IsInGoal(AIScriptedInterface *this, scrContext_t *scrContext)
{
  bool v4; 
  vec3_t vectorValue; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    Scr_GetVector(scrContext, 0, &vectorValue);
    v4 = AICommonInterface::PointAtGoal(this, &vectorValue, &this->m_pAI->codeGoal);
    Scr_AddBool(scrContext, v4);
  }
  else
  {
    Scr_Error(COM_ERR_3856, scrContext, "illegal call to isingoal()");
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_IsInScriptedState
==============
*/
void AIScriptedInterface::OnScrCmd_IsInScriptedState(AIScriptedInterface *this, scrContext_t *scrContext)
{
  bool v3; 

  v3 = this->InScriptedState(this);
  Scr_AddBool(scrContext, v3);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsKnownEnemyInRadius
==============
*/
void AIScriptedInterface::OnScrCmd_IsKnownEnemyInRadius(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int v5; 
  int Int; 
  vec3_t vectorValue; 

  v5 = 0;
  Int = 0;
  Scr_GetVector(scrContext, 0, &vectorValue);
  if ( Scr_GetNumParam(scrContext) > 2 )
    Int = Scr_GetInt(scrContext, 2u);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm { vmovaps xmm3, xmm0; radius }
  LOBYTE(v5) = AIScriptedInterface::IsKnownEnemyInRegion(this, NULL, &vectorValue, *(float *)&_XMM3, Int != 0) != NULL;
  Scr_AddInt(scrContext, v5);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsKnownEnemyInVolume
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_IsKnownEnemyInVolume(AIScriptedInterface *this, scrContext_t *scrContext, __int64 a3, double _XMM3_8)
{
  int v5; 
  int Int; 
  const gentity_s *Entity; 

  v5 = 0;
  Int = 0;
  Entity = GScr_GetEntity(0);
  if ( Scr_GetNumParam(scrContext) > 1 )
    Int = Scr_GetInt(scrContext, 1u);
  __asm { vxorps  xmm3, xmm3, xmm3; radius }
  LOBYTE(v5) = AIScriptedInterface::IsKnownEnemyInRegion(this, Entity, &vec3_origin, *(float *)&_XMM3, Int != 0) != NULL;
  Scr_AddInt(scrContext, v5);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsLegacyAgent
==============
*/
void AIScriptedInterface::OnScrCmd_IsLegacyAgent(AIScriptedInterface *this, scrContext_t *scrContext)
{
  Scr_AddInt(scrContext, 0);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsMoveSuppressed
==============
*/
void AIScriptedInterface::OnScrCmd_IsMoveSuppressed(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int IsMoveSuppressed; 

  IsMoveSuppressed = AIScriptedInterface::IsMoveSuppressed(this);
  Scr_AddInt(scrContext, IsMoveSuppressed);
}

/*
==============
AICommonInterface::OnScrCmd_IsNodeInBadplace
==============
*/
void AICommonInterface::OnScrCmd_IsNodeInBadplace(AICommonInterface *this, scrContext_t *scrContext)
{
  pathnode_t *Pathnode; 
  int v5; 
  unsigned __int64 eTeam; 
  int v7; 
  bitarray<224> teamFlags; 
  vec3_t pos; 

  Pathnode = Scr_GetPathnode(scrContext, 0);
  pathnode_t::GetPos(Pathnode, &pos);
  v5 = 0;
  eTeam = (unsigned int)this->m_pAI->sentient->eTeam;
  memset(&teamFlags, 0, sizeof(teamFlags));
  if ( (unsigned int)eTeam >= 0xE0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 263, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", eTeam, 224) )
    __debugbreak();
  teamFlags.array[eTeam >> 5] |= 0x80000000 >> (eTeam & 0x1F);
  v7 = Nav_TranslateTeamFlagsToRepulsorUsageFlags(&teamFlags);
  if ( Nav_IsPointInRepulsorBadplace(&pos, v7, this->m_pAI->ent->s.number, 2047) )
    v5 = 1;
  else
    LOBYTE(v5) = !this->m_pAI->pNavigator->IsNodeUsable(this->m_pAI->pNavigator, Pathnode);
  Scr_AddBool(scrContext, v5);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsPathDirect
==============
*/
void AIScriptedInterface::OnScrCmd_IsPathDirect(AIScriptedInterface *this, scrContext_t *scrContext)
{
  bool IsStraightLineToGoal; 

  if ( AICommonInterface::HasPath(this) )
  {
    IsStraightLineToGoal = Nav_IsStraightLineToGoal(this->m_pAI->pNavigator);
    Scr_AddInt(scrContext, IsStraightLineToGoal);
  }
  else
  {
    Scr_AddInt(scrContext, 0);
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_IsStanceAllowed
==============
*/
void AIScriptedInterface::OnScrCmd_IsStanceAllowed(AIScriptedInterface *this, scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  int v5; 
  ai_stance_e v6; 
  const char *v7; 
  const char *v8; 

  ConstString = Scr_GetConstString(scrContext, 0);
  v5 = 0;
  v6 = STANCE_BAD;
  if ( ConstString == scr_const.stand )
  {
    v6 = STANCE_STAND;
  }
  else if ( ConstString == scr_const.crouch )
  {
    v6 = STANCE_CROUCH;
  }
  else if ( ConstString == scr_const.prone )
  {
    v6 = STANCE_PRONE;
  }
  else
  {
    v7 = SL_ConvertToString(ConstString);
    v8 = j_va("invalid stance '%s' in isStanceAllowed()\n", v7);
    Scr_Error(COM_ERR_3841, scrContext, v8);
  }
  LOBYTE(v5) = AIScriptedInterface::IsStanceAllowed(this, v6);
  Scr_AddInt(scrContext, v5);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsSuppressed
==============
*/
void AIScriptedInterface::OnScrCmd_IsSuppressed(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int IsSuppressed; 

  IsSuppressed = AIScriptedInterface::IsSuppressed(this);
  Scr_AddInt(scrContext, IsSuppressed);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsSuppressionWaiting
==============
*/
void AIScriptedInterface::OnScrCmd_IsSuppressionWaiting(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int IsSuppressionWaiting; 

  IsSuppressionWaiting = AIScriptedInterface::IsSuppressionWaiting(this);
  Scr_AddInt(scrContext, IsSuppressionWaiting);
}

/*
==============
AIScriptedInterface::OnScrCmd_IsWithinScriptGoalRadius
==============
*/
void AIScriptedInterface::OnScrCmd_IsWithinScriptGoalRadius(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int NumParam; 
  bool IsWithinScriptGoalRadius; 
  vec3_t vectorValue; 

  __asm { vmovaps [rsp+68h+var_28], xmm6 }
  NumParam = Scr_GetNumParam(scrContext);
  _RDI = this->GetEntity(this);
  if ( NumParam > 0 && Scr_GetType(scrContext, 0) )
  {
    Scr_GetVector(scrContext, 0, &vectorValue);
  }
  else
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rdi+130h]
      vmovss  dword ptr [rsp+68h+vectorValue], xmm0
      vmovss  xmm1, dword ptr [rdi+134h]
      vmovss  dword ptr [rsp+68h+vectorValue+4], xmm1
      vmovss  xmm0, dword ptr [rdi+138h]
      vmovss  dword ptr [rsp+68h+vectorValue+8], xmm0
    }
  }
  __asm { vxorps  xmm6, xmm6, xmm6 }
  if ( NumParam > 1 && Scr_GetType(scrContext, 1u) )
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
    __asm { vmovaps xmm6, xmm0 }
  }
  __asm { vmovaps xmm2, xmm6; buffer }
  IsWithinScriptGoalRadius = AIScriptedInterface::IsWithinScriptGoalRadius(this, &vectorValue, *(float *)&_XMM2);
  Scr_AddBool(scrContext, IsWithinScriptGoalRadius);
  __asm { vmovaps xmm6, [rsp+68h+var_28] }
}

/*
==============
AIScriptedInterface::OnScrCmd_MayMoveCheckFriendlyFire
==============
*/
void AIScriptedInterface::OnScrCmd_MayMoveCheckFriendlyFire(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int v4; 
  vec3_t vectorValue; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  v4 = AIScriptedInterface::MayMove_CheckFriendlyFire(this, &this->m_pAI->ent->r.currentOrigin, &vectorValue);
  Scr_AddBool(scrContext, v4 == 0);
}

/*
==============
AIScriptedInterface::OnScrCmd_MayMoveFromPointToPoint
==============
*/
void AIScriptedInterface::OnScrCmd_MayMoveFromPointToPoint(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int checkDrop; 
  int ignoreActors; 
  bool MayMoveFromPointToPoint; 
  bfx::AreaHandle hStartArea; 
  __int64 v8; 
  vec3_t vEnd; 
  vec3_t vectorValue; 

  v8 = -2i64;
  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &vEnd);
  checkDrop = 0;
  ignoreActors = Scr_GetNumParam(scrContext) > 3 && Scr_GetInt(scrContext, 3u) != 0;
  if ( Scr_GetNumParam(scrContext) <= 2 )
    checkDrop = 1;
  else
    LOBYTE(checkDrop) = Scr_GetInt(scrContext, 2u) != 0;
  bfx::AreaHandle::AreaHandle(&hStartArea);
  MayMoveFromPointToPoint = AIScriptedInterface::MayMoveFromPointToPoint(this, &vectorValue, &hStartArea, &vEnd, ignoreActors, checkDrop);
  Scr_AddBool(scrContext, MayMoveFromPointToPoint);
  bfx::AreaHandle::~AreaHandle(&hStartArea);
}

/*
==============
AIScriptedInterface::OnScrCmd_MayMoveToPoint
==============
*/
void AIScriptedInterface::OnScrCmd_MayMoveToPoint(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int v4; 
  int checkDrop; 
  int ignoreActors; 
  gentity_s *v7; 
  const vec3_t *p_currentOrigin; 
  ai_scripted_t *m_pAI; 
  __int64 v10; 
  AINavigator2D *v11; 
  const bfx::AreaHandle *CurArea; 
  vec3_t vectorValue; 
  vec3_t vStart; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  v4 = 0;
  checkDrop = Scr_GetNumParam(scrContext) <= 1 || Scr_GetInt(scrContext, 1u) != 0;
  ignoreActors = Scr_GetNumParam(scrContext) > 2 && Scr_GetInt(scrContext, 2u) != 0;
  v7 = this->GetEntity(this);
  p_currentOrigin = &v7->r.currentOrigin;
  if ( v7->tagInfo )
  {
    AIScriptedInterface::MayMove_Debug(&v7->r.currentOrigin, &vectorValue, &colorMagenta, DEBUGMAYMOVE_LIFTED);
  }
  else if ( !AIScriptedInterface::MayMove_CheckFriendlyFire(this, &v7->r.currentOrigin, &vectorValue) )
  {
    m_pAI = this->m_pAI;
    if ( !m_pAI->pNavigator )
    {
      Scr_Error(COM_ERR_3886, scrContext, "AI does not have a navigator");
      m_pAI = this->m_pAI;
    }
    v10 = (__int64)m_pAI->pNavigator->Get2DNavigator(m_pAI->pNavigator);
    v11 = (AINavigator2D *)v10;
    if ( v10 )
    {
      (*(void (__fastcall **)(__int64, vec3_t *))(*(_QWORD *)v10 + 16i64))(v10, &vStart);
      CurArea = AINavigator2D::GetCurArea(v11);
      if ( !AIScriptedInterface::MayMoveFromPointToPoint(this, &vStart, CurArea, &vectorValue, ignoreActors, checkDrop) )
        goto LABEL_17;
    }
    else
    {
      Scr_Error(COM_ERR_3887, scrContext, "MayMoveToPoint does not work with 3D nav.  Use a nav trace (allow edge) instead.");
    }
    this->SetMayMoveTime(this, level.time);
    AIScriptedInterface::MayMove_Debug(p_currentOrigin, &vectorValue, &colorGreen, DEBUGMAYMOVE_LIFTED);
    v4 = 1;
  }
LABEL_17:
  Scr_AddBool(scrContext, v4);
}

/*
==============
AIScriptedInterface::OnScrCmd_Melee
==============
*/
void AIScriptedInterface::OnScrCmd_Melee(AIScriptedInterface *this, scrContext_t *scrContext)
{
  vec3_t *p_vectorValue; 
  int NumParam; 
  int Int; 
  const gentity_s *v15; 
  float v20; 
  float v21; 
  vec3_t vectorValue; 
  char v26; 

  __asm
  {
    vmovaps [rsp+98h+var_28], xmm6
    vmovaps [rsp+98h+var_38], xmm7
    vmovaps [rsp+98h+var_48], xmm8
  }
  p_vectorValue = NULL;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam > 0 && Scr_GetType(scrContext, 0) )
  {
    Scr_GetVector(scrContext, 0, &vectorValue);
    p_vectorValue = &vectorValue;
  }
  Int = -1;
  if ( NumParam > 1 && Scr_GetType(scrContext, 1u) )
    Int = Scr_GetInt(scrContext, 1u);
  __asm { vmovss  xmm7, cs:__real@42800000 }
  if ( NumParam > 2 && Scr_GetType(scrContext, 2u) )
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
    __asm { vmovaps xmm7, xmm0 }
  }
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vxorps  xmm8, xmm8, xmm8
  }
  if ( NumParam > 3 && Scr_GetType(scrContext, 3u) )
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
    __asm { vmovaps xmm8, xmm0 }
  }
  if ( NumParam > 4 && Scr_GetType(scrContext, 4u) )
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 4u);
    __asm { vmovaps xmm6, xmm0 }
  }
  __asm
  {
    vmovss  [rsp+98h+var_70], xmm6
    vmovaps xmm3, xmm7; range
    vmovss  [rsp+98h+var_78], xmm8
  }
  v15 = AIScriptedInterface::Melee(this, p_vectorValue, Int, *(float *)&_XMM3, v20, v21);
  if ( v15 )
    GScr_AddEntity(v15);
  _R11 = &v26;
  __asm
  {
    vmovaps xmm6, [rsp+98h+var_28]
    vmovaps xmm7, [rsp+98h+var_38]
    vmovaps xmm8, xmmword ptr [r11-30h]
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_NearClaimNode
==============
*/
void AIScriptedInterface::OnScrCmd_NearClaimNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  bool v3; 

  v3 = AIScriptedInterface::AtClaimNode(this);
  Scr_AddBool(scrContext, v3);
}

/*
==============
AIScriptedInterface::OnScrCmd_NearClaimNodeAndAngle
==============
*/
void AIScriptedInterface::OnScrCmd_NearClaimNodeAndAngle(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int v3; 

  v3 = AIScriptedInterface::AtClaimNodeAndAngle(this);
  Scr_AddBool(scrContext, v3);
}

/*
==============
AIScriptedInterface::OnScrCmd_OrientMode
==============
*/
void AIScriptedInterface::OnScrCmd_OrientMode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  bool v9; 
  bool v10; 
  _BOOL8 v11; 
  bool v15; 
  bool v16; 
  bool v20; 
  bool v24; 
  unsigned int NumParam; 
  AIScriptedInterface_vtbl *v33; 
  ai_scripted_t *m_pAI; 
  int number; 
  Ai_Asm *v45; 
  ASM_Instance *Instance; 
  const ASM_State *State; 
  const char *v48; 
  const char *v49; 
  int v50; 
  int v51; 
  int v52; 
  int v53; 
  vec3_t vectorValue; 
  vec3_t v55; 

  ConstString = Scr_GetConstString(scrContext, 0);
  if ( ConstString == scr_const.face_angle )
  {
    if ( this->Is3D(this) )
      Scr_Error(COM_ERR_3874, scrContext, "Invalid OrientMode 'face angle' on a 3D actor.  Did you mean to use 'face angle 3d'?");
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
    __asm
    {
      vxorps  xmm1, xmm1, xmm1
      vmovss  [rbp+var_40], xmm0
      vmovss  dword ptr [rbp+vectorValue], xmm1
      vmovss  dword ptr [rbp+vectorValue+4], xmm0
      vmovss  dword ptr [rbp+vectorValue+8], xmm1
    }
    if ( (v50 & 0x7F800000) == 2139095040 )
      Scr_Error(COM_ERR_3875, scrContext, "OrientMode - invalid angle provided to 'face angle'");
    v9 = 1;
    if ( Scr_GetNumParam(scrContext) > 2 )
      v9 = Scr_GetInt(scrContext, 2u) == 0;
    this->OrientMode_FaceAngles(this, &vectorValue, 0, v9);
  }
  else if ( ConstString == scr_const.face_angle_3d )
  {
    Scr_GetVector(scrContext, 1u, &vectorValue);
    v10 = 1;
    if ( Scr_GetNumParam(scrContext) > 2 )
      v10 = Scr_GetInt(scrContext, 2u) == 0;
    __asm
    {
      vmovss  xmm0, dword ptr [rbp+vectorValue]
      vmovss  [rbp+var_40], xmm0
    }
    if ( (v51 & 0x7F800000) == 2139095040 )
      goto LABEL_15;
    __asm
    {
      vmovss  xmm0, dword ptr [rbp+vectorValue+4]
      vmovss  [rbp+var_40], xmm0
    }
    if ( (v52 & 0x7F800000) == 2139095040 )
      goto LABEL_15;
    __asm
    {
      vmovss  xmm0, dword ptr [rbp+vectorValue+8]
      vmovss  [rbp+var_40], xmm0
    }
    if ( (v53 & 0x7F800000) == 2139095040 )
LABEL_15:
      Scr_Error(COM_ERR_3876, scrContext, "OrientMode - invalid angles provided to 'face angle 3d'");
    LOBYTE(v11) = 1;
    this->OrientMode_FaceAngles(this, &vectorValue, v11, v10);
  }
  else if ( ConstString == scr_const.face_current )
  {
    v15 = 1;
    if ( Scr_GetNumParam(scrContext) > 2 )
      v15 = Scr_GetInt(scrContext, 2u) == 0;
    this->OrientMode_FaceCurrent(this, v15);
  }
  else if ( ConstString == scr_const.face_direction )
  {
    __asm { vmovaps [rsp+70h+var_10], xmm6 }
    Scr_GetVector(scrContext, 1u, &vectorValue);
    __asm
    {
      vmovss  xmm0, dword ptr [rbp+vectorValue]
      vxorps  xmm6, xmm6, xmm6
      vucomiss xmm0, xmm6
    }
    if ( v16 )
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rbp+vectorValue+4]
        vucomiss xmm0, xmm6
      }
      if ( v16 )
      {
        v20 = this->Is3D(this);
        v16 = !v20;
        if ( !v20 )
          Scr_Error(COM_ERR_3877, scrContext, "2D Actor cannot face (0, 0, *)");
      }
      __asm
      {
        vmovss  xmm0, dword ptr [rbp+vectorValue]
        vucomiss xmm0, xmm6
      }
      if ( v16 )
      {
        __asm
        {
          vmovss  xmm0, dword ptr [rbp+vectorValue+4]
          vucomiss xmm0, xmm6
        }
        if ( v16 )
        {
          __asm
          {
            vmovss  xmm0, dword ptr [rbp+vectorValue+8]
            vucomiss xmm0, xmm6
          }
          if ( v16 )
            Scr_Error(COM_ERR_3878, scrContext, "cannot face (0, 0, 0)");
        }
      }
    }
    v24 = 1;
    NumParam = Scr_GetNumParam(scrContext);
    __asm { vmovaps xmm6, [rsp+70h+var_10] }
    if ( NumParam > 2 )
      v24 = Scr_GetInt(scrContext, 2u) == 0;
    this->OrientMode_FaceDirection(this, &vectorValue, v24);
  }
  else if ( ConstString == scr_const.face_enemy )
  {
    this->OrientMode(this, AI_ORIENT_TO_ENEMY);
  }
  else if ( ConstString == scr_const.face_enemy_or_motion )
  {
    this->OrientMode(this, AI_ORIENT_TO_ENEMY_OR_MOTION);
  }
  else if ( ConstString == scr_const.face_goal )
  {
    this->OrientMode(this, AI_ORIENT_TO_GOAL);
  }
  else if ( ConstString == scr_const.face_motion )
  {
    this->OrientMode(this, AI_ORIENT_TO_MOTION);
  }
  else if ( ConstString == scr_const.face_point )
  {
    Scr_GetVector(scrContext, 1u, &v55);
    this->GetEntity(this);
    __asm
    {
      vmovss  xmm0, dword ptr [rbp+var_28]
      vmovss  xmm2, dword ptr [rbp+var_28+4]
      vsubss  xmm1, xmm0, dword ptr [rax+130h]
      vmovss  dword ptr [rbp+vectorValue], xmm1
      vsubss  xmm0, xmm2, dword ptr [rax+134h]
      vmovss  xmm1, dword ptr [rbp+var_28+8]
      vmovss  dword ptr [rbp+vectorValue+4], xmm0
      vsubss  xmm2, xmm1, dword ptr [rax+138h]
    }
    v33 = this->__vftable;
    __asm
    {
      vmovss  dword ptr [rbp+vectorValue+8], xmm2
      vmovss  xmm0, dword ptr [rbp+vectorValue+4]
      vmovss  xmm1, dword ptr [rbp+vectorValue]
      vmulss  xmm3, xmm0, xmm0
      vmulss  xmm2, xmm1, xmm1
    }
    if ( v33->Is3D(this) )
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rbp+vectorValue+8]
        vmulss  xmm1, xmm0, xmm0
        vaddss  xmm4, xmm3, xmm2
        vaddss  xmm2, xmm4, xmm1
        vcomiss xmm2, cs:__real@3f800000
      }
    }
    else
    {
      __asm
      {
        vaddss  xmm0, xmm3, xmm2
        vcomiss xmm0, cs:__real@3f800000
      }
    }
    this->OrientMode_FaceDirection(this, &vectorValue, 0);
  }
  else if ( ConstString == scr_const.face_default )
  {
    if ( Dvar_GetBool_Internal_DebugName(DVARBOOL_ai_iw7, "ai_iw7") && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 3371, ASSERT_TYPE_ASSERT, "( !Dvar_GetBool_Internal_DebugName( DVARBOOL_ai_iw7, \"ai_iw7\" ) )", "OrientMode face default is not supported with iw7 ai.") )
      __debugbreak();
  }
  else if ( ConstString == scr_const.face_current_angles )
  {
    this->OrientMode(this, AI_ORIENT_CURRENT_ANGLES);
  }
  else
  {
    Scr_Error(COM_ERR_3879, scrContext, "orientMode must be 'face angle', 'face angle 3d', 'face current', 'face direction', 'face enemy', 'face enemy or motion', 'face goal', 'face motion', 'face point', or 'face default'\n'face direction' and 'face point' take a second argument that is a vector giving the way to face\n'face angle' takes a second argument that is a yaw angle\n");
  }
  if ( G_MotionWarp_Active(this->m_pAI->ent->s.number) )
  {
    m_pAI = this->m_pAI;
    if ( m_pAI->ScriptOrient.eMode > (unsigned int)AI_ORIENT_DONT_CHANGE_RELATIVE )
    {
      number = m_pAI->ent->s.number;
      v45 = Ai_Asm::Singleton();
      Instance = Ai_Asm::GetInstance(v45, NULL, number);
      if ( !Instance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 3387, ASSERT_TYPE_ASSERT, "(pInst)", (const char *)&queryFormat, "pInst") )
        __debugbreak();
      State = Common_Asm::Utils::GetState(Instance->m_pASM, Instance->m_CurState);
      v48 = SL_ConvertToString(State->m_Name);
      v49 = j_va("Script OrientMode must be set to face_angles during motionwarp. Current ASM State: %s", v48);
      Scr_Error(COM_ERR_3880, scrContext, v49);
    }
  }
  if ( Scr_GetNumParam(scrContext) > 2 && Scr_GetInt(scrContext, 2u) > 0 )
  {
    if ( this->Is3D(this) )
      Scr_Error(COM_ERR_3881, scrContext, "Invalid OrientMode option used on a 3D actor");
    this->OrientMode_Sync(this);
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_PointInFOV
==============
*/
void AIScriptedInterface::OnScrCmd_PointInFOV(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int v4; 
  vec3_t vectorValue; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  v4 = AICommonInterface::PointInFov(this, &vectorValue);
  Scr_AddInt(scrContext, v4);
}

/*
==============
AIScriptedInterface::OnScrCmd_PreCalcShouldStartArrival
==============
*/
void AIScriptedInterface::OnScrCmd_PreCalcShouldStartArrival(AIScriptedInterface *this, scrContext_t *scrContext)
{
  char v17; 
  AIUnitType unitType; 
  bool v20; 
  bool v21; 
  scr_string_t NearestSpeedThresholdString; 
  vec3_t vFinalGoal; 

  if ( AICommonInterface::HasPath(this) )
  {
    __asm { vmovaps [rsp+68h+var_28], xmm7 }
    AICommonInterface::GetPathFinalGoal(this, &vFinalGoal);
    __asm
    {
      vmovss  xmm0, dword ptr [rsp+68h+vFinalGoal]
      vmovss  xmm1, dword ptr [rsp+68h+vFinalGoal+4]
      vsubss  xmm3, xmm0, dword ptr [rcx+130h]
      vmovss  xmm0, dword ptr [rsp+68h+vFinalGoal+8]
      vsubss  xmm2, xmm1, dword ptr [rcx+134h]
      vsubss  xmm4, xmm0, dword ptr [rcx+138h]
      vmulss  xmm2, xmm2, xmm2
      vmulss  xmm1, xmm3, xmm3
      vmulss  xmm0, xmm4, xmm4
      vaddss  xmm3, xmm2, xmm1
      vaddss  xmm7, xmm3, xmm0
      vcomiss xmm7, cs:__real@47800000
    }
    if ( v20 | v17 )
    {
      AIScriptedInterface::GetDefaultSpeed(this);
      Scr_MakeArray(scrContext);
      _RCX = this->m_pAI;
      unitType = _RCX->unitType;
      if ( unitType == AI_UNITTYPE_SOLDIER || unitType == AI_UNITTYPE_JUGGERNAUT )
      {
        v20 = _RCX->blackboard.m_MoveType < (unsigned int)scr_const.combat;
        v21 = _RCX->blackboard.m_MoveType <= (unsigned int)scr_const.combat;
        if ( _RCX->blackboard.m_MoveType == scr_const.combat )
        {
          __asm
          {
            vmovss  xmm0, dword ptr [rcx+838h]
            vmovss  xmm2, dword ptr [rcx+83Ch]
            vmovss  xmm3, dword ptr [rcx+840h]
            vmulss  xmm1, xmm0, xmm0
            vmulss  xmm0, xmm2, xmm2
            vaddss  xmm2, xmm1, xmm0
            vmulss  xmm1, xmm3, xmm3
            vaddss  xmm2, xmm2, xmm1
            vmovss  xmm1, cs:__real@42800000
            vsqrtss xmm0, xmm7, xmm7
            vcomiss xmm0, xmm1
            vmovaps [rsp+68h+var_18], xmm6
            vsqrtss xmm6, xmm2, xmm2
          }
          if ( !v20 )
          {
            __asm { vcomiss xmm0, cs:__real@42dc0000 }
            if ( v21 )
            {
              __asm
              {
                vsubss  xmm0, xmm0, xmm1
                vmulss  xmm4, xmm0, cs:__real@3cb21643
                vmovss  xmm1, cs:__real@3f800000
                vsubss  xmm2, xmm1, xmm4
                vmulss  xmm3, xmm2, dword ptr [rcx+0D4Ch]
                vmulss  xmm0, xmm4, xmm6
                vaddss  xmm6, xmm3, xmm0
              }
            }
          }
          __asm { vmovaps xmm1, xmm6; value }
          Scr_AddFloat(scrContext, *(float *)&_XMM1);
          Scr_AddArrayStringIndexed(scrContext, scr_const.desiredspeed);
          __asm { vmovaps xmm1, xmm6; desiredSpeed }
          NearestSpeedThresholdString = GetNearestSpeedThresholdString(this->m_pAI->baseArchetype, *(float *)&_XMM1);
          GetAnimSpeedThresholdValue(this->m_pAI->baseArchetype, NearestSpeedThresholdString);
          __asm
          {
            vxorps  xmm1, xmm1, xmm1
            vcvtsi2ss xmm1, xmm1, eax; value
          }
          Scr_AddFloat(scrContext, *(float *)&_XMM1);
          Scr_AddArrayStringIndexed(scrContext, scr_const.targetspeed);
          Scr_AddConstString(scrContext, NearestSpeedThresholdString);
          Scr_AddArrayStringIndexed(scrContext, scr_const.speed);
          __asm { vmovaps xmm6, [rsp+68h+var_18] }
        }
      }
    }
    __asm { vmovaps xmm7, [rsp+68h+var_28] }
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_PushPlayer
==============
*/
void AIScriptedInterface::OnScrCmd_PushPlayer(AIScriptedInterface *this, scrContext_t *scrContext)
{
  AINavigator2D *v4; 
  unsigned int v5; 
  int Int; 
  ai_scripted_t *m_pAI; 
  int iTraceMask; 
  unsigned int v9; 
  sentient_s *v10; 

  v4 = this->m_pAI->pNavigator->Get2DNavigator(this->m_pAI->pNavigator);
  if ( !v4 )
    Scr_Error(COM_ERR_6577, scrContext, "Cannot push player on non-2D navigator");
  v5 = v4->GetObstacleBlockageFlags(v4);
  Int = Scr_GetInt(scrContext, 0);
  m_pAI = this->m_pAI;
  iTraceMask = m_pAI->Physics.iTraceMask;
  if ( Int )
  {
    m_pAI->Physics.iTraceMask = iTraceMask & 0xFDFFFFFF;
    v9 = v5 & 0xFFFFBFFF;
    this->m_pAI->avoidance.pushPlayerEnabled = 1;
LABEL_8:
    v4->SetObstacleBlockageFlags(v4, v9);
    return;
  }
  m_pAI->Physics.iTraceMask = iTraceMask | 0x2000000;
  this->m_pAI->avoidance.pushPlayerEnabled = 0;
  v10 = this->GetSentient(this);
  if ( v10 && v10->eTeam == TEAM_TWO )
  {
    v9 = v5 | 0x4000;
    goto LABEL_8;
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_ReacquireClear
==============
*/
void AIScriptedInterface::OnScrCmd_ReacquireClear(AIScriptedInterface *this, scrContext_t *scrContext)
{
  AIScriptedInterface::SetReacquire(this, AI_REACQUIRE_DISABLED, 2047);
  AIScriptedInterface::ClearBTGoal(this, AI_BT_GOAL_PRIORITY_URGENT);
}

/*
==============
AIScriptedInterface::OnScrCmd_ReacquireMove
==============
*/
void AIScriptedInterface::OnScrCmd_ReacquireMove(AIScriptedInterface *this, scrContext_t *scrContext)
{
  bool started; 

  started = AIScriptedInterface::Behave_StartReacquireMove(this);
  Scr_AddBool(scrContext, started);
}

/*
==============
AIScriptedInterface::OnScrCmd_ReacquireStep
==============
*/
void AIScriptedInterface::OnScrCmd_ReacquireStep(AIScriptedInterface *this, scrContext_t *scrContext)
{
  bool v6; 

  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm { vmovaps xmm1, xmm0; fDist }
  v6 = AIScriptedInterface::Behave_ReacquireStepMove(this, *(float *)&_XMM1);
  Scr_AddBool(scrContext, v6);
}

/*
==============
AIScriptedInterface::OnScrCmd_ResetThreatUpdate
==============
*/
void AIScriptedInterface::OnScrCmd_ResetThreatUpdate(AIScriptedInterface *this, scrContext_t *scrContext)
{
  this->m_pAI->threat.threatUpdateTime = 0;
}

/*
==============
AIScriptedInterface::OnScrCmd_SeeRecently
==============
*/
void AIScriptedInterface::OnScrCmd_SeeRecently(AIScriptedInterface *this, scrContext_t *scrContext)
{
  gentity_s *Entity; 
  int CanSeeEntity; 

  Entity = GScr_GetEntity(0);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 2257, ASSERT_TYPE_ASSERT, "(pOther)", (const char *)&queryFormat, "pOther") )
    __debugbreak();
  if ( Entity->sentient )
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
    __asm
    {
      vmulss  xmm1, xmm0, cs:__real@447a0000
      vcvttss2si r8d, xmm1; latency
    }
    CanSeeEntity = AICommonInterface::RecentlySeeSentient(this, Entity->sentient, _ER8);
  }
  else
  {
    CanSeeEntity = AICommonInterface::CanSeeEntity(this, Entity);
  }
  Scr_AddBool(scrContext, CanSeeEntity);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetAimAngles
==============
*/
void AIScriptedInterface::OnScrCmd_SetAimAngles(AIScriptedInterface *this, scrContext_t *scrContext)
{
  const dvar_t *v3; 
  bool enabled; 
  ai_scripted_t *m_pAI; 
  int Int; 
  vec3_t vectorValue; 
  vec3_t shootFromPos; 
  vec3_t angles; 
  vec3_t v30; 
  ActorAimAngleParam params; 

  v3 = DCONST_DVARBOOL_ai_debugaim;
  if ( !DCONST_DVARBOOL_ai_debugaim && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "ai_debugaim") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v3);
  enabled = v3->current.enabled;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmovss  dword ptr [rbp+57h+vectorValue], xmm0
    vmovss  dword ptr [rbp+57h+vectorValue+4], xmm0
    vmovss  dword ptr [rbp+57h+vectorValue+8], xmm0
  }
  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    Scr_GetVector(scrContext, 0, &vectorValue);
    if ( !enabled )
      goto LABEL_13;
    __asm { vmovsd  xmm0, qword ptr [rbp+57h+vectorValue] }
    angles.v[2] = vectorValue.v[2];
    m_pAI = this->m_pAI;
    __asm { vmovsd  qword ptr [rbp+57h+angles], xmm0 }
    _RCX = m_pAI->ent;
    __asm
    {
      vmovss  xmm0, dword ptr [rcx+130h]
      vmovss  dword ptr [rbp+57h+shootFromPos], xmm0
      vmovss  xmm1, dword ptr [rcx+134h]
      vmovss  dword ptr [rbp+57h+shootFromPos+4], xmm1
      vmovss  xmm0, dword ptr [rcx+138h]
      vaddss  xmm2, xmm0, cs:__real@42700000
      vmovss  dword ptr [rbp+57h+shootFromPos+8], xmm2
    }
  }
  else
  {
    Scr_GetVector(scrContext, 0, &shootFromPos);
    Scr_GetVector(scrContext, 1u, &v30);
    Int = Scr_GetInt(scrContext, 2u);
    Scr_GetVector(scrContext, 3u, &params.angleOffset);
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 4u);
    __asm { vmovss  [rbp+57h+params.stepOutYaw], xmm0 }
    params.useStepoutYaw = Scr_GetInt(scrContext, 5u) != 0;
    params.zeroIfNotInLimits = Scr_GetInt(scrContext, 6u) != 0;
    if ( Int )
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rbp+57h+var_50]
        vsubss  xmm1, xmm0, dword ptr [rbp+57h+shootFromPos]
        vmovss  xmm2, dword ptr [rbp+57h+var_50+4]
        vsubss  xmm0, xmm2, dword ptr [rbp+57h+shootFromPos+4]
        vmovss  dword ptr [rbp+57h+params.shootDir], xmm1
        vmovss  xmm1, dword ptr [rbp+57h+var_50+8]
        vsubss  xmm2, xmm1, dword ptr [rbp+57h+shootFromPos+8]
        vmovss  dword ptr [rbp+57h+params.shootDir+8], xmm2
        vmovss  dword ptr [rbp+57h+params.shootDir+4], xmm0
      }
      AIScriptedInterface::GetDesiredAimAngles(this, &params, &vectorValue);
    }
    else
    {
      AIScriptedInterface::GetAimAnglesForNoShootPos(this, &params, &shootFromPos, &vectorValue);
    }
    __asm
    {
      vmovsd  xmm0, qword ptr [rbp+57h+vectorValue]
      vmovsd  qword ptr [rbp+57h+angles], xmm0
    }
    angles.v[2] = vectorValue.v[2];
    AIScriptedInterface::ClampAimAngles(this, params.zeroIfNotInLimits, &vectorValue);
  }
  if ( enabled )
    AI_DrawSetAngleCalc(&this->m_pAI->ent->r.currentOrigin, &this->m_pAI->ent->r.currentAngles, &shootFromPos, &angles, &vectorValue);
LABEL_13:
  __asm { vmovss  xmm0, dword ptr [rbp+57h+vectorValue] }
  _RAX = this->m_pAI;
  __asm
  {
    vmovss  dword ptr [rax+474h], xmm0
    vmovss  xmm1, dword ptr [rbp+57h+vectorValue+4]
    vmovss  dword ptr [rax+478h], xmm1
    vmovss  xmm0, dword ptr [rbp+57h+vectorValue+8]
    vmovss  dword ptr [rax+47Ch], xmm0
  }
  Scr_AddVector(scrContext, vectorValue.v);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetBTGoalEnt
==============
*/
void AIScriptedInterface::OnScrCmd_SetBTGoalEnt(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int Int; 
  gentity_s *Entity; 

  Int = Scr_GetInt(scrContext, 0);
  if ( Int >= 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 1162, ASSERT_TYPE_ASSERT, "(priority < AI_BT_GOAL_PRIORITY_COUNT)", (const char *)&queryFormat, "priority < AI_BT_GOAL_PRIORITY_COUNT") )
    __debugbreak();
  Entity = GScr_GetEntity(1u);
  AIScriptedInterface::SetBTGoalEnt(this, (ai_bt_goal_priority_t)Int, Entity);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetBTGoalHeight
==============
*/
void AIScriptedInterface::OnScrCmd_SetBTGoalHeight(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int Int; 
  __int64 v6; 

  Int = Scr_GetInt(scrContext, 0);
  v6 = Int;
  if ( Int >= 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 1260, ASSERT_TYPE_ASSERT, "(priority < AI_BT_GOAL_PRIORITY_COUNT)", (const char *)&queryFormat, "priority < AI_BT_GOAL_PRIORITY_COUNT") )
    __debugbreak();
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  _RAX = this->m_pAI;
  _RCX = 56 * v6;
  __asm { vmovss  dword ptr [rcx+rax+2D0h], xmm0 }
}

/*
==============
AIScriptedInterface::OnScrCmd_SetBTGoalNode
==============
*/
void AIScriptedInterface::OnScrCmd_SetBTGoalNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int Int; 
  pathnode_t *Pathnode; 

  Int = Scr_GetInt(scrContext, 0);
  if ( Int >= 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 1140, ASSERT_TYPE_ASSERT, "(priority < AI_BT_GOAL_PRIORITY_COUNT)", (const char *)&queryFormat, "priority < AI_BT_GOAL_PRIORITY_COUNT") )
    __debugbreak();
  Pathnode = Scr_GetPathnode(scrContext, 1u);
  AIScriptedInterface::SetBTGoalNode(this, (ai_bt_goal_priority_t)Int, Pathnode);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetBTGoalPos
==============
*/
void AIScriptedInterface::OnScrCmd_SetBTGoalPos(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int Int; 
  vec3_t vectorValue; 

  Int = Scr_GetInt(scrContext, 0);
  if ( Int >= 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 1117, ASSERT_TYPE_ASSERT, "(priority < AI_BT_GOAL_PRIORITY_COUNT)", (const char *)&queryFormat, "priority < AI_BT_GOAL_PRIORITY_COUNT") )
    __debugbreak();
  Scr_GetVector(scrContext, 1u, &vectorValue);
  AIScriptedInterface::SetBTGoalPos(this, (ai_bt_goal_priority_t)Int, &vectorValue);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetBTGoalRadius
==============
*/
void AIScriptedInterface::OnScrCmd_SetBTGoalRadius(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int Int; 

  Int = Scr_GetInt(scrContext, 0);
  if ( Int >= 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 1237, ASSERT_TYPE_ASSERT, "(priority < AI_BT_GOAL_PRIORITY_COUNT)", (const char *)&queryFormat, "priority < AI_BT_GOAL_PRIORITY_COUNT") )
    __debugbreak();
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm { vmovaps xmm2, xmm0; radius }
  AIScriptedInterface::SetBTGoalRadius(this, (ai_bt_goal_priority_t)Int, *(float *)&_XMM2);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetBTGoalVolume
==============
*/
void AIScriptedInterface::OnScrCmd_SetBTGoalVolume(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int Int; 
  __int64 v5; 
  gentity_s *Entity; 

  Int = Scr_GetInt(scrContext, 0);
  v5 = Int;
  if ( Int >= 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 1187, ASSERT_TYPE_ASSERT, "(priority < AI_BT_GOAL_PRIORITY_COUNT)", (const char *)&queryFormat, "priority < AI_BT_GOAL_PRIORITY_COUNT") )
    __debugbreak();
  Entity = GScr_GetEntity(1u);
  if ( EntHandle::isDefined(&this->m_pAI->btGoals[v5].hEnt) )
    Scr_Error(COM_ERR_3827, scrContext, "cannot set goal volume when a goal entity is set");
  AIScriptedInterface::SetBTGoalVolume(this, (ai_bt_goal_priority_t)v5, Entity);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetBackupCoverFromPos
==============
*/
void AIScriptedInterface::OnScrCmd_SetBackupCoverFromPos(AIScriptedInterface *this, scrContext_t *scrContext)
{
  if ( Scr_GetNumParam(scrContext) && Scr_GetType(scrContext, 0) )
  {
    Scr_GetVector(scrContext, 0, &this->m_pAI->backupCoverFromPos);
    this->m_pAI->bUseBackupCoverFromPos = 1;
  }
  else
  {
    this->m_pAI->bUseBackupCoverFromPos = 0;
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_SetBaseArchetype
==============
*/
void AIScriptedInterface::OnScrCmd_SetBaseArchetype(AIScriptedInterface *this, scrContext_t *scrContext)
{
  scr_string_t ConstString; 

  ConstString = Scr_GetConstString(scrContext, 0);
  AIScriptedInterface::SetBaseOverrideArchetype(this, ConstString);
}

/*
==============
AICommonInterface::OnScrCmd_SetC8ObstacleFlag
==============
*/
void AICommonInterface::OnScrCmd_SetC8ObstacleFlag(AICommonInterface *this, scrContext_t *scrContext)
{
  ai_common_t *m_pAI; 
  __int64 v5; 
  bool v6; 
  int v7; 
  unsigned int v8; 

  m_pAI = this->m_pAI;
  if ( m_pAI->ent->actor )
  {
    Scr_Error(COM_ERR_3864, scrContext, "SetC8ObstacleFlag - doesn't apply to actors.  C8s should use their own nav layer and have obstacles applied to those layers.");
    m_pAI = this->m_pAI;
  }
  v5 = (__int64)m_pAI->pNavigator->Get2DNavigator(m_pAI->pNavigator);
  if ( !v5 )
    Scr_Error(COM_ERR_3865, scrContext, "SetC8ObstacleFlag - only applies to 2D navigators.");
  v6 = 1;
  v7 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 104i64))(v5);
  if ( Scr_GetNumParam(scrContext) )
    v6 = Scr_GetInt(scrContext, 0) != 0;
  if ( v6 )
    v8 = v7 | 0x1000;
  else
    v8 = v7 & 0xFFFFEFFF;
  (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v5 + 112i64))(v5, v8);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetCoverSelectionFocusEnt
==============
*/
void AIScriptedInterface::OnScrCmd_SetCoverSelectionFocusEnt(AIScriptedInterface *this, scrContext_t *scrContext)
{
  ai_scripted_t *m_pAI; 
  const gentity_s *Entity; 

  m_pAI = this->m_pAI;
  Entity = GScr_GetEntity(0);
  EntHandle::setEnt(&m_pAI->coverSelectionFocusEnt, Entity);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetDefaultAimLimits
==============
*/
void AIScriptedInterface::OnScrCmd_SetDefaultAimLimits(AIScriptedInterface *this, scrContext_t *scrContext)
{
  const pathnode_t *Pathnode; 

  Pathnode = NULL;
  if ( Scr_GetNumParam(scrContext) )
    Pathnode = Scr_GetPathnode(scrContext, 0);
  AIScriptedInterface::Cover_SetAimLimits(this, Pathnode);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetDesiredSpeed
==============
*/
void AIScriptedInterface::OnScrCmd_SetDesiredSpeed(AIScriptedInterface *this, scrContext_t *scrContext)
{
  char v8; 
  char v9; 
  const char *v15; 
  const char *v18; 

  __asm
  {
    vmovaps [rsp+48h+var_18], xmm6
    vmovaps [rsp+48h+var_28], xmm7
  }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm
  {
    vxorps  xmm1, xmm1, xmm1
    vcomiss xmm0, xmm1
    vmovaps xmm6, xmm0
    vcvtss2sd xmm7, xmm6, xmm0
  }
  if ( v8 )
  {
    __asm
    {
      vmovaps xmm1, xmm7
      vmovq   rdx, xmm1
    }
    v15 = j_va("AISetDesiredSpeed: speed cannot be negative. (%.2f)", _RDX);
    Scr_Error(COM_ERR_3869, scrContext, v15);
  }
  __asm { vcomiss xmm6, cs:__real@43960000 }
  if ( !(v8 | v9) )
  {
    __asm
    {
      vmovaps xmm1, xmm7
      vmovq   rdx, xmm1
    }
    v18 = j_va("AISetDesiredSpeed: speed way larger than anything we were expecting: %.2f", _RDX);
    Scr_Error(COM_ERR_3870, scrContext, v18);
  }
  _RAX = this->m_pAI;
  __asm
  {
    vmovaps xmm7, [rsp+48h+var_28]
    vmovss  dword ptr [rax+0B48h], xmm6
    vmovaps xmm6, [rsp+48h+var_18]
  }
  this->m_pAI->script_desiredSpeedEnabled = 1;
}

/*
==============
AIScriptedInterface::OnScrCmd_SetEngagementMaxDist
==============
*/
void AIScriptedInterface::OnScrCmd_SetEngagementMaxDist(AIScriptedInterface *this, scrContext_t *scrContext)
{
  char v10; 
  const char *v15; 

  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  _RAX = this->m_pAI;
  __asm { vmovss  dword ptr [rax+518h], xmm0 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  _RAX = this->m_pAI;
  __asm { vmovss  dword ptr [rax+51Ch], xmm0 }
  _RAX = this->m_pAI;
  __asm
  {
    vmovss  xmm1, dword ptr [rax+51Ch]
    vmovss  xmm0, dword ptr [rax+518h]
    vcomiss xmm1, xmm0
  }
  if ( v10 )
  {
    __asm
    {
      vcvtss2sd xmm2, xmm1, xmm1
      vcvtss2sd xmm1, xmm0, xmm0
      vmovq   rdx, xmm1
      vmovq   r8, xmm2
    }
    v15 = j_va("Max dist falloff must be >= max dist. [%f > %f]", _RDX, _R8);
    Scr_Error(COM_ERR_3896, scrContext, v15);
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_SetEngagementMinDist
==============
*/
void AIScriptedInterface::OnScrCmd_SetEngagementMinDist(AIScriptedInterface *this, scrContext_t *scrContext)
{
  char v10; 
  char v11; 
  const char *v16; 

  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  _RAX = this->m_pAI;
  __asm { vmovss  dword ptr [rax+510h], xmm0 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  _RAX = this->m_pAI;
  __asm { vmovss  dword ptr [rax+514h], xmm0 }
  _RAX = this->m_pAI;
  __asm
  {
    vmovss  xmm1, dword ptr [rax+514h]
    vmovss  xmm0, dword ptr [rax+510h]
    vcomiss xmm1, xmm0
  }
  if ( !(v10 | v11) )
  {
    __asm
    {
      vcvtss2sd xmm2, xmm1, xmm1
      vcvtss2sd xmm1, xmm0, xmm0
      vmovq   rdx, xmm1
      vmovq   r8, xmm2
    }
    v16 = j_va("Min dist falloff must be <= min dist. [%f < %f]", _RDX, _R8);
    Scr_Error(COM_ERR_3895, scrContext, v16);
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_SetEntityTarget
==============
*/
void AIScriptedInterface::OnScrCmd_SetEntityTarget(AIScriptedInterface *this, scrContext_t *scrContext)
{
  gentity_s *Entity; 
  char v11; 
  char v12; 
  gentity_s *v16; 
  const char *v17; 

  Entity = GScr_GetEntity(0);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 4976, ASSERT_TYPE_ASSERT, "(targetEnt)", (const char *)&queryFormat, "targetEnt") )
    __debugbreak();
  if ( Entity->sentient )
    Scr_Error(COM_ERR_3898, scrContext, "Do not use setentitytarget to set an AI or player as a target");
  _RBX = this->GetSentient(this);
  if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 4983, ASSERT_TYPE_ASSERT, "(sentient)", (const char *)&queryFormat, "sentient") )
    __debugbreak();
  EntHandle::setEnt(&_RBX->scriptTargetEnt, Entity);
  _RBX->scriptTargetHasTagEye = SV_Game_DObjGetBoneIndex(Entity, scr_const.tag_eye) >= 0;
  if ( Scr_GetNumParam(scrContext) <= 1 )
  {
    _RBX->entityTargetThreat = 1.0;
LABEL_16:
    Sentient_SetEnemy(_RBX, Entity, 1, 1);
    return;
  }
  __asm
  {
    vmovaps [rsp+68h+var_18], xmm6
    vmovaps [rsp+68h+var_28], xmm7
    vmovaps [rsp+68h+var_38], xmm8
  }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm
  {
    vmovss  xmm7, cs:__real@3f800000
    vxorps  xmm8, xmm8, xmm8
    vcomiss xmm0, xmm8
    vmovaps xmm6, xmm0
  }
  if ( v11 | v12 )
    goto LABEL_12;
  __asm { vcomiss xmm0, xmm7 }
  if ( !(v11 | v12) )
  {
LABEL_12:
    v16 = this->GetEntity(this);
    v17 = j_va("Threat fraction must be in (0, 1] for AI %d", (unsigned int)v16->s.number);
    Scr_Error(COM_ERR_3899, scrContext, v17);
    __asm
    {
      vmovaps xmm2, xmm7; max
      vxorps  xmm1, xmm1, xmm1; min
      vmovaps xmm0, xmm6; val
    }
    *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
    __asm { vmovaps xmm6, xmm0 }
  }
  __asm
  {
    vmovss  dword ptr [rbx+50h], xmm6
    vmovaps xmm8, [rsp+68h+var_38]
    vucomiss xmm6, xmm7
    vmovaps xmm7, [rsp+68h+var_28]
    vmovaps xmm6, [rsp+68h+var_18]
  }
  if ( v12 )
    goto LABEL_16;
}

/*
==============
AIScriptedInterface::OnScrCmd_SetFacialIndex
==============
*/
void AIScriptedInterface::OnScrCmd_SetFacialIndex(AIScriptedInterface *this, scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  unsigned __int8 v5; 
  const char *String; 
  const char *v7; 

  ConstString = Scr_GetConstString(scrContext, 0);
  v5 = AI_StringToFacialIndex(ConstString);
  if ( v5 == 12 )
  {
    String = Scr_GetString(scrContext, 0);
    v7 = j_va("Unknown facial state %s", String);
    Scr_Error(COM_ERR_5691, scrContext, v7);
  }
  this->m_pAI->animData.facialIndex = v5;
}

/*
==============
AIScriptedInterface::OnScrCmd_SetFacialIndexFromASM
==============
*/
void AIScriptedInterface::OnScrCmd_SetFacialIndexFromASM(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int number; 
  Ai_Asm *v5; 
  ASM_Instance *Instance; 
  const char *v7; 
  scr_string_t ConstString; 
  scr_string_t v9; 
  scr_string_t AnimsetName; 
  Animset *v11; 
  const char *name; 
  const char *String; 
  const char *v14; 
  int Int; 
  DObj *ServerDObjForEnt; 
  unsigned __int16 index; 
  __int64 v18; 
  unsigned int numAnimAliases; 
  AnimsetAlias *animAliases; 
  __int64 v21; 
  unsigned int numAnims; 
  const char *v23; 
  const char *v24; 
  const char *v25; 
  int pOutStateIndex; 
  AnimsetState *outState; 

  number = this->m_pAI->ent->s.number;
  v5 = Ai_Asm::Singleton();
  Instance = Ai_Asm::GetInstance(v5, NULL, number);
  if ( !Instance )
  {
    v7 = j_va("ent %d is not running an asm!", (unsigned int)this->m_pAI->ent->s.number);
    Scr_Error(COM_ERR_6494, scrContext, v7);
  }
  ConstString = Scr_GetConstString(scrContext, 0);
  v9 = Scr_GetConstString(scrContext, 1u);
  if ( !Instance->m_pASM && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 4729, ASSERT_TYPE_ASSERT, "( pInst->m_pASM )", (const char *)&queryFormat, "pInst->m_pASM") )
    __debugbreak();
  if ( Instance->m_pASM->m_Name == ConstString )
  {
    AnimsetName = BG_AnimationState_GetAnimsetName((const entityState_t *)this->m_pAI->ent);
    v11 = Animset_Find(AnimsetName);
    if ( !v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 4735, ASSERT_TYPE_ASSERT, "( pAnimset )", (const char *)&queryFormat, "pAnimset") )
      __debugbreak();
    outState = NULL;
    if ( !BG_Animset_GetStateInfoByName(v11, v9, &outState, &pOutStateIndex) )
    {
      name = v11->name;
      String = Scr_GetString(scrContext, 1u);
      v14 = j_va("Unable to find state %s in animset %s", String, name);
      Scr_Error(COM_ERR_6495, scrContext, v14);
    }
    if ( Scr_GetType(scrContext, 2u) )
    {
      if ( Scr_GetType(scrContext, 2u) == VAR_INTEGER )
      {
        Int = Scr_GetInt(scrContext, 2u);
      }
      else
      {
        ServerDObjForEnt = Com_GetServerDObjForEnt(this->m_pAI->ent);
        if ( !ServerDObjForEnt && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 4754, ASSERT_TYPE_ASSERT, "(obj)", (const char *)&queryFormat, "obj") )
          __debugbreak();
        index = Scr_GetAnim(scrContext, 2u, ServerDObjForEnt->tree).index;
        Int = 0;
        v18 = 0i64;
        numAnimAliases = outState->numAnimAliases;
        if ( numAnimAliases )
        {
          animAliases = outState->animAliases;
          while ( 1 )
          {
            v21 = 0i64;
            numAnims = animAliases[v18].numAnims;
            if ( numAnims )
              break;
LABEL_24:
            v18 = (unsigned int)(v18 + 1);
            if ( (unsigned int)v18 >= numAnimAliases )
              goto LABEL_25;
          }
          while ( animAliases[v18].anims[v21].anim.index != index )
          {
            ++Int;
            v21 = (unsigned int)(v21 + 1);
            if ( (unsigned int)v21 >= numAnims )
              goto LABEL_24;
          }
        }
        else
        {
LABEL_25:
          v23 = v11->name;
          v24 = Scr_GetString(scrContext, 1u);
          v25 = j_va("Unable to find anim in state %s in animset %s", v24, v23);
          Scr_Error(COM_ERR_6496, scrContext, v25);
        }
      }
    }
    else
    {
      Int = -1;
    }
    AIScriptedInterface::SetFacialIndexFromASM(this, Instance, v11, pOutStateIndex, Int);
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_SetFixedNodeSafeVolume
==============
*/
void AIScriptedInterface::OnScrCmd_SetFixedNodeSafeVolume(AIScriptedInterface *this, scrContext_t *scrContext)
{
  _RBX = GScr_GetEntity(0);
  EntHandle::setEnt(&this->m_pAI->fixedNodeSafeVolume, _RBX);
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+100h]
    vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vaddss  xmm2, xmm0, dword ptr [rbx+10Ch]
    vmovss  xmm0, dword ptr [rbx+104h]
    vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vaddss  xmm1, xmm0, dword ptr [rbx+110h]
  }
  _RAX = this->m_pAI;
  __asm
  {
    vmulss  xmm0, xmm1, xmm1
    vmulss  xmm2, xmm2, xmm2
    vaddss  xmm3, xmm2, xmm0
    vmovss  dword ptr [rax+5F4h], xmm3
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_SetFlashBanged
==============
*/
void AIScriptedInterface::OnScrCmd_SetFlashBanged(AIScriptedInterface *this, scrContext_t *scrContext)
{
  int Int; 

  Int = Scr_GetInt(scrContext, 0);
  AIScriptedInterface::SetFlashed(this, Int == 1);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetGoalEntity
==============
*/
void AIScriptedInterface::OnScrCmd_SetGoalEntity(AIScriptedInterface *this, scrContext_t *scrContext)
{
  gentity_s *Entity; 

  Entity = GScr_GetEntity(0);
  this->ClearKeepClaimedNode(this);
  AIScriptedInterface::SetScriptGoalEntity(this, Entity);
  if ( Scr_GetNumParam(scrContext) > 1 )
    this->m_pAI->scriptGoal.entUpdateInterval = Scr_GetInt(scrContext, 1u);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetGoalNode
==============
*/
void AIScriptedInterface::OnScrCmd_SetGoalNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  pathnode_t *Pathnode; 
  const char *v5; 
  gentity_s *v6; 
  const char *v7; 
  vec3_t pos; 

  Pathnode = Scr_GetPathnode(scrContext, 0);
  pathnode_t::GetPos(Pathnode, &pos);
  if ( !AIScriptedInterface::SetScriptGoalPos(this, &pos, Pathnode) )
  {
    v5 = vtos(&pos);
    v6 = this->GetEntity(this);
    v7 = j_va("SetGoalNode( ent %d, node pos %s ) : Unable to find navmesh in this area.  Either no mesh is loaded, or this is a moving platform where all of the mesh has been invalidated due to an obstacle.", (unsigned int)v6->s.number, v5);
    Scr_Error(COM_ERR_3842, scrContext, v7);
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_SetGoalPath
==============
*/
void AIScriptedInterface::OnScrCmd_SetGoalPath(AIScriptedInterface *this, scrContext_t *scrContext)
{
  AIScriptedInterface *v3; 
  pathnode_t *NodeFromEntref; 
  unsigned int ArrayObject; 
  int ArraySize; 
  int v8; 
  const char *v9; 
  int v10; 
  unsigned int LastSibling; 
  int v16; 
  unsigned int Object; 
  const char *v18; 
  const char *v19; 
  scr_entref_t EntityIdRef; 
  const char *v21; 
  AINavigator *pNavigator; 
  bool v23; 
  vec3_t *p_origin; 
  __int64 v27; 
  const char *v34; 
  const char *v35; 
  bool v36; 
  VariableValue out; 
  AIScriptedInterface *v39; 
  vec3_t origin; 
  char v41; 

  v3 = this;
  v39 = this;
  NodeFromEntref = NULL;
  ArrayObject = BGScr_Main_GetArrayObject(scrContext, 0);
  ArraySize = GetArraySize(scrContext, ArrayObject);
  v8 = ArraySize;
  if ( ArraySize > 16 )
  {
    v9 = j_va("SetGoalPath: %d exceeds max allowed scripted path points (%d)", (unsigned int)ArraySize, 16i64);
    Scr_Error(COM_ERR_3844, scrContext, v9);
  }
  v10 = 0;
  AddRefToObject(scrContext, ArrayObject);
  Scr_ClearOutParams(scrContext);
  LastSibling = FindLastSibling(scrContext, ArrayObject);
  if ( LastSibling )
  {
    _R14 = &origin.v[2];
    do
    {
      Scr_EvalVariable_Out(scrContext, LastSibling, &out);
      if ( out.type == VAR_VECTOR )
      {
        _R8 = out.u;
        __asm
        {
          vmovss  xmm1, dword ptr [r8+8]
          vmovss  xmm0, dword ptr [r8+4]
        }
        v16 = *(_DWORD *)out.u.vectorValue;
        __asm
        {
          vmovss  dword ptr [r14-4], xmm0
          vmovss  dword ptr [r14], xmm1
        }
        *((_DWORD *)_R14 - 2) = v16;
        RemoveRefToValue(scrContext, 4, _R8);
      }
      else if ( out.type == VAR_POINTER )
      {
        Object = FindObject(scrContext, LastSibling);
        if ( !Object )
        {
          RemoveRefToValue(scrContext, (unsigned __int8)out.type, out.u);
          RemoveRefToObject(scrContext, ArrayObject);
          v18 = j_va("SetGoalPath: Invalid object %d in array.", (unsigned int)v10);
          Scr_Error(COM_ERR_3845, scrContext, v18);
        }
        if ( !Scr_GetObjectOrigin(scrContext, Object, &origin + v10) )
        {
          RemoveRefToValue(scrContext, (unsigned __int8)out.type, out.u);
          RemoveRefToObject(scrContext, ArrayObject);
          v19 = j_va("SetGoalPath: Unable to find origin vector in object %d in array.", (unsigned int)v10);
          Scr_Error(COM_ERR_3846, scrContext, v19);
        }
        if ( v10 == v8 - 1 && GetObjectType(scrContext, Object) == VAR_ENTITY )
        {
          EntityIdRef = Scr_GetEntityIdRef(scrContext, Object);
          if ( EntityIdRef.entclass == ENTITY_CLASS_PATHNODE )
            NodeFromEntref = Path_GetNodeFromEntref(scrContext, EntityIdRef);
        }
        RemoveRefToValue(scrContext, (unsigned __int8)out.type, out.u);
      }
      else
      {
        RemoveRefToValue(scrContext, (unsigned __int8)out.type, out.u);
        RemoveRefToObject(scrContext, ArrayObject);
        v21 = j_va("SetGoalPath: array element %d is not a vector.", (unsigned int)v10);
        Scr_Error(COM_ERR_3847, scrContext, v21);
      }
      ++v10;
      _R14 += 3;
      LastSibling = FindPrevSibling(scrContext, LastSibling);
    }
    while ( LastSibling );
    v3 = v39;
  }
  RemoveRefToObject(scrContext, ArrayObject);
  if ( !v10 )
    Scr_Error(COM_ERR_3848, scrContext, "SetGoalPath: no path points provided.");
  pNavigator = v3->m_pAI->pNavigator;
  if ( !pNavigator || pNavigator->Get3DNavigator(pNavigator) )
    Scr_Error(COM_ERR_3849, scrContext, "SetGoalPath called on ent with invalid/unsupported navigator type.");
  if ( v10 > 1 )
  {
    v23 = v10 == 1;
    if ( v10 - 1 > 0 )
    {
      __asm { vmovaps [rsp+158h+var_48], xmm6 }
      p_origin = &origin;
      __asm { vmovss  xmm6, cs:__real@358637be }
      _RDI = &v41;
      v27 = (unsigned int)(v10 - 1);
      do
      {
        __asm
        {
          vmovss  xmm0, dword ptr [rdi-0Ch]
          vsubss  xmm1, xmm0, dword ptr [rdi]
          vmulss  xmm2, xmm1, xmm1
          vcomiss xmm2, xmm6
        }
        if ( v23 )
        {
          __asm
          {
            vmovss  xmm0, dword ptr [rdi-8]
            vsubss  xmm1, xmm0, dword ptr [rdi+4]
            vmulss  xmm2, xmm1, xmm1
            vcomiss xmm2, xmm6
          }
          if ( v23 )
          {
            v34 = vtos(p_origin);
            v35 = j_va("SetGoalPath called with duplicated path point %s", v34);
            Scr_Error(COM_ERR_3850, scrContext, v35);
          }
        }
        ++p_origin;
        _RDI += 12;
        v36 = v27-- == 0;
        v23 = v36 || v27 == 0;
      }
      while ( v27 );
      v3 = v39;
      __asm { vmovaps xmm6, [rsp+158h+var_48] }
    }
  }
  AIScriptedInterface::SetScriptGoalPath(v3, &origin, v10);
  if ( NodeFromEntref )
  {
    v3->m_pAI->nodeSelect.keepClaimedNode = 0;
    v3->m_pAI->scriptGoal.node = NodeFromEntref;
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_SetGoalPos
==============
*/
void AIScriptedInterface::OnScrCmd_SetGoalPos(AIScriptedInterface *this, scrContext_t *scrContext)
{
  const char *v4; 
  gentity_s *v5; 
  const char *v6; 
  vec3_t vectorValue; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  if ( !AIScriptedInterface::SetScriptGoalPos(this, &vectorValue, NULL) )
  {
    v4 = vtos(&vectorValue);
    v5 = this->GetEntity(this);
    v6 = j_va("SetGoalPos( ent %d, pos %s ) : Unable to find navmesh at this position.  Either there is no mesh loaded, or this is a moving platform where the whole mesh has been invalidated by an obstacle.", (unsigned int)v5->s.number, v4);
    Scr_Error(COM_ERR_3843, scrContext, v6);
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_SetGoalVolume
==============
*/
void AIScriptedInterface::OnScrCmd_SetGoalVolume(AIScriptedInterface *this, scrContext_t *scrContext)
{
  const char *v4; 
  ai_scripted_t *m_pAI; 
  gentity_s *Entity; 
  unsigned int Instance; 
  const char *v8; 
  unsigned int number; 
  const char *v10; 
  const char *v11; 

  if ( EntHandle::isDefined(&this->m_pAI->scriptGoal.hEnt) )
  {
    v4 = j_va("Cannot set goal volume when a goal entity is set. AI: %d", (unsigned int)this->m_pAI->ent->s.number);
    Scr_Error(COM_ERR_3851, scrContext, v4);
  }
  m_pAI = this->m_pAI;
  if ( m_pAI->fixedNode )
    Com_PrintError(18, "Setting goal volume for fixed node AI: %d\n", (unsigned int)m_pAI->ent->s.number);
  Entity = GScr_GetEntity(0);
  Instance = G_PhysicsObject_GetInstance(PHYSICS_WORLD_ID_FIRST, Entity);
  if ( !PhysicsQuery_LegacyEntityContactPoint(PHYSICS_WORLD_ID_FIRST, &this->m_pAI->scriptGoal.pos, Instance, Entity) )
  {
    v8 = vtos(&this->m_pAI->scriptGoal.pos);
    number = this->m_pAI->ent->s.number;
    v10 = vtos(&Entity->r.currentOrigin);
    v11 = j_va("Cannot set goal volume (%s) on AI %d which does not contain goal position %s.", v10, number, v8);
    Scr_Error(COM_ERR_3852, scrContext, v11);
  }
  this->ClearKeepClaimedNode(this);
  AIScriptedInterface::SetScriptGoalVolume(this, Entity);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetGoalVolumeAuto
==============
*/
void AIScriptedInterface::OnScrCmd_SetGoalVolumeAuto(AIScriptedInterface *this, scrContext_t *scrContext)
{
  const char *v6; 
  const char *v7; 
  pathnode_t *BestCover; 
  pathnode_t *v54; 
  float outBestScore; 
  vec3_t vectorValue; 
  CoverNodeMetricParams metricParams; 

  if ( EntHandle::isDefined(&this->m_pAI->scriptGoal.hEnt) )
    Scr_Error(COM_ERR_3853, scrContext, "cannot set goal volume when a goal entity is set");
  _RSI = GScr_GetEntity(0);
  EntHandle::setEnt(&this->m_pAI->scriptGoal.hVolume, NULL);
  if ( !Scr_IsTouchingInternal(scrContext, this->m_pAI->ent, _RSI) )
    this->ClearKeepClaimedNode(this);
  if ( !AIScriptedInterface::SetScriptGoalPos(this, &_RSI->r.absBox.midPoint, NULL) )
  {
    v6 = vtos(&_RSI->r.absBox.midPoint);
    v7 = j_va("SetGoalVolumeAuto( ent %d, vol midpt %s ): Unable to find navmesh at this position.  Either no mesh is loaded, or this is a moving platform that has had all of its mesh invalidated.", (unsigned int)this->m_pAI->ent->s.number, v6);
    Scr_Error(COM_ERR_3854, scrContext, v7);
  }
  __asm
  {
    vmovss  xmm1, dword ptr [rsi+128h]
    vmovss  xmm0, dword ptr [rsi+124h]
  }
  _RAX = this->m_pAI;
  __asm
  {
    vmulss  xmm2, xmm0, xmm0
    vmulss  xmm1, xmm1, xmm1
    vaddss  xmm2, xmm2, xmm1
    vsqrtss xmm0, xmm2, xmm2
    vaddss  xmm3, xmm0, cs:__real@41700000
    vmaxss  xmm1, xmm3, cs:__real@42800000
    vmovss  dword ptr [rax+294h], xmm1
    vmovss  xmm0, dword ptr [rsi+12Ch]
  }
  _RAX = this->m_pAI;
  __asm
  {
    vaddss  xmm2, xmm0, cs:__real@42100000
    vmovss  dword ptr [rax+298h], xmm2
  }
  AIScriptedInterface::SetScriptGoalVolume(this, _RSI);
  if ( !AICommonInterface::GetTargetEntity(this) && Scr_GetNumParam(scrContext) > 1 && Scr_GetType(scrContext, 1u) )
  {
    if ( Scr_GetType(scrContext, 1u) == VAR_VECTOR )
    {
      __asm { vmovaps [rsp+0D8h+var_28], xmm6 }
      Scr_GetVector(scrContext, 1u, &vectorValue);
      __asm
      {
        vmovss  xmm5, dword ptr [rsp+0D8h+vectorValue]
        vmovss  xmm6, dword ptr [rsp+0D8h+vectorValue+4]
        vmovss  xmm4, dword ptr [rsp+0D8h+vectorValue+8]
        vmulss  xmm1, xmm5, xmm5
        vmulss  xmm0, xmm6, xmm6
        vaddss  xmm2, xmm1, xmm0
        vmulss  xmm1, xmm4, xmm4
        vaddss  xmm0, xmm2, xmm1
        vmovss  xmm1, cs:__real@3f800000
        vsqrtss xmm3, xmm0, xmm0
        vcmpless xmm0, xmm3, cs:__real@80000000
        vblendvps xmm0, xmm3, xmm1, xmm0
        vdivss  xmm2, xmm1, xmm0
        vmulss  xmm0, xmm5, xmm2
        vmovss  dword ptr [rsp+0D8h+vectorValue], xmm0
        vmulss  xmm0, xmm4, xmm2
        vmulss  xmm1, xmm6, xmm2
        vmovss  dword ptr [rsp+0D8h+vectorValue+8], xmm0
        vmovss  dword ptr [rsp+0D8h+vectorValue+4], xmm1
      }
      AIScriptedInterface::GetCoverNodeMetricParams(this, &metricParams);
      __asm
      {
        vmovss  xmm0, dword ptr [rsi+124h]
        vmovss  xmm2, dword ptr [rsi+128h]
        vmovss  xmm3, dword ptr [rsi+12Ch]
        vmulss  xmm1, xmm0, xmm0
        vmulss  xmm0, xmm2, xmm2
        vaddss  xmm2, xmm1, xmm0
        vmulss  xmm1, xmm3, xmm3
        vaddss  xmm2, xmm2, xmm1
        vsqrtss xmm0, xmm2, xmm2
        vmulss  xmm3, xmm0, cs:__real@40800000
        vmulss  xmm0, xmm3, dword ptr [rsp+0D8h+vectorValue]
        vaddss  xmm2, xmm0, dword ptr [rsi+130h]
        vmulss  xmm0, xmm3, dword ptr [rsp+0D8h+vectorValue+4]
        vmovss  dword ptr [rsp+0D8h+metricParams.lastKnownEnemyOrigin], xmm2
        vaddss  xmm2, xmm0, dword ptr [rsi+134h]
        vmulss  xmm0, xmm3, dword ptr [rsp+0D8h+vectorValue+8]
        vmovss  dword ptr [rsp+0D8h+metricParams.lastKnownEnemyOrigin+4], xmm2
        vaddss  xmm2, xmm0, dword ptr [rsi+138h]
      }
      metricParams.lastKnownValid = 1;
      __asm { vmovss  dword ptr [rsp+0D8h+metricParams.lastKnownEnemyOrigin+8], xmm2 }
      AIScriptedInterface::UpdateGoalPos(this);
      BestCover = AIScriptedInterface::Cover_FindBestCover(this, (scr_string_t)0, 0, 0, &metricParams, &outBestScore);
      __asm { vmovaps xmm6, [rsp+0D8h+var_28] }
      v54 = BestCover;
      if ( BestCover )
      {
        if ( BestCover != this->m_pAI->sentient->pClaimedNode )
        {
          this->ClearKeepClaimedNode(this);
          AIScriptedInterface::Cover_UseCoverNode(this, v54);
        }
      }
    }
    else
    {
      Scr_Error(COM_ERR_3855, scrContext, "SetGoalVolumeAuto: Parameter 1 must be a vector or undefined.");
    }
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_SetGunAdditive
==============
*/
void AIScriptedInterface::OnScrCmd_SetGunAdditive(AIScriptedInterface *this, scrContext_t *scrContext)
{
  scr_string_t ConstString; 

  if ( !this->m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 4659, ASSERT_TYPE_ASSERT, "( m_pAI )", (const char *)&queryFormat, "m_pAI") )
    __debugbreak();
  ConstString = Scr_GetConstString(scrContext, 0);
  if ( ConstString == scr_const.gun_additive_disable )
  {
    this->m_pAI->animData.gunAdditiveIndex = 0;
  }
  else if ( ConstString == scr_const.gun_additive_gun_down )
  {
    this->m_pAI->animData.gunAdditiveIndex = 1;
  }
  else if ( ConstString == scr_const.gun_additive_ready )
  {
    this->m_pAI->animData.gunAdditiveIndex = 2;
  }
  else if ( ConstString == scr_const.gun_additive_ads )
  {
    this->m_pAI->animData.gunAdditiveIndex = 3;
  }
  else
  {
    Scr_Error(COM_ERR_3897, scrContext, " Invalid argument to SetGunAdditive(), check function description for valid options ");
  }
}

/*
==============
AICommonInterface::OnScrCmd_SetNavLayer
==============
*/
void AICommonInterface::OnScrCmd_SetNavLayer(AICommonInterface *this, scrContext_t *scrContext)
{
  AINavigator2D *v3; 
  scr_string_t ConstLowercaseString; 
  unsigned int v5; 
  const char *String; 
  unsigned int LayersLoaded; 
  const char *v8; 
  const char *v9; 

  v3 = this->m_pAI->pNavigator->Get2DNavigator(this->m_pAI->pNavigator);
  if ( !v3 )
    Scr_Error(COM_ERR_3866, scrContext, "SetNavLayer - only applies to 2D navigators.");
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  v5 = -1;
  if ( ConstLowercaseString == scr_const.human )
  {
    v5 = 0;
  }
  else
  {
    String = Scr_GetString(scrContext, 0);
    if ( I_stricmp(String, "superslasher") )
      Scr_Error(COM_ERR_3867, scrContext, "SetNavLayer - unknown nav layer name.");
    else
      v5 = 1;
  }
  LayersLoaded = bfx::GetLayersLoaded();
  if ( !_bittest((const int *)&LayersLoaded, v5) )
  {
    v8 = SL_ConvertToString(ConstLowercaseString);
    v9 = j_va("SetNavLayer - no navmesh present for layer %s", v8);
    Scr_Error(COM_ERR_3868, scrContext, v9);
  }
  v3->SetLayer(v3, (AINavLayer)v5);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetOverrideArchetype
==============
*/
void AIScriptedInterface::OnScrCmd_SetOverrideArchetype(AIScriptedInterface *this, scrContext_t *scrContext)
{
  bool v4; 
  unsigned int v5; 
  scr_string_t ConstString; 
  scr_string_t v7; 
  ArcOverridePriority v8; 

  v4 = 0;
  v5 = Scr_GetNumParam(scrContext) - 2;
  if ( v5 )
  {
    if ( v5 != 1 )
    {
      Scr_Error(COM_ERR_6527, scrContext, "Invalid parameter count to setoverridearchetype");
      return;
    }
    v4 = Scr_GetType(scrContext, 2u) && Scr_GetInt(scrContext, 2u);
  }
  ConstString = Scr_GetConstString(scrContext, 0);
  v7 = Scr_GetConstString(scrContext, 1u);
  v8 = AI_StringToArcOverridePriority(ConstString);
  if ( v8 == ARC_PRIORITY_COUNT )
    Scr_Error(COM_ERR_6528, scrContext, "invalid priority string");
  else
    AIScriptedInterface::SetOverrideArchetype(this, v8, v7, v4);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetPitchOrient
==============
*/
void AIScriptedInterface::OnScrCmd_SetPitchOrient(AIScriptedInterface *this, scrContext_t *scrContext)
{
  this->m_pAI->ProneInfo.prone = 1;
  this->m_pAI->ProneInfo.orientPitch = 1;
}

/*
==============
AIScriptedInterface::OnScrCmd_SetPotentialThreat
==============
*/
void AIScriptedInterface::OnScrCmd_SetPotentialThreat(AIScriptedInterface *this, scrContext_t *scrContext)
{
  if ( !this->m_pAI || Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_3890, scrContext, "illegal call to SetPotentialThreat()");
  if ( this->Is3D(this) )
    Scr_Error(COM_ERR_3891, scrContext, "3D actors cannot use SetPotentialThreat()");
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm { vmovaps xmm1, xmm0; yaw }
  AIScriptedInterface::SetPotentialThreat(this, *(float *)&_XMM1);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetRiotshieldWeapon
==============
*/
void AIScriptedInterface::OnScrCmd_SetRiotshieldWeapon(AIScriptedInterface *this, scrContext_t *scrContext)
{
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  this->SetRiotshieldWeapon(this, &outWeapon);
}

/*
==============
AIScriptedInterface::OnScrCmd_SetSpeedScaleMode
==============
*/
void AIScriptedInterface::OnScrCmd_SetSpeedScaleMode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const char *String; 
  const char *v6; 

  ConstString = Scr_GetConstString(scrContext, 0);
  if ( ConstString == scr_const.none )
  {
    this->m_pAI->speedScaleMode[0] = 0;
  }
  else if ( ConstString == scr_const.speed )
  {
    this->m_pAI->speedScaleMode[0] = 1;
    G_AIAnim_UpdateFieldByName(this->m_pAI->ent, (const scr_string_t)scr_const.desiredspeed);
  }
  else if ( ConstString == scr_const.strafe )
  {
    this->m_pAI->speedScaleMode[0] = 2;
    AIScriptedInterface::DecideOrientation(this);
    G_AIAnim_UpdateFieldByName(this->m_pAI->ent, (const scr_string_t)scr_const.desiredspeed);
    G_AIAnim_UpdateFieldByName(this->m_pAI->ent, (const scr_string_t)scr_const.groundslope);
    G_AIAnim_UpdateFieldByName(this->m_pAI->ent, (const scr_string_t)scr_const.strafeyaw);
  }
  else
  {
    String = Scr_GetString(scrContext, 0);
    v6 = j_va("invalid speedscale mode %s. supports none, speed, strafe.", String);
    Scr_Error(COM_ERR_3871, scrContext, v6);
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_SetStrafeReverse
==============
*/
void AIScriptedInterface::OnScrCmd_SetStrafeReverse(AIScriptedInterface *this, scrContext_t *scrContext)
{
  bool v3; 

  v3 = Scr_GetInt(scrContext, 0) != 0;
  *(_BYTE *)(this->GetAI(this) + 1742) = v3;
}

/*
==============
AIScriptedInterface::OnScrCmd_SetTargetSpeed
==============
*/
void AIScriptedInterface::OnScrCmd_SetTargetSpeed(AIScriptedInterface *this, scrContext_t *scrContext)
{
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  _RAX = this->m_pAI;
  __asm { vmovss  dword ptr [rax+0D4Ch], xmm0 }
}

/*
==============
AIScriptedInterface::OnScrCmd_SetupDoorOpen
==============
*/
void AIScriptedInterface::OnScrCmd_SetupDoorOpen(AIScriptedInterface *this, scrContext_t *scrContext)
{
  AINavigator2D *v10; 
  bool ModifierApproachDir; 
  bool v17; 
  unsigned __int8 v34; 
  scr_string_t NearestSpeedThresholdString; 
  scr_string_t soldier; 
  scr_string_t v42; 
  __int64 *v43; 
  int v44; 
  const char *String; 
  const char *v46; 
  int v47; 
  vec3_t outModifierDir; 
  vec3_t outApproachDir; 
  vec3_t outEndPoint; 
  vec3_t outStartPoint; 
  __int64 v57[4]; 
  __int64 v58[4]; 
  __int64 v59[5]; 
  __int64 v60[6]; 
  char v61; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm6
    vmovaps xmmword ptr [rax-48h], xmm7
    vmovaps xmmword ptr [rax-58h], xmm8
    vmovaps xmmword ptr [rax-68h], xmm9
  }
  if ( !AICommonInterface::HasPath(this) )
    Scr_Error(COM_ERR_5727, scrContext, "Cannot setup door open on AI without a path.");
  v10 = this->m_pAI->pNavigator->Get2DNavigator(this->m_pAI->pNavigator);
  if ( !v10 )
    Scr_Error(COM_ERR_5725, scrContext, "Cannot setup door on non-2D navigator");
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm
  {
    vmovss  xmm2, cs:__real@43480000; checkDist
    vmovaps xmm3, xmm0; approachDist
  }
  ModifierApproachDir = AINavigator2D::GetModifierApproachDir(v10, 0x10000000u, *(float *)&_XMM2, *(float *)&_XMM3, &outStartPoint, &outEndPoint, &outApproachDir, &outModifierDir);
  __asm { vxorps  xmm4, xmm4, xmm4 }
  v17 = !ModifierApproachDir;
  if ( ModifierApproachDir )
  {
    __asm
    {
      vmovss  xmm8, dword ptr [rsp+180h+var_140+8]
      vmovss  xmm5, dword ptr [rsp+180h+var_140+4]
      vmovss  xmm3, dword ptr [rsp+180h+var_140]
      vmovss  xmm9, dword ptr [rsp+180h+var_130+8]
      vmovss  xmm7, dword ptr [rsp+180h+var_130+4]
      vmovss  xmm6, dword ptr [rsp+180h+var_130]
    }
  }
  else
  {
    __asm
    {
      vmovss  xmm3, cs:__real@3f800000
      vxorps  xmm5, xmm5, xmm5
      vxorps  xmm8, xmm8, xmm8
      vxorps  xmm7, xmm7, xmm7
      vxorps  xmm9, xmm9, xmm9
      vmovss  dword ptr [rsp+180h+var_140], xmm3
      vmovss  dword ptr [rsp+180h+var_140+4], xmm5
      vmovss  dword ptr [rsp+180h+var_140+8], xmm8
      vmovss  dword ptr [rsp+180h+var_130], xmm3
      vmovss  dword ptr [rsp+180h+var_130+4], xmm7
      vmovss  dword ptr [rsp+180h+var_130+8], xmm9
      vmovaps xmm6, xmm3
    }
  }
  __asm
  {
    vmulss  xmm1, xmm7, xmm5
    vmulss  xmm0, xmm6, xmm3
    vaddss  xmm2, xmm1, xmm0
    vmulss  xmm1, xmm9, xmm8
    vaddss  xmm2, xmm2, xmm1
    vcomiss xmm2, cs:__real@3f5db22d
  }
  if ( ModifierApproachDir )
  {
    this->m_pAI->animData.doorIndex = 2;
  }
  else
  {
    __asm
    {
      vxorps  xmm2, xmm6, cs:__xmm@80000000800000008000000080000000
      vxorps  xmm1, xmm7, cs:__xmm@80000000800000008000000080000000
    }
    v34 = 3;
    __asm
    {
      vmulss  xmm1, xmm1, xmm3
      vmulss  xmm0, xmm2, xmm5
      vsubss  xmm2, xmm1, xmm0
      vcomiss xmm2, xmm4
    }
    if ( !v17 )
      v34 = 1;
    this->m_pAI->animData.doorIndex = v34;
  }
  _RAX = this->m_pAI;
  __asm { vmovss  xmm1, dword ptr [rax+0D4Ch]; desiredSpeed }
  NearestSpeedThresholdString = GetNearestSpeedThresholdString(_RAX->baseArchetype, *(float *)&_XMM1);
  soldier = scr_const.soldier;
  v60[5] = (__int64)&scr_const.run;
  v59[4] = (__int64)&scr_const.run;
  v57[3] = (__int64)&scr_const.run;
  v42 = NearestSpeedThresholdString;
  v58[3] = (__int64)&scr_const.run;
  v60[0] = (__int64)&scr_const.none;
  v60[1] = (__int64)&scr_const.shuffle;
  v60[2] = (__int64)&scr_const.walk;
  v60[3] = (__int64)&scr_const.fast;
  v59[2] = (__int64)&scr_const.fast;
  v60[4] = (__int64)&scr_const.jog;
  v59[0] = (__int64)&scr_const.none;
  v59[1] = (__int64)&scr_const.walk;
  v59[3] = (__int64)&scr_const.jog;
  v57[0] = (__int64)&scr_const.none;
  v57[1] = (__int64)&scr_const.walk;
  v57[2] = (__int64)&scr_const.jog;
  v58[0] = (__int64)&scr_const.none;
  v58[1] = (__int64)&scr_const.walk;
  v58[2] = (__int64)&scr_const.jog;
  if ( Scr_GetNumParam(scrContext) > 2 )
    soldier = Scr_GetConstString(scrContext, 2u);
  v43 = v60;
  v44 = 6;
  if ( soldier == scr_const.civilian )
  {
    v43 = v59;
    v44 = 5;
  }
  else if ( soldier == scr_const.civilian_panic )
  {
    v43 = v57;
    v44 = 4;
  }
  else if ( soldier == scr_const.juggernaut )
  {
    v43 = v58;
    v44 = 4;
  }
  else if ( soldier != scr_const.soldier )
  {
    String = Scr_GetString(scrContext, 2u);
    v46 = j_va("Unsupported door-open lookup type %s", String);
    Scr_Error(COM_ERR_5728, scrContext, v46);
  }
  v47 = 0;
  while ( v42 != *(_DWORD *)v43[v47] )
  {
    if ( ++v47 >= v44 )
      goto LABEL_28;
  }
  this->m_pAI->animData.doorSpeedIndex = v47;
LABEL_28:
  _R11 = &v61;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_SetupMotionWarpForTurn
==============
*/
void AIScriptedInterface::OnScrCmd_SetupMotionWarpForTurn(AIScriptedInterface *this, scrContext_t *scrContext)
{
  float v9; 
  vec3_t v10; 
  vec3_t v11; 
  vec3_t v12; 
  vec3_t v13; 
  vec3_t v14; 
  vec3_t v15; 
  vec3_t v16; 
  vec3_t vectorValue; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &v16);
  Scr_GetVector(scrContext, 2u, &v15);
  Scr_GetVector(scrContext, 3u, &v14);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 4u);
  __asm { vmovsd  xmm1, qword ptr [rbp+57h+var_50] }
  v10.v[2] = v14.v[2];
  __asm
  {
    vmovsd  [rbp+57h+var_90], xmm1
    vmovsd  xmm1, qword ptr [rbp+57h+var_40]
  }
  v11.v[2] = v15.v[2];
  __asm
  {
    vmovsd  [rbp+57h+var_80], xmm1
    vmovsd  xmm1, qword ptr [rbp+57h+var_30]
  }
  v12.v[2] = v16.v[2];
  __asm
  {
    vmovsd  [rbp+57h+var_70], xmm1
    vmovsd  xmm1, qword ptr [rbp+57h+vectorValue]
  }
  v13.v[2] = vectorValue.v[2];
  __asm
  {
    vmovss  [rsp+0C0h+var_98], xmm0
    vmovsd  [rbp+57h+var_60], xmm1
  }
  AIScriptedInterface::SetupMotionWarpForTurn(this, &v13, &v12, &v11, &v10, v9);
}

/*
==============
AIScriptedInterface::OnScrCmd_ShootBlank
==============
*/
void AIScriptedInterface::OnScrCmd_ShootBlank(AIScriptedInterface *this, scrContext_t *scrContext)
{
  const Weapon *Weapon; 
  bool IsAlternate; 
  const char *WeaponNameComplete; 
  const char *v7; 
  char output[1024]; 

  Weapon = GScr_Weapon_GetWeapon(scrContext, (const scr_weapon_t)this->m_pAI->currentWeapon);
  IsAlternate = GScr_Weapon_IsAlternate(scrContext, (const scr_weapon_t)this->m_pAI->currentWeapon);
  if ( BG_GetWeaponType(Weapon, IsAlternate) != WEAPTYPE_BULLET )
  {
    WeaponNameComplete = BG_GetWeaponNameComplete(Weapon, IsAlternate, output, 0x400u);
    v7 = j_va("ShootBlank() only works with bullet weapons.  Using weapon [%s]", WeaponNameComplete);
    Scr_Error(COM_ERR_3885, scrContext, v7);
  }
  AIScriptedInterface::ShootBlank(this);
}

/*
==============
AIScriptedInterface::OnScrCmd_ShouldCautiousStrafe
==============
*/
void AIScriptedInterface::OnScrCmd_ShouldCautiousStrafe(AIScriptedInterface *this, scrContext_t *scrContext)
{
  bool ShouldCautiousStrafe; 

  ShouldCautiousStrafe = AIScriptedInterface::ShouldCautiousStrafe(this);
  Scr_AddBool(scrContext, ShouldCautiousStrafe);
}

/*
==============
AIScriptedInterface::OnScrCmd_StartBeam
==============
*/
void AIScriptedInterface::OnScrCmd_StartBeam(AIScriptedInterface *this, scrContext_t *scrContext)
{
  unsigned int NumParam; 
  ai_scripted_t *m_pAI; 
  const gentity_s *Entity; 

  NumParam = Scr_GetNumParam(scrContext);
  m_pAI = this->m_pAI;
  if ( NumParam )
    Entity = GScr_GetEntity(0);
  else
    Entity = NULL;
  EntHandle::setEnt(&m_pAI->pBeamTargetEnt, Entity);
  this->m_pAI->bContinuousFire = 1;
}

/*
==============
AIScriptedInterface::OnScrCmd_StartCoverArrival
==============
*/
void AIScriptedInterface::OnScrCmd_StartCoverArrival(AIScriptedInterface *this, scrContext_t *scrContext)
{
  AIScriptedInterface::StartArrivalState(this, AIS_BEHAVE);
}

/*
==============
AIScriptedInterface::OnScrCmd_StartTraverseArrival
==============
*/
void AIScriptedInterface::OnScrCmd_StartTraverseArrival(AIScriptedInterface *this, scrContext_t *scrContext)
{
  const char *v11; 
  pathnode_t *StartNodeFromLink; 
  const char *v13; 
  ComErrorCode v14; 
  nav_posAlongPathResults_t pResults; 
  char v18; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm { vmovaps xmmword ptr [rax-18h], xmm6 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm { vmovaps xmm6, xmm0 }
  bfx::AreaHandle::AreaHandle(&pResults.m_hArea);
  bfx::LinkHandle::LinkHandle(&pResults.m_hLink);
  __asm { vmovaps xmm1, xmm6; dist }
  if ( !Nav_GetPosAlongPath(this->m_pAI->pNavigator, *(float *)&_XMM1, 1, &pResults) )
  {
    v13 = "AI cannot start traverse when there is no path.";
    v14 = COM_ERR_5660;
    goto LABEL_16;
  }
  if ( !bfx::LinkHandle::IsValid(&pResults.m_hLink) )
  {
    __asm
    {
      vcvtss2sd xmm1, xmm6, xmm6
      vmovq   rdx, xmm1
    }
    v11 = j_va("Unable to find valid traverse within %.f units down the path.", _RDX);
    Scr_Error(COM_ERR_5909, scrContext, v11);
  }
  StartNodeFromLink = Nav_GetStartNodeFromLink(&pResults.m_hLink);
  if ( !StartNodeFromLink )
    Scr_Error(COM_ERR_5658, scrContext, "Unable to find start node for traverse.");
  if ( !AIScriptedInterface::PushState(this, AIS_NEGOTIATION) )
  {
    v13 = "Failed to properly start negotiation.";
    v14 = COM_ERR_5659;
LABEL_16:
    Scr_Error(v14, scrContext, v13);
    goto LABEL_17;
  }
  bfx::LinkHandle::operator=(&this->m_pAI->pNavigator->m_hLink, &pResults.m_hLink);
  if ( ((1 << LOBYTE(StartNodeFromLink->constant.type)) & 0x68010000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 5239, ASSERT_TYPE_ASSERT, "( Path_IsNegotiationBegin( pStartNode ) )", (const char *)&queryFormat, "Path_IsNegotiationBegin( pStartNode )", -2i64) )
    __debugbreak();
  if ( !StartNodeFromLink->constant.animscript && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 5240, ASSERT_TYPE_ASSERT, "( pStartNode->constant.animscript != ( static_cast< scr_string_t >( 0 ) ) )", (const char *)&queryFormat, "pStartNode->constant.animscript != NULL_SCR_STRING") )
    __debugbreak();
  Scr_SetString(&this->m_pAI->traverseName, StartNodeFromLink->constant.animscript);
  this->m_pAI->bInTraverseState = 1;
LABEL_17:
  bfx::LinkHandle::~LinkHandle(&pResults.m_hLink);
  bfx::AreaHandle::~AreaHandle(&pResults.m_hArea);
  _R11 = &v18;
  __asm { vmovaps xmm6, xmmword ptr [r11-10h] }
}

/*
==============
AIScriptedInterface::OnScrCmd_StartZeroArrival
==============
*/
void AIScriptedInterface::OnScrCmd_StartZeroArrival(AIScriptedInterface *this, scrContext_t *scrContext)
{
  this->m_pAI->arrivalInfo.arrivalTimeLeft = 1;
}

/*
==============
AIScriptedInterface::OnScrCmd_StopBeam
==============
*/
void AIScriptedInterface::OnScrCmd_StopBeam(AIScriptedInterface *this, scrContext_t *scrContext)
{
  AIScriptedInterface::ClearLookAtEntity(this);
  this->m_pAI->bContinuousFire = 0;
}

/*
==============
AIScriptedInterface::OnScrCmd_UpdateAimInfo
==============
*/

void __fastcall AIScriptedInterface::OnScrCmd_UpdateAimInfo(AIScriptedInterface *this, scrContext_t *scrContext, __int64 a3, double _XMM3_8)
{
  sentient_s *TargetSentient; 
  int CanSeeEnemy; 
  const gentity_s *ent; 
  const sentient_s *sentient; 
  bool v17; 
  ai_scripted_t *m_pAI; 
  const tacpoint_t *v19; 
  const tacpoint_t *v20; 
  char v29; 
  bool v30; 
  pathnode_t *CoverNode; 
  ai_scripted_t *v32; 
  ai_scripted_t *v33; 
  ai_scripted_t *v51; 
  int v53; 
  sentient_s *v55; 
  pathnode_t *pClaimedNode; 
  double Angle; 
  ai_scripted_t *v73; 
  const vec4_t *v80; 
  vec3_t *p_outEyePos; 
  pathnode_t *PrevCoverNode; 
  const tacpoint_t *pTargetPoint; 
  const vec3_t *p_m_Pos; 
  const tacpoint_t *ClosestPointWithoutVisWithinConeWithinRadius; 
  ai_scripted_t *v110; 
  AINavigator2D *v111; 
  const bfx::AreaHandle *CurArea; 
  float v139; 
  float v140; 
  vec3_t outLastKnownPos; 
  vec3_t forward; 
  vec3_t outEyePos; 
  vec3_t outPos; 
  bitarray<224> result; 
  char v146[16]; 
  float pResults[14]; 
  char v148; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-28h], xmm6
    vmovaps xmmword ptr [rax-38h], xmm7
    vmovaps xmmword ptr [rax-48h], xmm8
    vmovaps xmmword ptr [rax-58h], xmm9
  }
  Sys_ProfBeginNamedEvent(0xFF808080, "UpdateAimInfo");
  TargetSentient = AICommonInterface::GetTargetSentient(this);
  if ( this->InScriptedState(this) || this->IsInPain(this) )
    goto LABEL_79;
  if ( TargetSentient )
  {
    CanSeeEnemy = AICommonInterface::CanSeeEnemy(this);
    ent = TargetSentient->ent;
    if ( CanSeeEnemy )
    {
LABEL_17:
      Scr_AddVector(scrContext, ent->r.currentOrigin.v);
      goto LABEL_79;
    }
    Sentient_GetLastKnownEnemyPos(this->m_pAI->sentient, ent, &outLastKnownPos);
    __asm
    {
      vmovss  xmm6, cs:__real@42480000
      vaddss  xmm1, xmm6, dword ptr [rsp+150h+outLastKnownPos+8]
      vmovss  dword ptr [rsp+150h+outLastKnownPos+8], xmm1
    }
    if ( AICommonInterface::HasPath(this) || AICommonInterface::RecentlySeeEnemy(this) )
      goto LABEL_77;
    sentient = TargetSentient->ent->sentient;
    if ( sentient )
      v17 = level.time - Sentient_GetSentientInfo(this->m_pAI->sentient, sentient)->lastKnownPosTime < 10000;
    else
      v17 = AICommonInterface::RecentlySeeSentient(this, TargetSentient, 10000) != 0;
    if ( v17 )
    {
      if ( Com_GameMode_SupportsFeature(WEAPON_RAISING_ALTSWITCH_ADS) )
      {
        m_pAI = this->m_pAI;
        if ( !m_pAI->combat.doingAmbush )
        {
          v19 = Sentient_NearestTacPoint(m_pAI->sentient);
          v20 = Sentient_NearestTacPoint(TargetSentient);
          if ( v19 )
          {
            if ( v20 && TacVisGraph_HasVis(v19, v20) )
            {
              ent = TargetSentient->ent;
              goto LABEL_17;
            }
          }
        }
      }
      if ( AIScriptedInterface::GetAnglesToLikelyEnemyPath(this) )
      {
        _RAX = this->m_pAI;
        __asm
        {
          vmovsd  xmm0, qword ptr [rax+0DCh]
          vmovsd  qword ptr [rsp+150h+forward], xmm0
        }
        forward.v[2] = _RAX->sight.faceLikelyEnemyCornerPos.v[2];
        AIScriptedInterface::GetApproxEyePos(this, &outEyePos, 1);
        __asm
        {
          vmovss  xmm0, dword ptr [rsp+150h+forward]
          vsubss  xmm4, xmm0, dword ptr [rsp+150h+outEyePos]
          vmovss  xmm1, dword ptr [rsp+150h+forward+4]
          vsubss  xmm3, xmm1, dword ptr [rsp+150h+outEyePos+4]
          vaddss  xmm2, xmm6, dword ptr [rsp+150h+forward+8]
          vmovss  dword ptr [rsp+150h+forward+8], xmm2
          vmulss  xmm1, xmm3, xmm3
          vmulss  xmm0, xmm4, xmm4
          vaddss  xmm1, xmm1, xmm0
          vcomiss xmm1, cs:__real@44800000
        }
        if ( !(v29 | v30) )
        {
LABEL_36:
          Scr_AddVector(scrContext, forward.v);
          goto LABEL_79;
        }
      }
    }
  }
  CoverNode = AIScriptedInterface::GetCoverNode(this);
  if ( AICommonInterface::HasPath(this) || CoverNode && this->m_pAI->sentient->pClaimedNode || (v32 = this->m_pAI, v32->arrivalInfo.arriving) || v32->sentient->eTeam != TEAM_TWO || AIScriptedInterface::IsDoingReacquire(this) || !EntHandle::isDefined(&this->m_pAI->grenade.pGrenade) && (v33 = this->m_pAI, !v33->fixedNodeNudged) && (!v33->fixedNode || AIScriptedInterface::IsFixedNodeUseable(this, 1)) )
  {
    this->m_pAI->iLastIdleFacingUseAlliesTime = 0;
    goto LABEL_79;
  }
  if ( this->m_pAI->sentient->pClaimedNode )
  {
    __asm { vmovss  xmm1, cs:__real@41400000; dist }
    if ( AICommonInterface::NearClaimNode(this, *(float *)&_XMM1) )
    {
      pathnode_t::GetAngles(this->m_pAI->sentient->pClaimedNode, &outLastKnownPos);
      if ( CoverNode )
      {
        *(double *)&_XMM0 = ((double (__fastcall *)(AIScriptedInterface *, pathnode_t *))this->GetNodeAngleYawOffset)(this, CoverNode);
        __asm
        {
          vaddss  xmm1, xmm0, dword ptr [rsp+150h+outLastKnownPos+4]
          vmulss  xmm4, xmm1, cs:__real@3b360b61
          vaddss  xmm2, xmm4, cs:__real@3f000000
          vxorps  xmm0, xmm0, xmm0
          vmovss  xmm3, xmm0, xmm2
          vxorps  xmm1, xmm1, xmm1
          vroundss xmm0, xmm1, xmm3, 1
          vsubss  xmm0, xmm4, xmm0
          vmulss  xmm1, xmm0, cs:__real@43b40000
          vmovss  dword ptr [rsp+150h+outLastKnownPos+4], xmm1
        }
      }
      AngleVectors(&outLastKnownPos, &forward, NULL, NULL);
      __asm
      {
        vmovss  xmm3, cs:__real@42f00000
        vmulss  xmm1, xmm3, dword ptr [rsp+150h+forward]
        vaddss  xmm2, xmm1, dword ptr [rcx+130h]
        vmovss  dword ptr [rsp+150h+forward], xmm2
        vmulss  xmm1, xmm3, dword ptr [rsp+150h+forward+4]
        vaddss  xmm2, xmm1, dword ptr [rcx+134h]
        vmovss  dword ptr [rsp+150h+forward+4], xmm2
        vmulss  xmm1, xmm3, dword ptr [rsp+150h+forward+8]
        vaddss  xmm1, xmm1, dword ptr [rcx+138h]
        vmovss  dword ptr [rsp+150h+forward+8], xmm1
      }
      if ( Dvar_GetBool_Internal_DebugName(DVARBOOL_ai_whereshouldiface, "ai_whereshouldiface") )
        G_DebugLine(&this->m_pAI->ent->r.currentOrigin, &forward, &colorWhite, 0);
      goto LABEL_36;
    }
  }
  v51 = this->m_pAI;
  __asm { vxorps  xmm7, xmm7, xmm7 }
  if ( level.time - v51->iLastIdleFacingUseAlliesTime > 1000 )
  {
    v51->iLastIdleFacingUseAlliesTime = level.time;
    v53 = 0;
    __asm { vxorps  xmm6, xmm6, xmm6 }
    Com_Teams_GetTeamFlag(&result, this->m_pAI->sentient->eTeam);
    v55 = Sentient_FirstSentient(&result);
    __asm { vmovss  xmm8, cs:__real@42700000 }
    if ( !v55 )
      goto LABEL_49;
    __asm { vmovss  xmm9, cs:__real@48800000 }
    do
    {
      if ( v55 != this->m_pAI->sentient )
      {
        if ( v55->ai )
        {
          pClaimedNode = v55->pClaimedNode;
          if ( pClaimedNode )
          {
            pathnode_t::GetPos(pClaimedNode, &outLastKnownPos);
            _RCX = this->m_pAI->ent;
            __asm
            {
              vmovss  xmm0, dword ptr [rcx+130h]
              vsubss  xmm3, xmm0, dword ptr [rsp+150h+outLastKnownPos]
              vmovss  xmm1, dword ptr [rcx+134h]
              vsubss  xmm2, xmm1, dword ptr [rsp+150h+outLastKnownPos+4]
              vmovss  xmm0, dword ptr [rcx+138h]
              vsubss  xmm4, xmm0, dword ptr [rsp+150h+outLastKnownPos+8]
              vmulss  xmm2, xmm2, xmm2
              vmulss  xmm1, xmm3, xmm3
              vaddss  xmm3, xmm2, xmm1
              vmulss  xmm0, xmm4, xmm4
              vaddss  xmm2, xmm3, xmm0
              vcomiss xmm2, xmm9
            }
            if ( v29 | v30 )
            {
              Angle = pathnode_t::GetAngle(v55->pClaimedNode);
              *(double *)&_XMM0 = AngleNormalize360(*(const float *)&Angle);
              __asm { vaddss  xmm6, xmm6, xmm0 }
              ++v53;
            }
          }
        }
      }
      v55 = Sentient_NextSentient(v55, &result);
    }
    while ( v55 );
    if ( v53 > 0 )
    {
      __asm
      {
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm0, xmm0, esi
        vdivss  xmm1, xmm6, xmm0
        vmovss  dword ptr [rsp+150h+outLastKnownPos], xmm7
        vmovss  dword ptr [rsp+150h+outLastKnownPos+4], xmm1
        vmovss  dword ptr [rsp+150h+outLastKnownPos+8], xmm7
      }
      AngleVectors(&outLastKnownPos, &forward, NULL, NULL);
      if ( Dvar_GetBool_Internal_DebugName(DVARBOOL_ai_whereshouldiface, "ai_whereshouldiface") )
      {
        v73 = this->m_pAI;
        __asm
        {
          vmulss  xmm1, xmm8, dword ptr [rsp+150h+forward]
          vaddss  xmm2, xmm1, dword ptr [rax+130h]
          vmovss  dword ptr [rsp+150h+outEyePos], xmm2
          vmulss  xmm1, xmm8, dword ptr [rsp+150h+forward+4]
          vaddss  xmm1, xmm1, dword ptr [rax+134h]
          vmovss  dword ptr [rsp+150h+outEyePos+4], xmm1
          vmulss  xmm2, xmm8, dword ptr [rsp+150h+forward+8]
          vaddss  xmm1, xmm2, dword ptr [rax+138h]
          vmovss  dword ptr [rsp+150h+outEyePos+8], xmm1
        }
        v80 = &colorLtOrange;
        p_outEyePos = &outEyePos;
LABEL_52:
        G_DebugLine(&v73->ent->r.currentOrigin, p_outEyePos, v80, 0);
      }
    }
    else
    {
LABEL_49:
      PrevCoverNode = AIScriptedInterface::GetPrevCoverNode(this);
      if ( !PrevCoverNode )
      {
LABEL_64:
        this->m_pAI->bCachedIdleFacingPosValid = 0;
        v51 = this->m_pAI;
LABEL_65:
        v30 = v51->pNavigator->Get2DNavigator(v51->pNavigator) == NULL;
        v110 = this->m_pAI;
        if ( v30 )
        {
          __asm { vmovss  xmm1, cs:__real@43000000; radius }
          TacGraph_CalcOpenView(&v110->ent->r.currentOrigin, *(float *)&_XMM1, pResults, 12);
        }
        else
        {
          v111 = v110->pNavigator->Get2DNavigator(v110->pNavigator);
          CurArea = AINavigator2D::GetCurArea(v111);
          __asm { vmovss  xmm1, cs:__real@43000000; radius }
          TacGraph_CalcOpenView(&this->m_pAI->ent->r.currentOrigin, *(float *)&_XMM1, CurArea, pResults, 12);
        }
        _RCX = this->m_pAI->ent;
        __asm { vmovss  xmm0, dword ptr [rcx+140h]; angle }
        *(double *)&_XMM0 = AngleNormalize360(*(const float *)&_XMM0);
        __asm
        {
          vmulss  xmm1, xmm0, cs:__real@3d088889
          vcvttss2si eax, xmm1
        }
        _RCX = _EAX;
        __asm
        {
          vmovss  xmm0, cs:__real@42800000
          vcomiss xmm0, [rbp+rcx*4+50h+pResults]
        }
        if ( v29 | v30 )
          goto LABEL_79;
        __asm { vmovss  xmm2, cs:__real@42100000; minDist }
        if ( (int)FindBestSlice(pResults, 12, *(double *)&_XMM2, _XMM3_8) < 0 )
        {
          __asm { vmovaps xmm2, xmm7; minDist }
          if ( (int)FindBestSlice(pResults, 12, *(double *)&_XMM2, _XMM3_8) < 0 )
            goto LABEL_79;
        }
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, eax
          vmulss  xmm1, xmm0, cs:__real@41f00000
          vaddss  xmm2, xmm1, cs:__real@41700000
          vmovss  dword ptr [rsp+150h+outEyePos], xmm7
          vmovss  dword ptr [rsp+150h+outEyePos+4], xmm2
          vmovss  dword ptr [rsp+150h+outEyePos+8], xmm7
        }
        AngleVectors(&outEyePos, &forward, NULL, NULL);
        __asm
        {
          vmovss  xmm3, cs:__real@42f00000
          vmulss  xmm1, xmm3, dword ptr [rsp+150h+forward]
          vaddss  xmm2, xmm1, dword ptr [rcx+130h]
          vmovss  dword ptr [rsp+150h+outLastKnownPos], xmm2
          vmulss  xmm1, xmm3, dword ptr [rsp+150h+forward+4]
          vaddss  xmm1, xmm1, dword ptr [rcx+134h]
          vmovss  dword ptr [rsp+150h+outLastKnownPos+4], xmm1
          vmulss  xmm2, xmm3, dword ptr [rsp+150h+forward+8]
          vaddss  xmm1, xmm2, dword ptr [rcx+138h]
          vmovss  dword ptr [rsp+150h+outLastKnownPos+8], xmm1
        }
        if ( Dvar_GetBool_Internal_DebugName(DVARBOOL_ai_whereshouldiface, "ai_whereshouldiface") )
          G_DebugLine(&this->m_pAI->ent->r.currentOrigin, &outLastKnownPos, &colorMdCyan, 0);
LABEL_77:
        Scr_AddVector(scrContext, outLastKnownPos.v);
        goto LABEL_79;
      }
      __asm { vmovss  dword ptr [rsp+150h+outEyePos], xmm7 }
      *(double *)&_XMM0 = pathnode_t::GetAngle(PrevCoverNode);
      __asm
      {
        vmovss  dword ptr [rsp+150h+outEyePos+4], xmm0
        vmovss  dword ptr [rsp+150h+outEyePos+8], xmm7
      }
      AngleVectors(&outEyePos, &forward, NULL, NULL);
      if ( Dvar_GetBool_Internal_DebugName(DVARBOOL_ai_whereshouldiface, "ai_whereshouldiface") )
      {
        v73 = this->m_pAI;
        __asm
        {
          vmulss  xmm1, xmm8, dword ptr [rsp+150h+forward]
          vaddss  xmm2, xmm1, dword ptr [rax+130h]
          vmovss  dword ptr [rsp+150h+outLastKnownPos], xmm2
          vmulss  xmm1, xmm8, dword ptr [rsp+150h+forward+4]
          vaddss  xmm1, xmm1, dword ptr [rax+134h]
          vmovss  dword ptr [rsp+150h+outLastKnownPos+4], xmm1
          vmulss  xmm2, xmm8, dword ptr [rsp+150h+forward+8]
          vaddss  xmm1, xmm2, dword ptr [rax+138h]
          vmovss  dword ptr [rsp+150h+outLastKnownPos+8], xmm1
        }
        v80 = &colorPink;
        p_outEyePos = &outLastKnownPos;
        goto LABEL_52;
      }
    }
    pTargetPoint = Sentient_NearestTacPoint(this->m_pAI->sentient);
    if ( pTargetPoint )
    {
      _RDX = this->m_pAI->ent;
      __asm
      {
        vmovss  xmm0, dword ptr [rdx+130h]
        vmovss  dword ptr [rsp+150h+outLastKnownPos], xmm0
        vmovss  xmm1, dword ptr [rdx+134h]
        vmovss  dword ptr [rsp+150h+outLastKnownPos+4], xmm1
        vaddss  xmm2, xmm8, dword ptr [rdx+138h]
        vmovss  dword ptr [rsp+150h+outLastKnownPos+8], xmm2
        vmovss  xmm6, cs:__real@3f70a3d7
        vmovss  dword ptr [rsp+150h+var_120], xmm6
        vmovss  xmm9, cs:__real@44000000
        vmovaps xmm2, xmm9; maxRadius
        vmovaps xmm1, xmm8; minRadius
      }
      _RAX = TacGraph_FindClosestPointWithVisWithinConeWithinRadius(&outLastKnownPos, *(float *)&_XMM1, *(float *)&_XMM2, &outLastKnownPos, pTargetPoint, &forward, v139, 0);
      p_m_Pos = &_RAX->m_Pos;
      if ( _RAX )
      {
        _RDX = this->m_pAI;
        _RDX->cachedIdleFacingUseAlliesPos.v[0] = _RAX->m_Pos.v[0];
        __asm
        {
          vmovss  xmm0, dword ptr [rax+4]
          vmovss  dword ptr [rdx+0C0Ch], xmm0
          vmovss  xmm1, dword ptr [rax+8]
          vmovss  dword ptr [rdx+0C10h], xmm1
        }
        this->m_pAI->bCachedIdleFacingPosValid = 1;
        Scr_AddVector(scrContext, _RAX->m_Pos.v);
        if ( Dvar_GetBool_Internal_DebugName(DVARBOOL_ai_whereshouldiface, "ai_whereshouldiface") )
          G_DebugLine(&this->m_pAI->ent->r.currentOrigin, p_m_Pos, &colorLtYellow, 0);
        goto LABEL_79;
      }
      __asm
      {
        vmovss  dword ptr [rsp+150h+var_120], xmm6
        vmovaps xmm2, xmm9; maxRadius
        vmovaps xmm1, xmm8; minRadius
      }
      ClosestPointWithoutVisWithinConeWithinRadius = TacGraph_FindClosestPointWithoutVisWithinConeWithinRadius(&outLastKnownPos, *(float *)&_XMM1, *(float *)&_XMM2, &outLastKnownPos, pTargetPoint, &forward, v140, 0);
      if ( ClosestPointWithoutVisWithinConeWithinRadius )
      {
        if ( Dvar_GetBool_Internal_DebugName(DVARBOOL_ai_whereshouldiface, "ai_whereshouldiface") )
          G_DebugLine(&this->m_pAI->ent->r.currentOrigin, &ClosestPointWithoutVisWithinConeWithinRadius->m_Pos, &colorLtGrey, 0);
        TacGraph_GetApproxGroundPosForPoint(ClosestPointWithoutVisWithinConeWithinRadius, &outPos);
        this->m_pAI->pNavigator->GetCurPos(this->m_pAI->pNavigator, &outEyePos);
        _RDI = this->m_pAI->pNavigator->FindLastTacPointOnPathWithVis(this->m_pAI->pNavigator, &outPos, pTargetPoint, &outEyePos, v146);
        if ( _RDI )
        {
          if ( Dvar_GetBool_Internal_DebugName(DVARBOOL_ai_whereshouldiface, "ai_whereshouldiface") )
            G_DebugLine(&this->m_pAI->ent->r.currentOrigin, &_RDI->m_Pos, &colorLtGreen, 0);
          _RCX = this->m_pAI;
          _RCX->cachedIdleFacingUseAlliesPos.v[0] = _RDI->m_Pos.v[0];
          __asm
          {
            vmovss  xmm0, dword ptr [rdi+4]
            vmovss  dword ptr [rcx+0C0Ch], xmm0
            vmovss  xmm1, dword ptr [rdi+8]
            vmovss  dword ptr [rcx+0C10h], xmm1
          }
          this->m_pAI->bCachedIdleFacingPosValid = 1;
          Scr_AddVector(scrContext, _RDI->m_Pos.v);
          goto LABEL_79;
        }
      }
    }
    goto LABEL_64;
  }
  if ( !v51->bCachedIdleFacingPosValid )
    goto LABEL_65;
  if ( Dvar_GetBool_Internal_DebugName(DVARBOOL_ai_whereshouldiface, "ai_whereshouldiface") )
    G_DebugLine(&this->m_pAI->ent->r.currentOrigin, &this->m_pAI->cachedIdleFacingUseAlliesPos, &colorLtGrey, 0);
  Scr_AddVector(scrContext, this->m_pAI->cachedIdleFacingUseAlliesPos.v);
LABEL_79:
  Sys_ProfEndNamedEvent();
  _R11 = &v148;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_UpdateCoverExposeType
==============
*/
void AIScriptedInterface::OnScrCmd_UpdateCoverExposeType(AIScriptedInterface *this, scrContext_t *scrContext)
{
  pathnode_t *CoverNode; 
  bool v15; 
  int Int; 
  ai_scripted_t *m_pAI; 
  int v18; 
  scr_string_t m_CoverExposeType; 
  bool v20; 
  bool v21; 
  int v22; 
  bool v23; 
  unsigned __int16 type; 
  unsigned __int16 coverMultiType; 
  bool v31; 
  const Weapon *v32; 
  weapClass_t WeaponClass; 
  bool v34; 
  bool v35; 
  ai_scripted_t *v36; 
  scrContext_t *v37; 
  bool v38; 
  bool v39; 
  bool v40; 
  scrContext_t *v41; 
  bool v42; 
  bool v43; 
  scr_string_t *v44; 
  int v45; 
  scr_string_t m_CrouchArrivalType; 
  const float *CoverCrouchAngleLimits; 
  bool v48; 
  bool v49; 
  bool v51; 
  scr_string_t aim; 
  unsigned int spawnflags; 
  unsigned int v61; 
  bool v62; 
  scr_string_t *p_m_CoverExposeType; 
  scr_string_t exposed; 
  __int16 v66; 
  bool v67; 
  __int64 v68; 
  unsigned int v69; 
  unsigned int v70; 
  scr_string_t *v71; 
  scr_string_t *p_m_CoverState; 
  bool v78; 
  bool v80; 
  int v81; 
  int outLimitsCount; 
  scr_string_t possiblePoses; 
  int v84[9]; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
  }
  CoverNode = AIScriptedInterface::GetCoverNode(this);
  if ( !CoverNode )
    Scr_Error(COM_ERR_6179, scrContext, "UpdateCoverExposeType called with invalid cover node.");
  Sys_ProfBeginNamedEvent(0xFFFFFFFF, "AIScr_UpdateCoverExposeType");
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm { vmovaps xmm6, xmm0 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm { vmovaps xmm7, xmm0 }
  v80 = Scr_GetInt(scrContext, 2u) != 0;
  v15 = Scr_GetInt(scrContext, 3u) != 0;
  Int = Scr_GetInt(scrContext, 4u);
  m_pAI = this->m_pAI;
  v18 = 0;
  v81 = Int;
  m_CoverExposeType = m_pAI->blackboard.m_CoverExposeType;
  v20 = m_CoverExposeType && m_CoverExposeType != scr_const.none;
  v78 = v20;
  v21 = m_pAI->blackboard.m_CoverState == scr_const.exposed;
  if ( !v20 || m_pAI->blackboard.m_CoverState == scr_const.exposed )
  {
    v23 = 1;
  }
  else
  {
    v22 = G_irand(0, 100);
    v20 = v78;
    v23 = v22 < 20;
  }
  type = CoverNode->constant.type;
  if ( type == 31 )
    coverMultiType = CoverNode->dynamic.coverMultiType;
  else
    coverMultiType = CoverNode->constant.type;
  __asm
  {
    vmovaps [rsp+110h+var_68+8], xmm8
    vmovaps [rsp+110h+var_78+8], xmm9
    vmovaps [rsp+110h+var_88+8], xmm10
  }
  if ( (unsigned int)coverMultiType - 6 > 1 )
  {
    if ( (unsigned __int16)(type - 3) <= 1u )
    {
      m_CrouchArrivalType = this->m_pAI->blackboard.m_CrouchArrivalType;
      if ( m_CrouchArrivalType == scr_const.cover_right_crouch_cc || m_CrouchArrivalType == scr_const.cover_left_crouch_cc )
      {
        __asm { vmovaps [rsp+110h+var_98+8], xmm11 }
        CoverCrouchAngleLimits = GetCoverCrouchAngleLimits(m_CrouchArrivalType, &v81);
        v48 = (unsigned int)v81 < 0x12;
        v49 = (unsigned int)v81 <= 0x12;
        _R14 = CoverCrouchAngleLimits;
        if ( v81 < 18 )
        {
          v51 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 7947, ASSERT_TYPE_ASSERT, "(numLimits >= 18)", (const char *)&queryFormat, "numLimits >= 18");
          v48 = 0;
          v49 = !v51;
          if ( v51 )
            __debugbreak();
        }
        __asm
        {
          vcomiss xmm7, cs:__real@42200000
          vmovss  xmm0, dword ptr [r14+8]
          vmovss  xmm1, dword ptr [r14+10h]
          vmovss  xmm2, dword ptr [r14+20h]
          vmovss  xmm8, dword ptr [r14+28h]
          vmovss  xmm9, dword ptr [r14+2Ch]
          vmovss  xmm10, dword ptr [r14+30h]
          vmovss  xmm11, dword ptr [r14+34h]
        }
        if ( v49 )
          goto LABEL_92;
        __asm { vcomiss xmm6, dword ptr [r14+18h] }
        if ( v48 )
          goto LABEL_92;
        __asm { vcomiss xmm6, dword ptr [r14+1Ch] }
        if ( !v48 )
        {
LABEL_92:
          if ( v78 && v21 )
          {
            __asm
            {
              vcomiss xmm0, xmm6
              vcomiss xmm1, xmm6
            }
            spawnflags = CoverNode->constant.spawnflags;
            if ( (CoverNode->constant.spawnflags & 0x200000) != 0 && (spawnflags & 8) == 0 )
            {
              __asm { vcomiss xmm2, xmm6 }
              if ( (spawnflags & 8) == 0 )
                __asm { vcomiss xmm6, dword ptr [r14+24h] }
            }
            v41 = scrContext;
            v61 = CoverNode->constant.spawnflags;
            v62 = (CoverNode->constant.spawnflags & 0x400000) == 0;
            if ( (CoverNode->constant.spawnflags & 0x400000) != 0 )
            {
              v62 = (v61 & 8) == 0;
              if ( (v61 & 8) == 0 )
              {
                __asm { vcomiss xmm8, xmm6 }
                if ( (v61 & 8) == 0 )
                  __asm { vcomiss xmm6, xmm9 }
              }
            }
            __asm { vcomiss xmm10, xmm6 }
            if ( v62 )
              __asm { vcomiss xmm6, xmm11 }
          }
          else
          {
            v41 = scrContext;
          }
          aim = scr_const.aim;
        }
        else
        {
          v41 = scrContext;
          possiblePoses = scr_const.overlean;
          aim = v84[G_irand(0, 1) - 1];
        }
        __asm { vmovaps xmm11, [rsp+110h+var_98+8] }
        p_m_CoverExposeType = &this->m_pAI->blackboard.m_CoverExposeType;
        if ( *p_m_CoverExposeType != aim )
          Scr_SetString(p_m_CoverExposeType, aim);
        goto LABEL_150;
      }
    }
    if ( coverMultiType == 21 )
    {
      if ( !v20 || v21 )
      {
        exposed = scr_const.exposed;
        goto LABEL_147;
      }
LABEL_149:
      v41 = scrContext;
LABEL_150:
      p_m_CoverState = &this->m_pAI->blackboard.m_CoverState;
      if ( *p_m_CoverState != scr_const.exposed )
        Scr_SetString(p_m_CoverState, scr_const.exposed);
      v37 = v41;
      goto LABEL_153;
    }
    if ( v20 && v21 )
      goto LABEL_149;
    v67 = type == 3;
    v66 = type - 3;
    if ( v67 || v66 == 1 )
    {
      __asm { vcomiss xmm7, cs:__real@41600000 }
      if ( !v67 && v66 != 1 )
        goto LABEL_120;
      __asm { vcomiss xmm7, cs:__real@41200000 }
      if ( v67 || v66 == 1 )
        goto LABEL_122;
      if ( v15 )
      {
LABEL_120:
        exposed = scr_const.leanover;
      }
      else
      {
        if ( !Path_DoesNodeAllowStance(CoverNode, (const scr_string_t)scr_const.stand) )
          goto LABEL_122;
        exposed = scr_const.full_exposed;
      }
      if ( exposed )
      {
LABEL_147:
        v71 = &this->m_pAI->blackboard.m_CoverExposeType;
        if ( *v71 != exposed )
          Scr_SetString(v71, exposed);
        goto LABEL_149;
      }
    }
LABEL_122:
    if ( (unsigned __int16)(CoverNode->constant.type - 3) > 1u )
    {
      LODWORD(v68) = 1;
      v70 = CoverNode->constant.spawnflags;
      possiblePoses = scr_const.full_exposed;
      if ( (v70 & 0x100000) != 0 && (v70 & 8) == 0 || (v70 & 0x200) != 0 && (v70 & 4) == 0 )
      {
        LODWORD(v68) = 2;
        v84[0] = scr_const.exposed;
      }
      goto LABEL_144;
    }
    if ( v15 || Path_DoesNodeAllowStance(CoverNode, (const scr_string_t)scr_const.stand) )
    {
      v18 = 1;
      possiblePoses = scr_const.full_exposed;
    }
    v68 = (unsigned int)(v18 + 1);
    v69 = CoverNode->constant.spawnflags;
    v84[v18 - 1] = scr_const.exposed;
    if ( (v69 & 0x200000) == 0 || (v69 & 8) != 0 )
    {
      if ( (v69 & 0x400) == 0 || (v69 & 0x204) != 0 )
      {
LABEL_133:
        if ( (v69 & 0x400000) == 0 || (v69 & 8) != 0 )
        {
          if ( (v69 & 0x800) != 0 && (v69 & 0x204) == 0 )
          {
            v84[v68 - 1] = scr_const.right;
            LODWORD(v68) = v68 + 1;
          }
        }
        else
        {
          v84[v68 - 1] = scr_const.right;
          LODWORD(v68) = v68 + 1;
        }
LABEL_144:
        if ( v15 )
          LODWORD(v68) = CullCoverPosesForShort(this->m_pAI, CoverNode, &possiblePoses, v68, &this->m_pAI->blackboard.m_CoverExposeType);
        exposed = v84[G_irand(0, v68) - 1];
        goto LABEL_147;
      }
      v84[v18] = scr_const.left;
    }
    else
    {
      v84[v68 - 1] = scr_const.left;
    }
    v68 = (unsigned int)(v18 + 2);
    goto LABEL_133;
  }
  _R14 = GetCoverAngleLimits(coverMultiType, this->m_pAI->eCurrentStance, &outLimitsCount);
  if ( outLimitsCount < 6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 7821, ASSERT_TYPE_ASSERT, "( numLimits >= 6 )", (const char *)&queryFormat, "numLimits >= 6") )
    __debugbreak();
  __asm
  {
    vmovss  xmm9, dword ptr [r14+8]
    vmovss  xmm10, dword ptr [r14+0Ch]
    vmovss  xmm7, dword ptr [r14+10h]
    vmovss  xmm8, dword ptr [r14+14h]
  }
  v31 = m_CoverExposeType == scr_const.lean && v21;
  v32 = this->GetEquippedWeapon(this);
  WeaponClass = BG_GetWeaponClass(v32, 0);
  if ( WeaponClass == WEAPCLASS_ROCKETLAUNCHER )
    goto LABEL_39;
  if ( WeaponClass == WEAPCLASS_MG )
    goto LABEL_39;
  v34 = 0;
  v35 = !v21;
  if ( v21 )
  {
    v34 = (unsigned int)m_CoverExposeType < scr_const.covertype_b;
    v35 = (unsigned int)m_CoverExposeType <= scr_const.covertype_b;
    if ( m_CoverExposeType == scr_const.covertype_b )
      goto LABEL_39;
  }
  __asm { vcomiss xmm9, xmm6 }
  if ( !v35 )
    goto LABEL_39;
  __asm { vcomiss xmm6, xmm10 }
  if ( !v34 )
  {
LABEL_39:
    if ( v31 )
    {
      v41 = scrContext;
      goto LABEL_80;
    }
  }
  else
  {
    v36 = this->m_pAI;
    if ( v36->combat.doingAmbush )
    {
      if ( v36->blackboard.m_CoverState != scr_const.exposed )
      {
        Scr_SetString(&v36->blackboard.m_CoverState, scr_const.exposed);
        v36 = this->m_pAI;
      }
      goto LABEL_32;
    }
    if ( v31 )
    {
LABEL_32:
      if ( v36->blackboard.m_CoverExposeType != scr_const.lean )
        Scr_SetString(&v36->blackboard.m_CoverExposeType, scr_const.lean);
      v37 = scrContext;
LABEL_153:
      v45 = 1;
      goto LABEL_154;
    }
    if ( !v21 && (v23 || m_CoverExposeType != scr_const.lean) )
    {
      possiblePoses = scr_const.lean;
      v18 = 1;
    }
  }
  v38 = v78;
  if ( v78 && v21 )
  {
    if ( m_CoverExposeType == scr_const.covertype_a )
    {
      __asm
      {
        vaddss  xmm7, xmm7, cs:__real@c0a00000
        vaddss  xmm8, xmm8, cs:__real@40a00000
      }
    }
    else
    {
      __asm
      {
        vaddss  xmm7, xmm7, cs:__real@40a00000
        vaddss  xmm8, xmm8, cs:__real@c0a00000
      }
    }
  }
  if ( !v80 )
  {
    v39 = (unsigned int)v81 < 0x1388;
    v40 = (unsigned int)v81 <= 0x1388;
    if ( v81 < 5000 && (m_CoverExposeType == scr_const.covertype_a || (v39 = (unsigned int)m_CoverExposeType < scr_const.covertype_b, v40 = (unsigned int)m_CoverExposeType <= scr_const.covertype_b, m_CoverExposeType == scr_const.covertype_b)) )
    {
      v84[v18 - 1] = m_CoverExposeType;
    }
    else
    {
      __asm { vcomiss xmm7, xmm6 }
      if ( !v40 )
        goto LABEL_62;
      __asm { vcomiss xmm6, xmm8 }
      if ( v39 )
      {
        if ( !v23 && m_CoverExposeType == scr_const.covertype_a )
          goto LABEL_52;
        v84[v18 - 1] = scr_const.covertype_a;
      }
      else
      {
LABEL_62:
        if ( !v23 && m_CoverExposeType == scr_const.covertype_b )
          goto LABEL_52;
        v42 = v21 && m_CoverExposeType == scr_const.covertype_b || AIScriptedInterface::HasRoomToFullExposeCorner(this, CoverNode);
        v43 = this->ShouldArriveToCoverExposedStepOut(this);
        if ( !v42 || !this->m_pAI->combat.doingAmbush && !v43 && !AIScriptedInterface::CanSeeEnemyFromExposed(this, CoverNode) )
        {
          v41 = scrContext;
          if ( !v18 )
            goto LABEL_80;
LABEL_74:
          m_CoverExposeType = v84[G_irand(0, v18) - 1];
          goto LABEL_75;
        }
        v84[v18 - 1] = scr_const.covertype_b;
      }
    }
    ++v18;
LABEL_51:
    v38 = v78;
LABEL_52:
    v41 = scrContext;
    goto LABEL_53;
  }
  if ( this->m_pAI->fixedNode )
    goto LABEL_51;
  Sys_ProfEndNamedEvent();
  v41 = scrContext;
  Scr_Error(COM_ERR_6180, scrContext, "only allowed to disable stepouts if we're in fixednode.");
  v38 = v78;
LABEL_53:
  if ( v18 )
    goto LABEL_74;
  if ( v38 )
  {
LABEL_75:
    v44 = &this->m_pAI->blackboard.m_CoverExposeType;
    if ( *v44 != m_CoverExposeType )
      Scr_SetString(v44, m_CoverExposeType);
    goto LABEL_150;
  }
LABEL_80:
  v45 = 0;
  v37 = v41;
LABEL_154:
  Scr_AddBool(v37, v45);
  Sys_ProfEndNamedEvent();
  __asm
  {
    vmovaps xmm10, [rsp+110h+var_88+8]
    vmovaps xmm9, [rsp+110h+var_78+8]
    vmovaps xmm8, [rsp+110h+var_68+8]
    vmovaps xmm6, xmmword ptr [rsp+110h+var_48+8]
    vmovaps xmm7, [rsp+110h+var_58+8]
  }
}

/*
==============
AIScriptedInterface::OnScrCmd_UpdateLastCoverTime
==============
*/
void AIScriptedInterface::OnScrCmd_UpdateLastCoverTime(AIScriptedInterface *this, scrContext_t *scrContext)
{
  this->m_pAI->lastCoverTime = level.time;
}

/*
==============
AIScriptedInterface::OnScrCmd_UseCoverNode
==============
*/
void AIScriptedInterface::OnScrCmd_UseCoverNode(AIScriptedInterface *this, scrContext_t *scrContext)
{
  pathnode_t *Pathnode; 
  bool v5; 

  if ( this->m_pAI->fixedNode )
    Scr_Error(COM_ERR_3839, scrContext, "cannot change node when using fixedNode mode");
  if ( AIScriptedInterface::KeepClaimedNode(this) )
    Scr_Error(COM_ERR_3840, scrContext, "cannot change node when nodeSelect.keepClaimedNode is set");
  if ( Scr_GetNumParam(scrContext) < 2 || Scr_GetType(scrContext, 1u) == VAR_UNDEFINED || Scr_GetInt(scrContext, 1u) )
    this->ClearPath(this);
  Pathnode = Scr_GetPathnode(scrContext, 0);
  v5 = AIScriptedInterface::Cover_UseCoverNode(this, Pathnode);
  Scr_AddBool(scrContext, v5);
}

/*
==============
PushStopDataToScript
==============
*/
void PushStopDataToScript(scrContext_t *scrContext, const gentity_s *pEnt, const AIAnimStopData *pStopData)
{
  unsigned int CanonicalString; 
  unsigned int v7; 
  unsigned int v8; 
  unsigned int v10; 
  unsigned int v11; 
  unsigned int v12; 
  unsigned int v13; 
  nav_space_s *m_pSpace; 
  int parentEntNum; 
  scrContext_t *v16; 
  const char *v17; 
  gentity_s *v18; 
  unsigned int v19; 
  unsigned int v20; 
  __int64 v21; 

  _RBX = pStopData;
  if ( !pEnt && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 6420, ASSERT_TYPE_ASSERT, "( pEnt )", (const char *)&queryFormat, "pEnt") )
    __debugbreak();
  if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 6421, ASSERT_TYPE_ASSERT, "( pStopData )", (const char *)&queryFormat, "pStopData") )
    __debugbreak();
  Scr_MakeStruct(scrContext);
  Scr_AddInt(scrContext, _RBX->stopAnimIndex);
  CanonicalString = SL_GetCanonicalString("stopanim");
  Scr_AddStructField(scrContext, CanonicalString);
  Scr_AddInt(scrContext, _RBX->angleIndex);
  v7 = SL_GetCanonicalString("angleindex");
  Scr_AddStructField(scrContext, v7);
  Scr_AddVector(scrContext, _RBX->startPos.v);
  v8 = SL_GetCanonicalString("startpos");
  Scr_AddStructField(scrContext, v8);
  __asm { vmovss  xmm1, dword ptr [rbx+14h]; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
  v10 = SL_GetCanonicalString("angledelta");
  Scr_AddStructField(scrContext, v10);
  Scr_AddVector(scrContext, _RBX->angles.v);
  v11 = SL_GetCanonicalString("angles");
  Scr_AddStructField(scrContext, v11);
  Scr_AddVector(scrContext, _RBX->finalAngles.v);
  v12 = SL_GetCanonicalString("finalangles");
  Scr_AddStructField(scrContext, v12);
  Scr_AddVector(scrContext, _RBX->moveDelta.v);
  v13 = SL_GetCanonicalString("movedelta");
  Scr_AddStructField(scrContext, v13);
  m_pSpace = Nav_GetNavigator(pEnt)->m_pSpace;
  parentEntNum = m_pSpace->parentEntNum;
  if ( parentEntNum != 2047 )
  {
    if ( !G_IsEntityInUse(parentEntNum) )
    {
      v16 = ScriptContext_Server();
      v17 = j_va("GetNavSpaceEnt : Space has invalid parent ent %d.", (unsigned int)m_pSpace->parentEntNum);
      Scr_Error(COM_ERR_3903, v16, v17);
    }
    if ( m_pSpace->parentEntNum >= 0x800u )
    {
      LODWORD(v21) = m_pSpace->parentEntNum;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 6310, ASSERT_TYPE_ASSERT, "(unsigned)( pSpace->parentEntNum ) < (unsigned)( ( 2048 ) )", "pSpace->parentEntNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v21, 2048) )
        __debugbreak();
    }
    v18 = &g_entities[m_pSpace->parentEntNum];
    if ( v18 )
    {
      Scr_AddVector(scrContext, v18->r.currentOrigin.v);
      v19 = SL_GetCanonicalString("parentpos");
      Scr_AddStructField(scrContext, v19);
      Scr_AddVector(scrContext, v18->r.currentAngles.v);
      v20 = SL_GetCanonicalString("parentangles");
      Scr_AddStructField(scrContext, v20);
    }
  }
}

/*
==============
AIScriptedInterface::SetIdleFacingUseAlliesPos
==============
*/
void AIScriptedInterface::SetIdleFacingUseAlliesPos(AIScriptedInterface *this, const vec3_t *pos)
{
  ai_scripted_t *m_pAI; 

  m_pAI = this->m_pAI;
  m_pAI->cachedIdleFacingUseAlliesPos = *pos;
  m_pAI->bCachedIdleFacingPosValid = 1;
}

/*
==============
AIScriptedInterface::SetupMotionWarpForTurn
==============
*/
bool AIScriptedInterface::SetupMotionWarpForTurn(AIScriptedInterface *this, const vec3_t *corner, const vec3_t *nextPathPoint, const vec3_t *turnStartAnimTranslation, const vec3_t *turnStartAnimRot, float turnStartSecs)
{
  char v36; 
  ai_scripted_t *m_pAI; 
  ai_scripted_t *duration; 
  gentity_s *ent; 
  bool result; 
  vec3_t out; 
  vec4_t quat; 
  vec3_t forward; 
  int v102[4]; 
  vec3_t animStartPos; 
  vec4_t v104; 
  vec4_t v105; 
  vec3_t targetAngles; 
  char v110; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
  }
  _RDI = corner;
  if ( !this->m_pAI->pNavigator && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\ai\\ai_scr.cpp", 6247, ASSERT_TYPE_ASSERT, "(m_pAI->pNavigator)", (const char *)&queryFormat, "m_pAI->pNavigator") )
    __debugbreak();
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vmovss  xmm1, dword ptr [rdi+4]
    vsubss  xmm9, xmm0, dword ptr [rcx+130h]
    vmovss  xmm0, dword ptr [rdi+8]
    vsubss  xmm6, xmm0, dword ptr [rcx+138h]
    vsubss  xmm8, xmm1, dword ptr [rcx+134h]
  }
  LOBYTE(_EAX) = this->Is3D(this);
  _ECX = 0;
  _EAX = (unsigned __int8)_EAX;
  __asm
  {
    vmovd   xmm1, ecx
    vmovd   xmm0, eax
    vpcmpeqd xmm2, xmm0, xmm1
    vxorps  xmm7, xmm7, xmm7
    vblendvps xmm6, xmm6, xmm7, xmm2
  }
  AngleVectors(&this->m_pAI->ent->r.currentAngles, &forward, NULL, NULL);
  __asm
  {
    vmulss  xmm1, xmm8, dword ptr [rsp+160h+forward+4]
    vmulss  xmm0, xmm9, dword ptr [rsp+160h+forward]
    vaddss  xmm3, xmm1, xmm0
    vmulss  xmm0, xmm6, dword ptr [rsp+160h+forward+8]
    vaddss  xmm1, xmm3, xmm0
    vcomiss xmm1, xmm7
  }
  if ( v36 )
    goto LABEL_7;
  AnglesToQuat(&this->m_pAI->ent->r.currentAngles, &quat);
  QuatTransform(&quat, turnStartAnimTranslation, &out);
  m_pAI = this->m_pAI;
  __asm
  {
    vmovss  xmm0, dword ptr [rsp+160h+out]
    vmovss  xmm2, dword ptr [rsp+160h+out+4]
    vaddss  xmm1, xmm0, dword ptr [rax+130h]
    vmovss  [rsp+160h+var_F8], xmm1
    vaddss  xmm0, xmm2, dword ptr [rax+134h]
    vmovss  xmm1, dword ptr [rsp+160h+out+8]
    vmovss  [rsp+160h+var_F4], xmm0
    vaddss  xmm2, xmm1, dword ptr [rax+138h]
    vmovss  [rsp+160h+var_F0], xmm2
  }
  if ( m_pAI->pNavigator->IsStraightLineReachable(m_pAI->pNavigator, (const vec3_t *)v102, nextPathPoint) )
  {
LABEL_7:
    result = 0;
  }
  else
  {
    __asm
    {
      vmovaps xmmword ptr [rsp+160h+var_88+8], xmm10
      vmovaps [rsp+160h+var_98+8], xmm11
      vmovaps [rsp+160h+var_A8+8], xmm12
    }
    AnglesToQuat(turnStartAnimRot, &v104);
    __asm
    {
      vmovss  xmm12, dword ptr [rbp+60h+var_D8]
      vmovss  xmm11, dword ptr [rsp+160h+quat+0Ch]
      vmovss  xmm10, dword ptr [rsp+160h+quat]
      vmovss  xmm7, dword ptr [rbp+60h+var_D8+0Ch]
      vmovss  xmm8, dword ptr [rbp+60h+var_D8+4]
      vmovss  xmm9, dword ptr [rsp+160h+quat+8]
      vmovss  xmm6, dword ptr [rbp+60h+var_D8+8]
      vmovss  xmm5, dword ptr [rsp+160h+quat+4]
      vmulss  xmm1, xmm12, xmm11
      vmulss  xmm0, xmm10, xmm7
      vaddss  xmm2, xmm1, xmm0
      vmulss  xmm0, xmm8, xmm9
      vaddss  xmm1, xmm2, xmm0
      vmulss  xmm0, xmm6, xmm5
      vsubss  xmm1, xmm1, xmm0
      vmovss  dword ptr [rbp+60h+var_C8], xmm1
      vmulss  xmm0, xmm9, xmm12
      vmulss  xmm2, xmm5, xmm7
      vsubss  xmm3, xmm2, xmm0
      vmulss  xmm1, xmm8, xmm11
      vaddss  xmm4, xmm3, xmm1
      vmulss  xmm0, xmm6, xmm10
      vaddss  xmm2, xmm4, xmm0
      vmovss  dword ptr [rbp+60h+var_C8+4], xmm2
      vmulss  xmm0, xmm9, xmm7
      vmulss  xmm1, xmm5, xmm12
      vaddss  xmm2, xmm1, xmm0
      vmulss  xmm1, xmm8, xmm10
      vsubss  xmm3, xmm2, xmm1
      vmulss  xmm0, xmm6, xmm11
      vaddss  xmm2, xmm3, xmm0
      vmulss  xmm0, xmm12, xmm10
      vmulss  xmm1, xmm11, xmm7
      vmovss  dword ptr [rbp+60h+var_C8+8], xmm2
      vsubss  xmm2, xmm1, xmm0
      vmulss  xmm1, xmm5, xmm8
      vsubss  xmm3, xmm2, xmm1
      vmulss  xmm0, xmm6, xmm9
      vsubss  xmm2, xmm3, xmm0
      vmovss  dword ptr [rbp+60h+var_C8+0Ch], xmm2
    }
    QuatToAngles(&v105, &targetAngles);
    duration = this->m_pAI;
    __asm
    {
      vmovss  xmm0, dword ptr [rdi]
      vsubss  xmm1, xmm0, dword ptr [rsp+160h+out]
      vmovss  xmm2, dword ptr [rdi+4]
      vsubss  xmm0, xmm2, dword ptr [rsp+160h+out+4]
      vmovss  dword ptr [rsp+160h+animStartPos], xmm1
      vmovss  xmm1, dword ptr [rdi+8]
      vsubss  xmm2, xmm1, dword ptr [rsp+160h+out+8]
      vmovss  dword ptr [rsp+160h+animStartPos+4], xmm0
      vmovss  xmm0, [rbp+60h+arg_28]
      vmulss  xmm1, xmm0, cs:__real@447a0000
      vmovss  dword ptr [rbp+60h+animStartPos+8], xmm2
    }
    ent = duration->ent;
    __asm { vcvttss2si eax, xmm1 }
    G_MotionWarp_StartWithAnim(ent->s.number, &animStartPos, &ent->r.currentAngles, _RDI, &targetAngles, (int)duration);
    __asm { vmovaps xmm12, [rsp+160h+var_A8+8] }
    result = 1;
    __asm
    {
      vmovaps xmm11, [rsp+160h+var_98+8]
      vmovaps xmm10, xmmword ptr [rsp+160h+var_88+8]
    }
  }
  _R11 = &v110;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-18h]
    vmovaps xmm7, xmmword ptr [r11-28h]
    vmovaps xmm8, xmmword ptr [r11-38h]
    vmovaps xmm9, xmmword ptr [r11-48h]
  }
  return result;
}

