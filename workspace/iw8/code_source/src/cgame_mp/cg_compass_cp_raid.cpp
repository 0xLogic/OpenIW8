/*
==============
CgCompassSystemCPRaid::DrawPlayerLayer
==============
*/

void __fastcall CgCompassSystemCPRaid::DrawPlayerLayer(CgCompassSystemCPRaid *this, const MinimapOptions *minimapOptions, const rectDef_s *parentRect, const rectDef_s *rect, const vec4_t *color, LUIElement *element, lua_State *luaVM)
{
  ?DrawPlayerLayer@CgCompassSystemCPRaid@@UEAAXPEBUMinimapOptions@@PEBUrectDef_s@@1AEBTvec4_t@@PEAULUIElement@@PEAUlua_State@@@Z(this, minimapOptions, parentRect, rect, color, element, luaVM);
}

/*
==============
CgCompassSystemCPRaid::GetObjectiveCompassColorCPRaid
==============
*/

void __fastcall CgCompassSystemCPRaid::GetObjectiveCompassColorCPRaid(CgCompassSystemCPRaid *this, const vec3_t *origin, ObjectiveSide side, ObjectiveSide progressSide, ObjectiveBackground background, int entNum, bool isSecurityScreen, vec4_t *newColor, vec4_t *backgroundColor, const vec4_t *color)
{
  ?GetObjectiveCompassColorCPRaid@CgCompassSystemCPRaid@@QEBAXAEBTvec3_t@@W4ObjectiveSide@@1W4ObjectiveBackground@@H_NAEATvec4_t@@4AEBT5@@Z(this, origin, side, progressSide, background, entNum, isSecurityScreen, newColor, backgroundColor, color);
}

/*
==============
CgCompassSystemCPRaid::DrawCursorLayer
==============
*/

void __fastcall CgCompassSystemCPRaid::DrawCursorLayer(CgCompassSystemCPRaid *this, const MinimapOptions *minimapOptions, const rectDef_s *parentRect, const rectDef_s *rect, const vec4_t *color, LUIElement *element, lua_State *luaVM)
{
  ?DrawCursorLayer@CgCompassSystemCPRaid@@UEAAXPEBUMinimapOptions@@PEBUrectDef_s@@1AEBTvec4_t@@PEAULUIElement@@PEAUlua_State@@@Z(this, minimapOptions, parentRect, rect, color, element, luaVM);
}

/*
==============
CgCompassSystemCPRaid::InitMaze
==============
*/

void __fastcall CgCompassSystemCPRaid::InitMaze(CgCompassSystemCPRaid *this, const GfxImage *image, const vec2_t *mazeUpperLeft, const vec2_t *mazeWorldSize)
{
  ?InitMaze@CgCompassSystemCPRaid@@QEAAXPEBUGfxImage@@AEBTvec2_t@@1@Z(this, image, mazeUpperLeft, mazeWorldSize);
}

/*
==============
CgCompassSystemCPRaid::DrawFriendliesCPRaid
==============
*/

void __fastcall CgCompassSystemCPRaid::DrawFriendliesCPRaid(CgCompassSystemCPRaid *this, CompassType compassType, bool cropPartialMap, bool largeMap, const rectDef_s *parentRect, const rectDef_s *rect, const float boundsRadius, const vec4_t *color, LUIElement *element, lua_State *luaVM)
{
  ?DrawFriendliesCPRaid@CgCompassSystemCPRaid@@QEAAXW4CompassType@@_N1PEBUrectDef_s@@2MAEBTvec4_t@@PEAULUIElement@@PEAUlua_State@@@Z(this, compassType, cropPartialMap, largeMap, parentRect, rect, boundsRadius, color, element, luaVM);
}

/*
==============
CgCompassSystemCPRaid::InitCompass
==============
*/

void __fastcall CgCompassSystemCPRaid::InitCompass(CgCompassSystemCPRaid *this)
{
  ?InitCompass@CgCompassSystemCPRaid@@QEAAXXZ(this);
}

/*
==============
CgCompassSystemCPRaid::DrawOthersLayer
==============
*/

void __fastcall CgCompassSystemCPRaid::DrawOthersLayer(CgCompassSystemCPRaid *this, const MinimapOptions *minimapOptions, const rectDef_s *parentRect, const rectDef_s *rect, const vec4_t *color, LUIElement *element, lua_State *luaVM)
{
  ?DrawOthersLayer@CgCompassSystemCPRaid@@UEAAXPEBUMinimapOptions@@PEBUrectDef_s@@1AEBTvec4_t@@PEAULUIElement@@PEAUlua_State@@@Z(this, minimapOptions, parentRect, rect, color, element, luaVM);
}

/*
==============
CgCompassSystemCPRaid::CgCompassSystemCPRaid
==============
*/

void __fastcall CgCompassSystemCPRaid::CgCompassSystemCPRaid(CgCompassSystemCPRaid *this, const LocalClientNum_t localClientNum)
{
  ??0CgCompassSystemCPRaid@@QEAA@W4LocalClientNum_t@@@Z(this, localClientNum);
}

/*
==============
CgCompassSystemCPRaid::DrawPlayerPointersCPRaid
==============
*/

void __fastcall CgCompassSystemCPRaid::DrawPlayerPointersCPRaid(CgCompassSystemCPRaid *this, CompassType compassType, bool cropPartialMap, bool largeMap, bool isSecurityScreen, const rectDef_s *parentRect, const rectDef_s *rect, const float boundsRadius, const vec4_t *color, LUIElement *element, lua_State *luaVM)
{
  ?DrawPlayerPointersCPRaid@CgCompassSystemCPRaid@@QEBAXW4CompassType@@_N11PEBUrectDef_s@@2MAEBTvec4_t@@PEAULUIElement@@PEAUlua_State@@@Z(this, compassType, cropPartialMap, largeMap, isSecurityScreen, parentRect, rect, boundsRadius, color, element, luaVM);
}

/*
==============
CgCompassSystemCPRaid::DrawPlayerCPRaid
==============
*/

void __fastcall CgCompassSystemCPRaid::DrawPlayerCPRaid(CgCompassSystemCPRaid *this, CompassType compassType, bool cropPartialMap, bool largeMap, const rectDef_s *parentRect, const rectDef_s *rect, const float boundsRadius, const vec4_t *color, LUIElement *element, lua_State *luaVM)
{
  ?DrawPlayerCPRaid@CgCompassSystemCPRaid@@QEAAXW4CompassType@@_N1PEBUrectDef_s@@2MAEBTvec4_t@@PEAULUIElement@@PEAUlua_State@@@Z(this, compassType, cropPartialMap, largeMap, parentRect, rect, boundsRadius, color, element, luaVM);
}

/*
==============
CgCompassSystemCPRaid::DrawEnemiesCPRaid
==============
*/

void __fastcall CgCompassSystemCPRaid::DrawEnemiesCPRaid(CgCompassSystemCPRaid *this, CompassType compassType, bool cropPartialMap, bool largeMap, const rectDef_s *parentRect, const rectDef_s *rect, const float boundsRadius, const vec4_t *color, LUIElement *element, lua_State *luaVM)
{
  ?DrawEnemiesCPRaid@CgCompassSystemCPRaid@@QEAAXW4CompassType@@_N1PEBUrectDef_s@@2MAEBTvec4_t@@PEAULUIElement@@PEAUlua_State@@@Z(this, compassType, cropPartialMap, largeMap, parentRect, rect, boundsRadius, color, element, luaVM);
}

/*
==============
CgCompassSystemCPRaid::DrawItemsLayer
==============
*/

void __fastcall CgCompassSystemCPRaid::DrawItemsLayer(CgCompassSystemCPRaid *this, const MinimapOptions *minimapOptions, const rectDef_s *parentRect, const rectDef_s *rect, const vec4_t *color, LUIElement *element, lua_State *luaVM)
{
  ?DrawItemsLayer@CgCompassSystemCPRaid@@UEAAXPEBUMinimapOptions@@PEBUrectDef_s@@1AEBTvec4_t@@PEAULUIElement@@PEAUlua_State@@@Z(this, minimapOptions, parentRect, rect, color, element, luaVM);
}

/*
==============
CgCompassSystemCPRaid::GetPlayerRoleMaterial
==============
*/

void __fastcall CgCompassSystemCPRaid::GetPlayerRoleMaterial(CgCompassSystemCPRaid *this, const LocalClientNum_t localClientNum, int clientNum, const GfxImage **material)
{
  ?GetPlayerRoleMaterial@CgCompassSystemCPRaid@@QEAAXW4LocalClientNum_t@@HPEAPEBUGfxImage@@@Z(this, localClientNum, clientNum, material);
}

/*
==============
CgCompassSystemCPRaid::DrawPlayerMapCPRaid
==============
*/

void __fastcall CgCompassSystemCPRaid::DrawPlayerMapCPRaid(CgCompassSystemCPRaid *this, CompassType compassType, bool cropPartialMap, const rectDef_s *parentRect, const rectDef_s *rect, Material *material, const vec4_t *color, GfxImage *mapMask, GfxImage *mapOverlay, GfxImage *mapRotOverlay, LUIElement *element, lua_State *luaVM, const GfxImage *mapMaterial)
{
  ?DrawPlayerMapCPRaid@CgCompassSystemCPRaid@@QEBAXW4CompassType@@_NPEBUrectDef_s@@2PEAUMaterial@@AEBTvec4_t@@PEAUGfxImage@@55PEAULUIElement@@PEAUlua_State@@PEBU6@@Z(this, compassType, cropPartialMap, parentRect, rect, material, color, mapMask, mapOverlay, mapRotOverlay, element, luaVM, mapMaterial);
}

/*
==============
CgCompassSystemCPRaid::DrawMapLayer
==============
*/

void __fastcall CgCompassSystemCPRaid::DrawMapLayer(CgCompassSystemCPRaid *this, const MinimapOptions *minimapOptions, const rectDef_s *parentRect, const rectDef_s *rect, const vec4_t *color, const vec4_t *mapColor, LUIElement *element, lua_State *luaVM)
{
  ?DrawMapLayer@CgCompassSystemCPRaid@@UEAAXPEBUMinimapOptions@@PEBUrectDef_s@@1AEBTvec4_t@@2PEAULUIElement@@PEAUlua_State@@@Z(this, minimapOptions, parentRect, rect, color, mapColor, element, luaVM);
}

/*
==============
CgCompassSystemCPRaid::CgCompassSystemCPRaid
==============
*/
void CgCompassSystemCPRaid::CgCompassSystemCPRaid(CgCompassSystemCPRaid *this, const LocalClientNum_t localClientNum)
{
  CgCompassSystemMP::CgCompassSystemMP(this, localClientNum);
  this->__vftable = (CgCompassSystemCPRaid_vtbl *)&CgCompassSystemCPRaid::`vftable';
  this->mazeCompassMapUpperLeft = 0i64;
  this->mazeCompassMapWorldSize.v[0] = 1.0;
  this->mazeCompassMapWorldSize.v[1] = 1.0;
}

/*
==============
CgCompassSystemCPRaid::DrawCursorLayer
==============
*/
void CgCompassSystemCPRaid::DrawCursorLayer(CgCompassSystemCPRaid *this, const MinimapOptions *minimapOptions, const rectDef_s *parentRect, const rectDef_s *rect, const vec4_t *color, LUIElement *element, lua_State *luaVM)
{
  if ( !minimapOptions->isCPRaidSecurityScreen )
    CgCompassSystemMP::DrawCursorLayer(this, minimapOptions, parentRect, rect, color, element, luaVM);
}

/*
==============
CgCompassSystemCPRaid::DrawEnemiesCPRaid
==============
*/
void CgCompassSystemCPRaid::DrawEnemiesCPRaid(CgCompassSystemCPRaid *this, CompassType compassType, bool cropPartialMap, bool largeMap, const rectDef_s *parentRect, const rectDef_s *rect, const float boundsRadius, const vec4_t *color, LUIElement *element, lua_State *luaVM)
{
  CgGlobalsMP *LocalClientGlobals; 
  CgStatic *LocalClientStatics; 
  characterInfo_t *CharacterInfo; 
  char v27; 
  vec2_t *p_mazeCompassMapWorldSize; 
  int *p_lastUpdate; 
  __int64 v38; 
  int v41; 
  int time; 
  int vertAlign; 
  int horzAlign; 
  const ScreenPlacement *ActivePlacement; 
  float fmt; 
  float fmta; 
  float outVector; 
  float y; 
  float w; 
  float h; 
  float playerWorldPos; 
  float in; 
  float v74; 
  float outClipped; 
  float v76; 
  float v77; 
  float width; 
  float v80; 
  float v81; 
  float outAngle; 
  vec2_t outPos; 
  const rectDef_s *v84; 
  lua_State *v85; 
  LUIElement *v86; 
  SecureVec3 out; 
  __int64 v88; 
  vec2_t v89; 
  vec4_t v90; 
  rectDef_s x; 
  vec2_t north; 
  char v93; 
  void *retaddr; 

  _RAX = &retaddr;
  v88 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
    vmovaps xmmword ptr [rax-88h], xmm10
    vmovaps xmmword ptr [rax-98h], xmm11
  }
  v84 = rect;
  v86 = element;
  v85 = luaVM;
  LocalClientGlobals = CgGlobalsMP::GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  LocalClientStatics = CgStatic::GetLocalClientStatics((const LocalClientNum_t)this->m_localClientNum);
  CharacterInfo = CgStatic::GetCharacterInfo(LocalClientStatics, LocalClientGlobals->predictedPlayerState.clientNum);
  if ( !LocalClientGlobals->nextSnap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame_mp\\cg_compass_cp_raid.cpp", 365, ASSERT_TYPE_ASSERT, "(cgameGlob->nextSnap)", (const char *)&queryFormat, "cgameGlob->nextSnap") )
    __debugbreak();
  if ( !CharacterInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame_mp\\cg_compass_cp_raid.cpp", 366, ASSERT_TYPE_ASSERT, "(localClientInfo)", (const char *)&queryFormat, "localClientInfo") )
    __debugbreak();
  CgCompassSystem::GetCompassYaw(this, compassType, cropPartialMap, LocalClientGlobals, &outAngle, &north);
  *(double *)&_XMM0 = CgCompassSystem::GetIconFadeAlpha(this, (const LocalClientNum_t)this->m_localClientNum, compassType);
  _RBX = color;
  __asm
  {
    vmulss  xmm6, xmm0, dword ptr [rbx+0Ch]
    vxorps  xmm7, xmm7, xmm7
    vucomiss xmm6, xmm7
  }
  if ( !v27 && CharacterInfo->infoValid && CharacterInfo->team != TEAM_SPECTATOR )
  {
    p_mazeCompassMapWorldSize = &this->mazeCompassMapWorldSize;
    CG_CompassCalcDimensions(compassType, LocalClientGlobals, parentRect, rect, &this->mazeCompassMapWorldSize, &x.x, &x.y, &x.w, &x.h);
    __asm
    {
      vmovss  xmm3, cs:__real@3f000000
      vmulss  xmm1, xmm3, [rbp+0A0h+var_B0]
      vaddss  xmm10, xmm1, [rbp+0A0h+x]
      vmulss  xmm0, xmm3, [rbp+0A0h+var_AC]
      vaddss  xmm11, xmm0, [rbp+0A0h+var_B4]
      vmovss  xmm1, dword ptr [rbx]
      vmovss  dword ptr [rbp+0A0h+var_C8], xmm1
      vmovss  xmm0, dword ptr [rbx+4]
      vmovss  dword ptr [rbp+0A0h+var_C8+4], xmm0
      vmovss  xmm1, dword ptr [rbx+8]
      vmovss  dword ptr [rbp+0A0h+var_C8+8], xmm1
    }
    CgCompassSystemMP::GetEnemyCompassColor(this, &v90, LocalClientGlobals);
    ScrPlace_GetActivePlacement((const LocalClientNum_t)this->m_localClientNum);
    CG_CalcPlayerPos(&out, this->m_localClientNum);
    p_lastUpdate = &this->m_compassActors[0].lastUpdate;
    v38 = 248i64;
    __asm
    {
      vmovss  xmm9, [rbp+0A0h+boundsRadius]
      vmovss  xmm8, cs:__real@3f800000
    }
    do
    {
      if ( (*(_BYTE *)(p_lastUpdate - 1) & 1) != 0 )
      {
        v41 = *p_lastUpdate;
        time = LocalClientGlobals->time;
        if ( *p_lastUpdate > time )
        {
          *p_lastUpdate = 0;
          time = LocalClientGlobals->time;
          v41 = 0;
        }
        if ( v41 >= time - 500 )
        {
          CompassActor_GetLastPos((const CompassActor *const)(p_lastUpdate - 1), &outPos);
          __asm { vmovss  dword ptr [rsp+1B0h+fmt], xmm9 }
          if ( !CgCompassSystem::WorldPosToCompass(this, compassType, cropPartialMap, &x, fmt, p_mazeCompassMapWorldSize, &this->mazeCompassMapUpperLeft, &LocalClientGlobals->compassNorth, &north, (const vec2_t *)&out, &outPos, NULL, &v89) || Dvar_GetBool_Internal_DebugName(DVARBOOL_compassClampIcons, "compassClampIcons") )
          {
            CalcCompassFriendlySize(compassType, &v81, &v80);
            __asm
            {
              vaddss  xmm1, xmm10, dword ptr [rbp+0A0h+var_D0]
              vmovss  dword ptr [rbp+0A0h+var_D0], xmm1
              vaddss  xmm0, xmm11, dword ptr [rbp+0A0h+var_D0+4]
              vmovss  dword ptr [rbp+0A0h+var_D0+4], xmm0
            }
            vertAlign = v84->vertAlign;
            horzAlign = v84->horzAlign;
            ActivePlacement = ScrPlace_GetActivePlacement((const LocalClientNum_t)this->m_localClientNum);
            ScrPlace_ApplyRect(ActivePlacement, (float *)&v89, (float *)&v89 + 1, &v81, &v80, horzAlign, vertAlign);
            __asm
            {
              vmovss  xmm0, [rbp+0A0h+outAngle]
              vsubss  xmm0, xmm0, dword ptr [rsi+4]; angle
            }
            *(double *)&_XMM0 = AngleNormalize360(*(const float *)&_XMM0);
            __asm
            {
              vmovss  [rbp+0A0h+width], xmm0
              vmovaps xmm3, xmm0; in
            }
            CgCompassSystem::WorldYawToCompass(this, compassType, LocalClientGlobals, *(const float *)&_XMM3, &width);
            if ( cgMedia.compass.enemy_arrow )
            {
              __asm
              {
                vmovss  dword ptr [rbp+0A0h+var_C8+0Ch], xmm6
                vmovss  [rsp+1B0h+var_140], xmm6
                vmovss  xmm0, dword ptr [rbp+0A0h+var_C8+8]
                vmovss  [rsp+1B0h+var_148], xmm0
                vmovss  xmm1, dword ptr [rbp+0A0h+var_C8+4]
                vmovss  dword ptr [rsp+1B0h+outClipped], xmm1
                vmovss  xmm0, dword ptr [rbp+0A0h+var_C8]
                vmovss  dword ptr [rsp+1B0h+var_158], xmm0
                vmovss  xmm1, [rbp+0A0h+width]
                vmovss  dword ptr [rsp+1B0h+in], xmm1
                vmovss  dword ptr [rsp+1B0h+playerWorldPos], xmm8
                vmovss  dword ptr [rsp+1B0h+h], xmm8
                vmovss  dword ptr [rsp+1B0h+w], xmm7
                vmovss  dword ptr [rsp+1B0h+y], xmm7
                vmovss  xmm0, [rbp+0A0h+var_118]
                vmovss  dword ptr [rsp+1B0h+outVector], xmm0
                vmovss  xmm1, [rbp+0A0h+var_114]
                vmovss  dword ptr [rsp+1B0h+fmt], xmm1
                vmovss  xmm3, dword ptr [rbp+0A0h+var_D0+4]; centerY
                vmovss  xmm2, dword ptr [rbp+0A0h+var_D0]; centerX
              }
              LUI_Render_DrawQuadRotated((const LocalClientNum_t)this->m_localClientNum, v86, *(float *)&_XMM2, *(float *)&_XMM3, fmta, outVector, y, w, h, playerWorldPos, in, v74, outClipped, v76, v77, cgMedia.compass.enemy_arrow, v85);
            }
            p_mazeCompassMapWorldSize = &this->mazeCompassMapWorldSize;
          }
        }
      }
      p_lastUpdate += 34;
      --v38;
    }
    while ( v38 );
  }
  memset(&out, 0, sizeof(out));
  memset(&outPos, 0, sizeof(outPos));
  _R11 = &v93;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
  }
}

/*
==============
CgCompassSystemCPRaid::DrawFriendliesCPRaid
==============
*/
void CgCompassSystemCPRaid::DrawFriendliesCPRaid(CgCompassSystemCPRaid *this, CompassType compassType, bool cropPartialMap, bool largeMap, const rectDef_s *parentRect, const rectDef_s *rect, const float boundsRadius, const vec4_t *color, LUIElement *element, lua_State *luaVM)
{
  CgGlobalsMP *LocalClientGlobals; 
  characterInfo_t *CharacterInfo; 
  bool v27; 
  bool v28; 
  CompassType v30; 
  int v39; 
  int *p_lastUpdate; 
  int v44; 
  int time; 
  bool v46; 
  CgStatic *v47; 
  clientInfo_t *v48; 
  const clientInfo_t *v49; 
  bool m_useSquads; 
  bool v51; 
  int vertAlign; 
  int horzAlign; 
  const ScreenPlacement *ActivePlacement; 
  int v61; 
  int v62; 
  int v63; 
  const char *PlayerRole; 
  const char *v65; 
  GfxImage *v66; 
  char v70; 
  const GfxImage *party_yelling; 
  lua_State *v99; 
  LUIElement *v108; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float fmtc; 
  float x; 
  float xa; 
  float xb; 
  float y; 
  float ya; 
  float yb; 
  float w; 
  float wa; 
  float wb; 
  float h; 
  float ha; 
  float hb; 
  float playerWorldPos; 
  float playerWorldPosa; 
  float playerWorldPosb; 
  float in; 
  float ina; 
  float inb; 
  float v149; 
  float v150; 
  float v151; 
  float outClipped; 
  float outClippeda; 
  float outClippedb; 
  float v155; 
  float v156; 
  float v157; 
  float v158; 
  float v159; 
  float v160; 
  GfxImage *material; 
  float v163; 
  float v164; 
  CompassType compassTypea; 
  unsigned int clientNum; 
  int v167; 
  GfxImage *output_material; 
  vec2_t outPos; 
  LUIElement *v170; 
  lua_State *v171; 
  CgStatic *LocalClientStatics; 
  const rectDef_s *v173; 
  SecureVec3 out; 
  __int64 v175; 
  vec2_t v1; 
  vec4_t v177; 
  vec2_t v0; 
  rectDef_s mapRect; 
  char v180; 
  void *retaddr; 

  _RAX = &retaddr;
  v175 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
    vmovaps xmmword ptr [rax-88h], xmm10
    vmovaps xmmword ptr [rax-98h], xmm11
    vmovaps xmmword ptr [rax-0A8h], xmm12
    vmovaps xmmword ptr [rax-0B8h], xmm13
    vmovaps xmmword ptr [rax-0C8h], xmm14
  }
  compassTypea = compassType;
  v173 = rect;
  v170 = element;
  v171 = luaVM;
  LocalClientGlobals = CgGlobalsMP::GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  LocalClientStatics = CgStatic::GetLocalClientStatics((const LocalClientNum_t)this->m_localClientNum);
  *(double *)&_XMM0 = CgCompassSystem::GetIconFadeAlpha(this, (const LocalClientNum_t)this->m_localClientNum, compassType);
  _RBX = color;
  __asm { vmulss  xmm11, xmm0, dword ptr [rbx+0Ch] }
  output_material = NULL;
  clientNum = LocalClientGlobals->predictedPlayerState.clientNum;
  CharacterInfo = CgStatic::GetCharacterInfo(LocalClientStatics, clientNum);
  v27 = LocalClientGlobals->nextSnap == NULL;
  if ( !LocalClientGlobals->nextSnap )
  {
    v28 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame_mp\\cg_compass_cp_raid.cpp", 201, ASSERT_TYPE_ASSERT, "(cgameGlob->nextSnap)", (const char *)&queryFormat, "cgameGlob->nextSnap");
    v27 = !v28;
    if ( v28 )
      __debugbreak();
  }
  __asm
  {
    vxorps  xmm9, xmm9, xmm9
    vucomiss xmm11, xmm9
  }
  if ( !v27 && CharacterInfo->infoValid && CharacterInfo->team == TEAM_TWO )
  {
    v30 = compassTypea;
    CG_CompassCalcDimensions(compassTypea, LocalClientGlobals, parentRect, rect, &this->mazeCompassMapWorldSize, &mapRect.x, &mapRect.y, &mapRect.w, &mapRect.h);
    __asm
    {
      vmovss  xmm3, cs:__real@3f000000
      vmulss  xmm1, xmm3, [rbp+0E0h+mapRect.w]
      vaddss  xmm12, xmm1, [rbp+0E0h+mapRect.x]
      vmulss  xmm0, xmm3, [rbp+0E0h+mapRect.h]
      vaddss  xmm13, xmm0, [rbp+0E0h+mapRect.y]
      vmovss  xmm1, dword ptr [rbx]
      vmovss  dword ptr [rbp+0E0h+var_F8], xmm1
      vmovss  xmm0, dword ptr [rbx+4]
      vmovss  dword ptr [rbp+0E0h+var_F8+4], xmm0
      vmovss  xmm1, dword ptr [rbx+8]
      vmovss  dword ptr [rbp+0E0h+var_F8+8], xmm1
    }
    CgCompassSystemMP::GetFriendlyCompassColor(this, &v177, LocalClientGlobals);
    v39 = 0;
    v167 = 0;
    p_lastUpdate = &this->m_compassActors[0].lastUpdate;
    __asm
    {
      vmovss  xmm14, [rbp+0E0h+boundsRadius]
      vmovss  xmm10, cs:__real@447a0000
      vmovss  xmm8, cs:__real@3f800000
    }
    while ( 1 )
    {
      v44 = *p_lastUpdate;
      time = LocalClientGlobals->time;
      if ( *p_lastUpdate > time )
      {
        *p_lastUpdate = 0;
        time = LocalClientGlobals->time;
        v44 = 0;
      }
      if ( v44 < time - 500 || (*(_BYTE *)(p_lastUpdate - 1) & 5) != 0 || clientNum == v39 )
        goto LABEL_71;
      CG_CalcPlayerPos(&out, this->m_localClientNum);
      CompassActor_GetLastPos((const CompassActor *const)(p_lastUpdate - 1), &outPos);
      __asm
      {
        vmovss  dword ptr [rbp+0E0h+v1], xmm9
        vmovss  dword ptr [rbp+0E0h+v1+4], xmm9
        vmovss  dword ptr [rsp+1F0h+fmt], xmm14
      }
      v46 = CgCompassSystem::WorldPosToCompass(this, v30, cropPartialMap, &mapRect, fmt, &this->mazeCompassMapWorldSize, &this->mazeCompassMapUpperLeft, &LocalClientGlobals->compassNorth, &this->m_compassPlayerForward, (const vec2_t *)&out, &outPos, &v0, &v1);
      if ( !v46 || Dvar_GetBool_Internal_DebugName(DVARBOOL_compassClampIcons, "compassClampIcons") && !Dvar_GetBool_Internal_DebugName(DVARBOOL_compassHideClippedFriendlies, "compassHideClippedFriendlies") )
        break;
LABEL_70:
      memset(&outPos, 0, sizeof(outPos));
LABEL_71:
      v167 = ++v39;
      p_lastUpdate += 34;
      if ( v39 >= 248 )
        goto LABEL_72;
    }
    v47 = LocalClientStatics;
    v48 = LocalClientStatics->GetClientInfo(LocalClientStatics, clientNum);
    if ( !v48 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame_mp\\cg_compass_cp_raid.cpp", 253, ASSERT_TYPE_ASSERT, "(myClientInfo)", (const char *)&queryFormat, "myClientInfo") )
      __debugbreak();
    v49 = v47->GetClientInfo(v47, v39);
    if ( !v49 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame_mp\\cg_compass_cp_raid.cpp", 255, ASSERT_TYPE_ASSERT, "(clientInfo)", (const char *)&queryFormat, "clientInfo") )
      __debugbreak();
    this->ComputeFriendlyCompassColor(this, v48, v49, &v177);
    m_useSquads = LocalClientGlobals->m_useSquads;
    v51 = m_useSquads && v48->squadIndex == v49->squadIndex;
    if ( v46 && m_useSquads && !v51 && Dvar_GetBool_Internal_DebugName(DVARBOOL_compassHideClippedNonSquad, "compassHideClippedNonSquad") )
    {
LABEL_69:
      v30 = compassTypea;
      goto LABEL_70;
    }
    CalcCompassFriendlySize(compassTypea, &v164, &v163);
    __asm
    {
      vaddss  xmm1, xmm12, dword ptr [rbp+0E0h+v0]
      vmovss  dword ptr [rbp+0E0h+v0], xmm1
      vaddss  xmm0, xmm13, dword ptr [rbp+0E0h+v0+4]
      vmovss  dword ptr [rbp+0E0h+v0+4], xmm0
      vaddss  xmm2, xmm12, dword ptr [rbp+0E0h+v1]
      vmovss  dword ptr [rbp+0E0h+v1], xmm2
      vaddss  xmm1, xmm13, dword ptr [rbp+0E0h+v1+4]
      vmovss  dword ptr [rbp+0E0h+v1+4], xmm1
    }
    if ( v46 )
    {
      *(double *)&_XMM0 = CalcCompassClippedDistanceScale(&v0, &v1, 0);
      __asm
      {
        vmulss  xmm2, xmm0, [rbp+0E0h+var_158]
        vmovss  [rbp+0E0h+var_158], xmm2
        vmulss  xmm0, xmm0, [rbp+0E0h+var_15C]
        vmovss  [rbp+0E0h+var_15C], xmm0
      }
    }
    vertAlign = v173->vertAlign;
    horzAlign = v173->horzAlign;
    ActivePlacement = ScrPlace_GetActivePlacement((const LocalClientNum_t)this->m_localClientNum);
    ScrPlace_ApplyRect(ActivePlacement, (float *)&v1, (float *)&v1 + 1, &v164, &v163, horzAlign, vertAlign);
    v61 = LocalClientGlobals->time;
    v62 = p_lastUpdate[23];
    if ( v61 < v62 )
    {
      if ( *((_BYTE *)p_lastUpdate + 118) && (v62 - v61) % 500 >= 250 )
      {
        v63 = 1;
        output_material = (GfxImage *)cgMedia.compass.party_chatting;
LABEL_37:
        v66 = NULL;
        __asm { vmovaps xmm7, xmm9 }
        _RDI = DVARFLT_compassSoundPingFadeTime;
        if ( !DVARFLT_compassSoundPingFadeTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "compassSoundPingFadeTime") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(_RDI);
        __asm
        {
          vmovss  xmm0, dword ptr [rdi+28h]
          vcomiss xmm0, xmm9
        }
        if ( v70 | v27 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame_mp\\cg_compass_cp_raid.cpp", 298, ASSERT_TYPE_ASSERT, "(Dvar_GetFloat_Internal_DebugName( DVARFLT_compassSoundPingFadeTime, \"compassSoundPingFadeTime\" ) > 0.0f)", (const char *)&queryFormat, "Dvar_GetFloat( compassSoundPingFadeTime ) > 0.0f") )
          __debugbreak();
        *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DVARFLT_compassSoundPingFadeTime, "compassSoundPingFadeTime");
        __asm
        {
          vmulss  xmm1, xmm0, xmm10
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, ecx
          vaddss  xmm2, xmm0, xmm1
          vxorps  xmm1, xmm1, xmm1
          vcvtsi2ss xmm1, xmm1, eax
          vcomiss xmm2, xmm1
        }
        if ( !v70 )
        {
          if ( p_lastUpdate[24] < LocalClientGlobals->time )
          {
            __asm
            {
              vxorps  xmm6, xmm6, xmm6
              vcvtsi2ss xmm6, xmm6, eax
            }
            *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DVARFLT_compassSoundPingFadeTime, "compassSoundPingFadeTime");
            __asm
            {
              vmulss  xmm1, xmm0, xmm10
              vdivss  xmm2, xmm6, xmm1
              vsubss  xmm7, xmm8, xmm2
            }
          }
          else
          {
            __asm { vmovaps xmm7, xmm8 }
          }
          v66 = output_material;
        }
        party_yelling = NULL;
        __asm { vmovaps xmm6, xmm9 }
        *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DVARFLT_compassSoundPingFadeTime, "compassSoundPingFadeTime");
        __asm
        {
          vmulss  xmm1, xmm0, xmm10
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, ecx
          vaddss  xmm2, xmm0, xmm1
          vxorps  xmm1, xmm1, xmm1
          vcvtsi2ss xmm1, xmm1, eax
          vcomiss xmm2, xmm1
        }
        if ( !v70 )
        {
          if ( p_lastUpdate[26] < LocalClientGlobals->time )
          {
            __asm
            {
              vxorps  xmm6, xmm6, xmm6
              vcvtsi2ss xmm6, xmm6, eax
            }
            *(double *)&_XMM0 = Dvar_GetFloat_Internal_DebugName(DVARFLT_compassSoundPingFadeTime, "compassSoundPingFadeTime");
            __asm
            {
              vmulss  xmm1, xmm0, xmm10
              vdivss  xmm2, xmm6, xmm1
              vsubss  xmm6, xmm8, xmm2
            }
          }
          else
          {
            __asm { vmovaps xmm6, xmm8 }
          }
          party_yelling = cgMedia.compass.party_yelling;
        }
        if ( output_material )
        {
          if ( v66 )
            __asm { vucomiss xmm7, xmm8 }
          if ( party_yelling )
            __asm { vucomiss xmm6, xmm8 }
          __asm
          {
            vmovss  dword ptr [rbp+0E0h+var_F8+0Ch], xmm11
            vmovss  dword ptr [rsp+1F0h+var_180], xmm11
            vmovss  xmm0, dword ptr [rbp+0E0h+var_F8+8]
            vmovss  [rsp+1F0h+var_188], xmm0
            vmovss  xmm1, dword ptr [rbp+0E0h+var_F8+4]
            vmovss  dword ptr [rsp+1F0h+outClipped], xmm1
            vmovss  xmm0, dword ptr [rbp+0E0h+var_F8]
            vmovss  dword ptr [rsp+1F0h+var_198], xmm0
            vmovss  dword ptr [rsp+1F0h+in], xmm9
            vmovss  dword ptr [rsp+1F0h+playerWorldPos], xmm8
            vmovss  dword ptr [rsp+1F0h+h], xmm8
            vmovss  dword ptr [rsp+1F0h+w], xmm9
            vmovss  dword ptr [rsp+1F0h+y], xmm9
            vmovss  xmm0, [rbp+0E0h+var_15C]
            vmovss  dword ptr [rsp+1F0h+x], xmm0
            vmovss  xmm1, [rbp+0E0h+var_158]
            vmovss  dword ptr [rsp+1F0h+fmt], xmm1
            vmovss  xmm3, dword ptr [rbp+0E0h+v1+4]; centerY
            vmovss  xmm2, dword ptr [rbp+0E0h+v1]; centerX
          }
          LUI_Render_DrawQuadRotated((const LocalClientNum_t)this->m_localClientNum, v170, *(float *)&_XMM2, *(float *)&_XMM3, fmta, x, y, w, h, playerWorldPos, in, v149, outClipped, v155, v158, output_material, v171);
        }
        if ( !v63 )
        {
          v99 = v171;
          if ( party_yelling )
          {
            __asm
            {
              vmulss  xmm0, xmm6, xmm11
              vmovss  dword ptr [rbp+0E0h+var_F8+0Ch], xmm0
            }
            material = (GfxImage *)party_yelling;
            __asm
            {
              vmovss  dword ptr [rsp+1F0h+var_180], xmm0
              vmovss  xmm0, dword ptr [rbp+0E0h+var_F8+8]
              vmovss  [rsp+1F0h+var_188], xmm0
              vmovss  xmm1, dword ptr [rbp+0E0h+var_F8+4]
              vmovss  dword ptr [rsp+1F0h+outClipped], xmm1
              vmovss  xmm0, dword ptr [rbp+0E0h+var_F8]
              vmovss  dword ptr [rsp+1F0h+var_198], xmm0
              vmovss  dword ptr [rsp+1F0h+in], xmm9
              vmovss  dword ptr [rsp+1F0h+playerWorldPos], xmm8
              vmovss  dword ptr [rsp+1F0h+h], xmm8
              vmovss  dword ptr [rsp+1F0h+w], xmm9
              vmovss  dword ptr [rsp+1F0h+y], xmm9
              vmovss  xmm0, [rbp+0E0h+var_15C]
              vmovss  dword ptr [rsp+1F0h+x], xmm0
              vmovss  xmm1, [rbp+0E0h+var_158]
              vmovss  dword ptr [rsp+1F0h+fmt], xmm1
              vmovss  xmm3, dword ptr [rbp+0E0h+v1+4]; centerY
              vmovss  xmm2, dword ptr [rbp+0E0h+v1]; centerX
            }
            v108 = v170;
            LUI_Render_DrawQuadRotated((const LocalClientNum_t)this->m_localClientNum, v170, *(float *)&_XMM2, *(float *)&_XMM3, fmtb, xa, ya, wa, ha, playerWorldPosa, ina, v150, outClippeda, v156, v159, material, v171);
          }
          else
          {
            v108 = v170;
          }
          if ( v66 )
          {
            __asm
            {
              vmulss  xmm0, xmm7, xmm11
              vmovss  dword ptr [rbp+0E0h+var_F8+0Ch], xmm0
              vmovss  dword ptr [rsp+1F0h+var_180], xmm0
              vmovss  xmm0, dword ptr [rbp+0E0h+var_F8+8]
              vmovss  [rsp+1F0h+var_188], xmm0
              vmovss  xmm1, dword ptr [rbp+0E0h+var_F8+4]
              vmovss  dword ptr [rsp+1F0h+outClipped], xmm1
              vmovss  xmm0, dword ptr [rbp+0E0h+var_F8]
              vmovss  dword ptr [rsp+1F0h+var_198], xmm0
              vmovss  dword ptr [rsp+1F0h+in], xmm9
              vmovss  dword ptr [rsp+1F0h+playerWorldPos], xmm8
              vmovss  dword ptr [rsp+1F0h+h], xmm8
              vmovss  dword ptr [rsp+1F0h+w], xmm9
              vmovss  dword ptr [rsp+1F0h+y], xmm9
              vmovss  xmm0, [rbp+0E0h+var_15C]
              vmovss  dword ptr [rsp+1F0h+x], xmm0
              vmovss  xmm1, [rbp+0E0h+var_158]
              vmovss  dword ptr [rsp+1F0h+fmt], xmm1
              vmovss  xmm3, dword ptr [rbp+0E0h+v1+4]; centerY
              vmovss  xmm2, dword ptr [rbp+0E0h+v1]; centerX
            }
            LUI_Render_DrawQuadRotated((const LocalClientNum_t)this->m_localClientNum, v108, *(float *)&_XMM2, *(float *)&_XMM3, fmtc, xb, yb, wb, hb, playerWorldPosb, inb, v151, outClippedb, v157, v160, v66, v99);
          }
        }
        v39 = v167;
        goto LABEL_69;
      }
    }
    else
    {
      *((_BYTE *)p_lastUpdate + 118) = 0;
    }
    v63 = 0;
    PlayerRole = CL_PlayerData_GetPlayerRole(this->m_localClientNum, v49->clientNum);
    v65 = StringTable_LookupFromAsset("cp/cp_fieldupgrades.csv", 1, PlayerRole, 2);
    if ( *v65 )
      LUI_Interface_RegisterMaterial(v65, (const GfxImage **)&output_material);
    goto LABEL_37;
  }
LABEL_72:
  memset(&out, 0, sizeof(out));
  _R11 = &v180;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
    vmovaps xmm13, xmmword ptr [r11-80h]
    vmovaps xmm14, xmmword ptr [r11-90h]
  }
}

/*
==============
CgCompassSystemCPRaid::DrawItemsLayer
==============
*/
void CgCompassSystemCPRaid::DrawItemsLayer(CgCompassSystemCPRaid *this, const MinimapOptions *minimapOptions, const rectDef_s *parentRect, const rectDef_s *rect, const vec4_t *color, LUIElement *element, lua_State *luaVM)
{
  bool cropPartialMap; 
  CompassType compassType; 
  float parentRecta; 
  float parentRectb; 
  float parentRectc; 
  float parentRectd; 
  float parentRecte; 
  float parentRectf; 
  float parentRectg; 
  float v30; 
  float mapMask; 
  float mapMaska; 
  void *retaddr; 

  _RAX = &retaddr;
  cropPartialMap = minimapOptions->cropPartialMap;
  __asm { vmovss  xmm0, dword ptr [rdx+38h] }
  _R14 = minimapOptions;
  if ( minimapOptions->isCPRaidSecurityScreen )
  {
    __asm { vmovss  dword ptr [rsp+78h+mapMask], xmm0 }
    CgCompassSystemCPRaid::DrawPlayerPointersCPRaid(this, minimapOptions->compassType, cropPartialMap, minimapOptions->largeMap, 1, parentRect, rect, mapMaska, color, element, luaVM);
  }
  else
  {
    compassType = minimapOptions->compassType;
    __asm { vmovss  dword ptr [rax-50h], xmm0 }
    CgCompassSystemMP::ComputeWorldToScreenScale(this, compassType, cropPartialMap, parentRect, rect, parentRecta, element, luaVM);
    __asm
    {
      vmovss  xmm0, dword ptr [r14+38h]
      vmovss  dword ptr [rsp+78h+parentRect], xmm0
    }
    CgCompassSystemMP::DrawScramblers(this, _R14->compassType, _R14->cropPartialMap, parentRect, rect, parentRectb, color, _R14->mapMask, element, luaVM);
    __asm
    {
      vmovss  xmm0, dword ptr [r14+38h]
      vmovss  dword ptr [rsp+78h+parentRect], xmm0
    }
    CgCompassSystemMP::DrawPortableRadar(this, _R14->compassType, _R14->cropPartialMap, parentRect, rect, parentRectc, color, _R14->mapMask, element, luaVM);
    __asm
    {
      vmovss  xmm0, dword ptr [r14+38h]
      vmovss  dword ptr [rsp+78h+mapMask], xmm0
    }
    CgCompassSystemCPRaid::DrawPlayerPointersCPRaid(this, _R14->compassType, _R14->cropPartialMap, _R14->largeMap, 0, parentRect, rect, mapMask, color, element, luaVM);
    __asm
    {
      vmovss  xmm0, dword ptr [r14+38h]
      vmovss  dword ptr [rsp+78h+parentRect], xmm0
    }
    CgCompassSystemMP::DrawTurrets(this, _R14->compassType, _R14->cropPartialMap, parentRect, rect, parentRectd, color, element, luaVM);
    __asm
    {
      vmovss  xmm0, dword ptr [r14+38h]
      vmovss  dword ptr [rsp+78h+parentRect], xmm0
    }
    CgCompassSystemMP::DrawPlanes(this, _R14->compassType, _R14->cropPartialMap, parentRect, rect, parentRecte, color, element, luaVM);
    __asm
    {
      vmovss  xmm0, dword ptr [r14+38h]
      vmovss  dword ptr [rsp+78h+var_48], xmm0
    }
    CgCompassSystemMP::DrawPlayerCalloutMarkerPings(this, 0, _R14->compassType, _R14->cropPartialMap, parentRect, rect, v30, color, element, luaVM);
    __asm
    {
      vmovss  xmm0, dword ptr [r14+38h]
      vmovss  dword ptr [rsp+78h+parentRect], xmm0
    }
    CG_VehicleHudMP_DrawCompass(this->m_localClientNum, _R14->compassType, _R14->cropPartialMap, parentRect, rect, parentRectf, color, _R14->largeMap, _R14->mapMask, element, luaVM);
    __asm
    {
      vmovss  xmm0, dword ptr [r14+38h]
      vmovss  dword ptr [rsp+78h+parentRect], xmm0
    }
    CgCompassSystemMP::DrawMLGCameras(this, _R14->compassType, _R14->cropPartialMap, parentRect, rect, parentRectg, color, element, luaVM);
    CgCompassSystemMP::DrawGridLabels(this, _R14->compassType, parentRect, rect, color, element, luaVM);
  }
}

/*
==============
CgCompassSystemCPRaid::DrawMapLayer
==============
*/
void CgCompassSystemCPRaid::DrawMapLayer(CgCompassSystemCPRaid *this, const MinimapOptions *minimapOptions, const rectDef_s *parentRect, const rectDef_s *rect, const vec4_t *color, const vec4_t *mapColor, LUIElement *element, lua_State *luaVM)
{
  if ( minimapOptions->isCPRaidSecurityScreen )
    CgCompassSystemCPRaid::DrawPlayerMapCPRaid(this, minimapOptions->compassType, minimapOptions->cropPartialMap, parentRect, rect, NULL, mapColor, minimapOptions->mapMask, minimapOptions->mapOverlay, minimapOptions->mapRotOverlay, element, luaVM, this->mapImage);
  else
    CgCompassSystemMP::DrawMapLayer(this, minimapOptions, parentRect, rect, color, mapColor, element, luaVM);
}

/*
==============
CgCompassSystemCPRaid::DrawOthersLayer
==============
*/
void CgCompassSystemCPRaid::DrawOthersLayer(CgCompassSystemCPRaid *this, const MinimapOptions *minimapOptions, const rectDef_s *parentRect, const rectDef_s *rect, const vec4_t *color, LUIElement *element, lua_State *luaVM)
{
  float v13; 
  float v14; 

  _R14 = minimapOptions;
  if ( minimapOptions->isCPRaidSecurityScreen )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rdx+38h]
      vmovss  [rsp+68h+var_38], xmm0
    }
    CgCompassSystemCPRaid::DrawFriendliesCPRaid(this, minimapOptions->compassType, minimapOptions->cropPartialMap, minimapOptions->largeMap, parentRect, rect, v13, color, element, luaVM);
    __asm
    {
      vmovss  xmm0, dword ptr [r14+38h]
      vmovss  [rsp+68h+var_38], xmm0
    }
    CgCompassSystemCPRaid::DrawEnemiesCPRaid(this, _R14->compassType, _R14->cropPartialMap, _R14->largeMap, parentRect, rect, v14, color, element, luaVM);
  }
  else
  {
    CgCompassSystemMP::DrawOthersLayer(this, minimapOptions, parentRect, rect, color, element, luaVM);
  }
}

/*
==============
CgCompassSystemCPRaid::DrawPlayerCPRaid
==============
*/
void CgCompassSystemCPRaid::DrawPlayerCPRaid(CgCompassSystemCPRaid *this, CompassType compassType, bool cropPartialMap, bool largeMap, const rectDef_s *parentRect, const rectDef_s *rect, const float boundsRadius, const vec4_t *color, LUIElement *element, lua_State *luaVM)
{
  cg_t *LocalClientGlobals; 
  char v26; 
  const dvar_t *v46; 
  const dvar_t *v51; 
  int vertAlign; 
  int horzAlign; 
  const ScreenPlacement *ActivePlacement; 
  const char *PlayerRole; 
  const char *v58; 
  float compassMapWorldSize; 
  float compassMapWorldSizea; 
  float x; 
  float y; 
  float w; 
  float h; 
  float playerWorldPos; 
  float in; 
  float v80; 
  float outClipped; 
  float v82; 
  float v83; 
  float outHeight; 
  float outWidth; 
  float v88; 
  float v89; 
  GfxImage *output_material; 
  rectDef_s *v91; 
  lua_State *v92; 
  SecureVec3 out; 
  __int64 v94; 
  vec2_t v95; 
  int v96; 
  rectDef_s mapRect; 
  char v101; 
  void *retaddr; 

  _RAX = &retaddr;
  v94 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-58h], xmm6
    vmovaps xmmword ptr [rax-68h], xmm7
    vmovaps xmmword ptr [rax-78h], xmm8
    vmovaps xmmword ptr [rax-88h], xmm9
    vmovaps xmmword ptr [rax-98h], xmm10
    vmovaps xmmword ptr [rax-0A8h], xmm11
    vmovaps xmmword ptr [rax-0B8h], xmm12
    vmovaps xmmword ptr [rax-0C8h], xmm13
  }
  v91 = (rectDef_s *)parentRect;
  v92 = luaVM;
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  *(double *)&_XMM0 = CgCompassSystem::GetIconFadeAlpha(this, (const LocalClientNum_t)this->m_localClientNum, compassType);
  _RDI = color;
  __asm { vmulss  xmm9, xmm0, dword ptr [rdi+0Ch] }
  output_material = NULL;
  __asm
  {
    vxorps  xmm8, xmm8, xmm8
    vucomiss xmm9, xmm8
  }
  if ( !v26 && !GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&LocalClientGlobals->predictedPlayerState.eFlags, ACTIVE, 0xCu) )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rdi]
      vmovss  [rbp+0C0h+var_F0], xmm0
      vmovss  xmm1, dword ptr [rdi+4]
      vmovss  [rbp+0C0h+var_EC], xmm1
      vmovss  xmm0, dword ptr [rdi+8]
      vmovss  [rbp+0C0h+var_E8], xmm0
    }
    this->GetPlayerCompassColor(this, (vec4_t *)&v96, LocalClientGlobals);
    __asm
    {
      vmovss  xmm11, [rbp+0C0h+var_F0]
      vmovss  xmm12, [rbp+0C0h+var_EC]
      vmovss  xmm13, [rbp+0C0h+var_E8]
      vmovss  xmm10, cs:__real@3f800000
      vmovss  [rbp+0C0h+var_E4], xmm10
    }
    CG_CompassCalcDimensions(compassType, LocalClientGlobals, v91, rect, &this->mazeCompassMapWorldSize, &mapRect.x, &mapRect.y, &mapRect.w, &mapRect.h);
    __asm
    {
      vmovss  xmm3, cs:__real@3f000000
      vmulss  xmm1, xmm3, [rbp+0C0h+mapRect.w]
      vaddss  xmm6, xmm1, [rbp+0C0h+mapRect.x]
      vmulss  xmm0, xmm3, [rbp+0C0h+mapRect.h]
      vaddss  xmm7, xmm0, [rbp+0C0h+mapRect.y]
      vmovss  dword ptr [rbp+0C0h+var_F8], xmm8
      vmovss  dword ptr [rbp+0C0h+var_F8+4], xmm8
    }
    CG_CalcPlayerPos(&out, this->m_localClientNum);
    __asm
    {
      vmovss  xmm0, [rbp+0C0h+boundsRadius]
      vmovss  dword ptr [rsp+1D0h+compassMapWorldSize], xmm0
    }
    CgCompassSystem::WorldPosToCompass(this, compassType, cropPartialMap, &mapRect, compassMapWorldSize, &this->mazeCompassMapWorldSize, &this->mazeCompassMapUpperLeft, &LocalClientGlobals->compassNorth, &this->m_compassPlayerForward, (const vec2_t *)&out, (const vec2_t *)&LocalClientGlobals->predictedPlayerState.origin, NULL, &v95);
    __asm
    {
      vmovss  xmm0, dword ptr [rbp+0C0h+var_F8]
      vmovss  [rbp+0C0h+var_130], xmm0
      vmovss  xmm1, dword ptr [rbp+0C0h+var_F8+4]
      vmovss  [rbp+0C0h+var_134], xmm1
    }
    CgCompassSystem::GetPlayerDrawSize(this, compassType, largeMap, &outHeight, &outWidth);
    __asm
    {
      vaddss  xmm1, xmm6, [rbp+0C0h+var_130]
      vmovss  [rbp+0C0h+var_130], xmm1
      vaddss  xmm0, xmm7, [rbp+0C0h+var_134]
      vmovss  [rbp+0C0h+var_134], xmm0
    }
    _RDI = DVARFLT_compassSize;
    if ( !DVARFLT_compassSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "compassSize") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RDI);
    __asm { vmovss  xmm6, dword ptr [rdi+28h] }
    v46 = DVARFLT_compassRoleIconScale;
    if ( !DVARFLT_compassRoleIconScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "compassRoleIconScale") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v46);
    __asm
    {
      vmulss  xmm2, xmm6, dword ptr [rdi+28h]
      vmulss  xmm2, xmm2, [rbp+0C0h+outWidth]
      vmovss  [rbp+0C0h+outWidth], xmm2
    }
    _RDI = DVARFLT_compassSize;
    if ( !DVARFLT_compassSize && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "compassSize") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RDI);
    __asm { vmovss  xmm6, dword ptr [rdi+28h] }
    v51 = DVARFLT_compassRoleIconScale;
    if ( !DVARFLT_compassRoleIconScale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "compassRoleIconScale") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v51);
    __asm
    {
      vmulss  xmm2, xmm6, dword ptr [rdi+28h]
      vmulss  xmm2, xmm2, [rbp+0C0h+outHeight]
      vmovss  [rbp+0C0h+outHeight], xmm2
    }
    vertAlign = rect->vertAlign;
    horzAlign = rect->horzAlign;
    ActivePlacement = ScrPlace_GetActivePlacement((const LocalClientNum_t)this->m_localClientNum);
    ScrPlace_ApplyRect(ActivePlacement, &v89, &v88, &outWidth, &outHeight, horzAlign, vertAlign);
    PlayerRole = CL_PlayerData_GetPlayerRole(this->m_localClientNum, LocalClientGlobals->predictedPlayerState.clientNum);
    v58 = StringTable_LookupFromAsset("cp/cp_fieldupgrades.csv", 1, PlayerRole, 2);
    if ( *v58 )
      LUI_Interface_RegisterMaterial(v58, (const GfxImage **)&output_material);
    __asm
    {
      vmovss  dword ptr [rsp+1D0h+var_160], xmm9
      vmovss  [rsp+1D0h+var_168], xmm13
      vmovss  dword ptr [rsp+1D0h+outClipped], xmm12
      vmovss  dword ptr [rsp+1D0h+var_178], xmm11
      vmovss  dword ptr [rsp+1D0h+in], xmm8
      vmovss  dword ptr [rsp+1D0h+playerWorldPos], xmm10
      vmovss  dword ptr [rsp+1D0h+h], xmm10
      vmovss  dword ptr [rsp+1D0h+w], xmm8
      vmovss  dword ptr [rsp+1D0h+y], xmm8
      vmovss  xmm0, [rbp+0C0h+outHeight]
      vmovss  dword ptr [rsp+1D0h+x], xmm0
      vmovss  xmm1, [rbp+0C0h+outWidth]
      vmovss  dword ptr [rsp+1D0h+compassMapWorldSize], xmm1
      vmovss  xmm3, [rbp+0C0h+var_134]; centerY
      vmovss  xmm2, [rbp+0C0h+var_130]; centerX
    }
    LUI_Render_DrawQuadRotated((const LocalClientNum_t)this->m_localClientNum, element, *(float *)&_XMM2, *(float *)&_XMM3, compassMapWorldSizea, x, y, w, h, playerWorldPos, in, v80, outClipped, v82, v83, output_material, v92);
  }
  memset(&out, 0, sizeof(out));
  _R11 = &v101;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-18h]
    vmovaps xmm7, xmmword ptr [r11-28h]
    vmovaps xmm8, xmmword ptr [r11-38h]
    vmovaps xmm9, xmmword ptr [r11-48h]
    vmovaps xmm10, xmmword ptr [r11-58h]
    vmovaps xmm11, xmmword ptr [r11-68h]
    vmovaps xmm12, xmmword ptr [r11-78h]
    vmovaps xmm13, xmmword ptr [r11-88h]
  }
}

/*
==============
CgCompassSystemCPRaid::DrawPlayerLayer
==============
*/
void CgCompassSystemCPRaid::DrawPlayerLayer(CgCompassSystemCPRaid *this, const MinimapOptions *minimapOptions, const rectDef_s *parentRect, const rectDef_s *rect, const vec4_t *color, LUIElement *element, lua_State *luaVM)
{
  float v8; 

  if ( minimapOptions->isCPRaidSecurityScreen )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rdx+38h]
      vmovss  [rsp+58h+var_28], xmm0
    }
    CgCompassSystemCPRaid::DrawPlayerCPRaid(this, minimapOptions->compassType, minimapOptions->cropPartialMap, minimapOptions->largeMap, parentRect, rect, v8, color, element, luaVM);
  }
  else
  {
    CgCompassSystemMP::DrawPlayerLayer(this, minimapOptions, parentRect, rect, color, element, luaVM);
  }
}

/*
==============
CgCompassSystemCPRaid::DrawPlayerMapCPRaid
==============
*/
void CgCompassSystemCPRaid::DrawPlayerMapCPRaid(CgCompassSystemCPRaid *this, CompassType compassType, bool cropPartialMap, const rectDef_s *parentRect, const rectDef_s *rect, Material *material, const vec4_t *color, GfxImage *mapMask, GfxImage *mapOverlay, GfxImage *mapRotOverlay, LUIElement *element, lua_State *luaVM, const GfxImage *mapMaterial)
{
  const GfxImage *image; 
  cg_t *LocalClientGlobals; 
  int vertAlign; 
  int horzAlign; 
  const ScreenPlacement *ActivePlacement; 
  float fmt; 
  float x; 
  float y; 
  float w; 
  float v40; 
  float h; 
  float v42; 
  float vMax; 
  lua_State *v44; 
  __int64 v45; 
  char v46[12]; 
  vec4_t v47; 
  vec4_t quadVerts[4]; 
  void *retaddr; 

  _RAX = &retaddr;
  v45 = -2i64;
  __asm { vmovaps xmmword ptr [rax-48h], xmm6 }
  v44 = luaVM;
  image = mapMaterial;
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  if ( !LocalClientGlobals->compassMapMaterial && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame_mp\\cg_compass_cp_raid.cpp", 625, ASSERT_TYPE_ASSERT, "(cgameGlob->compassMapMaterial)", (const char *)&queryFormat, "cgameGlob->compassMapMaterial") )
    __debugbreak();
  if ( !LocalClientGlobals->compassMapMaterial->textureCount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame_mp\\cg_compass_cp_raid.cpp", 626, ASSERT_TYPE_ASSERT, "(cgameGlob->compassMapMaterial->textureCount > 0)", (const char *)&queryFormat, "cgameGlob->compassMapMaterial->textureCount > 0") )
    __debugbreak();
  if ( !mapMaterial )
    image = LocalClientGlobals->compassMapMaterial->textureTable->image;
  _RAX = color;
  __asm
  {
    vmovss  xmm2, dword ptr [rax+0Ch]
    vxorps  xmm6, xmm6, xmm6
    vucomiss xmm2, xmm6
  }
  if ( mapMaterial )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rax]
      vmovss  dword ptr [rsp+128h+var_A8], xmm0
      vmovss  xmm1, dword ptr [rax+4]
      vmovss  dword ptr [rsp+128h+var_A8+4], xmm1
      vmovss  xmm0, dword ptr [rax+8]
      vmovss  dword ptr [rsp+128h+var_A8+8], xmm0
      vmovss  dword ptr [rsp+128h+var_A8+0Ch], xmm2
    }
    _RBX = &this->mazeCompassMapWorldSize;
    __asm
    {
      vucomiss xmm6, dword ptr [rbx]
      vucomiss xmm6, dword ptr [rbx+4]
    }
    if ( cg_t::ms_allocatedType == GLOB_TYPE_MP )
      CgGlobalsMP::GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
    if ( compassType != COMPASS_TYPE_FULL && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame_mp\\cg_compass_cp_raid.cpp", 653, ASSERT_TYPE_ASSERT, "(compassType == CompassType::COMPASS_TYPE_FULL)", (const char *)&queryFormat, "compassType == CompassType::COMPASS_TYPE_FULL") )
      __debugbreak();
    CG_CompassCalcDimensions(compassType, LocalClientGlobals, parentRect, rect, &this->mazeCompassMapWorldSize, &v42, &v40, &vMax, &h);
    vertAlign = rect->vertAlign;
    horzAlign = rect->horzAlign;
    ActivePlacement = ScrPlace_GetActivePlacement((const LocalClientNum_t)this->m_localClientNum);
    ScrPlace_ApplyRect(ActivePlacement, &v42, &v40, &vMax, &h, horzAlign, vertAlign);
    __asm
    {
      vmovss  xmm1, [rsp+128h+var_D8]; top
      vaddss  xmm3, xmm1, [rsp+128h+var_D4]; bottom
      vmovss  xmm0, [rsp+128h+var_D0]; left
      vaddss  xmm2, xmm0, [rsp+128h+vMax]; right
    }
    LUI_CoD_GenerateQuadVerts(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, (vec4_t (*)[4])quadVerts);
    __asm
    {
      vmovss  xmm0, cs:__real@3f800000
      vmovss  dword ptr [rsp+128h+w], xmm0
      vmovss  dword ptr [rsp+128h+y], xmm0
      vmovss  dword ptr [rsp+128h+x], xmm6
      vmovss  dword ptr [rsp+128h+fmt], xmm6
    }
    LUI_Render_DrawImage((const LocalClientNum_t)this->m_localClientNum, element, v44, (const vec4_t (*)[4])quadVerts, fmt, x, y, w, &v47, image);
  }
  memset(v46, 0, sizeof(v46));
  __asm { vmovaps xmm6, [rsp+128h+var_48] }
}

/*
==============
CgCompassSystemCPRaid::DrawPlayerPointersCPRaid
==============
*/
void CgCompassSystemCPRaid::DrawPlayerPointersCPRaid(CgCompassSystemCPRaid *this, CompassType compassType, bool cropPartialMap, bool largeMap, bool isSecurityScreen, const rectDef_s *parentRect, const rectDef_s *rect, const float boundsRadius, const vec4_t *color, LUIElement *element, lua_State *luaVM)
{
  CompassType v21; 
  cg_t *LocalClientGlobals; 
  CgStatic *LocalClientStatics; 
  __int64 clientNum; 
  cg_t *v34; 
  const characterInfo_t *CharacterInfo; 
  int v36; 
  int v37; 
  bool v40; 
  __int64 v41; 
  __int64 entNum; 
  int v43; 
  __int64 v45; 
  const dvar_t *v54; 
  char v58; 
  char v59; 
  ObjectiveIconSize ObjectiveIconSizeDefault; 
  const GfxImage *v62; 
  unsigned __int8 i; 
  const ObjectiveSettings *v66; 
  bool v69; 
  unsigned int v75; 
  const dvar_t *v76; 
  char v82; 
  char v83; 
  const GfxImage *v85; 
  ObjectiveIconSize v86; 
  float *x; 
  ObjectiveFlags xa; 
  float xb; 
  float xc; 
  bool xd; 
  float *y; 
  ObjectiveFlags ya; 
  ObjectiveFlags yb; 
  float w; 
  float prevOrigin; 
  float prevOrigina; 
  float centerX; 
  float centerXa; 
  float centerXb; 
  float centerXc; 
  float v110; 
  float v111; 
  float v112; 
  float v113; 
  bool ObjectiveClippedPos; 
  unsigned __int8 v116; 
  bool v117; 
  CompassType compassTypea; 
  int objectiveIndex; 
  __int16 v120; 
  vec3_t origin; 
  GfxImage *icon; 
  float outAngle; 
  float pingAlpha; 
  float scale; 
  float v126; 
  cg_t *v127; 
  GfxImage *outIcon; 
  __int64 v129; 
  lua_State *v130; 
  LUIElement *v131; 
  rectDef_s *v132; 
  SecureVec3 out; 
  vec3_t v134; 
  vec3_t v135; 
  __int64 v136; 
  vec4_t newColor; 
  vec4_t backgroundColor; 
  rectDef_s scaledRect; 
  vec2_t xyClipped; 
  vec2_t xy; 
  vec2_t outVector; 
  char v143; 
  void *retaddr; 

  _RAX = &retaddr;
  v136 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm7
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-78h], xmm9
    vmovaps xmmword ptr [rax-88h], xmm10
    vmovaps xmmword ptr [rax-98h], xmm11
    vmovaps xmmword ptr [rax-0A8h], xmm12
  }
  v21 = compassType;
  compassTypea = compassType;
  v132 = (rectDef_s *)rect;
  _R13 = color;
  v131 = element;
  v130 = luaVM;
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)this->m_localClientNum);
  v127 = LocalClientGlobals;
  *(double *)&_XMM0 = CgCompassSystem::GetIconFadeAlpha(this, (const LocalClientNum_t)this->m_localClientNum, v21);
  __asm
  {
    vmulss  xmm7, xmm0, dword ptr [r13+0Ch]
    vxorps  xmm8, xmm8, xmm8
    vucomiss xmm7, xmm8
  }
  if ( !v59 )
  {
    if ( isSecurityScreen )
      CG_CompassCalcDimensions(v21, LocalClientGlobals, parentRect, rect, &this->mazeCompassMapWorldSize, &scaledRect.x, &scaledRect.y, &scaledRect.w, &scaledRect.h);
    else
      CG_CompassCalcDimensions(v21, LocalClientGlobals, parentRect, rect, &scaledRect.x, &scaledRect.y, &scaledRect.w, &scaledRect.h);
    __asm
    {
      vmovss  xmm3, cs:__real@3f000000
      vmulss  xmm1, xmm3, [rbp+120h+scaledRect.w]
      vaddss  xmm11, xmm1, [rbp+120h+scaledRect.x]
      vmulss  xmm0, xmm3, [rbp+120h+scaledRect.h]
      vaddss  xmm12, xmm0, [rbp+120h+scaledRect.y]
    }
    LocalClientStatics = CgStatic::GetLocalClientStatics((const LocalClientNum_t)this->m_localClientNum);
    clientNum = LocalClientGlobals->predictedPlayerState.clientNum;
    v34 = CG_GetLocalClientGlobals((const LocalClientNum_t)LocalClientStatics->m_localClientNum);
    if ( !v34 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_static_inline.h", 33, ASSERT_TYPE_ASSERT, "(cgameGlob)", (const char *)&queryFormat, "cgameGlob") )
      __debugbreak();
    if ( v34->IsMP(v34) )
    {
      if ( (unsigned int)clientNum >= v34[1].predictedPlayerState.rxvOmnvars[64].timeModified )
      {
        LODWORD(y) = v34[1].predictedPlayerState.rxvOmnvars[64].timeModified;
        LODWORD(x) = clientNum;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame_mp\\cg_globals_mp_inline.h", 19, ASSERT_TYPE_ASSERT, "(unsigned)( characterIndex ) < (unsigned)( static_cast<int>( m_characterInfoCount ) )", "characterIndex doesn't index static_cast<int>( m_characterInfoCount )\n\t%i not in [0, %i)", x, y) )
          __debugbreak();
      }
      CharacterInfo = (const characterInfo_t *)(*(_QWORD *)&v34[1].predictedPlayerState.rxvOmnvars[62] + 14792 * clientNum);
    }
    else
    {
      CharacterInfo = CgGlobalsSP::GetCharacterInfo((CgGlobalsSP *)v34, clientNum);
    }
    if ( !CharacterInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame_mp\\cg_compass_cp_raid.cpp", 473, ASSERT_TYPE_ASSERT, "(ci)", (const char *)&queryFormat, "ci") )
      __debugbreak();
    if ( CharacterInfo->infoValid )
    {
      CgCompassSystem::GetCompassYaw(this, v21, cropPartialMap, LocalClientGlobals, &outAngle, &outVector);
      CG_CalcPlayerPos(&out, this->m_localClientNum);
      v36 = 0;
      objectiveIndex = 0;
      v37 = 0;
      __asm
      {
        vmovss  xmm10, [rbp+120h+boundsRadius]
        vmovss  xmm9, dword ptr cs:__xmm@7fffffff7fffffff7fffffff7fffffff
      }
      v40 = isSecurityScreen;
      do
      {
        v41 = v37;
        entNum = (__int64)LocalClientGlobals->predictedPlayerState.objectives[v41].entNum;
        outIcon = NULL;
        if ( v40 || (*(_WORD *)LocalClientGlobals->predictedPlayerState.objectives[v41].flags & 0x2000) == 0 )
        {
          if ( CgCompassSystemMP::GetObjectiveShouldRender(this, LocalClientGlobals->predictedPlayerState.objectives[v41].state, (ObjectiveFlags)*(unsigned __int16 *)LocalClientGlobals->predictedPlayerState.objectives[v41].flags, 0, LocalClientGlobals->predictedPlayerState.objectives[v41].icon, (const GfxImage **)&outIcon) && !this->IsObjectiveFiltered(this, v21, *(ObjectiveBackground *)(entNum + 158)) )
          {
            CG_CompassGetObjectivePingAlpha((const ObjectiveView *)entNum, LocalClientGlobals->time, &pingAlpha);
            CgCompassSystemMP::GetObjectiveScale(this, (const ObjectiveView *)entNum, &objectiveIndex, &scale);
            LOWORD(LocalClientGlobals) = *(_WORD *)(entNum + 156) >> 11;
            LOBYTE(LocalClientGlobals) = (*(_WORD *)(entNum + 156) & 0x800) != 0;
            v120 = (__int16)LocalClientGlobals;
            v43 = 1;
            _RDI = entNum + 32;
            v129 = entNum + 32;
            v45 = 8i64;
            icon = (GfxImage *)8;
            do
            {
              if ( (v43 & *(_DWORD *)(entNum + 128)) != 0 )
              {
                __asm
                {
                  vmovsd  xmm0, qword ptr [rdi]
                  vmovsd  [rbp+120h+var_120], xmm0
                }
                v134.v[2] = *(float *)(_RDI + 8);
                __asm
                {
                  vmovss  xmm0, [rbp+120h+outAngle]
                  vmovss  dword ptr [rsp+230h+w], xmm0
                }
                LOWORD(xa) = *(_WORD *)(entNum + 156);
                CgCompassSystemMP::GetObjectiveCompassOrigin(this, compassTypea, cropPartialMap, *(_DWORD *)entNum, 0xFFFFFFFF, xa, &v134, w, (SecureVec3 *)&origin, &v117, &v126);
                __asm
                {
                  vmovss  dword ptr [rsp+230h+var_1D8], xmm12
                  vmovss  [rsp+230h+centerX], xmm11
                  vmovss  dword ptr [rsp+230h+x], xmm10
                }
                ObjectiveClippedPos = CgCompassSystemMP::GetObjectiveClippedPos(this, compassTypea, v117, cropPartialMap, &scaledRect, xb, &outVector, &out, &origin, &v135, centerX, v110, &xy, &xyClipped);
                if ( !ObjectiveClippedPos || !(_BYTE)LocalClientGlobals )
                {
                  if ( isSecurityScreen )
                  {
                    __asm
                    {
                      vmovss  xmm2, dword ptr [r13+0]
                      vmovss  dword ptr [rbp+120h+newColor], xmm2
                      vmovss  xmm1, dword ptr [r13+4]
                      vmovss  dword ptr [rbp+120h+newColor+4], xmm1
                      vmovss  xmm0, dword ptr [r13+8]
                      vmovss  dword ptr [rbp+120h+newColor+8], xmm0
                      vmovss  xmm3, dword ptr [r13+0Ch]
                      vmovss  dword ptr [rbp+120h+backgroundColor], xmm2
                      vmovss  dword ptr [rbp+120h+backgroundColor+4], xmm1
                      vmovss  dword ptr [rbp+120h+backgroundColor+8], xmm0
                      vmovss  dword ptr [rbp+120h+backgroundColor+0Ch], xmm3
                    }
                  }
                  else
                  {
                    CgCompassSystemMP::GetObjectiveCompassColor(this, &origin, *(ObjectiveSide *)(entNum + 161), *(ObjectiveSide *)(entNum + 162), *(ObjectiveBackground *)(entNum + 158), *(_DWORD *)entNum, &newColor, &backgroundColor, color);
                    __asm { vmovss  xmm3, dword ptr [rbp+120h+newColor+0Ch] }
                  }
                  __asm
                  {
                    vcmpltss xmm0, xmm7, xmm3
                    vblendvps xmm1, xmm3, xmm7, xmm0
                    vmulss  xmm0, xmm1, [rbp+120h+pingAlpha]
                    vmovss  dword ptr [rbp+120h+newColor+0Ch], xmm0
                  }
                  LODWORD(LocalClientGlobals) = 0;
                  v54 = DVARBOOL_compassPrototypeElevation;
                  if ( !DVARBOOL_compassPrototypeElevation && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "compassPrototypeElevation") )
                    __debugbreak();
                  Dvar_CheckFrontendServerThread(v54);
                  if ( v54->current.enabled )
                  {
                    __asm
                    {
                      vmovss  xmm0, dword ptr [rbp+120h+origin+8]
                      vsubss  xmm6, xmm0, dword ptr [rax+40h]
                    }
                    _RDI = DCONST_DVARFLT_compassEnemyHeightDelta;
                    if ( !DCONST_DVARFLT_compassEnemyHeightDelta && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "compassEnemyHeightDelta") )
                      __debugbreak();
                    Dvar_CheckFrontendServerThread(_RDI);
                    __asm
                    {
                      vandps  xmm0, xmm6, xmm9
                      vcomiss xmm0, dword ptr [rdi+28h]
                    }
                    if ( !v58 )
                    {
                      __asm { vcomiss xmm6, xmm8 }
                      LOBYTE(LocalClientGlobals) = v58 | v59;
                      LODWORD(LocalClientGlobals) = (_DWORD)LocalClientGlobals + 1;
                    }
                  }
                  ObjectiveIconSizeDefault = CgCompassSystemMP::GetObjectiveIconSizeDefault(this, (ObjectiveFlags)*(unsigned __int16 *)(entNum + 156), *(ObjectiveIconSize *)(entNum + 160));
                  v62 = this->GetObjectiveBackgroundImage(this, *(unsigned __int8 *)(entNum + 158), (unsigned int)LocalClientGlobals);
                  __asm
                  {
                    vmovss  xmm0, [rbp+120h+scale]
                    vmovss  dword ptr [rsp+230h+var_1D8], xmm0
                    vmovss  [rsp+230h+centerX], xmm0
                    vmovss  xmm0, [rbp+120h+var_16C]
                    vmovss  dword ptr [rsp+230h+prevOrigin], xmm0
                  }
                  LOWORD(ya) = *(_WORD *)(entNum + 156);
                  CgCompassSystemMP::DrawObjective(this, compassTypea, v132, &xy, &xyClipped, ObjectiveClippedPos, ya, ObjectiveIconSizeDefault, v62, prevOrigin, centerXa, v111, outIcon, &newColor, &backgroundColor, v131, v130);
                  _RDI = v129;
                  v45 = (__int64)icon;
                  LOBYTE(LocalClientGlobals) = v120;
                }
              }
              v43 = __ROL4__(v43, 1);
              _RDI += 12i64;
              v129 = _RDI;
              icon = (GfxImage *)--v45;
            }
            while ( v45 );
            v21 = compassTypea;
            LocalClientGlobals = v127;
            v40 = isSecurityScreen;
          }
          v36 = objectiveIndex;
        }
        objectiveIndex = ++v36;
        v37 = v36;
      }
      while ( v36 < 32 );
      v116 = ScriptableCl_ObjectiveCount((const LocalClientNum_t)this->m_localClientNum);
      for ( i = 0; i < v116; v40 = isSecurityScreen )
      {
        v66 = ScriptableCl_ObjectiveGet((const LocalClientNum_t)this->m_localClientNum, i, &origin);
        if ( v66 )
        {
          __asm
          {
            vxorps  xmm1, xmm1, xmm1
            vcvtsi2ss xmm1, xmm1, dword ptr [rax+4]
            vaddss  xmm1, xmm1, dword ptr [rbp+120h+origin+8]
            vmovss  dword ptr [rbp+120h+origin+8], xmm1
          }
          if ( (v40 || (*(_WORD *)v66->flags & 0x2000) == 0) && CgCompassSystemMP::GetObjectiveShouldRender(this, v66->state, (ObjectiveFlags)*(unsigned __int16 *)v66->flags, 0, v66->icon, (const GfxImage **)&icon) && !this->IsObjectiveFiltered(this, v21, v66->background) )
          {
            v117 = 0;
            __asm
            {
              vmovss  dword ptr [rsp+230h+var_1D8], xmm12
              vmovss  [rsp+230h+centerX], xmm11
              vmovss  dword ptr [rsp+230h+x], xmm10
            }
            v69 = CgCompassSystemMP::GetObjectiveClippedPos(this, v21, 0, cropPartialMap, &scaledRect, xc, &outVector, &out, &origin, &v135, centerXb, v112, &xy, &xyClipped);
            if ( v69 && (*(_WORD *)v66->flags & 0x800) != 0 )
            {
              v21 = compassTypea;
            }
            else
            {
              if ( v40 )
              {
                __asm
                {
                  vmovss  xmm2, dword ptr [r13+0]
                  vmovss  dword ptr [rbp+120h+newColor], xmm2
                  vmovss  xmm1, dword ptr [r13+4]
                  vmovss  dword ptr [rbp+120h+newColor+4], xmm1
                  vmovss  xmm0, dword ptr [r13+8]
                  vmovss  dword ptr [rbp+120h+newColor+8], xmm0
                  vmovss  xmm3, dword ptr [r13+0Ch]
                  vmovss  dword ptr [rbp+120h+backgroundColor], xmm2
                  vmovss  dword ptr [rbp+120h+backgroundColor+4], xmm1
                  vmovss  dword ptr [rbp+120h+backgroundColor+8], xmm0
                  vmovss  dword ptr [rbp+120h+backgroundColor+0Ch], xmm3
                }
              }
              else
              {
                CgCompassSystemMP::GetObjectiveCompassColor(this, &origin, NEUTRAL, NEUTRAL, v66->background, 2047, &newColor, &backgroundColor, color);
                __asm { vmovss  xmm3, dword ptr [rbp+120h+newColor+0Ch] }
              }
              __asm
              {
                vcmpltss xmm0, xmm7, xmm3
                vblendvps xmm0, xmm3, xmm7, xmm0
                vmovss  dword ptr [rbp+120h+newColor+0Ch], xmm0
              }
              v75 = 0;
              v76 = DVARBOOL_compassPrototypeElevation;
              if ( !DVARBOOL_compassPrototypeElevation && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "compassPrototypeElevation") )
                __debugbreak();
              Dvar_CheckFrontendServerThread(v76);
              if ( v76->current.enabled )
              {
                __asm
                {
                  vxorps  xmm1, xmm1, xmm1
                  vcvtsi2ss xmm1, xmm1, dword ptr [rbx+4]
                  vmovss  xmm0, dword ptr [rbp+120h+origin+8]
                  vsubss  xmm1, xmm0, xmm1
                  vsubss  xmm6, xmm1, dword ptr [rax+40h]
                }
                _RSI = DCONST_DVARFLT_compassEnemyHeightDelta;
                if ( !DCONST_DVARFLT_compassEnemyHeightDelta && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "compassEnemyHeightDelta") )
                  __debugbreak();
                Dvar_CheckFrontendServerThread(_RSI);
                __asm
                {
                  vandps  xmm0, xmm6, xmm9
                  vcomiss xmm0, dword ptr [rsi+28h]
                }
                if ( !v82 )
                {
                  __asm { vcomiss xmm6, xmm8 }
                  LOBYTE(v75) = v82 | v83;
                  ++v75;
                }
              }
              v85 = this->GetObjectiveBackgroundImage(this, (unsigned __int8)v66->background, v75);
              v86 = CgCompassSystemMP::GetObjectiveIconSizeDefault(this, (ObjectiveFlags)*(unsigned __int16 *)v66->flags, v66->size);
              __asm
              {
                vmovss  dword ptr [rsp+230h+var_1D8], xmm8
                vmovss  [rsp+230h+centerX], xmm8
                vmovss  dword ptr [rsp+230h+prevOrigin], xmm8
              }
              LOWORD(yb) = *(_WORD *)v66->flags;
              xd = v69;
              v21 = compassTypea;
              CgCompassSystemMP::DrawObjective(this, compassTypea, v132, &xy, &xyClipped, xd, yb, v86, v85, prevOrigina, centerXc, v113, icon, &newColor, &backgroundColor, v131, v130);
            }
          }
        }
        ++i;
      }
    }
  }
  memset(&out, 0, sizeof(out));
  memset(&v135, 0, sizeof(v135));
  memset(&origin, 0, sizeof(origin));
  _R11 = &v143;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
  }
}

/*
==============
CgCompassSystemCPRaid::GetObjectiveCompassColorCPRaid
==============
*/
void CgCompassSystemCPRaid::GetObjectiveCompassColorCPRaid(CgCompassSystemCPRaid *this, const vec3_t *origin, ObjectiveSide side, ObjectiveSide progressSide, ObjectiveBackground background, int entNum, bool isSecurityScreen, vec4_t *newColor, vec4_t *backgroundColor, const vec4_t *color)
{
  if ( isSecurityScreen )
  {
    *newColor = *color;
    *backgroundColor = *color;
  }
  else
  {
    CgCompassSystemMP::GetObjectiveCompassColor(this, origin, side, progressSide, background, entNum, newColor, backgroundColor, color);
  }
}

/*
==============
CgCompassSystemCPRaid::GetPlayerRoleMaterial
==============
*/
void CgCompassSystemCPRaid::GetPlayerRoleMaterial(CgCompassSystemCPRaid *this, const LocalClientNum_t localClientNum, int clientNum, const GfxImage **material)
{
  const char *PlayerRole; 
  const char *v6; 

  PlayerRole = CL_PlayerData_GetPlayerRole(localClientNum, clientNum);
  v6 = StringTable_LookupFromAsset("cp/cp_fieldupgrades.csv", 1, PlayerRole, 2);
  if ( *v6 )
    LUI_Interface_RegisterMaterial(v6, material);
}

/*
==============
CgCompassSystemCPRaid::InitCompass
==============
*/

void __fastcall CgCompassSystemCPRaid::InitCompass(CgCompassSystemCPRaid *this)
{
  CgCompassSystemMP::InitCompass(this);
}

/*
==============
CgCompassSystemCPRaid::InitMaze
==============
*/
void CgCompassSystemCPRaid::InitMaze(CgCompassSystemCPRaid *this, const GfxImage *image, const vec2_t *mazeUpperLeft, const vec2_t *mazeWorldSize)
{
  this->mazeCompassMapUpperLeft = *mazeUpperLeft;
  this->mazeCompassMapWorldSize = *mazeWorldSize;
  this->mapImage = image;
}

