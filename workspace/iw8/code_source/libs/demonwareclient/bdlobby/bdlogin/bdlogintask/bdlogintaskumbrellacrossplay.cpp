/*
==============
bdLoginTaskUmbrellaCrossplay::getTaskCode
==============
*/

bdLoginTaskUmbrellaCrossplay::UmbrellaLoginStatusCode __fastcall bdLoginTaskUmbrellaCrossplay::getTaskCode(bdLoginTaskUmbrellaCrossplay *this)
{
  return ?getTaskCode@bdLoginTaskUmbrellaCrossplay@@QEBA?AW4UmbrellaLoginStatusCode@1@XZ(this);
}

/*
==============
bdLoginTaskUmbrellaCrossplay::getRemoteTaskRef
==============
*/

bdReference<bdRemoteTask> *__fastcall bdLoginTaskUmbrellaCrossplay::getRemoteTaskRef(bdLoginTaskUmbrellaCrossplay *this, bdReference<bdRemoteTask> *result)
{
  return ?getRemoteTaskRef@bdLoginTaskUmbrellaCrossplay@@QEAA?AV?$bdReference@VbdRemoteTask@@@@XZ(this, result);
}

/*
==============
bdLoginTaskUmbrellaCrossplay::validateAccessToken
==============
*/

bool __fastcall bdLoginTaskUmbrellaCrossplay::validateAccessToken(bdLoginTaskUmbrellaCrossplay *this)
{
  return ?validateAccessToken@bdLoginTaskUmbrellaCrossplay@@QEAA_NXZ(this);
}

/*
==============
bdLoginTaskUmbrellaCrossplay::cancelRemoteTask
==============
*/

void __fastcall bdLoginTaskUmbrellaCrossplay::cancelRemoteTask(bdLoginTaskUmbrellaCrossplay *this)
{
  ?cancelRemoteTask@bdLoginTaskUmbrellaCrossplay@@IEAAXXZ(this);
}

/*
==============
bdLoginTaskUmbrellaCrossplay::startLoginTask
==============
*/

void __fastcall bdLoginTaskUmbrellaCrossplay::startLoginTask(bdLoginTaskUmbrellaCrossplay *this)
{
  ?startLoginTask@bdLoginTaskUmbrellaCrossplay@@IEAAXXZ(this);
}

/*
==============
bdLoginTaskUmbrellaCrossplay::reset
==============
*/

void __fastcall bdLoginTaskUmbrellaCrossplay::reset(bdLoginTaskUmbrellaCrossplay *this)
{
  ?reset@bdLoginTaskUmbrellaCrossplay@@UEAAXXZ(this);
}

/*
==============
bdLoginTaskUmbrellaCrossplay::resetHttpInterface
==============
*/

void __fastcall bdLoginTaskUmbrellaCrossplay::resetHttpInterface(bdLoginTaskUmbrellaCrossplay *this)
{
  ?resetHttpInterface@bdLoginTaskUmbrellaCrossplay@@IEAAXXZ(this);
}

/*
==============
bdLoginTaskUmbrellaCrossplay::buildUmbrellaRefreshReq
==============
*/

void __fastcall bdLoginTaskUmbrellaCrossplay::buildUmbrellaRefreshReq(bdLoginTaskUmbrellaCrossplay *this)
{
  ?buildUmbrellaRefreshReq@bdLoginTaskUmbrellaCrossplay@@IEAAXXZ(this);
}

/*
==============
bdLoginTaskUmbrellaCrossplay::getTaskMessage
==============
*/

const char *__fastcall bdLoginTaskUmbrellaCrossplay::getTaskMessage(bdLoginTaskUmbrellaCrossplay *this)
{
  return ?getTaskMessage@bdLoginTaskUmbrellaCrossplay@@UEBAPEBDXZ(this);
}

/*
==============
bdLoginTaskUmbrellaCrossplay::clearBuffers
==============
*/

void __fastcall bdLoginTaskUmbrellaCrossplay::clearBuffers(bdLoginTaskUmbrellaCrossplay *this)
{
  ?clearBuffers@bdLoginTaskUmbrellaCrossplay@@IEAAXXZ(this);
}

/*
==============
bdLoginTaskUmbrellaCrossplay::abortTask
==============
*/

void __fastcall bdLoginTaskUmbrellaCrossplay::abortTask(bdLoginTaskUmbrellaCrossplay *this)
{
  ?abortTask@bdLoginTaskUmbrellaCrossplay@@UEAAXXZ(this);
}

/*
==============
bdLoginTaskUmbrellaCrossplay::convertSIErrorCode
==============
*/

bdLobbyErrorCode __fastcall bdLoginTaskUmbrellaCrossplay::convertSIErrorCode(bdLoginTaskUmbrellaCrossplay *this, const unsigned int *__formal)
{
  return ?convertSIErrorCode@bdLoginTaskUmbrellaCrossplay@@IEBA?AW4bdLobbyErrorCode@@AEBI@Z(this, __formal);
}

/*
==============
bdLoginTaskUmbrellaCrossplay::processUmbrellaRefreshReply
==============
*/

void __fastcall bdLoginTaskUmbrellaCrossplay::processUmbrellaRefreshReply(bdLoginTaskUmbrellaCrossplay *this)
{
  ?processUmbrellaRefreshReply@bdLoginTaskUmbrellaCrossplay@@IEAAXXZ(this);
}

/*
==============
bdLoginTaskUmbrellaCrossplay::processUmbrellaLoginReply
==============
*/

void __fastcall bdLoginTaskUmbrellaCrossplay::processUmbrellaLoginReply(bdLoginTaskUmbrellaCrossplay *this)
{
  ?processUmbrellaLoginReply@bdLoginTaskUmbrellaCrossplay@@IEAAXXZ(this);
}

/*
==============
bdLoginTaskUmbrellaCrossplay::parseErrorJSON
==============
*/

void __fastcall bdLoginTaskUmbrellaCrossplay::parseErrorJSON(bdLoginTaskUmbrellaCrossplay *this)
{
  ?parseErrorJSON@bdLoginTaskUmbrellaCrossplay@@IEAAXXZ(this);
}

/*
==============
bdLoginTaskUmbrellaCrossplay::createUmbrellaLoginJson
==============
*/

bool __fastcall bdLoginTaskUmbrellaCrossplay::createUmbrellaLoginJson(bdLoginTaskUmbrellaCrossplay *this, bdJSONSerializer *umbrellaLoginJSON)
{
  return ?createUmbrellaLoginJson@bdLoginTaskUmbrellaCrossplay@@IEAA_NAEAVbdJSONSerializer@@@Z(this, umbrellaLoginJSON);
}

/*
==============
bdLoginTaskUmbrellaCrossplay::setUnoIDToken
==============
*/

void __fastcall bdLoginTaskUmbrellaCrossplay::setUnoIDToken(bdLoginTaskUmbrellaCrossplay *this, const char *unoIDToken)
{
  ?setUnoIDToken@bdLoginTaskUmbrellaCrossplay@@QEAAXPEBD@Z(this, unoIDToken);
}

/*
==============
bdLoginTaskUmbrellaCrossplay::getFailedTask
==============
*/

bdReference<bdRemoteTask> *__fastcall bdLoginTaskUmbrellaCrossplay::getFailedTask(bdLoginTaskUmbrellaCrossplay *this, bdReference<bdRemoteTask> *result)
{
  return ?getFailedTask@bdLoginTaskUmbrellaCrossplay@@IEBA?AV?$bdReference@VbdRemoteTask@@@@XZ(this, result);
}

/*
==============
bdLoginTaskUmbrellaCrossplay::buildUmbrellaLoginReq
==============
*/

void __fastcall bdLoginTaskUmbrellaCrossplay::buildUmbrellaLoginReq(bdLoginTaskUmbrellaCrossplay *this)
{
  ?buildUmbrellaLoginReq@bdLoginTaskUmbrellaCrossplay@@IEAAXXZ(this);
}

/*
==============
bdLoginTaskUmbrellaCrossplay::pump
==============
*/

void __fastcall bdLoginTaskUmbrellaCrossplay::pump(bdLoginTaskUmbrellaCrossplay *this)
{
  ?pump@bdLoginTaskUmbrellaCrossplay@@UEAAXXZ(this);
}

/*
==============
bdLoginTaskUmbrellaCrossplay::sendUmbrellaRequest
==============
*/

void __fastcall bdLoginTaskUmbrellaCrossplay::sendUmbrellaRequest(bdLoginTaskUmbrellaCrossplay *this, bdJSONSerializer *requestJSON)
{
  ?sendUmbrellaRequest@bdLoginTaskUmbrellaCrossplay@@IEAAXAEAVbdJSONSerializer@@@Z(this, requestJSON);
}

/*
==============
bdLoginTaskUmbrellaCrossplay::startRefreshTask
==============
*/

void __fastcall bdLoginTaskUmbrellaCrossplay::startRefreshTask(bdLoginTaskUmbrellaCrossplay *this)
{
  ?startRefreshTask@bdLoginTaskUmbrellaCrossplay@@IEAAXXZ(this);
}

/*
==============
bdLoginTaskUmbrellaCrossplay::pumpRemoteTask
==============
*/

void __fastcall bdLoginTaskUmbrellaCrossplay::pumpRemoteTask(bdLoginTaskUmbrellaCrossplay *this)
{
  ?pumpRemoteTask@bdLoginTaskUmbrellaCrossplay@@IEAAXXZ(this);
}

/*
==============
bdLoginTaskUmbrellaCrossplay::getNewTask
==============
*/

bdReference<bdRemoteTask> *__fastcall bdLoginTaskUmbrellaCrossplay::getNewTask(bdLoginTaskUmbrellaCrossplay *this, bdReference<bdRemoteTask> *result)
{
  return ?getNewTask@bdLoginTaskUmbrellaCrossplay@@IEAA?AV?$bdReference@VbdRemoteTask@@@@XZ(this, result);
}

/*
==============
bdLoginTaskUmbrellaCrossplay::bdLoginTaskUmbrellaCrossplay
==============
*/

void __fastcall bdLoginTaskUmbrellaCrossplay::bdLoginTaskUmbrellaCrossplay(bdLoginTaskUmbrellaCrossplay *this, const bdLoginConfig *loginConfig, bdLoginResult *loginResult)
{
  ??0bdLoginTaskUmbrellaCrossplay@@QEAA@PEBVbdLoginConfig@@PEAVbdLoginResult@@@Z(this, loginConfig, loginResult);
}

/*
==============
bdLoginTaskUmbrellaCrossplay::setLinking
==============
*/

void __fastcall bdLoginTaskUmbrellaCrossplay::setLinking(bdLoginTaskUmbrellaCrossplay *this, const bool linking)
{
  ?setLinking@bdLoginTaskUmbrellaCrossplay@@QEAAX_N@Z(this, linking);
}

/*
==============
bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus
==============
*/

void __fastcall bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus(bdLoginTaskUmbrellaCrossplay *this, const char *messageInfo, const bdLoginTaskUmbrellaCrossplay::UmbrellaLoginStatusCode *code)
{
  ?updateUmbrellaCrossplayStatus@bdLoginTaskUmbrellaCrossplay@@IEAAXPEBDAEBW4UmbrellaLoginStatusCode@1@@Z(this, messageInfo, code);
}

/*
==============
bdLoginTaskUmbrellaCrossplay::~bdLoginTaskUmbrellaCrossplay
==============
*/

void __fastcall bdLoginTaskUmbrellaCrossplay::~bdLoginTaskUmbrellaCrossplay(bdLoginTaskUmbrellaCrossplay *this)
{
  ??1bdLoginTaskUmbrellaCrossplay@@UEAA@XZ(this);
}

/*
==============
bdLoginTaskUmbrellaCrossplay::readyForRequest
==============
*/

bool __fastcall bdLoginTaskUmbrellaCrossplay::readyForRequest(bdLoginTaskUmbrellaCrossplay *this)
{
  return ?readyForRequest@bdLoginTaskUmbrellaCrossplay@@IEAA_NXZ(this);
}

/*
==============
bdLoginTaskUmbrellaCrossplay::pumpRefresh
==============
*/

void __fastcall bdLoginTaskUmbrellaCrossplay::pumpRefresh(bdLoginTaskUmbrellaCrossplay *this)
{
  ?pumpRefresh@bdLoginTaskUmbrellaCrossplay@@QEAAXXZ(this);
}

/*
==============
bdLoginTaskUmbrellaCrossplay::bdLoginTaskUmbrellaCrossplay
==============
*/
void bdLoginTaskUmbrellaCrossplay::bdLoginTaskUmbrellaCrossplay(bdLoginTaskUmbrellaCrossplay *this, const bdLoginConfig *loginConfig, bdLoginResult *loginResult)
{
  this->__vftable = (bdLoginTaskUmbrellaCrossplay_vtbl *)&bdLoginTask::`vftable';
  bdStopwatch::bdStopwatch(&this->m_taskTimer);
  this->m_loginConfig = loginConfig;
  this->__vftable = (bdLoginTaskUmbrellaCrossplay_vtbl *)&bdLoginTaskUmbrellaCrossplay::`vftable';
  this->m_loginResult = loginResult;
  this->m_outputObject = NULL;
  *(_QWORD *)&this->m_umbrellaStatusCode = 0i64;
  this->m_firstPartyTokenStatusCode = FETCHING_FIRST_PARTY_TOKEN;
  this->m_environment = BD_ENVIRONMENT_MAX;
  this->m_remoteTask.m_ptr = NULL;
  this->m_httpInterface = NULL;
  this->m_linking = 0;
  memset_0(this->m_umbrellaStatusMessage, 0, 0x480ui64);
  *(_QWORD *)this->m_ivSeedB64 = 0i64;
  *(_QWORD *)&this->m_ivSeedB64[8] = 0i64;
  *(_QWORD *)&this->m_ivSeedB64[16] = 0i64;
  *(_QWORD *)&this->m_ivSeedB64[24] = 0i64;
  this->m_requestBufferSize = 4096;
  this->m_responseBufferSize = 18432;
  memset_0(this->m_httpRequestBuffer, 0, sizeof(this->m_httpRequestBuffer));
  memset_0(this->m_httpResponseBuffer, 0, this->m_responseBufferSize);
  memset_0(this->m_unoIDToken, 0, sizeof(this->m_unoIDToken));
}

/*
==============
bdLoginTaskUmbrellaCrossplay::~bdLoginTaskUmbrellaCrossplay
==============
*/
void bdLoginTaskUmbrellaCrossplay::~bdLoginTaskUmbrellaCrossplay(bdLoginTaskUmbrellaCrossplay *this)
{
  bdHTTP *m_httpInterface; 
  bdHTTP *v3; 
  bdRemoteTask *m_ptr; 
  bdRemoteTask *v5; 
  bdRemoteTask *v6; 

  this->__vftable = (bdLoginTaskUmbrellaCrossplay_vtbl *)&bdLoginTaskUmbrellaCrossplay::`vftable';
  m_httpInterface = this->m_httpInterface;
  if ( m_httpInterface )
  {
    m_httpInterface->abortOperation(m_httpInterface);
    v3 = this->m_httpInterface;
    if ( v3 )
      ((void (__fastcall *)(bdHTTP *, __int64))v3->~bdHTTP)(v3, 1i64);
    this->m_httpInterface = NULL;
  }
  m_ptr = this->m_remoteTask.m_ptr;
  if ( m_ptr )
    bdRemoteTask::cancelTask(m_ptr);
  memset_0(this->m_httpRequestBuffer, 0, this->m_requestBufferSize);
  memset_0(this->m_httpResponseBuffer, 0, this->m_responseBufferSize);
  v5 = this->m_remoteTask.m_ptr;
  if ( v5 && _InterlockedExchangeAdd((volatile signed __int32 *)&v5->m_refCount, 0xFFFFFFFF) == 1 )
  {
    v6 = this->m_remoteTask.m_ptr;
    if ( v6 )
      ((void (__fastcall *)(bdRemoteTask *, __int64))v6->~bdReferencable)(v6, 1i64);
    this->m_remoteTask.m_ptr = NULL;
  }
  this->__vftable = (bdLoginTaskUmbrellaCrossplay_vtbl *)&bdLoginTask::`vftable';
}

/*
==============
bdLoginTaskUmbrellaCrossplay::abortTask
==============
*/
void bdLoginTaskUmbrellaCrossplay::abortTask(bdLoginTaskUmbrellaCrossplay *this)
{
  char *m_umbrellaStatusMessage; 
  bdHTTP *m_httpInterface; 
  bdHTTP *v4; 
  bdRemoteTask *m_ptr; 
  bdLoginTaskUmbrellaCrossplay::UmbrellaLoginStatusCode code; 

  m_umbrellaStatusMessage = this->m_umbrellaStatusMessage;
  bdLogMessage(BD_LOG_WARNING, "warn/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::abortTask", 0x68u, "Aborting Umbrella crossplay login task, current status: [%s]", this->m_umbrellaStatusMessage);
  bdSnprintf(m_umbrellaStatusMessage, 0x400ui64, "Aborting task, current status: [%s]", m_umbrellaStatusMessage);
  code = CONNECTED;
  bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus(this, m_umbrellaStatusMessage, &code);
  m_httpInterface = this->m_httpInterface;
  this->m_outputObject = NULL;
  if ( m_httpInterface )
  {
    m_httpInterface->abortOperation(m_httpInterface);
    v4 = this->m_httpInterface;
    if ( v4 )
      ((void (__fastcall *)(bdHTTP *, __int64))v4->~bdHTTP)(v4, 1i64);
    this->m_httpInterface = NULL;
  }
  m_ptr = this->m_remoteTask.m_ptr;
  if ( m_ptr )
    bdRemoteTask::cancelTask(m_ptr);
  memset_0(this->m_httpRequestBuffer, 0, this->m_requestBufferSize);
  memset_0(this->m_httpResponseBuffer, 0, this->m_responseBufferSize);
}

/*
==============
bdLoginTaskUmbrellaCrossplay::buildUmbrellaLoginReq
==============
*/
void bdLoginTaskUmbrellaCrossplay::buildUmbrellaLoginReq(bdLoginTaskUmbrellaCrossplay *this)
{
  bdHTTP *v2; 
  bdLoginConfig *m_loginConfig; 
  const char *Region; 
  const char *ClientID; 
  __int64 v6; 
  bdEnvironment env; 
  char buf[40]; 
  char url[512]; 

  v2 = bdHTTPUtility::newHTTP(0, 0);
  m_loginConfig = (bdLoginConfig *)this->m_loginConfig;
  this->m_httpInterface = v2;
  Region = bdLoginConfig::getRegion(m_loginConfig);
  env = bdLoginResult::getEnvironment(this->m_loginResult);
  bdLoginUtils::getUmbrellaUrl((char (*)[512])url, &env, Region);
  ClientID = bdLoginResult::getClientID(this->m_loginResult);
  bdSnprintf(this->m_url, 0x200ui64, "%s/v2.0/tokens/crossplatform/?client=%s", url, ClientID);
  bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::buildUmbrellaLoginReq", 0x90u, "URL : %s", this->m_url);
  bdBase64::encode(this->m_loginResult->m_data, 0x80u, this->m_authTicketB64, 0xADu);
  bdSnprintf(buf, 0x20ui64, "%u", this->m_loginResult->m_IVSeed);
  bdHandleAssert(1, "s != BD_NULL", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdplatform\\bdplatformstring\\bdplatformstring.inl", "bdStrlen", 0x110u, "null ptr in bdStrlen");
  v6 = -1i64;
  do
    ++v6;
  while ( buf[v6] );
  bdBase64::encode(buf, v6, this->m_ivSeedB64, 0x20u);
  bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::buildUmbrellaLoginReq", 0x9Fu, "Setting state to READY");
  bdHandleAssert(1, "(messageInfo != BD_NULL)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus", 0x286u, "Must provide valid message to update Umbrella login task status!");
  this->m_umbrellaStatusCode = NOT_CONNECTED;
  bdStrlcpy(this->m_umbrellaStatusMessage, "Built request for Umbrella crossplay login", 0x400ui64);
  bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::buildUmbrellaLoginReq", 0xA1u, "Built request for Umbrella crossplay login");
}

/*
==============
bdLoginTaskUmbrellaCrossplay::buildUmbrellaRefreshReq
==============
*/
void bdLoginTaskUmbrellaCrossplay::buildUmbrellaRefreshReq(bdLoginTaskUmbrellaCrossplay *this)
{
  bdHTTP *v2; 
  bdLoginConfig *m_loginConfig; 
  const char *Region; 
  const char *ClientID; 
  bdEnvironment env[4]; 
  char url[512]; 

  v2 = bdHTTPUtility::newHTTP(0, 0);
  m_loginConfig = (bdLoginConfig *)this->m_loginConfig;
  this->m_httpInterface = v2;
  Region = bdLoginConfig::getRegion(m_loginConfig);
  env[0] = bdLoginResult::getEnvironment(this->m_loginResult);
  bdLoginUtils::getUmbrellaUrl((char (*)[512])url, env, Region);
  ClientID = bdLoginResult::getClientID(this->m_loginResult);
  bdSnprintf(this->m_url, 0x200ui64, "%s/v1.0/tokens/refresh/?client=%s", url, ClientID);
  bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::buildUmbrellaRefreshReq", 0xB3u, "Setting state to READY");
  bdHandleAssert(1, "(messageInfo != BD_NULL)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus", 0x286u, "Must provide valid message to update Umbrella login task status!");
  this->m_umbrellaStatusCode = NOT_CONNECTED;
  bdStrlcpy(this->m_umbrellaStatusMessage, "Built request for Umbrella crossplay refresh token", 0x400ui64);
  bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::buildUmbrellaRefreshReq", 0xB5u, "Built request for Umbrella crossplay refresh token");
}

/*
==============
bdLoginTaskUmbrellaCrossplay::cancelRemoteTask
==============
*/
void bdLoginTaskUmbrellaCrossplay::cancelRemoteTask(bdLoginTaskUmbrellaCrossplay *this)
{
  bdRemoteTask *m_ptr; 

  m_ptr = this->m_remoteTask.m_ptr;
  if ( m_ptr )
    bdRemoteTask::cancelTask(m_ptr);
}

/*
==============
bdLoginTaskUmbrellaCrossplay::clearBuffers
==============
*/
void bdLoginTaskUmbrellaCrossplay::clearBuffers(bdLoginTaskUmbrellaCrossplay *this)
{
  memset_0(this->m_httpRequestBuffer, 0, this->m_requestBufferSize);
  memset_0(this->m_httpResponseBuffer, 0, this->m_responseBufferSize);
}

/*
==============
bdLoginTaskUmbrellaCrossplay::convertSIErrorCode
==============
*/
__int64 bdLoginTaskUmbrellaCrossplay::convertSIErrorCode(bdLoginTaskUmbrellaCrossplay *this, const unsigned int *__formal)
{
  return 0i64;
}

/*
==============
bdLoginTaskUmbrellaCrossplay::createUmbrellaLoginJson
==============
*/
bool bdLoginTaskUmbrellaCrossplay::createUmbrellaLoginJson(bdLoginTaskUmbrellaCrossplay *this, bdJSONSerializer *umbrellaLoginJSON)
{
  bdExtendedAuthInfo *ExtendedAuthInfo; 
  const char *Data; 
  bool v6; 
  bdExtendedAuthInfo *v7; 
  const char *v8; 
  bool v9; 
  __int64 v11; 

  v6 = 0;
  if ( bdJSONSerializer::writeBeginObject(umbrellaLoginJSON) && bdJSONSerializer::writeString(umbrellaLoginJSON, "ticket", this->m_authTicketB64) && bdJSONSerializer::writeString(umbrellaLoginJSON, "initialVectorSeed", this->m_ivSeedB64) && bdJSONSerializer::writeInt32(umbrellaLoginJSON, "titleID", this->m_loginResult->m_titleID, 0) )
  {
    ExtendedAuthInfo = (bdExtendedAuthInfo *)bdLoginResult::getExtendedAuthInfo(this->m_loginResult);
    Data = bdExtendedAuthInfo::getData(ExtendedAuthInfo);
    if ( bdJSONSerializer::writeString(umbrellaLoginJSON, "authToken", Data) )
      v6 = 1;
  }
  bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::createUmbrellaLoginJson", 0xC1u, "Making request with the following params:");
  bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::createUmbrellaLoginJson", 0xC2u, "m_authTicketB64: %s", this->m_authTicketB64);
  bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::createUmbrellaLoginJson", 0xC3u, "m_ivSeedB64: %s", this->m_ivSeedB64);
  LODWORD(v11) = this->m_loginResult->m_titleID;
  bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::createUmbrellaLoginJson", 0xC4u, "m_titleID: %d", v11);
  v7 = (bdExtendedAuthInfo *)bdLoginResult::getExtendedAuthInfo(this->m_loginResult);
  v8 = bdExtendedAuthInfo::getData(v7);
  bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::createUmbrellaLoginJson", 0xC5u, "Auth token key: %s", v8);
  if ( this->m_linking )
  {
    bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::createUmbrellaLoginJson", 0xCEu, "Added UnoID token to perform crossplay account linking");
    if ( !v6 )
      return 0;
    v9 = !bdJSONSerializer::writeString(umbrellaLoginJSON, "unoToken", this->m_unoIDToken);
  }
  else
  {
    v9 = !v6;
  }
  return !v9 && bdJSONSerializer::writeEndObject(umbrellaLoginJSON);
}

/*
==============
bdLoginTaskUmbrellaCrossplay::getFailedTask
==============
*/
bdReference<bdRemoteTask> *bdLoginTaskUmbrellaCrossplay::getFailedTask(bdLoginTaskUmbrellaCrossplay *this, bdReference<bdRemoteTask> *result)
{
  bdRemoteTask *v3; 
  bdRemoteTask *v4; 
  bdRemoteTask *v5; 

  v3 = (bdRemoteTask *)bdMemory::allocate(0x68ui64);
  if ( v3 )
  {
    bdRemoteTask::bdRemoteTask(v3);
    v5 = v4;
  }
  else
  {
    v5 = NULL;
  }
  result->m_ptr = v5;
  if ( v5 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v5->m_refCount, 1u);
  result->m_ptr->m_status = BD_FAILED;
  result->m_ptr->m_errorCode = BD_START_TASK_FAILED;
  return result;
}

/*
==============
bdLoginTaskUmbrellaCrossplay::getNewTask
==============
*/
bdReference<bdRemoteTask> *bdLoginTaskUmbrellaCrossplay::getNewTask(bdLoginTaskUmbrellaCrossplay *this, bdReference<bdRemoteTask> *result)
{
  bdRemoteTask *v4; 
  bdRemoteTask *v5; 
  bdRemoteTask *v6; 

  v4 = NULL;
  v5 = (bdRemoteTask *)bdMemory::allocate(0x68ui64);
  if ( v5 )
  {
    bdRemoteTask::bdRemoteTask(v5);
    v4 = v6;
  }
  result->m_ptr = v4;
  if ( v4 )
    _InterlockedExchangeAdd((volatile signed __int32 *)&v4->m_refCount, 1u);
  result->m_ptr->m_status = BD_PENDING;
  result->m_ptr->m_transactionID = bdLoginResult::getTransactionID(this->m_loginResult);
  return result;
}

/*
==============
bdLoginTaskUmbrellaCrossplay::getRemoteTaskRef
==============
*/
bdReference<bdRemoteTask> *bdLoginTaskUmbrellaCrossplay::getRemoteTaskRef(bdLoginTaskUmbrellaCrossplay *this, bdReference<bdRemoteTask> *result)
{
  bdRemoteTask *m_ptr; 

  m_ptr = this->m_remoteTask.m_ptr;
  result->m_ptr = m_ptr;
  if ( m_ptr )
    _InterlockedExchangeAdd((volatile signed __int32 *)&m_ptr->m_refCount, 1u);
  return result;
}

/*
==============
bdLoginTaskUmbrellaCrossplay::getTaskCode
==============
*/
__int64 bdLoginTaskUmbrellaCrossplay::getTaskCode(bdLoginTaskUmbrellaCrossplay *this)
{
  return (unsigned int)this->m_umbrellaStatusCode;
}

/*
==============
bdLoginTaskUmbrellaCrossplay::getTaskMessage
==============
*/
char *bdLoginTaskUmbrellaCrossplay::getTaskMessage(bdLoginTaskUmbrellaCrossplay *this)
{
  return this->m_umbrellaStatusMessage;
}

/*
==============
bdLoginTaskUmbrellaCrossplay::parseErrorJSON
==============
*/
void bdLoginTaskUmbrellaCrossplay::parseErrorJSON(bdLoginTaskUmbrellaCrossplay *this)
{
  char *m_httpResponseBuffer; 
  unsigned int v3; 
  unsigned int v4; 
  unsigned __int64 TransactionID; 
  unsigned int v6; 
  unsigned int v7; 
  bdJSONDeserializer value; 
  __int64 v9; 
  bdJSONDeserializer v10; 
  char v11[128]; 
  char v12[256]; 

  v9 = -2i64;
  m_httpResponseBuffer = this->m_httpResponseBuffer;
  bdJSONDeserializer::bdJSONDeserializer(&v10, this->m_httpResponseBuffer);
  bdJSONDeserializer::bdJSONDeserializer(&value);
  if ( bdJSONDeserializer::getObject(&v10, "error", &value) && value.m_type == BD_JSON_OBJECT )
  {
    v7 = 0;
    if ( value.m_parsed && ((bdJSONDeserializer::getUInt32(&value, "code", &v7), bdJSONDeserializer::getString(&value, (const char *const)&stru_143C9A1A4, v11, 0x80u), bdJSONDeserializer::getString(&value, "msg", v12, 0x100u), v3 = v7, v4 = this->m_httpInterface->getLastHTTPStatus(this->m_httpInterface), TransactionID = bdLoginResult::getTransactionID(this->m_loginResult), bdLogMessage(BD_LOG_ERROR, (const char *const)&other, "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::parseErrorJSON", 0x200u, "Umbrella crossplay request failed. trID: %I64u; HTTP code: %u; Error: %s; Error code: %u; Message: %s", TransactionID, v4, v11, v3, v12), v7 == 255000) || v7 == 241000) )
    {
      if ( v7 == 241000 )
        this->m_loginResult->m_taskErrorCode = BD_UMBRELLA_MERGE_CONFLICT;
      else
        this->m_loginResult->m_taskErrorCode = BD_UMBRELLA_PLAYER_BAN;
    }
    else
    {
      this->m_remoteTask.m_ptr->m_errorCode = BD_NO_ERROR;
    }
  }
  else
  {
    v6 = this->m_httpInterface->getLastHTTPStatus(this->m_httpInterface);
    bdLogMessage(BD_LOG_ERROR, (const char *const)&other, "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::parseErrorJSON", 0x214u, "Umbrella crossplay HTTP request failed with HTTP error code: %u. Response: %s", v6, m_httpResponseBuffer);
    this->m_remoteTask.m_ptr->m_errorCode = BD_SI_ERROR;
  }
  bdJSONDeserializer::~bdJSONDeserializer(&value);
  bdJSONDeserializer::~bdJSONDeserializer(&v10);
}

/*
==============
bdLoginTaskUmbrellaCrossplay::processUmbrellaLoginReply
==============
*/
void bdLoginTaskUmbrellaCrossplay::processUmbrellaLoginReply(bdLoginTaskUmbrellaCrossplay *this)
{
  unsigned int v3; 
  unsigned int v4; 
  bdLoginResult *m_loginResult; 
  const char *m_authTicketB64; 
  char *m_data; 
  unsigned int v8; 
  bdLoginResult *v9; 
  unsigned int v10; 
  bdLoginResult *v11; 
  unsigned int v12; 
  const char *v14; 
  unsigned __int64 UmbrellaID; 
  __int64 v17; 
  double v18; 
  bool value; 
  bdLoginTaskUmbrellaCrossplay::UmbrellaLoginStatusCode code; 
  bdJSONDeserializer v21; 
  __int64 v22; 
  unsigned __int8 dest[8]; 
  __int64 v24; 
  __int64 v25; 
  __int64 v26; 

  v22 = -2i64;
  bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::processUmbrellaLoginReply", 0xD7u, "Processing bdLogin Umbrella crossplay login task reply");
  v3 = this->m_httpInterface->getLastHTTPStatus(this->m_httpInterface);
  v4 = v3;
  if ( v3 != 200 )
  {
    bdLogMessage(BD_LOG_ERROR, (const char *const)&other, "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::processUmbrellaLoginReply", 0x11Bu, "Umbrella login task failed with HTTP code [%u]", v3);
    if ( bdLoginResult::getTaskErrorCode(this->m_loginResult) == BD_UMBRELLA_PLAYER_BAN )
    {
      bdHandleAssert(1, "(messageInfo != BD_NULL)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus", 0x286u, "Must provide valid message to update Umbrella login task status!");
      v14 = "Player is banned";
    }
    else
    {
      if ( bdLoginResult::getTaskErrorCode(this->m_loginResult) != BD_UMBRELLA_MERGE_CONFLICT )
      {
        bdSnprintf(this->m_umbrellaStatusMessage, 0x400ui64, "Umbrella login task failed with HTTP code [%u]", v4);
        code = CONNECTED;
        bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus(this, this->m_umbrellaStatusMessage, &code);
        return;
      }
      bdHandleAssert(1, "(messageInfo != BD_NULL)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus", 0x286u, "Must provide valid message to update Umbrella login task status!");
      v14 = "Umbrella merge conflict";
    }
    this->m_umbrellaStatusCode = DISCONNECTING;
    bdStrlcpy(this->m_umbrellaStatusMessage, v14, 0x400ui64);
    *(double *)&_XMM0 = bdStopwatch::getElapsedTimeInSeconds(&this->m_taskTimer);
    __asm
    {
      vcvtss2sd xmm1, xmm0, xmm0
      vmovsd  [rsp+0B0h+var_78], xmm1
    }
    bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus", 0x28Eu, "Task finished after %2.1f seconds", v18);
    return;
  }
  bdJSONDeserializer::bdJSONDeserializer(&v21);
  if ( bdJSONDeserializer::parse(&v21, this->m_httpResponseBuffer) && bdJSONDeserializer::isObject(&v21) )
  {
    if ( !bdJSONDeserializer::getBoolean(&v21, "crossPlatformProgressionEnabled", &this->m_loginResult->m_crossPlatformProgressionEnabled) )
      bdLogMessage(BD_LOG_ERROR, (const char *const)&other, "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::processUmbrellaLoginReply", 0xE5u, "Failed to read crossplatform progression from Umbrella Crossplatform Response");
    if ( bdJSONDeserializer::hasKey(&v21, "hasUno") )
    {
      bdJSONDeserializer::getBoolean(&v21, "hasUno", &value);
      if ( !value )
      {
        this->m_remoteTask.m_ptr->m_errorCode = BD_UMBRELLA_ACCOUNT_NOT_FOUND;
        code = CONNECTED;
        bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus(this, "No Uno account detected for user.", &code);
        bdJSONDeserializer::~bdJSONDeserializer(&v21);
        return;
      }
    }
    if ( bdJSONDeserializer::hasKey(&v21, "lsgEndpoint") )
      bdJSONDeserializer::getString(&v21, "lsgEndpoint", this->m_loginResult->m_lsgAddress, 0x400u);
    bdLoginResult::setExtendedAuthInfo(this->m_loginResult, this->m_loginResult->m_crossplayAccount.m_crossplayInfo.m_accessInfo.m_accessToken);
    m_loginResult = this->m_loginResult;
    m_authTicketB64 = m_loginResult->m_crossplayAccount.m_crossplayInfo.m_authTicketB64;
    m_data = m_loginResult->m_data;
    v8 = bdStrlen(m_loginResult->m_crossplayAccount.m_crossplayInfo.m_authTicketB64);
    bdBase64::decode(m_authTicketB64, v8, m_data, 0x80u);
    *(_QWORD *)dest = 0i64;
    v24 = 0i64;
    v25 = 0i64;
    v26 = 0i64;
    v9 = this->m_loginResult;
    v10 = bdStrlen(v9->m_crossplayAccount.m_crossplayInfo.m_IVSeedB64Str);
    bdBase64::decode(v9->m_crossplayAccount.m_crossplayInfo.m_IVSeedB64Str, v10, dest, 0x20u);
    v11 = this->m_loginResult;
    v12 = strtoul((const char *)dest, NULL, 10);
    bdLoginResult::setIVSeed(v11, v12);
    bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::processUmbrellaLoginReply", 0x10Eu, "Setting state to COMPLETED");
    code = DISCONNECTED;
    bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus(this, "Got successful Umbrella Crossplay login reply", &code);
    UmbrellaID = bdLoginResult::getUmbrellaID(this->m_loginResult);
    bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::processUmbrellaLoginReply", 0x110u, "UmbrellaID: %I64u", UmbrellaID);
  }
  else
  {
    bdLogMessage(BD_LOG_ERROR, (const char *const)&other, "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::processUmbrellaLoginReply", 0x114u, "Failed to process Umbrella login response json", 200);
    bdHandleAssert(1, "(messageInfo != BD_NULL)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus", 0x286u, "Must provide valid message to update Umbrella login task status!");
    this->m_umbrellaStatusCode = CONNECTED;
    bdStrlcpy(this->m_umbrellaStatusMessage, "Failed to parse Umbrella login response json", 0x400ui64);
    *(double *)&_XMM0 = bdStopwatch::getElapsedTimeInSeconds(&this->m_taskTimer);
    __asm
    {
      vcvtss2sd xmm1, xmm0, xmm0
      vmovsd  [rsp+0B0h+var_78], xmm1
    }
    bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus", 0x28Eu, "Task finished after %2.1f seconds", v17);
  }
  bdJSONDeserializer::~bdJSONDeserializer(&v21);
}

/*
==============
bdLoginTaskUmbrellaCrossplay::processUmbrellaRefreshReply
==============
*/
void bdLoginTaskUmbrellaCrossplay::processUmbrellaRefreshReply(bdLoginTaskUmbrellaCrossplay *this)
{
  unsigned int v3; 
  unsigned int v4; 
  const char *v5; 
  double v7; 
  bdJSONDeserializer v8; 
  bdLoginTaskUmbrellaCrossplay::UmbrellaLoginStatusCode code; 

  bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::processUmbrellaRefreshReply", 0x1C6u, "Processing bdLogin Umbrella token refresh task reply");
  v3 = this->m_httpInterface->getLastHTTPStatus(this->m_httpInterface);
  v4 = v3;
  if ( v3 == 200 )
  {
    bdJSONDeserializer::bdJSONDeserializer(&v8);
    if ( bdJSONDeserializer::parse(&v8, this->m_httpResponseBuffer) && bdJSONDeserializer::isObject(&v8) )
    {
      bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::processUmbrellaRefreshReply", 0x1D3u, "Setting state to COMPLETED");
      bdHandleAssert(1, "(messageInfo != BD_NULL)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus", 0x286u, "Must provide valid message to update Umbrella login task status!");
      this->m_umbrellaStatusCode = DISCONNECTED;
      v5 = "Got successful Umbrella token refresh reply";
    }
    else
    {
      bdLogMessage(BD_LOG_ERROR, (const char *const)&other, "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::processUmbrellaRefreshReply", 0x1D8u, "Failed to process Umbrella token refresh response json", 200);
      bdHandleAssert(1, "(messageInfo != BD_NULL)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus", 0x286u, "Must provide valid message to update Umbrella login task status!");
      this->m_umbrellaStatusCode = CONNECTED;
      v5 = "Failed to parse Umbrella token refresh response json";
    }
    bdStrlcpy(this->m_umbrellaStatusMessage, v5, 0x400ui64);
    *(double *)&_XMM0 = bdStopwatch::getElapsedTimeInSeconds(&this->m_taskTimer);
    __asm
    {
      vcvtss2sd xmm1, xmm0, xmm0
      vmovsd  [rsp+78h+var_40], xmm1
    }
    bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus", 0x28Eu, "Task finished after %2.1f seconds", v7);
    bdJSONDeserializer::~bdJSONDeserializer(&v8);
  }
  else
  {
    bdLogMessage(BD_LOG_ERROR, (const char *const)&other, "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::processUmbrellaRefreshReply", 0x1DEu, "Umbrella token refresh task failed with HTTP code [%u]", v3);
    bdSnprintf(this->m_umbrellaStatusMessage, 0x400ui64, "Umbrella login task failed with HTTP code [%u]", v4);
    code = CONNECTED;
    bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus(this, this->m_umbrellaStatusMessage, &code);
  }
}

/*
==============
bdLoginTaskUmbrellaCrossplay::pump
==============
*/
void bdLoginTaskUmbrellaCrossplay::pump(bdLoginTaskUmbrellaCrossplay *this)
{
  bdLoginTaskUmbrellaCrossplay::UmbrellaLoginStatusCode m_umbrellaStatusCode; 
  __int32 v4; 
  __int32 v5; 
  bdHTTP *v7; 
  bdLoginConfig *m_loginConfig; 
  const char *Region; 
  const char *ClientID; 
  __int64 v11; 
  double v12; 
  bdLoginTaskUmbrellaCrossplay::UmbrellaLoginStatusCode code; 
  char buf[40]; 
  char url[512]; 

  m_umbrellaStatusCode = this->m_umbrellaStatusCode;
  if ( m_umbrellaStatusCode )
  {
    v4 = m_umbrellaStatusCode - 1;
    if ( v4 )
    {
      v5 = v4 - 1;
      if ( v5 )
      {
        if ( v5 == 1 )
        {
          bdLoginTaskUmbrellaCrossplay::processUmbrellaLoginReply(this);
        }
        else
        {
          bdLogMessage(BD_LOG_ERROR, (const char *const)&other, "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::pump", 0x27Du, "Pumping Umbrella crossplay login request in an unknown state!");
          bdHandleAssert(1, "(messageInfo != BD_NULL)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus", 0x286u, "Must provide valid message to update Umbrella login task status!");
          this->m_umbrellaStatusCode = CONNECTED;
          bdStrlcpy(this->m_umbrellaStatusMessage, "Pumping Umbrella crossplay login request in an unknown state!", 0x400ui64);
          *(double *)&_XMM0 = bdStopwatch::getElapsedTimeInSeconds(&this->m_taskTimer);
          __asm
          {
            vcvtss2sd xmm1, xmm0, xmm0
            vmovsd  [rsp+288h+var_250], xmm1
          }
          bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus", 0x28Eu, "Task finished after %2.1f seconds", v12);
        }
      }
      else if ( this->m_remoteTask.m_ptr->getStatus(this->m_remoteTask.m_ptr) == BD_PENDING )
      {
        bdLoginTaskUmbrellaCrossplay::pumpRemoteTask(this);
      }
      else
      {
        bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::pump", 0x274u, "Setting state to RECEIVED_REPLY");
        code = WAITING_FOR_REPORT_CONSOLE_DETAILS;
        bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus(this, "Got a reply from crossplay login request to Umbrella", &code);
      }
    }
    else
    {
      bdLoginTaskUmbrellaCrossplay::startLoginTask(this);
    }
  }
  else
  {
    bdStopwatch::start(&this->m_taskTimer);
    v7 = bdHTTPUtility::newHTTP(0, 0);
    m_loginConfig = (bdLoginConfig *)this->m_loginConfig;
    this->m_httpInterface = v7;
    Region = bdLoginConfig::getRegion(m_loginConfig);
    code = bdLoginResult::getEnvironment(this->m_loginResult);
    bdLoginUtils::getUmbrellaUrl((char (*)[512])url, (const bdEnvironment *)&code, Region);
    ClientID = bdLoginResult::getClientID(this->m_loginResult);
    bdSnprintf(this->m_url, 0x200ui64, "%s/v2.0/tokens/crossplatform/?client=%s", url, ClientID);
    bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::buildUmbrellaLoginReq", 0x90u, "URL : %s", this->m_url);
    bdBase64::encode(this->m_loginResult->m_data, 0x80u, this->m_authTicketB64, 0xADu);
    bdSnprintf(buf, 0x20ui64, "%u", this->m_loginResult->m_IVSeed);
    bdHandleAssert(1, "s != BD_NULL", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdplatform\\bdplatformstring\\bdplatformstring.inl", "bdStrlen", 0x110u, "null ptr in bdStrlen");
    v11 = -1i64;
    do
      ++v11;
    while ( buf[v11] );
    bdBase64::encode(buf, v11, this->m_ivSeedB64, 0x20u);
    bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::buildUmbrellaLoginReq", 0x9Fu, "Setting state to READY");
    bdHandleAssert(1, "(messageInfo != BD_NULL)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus", 0x286u, "Must provide valid message to update Umbrella login task status!");
    this->m_umbrellaStatusCode = NOT_CONNECTED;
    bdStrlcpy(this->m_umbrellaStatusMessage, "Built request for Umbrella crossplay login", 0x400ui64);
    bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::buildUmbrellaLoginReq", 0xA1u, "Built request for Umbrella crossplay login");
  }
}

/*
==============
bdLoginTaskUmbrellaCrossplay::pumpRefresh
==============
*/
void bdLoginTaskUmbrellaCrossplay::pumpRefresh(bdLoginTaskUmbrellaCrossplay *this)
{
  bdLoginTaskUmbrellaCrossplay::UmbrellaLoginStatusCode m_umbrellaStatusCode; 
  __int32 v4; 
  __int32 v5; 
  bdHTTP *v7; 
  bdLoginConfig *m_loginConfig; 
  const char *Region; 
  const char *ClientID; 
  double v11; 
  bdLoginTaskUmbrellaCrossplay::UmbrellaLoginStatusCode code[4]; 
  char url[512]; 

  m_umbrellaStatusCode = this->m_umbrellaStatusCode;
  if ( m_umbrellaStatusCode )
  {
    v4 = m_umbrellaStatusCode - 1;
    if ( v4 )
    {
      v5 = v4 - 1;
      if ( v5 )
      {
        if ( v5 == 1 )
        {
          bdLoginTaskUmbrellaCrossplay::processUmbrellaRefreshReply(this);
        }
        else
        {
          bdLogMessage(BD_LOG_ERROR, (const char *const)&other, "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::pumpRefresh", 0x2B8u, "Pumping Umbrella crossplay refresh token request in an unknown state!");
          bdHandleAssert(1, "(messageInfo != BD_NULL)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus", 0x286u, "Must provide valid message to update Umbrella login task status!");
          this->m_umbrellaStatusCode = CONNECTED;
          bdStrlcpy(this->m_umbrellaStatusMessage, "Pumping Umbrella crossplay refresh token request in an unknown state!", 0x400ui64);
          *(double *)&_XMM0 = bdStopwatch::getElapsedTimeInSeconds(&this->m_taskTimer);
          __asm
          {
            vcvtss2sd xmm1, xmm0, xmm0
            vmovsd  [rsp+268h+var_230], xmm1
          }
          bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus", 0x28Eu, "Task finished after %2.1f seconds", v11);
        }
      }
      else if ( this->m_remoteTask.m_ptr->getStatus(this->m_remoteTask.m_ptr) == BD_PENDING )
      {
        bdLoginTaskUmbrellaCrossplay::pumpRemoteTask(this);
      }
      else
      {
        bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::pumpRefresh", 0x2AFu, "Setting state to RECEIVED_REPLY");
        code[0] = WAITING_FOR_REPORT_CONSOLE_DETAILS;
        bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus(this, "Got a reply from crossplay refresh token request to Umbrella", code);
      }
    }
    else
    {
      bdLoginTaskUmbrellaCrossplay::startRefreshTask(this);
    }
  }
  else
  {
    bdStopwatch::reset(&this->m_taskTimer);
    bdStopwatch::start(&this->m_taskTimer);
    v7 = bdHTTPUtility::newHTTP(0, 0);
    m_loginConfig = (bdLoginConfig *)this->m_loginConfig;
    this->m_httpInterface = v7;
    Region = bdLoginConfig::getRegion(m_loginConfig);
    code[0] = bdLoginResult::getEnvironment(this->m_loginResult);
    bdLoginUtils::getUmbrellaUrl((char (*)[512])url, (const bdEnvironment *)code, Region);
    ClientID = bdLoginResult::getClientID(this->m_loginResult);
    bdSnprintf(this->m_url, 0x200ui64, "%s/v1.0/tokens/refresh/?client=%s", url, ClientID);
    bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::buildUmbrellaRefreshReq", 0xB3u, "Setting state to READY");
    bdHandleAssert(1, "(messageInfo != BD_NULL)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus", 0x286u, "Must provide valid message to update Umbrella login task status!");
    this->m_umbrellaStatusCode = NOT_CONNECTED;
    bdStrlcpy(this->m_umbrellaStatusMessage, "Built request for Umbrella crossplay refresh token", 0x400ui64);
    bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::buildUmbrellaRefreshReq", 0xB5u, "Built request for Umbrella crossplay refresh token");
  }
}

/*
==============
bdLoginTaskUmbrellaCrossplay::pumpRemoteTask
==============
*/
void bdLoginTaskUmbrellaCrossplay::pumpRemoteTask(bdLoginTaskUmbrellaCrossplay *this)
{
  bdRemoteTask *m_ptr; 
  int v3; 
  bdJSONDeserializer v4; 

  m_ptr = this->m_remoteTask.m_ptr;
  if ( m_ptr && m_ptr->getStatus(m_ptr) && this->m_remoteTask.m_ptr->getStatus(this->m_remoteTask.m_ptr) != BD_DONE )
  {
    if ( this->m_remoteTask.m_ptr->getStatus(this->m_remoteTask.m_ptr) == BD_CANCELLED && this->m_remoteTask.m_ptr )
    {
      if ( this->m_httpInterface->getStatus(this->m_httpInterface) != (BD_MAX_STATUS|BD_PENDING) )
      {
        bdLogMessage(BD_LOG_WARNING, "warn/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::pumpRemoteTask", 0x22Eu, "Aborting HTTP operation");
        this->m_httpInterface->abortOperation(this->m_httpInterface);
      }
      bdRemoteTask::cancelTask(this->m_remoteTask.m_ptr);
    }
    v3 = ((__int64 (__fastcall *)(bdHTTP *))this->m_httpInterface->getStatus)(this->m_httpInterface) - 5;
    if ( v3 )
    {
      if ( v3 == 1 )
      {
        this->m_remoteTask.m_ptr->m_status = BD_FAILED;
        bdLoginTaskUmbrellaCrossplay::parseErrorJSON(this);
        this->m_outputObject = NULL;
      }
    }
    else
    {
      this->m_remoteTask.m_ptr->m_status = BD_DONE;
      if ( this->m_outputObject )
      {
        bdJSONDeserializer::bdJSONDeserializer(&v4, this->m_httpResponseBuffer);
        this->m_outputObject->deserializeFromJSON(this->m_outputObject, &v4);
        bdJSONDeserializer::~bdJSONDeserializer(&v4);
      }
      bdUmbrellaCrossplayInfo::resetRefreshTimer(&this->m_loginResult->m_crossplayAccount.m_crossplayInfo, &this->m_loginResult->m_crossplayAccount.m_crossplayInfo.m_accessInfo);
      this->m_outputObject = NULL;
    }
  }
}

/*
==============
bdLoginTaskUmbrellaCrossplay::readyForRequest
==============
*/
_BOOL8 bdLoginTaskUmbrellaCrossplay::readyForRequest(bdLoginTaskUmbrellaCrossplay *this)
{
  bdHTTP::bdStatus v1; 
  bool v2; 

  v1 = this->m_httpInterface->getStatus(this->m_httpInterface);
  v2 = v1 != BD_FAILED;
  if ( v1 == BD_FAILED )
    bdLogMessage(BD_LOG_ERROR, (const char *const)&other, "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::readyForRequest", 0x49u, "Only one Umbrella crossplay request can happen at a time.");
  return v2;
}

/*
==============
bdLoginTaskUmbrellaCrossplay::reset
==============
*/
void bdLoginTaskUmbrellaCrossplay::reset(bdLoginTaskUmbrellaCrossplay *this)
{
  bdHTTP *m_httpInterface; 
  bdHTTP *v3; 
  bdRemoteTask *m_ptr; 
  bdRemoteTask *v5; 
  bdRemoteTask *v6; 

  m_httpInterface = this->m_httpInterface;
  if ( m_httpInterface )
  {
    m_httpInterface->abortOperation(m_httpInterface);
    v3 = this->m_httpInterface;
    if ( v3 )
      ((void (__fastcall *)(bdHTTP *, __int64))v3->~bdHTTP)(v3, 1i64);
    this->m_httpInterface = NULL;
  }
  m_ptr = this->m_remoteTask.m_ptr;
  if ( m_ptr )
    bdRemoteTask::cancelTask(m_ptr);
  memset_0(this->m_httpRequestBuffer, 0, this->m_requestBufferSize);
  memset_0(this->m_httpResponseBuffer, 0, this->m_responseBufferSize);
  v5 = this->m_remoteTask.m_ptr;
  if ( v5 )
  {
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)&v5->m_refCount, 0xFFFFFFFF) == 1 )
    {
      v6 = this->m_remoteTask.m_ptr;
      if ( v6 )
        ((void (__fastcall *)(bdRemoteTask *, __int64))v6->~bdReferencable)(v6, 1i64);
    }
  }
  this->m_remoteTask.m_ptr = NULL;
  bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::reset", 0x7Eu, "Setting state to UNINITIALIZED");
  bdHandleAssert(1, "(messageInfo != BD_NULL)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus", 0x286u, "Must provide valid message to update Umbrella login task status!");
  this->m_umbrellaStatusCode = UNINITIALIZED;
  bdStrlcpy(this->m_umbrellaStatusMessage, (const char *const)&queryFormat.fmt + 3, 0x400ui64);
}

/*
==============
bdLoginTaskUmbrellaCrossplay::resetHttpInterface
==============
*/
void bdLoginTaskUmbrellaCrossplay::resetHttpInterface(bdLoginTaskUmbrellaCrossplay *this)
{
  bdHTTP *m_httpInterface; 
  bdHTTP *v3; 

  m_httpInterface = this->m_httpInterface;
  if ( m_httpInterface )
  {
    m_httpInterface->abortOperation(m_httpInterface);
    v3 = this->m_httpInterface;
    if ( v3 )
      ((void (__fastcall *)(bdHTTP *, __int64))v3->~bdHTTP)(v3, 1i64);
    this->m_httpInterface = NULL;
  }
}

/*
==============
bdLoginTaskUmbrellaCrossplay::sendUmbrellaRequest
==============
*/
void bdLoginTaskUmbrellaCrossplay::sendUmbrellaRequest(bdLoginTaskUmbrellaCrossplay *this, bdJSONSerializer *requestJSON)
{
  __int64 v5; 
  bdRemoteTask *v6; 
  __int64 v7; 
  __int64 v8; 
  char v9; 
  bdHTTP *m_httpInterface; 
  unsigned int v11; 
  bdHTTP *v12; 
  bool (__fastcall *setHeader)(bdHTTP *, const char *, const unsigned __int64); 
  unsigned __int64 TransactionID; 
  bdRemoteTask *v16; 
  __int64 v17; 
  unsigned __int64 v18; 
  unsigned __int64 v20; 
  double v21; 
  double v22; 
  bdReference<bdRemoteTask> other; 
  bdReference<bdRemoteTask> v24; 

  v5 = 0i64;
  v6 = (bdRemoteTask *)bdMemory::allocate(0x68ui64);
  other.m_ptr = v6;
  if ( v6 )
  {
    bdRemoteTask::bdRemoteTask(v6);
    v8 = v7;
  }
  else
  {
    v8 = 0i64;
  }
  other.m_ptr = (bdRemoteTask *)v8;
  if ( v8 )
    _InterlockedExchangeAdd((volatile signed __int32 *)(v8 + 8), 1u);
  *(_DWORD *)(v8 + 28) = 1;
  *(_QWORD *)(v8 + 72) = bdLoginResult::getTransactionID(this->m_loginResult);
  bdReference<bdRemoteTask>::operator=(&this->m_remoteTask, &other);
  if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v8 + 8), 0xFFFFFFFF) == 1 )
    (**(void (__fastcall ***)(__int64, __int64))v8)(v8, 1i64);
  v9 = ((__int64 (__fastcall *)(bdHTTP *, __int64, char *))this->m_httpInterface->initRequest)(this->m_httpInterface, 3i64, this->m_url);
  m_httpInterface = this->m_httpInterface;
  v11 = bdJSONSerializer::length(requestJSON);
  bdHTTP::setUploadData(m_httpInterface, this->m_httpRequestBuffer, v11);
  bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::sendUmbrellaRequest", 0x183u, "HTTP Request Params: %s", this->m_httpRequestBuffer);
  bdHTTP::setDownloadBuffer(this->m_httpInterface, this->m_httpResponseBuffer, this->m_responseBufferSize);
  if ( !v9 || (v12 = this->m_httpInterface, setHeader = v12->setHeader, TransactionID = bdLoginResult::getTransactionID(this->m_loginResult), !setHeader(v12, "X-TransactionID", TransactionID)) || !this->m_httpInterface->setHeader(this->m_httpInterface, "Content-Type", "application/json") || !this->m_httpInterface->setHeader(this->m_httpInterface, "Accept", "application/json") )
  {
    bdHandleAssert(1, "(messageInfo != BD_NULL)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus", 0x286u, "Must provide valid message to update Umbrella login task status!");
    this->m_umbrellaStatusCode = CONNECTED;
    bdStrlcpy(this->m_umbrellaStatusMessage, "Encountered error while attempting to start request for Umbrella Crossplay token refresh", 0x400ui64);
    *(double *)&_XMM0 = bdStopwatch::getElapsedTimeInSeconds(&this->m_taskTimer);
    __asm
    {
      vcvtss2sd xmm1, xmm0, xmm0
      vmovsd  [rsp+88h+var_50], xmm1
    }
    bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus", 0x28Eu, "Task finished after %2.1f seconds", v21);
    bdLogMessage(BD_LOG_ERROR, (const char *const)&::other, "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::sendUmbrellaRequest", 0x18Fu, "Encountered error while attempting to start request for Umbrella Crossplay token refresh");
    v16 = (bdRemoteTask *)bdMemory::allocate(0x68ui64);
    v24.m_ptr = v16;
    if ( v16 )
    {
      bdRemoteTask::bdRemoteTask(v16);
      v5 = v17;
    }
    v24.m_ptr = (bdRemoteTask *)v5;
    if ( v5 )
      _InterlockedExchangeAdd((volatile signed __int32 *)(v5 + 8), 1u);
    *(_DWORD *)(v5 + 28) = 3;
    *(_DWORD *)(v5 + 80) = 5;
    bdReference<bdRemoteTask>::operator=(&this->m_remoteTask, &v24);
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v5 + 8), 0xFFFFFFFF) == 1 )
      (**(void (__fastcall ***)(__int64, __int64))v5)(v5, 1i64);
  }
  this->m_httpInterface->sendRequest(this->m_httpInterface);
  if ( this->m_remoteTask.m_ptr->getStatus(this->m_remoteTask.m_ptr) == BD_PENDING )
  {
    bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::sendUmbrellaRequest", 0x197u, "Setting state to PENDING");
    bdHandleAssert(1, "(messageInfo != BD_NULL)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus", 0x286u, "Must provide valid message to update Umbrella login task status!");
    this->m_umbrellaStatusCode = CONNECTING;
    bdStrlcpy(this->m_umbrellaStatusMessage, "Sent crossplay token refresh request to Umbrella", 0x400ui64);
    v18 = bdRemoteTask::getTransactionID(this->m_remoteTask.m_ptr);
    bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::sendUmbrellaRequest", 0x19Bu, "Started call to Umbrella token refresh. TransactionID: (%I64u)", v18);
  }
  else
  {
    bdHandleAssert(1, "(messageInfo != BD_NULL)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus", 0x286u, "Must provide valid message to update Umbrella login task status!");
    this->m_umbrellaStatusCode = CONNECTED;
    bdStrlcpy(this->m_umbrellaStatusMessage, "Got into unexpected state starting the Umbrella Crossplay token refresh request", 0x400ui64);
    *(double *)&_XMM0 = bdStopwatch::getElapsedTimeInSeconds(&this->m_taskTimer);
    __asm
    {
      vcvtss2sd xmm1, xmm0, xmm0
      vmovsd  [rsp+88h+var_50], xmm1
    }
    bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus", 0x28Eu, "Task finished after %2.1f seconds", v22);
    v20 = bdRemoteTask::getTransactionID(this->m_remoteTask.m_ptr);
    bdLogMessage(BD_LOG_ERROR, (const char *const)&::other, "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::sendUmbrellaRequest", 0x1A2u, "Got into unexpected state starting the Umbrella Crossplay Login request. TransactionID: (%I64u)", v20);
  }
}

/*
==============
bdLoginTaskUmbrellaCrossplay::setLinking
==============
*/
void bdLoginTaskUmbrellaCrossplay::setLinking(bdLoginTaskUmbrellaCrossplay *this, const bool linking)
{
  this->m_linking = linking;
}

/*
==============
bdLoginTaskUmbrellaCrossplay::setUnoIDToken
==============
*/
void bdLoginTaskUmbrellaCrossplay::setUnoIDToken(bdLoginTaskUmbrellaCrossplay *this, const char *unoIDToken)
{
  bdStrlcpy(this->m_unoIDToken, unoIDToken, 0x400ui64);
}

/*
==============
bdLoginTaskUmbrellaCrossplay::startLoginTask
==============
*/
void bdLoginTaskUmbrellaCrossplay::startLoginTask(bdLoginTaskUmbrellaCrossplay *this)
{
  __int64 v3; 
  bdRemoteTask *v5; 
  __int64 v6; 
  __int64 v7; 
  const char *ClientID; 
  bdRemoteTask *v9; 
  __int64 v10; 
  __int64 v11; 
  char v12; 
  bdHTTP *m_httpInterface; 
  unsigned int v14; 
  bdHTTP *v15; 
  bool (__fastcall *setHeader)(bdHTTP *, const char *, const unsigned __int64); 
  unsigned __int64 TransactionID; 
  bdRemoteTask *v19; 
  __int64 v20; 
  unsigned __int64 v22; 
  bdRemoteTask *v23; 
  __int64 v24; 
  double v26; 
  double v27; 
  unsigned __int64 v28; 
  double v29; 
  __int64 v30; 
  bdReference<bdRemoteTask> v31; 
  bdRemoteTask *v32; 
  bdReference<bdRemoteTask> other; 
  bdReference<bdRemoteTask> v34; 
  bdReference<bdRemoteTask> v35; 
  __int64 v36; 
  bdJSONSerializer umbrellaLoginJSON; 

  v36 = -2i64;
  v3 = 0i64;
  if ( !bdLoginTaskUmbrellaCrossplay::readyForRequest(this) )
  {
    bdHandleAssert(1, "(messageInfo != BD_NULL)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus", 0x286u, "Must provide valid message to update Umbrella login task status!");
    this->m_umbrellaStatusCode = CONNECTED;
    bdStrlcpy(this->m_umbrellaStatusMessage, "Another Umbrella login request is already in process", 0x400ui64);
    *(double *)&_XMM0 = bdStopwatch::getElapsedTimeInSeconds(&this->m_taskTimer);
    __asm
    {
      vcvtss2sd xmm1, xmm0, xmm0
      vmovsd  [rsp+1D8h+var_1A0], xmm1
    }
    bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus", 0x28Eu, "Task finished after %2.1f seconds", v26);
    bdLogMessage(BD_LOG_ERROR, (const char *const)&::other, "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::startLoginTask", 0x137u, "Another Umbrella login request is already in process");
    v5 = (bdRemoteTask *)bdMemory::allocate(0x68ui64);
    v31.m_ptr = v5;
    if ( v5 )
    {
      bdRemoteTask::bdRemoteTask(v5);
      v7 = v6;
    }
    else
    {
      v7 = 0i64;
    }
    other.m_ptr = (bdRemoteTask *)v7;
    if ( v7 )
      _InterlockedExchangeAdd((volatile signed __int32 *)(v7 + 8), 1u);
    *(_DWORD *)(v7 + 28) = 3;
    *(_DWORD *)(v7 + 80) = 5;
    bdReference<bdRemoteTask>::operator=(&this->m_remoteTask, &other);
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v7 + 8), 0xFFFFFFFF) == 1 )
      (**(void (__fastcall ***)(__int64, __int64))v7)(v7, 1i64);
  }
  memset_0(this->m_httpRequestBuffer, 0, this->m_requestBufferSize);
  memset_0(this->m_httpResponseBuffer, 0, this->m_responseBufferSize);
  ClientID = bdLoginResult::getClientID(this->m_loginResult);
  bdStrlcpy(this->m_client, ClientID, 0x40ui64);
  bdJSONSerializer::bdJSONSerializer(&umbrellaLoginJSON);
  bdJSONSerializer::setBuffer(&umbrellaLoginJSON, this->m_httpRequestBuffer, this->m_requestBufferSize);
  if ( bdLoginTaskUmbrellaCrossplay::createUmbrellaLoginJson(this, &umbrellaLoginJSON) )
  {
    v9 = (bdRemoteTask *)bdMemory::allocate(0x68ui64);
    v32 = v9;
    if ( v9 )
    {
      bdRemoteTask::bdRemoteTask(v9);
      v11 = v10;
    }
    else
    {
      v11 = 0i64;
    }
    v34.m_ptr = (bdRemoteTask *)v11;
    if ( v11 )
      _InterlockedExchangeAdd((volatile signed __int32 *)(v11 + 8), 1u);
    *(_DWORD *)(v11 + 28) = 1;
    *(_QWORD *)(v11 + 72) = bdLoginResult::getTransactionID(this->m_loginResult);
    bdReference<bdRemoteTask>::operator=(&this->m_remoteTask, &v34);
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v11 + 8), 0xFFFFFFFF) == 1 )
      (**(void (__fastcall ***)(__int64, __int64))v11)(v11, 1i64);
    this->m_outputObject = &this->m_loginResult->m_crossplayAccount;
    v12 = ((__int64 (__fastcall *)(bdHTTP *, __int64, char *))this->m_httpInterface->initRequest)(this->m_httpInterface, 3i64, this->m_url);
    m_httpInterface = this->m_httpInterface;
    v14 = bdJSONSerializer::length(&umbrellaLoginJSON);
    bdHTTP::setUploadData(m_httpInterface, this->m_httpRequestBuffer, v14);
    bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::startLoginTask", 0x150u, "HTTP Request Params: %s", this->m_httpRequestBuffer);
    bdHTTP::setDownloadBuffer(this->m_httpInterface, this->m_httpResponseBuffer, this->m_responseBufferSize);
    if ( !v12 || (v15 = this->m_httpInterface, setHeader = v15->setHeader, TransactionID = bdLoginResult::getTransactionID(this->m_loginResult), !setHeader(v15, "X-TransactionID", TransactionID)) || !this->m_httpInterface->setHeader(this->m_httpInterface, "Content-Type", "application/json") || !this->m_httpInterface->setHeader(this->m_httpInterface, "Accept", "application/json") )
    {
      bdHandleAssert(1, "(messageInfo != BD_NULL)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus", 0x286u, "Must provide valid message to update Umbrella login task status!");
      this->m_umbrellaStatusCode = CONNECTED;
      bdStrlcpy(this->m_umbrellaStatusMessage, "Encountered error while attempting to start request for Umbrella Crossplay Login", 0x400ui64);
      *(double *)&_XMM0 = bdStopwatch::getElapsedTimeInSeconds(&this->m_taskTimer);
      __asm
      {
        vcvtss2sd xmm1, xmm0, xmm0
        vmovsd  [rsp+1D8h+var_1A0], xmm1
      }
      bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus", 0x28Eu, "Task finished after %2.1f seconds", v27);
      bdLogMessage(BD_LOG_ERROR, (const char *const)&::other, "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::startLoginTask", 0x15Cu, "Encountered error while attempting to start request for Umbrella Crossplay Login");
      v19 = (bdRemoteTask *)bdMemory::allocate(0x68ui64);
      v32 = v19;
      if ( v19 )
      {
        bdRemoteTask::bdRemoteTask(v19);
        v3 = v20;
      }
      v35.m_ptr = (bdRemoteTask *)v3;
      if ( v3 )
        _InterlockedExchangeAdd((volatile signed __int32 *)(v3 + 8), 1u);
      *(_DWORD *)(v3 + 28) = 3;
      *(_DWORD *)(v3 + 80) = 5;
      bdReference<bdRemoteTask>::operator=(&this->m_remoteTask, &v35);
      if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v3 + 8), 0xFFFFFFFF) == 1 )
        (**(void (__fastcall ***)(__int64, __int64))v3)(v3, 1i64);
    }
    this->m_httpInterface->sendRequest(this->m_httpInterface);
    if ( this->m_remoteTask.m_ptr->getStatus(this->m_remoteTask.m_ptr) == BD_PENDING )
    {
      bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::startLoginTask", 0x164u, "Setting state to PENDING");
      bdHandleAssert(1, "(messageInfo != BD_NULL)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus", 0x286u, "Must provide valid message to update Umbrella login task status!");
      this->m_umbrellaStatusCode = CONNECTING;
      bdStrlcpy(this->m_umbrellaStatusMessage, "Sent crossplay login request to Umbrella", 0x400ui64);
      v28 = bdRemoteTask::getTransactionID(this->m_remoteTask.m_ptr);
      bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::startLoginTask", 0x168u, "Started call to Umbrella crossplay. TransactionID: (%I64u)", v28);
    }
    else
    {
      bdHandleAssert(1, "(messageInfo != BD_NULL)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus", 0x286u, "Must provide valid message to update Umbrella login task status!");
      this->m_umbrellaStatusCode = CONNECTED;
      bdStrlcpy(this->m_umbrellaStatusMessage, "Got into unexpected state starting the Umbrella Crossplay Login request", 0x400ui64);
      *(double *)&_XMM0 = bdStopwatch::getElapsedTimeInSeconds(&this->m_taskTimer);
      __asm
      {
        vcvtss2sd xmm1, xmm0, xmm0
        vmovsd  [rsp+1D8h+var_1A0], xmm1
      }
      bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus", 0x28Eu, "Task finished after %2.1f seconds", v29);
      v22 = bdRemoteTask::getTransactionID(this->m_remoteTask.m_ptr);
      bdLogMessage(BD_LOG_ERROR, (const char *const)&::other, "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::startLoginTask", 0x16Fu, "Got into unexpected state starting the Umbrella Crossplay Login request. TransactionID: (%I64u)", v22);
    }
  }
  else
  {
    bdLogMessage(BD_LOG_ERROR, (const char *const)&::other, "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::startLoginTask", 0x174u, "Failed to serialize JSON for Umbrella Crossplay Login request");
    v23 = (bdRemoteTask *)bdMemory::allocate(0x68ui64);
    v32 = v23;
    if ( v23 )
    {
      bdRemoteTask::bdRemoteTask(v23);
      v3 = v24;
    }
    v31.m_ptr = (bdRemoteTask *)v3;
    if ( v3 )
      _InterlockedExchangeAdd((volatile signed __int32 *)(v3 + 8), 1u);
    *(_DWORD *)(v3 + 28) = 3;
    *(_DWORD *)(v3 + 80) = 5;
    bdReference<bdRemoteTask>::operator=(&this->m_remoteTask, &v31);
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v3 + 8), 0xFFFFFFFF) == 1 )
      (**(void (__fastcall ***)(__int64, __int64))v3)(v3, 1i64);
    bdHandleAssert(1, "(messageInfo != BD_NULL)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus", 0x286u, "Must provide valid message to update Umbrella login task status!");
    this->m_umbrellaStatusCode = CONNECTED;
    bdStrlcpy(this->m_umbrellaStatusMessage, "Failed to serialize JSON for Umbrella Crossplay Login request", 0x400ui64);
    *(double *)&_XMM0 = bdStopwatch::getElapsedTimeInSeconds(&this->m_taskTimer);
    __asm
    {
      vcvtss2sd xmm1, xmm0, xmm0
      vmovsd  [rsp+1D8h+var_1A0], xmm1
    }
    bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus", 0x28Eu, "Task finished after %2.1f seconds", v30);
  }
  bdJSONSerializer::~bdJSONSerializer(&umbrellaLoginJSON);
}

/*
==============
bdLoginTaskUmbrellaCrossplay::startRefreshTask
==============
*/
void bdLoginTaskUmbrellaCrossplay::startRefreshTask(bdLoginTaskUmbrellaCrossplay *this)
{
  bdRemoteTask *v4; 
  __int64 v5; 
  __int64 v6; 
  const char *ClientID; 
  double v9; 
  double v10; 
  bdReference<bdRemoteTask> other; 
  __int64 v12; 
  bdJSONSerializer requestJSON; 

  v12 = -2i64;
  if ( !bdLoginTaskUmbrellaCrossplay::readyForRequest(this) )
  {
    bdHandleAssert(1, "(messageInfo != BD_NULL)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus", 0x286u, "Must provide valid message to update Umbrella login task status!");
    this->m_umbrellaStatusCode = CONNECTED;
    bdStrlcpy(this->m_umbrellaStatusMessage, "Another Umbrella request is already in process", 0x400ui64);
    *(double *)&_XMM0 = bdStopwatch::getElapsedTimeInSeconds(&this->m_taskTimer);
    __asm
    {
      vcvtss2sd xmm1, xmm0, xmm0
      vmovsd  [rsp+198h+var_160], xmm1
    }
    bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus", 0x28Eu, "Task finished after %2.1f seconds", v9);
    bdLogMessage(BD_LOG_ERROR, (const char *const)&::other, "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::startRefreshTask", 0x1ABu, "Another Umbrella request is already in process");
    v4 = (bdRemoteTask *)bdMemory::allocate(0x68ui64);
    other.m_ptr = v4;
    if ( v4 )
    {
      bdRemoteTask::bdRemoteTask(v4);
      v6 = v5;
    }
    else
    {
      v6 = 0i64;
    }
    other.m_ptr = (bdRemoteTask *)v6;
    if ( v6 )
      _InterlockedExchangeAdd((volatile signed __int32 *)(v6 + 8), 1u);
    *(_DWORD *)(v6 + 28) = 3;
    *(_DWORD *)(v6 + 80) = 5;
    bdReference<bdRemoteTask>::operator=(&this->m_remoteTask, &other);
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v6 + 8), 0xFFFFFFFF) == 1 )
      (**(void (__fastcall ***)(__int64, __int64))v6)(v6, 1i64);
  }
  memset_0(this->m_httpRequestBuffer, 0, this->m_requestBufferSize);
  memset_0(this->m_httpResponseBuffer, 0, this->m_responseBufferSize);
  ClientID = bdLoginResult::getClientID(this->m_loginResult);
  bdStrlcpy(this->m_client, ClientID, 0x40ui64);
  bdJSONSerializer::bdJSONSerializer(&requestJSON);
  bdJSONSerializer::setBuffer(&requestJSON, this->m_httpRequestBuffer, this->m_requestBufferSize);
  if ( !bdJSONSerializer::writeBeginObject(&requestJSON) || !bdJSONSerializer::writeString(&requestJSON, "refreshToken", this->m_loginResult->m_crossplayAccount.m_crossplayInfo.m_refreshToken) || !bdJSONSerializer::writeEndObject(&requestJSON) )
  {
    bdLogMessage(BD_LOG_ERROR, (const char *const)&::other, "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::startRefreshTask", 0x1BBu, "Failed to build JSON for Umbrella refresh token task");
    bdHandleAssert(1, "(messageInfo != BD_NULL)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus", 0x286u, "Must provide valid message to update Umbrella login task status!");
    this->m_umbrellaStatusCode = CONNECTED;
    bdStrlcpy(this->m_umbrellaStatusMessage, "Failed to build JSON for Umbrella refresh token task", 0x400ui64);
    *(double *)&_XMM0 = bdStopwatch::getElapsedTimeInSeconds(&this->m_taskTimer);
    __asm
    {
      vcvtss2sd xmm1, xmm0, xmm0
      vmovsd  [rsp+198h+var_160], xmm1
    }
    bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus", 0x28Eu, "Task finished after %2.1f seconds", v10);
  }
  this->m_outputObject = &this->m_loginResult->m_crossplayAccount.m_crossplayInfo.m_accessInfo;
  bdLoginTaskUmbrellaCrossplay::sendUmbrellaRequest(this, &requestJSON);
  bdJSONSerializer::~bdJSONSerializer(&requestJSON);
}

/*
==============
bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus
==============
*/
void bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus(bdLoginTaskUmbrellaCrossplay *this, const char *messageInfo, const bdLoginTaskUmbrellaCrossplay::UmbrellaLoginStatusCode *code)
{
  double v8; 

  bdHandleAssert(messageInfo != NULL, "(messageInfo != BD_NULL)", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus", 0x286u, "Must provide valid message to update Umbrella login task status!");
  this->m_umbrellaStatusCode = *code;
  bdStrlcpy(this->m_umbrellaStatusMessage, messageInfo, 0x400ui64);
  if ( (unsigned int)(*code - 4) <= 2 )
  {
    *(double *)&_XMM0 = bdStopwatch::getElapsedTimeInSeconds(&this->m_taskTimer);
    __asm
    {
      vcvtss2sd xmm1, xmm0, xmm0
      vmovsd  [rsp+48h+var_10], xmm1
    }
    bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::updateUmbrellaCrossplayStatus", 0x28Eu, "Task finished after %2.1f seconds", v8);
  }
}

/*
==============
bdLoginTaskUmbrellaCrossplay::validateAccessToken
==============
*/
char bdLoginTaskUmbrellaCrossplay::validateAccessToken(bdLoginTaskUmbrellaCrossplay *this)
{
  bdStopwatch v5; 

  if ( bdLoginResult::isCrossPlayEnabled(this->m_loginResult) )
  {
    v5.m_start = this->m_loginResult->m_crossplayAccount.m_crossplayInfo.m_tokenAgeTimer.m_start;
    *(double *)&_XMM0 = bdStopwatch::getElapsedTimeInSeconds(&v5);
    __asm { vcvttss2si rax, xmm0 }
    if ( this->m_loginResult->m_crossplayAccount.m_crossplayInfo.m_accessTokenValidilitySeconds > (unsigned int)(_RAX + 60) )
    {
      return 1;
    }
    else
    {
      bdLogMessage(BD_LOG_INFO, "info/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::validateAccessToken", 0x2D8u, "Crossplay token needs to be refreshed");
      this->reset(this);
      return 0;
    }
  }
  else
  {
    bdLogMessage(BD_LOG_WARNING, "warn/", "bdLogin", "c:\\workspace\\iw8\\code_source\\libs\\demonwareclient\\bdlobby\\bdlogin\\bdlogintask\\bdlogintaskumbrellacrossplay.cpp", "bdLoginTaskUmbrellaCrossplay::validateAccessToken", 0x2E5u, "Trying to validate crossplay token for refreshing on non crossplay title");
    return 0;
  }
}

