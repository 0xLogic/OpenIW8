/*
==============
CG_ViewMotion_InitCinematicMotionAssets
==============
*/

void CG_ViewMotion_InitCinematicMotionAssets(void)
{
  ?CG_ViewMotion_InitCinematicMotionAssets@@YAXXZ();
}

/*
==============
AdvancedSwayDeadzone::DebugDrawText
==============
*/

void __fastcall AdvancedSwayDeadzone::DebugDrawText(AdvancedSwayDeadzone *this, const LocalClientNum_t localClientNum, DebugDrawState *debugDraw)
{
  ?DebugDrawText@AdvancedSwayDeadzone@@QEBAXW4LocalClientNum_t@@PEAUDebugDrawState@@@Z(this, localClientNum, debugDraw);
}

/*
==============
DebugDrawDisplacementLine
==============
*/

void __fastcall DebugDrawDisplacementLine(const cg_t *const cgameGlob, const vec3_t *angles, const vec3_t *drawAxis, const vec4_t *color)
{
  ?DebugDrawDisplacementLine@@YAXQEBVcg_t@@AEBTvec3_t@@1AEBTvec4_t@@@Z(cgameGlob, angles, drawAxis, color);
}

/*
==============
CG_ViewMotion_MyChanges
==============
*/

void CG_ViewMotion_MyChanges(void)
{
  ?CG_ViewMotion_MyChanges@@YAXXZ();
}

/*
==============
AdvancedSwayState::AdvancedSwayState
==============
*/

void __fastcall AdvancedSwayState::AdvancedSwayState(AdvancedSwayState *this)
{
  ??0AdvancedSwayState@@QEAA@XZ(this);
}

/*
==============
CG_ViewMotion_ClearCinematicMotionAssets
==============
*/

void CG_ViewMotion_ClearCinematicMotionAssets(void)
{
  ?CG_ViewMotion_ClearCinematicMotionAssets@@YAXXZ();
}

/*
==============
AdvancedSwaySprings::Reset
==============
*/

void __fastcall AdvancedSwaySprings::Reset(AdvancedSwaySprings *this)
{
  ?Reset@AdvancedSwaySprings@@QEAAXXZ(this);
}

/*
==============
AdvancedSwaySprings::GetAnglesOffset
==============
*/

void __fastcall AdvancedSwaySprings::GetAnglesOffset(AdvancedSwaySprings *this, vec3_t *outAnglesOffset)
{
  ?GetAnglesOffset@AdvancedSwaySprings@@QEBAXAEATvec3_t@@@Z(this, outAnglesOffset);
}

/*
==============
ViewMotionSpring::ViewMotionSpring
==============
*/

void __fastcall ViewMotionSpring::ViewMotionSpring(ViewMotionSpring *this)
{
  ??0ViewMotionSpring@@QEAA@XZ(this);
}

/*
==============
CG_ViewMotion_LocalOffsetToLocalAngles
==============
*/

void __fastcall CG_ViewMotion_LocalOffsetToLocalAngles(const playerState_s *ps, const ViewMotionSpring *spring, const vec3_t *localOffset, vec3_t *outLocalAngles)
{
  ?CG_ViewMotion_LocalOffsetToLocalAngles@@YAXPEBUplayerState_s@@AEBUViewMotionSpring@@AEBTvec3_t@@AEAT3@@Z(ps, spring, localOffset, outLocalAngles);
}

/*
==============
CG_ViewMotion_GetSpringOffset
==============
*/

void __fastcall CG_ViewMotion_GetSpringOffset(const playerState_s *ps, const float adsFraction, const ViewMotionSpring *spring, const vec3_t *viewAngles, vec3_t *outLocalOffset, vec3_t *outWorldOffset)
{
  ?CG_ViewMotion_GetSpringOffset@@YAXPEBUplayerState_s@@MAEBUViewMotionSpring@@AEBTvec3_t@@PEAT3@3@Z(ps, adsFraction, spring, viewAngles, outLocalOffset, outWorldOffset);
}

/*
==============
AdvancedSwaySprings::AdvancedSwaySprings
==============
*/

void __fastcall AdvancedSwaySprings::AdvancedSwaySprings(AdvancedSwaySprings *this)
{
  ??0AdvancedSwaySprings@@QEAA@XZ(this);
}

/*
==============
AdvancedSwayGunDir::Reset
==============
*/

void __fastcall AdvancedSwayGunDir::Reset(AdvancedSwayGunDir *this)
{
  ?Reset@AdvancedSwayGunDir@@QEAAXXZ(this);
}

/*
==============
AngularSmoothing::AngularSmoothing
==============
*/

void __fastcall AngularSmoothing::AngularSmoothing(AngularSmoothing *this)
{
  ??0AngularSmoothing@@QEAA@XZ(this);
}

/*
==============
AdvancedSwaySprings::Update
==============
*/

void __fastcall AdvancedSwaySprings::Update(AdvancedSwaySprings *this, const bool enabled, const vec2_t *massConst, const vec2_t *springConst, const vec2_t *damperConst, const vec3_t *goalAnglesOffset, float frametimeSecScaled)
{
  ?Update@AdvancedSwaySprings@@QEAAX_NAEBTvec2_t@@11AEBTvec3_t@@M@Z(this, enabled, massConst, springConst, damperConst, goalAnglesOffset, frametimeSecScaled);
}

/*
==============
AdvancedSwayGunDir::AdvancedSwayGunDir
==============
*/

void __fastcall AdvancedSwayGunDir::AdvancedSwayGunDir(AdvancedSwayGunDir *this)
{
  ??0AdvancedSwayGunDir@@QEAA@XZ(this);
}

/*
==============
AdvancedSwayState::GetBlendspaceParams
==============
*/

void __fastcall AdvancedSwayState::GetBlendspaceParams(AdvancedSwayState *this, vec2_t *outBsParams)
{
  ?GetBlendspaceParams@AdvancedSwayState@@QEBAXAEATvec2_t@@@Z(this, outBsParams);
}

/*
==============
AdvancedSwayState::DebugDraw
==============
*/

void __fastcall AdvancedSwayState::DebugDraw(AdvancedSwayState *this, const LocalClientNum_t localClientNum)
{
  ?DebugDraw@AdvancedSwayState@@QEBAXW4LocalClientNum_t@@@Z(this, localClientNum);
}

/*
==============
CG_ViewMotion_DebugDrawGraph
==============
*/

void __fastcall CG_ViewMotion_DebugDrawGraph(const ScreenPlacement *const scrPlace, float drawX, float drawY, const RumbleGraph *const nonLinearGraph, const vec4_t *colorGraph, float normValueX_0, const vec4_t *color0, float normValueX_1, const vec4_t *color1)
{
  ?CG_ViewMotion_DebugDrawGraph@@YAXQEBUScreenPlacement@@MMQEBURumbleGraph@@AEBTvec4_t@@M2M2@Z(scrPlace, drawX, drawY, nonLinearGraph, colorGraph, normValueX_0, color0, normValueX_1, color1);
}

/*
==============
AdvancedSwayDeadzone::Reset
==============
*/

void __fastcall AdvancedSwayDeadzone::Reset(AdvancedSwayDeadzone *this)
{
  ?Reset@AdvancedSwayDeadzone@@QEAAXXZ(this);
}

/*
==============
AdvancedSwayDeadzone::GetAnglesOffset
==============
*/

void __fastcall AdvancedSwayDeadzone::GetAnglesOffset(AdvancedSwayDeadzone *this, vec3_t *outGoalAnglesOffset)
{
  ?GetAnglesOffset@AdvancedSwayDeadzone@@QEBAXAEATvec3_t@@@Z(this, outGoalAnglesOffset);
}

/*
==============
CG_ViewMotion_Update
==============
*/

void __fastcall CG_ViewMotion_Update(const LocalClientNum_t localClientNum)
{
  ?CG_ViewMotion_Update@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_ViewMotion_Impact
==============
*/

void __fastcall CG_ViewMotion_Impact(const LocalClientNum_t localClientNum, const int time)
{
  ?CG_ViewMotion_Impact@@YAXW4LocalClientNum_t@@H@Z(localClientNum, time);
}

/*
==============
AdvancedSwayDeadzone::AdvancedSwayDeadzone
==============
*/

void __fastcall AdvancedSwayDeadzone::AdvancedSwayDeadzone(AdvancedSwayDeadzone *this)
{
  ??0AdvancedSwayDeadzone@@QEAA@XZ(this);
}

/*
==============
AdvancedSwayState::DebugDrawText
==============
*/

void __fastcall AdvancedSwayState::DebugDrawText(AdvancedSwayState *this, const LocalClientNum_t localClientNum)
{
  ?DebugDrawText@AdvancedSwayState@@QEBAXW4LocalClientNum_t@@@Z(this, localClientNum);
}

/*
==============
AdvancedSwayDeadzone::DebugDraw
==============
*/

void __fastcall AdvancedSwayDeadzone::DebugDraw(AdvancedSwayDeadzone *this, const LocalClientNum_t localClientNum, const vec4_t *color)
{
  ?DebugDraw@AdvancedSwayDeadzone@@QEBAXW4LocalClientNum_t@@AEBTvec4_t@@@Z(this, localClientNum, color);
}

/*
==============
CG_ViewMotion_GetCinematicMotionIndexForPtr
==============
*/

unsigned int __fastcall CG_ViewMotion_GetCinematicMotionIndexForPtr(const CinematicMotionDef *const def)
{
  return ?CG_ViewMotion_GetCinematicMotionIndexForPtr@@YAIQEBUCinematicMotionDef@@@Z(def);
}

/*
==============
AdvancedSwayGunDir::GetAnglesOffset
==============
*/

void __fastcall AdvancedSwayGunDir::GetAnglesOffset(AdvancedSwayGunDir *this, vec3_t *outAnglesOffset)
{
  ?GetAnglesOffset@AdvancedSwayGunDir@@QEBAXAEATvec3_t@@@Z(this, outAnglesOffset);
}

/*
==============
ViewMotionSpring::Reset
==============
*/

void __fastcall ViewMotionSpring::Reset(ViewMotionSpring *this, const float4 *playerOrigin)
{
  ?Reset@ViewMotionSpring@@QEAAXAEBUfloat4@@@Z(this, playerOrigin);
}

/*
==============
AdvancedSwayState::GetAngleOffsets
==============
*/

void __fastcall AdvancedSwayState::GetAngleOffsets(AdvancedSwayState *this, vec3_t *outTorsoAngleOffsets, vec3_t *outGunAngleOffsets, vec3_t *outGunPivotOffset)
{
  ?GetAngleOffsets@AdvancedSwayState@@QEBAXAEATvec3_t@@00@Z(this, outTorsoAngleOffsets, outGunAngleOffsets, outGunPivotOffset);
}

/*
==============
AdvancedSwayGunDir::DebugDrawText
==============
*/

void __fastcall AdvancedSwayGunDir::DebugDrawText(AdvancedSwayGunDir *this, const LocalClientNum_t localClientNum, float yawToRollScale, DebugDrawState *debugDraw)
{
  ?DebugDrawText@AdvancedSwayGunDir@@QEBAXW4LocalClientNum_t@@MPEAUDebugDrawState@@@Z(this, localClientNum, yawToRollScale, debugDraw);
}

/*
==============
CG_ViewMotion_GetCinematicMotionDef
==============
*/

const CinematicMotionDef *__fastcall CG_ViewMotion_GetCinematicMotionDef(unsigned int index)
{
  return ?CG_ViewMotion_GetCinematicMotionDef@@YAPEBUCinematicMotionDef@@I@Z(index);
}

/*
==============
AdvancedSwaySprings::GetAnglesVelocity
==============
*/

void __fastcall AdvancedSwaySprings::GetAnglesVelocity(AdvancedSwaySprings *this, vec3_t *outAnglesVelocity)
{
  ?GetAnglesVelocity@AdvancedSwaySprings@@QEBAXAEATvec3_t@@@Z(this, outAnglesVelocity);
}

/*
==============
AdvancedSwayDeadzone::Update
==============
*/

void __fastcall AdvancedSwayDeadzone::Update(AdvancedSwayDeadzone *this, const AdvancedHipSwaySettings *const swayDef, const vec3_t *viewAngles, float frametimeSecScaled, const vec3_t *viewAngleVelocityScaled, float adsFraction, float fireFraction)
{
  ?Update@AdvancedSwayDeadzone@@QEAAXQEBUAdvancedHipSwaySettings@@AEBTvec3_t@@M1MM@Z(this, swayDef, viewAngles, frametimeSecScaled, viewAngleVelocityScaled, adsFraction, fireFraction);
}

/*
==============
AdvancedSwayState::Update
==============
*/

void __fastcall AdvancedSwayState::Update(AdvancedSwayState *this, const cg_t *const cgameGlob, const vec3_t *viewmodelAngles)
{
  ?Update@AdvancedSwayState@@QEAAXQEBVcg_t@@AEBTvec3_t@@@Z(this, cgameGlob, viewmodelAngles);
}

/*
==============
AngularSmoothing::Update
==============
*/

void __fastcall AngularSmoothing::Update(AngularSmoothing *this, const cg_t *const cgameGlob, const float adsFrac, const float frametime, const float speed, vec3_t *inOutAngles)
{
  ?Update@AngularSmoothing@@QEAAXQEBVcg_t@@MMMAEATvec3_t@@@Z(this, cgameGlob, adsFrac, frametime, speed, inOutAngles);
}

/*
==============
AngularSmoothing::Reset
==============
*/

void __fastcall AngularSmoothing::Reset(AngularSmoothing *this)
{
  ?Reset@AngularSmoothing@@QEAAXXZ(this);
}

/*
==============
AdvancedSwayGunDir::Update
==============
*/

void __fastcall AdvancedSwayGunDir::Update(AdvancedSwayGunDir *this, const AdvancedHipSwaySettings *const swayDef, const vec3_t *offsetAngles, const vec3_t *offsetVelocity, float frametimeSecScaled, const vec3_t *angleVelocityWorldScaled, float fireFraction)
{
  ?Update@AdvancedSwayGunDir@@QEAAXQEBUAdvancedHipSwaySettings@@AEBTvec3_t@@1M1M@Z(this, swayDef, offsetAngles, offsetVelocity, frametimeSecScaled, angleVelocityWorldScaled, fireFraction);
}

/*
==============
AdvancedSwayDeadzone::AdvancedSwayDeadzone
==============
*/
void AdvancedSwayDeadzone::AdvancedSwayDeadzone(AdvancedSwayDeadzone *this)
{
  this->m_isInitialized = 0;
}

/*
==============
AdvancedSwayGunDir::AdvancedSwayGunDir
==============
*/
void AdvancedSwayGunDir::AdvancedSwayGunDir(AdvancedSwayGunDir *this)
{
  this->m_isInitialized = 0;
}

/*
==============
AdvancedSwaySprings::AdvancedSwaySprings
==============
*/
void AdvancedSwaySprings::AdvancedSwaySprings(AdvancedSwaySprings *this)
{
  this->m_isInitialized = 0;
}

/*
==============
AdvancedSwayState::AdvancedSwayState
==============
*/
void AdvancedSwayState::AdvancedSwayState(AdvancedSwayState *this)
{
  this->m_smoothing.m_initialized = 0;
  this->m_torsoGoal.m_isInitialized = 0;
  this->m_torsoSprings.m_isInitialized = 0;
  this->m_gunGoal.m_isInitialized = 0;
  this->m_gunSprings.m_isInitialized = 0;
  this->m_isInitialized = 0;
}

/*
==============
AngularSmoothing::AngularSmoothing
==============
*/
void AngularSmoothing::AngularSmoothing(AngularSmoothing *this)
{
  this->m_initialized = 0;
}

/*
==============
ViewMotionSpring::ViewMotionSpring
==============
*/
void ViewMotionSpring::ViewMotionSpring(ViewMotionSpring *this)
{
  *(_QWORD *)&this->motionIndex = 31i64;
  *(_QWORD *)&this->motionIndexBlendDuration = 0i64;
  this->isLockingSpring = 0;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmovups ymmword ptr [rcx], ymm0
    vmovups ymmword ptr [rcx+20h], ymm0
    vmovups ymmword ptr [rcx+40h], ymm0
    vmovups ymmword ptr [rcx+60h], ymm0
    vmovups ymmword ptr [rcx+80h], ymm0
    vmovups xmm0, xmmword ptr cs:?g_1000@@3Ufloat4@@B.v; float4 const g_1000
    vmovups xmmword ptr [rcx+0A0h], xmm0
    vmovups xmm1, xmmword ptr cs:?g_0100@@3Ufloat4@@B.v; float4 const g_0100
    vmovups xmmword ptr [rcx+0B0h], xmm1
    vmovups xmm0, xmmword ptr cs:?g_0010@@3Ufloat4@@B.v; float4 const g_0010
    vmovups xmmword ptr [rcx+0C0h], xmm0
    vmovups xmm1, xmmword ptr cs:?g_0001@@3Ufloat4@@B.v; float4 const g_0001
    vmovups xmmword ptr [rcx+0D0h], xmm1
  }
  this->isInitialized = 0;
}

/*
==============
CG_ViewMotion_AssertFloat3Normalized
==============
*/
void CG_ViewMotion_AssertFloat3Normalized(const float4 *vec)
{
  __int64 v13; 
  double v14; 
  double v15; 

  __asm
  {
    vmovaps [rsp+78h+var_18], xmm6
    vmovups xmm0, xmmword ptr [rcx]
    vmulps  xmm1, xmm0, xmm0
    vinsertps xmm2, xmm1, xmm1, 8
    vhaddps xmm0, xmm2, xmm2
    vhaddps xmm0, xmm0, xmm0
    vsqrtps xmm6, xmm0
    vcomiss xmm6, cs:__real@3f7fbe77
  }
  if ( (unsigned __int64)&v13 == _security_cookie )
  {
    __asm
    {
      vmovsd  xmm1, cs:__real@3feff7cee0000000
      vcvtss2sd xmm0, xmm6, xmm6
      vmovsd  [rsp+78h+var_38], xmm0
      vmovsd  [rsp+78h+var_40], xmm1
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 1472, ASSERT_TYPE_ASSERT, "( (1.0f - 0.001f) ) < ( Float4ExtractX( len ) )", "%s < %s\n\t%g, %g", "(1.0f - EQUAL_EPSILON)", "Float4ExtractX( len )", v14, v15) )
      __debugbreak();
  }
  __asm
  {
    vcomiss xmm6, cs:__real@3f8020c5
    vmovsd  xmm0, cs:__real@3ff00418a0000000
    vmovsd  [rsp+78h+var_38], xmm0
    vcvtss2sd xmm1, xmm6, xmm6
    vmovsd  [rsp+78h+var_40], xmm1
  }
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 1473, ASSERT_TYPE_ASSERT, "( Float4ExtractX( len ) ) < ( (1.0f + 0.001f) )", "%s < %s\n\t%g, %g", "Float4ExtractX( len )", "(1.0f + EQUAL_EPSILON)", v14, v15) )
    __debugbreak();
  __asm { vmovaps xmm6, [rsp+78h+var_18] }
}

/*
==============
CG_ViewMotion_CheckSpringTeleport
==============
*/
void CG_ViewMotion_CheckSpringTeleport(const cg_t *const cgameGlob, const float4 *curPsOrigin, ViewMotionSpring *spring)
{
  char v7; 

  _RSI = curPsOrigin;
  _RDI = spring;
  v7 = cgameGlob->playerTeleported || !spring->isInitialized;
  if ( !BG_IsInAir(&cgameGlob->predictedPlayerState, 0) )
  {
    __asm
    {
      vmovups xmm0, xmmword ptr [rsi]
      vsubps  xmm1, xmm0, xmmword ptr [rdi+40h]
      vmulps  xmm2, xmm1, xmm1
      vhaddps xmm0, xmm2, xmm2
      vhaddps xmm1, xmm0, xmm0
      vcomiss xmm1, cs:teleportThresholdDistSq
    }
    v7 |= 1u;
  }
  if ( v7 )
  {
    __asm
    {
      vxorps  xmm1, xmm1, xmm1
      vmovups ymmword ptr [rdi], ymm1
      vmovups ymmword ptr [rdi+20h], ymm1
    }
    _RDI->unlockTime = 0;
    __asm
    {
      vmovups xmm0, xmmword ptr [rsi]
      vmovdqu xmmword ptr [rdi+40h], xmm0
      vmovups ymmword ptr [rdi+50h], ymm1
      vmovups ymmword ptr [rdi+70h], ymm1
      vmovups xmmword ptr [rdi+90h], xmm1
    }
    _RDI->isLockingSpring = 0;
    *(_QWORD *)&_RDI->motionIndex = 31i64;
    _RDI->motionIndexBlendDuration = 0;
    __asm
    {
      vmovups xmm0, xmmword ptr cs:?g_1000@@3Ufloat4@@B.v; float4 const g_1000
      vmovups xmmword ptr [rdi+0A0h], xmm0
      vmovups xmm1, xmmword ptr cs:?g_0100@@3Ufloat4@@B.v; float4 const g_0100
      vmovups xmmword ptr [rdi+0B0h], xmm1
      vmovups xmm0, xmmword ptr cs:?g_0010@@3Ufloat4@@B.v; float4 const g_0010
      vmovups xmmword ptr [rdi+0C0h], xmm0
      vmovups xmm1, xmmword ptr cs:?g_0001@@3Ufloat4@@B.v; float4 const g_0001
      vmovups xmmword ptr [rdi+0D0h], xmm1
    }
    _RDI->isInitialized = 1;
  }
}

/*
==============
CG_ViewMotion_ClearCinematicMotionAssets
==============
*/
void CG_ViewMotion_ClearCinematicMotionAssets(void)
{
  s_cgCinematicMotionDefsInitialized = 0;
  memset_0(s_cgCinematicMotionDefs, 0, sizeof(s_cgCinematicMotionDefs));
}

/*
==============
CG_ViewMotion_DebugDrawGraph
==============
*/

void __fastcall CG_ViewMotion_DebugDrawGraph(const ScreenPlacement *const scrPlace, double drawX, double drawY, const RumbleGraph *const nonLinearGraph, const vec4_t *colorGraph, float normValueX_0, const vec4_t *color0, float normValueX_1, const vec4_t *color1)
{
  char v37; 
  char v38; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float fmtc; 
  float color; 
  float colora; 
  float colorb; 
  float max; 
  float maxa; 
  float maxb; 
  __int64 numDataEntries; 
  float data[32]; 
  char v68; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-58h], xmm6
    vmovaps xmmword ptr [rax-68h], xmm7
    vmovaps xmmword ptr [rax-78h], xmm8
    vmovaps xmmword ptr [rax-88h], xmm9
    vmovaps xmmword ptr [rax-98h], xmm10
    vmovaps xmm8, xmm2
    vmovaps xmm9, xmm1
  }
  if ( !nonLinearGraph && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 707, ASSERT_TYPE_ASSERT, "( nonLinearGraph ) != ( nullptr )", "%s != %s\n\t%p, %p", "nonLinearGraph", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( !nonLinearGraph->knotCount )
  {
    LODWORD(numDataEntries) = 0;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 708, ASSERT_TYPE_ASSERT, "( 0 ) < ( nonLinearGraph->knotCount )", "%s < %s\n\t%i, %i", "0", "nonLinearGraph->knotCount", 0i64, numDataEntries) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm6, cs:__real@5f800000
    vmovss  xmm7, cs:__real@3d042108
  }
  for ( _RBX = 0i64; _RBX < 0x20; ++_RBX )
  {
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, rbx
      vmulss  xmm2, xmm0, xmm7; fraction
    }
    *(double *)&_XMM0 = GraphGetValueFromFraction(nonLinearGraph->knotCount, nonLinearGraph->knots, *(const float *)&_XMM2);
    __asm { vmovss  [rsp+rbx*4+188h+var_128], xmm0 }
  }
  __asm
  {
    vmovss  xmm0, cs:VMMOTION_DEBUG_GRAPH_HEIGHT
    vaddss  xmm8, xmm8, cs:__real@43700000
    vaddss  xmm9, xmm9, cs:__real@43a00000
    vaddss  xmm2, xmm8, cs:graphAdjustY_1; y
    vaddss  xmm1, xmm9, cs:graphAdjustX_1; x
    vmovss  xmm3, cs:VMMOTION_DEBUG_GRAPH_WIDTH; width
    vmovss  dword ptr [rsp+188h+fmt], xmm0
  }
  CG_DebugGraphs_DrawAxes(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, fmt, &colorWhite);
  __asm
  {
    vmovss  xmm0, cs:VMMOTION_DEBUG_GRAPH_HEIGHT
    vmovss  xmm7, cs:__real@3f800000
    vaddss  xmm2, xmm8, cs:graphAdjustY_1; y
    vaddss  xmm1, xmm9, cs:graphAdjustX_1; x
    vmovss  xmm3, cs:VMMOTION_DEBUG_GRAPH_WIDTH; width
    vmovss  [rsp+188h+max], xmm7
    vxorps  xmm10, xmm10, xmm10
    vmovss  dword ptr [rsp+188h+color], xmm10
    vmovss  dword ptr [rsp+188h+fmt], xmm0
  }
  CG_DebugGraphs_DrawGraphData(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, fmta, color, max, data, 0x20u, 0, colorGraph);
  __asm
  {
    vmovss  xmm6, [rsp+188h+normValueX_0]
    vcomiss xmm6, xmm10
  }
  if ( !v37 )
  {
    __asm { vcomiss xmm6, xmm7 }
    if ( v37 | v38 )
    {
      __asm { vmovaps xmm2, xmm6; fraction }
      *(double *)&_XMM0 = GraphGetValueFromFraction(nonLinearGraph->knotCount, nonLinearGraph->knots, *(const float *)&_XMM2);
      __asm
      {
        vaddss  xmm2, xmm8, cs:graphAdjustY_1; y
        vaddss  xmm1, xmm9, cs:graphAdjustX_1; x
        vmovss  xmm3, cs:VMMOTION_DEBUG_GRAPH_WIDTH; width
        vmovss  [rsp+188h+max], xmm0
        vmovss  xmm0, cs:VMMOTION_DEBUG_GRAPH_HEIGHT
        vmovss  dword ptr [rsp+188h+color], xmm6
        vmovss  dword ptr [rsp+188h+fmt], xmm0
      }
      CG_DebugGraphs_DrawGraphDatapoint(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, fmtb, colora, maxa, color0);
    }
  }
  __asm
  {
    vmovss  xmm6, [rsp+188h+normValueX_1]
    vcomiss xmm6, xmm10
  }
  if ( !v37 )
  {
    __asm { vcomiss xmm6, xmm7 }
    if ( v37 | v38 )
    {
      __asm { vmovaps xmm2, xmm6; fraction }
      *(double *)&_XMM0 = GraphGetValueFromFraction(nonLinearGraph->knotCount, nonLinearGraph->knots, *(const float *)&_XMM2);
      __asm
      {
        vaddss  xmm2, xmm8, cs:graphAdjustY_1; y
        vaddss  xmm1, xmm9, cs:graphAdjustX_1; x
        vmovss  xmm3, cs:VMMOTION_DEBUG_GRAPH_WIDTH; width
        vmovss  [rsp+188h+max], xmm0
        vmovss  xmm0, cs:VMMOTION_DEBUG_GRAPH_HEIGHT
        vmovss  dword ptr [rsp+188h+color], xmm6
        vmovss  dword ptr [rsp+188h+fmt], xmm0
      }
      CG_DebugGraphs_DrawGraphDatapoint(scrPlace, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, fmtc, colorb, maxb, color1);
    }
  }
  _R11 = &v68;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-18h]
    vmovaps xmm7, xmmword ptr [r11-28h]
    vmovaps xmm8, xmmword ptr [r11-38h]
    vmovaps xmm9, xmmword ptr [r11-48h]
    vmovaps xmm10, xmmword ptr [r11-58h]
  }
}

/*
==============
CG_ViewMotion_Enabled
==============
*/
bool CG_ViewMotion_Enabled(const playerState_s *ps)
{
  bool v2; 
  const dvar_t *v3; 

  v2 = GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 5u) && (ps->mantleState.flags & 0x800) != 0;
  v3 = DCONST_DVARMPBOOL_cg_viewmotion_spring_enable;
  if ( !DCONST_DVARMPBOOL_cg_viewmotion_spring_enable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmotion_spring_enable") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v3);
  return v3->current.enabled && !ps->vehicleAnimState.seat && !v2;
}

/*
==============
CG_ViewMotion_GetCinematicMotionDef
==============
*/
CinematicMotionDef *CG_ViewMotion_GetCinematicMotionDef(unsigned int index)
{
  __int64 v1; 

  v1 = index;
  if ( !s_cgCinematicMotionDefsInitialized )
    return 0i64;
  if ( index >= 0x20 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 523, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( ( sizeof( *array_counter( s_cgCinematicMotionDefs ) ) + 0 ) )", "index doesn't index ARRAY_COUNT( s_cgCinematicMotionDefs )\n\t%i not in [0, %i)", index, 32) )
    __debugbreak();
  return s_cgCinematicMotionDefs[v1];
}

/*
==============
CG_ViewMotion_GetCinematicMotionIndexForPtr
==============
*/
__int64 CG_ViewMotion_GetCinematicMotionIndexForPtr(const CinematicMotionDef *const def)
{
  __int64 result; 

  if ( !def )
    return 31i64;
  result = 0i64;
  while ( s_cgCinematicMotionDefs[result] != def )
  {
    if ( (unsigned __int64)++result >= 0x20 )
      return 31i64;
  }
  return result;
}

/*
==============
CG_ViewMotion_GetSpringOffset
==============
*/

void __fastcall CG_ViewMotion_GetSpringOffset(const playerState_s *ps, double adsFraction, const ViewMotionSpring *spring, const vec3_t *viewAngles, vec3_t *outLocalOffset, vec3_t *outWorldOffset)
{
  const float4 *v13; 
  float4 *v14; 
  const float4 *v31; 
  vector3 *v32; 
  __int128 v46; 

  __asm { vmovaps [rsp+78h+var_28], xmm6 }
  _RBX = outLocalOffset;
  _RBP = viewAngles;
  _RDI = outWorldOffset;
  _RSI = spring;
  __asm { vmovaps xmm6, xmm1 }
  if ( CG_ViewMotion_Enabled(ps) && _RSI->isInitialized )
  {
    __asm
    {
      vmovups xmm1, xmmword ptr [rsi+20h]
      vmovups xmm0, xmmword ptr [rsi]
      vsubps  xmm3, xmm0, xmm1
      vxorps  xmm0, xmm0, xmm0
      vmovaps xmm1, xmm6
      vsubps  xmm2, xmm0, xmm3
      vshufps xmm1, xmm1, xmm1, 0
      vmulps  xmm0, xmm2, xmm1
      vaddps  xmm6, xmm0, xmm3
    }
    if ( outLocalOffset )
    {
      __asm
      {
        vmovss  dword ptr [rbx], xmm6
        vextractps dword ptr [rbx+4], xmm6, 1
        vextractps dword ptr [rbx+8], xmm6, 2
      }
    }
    if ( outWorldOffset )
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rbp+0]
        vmovaps [rsp+78h+var_38], xmm7
        vmovdqa xmm7, xmmword ptr cs:?g_0001@@3Ufloat4@@B.v; float4 const g_0001
      }
      HIDWORD(v46) = 0;
      __asm
      {
        vmovups xmm3, xmmword ptr [rsp+20h]
        vmovss  xmm3, xmm3, xmm0
        vinsertps xmm3, xmm3, dword ptr [rbp+4], 10h
        vinsertps xmm3, xmm3, dword ptr [rbp+8], 20h ; ' '
        vmulps  xmm0, xmm3, xmmword ptr cs:?g_degreeToRadian@@3Ufloat4@@B.v; float4 const g_degreeToRadian
      }
      Float4RadianToQuat(v14, v13);
      Float4UnitQuatToAxis(v32, v31);
      __asm
      {
        vshufps xmm3, xmm6, xmm6, 0
        vmulps  xmm3, xmm0, xmm3
        vshufps xmm4, xmm6, xmm6, 55h ; 'U'
        vshufps xmm5, xmm6, xmm6, 0AAh ; 'ª'
        vmulps  xmm0, xmm2, xmm5
        vmulps  xmm4, xmm1, xmm4
        vaddps  xmm2, xmm0, xmm3
        vshufps xmm6, xmm6, xmm6, 0FFh
        vmulps  xmm1, xmm6, xmm7
        vmovaps xmm7, [rsp+78h+var_38]
        vaddps  xmm0, xmm1, xmm4
        vaddps  xmm3, xmm0, xmm2
        vmovss  dword ptr [rdi], xmm3
        vextractps dword ptr [rdi+4], xmm3, 1
        vextractps dword ptr [rdi+8], xmm3, 2
      }
    }
  }
  else
  {
    if ( outLocalOffset )
    {
      *(_QWORD *)outLocalOffset->v = 0i64;
      outLocalOffset->v[2] = 0.0;
    }
    if ( outWorldOffset )
    {
      *(_QWORD *)outWorldOffset->v = 0i64;
      outWorldOffset->v[2] = 0.0;
    }
  }
  __asm { vmovaps xmm6, [rsp+78h+var_28] }
}

/*
==============
CG_ViewMotion_Impact
==============
*/
void CG_ViewMotion_Impact(const LocalClientNum_t localClientNum, const int time)
{
  cg_t *LocalClientGlobals; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 408, ASSERT_TYPE_ASSERT, "( cgameGlob ) != ( nullptr )", "%s != %s\n\t%p, %p", "cgameGlob", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( (LocalClientGlobals->predictedPlayerState.slideState.flags & 0x20) == 0 && !GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&LocalClientGlobals->predictedPlayerState.pm_flags, ACTIVE, 0x1Du) )
    LocalClientGlobals->viewSpring.unlockTime = time;
}

/*
==============
CG_ViewMotion_InitCinematicMotionAssets
==============
*/
void CG_ViewMotion_InitCinematicMotionAssets(void)
{
  if ( s_cgCinematicMotionDefsInitialized )
  {
    NetConstStrings_CallForAllCinematicMotionStrings(CG_ViewMotion_Validate_Callback);
  }
  else
  {
    NetConstStrings_CallForAllCinematicMotionStrings(CG_ViewMotion_LoadCache_Callback);
    s_cgCinematicMotionDefsInitialized = 1;
  }
}

/*
==============
CG_ViewMotion_IntegrateSpring
==============
*/
void CG_ViewMotion_IntegrateSpring(int serverTime, const float4 *frametime4, const float4 *anchorVelocityLocal, ViewMotionSpring *springData)
{
  ViewMotionSpring *inOutMassPos; 
  const float4 *v13; 
  bool v30; 
  bool v31; 
  int v34; 
  int v59; 
  float4 anchorVelocity; 
  float4 mass; 
  char v97; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-48h], xmm7
    vmovaps xmmword ptr [rax-58h], xmm8
    vmovaps xmmword ptr [rax-68h], xmm9
    vmovups xmm9, xmmword ptr [rdx]
    vcvtss2sd xmm0, xmm9, xmm9
    vcomisd xmm0, cs:__real@3eb0c6f7a0b5ed8d
  }
  inOutMassPos = springData;
  _RDI = anchorVelocityLocal;
  v13 = frametime4;
  if ( !springData->isInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 84, ASSERT_TYPE_ASSERT, "(springData.isInitialized)", (const char *)&queryFormat, "springData.isInitialized") )
    __debugbreak();
  __asm
  {
    vmovups xmm1, xmmword ptr [rbx+30h]
    vmovss  xmm8, cs:__real@3f800000
    vdivss  xmm0, xmm8, xmm9
    vshufps xmm0, xmm0, xmm0, 0
    vmulps  xmm4, xmm0, xmmword ptr [rbx+50h]
    vrcpps  xmm3, xmm4
    vmulps  xmm0, xmm3, xmm1
    vsubps  xmm2, xmm1, xmm0
    vmulps  xmm0, xmm3, xmmword ptr [rdi]
    vmovups xmm1, xmmword ptr [rdi]
    vaddps  xmm3, xmm0, xmm2
    vcmpleps xmm0, xmm4, xmmword ptr cs:?g_one@@3Ufloat4@@B.v; float4 const g_one
    vblendvps xmm2, xmm3, xmm1, xmm0
    vcmpneqps xmm0, xmm2, xmm2
    vmovmskps eax, xmm0
    vmovups xmmword ptr [rbx+30h], xmm2
  }
  if ( _EAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 90, ASSERT_TYPE_SANITY, "( !Float4IsNaN( springData.anchorVelocitySmooth ) )", (const char *)&queryFormat, "!Float4IsNaN( springData.anchorVelocitySmooth )") )
    __debugbreak();
  v30 = 0;
  v31 = !inOutMassPos->isLockingSpring;
  __asm
  {
    vmovups xmm1, xmmword ptr [rbx+60h]
    vmulps  xmm7, xmm1, xmmword ptr [rbx+30h]
    vmovups xmmword ptr [rsp+0E8h+var_98.v], xmm7
  }
  if ( !v31 )
  {
    v34 = unlockDurationMs + unlockDurationBlendOutMs + inOutMassPos->unlockTime;
    v30 = v34 < (unsigned int)serverTime;
    if ( v34 <= serverTime )
      goto LABEL_9;
  }
  __asm
  {
    vmovups xmm0, xmmword ptr [rbx]
    vsubps  xmm1, xmm0, xmmword ptr [rbx+20h]
    vmovss  xmm3, cs:springRestingThreshold
    vmulps  xmm2, xmm1, xmm1
    vinsertps xmm0, xmm2, xmm2, 8
    vhaddps xmm1, xmm0, xmm0
    vhaddps xmm2, xmm1, xmm1
    vcomiss xmm2, xmm3
  }
  if ( !v30 )
    goto LABEL_12;
  __asm
  {
    vmovups xmm0, xmmword ptr [rbx+10h]
    vsubps  xmm1, xmm0, xmm7
    vmulps  xmm2, xmm1, xmm1
    vinsertps xmm0, xmm2, xmm2, 8
    vhaddps xmm1, xmm0, xmm0
    vhaddps xmm2, xmm1, xmm1
    vcomiss xmm2, xmm3
  }
  if ( v30 )
  {
LABEL_9:
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vmovups xmmword ptr [rbx], xmm0
      vmovups xmmword ptr [rbx+20h], xmm0
      vmovups xmmword ptr [rbx+10h], xmm7
    }
  }
  else
  {
LABEL_12:
    __asm { vmulps  xmm0, xmm7, xmmword ptr [r14] }
    _RDI = &inOutMassPos->anchorPos;
    __asm
    {
      vaddps  xmm2, xmm0, xmmword ptr [rdi]
      vcmpneqps xmm0, xmm2, xmm2
      vmovmskps eax, xmm0
      vmovaps [rsp+0E8h+var_38], xmm6
      vmovups xmmword ptr [rdi], xmm2
    }
    if ( _EAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 127, ASSERT_TYPE_SANITY, "( !Float4IsNaN( springData.anchorPos ) )", (const char *)&queryFormat, "!Float4IsNaN( springData.anchorPos )") )
      __debugbreak();
    __asm { vmovups xmm6, cs:__xmm@3f8000003f8000003f8000003f800000 }
    _RBP = &inOutMassPos->massVelocity;
    __asm { vmovups xmmword ptr [rsp+0E8h+mass.v], xmm6 }
    Float4IntegrateDampedSpring(v13, &mass, &inOutMassPos->springConstant, &inOutMassPos->dampingConstant, &inOutMassPos->anchorPos, &anchorVelocity, &inOutMassPos->massPos, &inOutMassPos->massVelocity);
    __asm
    {
      vmovups xmm0, xmmword ptr [rbx]
      vsubps  xmm2, xmm0, xmmword ptr [rdi]
      vandps  xmm0, xmm2, xmmword ptr cs:?g_negativeZero@@3Ufloat4@@B.v; float4 const g_negativeZero
      vmovups xmm1, xmmword ptr [rbx]
    }
    v59 = inOutMassPos->unlockTime + unlockDurationMs;
    v31 = !inOutMassPos->isLockingSpring;
    __asm
    {
      vorps   xmm3, xmm0, xmm6
      vmulps  xmm0, xmm3, xmmword ptr [rbx+90h]
      vmovaps xmm6, [rsp+0E8h+var_38]
      vmulps  xmm4, xmm3, xmm2
      vaddps  xmm2, xmm0, xmmword ptr [rdi]
      vmovups xmm0, xmmword ptr [rbx+90h]
      vcmpleps xmm0, xmm0, xmm4
      vblendvps xmm1, xmm1, xmm2, xmm0
      vmovups xmmword ptr [rbx], xmm1
    }
    if ( !v31 && v59 < serverTime )
    {
      __asm
      {
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm0, xmm0, eax
        vmulss  xmm2, xmm0, cs:__real@3a83126f
        vcvtss2sd xmm1, xmm2, xmm2
        vcomisd xmm1, cs:__real@3eb0c6f7a0b5ed8d
      }
      if ( !__CFADD__(v59, unlockDurationBlendOutMs - serverTime) && v59 + unlockDurationBlendOutMs - serverTime != 0 )
      {
        __asm
        {
          vdivss  xmm0, xmm9, xmm2; val
          vmovaps xmm2, xmm8; max
          vxorps  xmm1, xmm1, xmm1; min
        }
        *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
        __asm { vmovaps xmm8, xmm0 }
      }
      __asm
      {
        vmovups xmm0, xmmword ptr [rdi]
        vsubps  xmm0, xmm0, xmmword ptr [rbx]
        vmovaps xmm4, xmm8
        vshufps xmm4, xmm4, xmm4, 0
        vmulps  xmm1, xmm0, xmm4
        vaddps  xmm2, xmm1, xmmword ptr [rbx]
        vsubps  xmm0, xmm7, xmmword ptr [rbp+0]
        vmulps  xmm1, xmm0, xmm4
        vmovups xmmword ptr [rbx], xmm2
        vaddps  xmm2, xmm1, xmmword ptr [rbp+0]
        vmovups xmmword ptr [rbp+0], xmm2
      }
    }
    __asm
    {
      vmovups xmm0, xmmword ptr [rbx]
      vcmpneqps xmm0, xmm0, xmm0
      vmovmskps eax, xmm0
    }
    if ( _EAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 161, ASSERT_TYPE_SANITY, "( !Float4IsNaN( springData.massPos ) )", (const char *)&queryFormat, "!Float4IsNaN( springData.massPos )") )
      __debugbreak();
    __asm
    {
      vmovups xmm0, xmmword ptr [rbp+0]
      vcmpneqps xmm0, xmm0, xmm0
      vmovmskps eax, xmm0
    }
    if ( _EAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 162, ASSERT_TYPE_SANITY, "( !Float4IsNaN( springData.massVelocity ) )", (const char *)&queryFormat, "!Float4IsNaN( springData.massVelocity )") )
      __debugbreak();
  }
  _R11 = &v97;
  __asm
  {
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
  }
}

/*
==============
CG_ViewMotion_LoadCache_Callback
==============
*/
void CG_ViewMotion_LoadCache_Callback(const unsigned int cinematicMotionDefIndex, const char *cinematicMotionName)
{
  CinematicMotionDef *v2; 
  __int64 v3; 

  v2 = NULL;
  v3 = cinematicMotionDefIndex;
  if ( !cinematicMotionName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 488, ASSERT_TYPE_ASSERT, "(cinematicMotionName)", (const char *)&queryFormat, "cinematicMotionName") )
    __debugbreak();
  if ( (unsigned int)v3 >= 0x1F )
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1442D43B0, 1231i64);
  if ( *cinematicMotionName )
    v2 = CinematicMotion_Register(cinematicMotionName);
  s_cgCinematicMotionDefs[v3] = v2;
}

/*
==============
CG_ViewMotion_LocalOffsetToLocalAngles
==============
*/
void CG_ViewMotion_LocalOffsetToLocalAngles(const playerState_s *ps, const ViewMotionSpring *spring, const vec3_t *localOffset, vec3_t *outLocalAngles)
{
  __int128 v22; 

  _RBX = outLocalAngles;
  _RSI = localOffset;
  if ( CG_ViewMotion_Enabled(ps) )
  {
    __asm { vmovss  xmm0, dword ptr [rsi] }
    HIDWORD(v22) = 0;
    __asm
    {
      vmovups xmm5, xmmword ptr [rsp+20h]
      vmovss  xmm5, xmm5, xmm0
      vinsertps xmm5, xmm5, dword ptr [rsi+4], 10h
      vinsertps xmm5, xmm5, dword ptr [rsi+8], 20h ; ' '
      vshufps xmm1, xmm5, xmm5, 0
      vmulps  xmm2, xmm1, xmmword ptr [rdi+0A0h]
      vshufps xmm3, xmm5, xmm5, 55h ; 'U'
      vmulps  xmm1, xmm3, xmmword ptr [rdi+0B0h]
      vshufps xmm4, xmm5, xmm5, 0AAh ; 'ª'
      vmulps  xmm0, xmm4, xmmword ptr [rdi+0C0h]
      vaddps  xmm2, xmm0, xmm2
      vshufps xmm5, xmm5, xmm5, 0FFh
      vmulps  xmm0, xmm5, xmmword ptr [rdi+0D0h]
      vaddps  xmm1, xmm0, xmm1
      vaddps  xmm3, xmm1, xmm2
      vmovss  dword ptr [rbx], xmm3
      vextractps dword ptr [rbx+4], xmm3, 1
      vextractps dword ptr [rbx+8], xmm3, 2
    }
  }
  else
  {
    *(_QWORD *)_RBX->v = 0i64;
    _RBX->v[2] = 0.0;
  }
}

/*
==============
CG_ViewMotion_MyChanges
==============
*/
void CG_ViewMotion_MyChanges(void)
{
  s_cgCinematicMotionDefsInitialized = 0;
  memset_0(s_cgCinematicMotionDefs, 0, sizeof(s_cgCinematicMotionDefs));
  if ( NetConstStrings_AreStringsLoaded() )
  {
    if ( s_cgCinematicMotionDefsInitialized )
    {
      NetConstStrings_CallForAllCinematicMotionStrings(CG_ViewMotion_Validate_Callback);
    }
    else
    {
      NetConstStrings_CallForAllCinematicMotionStrings(CG_ViewMotion_LoadCache_Callback);
      s_cgCinematicMotionDefsInitialized = 1;
    }
  }
}

/*
==============
CG_ViewMotion_SmoothBlend
==============
*/

void __fastcall CG_ViewMotion_SmoothBlend(double lerp, double frametime, const float4 *up, double speed, vector4 *prevAxis, vector4 *goalAxis, vector4 *outCurAxis)
{
  char v36; 
  int v45; 
  unsigned int v46; 
  __int64 v47; 
  __int64 v71; 
  char v106; 
  const float4 *v118; 
  const float4 *v211; 
  __int64 v277; 
  float4 v278; 
  float4 v279[3]; 
  char v284; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm7
    vmovaps xmmword ptr [rax-48h], xmm8
    vmovaps xmmword ptr [rax-58h], xmm9
    vmovaps [rsp+108h+var_98], xmm15
  }
  _R14 = prevAxis;
  _R12 = up;
  _RSI = goalAxis;
  _RDI = outCurAxis;
  __asm
  {
    vxorps  xmm9, xmm9, xmm9
    vcomiss xmm1, xmm9
    vmovaps xmm7, xmm3
    vmovaps xmm8, xmm1
    vmovaps xmm15, xmm0
  }
  if ( (unsigned __int64)&v277 != _security_cookie )
  {
    __asm
    {
      vmovaps [rsp+108h+var_28], xmm6
      vmovaps [rsp+108h+var_68], xmm10
      vmovaps [rsp+108h+var_78], xmm11
      vmovaps [rsp+108h+var_88], xmm12
    }
    CG_ViewMotion_AssertFloat3Normalized(&prevAxis->x);
    CG_ViewMotion_AssertFloat3Normalized(&prevAxis->y);
    CG_ViewMotion_AssertFloat3Normalized(&prevAxis->z);
    CG_ViewMotion_AssertFloat3Normalized(&goalAxis->x);
    CG_ViewMotion_AssertFloat3Normalized(&goalAxis->y);
    CG_ViewMotion_AssertFloat3Normalized(&goalAxis->z);
    __asm
    {
      vmovups xmm1, xmmword ptr [rsi]
      vmulps  xmm1, xmm1, xmmword ptr [r14]
      vmovss  xmm12, cs:__real@3f800000
      vinsertps xmm2, xmm1, xmm1, 8
      vmovss  xmm1, cs:__real@bf800000; min
      vhaddps xmm0, xmm2, xmm2
      vhaddps xmm0, xmm0, xmm0; val
      vmovaps xmm2, xmm12; max
    }
    *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
    __asm
    {
      vandps  xmm1, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
      vsubss  xmm1, xmm12, xmm1
      vcomiss xmm1, cs:dotEpsilon
    }
    if ( v36 )
      goto LABEL_22;
    *(float *)&_XMM0 = acosf_0(*(float *)&_XMM0);
    __asm
    {
      vmovss  xmm6, cs:microStepSecInit
      vdivss  xmm1, xmm8, xmm6
      vcvttss2si ebx, xmm1
      vmovaps xmm11, xmm0
      vmovaps xmm3, xmm0
    }
    if ( microStepMax < _EBX )
    {
      __asm
      {
        vxorps  xmm1, xmm1, xmm1
        vcvtsi2ss xmm1, xmm1, eax
        vdivss  xmm6, xmm8, xmm1
      }
      _EBX = microStepMax;
    }
    v45 = 0;
    if ( _EBX >= 8 )
    {
      v46 = ((unsigned int)(_EBX - 8) >> 3) + 1;
      v47 = v46;
      v45 = 8 * v46;
      do
      {
        __asm
        {
          vmulss  xmm0, xmm3, xmm7
          vmulss  xmm1, xmm0, xmm6
          vsubss  xmm3, xmm3, xmm1
          vmulss  xmm2, xmm3, xmm7
          vmulss  xmm0, xmm2, xmm6
          vsubss  xmm4, xmm3, xmm0
          vmulss  xmm1, xmm4, xmm7
          vmulss  xmm2, xmm1, xmm6
          vsubss  xmm3, xmm4, xmm2
          vmulss  xmm0, xmm3, xmm7
          vmulss  xmm1, xmm0, xmm6
          vsubss  xmm4, xmm3, xmm1
          vmulss  xmm2, xmm4, xmm7
          vmulss  xmm0, xmm2, xmm6
          vsubss  xmm3, xmm4, xmm0
          vmulss  xmm1, xmm3, xmm7
          vmulss  xmm2, xmm1, xmm6
          vsubss  xmm4, xmm3, xmm2
          vmulss  xmm0, xmm4, xmm7
          vmulss  xmm1, xmm0, xmm6
          vsubss  xmm3, xmm4, xmm1
          vmulss  xmm2, xmm3, xmm7
          vmulss  xmm0, xmm2, xmm6
          vsubss  xmm3, xmm3, xmm0
        }
        --v47;
      }
      while ( v47 );
    }
    if ( v45 < _EBX )
    {
      v71 = (unsigned int)(_EBX - v45);
      do
      {
        __asm
        {
          vmulss  xmm1, xmm3, xmm7
          vmulss  xmm2, xmm1, xmm6
          vsubss  xmm3, xmm3, xmm2
        }
        --v71;
      }
      while ( v71 );
    }
    __asm
    {
      vmovaps xmm2, xmm11; max
      vmovaps xmm1, xmm9; min
      vmovaps xmm0, xmm3; val
    }
    *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
    __asm
    {
      vxorps  xmm1, xmm1, xmm1
      vcvtsi2ss xmm1, xmm1, ebx
      vmulss  xmm2, xmm1, xmm6
      vmovaps xmm10, xmm0
      vsubss  xmm0, xmm8, xmm2
      vcomiss xmm0, xmm9
    }
    if ( !v36 )
    {
      __asm
      {
        vmulss  xmm1, xmm10, xmm7
        vmulss  xmm2, xmm1, xmm0
        vsubss  xmm0, xmm10, xmm2; val
        vmovaps xmm2, xmm11; max
        vmovaps xmm1, xmm9; min
      }
      *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
      __asm { vmovaps xmm10, xmm0 }
    }
    _RBX = DCONST_DVARFLT_smoothClampAngle;
    if ( !DCONST_DVARFLT_smoothClampAngle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "smoothClampAngle") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm
    {
      vmovss  xmm0, dword ptr [rbx+28h]
      vmulss  xmm7, xmm0, cs:__real@3c8efa35
      vmovups xmm4, xmmword ptr [rsi]
      vmovups xmm2, xmmword ptr [r14]
      vshufps xmm1, xmm2, xmm2, 0C9h ; 'É'
      vshufps xmm0, xmm4, xmm4, 0D2h ; 'Ò'
      vmulps  xmm3, xmm1, xmm0
      vshufps xmm1, xmm4, xmm4, 0C9h ; 'É'
      vshufps xmm2, xmm2, xmm2, 0D2h ; 'Ò'
      vmulps  xmm0, xmm2, xmm1
      vsubps  xmm5, xmm3, xmm0
      vmulps  xmm1, xmm5, xmm5
      vinsertps xmm0, xmm1, xmm1, 8
      vhaddps xmm2, xmm0, xmm0
      vhaddps xmm0, xmm2, xmm2
      vsqrtps xmm3, xmm0
      vcvtss2sd xmm1, xmm3, xmm3
      vcomisd xmm1, cs:__real@3eb0c6f7a0b5ed8d
    }
    if ( v36 | v106 )
    {
LABEL_22:
      __asm
      {
        vmovups ymm0, ymmword ptr [rsi]
        vmovups ymm1, ymmword ptr [rsi+20h]
        vmovups ymmword ptr [rdi], ymm0
        vmovups ymmword ptr [rdi+20h], ymm1
      }
    }
    else
    {
      __asm
      {
        vdivss  xmm0, xmm12, xmm3
        vshufps xmm0, xmm0, xmm0, 0
        vmulps  xmm6, xmm0, xmm5
        vmovups xmmword ptr [rsp+108h+var_C8.v], xmm6
      }
      CG_ViewMotion_AssertFloat3Normalized(&v278);
      __asm
      {
        vminss  xmm0, xmm7, xmm10
        vsubss  xmm1, xmm11, xmm0
        vmulss  xmm2, xmm1, xmm15
        vsubss  xmm0, xmm12, xmm15
        vmulss  xmm1, xmm0, xmm11
        vaddss  xmm2, xmm2, xmm1
        vshufps xmm2, xmm2, xmm2, 0
        vmulps  xmm0, xmm2, xmmword ptr cs:?g_oneHalf@@3Ufloat4@@B.v; float4 const g_oneHalf
      }
      Float4SinCos(v118, &v278, v279);
      __asm
      {
        vmulps  xmm1, xmm6, xmmword ptr [rsp+108h+var_C8.v]
        vblendps xmm2, xmm1, [rsp+108h+var_B8], arg_0
        vmovups xmm7, xmmword ptr [r14]
        vshufps xmm6, xmm2, xmm2, 0C9h ; 'É'
        vshufps xmm5, xmm2, xmm2, 0FFh
        vshufps xmm8, xmm2, xmm2, 0D2h ; 'Ò'
        vshufps xmm0, xmm7, xmm7, 0D2h ; 'Ò'
        vmulps  xmm3, xmm0, xmm6
        vshufps xmm1, xmm7, xmm7, 0C9h ; 'É'
        vmulps  xmm2, xmm1, xmm8
        vsubps  xmm0, xmm3, xmm2
        vaddps  xmm4, xmm0, xmm0
        vmulps  xmm0, xmm5, xmm4
        vaddps  xmm5, xmm0, xmm7
        vshufps xmm0, xmm4, xmm4, 0C9h ; 'É'
        vmulps  xmm2, xmm0, xmm8
        vshufps xmm1, xmm4, xmm4, 0D2h ; 'Ò'
        vmulps  xmm3, xmm1, xmm6
        vsubps  xmm1, xmm3, xmm2
        vaddps  xmm4, xmm1, xmm5
        vmulps  xmm0, xmm4, xmm4
        vinsertps xmm1, xmm0, xmm0, 8
        vhaddps xmm2, xmm1, xmm1
        vhaddps xmm0, xmm2, xmm2
        vsqrtps xmm1, xmm0
        vdivps  xmm2, xmm4, xmm1
        vmovups xmmword ptr [rdi], xmm2
      }
      CG_ViewMotion_AssertFloat3Normalized(&outCurAxis->x);
      CG_ViewMotion_AssertFloat3Normalized(&outCurAxis->x);
      __asm
      {
        vmovups xmm3, xmmword ptr [r12]
        vmovups xmm1, xmmword ptr [r12]
        vmulps  xmm1, xmm1, xmmword ptr [rsi]
        vinsertps xmm2, xmm1, xmm1, 8
        vhaddps xmm0, xmm2, xmm2
        vhaddps xmm0, xmm0, xmm0
        vxorps  xmm5, xmm5, xmm5
        vsubps  xmm1, xmm5, xmm0
        vmulps  xmm2, xmm1, xmmword ptr [rsi]
        vaddps  xmm4, xmm2, xmm3
        vmulps  xmm0, xmm4, xmm4
        vinsertps xmm1, xmm0, xmm0, 8
        vhaddps xmm2, xmm1, xmm1
        vhaddps xmm0, xmm2, xmm2
        vsqrtps xmm1, xmm0
        vdivps  xmm6, xmm4, xmm1
        vmulps  xmm1, xmm3, xmmword ptr [rdi]
        vinsertps xmm2, xmm1, xmm1, 8
        vhaddps xmm0, xmm2, xmm2
        vhaddps xmm0, xmm0, xmm0
        vsubps  xmm1, xmm5, xmm0
        vmulps  xmm2, xmm1, xmmword ptr [rdi]
        vaddps  xmm4, xmm2, xmm3
        vmulps  xmm0, xmm4, xmm4
        vinsertps xmm1, xmm0, xmm0, 8
        vhaddps xmm2, xmm1, xmm1
        vhaddps xmm0, xmm2, xmm2
        vsqrtps xmm2, xmm0
        vdivps  xmm8, xmm4, xmm2
        vmulps  xmm2, xmm6, xmmword ptr [rsi+20h]
        vinsertps xmm3, xmm2, xmm2, 8
        vhaddps xmm0, xmm3, xmm3
        vhaddps xmm0, xmm0, xmm0; val
        vmovss  xmm1, cs:__real@bf800000; min
        vmovaps xmm2, xmm12; max
      }
      *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
      __asm
      {
        vsubss  xmm2, xmm12, cs:dotEpsilon
        vandps  xmm1, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
        vcomiss xmm2, xmm1
        vmovaps xmm5, xmm0
      }
      if ( v36 | v106 )
      {
        _RSI = &outCurAxis->z;
        __asm { vmovups xmmword ptr [rsi], xmm8 }
      }
      else
      {
        __asm
        {
          vmovups xmm2, xmmword ptr [rsi+20h]
          vshufps xmm1, xmm2, xmm2, 0C9h ; 'É'
          vshufps xmm2, xmm2, xmm2, 0D2h ; 'Ò'
          vshufps xmm0, xmm6, xmm6, 0D2h ; 'Ò'
          vmulps  xmm3, xmm1, xmm0
          vshufps xmm1, xmm6, xmm6, 0C9h ; 'É'
          vmulps  xmm0, xmm2, xmm1
          vsubps  xmm4, xmm3, xmm0
          vmulps  xmm1, xmm4, xmm4
          vinsertps xmm0, xmm1, xmm1, 8
          vhaddps xmm2, xmm0, xmm0
          vhaddps xmm0, xmm2, xmm2
          vsqrtps xmm1, xmm0
          vdivps  xmm3, xmm4, xmm1
          vmulps  xmm1, xmm3, xmmword ptr [rsi]
          vinsertps xmm2, xmm1, xmm1, 8
          vhaddps xmm0, xmm2, xmm2
          vhaddps xmm6, xmm0, xmm0
          vmovaps xmm0, xmm5; X
        }
        *(float *)&_XMM0 = acosf_0(*(float *)&_XMM0);
        __asm
        {
          vxorps  xmm2, xmm0, cs:__xmm@80000000800000008000000080000000
          vmovups xmm7, xmmword ptr [rdi]
          vcmpless xmm1, xmm9, xmm6
          vblendvps xmm0, xmm2, xmm0, xmm1
          vxorps  xmm2, xmm0, cs:__xmm@80000000800000008000000080000000
          vshufps xmm2, xmm2, xmm2, 0
          vmulps  xmm0, xmm2, xmmword ptr cs:?g_oneHalf@@3Ufloat4@@B.v; float4 const g_oneHalf
        }
        Float4SinCos(v211, v279, &v278);
        __asm
        {
          vmulps  xmm1, xmm7, [rsp+108h+var_B8]
          vblendps xmm2, xmm1, xmmword ptr [rsp+108h+var_C8.v], arg_0
          vshufps xmm6, xmm2, xmm2, 0C9h ; 'É'
          vshufps xmm5, xmm2, xmm2, 0FFh
          vshufps xmm7, xmm2, xmm2, 0D2h ; 'Ò'
          vshufps xmm0, xmm8, xmm8, 0D2h ; 'Ò'
          vmulps  xmm3, xmm0, xmm6
          vshufps xmm1, xmm8, xmm8, 0C9h ; 'É'
          vmulps  xmm2, xmm1, xmm7
          vsubps  xmm0, xmm3, xmm2
          vaddps  xmm4, xmm0, xmm0
          vmulps  xmm0, xmm5, xmm4
          vaddps  xmm5, xmm0, xmm8
          vshufps xmm0, xmm4, xmm4, 0C9h ; 'É'
          vmulps  xmm2, xmm0, xmm7
          vshufps xmm1, xmm4, xmm4, 0D2h ; 'Ò'
          vmulps  xmm3, xmm1, xmm6
          vsubps  xmm1, xmm3, xmm2
          vaddps  xmm4, xmm1, xmm5
          vmulps  xmm0, xmm4, xmm4
          vinsertps xmm1, xmm0, xmm0, 8
          vhaddps xmm2, xmm1, xmm1
          vhaddps xmm0, xmm2, xmm2
          vsqrtps xmm1, xmm0
          vdivps  xmm2, xmm4, xmm1
        }
        _RSI = &outCurAxis->z;
        __asm { vmovups xmmword ptr [rsi], xmm2 }
      }
      CG_ViewMotion_AssertFloat3Normalized(_RSI);
      __asm
      {
        vmovups xmm4, xmmword ptr [rdi]
        vmovups xmm2, xmmword ptr [rsi]
        vshufps xmm1, xmm2, xmm2, 0C9h ; 'É'
        vshufps xmm2, xmm2, xmm2, 0D2h ; 'Ò'
        vshufps xmm0, xmm4, xmm4, 0D2h ; 'Ò'
        vmulps  xmm3, xmm1, xmm0
        vshufps xmm1, xmm4, xmm4, 0C9h ; 'É'
        vmulps  xmm0, xmm2, xmm1
        vsubps  xmm5, xmm3, xmm0
        vmulps  xmm0, xmm5, xmm5
        vinsertps xmm1, xmm0, xmm0, 8
        vhaddps xmm2, xmm1, xmm1
        vhaddps xmm0, xmm2, xmm2
        vmovups xmm2, xmmword ptr [rdi]
        vsqrtps xmm1, xmm0
        vdivps  xmm4, xmm5, xmm1
        vshufps xmm1, xmm2, xmm2, 0C9h ; 'É'
        vshufps xmm2, xmm2, xmm2, 0D2h ; 'Ò'
        vshufps xmm0, xmm4, xmm4, 0D2h ; 'Ò'
        vmulps  xmm3, xmm1, xmm0
        vshufps xmm1, xmm4, xmm4, 0C9h ; 'É'
        vmulps  xmm0, xmm2, xmm1
        vsubps  xmm5, xmm3, xmm0
        vmulps  xmm0, xmm5, xmm5
        vinsertps xmm1, xmm0, xmm0, 8
        vhaddps xmm2, xmm1, xmm1
        vhaddps xmm0, xmm2, xmm2
        vsqrtps xmm1, xmm0
        vdivps  xmm2, xmm5, xmm1
        vmovups xmmword ptr [rsi], xmm2
        vmovups xmmword ptr [rdi+10h], xmm4
      }
      CG_ViewMotion_AssertFloat3Normalized(&outCurAxis->x);
      CG_ViewMotion_AssertFloat3Normalized(&outCurAxis->y);
      CG_ViewMotion_AssertFloat3Normalized(_RSI);
    }
    __asm
    {
      vmovaps xmm11, [rsp+108h+var_78]
      vmovaps xmm10, [rsp+108h+var_68]
      vmovaps xmm6, [rsp+108h+var_28]
      vmovaps xmm12, [rsp+108h+var_88]
    }
  }
  else
  {
    __asm
    {
      vmovups ymm0, ymmword ptr [r14]
      vmovups ymm1, ymmword ptr [r14+20h]
      vmovups ymmword ptr [rdi], ymm0
      vmovups ymmword ptr [rdi+20h], ymm1
    }
  }
  _R11 = &v284;
  __asm
  {
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm15, xmmword ptr [r11-80h]
  }
}

/*
==============
CG_ViewMotion_Update
==============
*/

void __fastcall CG_ViewMotion_Update(const LocalClientNum_t localClientNum, __int64 a2, double _XMM2_8)
{
  const float4 *v18; 
  float4 *v19; 
  const float4 *v42; 
  vector3 *v43; 
  char v72; 
  char v73; 
  float4 frametime4; 
  float4 curPsOrigin; 

  _RBX = CG_GetLocalClientGlobals(localClientNum);
  if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 339, ASSERT_TYPE_ASSERT, "( cgameGlob ) != ( nullptr )", "%s != %s\n\t%p, %p", "cgameGlob", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( CG_ViewMotion_Enabled(&_RBX->predictedPlayerState) )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rbx+38h]
      vmovaps [rsp+110h+var_90], xmm12
    }
    curPsOrigin.v.m128_i32[3] = 0;
    __asm
    {
      vmovups xmm12, xmmword ptr [rbp-59h]
      vmovss  xmm12, xmm12, xmm0
      vinsertps xmm12, xmm12, dword ptr [rbx+3Ch], 10h
      vinsertps xmm12, xmm12, dword ptr [rbx+40h], 20h ; ' '
      vmovups xmmword ptr [rbp-59h], xmm12
      vmovups xmmword ptr [rbp-59h], xmm12
    }
    if ( GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&_RBX->predictedPlayerState.otherFlags, ACTIVE, 0x1Fu) || GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&_RBX->predictedPlayerState.otherFlags, ACTIVE, 0x20u) || _RBX->predictedPlayerState.pm_type == 5 && !GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&_RBX->predictedPlayerState.otherFlags, GameModeFlagValues::ms_mpValue, 0x21u) )
    {
      __asm
      {
        vxorps  xmm2, xmm2, xmm2
        vmovups ymmword ptr [rbx+6790h], ymm2
        vmovups ymmword ptr [rbx+6770h], ymm2
        vmovups xmmword ptr [rbx+6760h], xmm12
      }
      *(_QWORD *)&_RBX->viewSpring.motionIndexBlendDuration = 0i64;
      __asm
      {
        vmovups ymmword ptr [rbx+6740h], ymm2
        vmovups ymmword ptr [rbx+6720h], ymm2
        vmovups xmmword ptr [rbx+67B0h], xmm2
      }
      _RBX->viewSpring.isLockingSpring = 0;
      *(_QWORD *)&_RBX->viewSpring.motionIndex = 31i64;
      __asm
      {
        vmovups xmm0, xmmword ptr cs:?g_1000@@3Ufloat4@@B.v; float4 const g_1000
        vmovups xmmword ptr [rbx+67C0h], xmm0
        vmovups xmm1, xmmword ptr cs:?g_0100@@3Ufloat4@@B.v; float4 const g_0100
        vmovups xmmword ptr [rbx+67D0h], xmm1
        vmovups xmm0, xmmword ptr cs:?g_0010@@3Ufloat4@@B.v; float4 const g_0010
        vmovups xmmword ptr [rbx+67E0h], xmm0
        vmovups xmm1, xmmword ptr cs:?g_0001@@3Ufloat4@@B.v; float4 const g_0001
        vmovups xmmword ptr [rbx+67F0h], xmm1
      }
      _RBX->viewSpring.isInitialized = 1;
      __asm
      {
        vmovups ymmword ptr [rbx+6820h], ymm2
        vmovups ymmword ptr [rbx+6840h], ymm2
      }
      *(_QWORD *)&_RBX->viewmodelSpring.motionIndexBlendDuration = 0i64;
      __asm
      {
        vmovups xmmword ptr [rbx+6860h], xmm12
        vmovups ymmword ptr [rbx+6870h], ymm2
        vmovups ymmword ptr [rbx+6890h], ymm2
        vmovups xmmword ptr [rbx+68B0h], xmm2
      }
      _RBX->viewmodelSpring.isLockingSpring = 0;
      *(_QWORD *)&_RBX->viewmodelSpring.motionIndex = 31i64;
      __asm
      {
        vmovups xmm0, xmmword ptr cs:?g_1000@@3Ufloat4@@B.v; float4 const g_1000
        vmovups xmmword ptr [rbx+68C0h], xmm0
        vmovups xmm1, xmmword ptr cs:?g_0100@@3Ufloat4@@B.v; float4 const g_0100
        vmovups xmmword ptr [rbx+68D0h], xmm1
        vmovups xmm0, xmmword ptr cs:?g_0010@@3Ufloat4@@B.v; float4 const g_0010
        vmovups xmmword ptr [rbx+68E0h], xmm0
        vmovups xmm1, xmmword ptr cs:?g_0001@@3Ufloat4@@B.v; float4 const g_0001
        vmovups xmmword ptr [rbx+68F0h], xmm1
      }
      _RBX->viewmodelSpring.isInitialized = 1;
    }
    else
    {
      __asm
      {
        vmovaps [rsp+110h+var_30], xmm6
        vmovaps [rsp+110h+var_40], xmm7
        vmovaps [rsp+110h+var_50], xmm8
        vmovaps [rsp+110h+var_60], xmm9
        vmovaps [rsp+110h+var_70], xmm10
        vmovaps [rsp+110h+var_80], xmm11
      }
      CG_ViewMotion_CheckSpringTeleport(_RBX, &curPsOrigin, &_RBX->viewSpring);
      CG_ViewMotion_CheckSpringTeleport(_RBX, &curPsOrigin, &_RBX->viewmodelSpring);
      CG_ViewMotion_UpdateSpringControls(_RBX, 1, &_RBX->viewSpring);
      CG_ViewMotion_UpdateSpringControls(_RBX, 0, &_RBX->viewmodelSpring);
      if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 168, ASSERT_TYPE_ASSERT, "( cgameGlob ) != ( nullptr )", "%s != %s\n\t%p, %p", "cgameGlob", "nullptr", NULL, NULL) )
        __debugbreak();
      __asm { vxorps  xmm0, xmm0, xmm0 }
      if ( BG_IsPlayerLinked(&_RBX->predictedPlayerState) )
      {
        __asm
        {
          vcvtsi2ss xmm0, xmm0, dword ptr [rbx+65E4h]
          vmulss  xmm3, xmm0, cs:__real@3a83126f
          vcvtss2sd xmm1, xmm3, xmm3
          vcomisd xmm1, cs:__real@3eb0c6f7a0b5ed8d
          vmovss  xmm0, cs:__real@3f800000
          vsubps  xmm2, xmm12, xmmword ptr [rbx+6760h]
          vdivss  xmm1, xmm0, xmm3
          vshufps xmm1, xmm1, xmm1, 0
          vmulps  xmm10, xmm2, xmm1
        }
      }
      else
      {
        __asm
        {
          vmovss  xmm1, dword ptr [rbx+44h]
          vcvtsi2ss xmm0, xmm0, cs:?cls@@3UClStatic@@A.frametime; ClStatic cls
          vmulss  xmm3, xmm0, cs:__real@3a83126f
        }
        curPsOrigin.v.m128_i32[3] = 0;
        __asm
        {
          vmovups xmm10, xmmword ptr [rbp+57h+curPsOrigin.v]
          vmovss  xmm10, xmm10, xmm1
          vinsertps xmm10, xmm10, dword ptr [rbx+48h], 10h
          vinsertps xmm10, xmm10, dword ptr [rbx+4Ch], 20h ; ' '
          vmovups xmmword ptr [rbp+57h+curPsOrigin.v], xmm10
        }
      }
      __asm
      {
        vmovss  xmm0, dword ptr [rbx+1E0h]
        vmovups xmm6, xmmword ptr cs:?g_0001@@3Ufloat4@@B.v; float4 const g_0001
        vmovaps xmm11, xmm3
      }
      curPsOrigin.v.m128_i32[3] = 0;
      __asm
      {
        vmovups xmm3, xmmword ptr [rbp+57h+curPsOrigin.v]
        vmovss  xmm3, xmm3, xmm0
        vinsertps xmm3, xmm3, dword ptr [rbx+1E4h], 10h
        vinsertps xmm3, xmm3, dword ptr [rbx+1E8h], 20h ; ' '
        vmulps  xmm0, xmm3, xmmword ptr cs:?g_degreeToRadian@@3Ufloat4@@B.v; float4 const g_degreeToRadian
        vshufps xmm11, xmm11, xmm11, 0
        vmovups xmmword ptr [rbp+57h+frametime4.v], xmm11
        vmovups xmmword ptr [rbp+57h+curPsOrigin.v], xmm3
      }
      Float4RadianToQuat(v19, v18);
      Float4UnitQuatToAxis(v43, v42);
      __asm
      {
        vshufps xmm4, xmm0, xmm1, 44h ; 'D'
        vshufps xmm1, xmm0, xmm1, 0EEh ; 'î'
        vshufps xmm3, xmm2, xmm6, 44h ; 'D'
        vshufps xmm0, xmm2, xmm6, 0EEh ; 'î'
        vshufps xmm6, xmm1, xmm0, 0DDh ; 'Ý'
        vshufps xmm2, xmm4, xmm3, 88h ; ''
        vshufps xmm7, xmm10, xmm10, 0
        vshufps xmm8, xmm10, xmm10, 55h ; 'U'
        vshufps xmm9, xmm10, xmm10, 0AAh ; 'ª'
        vshufps xmm5, xmm4, xmm3, 0DDh ; 'Ý'
        vshufps xmm4, xmm1, xmm0, 88h ; ''
        vmulps  xmm0, xmm7, xmm2
        vaddps  xmm2, xmm0, xmmword ptr cs:?g_negativeZero@@3Ufloat4@@B.v; float4 const g_negativeZero
        vmovaps xmm7, [rsp+110h+var_40]
        vmulps  xmm0, xmm8, xmm5
        vaddps  xmm3, xmm0, xmmword ptr cs:?g_negativeZero@@3Ufloat4@@B.v; float4 const g_negativeZero
        vmovaps xmm8, [rsp+110h+var_50]
        vmulps  xmm1, xmm9, xmm4
        vmovaps xmm9, [rsp+110h+var_60]
        vshufps xmm10, xmm10, xmm10, 0FFh
        vmulps  xmm0, xmm10, xmm6
        vmovaps xmm10, [rsp+110h+var_70]
        vmovaps xmm6, [rsp+110h+var_30]
        vaddps  xmm2, xmm1, xmm2
        vaddps  xmm1, xmm0, xmm3
        vcvtss2sd xmm0, xmm11, xmm11
        vcomisd xmm0, cs:__real@3eb0c6f7a0b5ed8d
        vmovaps xmm11, [rsp+110h+var_80]
        vaddps  xmm2, xmm1, xmm2
        vmovups xmmword ptr [rbp+57h+curPsOrigin.v], xmm2
      }
      if ( !(v72 | v73) )
      {
        CG_ViewMotion_IntegrateSpring(_RBX->time, &frametime4, &curPsOrigin, &_RBX->viewSpring);
        CG_ViewMotion_IntegrateSpring(_RBX->time, &frametime4, &curPsOrigin, &_RBX->viewmodelSpring);
      }
      __asm
      {
        vmovups xmmword ptr [rbx+6760h], xmm12
        vmovups xmmword ptr [rbx+6860h], xmm12
      }
    }
    __asm { vmovaps xmm12, [rsp+110h+var_90] }
  }
}

/*
==============
CG_ViewMotion_UpdateSpringControls
==============
*/
void CG_ViewMotion_UpdateSpringControls(const cg_t *const cgameGlob, bool isCameraSpring, ViewMotionSpring *spring)
{
  int integer; 
  __int64 localClientNum; 
  CinematicMotionDef *CinematicMotionDef; 
  __int64 v19; 
  const CinematicMotionDef *v20; 
  unsigned int cinematicMotionOverride; 
  unsigned int motionIndex; 
  const dvar_t *v23; 
  bool v28; 
  int v83; 
  int time; 
  __int64 v134; 
  __int64 v135; 
  __int128 v139; 
  __int128 v140; 
  __int128 v141; 
  __int128 v142; 
  __int128 v143; 
  __int128 v144; 
  __int128 v145; 
  __int128 v146; 
  __int128 v147; 
  __int128 v148; 
  __int128 v149; 
  __int128 v150; 
  char v151; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm6
    vmovaps xmmword ptr [rax-48h], xmm7
    vmovaps xmmword ptr [rax-58h], xmm8
    vmovaps xmmword ptr [rax-68h], xmm9
    vmovaps xmmword ptr [rax-78h], xmm10
    vmovaps xmmword ptr [rax-88h], xmm11
    vmovaps xmmword ptr [rax-98h], xmm12
    vmovaps xmmword ptr [rax-0A8h], xmm13
  }
  integer = 0;
  _RSI = spring;
  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 227, ASSERT_TYPE_ASSERT, "( cgameGlob ) != ( nullptr )", "%s != %s\n\t%p, %p", "cgameGlob", "nullptr", NULL, NULL) )
    __debugbreak();
  localClientNum = cgameGlob->localClientNum;
  if ( !CgWeaponMap::ms_instance[localClientNum] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  CinematicMotionDef = (CinematicMotionDef *)BG_Suit_GetCinematicMotionDef(&cgameGlob->predictedPlayerState, CgWeaponMap::ms_instance[localClientNum]);
  _RDI = CinematicMotionDef;
  if ( CinematicMotionDef )
  {
    v19 = 0i64;
    while ( s_cgCinematicMotionDefs[v19] != CinematicMotionDef )
    {
      if ( (unsigned __int64)++v19 >= 0x20 )
        goto LABEL_11;
    }
  }
  else
  {
LABEL_11:
    LODWORD(v19) = 31;
  }
  v20 = CG_Skydive_GetCinematicMotionDef((const LocalClientNum_t)cgameGlob->localClientNum, &cgameGlob->predictedPlayerState);
  if ( v20 )
  {
    if ( _RDI )
    {
      v19 = 0i64;
      while ( s_cgCinematicMotionDefs[v19] != _RDI )
      {
        if ( (unsigned __int64)++v19 >= 0x20 )
        {
          LODWORD(v19) = 31;
          _RDI = (CinematicMotionDef *)v20;
          goto LABEL_25;
        }
      }
      _RDI = (CinematicMotionDef *)v20;
    }
    else
    {
      LODWORD(v19) = 31;
      _RDI = (CinematicMotionDef *)v20;
    }
  }
  else
  {
    cinematicMotionOverride = cgameGlob->predictedPlayerState.cinematicMotionOverride;
    if ( cinematicMotionOverride != 31 )
    {
      v19 = cinematicMotionOverride;
      if ( cinematicMotionOverride >= 0x20 )
      {
        LODWORD(v135) = 32;
        LODWORD(v134) = cgameGlob->predictedPlayerState.cinematicMotionOverride;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 244, ASSERT_TYPE_ASSERT, "(unsigned)( motionIndex ) < (unsigned)( ( sizeof( *array_counter( s_cgCinematicMotionDefs ) ) + 0 ) )", "motionIndex doesn't index ARRAY_COUNT( s_cgCinematicMotionDefs )\n\t%i not in [0, %i)", v134, v135) )
          __debugbreak();
      }
      _RDI = s_cgCinematicMotionDefs[v19];
    }
  }
LABEL_25:
  if ( (_DWORD)v19 != 31 && !s_cgCinematicMotionDefsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 251, ASSERT_TYPE_ASSERT, "(s_cgCinematicMotionDefsInitialized)", "%s\n\tAttempting to locate a Cinematic Motion asset def by index, but NetConstStrings have not yet been processed for this asset.", "s_cgCinematicMotionDefsInitialized") )
    __debugbreak();
  motionIndex = _RSI->motionIndex;
  if ( (_DWORD)v19 != motionIndex )
  {
    _RSI->motionIndex = v19;
    _RSI->motionIndexBlendTime = cgameGlob->time;
    if ( motionIndex != 31 )
    {
      v23 = DCONST_DVARMPINT_cg_viewmotion_spring_blendDurationMs;
      if ( !DCONST_DVARMPINT_cg_viewmotion_spring_blendDurationMs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmotion_spring_blendDurationMs") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v23);
      integer = v23->current.integer;
    }
    _RSI->motionIndexBlendDuration = integer;
  }
  __asm
  {
    vmovdqa xmm11, xmmword ptr cs:?g_1000@@3Ufloat4@@B.v; float4 const g_1000
    vmovdqa xmm12, xmmword ptr cs:?g_0100@@3Ufloat4@@B.v; float4 const g_0100
    vmovdqa xmm13, xmmword ptr cs:?g_0010@@3Ufloat4@@B.v; float4 const g_0010
    vmovups xmm0, xmmword ptr cs:?g_0001@@3Ufloat4@@B.v; float4 const g_0001
  }
  v28 = 0;
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vxorps  xmm7, xmm7, xmm7
    vxorps  xmm8, xmm8, xmm8
    vxorps  xmm9, xmm9, xmm9
    vxorps  xmm10, xmm10, xmm10
    vmovups xmmword ptr [rsp+168h+var_108], xmm11
    vmovups xmmword ptr [rsp+168h+var_108+10h], xmm12
    vmovups xmmword ptr [rsp+168h+var_E8], xmm13
    vmovdqa xmmword ptr [rsp+168h+var_E8+10h], xmm0
  }
  if ( _RDI )
  {
    HIDWORD(v139) = 0;
    __asm { vmovups xmm6, xmmword ptr [rsp+0A0h] }
    if ( isCameraSpring )
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rdi+8]
        vmovss  xmm6, xmm6, xmm0
        vmovss  xmm0, dword ptr [rdi+14h]
        vinsertps xmm6, xmm6, dword ptr [rdi+0Ch], 10h
        vinsertps xmm6, xmm6, dword ptr [rdi+10h], 20h ; ' '
        vmovups xmmword ptr [rsp+0A0h], xmm6
      }
      HIDWORD(v140) = 0;
      __asm
      {
        vmovups xmm7, xmmword ptr [rsp+0A0h]
        vmovss  xmm7, xmm7, xmm0
        vmovss  xmm0, dword ptr [rdi+20h]
        vinsertps xmm7, xmm7, dword ptr [rdi+18h], 10h
        vinsertps xmm7, xmm7, dword ptr [rdi+1Ch], 20h ; ' '
        vmovups xmmword ptr [rsp+0A0h], xmm7
      }
      HIDWORD(v141) = 0;
      __asm
      {
        vmovups xmm8, xmmword ptr [rsp+0A0h]
        vmovss  xmm8, xmm8, xmm0
        vmovss  xmm0, dword ptr [rdi+2Ch]
        vinsertps xmm8, xmm8, dword ptr [rdi+24h], 10h
        vinsertps xmm8, xmm8, dword ptr [rdi+28h], 20h ; ' '
        vmovups xmmword ptr [rsp+0A0h], xmm8
      }
      HIDWORD(v142) = 0;
      __asm
      {
        vmovups xmm9, xmmword ptr [rsp+0A0h]
        vmovss  xmm9, xmm9, xmm0
        vinsertps xmm9, xmm9, dword ptr [rdi+30h], 10h
        vinsertps xmm9, xmm9, dword ptr [rdi+34h], 20h ; ' '
        vmovss  xmm0, dword ptr [rdi+38h]
        vmovups xmmword ptr [rsp+0A0h], xmm9
      }
      HIDWORD(v143) = 0;
      __asm
      {
        vmovups xmm10, xmmword ptr [rsp+0A0h]
        vmovss  xmm10, xmm10, xmm0
        vinsertps xmm10, xmm10, dword ptr [rdi+3Ch], 10h
        vinsertps xmm10, xmm10, dword ptr [rdi+40h], 20h ; ' '
      }
      v28 = !BG_IsPlayerLinked(&cgameGlob->predictedPlayerState);
    }
    else
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rdi+44h]
        vmovss  xmm6, xmm6, xmm0
        vmovss  xmm0, dword ptr [rdi+50h]
        vinsertps xmm6, xmm6, dword ptr [rdi+48h], 10h
        vinsertps xmm6, xmm6, dword ptr [rdi+4Ch], 20h ; ' '
        vmovups xmmword ptr [rsp+0A0h], xmm6
      }
      HIDWORD(v144) = 0;
      v28 = 0;
      __asm
      {
        vmovups xmm7, xmmword ptr [rsp+0A0h]
        vmovss  xmm7, xmm7, xmm0
        vmovss  xmm0, dword ptr [rdi+5Ch]
        vinsertps xmm7, xmm7, dword ptr [rdi+54h], 10h
        vinsertps xmm7, xmm7, dword ptr [rdi+58h], 20h ; ' '
        vmovups xmmword ptr [rsp+0A0h], xmm7
      }
      HIDWORD(v145) = 0;
      __asm
      {
        vmovups xmm8, xmmword ptr [rsp+0A0h]
        vmovss  xmm8, xmm8, xmm0
        vmovss  xmm0, dword ptr [rdi+68h]
        vinsertps xmm8, xmm8, dword ptr [rdi+60h], 10h
        vinsertps xmm8, xmm8, dword ptr [rdi+64h], 20h ; ' '
        vmovups xmmword ptr [rsp+0A0h], xmm8
      }
      HIDWORD(v146) = 0;
      __asm
      {
        vmovups xmm9, xmmword ptr [rsp+0A0h]
        vmovss  xmm9, xmm9, xmm0
        vmovss  xmm0, dword ptr [rdi+74h]
        vinsertps xmm9, xmm9, dword ptr [rdi+6Ch], 10h
        vinsertps xmm9, xmm9, dword ptr [rdi+70h], 20h ; ' '
        vmovups xmmword ptr [rsp+0A0h], xmm9
      }
      HIDWORD(v147) = 0;
      __asm
      {
        vmovups xmm10, xmmword ptr [rsp+0A0h]
        vmovss  xmm10, xmm10, xmm0
        vmovss  xmm0, dword ptr [rdi+80h]
        vinsertps xmm10, xmm10, dword ptr [rdi+78h], 10h
        vinsertps xmm10, xmm10, dword ptr [rdi+7Ch], 20h ; ' '
        vmovups xmmword ptr [rsp+0A0h], xmm10
      }
      HIDWORD(v148) = 0;
      __asm
      {
        vmovups xmm11, xmmword ptr [rsp+0A0h]
        vmovss  xmm11, xmm11, xmm0
        vmovss  xmm0, dword ptr [rdi+8Ch]
        vinsertps xmm11, xmm11, dword ptr [rdi+84h], 10h
        vinsertps xmm11, xmm11, dword ptr [rdi+88h], 20h ; ' '
        vmovups xmmword ptr [rsp+0A0h], xmm11
      }
      HIDWORD(v149) = 0;
      __asm
      {
        vmovups xmm12, xmmword ptr [rsp+0A0h]
        vmovss  xmm12, xmm12, xmm0
        vinsertps xmm12, xmm12, dword ptr [rdi+90h], 10h
        vinsertps xmm12, xmm12, dword ptr [rdi+94h], 20h ; ' '
        vmovss  xmm0, dword ptr [rdi+98h]
        vmovups xmmword ptr [rsp+0A0h], xmm12
      }
      HIDWORD(v150) = 0;
      __asm
      {
        vmovups xmm13, xmmword ptr [rsp+0A0h]
        vmovss  xmm13, xmm13, xmm0
        vinsertps xmm13, xmm13, dword ptr [rdi+9Ch], 10h
        vinsertps xmm13, xmm13, dword ptr [rdi+0A0h], 20h ; ' '
        vmovups xmmword ptr [rsp+168h+var_E8], xmm13
        vmovups xmmword ptr [rsp+168h+var_108], xmm11
        vmovups xmmword ptr [rsp+168h+var_108+10h], xmm12
      }
    }
  }
  v83 = _RSI->motionIndexBlendTime + _RSI->motionIndexBlendDuration;
  time = cgameGlob->time;
  if ( time >= v83 )
  {
    __asm
    {
      vmovups ymm0, [rsp+168h+var_108]
      vmovups ymm1, [rsp+168h+var_E8]
      vmovups ymmword ptr [rsi+0A0h], ymm0
      vmovups ymmword ptr [rsi+0C0h], ymm1
      vmovups xmmword ptr [rsi+50h], xmm6
      vmovups xmmword ptr [rsi+60h], xmm7
      vmovups xmmword ptr [rsi+70h], xmm8
      vmovups xmmword ptr [rsi+80h], xmm9
      vmovups xmmword ptr [rsi+90h], xmm10
    }
  }
  else
  {
    if ( v83 - time > 0 )
    {
      __asm
      {
        vmovss  xmm2, cs:__real@3f800000; max
        vxorps  xmm1, xmm1, xmm1
        vcvtsi2ss xmm1, xmm1, dword ptr [r14+65E4h]
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm0, xmm0, eax
        vdivss  xmm0, xmm1, xmm0; val
        vxorps  xmm1, xmm1, xmm1; min
      }
      *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
    }
    else
    {
      __asm { vmovss  xmm0, cs:__real@3f800000 }
    }
    __asm
    {
      vmovaps xmm3, xmm0
      vsubps  xmm0, xmm6, xmmword ptr [rsi+50h]
      vshufps xmm3, xmm3, xmm3, 0
      vmulps  xmm1, xmm0, xmm3
      vaddps  xmm2, xmm1, xmmword ptr [rsi+50h]
      vsubps  xmm0, xmm7, xmmword ptr [rsi+60h]
      vmovups xmmword ptr [rsi+50h], xmm2
      vmulps  xmm1, xmm0, xmm3
      vaddps  xmm2, xmm1, xmmword ptr [rsi+60h]
      vsubps  xmm0, xmm8, xmmword ptr [rsi+70h]
      vmovups xmmword ptr [rsi+60h], xmm2
      vmulps  xmm1, xmm0, xmm3
      vaddps  xmm2, xmm1, xmmword ptr [rsi+70h]
      vmovups xmmword ptr [rsi+70h], xmm2
      vmovups xmm2, xmmword ptr [rsi+80h]
      vsubps  xmm0, xmm9, xmm2
      vmulps  xmm1, xmm0, xmm3
      vaddps  xmm2, xmm1, xmm2
      vmovups xmmword ptr [rsi+80h], xmm2
      vmovups xmm2, xmmword ptr [rsi+90h]
      vsubps  xmm0, xmm10, xmm2
      vmulps  xmm1, xmm0, xmm3
      vaddps  xmm2, xmm1, xmm2
      vmovups xmmword ptr [rsi+90h], xmm2
      vmovups xmm2, xmmword ptr [rsi+0A0h]
      vsubps  xmm0, xmm11, xmm2
      vmulps  xmm1, xmm0, xmm3
      vaddps  xmm2, xmm1, xmm2
      vmovups xmmword ptr [rsi+0A0h], xmm2
      vmovups xmm2, xmmword ptr [rsi+0B0h]
      vsubps  xmm0, xmm12, xmm2
      vmulps  xmm1, xmm0, xmm3
      vaddps  xmm2, xmm1, xmm2
      vmovups xmmword ptr [rsi+0B0h], xmm2
      vmovups xmm2, xmmword ptr [rsi+0C0h]
      vsubps  xmm0, xmm13, xmm2
      vmulps  xmm1, xmm0, xmm3
      vaddps  xmm2, xmm1, xmm2
      vmovups xmmword ptr [rsi+0C0h], xmm2
    }
  }
  _RSI->isLockingSpring = v28;
  _R11 = &v151;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
    vmovaps xmm13, xmmword ptr [r11-80h]
  }
}

/*
==============
CG_ViewMotion_Validate_Callback
==============
*/
void CG_ViewMotion_Validate_Callback(const unsigned int cinematicMotionDefIndex, const char *cinematicMotionName)
{
  __int64 v2; 
  const char *v3; 
  CinematicMotionDef **v4; 
  __int64 v5; 
  const char *name; 
  signed __int64 v7; 
  int v8; 
  __int64 v9; 
  int v10; 
  int v11; 
  int v12; 
  __int64 v13; 

  v2 = cinematicMotionDefIndex;
  v3 = cinematicMotionName;
  if ( !cinematicMotionName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 507, ASSERT_TYPE_ASSERT, "(cinematicMotionName)", (const char *)&queryFormat, "cinematicMotionName") )
    __debugbreak();
  if ( (unsigned int)v2 >= 0x1F )
  {
    LODWORD(v13) = v2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 508, ASSERT_TYPE_ASSERT, "(unsigned)( cinematicMotionDefIndex ) < (unsigned)( ((1<<5)-1) )", "cinematicMotionDefIndex doesn't index INVALID_CINEMATICMOTION_DEF\n\t%i not in [0, %i)", v13, 31) )
      __debugbreak();
  }
  v4 = &s_cgCinematicMotionDefs[v2];
  if ( !*v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 510, ASSERT_TYPE_ASSERT, "(s_cgCinematicMotionDefs[cinematicMotionDefIndex])", (const char *)&queryFormat, "s_cgCinematicMotionDefs[cinematicMotionDefIndex]") )
    __debugbreak();
  v5 = 0x7FFFFFFFi64;
  name = (*v4)->name;
  if ( !name && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
    __debugbreak();
  if ( !v3 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 213, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
    __debugbreak();
  v7 = name - v3;
  do
  {
    v8 = (unsigned __int8)v3[v7];
    v9 = v5;
    v10 = *(unsigned __int8 *)v3++;
    --v5;
    if ( !v9 )
      break;
    if ( v8 != v10 )
    {
      v11 = v8 + 32;
      if ( (unsigned int)(v8 - 65) > 0x19 )
        v11 = v8;
      v8 = v11;
      v12 = v10 + 32;
      if ( (unsigned int)(v10 - 65) > 0x19 )
        v12 = v10;
      if ( v8 != v12 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 511, ASSERT_TYPE_ASSERT, "(!I_stricmp( s_cgCinematicMotionDefs[cinematicMotionDefIndex]->name, cinematicMotionName ))", "%s\n\tInvalid CinematicMotion asset mapping", "!I_stricmp( s_cgCinematicMotionDefs[cinematicMotionDefIndex]->name, cinematicMotionName )") )
          __debugbreak();
        return;
      }
    }
  }
  while ( v8 );
}

/*
==============
AdvancedSwayDeadzone::DebugDraw
==============
*/
void AdvancedSwayDeadzone::DebugDraw(AdvancedSwayDeadzone *this, const LocalClientNum_t localClientNum, const vec4_t *color)
{
  cg_t *LocalClientGlobals; 
  const dvar_t *v9; 
  vec3_t outOrg; 
  __int64 v55; 
  vec3_t forward; 
  vec3_t center; 
  vec3_t v58; 
  char v59; 
  void *retaddr; 

  _RAX = &retaddr;
  v55 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-28h], xmm6
    vmovaps xmmword ptr [rax-38h], xmm8
    vmovaps xmmword ptr [rax-48h], xmm9
  }
  _RBX = this;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v9 = DCONST_DVARBOOL_advancedSwayDebug;
  if ( !DCONST_DVARBOOL_advancedSwayDebug && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "advancedSwayDebug") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v9);
  if ( v9->current.enabled )
  {
    RefdefView_GetOrg(&LocalClientGlobals->refdef.view, &outOrg);
    AngleVectors(&_RBX->m_prevViewAngles, &forward, NULL, NULL);
    __asm
    {
      vmovss  xmm3, cs:debugDrawDist
      vmulss  xmm1, xmm3, dword ptr [rbp+57h+forward]
      vaddss  xmm1, xmm1, dword ptr [rbp+57h+outOrg]
      vmovss  dword ptr [rbp+57h+center], xmm1
      vmulss  xmm2, xmm3, dword ptr [rbp+57h+forward+4]
      vaddss  xmm1, xmm2, dword ptr [rbp+57h+outOrg+4]
      vmovss  dword ptr [rbp+57h+center+4], xmm1
      vmulss  xmm2, xmm3, dword ptr [rbp+57h+forward+8]
      vaddss  xmm1, xmm2, dword ptr [rbp+57h+outOrg+8]
      vmovss  dword ptr [rbp+57h+center+8], xmm1
      vmovss  xmm9, cs:__real@3f000000
      vmulss  xmm1, xmm9, cs:radius_2; radius
    }
    CG_DebugSphere(&center, *(float *)&_XMM1, &colorWhite, 0, 0);
    __asm
    {
      vmovss  xmm0, dword ptr [rbx+0Ch]
      vaddss  xmm2, xmm0, dword ptr [rbx]
      vmovss  xmm1, dword ptr [rbx+10h]
      vaddss  xmm4, xmm1, dword ptr [rbx+4]
      vmovss  xmm0, dword ptr [rbx+14h]
      vaddss  xmm8, xmm0, dword ptr [rbx+8]
      vmulss  xmm3, xmm2, cs:__real@3b360b61
      vaddss  xmm1, xmm3, xmm9
      vxorps  xmm6, xmm6, xmm6
      vroundss xmm0, xmm6, xmm1, 1
      vsubss  xmm0, xmm3, xmm0
      vmovss  xmm5, cs:__real@43b40000
      vmulss  xmm0, xmm0, xmm5
      vmovss  dword ptr [rbp+57h+center], xmm0
      vmulss  xmm4, xmm4, cs:__real@3b360b61
      vaddss  xmm1, xmm4, xmm9
      vroundss xmm3, xmm6, xmm1, 1
      vsubss  xmm0, xmm4, xmm3
      vmulss  xmm1, xmm0, xmm5
      vmovss  dword ptr [rbp+57h+center+4], xmm1
      vmulss  xmm4, xmm8, cs:__real@3b360b61
      vaddss  xmm2, xmm4, xmm9
      vroundss xmm3, xmm6, xmm2, 1
      vsubss  xmm0, xmm4, xmm3
      vmulss  xmm1, xmm0, xmm5
      vmovss  dword ptr [rbp+57h+center+8], xmm1
    }
    AngleVectors(&center, &forward, NULL, NULL);
    __asm
    {
      vmovss  xmm3, cs:debugDrawDist
      vmulss  xmm1, xmm3, dword ptr [rbp+57h+forward]
      vaddss  xmm2, xmm1, dword ptr [rbp+57h+outOrg]
      vmovss  dword ptr [rbp+57h+var_58], xmm2
      vmulss  xmm1, xmm3, dword ptr [rbp+57h+forward+4]
      vaddss  xmm2, xmm1, dword ptr [rbp+57h+outOrg+4]
      vmovss  dword ptr [rbp+57h+var_58+4], xmm2
      vmulss  xmm1, xmm3, dword ptr [rbp+57h+forward+8]
      vaddss  xmm2, xmm1, dword ptr [rbp+57h+outOrg+8]
      vmovss  dword ptr [rbp+57h+var_58+8], xmm2
      vmovss  xmm1, cs:radius_2; radius
    }
    CG_DebugSphere(&v58, *(float *)&_XMM1, &colorRed, 0, 0);
    DebugDrawRange(&outOrg, &_RBX->m_prevViewAngles, &_RBX->m_deadzoneGoal, &colorOrange);
    DebugDrawRange(&outOrg, &_RBX->m_prevViewAngles, &_RBX->m_deadzone, &colorRed);
    memset(&outOrg, 0, sizeof(outOrg));
  }
  _R11 = &v59;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm8, xmmword ptr [r11-20h]
    vmovaps xmm9, xmmword ptr [r11-30h]
  }
}

/*
==============
AdvancedSwayState::DebugDraw
==============
*/
void AdvancedSwayState::DebugDraw(AdvancedSwayState *this, const LocalClientNum_t localClientNum)
{
  const dvar_t *v15; 
  cg_t *LocalClientGlobals; 
  const dvar_t *v102; 
  const dvar_t *v118; 
  const dvar_t *v152; 
  vec3_t forward; 
  vec3_t center; 
  vec3_t v208; 
  vec3_t angles; 
  vec3_t outOrg; 
  vec3_t v211; 
  vec3_t v212; 
  char v213; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm6
    vmovaps xmmword ptr [rax-48h], xmm7
    vmovaps xmmword ptr [rax-58h], xmm8
    vmovaps xmmword ptr [rax-68h], xmm9
    vmovaps xmmword ptr [rax-78h], xmm10
    vmovaps xmmword ptr [rax-88h], xmm11
    vmovaps xmmword ptr [rax-98h], xmm12
    vmovaps xmmword ptr [rax-0A8h], xmm13
    vmovaps xmmword ptr [rax-0B8h], xmm14
    vmovaps xmmword ptr [rax-0C8h], xmm15
  }
  _RDI = this;
  v15 = DCONST_DVARBOOL_advancedSwayDebug;
  if ( !DCONST_DVARBOOL_advancedSwayDebug && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "advancedSwayDebug") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v15);
  if ( v15->current.enabled )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    __asm { vmovsd  xmm1, qword ptr [rdi+5Ch] }
    outOrg.v[2] = _RDI->m_torsoGoal.m_prevViewAnglesOffset.v[2];
    __asm
    {
      vaddss  xmm2, xmm1, dword ptr [rdi+0FCh]
      vshufps xmm0, xmm1, xmm1, 55h ; 'U'
      vmovsd  qword ptr [rbp+90h+outOrg], xmm1
      vaddss  xmm4, xmm0, dword ptr [rdi+100h]
      vmovss  xmm0, dword ptr [rbp+90h+outOrg+8]
      vaddss  xmm5, xmm0, dword ptr [rdi+104h]
      vmovss  xmm13, cs:__real@3b360b61
      vmulss  xmm3, xmm2, xmm13
      vmovss  xmm11, cs:__real@3f000000
      vaddss  xmm1, xmm3, xmm11
      vxorps  xmm0, xmm0, xmm0
      vmovss  xmm2, xmm0, xmm1
      vxorps  xmm12, xmm12, xmm12
      vroundss xmm0, xmm12, xmm2, 1
      vsubss  xmm0, xmm3, xmm0
      vmovss  xmm14, cs:__real@43b40000
      vmulss  xmm15, xmm0, xmm14
      vmulss  xmm4, xmm4, xmm13
      vaddss  xmm1, xmm4, xmm11
      vxorps  xmm0, xmm0, xmm0
      vmovss  xmm2, xmm0, xmm1
      vroundss xmm3, xmm12, xmm2, 1
      vsubss  xmm0, xmm4, xmm3
      vmulss  xmm10, xmm0, xmm14
      vmovss  [rsp+190h+var_144], xmm10
      vmulss  xmm5, xmm5, xmm13
      vaddss  xmm1, xmm5, xmm11
      vroundss xmm3, xmm12, xmm1, 1
      vsubss  xmm0, xmm5, xmm3
      vmulss  xmm1, xmm0, xmm14
      vmovss  dword ptr [rbp+90h+outOrg+8], xmm1
    }
    if ( _RDI->m_isInitialized )
    {
      __asm { vmovsd  xmm5, qword ptr [rdi+84h] }
      v208.v[2] = _RDI->m_torsoSprings.m_prevSpringOffset.v[2];
      __asm
      {
        vmulss  xmm4, xmm5, xmm13
        vaddss  xmm1, xmm4, xmm11
        vxorps  xmm0, xmm0, xmm0
        vmovss  xmm2, xmm0, xmm1
        vroundss xmm3, xmm12, xmm2, 1
        vsubss  xmm0, xmm4, xmm3
        vmulss  xmm10, xmm0, xmm14
        vshufps xmm1, xmm5, xmm5, 55h ; 'U'
        vmovsd  qword ptr [rsp+190h+var_118], xmm5
        vmulss  xmm4, xmm1, xmm13
        vaddss  xmm2, xmm4, xmm11
        vxorps  xmm0, xmm0, xmm0
        vmovss  xmm1, xmm0, xmm2
        vroundss xmm3, xmm12, xmm1, 1
        vsubss  xmm0, xmm4, xmm3
        vmulss  xmm9, xmm0, xmm14
        vmovaps xmm2, xmm11
        vxorps  xmm1, xmm1, xmm1; min
        vroundss xmm3, xmm12, xmm2, 1
        vmulss  xmm8, xmm3, cs:__real@c3b40000
        vmovsd  xmm0, qword ptr [rdi+0C8h]
      }
      v208.v[2] = _RDI->m_gunSprings.m_prevSpringOffset.v[2];
      __asm
      {
        vshufps xmm7, xmm0, xmm0, 55h ; 'U'
        vmovsd  qword ptr [rsp+190h+var_118], xmm0
        vmulss  xmm6, xmm7, dword ptr [rdi+11Ch]
        vmovss  xmm2, cs:__real@3f800000; max
        vsubss  xmm0, xmm2, dword ptr [rdi+108h]; val
      }
      *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
      __asm
      {
        vmulss  xmm2, xmm10, xmm0
        vmulss  xmm3, xmm9, xmm0
        vmulss  xmm4, xmm8, xmm0
        vmulss  xmm1, xmm0, dword ptr [rsp+190h+var_118]
        vmovss  [rsp+190h+var_150], xmm1
        vmulss  xmm1, xmm7, xmm0
        vmovss  [rsp+190h+var_14C], xmm1
        vmulss  xmm0, xmm6, xmm0
        vmovss  [rsp+190h+var_148], xmm0
        vmovsd  xmm0, qword ptr [rdi+110h]
        vmovsd  qword ptr [rsp+190h+forward], xmm0
      }
      forward.v[2] = _RDI->m_pivotPoint.v[2];
      __asm { vmovss  xmm10, [rsp+190h+var_144] }
    }
    else
    {
      __asm
      {
        vxorps  xmm2, xmm2, xmm2
        vxorps  xmm3, xmm3, xmm3
        vxorps  xmm4, xmm4, xmm4
        vxorps  xmm8, xmm8, xmm8
        vmovss  [rsp+190h+var_150], xmm8
        vxorps  xmm7, xmm7, xmm7
        vmovss  [rsp+190h+var_14C], xmm7
        vmovss  [rsp+190h+var_148], xmm7
        vmovss  dword ptr [rsp+190h+forward], xmm2
        vmovss  dword ptr [rsp+190h+forward+4], xmm2
        vmovss  dword ptr [rsp+190h+forward+8], xmm2
      }
    }
    __asm
    {
      vaddss  xmm0, xmm2, dword ptr [rdi+0F0h]
      vaddss  xmm5, xmm3, dword ptr [rdi+0F4h]
      vaddss  xmm6, xmm4, dword ptr [rdi+0F8h]
      vmulss  xmm4, xmm0, xmm13
      vaddss  xmm1, xmm4, xmm11
      vxorps  xmm0, xmm0, xmm0
      vmovss  xmm2, xmm0, xmm1
      vroundss xmm3, xmm12, xmm2, 1
      vsubss  xmm0, xmm4, xmm3
      vmulss  xmm1, xmm0, xmm14
      vmovss  dword ptr [rbp+90h+angles], xmm1
      vmulss  xmm4, xmm5, xmm13
      vaddss  xmm2, xmm4, xmm11
      vxorps  xmm0, xmm0, xmm0
      vmovss  xmm1, xmm0, xmm2
      vroundss xmm3, xmm12, xmm1, 1
      vsubss  xmm0, xmm4, xmm3
      vmulss  xmm1, xmm0, xmm14
      vmovss  dword ptr [rbp+90h+angles+4], xmm1
      vmulss  xmm4, xmm6, xmm13
      vaddss  xmm2, xmm4, xmm11
      vroundss xmm3, xmm12, xmm2, 1
      vsubss  xmm0, xmm4, xmm3
      vmulss  xmm1, xmm0, xmm14
      vmovss  dword ptr [rbp+90h+angles+8], xmm1
    }
    AdvancedSwayDeadzone::DebugDraw(&_RDI->m_torsoGoal, localClientNum, &colorRed);
    RefdefView_GetOrg(&LocalClientGlobals->refdef.view, &outOrg);
    v102 = DCONST_DVARBOOL_advancedSwayGunTorsoSpringDamperEnabled;
    if ( !DCONST_DVARBOOL_advancedSwayGunTorsoSpringDamperEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "advancedSwayGunTorsoSpringDamperEnabled") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v102);
    __asm
    {
      vmovss  xmm7, dword ptr [rbp+90h+outOrg+8]
      vmovss  xmm8, dword ptr [rbp+90h+outOrg+4]
      vmovss  xmm9, dword ptr [rbp+90h+outOrg]
    }
    if ( v102->current.enabled )
    {
      AngleVectors(&angles, &forward, NULL, NULL);
      __asm
      {
        vmovss  xmm3, cs:debugDrawDist_0
        vmulss  xmm1, xmm3, dword ptr [rsp+190h+forward]
        vaddss  xmm2, xmm1, xmm9
        vmovss  dword ptr [rsp+190h+center], xmm2
        vmulss  xmm1, xmm3, dword ptr [rsp+190h+forward+4]
        vaddss  xmm2, xmm1, xmm8
        vmovss  dword ptr [rsp+190h+center+4], xmm2
        vmulss  xmm1, xmm3, dword ptr [rsp+190h+forward+8]
        vaddss  xmm2, xmm1, xmm7
        vmovss  dword ptr [rsp+190h+center+8], xmm2
        vmovss  xmm1, cs:radius_3; radius
      }
      CG_DebugSphere(&center, *(float *)&_XMM1, &colorOrange, 0, 0);
      __asm
      {
        vmovsd  xmm0, qword ptr [rbp+90h+angles]
        vmovsd  qword ptr [rsp+190h+forward], xmm0
      }
      *(_QWORD *)&forward.y = __PAIR64__(LODWORD(angles.v[2]), HIDWORD(_RT0));
      __asm { vmovss  dword ptr [rsp+190h+forward], xmm15 }
      DebugDrawDisplacementLine(LocalClientGlobals, &forward, &LocalClientGlobals->refdef.view.axis.m[2], &colorOrange);
      __asm
      {
        vmovsd  xmm0, qword ptr [rbp+90h+angles]
        vmovsd  qword ptr [rsp+190h+forward], xmm0
      }
      LODWORD(forward.v[0]) = _RT0;
      forward.v[2] = angles.v[2];
      __asm { vmovss  dword ptr [rsp+190h+forward+4], xmm10 }
      DebugDrawDisplacementLine(LocalClientGlobals, &forward, &LocalClientGlobals->refdef.view.axis.m[1], &colorOrange);
    }
    v118 = DCONST_DVARBOOL_advancedSwayGunDirEnabled;
    if ( !DCONST_DVARBOOL_advancedSwayGunDirEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "advancedSwayGunDirEnabled") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v118);
    if ( v118->current.enabled )
    {
      __asm { vmovsd  xmm1, qword ptr [rdi+0B8h] }
      v208.v[2] = _RDI->m_gunGoal.m_gunAnglesOffset.v[2];
      __asm
      {
        vaddss  xmm2, xmm1, dword ptr [rbp+90h+angles]
        vshufps xmm0, xmm1, xmm1, 55h ; 'U'
        vmovsd  qword ptr [rsp+190h+var_118], xmm1
        vaddss  xmm5, xmm0, dword ptr [rbp+90h+angles+4]
        vmovss  xmm0, dword ptr [rbp+90h+var_118+8]
        vaddss  xmm6, xmm0, dword ptr [rbp+90h+angles+8]
        vmulss  xmm4, xmm2, xmm13
        vaddss  xmm1, xmm4, xmm11
        vxorps  xmm0, xmm0, xmm0
        vmovss  xmm2, xmm0, xmm1
        vroundss xmm3, xmm12, xmm2, 1
        vsubss  xmm0, xmm4, xmm3
        vmulss  xmm1, xmm0, xmm14
        vmovss  dword ptr [rsp+190h+forward], xmm1
        vmulss  xmm4, xmm5, xmm13
        vaddss  xmm2, xmm4, xmm11
        vxorps  xmm0, xmm0, xmm0
        vmovss  xmm1, xmm0, xmm2
        vroundss xmm3, xmm12, xmm1, 1
        vsubss  xmm0, xmm4, xmm3
        vmulss  xmm1, xmm0, xmm14
        vmovss  dword ptr [rsp+190h+forward+4], xmm1
        vmulss  xmm4, xmm6, xmm13
        vaddss  xmm2, xmm4, xmm11
        vroundss xmm3, xmm12, xmm2, 1
        vsubss  xmm0, xmm4, xmm3
        vmulss  xmm1, xmm0, xmm14
        vmovss  dword ptr [rsp+190h+forward+8], xmm1
      }
      AngleVectors(&forward, &center, NULL, NULL);
      __asm
      {
        vmovss  xmm3, cs:debugDrawDist_0
        vmulss  xmm1, xmm3, dword ptr [rsp+190h+center]
        vaddss  xmm2, xmm1, xmm9
        vmovss  dword ptr [rbp+90h+var_E8], xmm2
        vmulss  xmm1, xmm3, dword ptr [rsp+190h+center+4]
        vaddss  xmm2, xmm1, xmm8
        vmovss  dword ptr [rbp+90h+var_E8+4], xmm2
        vmulss  xmm1, xmm3, dword ptr [rsp+190h+center+8]
        vaddss  xmm2, xmm1, xmm7
        vmovss  dword ptr [rbp+90h+var_E8+8], xmm2
        vmovss  xmm1, cs:radius_3; radius
      }
      CG_DebugSphere(&v211, *(float *)&_XMM1, &colorBlue, 0, 0);
      v152 = DCONST_DVARBOOL_advancedSwayGunDirSpringDamperEnabled;
      if ( !DCONST_DVARBOOL_advancedSwayGunDirSpringDamperEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "advancedSwayGunDirSpringDamperEnabled") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v152);
      if ( v152->current.enabled )
      {
        __asm
        {
          vmovss  xmm0, dword ptr [rbp+90h+angles]
          vaddss  xmm2, xmm0, [rsp+190h+var_150]
          vmovss  xmm1, dword ptr [rbp+90h+angles+4]
          vaddss  xmm5, xmm1, [rsp+190h+var_14C]
          vmovss  xmm0, dword ptr [rbp+90h+angles+8]
          vaddss  xmm6, xmm0, [rsp+190h+var_148]
          vmulss  xmm4, xmm2, xmm13
          vaddss  xmm1, xmm4, xmm11
          vroundss xmm3, xmm12, xmm1, 1
          vsubss  xmm0, xmm4, xmm3
          vmulss  xmm1, xmm0, xmm14
          vmovss  dword ptr [rsp+190h+center], xmm1
          vmulss  xmm4, xmm5, xmm13
          vaddss  xmm2, xmm4, xmm11
          vroundss xmm3, xmm12, xmm2, 1
          vsubss  xmm0, xmm4, xmm3
          vmulss  xmm1, xmm0, xmm14
          vmovss  dword ptr [rsp+190h+center+4], xmm1
          vmulss  xmm4, xmm6, xmm13
          vaddss  xmm2, xmm4, xmm11
          vroundss xmm3, xmm12, xmm2, 1
          vsubss  xmm0, xmm4, xmm3
          vmulss  xmm1, xmm0, xmm14
          vmovss  dword ptr [rsp+190h+center+8], xmm1
        }
        AngleVectors(&center, &v211, NULL, NULL);
        __asm
        {
          vmovss  xmm3, cs:debugDrawDist_0
          vmulss  xmm1, xmm3, dword ptr [rbp+90h+var_E8]
          vaddss  xmm2, xmm1, xmm9
          vmovss  dword ptr [rbp+90h+var_D8], xmm2
          vmulss  xmm1, xmm3, dword ptr [rbp+90h+var_E8+4]
          vaddss  xmm2, xmm1, xmm8
          vmovss  dword ptr [rbp+90h+var_D8+4], xmm2
          vmulss  xmm1, xmm3, dword ptr [rbp+90h+var_E8+8]
          vaddss  xmm2, xmm1, xmm7
          vmovss  dword ptr [rbp+90h+var_D8+8], xmm2
          vmovss  xmm1, cs:radius_3; radius
        }
        CG_DebugSphere(&v212, *(float *)&_XMM1, &colorCyan, 0, 0);
        __asm
        {
          vmovsd  xmm0, qword ptr [rsp+190h+center]
          vmovsd  qword ptr [rsp+190h+var_118], xmm0
        }
        *(_QWORD *)&v208.y = __PAIR64__(LODWORD(center.v[2]), HIDWORD(_RT0));
        __asm
        {
          vmovss  xmm0, dword ptr [rsp+190h+forward]
          vmovss  dword ptr [rsp+190h+var_118], xmm0
        }
        DebugDrawDisplacementLine(LocalClientGlobals, &v208, &LocalClientGlobals->refdef.view.axis.m[2], &colorCyan);
        __asm
        {
          vmovsd  xmm0, qword ptr [rsp+190h+center]
          vmovsd  qword ptr [rsp+190h+var_118], xmm0
        }
        LODWORD(v208.v[0]) = _RT0;
        v208.v[2] = center.v[2];
        __asm
        {
          vmovss  xmm0, dword ptr [rsp+190h+forward+4]
          vmovss  dword ptr [rsp+190h+var_118+4], xmm0
        }
        DebugDrawDisplacementLine(LocalClientGlobals, &v208, &LocalClientGlobals->refdef.view.axis.m[1], &colorCyan);
      }
    }
    memset(&outOrg, 0, sizeof(outOrg));
  }
  _R11 = &v213;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
    vmovaps xmm13, xmmword ptr [r11-80h]
    vmovaps xmm14, xmmword ptr [r11-90h]
    vmovaps xmm15, xmmword ptr [r11-0A0h]
  }
}

/*
==============
DebugDrawDisplacementLine
==============
*/
void DebugDrawDisplacementLine(const cg_t *const cgameGlob, const vec3_t *angles, const vec3_t *drawAxis, const vec4_t *color)
{
  vec3_t outOrg; 
  __int64 v42; 
  vec3_t forward; 
  vec3_t start; 
  vec3_t end; 
  char v46; 
  void *retaddr; 

  _RAX = &retaddr;
  v42 = -2i64;
  __asm
  {
    vmovaps xmmword ptr [rax-28h], xmm6
    vmovaps xmmword ptr [rax-38h], xmm7
    vmovaps xmmword ptr [rax-48h], xmm8
    vmovaps xmmword ptr [rax-58h], xmm9
  }
  if ( dword_1512F37D0 > *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1772i64) )
  {
    j__Init_thread_header(&dword_1512F37D0);
    if ( dword_1512F37D0 == -1 )
    {
      __asm
      {
        vmovss  xmm0, cs:drawHalfAngleDeg
        vmulss  xmm1, xmm0, cs:__real@3c8efa35
        vmovss  cs:drawHalfAngle, xmm1
      }
      j__Init_thread_footer(&dword_1512F37D0);
    }
  }
  __asm { vmovss  xmm0, cs:drawHalfAngle; X }
  *(float *)&_XMM0 = tanf_0(*(float *)&_XMM0);
  __asm { vmulss  xmm9, xmm0, cs:drawDist_0 }
  AngleVectors(angles, &forward, NULL, NULL);
  RefdefView_GetOrg(&cgameGlob->refdef.view, &outOrg);
  __asm
  {
    vmovss  xmm2, cs:drawDist_0
    vmulss  xmm0, xmm2, dword ptr [rsp+0D8h+forward]
    vaddss  xmm6, xmm0, dword ptr [rsp+0D8h+outOrg]
    vmulss  xmm1, xmm2, dword ptr [rsp+0D8h+forward+4]
    vaddss  xmm7, xmm1, dword ptr [rsp+0D8h+outOrg+4]
    vmulss  xmm0, xmm2, dword ptr [rsp+0D8h+forward+8]
    vaddss  xmm8, xmm0, dword ptr [rsp+0D8h+outOrg+8]
    vmulss  xmm1, xmm9, dword ptr [rdi]
    vaddss  xmm0, xmm1, xmm6
    vmovss  dword ptr [rsp+0D8h+start], xmm0
    vmulss  xmm1, xmm9, dword ptr [rdi+4]
    vaddss  xmm0, xmm1, xmm7
    vmovss  dword ptr [rsp+0D8h+start+4], xmm0
    vmulss  xmm1, xmm9, dword ptr [rdi+8]
    vaddss  xmm0, xmm1, xmm8
    vmovss  dword ptr [rsp+0D8h+start+8], xmm0
    vxorps  xmm3, xmm9, cs:__xmm@80000000800000008000000080000000
    vmulss  xmm1, xmm3, dword ptr [rdi]
    vaddss  xmm0, xmm1, xmm6
    vmovss  dword ptr [rsp+0D8h+end], xmm0
    vmulss  xmm2, xmm3, dword ptr [rdi+4]
    vaddss  xmm1, xmm2, xmm7
    vmovss  dword ptr [rsp+0D8h+end+4], xmm1
    vmulss  xmm0, xmm3, dword ptr [rdi+8]
    vaddss  xmm2, xmm0, xmm8
    vmovss  dword ptr [rsp+0D8h+end+8], xmm2
  }
  CG_DebugLine(&start, &end, color, 0, 0);
  memset(&outOrg, 0, sizeof(outOrg));
  _R11 = &v46;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
  }
}

/*
==============
DebugDrawRange
==============
*/
void DebugDrawRange(const vec3_t *viewOrigin, const vec3_t *viewAngles, const vec2_t *angleRange, const vec4_t *color)
{
  char *v23; 
  unsigned int v24; 
  vec3_t end; 
  vec3_t start; 
  tmat33_t<vec3_t> axis; 
  __m256i v76; 
  char v77; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-28h], xmm6
    vmovaps xmmword ptr [rax-38h], xmm7
    vmovaps xmmword ptr [rax-48h], xmm8
    vmovaps xmmword ptr [rax-58h], xmm9
    vmovaps xmmword ptr [rax-68h], xmm10
    vmovaps xmmword ptr [rax-78h], xmm11
    vmovaps xmmword ptr [rax-88h], xmm12
    vmovaps xmmword ptr [rax-98h], xmm13
    vmovaps xmmword ptr [rax-0A8h], xmm14
    vmovaps xmmword ptr [rax-0B8h], xmm15
    vmovss  xmm7, cs:__real@3c8efa35
    vmulss  xmm0, xmm7, dword ptr [r8]; X
  }
  *(float *)&_XMM0 = tanf_0(*(float *)&_XMM0);
  __asm
  {
    vmulss  xmm15, xmm0, cs:drawDist
    vmulss  xmm0, xmm7, dword ptr [rbx+4]; X
  }
  *(float *)&_XMM0 = tanf_0(*(float *)&_XMM0);
  __asm
  {
    vmulss  xmm6, xmm0, cs:drawDist
    vmovups ymm1, cs:__ymm@3f800000bf800000bf800000bf800000bf8000003f8000003f8000003f800000
    vmovss  [rsp+168h+var_138], xmm6
    vmovups [rsp+168h+var_E8], ymm1
  }
  AnglesToAxis(viewAngles, &axis);
  v23 = &v76.m256i_i8[4];
  v24 = 0;
  do
  {
    __asm
    {
      vmovss  xmm3, cs:drawDist
      vmulss  xmm1, xmm3, dword ptr [rsp+168h+axis]
      vaddss  xmm12, xmm1, dword ptr [rsi]
      vmulss  xmm0, xmm3, dword ptr [rsp+168h+axis+4]
      vaddss  xmm13, xmm0, dword ptr [rsi+4]
      vmulss  xmm2, xmm3, dword ptr [rsp+168h+axis+8]
      vaddss  xmm14, xmm2, dword ptr [rsi+8]
      vmulss  xmm3, xmm6, dword ptr [rbx-4]
      vmulss  xmm0, xmm3, dword ptr [rsp+168h+axis+0Ch]
      vmulss  xmm4, xmm15, dword ptr [rbx]
      vmulss  xmm1, xmm4, dword ptr [rsp+168h+axis+18h]
      vaddss  xmm2, xmm0, xmm12
      vaddss  xmm0, xmm2, xmm1
      vmulss  xmm1, xmm3, dword ptr [rsp+168h+axis+10h]
      vmovss  dword ptr [rsp+168h+start], xmm0
      vmulss  xmm0, xmm4, dword ptr [rsp+168h+axis+1Ch]
      vaddss  xmm2, xmm1, xmm13
      vaddss  xmm1, xmm2, xmm0
      vmulss  xmm0, xmm3, dword ptr [rsp+168h+axis+14h]
      vaddss  xmm2, xmm0, xmm14
      vmovss  dword ptr [rsp+168h+start+4], xmm1
      vmulss  xmm1, xmm4, dword ptr [rsp+168h+axis+20h]
      vaddss  xmm0, xmm2, xmm1
      vmovss  dword ptr [rsp+168h+start+8], xmm0
      vmovss  xmm0, [rsp+168h+var_138]
    }
    ++v24;
    __asm
    {
      vmulss  xmm4, xmm0, dword ptr [rsp+rax*8+168h+var_E8]
      vmulss  xmm5, xmm15, dword ptr [rsp+rax*8+168h+var_E8+4]
      vmulss  xmm0, xmm4, dword ptr [rsp+168h+axis+0Ch]
      vmulss  xmm1, xmm5, dword ptr [rsp+168h+axis+18h]
      vaddss  xmm2, xmm0, xmm12
      vmulss  xmm0, xmm4, dword ptr [rsp+168h+axis+10h]
      vaddss  xmm2, xmm2, xmm1
      vmulss  xmm1, xmm5, dword ptr [rsp+168h+axis+1Ch]
      vaddss  xmm3, xmm0, xmm13
      vmulss  xmm0, xmm4, dword ptr [rsp+168h+axis+14h]
      vmovss  dword ptr [rsp+168h+end], xmm2
      vaddss  xmm2, xmm3, xmm1
      vmulss  xmm1, xmm5, dword ptr [rsp+168h+axis+20h]
      vaddss  xmm3, xmm0, xmm14
      vmovss  dword ptr [rsp+168h+end+4], xmm2
      vaddss  xmm2, xmm3, xmm1
      vmovss  dword ptr [rsp+168h+end+8], xmm2
    }
    CG_DebugLine(&start, &end, color, 0, 0);
    v23 += 8;
    __asm { vmovss  xmm6, [rsp+168h+var_138] }
  }
  while ( v24 < 4 );
  _R11 = &v77;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
    vmovaps xmm13, xmmword ptr [r11-80h]
    vmovaps xmm14, xmmword ptr [r11-90h]
    vmovaps xmm15, xmmword ptr [r11-0A0h]
  }
}

/*
==============
AdvancedSwayDeadzone::DebugDrawText
==============
*/
void AdvancedSwayDeadzone::DebugDrawText(AdvancedSwayDeadzone *this, const LocalClientNum_t localClientNum, DebugDrawState *debugDraw)
{
  bool m_isAlternate; 
  cg_t *LocalClientGlobals; 
  CgWeaponMap *Instance; 
  cg_t *v10; 
  const dvar_t *v11; 
  const ScreenPlacement *ActivePlacement; 
  const ScreenPlacement *v14; 
  GfxFont *FontHandle; 
  RumbleGraph *torsoGoalViewSpeedToMaxDeadzone_graph; 
  float outSwaySettings; 
  SwaySettings *outSwaySettingsa; 
  float outSwaySettingsb; 
  float y; 
  float ya; 
  double yb; 
  float yc; 
  double horzAlign; 
  int vertAlign; 
  double vertAligna; 
  float color1; 
  vec4_t *color1a; 
  float color1b; 
  SwaySettings v67; 
  char dest[6144]; 

  _R14 = debugDraw;
  _RBP = this;
  if ( this->m_isInitialized )
  {
    m_isAlternate = debugDraw->m_isAlternate;
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    Instance = CgWeaponMap::GetInstance(localClientNum);
    BG_GetSwaySettings(Instance, &LocalClientGlobals->predictedPlayerState, &_R14->m_weapon, m_isAlternate, &v67);
    v10 = CG_GetLocalClientGlobals(localClientNum);
    if ( !BG_ProceduralGunMotionDisabled(&v10->predictedPlayerState) )
    {
      v11 = DCONST_DVARBOOL_advancedSwayEnabled;
      if ( !DCONST_DVARBOOL_advancedSwayEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "advancedSwayEnabled") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v11);
      if ( v11->current.enabled && v67.adv.enabled )
      {
        __asm { vmovaps [rsp+19A8h+var_38], xmm8 }
        memset_0(dest, 0, sizeof(dest));
        ActivePlacement = ScrPlace_GetActivePlacement((const LocalClientNum_t)_R14->m_localClientNum);
        __asm { vmovss  xmm2, cs:VMMOTION_DEBUG_FONT_SCALE; scale }
        v14 = ActivePlacement;
        FontHandle = UI_GetFontHandle(ActivePlacement, VMMOTION_DEBUG_FONT_TYPE, *(float *)&_XMM2);
        Com_sprintf(dest, 0x1800ui64, "^7=== TORSO DEADZONE ===\n");
        __asm
        {
          vmovss  xmm0, cs:VMMOTION_DEBUG_FONT_SCALE
          vmovss  xmm1, dword ptr [r14+4]
          vmovss  dword ptr [rsp+19A8h+color1], xmm0
          vmovss  xmm0, dword ptr [r14+8]
          vmovss  [rsp+19A8h+y], xmm0
          vmovss  dword ptr [rsp+19A8h+outSwaySettings], xmm1
        }
        UI_DrawText(v14, dest, 6144, FontHandle, outSwaySettings, y, 2, 2, color1, &colorWhite, 3);
        __asm
        {
          vmovss  xmm0, dword ptr [r14+8]
          vaddss  xmm1, xmm0, cs:__real@41400000
          vmovss  xmm2, cs:__real@3f800000; max
        }
        torsoGoalViewSpeedToMaxDeadzone_graph = v67.adv.torsoGoalViewSpeedToMaxDeadzone_graph;
        __asm
        {
          vmovss  dword ptr [r14+8], xmm1
          vmovss  xmm0, dword ptr [rbp+18h]
          vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
          vdivss  xmm0, xmm0, dword ptr [rsp+19A8h+var_1948.adv.torsoGoalViewSpeedToMaxDeadzone_viewspeed]; val
          vxorps  xmm1, xmm1, xmm1; min
        }
        *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
        __asm
        {
          vmovss  xmm3, dword ptr [rbp+1Ch]
          vandps  xmm3, xmm3, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
          vmovss  xmm2, cs:__real@3f800000; max
          vmovaps xmm8, xmm0
          vdivss  xmm0, xmm3, dword ptr [rsp+19A8h+var_1948.adv.torsoGoalViewSpeedToMaxDeadzone_viewspeed+4]; val
          vxorps  xmm1, xmm1, xmm1; min
        }
        *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
        __asm
        {
          vmovss  xmm2, dword ptr [r14+8]; drawY
          vmovss  xmm1, dword ptr [r14+4]; drawX
          vmovss  [rsp+19A8h+vertAlign], xmm0
          vmovss  [rsp+19A8h+y], xmm8
        }
        CG_ViewMotion_DebugDrawGraph(v14, *(float *)&_XMM1, *(float *)&_XMM2, torsoGoalViewSpeedToMaxDeadzone_graph, &colorRed, ya, &colorGreen, *(float *)&vertAlign, &colorPurple);
        __asm
        {
          vmovss  xmm0, cs:textOffsetX_0
          vaddss  xmm1, xmm0, dword ptr [r14+4]
          vmovss  dword ptr [r14+4], xmm1
          vmovss  xmm2, dword ptr [rbp+24h]
          vmovss  xmm0, dword ptr [rbp+20h]
          vmovss  xmm1, dword ptr [rbp+30h]
          vmovss  xmm4, dword ptr [rbp+2Ch]
          vmovss  xmm5, dword ptr [rbp+1Ch]
          vmovss  xmm3, dword ptr [rbp+18h]
          vcvtss2sd xmm2, xmm2, xmm2
          vcvtss2sd xmm0, xmm0, xmm0
          vmovsd  [rsp+19A8h+color1], xmm2
          vmovsd  qword ptr [rsp+19A8h+vertAlign], xmm0
          vcvtss2sd xmm1, xmm1, xmm1
          vcvtss2sd xmm4, xmm4, xmm4
          vcvtss2sd xmm5, xmm5, xmm5
          vcvtss2sd xmm3, xmm3, xmm3
          vmovsd  qword ptr [rsp+19A8h+horzAlign], xmm1
          vmovsd  qword ptr [rsp+19A8h+y], xmm4
          vmovq   r9, xmm3
          vmovsd  [rsp+19A8h+outSwaySettings], xmm5
        }
        Com_sprintf(dest, 0x1800ui64, "^7IN View Speed: (^2%.0f^7, ^6%.0f^7)\n^7OUT Deadzone Goal: (^2%.1f^7, ^6%.1f^7)\n^7Deadzone Current: (^2%.1f^7, ^6%.1f^7)\n", *(double *)&_XMM3, *(double *)&outSwaySettingsa, yb, horzAlign, vertAligna, *(double *)&color1a);
        __asm
        {
          vmovss  xmm0, cs:VMMOTION_DEBUG_FONT_SCALE
          vmovss  xmm1, dword ptr [r14+4]
          vmovss  dword ptr [rsp+19A8h+color1], xmm0
          vmovss  xmm0, dword ptr [r14+8]
          vmovss  [rsp+19A8h+y], xmm0
          vmovss  dword ptr [rsp+19A8h+outSwaySettings], xmm1
        }
        UI_DrawText(v14, dest, 6144, FontHandle, outSwaySettingsb, yc, 2, 2, color1b, &colorWhite, 3);
        __asm { vmovaps xmm8, [rsp+19A8h+var_38] }
      }
    }
  }
}

/*
==============
AdvancedSwayGunDir::DebugDrawText
==============
*/

void __fastcall AdvancedSwayGunDir::DebugDrawText(AdvancedSwayGunDir *this, const LocalClientNum_t localClientNum, double yawToRollScale, DebugDrawState *debugDraw)
{
  signed __int64 v4; 
  void *v7; 
  bool m_isAlternate; 
  cg_t *LocalClientGlobals; 
  CgWeaponMap *Instance; 
  cg_t *v15; 
  const dvar_t *v16; 
  const ScreenPlacement *ActivePlacement; 
  const ScreenPlacement *v19; 
  GfxFont *FontHandle; 
  RumbleGraph *gunGoalViewSpeedToOffset_graph; 
  float outSwaySettings; 
  SwaySettings *outSwaySettingsa; 
  float outSwaySettingsb; 
  float y; 
  float ya; 
  double yb; 
  float yc; 
  double horzAlign; 
  int vertAlign; 
  double vertAligna; 
  float color1; 
  float color1a; 
  SwaySettings v70; 
  char dest[6144]; 

  v7 = alloca(v4);
  __asm { vmovaps [rsp+19C8h+var_58], xmm9 }
  _R14 = debugDraw;
  __asm { vmovaps xmm9, xmm2 }
  _RBP = this;
  if ( this->m_isInitialized )
  {
    m_isAlternate = debugDraw->m_isAlternate;
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    Instance = CgWeaponMap::GetInstance(localClientNum);
    BG_GetSwaySettings(Instance, &LocalClientGlobals->predictedPlayerState, &_R14->m_weapon, m_isAlternate, &v70);
    v15 = CG_GetLocalClientGlobals(localClientNum);
    if ( !BG_ProceduralGunMotionDisabled(&v15->predictedPlayerState) )
    {
      v16 = DCONST_DVARBOOL_advancedSwayEnabled;
      if ( !DCONST_DVARBOOL_advancedSwayEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "advancedSwayEnabled") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v16);
      if ( v16->current.enabled && v70.adv.enabled )
      {
        __asm { vmovaps [rsp+19C8h+var_48], xmm8 }
        memset_0(dest, 0, sizeof(dest));
        ActivePlacement = ScrPlace_GetActivePlacement((const LocalClientNum_t)_R14->m_localClientNum);
        __asm { vmovss  xmm2, cs:VMMOTION_DEBUG_FONT_SCALE; scale }
        v19 = ActivePlacement;
        FontHandle = UI_GetFontHandle(ActivePlacement, VMMOTION_DEBUG_FONT_TYPE, *(float *)&_XMM2);
        Com_sprintf(dest, 0x1800ui64, "^7=== GUN OFFSET ANGLES ===\n");
        __asm
        {
          vmovss  xmm0, cs:VMMOTION_DEBUG_FONT_SCALE
          vmovss  xmm1, dword ptr [r14+4]
          vmovss  dword ptr [rsp+19C8h+color1], xmm0
          vmovss  xmm0, dword ptr [r14+8]
          vmovss  [rsp+19C8h+y], xmm0
          vmovss  dword ptr [rsp+19C8h+outSwaySettings], xmm1
        }
        UI_DrawText(v19, dest, 6144, FontHandle, outSwaySettings, y, 2, 2, color1, &colorWhite, 3);
        __asm
        {
          vmovss  xmm0, dword ptr [r14+8]
          vaddss  xmm1, xmm0, cs:__real@41400000
          vmovss  xmm2, cs:__real@3f800000; max
        }
        gunGoalViewSpeedToOffset_graph = v70.adv.gunGoalViewSpeedToOffset_graph;
        __asm
        {
          vmovss  dword ptr [r14+8], xmm1
          vmovss  xmm0, dword ptr [rbp+0]
          vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
          vdivss  xmm0, xmm0, dword ptr [rsp+19C8h+var_1968.adv.gunGoalViewSpeedToOffset_viewspeed]; val
          vxorps  xmm1, xmm1, xmm1; min
        }
        *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
        __asm
        {
          vmovss  xmm3, dword ptr [rbp+4]
          vandps  xmm3, xmm3, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
          vmovss  xmm2, cs:__real@3f800000; max
          vmovaps xmm8, xmm0
          vdivss  xmm0, xmm3, dword ptr [rsp+19C8h+var_1968.adv.gunGoalViewSpeedToOffset_viewspeed+4]; val
          vxorps  xmm1, xmm1, xmm1; min
        }
        *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
        __asm
        {
          vmovss  xmm2, dword ptr [r14+8]; drawY
          vmovss  xmm1, dword ptr [r14+4]; drawX
          vmovss  [rsp+19C8h+vertAlign], xmm0
          vmovss  [rsp+19C8h+y], xmm8
        }
        CG_ViewMotion_DebugDrawGraph(v19, *(float *)&_XMM1, *(float *)&_XMM2, gunGoalViewSpeedToOffset_graph, &colorBlue, ya, &colorGreen, *(float *)&vertAlign, &colorPurple);
        __asm
        {
          vmovss  xmm0, cs:textOffsetX_1
          vaddss  xmm1, xmm0, dword ptr [r14+4]
          vmovss  dword ptr [r14+4], xmm1
          vmovss  xmm2, dword ptr [rbp+10h]
          vmovss  xmm5, dword ptr [rbp+0Ch]
          vmovss  xmm3, dword ptr [rbp+0]
          vmulss  xmm0, xmm2, xmm9
          vcvtss2sd xmm1, xmm0, xmm0
          vmovss  xmm0, dword ptr [rbp+4]
          vmovsd  qword ptr [rsp+19C8h+vertAlign], xmm1
          vcvtss2sd xmm4, xmm2, xmm2
          vmovsd  qword ptr [rsp+19C8h+horzAlign], xmm4
          vcvtss2sd xmm5, xmm5, xmm5
          vcvtss2sd xmm0, xmm0, xmm0
          vmovsd  qword ptr [rsp+19C8h+y], xmm5
          vmovsd  [rsp+19C8h+outSwaySettings], xmm0
          vcvtss2sd xmm3, xmm3, xmm3
          vmovq   r9, xmm3
        }
        Com_sprintf(dest, 0x1800ui64, "^7IN View Speed: (^2%.0f^7, ^6%.0f^7)\n^7OUT Offset: (^2%.1f^7, ^6%.1f^7, ^5%.1f)\n", *(double *)&_XMM3, *(double *)&outSwaySettingsa, yb, horzAlign, vertAligna);
        __asm
        {
          vmovss  xmm0, cs:VMMOTION_DEBUG_FONT_SCALE
          vmovss  xmm1, dword ptr [r14+4]
          vmovss  dword ptr [rsp+19C8h+color1], xmm0
          vmovss  xmm0, dword ptr [r14+8]
          vmovss  [rsp+19C8h+y], xmm0
          vmovss  dword ptr [rsp+19C8h+outSwaySettings], xmm1
        }
        UI_DrawText(v19, dest, 6144, FontHandle, outSwaySettingsb, yc, 2, 2, color1a, &colorWhite, 3);
        __asm { vmovaps xmm8, [rsp+19C8h+var_48] }
      }
    }
  }
  __asm { vmovaps xmm9, [rsp+19C8h+var_58] }
}

/*
==============
AdvancedSwayState::DebugDrawText
==============
*/
void AdvancedSwayState::DebugDrawText(AdvancedSwayState *this, const LocalClientNum_t localClientNum)
{
  const dvar_t *rbx1; 
  const ScreenPlacement *ActivePlacement; 
  const ScreenPlacement *v8; 
  GfxFont *FontHandle; 
  int v12; 
  GfxFont *v13; 
  bool m_isAlternate; 
  cg_t *LocalClientGlobals; 
  CgWeaponMap *Instance; 
  cg_t *v20; 
  const dvar_t *v21; 
  char *fmt; 
  float fmta; 
  float fmtb; 
  double y; 
  float ya; 
  float yb; 
  double horzAlign; 
  double vertAlign; 
  double v57; 
  float v58; 
  float v59; 
  vec4_t *color; 
  vec3_t v3; 
  DebugDrawState debugDraw; 
  SwaySettings outSwaySettings; 
  char dest[2048]; 

  rbx1 = DCONST_DVARBOOL_advancedSwayDebug;
  _R14 = this;
  if ( !DCONST_DVARBOOL_advancedSwayDebug && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "advancedSwayDebug") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(rbx1);
  if ( rbx1->current.enabled && _R14->m_isInitialized )
  {
    ActivePlacement = ScrPlace_GetActivePlacement(localClientNum);
    __asm { vmovss  xmm2, cs:VMMOTION_DEBUG_FONT_SCALE; scale }
    v8 = ActivePlacement;
    FontHandle = UI_GetFontHandle(ActivePlacement, VMMOTION_DEBUG_FONT_TYPE, *(float *)&_XMM2);
    __asm
    {
      vmovss  xmm0, cs:initialDrawX_0
      vmovss  xmm1, cs:initialDrawY_0
    }
    v12 = *(_DWORD *)&_R14->m_weapon.weaponCamo;
    v13 = FontHandle;
    m_isAlternate = _R14->m_isAlternate;
    __asm
    {
      vmovss  [rsp+0A10h+debugDraw.m_drawX], xmm0
      vmovups ymm0, ymmword ptr [r14+13Ch]
      vmovups ymmword ptr [rsp+0A10h+debugDraw.m_weapon.weaponIdx], ymm0
      vmovsd  xmm0, qword ptr [r14+16Ch]
      vmovss  [rsp+0A10h+debugDraw.m_drawY], xmm1
      vmovups xmm1, xmmword ptr [r14+15Ch]
    }
    *(_DWORD *)&debugDraw.m_weapon.weaponCamo = v12;
    __asm { vmovsd  qword ptr [rbp+910h+debugDraw.m_weapon.attachmentVariationIndices+15h], xmm0 }
    debugDraw.m_localClientNum = localClientNum;
    __asm { vmovups xmmword ptr [rbp+910h+debugDraw.m_weapon.attachmentVariationIndices+5], xmm1 }
    debugDraw.m_isAlternate = m_isAlternate;
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    Instance = CgWeaponMap::GetInstance(localClientNum);
    BG_GetSwaySettings(Instance, &LocalClientGlobals->predictedPlayerState, &_R14->m_weapon, m_isAlternate, &outSwaySettings);
    v20 = CG_GetLocalClientGlobals(localClientNum);
    if ( BG_ProceduralGunMotionDisabled(&v20->predictedPlayerState) )
      goto LABEL_13;
    v21 = DCONST_DVARBOOL_advancedSwayEnabled;
    if ( !DCONST_DVARBOOL_advancedSwayEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "advancedSwayEnabled") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v21);
    if ( v21->current.enabled && outSwaySettings.adv.enabled )
    {
      __asm { vmovaps [rsp+0A10h+var_40], xmm6 }
      AnglesSubtract(&_R14->m_prevViewmodelAnglesSmoothed, &_R14->m_prevViewmodelAngles, &v3);
      __asm
      {
        vmovss  xmm0, dword ptr [r14+10Ch]
        vmovss  xmm1, dword ptr [r14+138h]
        vmovss  xmm2, dword ptr [rsp+0A10h+v3+4]
        vmovss  xmm4, dword ptr [rsp+0A10h+v3]
        vmovss  xmm5, dword ptr [r14+12Ch]
        vmovss  xmm3, dword ptr [r14+134h]
        vmovss  xmm6, dword ptr [r14+128h]
        vcvtss2sd xmm0, xmm0, xmm0
        vmovsd  [rsp+0A10h+color], xmm0
        vcvtss2sd xmm1, xmm1, xmm1
        vmovsd  [rsp+0A10h+var_9D0], xmm1
        vcvtss2sd xmm2, xmm2, xmm2
        vmovsd  qword ptr [rsp+0A10h+vertAlign], xmm2
        vcvtss2sd xmm4, xmm4, xmm4
        vmovsd  qword ptr [rsp+0A10h+horzAlign], xmm4
        vcvtss2sd xmm5, xmm5, xmm5
        vcvtss2sd xmm3, xmm3, xmm3
        vmovsd  qword ptr [rsp+0A10h+y], xmm5
        vcvtss2sd xmm6, xmm6, xmm6
        vmovq   r9, xmm3
        vmovsd  [rsp+0A10h+fmt], xmm6
      }
      Com_sprintf(dest, 0x800ui64, "^7=== ADVANCED SWAY ===\n^7Delta Time: ^5%.4f^7\n^7View Velocity: (^2%.1f^7, ^6%.1f^7)\n^7Smoothing Offset: (^2%.1f^7, ^6%.1f^7)\n^7Fire Fraction: ^5%.2f {%.2f}\n", *(double *)&_XMM3, *(double *)&fmt, y, horzAlign, vertAlign, v57, *(double *)&color);
      __asm
      {
        vmovss  xmm0, cs:VMMOTION_DEBUG_FONT_SCALE
        vmovss  xmm1, [rsp+0A10h+debugDraw.m_drawX]
        vmovss  dword ptr [rsp+0A10h+var_9D0], xmm0
        vmovss  xmm0, [rsp+0A10h+debugDraw.m_drawY]
        vmovss  [rsp+0A10h+y], xmm0
        vmovss  dword ptr [rsp+0A10h+fmt], xmm1
      }
      UI_DrawText(v8, dest, 2048, v13, fmta, ya, 2, 2, v58, &colorWhite, 3);
      __asm
      {
        vmovss  xmm0, [rsp+0A10h+debugDraw.m_drawY]
        vaddss  xmm6, xmm0, cs:offsetY_1
        vmovss  [rsp+0A10h+debugDraw.m_drawY], xmm6
      }
      AdvancedSwayDeadzone::DebugDrawText(&_R14->m_torsoGoal, localClientNum, &debugDraw);
      __asm
      {
        vmovss  xmm0, [rsp+0A10h+debugDraw.m_drawX]
        vaddss  xmm1, xmm0, cs:graphOffsetX
        vmovss  xmm2, dword ptr [r14+11Ch]; yawToRollScale
        vmovss  [rsp+0A10h+debugDraw.m_drawX], xmm1
        vmovss  [rsp+0A10h+debugDraw.m_drawY], xmm6
      }
      AdvancedSwayGunDir::DebugDrawText(&_R14->m_gunGoal, localClientNum, *(float *)&_XMM2, &debugDraw);
      __asm { vmovaps xmm6, [rsp+0A10h+var_40] }
    }
    else
    {
LABEL_13:
      Com_sprintf(dest, 0x800ui64, "^7=== ADVANCED SWAY ===\n^7DISABLED\n");
      __asm
      {
        vmovss  xmm0, cs:VMMOTION_DEBUG_FONT_SCALE
        vmovss  xmm1, [rsp+0A10h+debugDraw.m_drawX]
        vmovss  dword ptr [rsp+0A10h+var_9D0], xmm0
        vmovss  xmm0, [rsp+0A10h+debugDraw.m_drawY]
        vmovss  [rsp+0A10h+y], xmm0
        vmovss  dword ptr [rsp+0A10h+fmt], xmm1
      }
      UI_DrawText(v8, dest, 2048, v13, fmtb, yb, 2, 2, v59, &colorWhite, 3);
    }
  }
}

/*
==============
AdvancedSwayState::GetAngleOffsets
==============
*/
void AdvancedSwayState::GetAngleOffsets(AdvancedSwayState *this, vec3_t *outTorsoAngleOffsets, vec3_t *outGunAngleOffsets, vec3_t *outGunPivotOffset)
{
  _RSI = outGunPivotOffset;
  _RDI = outGunAngleOffsets;
  _RBX = outTorsoAngleOffsets;
  _RBP = this;
  if ( this->m_isInitialized )
  {
    __asm
    {
      vmovsd  xmm0, qword ptr [rcx+84h]
      vmovss  xmm4, cs:__real@3b360b61
      vmovsd  qword ptr [rdx], xmm0
    }
    outTorsoAngleOffsets->v[2] = this->m_torsoSprings.m_prevSpringOffset.v[2];
    __asm
    {
      vmulss  xmm3, xmm4, dword ptr [rdx]
      vmulss  xmm4, xmm4, dword ptr [rdx+4]
      vaddss  xmm1, xmm3, cs:__real@3f000000
      vmovaps [rsp+38h+var_18], xmm7
      vxorps  xmm7, xmm7, xmm7
      vroundss xmm2, xmm7, xmm1, 1
      vsubss  xmm0, xmm3, xmm2
      vmulss  xmm0, xmm0, cs:__real@43b40000
      vaddss  xmm2, xmm4, cs:__real@3f000000
      vmovss  dword ptr [rdx], xmm0
      vroundss xmm3, xmm7, xmm2, 1
      vmovss  xmm2, cs:__real@3f000000
      vsubss  xmm0, xmm4, xmm3
      vmulss  xmm1, xmm0, cs:__real@43b40000
      vmovss  dword ptr [rdx+4], xmm1
      vroundss xmm3, xmm7, xmm2, 1
      vmulss  xmm0, xmm3, cs:__real@c3b40000
      vmovss  xmm2, cs:__real@3f800000; max
      vmovss  dword ptr [rdx+8], xmm0
      vmovsd  xmm0, qword ptr [rcx+0C8h]
      vmovsd  qword ptr [r8], xmm0
    }
    outGunAngleOffsets->v[2] = this->m_gunSprings.m_prevSpringOffset.v[2];
    __asm
    {
      vmovss  xmm0, dword ptr [rcx+11Ch]
      vmulss  xmm1, xmm0, dword ptr [r8+4]
      vmovss  dword ptr [r8+8], xmm1
      vsubss  xmm0, xmm2, dword ptr [rcx+108h]; val
      vxorps  xmm1, xmm1, xmm1; min
    }
    *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
    __asm
    {
      vmulss  xmm1, xmm0, dword ptr [rbx]
      vmulss  xmm2, xmm0, dword ptr [rbx+4]
      vmovaps xmm7, [rsp+38h+var_18]
      vmovss  dword ptr [rbx], xmm1
      vmulss  xmm1, xmm0, dword ptr [rbx+8]
      vmovss  dword ptr [rbx+8], xmm1
      vmovss  dword ptr [rbx+4], xmm2
      vmulss  xmm2, xmm0, dword ptr [rdi]
      vmulss  xmm1, xmm0, dword ptr [rdi+4]
      vmulss  xmm0, xmm0, dword ptr [rdi+8]
      vmovss  dword ptr [rdi+8], xmm0
      vmovss  dword ptr [rdi], xmm2
      vmovss  dword ptr [rdi+4], xmm1
      vmovsd  xmm0, qword ptr [rbp+110h]
      vmovsd  qword ptr [rsi], xmm0
    }
    _RSI->v[2] = _RBP->m_pivotPoint.v[2];
  }
  else
  {
    *(_QWORD *)outTorsoAngleOffsets->v = 0i64;
    outTorsoAngleOffsets->v[2] = 0.0;
    *(_QWORD *)outGunAngleOffsets->v = 0i64;
    outGunAngleOffsets->v[2] = 0.0;
    *(_QWORD *)outGunPivotOffset->v = 0i64;
    outGunPivotOffset->v[2] = 0.0;
  }
}

/*
==============
AdvancedSwayDeadzone::GetAnglesOffset
==============
*/
void AdvancedSwayDeadzone::GetAnglesOffset(AdvancedSwayDeadzone *this, vec3_t *outGoalAnglesOffset)
{
  __asm
  {
    vmovsd  xmm0, qword ptr [rcx+0Ch]
    vmovsd  qword ptr [rdx], xmm0
  }
  outGoalAnglesOffset->v[2] = this->m_prevViewAnglesOffset.v[2];
}

/*
==============
AdvancedSwayGunDir::GetAnglesOffset
==============
*/
void AdvancedSwayGunDir::GetAnglesOffset(AdvancedSwayGunDir *this, vec3_t *outAnglesOffset)
{
  __asm
  {
    vmovsd  xmm0, qword ptr [rcx+0Ch]
    vmovsd  qword ptr [rdx], xmm0
  }
  outAnglesOffset->v[2] = this->m_gunAnglesOffset.v[2];
}

/*
==============
AdvancedSwaySprings::GetAnglesOffset
==============
*/
void AdvancedSwaySprings::GetAnglesOffset(AdvancedSwaySprings *this, vec3_t *outAnglesOffset)
{
  __asm
  {
    vmovsd  xmm0, qword ptr [rcx]
    vmovsd  qword ptr [rdx], xmm0
  }
  outAnglesOffset->v[2] = this->m_prevSpringOffset.v[2];
}

/*
==============
AdvancedSwaySprings::GetAnglesVelocity
==============
*/
void AdvancedSwaySprings::GetAnglesVelocity(AdvancedSwaySprings *this, vec3_t *outAnglesVelocity)
{
  __asm
  {
    vmovsd  xmm0, qword ptr [rcx+0Ch]
    vmovsd  qword ptr [rdx], xmm0
  }
  outAnglesVelocity->v[2] = this->m_prevSpringVelocity.v[2];
}

/*
==============
AdvancedSwayState::GetBlendspaceParams
==============
*/
void AdvancedSwayState::GetBlendspaceParams(AdvancedSwayState *this, vec2_t *outBsParams)
{
  vec2_t v13; 

  __asm
  {
    vmovaps [rsp+58h+var_18], xmm6
    vmovss  xmm2, cs:__real@3f800000; max
    vsubss  xmm0, xmm2, dword ptr [rcx+108h]; val
    vmovsd  xmm6, qword ptr [rcx+84h]
    vxorps  xmm1, xmm1, xmm1; min
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm
  {
    vmovsd  [rsp+58h+var_38], xmm6
    vmulss  xmm1, xmm6, xmm0
    vmulss  xmm0, xmm0, dword ptr [rsp+58h+var_38+4]
    vmovss  dword ptr [rsp+58h+var_38+4], xmm0
    vmovss  dword ptr [rsp+58h+var_38], xmm1
  }
  *outBsParams = v13;
  __asm { vmovaps xmm6, [rsp+58h+var_18] }
}

/*
==============
AdvancedSwayDeadzone::Reset
==============
*/
void AdvancedSwayDeadzone::Reset(AdvancedSwayDeadzone *this)
{
  this->m_isInitialized = 0;
}

/*
==============
AdvancedSwayGunDir::Reset
==============
*/
void AdvancedSwayGunDir::Reset(AdvancedSwayGunDir *this)
{
  this->m_isInitialized = 0;
}

/*
==============
AdvancedSwaySprings::Reset
==============
*/
void AdvancedSwaySprings::Reset(AdvancedSwaySprings *this)
{
  this->m_isInitialized = 0;
}

/*
==============
AngularSmoothing::Reset
==============
*/
void AngularSmoothing::Reset(AngularSmoothing *this)
{
  this->m_initialized = 0;
}

/*
==============
ViewMotionSpring::Reset
==============
*/
void ViewMotionSpring::Reset(ViewMotionSpring *this, const float4 *playerOrigin)
{
  __asm
  {
    vxorps  xmm1, xmm1, xmm1
    vmovups ymmword ptr [rcx], ymm1
    vmovups ymmword ptr [rcx+20h], ymm1
  }
  this->unlockTime = 0;
  __asm
  {
    vmovups xmm0, xmmword ptr [rdx]
    vmovdqu xmmword ptr [rcx+40h], xmm0
    vmovups ymmword ptr [rcx+50h], ymm1
    vmovups ymmword ptr [rcx+70h], ymm1
    vmovups xmmword ptr [rcx+90h], xmm1
  }
  this->isLockingSpring = 0;
  *(_QWORD *)&this->motionIndex = 31i64;
  this->motionIndexBlendDuration = 0;
  __asm
  {
    vmovups xmm0, xmmword ptr cs:?g_1000@@3Ufloat4@@B.v; float4 const g_1000
    vmovups xmmword ptr [rcx+0A0h], xmm0
    vmovups xmm1, xmmword ptr cs:?g_0100@@3Ufloat4@@B.v; float4 const g_0100
    vmovups xmmword ptr [rcx+0B0h], xmm1
    vmovups xmm0, xmmword ptr cs:?g_0010@@3Ufloat4@@B.v; float4 const g_0010
    vmovups xmmword ptr [rcx+0C0h], xmm0
    vmovups xmm1, xmmword ptr cs:?g_0001@@3Ufloat4@@B.v; float4 const g_0001
    vmovups xmmword ptr [rcx+0D0h], xmm1
  }
  this->isInitialized = 1;
}

/*
==============
AdvancedSwayDeadzone::Update
==============
*/

void __fastcall AdvancedSwayDeadzone::Update(AdvancedSwayDeadzone *this, const AdvancedHipSwaySettings *const swayDef, const vec3_t *viewAngles, double frametimeSecScaled, const vec3_t *viewAngleVelocityScaled, float adsFraction, float fireFraction)
{
  bool v17; 
  const vec3_t *v18; 
  AdvancedSwayDeadzone *v22; 
  unsigned int v79; 
  bool v85; 
  bool v86; 
  unsigned int v105; 
  unsigned int v106; 
  bool v108; 
  __int64 v138; 
  __int64 v139; 
  double v140; 
  double v141; 
  double v142; 
  double v143; 
  AdvancedSwayDeadzone *v144; 
  const vec3_t *v145; 
  __int128 v146; 
  vec2_t v147; 
  vec3_t v3; 

  __asm { vmovaps [rsp+168h+var_A8], xmm11 }
  v17 = !this->m_isInitialized;
  v18 = viewAngles;
  _RBX = viewAngleVelocityScaled;
  __asm { vmovaps xmm11, xmm3 }
  v145 = viewAngles;
  v22 = this;
  v144 = this;
  if ( this->m_isInitialized )
  {
    __asm
    {
      vmovaps [rsp+168h+var_58], xmm6
      vmovaps [rsp+168h+var_68], xmm7
      vmovaps [rsp+168h+var_78], xmm8
      vmovaps [rsp+168h+var_88], xmm9
      vmovaps [rsp+168h+var_98], xmm10
      vmovaps [rsp+168h+var_B8], xmm12
      vxorps  xmm9, xmm9, xmm9
      vcomiss xmm11, xmm9
      vmovaps [rsp+168h+var_C8], xmm13
      vmovaps [rsp+168h+var_D8], xmm14
      vxorpd  xmm10, xmm10, xmm10
    }
    if ( v17 )
    {
      __asm
      {
        vcvtss2sd xmm0, xmm11, xmm11
        vmovsd  [rsp+168h+var_128], xmm0
        vmovsd  [rsp+168h+var_130], xmm10
      }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 605, ASSERT_TYPE_ASSERT, "( 0.0f ) < ( frametimeSecScaled )", "%s < %s\n\t%g, %g", "0.0f", "frametimeSecScaled", v140, v142) )
        __debugbreak();
    }
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, dword ptr [r12+8]
      vmulss  xmm1, xmm0, cs:__real@3a83126f
      vmovss  xmm0, dword ptr [rbx]
      vdivss  xmm5, xmm1, xmm11
    }
    _R13 = &v22->m_viewVelocityScaled;
    *((_QWORD *)&v146 + 1) = 0i64;
    __asm
    {
      vmovups xmm2, xmmword ptr [rsp+60h]
      vmovss  xmm2, xmm2, xmm0
      vinsertps xmm2, xmm2, dword ptr [rbx+4], 10h
      vmovups xmm0, xmmword ptr cs:?g_negativeZero@@3Ufloat4@@B.v; float4 const g_negativeZero
      vandnps xmm4, xmm0, xmm2
      vmovss  xmm0, dword ptr [r13+0]
      vmovups xmmword ptr [rsp+60h], xmm2
    }
    *(_QWORD *)&v146 = _RT0;
    __asm
    {
      vmovups xmm2, xmmword ptr [rsp+60h]
      vmovss  xmm2, xmm2, xmm0
      vinsertps xmm2, xmm2, dword ptr [r13+4], 10h
      vshufps xmm5, xmm5, xmm5, 0
      vrcpps  xmm1, xmm5
      vmulps  xmm0, xmm1, xmm2
      vmulps  xmm1, xmm4, xmm1
      vmovups xmmword ptr [rsp+60h], xmm2
      vsubps  xmm2, xmm2, xmm0
      vcmpleps xmm0, xmm5, xmmword ptr cs:?g_one@@3Ufloat4@@B.v; float4 const g_one
      vaddps  xmm3, xmm1, xmm2
      vblendvps xmm1, xmm3, xmm4, xmm0
      vmovss  dword ptr [r13+0], xmm1
      vextractps dword ptr [r13+4], xmm1, 1
    }
    AnglesSubtract(v18, &v22->m_prevViewAngles, &v3);
    __asm
    {
      vmovss  xmm7, cs:__real@3b360b61
      vmovss  xmm6, cs:__real@3f000000
      vmovss  xmm5, cs:__real@43b40000
      vmovss  xmm13, [rsp+168h+fireFraction]
      vmovss  xmm12, dword ptr cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    }
    _RBP = &v22->m_prevViewAnglesOffset;
    __asm
    {
      vmovss  xmm0, dword ptr [rbp+0]
      vsubss  xmm3, xmm0, dword ptr [rsp+168h+v3]
      vmovss  dword ptr [rbp+0], xmm3
      vmovss  xmm1, dword ptr [rbp+4]
      vsubss  xmm0, xmm1, dword ptr [rsp+168h+v3+4]
      vmovss  dword ptr [rbp+4], xmm0
      vmovss  xmm2, dword ptr [rbp+8]
      vsubss  xmm1, xmm2, dword ptr [rsp+168h+v3+8]
      vmovss  dword ptr [rbp+8], xmm1
      vmulss  xmm3, xmm3, xmm7
      vaddss  xmm1, xmm3, xmm6
      vxorps  xmm8, xmm8, xmm8
      vroundss xmm2, xmm8, xmm1, 1
      vsubss  xmm0, xmm3, xmm2
      vmulss  xmm0, xmm0, xmm5
      vmovss  dword ptr [rbp+0], xmm0
      vmulss  xmm4, xmm7, dword ptr [r15+10h]
      vaddss  xmm2, xmm4, xmm6
      vroundss xmm3, xmm8, xmm2, 1
      vsubss  xmm0, xmm4, xmm3
      vmulss  xmm1, xmm0, xmm5
      vmovss  dword ptr [rbp+4], xmm1
      vmulss  xmm3, xmm7, dword ptr [r15+14h]
      vaddss  xmm1, xmm3, xmm6
      vroundss xmm2, xmm8, xmm1, 1
      vmovss  xmm8, cs:__real@3f800000
    }
    _RSI = &swayDef->torsoGoalViewSpeedToMaxDeadzone_viewspeed;
    *(_QWORD *)&v146 = &v22->m_prevViewAnglesOffset;
    v79 = 0;
    __asm
    {
      vsubss  xmm0, xmm3, xmm2
      vmulss  xmm1, xmm0, xmm5
    }
    _R13 = (char *)&v22->m_viewVelocityScaled - (char *)&swayDef->torsoGoalViewSpeedToMaxDeadzone_viewspeed;
    _R14 = (char *)&v147 - (char *)&swayDef->torsoGoalViewSpeedToMaxDeadzone_viewspeed;
    __asm
    {
      vmovss  dword ptr [rbp+8], xmm1
      vsubss  xmm14, xmm8, xmm13
    }
    v85 = 1;
    do
    {
      if ( !v85 )
      {
        LODWORD(v139) = 2;
        LODWORD(v138) = v79;
        v86 = CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 16, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v138, v139);
        v85 = 0;
        if ( v86 )
          __debugbreak();
      }
      __asm { vcomiss xmm9, dword ptr [rsi] }
      if ( !v85 )
      {
        if ( v79 >= 2 )
        {
          LODWORD(v139) = 2;
          LODWORD(v138) = v79;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 16, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v138, v139) )
            __debugbreak();
        }
        __asm
        {
          vmovss  xmm0, dword ptr [rsi]
          vcvtss2sd xmm0, xmm0, xmm0
          vmovsd  [rsp+168h+var_128], xmm0
          vmovsd  [rsp+168h+var_130], xmm10
        }
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 626, ASSERT_TYPE_ASSERT, "( 0.0f ) < ( swayDef->torsoGoalViewSpeedToMaxDeadzone_viewspeed[axis] )", "%s < %s\n\t%g, %g", "0.0f", "swayDef->torsoGoalViewSpeedToMaxDeadzone_viewspeed[axis]", v141, v143) )
          __debugbreak();
      }
      if ( v79 >= 2 )
      {
        LODWORD(v139) = 2;
        LODWORD(v138) = v79;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v138, v139) )
          __debugbreak();
      }
      __asm
      {
        vmovss  xmm6, dword ptr [rsi+r13]
        vandps  xmm6, xmm6, xmm12
      }
      if ( v79 >= 2 )
      {
        LODWORD(v139) = 2;
        LODWORD(v138) = v79;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 16, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v138, v139) )
          __debugbreak();
      }
      __asm
      {
        vdivss  xmm0, xmm6, dword ptr [rsi]; val
        vmovaps xmm2, xmm8; max
        vmovaps xmm1, xmm9; min
      }
      *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
      __asm { vmovaps xmm2, xmm0; fraction }
      *(double *)&_XMM0 = GraphGetValueFromFraction(swayDef->torsoGoalViewSpeedToMaxDeadzone_graph->knotCount, swayDef->torsoGoalViewSpeedToMaxDeadzone_graph->knots, *(const float *)&_XMM2);
      __asm { vmovaps xmm6, xmm0 }
      if ( v79 >= 2 )
      {
        LODWORD(v139) = 2;
        LODWORD(v138) = v79;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 16, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v138, v139) )
          __debugbreak();
      }
      __asm { vmulss  xmm6, xmm6, dword ptr [rsi+8] }
      if ( v79 >= 2 )
      {
        LODWORD(v139) = 2;
        LODWORD(v138) = v79;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v138, v139) )
          __debugbreak();
      }
      __asm
      {
        vmulss  xmm0, xmm13, dword ptr [r12+0A0h]
        vaddss  xmm7, xmm0, xmm14
        vmovss  dword ptr [r14+rsi], xmm6
      }
      if ( v79 >= 2 )
      {
        LODWORD(v139) = 2;
        LODWORD(v138) = v79;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v138, v139) )
          __debugbreak();
      }
      __asm
      {
        vmulss  xmm0, xmm6, xmm7
        vmovss  dword ptr [r14+rsi], xmm0
      }
      _RSI = (vec2_t *)((char *)_RSI + 4);
      v85 = ++v79 < 2;
    }
    while ( (int)v79 < 2 );
    __asm
    {
      vsubss  xmm8, xmm8, [rsp+168h+adsFraction]
      vmovaps xmm14, [rsp+168h+var_D8]
      vmovaps xmm13, [rsp+168h+var_C8]
      vmovaps xmm10, [rsp+168h+var_98]
    }
    _RSI = &v144->m_deadzone;
    v105 = 0;
    v106 = 0;
    _R12 = (char *)&swayDef->torsoGoalDeadzoneAdjustSpeed - (char *)&v147;
    v108 = 1;
    do
    {
      if ( !v108 )
      {
        LODWORD(v139) = 2;
        LODWORD(v138) = v106;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 16, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v138, v139) )
          __debugbreak();
      }
      _R14 = (char *)_RSI + (char *)&v147 - (char *)&v144->m_deadzone;
      __asm { vmovss  xmm7, dword ptr [r14+r12] }
      if ( v106 >= 2 )
      {
        LODWORD(v139) = 2;
        LODWORD(v138) = v106;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v138, v139) )
          __debugbreak();
      }
      __asm { vmovss  xmm6, dword ptr [rsi] }
      if ( v106 >= 2 )
      {
        LODWORD(v139) = 2;
        LODWORD(v138) = v106;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v138, v139) )
          __debugbreak();
      }
      __asm
      {
        vmovss  xmm0, dword ptr [r14]; tgt
        vmovaps xmm3, xmm11; deltaTime
        vmovaps xmm2, xmm7; rate
        vmovaps xmm1, xmm6; cur
      }
      *(double *)&_XMM0 = LinearTrack(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3);
      __asm { vmovaps xmm6, xmm0 }
      if ( v106 >= 2 )
      {
        LODWORD(v139) = 2;
        LODWORD(v138) = v106;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v138, v139) )
          __debugbreak();
      }
      __asm { vmovss  dword ptr [rsi], xmm6 }
      if ( v106 >= 2 )
      {
        LODWORD(v139) = 2;
        LODWORD(v138) = v106;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v138, v139) )
          __debugbreak();
      }
      __asm { vmulss  xmm6, xmm8, dword ptr [rsi] }
      if ( v106 >= 2 )
      {
        LODWORD(v139) = 2;
        LODWORD(v138) = v106;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v138, v139) )
          __debugbreak();
      }
      __asm { vmovss  dword ptr [rsi], xmm6 }
      _RSI = (vec2_t *)((char *)_RSI + 4);
      v108 = ++v106 < 2;
    }
    while ( (int)v106 < 2 );
    __asm { vmovss  xmm8, dword ptr cs:__xmm@80000000800000008000000080000000 }
    _RBP = v146;
    do
    {
      if ( v105 >= 3 )
      {
        LODWORD(v139) = 3;
        LODWORD(v138) = v105;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v138, v139) )
          __debugbreak();
      }
      __asm { vmovss  xmm7, dword ptr [rbp+0] }
      if ( v105 >= 2 )
      {
        LODWORD(v139) = 2;
        LODWORD(v138) = v105;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v138, v139) )
          __debugbreak();
      }
      __asm { vmovss  xmm6, dword ptr [rbp+14h] }
      if ( v105 >= 3 )
      {
        LODWORD(v139) = 3;
        LODWORD(v138) = v105;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v138, v139) )
          __debugbreak();
      }
      __asm
      {
        vmovss  xmm0, dword ptr [rbp+0]
        vandps  xmm0, xmm0, xmm12
        vminss  xmm6, xmm0, xmm6
      }
      if ( v105 >= 3 )
      {
        LODWORD(v139) = 3;
        LODWORD(v138) = v105;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v138, v139) )
          __debugbreak();
      }
      __asm { vmovss  dword ptr [rbp+0], xmm6 }
      if ( v105 >= 3 )
      {
        LODWORD(v139) = 3;
        LODWORD(v138) = v105;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v138, v139) )
          __debugbreak();
      }
      __asm
      {
        vmovss  xmm2, dword ptr [rbp+0]
        vxorps  xmm1, xmm2, xmm8
        vcmpless xmm0, xmm9, xmm7
        vblendvps xmm0, xmm1, xmm2, xmm0
        vmovss  dword ptr [rbp+0], xmm0
      }
      _RBP += 4i64;
      ++v105;
    }
    while ( (int)v105 < 2 );
    _RAX = v145;
    _R15 = v144;
    __asm
    {
      vmovaps xmm12, [rsp+168h+var_B8]
      vmovaps xmm9, [rsp+168h+var_88]
      vmovsd  xmm0, qword ptr [rax]
      vmovaps xmm8, [rsp+168h+var_78]
      vmovaps xmm7, [rsp+168h+var_68]
      vmovaps xmm6, [rsp+168h+var_58]
      vmovsd  qword ptr [r15], xmm0
    }
    v144->m_prevViewAngles.v[2] = v145->v[2];
    v144->m_deadzoneGoal = v147;
  }
  else
  {
    __asm
    {
      vmovsd  xmm0, qword ptr [r8]
      vmovsd  qword ptr [rcx], xmm0
    }
    this->m_prevViewAngles.v[2] = viewAngles->v[2];
    __asm
    {
      vmovsd  xmm0, qword ptr cs:?vec3_origin@@3Tvec3_t@@B; vec3_t const vec3_origin
      vmovsd  qword ptr [rcx+0Ch], xmm0
    }
    this->m_prevViewAnglesOffset.v[2] = vec3_origin.v[2];
    this->m_viewVelocityScaled = 0i64;
    this->m_deadzone = 0i64;
    this->m_isInitialized = 1;
  }
  __asm { vmovaps xmm11, [rsp+168h+var_A8] }
}

/*
==============
AdvancedSwayGunDir::Update
==============
*/
void AdvancedSwayGunDir::Update(AdvancedSwayGunDir *this, const AdvancedHipSwaySettings *const swayDef, const vec3_t *offsetAngles, const vec3_t *offsetVelocity, float frametimeSecScaled, const vec3_t *angleVelocityWorldScaled, float fireFraction)
{
  const dvar_t *v23; 
  unsigned int v51; 
  bool v55; 
  bool v56; 
  __int64 v97; 
  __int64 v98; 
  double v99; 
  double v100; 
  double v101; 
  double v102; 
  double v103; 
  double v104; 
  AdvancedSwayGunDir *v105; 
  __int128 v107; 
  __int128 v108; 

  _R15 = swayDef;
  _RDI = angleVelocityWorldScaled;
  _RSI = this;
  v105 = this;
  if ( this->m_isInitialized )
  {
    __asm
    {
      vmovaps [rsp+128h+var_48], xmm6
      vmovss  xmm6, [rsp+128h+frametimeSecScaled]
      vmovaps [rsp+128h+var_58], xmm7
      vxorps  xmm7, xmm7, xmm7
      vcomiss xmm6, xmm7
      vmovaps [rsp+128h+var_78], xmm9
      vxorpd  xmm9, xmm9, xmm9
    }
    if ( !this->m_isInitialized )
    {
      __asm
      {
        vcvtss2sd xmm0, xmm6, xmm6
        vmovsd  [rsp+128h+var_E8], xmm0
        vmovsd  [rsp+128h+var_F0], xmm9
      }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 925, ASSERT_TYPE_ASSERT, "( 0.0f ) < ( frametimeSecScaled )", "%s < %s\n\t%g, %g", "0.0f", "frametimeSecScaled", v99, v102) )
        __debugbreak();
    }
    v23 = DCONST_DVARBOOL_advancedSwayGunDirEnabled;
    if ( !DCONST_DVARBOOL_advancedSwayGunDirEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "advancedSwayGunDirEnabled") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v23);
    if ( v23->current.enabled )
    {
      __asm
      {
        vcomiss xmm6, xmm7
        vmovaps [rsp+128h+var_68], xmm8
        vmovaps [rsp+128h+var_88], xmm10
        vmovaps [rsp+128h+var_98], xmm11
        vmovaps [rsp+128h+var_A8], xmm12
      }
      if ( !v23->current.enabled )
      {
        __asm
        {
          vcvtss2sd xmm0, xmm6, xmm6
          vmovsd  [rsp+128h+var_E8], xmm0
          vmovsd  [rsp+128h+var_F0], xmm9
        }
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 934, ASSERT_TYPE_ASSERT, "( 0.0f ) < ( frametimeSecScaled )", "%s < %s\n\t%g, %g", "0.0f", "frametimeSecScaled", v100, v103) )
          __debugbreak();
      }
      __asm
      {
        vmovss  xmm12, dword ptr cs:__xmm@80000000800000008000000080000000
        vmovss  xmm11, dword ptr cs:__xmm@7fffffff7fffffff7fffffff7fffffff
        vmovss  xmm10, cs:__real@3f800000
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm0, xmm0, dword ptr [r15+48h]
        vmulss  xmm1, xmm0, cs:__real@3a83126f
        vmovss  xmm0, dword ptr [rdi]
        vdivss  xmm5, xmm1, xmm6
      }
      HIDWORD(v107) = 0;
      __asm
      {
        vmovups xmm4, xmmword ptr [rsp+60h]
        vmovss  xmm4, xmm4, xmm0
        vmovss  xmm0, dword ptr [rsi]
        vinsertps xmm4, xmm4, dword ptr [rdi+4], 10h
        vinsertps xmm4, xmm4, dword ptr [rdi+8], 20h ; ' '
        vmovups xmmword ptr [rsp+60h], xmm4
        vshufps xmm5, xmm5, xmm5, 0
        vrcpps  xmm1, xmm5
      }
      _RDI = &_R15->gunGoalViewSpeedToOffset_viewspeed;
      HIDWORD(v108) = 0;
      __asm
      {
        vmovups xmm3, xmmword ptr [rsp+60h]
        vmovss  xmm3, xmm3, xmm0
        vinsertps xmm3, xmm3, dword ptr [rsi+4], 10h
        vinsertps xmm3, xmm3, dword ptr [rsi+8], 20h ; ' '
        vmulps  xmm0, xmm1, xmm3
        vsubps  xmm2, xmm3, xmm0
        vcmpleps xmm0, xmm5, xmmword ptr cs:?g_one@@3Ufloat4@@B.v; float4 const g_one
        vmulps  xmm1, xmm4, xmm1
        vaddps  xmm3, xmm1, xmm2
        vblendvps xmm1, xmm3, xmm4, xmm0
        vmovss  dword ptr [rsi], xmm1
      }
      v51 = 0;
      _RBP = (char *)_RSI - (char *)&_R15->gunGoalViewSpeedToOffset_viewspeed;
      __asm
      {
        vextractps dword ptr [rsi+4], xmm1, 1
        vextractps dword ptr [rsi+8], xmm1, 2
      }
      _R12 = (char *)&_RSI->m_gunAnglesOffset - (char *)&_R15->gunGoalViewSpeedToOffset_viewspeed;
      do
      {
        if ( v51 >= 3 )
        {
          LODWORD(v98) = 3;
          LODWORD(v97) = v51;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v97, v98) )
            __debugbreak();
        }
        __asm { vmovss  xmm8, dword ptr [rdi+rbp] }
        v55 = v51 < 2;
        if ( v51 >= 2 )
        {
          LODWORD(v98) = 2;
          LODWORD(v97) = v51;
          v56 = CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 16, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v97, v98);
          v55 = 0;
          if ( v56 )
            __debugbreak();
        }
        __asm { vcomiss xmm7, dword ptr [rdi] }
        if ( !v55 )
        {
          if ( v51 >= 2 )
          {
            LODWORD(v98) = 2;
            LODWORD(v97) = v51;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 16, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v97, v98) )
              __debugbreak();
          }
          __asm
          {
            vmovss  xmm0, dword ptr [rdi]
            vcvtss2sd xmm0, xmm0, xmm0
            vmovsd  [rsp+128h+var_E8], xmm0
            vmovsd  [rsp+128h+var_F0], xmm9
          }
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 946, ASSERT_TYPE_ASSERT, "( 0.0f ) < ( swayDef->gunGoalViewSpeedToOffset_viewspeed[axis] )", "%s < %s\n\t%g, %g", "0.0f", "swayDef->gunGoalViewSpeedToOffset_viewspeed[axis]", v101, v104) )
            __debugbreak();
        }
        if ( v51 >= 3 )
        {
          LODWORD(v98) = 3;
          LODWORD(v97) = v51;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v97, v98) )
            __debugbreak();
        }
        __asm
        {
          vmovss  xmm6, dword ptr [rdi+rbp]
          vandps  xmm6, xmm6, xmm11
        }
        if ( v51 >= 2 )
        {
          LODWORD(v98) = 2;
          LODWORD(v97) = v51;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 16, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v97, v98) )
            __debugbreak();
        }
        __asm
        {
          vdivss  xmm0, xmm6, dword ptr [rdi]; val
          vmovaps xmm2, xmm10; max
          vmovaps xmm1, xmm7; min
        }
        *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
        __asm { vmovaps xmm2, xmm0; fraction }
        *(double *)&_XMM0 = GraphGetValueFromFraction(_R15->gunGoalViewSpeedToOffset_graph->knotCount, _R15->gunGoalViewSpeedToOffset_graph->knots, *(const float *)&_XMM2);
        __asm { vmovaps xmm6, xmm0 }
        if ( v51 >= 2 )
        {
          LODWORD(v98) = 2;
          LODWORD(v97) = v51;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 16, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v97, v98) )
            __debugbreak();
        }
        __asm
        {
          vmovss  xmm2, dword ptr [rdi+8]
          vxorps  xmm1, xmm2, xmm12
          vcmpless xmm0, xmm7, xmm8
          vblendvps xmm0, xmm1, xmm2, xmm0
          vmulss  xmm6, xmm0, xmm6
        }
        if ( v51 >= 3 )
        {
          LODWORD(v98) = 3;
          LODWORD(v97) = v51;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v97, v98) )
            __debugbreak();
        }
        __asm { vmovss  dword ptr [r12+rdi], xmm6 }
        _RDI = (vec2_t *)((char *)_RDI + 4);
        ++v51;
      }
      while ( (int)v51 < 2 );
      _RSI = v105;
      __asm
      {
        vmovss  xmm8, [rsp+128h+fireFraction]
        vcomiss xmm8, xmm7
        vmovaps xmm12, [rsp+128h+var_A8]
        vmovaps xmm11, [rsp+128h+var_98]
      }
      _R13 = offsetAngles;
      v105->m_gunAnglesOffset.v[2] = 0.0;
      if ( v51 > 2 )
      {
        __asm
        {
          vmovss  xmm0, dword ptr [r15+0A4h]
          vmovss  xmm5, dword ptr [r13+4]
          vmovss  xmm6, dword ptr [r13+8]
          vsubss  xmm7, xmm0, xmm10
          vmulss  xmm0, xmm7, dword ptr [r13+0]
          vsubss  xmm1, xmm0, dword ptr [rsi+0Ch]
          vmulss  xmm2, xmm1, xmm8
          vaddss  xmm3, xmm2, dword ptr [rsi+0Ch]
          vmovss  dword ptr [rsi+0Ch], xmm3
          vmulss  xmm0, xmm7, xmm5
          vsubss  xmm1, xmm0, dword ptr [rsi+10h]
          vmulss  xmm2, xmm1, xmm8
          vaddss  xmm3, xmm2, dword ptr [rsi+10h]
          vmovss  dword ptr [rsi+10h], xmm3
          vmulss  xmm0, xmm7, xmm6
          vsubss  xmm1, xmm0, dword ptr [rsi+14h]
          vmulss  xmm2, xmm1, xmm8
          vaddss  xmm3, xmm2, dword ptr [rsi+14h]
          vmovss  dword ptr [rsi+14h], xmm3
        }
      }
      __asm
      {
        vmovaps xmm8, [rsp+128h+var_68]
        vmovaps xmm10, [rsp+128h+var_88]
      }
    }
    else
    {
      __asm
      {
        vmovsd  xmm0, qword ptr cs:?vec3_origin@@3Tvec3_t@@B; vec3_t const vec3_origin
        vmovsd  qword ptr [rsi+0Ch], xmm0
      }
      _RSI->m_gunAnglesOffset.v[2] = vec3_origin.v[2];
    }
    __asm
    {
      vmovaps xmm7, [rsp+128h+var_58]
      vmovaps xmm6, [rsp+128h+var_48]
      vmovaps xmm9, [rsp+128h+var_78]
    }
  }
  else
  {
    __asm
    {
      vmovsd  xmm0, qword ptr cs:?vec3_origin@@3Tvec3_t@@B; vec3_t const vec3_origin
      vmovsd  qword ptr [rcx], xmm0
    }
    this->m_smoothedWorldVelocity.v[2] = vec3_origin.v[2];
    __asm
    {
      vmovsd  xmm0, qword ptr cs:?vec3_origin@@3Tvec3_t@@B; vec3_t const vec3_origin
      vmovsd  qword ptr [rcx+0Ch], xmm0
    }
    this->m_gunAnglesOffset.v[2] = vec3_origin.v[2];
    this->m_isInitialized = 1;
  }
}

/*
==============
AdvancedSwaySprings::Update
==============
*/
void AdvancedSwaySprings::Update(AdvancedSwaySprings *this, const bool enabled, const vec2_t *massConst, const vec2_t *springConst, const vec2_t *damperConst, const vec3_t *goalAnglesOffset, float frametimeSecScaled)
{
  bool v21; 
  char v28; 
  double v107; 
  double v108; 
  double v109; 
  double v110; 
  __int128 v111; 
  __int128 v112; 
  __int128 v113; 
  __int128 v114; 
  __int128 v115; 
  vec3_t v3; 

  _R12 = damperConst;
  _R15 = springConst;
  _RDI = goalAnglesOffset;
  _RBX = this;
  if ( enabled )
  {
    v21 = !this->m_isInitialized;
    __asm
    {
      vmovaps [rsp+150h+var_40], xmm6
      vmovaps [rsp+150h+var_50], xmm7
      vmovaps [rsp+150h+var_60], xmm8
      vmovaps [rsp+150h+var_70], xmm9
      vmovaps [rsp+150h+var_80], xmm10
      vmovaps [rsp+150h+var_90], xmm11
      vmovaps [rsp+150h+var_A0], xmm12
      vmovaps [rsp+150h+var_B0], xmm13
      vmovaps [rsp+150h+var_C0], xmm14
      vmovaps [rsp+150h+var_D0], xmm15
    }
    if ( v21 )
    {
      __asm
      {
        vmovsd  xmm0, qword ptr [rdi]
        vmovsd  qword ptr [rcx], xmm0
      }
      this->m_prevSpringOffset.v[2] = goalAnglesOffset->v[2];
      v21 = 1;
      *(_QWORD *)this->m_prevSpringVelocity.v = 0i64;
      this->m_prevSpringVelocity.v[2] = 0.0;
      __asm
      {
        vmovsd  xmm0, qword ptr [rdi]
        vmovsd  qword ptr [rcx+18h], xmm0
      }
      this->m_prevSpringGoalAnglesOffset.v[2] = goalAnglesOffset->v[2];
      this->m_isInitialized = 1;
    }
    __asm
    {
      vmovss  xmm6, [rbp+50h+frametimeSecScaled]
      vxorps  xmm7, xmm7, xmm7
      vcomiss xmm6, xmm7
      vxorpd  xmm8, xmm8, xmm8
    }
    if ( v21 )
    {
      __asm
      {
        vcvtss2sd xmm0, xmm6, xmm6
        vmovsd  [rsp+150h+var_110], xmm0
        vmovsd  [rsp+150h+var_118], xmm8
      }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 862, ASSERT_TYPE_ASSERT, "( 0.0f ) < ( frametimeSecScaled )", "%s < %s\n\t%g, %g", "0.0f", "frametimeSecScaled", v107, v109) )
        __debugbreak();
    }
    AnglesSubtract(goalAnglesOffset, &_RBX->m_prevSpringGoalAnglesOffset, &v3);
    __asm { vcomiss xmm6, xmm7 }
    if ( v28 | v21 )
    {
      __asm
      {
        vcvtss2sd xmm0, xmm6, xmm6
        vmovsd  [rsp+150h+var_110], xmm0
        vmovsd  [rsp+150h+var_118], xmm8
      }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 867, ASSERT_TYPE_ASSERT, "( 0.0f ) < ( frametimeSecScaled )", "%s < %s\n\t%g, %g", "0.0f", "frametimeSecScaled", v108, v110) )
        __debugbreak();
    }
    __asm
    {
      vmovss  xmm0, cs:__real@3f800000
      vmovups xmm11, cs:__xmm@3f8000003f8000000000000000000000
      vinsertps xmm11, xmm11, dword ptr [r14], 0
      vinsertps xmm11, xmm11, dword ptr [r14+4], 10h
      vdivss  xmm2, xmm0, xmm6
      vmovss  xmm0, dword ptr [r15]
      vmulss  xmm3, xmm2, dword ptr [rsp+150h+v3]
      vmulss  xmm4, xmm2, dword ptr [rsp+150h+v3+4]
      vmulss  xmm15, xmm2, dword ptr [rsp+150h+v3+8]
    }
    *((_QWORD *)&v111 + 1) = 0i64;
    __asm
    {
      vmovups xmm7, xmmword ptr [rsp+50h]
      vmovss  xmm7, xmm7, xmm0
      vmovss  xmm0, dword ptr [r12]
      vinsertps xmm7, xmm7, dword ptr [r15+4], 10h
      vmovups xmmword ptr [rsp+50h], xmm7
    }
    *(_QWORD *)&v111 = _RT0;
    __asm
    {
      vmovups xmm10, xmmword ptr [rsp+50h]
      vmovss  xmm10, xmm10, xmm0
      vmovss  xmm0, dword ptr [rdi]
      vinsertps xmm10, xmm10, dword ptr [r12+4], 10h
      vmovups xmmword ptr [rsp+50h], xmm10
    }
    HIDWORD(v112) = 0;
    __asm
    {
      vmovups xmm12, xmmword ptr [rsp+50h]
      vmovss  xmm12, xmm12, xmm0
      vmovss  xmm0, dword ptr [rbx]
      vinsertps xmm12, xmm12, dword ptr [rdi+4], 10h
      vinsertps xmm12, xmm12, dword ptr [rdi+8], 20h ; ' '
      vmovups xmmword ptr [rsp+50h], xmm12
    }
    HIDWORD(v113) = 0;
    __asm
    {
      vmovups xmm13, xmmword ptr [rsp+50h]
      vmovss  xmm13, xmm13, xmm3
      vmovaps xmm8, xmm6
      vinsertps xmm13, xmm13, xmm4, 10h
      vinsertps xmm13, xmm13, xmm15, 20h ; ' '
      vmovups xmmword ptr [rsp+50h], xmm13
    }
    HIDWORD(v114) = 0;
    __asm
    {
      vmovups xmm9, xmmword ptr [rsp+50h]
      vmovss  xmm9, xmm9, xmm0
      vmovss  xmm0, dword ptr [rbx+0Ch]
      vinsertps xmm9, xmm9, dword ptr [rbx+4], 10h
      vinsertps xmm9, xmm9, dword ptr [rbx+8], 20h ; ' '
      vmovups xmmword ptr [rsp+50h], xmm9
    }
    HIDWORD(v115) = 0;
    __asm
    {
      vmovups xmm14, xmmword ptr [rsp+50h]
      vmovss  xmm14, xmm14, xmm0
      vinsertps xmm14, xmm14, dword ptr [rbx+10h], 10h
      vinsertps xmm14, xmm14, dword ptr [rbx+14h], 20h ; ' '
      vxorps  xmm6, xmm6, xmm6
      vcmpltps xmm0, xmm6, xmm11
      vmovmskps eax, xmm0
      vshufps xmm8, xmm8, xmm8, 0
    }
    if ( (_EAX & 0xF) != 15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\com_vector4.h", 440, ASSERT_TYPE_ASSERT, "(!Float4AnyLe( mass, Float4Zero() ))", (const char *)&queryFormat, "!Float4AnyLe( mass, g_zero )") )
      __debugbreak();
    __asm
    {
      vcmpltps xmm0, xmm7, xmm6
      vmovmskps eax, xmm0
    }
    if ( (_EAX & 0xF) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\com_vector4.h", 441, ASSERT_TYPE_ASSERT, "(!Float4AnyLt( springConstant, Float4Zero() ))", (const char *)&queryFormat, "!Float4AnyLt( springConstant, g_zero )") )
      __debugbreak();
    __asm
    {
      vcmpltps xmm0, xmm10, xmm6
      vmovmskps eax, xmm0
    }
    if ( (_EAX & 0xF) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\com_vector4.h", 442, ASSERT_TYPE_ASSERT, "(!Float4AnyLt( damperConstant, Float4Zero() ))", (const char *)&queryFormat, "!Float4AnyLt( damperConstant, g_zero )") )
      __debugbreak();
    __asm
    {
      vdivps  xmm6, xmm7, xmm11
      vdivps  xmm7, xmm10, xmm11
      vmovaps xmm11, [rsp+150h+var_90]
      vmovaps xmm10, [rsp+150h+var_80]
      vmulps  xmm0, xmm8, xmm7
      vmulps  xmm3, xmm13, xmm0
      vmovaps xmm13, [rsp+150h+var_B0]
      vsubps  xmm2, xmm9, xmm12
      vmovaps xmm12, [rsp+150h+var_A0]
      vmulps  xmm1, xmm8, xmm6
      vmulps  xmm0, xmm2, xmm1
      vsubps  xmm2, xmm14, xmm0
      vmovaps xmm14, [rsp+150h+var_C0]
      vmulps  xmm1, xmm8, xmm7
      vaddps  xmm4, xmm3, xmm2
      vmulps  xmm5, xmm8, xmm8
      vmulps  xmm0, xmm6, xmm5
      vaddps  xmm2, xmm0, xmmword ptr cs:?g_one@@3Ufloat4@@B.v; float4 const g_one
      vaddps  xmm0, xmm1, xmm2
      vdivps  xmm7, xmm4, xmm0
      vcmpneqps xmm1, xmm7, xmm7
      vmovmskps eax, xmm1
    }
    if ( _EAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\com_vector4.h", 475, ASSERT_TYPE_SANITY, "( !Float4IsNaN( inOutMassVelocity ) )", (const char *)&queryFormat, "!Float4IsNaN( inOutMassVelocity )") )
      __debugbreak();
    __asm
    {
      vmulps  xmm0, xmm8, xmm7
      vmovaps xmm8, [rsp+150h+var_60]
      vaddps  xmm6, xmm0, xmm9
      vmovaps xmm9, [rsp+150h+var_70]
      vcmpneqps xmm1, xmm6, xmm6
      vmovmskps eax, xmm1
    }
    if ( _EAX )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\com_vector4.h", 477, ASSERT_TYPE_SANITY, "( !Float4IsNaN( inOutMassPos ) )", (const char *)&queryFormat, "!Float4IsNaN( inOutMassPos )") )
        __debugbreak();
    }
    __asm
    {
      vmovss  dword ptr [rbx], xmm6
      vextractps dword ptr [rbx+4], xmm6, 1
      vextractps dword ptr [rbx+8], xmm6, 2
      vmovaps xmm6, [rsp+150h+var_40]
      vmovss  dword ptr [rbx+0Ch], xmm7
      vextractps dword ptr [rbx+10h], xmm7, 1
      vextractps dword ptr [rbx+14h], xmm7, 2
      vmovsd  xmm0, qword ptr [rdi]
      vmovaps xmm7, [rsp+150h+var_50]
      vmovsd  qword ptr [rbx+18h], xmm0
    }
    _RBX->m_prevSpringGoalAnglesOffset.v[2] = goalAnglesOffset->v[2];
    _RBX->m_prevSpringOffset.v[2] = goalAnglesOffset->v[2];
    __asm
    {
      vmovss  dword ptr [rbx+14h], xmm15
      vmovaps xmm15, [rsp+150h+var_D0]
    }
  }
  else
  {
    this->m_isInitialized = 0;
  }
}

/*
==============
AdvancedSwayState::Update
==============
*/
void AdvancedSwayState::Update(AdvancedSwayState *this, const cg_t *const cgameGlob, const vec3_t *viewmodelAngles)
{
  __int64 localClientNum; 
  playerState_s *p_predictedPlayerState; 
  const dvar_t *v15; 
  char v23; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-68h], xmm8
    vmovaps xmmword ptr [rax-98h], xmm12
  }
  localClientNum = cgameGlob->localClientNum;
  p_predictedPlayerState = &cgameGlob->predictedPlayerState;
  _R14 = cgameGlob;
  _RDI = this;
  if ( !CgWeaponMap::ms_instance[localClientNum] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  __asm { vmovss  xmm12, dword ptr [r14+7C64Ch] }
  if ( BG_IsUsingOffhandGestureWeaponADSSupport(CgWeaponMap::ms_instance[localClientNum], p_predictedPlayerState) )
  {
    *(double *)&_XMM0 = BG_GetOffhandAdsFrac(p_predictedPlayerState);
    __asm { vmovaps xmm12, xmm0 }
  }
  __asm { vmovss  dword ptr [rdi+108h], xmm12 }
  if ( !p_predictedPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2275, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  __asm
  {
    vmovaps [rsp+280h+var_58+8], xmm7
    vxorps  xmm8, xmm8, xmm8
  }
  if ( !GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&p_predictedPlayerState->otherFlags, GameModeFlagValues::ms_mpValue, 0x21u) && !CG_View_IsKillCamView((const LocalClientNum_t)_R14->localClientNum) )
  {
    __asm { vmovss  xmm7, dword ptr [r14+65E8h] }
LABEL_20:
    __asm { vcomiss xmm7, xmm8 }
    *(_QWORD *)_RDI->m_angularVelocity.v = 0i64;
    _RDI->m_angularVelocity.v[2] = 0.0;
    __asm { vmovss  dword ptr [rdi+134h], xmm7 }
    goto LABEL_21;
  }
  v15 = DCONST_DVARBOOL_advancedSwayEnabledSpectate;
  if ( !DCONST_DVARBOOL_advancedSwayEnabledSpectate && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "advancedSwayEnabledSpectate") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v15);
  if ( v15->current.enabled )
  {
    if ( _RDI->m_prevInputTime <= 0 )
    {
      __asm { vxorps  xmm7, xmm7, xmm7 }
    }
    else
    {
      __asm
      {
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm0, xmm0, eax
        vmulss  xmm7, xmm0, cs:__real@3a83126f
      }
    }
    _RDI->m_prevInputTime = p_predictedPlayerState->commandTimeInterpolated;
    goto LABEL_20;
  }
LABEL_21:
  __asm { vmovaps xmm7, [rsp+280h+var_58+8] }
  _R11 = &v23;
  __asm
  {
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm12, xmmword ptr [r11-60h]
  }
}

/*
==============
AngularSmoothing::Update
==============
*/

void __fastcall AngularSmoothing::Update(AngularSmoothing *this, const cg_t *const cgameGlob, double adsFrac, double frametime, const float speed, vec3_t *inOutAngles)
{
  bool v34; 
  LocalClientNum_t localClientNum; 
  CgHandler *Handler; 
  vector4 v61; 
  vector4 v62; 
  vector4 v63; 
  float4 v64; 
  vec3_t outUp; 
  tmat33_t<vec3_t> axis; 
  tmat33_t<vec3_t> v67; 
  WorldUpReferenceFrame v68; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-28h], xmm6
    vmovaps xmmword ptr [rax-58h], xmm9
  }
  _RBX = this;
  __asm
  {
    vmovaps xmm9, xmm3
    vmovaps xmm6, xmm2
  }
  AnglesToAxis(inOutAngles, &axis);
  __asm { vmovss  xmm0, dword ptr [rsp+1F8h+axis] }
  v64.v.m128_i32[3] = 0;
  __asm
  {
    vmovups xmm3, xmmword ptr [rsp+100h]
    vmovss  xmm3, xmm3, xmm0
    vinsertps xmm3, xmm3, dword ptr [rsp+1F8h+axis+4], 10h
    vinsertps xmm3, xmm3, dword ptr [rsp+1F8h+axis+8], 20h
    vmovss  xmm0, dword ptr [rsp+1F8h+axis+0Ch]
    vmovups xmmword ptr [rsp+100h], xmm3
    vmovups xmmword ptr [rsp+1F8h+var_1B8], xmm3
  }
  v64.v.m128_i32[3] = 0;
  __asm
  {
    vmovups xmm3, xmmword ptr [rsp+100h]
    vmovss  xmm3, xmm3, xmm0
    vinsertps xmm3, xmm3, dword ptr [rsp+1F8h+axis+10h], 10h
    vinsertps xmm3, xmm3, dword ptr [rsp+1F8h+axis+14h], 20h
    vmovss  xmm0, dword ptr [rsp+1F8h+axis+18h]
    vmovups xmmword ptr [rsp+100h], xmm3
    vmovups xmmword ptr [rsp+1F8h+var_1B8+10h], xmm3
  }
  v64.v.m128_i32[3] = 0;
  __asm
  {
    vmovups xmm3, xmmword ptr [rsp+100h]
    vmovss  xmm3, xmm3, xmm0
    vinsertps xmm3, xmm3, dword ptr [rsp+1F8h+axis+1Ch], 10h
    vinsertps xmm3, xmm3, dword ptr [rsp+1F8h+axis+20h], 20h
    vxorps  xmm2, xmm2, xmm2
    vxorps  xmm0, xmm2, xmmword ptr cs:?g_one@@3Ufloat4@@B.v; float4 const g_one
    vandps  xmm1, xmm0, xmmword ptr cs:?g_keepW@@3Ufloat4@@B.v; float4 const g_keepW
    vxorps  xmm2, xmm1, xmm2
    vmovups xmmword ptr [rsp+1F8h+var_198+10h], xmm2
    vmovups xmmword ptr [rsp+100h], xmm3
    vmovups xmmword ptr [rsp+1F8h+var_198], xmm3
  }
  v34 = !_RBX->m_initialized;
  if ( _RBX->m_initialized )
  {
    __asm
    {
      vmovaps [rsp+1F8h+var_38], xmm7
      vxorps  xmm7, xmm7, xmm7
      vcomiss xmm9, xmm7
    }
    if ( !v34 )
    {
      localClientNum = cgameGlob->localClientNum;
      __asm { vmovaps [rsp+1F8h+var_48], xmm8 }
      Handler = CgHandler::getHandler(localClientNum);
      WorldUpReferenceFrame::WorldUpReferenceFrame(&v68, &cgameGlob->predictedPlayerState, Handler);
      WorldUpReferenceFrame::GetUpVector(&v68, &outUp);
      __asm
      {
        vmovss  xmm0, dword ptr [rsp+1F8h+outUp]
        vmovss  xmm8, cs:__real@3f800000
        vcomiss xmm6, xmm7
      }
      v64.v.m128_i32[3] = 0;
      __asm
      {
        vmovups xmm3, xmmword ptr [rsp+100h]
        vmovss  xmm3, xmm3, xmm0
        vinsertps xmm3, xmm3, dword ptr [rsp+1F8h+outUp+4], 10h
        vinsertps xmm3, xmm3, dword ptr [rsp+1F8h+outUp+8], 20h
        vmovups xmmword ptr [rsp+100h], xmm3
        vmovups xmmword ptr [rsp+100h], xmm3
        vcomiss xmm6, xmm8
        vmovups ymm0, [rsp+1F8h+var_1B8]
        vmovups ymm1, [rsp+1F8h+var_198]
        vmovups ymm2, ymmword ptr [rbx+20h]
        vmovss  xmm3, [rsp+1F8h+speed]
        vmovups [rsp+1F8h+var_178], ymm0
        vmovups ymm0, ymmword ptr [rbx]
        vmovups [rsp+1F8h+var_158], ymm1
        vmovups [rsp+1F8h+var_1B8], ymm0
        vsubss  xmm0, xmm8, xmm6
        vmovaps xmm1, xmm9
        vmovups [rsp+1F8h+var_198], ymm2
      }
      CG_ViewMotion_SmoothBlend(*(double *)&_XMM0, *(double *)&_XMM1, &v64, *(double *)&_XMM3, &v61, &v62, &v63);
      __asm
      {
        vmovups ymm2, [rsp+1F8h+var_138]
        vmovups ymm3, [rsp+1F8h+var_118]
        vmovups ymmword ptr [rbx], ymm2
        vmovss  dword ptr [rsp+1F8h+var_B0], xmm2
        vextractps dword ptr [rsp+1F8h+var_B0+4], xmm2, 1
        vextractps dword ptr [rsp+1F8h+var_B0+8], xmm2, 2
        vextractf128 xmm2, ymm2, 1
        vmovss  dword ptr [rsp+1F8h+var_B0+0Ch], xmm2
        vextractps dword ptr [rsp+1F8h+var_B0+10h], xmm2, 1
        vextractps dword ptr [rsp+1F8h+var_B0+14h], xmm2, 2
        vmovss  dword ptr [rsp+1F8h+var_B0+18h], xmm3
        vextractps dword ptr [rsp+1F8h+var_B0+1Ch], xmm3, 1
        vextractps dword ptr [rsp+1F8h+var_B0+20h], xmm3, 2
        vmovups ymmword ptr [rbx+20h], ymm3
      }
      AxisToAngles(&v67, inOutAngles);
      __asm { vmovaps xmm8, [rsp+1F8h+var_48] }
    }
    __asm { vmovaps xmm7, [rsp+1F8h+var_38] }
  }
  else
  {
    __asm
    {
      vmovups ymm0, [rsp+1F8h+var_1B8]
      vmovups ymm1, [rsp+1F8h+var_198]
      vmovups ymmword ptr [rbx], ymm0
      vmovups ymmword ptr [rbx+20h], ymm1
    }
    _RBX->m_initialized = 1;
  }
  __asm
  {
    vmovaps xmm6, [rsp+1F8h+var_28]
    vmovaps xmm9, [rsp+1F8h+var_58]
  }
}

