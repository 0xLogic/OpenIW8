/*
==============
Scr_Target_SetMinSize
==============
*/

void __fastcall Scr_Target_SetMinSize(scrContext_t *scrContext)
{
  ?Scr_Target_SetMinSize@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_SetShader
==============
*/

void __fastcall Scr_Target_SetShader(scrContext_t *scrContext)
{
  ?Scr_Target_SetShader@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_Flush
==============
*/

void __fastcall Scr_Target_Flush(scrContext_t *scrContext)
{
  ?Scr_Target_Flush@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_IsTarget
==============
*/

void __fastcall Scr_Target_IsTarget(scrContext_t *scrContext)
{
  ?Scr_Target_IsTarget@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
G_Targets_AttackProfileTop
==============
*/

bool __fastcall G_Targets_AttackProfileTop(const gentity_s *ent)
{
  return ?G_Targets_AttackProfileTop@@YA_NPEBUgentity_s@@@Z(ent);
}

/*
==============
Scr_Target_IsInRect
==============
*/

void __fastcall Scr_Target_IsInRect(scrContext_t *scrContext)
{
  ?Scr_Target_IsInRect@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_DrawCornersOnly
==============
*/

void __fastcall Scr_Target_DrawCornersOnly(scrContext_t *scrContext)
{
  ?Scr_Target_DrawCornersOnly@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
G_Targets_Load
==============
*/

void G_Targets_Load(void)
{
  ?G_Targets_Load@@YAXXZ();
}

/*
==============
Scr_Target_StartLockOn
==============
*/

void __fastcall Scr_Target_StartLockOn(scrContext_t *scrContext)
{
  ?Scr_Target_StartLockOn@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_SetScaledRenderMode
==============
*/

void __fastcall Scr_Target_SetScaledRenderMode(scrContext_t *scrContext)
{
  ?Scr_Target_SetScaledRenderMode@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
G_Targets_RemoveAll
==============
*/

void G_Targets_RemoveAll(void)
{
  ?G_Targets_RemoveAll@@YAXXZ();
}

/*
==============
G_Targets_GetOffset
==============
*/

bool __fastcall G_Targets_GetOffset(const gentity_s *targ, vec3_t *result)
{
  return ?G_Targets_GetOffset@@YA_NPEBUgentity_s@@AEATvec3_t@@@Z(targ, result);
}

/*
==============
Scr_Target_SetOffscreenShader
==============
*/

void __fastcall Scr_Target_SetOffscreenShader(scrContext_t *scrContext)
{
  ?Scr_Target_SetOffscreenShader@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_DrawRotated
==============
*/

void __fastcall Scr_Target_DrawRotated(scrContext_t *scrContext)
{
  ?Scr_Target_DrawRotated@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_SetMaxSize
==============
*/

void __fastcall Scr_Target_SetMaxSize(scrContext_t *scrContext)
{
  ?Scr_Target_SetMaxSize@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_DrawSingle
==============
*/

void __fastcall Scr_Target_DrawSingle(scrContext_t *scrContext)
{
  ?Scr_Target_DrawSingle@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
G_Targets_Remove
==============
*/

bool __fastcall G_Targets_Remove(gentity_s *ent)
{
  return ?G_Targets_Remove@@YA_NPEAUgentity_s@@@Z(ent);
}

/*
==============
Scr_Target_DrawOnRadar
==============
*/

void __fastcall Scr_Target_DrawOnRadar(scrContext_t *scrContext)
{
  ?Scr_Target_DrawOnRadar@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_ClearLockOn
==============
*/

void __fastcall Scr_Target_ClearLockOn(scrContext_t *scrContext)
{
  ?Scr_Target_ClearLockOn@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_IsInCircle
==============
*/

void __fastcall Scr_Target_IsInCircle(scrContext_t *scrContext)
{
  ?Scr_Target_IsInCircle@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_DrawSquare
==============
*/

void __fastcall Scr_Target_DrawSquare(scrContext_t *scrContext)
{
  ?Scr_Target_DrawSquare@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_OffsetLocalSpace
==============
*/

void __fastcall Scr_Target_OffsetLocalSpace(scrContext_t *scrContext)
{
  ?Scr_Target_OffsetLocalSpace@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_Remove
==============
*/

void __fastcall Scr_Target_Remove(scrContext_t *scrContext)
{
  ?Scr_Target_Remove@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_Set
==============
*/

void __fastcall Scr_Target_Set(scrContext_t *scrContext)
{
  ?Scr_Target_Set@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_ShowToPlayer
==============
*/

void __fastcall Scr_Target_ShowToPlayer(scrContext_t *scrContext)
{
  ?Scr_Target_ShowToPlayer@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
G_Targets_Init
==============
*/

void G_Targets_Init(void)
{
  ?G_Targets_Init@@YAXXZ();
}

/*
==============
Scr_Target_GetArray
==============
*/

void __fastcall Scr_Target_GetArray(scrContext_t *scrContext)
{
  ?Scr_Target_GetArray@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_SetJavelinOnly
==============
*/

void __fastcall Scr_Target_SetJavelinOnly(scrContext_t *scrContext)
{
  ?Scr_Target_SetJavelinOnly@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_HideFromPlayer
==============
*/

void __fastcall Scr_Target_HideFromPlayer(scrContext_t *scrContext)
{
  ?Scr_Target_HideFromPlayer@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_Alloc
==============
*/

void __fastcall Scr_Target_Alloc(scrContext_t *scrContext)
{
  ?Scr_Target_Alloc@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_SetColor
==============
*/

void __fastcall Scr_Target_SetColor(scrContext_t *scrContext)
{
  ?Scr_Target_SetColor@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_GetTargetAtIndex
==============
*/

void __fastcall Scr_Target_GetTargetAtIndex(scrContext_t *scrContext)
{
  ?Scr_Target_GetTargetAtIndex@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_GetIndexOfTarget
==============
*/

void __fastcall Scr_Target_GetIndexOfTarget(scrContext_t *scrContext)
{
  ?Scr_Target_GetIndexOfTarget@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_SetRadarCenter
==============
*/

void __fastcall Scr_Target_SetRadarCenter(scrContext_t *scrContext)
{
  ?Scr_Target_SetRadarCenter@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_SetDelay
==============
*/

void __fastcall Scr_Target_SetDelay(scrContext_t *scrContext)
{
  ?Scr_Target_SetDelay@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_Target_SetAttackMode
==============
*/

void __fastcall Scr_Target_SetAttackMode(scrContext_t *scrContext)
{
  ?Scr_Target_SetAttackMode@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
G_Targets_AttackProfileTop
==============
*/
bool G_Targets_AttackProfileTop(const gentity_s *ent)
{
  unsigned int TargetIdx; 

  TargetIdx = GetTargetIdx(ent);
  return TargetIdx != 64 && (s_targGlob.targets[(unsigned __int64)TargetIdx].flags & 1) != 0;
}

/*
==============
G_Targets_GetOffset
==============
*/
char G_Targets_GetOffset(const gentity_s *targ, vec3_t *result)
{
  unsigned int TargetIdx; 
  char v4; 
  unsigned __int64 v5; 
  const vec3_t *v6; 
  gentity_s *v7; 
  tmat33_t<vec3_t> axis; 

  TargetIdx = GetTargetIdx(targ);
  if ( TargetIdx == 64 )
  {
    v4 = 0;
    *(_QWORD *)result->v = 0i64;
    result->v[2] = 0.0;
  }
  else
  {
    v5 = (unsigned __int64)TargetIdx << 6;
    v6 = (vec3_t *)((char *)&s_targGlob.targets[0].offset + v5);
    if ( (*(_DWORD *)&s_targGlob.targets[0].color[v5 + 4] & 0x4000) != 0 )
    {
      v7 = EntHandle::ent((EntHandle *)((char *)&s_targGlob + v5));
      AnglesToAxis(&v7->r.currentAngles, &axis);
      MatrixTransformVector(v6, &axis, result);
    }
    else
    {
      result->v[0] = v6->v[0];
      result->v[1] = *(float *)((char *)&s_targGlob.targets[0].offset.v[1] + v5);
      result->v[2] = *(float *)((char *)&s_targGlob.targets[0].offset.v[2] + v5);
    }
    return 1;
  }
  return v4;
}

/*
==============
G_Targets_Init
==============
*/
void G_Targets_Init(void)
{
  GTargetGlobals *v0; 
  unsigned int v1; 
  unsigned __int16 number; 
  __int64 v3; 
  unsigned int v4; 
  __int64 v5; 
  __int64 v6; 
  __int64 v7; 

  if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_SLOW_HARD_LAND) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_targets.cpp", 47, ASSERT_TYPE_ASSERT, "( Com_GameMode_SupportsFeature( Com_GameMode_Feature::TARGET_SYSTEM ) )", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::TARGET_SYSTEM )") )
    __debugbreak();
  s_targGlob.targetCount = 0;
  v0 = &s_targGlob;
  v1 = 4014;
  do
  {
    number = v0->targets[0].ent.number;
    if ( v0->targets[0].ent.number )
    {
      v3 = number;
      v4 = number - 1;
      if ( v4 >= 0x800 )
      {
        LODWORD(v7) = 2048;
        LODWORD(v6) = v4;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v6, v7) )
          __debugbreak();
      }
      if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
        __debugbreak();
      v5 = v3 - 1;
      if ( g_entities[v5].r.isInUse != g_entityIsInUse[v5] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
        __debugbreak();
      if ( !g_entityIsInUse[v5] )
      {
        LODWORD(v7) = v0->targets[0].ent.number - 1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 216, ASSERT_TYPE_ASSERT, "( ( !number || G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( !number || G_IsEntityInUse( number - 1 ) )", v7) )
          __debugbreak();
      }
      if ( v0->targets[0].ent.number && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_targets.cpp", 53, ASSERT_TYPE_ASSERT, "(!s_targGlob.targets[i].ent.isDefined())", (const char *)&queryFormat, "!s_targGlob.targets[i].ent.isDefined()") )
        __debugbreak();
    }
    if ( !BgDynamicLimits::IsValidGameMode() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_dynamic_limits.h", 126, ASSERT_TYPE_ASSERT, "(IsValidGameMode())", "%s\n\tAccessing BgDynamicLimits during invalid game mode", "IsValidGameMode()") )
      __debugbreak();
    if ( BgDynamicLimits::ms_data.m_maxConfigStrings <= 0xFAE )
    {
      LODWORD(v7) = 4014;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_configstrings.h", 68, ASSERT_TYPE_ASSERT, "(BG_ConfigStrings_IsConfigStringInCount( base, CS_FIRST, BgDynamicLimits::GetMaxConfigStrings() ))", "%s\n\tConfigStringOffset of invalid base ConfigString %u", "BG_ConfigStrings_IsConfigStringInCount( base, CS_FIRST, BgDynamicLimits::GetMaxConfigStrings() )", v7) )
        __debugbreak();
    }
    if ( !BgDynamicLimits::IsValidGameMode() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_dynamic_limits.h", 126, ASSERT_TYPE_ASSERT, "(IsValidGameMode())", "%s\n\tAccessing BgDynamicLimits during invalid game mode", "IsValidGameMode()") )
      __debugbreak();
    if ( v1 >= BgDynamicLimits::ms_data.m_maxConfigStrings )
    {
      LODWORD(v7) = v1;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_configstrings.h", 72, ASSERT_TYPE_ASSERT, "(BG_ConfigStrings_IsConfigStringInCount( newIndex, CS_FIRST, BgDynamicLimits::GetMaxConfigStrings() ))", "%s\n\tConfigStringOffset gets invalid ConfigString %u", "BG_ConfigStrings_IsConfigStringInCount( newIndex, CS_FIRST, BgDynamicLimits::GetMaxConfigStrings() )", v7) )
        __debugbreak();
    }
    SV_SetConfigstring(v1++, NULL);
    v0 = (GTargetGlobals *)((char *)v0 + 64);
  }
  while ( (__int64)v0 < (__int64)&s_targGlob.targetCount );
}

/*
==============
G_Targets_Load
==============
*/

void __fastcall G_Targets_Load(double _XMM0_8, __int64 a2, double _XMM2_8, double _XMM3_8)
{
  unsigned int v11; 
  const char *v13; 
  const gentity_s *v14; 
  int v15; 
  __int64 v16; 
  const char *v17; 
  const char *v18; 
  int v19; 
  const char *v20; 
  int v21; 
  const char *v22; 
  const char *v24; 
  int v25; 
  const char *v26; 
  int v27; 
  const char *v28; 
  const char *v36; 
  const char *v37; 
  int v38; 
  __int64 v43; 
  __int64 v44; 
  int v45; 
  int v46; 
  int v47; 
  int v48; 
  char v49; 
  char v50; 
  char v51; 
  char v52; 
  char buffer[1024]; 
  char v54; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm6
    vmovaps xmmword ptr [rax-48h], xmm7
    vmovaps xmmword ptr [rax-58h], xmm8
  }
  if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_SLOW_HARD_LAND) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_targets.cpp", 67, ASSERT_TYPE_ASSERT, "( Com_GameMode_SupportsFeature( Com_GameMode_Feature::TARGET_SYSTEM ) )", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::TARGET_SYSTEM )") )
    __debugbreak();
  __asm
  {
    vmovss  xmm7, cs:__real@bf800000
    vmovss  xmm8, cs:__real@3a83126f
  }
  _RBX = &s_targGlob.targets[0].offset;
  s_targGlob.targetCount = 0;
  v11 = 4014;
  __asm { vxorps  xmm6, xmm6, xmm6 }
  do
  {
    if ( !BgDynamicLimits::IsValidGameMode() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_dynamic_limits.h", 126, ASSERT_TYPE_ASSERT, "(IsValidGameMode())", "%s\n\tAccessing BgDynamicLimits during invalid game mode", "IsValidGameMode()") )
      __debugbreak();
    if ( BgDynamicLimits::ms_data.m_maxConfigStrings <= 0xFAE )
    {
      LODWORD(v44) = 4014;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_configstrings.h", 68, ASSERT_TYPE_ASSERT, "(BG_ConfigStrings_IsConfigStringInCount( base, CS_FIRST, BgDynamicLimits::GetMaxConfigStrings() ))", "%s\n\tConfigStringOffset of invalid base ConfigString %u", "BG_ConfigStrings_IsConfigStringInCount( base, CS_FIRST, BgDynamicLimits::GetMaxConfigStrings() )", v44) )
        __debugbreak();
    }
    if ( !BgDynamicLimits::IsValidGameMode() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_dynamic_limits.h", 126, ASSERT_TYPE_ASSERT, "(IsValidGameMode())", "%s\n\tAccessing BgDynamicLimits during invalid game mode", "IsValidGameMode()") )
      __debugbreak();
    if ( v11 >= BgDynamicLimits::ms_data.m_maxConfigStrings )
    {
      LODWORD(v44) = v11;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_configstrings.h", 72, ASSERT_TYPE_ASSERT, "(BG_ConfigStrings_IsConfigStringInCount( newIndex, CS_FIRST, BgDynamicLimits::GetMaxConfigStrings() ))", "%s\n\tConfigStringOffset gets invalid ConfigString %u", "BG_ConfigStrings_IsConfigStringInCount( newIndex, CS_FIRST, BgDynamicLimits::GetMaxConfigStrings() )", v44) )
        __debugbreak();
    }
    SV_GetConfigstring(v11, buffer, 1024);
    if ( buffer[0] )
    {
      ++s_targGlob.targetCount;
      v13 = Info_ValueForKey(buffer, "ent");
      if ( *v13 )
      {
        v15 = atoi(v13);
        v16 = v15;
        if ( (unsigned int)v15 >= 0x800 )
        {
          LODWORD(v44) = 2048;
          LODWORD(v43) = v15;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_targets.cpp", 92, ASSERT_TYPE_ASSERT, "(unsigned)( entNum ) < (unsigned)( ( 2048 ) )", "entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v43, v44) )
            __debugbreak();
        }
        v14 = &level.gentities[v16];
      }
      else
      {
        v14 = NULL;
      }
      EntHandle::setEnt((EntHandle *)&_RBX[-1].y, v14);
      v17 = Info_ValueForKey(buffer, "offs");
      _RBX->v[0] = 0.0;
      *(_QWORD *)&_RBX->y = 0i64;
      if ( *v17 )
        j_sscanf(v17, "%f %f %f", _RBX, &_RBX->y, &_RBX->z);
      v18 = Info_ValueForKey(buffer, "mat");
      if ( *v18 )
        v19 = atoi(v18);
      else
        v19 = -1;
      LODWORD(_RBX[1].v[0]) = v19;
      v20 = Info_ValueForKey(buffer, "offmat");
      if ( *v20 )
        v21 = atoi(v20);
      else
        v21 = -1;
      LODWORD(_RBX[1].v[1]) = v21;
      v22 = Info_ValueForKey(buffer, "entradius");
      if ( *v22 )
      {
        _XMM0_8 = atof(v22);
        __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
      }
      else
      {
        __asm { vmovaps xmm1, xmm7 }
      }
      __asm { vmovss  dword ptr [rbx+14h], xmm1 }
      v24 = Info_ValueForKey(buffer, "minsize");
      if ( *v24 )
        v25 = atoi(v24);
      else
        v25 = -1;
      LODWORD(_RBX[2].v[0]) = v25;
      v26 = Info_ValueForKey(buffer, "maxsize");
      if ( *v26 )
        v27 = atoi(v26);
      else
        v27 = -1;
      LODWORD(_RBX[2].v[1]) = v27;
      v28 = Info_ValueForKey(buffer, "delay");
      if ( *v28 )
      {
        j_sscanf(v28, "%i %i %i %i", &v48, &v47, &v46, &v45);
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, [rsp+4C0h+var_480]
          vmulss  xmm1, xmm0, xmm8
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, [rsp+4C0h+var_474]
          vxorps  xmm2, xmm2, xmm2
          vcvtsi2ss xmm2, xmm2, [rsp+4C0h+var_47C]
          vxorps  xmm3, xmm3, xmm3
          vcvtsi2ss xmm3, xmm3, [rsp+4C0h+var_478]
          vmulss  xmm4, xmm0, xmm8
        }
      }
      else
      {
        __asm
        {
          vmovaps xmm1, xmm6
          vmovaps xmm2, xmm6
          vmovaps xmm3, xmm6
          vmovaps xmm4, xmm7
        }
      }
      __asm
      {
        vmovss  dword ptr [rbx+20h], xmm4
        vmovss  dword ptr [rbx+28h], xmm3
        vmovss  dword ptr [rbx+2Ch], xmm2
        vmovss  dword ptr [rbx+24h], xmm1
      }
      v36 = Info_ValueForKey(buffer, "color");
      if ( *v36 )
      {
        j_sscanf(v36, "%d %d %d %d", &v49, &v50, &v51, &v52);
        LOBYTE(_RBX[4].v[0]) = v49;
        BYTE1(_RBX[4].v[0]) = v50;
        BYTE2(_RBX[4].x) = v51;
        HIBYTE(_RBX[4].x) = v52;
      }
      v37 = Info_ValueForKey(buffer, "flags");
      if ( *v37 )
        v38 = atoi(v37);
      else
        v38 = 0;
      LODWORD(_RBX[4].v[1]) = v38;
    }
    else
    {
      EntHandle::setEnt((EntHandle *)&_RBX[-1].y, NULL);
    }
    ++v11;
    _RBX = (vec3_t *)((char *)_RBX + 64);
  }
  while ( (__int64)_RBX < (__int64)&unk_14A6BC9B8 );
  _R11 = &v54;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
  }
}

/*
==============
G_Targets_Remove
==============
*/
char G_Targets_Remove(gentity_s *ent)
{
  unsigned int v2; 
  EntHandle *p_ent; 
  unsigned int v5; 
  unsigned int v6; 

  v2 = 0;
  while ( 1 )
  {
    p_ent = &s_targGlob.targets[(unsigned __int64)v2].ent;
    if ( EntHandle::isDefined(p_ent) )
    {
      if ( EntHandle::ent(p_ent) == ent )
        break;
    }
    if ( ++v2 >= 0x40 )
      return 0;
  }
  EntHandle::setEnt(p_ent, NULL);
  v5 = s_targGlob.targetCount - 1;
  s_targGlob.targetCount = v5;
  if ( v5 >= 0x40 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_targets.cpp", 515, ASSERT_TYPE_ASSERT, "(unsigned)( s_targGlob.targetCount ) < (unsigned)( 64 )", "s_targGlob.targetCount doesn't index IW_MAX_TARGETS\n\t%i not in [0, %i)", v5, 64) )
    __debugbreak();
  v6 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v2);
  SV_SetConfigstring(v6, (const char *)&queryFormat.fmt + 3);
  return 1;
}

/*
==============
G_Targets_RemoveAll
==============
*/
void G_Targets_RemoveAll(void)
{
  GTargetGlobals *v0; 
  unsigned int v1; 
  unsigned __int16 number; 
  __int64 v3; 
  unsigned int v4; 
  __int64 v5; 
  unsigned int v6; 
  __int64 v7; 
  __int64 v8; 

  v0 = &s_targGlob;
  v1 = 4014;
  do
  {
    number = v0->targets[0].ent.number;
    if ( v0->targets[0].ent.number )
    {
      v3 = number;
      v4 = number - 1;
      if ( v4 >= 0x800 )
      {
        LODWORD(v8) = 2048;
        LODWORD(v7) = v4;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v7, v8) )
          __debugbreak();
      }
      if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
        __debugbreak();
      v5 = v3 - 1;
      if ( g_entities[v5].r.isInUse != g_entityIsInUse[v5] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
        __debugbreak();
      if ( !g_entityIsInUse[v5] )
      {
        LODWORD(v8) = v0->targets[0].ent.number - 1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 216, ASSERT_TYPE_ASSERT, "( ( !number || G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( !number || G_IsEntityInUse( number - 1 ) )", v8) )
          __debugbreak();
      }
      if ( v0->targets[0].ent.number )
      {
        EntHandle::setEnt(&s_targGlob.targets[(unsigned __int64)(v1 - 4014)].ent, NULL);
        v6 = s_targGlob.targetCount - 1;
        s_targGlob.targetCount = v6;
        if ( v6 >= 0x40 )
        {
          LODWORD(v8) = 64;
          LODWORD(v7) = v6;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_targets.cpp", 536, ASSERT_TYPE_ASSERT, "(unsigned)( s_targGlob.targetCount ) < (unsigned)( 64 )", "s_targGlob.targetCount doesn't index IW_MAX_TARGETS\n\t%i not in [0, %i)", v7, v8) )
            __debugbreak();
        }
        if ( !BgDynamicLimits::IsValidGameMode() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_dynamic_limits.h", 126, ASSERT_TYPE_ASSERT, "(IsValidGameMode())", "%s\n\tAccessing BgDynamicLimits during invalid game mode", "IsValidGameMode()") )
          __debugbreak();
        if ( BgDynamicLimits::ms_data.m_maxConfigStrings <= 0xFAE )
        {
          LODWORD(v8) = 4014;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_configstrings.h", 68, ASSERT_TYPE_ASSERT, "(BG_ConfigStrings_IsConfigStringInCount( base, CS_FIRST, BgDynamicLimits::GetMaxConfigStrings() ))", "%s\n\tConfigStringOffset of invalid base ConfigString %u", "BG_ConfigStrings_IsConfigStringInCount( base, CS_FIRST, BgDynamicLimits::GetMaxConfigStrings() )", v8) )
            __debugbreak();
        }
        if ( !BgDynamicLimits::IsValidGameMode() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_dynamic_limits.h", 126, ASSERT_TYPE_ASSERT, "(IsValidGameMode())", "%s\n\tAccessing BgDynamicLimits during invalid game mode", "IsValidGameMode()") )
          __debugbreak();
        if ( v1 >= BgDynamicLimits::ms_data.m_maxConfigStrings )
        {
          LODWORD(v8) = v1;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_configstrings.h", 72, ASSERT_TYPE_ASSERT, "(BG_ConfigStrings_IsConfigStringInCount( newIndex, CS_FIRST, BgDynamicLimits::GetMaxConfigStrings() ))", "%s\n\tConfigStringOffset gets invalid ConfigString %u", "BG_ConfigStrings_IsConfigStringInCount( newIndex, CS_FIRST, BgDynamicLimits::GetMaxConfigStrings() )", v8) )
            __debugbreak();
        }
        SV_SetConfigstring(v1, (const char *)&queryFormat.fmt + 3);
      }
    }
    ++v1;
    v0 = (GTargetGlobals *)((char *)v0 + 64);
  }
  while ( v1 - 4014 < 0x40 );
}

/*
==============
GetTargetIdx
==============
*/
__int64 GetTargetIdx(const gentity_s *ent)
{
  unsigned int v2; 

  if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_SLOW_HARD_LAND) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_targets.cpp", 158, ASSERT_TYPE_ASSERT, "( Com_GameMode_SupportsFeature( Com_GameMode_Feature::TARGET_SYSTEM ) )", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::TARGET_SYSTEM )") )
    __debugbreak();
  if ( !ent )
    return 64i64;
  v2 = 0;
  while ( !EntHandle::isDefined(&s_targGlob.targets[(unsigned __int64)v2].ent) || EntHandle::ent(&s_targGlob.targets[(unsigned __int64)v2].ent) != ent )
  {
    if ( ++v2 >= 0x40 )
      return 64i64;
  }
  return v2;
}

/*
==============
ScrGetTargetScreenPos
==============
*/
bool ScrGetTargetScreenPos(scrContext_t *scrContext, vec2_t *screenPos)
{
  const gentity_s *Entity; 
  gentity_s *v13; 
  gentity_s *v14; 
  const char *v15; 
  unsigned int TargetIdx; 
  __int64 v19; 
  const char *v20; 
  __int64 v21; 
  gentity_s *v23; 
  bool result; 
  char v53; 
  bool v54; 
  bool v57; 
  vec3_t out; 
  tmat33_t<vec3_t> axis; 
  char v71; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-28h], xmm6
    vmovaps xmmword ptr [rax-38h], xmm7
    vmovaps xmmword ptr [rax-48h], xmm8
    vmovaps xmmword ptr [rax-58h], xmm9
    vmovaps xmmword ptr [rax-68h], xmm10
    vmovaps xmmword ptr [rax-78h], xmm11
  }
  _R14 = screenPos;
  if ( Scr_GetNumParam(scrContext) < 2 )
    Scr_Error(COM_ERR_1637, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  v13 = GScr_GetEntity(1u);
  v14 = v13;
  if ( !v13->client )
  {
    v15 = j_va("entity %i is not a player", (unsigned int)v13->s.number);
    Scr_ObjectError(COM_ERR_1638, scrContext, v15);
  }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vcomiss xmm0, xmm6
    vmovaps xmm7, xmm0
  }
  if ( v53 | v54 )
    Scr_ParamError(COM_ERR_1639, scrContext, 2u, "FOV must be positive");
  TargetIdx = GetTargetIdx(Entity);
  v19 = TargetIdx;
  if ( TargetIdx == 64 )
  {
    v20 = j_va("Entity %i is not a target", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1640, scrContext, v20);
  }
  v21 = v19 << 6;
  v54 = (s_targGlob.targets[v19].flags & 0x4000) == 0;
  _RDI = &s_targGlob.targets[v19].offset;
  if ( v54 )
  {
    __asm
    {
      vmovss  xmm10, dword ptr [rdi]
      vmovss  xmm9, dword ptr [rdi+4]
      vmovss  xmm8, dword ptr [rdi+8]
    }
  }
  else
  {
    v23 = EntHandle::ent((EntHandle *)((char *)&s_targGlob + v21));
    AnglesToAxis(&v23->r.currentAngles, &axis);
    MatrixTransformVector(_RDI, &axis, &out);
    __asm
    {
      vmovss  xmm8, dword ptr [rsp+0E8h+out+8]
      vmovss  xmm9, dword ptr [rsp+0E8h+out+4]
      vmovss  xmm10, dword ptr [rsp+0E8h+out]
    }
  }
  EntHandle::ent((EntHandle *)((char *)&s_targGlob + v21));
  __asm
  {
    vcomiss xmm7, xmm6
    vaddss  xmm0, xmm10, dword ptr [rax+130h]
    vaddss  xmm1, xmm9, dword ptr [rax+134h]
    vsubss  xmm10, xmm0, dword ptr [rsi+130h]
    vaddss  xmm0, xmm8, dword ptr [rax+138h]
    vsubss  xmm9, xmm1, dword ptr [rsi+134h]
    vsubss  xmm1, xmm0, dword ptr [rsi+138h]
    vsubss  xmm11, xmm1, dword ptr [rax+1E8h]
  }
  if ( v53 | v54 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_targets.cpp", 576, ASSERT_TYPE_ASSERT, "(fov_x > 0)", (const char *)&queryFormat, "fov_x > 0") )
    __debugbreak();
  AnglesToAxis(&v14->s.lerp.apos.trBase, &axis);
  __asm
  {
    vmulss  xmm3, xmm9, dword ptr [rsp+0E8h+axis+4]
    vmulss  xmm2, xmm10, dword ptr [rsp+0E8h+axis]
    vmulss  xmm1, xmm11, dword ptr [rsp+0E8h+axis+8]
    vmulss  xmm0, xmm11, dword ptr [rsp+0E8h+axis+14h]
    vaddss  xmm4, xmm3, xmm2
    vmulss  xmm3, xmm9, dword ptr [rsp+0E8h+axis+10h]
    vmulss  xmm2, xmm10, dword ptr [rsp+0E8h+axis+18h]
    vaddss  xmm5, xmm4, xmm1
    vcomiss xmm5, xmm6
    vmulss  xmm1, xmm10, dword ptr [rsp+0E8h+axis+0Ch]
    vaddss  xmm4, xmm3, xmm1
    vmulss  xmm3, xmm9, dword ptr [rsp+0E8h+axis+1Ch]
    vaddss  xmm8, xmm4, xmm0
    vmulss  xmm0, xmm11, dword ptr [rsp+0E8h+axis+20h]
    vaddss  xmm4, xmm3, xmm2
    vaddss  xmm2, xmm4, xmm0
  }
  if ( v53 | v54 )
  {
    result = 0;
  }
  else
  {
    __asm
    {
      vmulss  xmm0, xmm7, cs:__real@3c0efa35; X
      vdivss  xmm9, xmm8, xmm5
      vdivss  xmm10, xmm2, xmm5
    }
    *(float *)&_XMM0 = tanf_0(*(float *)&_XMM0);
    __asm
    {
      vcomiss xmm0, xmm6
      vmulss  xmm8, xmm0, cs:__real@3f400000
      vmovaps xmm7, xmm0
    }
    if ( v53 | v54 )
    {
      v57 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_targets.cpp", 589, ASSERT_TYPE_SANITY, "( tanHalfFovX > 0 )", (const char *)&queryFormat, "tanHalfFovX > 0");
      v53 = 0;
      v54 = !v57;
      if ( v57 )
        __debugbreak();
    }
    __asm { vcomiss xmm8, xmm6 }
    if ( v53 | v54 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_targets.cpp", 590, ASSERT_TYPE_SANITY, "( tanHalfFovY > 0 )", (const char *)&queryFormat, "tanHalfFovY > 0") )
      __debugbreak();
    __asm
    {
      vmulss  xmm0, xmm9, cs:__real@c3a00000
      vmulss  xmm2, xmm10, cs:__real@c3700000
      vdivss  xmm1, xmm0, xmm7
      vdivss  xmm0, xmm2, xmm8
      vmovss  dword ptr [r14+4], xmm0
      vmovss  dword ptr [r14], xmm1
    }
    result = 1;
  }
  _R11 = &v71;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
  }
  return result;
}

/*
==============
Scr_Target_Alloc
==============
*/
void Scr_Target_Alloc(scrContext_t *scrContext)
{
  s_targGlob.targets[(unsigned __int64)Target_Alloc(scrContext)].delayFlush = 1;
}

/*
==============
Scr_Target_ClearLockOn
==============
*/
void Scr_Target_ClearLockOn(scrContext_t *scrContext)
{
  const char *v1; 

  v1 = j_va("ret_lock_on %i %i", 2047i64, 0i64);
  SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v1);
}

/*
==============
Scr_Target_DrawCornersOnly
==============
*/
void Scr_Target_DrawCornersOnly(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  unsigned int TargetIdx; 
  __int64 v4; 
  const char *v5; 
  int Int; 
  unsigned int *p_flags; 
  unsigned int v8; 
  bool v9; 
  unsigned int v10; 
  const char *v11; 
  unsigned int v12; 
  char buffer[1024]; 

  if ( !Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_1651, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  TargetIdx = GetTargetIdx(Entity);
  v4 = TargetIdx;
  if ( TargetIdx == 64 )
  {
    v5 = j_va("Entity %i is not a target", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1652, scrContext, v5);
  }
  Int = Scr_GetInt(scrContext, 1u);
  p_flags = (unsigned int *)&s_targGlob.targets[v4].flags;
  v8 = *p_flags & 0xFFFFFF7F;
  if ( Int )
    v8 = *p_flags | 0x80;
  v9 = !s_targGlob.targets[v4].delayFlush;
  *p_flags = v8;
  if ( v9 )
  {
    v10 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_GetConfigstring(v10, buffer, 1024);
    v11 = j_va("%i", *p_flags);
    Info_SetValueForKey(buffer, "flags", v11);
    v12 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_SetConfigstring(v12, buffer);
  }
}

/*
==============
Scr_Target_DrawOnRadar
==============
*/
void Scr_Target_DrawOnRadar(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  bool v3; 
  unsigned int TargetIdx; 
  __int64 v5; 
  const char *v6; 
  unsigned int *p_flags; 
  unsigned int v8; 
  bool v9; 
  unsigned int v10; 
  const char *v11; 
  unsigned int v12; 
  char buffer[1024]; 

  if ( Scr_GetNumParam(scrContext) < 2 )
    Scr_Error(COM_ERR_1670, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  v3 = Scr_GetInt(scrContext, 1u) != 0;
  TargetIdx = GetTargetIdx(Entity);
  v5 = TargetIdx;
  if ( TargetIdx == 64 )
  {
    v6 = j_va("Entity %i is not a target", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1671, scrContext, v6);
  }
  p_flags = (unsigned int *)&s_targGlob.targets[v5].flags;
  v8 = *p_flags | 0x1000;
  if ( !v3 )
    v8 = *p_flags & 0xFFFFEFFF;
  v9 = !s_targGlob.targets[v5].delayFlush;
  *p_flags = v8;
  if ( v9 )
  {
    v10 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v5);
    SV_GetConfigstring(v10, buffer, 1024);
    v11 = j_va("%i", *p_flags);
    Info_SetValueForKey(buffer, "flags", v11);
    v12 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v5);
    SV_SetConfigstring(v12, buffer);
  }
}

/*
==============
Scr_Target_DrawRotated
==============
*/
void Scr_Target_DrawRotated(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  bool v3; 
  unsigned int TargetIdx; 
  __int64 v5; 
  const char *v6; 
  unsigned int *p_flags; 
  unsigned int v8; 
  bool v9; 
  unsigned int v10; 
  const char *v11; 
  unsigned int v12; 
  char buffer[1024]; 

  if ( Scr_GetNumParam(scrContext) < 2 )
    Scr_Error(COM_ERR_1676, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  v3 = Scr_GetInt(scrContext, 1u) != 0;
  TargetIdx = GetTargetIdx(Entity);
  v5 = TargetIdx;
  if ( TargetIdx == 64 )
  {
    v6 = j_va("Entity %i is not a target", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1677, scrContext, v6);
  }
  p_flags = (unsigned int *)&s_targGlob.targets[v5].flags;
  v8 = *p_flags | 0x8000;
  if ( !v3 )
    v8 = *p_flags & 0xFFFF7FFF;
  v9 = !s_targGlob.targets[v5].delayFlush;
  *p_flags = v8;
  if ( v9 )
  {
    v10 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v5);
    SV_GetConfigstring(v10, buffer, 1024);
    v11 = j_va("%i", *p_flags);
    Info_SetValueForKey(buffer, "flags", v11);
    v12 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v5);
    SV_SetConfigstring(v12, buffer);
  }
}

/*
==============
Scr_Target_DrawSingle
==============
*/
void Scr_Target_DrawSingle(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  unsigned int TargetIdx; 
  __int64 v4; 
  const char *v5; 
  unsigned int v6; 
  const char *v7; 
  unsigned int v8; 
  char buffer[1024]; 

  if ( !Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_1655, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  TargetIdx = GetTargetIdx(Entity);
  v4 = TargetIdx;
  if ( TargetIdx == 64 )
  {
    v5 = j_va("Entity %i is not a target", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1656, scrContext, v5);
  }
  s_targGlob.targets[v4].flags |= 0x800u;
  if ( !s_targGlob.targets[v4].delayFlush )
  {
    v6 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_GetConfigstring(v6, buffer, 1024);
    v7 = j_va("%i", (unsigned int)s_targGlob.targets[v4].flags);
    Info_SetValueForKey(buffer, "flags", v7);
    v8 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_SetConfigstring(v8, buffer);
  }
}

/*
==============
Scr_Target_DrawSquare
==============
*/
void Scr_Target_DrawSquare(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  unsigned int TargetIdx; 
  __int64 v5; 
  const char *v6; 
  bool v9; 
  unsigned int v10; 
  const char *v11; 
  const char *v15; 
  unsigned int v16; 
  char buffer[1024]; 

  if ( !Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_1653, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  TargetIdx = GetTargetIdx(Entity);
  v5 = TargetIdx;
  if ( TargetIdx == 64 )
  {
    v6 = j_va("Entity %i is not a target", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1654, scrContext, v6);
  }
  _RBP = &s_targGlob;
  _RDI = v5 << 6;
  s_targGlob.targets[v5].flags = s_targGlob.targets[v5].flags & 0xFFFFFBBF | 0x400;
  if ( Scr_GetNumParam(scrContext) <= 1 )
    __asm { vmovss  xmm0, cs:__real@bf800000 }
  else
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  v9 = !*(&s_targGlob.targets[0].delayFlush + _RDI);
  __asm { vmovss  dword ptr [rdi+rbp+1Ch], xmm0 }
  if ( v9 )
  {
    v10 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v5);
    SV_GetConfigstring(v10, buffer, 1024);
    v11 = j_va("%i", *(unsigned int *)&s_targGlob.targets[0].color[_RDI + 4]);
    Info_SetValueForKey(buffer, "flags", v11);
    __asm
    {
      vmovss  xmm1, dword ptr [rdi+rbp+1Ch]
      vcvtss2sd xmm1, xmm1, xmm1
      vmovq   rdx, xmm1
    }
    v15 = j_va("%.2f", _RDX);
    Info_SetValueForKey(buffer, "entradius", v15);
    v16 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v5);
    SV_SetConfigstring(v16, buffer);
  }
}

/*
==============
Scr_Target_Flush
==============
*/
void Scr_Target_Flush(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  unsigned int TargetIdx; 
  const char *v4; 

  if ( !Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_1633, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  TargetIdx = GetTargetIdx(Entity);
  if ( TargetIdx == 64 )
  {
    v4 = j_va("Entity %i is not a target", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1634, scrContext, v4);
  }
  Target_Flush(TargetIdx);
}

/*
==============
Scr_Target_GetArray
==============
*/
void Scr_Target_GetArray(scrContext_t *scrContext)
{
  GTargetGlobals *v2; 
  __int64 v3; 
  unsigned __int16 number; 
  __int64 v5; 
  unsigned int v6; 
  __int64 v7; 
  unsigned __int16 v8; 
  __int64 v9; 
  __int64 v10; 
  __int64 v11; 
  __int64 v12; 

  Scr_MakeArray(scrContext);
  v2 = &s_targGlob;
  v3 = 64i64;
  do
  {
    number = v2->targets[0].ent.number;
    if ( v2->targets[0].ent.number )
    {
      v5 = number;
      v6 = number - 1;
      if ( v6 >= 0x800 )
      {
        LODWORD(v12) = 2048;
        LODWORD(v11) = v6;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v11, v12) )
          __debugbreak();
      }
      if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
        __debugbreak();
      v7 = v5 - 1;
      if ( g_entities[v7].r.isInUse != g_entityIsInUse[v7] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
        __debugbreak();
      if ( !g_entityIsInUse[v7] )
      {
        LODWORD(v12) = v2->targets[0].ent.number - 1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 216, ASSERT_TYPE_ASSERT, "( ( !number || G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( !number || G_IsEntityInUse( number - 1 ) )", v12) )
          __debugbreak();
      }
      v8 = v2->targets[0].ent.number;
      if ( v2->targets[0].ent.number )
      {
        if ( (unsigned int)v8 - 1 >= 0x7FF )
        {
          LODWORD(v12) = 2047;
          LODWORD(v11) = v8 - 1;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 223, ASSERT_TYPE_ASSERT, "(unsigned)( number - 1 ) < (unsigned)( ENTITYNUM_NONE )", "number - 1 doesn't index ENTITYNUM_NONE\n\t%i not in [0, %i)", v11, v12) )
            __debugbreak();
        }
        v9 = v2->targets[0].ent.number;
        if ( (unsigned int)(v9 - 1) >= 0x800 )
        {
          LODWORD(v12) = 2048;
          LODWORD(v11) = v9 - 1;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v11, v12) )
            __debugbreak();
        }
        if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
          __debugbreak();
        v10 = v9 - 1;
        if ( g_entities[v10].r.isInUse != g_entityIsInUse[v10] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
          __debugbreak();
        if ( !g_entityIsInUse[v10] )
        {
          LODWORD(v12) = v2->targets[0].ent.number - 1;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 224, ASSERT_TYPE_ASSERT, "( ( G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( G_IsEntityInUse( number - 1 ) )", v12) )
            __debugbreak();
        }
        GScr_AddEntity(&g_entities[v2->targets[0].ent.number - 1]);
        Scr_AddArray(scrContext);
      }
    }
    v2 = (GTargetGlobals *)((char *)v2 + 64);
    --v3;
  }
  while ( v3 );
}

/*
==============
Scr_Target_GetIndexOfTarget
==============
*/
void Scr_Target_GetIndexOfTarget(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  int TargetIdx; 

  if ( !Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_1629, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  TargetIdx = GetTargetIdx(Entity);
  if ( TargetIdx == 64 )
    TargetIdx = -1;
  Scr_AddInt(scrContext, TargetIdx);
}

/*
==============
Scr_Target_GetTargetAtIndex
==============
*/
void Scr_Target_GetTargetAtIndex(scrContext_t *scrContext)
{
  int Int; 
  __int64 v3; 
  EntHandle *p_ent; 
  const gentity_s *v5; 
  __int64 v6; 
  int v7; 

  if ( !Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_1628, scrContext, "Too few arguments\n");
  Int = Scr_GetInt(scrContext, 0);
  v3 = Int;
  if ( Int < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_targets.cpp", 297, ASSERT_TYPE_ASSERT, "(targIdx >= 0)", "%s\n\tIndex passed in to Target_GetTargetAtIndex() must be >= 0", "targIdx >= 0") )
    __debugbreak();
  if ( (unsigned int)v3 >= 0x40 )
  {
    v7 = 64;
    LODWORD(v6) = v3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_targets.cpp", 298, ASSERT_TYPE_ASSERT, "(unsigned)( targIdx ) < (unsigned)( 64 )", "targIdx doesn't index IW_MAX_TARGETS\n\t%i not in [0, %i)", v6, v7) )
      __debugbreak();
  }
  p_ent = &s_targGlob.targets[v3].ent;
  if ( EntHandle::isDefined(p_ent) )
  {
    v5 = EntHandle::ent(p_ent);
    GScr_AddEntity(v5);
  }
  else
  {
    Scr_AddUndefined(scrContext);
  }
}

/*
==============
Scr_Target_HideFromPlayer
==============
*/
void Scr_Target_HideFromPlayer(scrContext_t *scrContext)
{
  Scr_Target_SetPlayerVisibility(scrContext, 0);
}

/*
==============
Scr_Target_IsInCircle
==============
*/
void Scr_Target_IsInCircle(scrContext_t *scrContext)
{
  bool TargetScreenPos; 
  int v6; 
  vec2_t screenPos; 

  __asm { vmovaps [rsp+48h+var_18], xmm6 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
  __asm { vmovaps xmm6, xmm0 }
  TargetScreenPos = ScrGetTargetScreenPos(scrContext, &screenPos);
  v6 = 0;
  if ( TargetScreenPos )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rsp+48h+screenPos]
      vmovss  xmm1, dword ptr [rsp+48h+screenPos+4]
      vmulss  xmm3, xmm0, xmm0
      vmulss  xmm2, xmm1, xmm1
      vaddss  xmm4, xmm3, xmm2
      vmulss  xmm0, xmm6, xmm6
      vcomiss xmm0, xmm4
    }
    LOBYTE(v6) = TargetScreenPos;
  }
  Scr_AddBool(scrContext, v6);
  __asm { vmovaps xmm6, [rsp+48h+var_18] }
}

/*
==============
Scr_Target_IsInRect
==============
*/
void Scr_Target_IsInRect(scrContext_t *scrContext)
{
  vec2_t screenPos; 

  __asm
  {
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps [rsp+58h+var_28], xmm7
  }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
  __asm { vmovaps xmm7, xmm0 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 4u);
  __asm { vmovaps xmm6, xmm0 }
  if ( ScrGetTargetScreenPos(scrContext, &screenPos) )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rsp+58h+screenPos]
      vmovss  xmm1, dword ptr cs:__xmm@7fffffff7fffffff7fffffff7fffffff
      vandps  xmm0, xmm0, xmm1
      vcomiss xmm0, xmm7
    }
  }
  Scr_AddBool(scrContext, 0);
  __asm
  {
    vmovaps xmm6, [rsp+58h+var_18]
    vmovaps xmm7, [rsp+58h+var_28]
  }
}

/*
==============
Scr_Target_IsTarget
==============
*/
void Scr_Target_IsTarget(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  int TargetIdx; 

  if ( !Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_1630, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  TargetIdx = GetTargetIdx(Entity);
  Scr_AddBool(scrContext, TargetIdx != 64);
}

/*
==============
Scr_Target_OffsetLocalSpace
==============
*/
void Scr_Target_OffsetLocalSpace(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  bool v3; 
  unsigned int TargetIdx; 
  __int64 v5; 
  const char *v6; 
  unsigned int *p_flags; 
  unsigned int v8; 
  bool v9; 
  unsigned int v10; 
  const char *v11; 
  unsigned int v12; 
  char buffer[1024]; 

  if ( Scr_GetNumParam(scrContext) < 2 )
    Scr_Error(COM_ERR_1674, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  v3 = Scr_GetInt(scrContext, 1u) != 0;
  TargetIdx = GetTargetIdx(Entity);
  v5 = TargetIdx;
  if ( TargetIdx == 64 )
  {
    v6 = j_va("Entity %i is not a target", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1675, scrContext, v6);
  }
  p_flags = (unsigned int *)&s_targGlob.targets[v5].flags;
  v8 = *p_flags | 0x4000;
  if ( !v3 )
    v8 = *p_flags & 0xFFFFBFFF;
  v9 = !s_targGlob.targets[v5].delayFlush;
  *p_flags = v8;
  if ( v9 )
  {
    v10 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v5);
    SV_GetConfigstring(v10, buffer, 1024);
    v11 = j_va("%i", *p_flags);
    Info_SetValueForKey(buffer, "flags", v11);
    v12 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v5);
    SV_SetConfigstring(v12, buffer);
  }
}

/*
==============
Scr_Target_Remove
==============
*/
void Scr_Target_Remove(scrContext_t *scrContext)
{
  gentity_s *Entity; 
  unsigned int v3; 
  EntHandle *p_ent; 
  const char *v5; 
  unsigned int v6; 
  unsigned int v7; 

  if ( !Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_1635, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  v3 = 0;
  while ( 1 )
  {
    p_ent = &s_targGlob.targets[(unsigned __int64)v3].ent;
    if ( EntHandle::isDefined(p_ent) )
    {
      if ( EntHandle::ent(p_ent) == Entity )
        break;
    }
    if ( ++v3 >= 0x40 )
    {
      v5 = j_va("Entity %i is not a target", (unsigned int)Entity->s.number);
      Scr_Error(COM_ERR_1636, scrContext, v5);
      return;
    }
  }
  EntHandle::setEnt(p_ent, NULL);
  v6 = s_targGlob.targetCount - 1;
  s_targGlob.targetCount = v6;
  if ( v6 >= 0x40 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_targets.cpp", 515, ASSERT_TYPE_ASSERT, "(unsigned)( s_targGlob.targetCount ) < (unsigned)( 64 )", "s_targGlob.targetCount doesn't index IW_MAX_TARGETS\n\t%i not in [0, %i)", v6, 64) )
    __debugbreak();
  v7 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v3);
  SV_SetConfigstring(v7, (const char *)&queryFormat.fmt + 3);
}

/*
==============
Scr_Target_Set
==============
*/
void Scr_Target_Set(scrContext_t *scrContext)
{
  unsigned int v1; 

  v1 = Target_Alloc(scrContext);
  Target_Flush(v1);
}

/*
==============
Scr_Target_SetAttackMode
==============
*/
void Scr_Target_SetAttackMode(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  unsigned int TargetIdx; 
  __int64 v4; 
  const char *v5; 
  scr_string_t ConstString; 
  unsigned int v7; 
  const char *v8; 
  unsigned int v9; 
  char buffer[1024]; 

  if ( Scr_GetNumParam(scrContext) < 2 )
    Scr_Error(COM_ERR_1641, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  TargetIdx = GetTargetIdx(Entity);
  v4 = TargetIdx;
  if ( TargetIdx == 64 )
  {
    v5 = j_va("Entity %i is not a target", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1642, scrContext, v5);
  }
  ConstString = Scr_GetConstString(scrContext, 1u);
  if ( ConstString == scr_const.top )
  {
    s_targGlob.targets[v4].flags |= 1u;
  }
  else if ( ConstString == scr_const.direct )
  {
    s_targGlob.targets[v4].flags &= ~1u;
  }
  else
  {
    Scr_Error(COM_ERR_1643, scrContext, "Incorrect mode name passed to target_setAttackMode().\n");
  }
  if ( !s_targGlob.targets[v4].delayFlush )
  {
    v7 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_GetConfigstring(v7, buffer, 1024);
    v8 = j_va("%i", (unsigned int)s_targGlob.targets[v4].flags);
    Info_SetValueForKey(buffer, "flags", v8);
    v9 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_SetConfigstring(v9, buffer);
  }
}

/*
==============
Scr_Target_SetColor
==============
*/
void Scr_Target_SetColor(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  unsigned int TargetIdx; 
  __int64 v7; 
  const char *v8; 
  __int64 v23; 
  bool v24; 
  unsigned __int8 v25; 
  unsigned __int8 v28; 
  unsigned __int8 v33; 
  unsigned __int8 v37; 
  unsigned int v38; 
  const char *v39; 
  const char *v40; 
  unsigned int v41; 
  int v45; 
  vec3_t vectorValue; 
  char buffer[1024]; 
  char v49; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-18h], xmm6
    vmovaps xmmword ptr [rax-28h], xmm7
  }
  if ( Scr_GetNumParam(scrContext) < 2 )
    Scr_Error(COM_ERR_1661, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  TargetIdx = GetTargetIdx(Entity);
  v7 = TargetIdx;
  if ( TargetIdx == 64 )
  {
    v8 = j_va("Entity %i is not a target", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1662, scrContext, v8);
  }
  Scr_GetVector(scrContext, 1u, &vectorValue);
  __asm
  {
    vmovss  xmm0, cs:__real@3f800000
    vmovss  [rsp+478h+var_43C], xmm0
  }
  if ( Scr_GetNumParam(scrContext) < 2 )
  {
    __asm { vmovss  xmm7, [rsp+478h+var_43C] }
  }
  else
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
    __asm
    {
      vmovss  [rsp+478h+var_43C], xmm0
      vmovaps xmm7, xmm0
    }
  }
  __asm
  {
    vmovss  xmm5, cs:__real@437f0000
    vmovss  xmm4, cs:__real@3f000000
    vmulss  xmm1, xmm5, dword ptr [rsp+478h+vectorValue]
    vaddss  xmm2, xmm1, xmm4
    vmulss  xmm1, xmm5, dword ptr [rsp+478h+vectorValue+4]
    vxorps  xmm6, xmm6, xmm6
    vroundss xmm3, xmm6, xmm2, 1
    vcvttss2si ecx, xmm3
    vaddss  xmm3, xmm1, xmm4
    vroundss xmm1, xmm6, xmm3, 1
    vmulss  xmm0, xmm7, xmm5
    vaddss  xmm2, xmm0, xmm4
  }
  v23 = v7 << 6;
  if ( _ECX > 255 )
    _ECX = 255;
  v24 = _ECX < 0;
  v25 = _ECX;
  __asm
  {
    vcvttss2si ecx, xmm1
    vmulss  xmm1, xmm5, dword ptr [rsp+478h+vectorValue+8]
  }
  if ( v24 )
    v25 = 0;
  s_targGlob.targets[0].color[v23] = v25;
  if ( _ECX > 255 )
    _ECX = 255;
  v28 = _ECX;
  __asm { vaddss  xmm3, xmm1, xmm4 }
  if ( _ECX < 0 )
    v28 = 0;
  s_targGlob.targets[0].color[v23 + 1] = v28;
  __asm
  {
    vroundss xmm1, xmm6, xmm3, 1
    vcvttss2si ecx, xmm1
    vxorps  xmm1, xmm1, xmm1
  }
  if ( _ECX > 255 )
    _ECX = 255;
  v33 = _ECX;
  __asm { vmovss  xmm2, xmm1, xmm2 }
  if ( _ECX < 0 )
    v33 = 0;
  s_targGlob.targets[0].color[v23 + 2] = v33;
  __asm
  {
    vroundss xmm0, xmm6, xmm2, 1
    vcvttss2si ecx, xmm0
  }
  if ( _ECX > 255 )
    _ECX = 255;
  v37 = _ECX;
  if ( _ECX < 0 )
    v37 = 0;
  s_targGlob.targets[0].color[v23 + 3] = v37;
  *(_DWORD *)&s_targGlob.targets[0].color[v23 + 4] |= 0x200u;
  if ( !*(&s_targGlob.targets[0].delayFlush + v23) )
  {
    v38 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v7);
    SV_GetConfigstring(v38, buffer, 1024);
    v45 = s_targGlob.targets[0].color[v23 + 3];
    v39 = j_va("%i %i %i %i", s_targGlob.targets[0].color[v23], s_targGlob.targets[0].color[v23 + 1], s_targGlob.targets[0].color[v23 + 2], v45);
    Info_SetValueForKey(buffer, "color", v39);
    v40 = j_va("%i", *(unsigned int *)&s_targGlob.targets[0].color[v23 + 4]);
    Info_SetValueForKey(buffer, "flags", v40);
    v41 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v7);
    SV_SetConfigstring(v41, buffer);
  }
  _R11 = &v49;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
  }
}

/*
==============
Scr_Target_SetDelay
==============
*/
void Scr_Target_SetDelay(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  unsigned int TargetIdx; 
  __int64 v8; 
  const char *v9; 
  const char *v15; 
  unsigned int NumParam; 
  bool v17; 
  bool v18; 
  const char *v22; 
  unsigned int v23; 
  bool v24; 
  bool v25; 
  const char *v28; 
  const char *v34; 
  unsigned int v35; 
  bool v36; 
  bool v37; 
  const char *v40; 
  unsigned int v41; 
  const char *v48; 
  unsigned int v49; 
  int v53; 
  char buffer[1024]; 
  char v55; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-18h], xmm6
    vmovaps xmmword ptr [rax-28h], xmm7
  }
  if ( Scr_GetNumParam(scrContext) < 2 )
    Scr_Error(COM_ERR_1663, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  TargetIdx = GetTargetIdx(Entity);
  v8 = TargetIdx;
  if ( TargetIdx == 64 )
  {
    v9 = j_va("Entity %i is not a target", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1664, scrContext, v9);
  }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  _RBP = &s_targGlob;
  _RDI = v8 << 6;
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vcomiss xmm0, xmm6
    vmovss  dword ptr [rdi+rbp+28h], xmm0
  }
  if ( __CFSHL__(v8, 6) )
    goto LABEL_7;
  __asm { vcomiss xmm0, cs:__real@3f800000 }
  if ( !__CFSHL__(v8, 6) && v8 << 6 != 0 )
  {
LABEL_7:
    __asm
    {
      vcvtss2sd xmm1, xmm0, xmm0
      vmovq   rdx, xmm1
    }
    v15 = j_va("Delay value out of range (0 .. 1) %f", _RDX);
    Scr_Error(COM_ERR_1665, scrContext, v15);
  }
  NumParam = Scr_GetNumParam(scrContext);
  v17 = NumParam < 2;
  v18 = NumParam == 2;
  if ( NumParam <= 2 )
    __asm { vxorps  xmm0, xmm0, xmm0 }
  else
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
  __asm
  {
    vcomiss xmm0, xmm6
    vmovss  xmm7, cs:__real@447a0000
    vmovss  dword ptr [rdi+rbp+30h], xmm0
  }
  if ( v17 )
    goto LABEL_13;
  __asm { vcomiss xmm0, xmm7 }
  if ( !v17 && !v18 )
  {
LABEL_13:
    __asm
    {
      vcvtss2sd xmm1, xmm0, xmm0
      vmovq   rdx, xmm1
    }
    v22 = j_va("Pause inner radius out of range (0 .. 1000) %f", _RDX);
    Scr_Error(COM_ERR_1666, scrContext, v22);
  }
  v23 = Scr_GetNumParam(scrContext);
  v24 = v23 < 3;
  v25 = v23 == 3;
  if ( v23 <= 3 )
    __asm { vxorps  xmm0, xmm0, xmm0 }
  else
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
  __asm
  {
    vcomiss xmm0, xmm6
    vmovss  dword ptr [rdi+rbp+34h], xmm0
  }
  if ( v24 )
    goto LABEL_19;
  __asm { vcomiss xmm0, xmm7 }
  if ( !v24 && !v25 )
  {
LABEL_19:
    __asm
    {
      vcvtss2sd xmm1, xmm0, xmm0
      vmovq   rdx, xmm1
    }
    v28 = j_va("Pause outer radius out of range (0 .. 1000) %f", _RDX);
    Scr_Error(COM_ERR_1667, scrContext, v28);
    __asm { vmovss  xmm0, dword ptr [rdi+rbp+34h] }
  }
  __asm
  {
    vmovss  xmm1, dword ptr [rdi+rbp+30h]
    vcomiss xmm0, xmm1
  }
  if ( v24 )
  {
    __asm
    {
      vcvtss2sd xmm2, xmm1, xmm1
      vcvtss2sd xmm1, xmm0, xmm0
      vmovq   rdx, xmm1
      vmovq   r8, xmm2
    }
    v34 = j_va("Pause outer radius must be >= the inner radius (%f < %f)", _RDX, _R8);
    Scr_Error(COM_ERR_1668, scrContext, v34);
  }
  v35 = Scr_GetNumParam(scrContext);
  v36 = v35 < 4;
  v37 = v35 == 4;
  if ( v35 <= 4 )
    __asm { vxorps  xmm0, xmm0, xmm0 }
  else
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 4u);
  __asm
  {
    vcomiss xmm0, xmm6
    vmovss  dword ptr [rdi+rbp+2Ch], xmm0
  }
  if ( v36 )
    goto LABEL_27;
  __asm { vcomiss xmm0, xmm7 }
  if ( !v36 && !v37 )
  {
LABEL_27:
    __asm
    {
      vcvtss2sd xmm1, xmm0, xmm0
      vmovq   rdx, xmm1
    }
    v40 = j_va("Pause inner radius wait time out of range (0 .. 1000) %f", _RDX);
    Scr_Error(COM_ERR_1669, scrContext, v40);
  }
  if ( !*(&s_targGlob.targets[0].delayFlush + _RDI) )
  {
    v41 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v8);
    SV_GetConfigstring(v41, buffer, 1024);
    __asm
    {
      vmulss  xmm1, xmm7, dword ptr [rdi+rbp+2Ch]
      vcvttss2si r9d, dword ptr [rdi+rbp+34h]
      vcvttss2si r8d, dword ptr [rdi+rbp+30h]
      vcvttss2si eax, xmm1
      vmulss  xmm1, xmm7, dword ptr [rdi+rbp+28h]
      vcvttss2si edx, xmm1
    }
    v53 = _EAX;
    v48 = j_va("%i %i %i %i", _RDX, _R8, _R9, v53);
    Info_SetValueForKey(buffer, "delay", v48);
    v49 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v8);
    SV_SetConfigstring(v49, buffer);
  }
  _R11 = &v55;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
  }
}

/*
==============
Scr_Target_SetJavelinOnly
==============
*/
void Scr_Target_SetJavelinOnly(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  unsigned int TargetIdx; 
  __int64 v4; 
  const char *v5; 
  int Int; 
  unsigned int *p_flags; 
  unsigned int v8; 
  bool v9; 
  unsigned int v10; 
  const char *v11; 
  unsigned int v12; 
  char buffer[1024]; 

  if ( Scr_GetNumParam(scrContext) < 2 )
    Scr_Error(COM_ERR_1644, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  TargetIdx = GetTargetIdx(Entity);
  v4 = TargetIdx;
  if ( TargetIdx == 64 )
  {
    v5 = j_va("Entity %i is not a target", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1645, scrContext, v5);
  }
  Int = Scr_GetInt(scrContext, 1u);
  p_flags = (unsigned int *)&s_targGlob.targets[v4].flags;
  v8 = *p_flags & 0xFFFFFFFD;
  if ( Int )
    v8 = *p_flags | 2;
  v9 = !s_targGlob.targets[v4].delayFlush;
  *p_flags = v8;
  if ( v9 )
  {
    v10 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_GetConfigstring(v10, buffer, 1024);
    v11 = j_va("%i", *p_flags);
    Info_SetValueForKey(buffer, "flags", v11);
    v12 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_SetConfigstring(v12, buffer);
  }
}

/*
==============
Scr_Target_SetMaxSize
==============
*/
void Scr_Target_SetMaxSize(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  unsigned int TargetIdx; 
  __int64 v4; 
  const char *v5; 
  int Int; 
  bool v7; 
  unsigned int v8; 
  const char *v9; 
  unsigned int v10; 
  char buffer[1024]; 

  if ( Scr_GetNumParam(scrContext) < 2 )
    Scr_Error(COM_ERR_1659, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  TargetIdx = GetTargetIdx(Entity);
  v4 = TargetIdx;
  if ( TargetIdx == 64 )
  {
    v5 = j_va("Entity %i is not a target", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1660, scrContext, v5);
  }
  Int = Scr_GetInt(scrContext, 1u);
  v7 = !s_targGlob.targets[v4].delayFlush;
  s_targGlob.targets[v4].maxSize = Int;
  if ( v7 )
  {
    v8 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_GetConfigstring(v8, buffer, 1024);
    v9 = j_va("%i", (unsigned int)s_targGlob.targets[v4].maxSize);
    Info_SetValueForKey(buffer, "maxsize", v9);
    v10 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_SetConfigstring(v10, buffer);
  }
}

/*
==============
Scr_Target_SetMinSize
==============
*/
void Scr_Target_SetMinSize(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  unsigned int TargetIdx; 
  __int64 v4; 
  const char *v5; 
  __int64 v6; 
  int Int; 
  unsigned int v8; 
  bool v9; 
  unsigned int v10; 
  const char *v11; 
  const char *v12; 
  unsigned int v13; 
  char buffer[1024]; 

  if ( Scr_GetNumParam(scrContext) < 3 )
    Scr_Error(COM_ERR_1657, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  TargetIdx = GetTargetIdx(Entity);
  v4 = TargetIdx;
  if ( TargetIdx == 64 )
  {
    v5 = j_va("Entity %i is not a target", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1658, scrContext, v5);
  }
  v6 = v4 << 6;
  s_targGlob.targets[v4].minSize = Scr_GetInt(scrContext, 1u);
  Int = Scr_GetInt(scrContext, 2u);
  v8 = s_targGlob.targets[v4].flags & 0xFFFFFEFF;
  if ( Int )
    v8 = s_targGlob.targets[v4].flags | 0x100;
  v9 = !*(&s_targGlob.targets[0].delayFlush + v6);
  *(_DWORD *)&s_targGlob.targets[0].color[v6 + 4] = v8;
  if ( v9 )
  {
    v10 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_GetConfigstring(v10, buffer, 1024);
    v11 = j_va("%i", *(unsigned int *)((char *)&s_targGlob.targets[0].minSize + v6));
    Info_SetValueForKey(buffer, "minsize", v11);
    v12 = j_va("%i", *(unsigned int *)&s_targGlob.targets[0].color[v6 + 4]);
    Info_SetValueForKey(buffer, "flags", v12);
    v13 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_SetConfigstring(v13, buffer);
  }
}

/*
==============
Scr_Target_SetOffscreenShader
==============
*/
void Scr_Target_SetOffscreenShader(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  unsigned int TargetIdx; 
  __int64 v4; 
  const char *v5; 
  const char *String; 
  GConfigStrings *v7; 
  unsigned int (__fastcall *GetMaterialIndex)(GConfigStrings *, const char *); 
  const char *v9; 
  int v10; 
  unsigned int *p_offscreenMaterialIndex; 
  unsigned int v12; 
  const char *v13; 
  unsigned int v14; 
  char buffer[1024]; 

  if ( Scr_GetNumParam(scrContext) < 2 )
    Scr_Error(COM_ERR_1626, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  TargetIdx = GetTargetIdx(Entity);
  v4 = TargetIdx;
  if ( TargetIdx == 64 )
  {
    v5 = j_va("Entity %i is not a target", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1627, scrContext, v5);
  }
  String = Scr_GetString(scrContext, 1u);
  if ( !GConfigStrings::ms_gConfigStrings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_configstrings.h", 71, ASSERT_TYPE_ASSERT, "( ms_gConfigStrings )", (const char *)&queryFormat, "ms_gConfigStrings") )
    __debugbreak();
  v7 = GConfigStrings::ms_gConfigStrings;
  if ( *String )
  {
    GetMaterialIndex = GConfigStrings::ms_gConfigStrings->GetMaterialIndex;
    v9 = Scr_GetString(scrContext, 1u);
    v10 = GetMaterialIndex(v7, v9);
  }
  else
  {
    v10 = -1;
  }
  p_offscreenMaterialIndex = (unsigned int *)&s_targGlob.targets[v4].offscreenMaterialIndex;
  *p_offscreenMaterialIndex = v10;
  if ( !s_targGlob.targets[v4].delayFlush )
  {
    v12 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_GetConfigstring(v12, buffer, 1024);
    v13 = j_va("%i", *p_offscreenMaterialIndex);
    Info_SetValueForKey(buffer, "offmat", v13);
    v14 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_SetConfigstring(v14, buffer);
  }
}

/*
==============
Scr_Target_SetPlayerVisibility
==============
*/
void Scr_Target_SetPlayerVisibility(scrContext_t *scrContext, bool makingVisible)
{
  const gentity_s *Entity; 
  unsigned int TargetIdx; 
  __int64 v6; 
  const char *v7; 
  gentity_s *v8; 
  gentity_s *v9; 
  const char *v10; 
  int v11; 
  int flags; 
  unsigned int *p_flags; 
  int v14; 
  bool v15; 
  unsigned int v16; 
  const char *v17; 
  unsigned int v18; 
  char buffer[1024]; 

  if ( Scr_GetNumParam(scrContext) < 2 )
    Scr_Error(COM_ERR_1646, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  TargetIdx = GetTargetIdx(Entity);
  v6 = TargetIdx;
  if ( TargetIdx == 64 )
  {
    v7 = j_va("Entity %i is not a target.", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1647, scrContext, v7);
  }
  v8 = GScr_GetEntity(1u);
  v9 = v8;
  if ( v8->s.eType != ET_PLAYER )
  {
    v10 = j_va("Entity %i is not a player entity.", (unsigned int)v8->s.number);
    Scr_Error(COM_ERR_1648, scrContext, v10);
  }
  if ( SV_Game_GetClientCount() > 4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_targets.cpp", 902, ASSERT_TYPE_ASSERT, "(SV_Game_GetClientCount() <= 4)", "%s\n\tIf we support more clients in SP, we need a more precise target flag system", "SV_Game_GetClientCount() <= 4") )
    __debugbreak();
  switch ( v9->s.number )
  {
    case 1:
      v11 = 8;
      break;
    case 2:
      v11 = 16;
      break;
    case 3:
      v11 = 32;
      break;
    default:
      if ( v9->s.number && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_targets.cpp", 916, ASSERT_TYPE_ASSERT, "( playerEnt->s.number == 0 )", (const char *)&queryFormat, "playerEnt->s.number == 0") )
        __debugbreak();
      v11 = 4;
      break;
  }
  flags = s_targGlob.targets[v6].flags;
  p_flags = (unsigned int *)&s_targGlob.targets[v6].flags;
  if ( makingVisible )
    v14 = flags & ~v11;
  else
    v14 = flags | v11;
  v15 = !s_targGlob.targets[v6].delayFlush;
  *p_flags = v14;
  if ( v15 )
  {
    v16 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v6);
    SV_GetConfigstring(v16, buffer, 1024);
    v17 = j_va("%i", *p_flags);
    Info_SetValueForKey(buffer, "flags", v17);
    v18 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v6);
    SV_SetConfigstring(v18, buffer);
  }
}

/*
==============
Scr_Target_SetRadarCenter
==============
*/
void Scr_Target_SetRadarCenter(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  bool v3; 
  unsigned int TargetIdx; 
  __int64 v5; 
  const char *v6; 
  unsigned int *p_flags; 
  int i; 
  unsigned __int16 v9; 
  __int64 v10; 
  unsigned int v11; 
  __int64 v12; 
  unsigned int v13; 
  const char *v14; 
  unsigned int v15; 
  unsigned int v16; 
  const char *v17; 
  unsigned int v18; 
  __int64 v19; 
  __int64 v20; 
  unsigned int offset; 
  char buffer[1024]; 

  if ( Scr_GetNumParam(scrContext) < 2 )
    Scr_Error(COM_ERR_1672, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  v3 = Scr_GetInt(scrContext, 1u) != 0;
  TargetIdx = GetTargetIdx(Entity);
  v5 = TargetIdx;
  offset = TargetIdx;
  if ( TargetIdx == 64 )
  {
    v6 = j_va("Entity %i is not a target", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1673, scrContext, v6);
  }
  if ( v3 )
  {
    p_flags = (unsigned int *)&s_targGlob.targets[0].flags;
    for ( i = 0; i < 64; ++i )
    {
      v9 = *((_WORD *)p_flags - 30);
      if ( v9 )
      {
        v10 = v9;
        v11 = v9 - 1;
        if ( v11 >= 0x800 )
        {
          LODWORD(v20) = 2048;
          LODWORD(v19) = v11;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v19, v20) )
            __debugbreak();
        }
        if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
          __debugbreak();
        v12 = v10 - 1;
        if ( g_entities[v12].r.isInUse != g_entityIsInUse[v12] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
          __debugbreak();
        if ( !g_entityIsInUse[v12] )
        {
          LODWORD(v20) = *((unsigned __int16 *)p_flags - 30) - 1;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 216, ASSERT_TYPE_ASSERT, "( ( !number || G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( !number || G_IsEntityInUse( number - 1 ) )", v20) )
            __debugbreak();
        }
        if ( *((_WORD *)p_flags - 30) && (*p_flags & 0x2000) != 0 )
        {
          *p_flags &= ~0x2000u;
          v13 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, i);
          SV_GetConfigstring(v13, buffer, 1024);
          v14 = j_va("%i", *p_flags);
          Info_SetValueForKey(buffer, "flags", v14);
          v15 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, i);
          SV_SetConfigstring(v15, buffer);
        }
      }
      p_flags += 16;
    }
    v5 = offset;
    s_targGlob.targets[(unsigned __int64)offset].flags |= 0x2000u;
  }
  else
  {
    s_targGlob.targets[v5].flags &= ~0x2000u;
  }
  if ( !s_targGlob.targets[v5].delayFlush )
  {
    v16 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v5);
    SV_GetConfigstring(v16, buffer, 1024);
    v17 = j_va("%i", (unsigned int)s_targGlob.targets[v5].flags);
    Info_SetValueForKey(buffer, "flags", v17);
    v18 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v5);
    SV_SetConfigstring(v18, buffer);
  }
}

/*
==============
Scr_Target_SetScaledRenderMode
==============
*/
void Scr_Target_SetScaledRenderMode(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  unsigned int TargetIdx; 
  __int64 v4; 
  const char *v5; 
  int Int; 
  unsigned int *p_flags; 
  unsigned int v8; 
  bool v9; 
  unsigned int v10; 
  const char *v11; 
  unsigned int v12; 
  char buffer[1024]; 

  if ( Scr_GetNumParam(scrContext) < 2 )
    Scr_Error(COM_ERR_1649, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  TargetIdx = GetTargetIdx(Entity);
  v4 = TargetIdx;
  if ( TargetIdx == 64 )
  {
    v5 = j_va("Entity %i is not a target", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1650, scrContext, v5);
  }
  Int = Scr_GetInt(scrContext, 1u);
  p_flags = (unsigned int *)&s_targGlob.targets[v4].flags;
  v8 = *p_flags & 0xFFFFFFBF;
  if ( Int )
    v8 = *p_flags | 0x40;
  v9 = !s_targGlob.targets[v4].delayFlush;
  *p_flags = v8;
  if ( v9 )
  {
    v10 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_GetConfigstring(v10, buffer, 1024);
    v11 = j_va("%i", *p_flags);
    Info_SetValueForKey(buffer, "flags", v11);
    v12 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_SetConfigstring(v12, buffer);
  }
}

/*
==============
Scr_Target_SetShader
==============
*/
void Scr_Target_SetShader(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  unsigned int TargetIdx; 
  __int64 v4; 
  const char *v5; 
  const char *String; 
  GConfigStrings *v7; 
  unsigned int (__fastcall *GetMaterialIndex)(GConfigStrings *, const char *); 
  const char *v9; 
  int v10; 
  unsigned int *p_materialIndex; 
  unsigned int v12; 
  const char *v13; 
  unsigned int v14; 
  char buffer[1024]; 

  if ( Scr_GetNumParam(scrContext) < 2 )
    Scr_Error(COM_ERR_1624, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  TargetIdx = GetTargetIdx(Entity);
  v4 = TargetIdx;
  if ( TargetIdx == 64 )
  {
    v5 = j_va("Entity %i is not a target", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_1625, scrContext, v5);
  }
  String = Scr_GetString(scrContext, 1u);
  if ( !GConfigStrings::ms_gConfigStrings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_configstrings.h", 71, ASSERT_TYPE_ASSERT, "( ms_gConfigStrings )", (const char *)&queryFormat, "ms_gConfigStrings") )
    __debugbreak();
  v7 = GConfigStrings::ms_gConfigStrings;
  if ( *String )
  {
    GetMaterialIndex = GConfigStrings::ms_gConfigStrings->GetMaterialIndex;
    v9 = Scr_GetString(scrContext, 1u);
    v10 = GetMaterialIndex(v7, v9);
  }
  else
  {
    v10 = -1;
  }
  p_materialIndex = (unsigned int *)&s_targGlob.targets[v4].materialIndex;
  *p_materialIndex = v10;
  if ( !s_targGlob.targets[v4].delayFlush )
  {
    v12 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_GetConfigstring(v12, buffer, 1024);
    v13 = j_va("%i", *p_materialIndex);
    Info_SetValueForKey(buffer, "mat", v13);
    v14 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v4);
    SV_SetConfigstring(v14, buffer);
  }
}

/*
==============
Scr_Target_ShowToPlayer
==============
*/
void Scr_Target_ShowToPlayer(scrContext_t *scrContext)
{
  Scr_Target_SetPlayerVisibility(scrContext, 1);
}

/*
==============
Scr_Target_StartLockOn
==============
*/
void Scr_Target_StartLockOn(scrContext_t *scrContext)
{
  gentity_s *Entity; 
  const char *v6; 

  Entity = GScr_GetEntity(0);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm
  {
    vmulss  xmm1, xmm0, cs:__real@447a0000
    vcvttss2si r8d, xmm1
  }
  v6 = j_va("ret_lock_on %i %i", (unsigned int)Entity->s.number, _R8);
  SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v6);
}

/*
==============
Target_Alloc
==============
*/
__int64 Target_Alloc(scrContext_t *scrContext)
{
  gentity_s *Entity; 
  unsigned int TargetIdx; 
  GTargetGlobals *v4; 
  unsigned __int16 number; 
  __int64 v6; 
  unsigned int v7; 
  __int64 v8; 
  unsigned __int64 v9; 
  vec3_t *p_offset; 
  __int64 result; 
  __int64 v12; 
  __int64 v13; 

  if ( !Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_1631, scrContext, "Too few arguments\n");
  Entity = GScr_GetEntity(0);
  TargetIdx = GetTargetIdx(Entity);
  if ( TargetIdx == 64 )
  {
    if ( s_targGlob.targetCount >= 0x40 )
      Scr_Error(COM_ERR_1632, scrContext, "Maximum number of targets exceeded");
    TargetIdx = 0;
    v4 = &s_targGlob;
    while ( 1 )
    {
      number = v4->targets[0].ent.number;
      if ( !v4->targets[0].ent.number )
        break;
      v6 = number;
      v7 = number - 1;
      if ( v7 >= 0x800 )
      {
        LODWORD(v13) = 2048;
        LODWORD(v12) = v7;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v12, v13) )
          __debugbreak();
      }
      if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
        __debugbreak();
      v8 = v6 - 1;
      if ( g_entities[v8].r.isInUse != g_entityIsInUse[v8] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
        __debugbreak();
      if ( !g_entityIsInUse[v8] )
      {
        LODWORD(v13) = v4->targets[0].ent.number - 1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 216, ASSERT_TYPE_ASSERT, "( ( !number || G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( !number || G_IsEntityInUse( number - 1 ) )", v13) )
          __debugbreak();
      }
      if ( !v4->targets[0].ent.number )
        break;
      ++TargetIdx;
      v4 = (GTargetGlobals *)((char *)v4 + 64);
      if ( TargetIdx >= 0x40 )
      {
        LODWORD(v13) = 64;
        LODWORD(v12) = TargetIdx;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_targets.cpp", 390, ASSERT_TYPE_ASSERT, "(unsigned)( targetIndex ) < (unsigned)( 64 )", "targetIndex doesn't index IW_MAX_TARGETS\n\t%i not in [0, %i)", v12, v13) )
          __debugbreak();
        break;
      }
    }
    v9 = (unsigned __int64)TargetIdx << 6;
    EntHandle::setEnt((EntHandle *)((char *)&s_targGlob + v9), Entity);
    Entity->flags.m_flags[1] |= 32 * GameModeFlagValues::ms_spValue;
    *(_QWORD *)((char *)&s_targGlob.targets[0].materialIndex + v9) = -1i64;
    *(_QWORD *)((char *)s_targGlob.targets[0].offset.v + v9) = 0i64;
    *(float *)((char *)&s_targGlob.targets[0].offset.v[2] + v9) = 0.0;
    *(_QWORD *)((char *)&s_targGlob.targets[0].entRadius + v9) = -1082130432i64;
    *(int *)((char *)&s_targGlob.targets[0].maxSize + v9) = -1;
    *(float *)((char *)&s_targGlob.targets[0].delay + v9) = -1.0;
    *(_QWORD *)((char *)&s_targGlob.targets[0].popRadiusInnerWaitTime + v9) = 0i64;
    *(float *)((char *)&s_targGlob.targets[0].popRadiusOuter + v9) = 0.0;
    *(_DWORD *)&s_targGlob.targets[0].color[v9 + 4] = 0;
    ++s_targGlob.targetCount;
  }
  p_offset = &s_targGlob.targets[(unsigned __int64)TargetIdx].offset;
  if ( Scr_GetNumParam(scrContext) <= 1 )
  {
    *(_QWORD *)p_offset->v = 0i64;
    result = TargetIdx;
    s_targGlob.targets[(unsigned __int64)TargetIdx].offset.v[2] = 0.0;
  }
  else
  {
    Scr_GetVector(scrContext, 1u, p_offset);
    return TargetIdx;
  }
  return result;
}

/*
==============
Target_Flush
==============
*/
void Target_Flush(unsigned int targetIndex)
{
  __int64 v1; 
  unsigned __int16 number; 
  __int64 v5; 
  unsigned int v6; 
  __int64 v7; 
  int v8; 
  __int64 v9; 
  __int64 v10; 
  const char *v11; 
  const char *v15; 
  const char *v16; 
  const char *v17; 
  const char *v21; 
  const char *v22; 
  const char *v23; 
  const char *v31; 
  const char *v32; 
  const char *v33; 
  unsigned int v34; 
  char *fmt; 
  char *fmta; 
  __int64 v37; 
  __int64 v39; 
  int v40; 
  char s[1024]; 

  v1 = targetIndex;
  if ( targetIndex >= 0x40 )
  {
    v40 = 64;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_targets.cpp", 420, ASSERT_TYPE_ASSERT, "(unsigned)( targetIndex ) < (unsigned)( 64 )", "targetIndex doesn't index IW_MAX_TARGETS\n\t%i not in [0, %i)", targetIndex, v40) )
      __debugbreak();
  }
  _RBP = &s_targGlob;
  _RBX = v1 << 6;
  number = s_targGlob.targets[v1].ent.number;
  if ( !number )
    goto LABEL_38;
  v5 = number;
  v6 = number - 1;
  if ( v6 >= 0x800 )
  {
    LODWORD(v39) = 2048;
    LODWORD(v37) = v6;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v37, v39) )
      __debugbreak();
  }
  if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
    __debugbreak();
  v7 = v5 - 1;
  if ( g_entities[v7].r.isInUse != g_entityIsInUse[v7] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
    __debugbreak();
  if ( !g_entityIsInUse[v7] )
  {
    LODWORD(v39) = *(unsigned __int16 *)((char *)&s_targGlob.targets[0].ent.number + _RBX) - 1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 216, ASSERT_TYPE_ASSERT, "( ( !number || G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( !number || G_IsEntityInUse( number - 1 ) )", v39) )
      __debugbreak();
  }
  if ( !*(unsigned __int16 *)((char *)&s_targGlob.targets[0].ent.number + _RBX) )
  {
LABEL_38:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_targets.cpp", 421, ASSERT_TYPE_ASSERT, "(s_targGlob.targets[targetIndex].ent.isDefined())", "%s\n\tTarget entity is not defined", "s_targGlob.targets[targetIndex].ent.isDefined()") )
      __debugbreak();
  }
  v8 = *(unsigned __int16 *)((char *)&s_targGlob.targets[0].ent.number + _RBX);
  s[0] = 0;
  if ( (unsigned int)(v8 - 1) >= 0x7FF )
  {
    LODWORD(v39) = 2047;
    LODWORD(v37) = v8 - 1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 231, ASSERT_TYPE_ASSERT, "(unsigned)( number - 1 ) < (unsigned)( ENTITYNUM_NONE )", "number - 1 doesn't index ENTITYNUM_NONE\n\t%i not in [0, %i)", v37, v39) )
      __debugbreak();
  }
  v9 = *(unsigned __int16 *)((char *)&s_targGlob.targets[0].ent.number + _RBX);
  if ( (unsigned int)(v9 - 1) >= 0x800 )
  {
    LODWORD(v39) = 2048;
    LODWORD(v37) = v9 - 1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v37, v39) )
      __debugbreak();
  }
  if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
    __debugbreak();
  v10 = v9 - 1;
  if ( g_entities[v10].r.isInUse != g_entityIsInUse[v10] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
    __debugbreak();
  if ( !g_entityIsInUse[v10] )
  {
    LODWORD(v39) = *(unsigned __int16 *)((char *)&s_targGlob.targets[0].ent.number + _RBX) - 1;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 232, ASSERT_TYPE_ASSERT, "( ( G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( G_IsEntityInUse( number - 1 ) )", v39) )
      __debugbreak();
  }
  v11 = j_va("%i", (unsigned int)(__int16)(*(unsigned __int16 *)((char *)&s_targGlob.targets[0].ent.number + _RBX) - 1));
  Info_SetValueForKey(s, "ent", v11);
  __asm
  {
    vcvttss2si r9d, dword ptr [rbx+rbp+10h]
    vcvttss2si r8d, dword ptr [rbx+rbp+0Ch]
    vcvttss2si edx, dword ptr [rbx+rbp+8]
  }
  v15 = j_va("%i %i %i", _RDX, _R8, _R9);
  Info_SetValueForKey(s, "offs", v15);
  v16 = j_va("%i", *(unsigned int *)((char *)&s_targGlob.targets[0].materialIndex + _RBX));
  Info_SetValueForKey(s, "mat", v16);
  v17 = j_va("%i", *(unsigned int *)((char *)&s_targGlob.targets[0].offscreenMaterialIndex + _RBX));
  Info_SetValueForKey(s, "offmat", v17);
  __asm
  {
    vmovss  xmm1, dword ptr [rbx+rbp+1Ch]
    vcvtss2sd xmm1, xmm1, xmm1
    vmovq   rdx, xmm1
  }
  v21 = j_va("%.2f", _RDX);
  Info_SetValueForKey(s, "entradius", v21);
  v22 = j_va("%i", *(unsigned int *)((char *)&s_targGlob.targets[0].minSize + _RBX));
  Info_SetValueForKey(s, "minsize", v22);
  v23 = j_va("%i", *(unsigned int *)((char *)&s_targGlob.targets[0].maxSize + _RBX));
  Info_SetValueForKey(s, "maxsize", v23);
  __asm
  {
    vmovss  xmm1, cs:__real@447a0000
    vmulss  xmm0, xmm1, dword ptr [rbx+rbp+2Ch]
    vmulss  xmm1, xmm1, dword ptr [rbx+rbp+28h]
    vcvttss2si r9d, dword ptr [rbx+rbp+34h]
    vcvttss2si r8d, dword ptr [rbx+rbp+30h]
    vcvttss2si eax, xmm0
    vcvttss2si edx, xmm1
  }
  LODWORD(fmt) = _EAX;
  v31 = j_va("%i %i %i %i", _RDX, _R8, _R9, fmt);
  Info_SetValueForKey(s, "delay", v31);
  LODWORD(fmta) = s_targGlob.targets[0].color[_RBX + 3];
  v32 = j_va("%i %i %i %i", s_targGlob.targets[0].color[_RBX], s_targGlob.targets[0].color[_RBX + 1], s_targGlob.targets[0].color[_RBX + 2], fmta);
  Info_SetValueForKey(s, "color", v32);
  v33 = j_va("%i", *(unsigned int *)&s_targGlob.targets[0].color[_RBX + 4]);
  Info_SetValueForKey(s, "flags", v33);
  v34 = BG_ConfigStrings_ConfigStringOffset(0xFAEu, v1);
  SV_SetConfigstring(v34, s);
  *(&s_targGlob.targets[0].delayFlush + _RBX) = 0;
}

