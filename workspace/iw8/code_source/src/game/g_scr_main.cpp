/*
==============
Scr_PlayFXInternal
==============
*/

gentity_s *__fastcall Scr_PlayFXInternal(scrContext_t *scrContext, int fxId, const vec3_t *pos, vec3_t *forward, vec3_t *up)
{
  return ?Scr_PlayFXInternal@@YAPEAUgentity_s@@AEAUscrContext_t@@HAEBTvec3_t@@PEAT3@2@Z(scrContext, fxId, pos, forward, up);
}

/*
==============
GScr_Main_DisableAimAssistCommon
==============
*/

void __fastcall GScr_Main_DisableAimAssistCommon(gentity_s *ent)
{
  ?GScr_Main_DisableAimAssistCommon@@YAXPEAUgentity_s@@@Z(ent);
}

/*
==============
GScr_Main_NavigateDDL
==============
*/

void __fastcall GScr_Main_NavigateDDL(scrContext_t *scrContext, const DDLDef *def, const char *functionName, DDLState *state, int firstArgIndex, int *finalArgumentIndex)
{
  ?GScr_Main_NavigateDDL@@YAXAEAUscrContext_t@@PEBUDDLDef@@PEBDPEAUDDLState@@HPEAH@Z(scrContext, def, functionName, state, firstArgIndex, finalArgumentIndex);
}

/*
==============
GScr_Main_GetDDL
==============
*/

void __fastcall GScr_Main_GetDDL(scrContext_t *scrContext, DDLState *state, const DDLDef *def, const DDLContext *context, const char *callingFunction, int firstArgIndex)
{
  ?GScr_Main_GetDDL@@YAXAEAUscrContext_t@@PEAUDDLState@@PEBUDDLDef@@PEBUDDLContext@@PEBDH@Z(scrContext, state, def, context, callingFunction, firstArgIndex);
}

/*
==============
GScr_Notify
==============
*/

void __fastcall GScr_Notify(const gentity_s *ent, scr_string_t stringValue, unsigned int paramcount)
{
  ?GScr_Notify@@YAXPEBUgentity_s@@W4scr_string_t@@I@Z(ent, stringValue, paramcount);
}

/*
==============
GScr_GetScriptableLootSpawnedCountByRarity
==============
*/

void __fastcall GScr_GetScriptableLootSpawnedCountByRarity(scrContext_t *scrContext)
{
  ?GScr_GetScriptableLootSpawnedCountByRarity@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_GetWeaponFlashTagname
==============
*/

void __fastcall Scr_GetWeaponFlashTagname(scrContext_t *scrContext)
{
  ?Scr_GetWeaponFlashTagname@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_IsTouchingInternal
==============
*/

int __fastcall Scr_IsTouchingInternal(scrContext_t *scrContext, const gentity_s *ent1, const gentity_s *ent2)
{
  return ?Scr_IsTouchingInternal@@YAHAEAUscrContext_t@@PEBUgentity_s@@1@Z(scrContext, ent1, ent2);
}

/*
==============
Scr_SetFxAngles
==============
*/

void __fastcall Scr_SetFxAngles(scrContext_t *scrContext, int givenAxisCount, tmat33_t<vec3_t> *inOutAxis, vec3_t *outAngles, int fxId)
{
  ?Scr_SetFxAngles@@YAXAEAUscrContext_t@@HAEAT?$tmat33_t@Tvec3_t@@@@AEATvec3_t@@H@Z(scrContext, givenAxisCount, inOutAxis, outAngles, fxId);
}

/*
==============
GScr_Main_GetWeaponForName
==============
*/

Weapon *__fastcall GScr_Main_GetWeaponForName(Weapon *result, scrContext_t *scrContext, const char *weaponName)
{
  return ?GScr_Main_GetWeaponForName@@YA?AUWeapon@@AEAUscrContext_t@@PEBD@Z(result, scrContext, weaponName);
}

/*
==============
GScr_Main_FillWeaponArray
==============
*/

unsigned int __fastcall GScr_Main_FillWeaponArray(scrContext_t *scrContext, Weapon *outWeapons, const unsigned int weaponIndexCount)
{
  return ?GScr_Main_FillWeaponArray@@YAIAEAUscrContext_t@@PEAUWeapon@@I@Z(scrContext, outWeapons, weaponIndexCount);
}

/*
==============
GScr_GetScriptableLootCacheContents
==============
*/

void __fastcall GScr_GetScriptableLootCacheContents(scrContext_t *scrContext)
{
  ?GScr_GetScriptableLootCacheContents@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_EntityGetAIScriptedData
==============
*/

ai_scripted_t *__fastcall GScr_EntityGetAIScriptedData(scrContext_t *scrContext, gentity_s *ent)
{
  return ?GScr_EntityGetAIScriptedData@@YAPEAUai_scripted_t@@AEAUscrContext_t@@PEAUgentity_s@@@Z(scrContext, ent);
}

/*
==============
ScrCmd_GetPlayerLightLevel
==============
*/

void __fastcall ScrCmd_GetPlayerLightLevel(scrContext_t *scrContext, scr_entref_t entref)
{
  ?ScrCmd_GetPlayerLightLevel@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
Scr_FxParamError
==============
*/

void __fastcall Scr_FxParamError(ComErrorCode uniqueErrorCode, scrContext_t *scrContext, int paramIndex, const char *errorString, int fxId)
{
  ?Scr_FxParamError@@YAXW4ComErrorCode@@AEAUscrContext_t@@HPEBDH@Z(uniqueErrorCode, scrContext, paramIndex, errorString, fxId);
}

/*
==============
G_GetAngleDelta
==============
*/

double __fastcall G_GetAngleDelta(scrContext_t *scrContext, const scr_anim_t anim, const float startTime, float endTime)
{
  double result; 

  *(float *)&result = ?G_GetAngleDelta@@YAMAEAUscrContext_t@@Uscr_anim_t@@MM@Z(scrContext, anim, startTime, endTime);
  return result;
}

/*
==============
GScr_Main_PostLoadScriptsCommon
==============
*/

void GScr_Main_PostLoadScriptsCommon(void)
{
  ?GScr_Main_PostLoadScriptsCommon@@YAXXZ();
}

/*
==============
GScr_GetScriptableArrayInRadius
==============
*/

void __fastcall GScr_GetScriptableArrayInRadius(scrContext_t *scrContext)
{
  ?GScr_GetScriptableArrayInRadius@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
G_GetMoveDelta
==============
*/

void __fastcall G_GetMoveDelta(scrContext_t *scrContext, const scr_anim_t anim, const float startTime, const float endTime, vec3_t *outMoveDelta)
{
  ?G_GetMoveDelta@@YAXAEAUscrContext_t@@Uscr_anim_t@@MMAEATvec3_t@@@Z(scrContext, anim, startTime, endTime, outMoveDelta);
}

/*
==============
GScr_GetEntitylessScriptableArray
==============
*/

void __fastcall GScr_GetEntitylessScriptableArray(scrContext_t *scrContext)
{
  ?GScr_GetEntitylessScriptableArray@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_GetScriptableLootSpawnedCountByName
==============
*/

void __fastcall GScr_GetScriptableLootSpawnedCountByName(scrContext_t *scrContext)
{
  ?GScr_GetScriptableLootSpawnedCountByName@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
ScrCmd_MotionBlurHQEnable
==============
*/

void __fastcall ScrCmd_MotionBlurHQEnable(scrContext_t *scrContext, scr_entref_t entref)
{
  ?ScrCmd_MotionBlurHQEnable@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
Scr_VerifyWeapon
==============
*/

void __fastcall Scr_VerifyWeapon(scrContext_t *scrContext, const Weapon *r_weapon, bool isAlternate, const char *weaponName)
{
  ?Scr_VerifyWeapon@@YAXAEAUscrContext_t@@AEBUWeapon@@_NPEBD@Z(scrContext, r_weapon, isAlternate, weaponName);
}

/*
==============
GScr_FreeScriptable
==============
*/

void __fastcall GScr_FreeScriptable(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScr_FreeScriptable@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_GetEntityAllowNull
==============
*/

gentity_s *__fastcall GScr_GetEntityAllowNull(unsigned int index)
{
  return ?GScr_GetEntityAllowNull@@YAPEAUgentity_s@@I@Z(index);
}

/*
==============
Scr_GetWeaponArrayInRadius
==============
*/

void __fastcall Scr_GetWeaponArrayInRadius(scrContext_t *scrContext)
{
  ?Scr_GetWeaponArrayInRadius@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_Main_WeaponParamError
==============
*/

void __fastcall GScr_Main_WeaponParamError(ComErrorCode uniqueErrorCode, scrContext_t *scrContext, const unsigned int index, const Weapon *r_weapon, const char *weaponFormatString)
{
  ?GScr_Main_WeaponParamError@@YAXW4ComErrorCode@@AEAUscrContext_t@@IAEBUWeapon@@PEBD@Z(uniqueErrorCode, scrContext, index, r_weapon, weaponFormatString);
}

/*
==============
GScr_GetLootScriptableArrayInRadius
==============
*/

void __fastcall GScr_GetLootScriptableArrayInRadius(scrContext_t *scrContext)
{
  ?GScr_GetLootScriptableArrayInRadius@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
ScrCmd_SetSolid
==============
*/

void __fastcall ScrCmd_SetSolid(scrContext_t *scrContext, scr_entref_t entref)
{
  ?ScrCmd_SetSolid@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_FreeScripts
==============
*/

void GScr_FreeScripts(void)
{
  ?GScr_FreeScripts@@YAXXZ();
}

/*
==============
GScr_UpdateTagInternal
==============
*/

int __fastcall GScr_UpdateTagInternal(scrContext_t *scrContext, gentity_s *ent, scr_string_t tagName, cached_tag_mat_t *cachedTag, int shouldUseCache, int showScriptError)
{
  return ?GScr_UpdateTagInternal@@YAHAEAUscrContext_t@@PEAUgentity_s@@W4scr_string_t@@PEAUcached_tag_mat_t@@HH@Z(scrContext, ent, tagName, cachedTag, shouldUseCache, showScriptError);
}

/*
==============
GScr_IsScriptableDefined
==============
*/

void __fastcall GScr_IsScriptableDefined(scrContext_t *scrContext)
{
  ?GScr_IsScriptableDefined@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
ScrCmd_MotionBlurHQDisable
==============
*/

void __fastcall ScrCmd_MotionBlurHQDisable(scrContext_t *scrContext, scr_entref_t entref)
{
  ?ScrCmd_MotionBlurHQDisable@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_Main_EnableAimAssistCommon
==============
*/

void __fastcall GScr_Main_EnableAimAssistCommon(gentity_s *ent)
{
  ?GScr_Main_EnableAimAssistCommon@@YAXPEAUgentity_s@@@Z(ent);
}

/*
==============
GScr_Main_GetWeaponParam
==============
*/

void __fastcall GScr_Main_GetWeaponParam(scrContext_t *scrContext, const unsigned int index, Weapon *outWeapon, bool *outIsAlternate)
{
  ?GScr_Main_GetWeaponParam@@YAXAEAUscrContext_t@@IPEAUWeapon@@PEA_N@Z(scrContext, index, outWeapon, outIsAlternate);
}

/*
==============
GScr_EntityGetShootAtPos
==============
*/

void __fastcall GScr_EntityGetShootAtPos(scrContext_t *scrContext, gentity_s *ent, vec3_t *outShootAtPos)
{
  ?GScr_EntityGetShootAtPos@@YAXAEAUscrContext_t@@PEAUgentity_s@@AEATvec3_t@@@Z(scrContext, ent, outShootAtPos);
}

/*
==============
G_SetEntityFlag
==============
*/

void __fastcall G_SetEntityFlag(gentity_s *ent, EntityStateFlagsCommon flag)
{
  ?G_SetEntityFlag@@YAXPEAUgentity_s@@W4EntityStateFlagsCommon@@@Z(ent, flag);
}

/*
==============
GScr_GetMethod
==============
*/

unsigned int __fastcall GScr_GetMethod(const char **pName, BuiltinType *type)
{
  return ?GScr_GetMethod@@YAIPEAPEBDPEAW4BuiltinType@@@Z(pName, type);
}

/*
==============
GScr_ExecSpawnerThread
==============
*/

unsigned int __fastcall GScr_ExecSpawnerThread(const spawner_t *spawner, int handle, unsigned int paramcount)
{
  return ?GScr_ExecSpawnerThread@@YAIPEBUspawner_t@@HI@Z(spawner, handle, paramcount);
}

/*
==============
GScr_AddEntity
==============
*/

void __fastcall GScr_AddEntity(const gentity_s *ent)
{
  ?GScr_AddEntity@@YAXPEBUgentity_s@@@Z(ent);
}

/*
==============
GScr_SpawnScriptable
==============
*/

void __fastcall GScr_SpawnScriptable(scrContext_t *scrContext)
{
  ?GScr_SpawnScriptable@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_Main_UpdateClassMap
==============
*/

void GScr_Main_UpdateClassMap(void)
{
  ?GScr_Main_UpdateClassMap@@YAXXZ();
}

/*
==============
Scr_GetWeaponArray
==============
*/

void __fastcall Scr_GetWeaponArray(scrContext_t *scrContext)
{
  ?Scr_GetWeaponArray@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_AllocString
==============
*/

scr_string_t __fastcall GScr_AllocString(const char *s)
{
  return ?GScr_AllocString@@YA?AW4scr_string_t@@PEBD@Z(s);
}

/*
==============
GScr_Main_RagdollBlendInit
==============
*/

void __fastcall GScr_Main_RagdollBlendInit(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScr_Main_RagdollBlendInit@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_SpawnRagdollConstraint
==============
*/

void __fastcall GScr_SpawnRagdollConstraint(scrContext_t *scrContext)
{
  ?GScr_SpawnRagdollConstraint@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_ExecEntThreadWithReturnValue
==============
*/

unsigned int __fastcall GScr_ExecEntThreadWithReturnValue(const gentity_s *ent, int handle, unsigned int paramcount, void (__fastcall *callback)(scrContext_t *, const void *, void *), const void *cbUserData, void *outReturnValue)
{
  return ?GScr_ExecEntThreadWithReturnValue@@YAIPEBUgentity_s@@HIP6AXAEAUscrContext_t@@PEBXPEAX@Z23@Z(ent, handle, paramcount, callback, cbUserData, outReturnValue);
}

/*
==============
GScr_MakeVehicleSolidSphere
==============
*/

void __fastcall GScr_MakeVehicleSolidSphere(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScr_MakeVehicleSolidSphere@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_LocalToWorldCoords
==============
*/

void __fastcall G_LocalToWorldCoords(const gentity_s *pSelf, const vec3_t *local, vec3_t *outWorld)
{
  ?G_LocalToWorldCoords@@YAXPEBUgentity_s@@AEBTvec3_t@@AEAT2@@Z(pSelf, local, outWorld);
}

/*
==============
GScrCmd_SetWaterSheeting
==============
*/

void __fastcall GScrCmd_SetWaterSheeting(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScrCmd_SetWaterSheeting@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
Scr_MagicBullet
==============
*/

void __fastcall Scr_MagicBullet(scrContext_t *scrContext)
{
  ?Scr_MagicBullet@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_FreeEntity
==============
*/

void __fastcall GScr_FreeEntity(gentity_s *ent)
{
  ?GScr_FreeEntity@@YAXPEAUgentity_s@@@Z(ent);
}

/*
==============
GScr_DisconnectNodePair
==============
*/

void __fastcall GScr_DisconnectNodePair(scrContext_t *scrContext)
{
  ?GScr_DisconnectNodePair@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_SpawnCustomWeaponScriptable
==============
*/

void __fastcall GScr_SpawnCustomWeaponScriptable(scrContext_t *scrContext)
{
  ?GScr_SpawnCustomWeaponScriptable@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_GetScriptCacheContents
==============
*/

void __fastcall GScr_GetScriptCacheContents(scrContext_t *scrContext)
{
  ?GScr_GetScriptCacheContents@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_GetNoTarget
==============
*/

void __fastcall Scr_GetNoTarget(scrContext_t *scrContext, gentity_s *ent, int offset)
{
  ?Scr_GetNoTarget@@YAXAEAUscrContext_t@@PEAUgentity_s@@H@Z(scrContext, ent, offset);
}

/*
==============
GScr_SetChargeMeleeHudVisible
==============
*/

void __fastcall GScr_SetChargeMeleeHudVisible(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScr_SetChargeMeleeHudVisible@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
Scr_GetTeamFlags
==============
*/

bitarray<224> *__fastcall Scr_GetTeamFlags(bitarray<224> *result, scrContext_t *scrContext, unsigned int i)
{
  return ?Scr_GetTeamFlags@@YA?AV?$bitarray@$0OA@@@AEAUscrContext_t@@I@Z(result, scrContext, i);
}

/*
==============
GScr_GetScriptableArray
==============
*/

void __fastcall GScr_GetScriptableArray(scrContext_t *scrContext)
{
  ?GScr_GetScriptableArray@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_Main_SetDDL
==============
*/

void __fastcall GScr_Main_SetDDL(scrContext_t *scrContext, DDLState *state, const DDLDef *def, DDLContext *context, const char *callingFunction, int firstArgIndex)
{
  ?GScr_Main_SetDDL@@YAXAEAUscrContext_t@@PEAUDDLState@@PEBUDDLDef@@PEAUDDLContext@@PEBDH@Z(scrContext, state, def, context, callingFunction, firstArgIndex);
}

/*
==============
Scr_EmitScriptBundlesAnimations
==============
*/

void __fastcall Scr_EmitScriptBundlesAnimations(scrContext_t *scrContext)
{
  ?Scr_EmitScriptBundlesAnimations@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_Main_GetPlayerEntity
==============
*/

gentity_s *__fastcall GScr_Main_GetPlayerEntity(scrContext_t *scrContext, scr_entref_t entref)
{
  return ?GScr_Main_GetPlayerEntity@@YAPEAUgentity_s@@AEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
ScrCmd_SetScriptablePartZeroState_Hack
==============
*/

void __fastcall ScrCmd_SetScriptablePartZeroState_Hack(scrContext_t *scrContext, scr_entref_t entref)
{
  ?ScrCmd_SetScriptablePartZeroState_Hack@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_Main_DeleteCommon
==============
*/

void __fastcall GScr_Main_DeleteCommon(scrContext_t *scrContext, gentity_s *ent)
{
  ?GScr_Main_DeleteCommon@@YAXAEAUscrContext_t@@PEAUgentity_s@@@Z(scrContext, ent);
}

/*
==============
GScr_MakeVehicleSolidCapsule
==============
*/

void __fastcall GScr_MakeVehicleSolidCapsule(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScr_MakeVehicleSolidCapsule@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_PickScriptableLootItem
==============
*/

void __fastcall GScr_PickScriptableLootItem(scrContext_t *scrContext)
{
  ?GScr_PickScriptableLootItem@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_Main_StructuredDataPrintArgs
==============
*/

void __fastcall GScr_Main_StructuredDataPrintArgs(scrContext_t *scrContext, const char *functionName)
{
  ?GScr_Main_StructuredDataPrintArgs@@YAXAEAUscrContext_t@@PEBD@Z(scrContext, functionName);
}

/*
==============
GScr_ScriptBundleContextScoped::~GScr_ScriptBundleContextScoped
==============
*/

void __fastcall GScr_ScriptBundleContextScoped::~GScr_ScriptBundleContextScoped(GScr_ScriptBundleContextScoped *this)
{
  ??1GScr_ScriptBundleContextScoped@@QEAA@XZ(this);
}

/*
==============
Scr_SetAngles
==============
*/

void __fastcall Scr_SetAngles(scrContext_t *scrContext, gentity_s *ent, int offset)
{
  ?Scr_SetAngles@@YAXAEAUscrContext_t@@PEAUgentity_s@@H@Z(scrContext, ent, offset);
}

/*
==============
GScr_IsOnLadder
==============
*/

void __fastcall GScr_IsOnLadder(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScr_IsOnLadder@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_Shutdown
==============
*/

void GScr_Shutdown(void)
{
  ?GScr_Shutdown@@YAXXZ();
}

/*
==============
GScr_GetScriptableLootSpawnedCountByType
==============
*/

void __fastcall GScr_GetScriptableLootSpawnedCountByType(scrContext_t *scrContext)
{
  ?GScr_GetScriptableLootSpawnedCountByType@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_MakeGameMessage
==============
*/

void __fastcall GScr_MakeGameMessage(scrContext_t *scrContext, int clientNum, const char cmd)
{
  ?GScr_MakeGameMessage@@YAXAEAUscrContext_t@@HD@Z(scrContext, clientNum, cmd);
}

/*
==============
GScr_GetEntity
==============
*/

gentity_s *__fastcall GScr_GetEntity(unsigned int index)
{
  return ?GScr_GetEntity@@YAPEAUgentity_s@@I@Z(index);
}

/*
==============
GScr_SetOmnvarInternal
==============
*/

void __fastcall GScr_SetOmnvarInternal(scrContext_t *scrContext, const OmnvarDef *def, OmnvarData *data, int valueArgumentIndex)
{
  ?GScr_SetOmnvarInternal@@YAXAEAUscrContext_t@@PEBUOmnvarDef@@PEAUOmnvarData@@H@Z(scrContext, def, data, valueArgumentIndex);
}

/*
==============
GScr_ExecEntThread
==============
*/

unsigned int __fastcall GScr_ExecEntThread(const gentity_s *ent, int handle, unsigned int paramcount)
{
  return ?GScr_ExecEntThread@@YAIPEBUgentity_s@@HI@Z(ent, handle, paramcount);
}

/*
==============
Scr_LocalizationError
==============
*/

void __fastcall Scr_LocalizationError(scrContext_t *scrContext, int iParm, const char *pszErrorMessage)
{
  ?Scr_LocalizationError@@YAXAEAUscrContext_t@@HPEBD@Z(scrContext, iParm, pszErrorMessage);
}

/*
==============
Scr_GetTeamFlag
==============
*/

bitarray<224> *__fastcall Scr_GetTeamFlag(bitarray<224> *result, scrContext_t *scrContext, scr_string_t teamName)
{
  return ?Scr_GetTeamFlag@@YA?AV?$bitarray@$0OA@@@AEAUscrContext_t@@W4scr_string_t@@@Z(result, scrContext, teamName);
}

/*
==============
Scr_ValidateLocalizedStringRef
==============
*/

void __fastcall Scr_ValidateLocalizedStringRef(scrContext_t *scrContext, int parmIndex, const char *token, int tokenLen)
{
  ?Scr_ValidateLocalizedStringRef@@YAXAEAUscrContext_t@@HPEBDH@Z(scrContext, parmIndex, token, tokenLen);
}

/*
==============
GScr_GetStandaloneScriptableIndex
==============
*/

unsigned int __fastcall GScr_GetStandaloneScriptableIndex(scrContext_t *scrContext, const scr_entref_t *entref)
{
  return ?GScr_GetStandaloneScriptableIndex@@YAIAEAUscrContext_t@@AEBUscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_ConnectNodePair
==============
*/

void __fastcall GScr_ConnectNodePair(scrContext_t *scrContext)
{
  ?GScr_ConnectNodePair@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_GetLootScriptableArray
==============
*/

void __fastcall GScr_GetLootScriptableArray(scrContext_t *scrContext)
{
  ?GScr_GetLootScriptableArray@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
ScrCmd_MakeCollideWithItemClip
==============
*/

void __fastcall ScrCmd_MakeCollideWithItemClip(scrContext_t *scrContext, scr_entref_t entref)
{
  ?ScrCmd_MakeCollideWithItemClip@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_GetFunction
==============
*/

unsigned int __fastcall GScr_GetFunction(const char **pName, BuiltinType *type)
{
  return ?GScr_GetFunction@@YAIPEAPEBDPEAW4BuiltinType@@@Z(pName, type);
}

/*
==============
Scr_SetOrigin
==============
*/

void __fastcall Scr_SetOrigin(scrContext_t *scrContext, gentity_s *ent, int offset)
{
  ?Scr_SetOrigin@@YAXAEAUscrContext_t@@PEAUgentity_s@@H@Z(scrContext, ent, offset);
}

/*
==============
GScr_SetScriptablePayloadModel
==============
*/

void __fastcall GScr_SetScriptablePayloadModel(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScr_SetScriptablePayloadModel@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_SetScriptablePayloadWeapon
==============
*/

void __fastcall GScr_SetScriptablePayloadWeapon(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScr_SetScriptablePayloadWeapon@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_Scriptable_GetScriptableInstanceFromIndex
==============
*/

void __fastcall GScr_Scriptable_GetScriptableInstanceFromIndex(scrContext_t *scrContext)
{
  ?GScr_Scriptable_GetScriptableInstanceFromIndex@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_LoadLevel
==============
*/

void GScr_LoadLevel(void)
{
  ?GScr_LoadLevel@@YAXXZ();
}

/*
==============
GScr_GetScriptableArray
==============
*/
void GScr_GetScriptableArray(scrContext_t *scrContext, const unsigned int begin, const unsigned int end, const int *offset, const scr_string_t name, const vec3_t *fromOrigin, const float radius, const scr_string_t partName)
{
  unsigned int v10; 
  unsigned int v11; 
  const scriptable_field_t *v14; 
  bool v18; 
  bool v19; 
  const char *v21; 
  ComErrorCode v22; 
  ScriptableInstance *v23; 
  int v24; 
  bool v25; 
  __int64 v38; 
  ScriptableInstance *outInstance; 

  __asm { vmovaps [rsp+98h+var_48], xmm6 }
  v10 = end;
  v11 = begin;
  if ( begin > end && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_scriptable.cpp", 357, ASSERT_TYPE_ASSERT, "( begin <= end )", (const char *)&queryFormat, "begin <= end") )
    __debugbreak();
  _R14 = fromOrigin;
  v14 = NULL;
  __asm
  {
    vmovss  xmm0, [rsp+98h+radius]
    vmulss  xmm6, xmm0, xmm0
  }
  if ( fromOrigin )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [r14]
      vmovss  dword ptr [rsp+98h+outInstance], xmm0
    }
    if ( ((unsigned int)outInstance & 0x7F800000) == 2139095040 )
      goto LABEL_47;
    __asm
    {
      vmovss  xmm0, dword ptr [r14+4]
      vmovss  dword ptr [rsp+98h+outInstance], xmm0
    }
    if ( ((unsigned int)outInstance & 0x7F800000) == 2139095040 )
      goto LABEL_47;
    __asm
    {
      vmovss  xmm0, dword ptr [r14+8]
      vmovss  dword ptr [rsp+98h+outInstance], xmm0
    }
    v18 = ((unsigned int)outInstance & 0x7F800000) < 0x7F800000;
    if ( ((unsigned int)outInstance & 0x7F800000) == 2139095040 )
    {
LABEL_47:
      v19 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_scriptable.cpp", 364, ASSERT_TYPE_SANITY, "( !IS_NAN( ( *fromOrigin )[0] ) && !IS_NAN( ( *fromOrigin )[1] ) && !IS_NAN( ( *fromOrigin )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( *fromOrigin )[0] ) && !IS_NAN( ( *fromOrigin )[1] ) && !IS_NAN( ( *fromOrigin )[2] )");
      v18 = 0;
      if ( v19 )
        __debugbreak();
    }
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcomiss xmm6, xmm0
    }
    if ( v18 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_scriptable.cpp", 365, ASSERT_TYPE_ASSERT, "( radiusSq >= 0 )", (const char *)&queryFormat, "radiusSq >= 0") )
      __debugbreak();
  }
  if ( offset )
  {
    if ( *offset >= 0xCu )
    {
      LODWORD(v38) = *offset;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_scriptable.cpp", 371, ASSERT_TYPE_ASSERT, "(unsigned)( *offset ) < (unsigned)( S_SCRIPTABLE_FIELD_COUNT )", "*offset doesn't index S_SCRIPTABLE_FIELD_COUNT\n\t%i not in [0, %i)", v38, 12) )
        __debugbreak();
    }
    v14 = &s_scriptableFields[*offset];
    if ( v14->type == F_STRING )
    {
      if ( v14->ofs != -1 )
        goto LABEL_22;
      v21 = "key cannot be used for lookup";
      v22 = COM_ERR_2780;
    }
    else
    {
      v21 = "key is not internally a string";
      v22 = COM_ERR_2779;
    }
    Scr_ParamError(v22, scrContext, 1u, v21);
  }
LABEL_22:
  Scr_MakeArray(scrContext);
  while ( v11 < v10 )
  {
    if ( ScriptableSv_GetInstanceInUse(v11) && ScriptableSv_GetInstanceCommonContext(v11)->linkedObjectType == SCRIPTABLE_LINK_NONE )
    {
      if ( offset )
      {
        if ( !v14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_scriptable.cpp", 401, ASSERT_TYPE_ASSERT, "( field )", (const char *)&queryFormat, "field") )
          __debugbreak();
        if ( !ScriptableCommon_GetMapInstance(v11, (const ScriptableInstance **)&outInstance) )
          goto LABEL_43;
        v23 = outInstance;
        if ( !outInstance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_scriptable.cpp", 409, ASSERT_TYPE_ASSERT, "( instance )", (const char *)&queryFormat, "instance") )
          __debugbreak();
        v24 = *(_DWORD *)((char *)&v23->initialDef + v14->ofs);
        v10 = end;
        if ( !v24 )
          goto LABEL_43;
        v25 = v24 == name;
      }
      else
      {
        if ( !name )
          goto LABEL_38;
        v25 = ScriptableSv_GetInstanceType(v11) == name;
      }
      if ( v25 )
      {
LABEL_38:
        if ( !fromOrigin )
          goto LABEL_48;
        ScriptableSv_GetInstanceOrigin(v11);
        __asm
        {
          vmovss  xmm0, dword ptr [r14]
          vmovss  xmm1, dword ptr [r14+4]
          vsubss  xmm3, xmm0, dword ptr [rax]
          vsubss  xmm2, xmm1, dword ptr [rax+4]
          vmovss  xmm0, dword ptr [r14+8]
          vsubss  xmm4, xmm0, dword ptr [rax+8]
          vmulss  xmm2, xmm2, xmm2
          vmulss  xmm1, xmm3, xmm3
          vmulss  xmm0, xmm4, xmm4
          vaddss  xmm3, xmm2, xmm1
          vaddss  xmm2, xmm3, xmm0
          vcomiss xmm2, xmm6
        }
        if ( v18 || v25 )
        {
LABEL_48:
          if ( !partName || ScriptableSv_GetPartScriptedDefFromName(v11, partName, 0) )
          {
            Scr_AddEntityNum(scrContext, v11, ENTITY_CLASS_SCRIPTABLE);
            Scr_AddArray(scrContext);
          }
        }
      }
    }
LABEL_43:
    ++v11;
  }
  __asm { vmovaps xmm6, [rsp+98h+var_48] }
}

/*
==============
ScrCmd_SetTeamInHudData
==============
*/
void ScrCmd_SetTeamInHudData(scrContext_t *scrContext, scr_entref_t entref)
{
  char Int; 
  gentity_s *Entity; 
  HudData *HudData; 

  if ( MLG_IsCoDCasterEnabled() )
  {
    if ( !Scr_GetNumParam(scrContext) )
      Scr_Error(COM_ERR_4108, scrContext, "SetTeamInHudData takes at least 1 parameter");
    Int = Scr_GetInt(scrContext, 0);
    Entity = GetEntity(entref);
    HudData = G_HudOutline_GetHudData(Entity);
    if ( !HudData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 6612, ASSERT_TYPE_ASSERT, "( hudData ) != ( nullptr )", "%s != %s\n\t%p, %p", "hudData", "nullptr", NULL, NULL) )
      __debugbreak();
    HudData->data &= 0xFFFFFE7F;
    HudData->data |= (Int & 3) << 7;
  }
}

/*
==============
Scr_GetMLGSettings
==============
*/
void Scr_GetMLGSettings(scrContext_t *scrContext)
{
  int Int; 
  const DDLDef *DDLDef; 
  const DDLContext *DDLContext; 
  DDLState state; 

  if ( !Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_4109, scrContext, "GetMLGSettings takes at least 1 parameter");
  Int = Scr_GetInt(scrContext, 0);
  if ( GamerProfile_IsDDLMounted(Int, MLG_SETTINGS) )
  {
    DDLDef = GamerProfile_GetDDLDef(Int, MLG_SETTINGS);
    __asm { vpxor   xmm0, xmm0, xmm0 }
    state.isValid = 0;
    state.offset = 0;
    state.arrayIndex = -1;
    __asm { vmovdqu xmmword ptr [rsp+58h+state.member], xmm0 }
    DDLContext = GamerProfile_GetDDLContext(Int, MLG_SETTINGS);
    GamerProfile_GetDDLState(&state, Int, MLG_SETTINGS);
    GScr_Main_GetDDL(scrContext, &state, DDLDef, DDLContext, "GetMLGSettings", 1);
  }
  else
  {
    Scr_AddUndefined(scrContext);
  }
}

/*
==============
ScrCmd_SetOtherEnt
==============
*/
void ScrCmd_SetOtherEnt(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( Entity->client )
  {
    Scr_Error(COM_ERR_4110, scrContext, "SetOtherEnt() cannot be called on a client");
  }
  else if ( Scr_GetType(scrContext, 0) )
  {
    Entity->s.otherEntityNum = GScr_GetEntity(0)->s.number;
  }
  else
  {
    Entity->s.otherEntityNum = 2047;
  }
}

/*
==============
GScr_Spawn
==============
*/
void GScr_Spawn(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  int v3; 
  int Int; 
  const char *v9; 
  const char *v10; 
  vec3_t vectorValue; 

  ConstString = Scr_GetConstString(scrContext, 0);
  Scr_GetVector(scrContext, 1u, &vectorValue);
  v3 = 0;
  if ( Scr_GetNumParam(scrContext) <= 2 )
    Int = 0;
  else
    Int = Scr_GetInt(scrContext, 2u);
  if ( Scr_GetNumParam(scrContext) > 3 )
    v3 = Scr_GetInt(scrContext, 3u);
  _RBX = G_Utils_SpawnEntity();
  Scr_SetString(&_RBX->script_classname, ConstString);
  __asm
  {
    vmovss  xmm0, dword ptr [rsp+58h+vectorValue]
    vmovss  dword ptr [rbx+130h], xmm0
    vmovss  xmm1, dword ptr [rsp+58h+vectorValue+4]
    vmovss  dword ptr [rbx+134h], xmm1
    vmovss  xmm0, dword ptr [rsp+58h+vectorValue+8]
    vmovss  dword ptr [rbx+138h], xmm0
  }
  _RBX->spawnflags = Int;
  if ( G_Spawn_CallForEntity(_RBX) )
  {
    if ( v3 == 1 )
      GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(&_RBX->s.lerp.eFlags, ACTIVE, 0);
    GScr_AddEntity(_RBX);
  }
  else
  {
    G_FreeEntity(_RBX);
    v9 = SL_ConvertToString(ConstString);
    v10 = j_va("unable to spawn \"%s\" entity", v9);
    Scr_Error(COM_ERR_4111, scrContext, v10);
  }
}

/*
==============
GScr_SpawnScriptItem
==============
*/
void GScr_SpawnScriptItem(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  gentity_s *v3; 
  const char *v4; 
  const char *v5; 

  ConstString = Scr_GetConstString(scrContext, 0);
  v3 = G_Utils_SpawnEntity();
  Scr_SetString(&v3->script_classname, ConstString);
  if ( G_Spawn_CallForEntity(v3) )
  {
    GScr_AddEntity(v3);
  }
  else
  {
    G_FreeEntity(v3);
    v4 = SL_ConvertToString(ConstString);
    v5 = j_va("unable to spawn \"%s\" entity", v4);
    Scr_Error(COM_ERR_4112, scrContext, v5);
  }
}

/*
==============
GScr_SpawnCoverWall
==============
*/
void GScr_SpawnCoverWall(scrContext_t *scrContext)
{
  unsigned int Int; 
  unsigned int NumParam; 
  const dvar_t *v4; 
  const gentity_s *v5; 
  vec3_t vectorValue; 
  vec3_t origin; 

  Int = 0;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam - 2 <= 1 )
  {
    Scr_GetVector(scrContext, 1u, &vectorValue);
    Scr_GetVector(scrContext, 0, &origin);
    if ( NumParam == 3 )
    {
      Int = Scr_GetInt(scrContext, 2u);
      if ( Int - 1 > 0xFE )
      {
        v4 = DVARINT_g_coverWall_coverHealth;
        if ( !DVARINT_g_coverWall_coverHealth && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "g_coverWall_coverHealth") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v4);
        Com_PrintWarning(16, "Warning: SpawnCoverWall - healthPerBlock %d is out of range [1,255], using default value %d\n", Int, v4->current.unsignedInt);
        Int = 0;
      }
    }
    v5 = G_CoverWall_Spawn(&origin, &vectorValue, Int);
    if ( v5 )
    {
      GScr_AddEntity(v5);
    }
    else
    {
      Com_PrintWarning(16, "Warning: SpawnCoverWall failed - reached max of %d coverwalls in the world.\n", 16i64);
      Scr_AddUndefined(scrContext);
    }
  }
  else
  {
    Scr_Error(COM_ERR_4113, scrContext, "USAGE: SpawnCoverWall( <origin>, <angles> <optional:healthPerBlock> )\n");
  }
}

/*
==============
ScrCmd_DeSpawnCoverWall
==============
*/
void ScrCmd_DeSpawnCoverWall(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  bool v4; 

  Entity = GetEntity(entref);
  if ( Entity->s.eType == ET_COVERWALL )
  {
    v4 = 0;
    if ( Scr_GetNumParam(scrContext) )
      v4 = Scr_GetInt(scrContext, 0) != 0;
    G_CoverWall_DeSpawn(Entity, v4);
  }
  else
  {
    Scr_Error(COM_ERR_4114, scrContext, " DeSpawnCoverWall() called on an entity that is not a cover wall.\n");
  }
}

/*
==============
GScr_Turret_Spawn
==============
*/
void GScr_Turret_Spawn(scrContext_t *scrContext)
{
  int Int; 
  scr_string_t ConstString; 
  bool outIsAlternate; 
  vec3_t vectorValue; 
  Weapon outWeapon; 

  Int = 1;
  ConstString = Scr_GetConstString(scrContext, 0);
  Scr_GetVector(scrContext, 1u, &vectorValue);
  GScr_Main_GetWeaponParam(scrContext, 2u, &outWeapon, &outIsAlternate);
  _RDI = G_Utils_SpawnEntity();
  Scr_SetString(&_RDI->classname, ConstString);
  Scr_SetString(&_RDI->script_classname, ConstString);
  __asm
  {
    vmovss  xmm0, dword ptr [rsp+88h+vectorValue]
    vmovss  dword ptr [rdi+130h], xmm0
    vmovss  xmm1, dword ptr [rsp+88h+vectorValue+4]
    vmovss  dword ptr [rdi+134h], xmm1
    vmovss  xmm0, dword ptr [rsp+88h+vectorValue+8]
    vmovss  dword ptr [rdi+138h], xmm0
  }
  if ( Scr_GetNumParam(scrContext) > 3 )
    Int = Scr_GetInt(scrContext, 3u);
  G_Turret_Spawn(scrContext, _RDI, &outWeapon, Int);
  GScr_AddEntity(_RDI);
}

/*
==============
GScr_Turret_CanSpawn
==============
*/
void GScr_Turret_CanSpawn(scrContext_t *scrContext)
{
  bool CanSpawnTurret; 

  CanSpawnTurret = GTurret::CanSpawnTurret();
  Scr_AddBool(scrContext, CanSpawnTurret);
}

/*
==============
GScr_Turret_Precache
==============
*/
void GScr_Turret_Precache(scrContext_t *scrContext)
{
  const char *String; 
  Weapon result; 

  if ( NetConstStrings_IsPrecacheAllowed() )
  {
    if ( !level.initializing )
      Scr_Error(COM_ERR_4115, scrContext, "precacheTurret must be called before any wait statements in the level script\n");
    String = Scr_GetString(scrContext, 0);
    GScr_Main_GetWeaponForName(&result, scrContext, String);
  }
}

/*
==============
ScrCmd_attach
==============
*/
void ScrCmd_attach(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t tagNameResult; 

  Entity = GetEntity(entref);
  AttachCmd(scrContext, Entity, &tagNameResult);
}

/*
==============
ScrCmd_attachShieldModel
==============
*/
void ScrCmd_attachShieldModel(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  char *client; 
  const char *v6; 
  scr_string_t tagNameResult; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3682, scrContext, "not an entity");
    client = NULL;
    v4 = NULL;
LABEL_9:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 7059, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
      __debugbreak();
    goto LABEL_11;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 7057, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = (char *)v4->client;
  if ( !client )
  {
    client = (char *)v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3679, scrContext, v6);
      goto LABEL_9;
    }
  }
LABEL_11:
  if ( AttachCmd(scrContext, v4, &tagNameResult) )
  {
    GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal((GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *)(client + 28), ACTIVE, 8u);
    if ( G_Utils_IsAgent(v4) )
    {
      if ( !v4->agent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 7069, ASSERT_TYPE_ASSERT, "( pSelf->agent )", (const char *)&queryFormat, "pSelf->agent") )
        __debugbreak();
      Scr_SetString(&v4->agent->attachShieldTagName, tagNameResult);
    }
    else
    {
      if ( !v4->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 7074, ASSERT_TYPE_ASSERT, "( pSelf->client )", (const char *)&queryFormat, "pSelf->client") )
        __debugbreak();
      Scr_SetString(&v4->client->attachShieldTagName, tagNameResult);
    }
  }
}

/*
==============
GScr_GetScriptBundle
==============
*/
void GScr_GetScriptBundle(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  unsigned int v3; 
  XAssetHeader v4; 
  XAssetHeader v5; 
  ScriptBundleValue *v6; 
  GScr_ScriptBundleContext ctxt; 

  ConstString = Scr_GetConstString(scrContext, 0);
  if ( !ConstString && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\script\\scr_stringlist.h", 158, ASSERT_TYPE_ASSERT, "( stringValue )", (const char *)&queryFormat, "stringValue") )
    __debugbreak();
  v3 = 16 * ConstString;
  if ( v3 >= 0x800000 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\script\\scr_stringlist.h", 159, ASSERT_TYPE_ASSERT, "( stringValue * MT_NODE_SIZE < MT_SIZE )", (const char *)&queryFormat, "stringValue * MT_NODE_SIZE < MT_SIZE") )
    __debugbreak();
  v4.physicsLibrary = DB_FindXAssetHeader(ASSET_TYPE_SCRIPTBUNDLE, &scrMemTreePub.mt_buffer[v3 + 8], 0).physicsLibrary;
  v5.physicsLibrary = v4.physicsLibrary;
  if ( v4.physicsLibrary )
  {
    if ( SLODWORD(v4.physicsLibrary[1].name) <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 26230, ASSERT_TYPE_ASSERT, "(bundle.scriptBundle->rootSize > 0)", (const char *)&queryFormat, "bundle.scriptBundle->rootSize > 0") )
      __debugbreak();
    ctxt.strPool = v5.physicsLibrary->havokData;
    ctxt.currentAnimTree = s_defaultScriptbundleAnimtree;
    ctxt.pScrContext = scrContext;
    ScriptContext_GetInstance(scrContext);
    v6 = *(ScriptBundleValue **)&v5.physicsLibrary[1].isMaterialList;
    ctxt.anim_user = 1;
    GScr_SBAddObject(&ctxt, v6);
  }
  else
  {
    Scr_AddUndefined(scrContext);
  }
}

/*
==============
GScr_IPrintLn_f
==============
*/
void GScr_IPrintLn_f(scrContext_t *scrContext)
{
  GScr_MakeGameMessage(scrContext, -1, 102);
}

/*
==============
GScr_IPrintLnBold_f
==============
*/
void GScr_IPrintLnBold_f(scrContext_t *scrContext)
{
  GScr_MakeGameMessage(scrContext, -1, 103);
}

/*
==============
GScr_AssertDemo
==============
*/
void GScr_AssertDemo(scrContext_t *scrContext)
{
  ;
}

/*
==============
Scr_GetReflectionLocs
==============
*/
void Scr_GetReflectionLocs(scrContext_t *scrContext)
{
  Scr_MakeArray(scrContext);
}

/*
==============
ScrCmd_moveShieldModel
==============
*/
void ScrCmd_moveShieldModel(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  const char *String; 
  scr_string_t ConstLowercaseString; 
  scr_string_t v8; 
  bool v9; 
  const char *v10; 
  const char *v11; 
  bool v12; 
  unsigned int *p_attachModelIsOnBack; 
  __int64 v14; 
  scr_string_t *p_attachShieldTagName; 
  unsigned int outModelIndex; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3678, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 7104, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client && !v4->agent )
    {
      v5 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3677, scrContext, v5);
    }
  }
  String = Scr_GetString(scrContext, 0);
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 1u);
  v8 = Scr_GetConstLowercaseString(scrContext, 2u);
  v9 = Scr_GetNumParam(scrContext) >= 4 && Scr_GetInt(scrContext, 3u) != 0;
  if ( !G_Utils_EntChangeAttachTag(v4, String, ConstLowercaseString, v8, &outModelIndex) )
  {
    v10 = SL_ConvertToString(ConstLowercaseString);
    v11 = j_va("model '%s' not attached to tag '%s'", String, v10);
    Scr_Error(COM_ERR_4119, scrContext, v11);
  }
  v12 = !v9;
  p_attachModelIsOnBack = &v4->attachModelIsOnBack;
  v14 = (int)outModelIndex;
  if ( v12 )
  {
    if ( v4 == (gentity_s *)-1448i64 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_bitset.h", 28, ASSERT_TYPE_SANITY, "( array )", (const char *)&queryFormat, "array") )
      __debugbreak();
    p_attachModelIsOnBack[v14 >> 5] &= ~(1 << (v14 & 0x1F));
  }
  else
  {
    if ( v4 == (gentity_s *)-1448i64 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_bitset.h", 20, ASSERT_TYPE_SANITY, "( array )", (const char *)&queryFormat, "array") )
      __debugbreak();
    p_attachModelIsOnBack[v14 >> 5] |= 1 << (v14 & 0x1F);
  }
  if ( G_Utils_IsAgent(v4) )
  {
    if ( !v4->agent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 7128, ASSERT_TYPE_ASSERT, "( pSelf->agent )", (const char *)&queryFormat, "pSelf->agent") )
      __debugbreak();
    p_attachShieldTagName = &v4->agent->attachShieldTagName;
  }
  else
  {
    if ( !v4->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 7133, ASSERT_TYPE_ASSERT, "( pSelf->client )", (const char *)&queryFormat, "pSelf->client") )
      __debugbreak();
    p_attachShieldTagName = &v4->client->attachShieldTagName;
  }
  Scr_SetString(p_attachShieldTagName, v8);
}

/*
==============
ScrCmd_SetMusicState
==============
*/
void ScrCmd_SetMusicState(scrContext_t *scrContext)
{
  unsigned int NumParam; 
  const char *String; 
  unsigned int v4; 
  unsigned int v5; 
  int v6; 
  unsigned int ArrayObject; 
  unsigned int FirstSibling; 
  scr_string_t *VariableValueAddress; 
  const char *v10; 
  unsigned int v11; 
  SndMusicState *MusicState; 
  unsigned int loopCount; 
  int v14; 
  char dest[884]; 

  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam - 1 <= 1 )
  {
    String = Scr_GetString(scrContext, 0);
    v4 = SND_HashName(String);
    v5 = v4;
    if ( v4 )
    {
      if ( !SND_GetMusicState(v4) )
      {
        Com_PrintError(9, "SOUND: ScrCmd_SetMusicState - Unknown music state '%s' %x\n", String, v5);
        v5 = 0;
      }
    }
    v6 = Com_sprintf<884>((char (*)[884])dest, "%c %x %x", 112i64, v5, 0i64) - 1;
    if ( NumParam == 2 )
    {
      if ( Scr_GetType(scrContext, 1u) == VAR_POINTER )
      {
        if ( Scr_GetPointerType(scrContext, 1u) == VAR_ARRAY )
        {
          ArrayObject = BGScr_Main_GetArrayObject(scrContext, 1u);
          FirstSibling = FindFirstSibling(scrContext, ArrayObject);
          if ( FirstSibling )
          {
            while ( (unsigned __int64)v6 <= 0x36A )
            {
              if ( GetValueType(scrContext, FirstSibling) != VAR_STRING )
              {
                Scr_Error(COM_ERR_6509, scrContext, "SetMusicState: Array entry is not a string.");
                return;
              }
              VariableValueAddress = (scr_string_t *)GetVariableValueAddress(scrContext, FirstSibling);
              v10 = SL_ConvertToString(*VariableValueAddress);
              v11 = SND_HashName(v10);
              MusicState = SND_GetMusicState(v5);
              if ( MusicState )
              {
                loopCount = MusicState->loopCount;
                v14 = 0;
                if ( loopCount )
                {
                  while ( MusicState->loops[v14].aliasId != v11 )
                  {
                    if ( ++v14 >= loopCount )
                      goto LABEL_18;
                  }
                }
                else
                {
LABEL_18:
                  Com_PrintError(9, "SOUND: ScrCmd_SetMusicState - Loop alias '%s' not found in state '%s'\n", v10, String);
                  v11 = 0;
                }
              }
              v6 = v6 + Com_sprintf(&dest[v6], 884i64 - v6, " %x", v11) - 1;
              FirstSibling = FindNextSibling(scrContext, FirstSibling);
              if ( !FirstSibling )
                goto LABEL_20;
            }
            Scr_Error(COM_ERR_6508, scrContext, "SetMusicState: Out of memory for playlist array.");
          }
        }
        else
        {
          Scr_Error(COM_ERR_6507, scrContext, "SetMusicState: 2nd parameter is an incorrect type.");
        }
      }
      else
      {
        Scr_Error(COM_ERR_6506, scrContext, "SetMusicState: 2nd parameter is an incorrect type.");
      }
    }
    else
    {
LABEL_20:
      SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, dest);
    }
  }
  else
  {
    Scr_Error(COM_ERR_4718, scrContext, "SetMusicState: Incorrect number of parameters\n");
  }
}

/*
==============
ScrCmd_getShieldMaxEnergy
==============
*/
void ScrCmd_getShieldMaxEnergy(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v5; 
  const char *v6; 
  ComErrorCode v7; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
LABEL_9:
    Scr_ObjectError(v7, scrContext, v6);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 7151, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
      __debugbreak();
    goto LABEL_11;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 7150, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v5 = &g_entities[entnum];
  if ( !v5->client && !v5->agent )
  {
    v6 = j_va("entity %i is not a player or agent", entnum);
    v7 = COM_ERR_3679;
    goto LABEL_9;
  }
LABEL_11:
  __asm { vxorps  xmm1, xmm1, xmm1; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
ScrCmd_SetSpaceJump
==============
*/
void ScrCmd_SetSpaceJump(scrContext_t *scrContext, scr_entref_t entref)
{
  ;
}

/*
==============
ScrCmd_SetPlayerMusicState
==============
*/
void ScrCmd_SetPlayerMusicState(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  int number; 
  const char *v7; 
  const char *v8; 
  unsigned int NumParam; 
  const char *String; 
  unsigned int v11; 
  unsigned int v12; 
  int v13; 
  unsigned int ArrayObject; 
  unsigned int FirstSibling; 
  scr_string_t *VariableValueAddress; 
  const char *v17; 
  unsigned int v18; 
  SndMusicState *MusicState; 
  unsigned int loopCount; 
  int v21; 
  SvClient *CommonClient; 
  int outControllingClientNum[4]; 
  char dest[884]; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3678, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 26460, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client && !v4->agent )
    {
      v5 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3677, scrContext, v5);
    }
  }
  number = v4->s.number;
  outControllingClientNum[0] = number;
  if ( !SV_IsAgent(number) || SV_GetAgentControlledByPlayerNum(outControllingClientNum[0], outControllingClientNum) )
  {
    if ( outControllingClientNum[0] < level.maxclients )
    {
      NumParam = Scr_GetNumParam(scrContext);
      if ( NumParam - 1 <= 1 )
      {
        String = Scr_GetString(scrContext, 0);
        v11 = SND_HashName(String);
        v12 = v11;
        if ( v11 && !SND_GetMusicState(v11) )
        {
          Com_PrintError(9, "SOUND: ScrCmd_SetPlayerMusicState - Unknown music state '%s' %x\n", String, v12);
          v12 = 0;
        }
        v13 = Com_sprintf<884>((char (*)[884])dest, "%c %x %x", 112i64, v12, 0i64);
        if ( NumParam == 2 )
        {
          if ( Scr_GetType(scrContext, 1u) == VAR_POINTER )
          {
            if ( Scr_GetPointerType(scrContext, 1u) == VAR_ARRAY )
            {
              ArrayObject = BGScr_Main_GetArrayObject(scrContext, 1u);
              FirstSibling = FindFirstSibling(scrContext, ArrayObject);
              if ( FirstSibling )
              {
                while ( (unsigned __int64)v13 <= 0x36A )
                {
                  if ( GetValueType(scrContext, FirstSibling) != VAR_STRING )
                  {
                    Scr_Error(COM_ERR_6513, scrContext, "SetPlayerMusicState: Array entry is not a string.");
                    return;
                  }
                  VariableValueAddress = (scr_string_t *)GetVariableValueAddress(scrContext, FirstSibling);
                  v17 = SL_ConvertToString(*VariableValueAddress);
                  v18 = SND_HashName(v17);
                  MusicState = SND_GetMusicState(v12);
                  if ( MusicState )
                  {
                    loopCount = MusicState->loopCount;
                    v21 = 0;
                    if ( loopCount )
                    {
                      while ( MusicState->loops[v21].aliasId != v18 )
                      {
                        if ( ++v21 >= loopCount )
                          goto LABEL_31;
                      }
                    }
                    else
                    {
LABEL_31:
                      Com_PrintError(9, "SOUND: ScrCmd_SetPlayerMusicState - Loop alias '%s' not found in state '%s'\n", v17, String);
                      v18 = 0;
                    }
                  }
                  v13 += Com_sprintf(&dest[v13], 884i64 - v13, " %x", v18);
                  FirstSibling = FindNextSibling(scrContext, FirstSibling);
                  if ( !FirstSibling )
                    goto LABEL_33;
                }
                Scr_Error(COM_ERR_6512, scrContext, "SetPlayerMusicState: Out of memory for playlist array.");
              }
            }
            else
            {
              Scr_Error(COM_ERR_6511, scrContext, "SetPlayerMusicState: 2nd parameter is an incorrect type.");
            }
          }
          else
          {
            Scr_Error(COM_ERR_6510, scrContext, "SetPlayerMusicState: 2nd parameter is an incorrect type.");
          }
        }
        else
        {
LABEL_33:
          if ( outControllingClientNum[0] == -1 )
          {
            SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, dest);
          }
          else
          {
            CommonClient = SvClient::GetCommonClient(outControllingClientNum[0]);
            CommonClient->SendServerCommand(CommonClient, SV_CMD_RELIABLE, dest);
          }
        }
      }
      else
      {
        Scr_Error(COM_ERR_4720, scrContext, "SetPlayerMusicState: Incorrect number of parameters\n");
      }
    }
    else
    {
      v8 = j_va("Invalid entity index %d before SV_Game_SendServerCommand\n", (unsigned int)outControllingClientNum[0]);
      Scr_Error(COM_ERR_6409, scrContext, v8);
    }
  }
  else
  {
    v7 = j_va("entity %i is not a player or player-controlled agent", entnum);
    Scr_ObjectError(COM_ERR_4719, scrContext, v7);
  }
}

/*
==============
ScrCmd_ClearSpaceJump
==============
*/
void ScrCmd_ClearSpaceJump(scrContext_t *scrContext, scr_entref_t entref)
{
  ;
}

/*
==============
ScrCmd_ModifySpaceJumpPath
==============
*/
void ScrCmd_ModifySpaceJumpPath(scrContext_t *scrContext, scr_entref_t entref)
{
  ;
}

/*
==============
ScrCmd_StartSpaceJumpDeath
==============
*/
void ScrCmd_StartSpaceJumpDeath(scrContext_t *scrContext, scr_entref_t entref)
{
  ;
}

/*
==============
ScrCmd_GetSpaceJumpState
==============
*/
void ScrCmd_GetSpaceJumpState(scrContext_t *scrContext, scr_entref_t entref)
{
  ;
}

/*
==============
ScrCmd_SetSpaceJumpEntOverride
==============
*/
void ScrCmd_SetSpaceJumpEntOverride(scrContext_t *scrContext, scr_entref_t entref)
{
  ;
}

/*
==============
ScrCmd_ClearSpaceJumpEntOverride
==============
*/
void ScrCmd_ClearSpaceJumpEntOverride(scrContext_t *scrContext, scr_entref_t entref)
{
  ;
}

/*
==============
ScrCmd_ForceSpaceJump
==============
*/
void ScrCmd_ForceSpaceJump(scrContext_t *scrContext, scr_entref_t entref)
{
  ;
}

/*
==============
ScrCmd_TrackMovingPlatformTilt
==============
*/
void ScrCmd_TrackMovingPlatformTilt(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  char *client; 
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *v6; 
  const char *v7; 
  ComErrorCode v8; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v7 = "not an entity";
    v8 = COM_ERR_3682;
    goto LABEL_12;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 7556, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = (char *)v4->client;
  if ( !client )
  {
    client = (char *)v4->agent;
    if ( !client )
    {
      v7 = j_va("entity %i is not a player or agent", entnum);
      v8 = COM_ERR_3679;
LABEL_12:
      Scr_ObjectError(v8, scrContext, v7);
      Scr_Error(COM_ERR_4138, scrContext, "ModifySpaceJumpPath must be called on a player.");
      return;
    }
  }
  v6 = (GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *)(client + 28);
  if ( Scr_GetInt(scrContext, 0) )
    GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal(v6, ACTIVE, 0xFu);
  else
    GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal(v6, ACTIVE, 0xFu);
}

/*
==============
ScrCmd_getShieldCurrentEnergy
==============
*/
void ScrCmd_getShieldCurrentEnergy(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v5; 
  const char *v6; 
  ComErrorCode v7; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
LABEL_9:
    Scr_ObjectError(v7, scrContext, v6);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 7588, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
      __debugbreak();
    goto LABEL_11;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 7587, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v5 = &g_entities[entnum];
  if ( !v5->client && !v5->agent )
  {
    v6 = j_va("entity %i is not a player or agent", entnum);
    v7 = COM_ERR_3679;
    goto LABEL_9;
  }
LABEL_11:
  __asm { vxorps  xmm1, xmm1, xmm1; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
ScrCmd_StopMusicState
==============
*/
void ScrCmd_StopMusicState(scrContext_t *scrContext)
{
  const char *String; 
  unsigned int v3; 
  unsigned int v4; 
  const char *v5; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    String = Scr_GetString(scrContext, 0);
    v3 = SND_HashName(String);
    v4 = v3;
    if ( v3 )
    {
      if ( !SND_GetMusicState(v3) )
      {
        Com_PrintError(9, "SOUND: Unknown music state '%s' %x\n", String, v4);
        v4 = 0;
      }
    }
    v5 = j_va("%c %x %x", 112i64, v4, 1i64);
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v5);
  }
  else
  {
    Scr_Error(COM_ERR_6502, scrContext, "StopMusicState: Incorrect number of parameters\n");
  }
}

/*
==============
ScrCmd_StopPlayerMusicState
==============
*/
void ScrCmd_StopPlayerMusicState(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  int number; 
  const char *v7; 
  const char *v8; 
  const char *String; 
  unsigned int v10; 
  unsigned int v11; 
  const char *v12; 
  const char *v13; 
  SvClient *CommonClient; 
  int outControllingClientNum; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3678, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 26628, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client && !v4->agent )
    {
      v5 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3677, scrContext, v5);
    }
  }
  number = v4->s.number;
  outControllingClientNum = number;
  if ( !SV_IsAgent(number) || SV_GetAgentControlledByPlayerNum(outControllingClientNum, &outControllingClientNum) )
  {
    if ( outControllingClientNum < level.maxclients )
    {
      if ( Scr_GetNumParam(scrContext) == 1 )
      {
        String = Scr_GetString(scrContext, 0);
        v10 = SND_HashName(String);
        v11 = v10;
        if ( v10 && !SND_GetMusicState(v10) )
        {
          Com_PrintError(9, "SOUND: Unknown music state '%s' %x\n", String, v11);
          v11 = 0;
        }
        v12 = j_va("%c %x %x", 112i64, v11, 1i64);
        v13 = v12;
        if ( outControllingClientNum == -1 )
        {
          SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v12);
        }
        else
        {
          CommonClient = SvClient::GetCommonClient(outControllingClientNum);
          CommonClient->SendServerCommand(CommonClient, SV_CMD_RELIABLE, v13);
        }
      }
      else
      {
        Scr_Error(COM_ERR_6505, scrContext, "StopPlayerMusicState: Incorrect number of parameters\n");
      }
    }
    else
    {
      v8 = j_va("Invalid entity index %d before SV_Game_SendServerCommand\n", (unsigned int)outControllingClientNum);
      Scr_Error(COM_ERR_6504, scrContext, v8);
    }
  }
  else
  {
    v7 = j_va("entity %i is not a player or player-controlled agent", entnum);
    Scr_ObjectError(COM_ERR_6503, scrContext, v7);
  }
}

/*
==============
ScrCmd_detach
==============
*/
void ScrCmd_detach(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  DetachCmd(scrContext, Entity);
}

/*
==============
ScrCmd_SetAudioTriggerState
==============
*/
void ScrCmd_SetAudioTriggerState(scrContext_t *scrContext)
{
  unsigned int NumParam; 
  const char *String; 
  const char *v5; 
  unsigned int v6; 
  unsigned int v7; 
  const char *v8; 
  const char *v9; 
  const char *v11; 
  double v12; 

  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam - 2 > 1 )
  {
    Scr_Error(COM_ERR_4721, scrContext, "SetAudioTriggerState: Incorrect number of parameters\n");
  }
  else
  {
    String = Scr_GetString(scrContext, 0);
    v5 = Scr_GetString(scrContext, 1u);
    v6 = SND_HashName(String);
    v7 = SND_HashName(v5);
    if ( !CG_CheckAudioStateId(String) )
    {
      v8 = j_va("SetAudioZoneState: Bad state id name: %s\n", String);
      Scr_Error(COM_ERR_4722, scrContext, v8);
    }
    if ( !SV_CheckAudioStateName(v5) )
    {
      v9 = j_va("SetAudioZoneState: Bad state name: %s\n", v5);
      Scr_Error(COM_ERR_4723, scrContext, v9);
    }
    if ( NumParam == 3 )
    {
      *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
      __asm
      {
        vcvtss2sd xmm1, xmm0, xmm0
        vmovsd  [rsp+48h+var_20], xmm1
      }
      v11 = j_va("%c %c %x %x %g", 109i64, 97i64, v6, v7, v12);
    }
    else
    {
      v11 = j_va("%c %c %x %x", 109i64, 97i64, v6, v7);
    }
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v11);
  }
}

/*
==============
ScrCmd_detachShieldModel
==============
*/
void ScrCmd_detachShieldModel(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  char *client; 
  const char *v6; 
  scr_string_t *p_attachShieldTagName; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3682, scrContext, "not an entity");
    client = NULL;
    v4 = NULL;
LABEL_9:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 7669, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
      __debugbreak();
    goto LABEL_11;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 7667, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = (char *)v4->client;
  if ( !client )
  {
    client = (char *)v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3679, scrContext, v6);
      goto LABEL_9;
    }
  }
LABEL_11:
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal((GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *)(client + 28), ACTIVE, 8u);
  if ( G_Utils_IsAgent(v4) )
  {
    if ( !v4->agent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 7675, ASSERT_TYPE_ASSERT, "( pSelf->agent )", (const char *)&queryFormat, "pSelf->agent") )
      __debugbreak();
    p_attachShieldTagName = &v4->agent->attachShieldTagName;
  }
  else
  {
    if ( !v4->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 7680, ASSERT_TYPE_ASSERT, "( pSelf->client )", (const char *)&queryFormat, "pSelf->client") )
      __debugbreak();
    p_attachShieldTagName = &v4->client->attachShieldTagName;
  }
  Scr_SetString(p_attachShieldTagName, (scr_string_t)0);
  DetachCmd(scrContext, v4);
}

/*
==============
ScrCmd_EnableAudioTrigger
==============
*/
void ScrCmd_EnableAudioTrigger(scrContext_t *scrContext)
{
  ScrCmd_EnableDisableAudioTrigger(scrContext, 1);
}

/*
==============
ScrCmd_DisableAudioTrigger
==============
*/
void ScrCmd_DisableAudioTrigger(scrContext_t *scrContext)
{
  ScrCmd_EnableDisableAudioTrigger(scrContext, 0);
}

/*
==============
ScrCmd_detachAll
==============
*/
void ScrCmd_detachAll(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gclient_s *client; 

  Entity = GetEntity(entref);
  if ( G_Utils_IsAgent(Entity) )
  {
    if ( !Entity->agent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 7706, ASSERT_TYPE_ASSERT, "( ent->agent )", (const char *)&queryFormat, "ent->agent") )
      __debugbreak();
    GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal(&Entity->agent->playerState.otherFlags, ACTIVE, 8u);
    Scr_SetString(&Entity->agent->attachShieldTagName, (scr_string_t)0);
  }
  client = Entity->client;
  if ( client )
  {
    GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal(&client->ps.otherFlags, ACTIVE, 8u);
    Scr_SetString(&Entity->client->attachShieldTagName, (scr_string_t)0);
  }
  if ( !GUtils::ms_gUtils && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_utils.h", 112, ASSERT_TYPE_ASSERT, "( ms_gUtils )", (const char *)&queryFormat, "ms_gUtils") )
    __debugbreak();
  GUtils::ms_gUtils->EntDetachAll(GUtils::ms_gUtils, Entity);
}

/*
==============
ScrCmd_SetGlobalSoundContext
==============
*/
void ScrCmd_SetGlobalSoundContext(scrContext_t *scrContext)
{
  unsigned int NumParam; 
  const char *String; 
  const char *v5; 
  unsigned int v6; 
  unsigned int v7; 
  const char *v9; 
  double v10; 

  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam - 2 > 1 )
  {
    Scr_Error(COM_ERR_4726, scrContext, "SetGlobalSoundContext: Incorrect number of parameters\n");
  }
  else
  {
    String = Scr_GetString(scrContext, 0);
    v5 = Scr_GetString(scrContext, 1u);
    v6 = SND_HashName(String);
    if ( *v5 )
      v7 = SND_HashName(v5);
    else
      v7 = 0;
    if ( NumParam == 3 )
    {
      *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
      __asm
      {
        vcvtss2sd xmm1, xmm0, xmm0
        vmovsd  [rsp+38h+var_10], xmm1
      }
      v9 = j_va("%c %c %x %x %g", 105i64, 98i64, v6, v7, v10);
    }
    else
    {
      v9 = j_va("%c %c %x %x", 105i64, 98i64, v6, v7);
    }
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v9);
  }
}

/*
==============
ScrCmd_GetAttachSize
==============
*/
void ScrCmd_GetAttachSize(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int v4; 
  __int64 v5; 
  unsigned __int16 *v6; 

  Entity = GetEntity(entref);
  v4 = 0;
  v5 = 0i64;
  v6 = &Entity->attachModelNames[1];
  while ( *(v6 - 1) )
  {
    if ( !*v6 )
    {
      ++v4;
      break;
    }
    if ( !v6[1] )
    {
      Scr_AddInt(scrContext, v4 + 2);
      return;
    }
    if ( !v6[2] )
    {
      Scr_AddInt(scrContext, v4 + 3);
      return;
    }
    v5 += 4i64;
    v6 += 4;
    v4 += 4;
    if ( v5 >= 28 )
      break;
  }
  Scr_AddInt(scrContext, v4);
}

/*
==============
ScrCmd_GetAttachModelName
==============
*/
void ScrCmd_GetAttachModelName(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  __int64 v5; 
  unsigned int v6; 
  const char *v7; 

  Entity = GetEntity(entref);
  Int = Scr_GetInt(scrContext, 0);
  v5 = Int;
  if ( (unsigned int)Int >= 0x1C || !Entity->attachModelNames[Int] )
    Scr_ParamError(COM_ERR_4140, scrContext, 0, "bad index");
  v6 = Entity->attachModelNames[v5];
  if ( !GConfigStrings::ms_gConfigStrings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_configstrings.h", 71, ASSERT_TYPE_ASSERT, "( ms_gConfigStrings )", (const char *)&queryFormat, "ms_gConfigStrings") )
    __debugbreak();
  v7 = GConfigStrings::ms_gConfigStrings->GetModelNameString(GConfigStrings::ms_gConfigStrings, v6);
  Scr_AddString(scrContext, v7);
}

/*
==============
ScrCmd_EnablePlayerBreathSystem
==============
*/
void ScrCmd_EnablePlayerBreathSystem(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  int number; 
  const char *v7; 
  const char *v8; 
  unsigned int Int; 
  const char *v10; 
  const char *v11; 
  SvClient *CommonClient; 
  int outControllingClientNum; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3678, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 26898, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client && !v4->agent )
    {
      v5 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3677, scrContext, v5);
    }
  }
  number = v4->s.number;
  outControllingClientNum = number;
  if ( !SV_IsAgent(number) || SV_GetAgentControlledByPlayerNum(outControllingClientNum, &outControllingClientNum) )
  {
    if ( outControllingClientNum < level.maxclients )
    {
      if ( Scr_GetNumParam(scrContext) == 1 )
      {
        Int = Scr_GetInt(scrContext, 0);
        v10 = j_va("%c %d", 121i64, Int);
        v11 = v10;
        if ( outControllingClientNum == -1 )
        {
          SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v10);
        }
        else
        {
          CommonClient = SvClient::GetCommonClient(outControllingClientNum);
          CommonClient->SendServerCommand(CommonClient, SV_CMD_RELIABLE, v11);
        }
      }
      else
      {
        Scr_Error(COM_ERR_4729, scrContext, "EnablePlayerBreathSystem: Incorrect number of parameters\n");
      }
    }
    else
    {
      v8 = j_va("Invalid entity index %d before SV_Game_SendServerCommand\n", (unsigned int)outControllingClientNum);
      Scr_Error(COM_ERR_6410, scrContext, v8);
    }
  }
  else
  {
    v7 = j_va("entity %i is not a player or player-controlled agent", entnum);
    Scr_ObjectError(COM_ERR_4728, scrContext, v7);
  }
}

/*
==============
ScrCmd_GetAttachTagName
==============
*/
void ScrCmd_GetAttachTagName(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  __int64 v5; 

  Entity = GetEntity(entref);
  Int = Scr_GetInt(scrContext, 0);
  v5 = Int;
  if ( (unsigned int)Int >= 0x1C || !Entity->attachModelNames[Int] )
    Scr_ParamError(COM_ERR_4141, scrContext, 0, "bad index");
  if ( !Entity->attachTagNames[v5] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 7796, ASSERT_TYPE_ASSERT, "(ent->attachTagNames[i] != ( static_cast< scr_string_t >( 0 ) ))", (const char *)&queryFormat, "ent->attachTagNames[i] != NULL_SCR_STRING") )
    __debugbreak();
  Scr_AddConstString(scrContext, Entity->attachTagNames[v5]);
}

/*
==============
ScrCmd_EnablePASpeaker
==============
*/
void ScrCmd_EnablePASpeaker(scrContext_t *scrContext)
{
  const char *String; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    String = Scr_GetString(scrContext, 0);
    ScrCmd_EnableDisablePASpeaker(scrContext, String, 1);
  }
  else
  {
    Scr_Error(COM_ERR_4730, scrContext, "EnablePASpeaker: Incorrect number of parameters\n");
  }
}

/*
==============
ScrCmd_GetAttachIgnoreCollision
==============
*/
void ScrCmd_GetAttachIgnoreCollision(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  unsigned int v5; 
  unsigned int attachIgnoreCollision; 

  Entity = GetEntity(entref);
  Int = Scr_GetInt(scrContext, 0);
  v5 = Int;
  if ( (unsigned int)Int >= 0x1C || !Entity->attachModelNames[Int] )
    Scr_ParamError(COM_ERR_4142, scrContext, 0, "bad index");
  attachIgnoreCollision = Entity->attachIgnoreCollision;
  Scr_AddBool(scrContext, _bittest((const int *)&attachIgnoreCollision, v5));
}

/*
==============
ScrCmd_DisablePASpeaker
==============
*/
void ScrCmd_DisablePASpeaker(scrContext_t *scrContext)
{
  const char *String; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    String = Scr_GetString(scrContext, 0);
    ScrCmd_EnableDisablePASpeaker(scrContext, String, 0);
  }
  else
  {
    Scr_Error(COM_ERR_4731, scrContext, "DisablePASpeaker: Incorrect number of parameters\n");
  }
}

/*
==============
GScr_WeaponUsesEnergyBullets
==============
*/
void GScr_WeaponUsesEnergyBullets(scrContext_t *scrContext)
{
  unsigned __int16 weaponIdx; 
  bool v3; 
  WeaponDef **v4; 
  int v5; 
  unsigned int v6; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  weaponIdx = outWeapon.weaponIdx;
  if ( outWeapon.weaponIdx > bg_lastParsedWeaponIndex )
  {
    v6 = bg_lastParsedWeaponIndex;
    v5 = outWeapon.weaponIdx;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1203, ASSERT_TYPE_ASSERT, "( weaponIdx ) <= ( bg_lastParsedWeaponIndex )", "weaponIdx not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", v5, v6) )
      __debugbreak();
  }
  v3 = bg_weaponDefs[weaponIdx] == NULL;
  v4 = &bg_weaponDefs[weaponIdx];
  if ( v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1204, ASSERT_TYPE_ASSERT, "(bg_weaponDefs[weaponIdx])", (const char *)&queryFormat, "bg_weaponDefs[weaponIdx]") )
    __debugbreak();
  Scr_AddBool(scrContext, (*v4)->bEnergyBullet);
}

/*
==============
ScrCmd_hidepart
==============
*/
void ScrCmd_hidepart(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  DObj *ServerDObjForEnt; 
  scr_string_t ConstLowercaseString; 
  unsigned __int8 ReverseBoneIndex; 
  const char *v7; 
  const char *v8; 
  const char *String; 
  const char *v10; 
  const char *v11; 
  DObjPartBits partBits; 

  Entity = GetEntity(entref);
  ServerDObjForEnt = Com_GetServerDObjForEnt(Entity);
  if ( !ServerDObjForEnt )
    Scr_Error(COM_ERR_4143, scrContext, "entity has no model");
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    ReverseBoneIndex = DObjGetReverseBoneIndex(ServerDObjForEnt, ConstLowercaseString);
    if ( ReverseBoneIndex == 0xFF )
    {
      v7 = SL_ConvertToString(ConstLowercaseString);
      v8 = j_va("cannot find part '%s' in entity model", v7);
      Scr_Error(COM_ERR_4144, scrContext, v8);
    }
  }
  else
  {
    String = Scr_GetString(scrContext, 1u);
    ReverseBoneIndex = DObjGetReverseModelBoneIndex(ServerDObjForEnt, String, ConstLowercaseString);
    if ( ReverseBoneIndex == 0xFF )
    {
      v10 = SL_ConvertToString(ConstLowercaseString);
      v11 = j_va("cannot find part '%s' in entity model '%s'", v10, String);
      Scr_Error(COM_ERR_4145, scrContext, v11);
    }
  }
  DObjGetHidePartBits(ServerDObjForEnt, &partBits);
  partBits.array[(unsigned __int64)ReverseBoneIndex >> 5] |= 0x80000000 >> (ReverseBoneIndex & 0x1F);
  DObjSetHidePartBits(ServerDObjForEnt, &partBits);
  if ( !GUtils::ms_gUtils && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_utils.h", 112, ASSERT_TYPE_ASSERT, "( ms_gUtils )", (const char *)&queryFormat, "ms_gUtils") )
    __debugbreak();
  GUtils::ms_gUtils->EntityStateSetPartBits(GUtils::ms_gUtils, Entity, &partBits);
}

/*
==============
GScr_EnableCallouts
==============
*/
void GScr_EnableCallouts(scrContext_t *scrContext, scr_entref_t entref)
{
  ;
}

/*
==============
ScrCmd_SetDead
==============
*/
void ScrCmd_SetDead(scrContext_t *scrContext, scr_entref_t entref)
{
  bool v4; 
  gentity_s *Entity; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *client; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *p_eFlags; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    v4 = Scr_GetInt(scrContext, 0) != 0;
    Entity = GetEntity(entref);
    if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 1969, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
      __debugbreak();
    if ( ((Entity->s.eType - 1) & 0xFFEF) == 0 || BG_IsCorpseEntity(&Entity->s) )
    {
      Scr_Error(COM_ERR_4733, scrContext, "SetDead: You cannot use this method on players, agents and corpses.\n");
    }
    else
    {
      client = (GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *)Entity->client;
      if ( v4 )
      {
        p_eFlags = client + 94;
        if ( !client )
          p_eFlags = &Entity->s.lerp.eFlags;
        GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(p_eFlags, ACTIVE, 0x11u);
      }
      else if ( client )
      {
        GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(client + 94, ACTIVE, 0x11u);
      }
      else
      {
        GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(&Entity->s.lerp.eFlags, ACTIVE, 0x11u);
      }
    }
  }
  else
  {
    Scr_Error(COM_ERR_4732, scrContext, "SetDead: Incorrect number of parameters.\n");
  }
}

/*
==============
GScr_AIAnimsetAssetLoaded
==============
*/
void GScr_AIAnimsetAssetLoaded(scrContext_t *scrContext)
{
  scr_string_t ConstLowercaseString; 
  bool IsLoaded; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
    IsLoaded = BG_Animset_IsLoaded(ConstLowercaseString);
    Scr_AddBool(scrContext, IsLoaded);
  }
  else
  {
    Scr_Error(COM_ERR_4734, scrContext, "ArchetypeAssetExists called with incorrect number of parameters.");
  }
}

/*
==============
GScr_AIAnimsetGetAlias
==============
*/
void GScr_AIAnimsetGetAlias(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  scr_string_t v3; 
  scr_string_t v4; 
  int Int; 
  unsigned int v6; 
  int v7; 
  Animset *v8; 
  AnimsetAlias_Union v9; 
  AnimsetAnim *redAnims; 
  unsigned int v11; 
  AnimsetAlias_Union v12; 
  unsigned int v13; 
  AnimsetAlias_Union v14; 
  unsigned int CanonicalString; 
  AnimsetAlias *v19; 
  unsigned int i; 
  unsigned int v21; 
  AnimsetAlias *v22; 
  unsigned int v26; 
  AnimsetAlias *outAlias; 

  if ( Scr_GetNumParam(scrContext) != 4 )
  {
    Scr_Error(COM_ERR_4735, scrContext, "GScr_ArchetypeGetAlias called with incorrect number of parameters.");
    return;
  }
  Sys_ProfBeginNamedEvent(0xFFFFFFFF, "ArchGetAlias");
  ConstString = Scr_GetConstString(scrContext, 0);
  v3 = Scr_GetConstString(scrContext, 1u);
  v4 = Scr_GetConstString(scrContext, 2u);
  Int = Scr_GetInt(scrContext, 3u);
  v6 = 0;
  outAlias = NULL;
  v7 = Int;
  if ( BG_Animset_GetCompleteAliasInfo(ConstString, v3, v4, &outAlias) )
  {
    if ( !outAlias && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 27132, ASSERT_TYPE_ASSERT, "(alias)", (const char *)&queryFormat, "alias") )
      __debugbreak();
    if ( v7 )
    {
      v8 = Animset_Find(ConstString);
      if ( (!v8 || v8->mode) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 27139, ASSERT_TYPE_ASSERT, "(animset && animset->mode == ASM_MODE_AI)", (const char *)&queryFormat, "animset && animset->mode == ASM_MODE_AI") )
        __debugbreak();
      v9.m_AIAnimsetAlias = (AIAnimsetAlias *)outAlias->u;
      if ( v9.m_AIAnimsetAlias->numRedAnims == 1 )
      {
        Scr_MakeStruct(scrContext);
        redAnims = outAlias->u.m_AIAnimsetAlias->redAnims;
LABEL_22:
        Scr_AddAnim(scrContext, redAnims->anim);
        CanonicalString = SL_GetCanonicalString("anims");
        Scr_AddStructField(scrContext, CanonicalString);
        Scr_AddUndefined(scrContext);
LABEL_28:
        v26 = SL_GetCanonicalString("weights");
        Scr_AddStructField(scrContext, v26);
        Sys_ProfEndNamedEvent();
        return;
      }
      if ( v9.m_AIAnimsetAlias->numRedAnims > 1 )
      {
        Scr_MakeStruct(scrContext);
        Scr_MakeArray(scrContext);
        v11 = 0;
        for ( v12.m_AIAnimsetAlias = (AIAnimsetAlias *)outAlias->u; v11 < v12.m_AIAnimsetAlias->numRedAnims; v12.m_AIAnimsetAlias = (AIAnimsetAlias *)outAlias->u )
        {
          Scr_AddAnim(scrContext, v12.m_AIAnimsetAlias->redAnims[v11].anim);
          Scr_AddArray(scrContext);
          ++v11;
        }
        v13 = SL_GetCanonicalString("anims");
        Scr_AddStructField(scrContext, v13);
        Scr_MakeArray(scrContext);
        v14.m_AIAnimsetAlias = (AIAnimsetAlias *)outAlias->u;
        if ( v14.m_AIAnimsetAlias->numRedAnims )
        {
          do
          {
            _RCX = 3i64 * v6;
            _RAX = v14.m_AIAnimsetAlias->redAnims;
            __asm { vmovss  xmm1, dword ptr [rax+rcx*8+4]; value }
            Scr_AddFloat(scrContext, *(float *)&_XMM1);
            Scr_AddArray(scrContext);
            ++v6;
            v14.m_AIAnimsetAlias = (AIAnimsetAlias *)outAlias->u;
          }
          while ( v6 < v14.m_AIAnimsetAlias->numRedAnims );
        }
        goto LABEL_28;
      }
    }
    if ( outAlias->numAnims == 1 )
    {
      Scr_MakeStruct(scrContext);
      redAnims = outAlias->anims;
      goto LABEL_22;
    }
    if ( outAlias->numAnims > 1 )
    {
      Scr_MakeStruct(scrContext);
      Scr_MakeArray(scrContext);
      v19 = outAlias;
      for ( i = 0; i < outAlias->numAnims; ++i )
      {
        Scr_AddAnim(scrContext, v19->anims[i].anim);
        Scr_AddArray(scrContext);
        v19 = outAlias;
      }
      v21 = SL_GetCanonicalString("anims");
      Scr_AddStructField(scrContext, v21);
      Scr_MakeArray(scrContext);
      v22 = outAlias;
      if ( outAlias->numAnims )
      {
        do
        {
          _RCX = 3i64 * v6;
          _RAX = v22->anims;
          __asm { vmovss  xmm1, dword ptr [rax+rcx*8+4]; value }
          Scr_AddFloat(scrContext, *(float *)&_XMM1);
          Scr_AddArray(scrContext);
          v22 = outAlias;
          ++v6;
        }
        while ( v6 < outAlias->numAnims );
      }
      goto LABEL_28;
    }
    Scr_AddUndefined(scrContext);
    Sys_ProfEndNamedEvent();
  }
  else
  {
    Sys_ProfEndNamedEvent();
    Scr_AddUndefined(scrContext);
  }
}

/*
==============
ScrCmd_hidepartAndChildrenAllInstances
==============
*/
void ScrCmd_hidepartAndChildrenAllInstances(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  DObj *ServerDObjForEnt; 
  scr_string_t ConstLowercaseString; 
  unsigned __int8 i; 
  int v7; 
  const char *BoneName; 
  scr_string_t String; 
  unsigned __int8 j; 
  unsigned __int8 childIndex; 
  unsigned __int8 v12[3]; 
  DObjPartBits partBits; 

  Entity = GetEntity(entref);
  ServerDObjForEnt = Com_GetServerDObjForEnt(Entity);
  if ( !ServerDObjForEnt )
    Scr_Error(COM_ERR_4146, scrContext, "entity has no model");
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  if ( Scr_GetNumParam(scrContext) == 2 )
    Scr_GetString(scrContext, 1u);
  DObjGetHidePartBits(ServerDObjForEnt, &partBits);
  for ( i = DObjGetNextBoneIndex(ServerDObjForEnt, ConstLowercaseString, 0xFEu); i != 0xFF; i = DObjGetNextBoneIndex(ServerDObjForEnt, ConstLowercaseString, i) )
  {
    childIndex = -2;
    partBits.array[(unsigned __int64)i >> 5] |= 0x80000000 >> (i & 0x1F);
    while ( DObjGetNextChildBoneIndex(ServerDObjForEnt, i, &childIndex) )
    {
      v7 = childIndex;
      partBits.array[(unsigned __int64)childIndex >> 5] |= 0x80000000 >> (childIndex & 0x1F);
      BoneName = DObjGetBoneName(ServerDObjForEnt, v7);
      String = SL_FindString(BoneName);
      for ( j = DObjGetNextBoneIndex(ServerDObjForEnt, String, childIndex); j != 0xFF; j = DObjGetNextBoneIndex(ServerDObjForEnt, String, j) )
      {
        if ( j != childIndex )
        {
          for ( v12[0] = -2; DObjGetNextChildBoneIndex(ServerDObjForEnt, j, v12); partBits.array[(unsigned __int64)v12[0] >> 5] |= 0x80000000 >> (v12[0] & 0x1F) )
            ;
        }
      }
    }
  }
  DObjSetHidePartBits(ServerDObjForEnt, &partBits);
  if ( !GUtils::ms_gUtils && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_utils.h", 112, ASSERT_TYPE_ASSERT, "( ms_gUtils )", (const char *)&queryFormat, "ms_gUtils") )
    __debugbreak();
  GUtils::ms_gUtils->EntityStateSetPartBits(GUtils::ms_gUtils, Entity, &partBits);
}

/*
==============
ScrCmd_hidepartAllInstances
==============
*/
void ScrCmd_hidepartAllInstances(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  DObj *ServerDObjForEnt; 
  scr_string_t ConstLowercaseString; 
  int v6; 
  const char *String; 
  unsigned __int8 v8; 
  unsigned __int8 v9; 
  const char *v10; 
  const char *v11; 
  ComErrorCode v12; 
  DObjPartBits partBits; 

  Entity = GetEntity(entref);
  ServerDObjForEnt = Com_GetServerDObjForEnt(Entity);
  if ( !ServerDObjForEnt )
    Scr_Error(COM_ERR_4147, scrContext, "entity has no model");
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  v6 = 0;
  if ( Scr_GetNumParam(scrContext) == 2 )
    String = Scr_GetString(scrContext, 1u);
  else
    String = NULL;
  DObjGetHidePartBits(ServerDObjForEnt, &partBits);
  v8 = -2;
  while ( 1 )
  {
    v9 = String ? DObjGetNextModelBoneIndex(ServerDObjForEnt, String, ConstLowercaseString, v8) : DObjGetNextBoneIndex(ServerDObjForEnt, ConstLowercaseString, v8);
    v8 = v9;
    if ( v9 == 0xFF )
      break;
    partBits.array[(unsigned __int64)v9 >> 5] |= 0x80000000 >> (v9 & 0x1F);
    ++v6;
  }
  if ( !v6 )
  {
    v10 = SL_ConvertToString(ConstLowercaseString);
    if ( String )
    {
      v11 = j_va("cannot find part '%s' in entity model '%s'", v10, String);
      v12 = COM_ERR_4148;
    }
    else
    {
      v11 = j_va("cannot find part '%s' in entity model", v10);
      v12 = COM_ERR_4149;
    }
    Scr_Error(v12, scrContext, v11);
  }
  DObjSetHidePartBits(ServerDObjForEnt, &partBits);
  if ( !GUtils::ms_gUtils && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_utils.h", 112, ASSERT_TYPE_ASSERT, "( ms_gUtils )", (const char *)&queryFormat, "ms_gUtils") )
    __debugbreak();
  GUtils::ms_gUtils->EntityStateSetPartBits(GUtils::ms_gUtils, Entity, &partBits);
}

/*
==============
ScrCmd_hideallparts
==============
*/
void ScrCmd_hideallparts(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  DObj *ServerDObjForEnt; 
  unsigned int v7; 
  DObjPartBits partBits; 

  __asm { vmovaps [rsp+98h+var_28], xmm6 }
  Entity = GetEntity(entref);
  ServerDObjForEnt = Com_GetServerDObjForEnt(Entity);
  if ( !ServerDObjForEnt )
    Scr_Error(COM_ERR_4150, scrContext, "entity has no model");
  __asm { vmovdqu xmm6, cs:__xmm@ffffffffffffffffffffffffffffffff }
  v7 = 0;
  _RDI = &partBits;
  do
  {
    __asm { vmovdqu xmmword ptr [rdi], xmm6 }
    _RDI = (DObjPartBits *)((char *)_RDI + 16);
    ++v7;
  }
  while ( v7 < 2 );
  DObjSetHidePartBits(ServerDObjForEnt, &partBits);
  if ( !GUtils::ms_gUtils && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_utils.h", 112, ASSERT_TYPE_ASSERT, "( ms_gUtils )", (const char *)&queryFormat, "ms_gUtils") )
    __debugbreak();
  GUtils::ms_gUtils->EntityStateSetPartBits(GUtils::ms_gUtils, Entity, &partBits);
  __asm { vmovaps xmm6, [rsp+98h+var_28] }
}

/*
==============
ScrCmd_showpart
==============
*/
void ScrCmd_showpart(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  DObj *ServerDObjForEnt; 
  scr_string_t ConstLowercaseString; 
  unsigned __int8 ReverseBoneIndex; 
  const char *v7; 
  const char *v8; 
  const char *String; 
  const char *v10; 
  const char *v11; 
  DObjPartBits partBits; 

  Entity = GetEntity(entref);
  ServerDObjForEnt = Com_GetServerDObjForEnt(Entity);
  if ( !ServerDObjForEnt )
    Scr_Error(COM_ERR_4151, scrContext, "entity has no model");
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    ReverseBoneIndex = DObjGetReverseBoneIndex(ServerDObjForEnt, ConstLowercaseString);
    if ( ReverseBoneIndex == 0xFF )
    {
      v7 = SL_ConvertToString(ConstLowercaseString);
      v8 = j_va("cannot find part '%s' in entity model", v7);
      Scr_Error(COM_ERR_4152, scrContext, v8);
    }
  }
  else
  {
    String = Scr_GetString(scrContext, 1u);
    ReverseBoneIndex = DObjGetReverseModelBoneIndex(ServerDObjForEnt, String, ConstLowercaseString);
    if ( ReverseBoneIndex == 0xFF )
    {
      v10 = SL_ConvertToString(ConstLowercaseString);
      v11 = j_va("cannot find part '%s' in entity model '%s'", v10, String);
      Scr_Error(COM_ERR_4153, scrContext, v11);
    }
  }
  DObjGetHidePartBits(ServerDObjForEnt, &partBits);
  partBits.array[(unsigned __int64)ReverseBoneIndex >> 5] &= ~(0x80000000 >> (ReverseBoneIndex & 0x1F));
  DObjSetHidePartBits(ServerDObjForEnt, &partBits);
  if ( !GUtils::ms_gUtils && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_utils.h", 112, ASSERT_TYPE_ASSERT, "( ms_gUtils )", (const char *)&queryFormat, "ms_gUtils") )
    __debugbreak();
  GUtils::ms_gUtils->EntityStateSetPartBits(GUtils::ms_gUtils, Entity, &partBits);
}

/*
==============
GScr_AIAnimsetGetRandomAlias
==============
*/
void GScr_AIAnimsetGetRandomAlias(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  scr_string_t v3; 
  scr_string_t v4; 
  int IndexOfRandomAnimFromAlias; 

  Sys_ProfBeginNamedEvent(0xFFFFFFFF, "ArchGetRandomAlias");
  if ( Scr_GetNumParam(scrContext) == 4 )
  {
    ConstString = Scr_GetConstString(scrContext, 0);
    v3 = Scr_GetConstString(scrContext, 1u);
    v4 = Scr_GetConstString(scrContext, 2u);
    IndexOfRandomAnimFromAlias = G_Animset_GetIndexOfRandomAnimFromAlias(ConstString, v3, v4);
    if ( IndexOfRandomAnimFromAlias < 0 )
      Scr_AddUndefined(scrContext);
    else
      Scr_AddInt(scrContext, IndexOfRandomAnimFromAlias);
    Sys_ProfEndNamedEvent();
  }
  else
  {
    Sys_ProfEndNamedEvent();
    Scr_Error(COM_ERR_4736, scrContext, "GScr_ArchetypeGetRandomAlias called with incorrect number of parameters.");
  }
}

/*
==============
GScr_AIAnimsetGetAnimFromIndex
==============
*/
void GScr_AIAnimsetGetAnimFromIndex(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  scr_string_t v3; 
  int Int; 
  const Animset *v5; 
  const Animset *v6; 
  unsigned __int16 AnimsIndex; 
  const XAnim_s *Anims; 
  int pOutAnimtreeIndex; 
  unsigned int pOutGraftNode; 
  scr_anim_t value; 
  AnimsetState *outState; 
  XAnimSubTreeID pOutAnimSubtreeID; 
  int pOutStateIndex; 
  unsigned int pOutAnimIndex; 

  ConstString = Scr_GetConstString(scrContext, 0);
  v3 = Scr_GetConstString(scrContext, 1u);
  Int = Scr_GetInt(scrContext, 2u);
  v5 = Animset_Find(ConstString);
  v6 = v5;
  if ( v5 )
  {
    outState = NULL;
    BG_Animset_GetStateInfoByName(v5, v3, &outState, &pOutStateIndex);
    if ( outState )
    {
      BG_Animset_GetAnimIndexFromStateIndexAndEntry(v6, pOutStateIndex, Int, &pOutAnimIndex, &pOutGraftNode, &pOutAnimSubtreeID, NULL, &pOutAnimtreeIndex, 1);
      value.index = pOutAnimIndex;
      AnimsIndex = pOutAnimtreeIndex;
      if ( pOutAnimtreeIndex < 0 )
      {
        Anims = BG_AnimationState_GetAnims(ConstString);
        AnimsIndex = Scr_GetAnimsIndex(Anims, 1u);
      }
      value.tree = AnimsIndex;
      Scr_AddAnim(scrContext, value);
    }
  }
}

/*
==============
ScrCmd_showallparts
==============
*/
void ScrCmd_showallparts(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  DObj *ServerDObjForEnt; 
  unsigned int v6; 
  DObjPartBits partBits; 

  __asm { vmovaps [rsp+98h+var_28], xmm6 }
  Entity = GetEntity(entref);
  ServerDObjForEnt = Com_GetServerDObjForEnt(Entity);
  if ( !ServerDObjForEnt )
    Scr_Error(COM_ERR_4154, scrContext, "entity has no model");
  v6 = 0;
  _RDI = &partBits;
  __asm { vpxor   xmm6, xmm6, xmm6 }
  do
  {
    __asm { vmovdqu xmmword ptr [rdi], xmm6 }
    _RDI = (DObjPartBits *)((char *)_RDI + 16);
    ++v6;
  }
  while ( v6 < 2 );
  DObjSetHidePartBits(ServerDObjForEnt, &partBits);
  if ( !GUtils::ms_gUtils && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_utils.h", 112, ASSERT_TYPE_ASSERT, "( ms_gUtils )", (const char *)&queryFormat, "ms_gUtils") )
    __debugbreak();
  GUtils::ms_gUtils->EntityStateSetPartBits(GUtils::ms_gUtils, Entity, &partBits);
  __asm { vmovaps xmm6, [rsp+98h+var_28] }
}

/*
==============
ScrCmd_SetMoveSpeedScale
==============
*/
void ScrCmd_SetMoveSpeedScale(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v6; 
  const char *v7; 
  char v9; 
  char v10; 
  const char *v13; 
  gagent_s *agent; 

  __asm { vmovaps [rsp+48h+var_18], xmm6 }
  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3678, scrContext, "not an entity");
    v6 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 8134, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v6 = &g_entities[entnum];
    if ( !v6->client && !v6->agent )
    {
      v7 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3677, scrContext, v7);
    }
  }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm
  {
    vcomiss xmm0, cs:__real@40a00000
    vmovaps xmm6, xmm0
  }
  if ( !(v9 | v10) )
  {
    __asm
    {
      vcvtss2sd xmm1, xmm6, xmm0
      vmovq   rdx, xmm1
    }
    v13 = j_va("Value %f is greater than SPEED_SCALE_MULTIPLIER_MAX_SIZE, please increase define.", _RDX);
    Scr_Error(COM_ERR_4155, scrContext, v13);
  }
  if ( G_Utils_IsAgent(v6) )
  {
    agent = v6->agent;
    if ( !agent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_playerstate.h", 1145, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    __asm
    {
      vmovss  xmm1, cs:__real@40a00000; maxAbsValueSize
      vmovaps xmm0, xmm6; value
    }
    agent->playerState.moveSpeedScaleMultiplier = MSG_PackUnsignedFloat(*(float *)&_XMM0, *(float *)&_XMM1, 0xCu);
  }
  else
  {
    if ( !v6->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 8150, ASSERT_TYPE_ASSERT, "( pSelf->client )", (const char *)&queryFormat, "pSelf->client") )
      __debugbreak();
    _RAX = v6->client;
    __asm { vmovss  dword ptr [rax+55C4h], xmm6 }
  }
  __asm { vmovaps xmm6, [rsp+48h+var_18] }
}

/*
==============
GScr_AIAnimsetGetAllAnimIndicesForAlias
==============
*/
void GScr_AIAnimsetGetAllAnimIndicesForAlias(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  scr_string_t v3; 
  scr_string_t v4; 
  int AllAnimIndicesForAlias; 
  __int64 v6; 
  __int64 v7; 
  __int64 i; 
  int pIndices[128]; 

  ConstString = Scr_GetConstString(scrContext, 0);
  v3 = Scr_GetConstString(scrContext, 1u);
  v4 = Scr_GetConstString(scrContext, 2u);
  AllAnimIndicesForAlias = BG_Animset_GetAllAnimIndicesForAlias(ConstString, v3, v4, pIndices, 0x80u);
  v6 = AllAnimIndicesForAlias;
  if ( AllAnimIndicesForAlias < 0 )
    Scr_Error(COM_ERR_4737, scrContext, "insufficient space in array for all the indices for this alias");
  if ( (int)v6 > 0 )
  {
    if ( (int)v6 > 128 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 27346, ASSERT_TYPE_ASSERT, "(numIndices <= cMaxIndices)", (const char *)&queryFormat, "numIndices <= cMaxIndices") )
      __debugbreak();
    Scr_MakeArray(scrContext);
    v7 = v6;
    if ( (int)v6 > 0 )
    {
      for ( i = 0i64; i < v7; ++i )
      {
        Scr_AddInt(scrContext, pIndices[i]);
        Scr_AddArray(scrContext);
      }
    }
  }
}

/*
==============
GScr_AIAnimsetGetAliases
==============
*/
void GScr_AIAnimsetGetAliases(scrContext_t *scrContext)
{
  scrContext_t *v2; 
  ntl::internal::pool_allocator_freelist<40> *p_m_freelist; 
  char *v4; 
  scr_string_t ConstLowercaseString; 
  scr_string_t v6; 
  int v7; 
  scr_string_t name; 
  ntl::red_black_tree_node_base *p_m_endNodeBase; 
  ntl::red_black_tree_node_base *mp_parent; 
  ntl::red_black_tree_node_base *v11; 
  ntl::red_black_tree_node_base *v12; 
  ntl::red_black_tree_node_base *v13; 
  bool v14; 
  ntl::red_black_tree_node_base *mp_left; 
  ntl::red_black_tree_node_base *i; 
  ntl::red_black_tree_node_base *v17; 
  ntl::red_black_tree_node_base *mp_right; 
  ntl::red_black_tree_node_base *j; 
  ntl::red_black_tree_node_base *v23; 
  ntl::red_black_tree_node_base *v24; 
  AnimsetState *outState; 
  ntl::pair<enum scr_string_t,bool> r_element; 
  scrContext_t *v27; 
  __m256i v28; 
  ntl::pair<enum scr_string_t,bool> v29; 
  __int64 v30; 
  ntl::red_black_tree_iterator<enum scr_string_t,ntl::red_black_tree_node<ntl::pair<enum scr_string_t,bool> >,ntl::pair<enum scr_string_t,bool> *,ntl::pair<enum scr_string_t,bool> &> result; 
  ntl::red_black_tree<enum scr_string_t,ntl::pair<enum scr_string_t,bool>,ntl::fixed_pool_allocator<ntl::red_black_tree_node<ntl::pair<enum scr_string_t,bool> >,4096,8>,ntl::return_pair_first<enum scr_string_t,bool>,ntl::less<enum scr_string_t,enum scr_string_t> > v32; 

  v30 = -2i64;
  v2 = scrContext;
  v27 = scrContext;
  p_m_freelist = &v32.m_freelist;
  v4 = &v32.m_data.m_buffer[163800];
  do
  {
    *(_QWORD *)v4 = p_m_freelist;
    p_m_freelist = (ntl::internal::pool_allocator_freelist<40> *)v4;
    v4 -= 40;
  }
  while ( v4 + 40 > (char *)&v32 );
  v32.m_freelist.m_head.mp_next = &p_m_freelist->m_head;
  if ( !p_m_freelist && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 112, ASSERT_TYPE_ASSERT, "( m_head.mp_next != 0 )", "This container was memset to zero") )
    __debugbreak();
  v32.m_size = 0i64;
  v32.m_endNodeBase.m_color = RB_NODE_COLOR_RED;
  v32.m_endNodeBase.mp_parent = NULL;
  v32.m_endNodeBase.mp_left = &v32.m_endNodeBase;
  v32.m_endNodeBase.mp_right = &v32.m_endNodeBase;
  if ( Scr_GetNumParam(v2) != 2 )
  {
    Scr_Error(COM_ERR_4738, v2, "ArchetypeGetAliases called with incorrect number of parameters.");
    goto LABEL_80;
  }
  ConstLowercaseString = Scr_GetConstLowercaseString(v2, 0);
  v6 = Scr_GetConstLowercaseString(v2, 1u);
  if ( !BG_Animset_IsLoaded(ConstLowercaseString) )
    goto LABEL_79;
  outState = NULL;
  if ( BG_Animset_GetStateInfoByName(ConstLowercaseString, v6, &outState, NULL) )
  {
    if ( !outState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 27393, ASSERT_TYPE_ASSERT, "(state)", (const char *)&queryFormat, "state") )
      __debugbreak();
    v7 = 0;
    if ( outState->numAnimAliases )
    {
      while ( 1 )
      {
        name = outState->animAliases[v7].name;
        if ( !name )
          goto LABEL_70;
        p_m_endNodeBase = &v32.m_endNodeBase;
        mp_parent = v32.m_endNodeBase.mp_parent;
        if ( v32.m_endNodeBase.mp_parent )
        {
          do
          {
            if ( mp_parent[1].m_color < name )
            {
              mp_parent = mp_parent->mp_right;
            }
            else
            {
              p_m_endNodeBase = mp_parent;
              mp_parent = mp_parent->mp_left;
            }
          }
          while ( mp_parent );
          if ( p_m_endNodeBase != &v32.m_endNodeBase )
          {
            v11 = &v32.m_endNodeBase;
            if ( name >= p_m_endNodeBase[1].m_color )
              v11 = p_m_endNodeBase;
            p_m_endNodeBase = v11;
          }
        }
        if ( p_m_endNodeBase != &v32.m_endNodeBase )
          goto LABEL_70;
        r_element.first = outState->animAliases[v7].name;
        r_element.second = 1;
        v12 = &v32.m_endNodeBase;
        v13 = v32.m_endNodeBase.mp_parent;
        v14 = 1;
        while ( v13 )
        {
          v12 = v13;
          v14 = name < v13[1].m_color;
          if ( name >= v13[1].m_color )
            v13 = v13->mp_right;
          else
            v13 = v13->mp_left;
        }
        mp_left = v12;
        if ( !v14 )
          goto LABEL_45;
        if ( v12 != v32.m_endNodeBase.mp_left )
          break;
        ntl::red_black_tree<enum scr_string_t,ntl::pair<enum scr_string_t,bool>,ntl::fixed_pool_allocator<ntl::red_black_tree_node<ntl::pair<enum scr_string_t,bool>>,4096,8>,ntl::return_pair_first<enum scr_string_t,bool>,ntl::less<enum scr_string_t,enum scr_string_t>>::insert_node(&v32, &result, v12, &r_element, 1, 0);
LABEL_70:
        if ( ++v7 >= outState->numAnimAliases )
        {
          v2 = v27;
          goto LABEL_72;
        }
      }
      if ( !v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\tree\\rb_tree.h", 108, ASSERT_TYPE_ASSERT, "( mp_node )", (const char *)&queryFormat, "mp_node") )
        __debugbreak();
      if ( v12->m_color || v12->mp_parent->mp_parent != v12 )
      {
        mp_left = v12->mp_left;
        if ( mp_left )
        {
          for ( i = mp_left->mp_right; i; i = i->mp_right )
            mp_left = i;
        }
        else
        {
          mp_left = v12->mp_parent;
          if ( v12 == mp_left->mp_left )
          {
            do
            {
              v17 = mp_left;
              mp_left = mp_left->mp_parent;
            }
            while ( v17 == mp_left->mp_left );
          }
        }
      }
      else
      {
        mp_left = v12->mp_right;
      }
LABEL_45:
      if ( !mp_left && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\tree\\rb_tree.h", 81, ASSERT_TYPE_ASSERT, "( mp_node )", (const char *)&queryFormat, "mp_node") )
        __debugbreak();
      if ( mp_left[1].m_color < name )
      {
        if ( !v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\tree\\rb_tree.h", 694, ASSERT_TYPE_ASSERT, "( p_insert != 0 )", (const char *)&queryFormat, "p_insert != NULL") )
          __debugbreak();
        if ( !v32.m_freelist.m_head.mp_next )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 112, ASSERT_TYPE_ASSERT, "( m_head.mp_next != 0 )", "This container was memset to zero") )
            __debugbreak();
          if ( !v32.m_freelist.m_head.mp_next && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 112, ASSERT_TYPE_ASSERT, "( m_head.mp_next != 0 )", "This container was memset to zero") )
            __debugbreak();
        }
        if ( (ntl::internal::pool_allocator_freelist<40> *)v32.m_freelist.m_head.mp_next == &v32.m_freelist && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 298, ASSERT_TYPE_ASSERT, "( !empty() )", "Pool out of elements to allocate (Elem size=%zu, Num elems=%zu)", 0x28ui64, 0x1000ui64) )
          __debugbreak();
        _RCX = v32.m_freelist.m_head.mp_next;
        v32.m_freelist.m_head.mp_next = v32.m_freelist.m_head.mp_next->mp_next;
        v28.m256i_i32[0] = 0;
        v28.m256i_i64[1] = (__int64)v12;
        __asm
        {
          vpxor   xmm0, xmm0, xmm0
          vmovdqu xmmword ptr [rsp+28100h+var_280A0+10h], xmm0
        }
        v29 = r_element;
        __asm
        {
          vmovups ymm0, [rsp+28100h+var_280A0]
          vmovups ymmword ptr [rcx], ymm0
          vmovsd  xmm1, [rbp+28000h+var_28080]
          vmovsd  qword ptr [rcx+20h], xmm1
        }
        if ( v12 == &v32.m_endNodeBase )
        {
          v32.m_endNodeBase.mp_left = (ntl::red_black_tree_node_base *)_RCX;
          v32.m_endNodeBase.mp_parent = (ntl::red_black_tree_node_base *)_RCX;
          v32.m_endNodeBase.mp_right = (ntl::red_black_tree_node_base *)_RCX;
        }
        else if ( name >= v12[1].m_color )
        {
          v12->mp_right = (ntl::red_black_tree_node_base *)_RCX;
          mp_right = v32.m_endNodeBase.mp_right;
          if ( v12 == v32.m_endNodeBase.mp_right )
            mp_right = (ntl::red_black_tree_node_base *)_RCX;
          v32.m_endNodeBase.mp_right = mp_right;
        }
        else
        {
          v12->mp_left = (ntl::red_black_tree_node_base *)_RCX;
          if ( v12 == v32.m_endNodeBase.mp_left )
            v32.m_endNodeBase.mp_left = (ntl::red_black_tree_node_base *)_RCX;
        }
        ntl::red_black_tree_node_base::rebalance((ntl::red_black_tree_node_base *)_RCX, &v32.m_endNodeBase.mp_parent);
        ++v32.m_size;
      }
      goto LABEL_70;
    }
  }
LABEL_72:
  if ( !v32.m_size )
  {
LABEL_79:
    Scr_AddUndefined(v2);
    goto LABEL_80;
  }
  Scr_MakeArray(v2);
  for ( j = v32.m_endNodeBase.mp_left; j != &v32.m_endNodeBase; j = ntl::red_black_tree_node_base::get_next(j) )
  {
    if ( !j && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\tree\\rb_tree.h", 87, ASSERT_TYPE_ASSERT, "( mp_node )", (const char *)&queryFormat, "mp_node") )
      __debugbreak();
    Scr_AddConstString(v2, (scr_string_t)j[1].m_color);
    Scr_AddArray(v2);
  }
LABEL_80:
  if ( v32.m_size )
  {
    v23 = v32.m_endNodeBase.mp_parent;
    if ( v32.m_endNodeBase.mp_parent )
    {
      do
      {
        ntl::red_black_tree<enum scr_string_t,ntl::pair<enum scr_string_t,bool>,ntl::fixed_pool_allocator<ntl::red_black_tree_node<ntl::pair<enum scr_string_t,bool>>,4096,8>,ntl::return_pair_first<enum scr_string_t,bool>,ntl::less<enum scr_string_t,enum scr_string_t>>::erase_tree(&v32, (ntl::red_black_tree_node<ntl::pair<enum scr_string_t,bool> > *)v23->mp_right);
        v24 = v23->mp_left;
        *(_QWORD *)&v23->m_color = v32.m_freelist.m_head.mp_next;
        v32.m_freelist.m_head.mp_next = (ntl::internal::pool_allocator_pointer_freelist::free_item_pointer *)v23;
        v23 = v24;
      }
      while ( v24 );
    }
  }
}

/*
==============
ScrCmd_LinkTo
==============
*/
void ScrCmd_LinkTo(scrContext_t *scrContext, scr_entref_t entref)
{
  ScrLinkTo_Internal(scrContext, entref, 0, 0);
}

/*
==============
ScrCmd_FixLinkToInterpolationBug
==============
*/
void ScrCmd_FixLinkToInterpolationBug(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  unsigned int v6; 

  if ( !Com_GameMode_SupportsFeature(WEAPON_DROPPING_ALT_ADS) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 8291, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::LINKED_TRAJECTORIES ))", "%s\n\tFixLinkToInterpolationBug() is not supported in this game mode.", "Com_GameMode_SupportsFeature( Com_GameMode_Feature::LINKED_TRAJECTORIES )") )
    __debugbreak();
  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 8294, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  Int = Scr_GetInt(scrContext, 0);
  v6 = Entity->flags.m_flags[0] & 0xFFFFFBFF;
  if ( Int )
    v6 = Entity->flags.m_flags[0] | 0x400;
  Entity->flags.m_flags[0] = v6;
}

/*
==============
ScrCmd_LinkToBlendToTag
==============
*/
void ScrCmd_LinkToBlendToTag(scrContext_t *scrContext, scr_entref_t entref)
{
  ScrLinkTo_Internal(scrContext, entref, 1, 0);
}

/*
==============
ScrCmd_LinkToMoveOffset
==============
*/
void ScrCmd_LinkToMoveOffset(scrContext_t *scrContext, scr_entref_t entref)
{
  ScrLinkTo_Internal(scrContext, entref, 0, 1);
}

/*
==============
ScrCmd_Unlink
==============
*/
void ScrCmd_Unlink(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int v4; 

  Entity = GetEntity(entref);
  v4 = 0;
  if ( Scr_GetNumParam(scrContext) )
  {
    if ( Scr_GetType(scrContext, 0) != VAR_INTEGER )
      Scr_ParamError(COM_ERR_4163, scrContext, 0, "not a boolean - allowUnlinkInCollision");
    LOBYTE(v4) = Scr_GetInt(scrContext, 0) != 0;
  }
  ScrCmd_Unlink_Internal(Entity, v4);
}

/*
==============
ScrCmd_IsLinked
==============
*/
void ScrCmd_IsLinked(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  int IsLinked; 

  Entity = GetEntity(entref);
  IsLinked = G_EntIsLinked(Entity);
  Scr_AddBool(scrContext, IsLinked);
}

/*
==============
ScrCmd_GetLinkedParent
==============
*/
void ScrCmd_GetLinkedParent(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( G_EntIsLinked(Entity) )
    GScr_AddEntity(Entity->tagInfo->parent);
  else
    Scr_AddUndefined(scrContext);
}

/*
==============
ScrCmd_GetLinkedChildren
==============
*/
void ScrCmd_GetLinkedChildren(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  int Int; 

  Entity = GetEntity(entref);
  if ( Scr_GetNumParam(scrContext) )
    Int = Scr_GetInt(scrContext, 0);
  else
    Int = 0;
  Scr_MakeArray(scrContext);
  AddLinkedChildren(scrContext, Entity, Int);
}

/*
==============
ScrCmd_GetMovingPlatformParent
==============
*/
void ScrCmd_GetMovingPlatformParent(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  actor_s *actor; 
  playerState_s *EntityPlayerState; 
  const gentity_s *MoverEntityFromPs; 

  Entity = GetEntity(entref);
  if ( !G_Utils_IsClientOrActor(Entity) )
  {
    Scr_Error(COM_ERR_4164, scrContext, "This function only supports players and actors.");
LABEL_3:
    Scr_AddUndefined(scrContext);
    return;
  }
  actor = Entity->actor;
  if ( actor )
  {
    if ( !BGMovingPlatforms::IsMovingPlatform(actor->Physics.groundEntNum) || !G_IsEntityInUse(Entity->actor->Physics.groundEntNum) )
      goto LABEL_3;
    GScr_AddEntity(&g_entities[Entity->actor->Physics.groundEntNum]);
  }
  else
  {
    EntityPlayerState = G_GetEntityPlayerState(Entity);
    if ( !EntityPlayerState )
      goto LABEL_3;
    MoverEntityFromPs = GMovingPlatforms::GetMoverEntityFromPs(EntityPlayerState);
    if ( !MoverEntityFromPs )
      goto LABEL_3;
    GScr_AddEntity(MoverEntityFromPs);
  }
}

/*
==============
ScrCmd_AutoboltMissileEffects
==============
*/
void ScrCmd_AutoboltMissileEffects(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  unsigned int v5; 

  Entity = GetEntity(entref);
  if ( BGMovingPlatforms::IsPlatformType(Entity->s.eType) )
  {
    Int = Scr_GetInt(scrContext, 0);
    v5 = Entity->flags.m_flags[0];
    if ( Int )
      Entity->flags.m_flags[0] = v5 & 0xFFFF7FFF;
    else
      Entity->flags.m_flags[0] = v5 | 0x8000;
  }
  else
  {
    Scr_Error(COM_ERR_4165, scrContext, "This function only supports moving platform entity types.");
  }
}

/*
==============
ScrCmd_EnableLinkTo
==============
*/
void ScrCmd_EnableLinkTo(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  unsigned int ScriptableIndexForEntity; 
  entityType_s eType; 
  const char *EntityTypeName; 
  const char *v7; 
  const char *v8; 

  Entity = GetEntity(entref);
  if ( (Entity->flags.m_flags[0] & 0x200) != 0 )
    Scr_ObjectError(COM_ERR_4166, scrContext, "entity already has linkTo enabled");
  if ( ((Entity->s.eType - 2) & 0xFFEF) != 0 )
  {
    ScriptableIndexForEntity = ScriptableSv_GetScriptableIndexForEntity(Entity);
    if ( ScriptableIndexForEntity == -1 || (ScriptableCommon_AssertCountsInitialized(), ScriptableIndexForEntity < g_scriptableWorldCounts.runtimeInstanceCount) )
    {
      eType = Entity->s.eType;
      if ( eType && eType != ET_INFO_VOLUME_GRAPPLE )
        goto LABEL_10;
    }
    else
    {
      ScriptableSv_VerifyScriptableMoverEntity(Entity);
    }
    if ( !Entity->physicsObject )
    {
LABEL_11:
      if ( Entity->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 8620, ASSERT_TYPE_ASSERT, "(!ent->client)", (const char *)&queryFormat, "!ent->client") )
        __debugbreak();
      goto LABEL_14;
    }
LABEL_10:
    EntityTypeName = G_GetEntityTypeName(Entity);
    v7 = SL_ConvertToString(Entity->classname);
    v8 = j_va("entity (classname: '%s', type: '%s') does not currently support enableLinkTo", v7, EntityTypeName);
    Scr_ObjectError(COM_ERR_4167, scrContext, v8);
    goto LABEL_11;
  }
LABEL_14:
  Entity->flags.m_flags[0] |= 0x200u;
}

/*
==============
ScrCmd_PlayerLinkTo
==============
*/
void ScrCmd_PlayerLinkTo(scrContext_t *scrContext, scr_entref_t entref)
{
  GScr_Main_PlayerLinkTo_Internal(scrContext, entref, PLAYERLINKTO_NORMAL);
}

/*
==============
ScrCmd_PlayerLinkToDelta
==============
*/
void ScrCmd_PlayerLinkToDelta(scrContext_t *scrContext, scr_entref_t entref)
{
  GScr_Main_PlayerLinkTo_Internal(scrContext, entref, PLAYERLINKTO_DELTA);
}

/*
==============
ScrCmd_PlayerLinkWeaponViewToDelta
==============
*/
void ScrCmd_PlayerLinkWeaponViewToDelta(scrContext_t *scrContext, scr_entref_t entref)
{
  GScr_Main_PlayerLinkTo_Internal(scrContext, entref, PLAYERLINKTO_DELTA_WEAPONVIEWONLY);
}

/*
==============
ScrCmd_PlayerLinkToAbsolute
==============
*/
void ScrCmd_PlayerLinkToAbsolute(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  scr_string_t v5; 
  scr_string_t ConstLowercaseString; 
  const char *v7; 
  char outErrorMessage[256]; 

  Entity = GetEntity(entref);
  if ( Scr_GetType(scrContext, 0) != VAR_POINTER || Scr_GetPointerType(scrContext, 0) != VAR_ENTITY )
    Scr_ParamError(COM_ERR_4174, scrContext, 0, "Not an entity");
  if ( !Entity->client )
    Scr_ObjectError(COM_ERR_4175, scrContext, "Not a player entity");
  if ( (Entity->flags.m_flags[0] & 0x200) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 8896, ASSERT_TYPE_ASSERT, "( ent->flags.TestFlag( BgEntityFlagsCommon::SUPPORTS_LINKTO ) )", (const char *)&queryFormat, "ent->flags.TestFlag( BgEntityFlagsCommon::SUPPORTS_LINKTO )") )
    __debugbreak();
  v4 = GScr_GetEntity(0);
  v5 = 0;
  if ( (int)Scr_GetNumParam(scrContext) > 1 && Scr_GetType(scrContext, 1u) )
  {
    ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 1u);
    if ( ConstLowercaseString == scr_const._ )
      ConstLowercaseString = 0;
    v5 = ConstLowercaseString;
  }
  Entity->client->linkAnglesFrac = 1.0;
  Entity->client->flags |= 4u;
  GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::SetFlagInternal(&Entity->client->ps.linkFlags, ACTIVE, 0);
  GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::ClearFlagInternal(&Entity->client->ps.linkFlags, ACTIVE, 2u);
  GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::ClearFlagInternal(&Entity->client->ps.linkFlags, GameModeFlagValues::ms_spValue, 7u);
  GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::ClearFlagInternal(&Entity->client->ps.linkFlags, GameModeFlagValues::ms_spValue, 8u);
  Entity->client->link_rotationMovesEyePos = 1;
  Entity->client->link_useTagAnglesForViewAngles = 1;
  Entity->client->link_useBaseAnglesForViewClamp = 0;
  Entity->client->link_useTagScriptedCamera = 0;
  if ( G_EntLinkTo(Entity, v4, v5, 256, outErrorMessage) )
  {
    G_InitPlayerLinkAngles(Entity);
  }
  else
  {
    v7 = j_va("failed to link entity %i to entity %i: %s", (unsigned int)Entity->s.number, (unsigned int)v4->s.number, outErrorMessage);
    Scr_Error(COM_ERR_4176, scrContext, v7);
  }
}

/*
==============
ScrCmd_PlayerLinkedOffsetEnable
==============
*/
void ScrCmd_PlayerLinkedOffsetEnable(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32> *client; 
  const char *v6; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3682, scrContext, "not an entity");
    client = NULL;
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 8943, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    client = (GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32> *)v4->client;
    if ( !client )
    {
      client = (GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32> *)v4->agent;
      if ( !client )
      {
        v6 = j_va("entity %i is not a player or agent", entnum);
        Scr_ObjectError(COM_ERR_3679, scrContext, v6);
      }
    }
  }
  if ( !v4->tagInfo )
    Scr_Error(COM_ERR_4177, scrContext, "Player is not linked.");
  GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::SetFlagInternal(client + 9, ACTIVE, 1u);
}

/*
==============
ScrCmd_PlayerLinkedSetForceParentVisible
==============
*/
void ScrCmd_PlayerLinkedSetForceParentVisible(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  int Int; 
  GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32> *p_linkFlags; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3682, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 8963, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client && !v4->agent )
    {
      v5 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3679, scrContext, v5);
    }
  }
  if ( !v4->tagInfo )
    Scr_Error(COM_ERR_5729, scrContext, "Player is not linked.");
  Int = Scr_GetInt(scrContext, 0);
  p_linkFlags = &v4->client->ps.linkFlags;
  if ( Int )
    GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::SetFlagInternal(p_linkFlags, GameModeFlagValues::ms_mpValue, 7u);
  else
    GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::ClearFlagInternal(p_linkFlags, GameModeFlagValues::ms_mpValue, 7u);
}

/*
==============
ScrCmd_PlayerUnlinkOnJump
==============
*/
void ScrCmd_PlayerUnlinkOnJump(scrContext_t *scrContext, scr_entref_t entref)
{
  Scr_Error(COM_ERR_4179, scrContext, "PlayerUnlinkOnJump is disabled");
}

/*
==============
ScrCmd_PlayerLinkedOffsetDisable
==============
*/
void ScrCmd_PlayerLinkedOffsetDisable(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32> *client; 
  const char *v6; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3682, scrContext, "not an entity");
    client = NULL;
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 9026, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    client = (GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32> *)v4->client;
    if ( !client )
    {
      client = (GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32> *)v4->agent;
      if ( !client )
      {
        v6 = j_va("entity %i is not a player or agent", entnum);
        Scr_ObjectError(COM_ERR_3679, scrContext, v6);
      }
    }
  }
  if ( !v4->tagInfo )
    Scr_Error(COM_ERR_4180, scrContext, "Player is not linked.");
  GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::ClearFlagInternal(client + 9, ACTIVE, 1u);
}

/*
==============
ScrCmd_PlayerLinkedSetViewZnear
==============
*/
void ScrCmd_PlayerLinkedSetViewZnear(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  int Int; 
  GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32> *p_linkFlags; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 9046, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  if ( !v4->tagInfo )
    Scr_Error(COM_ERR_4181, scrContext, "Player is not linked.");
  if ( (v4->client->ps.linkFlags.m_flags[0] & 4) == 0 )
    Scr_Error(COM_ERR_4182, scrContext, "Player must be linked using PlayerLinkWeaponViewToDelta()");
  Int = Scr_GetInt(scrContext, 0);
  p_linkFlags = &v4->client->ps.linkFlags;
  if ( Int )
    GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::SetFlagInternal(p_linkFlags, ACTIVE, 3u);
  else
    GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::ClearFlagInternal(p_linkFlags, ACTIVE, 3u);
}

/*
==============
ScrCmd_PlayerLinkedSetUseBaseAngleForViewClamp
==============
*/
void ScrCmd_PlayerLinkedSetUseBaseAngleForViewClamp(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 9074, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  if ( !v4->tagInfo )
    Scr_Error(COM_ERR_4183, scrContext, "Player is not linked.");
  if ( (v4->client->ps.linkFlags.m_flags[0] & 4) == 0 )
    Scr_Error(COM_ERR_4184, scrContext, "Player must be linked using PlayerLinkWeaponViewToDelta()");
  v4->client->link_useBaseAnglesForViewClamp = Scr_GetInt(scrContext, 0) != 0;
}

/*
==============
ScrCmd_PlayerLinkToBlend
==============
*/
void ScrCmd_PlayerLinkToBlend(scrContext_t *scrContext, scr_entref_t entref)
{
  scr_string_t v6; 
  unsigned int entnum; 
  const char *v10; 
  int NumParam; 
  gentity_s *Entity; 
  scr_string_t ConstLowercaseString; 
  gclient_s *client; 
  gclient_s *v25; 
  const char *v28; 
  float totalTime; 
  vec3_t inOutViewAngles; 
  char outErrorMessage[256]; 
  char v35; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-28h], xmm6
    vmovaps xmmword ptr [rax-38h], xmm7
  }
  v6 = 0;
  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    _RDI = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 9135, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    _RDI = &g_entities[entnum];
    if ( !_RDI->client )
    {
      v10 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v10);
    }
  }
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam < 1 )
    Scr_Error(COM_ERR_4189, scrContext, "Not enough parameters.\n");
  if ( (_RDI->flags.m_flags[0] & 0x200) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 9141, ASSERT_TYPE_ASSERT, "( pSelf->flags.TestFlag( BgEntityFlagsCommon::SUPPORTS_LINKTO ) )", (const char *)&queryFormat, "pSelf->flags.TestFlag( BgEntityFlagsCommon::SUPPORTS_LINKTO )") )
    __debugbreak();
  if ( WorldUpReferenceFrame::HasValidWorldUpInPs(&_RDI->client->ps) )
    ScrCmd_Unlink_Internal(_RDI, 1);
  Entity = GScr_GetEntity(0);
  if ( NumParam > 1 && Scr_GetType(scrContext, 1u) )
  {
    ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 1u);
    if ( ConstLowercaseString == scr_const._ )
      ConstLowercaseString = 0;
    v6 = ConstLowercaseString;
  }
  if ( NumParam <= 2 )
    __asm { vmovss  xmm0, cs:__real@3f800000 }
  else
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
  __asm
  {
    vmovss  [rsp+198h+totalTime], xmm0
    vxorps  xmm6, xmm6, xmm6
  }
  if ( NumParam <= 3 )
  {
    __asm { vxorps  xmm7, xmm7, xmm7 }
  }
  else
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
    __asm { vmovaps xmm7, xmm0 }
  }
  if ( NumParam > 4 )
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 4u);
    __asm { vmovaps xmm6, xmm0 }
  }
  __asm
  {
    vmovaps xmm3, xmm6; decelTime
    vmovaps xmm2, xmm7; accelTime
  }
  CheckTimes(scrContext, &totalTime, *(float *)&_XMM2, *(float *)&_XMM3);
  _RAX = _RDI->client;
  __asm
  {
    vmovss  xmm0, dword ptr [rax+1D8h]
    vmovss  dword ptr [rsp+198h+inOutViewAngles], xmm0
    vmovss  xmm1, dword ptr [rax+1DCh]
    vmovss  dword ptr [rsp+198h+inOutViewAngles+4], xmm1
    vmovss  xmm0, dword ptr [rax+1E0h]
    vmovss  dword ptr [rsp+198h+inOutViewAngles+8], xmm0
  }
  if ( _RDI->tagInfo )
    BG_ApplyLinkAngles(&_RDI->client->ps.linkAngles, &inOutViewAngles);
  AnglesToQuat(&inOutViewAngles, &_RDI->c.blend.viewQuat);
  __asm { vmovss  xmm0, [rsp+198h+totalTime] }
  _RDI->c.item[0].ammoCount = LODWORD(_RDI->r.currentOrigin.v[0]);
  _RDI->c.item[0].clipAmmoCount[0] = LODWORD(_RDI->r.currentOrigin.v[1]);
  _RDI->c.item[0].clipAmmoCount[1] = LODWORD(_RDI->r.currentOrigin.v[2]);
  client = _RDI->client;
  __asm { vxorps  xmm1, xmm1, xmm1 }
  _RDI->c.spawner.count = LODWORD(client->ps.velocity.v[0]);
  _RDI->c.mover.pos.pos1.v[1] = client->ps.velocity.v[1];
  _RDI->c.mover.pos.pos1.v[2] = client->ps.velocity.v[2];
  v25 = _RDI->client;
  __asm
  {
    vmovss  dword ptr [rdi+1E8h], xmm7
    vmovss  dword ptr [rdi+1ECh], xmm6
    vmovss  dword ptr [rdi+1F4h], xmm0
    vcvtsi2ss xmm1, xmm1, cs:?level@@3Ulevel_locals_t@@A.time; level_locals_t level
    vmulss  xmm2, xmm1, cs:__real@3a83126f
    vmovss  dword ptr [rdi+1F0h], xmm2
  }
  _RDI->c.item[0].weapon.attachmentVariationIndices[19] = 1;
  _RDI->c.blend.platformEnt = truncate_cast<unsigned short,int>(v25->ps.movingPlatforms.m_movingPlatformEntity);
  _RDI->client->linkAnglesFrac = 1.0;
  _RDI->client->link_rotationMovesEyePos = 1;
  _RDI->client->link_useTagAnglesForViewAngles = 1;
  _RDI->client->link_useBaseAnglesForViewClamp = 0;
  _RDI->client->link_useTagScriptedCamera = 0;
  _RDI->client->prevLinkAnglesSet = 0;
  GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::SetFlagInternal(&_RDI->client->ps.linkFlags, ACTIVE, 0);
  GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::ClearFlagInternal(&_RDI->client->ps.linkFlags, ACTIVE, 2u);
  GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::ClearFlagInternal(&_RDI->client->ps.linkFlags, GameModeFlagValues::ms_spValue, 8u);
  if ( G_EntLinkTo(_RDI, Entity, v6, 256, outErrorMessage) )
  {
    _RDI->tagInfo->blendToParent = 1;
    G_InitPlayerLinkAngles(_RDI);
  }
  else
  {
    v28 = j_va("failed to link entity %i to entity %i: %s", (unsigned int)_RDI->s.number, (unsigned int)Entity->s.number, outErrorMessage);
    Scr_Error(COM_ERR_4190, scrContext, v28);
  }
  _R11 = &v35;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
  }
}

/*
==============
ScrCmd_LerpViewAngleClamp
==============
*/
void ScrCmd_LerpViewAngleClamp(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v14; 
  const char *v15; 
  int NumParam; 
  gclient_s *client; 
  __int128 v48; 
  char v49; 
  void *retaddr; 
  float totalTime; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-28h], xmm6
    vmovaps xmmword ptr [rax-38h], xmm7
    vmovaps xmmword ptr [rax-48h], xmm8
  }
  entnum = entref.entnum;
  __asm
  {
    vmovaps xmmword ptr [rax-58h], xmm9
    vmovaps xmmword ptr [rax-68h], xmm10
    vmovaps xmmword ptr [rax-78h], xmm11
    vmovaps [rsp+0B8h+var_88], xmm12
  }
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v14 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 9259, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES", v48) )
      __debugbreak();
    v14 = &g_entities[entnum];
    if ( !v14->client )
    {
      v15 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v15);
    }
  }
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam < 7 )
    Scr_Error(COM_ERR_4191, scrContext, "Incorrect number of parameters.  See script docs.\n");
  if ( (NumParam <= 7 || !Scr_GetInt(scrContext, 7u)) && !BG_IsPlayerLinked(&v14->client->ps) && (v14->client->ps.linkFlags.m_flags[0] & 4) == 0 )
    Scr_Error(COM_ERR_4192, scrContext, "Must be linked to an entity.\n");
  if ( (v14->client->ps.linkFlags.m_flags[0] & 1) != 0 )
    Scr_Error(COM_ERR_4193, scrContext, "Angle locked to linked entity.  View clamp is 0.\n");
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm { vmovss  [rsp+0B8h+totalTime], xmm0 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm { vmovaps xmm8, xmm0 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
  __asm
  {
    vmovaps xmm3, xmm0; decelTime
    vmovaps xmm2, xmm8; accelTime
    vmovaps xmm9, xmm0
  }
  CheckTimes(scrContext, &totalTime, *(float *)&_XMM2, *(float *)&_XMM3);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
  __asm
  {
    vmovss  xmm7, cs:__real@43340000
    vmovaps xmm2, xmm7; max
    vxorps  xmm1, xmm1, xmm1; min
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm { vxorps  xmm10, xmm0, cs:__xmm@80000000800000008000000080000000 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 4u);
  __asm
  {
    vmovaps xmm2, xmm7; max
    vxorps  xmm1, xmm1, xmm1; min
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm { vmovaps xmm11, xmm0 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 5u);
  __asm
  {
    vmovaps xmm2, xmm7; max
    vxorps  xmm1, xmm1, xmm1; min
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm { vxorps  xmm12, xmm0, cs:__xmm@80000000800000008000000080000000 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 6u);
  __asm
  {
    vmovaps xmm2, xmm7; max
    vxorps  xmm1, xmm1, xmm1; min
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm { vmovaps xmm7, xmm0 }
  if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_FREEFALL_IDLE|WEAPON_OFFHAND_END) )
  {
    client = v14->client;
    client->link_viewClamp.resistMin.goal = 0i64;
    client->link_viewClamp.resistMax.goal = 0i64;
  }
  __asm { vmovss  xmm6, [rsp+0B8h+totalTime] }
  _RBX = &v14->client->link_viewClamp;
  if ( v14->client == (gclient_s *)-24252i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 9206, ASSERT_TYPE_ASSERT, "(clamp)", (const char *)&queryFormat, "clamp") )
    __debugbreak();
  __asm
  {
    vmovss  dword ptr [rbx+68h], xmm6
    vmovss  dword ptr [rbx+60h], xmm8
    vmovss  dword ptr [rbx+64h], xmm9
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, cs:?level@@3Ulevel_locals_t@@A.time; level_locals_t level
    vmulss  xmm1, xmm0, cs:__real@3a83126f
    vmovss  dword ptr [rbx+6Ch], xmm1
    vmovss  dword ptr [rbx+28h], xmm7
    vmovss  dword ptr [rbx+2Ch], xmm11
    vmovss  dword ptr [rbx+10h], xmm12
    vmovss  dword ptr [rbx+14h], xmm10
  }
  _RBX->min.start.v[0] = _RBX->min.current.v[0];
  _RBX->min.start.v[1] = _RBX->min.current.v[1];
  _RBX->max.start.v[0] = _RBX->max.current.v[0];
  _RBX->max.start.v[1] = _RBX->max.current.v[1];
  if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_FREEFALL_IDLE|WEAPON_OFFHAND_END) )
  {
    _RBX->resistMin.start.v[0] = _RBX->resistMin.current.v[0];
    _RBX->resistMin.start.v[1] = _RBX->resistMin.current.v[1];
    _RBX->resistMax.start.v[0] = _RBX->resistMax.current.v[0];
    _RBX->resistMax.start.v[1] = _RBX->resistMax.current.v[1];
  }
  _R11 = &v49;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
  }
}

/*
==============
ScrCmd_SetViewAngleResistance
==============
*/
void ScrCmd_SetViewAngleResistance(scrContext_t *scrContext, scr_entref_t entref)
{
  int v9; 
  unsigned int entnum; 
  gentity_s *v12; 
  const char *v13; 
  unsigned int NumParam; 
  char v36; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm { vmovaps xmmword ptr [rax-18h], xmm6 }
  v9 = 0;
  __asm { vmovaps xmmword ptr [rax-28h], xmm7 }
  entnum = entref.entnum;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm8
    vmovaps xmmword ptr [rax-48h], xmm9
  }
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v12 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 9316, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v12 = &g_entities[entnum];
    if ( !v12->client )
    {
      v13 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v13);
    }
  }
  if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_FREEFALL_IDLE|WEAPON_OFFHAND_END) )
    Scr_Error(COM_ERR_4194, scrContext, "SetViewAngleResistance is not supported in this game mode");
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam - 4 > 1 )
    Scr_Error(COM_ERR_4195, scrContext, "Incorrect number of parameters.  See script docs.\n");
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm
  {
    vmovss  xmm6, cs:__real@43340000
    vmovaps xmm2, xmm6; max
    vxorps  xmm1, xmm1, xmm1; min
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm { vmovaps xmm7, xmm0 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm
  {
    vmovaps xmm2, xmm6; max
    vxorps  xmm1, xmm1, xmm1; min
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm { vmovaps xmm8, xmm0 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
  __asm
  {
    vmovaps xmm2, xmm6; max
    vxorps  xmm1, xmm1, xmm1; min
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm { vmovaps xmm9, xmm0 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
  __asm
  {
    vmovaps xmm2, xmm6; max
    vxorps  xmm1, xmm1, xmm1; min
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm { vmovaps xmm6, xmm0 }
  if ( NumParam == 5 )
    LOBYTE(v9) = Scr_GetInt(scrContext, 4u) != 0;
  else
    v9 = 1;
  _RCX = v12->client;
  __asm
  {
    vmovss  dword ptr [rcx+5F18h], xmm8
    vmovss  dword ptr [rcx+5F14h], xmm6
    vmovss  dword ptr [rcx+5F00h], xmm7
    vmovss  dword ptr [rcx+5EFCh], xmm9
  }
  if ( v9 )
  {
    _RCX->link_viewClamp.resistMin.current.v[0] = _RCX->link_viewClamp.resistMin.goal.v[0];
    _RCX->link_viewClamp.resistMin.current.v[1] = _RCX->link_viewClamp.resistMin.goal.v[1];
    _RCX->link_viewClamp.resistMax.current.v[0] = _RCX->link_viewClamp.resistMax.goal.v[0];
    _RCX->link_viewClamp.resistMax.current.v[1] = _RCX->link_viewClamp.resistMax.goal.v[1];
  }
  __asm { vmovaps xmm6, [rsp+78h+var_18] }
  _R11 = &v36;
  __asm
  {
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm7, [rsp+78h+var_28]
  }
}

/*
==============
ScrCmd_MakeUsable
==============
*/
void ScrCmd_MakeUsable(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  __int16 scriptMoverType; 
  __int16 v5; 
  int v6; 
  int v7; 

  Entity = GetEntity(entref);
  if ( BG_IsCharacterEntity(&Entity->s) && !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_STILL_LAND|0x80) )
    Scr_Error(COM_ERR_4196, scrContext, "MakeUsable may not be called on player or agent type entities");
  if ( Entity->vehicle )
    Entity->spawnflags |= 1u;
  G_PlayerUse_SetEntityUsable(Entity, 1);
  if ( !Entity->hint.hintType )
  {
    if ( Entity->s.eType == ET_SCRIPTMOVER )
    {
      scriptMoverType = Entity->s.un.scriptMoverType;
      if ( (unsigned __int16)scriptMoverType >= 0xCu )
      {
        v7 = 12;
        v6 = scriptMoverType;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 9376, ASSERT_TYPE_ASSERT, "(unsigned)( ent->s.un.scriptMoverType ) < (unsigned)( ScriptMoverType_Count )", "ent->s.un.scriptMoverType doesn't index ScriptMoverType_Count\n\t%i not in [0, %i)", v6, v7) )
          __debugbreak();
      }
      v5 = 1;
      if ( (unsigned __int16)(Entity->s.un.scriptMoverType - 5) <= 1u )
        v5 = 6;
    }
    else
    {
      v5 = 1;
    }
    Entity->hint.hintType = v5;
  }
  SV_LinkEntity(Entity);
}

/*
==============
ScrCmd_MakeUnusable
==============
*/
void ScrCmd_MakeUnusable(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v3; 

  Entity = GetEntity(entref);
  v3 = Entity;
  if ( Entity->vehicle )
    Entity->spawnflags &= ~1u;
  G_PlayerUse_SetEntityUsable(Entity, 0);
  SV_LinkEntity(v3);
}

/*
==============
GScr_AIAnimsetHasState
==============
*/
void GScr_AIAnimsetHasState(scrContext_t *scrContext)
{
  scr_string_t ConstLowercaseString; 
  scr_string_t v3; 
  int StateInfoByName; 
  AnimsetState *outState; 

  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
    v3 = Scr_GetConstLowercaseString(scrContext, 1u);
    outState = NULL;
    StateInfoByName = BG_Animset_GetStateInfoByName(ConstLowercaseString, v3, &outState, NULL);
    Scr_AddBool(scrContext, StateInfoByName);
  }
  else
  {
    Scr_Error(COM_ERR_4739, scrContext, "GScr_ArchetypeHasState called with incorrect number of parameters.");
  }
}

/*
==============
ScrCmd_EnableMissileHint
==============
*/
void ScrCmd_EnableMissileHint(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  unsigned __int8 flags; 

  Entity = GetEntity(entref);
  Int = Scr_GetInt(scrContext, 0);
  flags = Entity->hint.flags;
  if ( Int )
    Entity->hint.flags = flags | 0x10;
  else
    Entity->hint.flags = flags & 0xEF;
}

/*
==============
GScr_SetUmbraPortalState
==============
*/
void GScr_SetUmbraPortalState(scrContext_t *scrContext)
{
  const char *String; 
  const char *v3; 
  int Int; 
  unsigned __int64 v5; 
  unsigned int gateIndexOut; 

  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_Error(COM_ERR_4740, scrContext, "SetUmbraPortalState() called with incorrect number of parameters.  Usage:  SetUmbraPortalState( <gate name>, <0/1> )\n");
  String = Scr_GetString(scrContext, 0);
  gateIndexOut = 0;
  v3 = String;
  if ( Com_GetUmbraGateIndex(String, &gateIndexOut) )
  {
    Int = Scr_GetInt(scrContext, 1u);
    v5 = gateIndexOut;
    if ( Int )
    {
      if ( gateIndexOut >= 0x180 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 263, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", gateIndexOut, 384) )
        __debugbreak();
      level.umbraGateStates.array[v5 >> 5] |= 0x80000000 >> (v5 & 0x1F);
    }
    else
    {
      if ( gateIndexOut >= 0x180 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 290, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", gateIndexOut, 384) )
        __debugbreak();
      level.umbraGateStates.array[v5 >> 5] &= ~(0x80000000 >> (v5 & 0x1F));
    }
  }
  else
  {
    Com_PrintWarning(24, "SetUmbraPortalState() called on an unknown gate:  %s\n", v3);
  }
}

/*
==============
GScr_SetCursorHint
==============
*/
void GScr_SetCursorHint(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  const char *String; 
  scr_string_t classname; 
  const char *v9; 
  const dvar_t *v11; 
  char v13; 
  const dvar_t *v14; 
  int v15; 
  __int64 v16; 
  const char *v17; 
  signed __int64 v18; 
  int v19; 
  __int64 v20; 
  int v21; 
  int v22; 
  int v23; 
  const char **v24; 
  __int64 v25; 
  const char *v26; 

  entnum = entref.entnum;
  Entity = GetEntity(entref);
  _RBP = Entity;
  if ( Entity->s.eType == ET_MISSILE && (Entity->hint.flags & 0x10) == 0 )
    Scr_Error(COM_ERR_4197, scrContext, "SetCursorHint called on missile without EnableMissileHint() activation.");
  if ( BG_IsCharacterEntity(&_RBP->s) && !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_STILL_LAND|0x80) )
    Scr_Error(COM_ERR_4198, scrContext, "SetCursorHint may not be called on player or agent type entities");
  if ( (_RBP->r.svFlags & 1) != 0 )
  {
    if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_STILL_LAND|0x80) )
    {
      Com_Printf(24, "SetCursorHint called on entity %d, which has SVF_NOCLIENT set. Flag will be removed and the entity will be passed to clients.\n", entnum);
      _RBP->r.svFlags &= ~1u;
    }
    else
    {
      Com_PrintWarning(24, "SetCursorHint called on entity %d, which has SVF_NOCLIENT set. This entity cannot support a cursor hint since it is not sent to the client!\n", entnum);
    }
  }
  String = Scr_GetString(scrContext, 0);
  classname = _RBP->classname;
  v9 = String;
  if ( (classname == scr_const.trigger_use || classname == scr_const.trigger_use_touch) && !I_stricmp(String, "HINT_NODISPLAY") )
  {
    _RBP->hint.hintType = 3;
  }
  else
  {
    if ( !I_stricmp(v9, "HINT_BUTTON") )
    {
      __asm
      {
        vmovaps [rsp+88h+var_38], xmm6
        vxorps  xmm6, xmm6, xmm6
        vcomiss xmm6, dword ptr [rbp+264h]
      }
      v11 = DVARFLT_player_buttonHintRadius;
      if ( !DVARFLT_player_buttonHintRadius && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_buttonHintRadius") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v11);
      LODWORD(_RBP->hint.displayRadius) = v11->current.integer;
      __asm
      {
        vcomiss xmm6, dword ptr [rbp+268h]
        vmovaps xmm6, [rsp+88h+var_38]
      }
      if ( !v13 )
      {
        v14 = DVARFLT_player_buttonHintFOV;
        if ( !DVARFLT_player_buttonHintFOV && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_buttonHintFOV") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v14);
        LODWORD(_RBP->hint.displayFOV) = v14->current.integer;
      }
    }
    v15 = 1;
    while ( 2 )
    {
      v16 = 0x7FFFFFFFi64;
      v17 = hintStrings[v15];
      if ( !v9 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
        __debugbreak();
      if ( !v17 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 213, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
        __debugbreak();
      v18 = v9 - v17;
      while ( 1 )
      {
        v19 = (unsigned __int8)v17[v18];
        v20 = v16;
        v21 = *(unsigned __int8 *)v17++;
        --v16;
        if ( !v20 )
        {
LABEL_40:
          if ( (unsigned int)(v15 + 0x8000) > 0xFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "short __cdecl truncate_cast_impl<short,int>(int)", "signed", (__int16)v15, "signed", v15) )
            __debugbreak();
          _RBP->hint.hintType = v15;
          return;
        }
        if ( v19 != v21 )
        {
          v22 = v19 + 32;
          if ( (unsigned int)(v19 - 65) > 0x19 )
            v22 = v19;
          v19 = v22;
          v23 = v21 + 32;
          if ( (unsigned int)(v21 - 65) > 0x19 )
            v23 = v21;
          if ( v19 != v23 )
            break;
        }
        if ( !v19 )
          goto LABEL_40;
      }
      if ( ++v15 < 6 )
        continue;
      break;
    }
    Com_Printf(23, "List of valid hint type strings\n");
    v24 = &hintStrings[1];
    v25 = 5i64;
    do
    {
      Com_Printf(23, "%s\n", *v24++);
      --v25;
    }
    while ( v25 );
    v26 = j_va("%s is not a valid hint type. See above for list of valid hint types\n", v9);
    Scr_Error(COM_ERR_4199, scrContext, v26);
  }
}

/*
==============
G_ScrMain_FrontEndSceneCameraFade
==============
*/
void G_ScrMain_FrontEndSceneCameraFade(scrContext_t *scrContext)
{
  BOOL v3; 

  if ( !Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_4741, scrContext, "FrontEndSceneCameraChange() called with incorrect number of parameters.\n");
  v3 = Scr_GetInt(scrContext, 0) != 0;
  if ( Scr_GetNumParam(scrContext) <= 2 )
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
    __asm
    {
      vmulss  xmm1, xmm0, cs:__real@447a0000
      vcvttss2si eax, xmm1
    }
  }
  else
  {
    _EAX = 500;
  }
  G_FrontEndScene_SetCameraFade((const BgScriptedCameraFadeState)v3, level.time, level.time + _EAX);
}

/*
==============
G_ScrMain_FrontEndSceneCameraFOV
==============
*/
void G_ScrMain_FrontEndSceneCameraFOV(scrContext_t *scrContext)
{
  int Int; 

  if ( !Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_4742, scrContext, "FrontEndSceneFovChange() called with incorrect number of parameters.\n");
  Int = Scr_GetInt(scrContext, 0);
  if ( Scr_GetNumParam(scrContext) < 2 )
  {
    _ECX = 0;
  }
  else
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
    __asm
    {
      vmulss  xmm1, xmm0, cs:__real@447a0000
      vcvttss2si ecx, xmm1
    }
  }
  G_FrontEndScene_SetCameraFov(Int, level.time, level.time + _ECX);
}

/*
==============
G_ScrMain_FrontEndSceneCameraCharacters
==============
*/
void G_ScrMain_FrontEndSceneCameraCharacters(scrContext_t *scrContext)
{
  unsigned int time; 
  unsigned int NumParam; 
  unsigned int v4; 
  unsigned int Int; 
  __int64 v6; 
  bool requiredCharacters[8]; 
  __int64 v8; 
  __int64 i; 

  if ( Scr_GetNumParam(scrContext) > 0x18 )
    Scr_Error(COM_ERR_4743, scrContext, "FrontEndSceneCameraRequiredCharacter() called with too many parameters.\n");
  time = level.time;
  NumParam = Scr_GetNumParam(scrContext);
  Com_Printf(24, "FrontEndSceneCameraCharacters: %i characters, time %i.\n", NumParam, time);
  *(_QWORD *)requiredCharacters = 0i64;
  v4 = 0;
  v8 = 0i64;
  for ( i = 0i64; v4 < Scr_GetNumParam(scrContext); ++v4 )
  {
    Int = Scr_GetInt(scrContext, v4);
    v6 = Int;
    if ( Int >= 0x18 )
      Scr_Error(COM_ERR_4744, scrContext, "FrontEndSceneCameraRequiredCharacter() CharacterId must a valid client index.\n");
    requiredCharacters[v6] = 1;
  }
  G_FrontEndScene_SetCameraCharacters(requiredCharacters, level.time);
}

/*
==============
G_ScrMain_FrontEndSceneCameraCinematic
==============
*/
void G_ScrMain_FrontEndSceneCameraCinematic(scrContext_t *scrContext)
{
  const char *String; 
  bool v3; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4745, scrContext, "Expected parameter <bink name>");
  String = Scr_GetString(scrContext, 0);
  if ( Scr_GetNumParam(scrContext) < 2 )
  {
    v3 = 1;
  }
  else
  {
    if ( !*String )
      Scr_ParamError(COM_ERR_4746, scrContext, 1u, "Shouldn't specify a looping parameter when the bink name is blank");
    v3 = Scr_GetInt(scrContext, 1u) != 0;
  }
  G_FrontEndScene_SetCameraCinematicPlayback(String, v3, level.time);
}

/*
==============
G_ScrMain_FrontEndSceneGetActiveSection
==============
*/
void G_ScrMain_FrontEndSceneGetActiveSection(scrContext_t *scrContext)
{
  int ActiveSectionParam; 
  unsigned int CanonicalString; 
  const char *ActiveSectionName; 
  unsigned int v5; 

  Scr_AddStruct(scrContext);
  ActiveSectionParam = G_FrontEndScene_GetActiveSectionParam();
  Scr_AddInt(scrContext, ActiveSectionParam);
  CanonicalString = SL_GetCanonicalString("index");
  Scr_AddStructField(scrContext, CanonicalString);
  ActiveSectionName = G_FrontEndScene_GetActiveSectionName();
  Scr_AddString(scrContext, ActiveSectionName);
  v5 = SL_GetCanonicalString((const char *)&stru_143C9A1A4);
  Scr_AddStructField(scrContext, v5);
}

/*
==============
ScrCmd_IsAgent
==============
*/
void ScrCmd_IsAgent(scrContext_t *scrContext)
{
  const gentity_s *Entity; 

  if ( Scr_GetType(scrContext, 0) == VAR_POINTER && Scr_GetPointerType(scrContext, 0) == VAR_ENTITY && (Entity = GScr_GetEntity(0), SV_IsAgentEntity(Entity)) )
    Scr_AddInt(scrContext, 1);
  else
    Scr_AddInt(scrContext, 0);
}

/*
==============
GScr_SetHintString
==============
*/
void GScr_SetHintString(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  entityType_s eType; 
  const char *v5; 
  ComErrorCode v6; 
  scr_string_t classname; 
  const char *String; 
  const char *v9; 

  Entity = GetEntity(entref);
  eType = Entity->s.eType;
  if ( eType == ET_MISSILE )
  {
    if ( (Entity->hint.flags & 0x10) == 0 )
    {
      v5 = "SetHintString called on missile without EnableMissileHint() activation.";
      v6 = COM_ERR_4200;
LABEL_11:
      Scr_Error(v6, scrContext, v5);
    }
  }
  else
  {
    classname = Entity->classname;
    if ( classname != scr_const.trigger_use && classname != scr_const.trigger_use_touch && eType != ET_TURRET && eType != ET_SCRIPTMOVER && !Entity->actor && !Entity->agent )
    {
      v5 = "The setHintString command only works on trigger_use, trigger_use_touch, turret, actor, and script entities.\n";
      v6 = COM_ERR_4201;
      goto LABEL_11;
    }
  }
  Entity->hint.hintString = 0;
  if ( Scr_GetType(scrContext, 0) != VAR_STRING || (String = Scr_GetString(scrContext, 0), I_stricmp(String, (const char *)&queryFormat.fmt + 3)) )
    Entity->hint.hintString = G_ScrMain_GetHintStringMessage(scrContext, 0, 0);
  Entity->hint.ownerHintString = 0;
  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    if ( Scr_GetType(scrContext, 1u) != VAR_STRING || (v9 = Scr_GetString(scrContext, 1u), I_stricmp(v9, (const char *)&queryFormat.fmt + 3)) )
      Entity->hint.ownerHintString = G_ScrMain_GetHintStringMessage(scrContext, 1, 1);
  }
}

/*
==============
ScrCmd_IsScriptedAgent
==============
*/
void ScrCmd_IsScriptedAgent(scrContext_t *scrContext)
{
  const gentity_s *Entity; 

  if ( Scr_GetType(scrContext, 0) == VAR_POINTER && Scr_GetPointerType(scrContext, 0) == VAR_ENTITY && (Entity = GScr_GetEntity(0), SV_IsAgentEntity(Entity)) && SV_Agent_IsScripted(Entity->s.number) )
    Scr_AddInt(scrContext, 1);
  else
    Scr_AddInt(scrContext, 0);
}

/*
==============
ScrCmd_IsBot
==============
*/
void ScrCmd_IsBot(scrContext_t *scrContext)
{
  const gentity_s *Entity; 

  if ( Scr_GetType(scrContext, 0) == VAR_POINTER && Scr_GetPointerType(scrContext, 0) == VAR_ENTITY && (Entity = GScr_GetEntity(0), SV_BotIsBotEntClient(Entity)) )
    Scr_AddInt(scrContext, 1);
  else
    Scr_AddInt(scrContext, 0);
}

/*
==============
ScrCmd_GetWeaponClipModel
==============
*/
void ScrCmd_GetWeaponClipModel(scrContext_t *scrContext)
{
  const WeaponAttachment *WeaponPrimaryAttachment; 
  const WeaponAttachment *v3; 
  unsigned int numModelVariations; 
  __int64 v5; 
  const char *name; 
  int v7; 
  unsigned int v8; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( outWeapon.weaponIdx )
  {
    WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(&outWeapon, ATT_SLOT_MAGAZINE);
    v3 = WeaponPrimaryAttachment;
    if ( WeaponPrimaryAttachment )
    {
      numModelVariations = WeaponPrimaryAttachment->numModelVariations;
      if ( numModelVariations )
      {
        v5 = outWeapon.attachmentVariationIndices[3];
        if ( outWeapon.attachmentVariationIndices[3] >= numModelVariations )
        {
          v8 = WeaponPrimaryAttachment->numModelVariations;
          v7 = outWeapon.attachmentVariationIndices[3];
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 27778, ASSERT_TYPE_ASSERT, "(unsigned)( varIndex ) < (unsigned)( magazineAttachment->numModelVariations )", "varIndex doesn't index magazineAttachment->numModelVariations\n\t%i not in [0, %i)", v7, v8) )
            __debugbreak();
        }
        name = v3->worldModelVariations[v5]->name;
        if ( name )
        {
          if ( *name )
            Scr_AddString(scrContext, name);
        }
      }
    }
  }
}

/*
==============
GScr_SetHintIcon
==============
*/
void GScr_SetHintIcon(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t classname; 
  entityType_s eType; 
  const char *String; 
  const char *v7; 
  unsigned int outIndex; 

  Entity = GetEntity(entref);
  classname = Entity->classname;
  if ( classname != scr_const.trigger_use && classname != scr_const.trigger_use_touch )
  {
    eType = Entity->s.eType;
    if ( eType != ET_TURRET && eType != ET_SCRIPTMOVER && !Entity->actor && !Entity->agent )
      Scr_Error(COM_ERR_4202, scrContext, "The SetHintStringParams command only works on trigger_use, trigger_use_touch, turret, actor, and script entities.\n");
  }
  String = Scr_GetString(scrContext, 0);
  if ( !NetConstStrings_GetIndexFromName(NETCONSTSTRINGTYPE_IMAGE, String, &outIndex) )
  {
    v7 = j_va("'%s' is not a valid image. Please make sure it is included as precache_image in zone_source.", String);
    Scr_Error(COM_ERR_4203, scrContext, v7);
  }
  Entity->hint.paramsTypes[0] = HINT_PARAM_TYPE_IMAGE;
  Entity->hint.paramValues[0].intVal = outIndex;
}

/*
==============
GScr_SetHintStringParams
==============
*/
void GScr_SetHintStringParams(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t classname; 
  entityType_s eType; 
  unsigned int NumParam; 
  unsigned int v8; 
  __int64 v10; 
  VariableType Type; 
  const char *v12; 
  unsigned int HintStringMessage; 

  Entity = GetEntity(entref);
  classname = Entity->classname;
  if ( classname != scr_const.trigger_use && classname != scr_const.trigger_use_touch )
  {
    eType = Entity->s.eType;
    if ( eType != ET_TURRET && eType != ET_SCRIPTMOVER && !Entity->actor && !Entity->agent )
      Scr_Error(COM_ERR_4204, scrContext, "The SetHintStringParams command only works on trigger_use, trigger_use_touch, turret, actor, and script entities.\n");
  }
  NumParam = Scr_GetNumParam(scrContext);
  v8 = 0;
  if ( NumParam )
  {
    _RSI = Entity->hint.paramValues;
    v10 = 0i64;
    do
    {
      Type = Scr_GetType(scrContext, v8);
      if ( Type )
      {
        switch ( Type )
        {
          case VAR_ISTRING:
            HintStringMessage = G_ScrMain_GetHintStringMessage(scrContext, v8, v8);
            if ( !HintStringMessage )
              Com_PrintError(15, "SetHintStringParams could not find or allocate hint string index for param %u", v8);
            Entity->hint.paramsTypes[v10] = HINT_PARAM_TYPE_STRING;
            _RSI->intVal = HintStringMessage;
            break;
          case VAR_FLOAT:
            Entity->hint.paramsTypes[v10] = HINT_PARAM_TYPE_FLOAT;
            *(double *)&_XMM0 = Scr_GetFloat(scrContext, v8);
            __asm { vmovss  dword ptr [rsi], xmm0 }
            break;
          case VAR_INTEGER:
            Entity->hint.paramsTypes[v10] = HINT_PARAM_TYPE_INT;
            _RSI->intVal = Scr_GetInt(scrContext, v8);
            break;
          default:
            v12 = j_va("The SetHintStringParams passed an unhandled type for parameter %u\n", v8);
            Scr_Error(COM_ERR_4205, scrContext, v12);
            break;
        }
      }
      else
      {
        Entity->hint.paramsTypes[v10] = HINT_PARAM_TYPE_NONE;
        _RSI->intVal = 0;
      }
      ++v8;
      ++v10;
      ++_RSI;
    }
    while ( v8 < NumParam );
  }
}

/*
==============
ScrCmd_GetUnarchivedDebugDvar
==============
*/
void ScrCmd_GetUnarchivedDebugDvar(scrContext_t *scrContext)
{
  const char *String; 
  unsigned int NumParam; 
  const char *v4; 
  const char *VariantStringWithDefault; 

  String = (char *)&queryFormat.fmt + 3;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam != 1 )
  {
    if ( NumParam != 2 )
    {
      Scr_Error(COM_ERR_4747, scrContext, "GetUnarchivedDebugDvar( <dvar>, <default> ) takes either one or two parameters");
      return;
    }
    String = Scr_GetString(scrContext, 1u);
  }
  v4 = Scr_GetString(scrContext, 0);
  VariantStringWithDefault = Dvar_GetVariantStringWithDefault(v4, String);
  Scr_AddString(scrContext, VariantStringWithDefault);
}

/*
==============
ScrCmd_SetClothType
==============
*/
void ScrCmd_SetClothType(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *String; 
  int EquipmentSoundClothIndex; 
  const char *v6; 
  AICommonInterface *m_pAI; 
  void (__fastcall *SetClothType)(AICommonInterface *, unsigned __int8); 
  AICommonWrapper v9; 

  Entity = GetEntity(entref);
  String = Scr_GetString(scrContext, 0);
  EquipmentSoundClothIndex = BG_FindEquipmentSoundClothIndex(String);
  if ( EquipmentSoundClothIndex == -1 )
  {
    v6 = j_va("unable to find cloth type '%s'", String);
    Scr_Error(COM_ERR_4748, scrContext, v6);
  }
  if ( Entity->client )
  {
    Entity->client->ps.clothType = truncate_cast<signed char,int>(EquipmentSoundClothIndex);
  }
  else
  {
    AIActorInterface::AIActorInterface(&v9.m_actorInterface);
    AIAgentInterface::AIAgentInterface(&v9.m_newAgentInterface);
    v9.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
    AICommonInterface::AICommonInterface(&v9.m_botInterface);
    v9.m_botInterface.__vftable = (AIBotInterface_vtbl *)&AIBotInterface::`vftable';
    AICommonInterface::AICommonInterface(&v9.m_botAgentInterface);
    v9.m_pAI = NULL;
    v9.m_botAgentInterface.__vftable = (AIBotAgentInterface_vtbl *)&AIBotAgentInterface::`vftable';
    AICommonWrapper::Setup(&v9, Entity);
    m_pAI = v9.m_pAI;
    if ( v9.m_pAI )
    {
      SetClothType = v9.m_pAI->SetClothType;
      if ( (EquipmentSoundClothIndex < 0 || (unsigned int)EquipmentSoundClothIndex > 0xFF) && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned char __cdecl truncate_cast_impl<unsigned char,int>(int)", "unsigned", (unsigned __int8)EquipmentSoundClothIndex, "signed", EquipmentSoundClothIndex) )
        __debugbreak();
      SetClothType(m_pAI, EquipmentSoundClothIndex);
    }
  }
}

/*
==============
GScr_SetHintDisplayRange
==============
*/
void GScr_SetHintDisplayRange(scrContext_t *scrContext, scr_entref_t entref)
{
  _RDI = GetEntity(entref);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm
  {
    vxorps  xmm1, xmm1, xmm1
    vmaxss  xmm0, xmm0, xmm1
    vmovss  dword ptr [rdi+264h], xmm0
  }
}

/*
==============
GScr_SetHintDisplayFOV
==============
*/
void GScr_SetHintDisplayFOV(scrContext_t *scrContext, scr_entref_t entref)
{
  _RDI = GetEntity(entref);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm
  {
    vxorps  xmm1, xmm1, xmm1
    vmaxss  xmm0, xmm0, xmm1
    vmovss  dword ptr [rdi+268h], xmm0
  }
}

/*
==============
GScr_SetHintTag
==============
*/
void GScr_SetHintTag(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t ConstLowercaseString; 
  int BoneIndex; 

  Entity = GetEntity(entref);
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  if ( SV_Game_DObjExists(Entity) )
  {
    BoneIndex = SV_Game_DObjGetBoneIndex(Entity, ConstLowercaseString);
    if ( BoneIndex < 0 )
      BoneIndex = 255;
    Entity->hint.tag = BoneIndex;
  }
  else
  {
    Entity->hint.tag = 255;
  }
}

/*
==============
GScr_SetUseRange
==============
*/
void GScr_SetUseRange(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int number; 
  const char *v9; 

  _RBX = GetEntity(entref);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  number = _RBX->s.number;
  __asm
  {
    vxorps  xmm1, xmm1, xmm1
    vmaxss  xmm3, xmm0, xmm1; useRadius
    vmovss  dword ptr [rbx+26Ch], xmm3
  }
  if ( !G_PlayerUse_SetUseRadius(number, USE_CLASS_GENTITY, 0, *(const float *)&_XMM3) )
  {
    v9 = j_va("Failed to set the use radius for entity %d\n", (unsigned int)_RBX->s.number);
    Scr_Error(COM_ERR_4206, scrContext, v9);
  }
}

/*
==============
ScrCmd_GetShootAtPosition
==============
*/
void ScrCmd_GetShootAtPosition(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const gentity_s *v4; 
  const sentient_s *sentient; 
  gclient_s *client; 
  scr_string_t tag_eye; 
  vec3_t outCentroid; 

  Entity = GetEntity(entref);
  v4 = Entity;
  sentient = Entity->sentient;
  if ( sentient )
  {
    client = Entity->client;
    if ( client && client->sess.sessionState )
    {
      Com_PrintWarning(23, "GetShootAtPos() called while not in SESS_STATE_PLAYING");
      G_Utils_EntityCentroid(v4, &outCentroid);
    }
    else
    {
      Sentient_GetEyePosition(sentient, &outCentroid);
    }
  }
  else
  {
    tag_eye = scr_const.tag_eye;
    if ( Entity->s.number != level.cachedEntTargetTagMat.entnum || level.time != level.cachedEntTargetTagMat.time || scr_const.tag_eye != level.cachedEntTargetTagMat.name )
    {
      if ( !SV_Game_DObjExists(Entity) || !G_Utils_DObjGetWorldTagMatrix(v4, tag_eye, &level.cachedEntTargetTagMat.tagMat) )
      {
        G_Utils_EntityCentroid(v4, &outCentroid);
        goto LABEL_14;
      }
      level.cachedEntTargetTagMat.entnum = v4->s.number;
      level.cachedEntTargetTagMat.time = level.time;
      Scr_SetString(&level.cachedEntTargetTagMat.name, tag_eye);
    }
    __asm
    {
      vmovss  xmm0, dword ptr cs:?level@@3Ulevel_locals_t@@A.cachedEntTargetTagMat.tagMat+24h; level_locals_t level
      vmovss  xmm1, dword ptr cs:?level@@3Ulevel_locals_t@@A.cachedEntTargetTagMat.tagMat+28h; level_locals_t level
      vmovss  dword ptr [rsp+48h+outCentroid], xmm0
      vmovss  xmm0, dword ptr cs:?level@@3Ulevel_locals_t@@A.cachedEntTargetTagMat.tagMat+2Ch; level_locals_t level
      vmovss  dword ptr [rsp+48h+outCentroid+8], xmm0
      vmovss  dword ptr [rsp+48h+outCentroid+4], xmm1
    }
  }
LABEL_14:
  Scr_AddVector(scrContext, outCentroid.v);
}

/*
==============
GScr_SetUseHoldDuration
==============
*/
void GScr_SetUseHoldDuration(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t ConstString; 
  const char *String; 
  const char *v6; 

  Entity = GetEntity(entref);
  ConstString = Scr_GetConstString(scrContext, 0);
  if ( ConstString == scr_const.duration_none )
  {
    Entity->hint.useHoldDuration = HINT_HOLD_DURATION_NONE;
  }
  else if ( ConstString == scr_const.duration_short )
  {
    Entity->hint.useHoldDuration = HINT_HOLD_DURATION_SHORT;
  }
  else if ( ConstString == scr_const.duration_medium )
  {
    Entity->hint.useHoldDuration = HINT_HOLD_DURATION_MEDIUM;
  }
  else if ( ConstString == scr_const.duration_long )
  {
    Entity->hint.useHoldDuration = HINT_HOLD_DURATION_LONG;
  }
  else
  {
    String = Scr_GetString(scrContext, 0);
    v6 = j_va("Illegal duration string \"%s\". Valid strings are \"duration_none\", \"duration_short\", \"duration_medium\", \"duration_long\"\n", String);
    Scr_Error(COM_ERR_4207, scrContext, v6);
  }
}

/*
==============
ScrCmd_GetMuzzlePos
==============
*/
void ScrCmd_GetMuzzlePos(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  AIWrapper v6; 
  vec3_t outOrigin; 
  vec3_t outForward; 

  AIActorInterface::AIActorInterface(&v6.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v6.m_newAgentInterface);
  v6.m_pAI = NULL;
  v6.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v6, Entity);
  m_pAI = v6.m_pAI;
  if ( !v6.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 27927, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  if ( !AIScriptedInterface::GetMuzzleInfo(m_pAI, &outOrigin, &outForward) )
    m_pAI->GetEyePosition(m_pAI, &outOrigin);
  Scr_AddVector(scrContext, outOrigin.v);
}

/*
==============
ScrCmd_NearNode
==============
*/
void ScrCmd_NearNode(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AICommonInterface *m_pAI; 
  const pathnode_t *Pathnode; 
  __int64 v7; 
  bool v8; 
  AICommonWrapper v9; 

  AIActorInterface::AIActorInterface(&v9.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v9.m_newAgentInterface);
  v9.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AICommonInterface::AICommonInterface(&v9.m_botInterface);
  v9.m_botInterface.__vftable = (AIBotInterface_vtbl *)&AIBotInterface::`vftable';
  AICommonInterface::AICommonInterface(&v9.m_botAgentInterface);
  v9.m_pAI = NULL;
  v9.m_botAgentInterface.__vftable = (AIBotAgentInterface_vtbl *)&AIBotAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AICommonWrapper::Setup(&v9, Entity);
  m_pAI = v9.m_pAI;
  if ( !v9.m_pAI || !v9.m_pAI->GetSentient(v9.m_pAI) )
    Scr_Error(COM_ERR_4749, scrContext, "NearNode must be called on an AI");
  Pathnode = Scr_GetPathnode(scrContext, 0);
  v7 = (__int64)m_pAI->GetEntity(m_pAI);
  v8 = AICommonInterface::PointNearNode(m_pAI, (const vec3_t *)(v7 + 304), Pathnode);
  Scr_AddBool(scrContext, v8);
}

/*
==============
GScr_SetUseHideProgressBar
==============
*/
void GScr_SetUseHideProgressBar(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  unsigned __int8 flags; 

  Entity = GetEntity(entref);
  Int = Scr_GetInt(scrContext, 0);
  flags = Entity->hint.flags;
  if ( Int )
    Entity->hint.flags = flags | 0x20;
  else
    Entity->hint.flags = flags & 0xDF;
}

/*
==============
GScr_SetUseWhenHandsOccupied
==============
*/
void GScr_SetUseWhenHandsOccupied(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  unsigned __int8 flags; 

  Entity = GetEntity(entref);
  Int = Scr_GetInt(scrContext, 0);
  flags = Entity->hint.flags;
  if ( Int )
    Entity->hint.flags = flags | 0x40;
  else
    Entity->hint.flags = flags & 0xBF;
}

/*
==============
ScrCmd_GetMuzzleDir
==============
*/
void ScrCmd_GetMuzzleDir(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  AIWrapper v6; 
  vec3_t outForward; 
  vec3_t outOrigin; 

  AIActorInterface::AIActorInterface(&v6.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v6.m_newAgentInterface);
  v6.m_pAI = NULL;
  v6.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v6, Entity);
  m_pAI = v6.m_pAI;
  if ( !v6.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 27981, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  if ( !AIScriptedInterface::GetMuzzleInfo(m_pAI, &outOrigin, &outForward) )
    AICommonInterface::GetEyeDirection(m_pAI, &outForward);
  Scr_AddVector(scrContext, outForward.v);
}

/*
==============
GScr_SetUseCommand
==============
*/
void GScr_SetUseCommand(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *String; 
  LocalClientNum_t OnlyLocalClientNum; 
  int CommandAssignment; 
  bool v7; 
  LocalClientNum_t v8; 
  int v9; 
  LocalClientNum_t v10; 
  int BindingForCommand; 
  int v12; 
  const char *v13; 
  int twokeys; 

  Entity = GetEntity(entref);
  String = Scr_GetString(scrContext, 0);
  if ( !String )
    Scr_Error(COM_ERR_4208, scrContext, "SetUseCommand: NULL useCommand provided.");
  if ( !Com_GameMode_SupportsFeature(WEAPON_LEAP_LOOP) )
    goto LABEL_8;
  OnlyLocalClientNum = CL_GetOnlyLocalClientNum();
  CommandAssignment = CL_Keys_GetCommandAssignment(OnlyLocalClientNum, String, &twokeys);
  v7 = CommandAssignment <= 0;
  if ( !CommandAssignment )
  {
    v8 = CL_GetOnlyLocalClientNum();
    v7 = CL_Keys_GetAlternateCommandAssignment(v8, String, &twokeys) <= 0;
  }
  if ( v7 )
  {
LABEL_8:
    BindingForCommand = Com_Keys_GetBindingForCommand(String);
    v12 = BindingForCommand;
    if ( (BindingForCommand & 1) == 0 || (unsigned int)(BindingForCommand - 117) <= 0x83 || BindingForCommand >= 255 || !BindingForCommand )
    {
      v13 = j_va("SetUseCommand: (%s) is not a valid use command.", String);
      Scr_Error(COM_ERR_4209, scrContext, v13);
    }
    Entity->hint.useBinding = v12;
  }
  else
  {
    v9 = twokeys;
    v10 = CL_GetOnlyLocalClientNum();
    Entity->hint.useBinding = CL_Keys_GetActiveBinding(v10, v9);
  }
}

/*
==============
ScrCmd_GetMuzzleAngle
==============
*/
void ScrCmd_GetMuzzleAngle(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  AIWrapper v6; 
  vec3_t outForward; 
  vec3_t angles; 
  vec3_t outOrigin; 

  AIActorInterface::AIActorInterface(&v6.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v6.m_newAgentInterface);
  v6.m_pAI = NULL;
  v6.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v6, Entity);
  m_pAI = v6.m_pAI;
  if ( !v6.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 28008, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  if ( !AIScriptedInterface::GetMuzzleInfo(m_pAI, &outOrigin, &outForward) )
    AICommonInterface::GetEyeDirection(m_pAI, &outForward);
  vectoangles(&outForward, &angles);
  Scr_AddVector(scrContext, angles.v);
}

/*
==============
GScr_SetUseFOV
==============
*/
void GScr_SetUseFOV(scrContext_t *scrContext, scr_entref_t entref)
{
  _RDI = GetEntity(entref);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm
  {
    vxorps  xmm1, xmm1, xmm1
    vmaxss  xmm0, xmm0, xmm1
    vmovss  dword ptr [rdi+270h], xmm0
  }
}

/*
==============
GScr_SetHintOnObstruction
==============
*/
void GScr_SetHintOnObstruction(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *String; 

  Entity = GetEntity(entref);
  String = Scr_GetString(scrContext, 0);
  if ( I_stricmp(String, "hide") )
  {
    if ( I_stricmp(String, "show") )
      Scr_Error(COM_ERR_4210, scrContext, "Acceptable values for SetHintOnObstruction are \"hide\" and \"show\".\n");
    else
      Entity->hint.onObstruction = SHOW;
  }
  else
  {
    Entity->hint.onObstruction = HIDE;
  }
}

/*
==============
ScrCmd_GetMuzzleSideOffsetPos
==============
*/
void ScrCmd_GetMuzzleSideOffsetPos(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  int MuzzleInfo; 
  AIScriptedInterface_vtbl *v7; 
  __int64 v8; 
  AIWrapper v20; 
  vec3_t outOrigin; 
  vec3_t right; 
  vec3_t outForward; 

  AIActorInterface::AIActorInterface(&v20.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v20.m_newAgentInterface);
  v20.m_pAI = NULL;
  v20.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v20, Entity);
  m_pAI = v20.m_pAI;
  if ( !v20.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 28032, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  MuzzleInfo = AIScriptedInterface::GetMuzzleInfo(m_pAI, &outOrigin, &outForward);
  v7 = m_pAI->__vftable;
  if ( MuzzleInfo )
  {
    v8 = (__int64)v7->GetEntity(m_pAI);
    AngleVectors((const vec3_t *)(v8 + 316), NULL, &right, NULL);
    __asm
    {
      vmovss  xmm0, dword ptr [rsp+0C8h+outOrigin+4]
      vsubss  xmm1, xmm0, dword ptr [rbx+134h]
      vmovss  xmm0, dword ptr [rsp+0C8h+outOrigin]
      vsubss  xmm2, xmm0, dword ptr [rbx+130h]
      vmulss  xmm4, xmm1, dword ptr [rsp+0C8h+right+4]
      vmulss  xmm1, xmm2, dword ptr [rsp+0C8h+right]
      vaddss  xmm4, xmm4, xmm1
      vmulss  xmm0, xmm4, dword ptr [rsp+0C8h+right]
      vaddss  xmm2, xmm0, dword ptr [rbx+130h]
      vmulss  xmm1, xmm4, dword ptr [rsp+0C8h+right+4]
      vmovss  dword ptr [rsp+0C8h+outOrigin], xmm2
      vaddss  xmm0, xmm1, dword ptr [rbx+134h]
      vmovss  dword ptr [rsp+0C8h+outOrigin+4], xmm0
    }
  }
  else
  {
    v7->GetEyePosition(m_pAI, &outOrigin);
  }
  Scr_AddVector(scrContext, outOrigin.v);
}

/*
==============
GScr_SetHintRequiresMashing
==============
*/
void GScr_SetHintRequiresMashing(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  unsigned __int8 flags; 

  Entity = GetEntity(entref);
  Int = Scr_GetInt(scrContext, 0);
  flags = Entity->hint.flags;
  if ( Int )
    Entity->hint.flags = flags | 2;
  else
    Entity->hint.flags = flags & 0xFD;
}

/*
==============
ScrCmd_UpdatePlayerSightAccuracy
==============
*/
void ScrCmd_UpdatePlayerSightAccuracy(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  AIWrapper v5; 

  AIActorInterface::AIActorInterface(&v5.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v5.m_newAgentInterface);
  v5.m_pAI = NULL;
  v5.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v5, Entity);
  m_pAI = v5.m_pAI;
  if ( !v5.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 28066, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  AIScriptedInterface::UpdatePlayerSightAccuracy(m_pAI);
}

/*
==============
GScr_SetHintLockPlayerMovement
==============
*/
void GScr_SetHintLockPlayerMovement(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  unsigned __int8 flags; 

  Entity = GetEntity(entref);
  Int = Scr_GetInt(scrContext, 0);
  flags = Entity->hint.flags;
  if ( Int )
    Entity->hint.flags = flags | 8;
  else
    Entity->hint.flags = flags & 0xF7;
}

/*
==============
GScr_ClearPlayerHintLock
==============
*/
void GScr_ClearPlayerHintLock(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  char *client; 
  const char *v6; 
  ComErrorCode v7; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 10057, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = (char *)v4->client;
  if ( !client )
  {
    client = (char *)v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v7, scrContext, v6);
      client = NULL;
    }
  }
  *((_WORD *)client + 366) &= ~0x10u;
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal((GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *)(client + 28), GameModeFlagValues::ms_spValue, 0x2Eu);
}

/*
==============
ScrCmd_AddAIEventListener
==============
*/
void ScrCmd_AddAIEventListener(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *v4; 
  scr_string_t ConstString; 

  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 28087, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !Entity->sentient )
  {
    v4 = j_va("entity %d must be a sentient!", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_4750, scrContext, v4);
  }
  ConstString = Scr_GetConstString(scrContext, 0);
  Actor_EventListener_Add(Entity->s.number, ConstString);
}

/*
==============
ScrCmd_RemoveAIEventListener
==============
*/
void ScrCmd_RemoveAIEventListener(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t ConstString; 

  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 28112, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( Scr_GetNumParam(scrContext) )
  {
    ConstString = Scr_GetConstString(scrContext, 0);
    Actor_EventListener_Remove(Entity->s.number, ConstString);
  }
  else
  {
    Actor_EventListener_RemoveEntity(Entity->s.number);
  }
}

/*
==============
GScr_SetHintRequiresHolding
==============
*/
void GScr_SetHintRequiresHolding(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  unsigned __int8 flags; 

  Entity = GetEntity(entref);
  Int = Scr_GetInt(scrContext, 0);
  flags = Entity->hint.flags;
  if ( Int )
    Entity->hint.flags = flags | 4;
  else
    Entity->hint.flags = flags & 0xFB;
}

/*
==============
GScr_SetHintInoperable
==============
*/
void GScr_SetHintInoperable(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  unsigned __int8 flags; 

  Entity = GetEntity(entref);
  Int = Scr_GetInt(scrContext, 0);
  flags = Entity->hint.flags;
  if ( Int )
    Entity->hint.flags = flags | 1;
  else
    Entity->hint.flags = flags & 0xFE;
}

/*
==============
ScrCmd_AIEventListenerEvent
==============
*/
void ScrCmd_AIEventListenerEvent(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v6; 
  scr_string_t ConstString; 
  vec3_t vectorValue; 

  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 28142, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmovss  dword ptr [rsp+68h+vectorValue], xmm0
    vmovss  dword ptr [rsp+68h+vectorValue+4], xmm0
    vmovss  dword ptr [rsp+68h+vectorValue+8], xmm0
  }
  v6 = NULL;
  ConstString = Scr_GetConstString(scrContext, 0);
  if ( Scr_GetNumParam(scrContext) > 1 && Scr_GetType(scrContext, 1u) )
    v6 = GScr_GetEntity(1u);
  if ( Scr_GetNumParam(scrContext) > 2 && Scr_GetType(scrContext, 2u) )
    Scr_GetVector(scrContext, 2u, &vectorValue);
  Actor_EventListener_EventAdd(Entity->s.number, v6, ConstString, &vectorValue);
}

/*
==============
GScr_SetUsePriority
==============
*/
void GScr_SetUsePriority(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  unsigned int Int; 
  int v5; 
  int number; 

  Entity = GetEntity(entref);
  Int = Scr_GetInt(scrContext, 0);
  Entity->hint.priority = Int;
  if ( Int + 10 > 0xB )
  {
    number = Entity->s.number;
    v5 = 1;
    Com_PrintWarning(16, "SetUsePriority script function is passed in a priority value of %d which is not in in the range of [%d, %d] for entity %d\n", Int, 4294967286i64, v5, number);
  }
  if ( Scr_GetNumParam(scrContext) > 1 && Scr_GetInt(scrContext, 1u) )
    Entity->hint.flags |= 0x80u;
  else
    Entity->hint.flags &= ~0x80u;
}

/*
==============
ScrCmd_SetSurfaceType
==============
*/
void ScrCmd_SetSurfaceType(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *String; 
  int v6; 
  const char *v7; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4751, scrContext, "USAGE: self SetSurfaceType( <surface type name> )\n");
  Entity = GetEntity(entref);
  String = Scr_GetString(scrContext, 0);
  v6 = Com_SurfaceTypeFromName(String);
  if ( !BG_IsCharacterEntity(&Entity->s) && !BG_IsCorpseEntity(&Entity->s) && !G_Utils_IsClientOrActorOrAgent(Entity) )
    Scr_Error(COM_ERR_4752, scrContext, "SetSurfaceType is only valid on players, agents, or actors.");
  if ( v6 < 0 )
  {
    v7 = j_va("unable to find surface type '%s'", String);
    Scr_Error(COM_ERR_4753, scrContext, v7);
  }
  Entity->s.surfType = v6;
}

/*
==============
GScr_SetUsePriorityMax
==============
*/
void GScr_SetUsePriorityMax(scrContext_t *scrContext, scr_entref_t entref)
{
  GetEntity(entref)->hint.priority = 0x80000000;
}

/*
==============
ScrCmd_ForceUseHintOn
==============
*/
void ScrCmd_ForceUseHintOn(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  unsigned int NumParam; 
  unsigned int HintStringMessage; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 10185, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  NumParam = Scr_GetNumParam(scrContext);
  HintStringMessage = G_ScrMain_GetHintStringMessage(scrContext, 0, NumParam - 1);
  if ( HintStringMessage )
  {
    v4->client->hintForcedType = HINT_NOICON;
    v4->client->hintForcedString = HintStringMessage;
  }
}

/*
==============
ScrCmd_DontInterpolate
==============
*/
void ScrCmd_DontInterpolate(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gclient_s *client; 

  Entity = GetEntity(entref);
  client = Entity->client;
  if ( client )
    client->ps.eFlags.m_flags[0] ^= 4u;
  else
    Entity->s.lerp.eFlags.m_flags[0] ^= 4u;
}

/*
==============
ScrCmd_SetScriptableDamageOwner
==============
*/
void ScrCmd_SetScriptableDamageOwner(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  const gentity_s *v4; 
  unsigned int scriptableIndex; 

  Entity = GetEntity(entref);
  if ( ScriptableSv_TryGetIndexForEntity(Entity, &scriptableIndex) )
  {
    v4 = GScr_GetEntity(0);
    ScriptableSv_SetDamageOwner(scriptableIndex, v4);
  }
  else
  {
    Scr_Error(COM_ERR_4754, scrContext, "SetScriptableDamageOwner() must be called on a Scriptable");
  }
}

/*
==============
GScr_SetHUDTutorialMessage
==============
*/
void GScr_SetHUDTutorialMessage(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v16; 
  playerState_s *EntityPlayerState; 
  const char *String; 
  const char *v19; 
  unsigned int IndexByName; 
  OmnvarData *Data; 
  char *fmt; 

  entnum = entref.entnum;
  _RDI = GetEntity(entref);
  if ( !G_Utils_IsClientOrAgent(_RDI) )
  {
    targetname = _RDI->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(_RDI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rdi+134h]
      vmovss  xmm2, dword ptr [rdi+130h]
      vmovss  xmm0, dword ptr [rdi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+48h+fmt], xmm0
    }
    v16 = j_va("only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, fmt, v7, v6);
    Scr_Error(COM_ERR_4211, scrContext, v16);
  }
  EntityPlayerState = G_GetEntityPlayerState(_RDI);
  if ( Scr_GetType(scrContext, 0) == VAR_STRING )
    String = Scr_GetString(scrContext, 0);
  else
    String = Scr_GetIString(scrContext, 0);
  v19 = String;
  if ( !GConfigStrings::ms_gConfigStrings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_configstrings.h", 71, ASSERT_TYPE_ASSERT, "( ms_gConfigStrings )", (const char *)&queryFormat, "ms_gConfigStrings") )
    __debugbreak();
  GConfigStrings::ms_gConfigStrings->SetLocalizedString(GConfigStrings::ms_gConfigStrings, v19, &EntityPlayerState->tutorialString);
  IndexByName = BG_Omnvar_GetIndexByName("ui_tutorial_message_show");
  if ( IndexByName == -1 )
    Scr_Error(COM_ERR_4212, scrContext, "SetHUDTutorialMessage can't find omnvar ui_tutorial_message_show - check omnvars.csv");
  Data = G_Omnvar_GetData(IndexByName, _RDI->s.clientNum, NULL);
  Data->current.enabled = 1;
  G_Omnvar_MarkChanged(Data);
}

/*
==============
ScrCmd_ClearScriptableDamageOwner
==============
*/
void ScrCmd_ClearScriptableDamageOwner(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  unsigned int scriptableIndex; 

  Entity = GetEntity(entref);
  if ( ScriptableSv_TryGetIndexForEntity(Entity, &scriptableIndex) )
    ScriptableSv_SetDamageOwner(scriptableIndex, NULL);
  else
    Scr_Error(COM_ERR_4755, scrContext, "SetScriptableDamageOwner() must be called on a Scriptable");
}

/*
==============
ScrCmd_GetLinkedScriptableInstance
==============
*/
void ScrCmd_GetLinkedScriptableInstance(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  unsigned int scriptableIndex; 

  Entity = GetEntity(entref);
  if ( !ScriptableSv_TryGetIndexForEntity(Entity, &scriptableIndex) )
    Scr_Error(COM_ERR_5924, scrContext, "GetScriptableInstance() must be called on an entity linked to a scriptable");
  Scr_AddEntityNum(scrContext, scriptableIndex, ENTITY_CLASS_SCRIPTABLE);
}

/*
==============
GScr_ClearHUDTutorialMessage
==============
*/
void GScr_ClearHUDTutorialMessage(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v16; 
  playerState_s *EntityPlayerState; 
  unsigned int IndexByName; 
  OmnvarData *Data; 
  char *fmt; 

  entnum = entref.entnum;
  _RDI = GetEntity(entref);
  if ( !G_Utils_IsClientOrAgent(_RDI) )
  {
    targetname = _RDI->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(_RDI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rdi+134h]
      vmovss  xmm2, dword ptr [rdi+130h]
      vmovss  xmm0, dword ptr [rdi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+48h+fmt], xmm0
    }
    v16 = j_va("only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, fmt, v7, v6);
    Scr_Error(COM_ERR_4213, scrContext, v16);
  }
  if ( Scr_GetNumParam(scrContext) && Scr_GetInt(scrContext, 0) )
  {
    EntityPlayerState = G_GetEntityPlayerState(_RDI);
    if ( !GConfigStrings::ms_gConfigStrings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_configstrings.h", 71, ASSERT_TYPE_ASSERT, "( ms_gConfigStrings )", (const char *)&queryFormat, "ms_gConfigStrings") )
      __debugbreak();
    GConfigStrings::ms_gConfigStrings->ClearLocalizedString(GConfigStrings::ms_gConfigStrings, &EntityPlayerState->tutorialString);
  }
  else
  {
    IndexByName = BG_Omnvar_GetIndexByName("ui_tutorial_message_show");
    if ( IndexByName == -1 )
      Scr_Error(COM_ERR_4214, scrContext, "ClearHUDTutorialMessage can't find omnvar ui_tutorial_message_show - check omnvars.csv");
    Data = G_Omnvar_GetData(IndexByName, _RDI->s.clientNum, NULL);
    Data->current.enabled = 0;
    G_Omnvar_MarkChanged(Data);
  }
}

/*
==============
ScrCmd_GetScriptableLinkedEntity
==============
*/
void ScrCmd_GetScriptableLinkedEntity(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  unsigned int v4; 
  const gentity_s *Entity; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  v4 = ScriptableIndex_Internal;
  if ( ScriptableIndex_Internal != -1 )
  {
    if ( ScriptableSv_GetInstanceCommonContext(ScriptableIndex_Internal)->linkedObjectType != SCRIPTABLE_LINK_ENTITY )
      Scr_Error(COM_ERR_5925, scrContext, "Scriptable is not linked to an entity");
    Entity = ScriptableSv_GetEntity(v4);
    GScr_AddEntity(Entity);
  }
}

/*
==============
GScr_AddHUDWarningMessage
==============
*/
void GScr_AddHUDWarningMessage(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v16; 
  const char *String; 
  const char *v18; 
  const char *v19; 
  int v20; 
  __int64 returnValueColumn; 

  entnum = entref.entnum;
  _RSI = GetEntity(entref);
  if ( !G_Utils_IsClientOrAgent(_RSI) )
  {
    targetname = _RSI->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(_RSI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rsi+134h]
      vmovss  xmm2, dword ptr [rsi+130h]
      vmovss  xmm0, dword ptr [rsi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  qword ptr [rsp+48h+returnValueColumn], xmm0
    }
    v16 = j_va("only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, returnValueColumn, v7, v6);
    Scr_Error(COM_ERR_4216, scrContext, v16);
  }
  String = Scr_GetString(scrContext, 0);
  v18 = BGScr_TableLookupInternal(scrContext, "hudwarnings.csv", 1, String, 0);
  v19 = v18;
  if ( !v18 || !*v18 )
    Scr_Error(COM_ERR_4217, scrContext, "GScr_AddHUDWarningMessage unable to find given warning key. Please check hudwarnings.csv");
  v20 = atoi(v19);
  SetHUDWarningOmnvars(scrContext, v20, 1);
}

/*
==============
ScrCmd_GetScriptableHasPart
==============
*/
void ScrCmd_GetScriptableHasPart(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  scr_string_t ConstLowercaseString; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal != -1 )
  {
    ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
    if ( ConstLowercaseString )
    {
      if ( ScriptableSv_GetPartScriptedDefFromName(ScriptableIndex_Internal, ConstLowercaseString, 0) )
        Scr_AddBool(scrContext, 1);
      else
        Scr_AddBool(scrContext, 0);
    }
    else
    {
      Scr_Error(COM_ERR_4758, scrContext, "GetScriptableHasPart() missing partName");
    }
  }
}

/*
==============
GScr_ClearHUDWarningMessage
==============
*/
void GScr_ClearHUDWarningMessage(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v16; 
  __int64 v17; 

  entnum = entref.entnum;
  _RDI = GetEntity(entref);
  if ( !G_Utils_IsClientOrAgent(_RDI) )
  {
    targetname = _RDI->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(_RDI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rdi+134h]
      vmovss  xmm2, dword ptr [rdi+130h]
      vmovss  xmm0, dword ptr [rdi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+48h+var_28], xmm0
    }
    v16 = j_va("only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, v17, v7, v6);
    Scr_Error(COM_ERR_4218, scrContext, v16);
  }
  SetHUDWarningOmnvars(scrContext, 0, 0);
}

/*
==============
ScrCmd_GetScriptablePartHasState
==============
*/
void ScrCmd_GetScriptablePartHasState(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  scr_string_t ConstLowercaseString; 
  scr_string_t v5; 
  ScriptablePartDef *PartScriptedDefFromName; 
  int v7; 
  unsigned int out_stateIndex; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal != -1 )
  {
    ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
    if ( ConstLowercaseString )
    {
      v5 = Scr_GetConstLowercaseString(scrContext, 1u);
      if ( v5 )
      {
        PartScriptedDefFromName = ScriptableSv_GetPartScriptedDefFromName(ScriptableIndex_Internal, ConstLowercaseString, 0);
        v7 = PartScriptedDefFromName && ScriptableSv_GetPartScriptedStateFromName(ScriptableIndex_Internal, PartScriptedDefFromName, v5, 0, &out_stateIndex);
        Scr_AddBool(scrContext, v7);
      }
      else
      {
        Scr_Error(COM_ERR_4760, scrContext, "GetScriptablePartHasState() missing stateName");
      }
    }
    else
    {
      Scr_Error(COM_ERR_4759, scrContext, "GetScriptablePartHasState() missing partName");
    }
  }
}

/*
==============
ScrCmd_ForceUseHintOff
==============
*/
void ScrCmd_ForceUseHintOff(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    *(_BYTE *)(MEMORY[0x150] + 24493i64) = 0;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 10379, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
    v4->client->hintForcedType = HINT_NONE;
  }
}

/*
==============
ScrCmd_LaserOn
==============
*/
void ScrCmd_LaserOn(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gclient_s *client; 
  LerpEntityState *p_lerp; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *p_eFlags; 

  Entity = GetEntity(entref);
  client = Entity->client;
  p_lerp = &Entity->s.lerp;
  p_eFlags = &client->ps.eFlags;
  if ( !client )
    p_eFlags = &p_lerp->eFlags;
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(p_eFlags, ACTIVE, 9u);
}

/*
==============
ScrCmd_GetScriptablePartStateHasEvent
==============
*/
void ScrCmd_GetScriptablePartStateHasEvent(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  scr_string_t ConstLowercaseString; 
  scr_string_t v5; 
  scr_string_t v6; 
  scr_string_t v7; 
  Scriptable_EventType ScriptableEventType_Internal; 
  const char *v9; 
  const char *v10; 
  ScriptablePartDef *PartScriptedDefFromName; 
  const char *v12; 
  const char *v13; 
  const ScriptableStateDef *PartScriptedStateFromName; 
  const char *v15; 
  const char *v16; 
  const char *v17; 
  ScriptableEventDef *PartScriptedStateFirstEventOfType; 
  unsigned int out_stateIndex; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal != -1 )
  {
    ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
    if ( ConstLowercaseString )
    {
      v5 = Scr_GetConstLowercaseString(scrContext, 1u);
      if ( v5 )
      {
        v6 = Scr_GetConstLowercaseString(scrContext, 2u);
        ScriptableEventType_Internal = ScrCmd_GetScriptableEventType_Internal(v6);
        if ( ScriptableEventType_Internal == Scriptable_EventType_Count )
        {
          v9 = SL_ConvertToString(v7);
          v10 = j_va("GetScriptablePartStateHasEvent() unsupported event '%s'", v9);
          Scr_Error(COM_ERR_4764, scrContext, v10);
        }
        else
        {
          PartScriptedDefFromName = ScriptableSv_GetPartScriptedDefFromName(ScriptableIndex_Internal, ConstLowercaseString, 0);
          if ( PartScriptedDefFromName )
          {
            PartScriptedStateFromName = ScriptableSv_GetPartScriptedStateFromName(ScriptableIndex_Internal, PartScriptedDefFromName, v5, 0, &out_stateIndex);
            if ( PartScriptedStateFromName )
            {
              PartScriptedStateFirstEventOfType = ScriptableSv_GetPartScriptedStateFirstEventOfType(ScriptableIndex_Internal, PartScriptedStateFromName, ScriptableEventType_Internal);
              Scr_AddBool(scrContext, PartScriptedStateFirstEventOfType != NULL);
            }
            else
            {
              v15 = SL_ConvertToString(ConstLowercaseString);
              v16 = SL_ConvertToString(v5);
              v17 = j_va("GetScriptablePartStateHasEvent() could not find state '%s' in part '%s'", v16, v15);
              Scr_Error(COM_ERR_4766, scrContext, v17);
            }
          }
          else
          {
            v12 = SL_ConvertToString(ConstLowercaseString);
            v13 = j_va("GetScriptablePartStateHasEvent() could not find part '%s'", v12);
            Scr_Error(COM_ERR_4765, scrContext, v13);
          }
        }
      }
      else
      {
        Scr_Error(COM_ERR_4762, scrContext, "GetScriptablePartStateHasEvent() missing stateName");
      }
    }
    else
    {
      Scr_Error(COM_ERR_4761, scrContext, "GetScriptablePartStateHasEvent() missing partName");
    }
  }
}

/*
==============
ScrCmd_LaserOff
==============
*/
void ScrCmd_LaserOff(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gclient_s *client; 
  LerpEntityState *p_lerp; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *p_eFlags; 

  Entity = GetEntity(entref);
  client = Entity->client;
  p_lerp = &Entity->s.lerp;
  p_eFlags = &client->ps.eFlags;
  if ( !client )
    p_eFlags = &p_lerp->eFlags;
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(p_eFlags, ACTIVE, 9u);
}

/*
==============
ScrCmd_LaserAltViewOn
==============
*/
void ScrCmd_LaserAltViewOn(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  char *client; 
  const char *v6; 
  ComErrorCode v7; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 10435, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = (char *)v4->client;
  if ( !client )
  {
    client = (char *)v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v7, scrContext, v6);
      client = NULL;
    }
  }
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal((GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *)(client + 28), ACTIVE, 2u);
}

/*
==============
ScrCmd_LaserAltViewOff
==============
*/
void ScrCmd_LaserAltViewOff(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  char *client; 
  const char *v6; 
  ComErrorCode v7; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 10452, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = (char *)v4->client;
  if ( !client )
  {
    client = (char *)v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v7, scrContext, v6);
      client = NULL;
    }
  }
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal((GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *)(client + 28), ACTIVE, 2u);
}

/*
==============
ScrCmd_GetScriptablePartStateField
==============
*/
void ScrCmd_GetScriptablePartStateField(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  scr_string_t ConstLowercaseString; 
  scr_string_t v5; 
  scr_string_t v6; 
  const char *v7; 
  ComErrorCode v8; 
  ScriptablePartDef *PartScriptedDefFromName; 
  const char *v10; 
  char *v11; 
  const char *v13; 
  const char *v14; 
  Scriptable_StateType type; 
  const char *v17; 
  const char *v18; 
  const char *v19; 
  unsigned int out_stateIndex; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal != -1 )
  {
    ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
    if ( !ConstLowercaseString )
    {
      Scr_Error(COM_ERR_4767, scrContext, "GetScriptablePartStateField() missing partName");
      return;
    }
    v5 = Scr_GetConstLowercaseString(scrContext, 1u);
    if ( !v5 )
    {
      Scr_Error(COM_ERR_4768, scrContext, "GetScriptablePartStateField() missing stateName");
      return;
    }
    v6 = Scr_GetConstLowercaseString(scrContext, 2u);
    if ( !v6 )
    {
      v7 = "GetScriptablePartStateField() missing fieldName";
      v8 = COM_ERR_4769;
LABEL_29:
      Scr_Error(v8, scrContext, v7);
      return;
    }
    PartScriptedDefFromName = ScriptableSv_GetPartScriptedDefFromName(ScriptableIndex_Internal, ConstLowercaseString, 1);
    if ( !PartScriptedDefFromName )
    {
      v10 = SL_ConvertToString(ConstLowercaseString);
      v11 = j_va("GetScriptablePartStateField() could not find part '%s'", v10);
      v8 = COM_ERR_4770;
LABEL_28:
      v7 = v11;
      goto LABEL_29;
    }
    _RAX = ScriptableSv_GetPartScriptedStateFromName(ScriptableIndex_Internal, PartScriptedDefFromName, v5, 1, &out_stateIndex);
    if ( !_RAX )
    {
      v13 = SL_ConvertToString(ConstLowercaseString);
      v14 = SL_ConvertToString(v5);
      v11 = j_va("GetScriptablePartStateField() could not find state '%s' in part '%s'", v14, v13);
      v8 = COM_ERR_4771;
      goto LABEL_28;
    }
    if ( v6 == scr_const.type )
    {
      type = _RAX->type;
      if ( type == Scriptable_StateType_Health )
      {
        Scr_AddConstString(scrContext, scr_const.health);
      }
      else if ( type == Scriptable_StateType_Usable )
      {
        Scr_AddConstString(scrContext, scr_const.useable);
      }
      else
      {
        if ( type != Scriptable_StateType_Scripted && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 28627, ASSERT_TYPE_ASSERT, "( stateDef->type == Scriptable_StateType::Scriptable_StateType_Scripted )", (const char *)&queryFormat, "stateDef->type == Scriptable_StateType::Scriptable_StateType_Scripted") )
          __debugbreak();
        Scr_AddConstString(scrContext, scr_const.scriptable);
      }
    }
    else if ( v6 == scr_const.maxhealth )
    {
      if ( _RAX->type == Scriptable_StateType_Health )
        Scr_AddInt(scrContext, _RAX->data.health.health);
    }
    else
    {
      if ( v6 != scr_const.radius )
      {
        v17 = SL_ConvertToString(ConstLowercaseString);
        v18 = SL_ConvertToString(v5);
        v19 = SL_ConvertToString(v6);
        v11 = j_va("GetScriptablePartStateField() unsupported field '%s' for state '%s' in part '%s'", v19, v18, v17);
        v8 = COM_ERR_4772;
        goto LABEL_28;
      }
      if ( _RAX->type == Scriptable_StateType_Usable )
      {
        __asm { vmovss  xmm1, dword ptr [rax+3Ch]; value }
        Scr_AddFloat(scrContext, *(float *)&_XMM1);
      }
    }
  }
}

/*
==============
GScr_SetImpactFx
==============
*/
void GScr_SetImpactFx(scrContext_t *scrContext, scr_entref_t entref)
{
  const char *String; 
  gentity_s *Entity; 
  const char *v6; 
  unsigned int clientNum; 
  const char *v8; 
  SvClient *CommonClient; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4219, scrContext, "Invalid parameters. Usage: player SetImpactFx( <tableName> ) \n");
  String = Scr_GetString(scrContext, 0);
  Entity = GetEntity(entref);
  if ( !Entity->client )
    Scr_Error(COM_ERR_4220, scrContext, "Invalid ent, ent needs to be a player.\n");
  v6 = j_va("%c %s", 66i64, String);
  clientNum = Entity->s.clientNum;
  v8 = v6;
  if ( clientNum == -1 )
  {
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v6);
  }
  else
  {
    CommonClient = SvClient::GetCommonClient(clientNum);
    CommonClient->SendServerCommand(CommonClient, SV_CMD_RELIABLE, v8);
  }
}

/*
==============
GScr_IsNightVisionOn
==============
*/
void GScr_IsNightVisionOn(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const playerState_s *p_ps; 
  const char *v6; 
  ComErrorCode v7; 
  bool IsUsingNightVision; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 10499, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  p_ps = &v4->client->ps;
  if ( !p_ps )
  {
    p_ps = &v4->agent->playerState;
    if ( !p_ps )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v7, scrContext, v6);
      p_ps = NULL;
    }
  }
  IsUsingNightVision = BG_IsUsingNightVision(p_ps);
  Scr_AddBool(scrContext, IsUsingNightVision);
}

/*
==============
ScrCmd_GetScriptablePartStateEventField
==============
*/
void ScrCmd_GetScriptablePartStateEventField(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  scr_string_t ConstLowercaseString; 
  scr_string_t v6; 
  scr_string_t v7; 
  scr_string_t v8; 
  ScriptablePartDef *PartScriptedDefFromName; 
  const char *v10; 
  const char *v11; 
  const char *v12; 
  const char *v13; 
  const char *v14; 
  Scriptable_EventType ScriptableEventType_Internal; 
  const ScriptableStateDef *v16; 
  scr_string_t v17; 
  Scriptable_EventType v18; 
  const char *v19; 
  const char *v20; 
  const char *v22; 
  const char *v23; 
  const char *v24; 
  const char *v25; 
  const char *v39; 
  const char *v40; 
  const char *v41; 
  const char *v42; 
  const char *v43; 
  unsigned int out_stateIndex; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal != -1 )
  {
    ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
    if ( ConstLowercaseString )
    {
      v6 = Scr_GetConstLowercaseString(scrContext, 1u);
      if ( v6 )
      {
        v7 = Scr_GetConstLowercaseString(scrContext, 2u);
        if ( v7 )
        {
          v8 = Scr_GetConstLowercaseString(scrContext, 3u);
          if ( v8 )
          {
            PartScriptedDefFromName = ScriptableSv_GetPartScriptedDefFromName(ScriptableIndex_Internal, ConstLowercaseString, 1);
            if ( PartScriptedDefFromName )
            {
              if ( ScriptableSv_GetPartScriptedStateFromName(ScriptableIndex_Internal, PartScriptedDefFromName, v6, 1, &out_stateIndex) )
              {
                ScriptableEventType_Internal = ScrCmd_GetScriptableEventType_Internal(v7);
                v18 = ScriptableEventType_Internal;
                if ( ScriptableEventType_Internal == Scriptable_EventType_Count )
                {
                  v19 = SL_ConvertToString(v17);
                  v20 = j_va("GetScriptablePartStateEventField() unsupported event '%s'", v19);
                  Scr_Error(COM_ERR_4779, scrContext, v20);
                }
                else
                {
                  _RBX = ScriptableSv_GetPartScriptedStateFirstEventOfType(ScriptableIndex_Internal, v16, ScriptableEventType_Internal);
                  if ( _RBX )
                  {
                    switch ( v18 )
                    {
                      case Scriptable_EventType_Wait:
                        if ( v8 != scr_const.duration )
                          goto $LN45_11;
                        __asm
                        {
                          vmovss  xmm0, dword ptr [rbx+24h]
                          vmulss  xmm1, xmm0, cs:__real@447a0000
                          vcvttss2si edx, xmm1; value
                        }
                        Scr_AddInt(scrContext, _EDX);
                        return;
                      case Scriptable_EventType_Script:
                      case Scriptable_EventType_ScriptDamage:
                        if ( v8 != scr_const.notifyname )
                          goto $LN45_11;
                        Scr_AddConstString(scrContext, _RBX->data.script.scrNotification);
                        return;
                      case Scriptable_EventType_Model:
                        if ( v8 != scr_const.radius )
                          goto $LN45_11;
                        if ( _RBX->data.anonymous.buffer[0] != 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 28766, ASSERT_TYPE_ASSERT, "( eventDef->data.model.dataType == SCRIPTABLE_DATA_TYPE_XMODEL )", (const char *)&queryFormat, "eventDef->data.model.dataType == SCRIPTABLE_DATA_TYPE_XMODEL") )
                          __debugbreak();
                        if ( !_RBX->data.disablePhysicsSubShape.mutableShapeHash && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 28767, ASSERT_TYPE_ASSERT, "( eventDef->data.model.data.model )", (const char *)&queryFormat, "eventDef->data.model.data.model") )
                          __debugbreak();
                        _RAX = _RBX->data.stateChange.part;
                        __asm { vmovss  xmm1, dword ptr [rax+28h]; value }
                        Scr_AddFloat(scrContext, *(float *)&_XMM1);
                        return;
                      case Scriptable_EventType_Collision:
                        goto $LN45_11;
                      case Scriptable_EventType_Animation:
                        if ( v8 != scr_const.duration )
                          goto $LN45_11;
                        if ( !_RBX->data.script.notification && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 28782, ASSERT_TYPE_ASSERT, "( eventDef->data.animation.animation )", (const char *)&queryFormat, "eventDef->data.animation.animation") )
                          __debugbreak();
                        __asm
                        {
                          vxorps  xmm0, xmm0, xmm0
                          vcvtsi2ss xmm0, xmm0, eax
                          vmulss  xmm1, xmm0, dword ptr [rcx+64h]
                          vmulss  xmm2, xmm1, cs:__real@447a0000
                          vcvttss2si edx, xmm2; value
                        }
                        Scr_AddInt(scrContext, _EDX);
                        break;
                      case Scriptable_EventType_Move:
                        if ( v8 == scr_const.duration )
                        {
                          __asm
                          {
                            vmovss  xmm0, dword ptr [rbx+38h]
                            vmulss  xmm1, xmm0, cs:__real@447a0000
                            vcvttss2si edx, xmm1; value
                          }
                          Scr_AddInt(scrContext, _EDX);
                        }
                        else if ( v8 == scr_const.angles_offset )
                        {
                          Scr_AddVector(scrContext, &_RBX->data.animation.startTimeMin);
                        }
                        else if ( v8 == scr_const.origin_offset )
                        {
                          Scr_AddVector(scrContext, &_RBX->data.wait.delayMin);
                        }
                        else
                        {
$LN45_11:
                          v39 = SL_ConvertToString(ConstLowercaseString);
                          v40 = SL_ConvertToString(v6);
                          v41 = SL_ConvertToString(v7);
                          v42 = SL_ConvertToString(v8);
                          v43 = j_va("GetScriptablePartStateEventField() unsupported field '%s' for event '%s' in state '%s' in part '%s'", v42, v41, v40, v39);
                          Scr_Error(COM_ERR_4781, scrContext, v43);
                        }
                        break;
                      default:
                        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 28818, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "GetScriptablePartStateEventField() eventType unhandled in switch statement") )
                          __debugbreak();
                        return;
                    }
                  }
                  else
                  {
                    v22 = SL_ConvertToString(ConstLowercaseString);
                    v23 = SL_ConvertToString(v6);
                    v24 = SL_ConvertToString(v7);
                    v25 = j_va("GetScriptablePartStateEventField() could not find event '%s' in state '%s' in part '%s'", v24, v23, v22);
                    Scr_Error(COM_ERR_4780, scrContext, v25);
                  }
                }
              }
              else
              {
                v12 = SL_ConvertToString(ConstLowercaseString);
                v13 = SL_ConvertToString(v6);
                v14 = j_va("GetScriptablePartStateEventField() could not find state '%s' in part '%s'", v13, v12);
                Scr_Error(COM_ERR_4778, scrContext, v14);
              }
            }
            else
            {
              v10 = SL_ConvertToString(ConstLowercaseString);
              v11 = j_va("GetScriptablePartStateEventField() could not find part '%s'", v10);
              Scr_Error(COM_ERR_4777, scrContext, v11);
            }
          }
          else
          {
            Scr_Error(COM_ERR_4776, scrContext, "GetScriptablePartStateEventField() missing fieldName");
          }
        }
        else
        {
          Scr_Error(COM_ERR_4775, scrContext, "GetScriptablePartStateEventField() missing eventName");
        }
      }
      else
      {
        Scr_Error(COM_ERR_4774, scrContext, "GetScriptablePartStateEventField() missing stateName");
      }
    }
    else
    {
      Scr_Error(COM_ERR_4773, scrContext, "GetScriptablePartStateEventField() missing partName");
    }
  }
}

/*
==============
ScrCmd_NightVisionViewOff
==============
*/
void ScrCmd_NightVisionViewOff(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v5; 
  const char *v7; 
  ComErrorCode v8; 
  unsigned int clientNum; 
  const char *v11; 
  const char *v12; 
  SvClient *CommonClient; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v7 = "not an entity";
    v8 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 10526, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v5 = &g_entities[entnum];
  _RDI = &v5->client->ps;
  if ( !_RDI )
  {
    _RDI = &v5->agent->playerState;
    if ( !_RDI )
    {
      v7 = j_va("entity %i is not a player or agent", entnum);
      v8 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v8, scrContext, v7);
      _RDI = NULL;
    }
  }
  if ( Scr_GetNumParam(scrContext) == 1 && Scr_GetInt(scrContext, 0) && BG_IsUsingNightVision(_RDI) )
  {
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcomiss xmm0, dword ptr [rdi+730h]
    }
    GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::ClearFlagInternal(&_RDI->weapCommon.weapFlags, ACTIVE, 7u);
  }
  else
  {
    clientNum = _RDI->clientNum;
    v11 = j_va("%c %d", 69i64, 0i64);
    v12 = v11;
    if ( clientNum == -1 )
    {
      SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v11);
    }
    else
    {
      CommonClient = SvClient::GetCommonClient(clientNum);
      CommonClient->SendServerCommand(CommonClient, SV_CMD_RELIABLE, v12);
    }
  }
}

/*
==============
ScrCmd_NightVisionViewOn
==============
*/
void ScrCmd_NightVisionViewOn(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v5; 
  const char *v7; 
  ComErrorCode v8; 
  unsigned int clientNum; 
  const char *v11; 
  const char *v12; 
  SvClient *CommonClient; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v7 = "not an entity";
    v8 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 10566, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v5 = &g_entities[entnum];
  _RDI = &v5->client->ps;
  if ( !_RDI )
  {
    _RDI = &v5->agent->playerState;
    if ( !_RDI )
    {
      v7 = j_va("entity %i is not a player or agent", entnum);
      v8 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v8, scrContext, v7);
      _RDI = NULL;
    }
  }
  if ( Scr_GetNumParam(scrContext) == 1 && Scr_GetInt(scrContext, 0) && !BG_IsUsingNightVision(_RDI) )
  {
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcomiss xmm0, dword ptr [rdi+730h]
    }
    GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::SetFlagInternal(&_RDI->weapCommon.weapFlags, ACTIVE, 7u);
  }
  else
  {
    clientNum = _RDI->clientNum;
    v11 = j_va("%c %d", 69i64, 1i64);
    v12 = v11;
    if ( clientNum == -1 )
    {
      SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v11);
    }
    else
    {
      CommonClient = SvClient::GetCommonClient(clientNum);
      CommonClient->SendServerCommand(CommonClient, SV_CMD_RELIABLE, v12);
    }
  }
}

/*
==============
ScrCmd_ActivateNightVisionBlind
==============
*/
void ScrCmd_ActivateNightVisionBlind(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const playerState_s *p_ps; 
  const char *v6; 
  unsigned int clientNum; 
  const char *v8; 
  SvClient *CommonClient; 
  const char *v10; 
  ComErrorCode v11; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v10 = "not an entity";
    v11 = COM_ERR_3682;
    goto LABEL_13;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 10605, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  p_ps = &v4->client->ps;
  if ( !p_ps )
  {
    p_ps = &v4->agent->playerState;
    if ( !p_ps )
    {
      v10 = j_va("entity %i is not a player or agent", entnum);
      v11 = COM_ERR_3679;
LABEL_13:
      Scr_ObjectError(v11, scrContext, v10);
      Scr_Error(COM_ERR_6123, scrContext, "ActivateNightVisionBlind: This method must be called on players.\n");
      return;
    }
  }
  if ( !BG_IsAgent(p_ps) )
  {
    v6 = j_va("%c", 33i64);
    clientNum = p_ps->clientNum;
    v8 = v6;
    if ( clientNum == -1 )
    {
      SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v6);
    }
    else
    {
      CommonClient = SvClient::GetCommonClient(clientNum);
      CommonClient->SendServerCommand(CommonClient, SV_CMD_RELIABLE, v8);
    }
  }
}

/*
==============
ScrCmd_SetNightVisionBlindWeight
==============
*/
void ScrCmd_SetNightVisionBlindWeight(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v5; 
  const playerState_s *p_ps; 
  ComErrorCode v7; 
  const char *v8; 
  const char *v11; 
  unsigned int clientNum; 
  const char *v13; 
  SvClient *CommonClient; 
  const char *v15; 
  ComErrorCode v16; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v15 = "not an entity";
    v16 = COM_ERR_3682;
    goto LABEL_16;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 10636, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v5 = &g_entities[entnum];
  p_ps = &v5->client->ps;
  if ( !p_ps )
  {
    p_ps = &v5->agent->playerState;
    if ( !p_ps )
    {
      v15 = j_va("entity %i is not a player or agent", entnum);
      v16 = COM_ERR_3679;
LABEL_16:
      Scr_ObjectError(v16, scrContext, v15);
      v7 = COM_ERR_6148;
      goto LABEL_17;
    }
  }
  if ( BG_IsAgent(p_ps) )
  {
    v7 = COM_ERR_6291;
LABEL_17:
    v8 = "SetNightVisionBlindWeight: This method must be called on players.\n";
    goto LABEL_18;
  }
  if ( Scr_GetNumParam(scrContext) != 1 )
  {
    v8 = "usage: level.player SetNightVisionBlindWeight( <weight> )\n";
    v7 = COM_ERR_6149;
LABEL_18:
    Scr_Error(v7, scrContext, v8);
    return;
  }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm
  {
    vcvtss2sd xmm2, xmm0, xmm0
    vmovq   r8, xmm2
  }
  v11 = j_va("%c %f", 36i64, _R8);
  clientNum = p_ps->clientNum;
  v13 = v11;
  if ( clientNum == -1 )
  {
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v11);
  }
  else
  {
    CommonClient = SvClient::GetCommonClient(clientNum);
    CommonClient->SendServerCommand(CommonClient, SV_CMD_RELIABLE, v13);
  }
}

/*
==============
ScrCmd_SetScriptablePartState
==============
*/
void ScrCmd_SetScriptablePartState(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  scr_string_t ConstLowercaseString; 
  scr_string_t v5; 
  scr_string_t v6; 
  const char *v7; 
  ComErrorCode v8; 
  const char *v9; 
  const char *v10; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal != -1 )
  {
    ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
    if ( !ConstLowercaseString )
    {
      Scr_Error(COM_ERR_4782, scrContext, "SetScriptablePartState() missing partName");
      return;
    }
    v5 = Scr_GetConstLowercaseString(scrContext, 1u);
    v6 = v5;
    if ( !v5 )
    {
      v7 = "SetScriptablePartState() missing stateName";
      v8 = COM_ERR_4783;
LABEL_10:
      Scr_Error(v8, scrContext, v7);
      return;
    }
    if ( !ScriptableSv_SetPartScriptedState(ScriptableIndex_Internal, ConstLowercaseString, v5) && (Scr_GetNumParam(scrContext) < 3 || Scr_GetInt(scrContext, 2u)) )
    {
      v9 = SL_ConvertToString(v6);
      v10 = SL_ConvertToString(ConstLowercaseString);
      v7 = j_va("SetScriptablePartState() could not set part '%s' to state '%s'", v10, v9);
      v8 = COM_ERR_4784;
      goto LABEL_10;
    }
  }
}

/*
==============
ScrCmd_ThermalVisionOn
==============
*/
void ScrCmd_ThermalVisionOn(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  char *client; 
  const char *v6; 
  ComErrorCode v7; 
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *v8; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 10677, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = (char *)v4->client;
  if ( !client )
  {
    client = (char *)v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v7, scrContext, v6);
      client = NULL;
    }
  }
  v8 = (GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *)(client + 28);
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal((GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *)(client + 28), ACTIVE, 3u);
  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    if ( Scr_GetInt(scrContext, 0) )
      GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal(v8, GameModeFlagValues::ms_mpValue, 0x28u);
  }
}

/*
==============
ScrCmd_SetScriptablePartZeroState_Hack
==============
*/
void ScrCmd_SetScriptablePartZeroState_Hack(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  scr_string_t ConstLowercaseString; 
  const ScriptableDef *def; 
  const char *v6; 
  ComErrorCode v7; 
  ScriptablePartDef *parts; 
  const char *v9; 
  ScriptableEventParams outParams; 
  unsigned int newState; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal != -1 )
  {
    ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
    if ( !ConstLowercaseString )
    {
      Scr_Error(COM_ERR_4785, scrContext, "SetScriptablePartZeroState_Hack() missing stateName");
      return;
    }
    def = ScriptableSv_GetInstanceCommonContext(ScriptableIndex_Internal)->def;
    if ( def )
    {
      parts = def->parts;
      if ( parts )
      {
        if ( ScriptableSv_GetPartScriptedStateFromName(ScriptableIndex_Internal, parts, ConstLowercaseString, 1, &newState) )
        {
          ScriptableSv_InitEventParams(&outParams, ScriptableIndex_Internal, parts);
          ScriptableBg_ChangePartState(&outParams, newState, 1);
          if ( ScriptableSv_SetPartScriptedState(ScriptableIndex_Internal, (const scr_string_t)parts->scrName, ConstLowercaseString) )
            return;
          v9 = SL_ConvertToString(ConstLowercaseString);
          v6 = j_va("SetScriptablePartZeroState_Hack() could not set part 0 to state '%s' for scriptable instance %d", v9, ScriptableIndex_Internal);
          v7 = COM_ERR_4790;
        }
        else
        {
          v6 = j_va("SetScriptablePartZeroState_Hack() could not get state def for part 0 of scriptable instance %d", ScriptableIndex_Internal);
          v7 = COM_ERR_4789;
        }
      }
      else
      {
        v6 = j_va("SetScriptablePartZeroState_Hack() could not get part def 0 for scriptable instance %d", ScriptableIndex_Internal);
        v7 = COM_ERR_4788;
      }
    }
    else
    {
      v6 = j_va("SetScriptablePartZeroState_Hack() could not get def for scriptable instance %d", ScriptableIndex_Internal);
      v7 = COM_ERR_4787;
    }
    Scr_Error(v7, scrContext, v6);
  }
}

/*
==============
ScrCmd_ThermalVisionOnShadowOff
==============
*/
void ScrCmd_ThermalVisionOnShadowOff(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  char *client; 
  const char *v6; 
  ComErrorCode v7; 
  gentity_s *v8; 
  char *agent; 
  const char *v10; 
  ComErrorCode v11; 
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *v12; 
  EntityClass entclass; 

  entclass = entref.entclass;
  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 10697, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = (char *)v4->client;
  if ( !client )
  {
    client = (char *)v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v7, scrContext, v6);
      client = NULL;
    }
  }
  if ( entclass )
  {
    v10 = "not an entity";
    v11 = COM_ERR_3682;
    goto LABEL_18;
  }
  if ( entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 10677, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v8 = &g_entities[entnum];
  agent = (char *)v8->client;
  if ( !agent )
  {
    agent = (char *)v8->agent;
    if ( !agent )
    {
      v10 = j_va("entity %i is not a player or agent", entnum);
      v11 = COM_ERR_3679;
LABEL_18:
      Scr_ObjectError(v11, scrContext, v10);
      agent = NULL;
    }
  }
  v12 = (GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *)(agent + 28);
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal((GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *)(agent + 28), ACTIVE, 3u);
  if ( Scr_GetNumParam(scrContext) == 1 && Scr_GetInt(scrContext, 0) )
    GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal(v12, GameModeFlagValues::ms_mpValue, 0x28u);
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal((GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *)(client + 28), ACTIVE, 0xCu);
}

/*
==============
ScrCmd_GetScriptablePartState
==============
*/
void ScrCmd_GetScriptablePartState(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  scr_string_t ConstLowercaseString; 
  bool v5; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  const char *v9; 
  scr_string_t out_stateName; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal != -1 )
  {
    ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
    if ( ConstLowercaseString )
    {
      v5 = 0;
      if ( Scr_GetNumParam(scrContext) >= 2 )
        v5 = Scr_GetInt(scrContext, 1u) != 0;
      if ( ScriptableSv_GetPartScriptedState(ScriptableIndex_Internal, ConstLowercaseString, &out_stateName) )
      {
        if ( out_stateName )
        {
          Scr_AddConstString(scrContext, out_stateName);
        }
        else if ( !v5 )
        {
          v8 = SL_ConvertToString(ConstLowercaseString);
          v9 = j_va("GetScriptablePartState() got part %s, but it had no Script Id set - check the scriptable", v8);
          Scr_Error(COM_ERR_4793, scrContext, v9);
        }
      }
      else if ( !v5 )
      {
        v6 = SL_ConvertToString(ConstLowercaseString);
        v7 = j_va("GetScriptablePartState() could not get the state name for part %s", v6);
        Scr_Error(COM_ERR_4792, scrContext, v7);
      }
    }
    else
    {
      Scr_Error(COM_ERR_4791, scrContext, "GetScriptablePartState() missing partName");
    }
  }
}

/*
==============
ScrCmd_ThermalVisionOff
==============
*/
void ScrCmd_ThermalVisionOff(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  char *client; 
  const char *v6; 
  ComErrorCode v7; 
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *v8; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 10715, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = (char *)v4->client;
  if ( !client )
  {
    client = (char *)v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v7, scrContext, v6);
      client = NULL;
    }
  }
  v8 = (GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *)(client + 28);
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal((GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *)(client + 28), ACTIVE, 3u);
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal(v8, GameModeFlagValues::ms_mpValue, 0x28u);
}

/*
==============
ScrCmd_ThermalDrawEnable
==============
*/
void ScrCmd_ThermalDrawEnable(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(&Entity->s.lerp.eFlags, ACTIVE, 0xEu);
}

/*
==============
ScrCmd_GetScriptablePartCount
==============
*/
void ScrCmd_GetScriptablePartCount(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  ScriptableInstanceContext *InstanceCommonContext; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal != -1 )
  {
    InstanceCommonContext = ScriptableSv_GetInstanceCommonContext(ScriptableIndex_Internal);
    if ( InstanceCommonContext->def )
      Scr_AddInt(scrContext, InstanceCommonContext->def->partCount);
  }
}

/*
==============
ScrCmd_ThermalDrawDisable
==============
*/
void ScrCmd_ThermalDrawDisable(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(&Entity->s.lerp.eFlags, ACTIVE, 0xEu);
}

/*
==============
ScrCmd_GetScriptablePartNameAtIndex
==============
*/
void ScrCmd_GetScriptablePartNameAtIndex(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  __int64 Int; 
  const ScriptableDef *def; 
  scr_string_t scrName; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal != -1 )
  {
    Int = (unsigned int)Scr_GetInt(scrContext, 0);
    def = ScriptableSv_GetInstanceCommonContext(ScriptableIndex_Internal)->def;
    if ( def )
    {
      if ( (unsigned int)Int < def->partCount )
      {
        scrName = def->parts[Int].scrName;
        if ( scrName )
          Scr_AddConstString(scrContext, scrName);
      }
    }
  }
}

/*
==============
ScrCmd_ScriptMoverPlane
==============
*/
void ScrCmd_ScriptMoverPlane(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( Entity->s.eType == ET_SCRIPTMOVER )
    Entity->s.lerp.u.anonymous.data[2] |= 0x20u;
  else
    Scr_Error(COM_ERR_4221, scrContext, "ScriptMoverOutline Must be called on a script mover");
}

/*
==============
ScrCmd_ScriptMoverOutline
==============
*/
void ScrCmd_ScriptMoverOutline(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( Entity->s.eType == ET_SCRIPTMOVER )
    Entity->s.lerp.u.anonymous.data[2] |= 8u;
  else
    Scr_Error(COM_ERR_4222, scrContext, "ScriptMoverOutline Must be called on a script mover");
}

/*
==============
ScrCmd_ScriptMoverClearOutline
==============
*/
void ScrCmd_ScriptMoverClearOutline(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( Entity->s.eType == ET_SCRIPTMOVER )
    Entity->s.lerp.u.anonymous.data[2] &= ~8u;
  else
    Scr_Error(COM_ERR_4223, scrContext, "ScriptMoverClearOutline Must be called on a script mover");
}

/*
==============
ScrCmd_ScriptMoverDistanceFade
==============
*/
void ScrCmd_ScriptMoverDistanceFade(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( Entity->s.eType == ET_SCRIPTMOVER )
  {
    if ( GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&Entity->s.lerp.eFlags, ACTIVE, 1u) )
      Scr_Error(COM_ERR_5919, scrContext, "ScriptMoverDistanceFade() cannot be called on scriptmovers that are brushmodels");
    else
      v4->s.lerp.u.anonymous.data[2] |= 0x80u;
  }
  else
  {
    Scr_Error(COM_ERR_5918, scrContext, "ScriptMoverDistanceFade() must be called on a script mover");
  }
}

/*
==============
ScrCmd_EnableScriptablePartPlayerUse
==============
*/
void ScrCmd_EnableScriptablePartPlayerUse(scrContext_t *scrContext, scr_entref_t entref)
{
  GScr_SetScriptablePartUsability(scrContext, entref, 1);
}

/*
==============
ScrCmd_ScriptMoverClearDistanceFade
==============
*/
void ScrCmd_ScriptMoverClearDistanceFade(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( Entity->s.eType == ET_SCRIPTMOVER )
    Entity->s.lerp.u.anonymous.data[2] &= ~0x80u;
  else
    Scr_Error(COM_ERR_5749, scrContext, "ScriptMoverClearDistanceFade() must be called on a script mover");
}

/*
==============
ScrCmd_DisableScriptablePartPlayerUse
==============
*/
void ScrCmd_DisableScriptablePartPlayerUse(scrContext_t *scrContext, scr_entref_t entref)
{
  GScr_SetScriptablePartUsability(scrContext, entref, 0);
}

/*
==============
ScrCmd_ScriptMoverThermal
==============
*/
void ScrCmd_ScriptMoverThermal(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( Entity->s.eType == ET_SCRIPTMOVER )
    Entity->s.lerp.u.anonymous.data[2] |= 0x10u;
  else
    Scr_Error(COM_ERR_4224, scrContext, "ScriptMoverThermal Must be called on a script mover");
}

/*
==============
ScrCmd_ScriptMoverClearThermal
==============
*/
void ScrCmd_ScriptMoverClearThermal(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( Entity->s.eType == ET_SCRIPTMOVER )
    Entity->s.lerp.u.anonymous.data[2] &= ~0x10u;
  else
    Scr_Error(COM_ERR_4225, scrContext, "ScriptMoverClearThermal Must be called on a script mover");
}

/*
==============
ScrCmd_MissileThermal
==============
*/
void ScrCmd_MissileThermal(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( Entity->s.eType == ET_MISSILE )
    Entity->s.lerp.u.anonymous.data[4] |= 0x40u;
  else
    Scr_Error(COM_ERR_4226, scrContext, "MissileThermal Must be called on a missile");
}

/*
==============
ScrCmd_MissileHideTrail
==============
*/
void ScrCmd_MissileHideTrail(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( Entity->s.eType == ET_MISSILE )
    Entity->s.lerp.u.anonymous.data[4] |= 0x200u;
  else
    Scr_Error(COM_ERR_4227, scrContext, "MissileHideTrail Must be called on a missile");
}

/*
==============
ScrCmd_MissileOutline
==============
*/
void ScrCmd_MissileOutline(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( Entity->s.eType == ET_MISSILE )
    Entity->s.lerp.u.anonymous.data[4] |= 0x20u;
  else
    Scr_Error(COM_ERR_4228, scrContext, "MissileOutline Must be called on a missile");
}

/*
==============
ScrCmd_EnableScriptablePlayerUse
==============
*/
void ScrCmd_EnableScriptablePlayerUse(scrContext_t *scrContext, scr_entref_t entref)
{
  GScr_SetScriptableUsability(scrContext, entref, 1);
}

/*
==============
ScrCmd_DisableScriptablePlayerUse
==============
*/
void ScrCmd_DisableScriptablePlayerUse(scrContext_t *scrContext, scr_entref_t entref)
{
  GScr_SetScriptableUsability(scrContext, entref, 0);
}

/*
==============
ScrCmd_HudOutlineEnableForClient
==============
*/
void ScrCmd_HudOutlineEnableForClient(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v5; 
  gentity_s *v6; 
  scr_string_t ConstString; 
  const char *v8; 
  const char *v9; 
  scrContext_t *v10; 
  ComErrorCode v11; 
  unsigned int number; 
  int v15; 
  unsigned int outIndex[3]; 
  ClientBits v17; 
  __int128 v18; 
  __int64 v19; 
  unsigned int v20; 

  v15 = 0;
  if ( Scr_GetNumParam(scrContext) > 2 )
  {
    Scr_Error(COM_ERR_4229, scrContext, "usage: HudOutlineEnableForClient( <client>, <hudOutline> );");
    return;
  }
  Entity = GetEntity(entref);
  v5 = GScr_GetEntity(0);
  v6 = v5;
  if ( !v5 || !v5->client )
  {
    Scr_ParamError(COM_ERR_4230, scrContext, 0, "Invalid client entity.");
    return;
  }
  if ( (unsigned int)v5->s.number >= level.maxclients && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 11059, ASSERT_TYPE_ASSERT, "(unsigned)( clientEnt->s.number ) < (unsigned)( level.maxclients )", "clientEnt->s.number doesn't index level.maxclients\n\t%i not in [0, %i)", v5->s.number, level.maxclients) )
    __debugbreak();
  ConstString = Scr_GetConstString(scrContext, 1u);
  if ( !ConstString && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 11063, ASSERT_TYPE_ASSERT, "(hudOutlineScrStr != ( static_cast< scr_string_t >( 0 ) ))", (const char *)&queryFormat, "hudOutlineScrStr != NULL_SCR_STRING") )
    __debugbreak();
  v8 = SL_ConvertToString(ConstString);
  if ( !v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 11066, ASSERT_TYPE_ASSERT, "(hudOutlineName)", (const char *)&queryFormat, "hudOutlineName") )
    __debugbreak();
  outIndex[0] = 0;
  if ( !BG_HudOutline_GetDefIndex(v8, outIndex) )
  {
    v9 = j_va("Hud Outline name not found (%s)! Make sure you add your Hud Outline asset to your level csv file!\n", v8);
    v10 = scrContext;
    v11 = COM_ERR_5931;
LABEL_16:
    Scr_Error(v11, v10, v9);
    return;
  }
  v18 = 0ui64;
  v19 = 0i64;
  v15 ^= ((unsigned __int8)v15 ^ LOBYTE(outIndex[0])) & 0x3F;
  number = v6->s.number;
  v20 = 0;
  if ( number >= 0xE0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 263, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", number, 224) )
    __debugbreak();
  *((_DWORD *)&v18 + ((unsigned __int64)number >> 5)) |= 0x80000000 >> (number & 0x1F);
  __asm
  {
    vmovups xmm0, [rsp+0D8h+var_58]
    vmovsd  xmm1, [rsp+0D8h+var_48]
    vmovups [rsp+0D8h+var_78], xmm0
    vmovsd  [rsp+0D8h+var_68], xmm1
  }
  v17.array[6] = v20;
  if ( !G_HudOutline_EnableForClientMask(Entity, &v17, (const outline_client_data_t *)&v15) )
  {
    v9 = "HudOutlineEnableForClient() could not be applied because there are currently too many hud outline settings. Can we reduce color and depth test variations?";
    v10 = scrContext;
    v11 = COM_ERR_156;
    goto LABEL_16;
  }
}

/*
==============
ScrCmd_SetScriptableUseLargerBounds
==============
*/
void ScrCmd_SetScriptableUseLargerBounds(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  __int64 v4; 
  ScriptableInstanceServerContext *v5; 
  __int64 v6; 
  int v7; 
  __int64 v8; 
  unsigned int serverInstanceCount; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  v4 = ScriptableIndex_Internal;
  if ( ScriptableIndex_Internal != -1 )
  {
    ScriptableCommon_AssertCountsInitialized();
    if ( (unsigned int)v4 >= g_scriptableWorldCounts.serverInstanceCount )
    {
      ScriptableCommon_AssertCountsInitialized();
      serverInstanceCount = g_scriptableWorldCounts.serverInstanceCount;
      v7 = v4;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 29213, ASSERT_TYPE_ASSERT, "(unsigned)( scriptableIndex ) < (unsigned)( ScriptableCommon_GetServerInstanceCount() )", "scriptableIndex doesn't index ScriptableCommon_GetServerInstanceCount()\n\t%i not in [0, %i)", v7, serverInstanceCount) )
        __debugbreak();
    }
    if ( ScriptableSv_HasCollisionSupport(v4) )
    {
      if ( !g_scriptableSv_instanceContexts && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\scriptable\\scriptable_server_utility.h", 90, ASSERT_TYPE_ASSERT, "( g_scriptableSv_instanceContexts )", (const char *)&queryFormat, "g_scriptableSv_instanceContexts") )
        __debugbreak();
      ScriptableCommon_AssertCountsInitialized();
      if ( (unsigned int)v4 >= g_scriptableWorldCounts.serverInstanceCount )
      {
        ScriptableCommon_AssertCountsInitialized();
        LODWORD(v8) = g_scriptableWorldCounts.serverInstanceCount;
        LODWORD(v6) = v4;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\scriptable\\scriptable_server_utility.h", 91, ASSERT_TYPE_ASSERT, "(unsigned)( scriptableIndex ) < (unsigned)( ScriptableCommon_GetServerInstanceCount() )", "scriptableIndex doesn't index ScriptableCommon_GetServerInstanceCount()\n\t%i not in [0, %i)", v6, v8) )
          __debugbreak();
      }
      v5 = &g_scriptableSv_instanceContexts[v4];
      v5->collisionContext.useLargerBounds = Scr_GetInt(scrContext, 0) != 0;
    }
  }
}

/*
==============
ScrCmd_GetScriptableIsLoot
==============
*/
void ScrCmd_GetScriptableIsLoot(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  ScriptableInstanceContext *InstanceCommonContext; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal == -1 || (InstanceCommonContext = ScriptableSv_GetInstanceCommonContext(ScriptableIndex_Internal), !InstanceCommonContext->def) )
    Scr_AddBool(scrContext, 0);
  else
    Scr_AddBool(scrContext, ((unsigned int)InstanceCommonContext->def->flags >> 17) & 1);
}

/*
==============
ScrCmd_ScriptableCanBePinged
==============
*/
void ScrCmd_ScriptableCanBePinged(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  unsigned int v4; 
  ScriptableInstanceContext *InstanceCommonContext; 
  int flags; 
  bool v7; 
  char v8; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  v4 = ScriptableIndex_Internal;
  if ( ScriptableIndex_Internal != -1 && (InstanceCommonContext = ScriptableSv_GetInstanceCommonContext(ScriptableIndex_Internal), InstanceCommonContext->def) && ((flags = InstanceCommonContext->def->flags, v7 = (flags & 0x20000) != 0, (flags & 0x180000) == 0) || G_Door_IsClosed(v4) ? (v8 = 0) : (v8 = 1), v7 || v8) )
    Scr_AddBool(scrContext, 1);
  else
    Scr_AddBool(scrContext, 0);
}

/*
==============
ScrCmd_GetScriptableIsReserved
==============
*/
void ScrCmd_GetScriptableIsReserved(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  ScriptableCommon_AssertCountsInitialized();
  Scr_AddBool(scrContext, ScriptableIndex_Internal < g_scriptableWorldCounts.runtimeInstanceCount);
}

/*
==============
ScrCmd_HudOutlineDisableForClient
==============
*/
void ScrCmd_HudOutlineDisableForClient(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v5; 
  gentity_s *v6; 
  unsigned int v7; 
  int number; 
  int maxclients; 
  unsigned int v12; 
  int v13; 
  ClientBits v14; 
  __int128 v15; 
  __int64 v16; 
  unsigned int v17; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    Entity = GetEntity(entref);
    v5 = GScr_GetEntity(0);
    v6 = v5;
    if ( v5 && v5->client )
    {
      if ( (unsigned int)v5->s.number >= level.maxclients )
      {
        maxclients = level.maxclients;
        number = v5->s.number;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 11121, ASSERT_TYPE_ASSERT, "(unsigned)( clientEnt->s.number ) < (unsigned)( level.maxclients )", "clientEnt->s.number doesn't index level.maxclients\n\t%i not in [0, %i)", number, maxclients) )
          __debugbreak();
      }
      v7 = v6->s.number;
      v15 = 0ui64;
      v16 = 0i64;
      v17 = 0;
      if ( v7 >= 0xE0 )
      {
        v13 = 224;
        v12 = v7;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 263, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v12, v13) )
          __debugbreak();
      }
      *((_DWORD *)&v15 + ((unsigned __int64)v7 >> 5)) |= 0x80000000 >> (v7 & 0x1F);
      __asm
      {
        vmovups xmm0, [rsp+0A8h+var_38]
        vmovsd  xmm1, [rsp+0A8h+var_28]
        vmovups [rsp+0A8h+var_58], xmm0
        vmovsd  [rsp+0A8h+var_48], xmm1
      }
      v14.array[6] = v17;
      if ( !G_HudOutline_DisableForClientMask(Entity, &v14) )
        Scr_Error(COM_ERR_6292, scrContext, "HudOutlineDisableForClient() could not be applied because there are currently too many hud outline settings. Can we reduce color and depth test variations?");
    }
    else
    {
      Scr_ParamError(COM_ERR_4233, scrContext, 0, "Invalid client entity.");
    }
  }
  else
  {
    Scr_Error(COM_ERR_4232, scrContext, "usage: HudOutlineDisableForClient( <client> );");
  }
}

/*
==============
ScrCmd_GetScriptableIsLinked
==============
*/
void ScrCmd_GetScriptableIsLinked(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  ScriptableInstanceContext *InstanceCommonContext; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal == -1 )
  {
    Scr_AddBool(scrContext, 0);
  }
  else
  {
    InstanceCommonContext = ScriptableSv_GetInstanceCommonContext(ScriptableIndex_Internal);
    Scr_AddBool(scrContext, InstanceCommonContext->linkedObjectType != SCRIPTABLE_LINK_NONE);
  }
}

/*
==============
ScrCmd_GetScriptableIsUsableOnAnyPart
==============
*/
void ScrCmd_GetScriptableIsUsableOnAnyPart(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  int v4; 
  const ScriptableDef *def; 
  int v6; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal == -1 )
  {
    v4 = 0;
  }
  else
  {
    v4 = 0;
    def = ScriptableSv_GetInstanceCommonContext(ScriptableIndex_Internal)->def;
    if ( def )
    {
      v6 = 0;
      if ( def->numParts )
      {
        while ( !ScriptableCommon_GetPartHasUsableState(&def->parts[v6]) )
        {
          if ( ++v6 >= def->numParts )
            goto LABEL_9;
        }
        v4 = 1;
      }
    }
  }
LABEL_9:
  Scr_AddBool(scrContext, v4);
}

/*
==============
GScr_GetScriptableReservedReamining
==============
*/
void GScr_GetScriptableReservedReamining(scrContext_t *scrContext)
{
  int FreeReservedScriptableCount; 

  FreeReservedScriptableCount = ScriptableSv_GetFreeReservedScriptableCount();
  Scr_AddInt(scrContext, FreeReservedScriptableCount);
}

/*
==============
GScr_CalcScriptablePayloadGravityArc
==============
*/
void GScr_CalcScriptablePayloadGravityArc(scrContext_t *scrContext)
{
  unsigned __int16 v2; 
  vec3_t end; 
  vec3_t vectorValue; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &end);
  v2 = ScriptableBg_GravityArcEncodePayload(&vectorValue, &end);
  Scr_AddInt(scrContext, v2);
}

/*
==============
GScr_StopSliding
==============
*/
void GScr_StopSliding(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v16; 
  playerState_s *EntityPlayerState; 
  int time; 
  GHandler *Handler; 
  GWeaponMap *Instance; 
  char *fmt; 

  entnum = entref.entnum;
  _RDI = GetEntity(entref);
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 29427, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClientOrAgent(_RDI) )
  {
    targetname = _RDI->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(_RDI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rdi+134h]
      vmovss  xmm2, dword ptr [rdi+130h]
      vmovss  xmm0, dword ptr [rdi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+48h+fmt], xmm0
    }
    v16 = j_va("StopSliding is only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, fmt, v7, v6);
    Scr_Error(COM_ERR_4797, scrContext, v16);
  }
  EntityPlayerState = G_GetEntityPlayerState(_RDI);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 29433, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_4798, scrContext, "USAGE: <player> StopSliding()\n");
  time = level.time;
  Handler = GHandler::getHandler();
  Instance = GWeaponMap::GetInstance();
  Slide_Interrupt(EntityPlayerState, Instance, Handler, time);
}

/*
==============
ScrCmd_SetEntitySoundContext
==============
*/
void ScrCmd_SetEntitySoundContext(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  unsigned int NumParam; 
  const char *String; 
  const char *v7; 
  unsigned int v8; 
  unsigned int v9; 
  const char *v11; 
  double v12; 

  entnum = entref.entnum;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam - 2 > 1 )
  {
    Scr_Error(COM_ERR_4799, scrContext, "SetEntitySoundContext: Incorrect number of parameters\n");
  }
  else
  {
    String = Scr_GetString(scrContext, 0);
    v7 = Scr_GetString(scrContext, 1u);
    v8 = SND_HashName(String);
    SND_DevhostString(String);
    if ( *v7 )
    {
      v9 = SND_HashName(v7);
      SND_DevhostString(v7);
    }
    else
    {
      v9 = 0;
    }
    if ( NumParam == 3 )
    {
      *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
      __asm
      {
        vcvtss2sd xmm1, xmm0, xmm0
        vmovsd  [rsp+58h+var_28], xmm1
      }
      v11 = j_va("%c %c %d %x %x %g", 105i64, 97i64, entnum, v8, v9, v12);
    }
    else
    {
      v11 = j_va("%c %c %d %x %x", 105i64, 97i64, entnum, v8, v9);
    }
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v11);
  }
}

/*
==============
ScrCmd_HudOutlineEnableForClients
==============
*/
void ScrCmd_HudOutlineEnableForClients(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t ConstString; 
  const char *v6; 
  const char *v7; 
  ComErrorCode v8; 
  int v11; 
  unsigned int outIndex[3]; 
  ClientBits v13; 
  ClientBits outClientMask; 

  v11 = 0;
  if ( Scr_GetNumParam(scrContext) > 2 )
  {
    Scr_Error(COM_ERR_4239, scrContext, "usage: HudOutlineEnableForClients( <client array>, <hudOutline> );");
    return;
  }
  Entity = GetEntity(entref);
  ScrCmd_BuildHudOutlineClientMaskFromEntArray(scrContext, 0, &outClientMask);
  ConstString = Scr_GetConstString(scrContext, 1u);
  if ( !ConstString && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 11220, ASSERT_TYPE_ASSERT, "(hudOutlineScrStr != ( static_cast< scr_string_t >( 0 ) ))", (const char *)&queryFormat, "hudOutlineScrStr != NULL_SCR_STRING") )
    __debugbreak();
  v6 = SL_ConvertToString(ConstString);
  if ( !v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 11223, ASSERT_TYPE_ASSERT, "(hudOutlineName)", (const char *)&queryFormat, "hudOutlineName") )
    __debugbreak();
  outIndex[0] = 0;
  if ( BG_HudOutline_GetDefIndex(v6, outIndex) )
  {
    __asm
    {
      vmovups xmm0, xmmword ptr [rsp+0A8h+outClientMask.baseclass_0.array]
      vmovsd  xmm1, qword ptr [rsp+0A8h+outClientMask.baseclass_0.array+10h]
    }
    v11 ^= ((unsigned __int8)v11 ^ LOBYTE(outIndex[0])) & 0x3F;
    v13.array[6] = outClientMask.array[6];
    __asm
    {
      vmovups [rsp+0A8h+var_68], xmm0
      vmovsd  [rsp+0A8h+var_58], xmm1
    }
    if ( G_HudOutline_EnableForClientMask(Entity, &v13, (const outline_client_data_t *)&v11) )
      return;
    v7 = "HudOutlineEnableForClients() could not be applied because there are currently too many hud outline settings. Can we reduce color and depth test variations?";
    v8 = COM_ERR_6293;
  }
  else
  {
    v7 = j_va("Hud Outline name not found (%s)! Make sure you add your Hud Outline asset to your level csv file!\n", v6);
    v8 = COM_ERR_6087;
  }
  Scr_Error(v8, scrContext, v7);
}

/*
==============
PlayerCmd_SetClientTriggerAudioZone
==============
*/
void PlayerCmd_SetClientTriggerAudioZone(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v5; 
  const char *v6; 
  int number; 
  const char *v8; 
  const char *v9; 
  ComErrorCode v10; 
  unsigned int NumParam; 
  const char *String; 
  const char *v13; 
  const char *v14; 
  char *fmt; 
  int outControllingClientNum; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3678, scrContext, "not an entity");
    v5 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 29521, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v5 = &g_entities[entnum];
    if ( !v5->client && !v5->agent )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3677, scrContext, v6);
    }
  }
  number = v5->s.number;
  outControllingClientNum = number;
  if ( SV_IsAgent(number) && !SV_GetAgentControlledByPlayerNum(outControllingClientNum, &outControllingClientNum) )
  {
    v8 = j_va("entity %i is not a player or player-controlled agent", entnum);
    Scr_ObjectError(COM_ERR_4800, scrContext, v8);
    return;
  }
  if ( outControllingClientNum < level.maxclients )
  {
    NumParam = Scr_GetNumParam(scrContext);
    if ( NumParam - 1 <= 1 )
    {
      if ( NumParam == 1 )
      {
        String = Scr_GetString(scrContext, 0);
        v13 = j_va("%c %c %s 0", 109i64, 98i64, String);
      }
      else
      {
        if ( NumParam != 2 )
          return;
        v14 = Scr_GetString(scrContext, 0);
        *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
        __asm
        {
          vcvtss2sd xmm1, xmm0, xmm0
          vmovsd  [rsp+38h+fmt], xmm1
        }
        v13 = j_va("%c %c %s 0 %g", 109i64, 98i64, v14, *(double *)&fmt);
      }
      SV_Game_SendServerCommand(outControllingClientNum, SV_CMD_RELIABLE, v13);
      return;
    }
    v9 = "Incorrect number of parameters\n";
    v10 = COM_ERR_4801;
  }
  else
  {
    v9 = j_va("Invalid entity index %d before SV_Game_SendServerCommand\n", (unsigned int)outControllingClientNum);
    v10 = COM_ERR_6411;
  }
  Scr_Error(v10, scrContext, v9);
}

/*
==============
ScrCmd_HudOutlineDisableForClients
==============
*/
void ScrCmd_HudOutlineDisableForClients(scrContext_t *scrContext, scr_entref_t entref)
{
  const char *v4; 
  ComErrorCode v5; 
  gentity_s *Entity; 
  ClientBits v9; 
  ClientBits outClientMask; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    Entity = GetEntity(entref);
    ScrCmd_BuildHudOutlineClientMaskFromEntArray(scrContext, 0, &outClientMask);
    __asm
    {
      vmovups xmm0, xmmword ptr [rsp+78h+outClientMask.baseclass_0.array]
      vmovsd  xmm1, qword ptr [rsp+78h+outClientMask.baseclass_0.array+10h]
    }
    v9.array[6] = outClientMask.array[6];
    __asm
    {
      vmovups [rsp+78h+var_58], xmm0
      vmovsd  [rsp+78h+var_48], xmm1
    }
    if ( G_HudOutline_DisableForClientMask(Entity, &v9) )
      return;
    v4 = "HudOutlineDisableForClients() could not be applied because there are currently too many hud outline settings. Can we reduce color and depth test variations?";
    v5 = COM_ERR_6294;
  }
  else
  {
    v4 = "usage: HudOutlineDisableForClients( <client array> );";
    v5 = COM_ERR_4241;
  }
  Scr_Error(v5, scrContext, v4);
}

/*
==============
ScrCmd_HudOutlineEnable
==============
*/
void ScrCmd_HudOutlineEnable(scrContext_t *scrContext, scr_entref_t entref)
{
  scr_string_t ConstString; 
  const char *v5; 
  const char *v6; 
  ComErrorCode v7; 
  gentity_s *Entity; 
  int v11; 
  unsigned int outIndex[3]; 
  ClientBits v13; 
  __int128 v14; 
  __int64 v15; 

  v11 = 0;
  if ( Scr_GetNumParam(scrContext) > 1 )
  {
    Scr_Error(COM_ERR_4242, scrContext, "Usage: HudOutlineEnable( <hudOutline>");
    return;
  }
  ConstString = Scr_GetConstString(scrContext, 0);
  if ( !ConstString && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 11305, ASSERT_TYPE_ASSERT, "(hudOutlineScrStr != ( static_cast< scr_string_t >( 0 ) ))", (const char *)&queryFormat, "hudOutlineScrStr != NULL_SCR_STRING") )
    __debugbreak();
  v5 = SL_ConvertToString(ConstString);
  if ( !v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 11308, ASSERT_TYPE_ASSERT, "(hudOutlineName)", (const char *)&queryFormat, "hudOutlineName") )
    __debugbreak();
  outIndex[0] = 0;
  if ( BG_HudOutline_GetDefIndex(v5, outIndex) )
  {
    v11 ^= ((unsigned __int8)v11 ^ LOBYTE(outIndex[0])) & 0x3F;
    Entity = GetEntity(entref);
    *(_QWORD *)&v14 = -1i64;
    *((_QWORD *)&v14 + 1) = -1i64;
    __asm { vmovups xmm0, [rsp+0A8h+var_48] }
    v15 = -1i64;
    __asm
    {
      vmovsd  xmm1, [rsp+0A8h+var_38]
      vmovups [rsp+0A8h+var_68], xmm0
      vmovsd  [rsp+0A8h+var_58], xmm1
    }
    v13.array[6] = -1;
    if ( G_HudOutline_EnableForClientMask(Entity, &v13, (const outline_client_data_t *)&v11) )
      return;
    v6 = "HudOutlineEnable() could not be applied because there are currently too many hud outline settings. Can we reduce color and depth test variations?";
    v7 = COM_ERR_6295;
  }
  else
  {
    v6 = j_va("Hud Outline name not found (%s)! Make sure you add your Hud Outline asset to your level csv file!\n", v5);
    v7 = COM_ERR_6088;
  }
  Scr_Error(v7, scrContext, v6);
}

/*
==============
PlayerCmd_SetPriorityClientTriggerAudioZone
==============
*/
void PlayerCmd_SetPriorityClientTriggerAudioZone(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v5; 
  const char *v6; 
  int number; 
  const char *v8; 
  const char *v9; 
  unsigned int NumParam; 
  const char *String; 
  int AudioTriggerPriorityIndex; 
  const char *v13; 
  const char *v14; 
  const char *v16; 
  char *fmt; 
  double v18; 
  int outControllingClientNum; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3678, scrContext, "not an entity");
    v5 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 29577, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v5 = &g_entities[entnum];
    if ( !v5->client && !v5->agent )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3677, scrContext, v6);
    }
  }
  number = v5->s.number;
  outControllingClientNum = number;
  if ( !SV_IsAgent(number) || SV_GetAgentControlledByPlayerNum(outControllingClientNum, &outControllingClientNum) )
  {
    if ( outControllingClientNum < level.maxclients )
    {
      NumParam = Scr_GetNumParam(scrContext);
      if ( NumParam - 2 > 1 )
      {
        Scr_Error(COM_ERR_4803, scrContext, "Incorrect number of parameters\n");
      }
      else
      {
        String = Scr_GetString(scrContext, 1u);
        AudioTriggerPriorityIndex = GScr_Main_GetAudioTriggerPriorityIndex(String);
        if ( AudioTriggerPriorityIndex == -1 )
        {
          v13 = j_va("Invalid client trigger override priority level: %s", String);
          Scr_Error(COM_ERR_4804, scrContext, v13);
        }
        else if ( NumParam == 2 )
        {
          v14 = Scr_GetString(scrContext, 0);
          *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
          __asm
          {
            vcvtss2sd xmm1, xmm0, xmm0
            vmovsd  [rsp+38h+var_10], xmm1
          }
          LODWORD(fmt) = AudioTriggerPriorityIndex;
          v16 = j_va("%c %c %s %d %g", 109i64, 98i64, v14, fmt, v18);
          SV_Game_SendServerCommand(outControllingClientNum, SV_CMD_RELIABLE, v16);
        }
      }
    }
    else
    {
      v9 = j_va("Invalid entity index %d before SV_Game_SendServerCommand\n", (unsigned int)outControllingClientNum);
      Scr_Error(COM_ERR_6412, scrContext, v9);
    }
  }
  else
  {
    v8 = j_va("entity %i is not a player or player-controlled agent", entnum);
    Scr_ObjectError(COM_ERR_4802, scrContext, v8);
  }
}

/*
==============
ScrCmd_HudOutlineDisable
==============
*/
void ScrCmd_HudOutlineDisable(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  ClientBits v6; 
  __int128 v7; 
  __int64 v8; 

  *(_QWORD *)&v7 = -1i64;
  *((_QWORD *)&v7 + 1) = -1i64;
  v8 = -1i64;
  Entity = GetEntity(entref);
  __asm
  {
    vmovups xmm0, [rsp+78h+var_38]
    vmovsd  xmm1, [rsp+78h+var_28]
  }
  v6.array[6] = -1;
  __asm
  {
    vmovups [rsp+78h+var_58], xmm0
    vmovsd  [rsp+78h+var_48], xmm1
  }
  if ( !G_HudOutline_DisableForClientMask(Entity, &v6) )
    Scr_Error(COM_ERR_6296, scrContext, "HudOutlineDisable() could not be applied because there are currently too many hud outline settings. Can we reduce color and depth test variations?");
}

/*
==============
PlayerCmd_SetClientTriggerAudioZoneLerp
==============
*/
void PlayerCmd_SetClientTriggerAudioZoneLerp(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v5; 
  const char *v6; 
  int number; 
  const char *v8; 
  const char *v9; 
  ComErrorCode v10; 
  const char *String; 
  const char *v12; 
  const char *v14; 
  double v15; 
  int outControllingClientNum; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3678, scrContext, "not an entity");
    v5 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 29643, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v5 = &g_entities[entnum];
    if ( !v5->client && !v5->agent )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3677, scrContext, v6);
    }
  }
  number = v5->s.number;
  outControllingClientNum = number;
  if ( SV_IsAgent(number) && !SV_GetAgentControlledByPlayerNum(outControllingClientNum, &outControllingClientNum) )
  {
    v8 = j_va("entity %i is not a player or player-controlled agent", entnum);
    Scr_ObjectError(COM_ERR_4805, scrContext, v8);
    return;
  }
  if ( outControllingClientNum < level.maxclients )
  {
    if ( Scr_GetNumParam(scrContext) == 3 )
    {
      String = Scr_GetString(scrContext, 0);
      v12 = Scr_GetString(scrContext, 1u);
      *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
      __asm
      {
        vcvtss2sd xmm1, xmm0, xmm0
        vmovsd  [rsp+38h+var_10], xmm1
      }
      v14 = j_va("%c %c %s %s %g", 109i64, 99i64, String, v12, v15);
      SV_Game_SendServerCommand(outControllingClientNum, SV_CMD_RELIABLE, v14);
      return;
    }
    v9 = "Incorrect number of parameters\n";
    v10 = COM_ERR_4806;
  }
  else
  {
    v9 = j_va("Invalid entity index %d before SV_Game_SendServerCommand\n", (unsigned int)outControllingClientNum);
    v10 = COM_ERR_6413;
  }
  Scr_Error(v10, scrContext, v9);
}

/*
==============
ScrCmd_MotionBlurHQEnable
==============
*/
void ScrCmd_MotionBlurHQEnable(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *client; 

  Entity = GetEntity(entref);
  client = (GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *)Entity->client;
  if ( client )
    GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(client + 94, ACTIVE, 0xDu);
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(&Entity->s.lerp.eFlags, ACTIVE, 0xDu);
}

/*
==============
ScrCmd_MotionBlurHQDisable
==============
*/
void ScrCmd_MotionBlurHQDisable(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *client; 

  Entity = GetEntity(entref);
  client = (GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *)Entity->client;
  if ( client )
    GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(client + 94, ACTIVE, 0xDu);
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(&Entity->s.lerp.eFlags, ACTIVE, 0xDu);
}

/*
==============
ScrCmd_ThermalVisionFOFOverlayOn
==============
*/
void ScrCmd_ThermalVisionFOFOverlayOn(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  char *client; 
  const char *v6; 
  ComErrorCode v7; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 11417, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = (char *)v4->client;
  if ( !client )
  {
    client = (char *)v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v7, scrContext, v6);
      client = NULL;
    }
  }
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal((GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *)(client + 28), ACTIVE, 4u);
}

/*
==============
ScrCmd_ThermalVisionFOFOverlayOff
==============
*/
void ScrCmd_ThermalVisionFOFOverlayOff(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  char *client; 
  const char *v6; 
  ComErrorCode v7; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 11434, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = (char *)v4->client;
  if ( !client )
  {
    client = (char *)v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v7, scrContext, v6);
      client = NULL;
    }
  }
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal((GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *)(client + 28), ACTIVE, 4u);
}

/*
==============
ScrCmd_GetStance
==============
*/
void ScrCmd_GetStance(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v16; 
  playerState_s *EntityPlayerState; 
  bool v18; 
  scr_string_t crouch; 
  char *fmt; 

  entnum = entref.entnum;
  _RDI = GetEntity(entref);
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 11455, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClientOrAgent(_RDI) )
  {
    targetname = _RDI->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(_RDI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rdi+134h]
      vmovss  xmm2, dword ptr [rdi+130h]
      vmovss  xmm0, dword ptr [rdi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+48h+fmt], xmm0
    }
    v16 = j_va("only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, fmt, v7, v6);
    Scr_Error(COM_ERR_4244, scrContext, v16);
  }
  EntityPlayerState = G_GetEntityPlayerState(_RDI);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 11461, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&EntityPlayerState->pm_flags, ACTIVE, 0) )
  {
    Scr_AddConstString(scrContext, scr_const.prone);
  }
  else
  {
    v18 = GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&EntityPlayerState->pm_flags, ACTIVE, 1u);
    crouch = scr_const.crouch;
    if ( !v18 )
      crouch = scr_const.stand;
    Scr_AddConstString(scrContext, crouch);
  }
}

/*
==============
PlayerCmd_SetClientTriggerAudioZonePartial
==============
*/
void PlayerCmd_SetClientTriggerAudioZonePartial(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *v5; 
  const char *v6; 
  ComErrorCode v7; 
  const char *String; 
  float fmt; 

  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3678;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 29778, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v5 = &g_entities[entref.entnum];
  if ( !v5->client && !v5->agent )
  {
    v6 = j_va("entity %i is not a player or agent", entref.entnum);
    v7 = COM_ERR_3677;
LABEL_9:
    Scr_ObjectError(v7, scrContext, v6);
  }
  Scr_GetNumParam(scrContext);
  String = Scr_GetString(scrContext, 0);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmovss  dword ptr [rsp+38h+fmt], xmm0
  }
  SetClientTriggerAudioZonePartial(scrContext, entref, String, 0, fmt, 1);
}

/*
==============
ScrCmd_SetStance
==============
*/
void ScrCmd_SetStance(scrContext_t *scrContext, scr_entref_t entref)
{
  bool v4; 
  gentity_s *Entity; 
  scr_string_t ConstString; 
  int v7; 
  int passEntityNum; 
  const Bounds *v10; 
  const char *v11; 
  int clientNum; 
  const Bounds *Bounds; 
  const char *v14; 
  const SuitDef *SuitDef; 
  bool v16; 
  bool v17; 
  int viewheight_stand; 
  unsigned int v19; 
  int v22; 
  trace_t results; 

  v4 = 0;
  Entity = GetEntity(entref);
  ConstString = Scr_GetConstString(scrContext, 0);
  v7 = 1;
  if ( Scr_GetNumParam(scrContext) > 1 && Scr_GetType(scrContext, 1u) )
    v4 = Scr_GetInt(scrContext, 1u) != 0;
  _RSI = Entity->client;
  if ( !_RSI )
  {
    Scr_Error(COM_ERR_4245, scrContext, "SetStance is only defined for players.");
    return;
  }
  if ( v4 )
    goto LABEL_19;
  if ( !GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&_RSI->ps.pm_flags, ACTIVE, 0) || ConstString != scr_const.crouch && ConstString != scr_const.stand || (passEntityNum = _RSI->ps.clientNum, v10 = BG_Suit_GetBounds(_RSI->ps.suitIndex, PM_EFF_STANCE_DUCKED), G_Main_TraceCapsule(&results, &_RSI->ps.origin, &_RSI->ps.origin, v10, passEntityNum, 65553), !results.allsolid) )
  {
    if ( (GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&_RSI->ps.pm_flags, ACTIVE, 0) || GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&_RSI->ps.pm_flags, ACTIVE, 1u)) && ConstString == scr_const.stand )
    {
      clientNum = _RSI->ps.clientNum;
      Bounds = BG_Suit_GetBounds(_RSI->ps.suitIndex, PM_EFF_STANCE_DUCKED);
      G_Main_TraceCapsule(&results, &_RSI->ps.origin, &_RSI->ps.origin, Bounds, clientNum, 65553);
      if ( results.allsolid )
      {
        v14 = SL_ConvertToString(ConstString);
        Com_PrintWarning(23, "Warning: SetStance( \"%s\" ) could not be applied because there isn't enough room", v14);
        if ( !GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&_RSI->ps.pm_flags, ACTIVE, 0) )
          goto LABEL_11;
        ConstString = scr_const.crouch;
      }
    }
LABEL_19:
    SuitDef = BG_GetSuitDef(_RSI->ps.suitIndex);
    if ( !SuitDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 11540, ASSERT_TYPE_ASSERT, "(suitDef)", (const char *)&queryFormat, "suitDef") )
      __debugbreak();
    v16 = Scr_GetNumParam(scrContext) > 2 && Scr_GetType(scrContext, 2u) && Scr_GetInt(scrContext, 2u);
    v17 = Scr_GetNumParam(scrContext) > 3 && Scr_GetType(scrContext, 3u) && Scr_GetInt(scrContext, 3u);
    if ( ConstString == scr_const.stand )
    {
      if ( v16 )
        GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::SetFlagInternal(&_RSI->ps.pm_flags, ACTIVE, 4u);
      GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(&_RSI->ps.pm_flags, ACTIVE, 2u);
      GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(&_RSI->ps.pm_flags, ACTIVE, 3u);
      GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(&_RSI->ps.pm_flags, ACTIVE, 0);
      GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(&_RSI->ps.pm_flags, ACTIVE, 0x36u);
      GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(&_RSI->ps.pm_flags, ACTIVE, 1u);
      viewheight_stand = SuitDef->viewheight_stand;
      v19 = 10;
    }
    else if ( ConstString == scr_const.crouch )
    {
      if ( v16 )
        GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::SetFlagInternal(&_RSI->ps.pm_flags, ACTIVE, 3u);
      GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(&_RSI->ps.pm_flags, ACTIVE, 2u);
      GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(&_RSI->ps.pm_flags, ACTIVE, 4u);
      GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(&_RSI->ps.pm_flags, ACTIVE, 0);
      GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(&_RSI->ps.pm_flags, ACTIVE, 0x36u);
      GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::SetFlagInternal(&_RSI->ps.pm_flags, ACTIVE, 1u);
      viewheight_stand = SuitDef->viewheight_crouch;
      v19 = 11;
    }
    else
    {
      if ( ConstString != scr_const.prone )
      {
        v7 = 0;
LABEL_52:
        Scr_AddBool(scrContext, v7);
        return;
      }
      if ( !GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&_RSI->ps.pm_flags, ACTIVE, 0) )
      {
        __asm
        {
          vmovss  xmm0, dword ptr [rsi+1DCh]
          vmovss  [rsp+0E8h+var_B8], xmm0
        }
        if ( (v22 & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 11593, ASSERT_TYPE_ASSERT, "(!IS_NAN( ps->viewangles[YAW] ))", (const char *)&queryFormat, "!IS_NAN( ps->viewangles[YAW] )") )
          __debugbreak();
        _RSI->ps.proneDirection = _RSI->ps.viewangles.v[1];
      }
      if ( v16 )
        GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::SetFlagInternal(&_RSI->ps.pm_flags, ACTIVE, 2u);
      GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(&_RSI->ps.pm_flags, ACTIVE, 3u);
      GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(&_RSI->ps.pm_flags, ACTIVE, 4u);
      GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(&_RSI->ps.pm_flags, ACTIVE, 1u);
      GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::SetFlagInternal(&_RSI->ps.pm_flags, ACTIVE, 0);
      viewheight_stand = BG_Suit_GetProneViewHeight(SuitDef);
      v19 = 12;
    }
    _RSI->ps.viewHeightTarget = viewheight_stand;
    G_Utils_AddEvent(Entity, v19, 0);
    if ( v17 )
    {
      __asm
      {
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm0, xmm0, dword ptr [rsi+1E4h]
        vmovss  dword ptr [rsi+1E8h], xmm0
      }
    }
    goto LABEL_52;
  }
  v11 = SL_ConvertToString(ConstString);
  Com_PrintWarning(23, "Warning: SetStance( \"%s\" ) could not be applied because there isn't enough room", v11);
LABEL_11:
  Scr_AddBool(scrContext, 0);
}

/*
==============
PlayerCmd_SetPriorityClientTriggerAudioZonePartial
==============
*/
void PlayerCmd_SetPriorityClientTriggerAudioZonePartial(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *v5; 
  const char *v6; 
  ComErrorCode v7; 
  const char *String; 
  const char *v9; 
  int AudioTriggerPriorityIndex; 
  const char *v11; 
  float fmt; 

  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3678;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 29817, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v5 = &g_entities[entref.entnum];
  if ( !v5->client && !v5->agent )
  {
    v6 = j_va("entity %i is not a player or agent", entref.entnum);
    v7 = COM_ERR_3677;
LABEL_9:
    Scr_ObjectError(v7, scrContext, v6);
  }
  Scr_GetNumParam(scrContext);
  String = Scr_GetString(scrContext, 0);
  v9 = Scr_GetString(scrContext, 1u);
  AudioTriggerPriorityIndex = GScr_Main_GetAudioTriggerPriorityIndex(v9);
  if ( AudioTriggerPriorityIndex == -1 )
  {
    v11 = j_va("Invalid client trigger override priority level: %s", v9);
    Scr_Error(COM_ERR_4809, scrContext, v11);
  }
  else
  {
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vmovss  dword ptr [rsp+38h+fmt], xmm0
    }
    SetClientTriggerAudioZonePartial(scrContext, entref, String, AudioTriggerPriorityIndex, fmt, 2);
  }
}

/*
==============
PlayerCmd_SetClientTriggerAudioZonePartialWithFade
==============
*/
void PlayerCmd_SetClientTriggerAudioZonePartialWithFade(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *v5; 
  const char *v6; 
  ComErrorCode v7; 
  const char *String; 
  float fmt; 

  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3678;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 29863, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v5 = &g_entities[entref.entnum];
  if ( !v5->client && !v5->agent )
  {
    v6 = j_va("entity %i is not a player or agent", entref.entnum);
    v7 = COM_ERR_3677;
LABEL_9:
    Scr_ObjectError(v7, scrContext, v6);
  }
  Scr_GetNumParam(scrContext);
  String = Scr_GetString(scrContext, 0);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm { vmovss  dword ptr [rsp+38h+fmt], xmm0 }
  SetClientTriggerAudioZonePartial(scrContext, entref, String, 0, fmt, 2);
}

/*
==============
PlayerCmd_SetPriorityClientTriggerAudioZonePartialWithFade
==============
*/
void PlayerCmd_SetPriorityClientTriggerAudioZonePartialWithFade(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *v6; 
  const char *v7; 
  ComErrorCode v8; 
  const char *String; 
  const char *v11; 
  int AudioTriggerPriorityIndex; 
  const char *v13; 
  float fmt; 

  __asm { vmovaps [rsp+48h+var_18], xmm6 }
  if ( entref.entclass )
  {
    v7 = "not an entity";
    v8 = COM_ERR_3678;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 29905, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v6 = &g_entities[entref.entnum];
  if ( !v6->client && !v6->agent )
  {
    v7 = j_va("entity %i is not a player or agent", entref.entnum);
    v8 = COM_ERR_3677;
LABEL_9:
    Scr_ObjectError(v8, scrContext, v7);
  }
  Scr_GetNumParam(scrContext);
  String = Scr_GetString(scrContext, 0);
  Scr_GetString(scrContext, 1u);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
  __asm { vmovaps xmm6, xmm0 }
  v11 = Scr_GetString(scrContext, 0);
  AudioTriggerPriorityIndex = GScr_Main_GetAudioTriggerPriorityIndex(v11);
  if ( AudioTriggerPriorityIndex == -1 )
  {
    v13 = j_va("Invalid client trigger override priority level: %s", v11);
    Scr_Error(COM_ERR_4810, scrContext, v13);
  }
  else
  {
    __asm { vmovss  dword ptr [rsp+48h+fmt], xmm6 }
    SetClientTriggerAudioZonePartial(scrContext, entref, String, AudioTriggerPriorityIndex, fmt, 2);
  }
  __asm { vmovaps xmm6, [rsp+48h+var_18] }
}

/*
==============
PlayerCmd_ClearClientTriggerAudioZone
==============
*/
void PlayerCmd_ClearClientTriggerAudioZone(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v5; 
  const char *v6; 
  int NumParam; 
  int number; 
  const char *v9; 
  const char *v10; 
  const char *v11; 
  int outControllingClientNum; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3678, scrContext, "not an entity");
    v5 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 29942, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v5 = &g_entities[entnum];
    if ( !v5->client && !v5->agent )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3677, scrContext, v6);
    }
  }
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam > 1 )
  {
    Scr_Error(COM_ERR_4811, scrContext, "Incorrect number of parameters\n");
    return;
  }
  number = v5->s.number;
  outControllingClientNum = number;
  if ( SV_IsAgent(number) && !SV_GetAgentControlledByPlayerNum(outControllingClientNum, &outControllingClientNum) )
  {
    v9 = j_va("entity %i is not a player or player-controlled agent", entnum);
    Scr_ObjectError(COM_ERR_4812, scrContext, v9);
    return;
  }
  if ( outControllingClientNum >= level.maxclients )
  {
    v10 = j_va("Invalid entity index %d before SV_Game_SendServerCommand\n", (unsigned int)outControllingClientNum);
    Scr_Error(COM_ERR_6415, scrContext, v10);
    return;
  }
  if ( NumParam )
  {
    if ( NumParam != 1 )
      return;
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
    __asm
    {
      vcvtss2sd xmm3, xmm0, xmm0
      vmovq   r9, xmm3
    }
    v11 = j_va("%c %c 0 %g", 109i64, 101i64, _R9);
  }
  else
  {
    v11 = j_va("%c %c 0", 109i64, 101i64);
  }
  SV_Game_SendServerCommand(outControllingClientNum, SV_CMD_RELIABLE, v11);
}

/*
==============
ScrCmd_GetEye
==============
*/
void ScrCmd_GetEye(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const gentity_s *v4; 
  const char *v5; 
  const char *v6; 
  gclient_s *client; 
  vec3_t outCentroid; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( !Entity->sentient )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("getEye must be called on a sentient entity. Use self MakeEntitySentient() with '%s'", v5);
    Scr_Error(COM_ERR_4251, scrContext, v6);
  }
  client = v4->client;
  if ( client && client->sess.sessionState )
  {
    Com_Printf(23, "GetEye() called while not in SESS_STATE_PLAYING\n");
    G_Utils_EntityCentroid(v4, &outCentroid);
  }
  else
  {
    Sentient_GetEyePosition(v4->sentient, &outCentroid);
  }
  Scr_AddVector(scrContext, outCentroid.v);
}

/*
==============
ScrCmd_GetViewOrigin
==============
*/
void ScrCmd_GetViewOrigin(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const playerState_s *p_ps; 
  const char *v6; 
  ComErrorCode v7; 
  vec3_t outOrigin; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 11726, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  p_ps = &v4->client->ps;
  if ( !p_ps )
  {
    p_ps = &v4->agent->playerState;
    if ( !p_ps )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v7, scrContext, v6);
      p_ps = NULL;
    }
  }
  G_Client_GetViewOrigin(p_ps, &outOrigin);
  Scr_AddVector(scrContext, outOrigin.v);
}

/*
==============
PlayerCmd_ClearPriorityClientTriggerAudioZone
==============
*/
void PlayerCmd_ClearPriorityClientTriggerAudioZone(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v5; 
  const char *v6; 
  int NumParam; 
  int number; 
  const char *v9; 
  const char *String; 
  unsigned int AudioTriggerPriorityIndex; 
  unsigned int v12; 
  const char *v13; 
  const char *v14; 
  const char *v15; 
  char *fmt; 
  int outControllingClientNum; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3678, scrContext, "not an entity");
    v5 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 29994, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v5 = &g_entities[entnum];
    if ( !v5->client && !v5->agent )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3677, scrContext, v6);
    }
  }
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam > 2 )
  {
    Scr_Error(COM_ERR_4813, scrContext, "Incorrect number of parameters\n");
    return;
  }
  number = v5->s.number;
  outControllingClientNum = number;
  if ( SV_IsAgent(number) && !SV_GetAgentControlledByPlayerNum(outControllingClientNum, &outControllingClientNum) )
  {
    v9 = j_va("entity %i is not a player or player-controlled agent", entnum);
    Scr_ObjectError(COM_ERR_4814, scrContext, v9);
    return;
  }
  String = Scr_GetString(scrContext, 0);
  AudioTriggerPriorityIndex = GScr_Main_GetAudioTriggerPriorityIndex(String);
  v12 = AudioTriggerPriorityIndex;
  if ( AudioTriggerPriorityIndex == -1 )
  {
    v13 = j_va("Invalid client trigger override priority level: %s", String);
    Scr_Error(COM_ERR_4815, scrContext, v13);
    return;
  }
  if ( outControllingClientNum >= level.maxclients )
  {
    v14 = j_va("Invalid entity index %d before SV_Game_SendServerCommand\n", (unsigned int)outControllingClientNum);
    Scr_Error(COM_ERR_6416, scrContext, v14);
    return;
  }
  if ( NumParam == 1 )
  {
    v15 = j_va("%c %c %d", 109i64, 101i64, AudioTriggerPriorityIndex);
  }
  else
  {
    if ( NumParam != 2 )
      return;
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
    __asm
    {
      vcvtss2sd xmm1, xmm0, xmm0
      vmovsd  [rsp+38h+fmt], xmm1
    }
    v15 = j_va("%c %c %d %g", 109i64, 101i64, v12, *(double *)&fmt);
  }
  SV_Game_SendServerCommand(outControllingClientNum, SV_CMD_RELIABLE, v15);
}

/*
==============
Scr_BulletSpread
==============
*/
void Scr_BulletSpread(scrContext_t *scrContext)
{
  const WeaponDef *v11; 
  bool v47; 
  float v57; 
  float v58; 
  float v59; 
  unsigned int pHoldrand[4]; 
  BgWeaponParms src; 
  vec3_t end; 
  vec3_t vectorValue; 
  vec3_t dir; 
  char vars0; 
  void *retaddr; 

  _R11 = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [r11-38h], xmm8
    vmovaps xmmword ptr [r11-18h], xmm6
    vmovaps xmmword ptr [r11-28h], xmm7
  }
  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &end);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
  __asm
  {
    vmovups ymm1, ymmword ptr cs:?NULL_WEAPON@@3UWeapon@@B.weaponIdx; Weapon const NULL_WEAPON
    vmovups xmm2, xmmword ptr cs:?NULL_WEAPON@@3UWeapon@@B.attachmentVariationIndices+5; Weapon const NULL_WEAPON
    vmovups [rbp+60h+var_B8], ymm1
    vmovsd  xmm1, qword ptr cs:?NULL_WEAPON@@3UWeapon@@B.attachmentVariationIndices+15h; Weapon const NULL_WEAPON
  }
  *(_DWORD *)&src.weapon.weaponCamo = *(_DWORD *)&NULL_WEAPON.weaponCamo;
  __asm
  {
    vmovsd  [rbp+60h+var_88], xmm1
    vmovaps xmm8, xmm0
    vmovups [rbp+60h+var_98], xmm2
  }
  v11 = BG_WeaponDef(&NULL_WEAPON, 0);
  __asm
  {
    vmovss  xmm1, dword ptr [rbp+60h+vectorValue]
    vmovss  xmm2, dword ptr [rbp+60h+vectorValue+4]
    vmovss  xmm3, dword ptr [rbp+60h+vectorValue+8]
    vmovss  xmm0, dword ptr [rbp+60h+end]
    vsubss  xmm5, xmm0, xmm1
    vmovss  xmm0, dword ptr [rbp+60h+end+8]
    vsubss  xmm7, xmm0, xmm3
    vmovss  [rbp+60h+var_DC], xmm1
    vmovss  xmm1, dword ptr [rbp+60h+end+4]
    vsubss  xmm6, xmm1, xmm2
    vmovss  [rbp+60h+var_D8], xmm2
    vmulss  xmm0, xmm7, xmm7
    vmulss  xmm2, xmm6, xmm6
    vmulss  xmm1, xmm5, xmm5
    vmovss  [rbp+60h+var_D4], xmm3
    vaddss  xmm3, xmm2, xmm1
    vmovss  xmm1, cs:__real@3f800000
    vaddss  xmm2, xmm3, xmm0
    vsqrtss xmm4, xmm2, xmm2
    vcmpless xmm0, xmm4, cs:__real@80000000
    vblendvps xmm0, xmm4, xmm1, xmm0
    vdivss  xmm2, xmm1, xmm0
    vmulss  xmm3, xmm5, xmm2
    vmulss  xmm1, xmm6, xmm2
    vmulss  xmm0, xmm7, xmm2
  }
  src.weapDef = v11;
  __asm
  {
    vmovss  dword ptr [rsp+160h+src], xmm3
    vmovss  dword ptr [rsp+160h+src+4], xmm1
    vmovss  dword ptr [rsp+160h+src+8], xmm0
    vmovss  [rbp+60h+var_D0], xmm3
    vmovss  [rbp+60h+var_CC], xmm1
    vmovss  [rbp+60h+var_C8], xmm0
  }
  PerpendicularVector(&src.forward, &src.up);
  __asm
  {
    vmovss  xmm5, dword ptr [rbp+60h+dst+8]
    vmovss  xmm2, dword ptr [rsp+160h+src+8]
    vmovss  xmm7, dword ptr [rsp+160h+src+4]
    vmovss  xmm6, dword ptr [rsp+160h+dst+4]
    vmulss  xmm0, xmm2, xmm6
    vmulss  xmm2, xmm2, dword ptr [rsp+160h+dst]
    vmulss  xmm1, xmm7, xmm5
    vsubss  xmm1, xmm1, xmm0
    vmulss  xmm0, xmm5, dword ptr [rsp+160h+src]
    vmovss  [rsp+160h+var_F4], xmm1
    vsubss  xmm1, xmm2, xmm0
    vmulss  xmm2, xmm6, dword ptr [rsp+160h+src]
    vmulss  xmm0, xmm7, dword ptr [rsp+160h+dst]
    vmovss  [rsp+160h+var_F0], xmm1
    vsubss  xmm1, xmm2, xmm0
    vmovss  [rsp+160h+var_EC], xmm1
  }
  pHoldrand[0] = level.time;
  BG_srand(pHoldrand);
  v47 = Com_GameMode_SupportsFeature(WEAPON_DROPPING|0x80);
  __asm
  {
    vmovaps xmm7, [rsp+160h+var_28+8]
    vmovaps xmm6, xmmword ptr [rsp+160h+var_18+8]
  }
  if ( v47 )
  {
    _RBX = DCONST_DVARFLT_bg_bulletLongHitScanDistance;
    if ( !DCONST_DVARFLT_bg_bulletLongHitScanDistance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_bulletLongHitScanDistance") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBX);
    __asm { vmovss  xmm0, dword ptr [rbx+28h] }
  }
  else
  {
    __asm { vmovss  xmm0, cs:__real@46000000 }
  }
  __asm
  {
    vmovss  [rsp+160h+var_120], xmm0
    vmovss  xmm0, cs:__real@43b40000
    vmovss  dword ptr [rsp+160h+var_130], xmm0
    vxorps  xmm1, xmm1, xmm1; spreadMin
    vmovss  dword ptr [rsp+160h+var_138], xmm1
    vmovaps xmm2, xmm8; spreadMax
  }
  G_Bullet_Endpos(pHoldrand, *(float *)&_XMM1, *(float *)&_XMM2, &end, &dir, v57, v58, &src, v59);
  Scr_AddVector(scrContext, end.v);
  _R11 = &vars0;
  __asm { vmovaps xmm8, xmmword ptr [r11-30h] }
}

/*
==============
Scr_SightTracePassed
==============
*/
void Scr_SightTracePassed(scrContext_t *scrContext)
{
  int number; 
  int v4; 
  int contentmask; 
  int NumParam; 
  bool v8; 
  vec3_t vectorValue; 
  vec3_t start; 

  number = 2047;
  v4 = 2047;
  contentmask = 41965571;
  Scr_GetVector(scrContext, 0, &start);
  Scr_GetVector(scrContext, 1u, &vectorValue);
  if ( !Scr_GetInt(scrContext, 2u) )
    contentmask = 8394755;
  if ( Scr_GetType(scrContext, 3u) == VAR_POINTER && Scr_GetPointerType(scrContext, 3u) == VAR_ENTITY )
    number = GScr_GetEntity(3u)->s.number;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam > 4 && Scr_GetType(scrContext, 4u) == VAR_POINTER && Scr_GetPointerType(scrContext, 4u) == VAR_ENTITY )
    v4 = GScr_GetEntity(4u)->s.number;
  if ( NumParam > 5 && Scr_GetType(scrContext, 5u) == VAR_INTEGER && Scr_GetInt(scrContext, 5u) )
    contentmask &= ~2u;
  v8 = G_Main_SightTrace(&start, &vectorValue, number, v4, contentmask);
  if ( v8 && (unsigned __int8)Com_GameMode_GetActiveGameMode() == HALF )
  {
    __asm { vmovaps [rsp+88h+var_28], xmm6 }
    if ( SV_IsDemoPlaying() )
    {
      *(double *)&_XMM0 = SV_DemoSP_GetFxVisibility();
      __asm { vmovaps xmm6, xmm0 }
    }
    else
    {
      if ( !Com_GameMode_SupportsFeature(WEAPON_FIRING) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\effectscore\\fx_system_api_inline.h", 118, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::CLIENT_SERVER_SHARED_MEMORY ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::CLIENT_SERVER_SHARED_MEMORY )") )
        __debugbreak();
      *(double *)&_XMM0 = FX_GetClientVisibility(fx_serverVisClient, &start, &vectorValue);
      __asm { vmovaps xmm6, xmm0 }
      SV_DemoSP_RecordFxVisibility(*(float *)&_XMM0);
    }
    __asm
    {
      vcomiss xmm6, cs:__real@3e4ccccd
      vmovaps xmm6, [rsp+88h+var_28]
    }
  }
  Scr_AddBool(scrContext, v8);
}

/*
==============
PlayerCmd_SetSoundSubmix
==============
*/

void __fastcall PlayerCmd_SetSoundSubmix(scrContext_t *scrContext, scr_entref_t entref, double _XMM2_8)
{
  unsigned int entnum; 
  unsigned int NumParam; 
  const char *String; 
  const char *v10; 
  unsigned int v11; 
  const char *v12; 
  const char *v13; 
  const char *v14; 
  char v15; 
  const char *v22; 
  const char *v24; 
  char v27; 
  char v28; 
  const char *v36; 
  char *fmt; 
  char *fmta; 
  double v40; 
  int outControllingClientNum; 

  entnum = entref.entnum;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam - 1 > 2 )
  {
    Scr_Error(COM_ERR_4818, scrContext, "SetSoundSubmix: Incorrect number of parameters - expect: duckname [,fadeTime [,scale]]\n");
  }
  else
  {
    String = Scr_GetString(scrContext, 0);
    v10 = String;
    if ( (!String || !*String) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 30171, ASSERT_TYPE_ASSERT, "(duckName && duckName[0])", (const char *)&queryFormat, "duckName && duckName[0]") )
      __debugbreak();
    v11 = SND_HashName(v10);
    if ( !v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 30173, ASSERT_TYPE_ASSERT, "(duckHash != static_cast< SndStringHash >( 0 ))", (const char *)&queryFormat, "duckHash != SND_INVALID_HASH") )
      __debugbreak();
    if ( SND_GetDuckById(v11) )
    {
      if ( SV_GetAgentControlledByPlayerNum(entnum, &outControllingClientNum) )
        entnum = outControllingClientNum;
      if ( (int)entnum < level.maxclients )
      {
        if ( NumParam == 1 )
        {
          v14 = j_va("%c %c %x", 90i64, 48i64, v11);
          SV_Game_SendServerCommand(entnum, SV_CMD_RELIABLE, v14);
        }
        else
        {
          __asm
          {
            vmovaps [rsp+68h+var_28], xmm6
            vmovaps [rsp+68h+var_38], xmm7
          }
          *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
          __asm
          {
            vxorps  xmm7, xmm7, xmm7
            vcomiss xmm0, xmm7
            vmovaps xmm6, xmm0
          }
          if ( !v27 )
            goto LABEL_20;
          __asm { vucomiss xmm0, cs:__real@bf800000 }
          if ( v15 )
          {
LABEL_20:
            if ( NumParam == 2 )
            {
              __asm
              {
                vcvtss2sd xmm0, xmm6, xmm6
                vmovsd  [rsp+68h+fmt], xmm0
              }
              v24 = j_va("%c %c %x %f", NumParam + 88, NumParam + 47, v11, *(double *)&fmt);
            }
            else
            {
              *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
              __asm { vcomiss xmm0, xmm7 }
              if ( v27 )
                goto LABEL_28;
              __asm { vcomiss xmm0, cs:__real@3f800000 }
              if ( !(v27 | v28) )
              {
LABEL_28:
                __asm
                {
                  vmovsd  xmm3, cs:__real@3ff0000000000000
                  vcvtss2sd xmm7, xmm0, xmm0
                  vmovaps xmm1, xmm7
                  vxorpd  xmm2, xmm2, xmm2
                  vmovq   rdx, xmm1
                  vmovq   r9, xmm3
                  vmovq   r8, xmm2
                }
                v36 = j_va("SetSoundSubmix: Incorrect scale parameters %.2f- expect [%.2f,%.2f])\n", _RDX, _R8, _R9);
                Scr_Error(COM_ERR_5929, scrContext, v36);
              }
              else
              {
                __asm { vcvtss2sd xmm7, xmm0, xmm0 }
              }
              __asm
              {
                vcvtss2sd xmm0, xmm6, xmm6
                vmovsd  [rsp+68h+var_40], xmm7
                vmovsd  [rsp+68h+fmt], xmm0
              }
              v24 = j_va("%c %c %x %f %f", 90i64, 50i64, v11, *(double *)&fmta, v40);
            }
            SV_Game_SendServerCommand(entnum, SV_CMD_RELIABLE, v24);
          }
          else
          {
            __asm
            {
              vmovsd  xmm2, cs:__real@bff0000000000000
              vcvtss2sd xmm1, xmm6, xmm0
              vmovq   r8, xmm2
              vmovq   rdx, xmm1
            }
            v22 = j_va("SetSoundSubmix: Incorrect fadeTime parameters %.2f- expect >= 0 (or %.2f for asset default)\n", _RDX, _R8);
            Scr_Error(COM_ERR_5928, scrContext, v22);
          }
          __asm
          {
            vmovaps xmm6, [rsp+68h+var_28]
            vmovaps xmm7, [rsp+68h+var_38]
          }
        }
      }
      else
      {
        v13 = j_va("Invalid entity index %d before SV_Game_SendServerCommand\n", entnum);
        Scr_Error(COM_ERR_6419, scrContext, v13);
      }
    }
    else
    {
      v12 = j_va("SetSoundSubmix: bad duck name: '%s'", v10);
      Scr_ParamError(COM_ERR_4819, scrContext, 0, v12);
    }
  }
}

/*
==============
Scr_PhysicsTrace
==============
*/
void Scr_PhysicsTrace(scrContext_t *scrContext)
{
  vec3_t vectorValue; 
  vec3_t end; 
  float value[4]; 
  trace_t results; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &end);
  G_Main_TraceCapsule(&results, &vectorValue, &end, &bounds_origin, 2047, 131089);
  __asm
  {
    vmovss  xmm5, [rsp+0D8h+results.fraction]
    vmovss  xmm0, dword ptr [rsp+0D8h+end]
    vsubss  xmm1, xmm0, dword ptr [rsp+0D8h+vectorValue]
    vmulss  xmm1, xmm1, xmm5
    vaddss  xmm0, xmm1, dword ptr [rsp+0D8h+vectorValue]
    vmovss  xmm1, dword ptr [rsp+0D8h+end+4]
    vmovss  [rsp+0D8h+value], xmm0
    vsubss  xmm0, xmm1, dword ptr [rsp+0D8h+vectorValue+4]
    vmulss  xmm2, xmm0, xmm5
    vaddss  xmm3, xmm2, dword ptr [rsp+0D8h+vectorValue+4]
    vmovss  xmm0, dword ptr [rsp+0D8h+end+8]
    vsubss  xmm1, xmm0, dword ptr [rsp+0D8h+vectorValue+8]
    vmulss  xmm2, xmm1, xmm5
    vmovss  [rsp+0D8h+var_84], xmm3
    vaddss  xmm3, xmm2, dword ptr [rsp+0D8h+vectorValue+8]
    vmovss  [rsp+0D8h+var_80], xmm3
  }
  Scr_AddVector(scrContext, value);
}

/*
==============
Scr_PlayerPhysicsTrace
==============
*/
void Scr_PlayerPhysicsTrace(scrContext_t *scrContext)
{
  const Bounds *bounds; 
  gentity_s *Entity; 
  gclient_s *client; 
  gagent_s *agent; 
  int skipEntities; 
  vec3_t vectorValue; 
  vec3_t end; 
  float value[4]; 
  vec3_t overrideAngles; 
  trace_t results; 

  skipEntities = 2047;
  bounds = &playerBox;
  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &end);
  if ( Scr_GetNumParam(scrContext) > 2 && Scr_GetType(scrContext, 2u) )
  {
    Entity = GScr_GetEntity(2u);
    client = Entity->client;
    if ( client )
    {
      bounds = BG_Suit_GetBounds(client->ps.suitIndex, PM_EFF_STANCE_DEFAULT);
    }
    else
    {
      agent = Entity->agent;
      if ( agent )
        bounds = BG_Suit_GetBounds(agent->playerState.suitIndex, PM_EFF_STANCE_DEFAULT);
      else
        Scr_ParamError(COM_ERR_4252, scrContext, 1u, "Entity is not a client or agent.");
    }
  }
  if ( Scr_GetNumParam(scrContext) > 3 && Scr_GetType(scrContext, 3u) )
  {
    Scr_GetVector(scrContext, 3u, &overrideAngles);
    PhysicsQuery_LegacyCapsuleTraceAngles(PHYSICS_WORLD_ID_FIRST, &results, &vectorValue, &end, bounds, &skipEntities, 1, 65553, NULL, 0, &overrideAngles);
  }
  else
  {
    PhysicsQuery_LegacyCapsuleTrace(PHYSICS_WORLD_ID_FIRST, &results, &vectorValue, &end, bounds, &skipEntities, 1, 65553, NULL, 0, NULL, NULL);
  }
  __asm
  {
    vmovss  xmm5, [rbp+20h+results.fraction]
    vmovss  xmm0, dword ptr [rsp+120h+end]
    vsubss  xmm1, xmm0, dword ptr [rsp+120h+vectorValue]
    vmulss  xmm1, xmm1, xmm5
    vaddss  xmm0, xmm1, dword ptr [rsp+120h+vectorValue]
    vmovss  xmm1, dword ptr [rsp+120h+end+4]
    vmovss  [rbp+20h+value], xmm0
    vsubss  xmm0, xmm1, dword ptr [rsp+120h+vectorValue+4]
    vmulss  xmm2, xmm0, xmm5
    vaddss  xmm3, xmm2, dword ptr [rsp+120h+vectorValue+4]
    vmovss  xmm0, dword ptr [rbp+20h+end+8]
    vsubss  xmm1, xmm0, dword ptr [rsp+120h+vectorValue+8]
    vmulss  xmm2, xmm1, xmm5
    vmovss  [rbp+20h+var_94], xmm3
    vaddss  xmm3, xmm2, dword ptr [rsp+120h+vectorValue+8]
    vmovss  [rbp+20h+var_90], xmm3
  }
  Scr_AddVector(scrContext, value);
}

/*
==============
Scr_AIPhysicsTrace
==============
*/
void Scr_AIPhysicsTrace(scrContext_t *scrContext, scr_entref_t entref)
{
  int passEntityNum; 
  const gentity_s *Entity; 
  int NumParam; 
  Bounds *p_box; 
  bool v16; 
  bool v17; 
  int v18; 
  AIScriptedInterface *m_pAI; 
  int contentmask; 
  unsigned __int16 EntityHitId; 
  char v38; 
  const char *v39; 
  scr_string_t stairs; 
  AIWrapper v61; 
  vec3_t end; 
  vec3_t vectorValue; 
  Bounds *bounds; 
  float value[4]; 
  int v67[8]; 
  trace_t results; 
  void *retaddr; 

  _R11 = &retaddr;
  __asm { vmovaps xmmword ptr [r11-48h], xmm6 }
  passEntityNum = entref.entnum;
  Entity = GetEntity(entref);
  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &end);
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam > 3 && (Scr_GetType(scrContext, 2u) == VAR_FLOAT || Scr_GetType(scrContext, 2u) == VAR_INTEGER) && (Scr_GetType(scrContext, 3u) == VAR_FLOAT || Scr_GetType(scrContext, 3u) == VAR_INTEGER) )
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
    __asm { vmovaps xmm6, xmm0 }
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
    __asm
    {
      vmulss  xmm4, xmm0, cs:__real@3f000000
      vaddss  xmm3, xmm4, dword ptr cs:?vec3_origin@@3Tvec3_t@@B+8; vec3_t const vec3_origin
      vmovss  xmm1, dword ptr cs:?vec3_origin@@3Tvec3_t@@B; vec3_t const vec3_origin
      vmovss  xmm2, dword ptr cs:?vec3_origin@@3Tvec3_t@@B+4; vec3_t const vec3_origin
      vmovss  [rbp+0A0h+var_D8], xmm3
      vmovss  [rbp+0A0h+var_E0], xmm1
      vmovss  [rbp+0A0h+var_DC], xmm2
      vmovss  [rbp+0A0h+var_D4], xmm6
      vmovss  [rbp+0A0h+var_D0], xmm6
      vmovss  [rbp+0A0h+var_CC], xmm4
    }
    p_box = (Bounds *)v67;
  }
  else
  {
    p_box = &Entity->r.box;
  }
  bounds = p_box;
  v16 = NumParam <= 4 || Scr_GetInt(scrContext, 4u) != 0;
  v17 = NumParam > 5 && Scr_GetInt(scrContext, 5u) != 0;
  v18 = 33685521;
  if ( NumParam > 6 && BG_ActorOrAgentSystemEnabled() && Scr_GetInt(scrContext, 6u) )
  {
    AIActorInterface::AIActorInterface(&v61.m_actorInterface);
    AIAgentInterface::AIAgentInterface(&v61.m_newAgentInterface);
    v61.m_pAI = NULL;
    v61.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
    AIWrapper::Setup(&v61, Entity);
    m_pAI = v61.m_pAI;
    if ( !v61.m_pAI )
      Scr_Error(COM_ERR_4253, scrContext, "AIPhysicsTrace: arg 6 (bUseActorPhysicsMask) can only be used with a valid actor or agent!");
    v18 = *(_DWORD *)(m_pAI->GetAI(m_pAI) + 2268);
  }
  contentmask = v18 & 0xFDFFBFFF;
  if ( !v16 )
    contentmask = v18;
  G_Main_TraceCapsule(&results, &vectorValue, &end, bounds, passEntityNum, contentmask);
  __asm
  {
    vmovss  xmm5, [rbp+0A0h+results.fraction]
    vmovss  xmm0, dword ptr [rbp+0A0h+end]
    vsubss  xmm1, xmm0, dword ptr [rbp+0A0h+vectorValue]
    vmulss  xmm1, xmm1, xmm5
    vaddss  xmm0, xmm1, dword ptr [rbp+0A0h+vectorValue]
    vmovss  xmm1, dword ptr [rbp+0A0h+end+4]
    vmovss  [rbp+0A0h+value], xmm0
    vsubss  xmm0, xmm1, dword ptr [rbp+0A0h+vectorValue+4]
    vmulss  xmm2, xmm0, xmm5
    vaddss  xmm3, xmm2, dword ptr [rbp+0A0h+vectorValue+4]
    vmovss  xmm0, dword ptr [rbp+0A0h+end+8]
    vsubss  xmm1, xmm0, dword ptr [rbp+0A0h+vectorValue+8]
    vmulss  xmm2, xmm1, xmm5
    vmovss  [rbp+0A0h+var_EC], xmm3
    vaddss  xmm3, xmm2, dword ptr [rbp+0A0h+vectorValue+8]
    vmovss  [rbp+0A0h+var_E8], xmm3
  }
  if ( v17 )
  {
    __asm { vmovaps [rsp+1A0h+var_58+8], xmm7 }
    Scr_MakeArray(scrContext);
    __asm { vmovss  xmm1, [rbp+0A0h+results.fraction]; value }
    Scr_AddFloat(scrContext, *(float *)&_XMM1);
    Scr_AddArrayStringIndexed(scrContext, scr_const.fraction);
    Scr_AddVector(scrContext, value);
    Scr_AddArrayStringIndexed(scrContext, scr_const.position);
    EntityHitId = Trace_GetEntityHitId(&results);
    if ( (unsigned __int16)(EntityHitId - 2046) <= 1u )
      Scr_AddUndefined(scrContext);
    else
      GScr_AddEntity(&g_entities[EntityHitId]);
    Scr_AddArrayStringIndexed(scrContext, scr_const.entity);
    __asm
    {
      vmovss  xmm0, [rbp+0A0h+results.fraction]
      vmovss  xmm7, cs:__real@3f800000
      vcomiss xmm0, xmm7
    }
    if ( v38 )
    {
      Scr_AddVector(scrContext, results.normal.v);
      Scr_AddArrayStringIndexed(scrContext, scr_const.normal);
      v39 = Com_SurfaceTypeToName((results.surfaceFlags >> 19) & 0x3F);
      Scr_AddString(scrContext, v39);
      Scr_AddArrayStringIndexed(scrContext, scr_const.surfacetype);
      if ( (results.surfaceFlags & 0x200) == 0 )
      {
LABEL_32:
        __asm { vmovaps xmm7, [rsp+1A0h+var_58+8] }
        goto LABEL_33;
      }
      Scr_AddBool(scrContext, (results.surfaceFlags & 0x200) != 0);
      stairs = scr_const.stairs;
    }
    else
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rbp+0A0h+end]
        vsubss  xmm4, xmm0, dword ptr [rbp+0A0h+vectorValue]
        vmovss  xmm1, dword ptr [rbp+0A0h+end+4]
        vsubss  xmm5, xmm1, dword ptr [rbp+0A0h+vectorValue+4]
        vmovss  xmm0, dword ptr [rbp+0A0h+end+8]
        vsubss  xmm6, xmm0, dword ptr [rbp+0A0h+vectorValue+8]
        vmulss  xmm0, xmm6, xmm6
        vmulss  xmm2, xmm5, xmm5
        vmulss  xmm1, xmm4, xmm4
        vaddss  xmm3, xmm2, xmm1
        vaddss  xmm2, xmm3, xmm0
        vsqrtss xmm1, xmm2, xmm2
        vcmpless xmm0, xmm1, cs:__real@80000000
        vblendvps xmm0, xmm1, xmm7, xmm0
        vdivss  xmm2, xmm7, xmm0
        vmulss  xmm0, xmm2, xmm4
        vmovss  dword ptr [rbp+0A0h+bounds], xmm0
        vmulss  xmm0, xmm2, xmm6
        vmulss  xmm1, xmm2, xmm5
        vmovss  [rbp+0A0h+var_F8], xmm0
        vmovss  dword ptr [rbp+0A0h+bounds+4], xmm1
      }
      Scr_AddVector(scrContext, (const float *)&bounds);
      Scr_AddArrayStringIndexed(scrContext, scr_const.normal);
      Scr_AddConstString(scrContext, scr_const.none);
      stairs = scr_const.surfacetype;
    }
    Scr_AddArrayStringIndexed(scrContext, stairs);
    goto LABEL_32;
  }
  Scr_AddVector(scrContext, value);
LABEL_33:
  __asm { vmovaps xmm6, [rsp+1A0h+var_48+8] }
}

/*
==============
PlayerCmd_ScaleSoundSubmix
==============
*/

void __fastcall PlayerCmd_ScaleSoundSubmix(scrContext_t *scrContext, scr_entref_t entref, double _XMM2_8)
{
  int entnum; 
  const char *String; 
  const char *v8; 
  unsigned int v9; 
  const char *v10; 
  const char *v11; 
  scrContext_t *v12; 
  ComErrorCode v13; 
  char v14; 
  char v15; 
  const char *v18; 
  char *fmt; 
  int outControllingClientNum; 

  entnum = entref.entnum;
  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    String = Scr_GetString(scrContext, 0);
    v8 = String;
    if ( (!String || !*String) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 30255, ASSERT_TYPE_ASSERT, "(submixName && submixName[0])", (const char *)&queryFormat, "submixName && submixName[0]") )
      __debugbreak();
    v9 = SND_HashName(v8);
    if ( !v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 30257, ASSERT_TYPE_ASSERT, "(submixHash != static_cast< SndStringHash >( 0 ))", (const char *)&queryFormat, "submixHash != SND_INVALID_HASH") )
      __debugbreak();
    if ( !SND_GetDuckById(v9) )
    {
      v10 = j_va("ScaleSoundSubmix: bad submix name: '%s'", v8);
      Scr_ParamError(COM_ERR_4821, scrContext, 0, v10);
      return;
    }
    if ( SV_GetAgentControlledByPlayerNum(entnum, &outControllingClientNum) )
      entnum = outControllingClientNum;
    if ( entnum >= level.maxclients )
    {
      v11 = j_va("Invalid entity index %d before SV_Game_SendServerCommand\n", (unsigned int)entnum);
      v12 = scrContext;
      v13 = COM_ERR_6420;
LABEL_15:
      Scr_Error(v13, v12, v11);
      return;
    }
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
    __asm
    {
      vxorps  xmm1, xmm1, xmm1
      vcomiss xmm0, xmm1
    }
    if ( v14 )
      goto LABEL_19;
    __asm { vcomiss xmm0, cs:__real@3f800000 }
    if ( !(v14 | v15) )
    {
LABEL_19:
      __asm
      {
        vmovsd  xmm3, cs:__real@3ff0000000000000
        vcvtss2sd xmm1, xmm0, xmm0
        vxorpd  xmm2, xmm2, xmm2
        vmovq   r9, xmm3
        vmovq   r8, xmm2
        vmovq   rdx, xmm1
      }
      v11 = j_va("ScaleSoundSubmix: Incorrect scale parameters %.2f- expect [%.2f,%.2f])\n", _RDX, _R8, _R9);
      v12 = scrContext;
      v13 = COM_ERR_5930;
      goto LABEL_15;
    }
    __asm
    {
      vcvtss2sd xmm0, xmm0, xmm0
      vmovsd  [rsp+48h+fmt], xmm0
    }
    v18 = j_va("%c %c %x %f", 90i64, 51i64, v9, *(double *)&fmt);
    SV_Game_SendServerCommand(entnum, SV_CMD_RELIABLE, v18);
  }
  else
  {
    Scr_Error(COM_ERR_4820, scrContext, "ScaleSoundSubmix: Incorrect number of parameters - expect: submixname, scale\n");
  }
}

/*
==============
PlayerCmd_ClearSoundSubmix
==============
*/
void PlayerCmd_ClearSoundSubmix(scrContext_t *scrContext, scr_entref_t entref)
{
  int entnum; 
  unsigned int NumParam; 
  const char *String; 
  unsigned int v8; 
  const char *v9; 
  const char *v10; 
  const char *v11; 
  char v12; 
  char v14; 
  const char *v19; 
  double v21; 
  int outControllingClientNum; 

  entnum = entref.entnum;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam - 1 > 1 )
  {
    Scr_Error(COM_ERR_4822, scrContext, "ClearSoundSubmix: Incorrect number of parameters - expect: duckname [, fadeTime]\n");
  }
  else
  {
    String = Scr_GetString(scrContext, 0);
    v8 = SND_HashName(String);
    if ( !SND_GetDuckById(v8) )
    {
      v9 = j_va("ClearSoundSubmix: bad duck name: '%s'", String);
      Scr_ParamError(COM_ERR_4823, scrContext, 0, v9);
      return;
    }
    if ( SV_GetAgentControlledByPlayerNum(entnum, &outControllingClientNum) )
      entnum = outControllingClientNum;
    if ( entnum >= level.maxclients )
    {
      v10 = j_va("Invalid entity index %d before SV_Game_SendServerCommand\n", (unsigned int)entnum);
      Scr_Error(COM_ERR_6421, scrContext, v10);
      return;
    }
    if ( NumParam == 1 )
    {
      v11 = j_va("%c %c %x", 90i64, 52i64, v8);
    }
    else
    {
      *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
      __asm
      {
        vxorps  xmm1, xmm1, xmm1
        vcomiss xmm0, xmm1
      }
      if ( v14 )
      {
        __asm { vucomiss xmm0, cs:__real@bf800000 }
        if ( !v12 )
        {
          __asm
          {
            vmovsd  xmm2, cs:__real@bff0000000000000
            vcvtss2sd xmm1, xmm0, xmm0
            vmovq   r8, xmm2
            vmovq   rdx, xmm1
          }
          v19 = j_va("ClearSoundSubmix: Incorrect fadeTime parameters %.2f- expect >= 0 (or %.2f for asset default)\n", _RDX, _R8);
          Scr_Error(COM_ERR_5666, scrContext, v19);
          return;
        }
      }
      __asm
      {
        vcvtss2sd xmm0, xmm0, xmm0
        vmovsd  [rsp+48h+var_28], xmm0
      }
      v11 = j_va("%c %c %x %f", 90i64, 55i64, v8, v21);
    }
    SV_Game_SendServerCommand(entnum, SV_CMD_RELIABLE, v11);
  }
}

/*
==============
Scr_AIPhysicsTracePassed
==============
*/
void Scr_AIPhysicsTracePassed(scrContext_t *scrContext, scr_entref_t entref)
{
  int passEntityNum; 
  int v10; 
  int v11; 
  char v16; 
  Bounds bounds; 
  vec3_t end; 
  vec3_t vectorValue; 
  trace_t results; 
  char v24; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-18h], xmm6
    vmovaps xmmword ptr [rax-28h], xmm7
  }
  passEntityNum = entref.entnum;
  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &end);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
  __asm { vmovaps xmm6, xmm0 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
  __asm { vmulss  xmm7, xmm0, cs:__real@3f000000 }
  v10 = 0;
  v11 = Scr_GetNumParam(scrContext) > 4 && Scr_GetInt(scrContext, 4u) == 0;
  __asm
  {
    vmovss  xmm0, dword ptr cs:?vec3_origin@@3Tvec3_t@@B; vec3_t const vec3_origin
    vmovss  xmm1, dword ptr cs:?vec3_origin@@3Tvec3_t@@B+4; vec3_t const vec3_origin
    vaddss  xmm2, xmm7, dword ptr cs:?vec3_origin@@3Tvec3_t@@B+8; vec3_t const vec3_origin
    vmovss  dword ptr [rsp+108h+bounds.midPoint], xmm0
    vmovss  dword ptr [rsp+108h+bounds.midPoint+4], xmm1
    vmovss  dword ptr [rsp+108h+bounds.midPoint+8], xmm2
    vmovss  dword ptr [rsp+108h+bounds.halfSize], xmm6
    vmovss  dword ptr [rsp+108h+bounds.halfSize+4], xmm6
    vmovss  dword ptr [rsp+108h+bounds.halfSize+8], xmm7
  }
  G_Main_TraceCapsule(&results, &vectorValue, &end, &bounds, passEntityNum, (v11 << 25) + 131089);
  __asm
  {
    vmovss  xmm0, [rsp+108h+results.fraction]
    vcomiss xmm0, cs:__real@3f800000
  }
  LOBYTE(v10) = !v16;
  Scr_AddBool(scrContext, v10);
  _R11 = &v24;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
  }
}

/*
==============
Scr_GetGroundPosition
==============
*/
void Scr_GetGroundPosition(scrContext_t *scrContext)
{
  vec3_t *p_vectorValue; 
  __int64 passEntityNum; 
  vec3_t vectorValue; 
  vec3_t start; 
  vec3_t end; 
  float value[4]; 
  Bounds bounds; 
  trace_t results; 
  char vars0; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-18h], xmm6
    vmovaps xmmword ptr [rax-28h], xmm7
  }
  Scr_GetVector(scrContext, 0, &vectorValue);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm
  {
    vmovaps xmm6, xmm0
    vshufps xmm6, xmm6, xmm6, 0
  }
  if ( Scr_GetNumParam(scrContext) <= 2 )
  {
    __asm { vmovss  xmm7, cs:__real@44340000 }
  }
  else
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
    __asm { vmovaps xmm7, xmm0 }
  }
  if ( Scr_GetNumParam(scrContext) <= 3 )
  {
    __asm { vmaxss  xmm4, xmm6, cs:__real@42800000 }
  }
  else
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
    __asm { vmovaps xmm4, xmm0 }
  }
  __asm
  {
    vmovss  xmm1, dword ptr [rsp+120h+vectorValue+8]
    vmovss  xmm3, dword ptr [rsp+120h+vectorValue]
    vmovss  xmm2, dword ptr [rsp+120h+vectorValue+4]
    vsubss  xmm0, xmm1, xmm7
    vmovss  dword ptr [rsp+120h+end+8], xmm0
    vaddss  xmm0, xmm1, xmm4
    vxorps  xmm1, xmm1, xmm1
    vmovss  dword ptr [rsp+120h+bounds.midPoint], xmm1
    vmovss  dword ptr [rsp+120h+bounds.midPoint+4], xmm1
    vmovss  dword ptr [rsp+120h+end], xmm3
    vmovss  dword ptr [rsp+120h+end+4], xmm2
    vmovss  dword ptr [rsp+120h+start], xmm3
    vmovss  dword ptr [rsp+120h+start+4], xmm2
    vmovss  dword ptr [rsp+120h+start+8], xmm0
    vmovups xmmword ptr [rsp+120h+bounds.midPoint+8], xmm6
  }
  G_Main_TraceCapsule(&results, &start, &end, &bounds, 2047, 131089);
  if ( results.startsolid )
  {
    __asm
    {
      vmovss  xmm3, dword ptr [rsp+120h+vectorValue+4]
      vmovss  xmm2, dword ptr [rsp+120h+vectorValue]
      vmovss  xmm0, dword ptr [rsp+120h+vectorValue+8]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+120h+passEntityNum], xmm0
    }
    Com_PrintWarning(23, "GetGroundPosition started in solid at (%g %g %g)\n", _R8, _R9, passEntityNum);
    p_vectorValue = &vectorValue;
  }
  else
  {
    __asm
    {
      vmovss  xmm5, [rbp+20h+results.fraction]
      vmovss  xmm0, dword ptr [rsp+120h+end]
      vsubss  xmm1, xmm0, dword ptr [rsp+120h+start]
      vmulss  xmm1, xmm1, xmm5
      vaddss  xmm0, xmm1, dword ptr [rsp+120h+start]
      vmovss  xmm1, dword ptr [rsp+120h+end+4]
      vmovss  [rsp+120h+value], xmm0
      vsubss  xmm0, xmm1, dword ptr [rsp+120h+start+4]
      vmulss  xmm2, xmm0, xmm5
      vaddss  xmm3, xmm2, dword ptr [rsp+120h+start+4]
      vmovss  xmm0, dword ptr [rsp+120h+end+8]
      vsubss  xmm1, xmm0, dword ptr [rsp+120h+start+8]
      vmulss  xmm2, xmm1, xmm5
      vmovss  [rsp+120h+var_BC], xmm3
      vaddss  xmm3, xmm2, dword ptr [rsp+120h+start+8]
      vmovss  [rsp+120h+var_B8], xmm3
    }
    p_vectorValue = (vec3_t *)value;
  }
  Scr_AddVector(scrContext, p_vectorValue->v);
  _R11 = &vars0;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
  }
}

/*
==============
PlayerCmd_ClearAllSoundSubmixes
==============
*/
void PlayerCmd_ClearAllSoundSubmixes(scrContext_t *scrContext, scr_entref_t entref)
{
  int entnum; 
  int NumParam; 
  const char *v7; 
  const char *v8; 
  const char *v9; 
  SvClient *CommonClient; 
  char v11; 
  char v13; 
  const char *v18; 
  const char *v21; 
  int outControllingClientNum; 

  entnum = entref.entnum;
  if ( SV_GetAgentControlledByPlayerNum(entref.entnum, &outControllingClientNum) )
    entnum = outControllingClientNum;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam <= 2 )
  {
    if ( entnum < level.maxclients )
    {
      if ( NumParam )
      {
        *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
        __asm
        {
          vxorps  xmm1, xmm1, xmm1
          vcomiss xmm0, xmm1
        }
        if ( !v13 )
          goto LABEL_14;
        __asm { vucomiss xmm0, cs:__real@bf800000 }
        if ( v11 )
        {
LABEL_14:
          __asm
          {
            vcvtss2sd xmm3, xmm0, xmm0
            vmovq   r9, xmm3
          }
          v21 = j_va("%c %c %f", 90i64, 54i64, _R9);
          SV_Game_SendServerCommand(entnum, SV_CMD_RELIABLE, v21);
        }
        else
        {
          __asm
          {
            vmovsd  xmm2, cs:__real@bff0000000000000
            vcvtss2sd xmm1, xmm0, xmm0
            vmovq   r8, xmm2
            vmovq   rdx, xmm1
          }
          v18 = j_va("ClearAllSoundSubmixes: Incorrect fadeTime parameters %.2f- expect >= 0 (or %.2f for asset default)\n", _RDX, _R8);
          Scr_Error(COM_ERR_5667, scrContext, v18);
        }
      }
      else
      {
        v8 = j_va("%c %c", 90i64, 53i64);
        v9 = v8;
        if ( entnum == -1 )
        {
          SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v8);
        }
        else
        {
          CommonClient = SvClient::GetCommonClient(entnum);
          CommonClient->SendServerCommand(CommonClient, SV_CMD_RELIABLE, v9);
        }
      }
    }
    else
    {
      v7 = j_va("Invalid entity index %d before SV_Game_SendServerCommand\n", (unsigned int)entnum);
      Scr_Error(COM_ERR_6422, scrContext, v7);
    }
  }
  else
  {
    Scr_Error(COM_ERR_4824, scrContext, "ClearAllSoundSubmixes: Incorrect number of parameters - expect: none or optional [fadeTime]\n");
  }
}

/*
==============
GScr_PhysicsSetGravity
==============
*/
void GScr_PhysicsSetGravity(scrContext_t *scrContext)
{
  unsigned int IndexByName; 
  unsigned int v3; 
  unsigned int v4; 
  unsigned int v5; 
  OmnvarData *Data; 
  vec3_t vectorValue; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4254, scrContext, "Physics_SetGravity takes 1 vector parameter");
  Scr_GetVector(scrContext, 0, &vectorValue);
  IndexByName = BG_Omnvar_GetIndexByName("physics_gravity_x");
  v3 = BG_Omnvar_GetIndexByName("physics_gravity_y");
  v4 = BG_Omnvar_GetIndexByName("physics_gravity_z");
  v5 = v4;
  if ( IndexByName == -1 || v3 == -1 || v4 == -1 )
    Scr_Error(COM_ERR_4255, scrContext, "Physics_SetGravity can't find omnvars - check omnvar.csv");
  _RBP = G_Omnvar_GetData(IndexByName, -1, NULL);
  _RDI = G_Omnvar_GetData(v3, -1, NULL);
  Data = G_Omnvar_GetData(v5, -1, NULL);
  _RSI = Data;
  if ( !_RBP || !_RDI || !Data )
    Scr_Error(COM_ERR_4256, scrContext, "Physics_SetGravity has invalid omnvar data - check omnvar.csv");
  __asm
  {
    vmovss  xmm0, dword ptr [rsp+48h+vectorValue]
    vmovss  dword ptr [rbp+4], xmm0
    vmovss  xmm1, dword ptr [rsp+48h+vectorValue+4]
    vmovss  dword ptr [rdi+4], xmm1
    vmovss  xmm0, dword ptr [rsp+48h+vectorValue+8]
    vmovss  dword ptr [rsi+4], xmm0
  }
  G_Omnvar_MarkChanged(_RBP);
  G_Omnvar_MarkChanged(_RDI);
  G_Omnvar_MarkChanged(_RSI);
}

/*
==============
PlayerCmd_GetSprintMeterFraction
==============
*/

void __fastcall PlayerCmd_GetSprintMeterFraction(scrContext_t *scrContext, scr_entref_t entref, __int64 a3, double _XMM3_8)
{
  unsigned int entnum; 
  gentity_s *v8; 
  const char *v9; 
  const playerState_s *p_ps; 
  const char *v11; 
  GWeaponMap *Instance; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3678, scrContext, "not an entity");
    v8 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 30432, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v8 = &g_entities[entnum];
    if ( !v8->client && !v8->agent )
    {
      v9 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3677, scrContext, v9);
    }
  }
  p_ps = &v8->client->ps;
  if ( !p_ps )
  {
    p_ps = &v8->agent->playerState;
    if ( !p_ps )
    {
      v11 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3679, scrContext, v11);
    }
  }
  Instance = GWeaponMap::GetInstance();
  PM_GetSprintLeftRaw(Instance, p_ps, p_ps->serverTime);
  __asm { vxorps  xmm3, xmm3, xmm3 }
  if ( BG_GetMaxSprintTime(Instance, p_ps) > 0 )
  {
    __asm
    {
      vmovss  xmm2, cs:__real@3f800000; max
      vxorps  xmm1, xmm1, xmm1
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm1, xmm1, edi
      vcvtsi2ss xmm0, xmm0, eax
      vdivss  xmm0, xmm1, xmm0; val
      vxorps  xmm1, xmm1, xmm1; min
    }
    *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
    __asm { vmovaps xmm3, xmm0 }
  }
  __asm { vmovaps xmm1, xmm3; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
GScr_PhysicsSetGravityRagdollScalar
==============
*/
void GScr_PhysicsSetGravityRagdollScalar(scrContext_t *scrContext)
{
  char v6; 
  unsigned int IndexByName; 

  __asm { vmovaps [rsp+38h+var_18], xmm6 }
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4257, scrContext, "Physics_SetGravityRagdollScalar takes 1 vector parameter");
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm
  {
    vandps  xmm1, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcomiss xmm1, cs:__real@3c23d70a
    vmovaps xmm6, xmm0
  }
  if ( v6 )
    Scr_Error(COM_ERR_4258, scrContext, "Physics_SetGravityRagdollScalar doesn't support tiny values between -0.01 and 0.01");
  IndexByName = BG_Omnvar_GetIndexByName("physics_gravity_ragdoll");
  if ( IndexByName == -1 )
    Scr_Error(COM_ERR_4259, scrContext, "Physics_SetGravityRagdollScalar can't find omnvars - check omnvar.csv");
  _RDI = G_Omnvar_GetData(IndexByName, -1, NULL);
  if ( !_RDI )
    Scr_Error(COM_ERR_4260, scrContext, "Physics_SetGravityRagdollScalar has invalid omnvar data - check omnvar.csv");
  __asm
  {
    vmovss  dword ptr [rdi+4], xmm6
    vmovaps xmm6, [rsp+38h+var_18]
  }
  G_Omnvar_MarkChanged(_RDI);
}

/*
==============
Scr_InitDamageParts
==============
*/

void __fastcall Scr_InitDamageParts(scrContext_t *scrContext, scr_entref_t entref)
{
  InitDamageParts(scrContext, entref);
}

/*
==============
Scr_AddDamagePart
==============
*/

void __fastcall Scr_AddDamagePart(scrContext_t *scrContext, scr_entref_t entref)
{
  AddDamagePart(scrContext, entref);
}

/*
==============
ScrCmd_GetCentroid
==============
*/
void ScrCmd_GetCentroid(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  vec3_t outCentroid; 

  Entity = GetEntity(entref);
  G_Utils_EntityCentroid(Entity, &outCentroid);
  Scr_AddVector(scrContext, outCentroid.v);
}

/*
==============
GScr_PhysicsSetGravityDynentScalar
==============
*/
void GScr_PhysicsSetGravityDynentScalar(scrContext_t *scrContext)
{
  char v6; 
  unsigned int IndexByName; 

  __asm { vmovaps [rsp+38h+var_18], xmm6 }
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4261, scrContext, "Physics_SetGravityDynentScalar takes 1 vector parameter");
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm
  {
    vandps  xmm1, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcomiss xmm1, cs:__real@3c23d70a
    vmovaps xmm6, xmm0
  }
  if ( v6 )
    Scr_Error(COM_ERR_4262, scrContext, "Physics_SetGravityDynentScalar doesn't support tiny values between -0.01 and 0.01");
  IndexByName = BG_Omnvar_GetIndexByName("physics_gravity_dynent");
  if ( IndexByName == -1 )
    Scr_Error(COM_ERR_4263, scrContext, "Physics_SetGravityDynentScalar can't find omnvars - check omnvar.csv");
  _RDI = G_Omnvar_GetData(IndexByName, -1, NULL);
  if ( !_RDI )
    Scr_Error(COM_ERR_4264, scrContext, "Physics_SetGravityDynentScalar has invalid omnvar data - check omnvar.csv");
  __asm
  {
    vmovss  dword ptr [rdi+4], xmm6
    vmovaps xmm6, [rsp+38h+var_18]
  }
  G_Omnvar_MarkChanged(_RDI);
}

/*
==============
GScr_SetChargeMeleeHudVisible
==============
*/
void GScr_SetChargeMeleeHudVisible(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  playerState_s *EntityPlayerState; 
  int Int; 
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *p_otherFlags; 

  Entity = GetEntity(entref);
  if ( !Entity )
    Scr_ObjectError(COM_ERR_4825, scrContext, "SetChargeMeleeHudVisible() must be called on a valid entity");
  EntityPlayerState = G_GetEntityPlayerState(Entity);
  if ( !EntityPlayerState )
  {
    Scr_ObjectError(COM_ERR_4826, scrContext, "SetChargeMeleeHudVisible() must be called on a player or agent");
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 30538, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
  }
  Int = Scr_GetInt(scrContext, 0);
  p_otherFlags = &EntityPlayerState->otherFlags;
  if ( Int )
    GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal(p_otherFlags, ACTIVE, 0x13u);
  else
    GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal(p_otherFlags, ACTIVE, 0x13u);
}

/*
==============
GScr_PhysicsSetGravityParticleScalar
==============
*/
void GScr_PhysicsSetGravityParticleScalar(scrContext_t *scrContext)
{
  char v6; 
  unsigned int IndexByName; 

  __asm { vmovaps [rsp+38h+var_18], xmm6 }
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4265, scrContext, "Physics_SetGravityParticleScalar takes 1 vector parameter");
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm
  {
    vandps  xmm1, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcomiss xmm1, cs:__real@3c23d70a
    vmovaps xmm6, xmm0
  }
  if ( v6 )
    Scr_Error(COM_ERR_4266, scrContext, "Physics_SetGravityParticleScalar doesn't support tiny values between -0.01 and 0.01");
  IndexByName = BG_Omnvar_GetIndexByName("physics_gravity_particle");
  if ( IndexByName == -1 )
    Scr_Error(COM_ERR_4267, scrContext, "Physics_SetGravityParticleScalar can't find omnvars - check omnvar.csv");
  _RDI = G_Omnvar_GetData(IndexByName, -1, NULL);
  if ( !_RDI )
    Scr_Error(COM_ERR_4268, scrContext, "Physics_SetGravityParticleScalar has invalid omnvar data - check omnvar.csv");
  __asm
  {
    vmovss  dword ptr [rdi+4], xmm6
    vmovaps xmm6, [rsp+38h+var_18]
  }
  G_Omnvar_MarkChanged(_RDI);
}

/*
==============
GScr_Main_RagdollBlendInit
==============
*/
void GScr_Main_RagdollBlendInit(scrContext_t *scrContext, scr_entref_t entref)
{
  ;
}

/*
==============
ScrCmd_GetDebugEye
==============
*/
void ScrCmd_GetDebugEye(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  const sentient_s *sentient; 
  const char *v6; 
  const char *v7; 
  vec3_t vEyePosOut; 

  Entity = GetEntity(entref);
  v4 = Entity;
  sentient = Entity->sentient;
  if ( !sentient )
  {
    v6 = SL_ConvertToString(Entity->classname);
    v7 = j_va("getDebugEye must be called on an AI or player, not on a '%s'", v6);
    Scr_Error(COM_ERR_4827, scrContext, v7);
    sentient = v4->sentient;
  }
  Sentient_GetDebugEyePosition(sentient, &vEyePosOut);
  Scr_AddVector(scrContext, vEyePosOut.v);
}

/*
==============
GScr_PhysicsSetGravityItemScalar
==============
*/
void GScr_PhysicsSetGravityItemScalar(scrContext_t *scrContext)
{
  char v6; 

  __asm { vmovaps [rsp+38h+var_18], xmm6 }
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4269, scrContext, "Physics_SetGravityItemScalar takes 1 vector parameter");
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm
  {
    vandps  xmm1, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vcomiss xmm1, cs:__real@3c23d70a
    vmovaps xmm6, xmm0
  }
  if ( v6 )
    Scr_Error(COM_ERR_4270, scrContext, "Physics_SetGravityItemScalar doesn't support tiny values between -0.01 and 0.01");
  __asm
  {
    vmovaps xmm2, xmm6; scalar
    vmovaps xmm6, [rsp+38h+var_18]
  }
  HavokPhysics_UpdateGravityScalar(PHYSICS_WORLD_ID_FIRST, Physics_GravityType_Item, *(float *)&_XMM2);
}

/*
==============
ScrCmd_GetPlayerLightLevel
==============
*/
void ScrCmd_GetPlayerLightLevel(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  __int16 number; 
  const char *v6; 

  Entity = GetEntity(entref);
  if ( !Entity->client )
    Scr_Error(COM_ERR_4828, scrContext, "GetPlayerLightLevel not called on player character.");
  if ( SV_BotIsBot(Entity->s.number) )
    Scr_Error(COM_ERR_4829, scrContext, "GetPlayerLightLevel cannot be called on a player bot.");
  number = Entity->s.number;
  if ( Entity->s.number >= 24 )
  {
    v6 = j_va("GetPlayerLightLevel only supports %i players (requested for %i)", 24i64, (unsigned int)number);
    Scr_Error(COM_ERR_4830, scrContext, v6);
    number = Entity->s.number;
  }
  *(double *)&_XMM0 = G_LightSampler_GetNormalized(number);
  __asm { vmovaps xmm1, xmm0; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
ScrCmd_DoEntitiesShareHierarchy
==============
*/
void ScrCmd_DoEntitiesShareHierarchy(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  const gentity_s *v3; 
  bool v4; 

  Entity = GScr_GetEntity(0);
  v3 = GScr_GetEntity(1u);
  v4 = GUtils::AreEntsInSameLinkTree(Entity, v3);
  Scr_AddBool(scrContext, v4);
}

/*
==============
Scr_RandomInt
==============
*/
void Scr_RandomInt(scrContext_t *scrContext)
{
  int Int; 
  int v3; 

  Int = Scr_GetInt(scrContext, 0);
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4271, scrContext, "RandomInt takes 1 parameter");
  if ( Int > 0 )
  {
    v3 = G_irand(0, Int);
    Scr_AddInt(scrContext, v3);
  }
  else
  {
    Com_Printf(23, "RandomInt parm: %d  ", (unsigned int)Int);
    Scr_Error(COM_ERR_4272, scrContext, "RandomInt parm must be positive integer.\n");
  }
}

/*
==============
ScrCmd_MotionWarp
==============
*/
void ScrCmd_MotionWarp(scrContext_t *scrContext, scr_entref_t entref)
{
  int entnum; 
  int Int; 
  const char *v5; 
  vec3_t targetAngles; 
  vec3_t vectorValue; 

  entnum = entref.entnum;
  if ( Scr_GetNumParam(scrContext) != 3 )
    Scr_Error(COM_ERR_4831, scrContext, "Incorrect number of parameters.");
  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &targetAngles);
  Int = Scr_GetInt(scrContext, 2u);
  if ( !level.frameDuration && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_level_locals.h", 349, ASSERT_TYPE_ASSERT, "(level.frameDuration)", "%s\n\tAccessing frame duration before it's been set", "level.frameDuration") )
    __debugbreak();
  if ( Int < level.frameDuration )
  {
    v5 = j_va("Motion warp duration (%i ms) must be at least one frame (%i ms).", (unsigned int)Int, (unsigned int)level.frameDuration);
    Scr_Error(COM_ERR_4832, scrContext, v5);
  }
  if ( G_MotionWarp_TrackerIsFull() )
    Scr_Error(COM_ERR_4833, scrContext, "Max tracked entities exceeded.");
  else
    G_MotionWarp_Start(entnum, &vectorValue, &targetAngles, Int);
}

/*
==============
Scr_RandomFloat
==============
*/
void Scr_RandomFloat(scrContext_t *scrContext)
{
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4273, scrContext, "RandomFloat takes 1 parameter");
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm
  {
    vmovaps xmm1, xmm0; max
    vxorps  xmm0, xmm0, xmm0; min
  }
  *(double *)&_XMM0 = G_flrand(*(float *)&_XMM0, *(float *)&_XMM1);
  __asm { vmovaps xmm1, xmm0; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
Scr_RandomIntRange
==============
*/
void Scr_RandomIntRange(scrContext_t *scrContext)
{
  int Int; 
  int v3; 
  int v4; 
  int v5; 

  Int = Scr_GetInt(scrContext, 0);
  v3 = Scr_GetInt(scrContext, 1u);
  v4 = v3;
  if ( v3 <= Int )
  {
    Com_Printf(23, "RandomIntRange parms: %d %d ", (unsigned int)Int, (unsigned int)v3);
    Scr_Error(COM_ERR_4274, scrContext, "RandomIntRange's second parameter must be greater than the first.\n");
  }
  v5 = G_irand(Int, v4);
  Scr_AddInt(scrContext, v5);
}

/*
==============
ScrCmd_MotionWarpWithAnim
==============
*/
void ScrCmd_MotionWarpWithAnim(scrContext_t *scrContext, scr_entref_t entref)
{
  int entnum; 
  int duration; 
  const char *v5; 
  vec3_t targetAngles; 
  vec3_t targetPos; 
  vec3_t animStartAngles; 
  vec3_t vectorValue; 

  entnum = entref.entnum;
  if ( Scr_GetNumParam(scrContext) != 5 )
    Scr_Error(COM_ERR_4834, scrContext, "Incorrect number of parameters.");
  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &animStartAngles);
  Scr_GetVector(scrContext, 2u, &targetPos);
  Scr_GetVector(scrContext, 3u, &targetAngles);
  duration = Scr_GetInt(scrContext, 4u);
  if ( !level.frameDuration && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_level_locals.h", 349, ASSERT_TYPE_ASSERT, "(level.frameDuration)", "%s\n\tAccessing frame duration before it's been set", "level.frameDuration") )
    __debugbreak();
  if ( duration < level.frameDuration )
  {
    v5 = j_va("Motion warp duration (%i ms) must be at least one frame (%i ms).", (unsigned int)duration, (unsigned int)level.frameDuration);
    Scr_Error(COM_ERR_4835, scrContext, v5);
  }
  if ( G_MotionWarp_TrackerIsFull() )
    Scr_Error(COM_ERR_4836, scrContext, "Max tracked entities exceeded.");
  else
    G_MotionWarp_StartWithAnim(entnum, &vectorValue, &animStartAngles, &targetPos, &targetAngles, duration);
}

/*
==============
Scr_RandomFloatRange
==============
*/
void Scr_RandomFloatRange(scrContext_t *scrContext)
{
  char v7; 
  char v8; 

  __asm
  {
    vmovaps [rsp+48h+var_18], xmm6
    vmovaps [rsp+48h+var_28], xmm7
  }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm { vmovaps xmm6, xmm0 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm
  {
    vcomiss xmm0, xmm6
    vmovaps xmm7, xmm0
  }
  if ( v7 | v8 )
  {
    __asm
    {
      vcvtss2sd xmm3, xmm7, xmm0
      vcvtss2sd xmm2, xmm6, xmm6
      vmovq   r9, xmm3
      vmovq   r8, xmm2
    }
    Com_Printf(23, "Scr_RandomFloatRange parms: %f %f ", *(double *)&_XMM2, *(double *)&_XMM3);
    Scr_Error(COM_ERR_4275, scrContext, "Scr_RandomFloatRange's second parameter must be greater than the first.\n");
  }
  __asm
  {
    vmovaps xmm1, xmm7; max
    vmovaps xmm0, xmm6; min
  }
  *(double *)&_XMM0 = G_flrand(*(float *)&_XMM0, *(float *)&_XMM1);
  __asm
  {
    vmovaps xmm1, xmm0; value
    vmovaps xmm6, [rsp+48h+var_18]
    vmovaps xmm7, [rsp+48h+var_28]
  }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
GScr_IsPointInVolume
==============
*/
void GScr_IsPointInVolume(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  unsigned int Instance; 
  int v4; 
  vec3_t vectorValue; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  Entity = GScr_GetEntity(1u);
  Instance = G_PhysicsObject_GetInstance(PHYSICS_WORLD_ID_FIRST, Entity);
  v4 = PhysicsQuery_LegacyEntityContactPoint(PHYSICS_WORLD_ID_FIRST, &vectorValue, Instance, Entity);
  Scr_AddInt(scrContext, v4);
}

/*
==============
ScrCmd_MotionWarpCancel
==============
*/
void ScrCmd_MotionWarpCancel(scrContext_t *scrContext, scr_entref_t entref)
{
  G_MotionWarp_Cancel(entref.entnum);
}

/*
==============
ScrCmd_IsNearAnyPlayer
==============
*/
void ScrCmd_IsNearAnyPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  int v5; 
  __int64 v8; 
  __int64 v22; 
  __int64 v23; 

  __asm { vmovaps [rsp+88h+var_48], xmm6 }
  GetEntity(entref);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  v5 = 0;
  __asm { vmulss  xmm6, xmm0, xmm0 }
  if ( level.maxclients > 0 )
  {
    _RSI = 0i64;
    v8 = 0i64;
    do
    {
      if ( (unsigned int)v5 >= 0x800 )
      {
        LODWORD(v23) = 2048;
        LODWORD(v22) = v5;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v22, v23) )
          __debugbreak();
      }
      if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
        __debugbreak();
      if ( g_entities[_RSI].r.isInUse != g_entityIsInUse[v8] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
        __debugbreak();
      if ( g_entityIsInUse[v8] )
      {
        _RAX = g_entities;
        __asm
        {
          vmovss  xmm0, dword ptr [rsi+rax+130h]
          vsubss  xmm3, xmm0, dword ptr [r14+130h]
          vmovss  xmm1, dword ptr [rsi+rax+134h]
          vsubss  xmm2, xmm1, dword ptr [r14+134h]
          vmovss  xmm0, dword ptr [rsi+rax+138h]
          vsubss  xmm4, xmm0, dword ptr [r14+138h]
          vmulss  xmm2, xmm2, xmm2
          vmulss  xmm1, xmm3, xmm3
          vmulss  xmm0, xmm4, xmm4
          vaddss  xmm3, xmm2, xmm1
          vaddss  xmm2, xmm3, xmm0
          vcomiss xmm2, xmm6
        }
      }
      ++v5;
      ++v8;
      ++_RSI;
    }
    while ( v5 < level.maxclients );
  }
  __asm { vmovaps xmm6, [rsp+88h+var_48] }
  Scr_AddBool(scrContext, 0);
}

/*
==============
GScr_UseTriggerRequireLookAt
==============
*/
void GScr_UseTriggerRequireLookAt(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t classname; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    Entity = GetEntity(entref);
    if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 12563, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
      __debugbreak();
    classname = Entity->classname;
    if ( classname != scr_const.trigger_use && classname != scr_const.trigger_use_touch )
      Scr_Error(COM_ERR_4277, scrContext, "The UseTriggerRequireLookAt command only works on trigger_use and trigger_use_touch entities.\n");
    Entity->c.trigger.requireLookAt = Scr_GetInt(scrContext, 0) != 0;
  }
  else
  {
    Scr_Error(COM_ERR_4276, scrContext, "USAGE: <trigger_use|trigger_use_touch> UseTriggerRequireLookAt( <bool> )\n");
  }
}

/*
==============
GScr_Turret_SetDismountOrg
==============
*/
void GScr_Turret_SetDismountOrg(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v6; 
  const char *v7; 
  vec3_t vectorValue; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v6 = SL_ConvertToString(Entity->classname);
    v7 = j_va("entity type '%s' is not a turret", v6);
    Scr_Error(COM_ERR_4837, scrContext, v7);
  }
  _RAX = GTurret::GetTurret(p_turretHandle);
  __asm
  {
    vmovss  xmm0, dword ptr [rsp+48h+vectorValue]
    vmovss  dword ptr [rax+3Ch], xmm0
    vmovss  xmm1, dword ptr [rsp+48h+vectorValue+4]
    vmovss  dword ptr [rax+40h], xmm1
    vmovss  xmm0, dword ptr [rsp+48h+vectorValue+8]
    vmovss  dword ptr [rax+44h], xmm0
  }
}

/*
==============
GScr_GetGroundEntity
==============
*/
void GScr_GetGroundEntity(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  playerState_s *EntityPlayerState; 
  signed __int16 GroundEntNum; 
  AIWrapper v6; 

  Entity = GetEntity(entref);
  EntityPlayerState = G_GetEntityPlayerState(Entity);
  AIActorInterface::AIActorInterface(&v6.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v6.m_newAgentInterface);
  v6.m_pAI = NULL;
  v6.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AIWrapper::Setup(&v6, Entity);
  if ( v6.m_pAI )
  {
    GroundEntNum = AIScriptedInterface::GetGroundEntNum(v6.m_pAI);
  }
  else
  {
    if ( !EntityPlayerState )
    {
LABEL_11:
      Scr_AddUndefined(scrContext);
      return;
    }
    GroundEntNum = EntityPlayerState->groundEntityNum;
  }
  if ( GroundEntNum == 2047 || !G_IsEntityInUse(GroundEntNum) )
    goto LABEL_11;
  if ( (unsigned __int16)GroundEntNum >= 0x800u && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 30954, ASSERT_TYPE_ASSERT, "(unsigned)( groundEntityNum ) < (unsigned)( ( 2048 ) )", "groundEntityNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", GroundEntNum, 2048) )
    __debugbreak();
  GScr_AddEntity(&g_entities[GroundEntNum]);
}

/*
==============
Scr_PrecacheModel
==============
*/
void Scr_PrecacheModel(scrContext_t *scrContext)
{
  const char *String; 
  int CompositeModelIndex; 
  const XCompositeModelDef *CompositeModel; 

  if ( NetConstStrings_IsPrecacheAllowed() )
  {
    if ( !level.initializing )
      Scr_Error(COM_ERR_4279, scrContext, "precacheModel must be called before any wait statements in the gametype or level script\n");
    String = Scr_GetString(scrContext, 0);
    if ( !*String )
      Scr_ParamError(COM_ERR_4280, scrContext, 0, "Model name string is empty");
    if ( !GUtils::ms_gUtils && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_utils.h", 112, ASSERT_TYPE_ASSERT, "( ms_gUtils )", (const char *)&queryFormat, "ms_gUtils") )
      __debugbreak();
    if ( GUtils::ms_gUtils->IsTransientCustomizationModel(GUtils::ms_gUtils, String) )
      Scr_Error(COM_ERR_4281, scrContext, "Can't precache transient models");
    if ( G_Utils_IsNameCompositeModel(String) )
    {
      CompositeModelIndex = G_CString_GetCompositeModelIndex(String);
      CompositeModel = G_Utils_GetCompositeModel(CompositeModelIndex);
      if ( CompositeModel )
        G_XCompositeModel_PrecacheModels(CompositeModel);
    }
    else
    {
      Scr_ErrorOnDefaultAsset(scrContext, ASSET_TYPE_XMODEL, String);
      if ( !GConfigStrings::ms_gConfigStrings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_configstrings.h", 71, ASSERT_TYPE_ASSERT, "( ms_gConfigStrings )", (const char *)&queryFormat, "ms_gConfigStrings") )
        __debugbreak();
      GConfigStrings::GetModelIndex(GConfigStrings::ms_gConfigStrings, String);
    }
  }
}

/*
==============
Scr_PrecacheCompositeModel
==============
*/
void Scr_PrecacheCompositeModel(scrContext_t *scrContext)
{
  const char *String; 
  int CompositeModelIndex; 
  const XCompositeModelDef *CompositeModel; 

  if ( NetConstStrings_IsPrecacheAllowed() )
  {
    if ( !level.initializing )
      Scr_Error(COM_ERR_4282, scrContext, "precacheCompositeModel must be called before any wait statements in the gametype or level script\n");
    String = Scr_GetString(scrContext, 0);
    if ( !*String )
      Scr_ParamError(COM_ERR_4283, scrContext, 0, "Model name string is empty");
    CompositeModelIndex = G_CString_GetCompositeModelIndex(String);
    CompositeModel = G_Utils_GetCompositeModel(CompositeModelIndex);
    if ( CompositeModel )
      G_XCompositeModel_PrecacheModels(CompositeModel);
  }
}

/*
==============
GScr_IsEntityWithinCone
==============
*/
void GScr_IsEntityWithinCone(scrContext_t *scrContext, scr_entref_t entref)
{
  int NumParam; 
  gentity_s *Entity; 
  char v81; 
  char v82; 
  int v107; 
  vec3_t coneDir; 
  Bounds bounds; 
  vec3_t vectorValue; 
  tmat33_t<vec3_t> axis; 
  char v122; 

  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam < 3 )
    Scr_Error(COM_ERR_4838, scrContext, "Incorrect number of parameters.");
  Entity = GetEntity(entref);
  if ( Entity )
  {
    __asm
    {
      vmovaps [rsp+160h+var_30], xmm6
      vmovaps [rsp+160h+var_40], xmm7
      vmovaps [rsp+160h+var_50], xmm8
      vmovaps [rsp+160h+var_60], xmm9
      vmovaps [rsp+160h+var_70], xmm10
      vmovaps [rsp+160h+var_80], xmm11
      vmovaps [rsp+160h+var_90], xmm12
      vmovaps [rsp+160h+var_A0], xmm13
      vmovaps [rsp+160h+var_B0], xmm14
    }
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
    __asm { vmulss  xmm0, xmm0, cs:__real@3c8efa35; X }
    *(float *)&_XMM0 = cosf_0(*(float *)&_XMM0);
    __asm { vmovaps xmm14, xmm0 }
    Scr_GetVector(scrContext, 0, &vectorValue);
    Scr_GetVector(scrContext, 1u, &coneDir);
    AnglesToAxis(&Entity->r.currentAngles, &axis);
    _RSI = (char *)&Entity->r.box;
    if ( &bounds == &Entity->r.box && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\bounds_inline.h", 218, ASSERT_TYPE_ASSERT, "( rotatedBounds != baseBounds )", (const char *)&queryFormat, "rotatedBounds != baseBounds") )
      __debugbreak();
    if ( _RSI == &v122 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_math.h", 470, ASSERT_TYPE_SANITY, "( &in1 != &out )", (const char *)&queryFormat, "&in1 != &out") )
      __debugbreak();
    __asm
    {
      vmovss  xmm4, dword ptr [rsi+4]
      vmovss  xmm3, dword ptr [rsi]
      vmovss  xmm5, dword ptr [rsi+8]
      vmovss  xmm7, dword ptr [rsp+160h+axis+0Ch]
      vmovss  xmm8, dword ptr [rbp+60h+axis+18h]
      vmovss  xmm9, dword ptr [rsp+160h+axis+4]
      vmovss  xmm10, dword ptr [rsp+160h+axis+10h]
      vmovss  xmm11, dword ptr [rbp+60h+axis+1Ch]
      vmovss  xmm12, dword ptr [rsp+160h+axis+8]
      vmovss  xmm13, dword ptr [rsp+160h+axis+14h]
      vmovss  xmm6, dword ptr [rsp+160h+axis]
      vmulss  xmm0, xmm4, xmm7
      vmulss  xmm1, xmm3, xmm6
      vaddss  xmm2, xmm1, xmm0
      vmulss  xmm1, xmm5, xmm8
      vaddss  xmm0, xmm2, xmm1
      vaddss  xmm2, xmm0, dword ptr [rbx+130h]
      vmovss  dword ptr [rsp+160h+bounds.midPoint], xmm2
      vmulss  xmm0, xmm4, xmm10
      vmulss  xmm1, xmm3, xmm9
      vaddss  xmm2, xmm1, xmm0
      vmulss  xmm1, xmm5, xmm11
      vaddss  xmm0, xmm2, xmm1
      vaddss  xmm2, xmm0, dword ptr [rbx+134h]
      vmovss  dword ptr [rsp+160h+bounds.midPoint+4], xmm2
      vmulss  xmm0, xmm4, xmm13
      vmovss  xmm4, dword ptr [rbp+60h+axis+20h]
      vmulss  xmm1, xmm3, xmm12
      vmovss  xmm3, dword ptr cs:__xmm@7fffffff7fffffff7fffffff7fffffff
      vaddss  xmm2, xmm1, xmm0
      vmulss  xmm1, xmm5, xmm4
      vaddss  xmm0, xmm2, xmm1
      vaddss  xmm2, xmm0, dword ptr [rbx+138h]
      vmovss  dword ptr [rsp+160h+bounds.midPoint+8], xmm2
      vandps  xmm7, xmm7, xmm3
      vmulss  xmm0, xmm7, dword ptr [rsi+10h]
      vmovaps xmm7, [rsp+160h+var_40]
      vandps  xmm8, xmm8, xmm3
      vandps  xmm9, xmm9, xmm3
      vandps  xmm10, xmm10, xmm3
      vandps  xmm11, xmm11, xmm3
      vandps  xmm12, xmm12, xmm3
      vandps  xmm13, xmm13, xmm3
      vandps  xmm6, xmm6, xmm3
      vmulss  xmm1, xmm6, dword ptr [rsi+0Ch]
      vaddss  xmm2, xmm1, xmm0
      vmulss  xmm0, xmm8, dword ptr [rsi+14h]
      vmovaps xmm8, [rsp+160h+var_50]
      vaddss  xmm1, xmm2, xmm0
      vmovss  dword ptr [rsp+160h+bounds.halfSize], xmm1
      vmulss  xmm1, xmm9, dword ptr [rsi+0Ch]
      vmovaps xmm9, [rsp+160h+var_60]
      vmulss  xmm0, xmm10, dword ptr [rsi+10h]
      vmovaps xmm10, [rsp+160h+var_70]
      vaddss  xmm2, xmm1, xmm0
      vmulss  xmm0, xmm11, dword ptr [rsi+14h]
      vmovaps xmm11, [rsp+160h+var_80]
      vaddss  xmm1, xmm2, xmm0
      vmovss  dword ptr [rsp+160h+bounds.halfSize+4], xmm1
      vmulss  xmm1, xmm12, dword ptr [rsi+0Ch]
      vmovaps xmm12, [rsp+160h+var_90]
      vmulss  xmm0, xmm13, dword ptr [rsi+10h]
      vmovaps xmm13, [rsp+160h+var_A0]
      vaddss  xmm2, xmm1, xmm0
      vandps  xmm4, xmm4, xmm3
      vmulss  xmm0, xmm4, dword ptr [rsi+14h]
      vaddss  xmm1, xmm2, xmm0
      vmovss  dword ptr [rsp+160h+bounds.halfSize+8], xmm1
    }
    if ( NumParam < 4 )
      goto LABEL_15;
    if ( Scr_GetType(scrContext, 3u) == VAR_UNDEFINED )
      goto LABEL_15;
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
    __asm
    {
      vxorps  xmm1, xmm1, xmm1
      vcomiss xmm0, xmm1
      vmovaps xmm6, xmm0
    }
    if ( v81 | v82 )
      goto LABEL_15;
    __asm
    {
      vmovss  xmm1, dword ptr [rsp+160h+vectorValue]
      vsubss  xmm4, xmm1, dword ptr [rsp+160h+bounds.midPoint]
      vmovss  xmm2, dword ptr [rsp+160h+vectorValue+4]
      vsubss  xmm3, xmm2, dword ptr [rsp+160h+bounds.midPoint+4]
      vmovss  xmm1, dword ptr [rsp+160h+vectorValue+8]
      vsubss  xmm5, xmm1, dword ptr [rsp+160h+bounds.midPoint+8]
      vmulss  xmm3, xmm3, xmm3
      vmulss  xmm2, xmm4, xmm4
      vaddss  xmm4, xmm3, xmm2
      vmovss  xmm2, dword ptr [rsp+160h+bounds.halfSize]
      vmulss  xmm3, xmm2, xmm2
      vmovss  xmm2, dword ptr [rsp+160h+bounds.halfSize+8]
      vmulss  xmm1, xmm5, xmm5
      vaddss  xmm0, xmm4, xmm1
      vsqrtss xmm5, xmm0, xmm0
      vmovss  xmm0, dword ptr [rsp+160h+bounds.halfSize+4]
      vmulss  xmm1, xmm0, xmm0
      vaddss  xmm4, xmm3, xmm1
      vmulss  xmm0, xmm2, xmm2
      vaddss  xmm1, xmm4, xmm0
      vsqrtss xmm3, xmm1, xmm1
      vsubss  xmm2, xmm5, xmm3
      vcomiss xmm2, xmm6
    }
    if ( v81 | v82 )
    {
LABEL_15:
      __asm
      {
        vmovss  xmm2, dword ptr [rsp+160h+coneDir+4]
        vmovss  xmm3, dword ptr cs:__xmm@80000000800000008000000080000000
        vmovss  xmm0, dword ptr [rsp+160h+coneDir]
        vxorps  xmm1, xmm0, xmm3
        vxorps  xmm0, xmm2, xmm3
        vmovss  dword ptr [rsp+160h+coneDir], xmm1
        vmovss  xmm1, dword ptr [rsp+160h+coneDir+8]
        vxorps  xmm2, xmm1, xmm3
        vmovss  dword ptr [rsp+160h+coneDir+8], xmm2
        vmovaps xmm2, xmm14; cosHalfFov
        vmovss  dword ptr [rsp+160h+coneDir+4], xmm0
      }
      v107 = !CullBoxFromCone(&vectorValue, &coneDir, *(float *)&_XMM2, &bounds);
    }
    else
    {
      v107 = 0;
    }
    Scr_AddBool(scrContext, v107);
    __asm
    {
      vmovaps xmm6, [rsp+160h+var_30]
      vmovaps xmm14, [rsp+160h+var_B0]
    }
  }
}

/*
==============
GScr_PrecacheSuit
==============
*/
void GScr_PrecacheSuit(scrContext_t *scrContext)
{
  const char *String; 

  String = Scr_GetString(scrContext, 0);
  Com_Printf(15, "PreCacheSuit() is deprecated, suits automatically register. Please delete this script call (%s)\n", String);
}

/*
==============
ScrCmd_StopLoopSound
==============
*/
void ScrCmd_StopLoopSound(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  Entity->r.svFlags &= ~1u;
  Entity->s.loopSound = 0;
}

/*
==============
GScr_CameraDefault
==============
*/
void GScr_CameraDefault(scrContext_t *scrContext, scr_entref_t entref)
{
  gclient_s *client; 
  int cameraTypeIndex; 
  const CameraDef *Def; 

  client = GScr_Main_GetPlayerEntity(scrContext, entref)->client;
  cameraTypeIndex = client->ps.cameraTypeIndex;
  if ( cameraTypeIndex && cameraTypeIndex < 256 && (unsigned int)(cameraTypeIndex - 1) < 0xFA )
  {
    Def = BG_Camera_GetDef(cameraTypeIndex);
    if ( !Def && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31070, ASSERT_TYPE_ASSERT, "(camDef)", (const char *)&queryFormat, "camDef") )
      __debugbreak();
    if ( Def->behaveAsRemoteCont )
      GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(&client->ps.pm_flags, ACTIVE, 0x1Cu);
  }
  client->ps.cameraTypeIndex = 0;
}

/*
==============
ScrCmd_PlayRumbleOnEntity
==============
*/
void ScrCmd_PlayRumbleOnEntity(scrContext_t *scrContext, scr_entref_t entref)
{
  ScrCmd_PlayRumbleOnEntity_Internal(scrContext, entref, 148);
}

/*
==============
ScrCmd_PlayRumbleLoopOnEntity
==============
*/
void ScrCmd_PlayRumbleLoopOnEntity(scrContext_t *scrContext, scr_entref_t entref)
{
  ScrCmd_PlayRumbleOnEntity_Internal(scrContext, entref, 150);
}

/*
==============
GScr_CameraSet
==============
*/
void GScr_CameraSet(scrContext_t *scrContext, scr_entref_t entref)
{
  gclient_s *client; 
  scr_string_t ConstString; 
  const char *v5; 
  const char *v6; 
  unsigned int v7; 
  const CameraDef *Def; 
  __int64 v9; 
  unsigned int outIndex; 

  client = GScr_Main_GetPlayerEntity(scrContext, entref)->client;
  ConstString = Scr_GetConstString(scrContext, 0);
  if ( !ConstString && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31101, ASSERT_TYPE_ASSERT, "(camera != ( static_cast< scr_string_t >( 0 ) ))", (const char *)&queryFormat, "camera != NULL_SCR_STRING") )
    __debugbreak();
  v5 = SL_ConvertToString(ConstString);
  if ( !v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31104, ASSERT_TYPE_ASSERT, "(cameraName)", (const char *)&queryFormat, "cameraName") )
    __debugbreak();
  outIndex = 0;
  if ( BG_Camera_GetDefIndex(v5, &outIndex) )
  {
    v7 = outIndex;
    if ( !CameraType_Is_Def(outIndex) )
    {
      LODWORD(v9) = v7;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31112, ASSERT_TYPE_ASSERT, "( CameraType_Is_Def( cameraDefIndex ) )", "Camera index (%d) does not reference an asset def or there are more than %d camera assets", v9, 250) )
        __debugbreak();
      v7 = outIndex;
    }
    client->ps.cameraTypeIndex = v7;
    Def = BG_Camera_GetDef(outIndex);
    if ( !Def && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31117, ASSERT_TYPE_ASSERT, "(camDef)", (const char *)&queryFormat, "camDef") )
      __debugbreak();
    if ( Def->behaveAsRemoteCont )
      GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::SetFlagInternal(&client->ps.pm_flags, ACTIVE, 0x1Cu);
  }
  else
  {
    v6 = j_va("Camera name not found (%s). Call CameraDefault() if you want to disable a camera.\n", v5);
    Scr_Error(COM_ERR_6091, scrContext, v6);
  }
}

/*
==============
Scr_PlayRumbleOnPosition
==============
*/
void Scr_PlayRumbleOnPosition(scrContext_t *scrContext)
{
  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_ParamError(COM_ERR_4287, scrContext, 0, "PlayRumbleOnPosition [rumble name] [pos]");
  Scr_PlayRumbleOnPosition_Internal(scrContext, 149);
}

/*
==============
Scr_PlayRumbleLoopOnPosition
==============
*/
void Scr_PlayRumbleLoopOnPosition(scrContext_t *scrContext)
{
  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_ParamError(COM_ERR_4288, scrContext, 0, "PlayRumbleLoopOnPosition [rumble name] [pos]");
  Scr_PlayRumbleOnPosition_Internal(scrContext, 151);
}

/*
==============
Scr_PlayRumbleOnPositionForClient
==============
*/
void Scr_PlayRumbleOnPositionForClient(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  gentity_s *v6; 
  unsigned int number; 
  unsigned int *v8; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 12888, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_ParamError(COM_ERR_4289, scrContext, 0, "PlayRumbleOnPositionForClient [rumble name] [pos]");
  v6 = Scr_PlayRumbleOnPosition_Internal(scrContext, 149);
  *(_QWORD *)v6->clientMask.array = -1i64;
  *(_QWORD *)&v6->clientMask.array[2] = -1i64;
  *(_QWORD *)&v6->clientMask.array[4] = -1i64;
  v6->clientMask.array[6] = -1;
  number = v4->s.number;
  if ( number >= 0xE0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 290, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", number, 224) )
    __debugbreak();
  v8 = &v6->clientMask.array[(unsigned __int64)number >> 5];
  *v8 &= ~(0x80000000 >> (number & 0x1F));
}

/*
==============
Scr_PlayRumbleLoopOnPositionForClient
==============
*/
void Scr_PlayRumbleLoopOnPositionForClient(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  gentity_s *v6; 
  unsigned int number; 
  unsigned int *v8; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 12920, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_ParamError(COM_ERR_4290, scrContext, 0, "PlayRumbleLoopOnPositionForClient [rumble name] [pos]");
  v6 = Scr_PlayRumbleOnPosition_Internal(scrContext, 151);
  *(_QWORD *)v6->clientMask.array = -1i64;
  *(_QWORD *)&v6->clientMask.array[2] = -1i64;
  *(_QWORD *)&v6->clientMask.array[4] = -1i64;
  v6->clientMask.array[6] = -1;
  number = v4->s.number;
  if ( number >= 0xE0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 290, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", number, 224) )
    __debugbreak();
  v8 = &v6->clientMask.array[(unsigned __int64)number >> 5];
  *v8 &= ~(0x80000000 >> (number & 0x1F));
}

/*
==============
ScrCmd_GetBoundsHalfSize
==============
*/
void ScrCmd_GetBoundsHalfSize(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31138, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  Scr_AddVector(scrContext, Entity->r.box.halfSize.v);
}

/*
==============
Scr_StopAllRumbles
==============
*/
void Scr_StopAllRumbles(scrContext_t *scrContext)
{
  gentity_s *v3; 
  vec3_t origin; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmovss  dword ptr [rsp+48h+origin], xmm0
    vmovss  dword ptr [rsp+48h+origin+4], xmm0
    vmovss  dword ptr [rsp+48h+origin+8], xmm0
  }
  v3 = G_Utils_SpawnEventEntity(&origin, 153);
  v3->s.eventParm2 = 0;
  v3->s.eventParm = 0;
}

/*
==============
ScrCmd_StopRumble
==============
*/
void ScrCmd_StopRumble(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *String; 
  const char *v5; 
  gclient_s *client; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *p_eFlags; 
  unsigned int outIndex; 

  Entity = GetEntity(entref);
  String = Scr_GetString(scrContext, 0);
  if ( !NetConstStrings_GetIndexFromName(NETCONSTSTRINGTYPE_RUMBLE, String, &outIndex) )
  {
    v5 = j_va("unknown rumble name '%s'", String);
    Scr_ParamError(COM_ERR_4291, scrContext, 0, v5);
  }
  Entity->r.svFlags &= ~1u;
  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    client = Entity->client;
    if ( client )
      p_eFlags = &client->ps.eFlags;
    else
      p_eFlags = &Entity->s.lerp.eFlags;
    GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(p_eFlags, GameModeFlagValues::ms_mpValue, 0x17u);
    G_Utils_AddEvent(Entity, 0x98u, outIndex);
  }
  else
  {
    Scr_Error(COM_ERR_4292, scrContext, "USAGE: StopRumble( <rumblename> )  The rumble name is required.\n");
  }
}

/*
==============
ScrCmd_GetBoundsMidPoint
==============
*/
void ScrCmd_GetBoundsMidPoint(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31156, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  Scr_AddVector(scrContext, Entity->r.box.midPoint.v);
}

/*
==============
GScr_TriggerEnable
==============
*/
void GScr_TriggerEnable(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *v4; 
  scr_string_t classname; 

  Entity = GetEntity(entref);
  v4 = (GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *)Entity;
  if ( Entity )
  {
    classname = Entity->classname;
    if ( classname == scr_const.trigger || classname == scr_const.trigger_progress || classname == scr_const.trigger_use || classname == scr_const.trigger_use_touch || classname == scr_const.trigger_damage || classname == scr_const.trigger_multiple || classname == scr_const.trigger_disk || classname == scr_const.trigger_hurt || classname == scr_const.trigger_once || classname == scr_const.trigger_radius || classname == scr_const.trigger_rotatable_radius )
      GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(v4 + 3, ACTIVE, 0);
    else
      Scr_Error(COM_ERR_4845, scrContext, "EnableTriggerForPlayer was not called on an entity of trigger type.");
  }
  else
  {
    Scr_Error(COM_ERR_4844, scrContext, "TriggerEnable was not called on an entity.");
  }
}

/*
==============
GScr_WeaponClipSize
==============
*/
void GScr_WeaponClipSize(scrContext_t *scrContext)
{
  int ClipSize; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  ClipSize = BG_GetClipSize(NULL, &outWeapon, outIsAlternate);
  Scr_AddInt(scrContext, ClipSize);
}

/*
==============
GScr_WeaponGetDamageMax
==============
*/
void GScr_WeaponGetDamageMax(scrContext_t *scrContext)
{
  int Damage; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  Damage = BG_GetDamage(WEAP_DMG_CALC_TYPE_DEFAULT, &outWeapon, outIsAlternate);
  Scr_AddInt(scrContext, Damage);
}

/*
==============
GScr_TriggerDisable
==============
*/
void GScr_TriggerDisable(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *v4; 
  scr_string_t classname; 

  Entity = GetEntity(entref);
  v4 = (GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *)Entity;
  if ( Entity )
  {
    classname = Entity->classname;
    if ( classname == scr_const.trigger || classname == scr_const.trigger_progress || classname == scr_const.trigger_use || classname == scr_const.trigger_use_touch || classname == scr_const.trigger_damage || classname == scr_const.trigger_multiple || classname == scr_const.trigger_disk || classname == scr_const.trigger_hurt || classname == scr_const.trigger_once || classname == scr_const.trigger_radius || classname == scr_const.trigger_rotatable_radius )
      GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(v4 + 3, ACTIVE, 0);
    else
      Scr_Error(COM_ERR_4847, scrContext, "TriggerDisable was not called on an entity of trigger type.");
  }
  else
  {
    Scr_Error(COM_ERR_4846, scrContext, "TriggerDisable was not called on an entity.");
  }
}

/*
==============
GScr_GetGrenadeFuseTime
==============
*/
void GScr_GetGrenadeFuseTime(scrContext_t *scrContext)
{
  int v2; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( !BG_IsOffhandWeaponType(&outWeapon, outIsAlternate) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 13069, ASSERT_TYPE_ASSERT, "(BG_IsOffhandWeaponType( weapon, isAlternate ))", "%s\n\tWeapon param for GetGrenadeFuseTime( <weapon name> ) must be of type offhand", "BG_IsOffhandWeaponType( weapon, isAlternate )") )
    __debugbreak();
  v2 = BG_WeaponFuseTime(&outWeapon, outIsAlternate);
  Scr_AddInt(scrContext, v2);
}

/*
==============
GScr_IsTriggerEnabled
==============
*/
void GScr_IsTriggerEnabled(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *v4; 
  scr_string_t classname; 
  bool v6; 

  Entity = GetEntity(entref);
  v4 = (GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *)Entity;
  if ( Entity )
  {
    classname = Entity->classname;
    if ( classname == scr_const.trigger || classname == scr_const.trigger_progress || classname == scr_const.trigger_use || classname == scr_const.trigger_use_touch || classname == scr_const.trigger_damage || classname == scr_const.trigger_multiple || classname == scr_const.trigger_disk || classname == scr_const.trigger_hurt || classname == scr_const.trigger_once || classname == scr_const.trigger_radius || classname == scr_const.trigger_rotatable_radius )
    {
      v6 = GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(v4 + 3, ACTIVE, 0);
      Scr_AddInt(scrContext, !v6);
    }
    else
    {
      Scr_Error(COM_ERR_4849, scrContext, "IsTriggerEnabled was not called on an entity of trigger type.");
    }
  }
  else
  {
    Scr_Error(COM_ERR_4848, scrContext, "IsTriggerEnabled was not called on an entity.");
  }
}

/*
==============
GScr_GetGrenadeFuseTimeAI
==============
*/
void GScr_GetGrenadeFuseTimeAI(scrContext_t *scrContext)
{
  int v2; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( !BG_IsOffhandWeaponType(&outWeapon, outIsAlternate) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 13091, ASSERT_TYPE_ASSERT, "(BG_IsOffhandWeaponType( weapon, isAlternate ))", "%s\n\tWeapon param for GetGrenadeFuseTimeAI( <weapon name> ) must be of type offhand", "BG_IsOffhandWeaponType( weapon, isAlternate )") )
    __debugbreak();
  v2 = BG_WeaponAIFuseTime(&outWeapon, outIsAlternate);
  Scr_AddInt(scrContext, v2);
}

/*
==============
GScr_Skydive_BeginFreefall
==============
*/
void GScr_Skydive_BeginFreefall(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v16; 
  playerState_s *EntityPlayerState; 
  char *fmt; 

  entnum = entref.entnum;
  _RDI = GetEntity(entref);
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31297, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( G_Utils_IsClient(_RDI) )
  {
    EntityPlayerState = G_GetEntityPlayerState(_RDI);
    if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31306, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
      __debugbreak();
    GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::SetFlagInternal(&EntityPlayerState->pm_flags, ACTIVE, 0x2Fu);
  }
  else
  {
    targetname = _RDI->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(_RDI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rdi+134h]
      vmovss  xmm2, dword ptr [rdi+130h]
      vmovss  xmm0, dword ptr [rdi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+48h+fmt], xmm0
    }
    v16 = j_va("Skydive_BeginFreefall(). Only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, fmt, v7, v6);
    Scr_Error(COM_ERR_4850, scrContext, v16);
  }
}

/*
==============
GScr_GetGrenadeDamageRadius
==============
*/
void GScr_GetGrenadeDamageRadius(scrContext_t *scrContext)
{
  int v2; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( !BG_IsOffhandWeaponType(&outWeapon, outIsAlternate) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 13113, ASSERT_TYPE_ASSERT, "(BG_IsOffhandWeaponType( weapon, isAlternate ))", "%s\n\tWeapon param for GetGrenadeDamageRadius( <weapon name> ) must be of type offhand", "BG_IsOffhandWeaponType( weapon, isAlternate )") )
    __debugbreak();
  v2 = BG_ExplosionRadius(&outWeapon, outIsAlternate);
  Scr_AddInt(scrContext, v2);
}

/*
==============
GScr_WeaponGetDamageMin
==============
*/
void GScr_WeaponGetDamageMin(scrContext_t *scrContext)
{
  int MinDamage; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  MinDamage = BG_GetMinDamage(WEAP_DMG_CALC_TYPE_DEFAULT, &outWeapon, outIsAlternate);
  Scr_AddInt(scrContext, MinDamage);
}

/*
==============
GScr_Skydive_DeployParachute
==============
*/
void GScr_Skydive_DeployParachute(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v16; 
  playerState_s *EntityPlayerState; 
  char *fmt; 

  entnum = entref.entnum;
  _RDI = GetEntity(entref);
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31325, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( G_Utils_IsClient(_RDI) )
  {
    EntityPlayerState = G_GetEntityPlayerState(_RDI);
    if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31334, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
      __debugbreak();
    GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::SetFlagInternal(&EntityPlayerState->pm_flags, ACTIVE, 0x30u);
  }
  else
  {
    targetname = _RDI->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(_RDI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rdi+134h]
      vmovss  xmm2, dword ptr [rdi+130h]
      vmovss  xmm0, dword ptr [rdi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+48h+fmt], xmm0
    }
    v16 = j_va("Skydive_DeployParachute(). Only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, fmt, v7, v6);
    Scr_Error(COM_ERR_4851, scrContext, v16);
  }
}

/*
==============
ScrCmd_ItemWeaponSetAmmo
==============
*/
void ScrCmd_ItemWeaponSetAmmo(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  int v5; 
  int v6; 
  int v7; 
  const char *v8; 
  char *v9; 
  bool v10; 
  int ClipSize; 
  int v12; 

  Entity = GetEntity(entref);
  if ( Entity->s.eType != ET_ITEM )
    Scr_Error(COM_ERR_4293, scrContext, "Entity is not an item.");
  Int = Scr_GetInt(scrContext, 0);
  if ( Int < 0 )
    Scr_ParamError(COM_ERR_4294, scrContext, 0, "Ammo count must not be negative");
  v5 = Scr_GetInt(scrContext, 1u);
  if ( v5 < 0 )
    Scr_ParamError(COM_ERR_4295, scrContext, 1u, "Ammo count must not be negative");
  v6 = Int;
  if ( Scr_GetNumParam(scrContext) > 2 )
  {
    v6 = Scr_GetInt(scrContext, 2u);
    if ( v6 < 0 )
      Scr_ParamError(COM_ERR_4296, scrContext, 2u, "Ammo count must not be negative");
  }
  v7 = 0;
  if ( Scr_GetNumParam(scrContext) > 3 )
  {
    v7 = Scr_GetInt(scrContext, 3u);
    if ( (unsigned int)v7 > 1 )
    {
      v8 = j_va("Value out of range.  Allowed values: 0 to %i", 2i64);
      Scr_ParamError(COM_ERR_4297, scrContext, 3u, v8);
    }
  }
  v9 = (char *)Entity + 80 * v7;
  if ( *((_WORD *)v9 + 230) )
  {
    v10 = v7 != 0;
    if ( BG_GetClipSize(NULL, (const Weapon *)(v9 + 460), v10) < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 13210, ASSERT_TYPE_ASSERT, "(BG_GetClipSize( 0, r_weapon, altEntityIndex != 0 ) >= 0)", (const char *)&queryFormat, "BG_GetClipSize( NULL, r_weapon, altEntityIndex != 0 ) >= 0") )
      __debugbreak();
    ClipSize = BG_GetClipSize(NULL, (const Weapon *)(v9 + 460), v10);
    *((_DWORD *)v9 + 112) = v5;
    if ( Int < ClipSize )
      ClipSize = Int;
    *((_DWORD *)v9 + 113) = ClipSize;
    if ( v9[520] )
    {
      v12 = BG_GetClipSize(NULL, (const Weapon *)(v9 + 460), v10);
      if ( v6 < v12 )
        v12 = v6;
      *((_DWORD *)v9 + 114) = v12;
    }
  }
}

/*
==============
GScr_Skydive_SetDeploymentStatus
==============
*/
void GScr_Skydive_SetDeploymentStatus(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v16; 
  playerState_s *EntityPlayerState; 
  int Int; 
  GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64> *p_pm_flags; 
  char *fmt; 

  entnum = entref.entnum;
  _RDI = GetEntity(entref);
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31354, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( G_Utils_IsClient(_RDI) )
  {
    if ( Scr_GetNumParam(scrContext) )
    {
      EntityPlayerState = G_GetEntityPlayerState(_RDI);
      if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31369, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
        __debugbreak();
      Int = Scr_GetInt(scrContext, 0);
      p_pm_flags = &EntityPlayerState->pm_flags;
      if ( Int )
      {
        GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::SetFlagInternal(p_pm_flags, ACTIVE, 0x32u);
        EntityPlayerState->skydivePlayerState.flagsExtra[0] &= ~0x20u;
      }
      else
      {
        GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(p_pm_flags, ACTIVE, 0x32u);
        EntityPlayerState->skydivePlayerState.flagsExtra[0] |= 0x20u;
      }
    }
    else
    {
      Scr_Error(COM_ERR_4853, scrContext, "Missing parameter: player Skydive_SetDeploymentStatus( <enabled> );");
    }
  }
  else
  {
    targetname = _RDI->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(_RDI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rdi+134h]
      vmovss  xmm2, dword ptr [rdi+130h]
      vmovss  xmm0, dword ptr [rdi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+48h+fmt], xmm0
    }
    v16 = j_va("Skydive_SetDeploymentStatus(). Only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, fmt, v7, v6);
    Scr_Error(COM_ERR_4852, scrContext, v16);
  }
}

/*
==============
GScr_GetAmmoCount
==============
*/
void GScr_GetAmmoCount(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const playerState_s *p_ps; 
  const char *v6; 
  ComErrorCode v7; 
  GWeaponMap *Instance; 
  int v9; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 13240, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  p_ps = &v4->client->ps;
  if ( !p_ps )
  {
    p_ps = &v4->agent->playerState;
    if ( !p_ps )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v7, scrContext, v6);
      p_ps = NULL;
    }
  }
  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  Instance = GWeaponMap::GetInstance();
  v9 = BG_WeaponAmmo(Instance, p_ps, &outWeapon, outIsAlternate);
  Scr_AddInt(scrContext, v9);
}

/*
==============
GScr_Skydive_SetBaseJumpingStatus
==============
*/
void GScr_Skydive_SetBaseJumpingStatus(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v16; 
  playerState_s *EntityPlayerState; 
  int Int; 
  GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64> *p_pm_flags; 
  char *fmt; 

  entnum = entref.entnum;
  _RDI = GetEntity(entref);
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31398, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( G_Utils_IsClient(_RDI) )
  {
    if ( Scr_GetNumParam(scrContext) )
    {
      EntityPlayerState = G_GetEntityPlayerState(_RDI);
      if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31413, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
        __debugbreak();
      Int = Scr_GetInt(scrContext, 0);
      p_pm_flags = &EntityPlayerState->pm_flags;
      if ( Int )
        GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::SetFlagInternal(p_pm_flags, ACTIVE, 0x34u);
      else
        GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(p_pm_flags, ACTIVE, 0x34u);
    }
    else
    {
      Scr_Error(COM_ERR_5933, scrContext, "Missing parameter: player GScr_Skydive_SetBaseJumpingStatus( <enabled> );");
    }
  }
  else
  {
    targetname = _RDI->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(_RDI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rdi+134h]
      vmovss  xmm2, dword ptr [rdi+130h]
      vmovss  xmm0, dword ptr [rdi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+48h+fmt], xmm0
    }
    v16 = j_va("GScr_Skydive_SetBaseJumpingStatus(). Only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, fmt, v7, v6);
    Scr_Error(COM_ERR_5932, scrContext, v16);
  }
}

/*
==============
GScr_GetAmmoType
==============
*/
void GScr_GetAmmoType(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  ComErrorCode v6; 
  scr_string_t primary; 
  bool outIsAlternate; 
  AmmoStore result; 
  Weapon outWeapon; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v5 = "not an entity";
    v6 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 13264, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  if ( !v4->client && !v4->agent )
  {
    v5 = j_va("entity %i is not a player or agent", entnum);
    v6 = COM_ERR_3679;
LABEL_9:
    Scr_ObjectError(v6, scrContext, v5);
  }
  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  _RAX = BG_AmmoStoreForWeapon(&result, &outWeapon, outIsAlternate);
  primary = scr_const.primary;
  __asm
  {
    vmovups ymm1, ymmword ptr [rax+20h]
    vextractf128 xmm0, ymm1, 1
    vpextrd rax, xmm0, 3
  }
  if ( (_DWORD)_RAX )
    primary = scr_const.alternate;
  Scr_AddConstString(scrContext, primary);
}

/*
==============
GScr_Skydive_Interrupt
==============
*/
void GScr_Skydive_Interrupt(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v16; 
  playerState_s *EntityPlayerState; 
  GWeaponMap *Instance; 
  char *fmt; 

  entnum = entref.entnum;
  _RDI = GetEntity(entref);
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31439, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( G_Utils_IsClient(_RDI) )
  {
    EntityPlayerState = G_GetEntityPlayerState(_RDI);
    if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31448, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
      __debugbreak();
    if ( EntityPlayerState->skydivePlayerState.state[0] )
    {
      EntityPlayerState->skydivePlayerState.state[0] = 0;
      EntityPlayerState->skydivePlayerState.animState = 0;
      EntityPlayerState->skydivePlayerState.flagsExtra[0] = 0;
    }
    if ( (unsigned int)(EntityPlayerState->weapState[0].weaponState - 63) <= 0xC )
    {
      EntityPlayerState->weapState[0].weaponTime = 0;
      Instance = GWeaponMap::GetInstance();
      BG_SetWeaponDelay(Instance, EntityPlayerState, WEAPON_HAND_DEFAULT, 0, NULL);
      EntityPlayerState->weapState[0].weaponState = 0;
      PM_StartWeaponAnim(EntityPlayerState, WEAP_IDLE, WEAPON_HAND_DEFAULT);
    }
    if ( EntityPlayerState->cameraTypeIndex == 251 )
      EntityPlayerState->cameraTypeIndex = 0;
    if ( EntityPlayerState->cameraTypeIndex == BG_Camera_GetSkydiveOrbitDefIndex() )
      EntityPlayerState->cameraTypeIndex = 0;
  }
  else
  {
    targetname = _RDI->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(_RDI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rdi+134h]
      vmovss  xmm2, dword ptr [rdi+130h]
      vmovss  xmm0, dword ptr [rdi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+48h+fmt], xmm0
    }
    v16 = j_va("Skydive_Interrupt(). Only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, fmt, v7, v6);
    Scr_Error(COM_ERR_5934, scrContext, v16);
  }
}

/*
==============
GScr_WeaponIsImpaling
==============
*/
void GScr_WeaponIsImpaling(scrContext_t *scrContext)
{
  bool IsImpalingBullet; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  IsImpalingBullet = BG_IsImpalingBullet(&outWeapon, outIsAlternate);
  Scr_AddBool(scrContext, IsImpalingBullet);
}

/*
==============
GScr_WeaponIsAuto
==============
*/
void GScr_WeaponIsAuto(scrContext_t *scrContext)
{
  int v2; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  v2 = BG_GetWeaponFireType(&outWeapon, outIsAlternate) == WEAPON_FIRETYPE_FULLAUTO && BG_GetWeaponType(&outWeapon, outIsAlternate) == WEAPTYPE_BULLET;
  Scr_AddInt(scrContext, v2);
}

/*
==============
GScr_WeaponIsBeam
==============
*/
void GScr_WeaponIsBeam(scrContext_t *scrContext)
{
  weapFireType_t WeaponFireType; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  WeaponFireType = BG_GetWeaponFireType(&outWeapon, outIsAlternate);
  Scr_AddInt(scrContext, WeaponFireType == WEAPON_FIRETYPE_BEAM);
}

/*
==============
GScr_WeaponIsSemiAuto
==============
*/
void GScr_WeaponIsSemiAuto(scrContext_t *scrContext)
{
  weapFireType_t WeaponFireType; 
  int v3; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  WeaponFireType = BG_GetWeaponFireType(&outWeapon, outIsAlternate);
  v3 = ((WeaponFireType - 1) & 0xFFFFFFFC) == 0 && WeaponFireType != WEAPON_FIRETYPE_BURST && BG_GetWeaponType(&outWeapon, outIsAlternate) == WEAPTYPE_BULLET;
  Scr_AddInt(scrContext, v3);
}

/*
==============
PlayerCmd_IsSkydiving
==============
*/
void PlayerCmd_IsSkydiving(scrContext_t *scrContext, scr_entref_t entref)
{
  int v2; 
  unsigned int entnum; 
  gentity_s *v5; 
  _BYTE *client; 
  const char *v7; 
  ComErrorCode v8; 

  v2 = 0;
  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v7 = "not an entity";
    v8 = COM_ERR_3682;
LABEL_9:
    Scr_ObjectError(v8, scrContext, v7);
    client = NULL;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31491, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    goto LABEL_11;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31490, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v5 = &g_entities[entnum];
  client = v5->client;
  if ( !client )
  {
    client = v5->agent;
    if ( !client )
    {
      v7 = j_va("entity %i is not a player or agent", entnum);
      v8 = COM_ERR_3679;
      goto LABEL_9;
    }
  }
LABEL_11:
  LOBYTE(v2) = (unsigned __int8)(client[12112] - 1) <= 5u;
  Scr_AddBool(scrContext, v2);
}

/*
==============
GScr_WeaponBurstCount
==============
*/
void GScr_WeaponBurstCount(scrContext_t *scrContext)
{
  int WeaponBurstCount; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( BG_GetWeaponFireType(&outWeapon, outIsAlternate) == WEAPON_FIRETYPE_BURST )
    WeaponBurstCount = BG_GetWeaponBurstCount(&outWeapon, outIsAlternate);
  else
    WeaponBurstCount = 0;
  Scr_AddInt(scrContext, WeaponBurstCount);
}

/*
==============
GScr_WeaponIsBoltAction
==============
*/
void GScr_WeaponIsBoltAction(scrContext_t *scrContext)
{
  bool IsBoltAction; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  IsBoltAction = BG_IsBoltAction(&outWeapon, outIsAlternate);
  Scr_AddInt(scrContext, IsBoltAction);
}

/*
==============
GScr_WeaponInheritsPerks
==============
*/
void GScr_WeaponInheritsPerks(scrContext_t *scrContext)
{
  int v2; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( outWeapon.weaponIdx )
    v2 = BG_InheritsPerks(&outWeapon, outIsAlternate);
  else
    v2 = 1;
  Scr_AddInt(scrContext, v2);
}

/*
==============
GScr_WeaponType
==============
*/
void GScr_WeaponType(scrContext_t *scrContext)
{
  weapType_t WeaponType; 
  const char *WeaponTypeName; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  WeaponType = BG_GetWeaponType(&outWeapon, outIsAlternate);
  WeaponTypeName = BG_GetWeaponTypeName(WeaponType);
  Scr_AddString(scrContext, WeaponTypeName);
}

/*
==============
PlayerCmd_IsBaseJumpAvailable
==============
*/
void PlayerCmd_IsBaseJumpAvailable(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  unsigned __int8 *client; 
  const char *v6; 
  ComErrorCode v7; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
LABEL_9:
    Scr_ObjectError(v7, scrContext, v6);
    client = NULL;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31510, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    goto LABEL_11;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31509, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = (unsigned __int8 *)v4->client;
  if ( !client )
  {
    client = (unsigned __int8 *)v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
      goto LABEL_9;
    }
  }
LABEL_11:
  Scr_AddBool(scrContext, client[12140] >> 7);
}

/*
==============
GScr_WeaponClass
==============
*/
void GScr_WeaponClass(scrContext_t *scrContext)
{
  const char *WeaponClassName; 
  weapClass_t WeaponClass; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( outWeapon.weaponIdx )
  {
    WeaponClass = BG_GetWeaponClass(&outWeapon, outIsAlternate);
    WeaponClassName = BG_GetWeaponClassName(WeaponClass);
  }
  else
  {
    WeaponClassName = "none";
  }
  Scr_AddString(scrContext, WeaponClassName);
}

/*
==============
GScr_WeaponOffhandClass
==============
*/
void GScr_WeaponOffhandClass(scrContext_t *scrContext)
{
  const char *WeaponOffhandClassName; 
  OffhandClass WeaponOffhandClass; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( outWeapon.weaponIdx )
  {
    WeaponOffhandClass = BG_GetWeaponOffhandClass(&outWeapon);
    WeaponOffhandClassName = BG_GetWeaponOffhandClassName(WeaponOffhandClass);
  }
  else
  {
    WeaponOffhandClassName = "none";
  }
  Scr_AddString(scrContext, WeaponOffhandClassName);
}

/*
==============
GScr_WeaponInventoryType
==============
*/
void GScr_WeaponInventoryType(scrContext_t *scrContext)
{
  weapInventoryType_t inventoryType; 
  unsigned __int16 weaponIdx; 
  bool v4; 
  WeaponDef **v5; 
  const char *WeaponInventoryTypeName; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( outIsAlternate )
  {
    inventoryType = WEAPINVENTORY_ALTMODE;
  }
  else
  {
    weaponIdx = outWeapon.weaponIdx;
    if ( outWeapon.weaponIdx > bg_lastParsedWeaponIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1203, ASSERT_TYPE_ASSERT, "( weaponIdx ) <= ( bg_lastParsedWeaponIndex )", "weaponIdx not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", outWeapon.weaponIdx, bg_lastParsedWeaponIndex) )
      __debugbreak();
    v4 = bg_weaponDefs[weaponIdx] == NULL;
    v5 = &bg_weaponDefs[weaponIdx];
    if ( v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1204, ASSERT_TYPE_ASSERT, "(bg_weaponDefs[weaponIdx])", (const char *)&queryFormat, "bg_weaponDefs[weaponIdx]") )
      __debugbreak();
    inventoryType = (*v5)->inventoryType;
  }
  WeaponInventoryTypeName = BG_GetWeaponInventoryTypeName(inventoryType);
  Scr_AddString(scrContext, WeaponInventoryTypeName);
}

/*
==============
GScr_Skydive_CutParachuteOn
==============
*/
void GScr_Skydive_CutParachuteOn(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  _BYTE *client; 
  const char *v6; 
  ComErrorCode v7; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
LABEL_9:
    Scr_ObjectError(v7, scrContext, v6);
    client = NULL;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31529, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    goto LABEL_11;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31528, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = v4->client;
  if ( !client )
  {
    client = v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
      goto LABEL_9;
    }
  }
LABEL_11:
  client[12140] &= ~0x10u;
}

/*
==============
GScr_WeaponStartAmmo
==============
*/
void GScr_WeaponStartAmmo(scrContext_t *scrContext)
{
  bool v2; 
  int started; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  v2 = Scr_GetNumParam(scrContext) > 1 && Scr_GetType(scrContext, 1u) && Scr_GetInt(scrContext, 1u) != 0;
  started = BG_StartAmmo(&outWeapon, outIsAlternate, v2);
  Scr_AddInt(scrContext, started);
}

/*
==============
GScr_WeaponMaxAmmo
==============
*/
void GScr_WeaponMaxAmmo(scrContext_t *scrContext)
{
  bool v2; 
  int v3; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  v2 = Scr_GetNumParam(scrContext) > 1 && Scr_GetType(scrContext, 1u) && Scr_GetInt(scrContext, 1u) != 0;
  v3 = BG_MaxAmmo(&outWeapon, outIsAlternate, v2);
  Scr_AddInt(scrContext, v3);
}

/*
==============
GScr_WeaponAltWeaponName
==============
*/
void GScr_WeaponAltWeaponName(scrContext_t *scrContext)
{
  bool outIsAlternate; 
  Weapon outWeapon; 
  char output[1024]; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( !outIsAlternate && (unsigned __int16)*(_DWORD *)&BG_GetAltWeapon(&outWeapon)->weaponIdx )
  {
    BG_GetWeaponNameComplete(&outWeapon, 1, output, 0x400u);
    Scr_AddString(scrContext, output);
  }
  else
  {
    Scr_AddConstString(scrContext, scr_const.none);
  }
}

/*
==============
GScr_Skydive_CutParachuteOff
==============
*/
void GScr_Skydive_CutParachuteOff(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  _BYTE *client; 
  const char *v6; 
  ComErrorCode v7; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
LABEL_9:
    Scr_ObjectError(v7, scrContext, v6);
    client = NULL;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31547, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    goto LABEL_11;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31546, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = v4->client;
  if ( !client )
  {
    client = v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
      goto LABEL_9;
    }
  }
LABEL_11:
  client[12140] |= 0x10u;
  client[12141] |= 2u;
}

/*
==============
GScr_WeaponFireTime
==============
*/
void GScr_WeaponFireTime(scrContext_t *scrContext)
{
  bool isDualWielding; 
  bool outIsAlternate; 
  int fireTime; 
  int fireDelay; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  isDualWielding = BG_WeaponIsDualWield(&outWeapon);
  BG_GetFireTime(NULL, NULL, &outWeapon, outIsAlternate, isDualWielding, 0, &fireTime, &fireDelay);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, [rsp+0A8h+var_64]
    vmulss  xmm1, xmm0, cs:__real@3a83126f; value
  }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
GScr_IsWeaponClipOnly
==============
*/
void GScr_IsWeaponClipOnly(scrContext_t *scrContext)
{
  int IsClipOnly; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( outWeapon.weaponIdx )
    IsClipOnly = BG_WeaponIsClipOnly(&outWeapon, outIsAlternate);
  else
    IsClipOnly = 0;
  Scr_AddBool(scrContext, IsClipOnly);
}

/*
==============
GScr_IsWeaponDetonationTimed
==============
*/
void GScr_IsWeaponDetonationTimed(scrContext_t *scrContext)
{
  int v2; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( outWeapon.weaponIdx )
    v2 = BG_TimedDetonation(&outWeapon, outIsAlternate);
  else
    v2 = 0;
  Scr_AddBool(scrContext, v2);
}

/*
==============
GScr_Skydive_CutAutoDeployOn
==============
*/
void GScr_Skydive_CutAutoDeployOn(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  _BYTE *client; 
  const char *v6; 
  ComErrorCode v7; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
LABEL_9:
    Scr_ObjectError(v7, scrContext, v6);
    client = NULL;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31568, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    goto LABEL_11;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31567, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = v4->client;
  if ( !client )
  {
    client = v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
      goto LABEL_9;
    }
  }
LABEL_11:
  client[12141] &= ~2u;
}

/*
==============
GScr_WeaponHasThermalScope
==============
*/
void GScr_WeaponHasThermalScope(scrContext_t *scrContext)
{
  bool HasThermalScope; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  HasThermalScope = BG_HasThermalScope(NULL, &outWeapon, outIsAlternate);
  Scr_AddInt(scrContext, HasThermalScope);
}

/*
==============
GScr_WeaponCanDrop
==============
*/
void GScr_WeaponCanDrop(scrContext_t *scrContext)
{
  bool IsDisabled; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  IsDisabled = BG_WeaponDropIsDisabled(&outWeapon, 0);
  Scr_AddBool(scrContext, !IsDisabled);
}

/*
==============
GScr_WeaponIsPreferredDrop
==============
*/
void GScr_WeaponIsPreferredDrop(scrContext_t *scrContext)
{
  bool IsPrefferedDrop; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  IsPrefferedDrop = BG_WeaponIsPrefferedDrop(&outWeapon, 0);
  Scr_AddBool(scrContext, IsPrefferedDrop);
}

/*
==============
Scr_PrecacheItem
==============
*/
void Scr_PrecacheItem(scrContext_t *scrContext)
{
  const char *String; 

  String = Scr_GetString(scrContext, 0);
  Com_Printf(15, "PrecacheItem() is deprecated, weapons automatically register. Please delete this instruction (Weapon %s)\n", String);
}

/*
==============
GScr_Skydive_CutAutoDeployOff
==============
*/
void GScr_Skydive_CutAutoDeployOff(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  _BYTE *client; 
  const char *v6; 
  ComErrorCode v7; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
LABEL_9:
    Scr_ObjectError(v7, scrContext, v6);
    client = NULL;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31586, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    goto LABEL_11;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31585, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = v4->client;
  if ( !client )
  {
    client = v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
      goto LABEL_9;
    }
  }
LABEL_11:
  client[12141] |= 2u;
}

/*
==============
Scr_PrecacheMaterial
==============
*/
void Scr_PrecacheMaterial(scrContext_t *scrContext)
{
  const char *String; 

  if ( NetConstStrings_IsPrecacheAllowed() )
  {
    if ( !level.initializing )
      Scr_Error(COM_ERR_4298, scrContext, "precacheShader must be called before any wait statements in the gametype or level script\n");
    String = Scr_GetString(scrContext, 0);
    if ( !*String )
      Scr_ParamError(COM_ERR_4299, scrContext, 0, "Shader name string is empty");
    Scr_ErrorOnDefaultAsset(scrContext, ASSET_TYPE_MATERIAL, String);
    if ( !GConfigStrings::ms_gConfigStrings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_configstrings.h", 71, ASSERT_TYPE_ASSERT, "( ms_gConfigStrings )", (const char *)&queryFormat, "ms_gConfigStrings") )
      __debugbreak();
    GConfigStrings::ms_gConfigStrings->GetMaterialIndex(GConfigStrings::ms_gConfigStrings, String);
  }
}

/*
==============
Scr_PrecacheLeaderboards
==============
*/
void Scr_PrecacheLeaderboards(scrContext_t *scrContext)
{
  const char *String; 

  if ( !level.initializing )
    Scr_Error(COM_ERR_4300, scrContext, "preacheLeaderboards must be called before any wait statements in the gametype or level script\n");
  String = Scr_GetString(scrContext, 0);
  SV_SetConfigstring(0xDu, String);
}

/*
==============
Scr_PrecacheString
==============
*/
void Scr_PrecacheString(scrContext_t *scrContext)
{
  GConfigStrings *ConfigStringSystem; 
  char v3[1024]; 

  if ( NetConstStrings_IsPrecacheAllowed() )
  {
    if ( !level.initializing )
      Scr_Error(COM_ERR_4301, scrContext, "precacheString must be called before any wait statements in the gametype or level script\n");
    if ( !GScript::ms_gScriptSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.h", 183, ASSERT_TYPE_ASSERT, "( ms_gScriptSystem )", (const char *)&queryFormat, "ms_gScriptSystem") )
      __debugbreak();
    GScript::ms_gScriptSystem->ConstructMessageString(GScript::ms_gScriptSystem, scrContext, 0, 0, "Precache String", v3, 1024u);
    if ( v3[0] )
    {
      ConfigStringSystem = GConfigStrings::GetConfigStringSystem();
      ConfigStringSystem->SetLocalizedString(ConfigStringSystem, v3, NULL);
    }
  }
}

/*
==============
PlayerCmd_IsInFreefall
==============
*/
void PlayerCmd_IsInFreefall(scrContext_t *scrContext, scr_entref_t entref)
{
  int v2; 
  unsigned int entnum; 
  gentity_s *v5; 
  _BYTE *client; 
  const char *v7; 
  ComErrorCode v8; 

  v2 = 0;
  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v7 = "not an entity";
    v8 = COM_ERR_3682;
LABEL_9:
    Scr_ObjectError(v8, scrContext, v7);
    client = NULL;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31604, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    goto LABEL_11;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31603, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v5 = &g_entities[entnum];
  client = v5->client;
  if ( !client )
  {
    client = v5->agent;
    if ( !client )
    {
      v7 = j_va("entity %i is not a player or agent", entnum);
      v8 = COM_ERR_3679;
      goto LABEL_9;
    }
  }
LABEL_11:
  if ( client[12112] == 7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31605, ASSERT_TYPE_ASSERT, "( ps->skydivePlayerState.state ) != ( SkydiveState::Count )", "%s != %s\n\t%i, %i", "ps->skydivePlayerState.state", "SkydiveState::Count", 7, 7) )
    __debugbreak();
  LOBYTE(v2) = ((client[12112] - 1) & 0xFB) == 0;
  Scr_AddBool(scrContext, v2);
}

/*
==============
Scr_PrecacheRumble
==============
*/
void Scr_PrecacheRumble(scrContext_t *scrContext)
{
  const char *String; 

  String = Scr_GetString(scrContext, 0);
  Com_Printf(15, "PrecacheItem() is deprecated, rumbles automatically register. Please delete this instruction (Rumble %s)\n", String);
}

/*
==============
PlayerCmd_IsParachuting
==============
*/
void PlayerCmd_IsParachuting(scrContext_t *scrContext, scr_entref_t entref)
{
  int v2; 
  unsigned int entnum; 
  gentity_s *v5; 
  _BYTE *client; 
  const char *v7; 
  ComErrorCode v8; 

  v2 = 0;
  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v7 = "not an entity";
    v8 = COM_ERR_3682;
LABEL_9:
    Scr_ObjectError(v8, scrContext, v7);
    client = NULL;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31624, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    goto LABEL_11;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31623, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v5 = &g_entities[entnum];
  client = v5->client;
  if ( !client )
  {
    client = v5->agent;
    if ( !client )
    {
      v7 = j_va("entity %i is not a player or agent", entnum);
      v8 = COM_ERR_3679;
      goto LABEL_9;
    }
  }
LABEL_11:
  if ( client[12112] == 7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31625, ASSERT_TYPE_ASSERT, "( ps->skydivePlayerState.state ) != ( SkydiveState::Count )", "%s != %s\n\t%i, %i", "ps->skydivePlayerState.state", "SkydiveState::Count", 7, 7) )
    __debugbreak();
  LOBYTE(v2) = (unsigned __int8)(client[12112] - 2) <= 1u;
  Scr_AddBool(scrContext, v2);
}

/*
==============
PlayerCmd_ShouldDisableSkydiveVfx
==============
*/
void PlayerCmd_ShouldDisableSkydiveVfx(scrContext_t *scrContext, scr_entref_t entref)
{
  int v2; 
  unsigned int entnum; 
  gentity_s *v5; 
  _BYTE *client; 
  const char *v7; 
  ComErrorCode v8; 

  v2 = 0;
  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v7 = "not an entity";
    v8 = COM_ERR_3682;
LABEL_9:
    Scr_ObjectError(v8, scrContext, v7);
    client = NULL;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31644, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    goto LABEL_11;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31643, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v5 = &g_entities[entnum];
  client = v5->client;
  if ( !client )
  {
    client = v5->agent;
    if ( !client )
    {
      v7 = j_va("entity %i is not a player or agent", entnum);
      v8 = COM_ERR_3679;
      goto LABEL_9;
    }
  }
LABEL_11:
  if ( (client[12141] & 4) != 0 || !client[12112] )
    v2 = 1;
  Scr_AddBool(scrContext, v2);
}

/*
==============
PlayerCmd_SetIsInfilSkydive
==============
*/
void PlayerCmd_SetIsInfilSkydive(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  _BYTE *client; 
  const char *v6; 
  ComErrorCode v7; 
  bool v8; 
  char v9; 
  char v10; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
LABEL_9:
    Scr_ObjectError(v7, scrContext, v6);
    client = NULL;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31665, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    goto LABEL_11;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31664, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = v4->client;
  if ( !client )
  {
    client = v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
      goto LABEL_9;
    }
  }
LABEL_11:
  v8 = Scr_GetInt(scrContext, 0) != 0;
  if ( client[12112] )
  {
    v9 = client[12141];
    if ( ((v9 & 8) != 0) != v8 )
    {
      if ( (v9 & 8) != 0 )
        v10 = v9 & 0xF7;
      else
        v10 = v9 | 8;
      client[12141] = v10;
    }
  }
}

/*
==============
GScr_Skydive_SetForceThirdPersonStatus
==============
*/
void GScr_Skydive_SetForceThirdPersonStatus(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v16; 
  playerState_s *EntityPlayerState; 
  int Int; 
  GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64> *p_pm_flags; 
  char *fmt; 

  entnum = entref.entnum;
  _RDI = GetEntity(entref);
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31709, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( G_Utils_IsClient(_RDI) )
  {
    if ( Scr_GetNumParam(scrContext) )
    {
      EntityPlayerState = G_GetEntityPlayerState(_RDI);
      if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31724, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
        __debugbreak();
      Int = Scr_GetInt(scrContext, 0);
      p_pm_flags = &EntityPlayerState->pm_flags;
      if ( Int )
        GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::SetFlagInternal(p_pm_flags, ACTIVE, 0x31u);
      else
        GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(p_pm_flags, ACTIVE, 0x31u);
    }
    else
    {
      Scr_Error(COM_ERR_5731, scrContext, "Missing parameter: player Skydive_SetForceThirdPersonStatus( <enabled> );");
    }
  }
  else
  {
    targetname = _RDI->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(_RDI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rdi+134h]
      vmovss  xmm2, dword ptr [rdi+130h]
      vmovss  xmm0, dword ptr [rdi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+48h+fmt], xmm0
    }
    v16 = j_va("Skydive_SetForceThirdPersonStatus(). Only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, fmt, v7, v6);
    Scr_Error(COM_ERR_5935, scrContext, v16);
  }
}

/*
==============
GScr_EnablePlayerMarks
==============
*/
void GScr_EnablePlayerMarks(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t ConstString; 
  const char *v5; 
  const char *v6; 
  EntityMarkType outMarkType; 

  Entity = GetEntity(entref);
  ConstString = Scr_GetConstString(scrContext, 0);
  if ( G_EntityMarks_GetMarkType(ConstString, &outMarkType) )
  {
    Entity->markFlags |= 1 << outMarkType;
    *(_QWORD *)Entity->markFilterOut = 0i64;
    *(_QWORD *)&Entity->markFilterOut[2] = 0i64;
    *(_QWORD *)&Entity->markFilterOut[4] = 0i64;
    Entity->markFilterOut[6] = 0;
  }
  else
  {
    G_EntityMarks_PrintMarkTypes();
    v5 = SL_ConvertToString(ConstString);
    v6 = j_va("Invalid mark type specified: %s. See console log for details.\n", v5);
    Scr_ParamError(COM_ERR_6044, scrContext, 0, v6);
  }
}

/*
==============
GScr_DisablePlayerMarks
==============
*/
void GScr_DisablePlayerMarks(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t ConstString; 
  const char *v5; 
  const char *v6; 
  EntityMarkType outMarkType; 

  Entity = GetEntity(entref);
  ConstString = Scr_GetConstString(scrContext, 0);
  if ( G_EntityMarks_GetMarkType(ConstString, &outMarkType) )
  {
    Entity->markFlags &= ~(1 << outMarkType);
    *(_QWORD *)Entity->markFilterOut = 0i64;
    *(_QWORD *)&Entity->markFilterOut[2] = 0i64;
    *(_QWORD *)&Entity->markFilterOut[4] = 0i64;
    Entity->markFilterOut[6] = 0;
  }
  else
  {
    G_EntityMarks_PrintMarkTypes();
    v5 = SL_ConvertToString(ConstString);
    v6 = j_va("Invalid mark type specified: %s. See console log for details.\n", v5);
    Scr_ParamError(COM_ERR_6092, scrContext, 0, v6);
  }
}

/*
==============
GScr_IsExplosiveDamageMOD
==============
*/
void GScr_IsExplosiveDamageMOD(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  scr_string_t **v3; 
  int v4; 

  ConstString = Scr_GetConstString(scrContext, 0);
  v3 = g_combat_modNames;
  v4 = 0;
  while ( **v3 != ConstString )
  {
    ++v4;
    if ( (__int64)++v3 >= (__int64)&MAX_TRANSIENT_WORLD_FASTFILES_454 )
    {
      Scr_AddBool(scrContext, 0);
      return;
    }
  }
  Scr_AddBool(scrContext, modExplosiveFlags[v4]);
}

/*
==============
ScrCmd_DoDamage
==============
*/
void ScrCmd_DoDamage(scrContext_t *scrContext, scr_entref_t entref)
{
  int v6; 
  gentity_s *v10; 
  gentity_s *EntityAllowNull; 
  scr_string_t ConstString; 
  const char *v27; 
  bool v44; 
  bool v45; 
  int *v61; 
  damageReturnCode_t (__fastcall *Damage)(GCombat *, gentity_s *, const gentity_s *, gentity_s *, const vec3_t *, const vec3_t *, int, int, int, const Weapon *, bool, hitLocation_t, unsigned int, scr_string_t, int, const vec3_t *, const GExtraDamageParams *); 
  bool outIsAlternate[4]; 
  hitLocation_t HitLocationIndexFromString; 
  meansOfDeath_t v67; 
  int v68; 
  vec3_t vectorValue; 
  Weapon outWeapon; 

  __asm
  {
    vmovups ymm0, ymmword ptr cs:?NULL_WEAPON@@3UWeapon@@B.weaponIdx; Weapon const NULL_WEAPON
    vmovups xmm1, xmmword ptr cs:?NULL_WEAPON@@3UWeapon@@B.attachmentVariationIndices+5; Weapon const NULL_WEAPON
  }
  v6 = 0;
  __asm
  {
    vmovups ymmword ptr [rbp+50h+outWeapon.weaponIdx], ymm0
    vmovsd  xmm0, qword ptr cs:?NULL_WEAPON@@3UWeapon@@B.attachmentVariationIndices+15h; Weapon const NULL_WEAPON
    vmovsd  qword ptr [rbp+50h+outWeapon.attachmentVariationIndices+15h], xmm0
  }
  *(_DWORD *)&outWeapon.weaponCamo = *(_DWORD *)&NULL_WEAPON.weaponCamo;
  outIsAlternate[0] = 0;
  __asm { vmovups xmmword ptr [rbp+50h+outWeapon.attachmentVariationIndices+5], xmm1 }
  v10 = NULL;
  v67 = MOD_UNKNOWN;
  EntityAllowNull = NULL;
  HitLocationIndexFromString = HITLOC_HEAD;
  switch ( Scr_GetNumParam(scrContext) )
  {
    case 2u:
      goto $LN22_42;
    case 3u:
      goto $LN20_39;
    case 4u:
      goto $LN18_41;
    case 5u:
      goto $LN16_45;
    case 6u:
      goto $LN14_55;
    case 7u:
      if ( Scr_GetType(scrContext, 6u) )
      {
        ConstString = Scr_GetConstString(scrContext, 6u);
        HitLocationIndexFromString = G_Combat_GetHitLocationIndexFromString(ConstString);
      }
$LN14_55:
      if ( Scr_GetType(scrContext, 5u) )
        GScr_Main_GetWeaponParam(scrContext, 5u, &outWeapon, outIsAlternate);
$LN16_45:
      if ( Scr_GetType(scrContext, 4u) )
        v67 = G_Combat_MeansOfDeathFromScriptParam(scrContext, 4);
$LN18_41:
      if ( Scr_GetType(scrContext, 3u) )
        EntityAllowNull = GScr_GetEntityAllowNull(3u);
$LN20_39:
      if ( Scr_GetType(scrContext, 2u) )
        v10 = GScr_GetEntityAllowNull(2u);
$LN22_42:
      __asm
      {
        vmovaps [rsp+160h+var_40], xmm6
        vmovaps [rsp+160h+var_50], xmm7
      }
      _RBX = GetEntity(entref);
      *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
      __asm { vmovaps xmm7, xmm0 }
      Scr_GetVector(scrContext, 1u, &vectorValue);
      __asm
      {
        vmovss  xmm1, dword ptr [rbp+50h+vectorValue]
        vmovss  dword ptr [rbp+50h+outIsAlternate], xmm1
      }
      if ( (*(_DWORD *)outIsAlternate & 0x7F800000) == 2139095040 )
        goto LABEL_15;
      __asm
      {
        vmovss  xmm1, dword ptr [rbp+50h+vectorValue+4]
        vmovss  dword ptr [rbp+50h+outIsAlternate], xmm1
      }
      if ( (*(_DWORD *)outIsAlternate & 0x7F800000) == 2139095040 )
        goto LABEL_15;
      __asm
      {
        vmovss  xmm0, dword ptr [rbp+50h+vectorValue+8]
        vmovss  dword ptr [rbp+50h+outIsAlternate], xmm0
      }
      if ( (*(_DWORD *)outIsAlternate & 0x7F800000) == 2139095040 )
      {
LABEL_15:
        __asm
        {
          vmovss  xmm3, dword ptr [rbp+50h+vectorValue+8]
          vmovss  xmm2, dword ptr [rbp+50h+vectorValue+4]
          vmovss  xmm1, dword ptr [rbp+50h+vectorValue]
          vcvtss2sd xmm3, xmm3, xmm3
          vcvtss2sd xmm2, xmm2, xmm2
          vcvtss2sd xmm1, xmm1, xmm1
          vmovq   r9, xmm3
          vmovq   r8, xmm2
          vmovq   rdx, xmm1
        }
        v27 = j_va("Source Damage vector is invalid : %f %f %f", _RDX, _R8, _R9);
        Scr_Error(COM_ERR_4305, scrContext, v27);
      }
      if ( _RBX->client )
      {
        __asm
        {
          vmovss  xmm0, dword ptr [rcx+30h]
          vmovss  dword ptr [rbp+50h+outIsAlternate], xmm0
        }
        if ( (*(_DWORD *)outIsAlternate & 0x7F800000) == 2139095040 )
          goto LABEL_44;
        __asm
        {
          vmovss  xmm0, dword ptr [rcx+34h]
          vmovss  dword ptr [rbp+50h+outIsAlternate], xmm0
        }
        if ( (*(_DWORD *)outIsAlternate & 0x7F800000) == 2139095040 )
          goto LABEL_44;
        __asm
        {
          vmovss  xmm0, dword ptr [rcx+38h]
          vmovss  dword ptr [rbp+50h+outIsAlternate], xmm0
        }
        if ( (*(_DWORD *)outIsAlternate & 0x7F800000) == 2139095040 )
        {
LABEL_44:
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 14301, ASSERT_TYPE_SANITY, "( !IS_NAN( ( ent->client->ps.origin )[0] ) && !IS_NAN( ( ent->client->ps.origin )[1] ) && !IS_NAN( ( ent->client->ps.origin )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( ent->client->ps.origin )[0] ) && !IS_NAN( ( ent->client->ps.origin )[1] ) && !IS_NAN( ( ent->client->ps.origin )[2] )") )
            __debugbreak();
        }
        _RAX = _RBX->client;
        __asm
        {
          vmovss  xmm0, dword ptr [rax+30h]
          vsubss  xmm4, xmm0, dword ptr [rbp+50h+vectorValue]
          vmovss  [rbp+50h+var_C0], xmm4
          vmovss  xmm1, dword ptr [rax+34h]
          vsubss  xmm5, xmm1, dword ptr [rbp+50h+vectorValue+4]
          vmovss  [rbp+50h+var_BC], xmm5
          vmovss  xmm0, dword ptr [rax+38h]
        }
      }
      else
      {
        __asm
        {
          vmovss  xmm0, dword ptr [rbx+130h]
          vmovss  dword ptr [rbp+50h+outIsAlternate], xmm0
        }
        if ( (*(_DWORD *)outIsAlternate & 0x7F800000) == 2139095040 )
          goto LABEL_45;
        __asm
        {
          vmovss  xmm0, dword ptr [rbx+134h]
          vmovss  dword ptr [rbp+50h+outIsAlternate], xmm0
        }
        if ( (*(_DWORD *)outIsAlternate & 0x7F800000) == 2139095040 )
          goto LABEL_45;
        __asm
        {
          vmovss  xmm0, dword ptr [rbx+138h]
          vmovss  dword ptr [rbp+50h+outIsAlternate], xmm0
        }
        if ( (*(_DWORD *)outIsAlternate & 0x7F800000) == 2139095040 )
        {
LABEL_45:
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 14306, ASSERT_TYPE_SANITY, "( !IS_NAN( ( ent->r.currentOrigin )[0] ) && !IS_NAN( ( ent->r.currentOrigin )[1] ) && !IS_NAN( ( ent->r.currentOrigin )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( ent->r.currentOrigin )[0] ) && !IS_NAN( ( ent->r.currentOrigin )[1] ) && !IS_NAN( ( ent->r.currentOrigin )[2] )") )
            __debugbreak();
        }
        __asm
        {
          vmovss  xmm0, dword ptr [rbx+130h]
          vsubss  xmm4, xmm0, dword ptr [rbp+50h+vectorValue]
          vmovss  [rbp+50h+var_C0], xmm4
          vmovss  xmm1, dword ptr [rbx+134h]
          vsubss  xmm5, xmm1, dword ptr [rbp+50h+vectorValue+4]
          vmovss  [rbp+50h+var_BC], xmm5
          vmovss  xmm0, dword ptr [rbx+138h]
        }
      }
      __asm
      {
        vsubss  xmm6, xmm0, dword ptr [rbp+50h+vectorValue+8]
        vmovss  dword ptr [rbp+50h+outIsAlternate], xmm4
        vmovss  [rbp+50h+var_B8], xmm6
      }
      if ( (*(_DWORD *)outIsAlternate & 0x7F800000) == 2139095040 )
        goto LABEL_32;
      __asm { vmovss  dword ptr [rbp+50h+outIsAlternate], xmm5 }
      if ( (*(_DWORD *)outIsAlternate & 0x7F800000) == 2139095040 )
        goto LABEL_32;
      __asm { vmovss  dword ptr [rbp+50h+outIsAlternate], xmm6 }
      v44 = (*(_DWORD *)outIsAlternate & 0x7F800000) == 2139095040;
      if ( (*(_DWORD *)outIsAlternate & 0x7F800000) == 2139095040 )
      {
LABEL_32:
        v45 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 14310, ASSERT_TYPE_SANITY, "( !IS_NAN( ( from )[0] ) && !IS_NAN( ( from )[1] ) && !IS_NAN( ( from )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( from )[0] ) && !IS_NAN( ( from )[1] ) && !IS_NAN( ( from )[2] )");
        v44 = !v45;
        if ( v45 )
          __debugbreak();
        __asm
        {
          vmovss  xmm4, [rbp+50h+var_C0]
          vmovss  xmm5, [rbp+50h+var_BC]
          vmovss  xmm6, [rbp+50h+var_B8]
        }
      }
      __asm
      {
        vmulss  xmm0, xmm4, xmm4
        vmulss  xmm1, xmm5, xmm5
        vaddss  xmm2, xmm1, xmm0
        vmulss  xmm1, xmm6, xmm6
        vaddss  xmm2, xmm2, xmm1
        vmovss  xmm1, cs:__real@3f800000
        vsqrtss xmm3, xmm2, xmm2
        vcmpless xmm0, xmm3, cs:__real@80000000
        vblendvps xmm0, xmm3, xmm1, xmm0
        vdivss  xmm2, xmm1, xmm0
        vmulss  xmm1, xmm5, xmm2
        vmulss  xmm0, xmm4, xmm2
        vmovss  [rbp+50h+var_BC], xmm1
        vxorps  xmm1, xmm1, xmm1
        vucomiss xmm3, xmm1
        vmovss  [rbp+50h+var_C0], xmm0
        vmulss  xmm0, xmm6, xmm2
        vmovaps xmm6, [rsp+160h+var_40]
      }
      v61 = NULL;
      __asm { vmovss  [rbp+50h+var_B8], xmm0 }
      if ( !v44 )
        v61 = &v68;
      if ( !GCombat::ms_gCombatSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_combat.h", 177, ASSERT_TYPE_ASSERT, "( ms_gCombatSystem )", (const char *)&queryFormat, "ms_gCombatSystem") )
        __debugbreak();
      Damage = GCombat::ms_gCombatSystem->Damage;
      __asm { vcvttss2si eax, xmm7 }
      *(_WORD *)outIsAlternate = 0;
      LOBYTE(v6) = Damage(GCombat::ms_gCombatSystem, _RBX, EntityAllowNull, v10, (const vec3_t *)v61, &vectorValue, _EAX, 0, v67, &outWeapon, 0, HitLocationIndexFromString, 0, (scr_string_t)0, 0, NULL, (const GExtraDamageParams *)outIsAlternate) == DAMAGE_RETURNCODE_SUCCESS;
      Scr_AddBool(scrContext, v6);
      __asm { vmovaps xmm7, [rsp+160h+var_50] }
      break;
    default:
      Scr_Error(COM_ERR_4306, scrContext, "Usage: doDamage( <health>, <source position>, <attacker>, <inflictor> )\n");
      break;
  }
}

/*
==============
GScr_RadiusDamage
==============
*/
void GScr_RadiusDamage(scrContext_t *scrContext)
{
  GScr_RadiusDamageInternal(scrContext, NULL);
}

/*
==============
GScr_EntityRadiusDamage
==============
*/
void GScr_EntityRadiusDamage(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  GScr_RadiusDamageInternal(scrContext, Entity);
}

/*
==============
GScr_RadiusDamageStepped
==============
*/
void GScr_RadiusDamageStepped(scrContext_t *scrContext)
{
  GScr_RadiusDamageSteppedInternal(scrContext, NULL);
}

/*
==============
GScr_EntityRadiusDamageStepped
==============
*/
void GScr_EntityRadiusDamageStepped(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  GScr_RadiusDamageSteppedInternal(scrContext, Entity);
}

/*
==============
GScr_GlassRadiusDamage
==============
*/

void __fastcall GScr_GlassRadiusDamage(scrContext_t *scrContext, __int64 a2, double _XMM2_8)
{
  char v12; 
  float v21; 
  float v22; 
  vec3_t vectorValue; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-18h], xmm6
    vmovaps xmmword ptr [rax-28h], xmm7
    vmovaps xmmword ptr [rax-38h], xmm9
    vmovaps xmmword ptr [rax-48h], xmm10
  }
  Scr_GetVector(scrContext, 0, &vectorValue);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm
  {
    vxorps  xmm9, xmm9, xmm9
    vcomiss xmm0, xmm9
    vmovaps xmm10, xmm0
  }
  if ( v12 )
    Scr_Error(COM_ERR_4307, scrContext, "Invalid <range> value specified for radius damage ( parameter 2 ).\n");
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
  __asm
  {
    vcomiss xmm0, xmm9
    vmovaps xmm6, xmm0
  }
  if ( !v12 )
    __asm { vcomiss xmm0, cs:__real@4f000000 }
  Scr_Error(COM_ERR_4308, scrContext, "Invalid <max_damage> value specified for radius damage ( parameter 3 ).\n");
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
  __asm
  {
    vcomiss xmm0, xmm9
    vmovaps xmm7, xmm0
  }
  if ( !v12 )
    __asm { vcomiss xmm0, cs:__real@4f000000 }
  Scr_Error(COM_ERR_4309, scrContext, "Invalid <min_damage> value specified for radius damage ( parameter 4 ).\n");
  __asm
  {
    vmovss  [rsp+98h+var_70], xmm7
    vxorps  xmm2, xmm2, xmm2; coneAngleCos
    vmovaps xmm1, xmm10; radius
    vmovss  [rsp+98h+var_78], xmm6
  }
  G_Glass_RadiusDamage(&vectorValue, *(float *)&_XMM1, *(float *)&_XMM2, NULL, v21, v22);
  __asm
  {
    vmovaps xmm6, [rsp+98h+var_18]
    vmovaps xmm7, [rsp+98h+var_28]
    vmovaps xmm9, [rsp+98h+var_38]
    vmovaps xmm10, [rsp+98h+var_48]
  }
}

/*
==============
GScr_Detonate
==============
*/
void GScr_Detonate(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  GWeaponMap *Instance; 
  const Weapon *WeaponForEntity; 
  const WeaponDef *v6; 
  bool v7; 
  const gentity_s *v8; 
  gentity_s *v9; 

  Entity = GetEntity(entref);
  Instance = GWeaponMap::GetInstance();
  WeaponForEntity = BG_GetWeaponForEntity(Instance, &Entity->s);
  v6 = BG_WeaponDef(WeaponForEntity, 0);
  v7 = BG_GetWeaponType(WeaponForEntity, 0) == WEAPTYPE_GRENADE || BG_GetWeaponType(WeaponForEntity, 0) == WEAPTYPE_PROJECTILE;
  if ( Entity->s.eType != ET_MISSILE || !v6 || !v7 )
    Scr_ObjectError(COM_ERR_4310, scrContext, "entity is not a grenade or projectile or it already exploded");
  if ( Scr_GetNumParam(scrContext) )
  {
    if ( Scr_GetType(scrContext, 0) )
    {
      v9 = GScr_GetEntity(0);
      v8 = v9;
      if ( !v9->client && !v9->agent )
        Scr_ParamError(COM_ERR_4311, scrContext, 0, "Entity is not a player or agent");
    }
    else
    {
      v8 = g_entities + 2046;
    }
    EntHandle::setEnt(&Entity->parent, v8);
  }
  G_Missile_Explode(Entity);
}

/*
==============
GScr_FilterOutPlayerMarks
==============
*/
void GScr_FilterOutPlayerMarks(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  GScr_FilterPlayerMarks_Internal(scrContext, (unsigned int (*)[7])Entity->markFilterOut);
}

/*
==============
GScr_FilterInPlayerMarks
==============
*/
void GScr_FilterInPlayerMarks(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  GScr_FilterPlayerMarks_Internal(scrContext, (unsigned int (*)[7])Entity->markFilterIn);
}

/*
==============
GScr_GetPlayerMarks
==============
*/
void GScr_GetPlayerMarks(scrContext_t *scrContext, scr_entref_t entref)
{
  scr_string_t MarkName; 

  _RBX = GetEntity(entref);
  Scr_MakeArray(scrContext);
  for ( LOBYTE(_RBX) = _RBX->markFlags; (_BYTE)_RBX; LODWORD(_RBX) = (unsigned __int8)_RBX ^ (1 << _EDI) )
  {
    LODWORD(_RBX) = (unsigned __int8)_RBX;
    __asm { tzcnt   edi, ebx }
    MarkName = G_EntityMarks_GetMarkName((const EntityMarkType)_EDI);
    Scr_AddConstString(scrContext, MarkName);
    Scr_AddArray(scrContext);
  }
}

/*
==============
GScr_SetPlayerIgnoreRadiusDamage
==============
*/
void GScr_SetPlayerIgnoreRadiusDamage(scrContext_t *scrContext)
{
  level.bPlayerIgnoreRadiusDamageLatched = Scr_GetInt(scrContext, 0);
}

/*
==============
GScr_GetPlayerRateOfGameRevenue
==============
*/
void GScr_GetPlayerRateOfGameRevenue(scrContext_t *scrContext)
{
  __asm
  {
    vmovaps [rsp+38h+var_18], xmm6
    vmovss  xmm6, cs:__real@3f800000
  }
  if ( g_wegame_platform->current.enabled && Scr_GetType(scrContext, 0) == VAR_POINTER && Scr_GetPointerType(scrContext, 0) == VAR_ENTITY )
  {
    if ( GScr_GetEntity(0)->client )
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rcx+5D2Ch]
        vaddss  xmm6, xmm0, xmm6
      }
    }
  }
  __asm
  {
    vmovaps xmm1, xmm6; value
    vmovaps xmm6, [rsp+38h+var_18]
  }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
GScr_DamageConeTrace
==============
*/
void GScr_DamageConeTrace(scrContext_t *scrContext, scr_entref_t entref)
{
  GScr_DamageConeTraceInternal(scrContext, entref, 9441297);
}

/*
==============
GScr_GetBnetIGRPlayerXPMultiplier
==============
*/
void GScr_GetBnetIGRPlayerXPMultiplier(scrContext_t *scrContext)
{
  __asm { vmovss  xmm1, cs:__real@3f800000; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
GScr_SightConeTrace
==============
*/
void GScr_SightConeTrace(scrContext_t *scrContext, scr_entref_t entref)
{
  GScr_DamageConeTraceInternal(scrContext, entref, 2049);
}

/*
==============
GScr_GetBnetIGRWeaponXPMultiplier
==============
*/
void GScr_GetBnetIGRWeaponXPMultiplier(scrContext_t *scrContext)
{
  __asm { vmovss  xmm1, cs:__real@3f800000; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
GScr_ShellShock
==============
*/

void __fastcall GScr_ShellShock(scrContext_t *scrContext, scr_entref_t entref, double _XMM2_8)
{
  unsigned int entnum; 
  scr_string_t targetname; 
  const char *v8; 
  const char *v9; 
  const char *v16; 
  playerState_s *EntityPlayerState; 
  const char *String; 
  const char *v19; 
  int v20; 
  const char *v33; 
  int v34; 
  __int64 v35; 
  unsigned int Animset; 
  unsigned int Anim; 
  bool IsThrowAnim; 
  SuitAnimType SuitAnimIndexFromPlayerState; 
  unsigned __int64 weaponState; 
  __int64 v41; 
  unsigned int *holdrand; 
  GHandler *Handler; 
  char *fmt; 
  unsigned int outIndex; 

  entnum = entref.entnum;
  _RBP = GetEntity(entref);
  if ( !_RBP && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 14595, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClientOrAgent(_RBP) )
  {
    targetname = _RBP->targetname;
    if ( targetname )
      v8 = SL_ConvertToString(targetname);
    else
      v8 = "<undefined>";
    v9 = SL_ConvertToString(_RBP->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rbp+134h]
      vmovss  xmm2, dword ptr [rbp+130h]
      vmovss  xmm0, dword ptr [rbp+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+58h+fmt], xmm0
    }
    v16 = j_va("only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, fmt, v9, v8);
    Scr_Error(COM_ERR_4312, scrContext, v16);
  }
  EntityPlayerState = G_GetEntityPlayerState(_RBP);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 14601, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( Scr_GetNumParam(scrContext) < 2 )
    Scr_Error(COM_ERR_4313, scrContext, "USAGE: <player> shellshock(<shellshockname>, <duration>)\n");
  String = Scr_GetString(scrContext, 0);
  if ( !NetConstStrings_GetIndexPlusOneFromName(NETCONSTSTRINGTYPE_SHOCK, String, &outIndex) )
  {
    v19 = j_va("Shellshock '%s' does not exist", String);
    Scr_Error(COM_ERR_4314, scrContext, v19);
  }
  if ( !outIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 14613, ASSERT_TYPE_ASSERT, "(shockIndex != 0)", "%s\n\tWe use 0 as a sentinel value for the shellshock index to mean no shock, so start at index 1.", "shockIndex != 0") )
    __debugbreak();
  v20 = 1;
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm
  {
    vmulss  xmm1, xmm0, cs:__real@447a0000
    vaddss  xmm3, xmm1, cs:__real@3f000000
    vxorps  xmm2, xmm2, xmm2
    vmovss  xmm4, xmm2, xmm3
    vxorps  xmm0, xmm0, xmm0
    vroundss xmm1, xmm0, xmm4, 1
    vcvttss2si ebx, xmm1
  }
  if ( _EBX < 0 )
  {
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, ebx
      vmulss  xmm1, xmm0, cs:__real@3a83126f
      vcvtss2sd xmm1, xmm1, xmm1
      vmovq   rdx, xmm1
    }
    v33 = j_va("duration %g should be >= 0", _RDX);
    Scr_ParamError(COM_ERR_4315, scrContext, 1u, v33);
  }
  v34 = 0xFFFF;
  EntityPlayerState->shellshockIndex = outIndex;
  if ( _EBX < 0xFFFF )
    v34 = _EBX;
  EntityPlayerState->shellshockTime = level.time;
  EntityPlayerState->shellshockDuration = truncate_cast<unsigned short,int>(v34);
  if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_STILL_LAND|0x80) )
  {
    GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::SetFlagInternal(&EntityPlayerState->pm_flags, ACTIVE, 0x15u);
  }
  else if ( _RBP->health > 0 )
  {
    GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::SetFlagInternal(&EntityPlayerState->pm_flags, ACTIVE, 0x15u);
    if ( Scr_GetNumParam(scrContext) < 3 || Scr_GetInt(scrContext, 2u) )
    {
      v35 = *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 272i64);
      if ( !v35 )
        goto LABEL_45;
      if ( !*(_QWORD *)&GStatic::ms_gameStatics && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_static.h", 64, ASSERT_TYPE_ASSERT, "( ms_gameStatics )", (const char *)&queryFormat, "ms_gameStatics") )
        __debugbreak();
      if ( v35 != *(_QWORD *)&GStatic::ms_gameStatics )
      {
LABEL_45:
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 14641, ASSERT_TYPE_ASSERT, "(BgStatic::HasActiveStatics() && (BgStatic::GetActiveStatics() == GStatic::GetGameStatics()))", "%s\n\tEntering server game character processing without a valid client game state", "BgStatic::HasActiveStatics() && (BgStatic::GetActiveStatics() == GStatic::GetGameStatics())") )
          __debugbreak();
      }
      if ( PlayerASM_IsEnabled() )
      {
        Animset = BG_PlayerASM_GetAnimset(EntityPlayerState);
        Anim = BG_PlayerASM_GetAnim(EntityPlayerState, DODGE);
        IsThrowAnim = BG_PlayerASM_IsThrowAlias(Anim, Animset) != 0;
      }
      else
      {
        SuitAnimIndexFromPlayerState = BG_GetSuitAnimIndexFromPlayerState(EntityPlayerState);
        IsThrowAnim = BG_IsThrowAnim(EntityPlayerState->torsoAnim, SuitAnimIndexFromPlayerState);
      }
      weaponState = EntityPlayerState->weapState[0].weaponState;
      if ( (unsigned int)weaponState <= 0x32 && (v41 = 0x4000000001FBEi64, _bittest64(&v41, weaponState)) || IsThrowAnim )
        v20 = 0;
      holdrand = G_GetRandomSeed();
      Handler = GHandler::getHandler();
      BG_AnimScriptEvent(Handler, EntityPlayerState, ANIM_ET_SHELLSHOCK, 0, v20, holdrand);
    }
  }
}

/*
==============
GScr_GetBnetIGRBattlePassXPMultiplier
==============
*/
void GScr_GetBnetIGRBattlePassXPMultiplier(scrContext_t *scrContext)
{
  __asm { vmovss  xmm1, cs:__real@3f800000; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
GScr_GetBuildVersion
==============
*/
void GScr_GetBuildVersion(scrContext_t *scrContext)
{
  Scr_AddString(scrContext, "IW8_DEV");
}

/*
==============
GScr_GetBuildNumber
==============
*/
void GScr_GetBuildNumber(scrContext_t *scrContext)
{
  int BuildNumberAsInt; 

  BuildNumberAsInt = j_getBuildNumberAsInt();
  Scr_AddInt(scrContext, BuildNumberAsInt);
}

/*
==============
GScr_SpawnBrCircle
==============
*/
void GScr_SpawnBrCircle(scrContext_t *scrContext)
{
  scr_string_t script_model; 

  script_model = scr_const.script_model;
  __asm
  {
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps [rsp+58h+var_28], xmm7
    vmovaps [rsp+58h+var_38], xmm8
  }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm { vmovaps xmm8, xmm0 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm { vmovaps xmm7, xmm0 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
  __asm { vmovaps xmm6, xmm0 }
  _RDI = G_Utils_SpawnEntity();
  Scr_SetString(&_RDI->script_classname, script_model);
  _RDI->spawnflags = 0;
  __asm
  {
    vmovss  dword ptr [rdi+130h], xmm8
    vmovss  dword ptr [rdi+134h], xmm7
    vmovss  dword ptr [rdi+138h], xmm6
  }
  if ( G_Spawn_CallForEntity(_RDI) )
  {
    _RDI->s.un.scriptMoverType = 9;
    GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(&_RDI->s.lerp.eFlags, ACTIVE, 0);
    GScr_AddEntity(_RDI);
  }
  else
  {
    G_FreeEntity(_RDI);
    Scr_Error(COM_ERR_5936, scrContext, "unable to spawn br circle");
  }
  __asm
  {
    vmovaps xmm6, [rsp+58h+var_18]
    vmovaps xmm7, [rsp+58h+var_28]
    vmovaps xmm8, [rsp+58h+var_38]
  }
}

/*
==============
GScr_SpawnMapCircle
==============
*/
void GScr_SpawnMapCircle(scrContext_t *scrContext)
{
  scr_string_t script_model; 
  unsigned int NumParam; 
  gentity_s *v8; 
  gentity_s *Entity; 
  const char *v10; 

  script_model = scr_const.script_model;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam - 3 > 1 )
  {
    Scr_Error(COM_ERR_6076, scrContext, "Usage: SpawnMapCircle( <x>, <y>, <initial_radius>, [owner] )");
  }
  else
  {
    v8 = NULL;
    __asm
    {
      vmovaps [rsp+58h+var_18], xmm6
      vmovaps [rsp+58h+var_28], xmm7
      vmovaps [rsp+58h+var_38], xmm8
    }
    if ( NumParam == 4 && Scr_GetType(scrContext, 3u) == VAR_POINTER && Scr_GetPointerType(scrContext, 3u) == VAR_ENTITY )
    {
      Entity = GScr_GetEntity(3u);
      v8 = Entity;
      if ( !Entity->client )
      {
        v10 = j_va("Owner entity %i is not a player", (unsigned int)Entity->s.number);
        Scr_ObjectError(COM_ERR_6569, scrContext, v10);
      }
    }
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
    __asm { vmovaps xmm8, xmm0 }
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
    __asm { vmovaps xmm7, xmm0 }
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
    __asm { vmovaps xmm6, xmm0 }
    _RBX = G_Utils_SpawnEntity();
    Scr_SetString(&_RBX->script_classname, script_model);
    _RBX->spawnflags = 0;
    __asm
    {
      vmovss  dword ptr [rbx+130h], xmm8
      vmovss  dword ptr [rbx+134h], xmm7
      vmovss  dword ptr [rbx+138h], xmm6
      vmovaps xmm8, [rsp+58h+var_38]
      vmovaps xmm7, [rsp+58h+var_28]
      vmovaps xmm6, [rsp+58h+var_18]
    }
    if ( G_Spawn_CallForEntity(_RBX) )
    {
      _RBX->s.un.scriptMoverType = 10;
      GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(&_RBX->s.lerp.eFlags, ACTIVE, 0);
      _RBX->s.staticState.player.stowedWeaponHandle.m_mapEntryId &= 0xFFFC0000;
      if ( v8 )
        _RBX->s.otherEntityNum = v8->s.number;
      GScr_AddEntity(_RBX);
    }
    else
    {
      G_FreeEntity(_RBX);
      Scr_Error(COM_ERR_6074, scrContext, "unable to spawn map circle");
    }
  }
}

/*
==============
GScr_SetMapCircleColorIndex
==============
*/
void GScr_SetMapCircleColorIndex(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  char Int; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( Entity->s.eType == ET_SCRIPTMOVER && Entity->s.un.scriptMoverType == 10 )
  {
    if ( Scr_GetNumParam(scrContext) == 1 )
    {
      Int = Scr_GetInt(scrContext, 0);
      v4->s.staticState.player.stowedWeaponHandle.m_mapEntryId &= 0xFFFFFFC0;
      v4->s.staticState.player.stowedWeaponHandle.m_mapEntryId |= Int & 0x3F;
    }
    else
    {
      Scr_Error(COM_ERR_6571, scrContext, "Usage: SetMapCircleColorIndex( <idx> )");
    }
  }
  else
  {
    Scr_Error(COM_ERR_6570, scrContext, " SetMapCircleColorIndex() called on an entity that is not a map circle.\n");
  }
}

/*
==============
GScr_SetMapCircleStyleIndex
==============
*/
void GScr_SetMapCircleStyleIndex(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  char Int; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( Entity->s.eType == ET_SCRIPTMOVER && Entity->s.un.scriptMoverType == 10 )
  {
    if ( Scr_GetNumParam(scrContext) == 1 )
    {
      Int = Scr_GetInt(scrContext, 0);
      v4->s.staticState.player.stowedWeaponHandle.m_mapEntryId &= 0xFFFFF03F;
      v4->s.staticState.player.stowedWeaponHandle.m_mapEntryId |= (Int & 0x3F) << 6;
    }
    else
    {
      Scr_Error(COM_ERR_6154, scrContext, "Usage: SetMapCircleStyleIndex( <idx> )");
    }
  }
  else
  {
    Scr_Error(COM_ERR_6153, scrContext, " SetMapCircleStyleIndex() called on an entity that is not a map circle.\n");
  }
}

/*
==============
GScr_StunPlayer
==============
*/

void __fastcall GScr_StunPlayer(scrContext_t *scrContext, scr_entref_t entref, double _XMM2_8)
{
  unsigned int entnum; 
  scr_string_t targetname; 
  const char *v8; 
  const char *v9; 
  const char *v16; 
  playerState_s *EntityPlayerState; 
  const char *v30; 
  char *fmt; 

  entnum = entref.entnum;
  _RDI = GetEntity(entref);
  if ( !G_Utils_IsClientOrAgent(_RDI) )
  {
    targetname = _RDI->targetname;
    if ( targetname )
      v8 = SL_ConvertToString(targetname);
    else
      v8 = "<undefined>";
    v9 = SL_ConvertToString(_RDI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rdi+134h]
      vmovss  xmm2, dword ptr [rdi+130h]
      vmovss  xmm0, dword ptr [rdi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+48h+fmt], xmm0
    }
    v16 = j_va("only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, fmt, v9, v8);
    Scr_Error(COM_ERR_4316, scrContext, v16);
  }
  EntityPlayerState = G_GetEntityPlayerState(_RDI);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 14682, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
    __debugbreak();
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm
  {
    vmulss  xmm1, xmm0, cs:__real@447a0000
    vaddss  xmm3, xmm1, cs:__real@3f000000
    vxorps  xmm2, xmm2, xmm2
    vmovss  xmm4, xmm2, xmm3
    vxorps  xmm0, xmm0, xmm0
    vroundss xmm1, xmm0, xmm4, 1
    vcvttss2si edi, xmm1
  }
  if ( _EDI < 0 )
  {
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, edi
      vmulss  xmm1, xmm0, cs:__real@3a83126f
      vcvtss2sd xmm1, xmm1, xmm1
      vmovq   rdx, xmm1
    }
    v30 = j_va("duration %g should be >= 0", _RDX);
    Scr_ParamError(COM_ERR_4317, scrContext, 0, v30);
  }
  EntityPlayerState->stunTime = _EDI + level.time;
}

/*
==============
GScr_SetMapCircleIconIndex
==============
*/
void GScr_SetMapCircleIconIndex(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  char Int; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( Entity->s.eType == ET_SCRIPTMOVER && Entity->s.un.scriptMoverType == 10 )
  {
    if ( Scr_GetNumParam(scrContext) == 1 )
    {
      Int = Scr_GetInt(scrContext, 0);
      v4->s.staticState.player.stowedWeaponHandle.m_mapEntryId &= 0xFFFC0FFF;
      v4->s.staticState.player.stowedWeaponHandle.m_mapEntryId |= (Int & 0x3F) << 12;
    }
    else
    {
      Scr_Error(COM_ERR_6156, scrContext, "Usage: SetMapCircleIconIndex( <idx> )");
    }
  }
  else
  {
    Scr_Error(COM_ERR_6155, scrContext, " SetMapCircleIconIndex() called on an entity that is not a map circle.\n");
  }
}

/*
==============
GScr_GetMoveDelta
==============
*/
void GScr_GetMoveDelta(scrContext_t *scrContext)
{
  unsigned int v10; 
  char v11; 
  char v12; 
  char v13; 
  char v14; 
  int linkPointer; 
  unsigned int v16; 
  const XAnim_s *Anims; 
  float v22; 
  float v23; 
  vec3_t trans; 
  vec4_t rot; 
  char v27; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-18h], xmm6
    vmovaps xmmword ptr [rax-28h], xmm7
    vmovaps xmmword ptr [rax-38h], xmm9
    vmovss  xmm7, cs:__real@3f800000
    vxorps  xmm9, xmm9, xmm9
    vxorps  xmm6, xmm6, xmm6
  }
  v10 = Scr_GetNumParam(scrContext) - 1;
  if ( v10 )
  {
    if ( v10 != 1 )
    {
      *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
      __asm
      {
        vcomiss xmm0, xmm9
        vmovaps xmm7, xmm0
      }
      if ( v11 )
        goto LABEL_5;
      __asm { vcomiss xmm0, cs:__real@3f800000 }
      if ( !(v11 | v12) )
LABEL_5:
        Scr_ParamError(COM_ERR_4318, scrContext, 2u, "end time must be between 0 and 1");
    }
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
    __asm
    {
      vcomiss xmm0, xmm9
      vmovaps xmm6, xmm0
    }
    if ( v13 )
      goto LABEL_8;
    __asm { vcomiss xmm0, cs:__real@3f800000 }
    if ( !(v13 | v14) )
LABEL_8:
      Scr_ParamError(COM_ERR_4319, scrContext, 1u, "start time must be between 0 and 1");
  }
  linkPointer = Scr_GetAnim(scrContext, 0, NULL).linkPointer;
  v16 = (unsigned __int16)linkPointer;
  Anims = Scr_GetAnims(scrContext, HIWORD(linkPointer));
  __asm
  {
    vmovss  [rsp+98h+var_70], xmm7
    vmovss  [rsp+98h+var_78], xmm6
  }
  XAnimGetRelDelta3D(Anims, v16, &rot, &trans, v22, v23);
  Scr_AddVector(scrContext, trans.v);
  _R11 = &v27;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, [rsp+98h+var_28]
    vmovaps xmm9, xmmword ptr [r11-30h]
  }
}

/*
==============
GScr_NvidiaHighlightsRequestPermissions
==============
*/
void GScr_NvidiaHighlightsRequestPermissions(scrContext_t *scrContext)
{
  ;
}

/*
==============
GScr_NvidiaHighlightsIsEnabled
==============
*/
void GScr_NvidiaHighlightsIsEnabled(scrContext_t *scrContext)
{
  Scr_AddBool(scrContext, 0);
}

/*
==============
GScr_NvidiaHighlightsBeginGroup
==============
*/
void GScr_NvidiaHighlightsBeginGroup(scrContext_t *scrContext)
{
  ;
}

/*
==============
GScr_NvidiaHighlightsEndGroup
==============
*/
void GScr_NvidiaHighlightsEndGroup(scrContext_t *scrContext)
{
  ;
}

/*
==============
GScr_NvidiaHighlightsScreenshot
==============
*/
void GScr_NvidiaHighlightsScreenshot(scrContext_t *scrContext)
{
  ;
}

/*
==============
GScr_NvidiaHighlightsVideo
==============
*/
void GScr_NvidiaHighlightsVideo(scrContext_t *scrContext)
{
  ;
}

/*
==============
GScr_NvidiaHighlightsGetCount
==============
*/
void GScr_NvidiaHighlightsGetCount(scrContext_t *scrContext)
{
  ;
}

/*
==============
GScr_NvidiaHighlightsSummary
==============
*/
void GScr_NvidiaHighlightsSummary(scrContext_t *scrContext)
{
  ;
}

/*
==============
GScr_NvidiaHighlightsCleanup
==============
*/
void GScr_NvidiaHighlightsCleanup(scrContext_t *scrContext)
{
  ;
}

/*
==============
GScr_NvidiaAnselIsEnabled
==============
*/
void GScr_NvidiaAnselIsEnabled(scrContext_t *scrContext)
{
  Scr_AddBool(scrContext, 0);
}

/*
==============
GScr_GetAngleDelta
==============
*/
void GScr_GetAngleDelta(scrContext_t *scrContext)
{
  unsigned int v10; 
  char v11; 
  char v12; 
  char v13; 
  char v14; 
  int linkPointer; 
  unsigned __int16 v16; 
  const XAnim_s *Anims; 
  float v23; 
  float v24; 
  vec2_t rot; 
  vec3_t trans; 
  char v28; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-18h], xmm6
    vmovaps xmmword ptr [rax-28h], xmm7
    vmovaps xmmword ptr [rax-38h], xmm9
    vmovss  xmm7, cs:__real@3f800000
    vxorps  xmm9, xmm9, xmm9
    vxorps  xmm6, xmm6, xmm6
  }
  v10 = Scr_GetNumParam(scrContext) - 1;
  if ( v10 )
  {
    if ( v10 != 1 )
    {
      *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
      __asm
      {
        vcomiss xmm0, xmm9
        vmovaps xmm7, xmm0
      }
      if ( v11 )
        goto LABEL_5;
      __asm { vcomiss xmm0, cs:__real@3f800000 }
      if ( !(v11 | v12) )
LABEL_5:
        Scr_ParamError(COM_ERR_4320, scrContext, 2u, "end time must be between 0 and 1");
    }
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
    __asm
    {
      vcomiss xmm0, xmm9
      vmovaps xmm6, xmm0
    }
    if ( v13 )
      goto LABEL_8;
    __asm { vcomiss xmm0, cs:__real@3f800000 }
    if ( !(v13 | v14) )
LABEL_8:
      Scr_ParamError(COM_ERR_4321, scrContext, 1u, "start time must be between 0 and 1");
  }
  linkPointer = Scr_GetAnim(scrContext, 0, NULL).linkPointer;
  v16 = linkPointer;
  Anims = Scr_GetAnims(scrContext, HIWORD(linkPointer));
  __asm
  {
    vmovss  [rsp+98h+var_70], xmm7
    vmovss  [rsp+98h+var_78], xmm6
  }
  XAnimGetRelDelta(Anims, v16, &rot, &trans, v23, v24);
  *(double *)&_XMM0 = RotationToYaw(&rot);
  __asm { vmovaps xmm1, xmm0; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
  _R11 = &v28;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, [rsp+98h+var_28]
    vmovaps xmm9, xmmword ptr [r11-30h]
  }
}

/*
==============
Scr_StreamSetMaterialTouchUntilLoaded
==============
*/
void Scr_StreamSetMaterialTouchUntilLoaded(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *String; 
  const char *v5; 
  unsigned int v6; 
  const char *v7; 
  const char *v8; 
  unsigned int number; 
  const char *v10; 
  SvClient *CommonClient; 

  Entity = GetEntity(entref);
  if ( !Entity->client )
    Scr_ObjectError(COM_ERR_6300, scrContext, "StreamSetMaterialTouchUntilLoaded can only be called on players");
  String = Scr_GetString(scrContext, 0);
  v5 = String;
  if ( !String || !*String )
    Scr_ParamError(COM_ERR_6063, scrContext, 0, "Material name string is empty");
  if ( !GConfigStrings::ms_gConfigStrings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_configstrings.h", 71, ASSERT_TYPE_ASSERT, "( ms_gConfigStrings )", (const char *)&queryFormat, "ms_gConfigStrings") )
    __debugbreak();
  v6 = GConfigStrings::ms_gConfigStrings->GetMaterialIndex(GConfigStrings::ms_gConfigStrings, v5);
  if ( !v6 )
  {
    v7 = j_va("Material '%s' is not precached.", v5);
    Scr_ParamError(COM_ERR_6064, scrContext, 0, v7);
  }
  v8 = j_va("%c %i", 98i64, v6);
  number = Entity->s.number;
  v10 = v8;
  if ( number == -1 )
  {
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v8);
  }
  else
  {
    CommonClient = SvClient::GetCommonClient(number);
    CommonClient->SendServerCommand(CommonClient, SV_CMD_RELIABLE, v10);
  }
}

/*
==============
GScr_GetAngleDelta3D
==============
*/
void GScr_GetAngleDelta3D(scrContext_t *scrContext)
{
  unsigned int v10; 
  char v11; 
  char v12; 
  char v13; 
  char v14; 
  int linkPointer; 
  unsigned int v16; 
  const XAnim_s *Anims; 
  float v22; 
  float v23; 
  vec3_t angles; 
  vec4_t rot; 
  vec3_t trans; 
  tmat33_t<vec3_t> axis; 
  char v28; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-18h], xmm6
    vmovaps xmmword ptr [rax-28h], xmm7
    vmovaps xmmword ptr [rax-38h], xmm9
    vmovss  xmm7, cs:__real@3f800000
    vxorps  xmm9, xmm9, xmm9
    vxorps  xmm6, xmm6, xmm6
  }
  v10 = Scr_GetNumParam(scrContext) - 1;
  if ( v10 )
  {
    if ( v10 != 1 )
    {
      *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
      __asm
      {
        vcomiss xmm0, xmm9
        vmovaps xmm7, xmm0
      }
      if ( v11 )
        goto LABEL_5;
      __asm { vcomiss xmm0, cs:__real@3f800000 }
      if ( !(v11 | v12) )
LABEL_5:
        Scr_ParamError(COM_ERR_4322, scrContext, 2u, "end time must be between 0 and 1");
    }
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
    __asm
    {
      vcomiss xmm0, xmm9
      vmovaps xmm6, xmm0
    }
    if ( v13 )
      goto LABEL_8;
    __asm { vcomiss xmm0, cs:__real@3f800000 }
    if ( !(v13 | v14) )
LABEL_8:
      Scr_ParamError(COM_ERR_4323, scrContext, 1u, "start time must be between 0 and 1");
  }
  linkPointer = Scr_GetAnim(scrContext, 0, NULL).linkPointer;
  v16 = (unsigned __int16)linkPointer;
  Anims = Scr_GetAnims(scrContext, HIWORD(linkPointer));
  __asm
  {
    vmovss  [rsp+0C8h+var_A0], xmm7
    vmovss  [rsp+0C8h+var_A8], xmm6
  }
  XAnimGetRelDelta3D(Anims, v16, &rot, &trans, v22, v23);
  QuatToAxis(&rot, &axis);
  AxisToAngles(&axis, &angles);
  Scr_AddVector(scrContext, angles.v);
  _R11 = &v28;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm9, xmmword ptr [r11-30h]
  }
}

/*
==============
GScr_ScriptableIsLootCache
==============
*/
void GScr_ScriptableIsLootCache(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  unsigned int v4; 
  const ScriptableDef *def; 
  const BG_SpawnGroup_Loot_ItemDef *LootItemDef; 
  unsigned __int8 itemTypeIndexCache; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  v4 = ScriptableIndex_Internal;
  if ( ScriptableIndex_Internal == -1 )
  {
    Scr_Error(COM_ERR_6425, scrContext, "Invalid scriptable index");
  }
  else
  {
    def = ScriptableSv_GetInstanceCommonContext(ScriptableIndex_Internal)->def;
    if ( def && (def->flags & 0x20000) != 0 && (LootItemDef = ScriptableSv_GetLootItemDef(v4)) != NULL && (itemTypeIndexCache = ScriptableSv_GetLootTable()->itemTypeIndexCache, itemTypeIndexCache != 0xFF) )
      Scr_AddBool(scrContext, itemTypeIndexCache == LootItemDef->type);
    else
      Scr_AddBool(scrContext, 0);
  }
}

/*
==============
GScr_GetNorthYaw
==============
*/
void GScr_GetNorthYaw(scrContext_t *scrContext)
{
  char buffer[32]; 

  SV_GetConfigstring(9u, buffer, 32);
  *(double *)&_XMM0 = atof(buffer);
  __asm { vcvtsd2ss xmm1, xmm0, xmm0; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
GScr_ScriptableGetMidPoint
==============
*/
void GScr_ScriptableGetMidPoint(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  const XModel *ScriptableModel; 
  float value; 
  vec3_t out; 
  tmat33_t<vec3_t> axis; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal == -1 )
  {
    Scr_Error(COM_ERR_6426, scrContext, "Invalid scriptable index");
  }
  else
  {
    _RBX = ScriptableSv_GetInstanceCommonContext(ScriptableIndex_Internal);
    ScriptableModel = BG_XCompositeModel_GetScriptableModel(_RBX);
    if ( ScriptableModel )
    {
      AnglesToAxis(&_RBX->angles, &axis);
      MatrixTransformVector(&ScriptableModel->bounds.midPoint, &axis, &out);
      __asm
      {
        vmovss  xmm0, dword ptr [rsp+78h+out]
        vaddss  xmm1, xmm0, dword ptr [rbx+20h]
        vmovss  xmm2, dword ptr [rsp+78h+out+4]
        vmovss  [rsp+78h+value], xmm1
        vaddss  xmm0, xmm2, dword ptr [rbx+24h]
        vmovss  xmm1, dword ptr [rsp+78h+out+8]
        vmovss  [rsp+78h+var_54], xmm0
        vaddss  xmm2, xmm1, dword ptr [rbx+28h]
        vmovss  [rsp+78h+var_50], xmm2
      }
    }
    else
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rbx+20h]
        vmovss  [rsp+78h+value], xmm0
        vmovss  xmm1, dword ptr [rbx+24h]
        vmovss  [rsp+78h+var_54], xmm1
        vmovss  xmm0, dword ptr [rbx+28h]
        vmovss  [rsp+78h+var_50], xmm0
      }
    }
    Scr_AddVector(scrContext, &value);
  }
}

/*
==============
Scr_IsVFXFile
==============
*/
void Scr_IsVFXFile(scrContext_t *scrContext)
{
  unsigned int Int; 
  const char *v3; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4324, scrContext, "Incorrect number of parameters");
  Int = Scr_GetInt(scrContext, 0);
  if ( !FX_IsValidFxId(Int) )
  {
    v3 = j_va("IsVFXFile: invalid effect id %d", Int);
    Scr_Error(COM_ERR_4325, scrContext, v3);
  }
  Scr_AddBool(scrContext, 1);
}

/*
==============
GScr_ScriptableDoorFreeze
==============
*/
void GScr_ScriptableDoorFreeze(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  bool v4; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal == -1 )
  {
    Scr_Error(COM_ERR_6182, scrContext, "Invalid scriptable index");
  }
  else
  {
    v4 = 1;
    if ( Scr_GetNumParam(scrContext) )
      v4 = Scr_GetInt(scrContext, 0) != 0;
    G_Door_Freeze(v4, ScriptableIndex_Internal);
  }
}

/*
==============
GScr_ScriptableDoorIsClosed
==============
*/
void GScr_ScriptableDoorIsClosed(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  bool IsClosed; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal == -1 )
  {
    Scr_Error(COM_ERR_6183, scrContext, "Invalid scriptable index");
  }
  else
  {
    IsClosed = G_Door_IsClosed(ScriptableIndex_Internal);
    Scr_AddBool(scrContext, IsClosed);
  }
}

/*
==============
GScr_ScriptableDoorIsOwned
==============
*/
void GScr_ScriptableDoorIsOwned(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  int Owner; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal == -1 )
  {
    Scr_Error(COM_ERR_6184, scrContext, "Invalid scriptable index");
  }
  else
  {
    Owner = G_Door_GetOwner(ScriptableIndex_Internal);
    Scr_AddBool(scrContext, Owner != -1);
  }
}

/*
==============
GScr_ScriptableIsDoor
==============
*/
void GScr_ScriptableIsDoor(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  const ScriptableDef *def; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal == -1 )
  {
    Scr_Error(COM_ERR_6185, scrContext, "Invalid scriptable index");
  }
  else
  {
    def = ScriptableSv_GetInstanceCommonContext(ScriptableIndex_Internal)->def;
    if ( def )
      Scr_AddBool(scrContext, (def->flags & 0x180000) != 0);
    else
      Scr_AddBool(scrContext, 0);
  }
}

/*
==============
Scr_LoadFX
==============
*/
void Scr_LoadFX(scrContext_t *scrContext)
{
  const char *v2; 
  char *String; 
  __int64 v4; 
  char v5; 
  __int64 v6; 
  char v7; 
  const char *v8; 
  __int64 v9; 
  char v10; 
  __int64 v11; 
  char v12; 
  char *v13; 
  int v14; 
  char dest[128]; 

  v2 = "fx/";
  String = (char *)Scr_GetString(scrContext, 0);
  v4 = 3i64;
  if ( !String && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 181, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
    __debugbreak();
  do
  {
    v5 = v2[String - "fx/"];
    v6 = v4;
    v7 = *v2++;
    --v4;
    if ( !v6 )
      break;
    if ( v5 != v7 )
    {
      v8 = "vfx/";
      v9 = 4i64;
      if ( !String && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 181, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
        __debugbreak();
      while ( 1 )
      {
        v10 = v8[String - "vfx/"];
        v11 = v9;
        v12 = *v8++;
        --v9;
        if ( !v11 )
          goto LABEL_16;
        if ( v10 != v12 )
        {
          Scr_ParamError(COM_ERR_4327, scrContext, 0, "effect name must start with 'fx/' or 'vfx/'");
          goto LABEL_16;
        }
        if ( !v10 )
          goto LABEL_16;
      }
    }
  }
  while ( v5 );
LABEL_16:
  v13 = strrchr_0(String, 46);
  if ( v13 )
  {
    Core_strncpy_truncate(dest, 0x80ui64, String, v13 - String);
    String = dest;
  }
  if ( !GConfigStrings::ms_gConfigStrings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_configstrings.h", 71, ASSERT_TYPE_ASSERT, "( ms_gConfigStrings )", (const char *)&queryFormat, "ms_gConfigStrings") )
    __debugbreak();
  v14 = GConfigStrings::ms_gConfigStrings->GetEffectIndex(GConfigStrings::ms_gConfigStrings, String);
  if ( !v14 )
  {
    if ( level.initializing )
      Com_PrintError(23, "Could not allocate/find effect ID for '%s'\n", String);
    else
      Scr_Error(COM_ERR_4328, scrContext, "loadFx must be called before any wait statements in the level script, or on an already loaded effect\n");
  }
  Scr_AddInt(scrContext, v14);
}

/*
==============
GScr_ScriptableDoorIsDouble
==============
*/
void GScr_ScriptableDoorIsDouble(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  ScriptableInstanceContext *InstanceCommonContext; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal == -1 )
  {
    Scr_Error(COM_ERR_6186, scrContext, "Invalid scriptable index");
  }
  else
  {
    InstanceCommonContext = ScriptableSv_GetInstanceCommonContext(ScriptableIndex_Internal);
    if ( InstanceCommonContext->def )
      Scr_AddBool(scrContext, ((unsigned int)InstanceCommonContext->def->flags >> 20) & 1);
    else
      Scr_AddBool(scrContext, 0);
  }
}

/*
==============
GScr_ScriptableDoorAngle
==============
*/
void GScr_ScriptableDoorAngle(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal == -1 )
  {
    Scr_Error(COM_ERR_6187, scrContext, "Invalid scriptable index");
  }
  else
  {
    *(double *)&_XMM0 = G_Door_GetDeltaAngle(ScriptableIndex_Internal);
    __asm { vmovaps xmm1, xmm0; value }
    Scr_AddFloat(scrContext, *(float *)&_XMM1);
  }
}

/*
==============
GScr_ScriptableDoorOpen
==============
*/
void GScr_ScriptableDoorOpen(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  scr_string_t ConstString; 
  DoorMoveType v5; 
  vec3_t v7; 
  vec3_t vectorValue; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal == -1 )
  {
    Scr_Error(COM_ERR_6188, scrContext, "Invalid scriptable index");
    return;
  }
  if ( !Scr_GetNumParam(scrContext) || (ConstString = Scr_GetConstString(scrContext, 0), ConstString == scr_const.left) )
  {
    v5 = DOOR_MOVE_OPEN_LEFT_RELIABLE;
    goto LABEL_14;
  }
  if ( ConstString == scr_const.right )
  {
    v5 = DOOR_MOVE_OPEN_RIGHT_RELIABLE;
LABEL_14:
    G_Door_MoveReliably(ScriptableIndex_Internal, v5);
    return;
  }
  if ( ConstString == scr_const.away )
  {
    if ( Scr_GetNumParam(scrContext) == 2 && Scr_GetType(scrContext, 1u) == VAR_VECTOR )
    {
      Scr_GetVector(scrContext, 1u, &vectorValue);
      __asm { vmovsd  xmm0, qword ptr [rsp+58h+vectorValue] }
      v7.v[2] = vectorValue.v[2];
      __asm { vmovsd  [rsp+58h+var_38], xmm0 }
      G_Door_OpenReliablyFromPosition(ScriptableIndex_Internal, &v7);
    }
    else
    {
      Scr_Error(COM_ERR_6189, scrContext, "ScriptableDoorOpen - Bad openAwayFromPosition input");
    }
  }
  else
  {
    Scr_Error(COM_ERR_6190, scrContext, "ScriptableDoorOpen - Bad openDir input");
  }
}

/*
==============
GScr_ScriptableDoorClose
==============
*/
void GScr_ScriptableDoorClose(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal == -1 )
    Scr_Error(COM_ERR_6191, scrContext, "Invalid scriptable index");
  else
    G_Door_MoveReliably(ScriptableIndex_Internal, DOOR_MOVE_CLOSE_RELIABLE);
}

/*
==============
ScrCmd_HasTacVis
==============
*/
void ScrCmd_HasTacVis(scrContext_t *scrContext)
{
  int v1; 
  const tacpoint_t *PointForPathnodeVis; 
  const tacpoint_t *ClosestPoint; 
  VariableType Type; 
  const tacpoint_t *PointForPathnode; 
  sentient_s *sentient; 
  const pathnode_t *Pathnode; 
  bool HasVis; 
  scr_entref_t EntityRef; 
  vec3_t vectorValue; 

  v1 = 0;
  PointForPathnodeVis = NULL;
  Scr_GetVector(scrContext, 0, &vectorValue);
  ClosestPoint = TacGraph_FindClosestPoint(&vectorValue);
  if ( ClosestPoint )
  {
    Type = Scr_GetType(scrContext, 1u);
    if ( Type == VAR_VECTOR )
    {
      Scr_GetVector(scrContext, 1u, &vectorValue);
      PointForPathnode = TacGraph_FindClosestPoint(&vectorValue);
    }
    else
    {
      if ( Type != VAR_POINTER || Scr_GetPointerType(scrContext, 1u) != VAR_ENTITY )
        goto LABEL_18;
      EntityRef = Scr_GetEntityRef(scrContext, 1u);
      if ( EntityRef.entclass )
      {
        if ( EntityRef.entclass != ENTITY_CLASS_PATHNODE )
          goto LABEL_18;
        Pathnode = Scr_GetPathnode(scrContext, 1u);
        PointForPathnode = TacGraph_GetPointForPathnode(Pathnode);
        if ( Scr_GetNumParam(scrContext) > 2 && Scr_GetInt(scrContext, 2u) )
          PointForPathnodeVis = TacGraph_GetPointForPathnodeVis(Pathnode);
      }
      else
      {
        sentient = GScr_GetEntity(1u)->sentient;
        if ( !sentient )
          goto LABEL_18;
        PointForPathnode = Sentient_NearestTacPoint(sentient);
      }
    }
    if ( PointForPathnode )
    {
      HasVis = TacVisGraph_HasVis(ClosestPoint, PointForPathnode);
      if ( HasVis && PointForPathnodeVis )
        HasVis = TacVisGraph_HasVis(ClosestPoint, PointForPathnodeVis);
      v1 = HasVis;
    }
  }
LABEL_18:
  Scr_AddBool(scrContext, v1);
}

/*
==============
Scr_PlayFX
==============
*/
void Scr_PlayFX(scrContext_t *scrContext)
{
  int NumParam; 
  vec3_t *v3; 
  __int16 *p_number; 
  gentity_s *Entity; 
  const char *v6; 
  int Int; 
  vec3_t *v8; 
  gentity_s *v9; 
  const gentity_s *v10; 
  unsigned int v11; 
  vec3_t v12; 
  vec3_t v13; 
  vec3_t vectorValue; 

  NumParam = Scr_GetNumParam(scrContext);
  if ( (unsigned int)(NumParam - 2) > 3 )
    Scr_Error(COM_ERR_4331, scrContext, "Incorrect number of parameters");
  v3 = NULL;
  p_number = NULL;
  if ( NumParam >= 5 )
  {
    Entity = GScr_GetEntity(4u);
    p_number = &Entity->s.number;
    if ( !Entity->client )
    {
      v6 = j_va("Entity number %i is not a client", (unsigned int)Entity->s.number);
      Scr_ParamError(COM_ERR_4332, scrContext, 5u, v6);
    }
    if ( (unsigned int)*p_number >= level.maxclients && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 15069, ASSERT_TYPE_ASSERT, "(unsigned)( player->s.number ) < (unsigned)( level.maxclients )", "player->s.number doesn't index level.maxclients\n\t%i not in [0, %i)", *p_number, level.maxclients) )
      __debugbreak();
  }
  Int = Scr_GetInt(scrContext, 0);
  Scr_GetVector(scrContext, 1u, &vectorValue);
  v8 = NULL;
  if ( NumParam > 2 )
  {
    if ( Scr_GetType(scrContext, 2u) )
    {
      Scr_GetVector(scrContext, 2u, &v12);
      v3 = &v12;
    }
    if ( NumParam > 3 && Scr_GetType(scrContext, 3u) )
    {
      Scr_GetVector(scrContext, 3u, &v13);
      v8 = &v13;
    }
  }
  v9 = Scr_PlayFXInternal(scrContext, Int, &vectorValue, v3, v8);
  v10 = v9;
  if ( p_number )
  {
    *(_QWORD *)v9->clientMask.array = -1i64;
    *(_QWORD *)&v9->clientMask.array[2] = -1i64;
    *(_QWORD *)&v9->clientMask.array[4] = -1i64;
    v9->clientMask.array[6] = -1;
    v11 = *p_number;
    if ( v11 >= 0xE0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 290, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v11, 224) )
      __debugbreak();
    v10->clientMask.array[(unsigned __int64)v11 >> 5] &= ~(0x80000000 >> (v11 & 0x1F));
  }
  else
  {
    GScr_Main_ClientmaskSetAllVisible(v9);
  }
  GScr_AddEntity(v10);
}

/*
==============
Scr_PlayFXOnTag
==============
*/
void Scr_PlayFXOnTag(scrContext_t *scrContext)
{
  unsigned int Int; 
  gentity_s *Entity; 
  scr_string_t ConstLowercaseString; 

  if ( Scr_GetNumParam(scrContext) != 3 )
    Scr_Error(COM_ERR_4336, scrContext, "Incorrect number of parameters");
  Int = Scr_GetInt(scrContext, 0);
  Entity = GScr_GetEntity(1u);
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 2u);
  Scr_PlayFxOnTagInternal(scrContext, Entity, Int, ConstLowercaseString, -1);
}

/*
==============
Scr_PlayFXOnTagForClients
==============
*/
void Scr_PlayFXOnTagForClients(scrContext_t *scrContext)
{
  unsigned int Int; 
  gentity_s *Entity; 
  scr_string_t ConstLowercaseString; 
  gentity_s *v5; 
  gentity_s *v6; 
  const char *v7; 
  int number; 
  int maxclients; 

  if ( Scr_GetNumParam(scrContext) < 4 )
    Scr_Error(COM_ERR_4337, scrContext, "Incorrect number of parameters");
  Int = Scr_GetInt(scrContext, 0);
  Entity = GScr_GetEntity(1u);
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 2u);
  if ( Scr_GetType(scrContext, 3u) == VAR_ARRAY )
    Scr_ParamError(COM_ERR_4338, scrContext, 3u, "No longer support arrays of player, please specify a player entity");
  v5 = GScr_GetEntity(3u);
  v6 = v5;
  if ( !v5->client )
  {
    v7 = j_va("Entity number %i is not a client", (unsigned int)v5->s.number);
    Scr_ParamError(COM_ERR_4339, scrContext, 3u, v7);
  }
  if ( (unsigned int)v6->s.number >= level.maxclients )
  {
    maxclients = level.maxclients;
    number = v6->s.number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 15221, ASSERT_TYPE_ASSERT, "(unsigned)( player->s.number ) < (unsigned)( level.maxclients )", "player->s.number doesn't index level.maxclients\n\t%i not in [0, %i)", number, maxclients) )
      __debugbreak();
  }
  Scr_PlayFxOnTagInternal(scrContext, Entity, Int, ConstLowercaseString, v6->s.number);
}

/*
==============
Scr_StopFXOnTag
==============
*/
void Scr_StopFXOnTag(scrContext_t *scrContext)
{
  unsigned int Int; 
  gentity_s *Entity; 
  scr_string_t ConstLowercaseString; 

  if ( Scr_GetNumParam(scrContext) != 3 )
    Scr_Error(COM_ERR_4343, scrContext, "Incorrect number of parameters");
  Int = Scr_GetInt(scrContext, 0);
  Entity = GScr_GetEntity(1u);
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 2u);
  Scr_StopFxOnTagInternal(scrContext, Entity, Int, ConstLowercaseString, -1);
}

/*
==============
Scr_StopFXOnTagForClients
==============
*/
void Scr_StopFXOnTagForClients(scrContext_t *scrContext)
{
  unsigned int Int; 
  gentity_s *Entity; 
  scr_string_t ConstLowercaseString; 
  gentity_s *v5; 
  gentity_s *v6; 
  const char *v7; 
  int number; 
  int maxclients; 

  if ( Scr_GetNumParam(scrContext) < 4 )
    Scr_Error(COM_ERR_4344, scrContext, "Incorrect number of parameters");
  Int = Scr_GetInt(scrContext, 0);
  Entity = GScr_GetEntity(1u);
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 2u);
  if ( Scr_GetType(scrContext, 3u) == VAR_ARRAY )
    Scr_ParamError(COM_ERR_4345, scrContext, 3u, "No longer support arrays of player, please specify a player entity");
  v5 = GScr_GetEntity(3u);
  v6 = v5;
  if ( !v5->client )
  {
    v7 = j_va("Entity number %i is not a client", (unsigned int)v5->s.number);
    Scr_ParamError(COM_ERR_4346, scrContext, 3u, v7);
  }
  if ( (unsigned int)v6->s.number >= level.maxclients )
  {
    maxclients = level.maxclients;
    number = v6->s.number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 15317, ASSERT_TYPE_ASSERT, "(unsigned)( player->s.number ) < (unsigned)( level.maxclients )", "player->s.number doesn't index level.maxclients\n\t%i not in [0, %i)", number, maxclients) )
      __debugbreak();
  }
  Scr_StopFxOnTagInternal(scrContext, Entity, Int, ConstLowercaseString, v6->s.number);
}

/*
==============
Scr_KillFXOnTag
==============
*/
void Scr_KillFXOnTag(scrContext_t *scrContext)
{
  unsigned int Int; 
  const char *v3; 
  gentity_s *Entity; 
  scr_string_t ConstLowercaseString; 
  const char *v6; 
  int BoneIndex; 
  const char *ModelName; 
  const char *v9; 
  const char *v10; 
  unsigned int FxEventParam; 

  if ( Scr_GetNumParam(scrContext) != 3 )
    Scr_Error(COM_ERR_4347, scrContext, "Incorrect number of parameters");
  Int = Scr_GetInt(scrContext, 0);
  if ( !FX_IsValidFxId(Int) )
  {
    v3 = j_va("effect id %i is invalid\n", Int);
    Scr_ParamError(COM_ERR_4348, scrContext, 0, v3);
  }
  Entity = GScr_GetEntity(1u);
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 2u);
  v6 = SL_ConvertToString(ConstLowercaseString);
  if ( strchr_0(v6, 34) )
    Scr_ParamError(COM_ERR_4349, scrContext, 2u, "cannot use \" characters in tag names\n");
  BoneIndex = SV_Game_DObjGetBoneIndex(Entity, ConstLowercaseString);
  if ( BoneIndex < 0 )
  {
    SV_Game_DObjDumpInfo(Entity);
    ModelName = G_CString_GetModelName(Entity->model);
    v9 = SL_ConvertToString(ConstLowercaseString);
    v10 = j_va("tag '%s' does not exist on entity with model '%s'", v9, ModelName);
    Scr_ParamError(COM_ERR_4350, scrContext, 2u, v10);
  }
  FxEventParam = Scr_GetFxEventParam(Int, BoneIndex, -1);
  G_Utils_AddEvent(Entity, 0x7Eu, FxEventParam);
}

/*
==============
Scr_PlayFxOnTagsBetweenClients
==============
*/
void Scr_PlayFxOnTagsBetweenClients(scrContext_t *scrContext)
{
  unsigned int Int; 
  gentity_s *Entity; 
  scr_string_t ConstLowercaseString; 
  const gentity_s *v5; 
  scr_string_t v6; 
  char v7; 
  __int16 *p_number; 
  gentity_s *v9; 
  const char *v10; 
  const char *v11; 
  const char *v12; 
  const char *v13; 
  const char *v14; 
  const char *v15; 
  gentity_s *v16; 
  unsigned int v17; 
  unsigned int clientTagIndex; 

  if ( Scr_GetNumParam(scrContext) > 6 )
    Scr_Error(COM_ERR_4351, scrContext, "Incorrect number of parameters");
  Int = Scr_GetInt(scrContext, 0);
  Entity = GScr_GetEntity(1u);
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 2u);
  v5 = GScr_GetEntity(3u);
  v6 = Scr_GetConstLowercaseString(scrContext, 4u);
  v7 = 0;
  p_number = NULL;
  if ( Scr_GetNumParam(scrContext) == 6 )
  {
    v9 = GScr_GetEntity(5u);
    p_number = &v9->s.number;
    if ( !v9->client )
    {
      v10 = j_va("Entity number %i is not a client", (unsigned int)v9->s.number);
      Scr_ParamError(COM_ERR_4352, scrContext, 5u, v10);
    }
    if ( (unsigned int)*p_number >= level.maxclients && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 15411, ASSERT_TYPE_ASSERT, "(unsigned)( player->s.number ) < (unsigned)( level.maxclients )", "player->s.number doesn't index level.maxclients\n\t%i not in [0, %i)", *p_number, level.maxclients) )
      __debugbreak();
    v7 = 1;
  }
  if ( !FX_IsValidFxId(Int) )
  {
    v11 = j_va("effect id %i is invalid\n", Int);
    Scr_ParamError(COM_ERR_4353, scrContext, 0, v11);
  }
  v12 = SL_ConvertToString(ConstLowercaseString);
  if ( strchr_0(v12, 34) )
    Scr_ParamError(COM_ERR_4354, scrContext, 2u, "cannot use \" characters in tag names\n");
  v13 = SL_ConvertToString(v6);
  if ( strchr_0(v13, 34) )
    Scr_ParamError(COM_ERR_4355, scrContext, 4u, "cannot use \" characters in tag names\n");
  clientTagIndex = 0;
  v14 = SL_ConvertToString(ConstLowercaseString);
  if ( !NetConstStrings_GetClientTagIndex(v14, &clientTagIndex) )
    Scr_ParamError(COM_ERR_4356, scrContext, 2u, "tag must be a client tag that is in ncsclienttags.txt");
  v15 = SL_ConvertToString(v6);
  if ( !NetConstStrings_GetClientTagIndex(v15, &clientTagIndex) )
    Scr_ParamError(COM_ERR_4357, scrContext, 4u, "tag must be a client tag that is in ncsclienttags.txt");
  v16 = G_BeamEntity_ScriptSpawn(Entity, ConstLowercaseString, Int);
  G_BeamEntity_ClearTargets(v16);
  G_BeamEntity_AddTargetEnt(v16, v5, v6, NULL);
  if ( v7 )
  {
    if ( !p_number && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 15444, ASSERT_TYPE_ASSERT, "(player)", (const char *)&queryFormat, rowName) )
      __debugbreak();
    *(_QWORD *)v16->clientMask.array = -1i64;
    *(_QWORD *)&v16->clientMask.array[2] = -1i64;
    *(_QWORD *)&v16->clientMask.array[4] = -1i64;
    v16->clientMask.array[6] = -1;
    v17 = *p_number;
    if ( v17 >= 0xE0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 290, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v17, 224) )
      __debugbreak();
    v16->clientMask.array[(unsigned __int64)v17 >> 5] &= ~(0x80000000 >> (v17 & 0x1F));
  }
  GScr_AddEntity(v16);
}

/*
==============
Scr_PlayFxBetweenPoints
==============
*/
void Scr_PlayFxBetweenPoints(scrContext_t *scrContext)
{
  unsigned int Int; 
  char v3; 
  __int16 *p_number; 
  gentity_s *Entity; 
  const char *v6; 
  const char *v7; 
  unsigned int v15; 
  vec3_t v16; 
  vec3_t v17; 
  vec3_t vectorValue; 

  if ( Scr_GetNumParam(scrContext) > 5 )
    Scr_Error(COM_ERR_4358, scrContext, "Incorrect number of parameters");
  Int = Scr_GetInt(scrContext, 0);
  Scr_GetVector(scrContext, 1u, &vectorValue);
  Scr_GetVector(scrContext, 2u, &v17);
  Scr_GetVector(scrContext, 3u, &v16);
  v3 = 0;
  p_number = NULL;
  if ( Scr_GetNumParam(scrContext) == 5 )
  {
    Entity = GScr_GetEntity(4u);
    p_number = &Entity->s.number;
    if ( !Entity->client )
    {
      v6 = j_va("Entity number %i is not a client", (unsigned int)Entity->s.number);
      Scr_ParamError(COM_ERR_4359, scrContext, 4u, v6);
    }
    if ( (unsigned int)*p_number >= level.maxclients && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 15490, ASSERT_TYPE_ASSERT, "(unsigned)( player->s.number ) < (unsigned)( level.maxclients )", "player->s.number doesn't index level.maxclients\n\t%i not in [0, %i)", *p_number, level.maxclients) )
      __debugbreak();
    v3 = 1;
  }
  if ( !FX_IsValidFxId(Int) )
  {
    v7 = j_va("effect id %i is invalid\n", Int);
    Scr_ParamError(COM_ERR_4360, scrContext, 0, v7);
  }
  _RBX = G_Utils_SpawnEventEntity(&vectorValue, 123);
  __asm
  {
    vmovss  xmm0, dword ptr [rsp+98h+var_48]
    vmovss  dword ptr [rax+58h], xmm0
    vmovss  xmm1, dword ptr [rsp+98h+var_48+4]
    vmovss  dword ptr [rax+5Ch], xmm1
    vmovss  xmm0, dword ptr [rsp+98h+var_48+8]
    vmovss  dword ptr [rax+60h], xmm0
    vmovss  xmm1, dword ptr [rsp+98h+var_38]
    vmovss  dword ptr [rax+40h], xmm1
    vmovss  xmm0, dword ptr [rsp+98h+var_38+4]
    vmovss  dword ptr [rax+44h], xmm0
    vmovss  xmm1, dword ptr [rsp+98h+var_38+8]
    vmovss  dword ptr [rax+48h], xmm1
  }
  _RBX->s.eventParm = Int;
  if ( v3 )
  {
    if ( !p_number && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 15505, ASSERT_TYPE_ASSERT, "(player)", (const char *)&queryFormat, rowName) )
      __debugbreak();
    *(_QWORD *)_RBX->clientMask.array = -1i64;
    *(_QWORD *)&_RBX->clientMask.array[2] = -1i64;
    *(_QWORD *)&_RBX->clientMask.array[4] = -1i64;
    _RBX->clientMask.array[6] = -1;
    v15 = *p_number;
    if ( v15 >= 0xE0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 290, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v15, 224) )
      __debugbreak();
    _RBX->clientMask.array[(unsigned __int64)v15 >> 5] &= ~(0x80000000 >> (v15 & 0x1F));
  }
}

/*
==============
Scr_PhysicsExplosionSphere
==============
*/

void __fastcall Scr_PhysicsExplosionSphere(scrContext_t *scrContext, __int64 a2, __int64 a3, double _XMM3_8)
{
  char v8; 
  char v9; 
  float v19; 
  float v20; 
  float impulse; 
  float v22; 
  vec3_t vectorValue; 

  __asm { vmovaps [rsp+88h+var_18], xmm6 }
  if ( Scr_GetNumParam(scrContext) != 4 )
    Scr_Error(COM_ERR_4361, scrContext, "Incorrect number of parameters");
  Scr_GetVector(scrContext, 0, &vectorValue);
  _RDI = G_Utils_SpawnEventEntity(&vectorValue, 130);
  _RDI->s.eventParm2 = 0;
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm { vmovss  dword ptr [rdi+5Ch], xmm0 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vcomiss xmm6, dword ptr [rdi+5Ch]
    vmovss  dword ptr [rdi+58h], xmm0
  }
  if ( !(v8 | v9) )
    Scr_ParamError(COM_ERR_4362, scrContext, 1u, "Radius is negative");
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+58h]
    vcomiss xmm0, xmm6
  }
  if ( v8 )
  {
    Scr_ParamError(COM_ERR_4363, scrContext, 2u, "Radius is negative");
    __asm { vmovss  xmm0, dword ptr [rdi+58h] }
  }
  __asm { vcomiss xmm0, dword ptr [rdi+5Ch] }
  if ( !(v8 | v9) )
    Scr_Error(COM_ERR_4364, scrContext, "Inner radius is outside the outer radius");
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
  __asm
  {
    vmovss  xmm1, cs:__real@3f800000
    vmovss  xmm2, dword ptr [rdi+5Ch]; radius
    vmovss  [rsp+88h+var_48], xmm1
    vmovss  dword ptr [rdi+60h], xmm0
    vmovss  dword ptr [rsp+88h+impulse], xmm0
    vxorps  xmm3, xmm3, xmm3; innerDamage
    vmovss  [rsp+88h+var_68], xmm6
  }
  Physics_ApplyRadiusForce(PHYSICS_WORLD_ID_FIRST, &vectorValue, *(const float *)&_XMM2, *(const float *)&_XMM3, v19, impulse, &vec3_origin, level.time, v22);
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+60h]
    vmovss  xmm2, dword ptr [rdi+5Ch]; outerRadius
    vmovss  xmm1, dword ptr [rdi+58h]; innerRadius
    vmovss  [rsp+88h+var_68], xmm0
  }
  G_Vehicle_ExplosionEvent(&vectorValue, *(float *)&_XMM1, *(float *)&_XMM2, 0, v20, NULL);
  __asm { vmovaps xmm6, [rsp+88h+var_18] }
}

/*
==============
Scr_PhysicsRadiusJolt
==============
*/

void __fastcall Scr_PhysicsRadiusJolt(scrContext_t *scrContext, __int64 a2, __int64 a3, double _XMM3_8)
{
  bool v11; 
  char v19; 
  char v20; 
  char v29; 
  float v42; 
  float v43; 
  float impulse; 
  float v45; 
  vec3_t vectorValue; 
  char v47; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-18h], xmm6
    vmovaps xmmword ptr [rax-28h], xmm7
    vmovaps xmmword ptr [rax-38h], xmm8
  }
  if ( Scr_GetNumParam(scrContext) != 4 )
    Scr_Error(COM_ERR_4365, scrContext, "Incorrect number of parameters");
  Scr_GetVector(scrContext, 0, &vectorValue);
  _RSI = G_Utils_SpawnEventEntity(&vectorValue, 131);
  _RSI->s.eventParm2 = 0;
  v11 = Com_GameMode_SupportsFeature(WEAPON_LEAP_OUT);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm { vmovaps xmm8, xmm0 }
  if ( v11 )
  {
    __asm
    {
      vaddss  xmm1, xmm0, cs:__real@3f000000
      vxorps  xmm0, xmm0, xmm0
      vmovss  xmm1, xmm0, xmm1
      vxorps  xmm7, xmm7, xmm7
      vroundss xmm2, xmm7, xmm1, 1
      vcvttss2si eax, xmm2
      vmovd   xmm8, eax
      vcvtdq2ps xmm8, xmm8
    }
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
    __asm
    {
      vaddss  xmm2, xmm0, cs:__real@3f000000
      vxorps  xmm1, xmm1, xmm1
      vmovss  xmm2, xmm1, xmm2
      vroundss xmm0, xmm7, xmm2, 1
      vcvttss2si eax, xmm0
      vmovd   xmm0, eax
      vcvtdq2ps xmm0, xmm0
    }
  }
  else
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
  }
  __asm
  {
    vxorps  xmm7, xmm7, xmm7
    vcomiss xmm8, xmm7
    vmovss  dword ptr [rsi+5Ch], xmm8
    vmovss  dword ptr [rsi+58h], xmm0
  }
  if ( v19 )
  {
    Scr_ParamError(COM_ERR_4366, scrContext, 1u, "Radius is negative");
    __asm { vmovss  xmm0, dword ptr [rsi+58h] }
  }
  __asm { vcomiss xmm0, xmm7 }
  if ( v19 )
  {
    Scr_ParamError(COM_ERR_4367, scrContext, 2u, "Radius is negative");
    __asm { vmovss  xmm0, dword ptr [rsi+58h] }
  }
  __asm { vcomiss xmm0, dword ptr [rsi+5Ch] }
  if ( !(v19 | v20) )
    Scr_Error(COM_ERR_4368, scrContext, "Inner radius is outside the outer radius");
  _RBX = &_RSI->s.lerp.u.anonymous.data[2];
  Scr_GetVector(scrContext, 3u, &_RSI->s.lerp.u.event.explosionJolt.impulse);
  __asm
  {
    vmovss  xmm0, dword ptr cs:?vec3_origin@@3Tvec3_t@@B; vec3_t const vec3_origin
    vucomiss xmm0, dword ptr [rbx]
  }
  if ( v29 )
  {
    __asm
    {
      vmovss  xmm0, dword ptr cs:?vec3_origin@@3Tvec3_t@@B+4; vec3_t const vec3_origin
      vucomiss xmm0, dword ptr [rbx+4]
    }
    if ( v29 )
    {
      __asm
      {
        vmovss  xmm0, dword ptr cs:?vec3_origin@@3Tvec3_t@@B+8; vec3_t const vec3_origin
        vucomiss xmm0, dword ptr [rbx+8]
      }
      if ( v29 )
        *_RBX = 0x800000;
    }
  }
  __asm
  {
    vmovss  xmm6, cs:__real@3f800000
    vmovss  [rsp+0A8h+var_68], xmm6
    vmovss  dword ptr [rsp+0A8h+impulse], xmm7
    vxorps  xmm3, xmm3, xmm3; innerDamage
    vmovaps xmm2, xmm8; radius
    vmovss  [rsp+0A8h+var_88], xmm7
  }
  Physics_ApplyRadiusForce(PHYSICS_WORLD_ID_FIRST, &vectorValue, *(const float *)&_XMM2, *(const float *)&_XMM3, v42, impulse, &_RSI->s.lerp.u.event.explosionJolt.impulse, level.time, v45);
  __asm
  {
    vmovss  xmm2, dword ptr [rsi+5Ch]; outerRadius
    vmovss  xmm1, dword ptr [rsi+58h]; innerRadius
    vmovss  [rsp+0A8h+var_88], xmm6
  }
  G_Vehicle_ExplosionEvent(&vectorValue, *(float *)&_XMM1, *(float *)&_XMM2, 0, v43, &_RSI->s.lerp.u.event.explosionJolt.impulse);
  _R11 = &v47;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
  }
}

/*
==============
ScrCmd_TableSort
==============
*/
void ScrCmd_TableSort(scrContext_t *scrContext)
{
  std::pair<unsigned int,VariableUnion const *> *v2; 
  __int64 v3; 
  unsigned int ArrayObject; 
  unsigned int ArraySize; 
  const char *v6; 
  scr_string_t down; 
  scr_string_t ConstString; 
  const char *v9; 
  const char *v10; 
  const char *v11; 
  const char *v12; 
  int TableEntries; 
  __int64 v14; 
  __int64 v15; 
  std::pair<unsigned int,VariableUnion const *> *v16; 
  int v17; 
  __int64 v18; 
  std::pair<unsigned int,VariableUnion const *> *v19; 
  VariableType outType[8]; 
  VariableValue out; 
  std::pair<unsigned int,VariableUnion const *> outEntries[1024]; 

  v2 = outEntries;
  v3 = 1024i64;
  do
  {
    std::pair<unsigned int,VariableUnion const *>::pair<unsigned int,VariableUnion const *>(v2++);
    --v3;
  }
  while ( v3 );
  ArrayObject = BGScr_Main_GetArrayObject(scrContext, 0);
  ArraySize = GetArraySize(scrContext, ArrayObject);
  if ( ArraySize > 0x400 )
  {
    v6 = j_va("Key array exceeds maximum sort size: %d > %d", ArraySize, 1024i64);
    Scr_ParamError(COM_ERR_6575, scrContext, 0, v6);
  }
  down = scr_const.down;
  if ( Scr_GetNumParam(scrContext) > 1 )
  {
    ConstString = Scr_GetConstString(scrContext, 1u);
    down = ConstString;
    if ( ConstString != scr_const.up && ConstString != scr_const.down )
    {
      v9 = SL_ConvertToString(scr_const.down);
      v10 = SL_ConvertToString(scr_const.up);
      v11 = SL_ConvertToString(down);
      v12 = j_va("Invalid sort direction specified: %s is not \"%s\" or \"%s\"", v11, v10, v9);
      Scr_ParamError(COM_ERR_6576, scrContext, 0, v12);
    }
  }
  TableEntries = ScrCmd_GetTableEntries(scrContext, ArrayObject, outEntries, outType);
  v14 = TableEntries;
  if ( outType[0] )
  {
    switch ( outType[0] )
    {
      case VAR_STRING:
        std::_Sort_unchecked<std::pair<unsigned int,VariableUnion const *> *,ScrCmd_CompareTableEntriesString>(outEntries, &outEntries[TableEntries], TableEntries, (ScrCmd_CompareTableEntriesString)outType[0]);
        break;
      case VAR_FLOAT:
        std::_Sort_unchecked<std::pair<unsigned int,VariableUnion const *> *,ScrCmd_CompareTableEntriesFloat>(outEntries, &outEntries[TableEntries], TableEntries, (ScrCmd_CompareTableEntriesFloat)outType[0]);
        break;
      case VAR_INTEGER:
        std::_Sort_unchecked<std::pair<unsigned int,VariableUnion const *> *,ScrCmd_CompareTableEntriesInteger>(outEntries, &outEntries[TableEntries], TableEntries, (ScrCmd_CompareTableEntriesInteger)outType[0]);
        break;
      default:
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 33110, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Invalid array entries in TableSort") )
          __debugbreak();
        break;
    }
  }
  Scr_MakeArray(scrContext);
  if ( down == scr_const.up )
  {
    v15 = v14;
    if ( (int)v14 > 0 )
    {
      v16 = outEntries;
      do
      {
        Scr_GetArrayIndexValue_Out(v16->first, &out);
        Scr_AddValue(scrContext, &out);
        Scr_AddArray(scrContext);
        ++v16;
        --v15;
      }
      while ( v15 );
    }
  }
  else
  {
    v17 = v14 - 1;
    v18 = (int)v14 - 1;
    if ( v17 >= 0 )
    {
      v19 = &outEntries[v17];
      do
      {
        Scr_GetArrayIndexValue_Out(v19->first, &out);
        Scr_AddValue(scrContext, &out);
        Scr_AddArray(scrContext);
        --v18;
        --v19;
      }
      while ( v18 >= 0 );
    }
  }
}

/*
==============
Scr_PhysicsRadiusJitter
==============
*/
void Scr_PhysicsRadiusJitter(scrContext_t *scrContext)
{
  bool v8; 
  char v17; 
  char v18; 
  const char *v31; 
  vec3_t vectorValue; 
  void *retaddr; 

  _R11 = &retaddr;
  __asm
  {
    vmovaps [rsp+78h+var_18], xmm6
    vmovaps xmmword ptr [r11-38h], xmm8
  }
  if ( Scr_GetNumParam(scrContext) < 5 || Scr_GetNumParam(scrContext) > 6 )
    Scr_Error(COM_ERR_4369, scrContext, "Incorrect number of parameters");
  Scr_GetVector(scrContext, 0, &vectorValue);
  _RSI = G_Utils_SpawnEventEntity(&vectorValue, 133);
  _RSI->s.eventParm2 = 0;
  v8 = Com_GameMode_SupportsFeature(WEAPON_LEAP_OUT);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm { vmovaps xmm8, xmm0 }
  if ( v8 )
  {
    __asm
    {
      vaddss  xmm1, xmm0, cs:__real@3f000000
      vxorps  xmm0, xmm0, xmm0
      vmovss  xmm1, xmm0, xmm1
      vmovaps [rsp+78h+var_28], xmm7
      vxorps  xmm7, xmm7, xmm7
      vroundss xmm2, xmm7, xmm1, 1
      vcvttss2si eax, xmm2
      vmovd   xmm8, eax
      vcvtdq2ps xmm8, xmm8
    }
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
    __asm
    {
      vaddss  xmm2, xmm0, cs:__real@3f000000
      vxorps  xmm1, xmm1, xmm1
      vmovss  xmm2, xmm1, xmm2
      vroundss xmm0, xmm7, xmm2, 1
      vmovaps xmm7, [rsp+78h+var_28]
      vcvttss2si eax, xmm0
      vmovd   xmm0, eax
      vcvtdq2ps xmm0, xmm0
    }
  }
  else
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
  }
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vcomiss xmm8, xmm6
    vmovss  dword ptr [rsi+5Ch], xmm8
    vmovss  dword ptr [rsi+58h], xmm0
  }
  if ( v17 )
  {
    Scr_ParamError(COM_ERR_4370, scrContext, 1u, "Radius is negative");
    __asm { vmovss  xmm0, dword ptr [rsi+58h] }
  }
  __asm
  {
    vcomiss xmm0, xmm6
    vmovaps xmm6, [rsp+78h+var_18]
  }
  if ( v17 )
  {
    Scr_ParamError(COM_ERR_4371, scrContext, 2u, "Radius is negative");
    __asm { vmovss  xmm0, dword ptr [rsi+58h] }
  }
  __asm { vcomiss xmm0, dword ptr [rsi+5Ch] }
  if ( !(v17 | v18) )
    Scr_Error(COM_ERR_4372, scrContext, "Inner radius is outside the outer radius");
  __asm
  {
    vcomiss xmm8, cs:__real@44800000
    vmovaps xmm8, [rsp+78h+var_38]
  }
  if ( !(v17 | v18) )
  {
    __asm
    {
      vmovsd  xmm1, cs:__real@4090000000000000
      vmovq   rdx, xmm1
    }
    v31 = j_va("Jitter is too big - max radius is %.2f", _RDX);
    Scr_Error(COM_ERR_4373, scrContext, v31);
  }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
  __asm { vmovss  dword ptr [rsi+60h], xmm0 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 4u);
  __asm
  {
    vcomiss xmm0, dword ptr [rsi+60h]
    vmovss  dword ptr [rsi+64h], xmm0
  }
  if ( v17 )
    Scr_Error(COM_ERR_4374, scrContext, "Maximum jitter is less than minimum jitter");
}

/*
==============
Scr_VisionSetNaked
==============
*/
void Scr_VisionSetNaked(scrContext_t *scrContext)
{
  VisionSetSendToClient(scrContext, VISIONSET_SCRIPT);
}

/*
==============
Scr_VisionSetNight
==============
*/
void Scr_VisionSetNight(scrContext_t *scrContext)
{
  VisionSetSendToClient(scrContext, VISIONSET_NIGHT);
}

/*
==============
Scr_VisionSetMissilecam
==============
*/
void Scr_VisionSetMissilecam(scrContext_t *scrContext)
{
  VisionSetSendToClient(scrContext, VISIONSET_MISSILECAM);
}

/*
==============
Scr_VisionSetThermal
==============
*/
void Scr_VisionSetThermal(scrContext_t *scrContext)
{
  VisionSetSendToClient(scrContext, VISIONSET_THERMAL);
}

/*
==============
Scr_VisionSetPain
==============
*/
void Scr_VisionSetPain(scrContext_t *scrContext)
{
  VisionSetSendToClient(scrContext, VISIONSET_PAIN);
}

/*
==============
Scr_VisionSetFadeToBlack
==============
*/
void Scr_VisionSetFadeToBlack(scrContext_t *scrContext)
{
  VisionSetSendToClient(scrContext, VISIONSET_FADE_TO_BLACK);
}

/*
==============
Scr_VisionSetKillcamThirdpersonNight
==============
*/
void Scr_VisionSetKillcamThirdpersonNight(scrContext_t *scrContext)
{
  VisionSetSendToClient(scrContext, VISIONSET_KILLCAM);
}

/*
==============
ScrCmd_PainVisionOn
==============
*/
void ScrCmd_PainVisionOn(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 15874, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal(&v4->client->ps.otherFlags, ACTIVE, 0x19u);
}

/*
==============
ScrCmd_PainVisionOff
==============
*/
void ScrCmd_PainVisionOff(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 15891, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal(&v4->client->ps.otherFlags, ACTIVE, 0x19u);
}

/*
==============
ScrCmd_MarkKeyframedMover
==============
*/
void ScrCmd_MarkKeyframedMover(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const dvar_t *v4; 

  Entity = GetEntity(entref);
  if ( Entity->s.eType == ET_SCRIPTMOVER )
  {
    v4 = DVARBOOL_movingPlatformUseKeyframeVelocities;
    if ( !DVARBOOL_movingPlatformUseKeyframeVelocities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "movingPlatformUseKeyframeVelocities") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v4);
    if ( v4->current.enabled )
      GMovingPlatforms::MarkEntityKeyframedMover(Entity);
  }
  else
  {
    Scr_Error(COM_ERR_4221, scrContext, "MarkKeyframedMover must be called on a script mover");
  }
}

/*
==============
ScrCmd_GetNodeNumber
==============
*/
void ScrCmd_GetNodeNumber(scrContext_t *scrContext, scr_entref_t entref)
{
  if ( entref.entclass == ENTITY_CLASS_PATHNODE )
    Scr_AddInt(scrContext, entref.entnum);
  else
    Scr_Error(COM_ERR_4377, scrContext, "GetNodeNumber not called on pathnode");
}

/*
==============
ScrCmd_UnmarkKeyframedMover
==============
*/
void ScrCmd_UnmarkKeyframedMover(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( Entity->s.eType == ET_SCRIPTMOVER )
    GMovingPlatforms::UnmarkEntityKeyframedMover(Entity);
  else
    Scr_Error(COM_ERR_4221, scrContext, "UnmarkKeyframedMover must be called on a script mover");
}

/*
==============
Scr_SetVisionParams
==============
*/

void __fastcall Scr_SetVisionParams(scrContext_t *scrContext, scr_entref_t entref, double _XMM2_8)
{
  unsigned int entnum; 
  gentity_s *v6; 
  const char *v7; 
  int number; 
  const char *v9; 
  const char *String; 
  const char *v18; 
  const char *v19; 
  SvClient *CommonClient; 
  int outControllingClientNum; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3678, scrContext, "not an entity");
    v6 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 15932, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v6 = &g_entities[entnum];
    if ( !v6->client && !v6->agent )
    {
      v7 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3677, scrContext, v7);
    }
  }
  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_Error(COM_ERR_4378, scrContext, "Incorrect usage for SetVisionParams()");
  number = v6->s.number;
  outControllingClientNum = number;
  if ( !SV_IsAgent(number) || SV_GetAgentControlledByPlayerNum(outControllingClientNum, &outControllingClientNum) )
  {
    String = Scr_GetString(scrContext, 1u);
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
    __asm
    {
      vmulss  xmm1, xmm0, cs:__real@447a0000
      vaddss  xmm3, xmm1, cs:__real@3f000000
      vxorps  xmm2, xmm2, xmm2
      vmovss  xmm4, xmm2, xmm3
      vxorps  xmm0, xmm0, xmm0
      vroundss xmm1, xmm0, xmm4, 1
      vcvttss2si r8d, xmm1
    }
    v18 = j_va("%c %i \"%s\"", 54i64, _R8, String);
    v19 = v18;
    if ( outControllingClientNum == -1 )
    {
      SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v18);
    }
    else
    {
      CommonClient = SvClient::GetCommonClient(outControllingClientNum);
      CommonClient->SendServerCommand(CommonClient, SV_CMD_RELIABLE, v19);
    }
  }
  else
  {
    v9 = j_va("entity %i is not a player or player-controlled agent", entnum);
    Scr_ObjectError(COM_ERR_4379, scrContext, v9);
  }
}

/*
==============
Scr_VisionSetAlternate
==============
*/

void __fastcall Scr_VisionSetAlternate(scrContext_t *scrContext, __int64 a2, double _XMM2_8)
{
  unsigned int v5; 
  unsigned int Int; 
  scr_string_t ConstLowercaseString; 
  const char *v15; 
  const char *v16; 
  ComErrorCode v17; 
  int v18; 
  unsigned int v19; 
  unsigned int outVisionSetIndex[4]; 
  char dest[64]; 

  v5 = -1;
  Int = Scr_GetInt(scrContext, 0);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm
  {
    vmulss  xmm1, xmm0, cs:__real@447a0000
    vaddss  xmm3, xmm1, cs:__real@3f000000
    vxorps  xmm2, xmm2, xmm2
    vmovss  xmm4, xmm2, xmm3
    vxorps  xmm0, xmm0, xmm0
    vroundss xmm1, xmm0, xmm4, 1
    vcvttss2si ebp, xmm1
  }
  if ( Scr_GetNumParam(scrContext) != 3 )
  {
    if ( Scr_GetNumParam(scrContext) == 2 )
      goto LABEL_9;
    v16 = "USAGE: VisionSetAlternate( <stage>, <duration>, <optional override> )\n";
    v17 = COM_ERR_4381;
LABEL_8:
    Scr_Error(v17, scrContext, v16);
    goto LABEL_9;
  }
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 2u);
  v15 = SL_ConvertToString(ConstLowercaseString);
  if ( !*v15 || !NetConstStrings_GetVisionSetIndex(v15, outVisionSetIndex) )
  {
    v16 = "Invalid vision set override for VisionSetAlternate.";
    v17 = COM_ERR_4380;
    goto LABEL_8;
  }
  v5 = outVisionSetIndex[0];
LABEL_9:
  v19 = v5;
  v18 = _EBP;
  Com_sprintf(dest, 0x40ui64, "%i %i %i", Int, v18, v19);
  SV_SetConfigstring(8u, dest);
}

/*
==============
GScr_GetNumParts
==============
*/
void GScr_GetNumParts(scrContext_t *scrContext)
{
  const char *String; 
  XModel *XModel; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4382, scrContext, "Incorrect use of getnumparts()");
  String = Scr_GetString(scrContext, 0);
  if ( !*String )
    Scr_Error(COM_ERR_4383, scrContext, "GetNumParts() used with an empty model name!");
  XModel = SV_Game_GetXModel(String);
  if ( !XModel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\xanim\\xmodel_utils.h", 136, ASSERT_TYPE_ASSERT, "(model)", (const char *)&queryFormat, "model") )
    __debugbreak();
  Scr_AddInt(scrContext, XModel->numBones);
}

/*
==============
GScr_GetPartName
==============
*/
void GScr_GetPartName(scrContext_t *scrContext)
{
  const char *String; 
  XModel *XModel; 
  __int64 Int; 
  unsigned int numBones; 
  const char *v6; 
  scr_string_t v7; 

  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_Error(COM_ERR_4384, scrContext, "Incorrect usage for getpartname()");
  String = Scr_GetString(scrContext, 0);
  XModel = SV_Game_GetXModel(String);
  Int = (unsigned int)Scr_GetInt(scrContext, 1u);
  if ( !XModel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\xanim\\xmodel_utils.h", 136, ASSERT_TYPE_ASSERT, "(model)", (const char *)&queryFormat, "model") )
    __debugbreak();
  numBones = XModel->numBones;
  if ( (unsigned int)Int >= numBones )
  {
    v6 = j_va("index out of range (0 - %d)", numBones - 1);
    Scr_ParamError(COM_ERR_4385, scrContext, 1u, v6);
  }
  v7 = XModelBoneNames(XModel)[Int];
  if ( !v7 )
    Scr_ParamError(COM_ERR_4386, scrContext, 0, "bad model");
  Scr_AddConstString(scrContext, v7);
}

/*
==============
GScr_GetAnimName
==============
*/
void GScr_GetAnimName(scrContext_t *scrContext)
{
  int linkPointer; 
  unsigned int v3; 
  XAnim_s *Anims; 
  const char *AnimName; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    linkPointer = Scr_GetAnim(scrContext, 0, NULL).linkPointer;
    v3 = (unsigned __int16)linkPointer;
    Anims = Scr_GetAnims(scrContext, HIWORD(linkPointer));
    if ( XAnimIsPrimitive(Anims, v3) && XAnimGetParts(Anims, v3) )
    {
      AnimName = XAnimGetAnimName(Anims, v3);
      Scr_AddString(scrContext, AnimName);
    }
    else
    {
      Scr_Error(COM_ERR_4388, scrContext, "GetAnimName() expects a primitive animation as its parameter");
    }
  }
  else
  {
    Scr_Error(COM_ERR_4387, scrContext, "GetAnimName() expects exactly one parameter");
  }
}

/*
==============
Scr_LookupSoundLength
==============
*/
void Scr_LookupSoundLength(scrContext_t *scrContext)
{
  int NumParam; 
  int v3; 
  bool v4; 
  bool v5; 
  const char *String; 
  bool v7; 
  const char *v8; 
  int v9; 

  NumParam = Scr_GetNumParam(scrContext);
  v3 = NumParam;
  if ( NumParam && NumParam <= 2 )
  {
    v4 = Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_STILL_LAND|0x80);
    v5 = !v4;
    if ( !v4 && !Com_GameMode_SupportsFeature(WEAPON_INSPECT|0x80) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16110, ASSERT_TYPE_ASSERT, "(!useApproximation || Com_GameMode_SupportsFeature( Com_GameMode_Feature::SOUND_MULTIPLAYER ))", (const char *)&queryFormat, "!useApproximation || Com_GameMode_SupportsFeature( Com_GameMode_Feature::SOUND_MULTIPLAYER )") )
      __debugbreak();
    String = Scr_GetString(scrContext, 0);
    v7 = 0;
    v8 = String;
    if ( v3 > 1 )
      v7 = Scr_GetInt(scrContext, 1u) != 0;
    v9 = SND_SV_LookupSoundLength(v8, v5, v7);
    Scr_AddInt(scrContext, v9);
  }
  else
  {
    Scr_Error(COM_ERR_4389, scrContext, "usage: timeMS = LookupSoundLength( <alias>, <findLongestVariant> );\n");
  }
}

/*
==============
Scr_SoundSetTimeScaleFactor
==============
*/

void __fastcall Scr_SoundSetTimeScaleFactor(scrContext_t *scrContext, double _XMM1_8)
{
  const char *String; 
  unsigned int EntChannelFromName; 
  const char *v7; 
  char v8; 
  char v9; 
  const char *v14; 
  double v16; 
  char dest[64]; 

  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    __asm { vmovaps [rsp+98h+var_18], xmm6 }
    String = Scr_GetString(scrContext, 0);
    EntChannelFromName = SND_GetEntChannelFromName(String);
    if ( EntChannelFromName == -1 )
    {
      v7 = j_va("uknown channel: %s\n", String);
      Scr_ParamError(COM_ERR_4394, scrContext, 0, v7);
    }
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
    __asm
    {
      vxorps  xmm1, xmm1, xmm1
      vcomiss xmm0, xmm1
    }
    if ( v8 )
      goto LABEL_8;
    __asm { vcomiss xmm0, cs:__real@3f800000 }
    if ( !(v8 | v9) )
    {
LABEL_8:
      __asm
      {
        vcvtss2sd xmm6, xmm0, xmm0
        vmovaps xmm1, xmm6
        vmovq   rdx, xmm1
      }
      v14 = j_va("time scale factor must be between 0 and 1 - %f\n", _RDX);
      Scr_ParamError(COM_ERR_4395, scrContext, 1u, v14);
    }
    else
    {
      __asm { vcvtss2sd xmm6, xmm0, xmm0 }
    }
    __asm { vmovsd  [rsp+98h+var_70], xmm6 }
    Com_sprintf(dest, 0x40ui64, "%c %i %.3f\n", 115i64, EntChannelFromName, v16);
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, dest);
    __asm { vmovaps xmm6, [rsp+98h+var_18] }
  }
  else
  {
    Scr_Error(COM_ERR_4393, scrContext, "usage: SoundSetTimeScaleFactor( <channelname>, <lerp> )\n");
  }
}

/*
==============
Scr_SoundSetTimeScaleFactorFromTable
==============
*/
void Scr_SoundSetTimeScaleFactorFromTable(scrContext_t *scrContext)
{
  const char *String; 
  const char *v3; 
  __int64 v4; 
  char dest[64]; 

  String = Scr_GetString(scrContext, 0);
  v3 = String;
  v4 = -1i64;
  do
    ++v4;
  while ( String[v4] );
  if ( (unsigned int)v4 > 0x20 )
    Scr_ParamError(COM_ERR_6440, scrContext, 1u, "Preset name is too long to fit in the buffer");
  Com_sprintf(dest, 0x40ui64, "%c %s\n", 116i64, v3);
  SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, dest);
}

/*
==============
ScrCmd_HudOutlineViewModelEnable
==============
*/
void ScrCmd_HudOutlineViewModelEnable(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  scr_string_t ConstString; 
  const char *v7; 
  const char *v8; 
  unsigned int outIndex; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16268, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  if ( v4->s.eType != ET_PLAYER )
    Scr_Error(COM_ERR_4396, scrContext, "ViewModelOutlineEnable called on an ent that's not a player.");
  ConstString = Scr_GetConstString(scrContext, 0);
  if ( !ConstString && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16276, ASSERT_TYPE_ASSERT, "(hudOutlineScrStr != ( static_cast< scr_string_t >( 0 ) ))", (const char *)&queryFormat, "hudOutlineScrStr != NULL_SCR_STRING") )
    __debugbreak();
  v7 = SL_ConvertToString(ConstString);
  if ( !v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16279, ASSERT_TYPE_ASSERT, "(hudOutlineName)", (const char *)&queryFormat, "hudOutlineName") )
    __debugbreak();
  outIndex = 0;
  if ( BG_HudOutline_GetDefIndex(v7, &outIndex) )
  {
    *(_DWORD *)&v4->client->ps.outlineData.viewmodel ^= ((unsigned __int8)outIndex ^ (unsigned __int8)*(_DWORD *)&v4->client->ps.outlineData.viewmodel) & 0x3F;
  }
  else
  {
    v8 = j_va("Hud Outline name not found (%s)! Make sure you add your Hud Outline asset to your level csv file!\n", v7);
    Scr_Error(COM_ERR_6089, scrContext, v8);
  }
}

/*
==============
ScrCmd_HudOutlineViewModelDisable
==============
*/
void ScrCmd_HudOutlineViewModelDisable(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16305, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  if ( v4->s.eType != ET_PLAYER )
    Scr_Error(COM_ERR_4398, scrContext, "ViewModelOutlineDisable called on an ent that's not a player.");
  *(_DWORD *)&v4->client->ps.outlineData.viewmodel &= 0xFFFFFFC0;
}

/*
==============
GScr_GetTagOrigin
==============
*/
void GScr_GetTagOrigin(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int shouldUseCache; 
  int showScriptError; 
  scr_string_t ConstLowercaseString; 
  const playerState_s *EntityPlayerState; 
  GHandler *Handler; 
  float value; 
  vec3_t vec; 
  WorldUpReferenceFrame v28; 

  Entity = GetEntity(entref);
  shouldUseCache = 1;
  showScriptError = 1;
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  if ( Scr_GetNumParam(scrContext) > 1 && Scr_GetInt(scrContext, 1u) )
    showScriptError = 0;
  if ( Scr_GetNumParam(scrContext) > 3 && !Scr_GetInt(scrContext, 3u) )
    shouldUseCache = 0;
  if ( GScr_UpdateTagInternal(scrContext, Entity, ConstLowercaseString, &level.cachedTagMat, shouldUseCache, showScriptError) )
  {
    __asm
    {
      vmovss  xmm0, dword ptr cs:?level@@3Ulevel_locals_t@@A.cachedTagMat.tagMat+24h; level_locals_t level
      vmovss  xmm1, dword ptr cs:?level@@3Ulevel_locals_t@@A.cachedTagMat.tagMat+28h; level_locals_t level
      vmovss  [rsp+0A8h+value], xmm0
      vmovss  xmm0, dword ptr cs:?level@@3Ulevel_locals_t@@A.cachedTagMat.tagMat+2Ch; level_locals_t level
      vmovss  [rsp+0A8h+var_70], xmm0
      vmovss  [rsp+0A8h+var_74], xmm1
    }
    if ( Scr_GetNumParam(scrContext) > 2 && Scr_GetInt(scrContext, 2u) == 1 )
    {
      EntityPlayerState = G_GetEntityPlayerState(Entity);
      if ( EntityPlayerState )
      {
        Handler = GHandler::getHandler();
        WorldUpReferenceFrame::WorldUpReferenceFrame(&v28, EntityPlayerState, Handler);
        __asm
        {
          vmovss  xmm0, [rsp+0A8h+value]
          vsubss  xmm1, xmm0, dword ptr [rdi+30h]
          vmovss  xmm2, [rsp+0A8h+var_74]
          vsubss  xmm0, xmm2, dword ptr [rdi+34h]
          vmovss  dword ptr [rsp+0A8h+vec], xmm1
          vmovss  xmm1, [rsp+0A8h+var_70]
          vsubss  xmm2, xmm1, dword ptr [rdi+38h]
          vmovss  dword ptr [rsp+0A8h+vec+8], xmm2
          vmovss  dword ptr [rsp+0A8h+vec+4], xmm0
        }
        WorldUpReferenceFrame::ApplyReferenceFrameToVector(&v28, &vec);
        __asm
        {
          vmovss  xmm0, dword ptr [rsp+0A8h+vec]
          vaddss  xmm1, xmm0, dword ptr [rdi+30h]
          vmovss  xmm2, dword ptr [rsp+0A8h+vec+4]
          vmovss  [rsp+0A8h+value], xmm1
          vaddss  xmm0, xmm2, dword ptr [rdi+34h]
          vmovss  xmm1, dword ptr [rsp+0A8h+vec+8]
          vmovss  [rsp+0A8h+var_74], xmm0
          vaddss  xmm2, xmm1, dword ptr [rdi+38h]
          vmovss  [rsp+0A8h+var_70], xmm2
        }
      }
    }
    Scr_AddVector(scrContext, &value);
  }
}

/*
==============
GScr_GetTagAngles
==============
*/
void GScr_GetTagAngles(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int shouldUseCache; 
  int showScriptError; 
  scr_string_t ConstLowercaseString; 
  const playerState_s *EntityPlayerState; 
  GHandler *Handler; 
  vec3_t angles; 
  WorldUpReferenceFrame v10; 

  Entity = GetEntity(entref);
  shouldUseCache = 1;
  showScriptError = 1;
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  if ( Scr_GetNumParam(scrContext) > 1 && Scr_GetInt(scrContext, 1u) )
    showScriptError = 0;
  if ( Scr_GetNumParam(scrContext) > 3 && !Scr_GetInt(scrContext, 3u) )
    shouldUseCache = 0;
  GScr_UpdateTagInternal(scrContext, Entity, ConstLowercaseString, &level.cachedTagMat, shouldUseCache, showScriptError);
  AxisToAngles((const tmat33_t<vec3_t> *)&level.cachedTagMat.tagMat, &angles);
  if ( Scr_GetNumParam(scrContext) > 2 && Scr_GetInt(scrContext, 2u) == 1 )
  {
    EntityPlayerState = G_GetEntityPlayerState(Entity);
    if ( EntityPlayerState )
    {
      Handler = GHandler::getHandler();
      WorldUpReferenceFrame::WorldUpReferenceFrame(&v10, EntityPlayerState, Handler);
      WorldUpReferenceFrame::ApplyReferenceFrameToAngles(&v10, &angles);
    }
  }
  Scr_AddVector(scrContext, angles.v);
}

/*
==============
GScr_TagExists
==============
*/
void GScr_TagExists(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t ConstLowercaseString; 
  int BoneIndex; 
  const XModel *Model; 
  int v7; 
  unsigned __int8 index; 

  Entity = GetEntity(entref);
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  if ( SV_Game_DObjExists(Entity) )
  {
    BoneIndex = SV_Game_DObjGetBoneIndex(Entity, ConstLowercaseString);
  }
  else
  {
    if ( !Entity->model )
      goto LABEL_9;
    Model = G_Utils_GetModel(Entity->model);
    if ( !XModelGetBoneIndex(Model, ConstLowercaseString, 0, &index) )
      goto LABEL_9;
    BoneIndex = index;
  }
  if ( (unsigned int)(BoneIndex - 254) <= 1 || BoneIndex == -1 )
  {
LABEL_9:
    v7 = 0;
    goto LABEL_10;
  }
  v7 = 1;
LABEL_10:
  Scr_AddInt(scrContext, v7);
}

/*
==============
GScr_SetDepthOfField
==============
*/
void GScr_SetDepthOfField(scrContext_t *scrContext, scr_entref_t entref)
{
  Com_PrintWarning(24, "GScr_SetDepthOfField: Legacy DoF controls deprecated. Please update script to physical DoF controls!\n");
}

/*
==============
GScr_VignetteSetParams
==============
*/

void __fastcall GScr_VignetteSetParams(scrContext_t *scrContext, scr_entref_t entref, double _XMM2_8)
{
  gentity_s *PlayerEntity; 
  int NumParam; 
  char v18; 
  char v19; 
  const char *v24; 

  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  _RBX = G_GetEntityPlayerState(PlayerEntity);
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam >= 10 )
  {
    __asm
    {
      vmovaps [rsp+0B8h+var_18], xmm6
      vmovaps [rsp+0B8h+var_28], xmm7
      vmovaps [rsp+0B8h+var_38], xmm8
      vmovaps [rsp+0B8h+var_48], xmm9
      vmovaps [rsp+0B8h+var_58], xmm10
      vmovaps [rsp+0B8h+var_68], xmm11
      vmovaps [rsp+0B8h+var_78], xmm12
      vmovaps [rsp+0B8h+var_88], xmm13
      vmovaps [rsp+0B8h+var_98], xmm14
    }
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
    __asm
    {
      vxorps  xmm1, xmm1, xmm1
      vcomiss xmm0, xmm1
      vmovaps xmm6, xmm0
    }
    if ( v18 )
      goto LABEL_5;
    __asm { vcomiss xmm0, cs:__real@3f800000 }
    if ( !(v18 | v19) )
    {
LABEL_5:
      __asm
      {
        vcvtss2sd xmm1, xmm6, xmm6
        vmovq   rdx, xmm1
      }
      v24 = j_va("intensity must be between -1 and 1 - %f\n", _RDX);
      Scr_ParamError(COM_ERR_5922, scrContext, 1u, v24);
    }
    Scr_GetInt(scrContext, 1u);
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
    __asm { vmovaps xmm7, xmm0 }
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
    __asm { vmovaps xmm8, xmm0 }
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 4u);
    __asm { vmovaps xmm9, xmm0 }
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 5u);
    __asm { vmovaps xmm10, xmm0 }
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 6u);
    __asm { vmovaps xmm11, xmm0 }
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 7u);
    __asm { vmovaps xmm12, xmm0 }
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 8u);
    __asm { vmovaps xmm13, xmm0 }
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 9u);
    __asm { vmovaps xmm14, xmm0 }
    if ( NumParam > 10 )
    {
      *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0xAu);
      __asm
      {
        vmulss  xmm1, xmm0, cs:__real@447a0000
        vaddss  xmm3, xmm1, cs:__real@3f000000
        vxorps  xmm2, xmm2, xmm2
        vmovss  xmm4, xmm2, xmm3
        vxorps  xmm1, xmm1, xmm1
        vroundss xmm5, xmm1, xmm4, 1
        vcvttss2si eax, xmm5
      }
    }
    __asm
    {
      vmovss  dword ptr [rbx+1244h], xmm6
      vmovaps xmm6, [rsp+0B8h+var_18]
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, ebp
      vmovss  dword ptr [rbx+1248h], xmm0
      vmovss  dword ptr [rbx+124Ch], xmm7
      vmovaps xmm7, [rsp+0B8h+var_28]
      vmovss  dword ptr [rbx+1250h], xmm8
      vmovaps xmm8, [rsp+0B8h+var_38]
      vmovss  dword ptr [rbx+1254h], xmm9
      vmovaps xmm9, [rsp+0B8h+var_48]
      vmovss  dword ptr [rbx+1258h], xmm10
      vmovaps xmm10, [rsp+0B8h+var_58]
      vmovss  dword ptr [rbx+125Ch], xmm11
      vmovaps xmm11, [rsp+0B8h+var_68]
      vmovss  dword ptr [rbx+1260h], xmm12
      vmovaps xmm12, [rsp+0B8h+var_78]
      vmovss  dword ptr [rbx+1264h], xmm13
      vmovaps xmm13, [rsp+0B8h+var_88]
      vmovss  dword ptr [rbx+1268h], xmm14
      vmovaps xmm14, [rsp+0B8h+var_98]
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm0, xmm0, eax
      vmovss  dword ptr [rbx+126Ch], xmm0
    }
  }
  else
  {
    Scr_Error(COM_ERR_5921, scrContext, "usage: VignetteSetParams( <intensity>, <squareAspectRatio>, <scaleX>, <scaleY>, <falloff>, <falloffStart>, <boxSizeX>, <boxSizeY>, <offsetX>, <offsetY>, <optional:lerpDuration> )\n");
  }
}

/*
==============
GScr_VignetteGetParams
==============
*/
void GScr_VignetteGetParams(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *PlayerEntity; 
  unsigned int CanonicalString; 
  char v10; 
  int v11; 
  unsigned int v12; 
  unsigned int v14; 
  unsigned int v16; 
  unsigned int v18; 
  unsigned int v20; 
  unsigned int v22; 
  unsigned int v24; 
  unsigned int v26; 
  unsigned int v28; 
  unsigned int v31; 

  __asm { vmovaps [rsp+38h+var_18], xmm6 }
  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  _RDI = G_GetEntityPlayerState(PlayerEntity);
  Scr_MakeStruct(scrContext);
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+1244h]
    vxorps  xmm6, xmm6, xmm6
    vmaxss  xmm1, xmm0, xmm6; value
  }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
  CanonicalString = SL_GetCanonicalString("intensity");
  Scr_AddStructField(scrContext, CanonicalString);
  __asm { vucomiss xmm6, dword ptr [rdi+1248h] }
  if ( v10 )
    v11 = 0;
  else
    v11 = 1;
  Scr_AddBool(scrContext, v11);
  v12 = SL_GetCanonicalString("squareaspectratio");
  Scr_AddStructField(scrContext, v12);
  __asm { vmovss  xmm1, dword ptr [rdi+124Ch]; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
  v14 = SL_GetCanonicalString("scalex");
  Scr_AddStructField(scrContext, v14);
  __asm { vmovss  xmm1, dword ptr [rdi+1250h]; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
  v16 = SL_GetCanonicalString("scaley");
  Scr_AddStructField(scrContext, v16);
  __asm { vmovss  xmm1, dword ptr [rdi+1254h]; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
  v18 = SL_GetCanonicalString("falloff");
  Scr_AddStructField(scrContext, v18);
  __asm { vmovss  xmm1, dword ptr [rdi+1258h]; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
  v20 = SL_GetCanonicalString("falloffstart");
  Scr_AddStructField(scrContext, v20);
  __asm { vmovss  xmm1, dword ptr [rdi+125Ch]; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
  v22 = SL_GetCanonicalString("boxsizex");
  Scr_AddStructField(scrContext, v22);
  __asm { vmovss  xmm1, dword ptr [rdi+1260h]; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
  v24 = SL_GetCanonicalString("boxsizey");
  Scr_AddStructField(scrContext, v24);
  __asm { vmovss  xmm1, dword ptr [rdi+1264h]; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
  v26 = SL_GetCanonicalString("offsetx");
  Scr_AddStructField(scrContext, v26);
  __asm { vmovss  xmm1, dword ptr [rdi+1268h]; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
  v28 = SL_GetCanonicalString("offsety");
  Scr_AddStructField(scrContext, v28);
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+126Ch]
    vmulss  xmm1, xmm0, cs:__real@3a83126f; value
  }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
  v31 = SL_GetCanonicalString("lerpduration");
  __asm { vmovaps xmm6, [rsp+38h+var_18] }
  Scr_AddStructField(scrContext, v31);
}

/*
==============
GScr_VignetteScriptDisable
==============
*/
void GScr_VignetteScriptDisable(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *PlayerEntity; 
  playerState_s *EntityPlayerState; 

  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  EntityPlayerState = G_GetEntityPlayerState(PlayerEntity);
  EntityPlayerState->vignetteIntensity = -1.0;
  EntityPlayerState->vignetteSquareAspectRatio = 0.0;
  EntityPlayerState->vignetteScale.v[0] = 1.0;
  EntityPlayerState->vignetteScale.v[1] = 1.0;
  *(_QWORD *)&EntityPlayerState->vignetteFalloff = 1065353216i64;
  EntityPlayerState->vignetteBoxSize = 0i64;
  EntityPlayerState->vignetteOffset = 0i64;
  EntityPlayerState->vignetteLerpDuration = 0.0;
}

/*
==============
GScr_SetNVGAreaLightEffect
==============
*/
void GScr_SetNVGAreaLightEffect(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v16; 
  playerState_s *EntityPlayerState; 
  int Int; 
  GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64> *p_weapFlags; 
  char *fmt; 

  entnum = entref.entnum;
  _RDI = GetEntity(entref);
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16702, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClientOrAgent(_RDI) )
  {
    targetname = _RDI->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(_RDI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rdi+134h]
      vmovss  xmm2, dword ptr [rdi+130h]
      vmovss  xmm0, dword ptr [rdi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+48h+fmt], xmm0
    }
    v16 = j_va("SetNVGAreaLightEffect(). Only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, fmt, v7, v6);
    Scr_Error(COM_ERR_4408, scrContext, v16);
  }
  EntityPlayerState = G_GetEntityPlayerState(_RDI);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16710, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4409, scrContext, "SetNVGAreaLightEffect(). USAGE: <player> SetNVGAreaLightEffect( <use alternate> )\n");
  Int = Scr_GetInt(scrContext, 0);
  p_weapFlags = &EntityPlayerState->weapCommon.weapFlags;
  if ( Int )
    GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::SetFlagInternal(p_weapFlags, ACTIVE, 8u);
  else
    GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::ClearFlagInternal(p_weapFlags, ACTIVE, 8u);
}

/*
==============
GScr_AnimScriptSetInputParamReplicationStatus
==============
*/
void GScr_AnimScriptSetInputParamReplicationStatus(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v16; 
  gclient_s *client; 
  int Int; 
  unsigned int v19; 
  char *fmt; 

  entnum = entref.entnum;
  _RDI = GetEntity(entref);
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16745, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClient(_RDI) )
  {
    targetname = _RDI->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(_RDI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rdi+134h]
      vmovss  xmm2, dword ptr [rdi+130h]
      vmovss  xmm0, dword ptr [rdi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+48h+fmt], xmm0
    }
    v16 = j_va("AnimScriptSetInputParamReplicationStatus(). Only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, fmt, v7, v6);
    Scr_Error(COM_ERR_4410, scrContext, v16);
  }
  client = _RDI->client;
  if ( !client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16753, ASSERT_TYPE_ASSERT, "( client )", (const char *)&queryFormat, "client") )
    __debugbreak();
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4411, scrContext, "AnimScriptSetInputParamReplicationStatus(). USAGE: <player> AnimScriptSetInputParamReplicationStatus( <replicate> )\n");
  Int = Scr_GetInt(scrContext, 0);
  v19 = client->flags & 0xFFFFF7FF;
  if ( Int )
    v19 = client->flags | 0x800;
  client->flags = v19;
}

/*
==============
GScr_AnimScriptSetParachuteState
==============
*/
void GScr_AnimScriptSetParachuteState(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v16; 
  playerState_s *EntityPlayerState; 
  scr_string_t ConstString; 
  int ParachuteState; 
  unsigned __int8 v20; 
  char *fmt; 

  entnum = entref.entnum;
  _RDI = GetEntity(entref);
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16788, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClient(_RDI) )
  {
    targetname = _RDI->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(_RDI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rdi+134h]
      vmovss  xmm2, dword ptr [rdi+130h]
      vmovss  xmm0, dword ptr [rdi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+48h+fmt], xmm0
    }
    v16 = j_va("AnimScriptSetParachuteState(). Only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, fmt, v7, v6);
    Scr_Error(COM_ERR_4412, scrContext, v16);
  }
  EntityPlayerState = G_GetEntityPlayerState(_RDI);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16796, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4413, scrContext, "AnimScriptSetInputParamReplicationStatus(). USAGE: <player> AnimScriptSetInputParamReplicationStatus( <replicate> )\n");
  ConstString = Scr_GetConstString(scrContext, 0);
  ParachuteState = BG_AnimScriptGetParachuteState(ConstString);
  v20 = ParachuteState;
  if ( !ParachuteState || ParachuteState >= 12 )
    Scr_ParamError(COM_ERR_4414, scrContext, 0, "Invalid parachute state supplied to AnimScriptSetParachuteState");
  GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::SetFlagInternal(&EntityPlayerState->pm_flags, ACTIVE, 0x2Eu);
  EntityPlayerState->skydivePlayerState.animState = v20;
}

/*
==============
GScr_AnimScriptExitParachuteState
==============
*/
void GScr_AnimScriptExitParachuteState(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v16; 
  playerState_s *EntityPlayerState; 
  char *fmt; 

  entnum = entref.entnum;
  _RDI = GetEntity(entref);
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16832, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClientOrAgent(_RDI) )
  {
    targetname = _RDI->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(_RDI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rdi+134h]
      vmovss  xmm2, dword ptr [rdi+130h]
      vmovss  xmm0, dword ptr [rdi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+48h+fmt], xmm0
    }
    v16 = j_va("AnimScriptExitParachuteState(). Only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, fmt, v7, v6);
    Scr_Error(COM_ERR_4415, scrContext, v16);
  }
  EntityPlayerState = G_GetEntityPlayerState(_RDI);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16840, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( (int)Scr_GetNumParam(scrContext) > 0 )
    Scr_Error(COM_ERR_4416, scrContext, "AnimScriptExitParachuteState(). Too many parameters. USAGE: <player> AnimScriptExitParachuteState()\n");
  GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(&EntityPlayerState->pm_flags, ACTIVE, 0x2Eu);
  EntityPlayerState->skydivePlayerState.animState = 0;
}

/*
==============
GScr_AnimScriptSelfRevivingDoneEvent
==============
*/
void GScr_AnimScriptSelfRevivingDoneEvent(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v16; 
  playerState_s *EntityPlayerState; 
  unsigned int *holdrand; 
  GHandler *Handler; 
  char *fmt; 

  entnum = entref.entnum;
  _RDI = GetEntity(entref);
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16870, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClientOrAgent(_RDI) )
  {
    targetname = _RDI->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(_RDI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rdi+134h]
      vmovss  xmm2, dword ptr [rdi+130h]
      vmovss  xmm0, dword ptr [rdi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+48h+fmt], xmm0
    }
    v16 = j_va("AnimScriptSelfRevivingDoneEvent(): only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, fmt, v7, v6);
    Scr_Error(COM_ERR_6427, scrContext, v16);
  }
  EntityPlayerState = G_GetEntityPlayerState(_RDI);
  holdrand = G_GetRandomSeed();
  Handler = GHandler::getHandler();
  BG_AnimScriptEvent(Handler, EntityPlayerState, ANIM_ET_SELF_REVIVING_DONE, 0, 1, holdrand);
}

/*
==============
GScr_AnimScriptBuddyRevivingDoneEvent
==============
*/
void GScr_AnimScriptBuddyRevivingDoneEvent(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v16; 
  playerState_s *EntityPlayerState; 
  unsigned int *holdrand; 
  GHandler *Handler; 
  char *fmt; 

  entnum = entref.entnum;
  _RDI = GetEntity(entref);
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16899, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClientOrAgent(_RDI) )
  {
    targetname = _RDI->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(_RDI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rdi+134h]
      vmovss  xmm2, dword ptr [rdi+130h]
      vmovss  xmm0, dword ptr [rdi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+48h+fmt], xmm0
    }
    v16 = j_va("AnimScriptBuddyRevivingDoneEvent(): only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, fmt, v7, v6);
    Scr_Error(COM_ERR_6428, scrContext, v16);
  }
  EntityPlayerState = G_GetEntityPlayerState(_RDI);
  holdrand = G_GetRandomSeed();
  Handler = GHandler::getHandler();
  BG_AnimScriptEvent(Handler, EntityPlayerState, ANIM_ET_BUDDY_REVIVING_DONE, 0, 1, holdrand);
}

/*
==============
GScr_AnimScriptEnterVehicle
==============
*/
void GScr_AnimScriptEnterVehicle(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v16; 
  playerState_s *EntityPlayerState; 
  char *fmt; 

  entnum = entref.entnum;
  _RDI = GetEntity(entref);
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16925, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClientOrAgent(_RDI) )
  {
    targetname = _RDI->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(_RDI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rdi+134h]
      vmovss  xmm2, dword ptr [rdi+130h]
      vmovss  xmm0, dword ptr [rdi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+48h+fmt], xmm0
    }
    v16 = j_va("AnimScriptEnterVehicle(). Only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, fmt, v7, v6);
    Scr_Error(COM_ERR_4417, scrContext, v16);
  }
  EntityPlayerState = G_GetEntityPlayerState(_RDI);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16933, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( (int)Scr_GetNumParam(scrContext) > 0 )
    Scr_Error(COM_ERR_4418, scrContext, "AnimScriptEnterVehicle(). USAGE: <player> AnimScriptEnterVehicle()\n");
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal(&EntityPlayerState->otherFlags, ACTIVE, 0x1Bu);
}

/*
==============
GScr_AnimScriptExitVehicle
==============
*/
void GScr_AnimScriptExitVehicle(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v16; 
  playerState_s *EntityPlayerState; 
  char *fmt; 

  entnum = entref.entnum;
  _RDI = GetEntity(entref);
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16959, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClientOrAgent(_RDI) )
  {
    targetname = _RDI->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(_RDI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rdi+134h]
      vmovss  xmm2, dword ptr [rdi+130h]
      vmovss  xmm0, dword ptr [rdi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+48h+fmt], xmm0
    }
    v16 = j_va("AnimScriptExitVehicle(). Only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, fmt, v7, v6);
    Scr_Error(COM_ERR_4419, scrContext, v16);
  }
  EntityPlayerState = G_GetEntityPlayerState(_RDI);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16967, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( (int)Scr_GetNumParam(scrContext) > 0 )
    Scr_Error(COM_ERR_4420, scrContext, "AnimScriptExitVehicle(). USAGE: <player> AnimScriptEnterVehicle()\n");
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal(&EntityPlayerState->otherFlags, ACTIVE, 0x1Bu);
}

/*
==============
GScr_Vehicle_SetHeldWeaponVisibility
==============
*/
void GScr_Vehicle_SetHeldWeaponVisibility(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  scr_string_t v5; 
  const char *v6; 
  const char *v7; 
  const char *v16; 
  playerState_s *EntityPlayerState; 
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *p_otherFlags; 
  scr_string_t targetname; 
  const char *v20; 
  const char *v21; 
  const char *v30; 
  char *fmt; 
  char *fmta; 

  entnum = entref.entnum;
  _RDI = GetEntity(entref);
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16994, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( G_Utils_IsClientOrAgent(_RDI) )
  {
    EntityPlayerState = G_GetEntityPlayerState(_RDI);
    if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17003, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
      __debugbreak();
    p_otherFlags = &EntityPlayerState->otherFlags;
    if ( GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(p_otherFlags, ACTIVE, 0x1Bu) )
    {
      if ( Scr_GetNumParam(scrContext) != 1 )
        Scr_Error(COM_ERR_6140, scrContext, "Vehicle_SetHeldWeaponVisibility(). USAGE: <player> Vehicle_SetHeldWeaponVisibility( isVisible )\n");
      if ( Scr_GetInt(scrContext, 0) )
        GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal(p_otherFlags, ACTIVE, 0x1Cu);
      else
        GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal(p_otherFlags, ACTIVE, 0x1Cu);
    }
    else
    {
      targetname = _RDI->targetname;
      if ( targetname )
        v20 = SL_ConvertToString(targetname);
      else
        v20 = "<undefined>";
      v21 = SL_ConvertToString(_RDI->classname);
      __asm
      {
        vmovss  xmm3, dword ptr [rdi+134h]
        vmovss  xmm2, dword ptr [rdi+130h]
        vmovss  xmm0, dword ptr [rdi+138h]
        vcvtss2sd xmm3, xmm3, xmm3
        vcvtss2sd xmm2, xmm2, xmm2
        vcvtss2sd xmm0, xmm0, xmm0
        vmovq   r9, xmm3
        vmovq   r8, xmm2
        vmovsd  [rsp+48h+fmt], xmm0
      }
      v30 = j_va("Vehicle_SetHeldWeaponVisibility(). Only valid on players or agents which are playing vehicle animations via the AnimScriptEnterVehicle call; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, fmta, v21, v20);
      Scr_Error(COM_ERR_6139, scrContext, v30);
    }
  }
  else
  {
    v5 = _RDI->targetname;
    if ( v5 )
      v6 = SL_ConvertToString(v5);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(_RDI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rdi+134h]
      vmovss  xmm2, dword ptr [rdi+130h]
      vmovss  xmm0, dword ptr [rdi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+48h+fmt], xmm0
    }
    v16 = j_va("Vehicle_SetHeldWeaponVisibility(). Only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, fmt, v7, v6);
    Scr_Error(COM_ERR_6138, scrContext, v16);
  }
}

/*
==============
GScr_Vehicle_SetStowedWeaponVisibility
==============
*/
void GScr_Vehicle_SetStowedWeaponVisibility(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  scr_string_t v5; 
  const char *v6; 
  const char *v7; 
  const char *v16; 
  playerState_s *EntityPlayerState; 
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *p_otherFlags; 
  scr_string_t targetname; 
  const char *v20; 
  const char *v21; 
  const char *v30; 
  char *fmt; 
  char *fmta; 

  entnum = entref.entnum;
  _RDI = GetEntity(entref);
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17045, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( G_Utils_IsClientOrAgent(_RDI) )
  {
    EntityPlayerState = G_GetEntityPlayerState(_RDI);
    if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17054, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
      __debugbreak();
    p_otherFlags = &EntityPlayerState->otherFlags;
    if ( GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(p_otherFlags, ACTIVE, 0x1Bu) )
    {
      if ( Scr_GetNumParam(scrContext) != 1 )
        Scr_Error(COM_ERR_6143, scrContext, "Vehicle_SetStowedWeaponVisibility(). USAGE: <player> Vehicle_SetStowedWeaponVisibility( isVisible )\n");
      if ( Scr_GetInt(scrContext, 0) )
        GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal(p_otherFlags, ACTIVE, 0x1Du);
      else
        GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal(p_otherFlags, ACTIVE, 0x1Du);
    }
    else
    {
      targetname = _RDI->targetname;
      if ( targetname )
        v20 = SL_ConvertToString(targetname);
      else
        v20 = "<undefined>";
      v21 = SL_ConvertToString(_RDI->classname);
      __asm
      {
        vmovss  xmm3, dword ptr [rdi+134h]
        vmovss  xmm2, dword ptr [rdi+130h]
        vmovss  xmm0, dword ptr [rdi+138h]
        vcvtss2sd xmm3, xmm3, xmm3
        vcvtss2sd xmm2, xmm2, xmm2
        vcvtss2sd xmm0, xmm0, xmm0
        vmovq   r9, xmm3
        vmovq   r8, xmm2
        vmovsd  [rsp+48h+fmt], xmm0
      }
      v30 = j_va("Vehicle_SetStowedWeaponVisibility(). Only valid on players or agents which are playing vehicle animations via the AnimScriptEnterVehicle call; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, fmta, v21, v20);
      Scr_Error(COM_ERR_6142, scrContext, v30);
    }
  }
  else
  {
    v5 = _RDI->targetname;
    if ( v5 )
      v6 = SL_ConvertToString(v5);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(_RDI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rdi+134h]
      vmovss  xmm2, dword ptr [rdi+130h]
      vmovss  xmm0, dword ptr [rdi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+48h+fmt], xmm0
    }
    v16 = j_va("Vehicle_SetStowedWeaponVisibility(). Only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, fmt, v7, v6);
    Scr_Error(COM_ERR_6141, scrContext, v16);
  }
}

/*
==============
GScr_GetLeftStickX
==============
*/
void GScr_GetLeftStickX(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v16; 
  playerState_s *EntityPlayerState; 
  char *fmt; 
  int v20; 

  entnum = entref.entnum;
  _RDI = GetEntity(entref);
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17095, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClient(_RDI) )
  {
    targetname = _RDI->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(_RDI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rdi+134h]
      vmovss  xmm2, dword ptr [rdi+130h]
      vmovss  xmm0, dword ptr [rdi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+58h+fmt], xmm0
    }
    v16 = j_va("GetLeftStickX(). Only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, fmt, v7, v6);
    Scr_Error(COM_ERR_4421, scrContext, v16);
  }
  if ( (int)Scr_GetNumParam(scrContext) > 0 )
    Scr_Error(COM_ERR_4422, scrContext, "GetLeftStickX(). USAGE: x = <player> GetLeftStickX()\n");
  EntityPlayerState = G_GetEntityPlayerState(_RDI);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17110, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v20 = *(_QWORD *)&BG_GetStickCartesianCoords(EntityPlayerState->lastInput.rightmove, EntityPlayerState->lastInput.forwardmove);
  __asm { vmovss  xmm1, dword ptr [rsp+58h+arg_10]; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
GScr_GetLeftStickY
==============
*/
void GScr_GetLeftStickY(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v16; 
  playerState_s *EntityPlayerState; 
  char *fmt; 
  int v20; 

  entnum = entref.entnum;
  _RDI = GetEntity(entref);
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17133, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClient(_RDI) )
  {
    targetname = _RDI->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(_RDI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rdi+134h]
      vmovss  xmm2, dword ptr [rdi+130h]
      vmovss  xmm0, dword ptr [rdi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+58h+fmt], xmm0
    }
    v16 = j_va("GetLeftStickY(). Only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, fmt, v7, v6);
    Scr_Error(COM_ERR_4423, scrContext, v16);
  }
  if ( (int)Scr_GetNumParam(scrContext) > 0 )
    Scr_Error(COM_ERR_4424, scrContext, "GetLeftStickY(). USAGE: y = <player> GetLeftStickY()\n");
  EntityPlayerState = G_GetEntityPlayerState(_RDI);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17148, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v20 = HIDWORD(*(unsigned __int64 *)&BG_GetStickCartesianCoords(EntityPlayerState->lastInput.rightmove, EntityPlayerState->lastInput.forwardmove));
  __asm { vmovss  xmm1, dword ptr [rsp+58h+arg_10+4]; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
GScr_GetRightStickX
==============
*/
void GScr_GetRightStickX(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v16; 
  playerState_s *EntityPlayerState; 
  char *fmt; 
  int v20; 

  entnum = entref.entnum;
  _RDI = GetEntity(entref);
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17171, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClient(_RDI) )
  {
    targetname = _RDI->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(_RDI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rdi+134h]
      vmovss  xmm2, dword ptr [rdi+130h]
      vmovss  xmm0, dword ptr [rdi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+58h+fmt], xmm0
    }
    v16 = j_va("GetRightStickX(). Only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, fmt, v7, v6);
    Scr_Error(COM_ERR_4425, scrContext, v16);
  }
  if ( (int)Scr_GetNumParam(scrContext) > 0 )
    Scr_Error(COM_ERR_4426, scrContext, "GetRightStickX(). USAGE: x = <player> GetRightStickX()\n");
  EntityPlayerState = G_GetEntityPlayerState(_RDI);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17186, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v20 = *(_QWORD *)&BG_GetStickCartesianCoords(EntityPlayerState->lastInput.yawmove, EntityPlayerState->lastInput.pitchmove);
  __asm { vmovss  xmm1, dword ptr [rsp+58h+arg_10]; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
GScr_GetRightStickY
==============
*/
void GScr_GetRightStickY(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v16; 
  playerState_s *EntityPlayerState; 
  char *fmt; 
  int v20; 

  entnum = entref.entnum;
  _RDI = GetEntity(entref);
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17209, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClient(_RDI) )
  {
    targetname = _RDI->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(_RDI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rdi+134h]
      vmovss  xmm2, dword ptr [rdi+130h]
      vmovss  xmm0, dword ptr [rdi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+58h+fmt], xmm0
    }
    v16 = j_va("GetRightStickY(). Only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, fmt, v7, v6);
    Scr_Error(COM_ERR_4427, scrContext, v16);
  }
  if ( (int)Scr_GetNumParam(scrContext) > 0 )
    Scr_Error(COM_ERR_4428, scrContext, "GetRightStickY(). USAGE: y = <player> GetRightStickY()\n");
  EntityPlayerState = G_GetEntityPlayerState(_RDI);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17224, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
    __debugbreak();
  v20 = HIDWORD(*(unsigned __int64 *)&BG_GetStickCartesianCoords(EntityPlayerState->lastInput.yawmove, EntityPlayerState->lastInput.pitchmove));
  __asm { vmovss  xmm1, dword ptr [rsp+58h+arg_10+4]; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
GScr_PlayAnimScriptSceneEvent
==============
*/
void GScr_PlayAnimScriptSceneEvent(scrContext_t *scrContext, scr_entref_t entref)
{
  const characterInfo_t *v2; 
  int NumParam; 
  scr_string_t targetname; 
  const char *v8; 
  const char *v9; 
  const char *v18; 
  playerState_s *EntityPlayerState; 
  const char *String; 
  const char *v21; 
  const char *v22; 
  const clientState_t *p_cs; 
  int time; 
  const char *v25; 
  gclient_s *client; 
  gagent_s *agent; 
  unsigned int ScriptedSceneAnimTypeIndex; 
  int v29; 
  const char *v30; 
  unsigned int *holdrand; 
  GHandler *Handler; 
  int v33; 
  int v34; 
  const char *v35; 
  char *fmt; 
  PlayerAnimScriptEventType event; 
  char *value; 

  v2 = NULL;
  value = NULL;
  NumParam = Scr_GetNumParam(scrContext);
  _RDI = GetEntity(entref);
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17255, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClientOrAgent(_RDI) )
  {
    targetname = _RDI->targetname;
    if ( targetname )
      v8 = SL_ConvertToString(targetname);
    else
      v8 = "<undefined>";
    v9 = SL_ConvertToString(_RDI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rdi+134h]
      vmovss  xmm2, dword ptr [rdi+130h]
      vmovss  xmm0, dword ptr [rdi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+78h+fmt], xmm0
    }
    v18 = j_va("PlayAnimScriptEvent(). Only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entref.entnum, _R8, _R9, fmt, v9, v8);
    Scr_Error(COM_ERR_4429, scrContext, v18);
  }
  EntityPlayerState = G_GetEntityPlayerState(_RDI);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17263, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( NumParam < 1 )
    Scr_Error(COM_ERR_4430, scrContext, "PlayAnimScriptEvent(). USAGE: <player> PlayAnimScriptEvent(<eventname>, <optional scene_scriptedanimtype>)\n");
  String = Scr_GetString(scrContext, 0);
  if ( NumParam >= 2 )
    value = (char *)Scr_GetString(scrContext, 1u);
  event = BG_GetExposedAnimEvent(String);
  if ( event < ANIM_ET_DEATH )
  {
    v21 = j_va("PlayAnimScriptSceneEvent(). Invalid event name '%s'\n", String);
    Scr_Error(COM_ERR_4431, scrContext, v21);
  }
  if ( event != ANIM_ET_SCRIPTED_SCENE )
  {
    v22 = j_va("PlayAnimScriptSceneEvent(). Attempting to play anim event '%s', but it is not a scene anim, use PlayAnimScriptEvent for this\n", String);
    Scr_Error(COM_ERR_4432, scrContext, v22);
  }
  p_cs = NULL;
  if ( _RDI->client )
  {
    if ( !*(_QWORD *)&GStatic::ms_gameStatics && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_static.h", 64, ASSERT_TYPE_ASSERT, "( ms_gameStatics )", (const char *)&queryFormat, "ms_gameStatics") )
      __debugbreak();
    if ( *(_QWORD *)&GStatic::ms_gameStatics )
      v2 = (const characterInfo_t *)(*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)&GStatic::ms_gameStatics + 216i64))(*(_QWORD *)&GStatic::ms_gameStatics, (unsigned int)_RDI->s.number);
    p_cs = &_RDI->client->sess.cs;
  }
  time = level.time;
  v25 = j_va("g_scr_main starting scripted anim %s", String);
  BG_ScriptedAsmDebugPrint(v25, time, v2, p_cs);
  if ( PlayerASM_IsEnabled() )
  {
    client = _RDI->client;
    if ( client )
    {
      client->sess.cs.playerASM_scripted_anim_start_time = level.time;
      BG_ScriptedAsmDebugPrint("g_scr_main client anim", level.time, v2, p_cs);
    }
    else
    {
      agent = _RDI->agent;
      if ( agent )
      {
        agent->agentState.playerASM_scripted_anim_start_time = level.time;
        BG_ScriptedAsmDebugPrint("g_scr_main agent anim", level.time, v2, p_cs);
      }
    }
  }
  else
  {
    GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::SetFlagInternal(&EntityPlayerState->pm_flags, GameModeFlagValues::ms_mpValue, 0x3Du);
  }
  if ( NumParam >= 2 && value )
  {
    ScriptedSceneAnimTypeIndex = BG_GetScriptedSceneAnimTypeIndex(value);
    BG_AnimScriptSetConditionValue(EntityPlayerState, 37, ScriptedSceneAnimTypeIndex);
    v29 = level.time;
    v30 = j_va("Set type %d", ScriptedSceneAnimTypeIndex);
    BG_ScriptedAsmDebugPrint(v30, v29, v2, p_cs);
  }
  holdrand = G_GetRandomSeed();
  Handler = GHandler::getHandler();
  v33 = BG_AnimScriptEvent(Handler, EntityPlayerState, event, 0, 1, holdrand);
  LODWORD(holdrand) = level.time;
  v34 = v33;
  v35 = j_va("Set event %d", (unsigned int)event);
  BG_ScriptedAsmDebugPrint(v35, (int)holdrand, v2, p_cs);
  Scr_AddInt(scrContext, v34);
}

/*
==============
GScr_StopAnimScriptSceneEvent
==============
*/
void GScr_StopAnimScriptSceneEvent(scrContext_t *scrContext, scr_entref_t entref)
{
  int NumParam; 
  scr_string_t targetname; 
  const char *v7; 
  const char *v8; 
  const char *v17; 
  playerState_s *EntityPlayerState; 
  __int64 v19; 
  const characterInfo_t *v20; 
  const clientState_t *p_cs; 
  GHandler *Handler; 
  unsigned int *holdrand; 
  GHandler *v24; 
  char *fmt; 

  NumParam = Scr_GetNumParam(scrContext);
  _RDI = GetEntity(entref);
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17367, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClientOrAgent(_RDI) )
  {
    targetname = _RDI->targetname;
    if ( targetname )
      v7 = SL_ConvertToString(targetname);
    else
      v7 = "<undefined>";
    v8 = SL_ConvertToString(_RDI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rdi+134h]
      vmovss  xmm2, dword ptr [rdi+130h]
      vmovss  xmm0, dword ptr [rdi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+58h+fmt], xmm0
    }
    v17 = j_va("StopAnimScriptEvent(). Only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entref.entnum, _R8, _R9, fmt, v8, v7);
    Scr_Error(COM_ERR_4433, scrContext, v17);
  }
  EntityPlayerState = G_GetEntityPlayerState(_RDI);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17375, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( NumParam > 0 )
    Scr_Error(COM_ERR_4434, scrContext, "StopAnimScriptEvent() takes no arguments\n");
  if ( !PlayerASM_IsEnabled() )
    GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(&EntityPlayerState->pm_flags, GameModeFlagValues::ms_mpValue, 0x3Du);
  v20 = NULL;
  p_cs = NULL;
  if ( _RDI->client )
  {
    if ( !*(_QWORD *)&GStatic::ms_gameStatics && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_static.h", 64, ASSERT_TYPE_ASSERT, "( ms_gameStatics )", (const char *)&queryFormat, "ms_gameStatics") )
      __debugbreak();
    if ( *(_QWORD *)&GStatic::ms_gameStatics )
      v20 = (const characterInfo_t *)(*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64, const clientState_t *))(**(_QWORD **)&GStatic::ms_gameStatics + 216i64))(*(_QWORD *)&GStatic::ms_gameStatics, (unsigned int)_RDI->s.number, v19, p_cs);
    p_cs = &_RDI->client->sess.cs;
  }
  BG_ScriptedAsmDebugPrint("g_scr_main stop anim scripted", level.time, v20, p_cs);
  BG_AnimScriptSetConditionValue(EntityPlayerState, 37, 0);
  Handler = GHandler::getHandler();
  BG_ClearSceneAnim(Handler, EntityPlayerState);
  holdrand = G_GetRandomSeed();
  v24 = GHandler::getHandler();
  BG_AnimScriptEvent(v24, EntityPlayerState, ANIM_ET_SCRIPTED_SCENE_DONE, 0, 1, holdrand);
}

/*
==============
GScr_PlayAnimScriptEvent
==============
*/
void GScr_PlayAnimScriptEvent(scrContext_t *scrContext, scr_entref_t entref)
{
  const char *v4; 
  int NumParam; 
  scr_string_t targetname; 
  const char *v8; 
  const char *v9; 
  const char *v18; 
  playerState_s *EntityPlayerState; 
  const char *String; 
  int ExposedAnimEvent; 
  const char *v22; 
  const char *v23; 
  int ScriptedAnimTypeIndex; 
  unsigned int *holdrand; 
  GHandler *Handler; 
  int v27; 
  char *fmt; 

  v4 = NULL;
  NumParam = Scr_GetNumParam(scrContext);
  _RSI = GetEntity(entref);
  if ( !_RSI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17428, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClientOrAgent(_RSI) )
  {
    targetname = _RSI->targetname;
    if ( targetname )
      v8 = SL_ConvertToString(targetname);
    else
      v8 = "<undefined>";
    v9 = SL_ConvertToString(_RSI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rsi+134h]
      vmovss  xmm2, dword ptr [rsi+130h]
      vmovss  xmm0, dword ptr [rsi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+58h+fmt], xmm0
    }
    v18 = j_va("PlayAnimScriptEvent(). Only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entref.entnum, _R8, _R9, fmt, v9, v8);
    Scr_Error(COM_ERR_4435, scrContext, v18);
  }
  EntityPlayerState = G_GetEntityPlayerState(_RSI);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17436, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( NumParam < 1 )
    Scr_Error(COM_ERR_4436, scrContext, "PlayAnimScriptEvent(). USAGE: <player> PlayAnimScriptEvent(<eventname>, <optional scriptedanimtype>)\n");
  String = Scr_GetString(scrContext, 0);
  if ( NumParam >= 2 )
    v4 = Scr_GetString(scrContext, 1u);
  ExposedAnimEvent = BG_GetExposedAnimEvent(String);
  if ( ExposedAnimEvent < 0 )
  {
    v22 = j_va("PlayAnimScriptEvent(). Invalid event name '%s'\n", String);
    Scr_Error(COM_ERR_4437, scrContext, v22);
  }
  if ( ExposedAnimEvent == 34 )
  {
    v23 = j_va("PlayAnimScriptEvent(). Attempting to play a scene anim event '%s', use PlayAnimScriptSceneEvent for this\n", String);
    Scr_Error(COM_ERR_4438, scrContext, v23);
  }
  if ( NumParam >= 2 && v4 )
  {
    ScriptedAnimTypeIndex = BG_GetScriptedAnimTypeIndex(v4);
    BG_AnimScriptSetConditionBit(EntityPlayerState, 23, ScriptedAnimTypeIndex);
  }
  holdrand = G_GetRandomSeed();
  Handler = GHandler::getHandler();
  v27 = BG_AnimScriptEvent(Handler, EntityPlayerState, (PlayerAnimScriptEventType)ExposedAnimEvent, 0, 1, holdrand);
  Scr_AddInt(scrContext, v27);
}

/*
==============
PlayerCmd_PlayViewModelAnim
==============
*/
void PlayerCmd_PlayViewModelAnim(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *String; 
  const char *v6; 
  gclient_s *client; 
  playerState_s *p_ps; 
  GWeaponMap *Instance; 
  int time; 
  unsigned int v16; 
  GWeaponMap *v17; 
  const char *v18; 
  unsigned int outIndex[4]; 
  char dest[1024]; 

  Entity = GetEntity(entref);
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4439, scrContext, "PlayViewModelAnim(). Invalid number of parameters");
  String = Scr_GetString(scrContext, 0);
  v6 = String;
  if ( String && *String )
  {
    client = Entity->client;
    if ( !client )
    {
      Scr_Error(COM_ERR_4441, scrContext, "PlayGestureViewmodel(). Self must be a player");
      client = Entity->client;
    }
    if ( !client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17512, ASSERT_TYPE_ASSERT, "(player->client)", (const char *)&queryFormat, "player->client") )
      __debugbreak();
    p_ps = &Entity->client->ps;
    Instance = GWeaponMap::GetInstance();
    if ( BG_HighPriorityWeapon_Get(Instance, p_ps)->weaponIdx )
    {
      Scr_Error(COM_ERR_4442, scrContext, "You cannot play a scripted viewmodel animation when a high priority weapon is set. Player is most likely in the process of switching, or trying to switch, to a high priority weapon.");
    }
    else
    {
      Core_strcpy(dest, 0x400ui64, v6);
      I_strlwr(dest);
      Com_Printf(16, "Playing anim %s on the viewmodel\n", dest);
      if ( NetConstStrings_GetIndexPlusOneFromName(NETCONSTSTRINGTYPE_ANIM, dest, outIndex) )
      {
        XAnimFindData(dest);
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, edx
          vdivss  xmm1, xmm0, dword ptr [rax+64h]
          vmulss  xmm2, xmm1, cs:__real@447a0000
          vcvttss2si ebp, xmm2
        }
        if ( !outIndex[0] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17537, ASSERT_TYPE_ASSERT, "( animIndex != 0 )", (const char *)&queryFormat, "animIndex != 0") )
          __debugbreak();
        time = level.time;
        v16 = outIndex[0];
        v17 = GWeaponMap::GetInstance();
        BG_Weapon_ViewModelScriptedBegin(v17, p_ps, v16, time, _EBP, WEAPON_HAND_DEFAULT);
      }
      else
      {
        _EBP = 0;
        v18 = j_va("MP Anim [%s] needs to be pre-cached in order to work with PlayViewModelAnim()\n", dest);
        Scr_Error(COM_ERR_4443, scrContext, v18);
      }
      Scr_AddInt(scrContext, _EBP);
    }
  }
  else
  {
    Scr_Error(COM_ERR_4440, scrContext, "PlayViewModelAnim() missing xanim name");
  }
}

/*
==============
PlayerCmd_StopViewModelAnim
==============
*/
void PlayerCmd_StopViewModelAnim(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  playerState_s *p_ps; 
  GHandler *Handler; 
  GWeaponMap *Instance; 

  Entity = GetEntity(entref);
  if ( Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_4444, scrContext, "PlayViewModelAnim(). Takes No parameters");
  if ( !Entity->client )
  {
    Scr_Error(COM_ERR_4445, scrContext, "PlayGestureViewmodel(). Self must be a player");
    if ( !Entity->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17577, ASSERT_TYPE_ASSERT, "(player->client)", (const char *)&queryFormat, "player->client") )
      __debugbreak();
  }
  p_ps = &Entity->client->ps;
  if ( BG_Weapon_IsScriptedViewModelAnimPlaying(p_ps) )
  {
    GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::ClearFlagInternal(&p_ps->weapCommon.weapFlags, ACTIVE, 0x2Au);
    Handler = GHandler::getHandler();
    Instance = GWeaponMap::GetInstance();
    PM_ResetWeaponState(Instance, p_ps, Handler);
  }
}

/*
==============
PlayerCmd_IsViewModelAnimPlaying
==============
*/
void PlayerCmd_IsViewModelAnimPlaying(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  bool IsScriptedViewModelAnimPlaying; 

  Entity = GetEntity(entref);
  if ( Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_4446, scrContext, "IsViewModelAnimPlaying() takes no parameters");
  if ( !Entity->client )
  {
    Scr_Error(COM_ERR_4447, scrContext, "IsViewModelAnimPlaying() self must be a player");
    if ( !Entity->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17613, ASSERT_TYPE_ASSERT, "(player->client)", (const char *)&queryFormat, "player->client") )
      __debugbreak();
  }
  IsScriptedViewModelAnimPlaying = BG_Weapon_IsScriptedViewModelAnimPlaying(&Entity->client->ps);
  Scr_AddInt(scrContext, IsScriptedViewModelAnimPlaying);
}

/*
==============
GScr_SetDemeanorViewmodel
==============
*/
void GScr_SetDemeanorViewmodel(scrContext_t *scrContext, scr_entref_t entref)
{
  const char *String; 
  gentity_s *Entity; 
  unsigned int v5; 
  scr_string_t ConstString; 
  scr_string_t v7; 
  playerState_s *p_ps; 
  scr_string_t DefaultGesture; 
  unsigned int IndexFromName; 
  bool v11; 

  String = NULL;
  Entity = GetEntity(entref);
  v5 = Scr_GetNumParam(scrContext) - 1;
  if ( v5 )
  {
    if ( v5 != 1 )
      Scr_Error(COM_ERR_4448, scrContext, "too many parameters");
    String = Scr_GetString(scrContext, 1u);
  }
  ConstString = Scr_GetConstString(scrContext, 0);
  v7 = ConstString;
  if ( ConstString )
  {
    if ( BG_Demeanor_GetStateType(ConstString) == DEMEANOR_STATE_NUM )
    {
      Scr_Error(COM_ERR_4450, scrContext, "SetDemeanorViewmodel() invalid state name. Valid states are: 'normal', 'safe', 'relaxed'.");
    }
    else
    {
      if ( !Entity->client )
      {
        Scr_Error(COM_ERR_4451, scrContext, "self must be a player");
        if ( !Entity->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17679, ASSERT_TYPE_ASSERT, "(player->client)", (const char *)&queryFormat, "player->client") )
          __debugbreak();
      }
      p_ps = &Entity->client->ps;
      if ( !String || !*String )
      {
        DefaultGesture = BG_Demeanor_GetDefaultGesture(v7);
        if ( DefaultGesture )
          String = SL_ConvertToString(DefaultGesture);
        else
          String = "void";
      }
      IndexFromName = BG_Gesture_GetIndexFromName(String);
      if ( IndexFromName == 256 && BG_Demeanor_GetStateType(v7) )
        Scr_Error(COM_ERR_4452, scrContext, "SetDemeanorViewmodel() invalid gesture asset name.\n");
      v11 = 0;
      if ( (unsigned int)(p_ps->weapState[0].weaponState - 34) > 2 )
        v11 = BG_Demeanor_SetState(p_ps, v7, IndexFromName, level.time);
      Scr_AddBool(scrContext, v11);
    }
  }
  else
  {
    Scr_Error(COM_ERR_4449, scrContext, "SetDemeanorViewmodel() missing demeanor state name");
  }
}

/*
==============
GScr_GetDemeanorViewmodel
==============
*/
void GScr_GetDemeanorViewmodel(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  DemeanorStateType TargetState; 
  scr_string_t StateName; 
  const char *v6; 

  Entity = GetEntity(entref);
  if ( Scr_GetNumParam(scrContext) )
  {
    Scr_Error(COM_ERR_4453, scrContext, "too many parameters");
  }
  else
  {
    if ( !Entity->client )
    {
      Scr_Error(COM_ERR_4454, scrContext, "self must be a player");
      if ( !Entity->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17751, ASSERT_TYPE_ASSERT, "(player->client)", (const char *)&queryFormat, "player->client") )
        __debugbreak();
    }
    TargetState = BG_Demeanor_GetTargetState(&Entity->client->ps);
    StateName = BG_Demeanor_GetStateName(TargetState);
    v6 = SL_ConvertToString(StateName);
    Scr_AddString(scrContext, v6);
  }
}

/*
==============
GScr_PlayGestureViewmodel
==============
*/
void GScr_PlayGestureViewmodel(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *v3; 
  bool v5; 
  gentity_s *Entity; 
  int NumParam; 
  const char *String; 
  const char *v13; 
  playerState_s *p_ps; 
  unsigned int IndexFromName; 
  bool v16; 
  int gameTime; 
  GHandler *Handler; 
  GWeaponMap *Instance; 
  bool v24; 
  const char *ErrorDescription; 
  const char *v26; 
  int v27; 
  int v28; 
  int number; 
  GestureError outErrorCode; 
  GesturePlayRequest request; 
  GesturePlayRequest result; 
  bool v33; 
  bool v34; 

  v3 = NULL;
  number = 2047;
  v28 = 0;
  v27 = 0;
  v34 = 0;
  v5 = 0;
  v33 = 0;
  Entity = GetEntity(entref);
  NumParam = Scr_GetNumParam(scrContext);
  if ( (unsigned int)(NumParam - 1) > 5 )
    Scr_Error(COM_ERR_4455, scrContext, "PlayGestureViewmodel(). Invalid number of parameters");
  if ( NumParam >= 2 && Scr_GetType(scrContext, 1u) )
    v3 = GScr_GetEntity(1u);
  if ( NumParam >= 3 && Scr_GetType(scrContext, 2u) )
    v33 = Scr_GetInt(scrContext, 2u) > 0;
  if ( NumParam >= 4 )
  {
    if ( Scr_GetType(scrContext, 3u) )
    {
      v5 = 1;
      *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
      __asm
      {
        vmulss  xmm1, xmm0, cs:__real@447a0000
        vcvttss2si ebp, xmm1
      }
      v28 = _EBP;
      if ( _EBP < 0 )
        Scr_Error(COM_ERR_4456, scrContext, "PlayGestureViewmodel(). Invalid blend time");
    }
  }
  if ( NumParam >= 5 )
  {
    if ( Scr_GetType(scrContext, 4u) )
    {
      *(double *)&_XMM0 = Scr_GetFloat(scrContext, 4u);
      __asm
      {
        vmulss  xmm1, xmm0, cs:__real@447a0000
        vcvttss2si ebp, xmm1
      }
      v27 = _EBP;
      if ( _EBP < 0 )
        Scr_Error(COM_ERR_4457, scrContext, "PlayGestureViewmodel(). Invalid start time");
    }
  }
  if ( NumParam >= 6 && Scr_GetType(scrContext, 5u) )
    v34 = Scr_GetInt(scrContext, 5u) > 0;
  String = Scr_GetString(scrContext, 0);
  v13 = String;
  if ( String && *String )
  {
    if ( v3 && G_IsEntityInUse(v3->s.number) )
      number = v3->s.number;
    if ( !Entity->client )
    {
      Scr_Error(COM_ERR_4459, scrContext, "PlayGestureViewmodel(). Self must be a player");
      if ( !Entity->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17862, ASSERT_TYPE_ASSERT, "(player->client)", (const char *)&queryFormat, "player->client") )
        __debugbreak();
    }
    p_ps = &Entity->client->ps;
    IndexFromName = BG_Gesture_GetIndexFromName(v13);
    if ( IndexFromName == 256 )
      Scr_Error(COM_ERR_4460, scrContext, "PlayGestureViewmodel() invalid gesture asset name.\n");
    v16 = v5 && BG_Demeanor_ShouldEnableBlendToLoop(p_ps, IndexFromName);
    gameTime = level.time;
    Handler = GHandler::getHandler();
    Instance = GWeaponMap::GetInstance();
    _RAX = BG_GesturePriority_SetupRequest(&result, Instance, p_ps, Handler, IndexFromName, gameTime);
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovups ymmword ptr [rsp+0E8h+request.weaponMap], ymm0
      vmovups xmm1, xmmword ptr [rax+20h]
      vmovups xmmword ptr [rsp+0E8h+request.startTime], xmm1
      vmovsd  xmm0, qword ptr [rax+30h]
    }
    request.startTime = v27;
    request.ignoreGamePlayState = v33;
    request.slotBlendDuration = v28;
    __asm { vmovsd  qword ptr [rsp+0E8h+request.cancelTransitions], xmm0 }
    request.targetEntNumber = number;
    request.stopAllGestures = 0;
    request.slotBlend = v5;
    request.cancelTransitions = v34 || v16;
    v24 = BG_GesturePriority_TryPlay(&request, NULL, &outErrorCode);
    if ( !v24 )
    {
      if ( outErrorCode )
      {
        ErrorDescription = BG_Gesture_GetErrorDescription(outErrorCode);
        v26 = j_va("Gesture '%s' %s.", v13, ErrorDescription);
        Scr_Error(COM_ERR_4461, scrContext, v26);
      }
    }
    Scr_AddBool(scrContext, v24);
  }
  else
  {
    Scr_Error(COM_ERR_4458, scrContext, "PlayGestureViewmodel() missing gesture asset name");
  }
}

/*
==============
GScr_ForcePlayGestureViewmodel
==============
*/
void GScr_ForcePlayGestureViewmodel(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *v3; 
  bool v5; 
  bool v6; 
  gentity_s *Entity; 
  int NumParam; 
  const char *String; 
  const char *v14; 
  playerState_s *p_ps; 
  unsigned int IndexFromName; 
  bool v17; 
  int gameTime; 
  GHandler *Handler; 
  GWeaponMap *Instance; 
  bool v25; 
  const char *ErrorDescription; 
  const char *v27; 
  int v28; 
  int v29; 
  int number; 
  GestureError outErrorCode; 
  GesturePlayRequest request; 
  GesturePlayRequest result; 
  bool v34; 
  bool v35; 

  v3 = NULL;
  number = 2047;
  v29 = 0;
  v5 = 1;
  v28 = 0;
  v34 = 1;
  v35 = 0;
  v6 = 0;
  Entity = GetEntity(entref);
  NumParam = Scr_GetNumParam(scrContext);
  if ( (unsigned int)(NumParam - 1) > 5 )
    Scr_Error(COM_ERR_4462, scrContext, "PlayGestureViewmodel(). Invalid number of parameters");
  if ( NumParam >= 3 )
  {
    if ( Scr_GetType(scrContext, 2u) )
    {
      v6 = 1;
      *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
      __asm
      {
        vmulss  xmm1, xmm0, cs:__real@447a0000
        vcvttss2si ebp, xmm1
      }
      v29 = _EBP;
      if ( _EBP < 0 )
        Scr_Error(COM_ERR_4463, scrContext, "PlayGestureViewmodel(). Invalid blend time");
    }
  }
  if ( NumParam >= 2 && Scr_GetType(scrContext, 1u) )
    v3 = GScr_GetEntity(1u);
  if ( NumParam >= 4 )
  {
    if ( Scr_GetType(scrContext, 3u) )
    {
      *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
      __asm
      {
        vmulss  xmm1, xmm0, cs:__real@447a0000
        vcvttss2si ebp, xmm1
      }
      v28 = _EBP;
      if ( _EBP < 0 )
        Scr_Error(COM_ERR_4464, scrContext, "PlayGestureViewmodel(). Invalid start time");
    }
  }
  if ( NumParam >= 5 && Scr_GetType(scrContext, 4u) )
  {
    v5 = Scr_GetInt(scrContext, 4u) > 0;
    v34 = v5;
  }
  if ( NumParam == 6 )
  {
    if ( Scr_GetType(scrContext, 5u) )
    {
      v35 = Scr_GetInt(scrContext, 5u) > 0;
      if ( !v5 || !v6 )
        Scr_Error(COM_ERR_4465, scrContext, "ForcePlayGestureViewmodel(). Cancel transitions is available only when stopAllGestures is true and a valid blendtime is provided.");
    }
  }
  String = Scr_GetString(scrContext, 0);
  v14 = String;
  if ( String && *String )
  {
    if ( v3 && G_IsEntityInUse(v3->s.number) )
      number = v3->s.number;
    if ( !Entity->client )
    {
      Scr_Error(COM_ERR_4467, scrContext, "PlayGestureViewmodel(). Self must be a player");
      if ( !Entity->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 18000, ASSERT_TYPE_ASSERT, "(player->client)", (const char *)&queryFormat, "player->client") )
        __debugbreak();
    }
    p_ps = &Entity->client->ps;
    IndexFromName = BG_Gesture_GetIndexFromName(v14);
    if ( IndexFromName == 256 )
      Scr_Error(COM_ERR_4468, scrContext, "PlayGestureViewmodel() invalid gesture asset name.\n");
    v17 = v5 && v6 && BG_Demeanor_ShouldEnableBlendToLoop(p_ps, IndexFromName);
    gameTime = level.time;
    Handler = GHandler::getHandler();
    Instance = GWeaponMap::GetInstance();
    _RAX = BG_GesturePriority_SetupRequest(&result, Instance, p_ps, Handler, IndexFromName, gameTime);
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovups ymmword ptr [rsp+0E8h+request.weaponMap], ymm0
      vmovups xmm1, xmmword ptr [rax+20h]
      vmovups xmmword ptr [rsp+0E8h+request.startTime], xmm1
      vmovsd  xmm0, qword ptr [rax+30h]
    }
    request.startTime = v28;
    request.stopAllGestures = v34;
    request.slotBlendDuration = v29;
    __asm { vmovsd  qword ptr [rsp+0E8h+request.cancelTransitions], xmm0 }
    request.targetEntNumber = number;
    request.ignoreGamePlayState = 1;
    request.slotBlend = v6;
    request.cancelTransitions = v35 || v17;
    v25 = BG_GesturePriority_TryPlay(&request, NULL, &outErrorCode);
    if ( !v25 )
    {
      if ( outErrorCode )
      {
        ErrorDescription = BG_Gesture_GetErrorDescription(outErrorCode);
        v27 = j_va("Gesture '%s' %s.", v14, ErrorDescription);
        Scr_Error(COM_ERR_4469, scrContext, v27);
      }
    }
    Scr_AddBool(scrContext, v25);
  }
  else
  {
    Scr_Error(COM_ERR_4466, scrContext, "PlayGestureViewmodel() missing gesture asset name");
  }
}

/*
==============
GScr_StopGestureViewmodel
==============
*/
void GScr_StopGestureViewmodel(scrContext_t *scrContext, scr_entref_t entref)
{
  const char *v4; 
  char v6; 
  bool v7; 
  bool cancelTransitions; 
  gentity_s *Entity; 
  int NumParam; 
  const char *String; 
  const char *v13; 
  ComErrorCode v14; 
  playerState_s *p_ps; 
  unsigned int IndexFromName; 

  v4 = NULL;
  _EBP = 0;
  v6 = 1;
  v7 = 0;
  cancelTransitions = 0;
  Entity = GetEntity(entref);
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam > 3 )
  {
    Scr_Error(COM_ERR_4470, scrContext, "StopGestureViewmodel() too many parameters");
    return;
  }
  if ( NumParam >= 1 )
  {
    String = Scr_GetString(scrContext, 0);
    v4 = String;
    if ( !String || !*String )
    {
      Scr_Error(COM_ERR_4471, scrContext, "StopGestureViewmodel() missing gesture asset name.");
      return;
    }
    v6 = 0;
  }
  if ( NumParam >= 2 )
  {
    if ( Scr_GetType(scrContext, 1u) )
    {
      v7 = 1;
      *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
      __asm
      {
        vmulss  xmm1, xmm0, cs:__real@447a0000
        vcvttss2si ebp, xmm1
      }
      if ( _EBP >= 0 )
        goto LABEL_15;
      v13 = "StopGestureViewmodel(). Invalid 'out' time";
      v14 = COM_ERR_4472;
    }
    else
    {
      if ( Scr_GetType(scrContext, 1u) )
        goto LABEL_15;
      v13 = "StopGestureViewmodel(). Invalid 'out' time use 0 as the default.";
      v14 = COM_ERR_4473;
    }
    Scr_Error(v14, scrContext, v13);
  }
LABEL_15:
  if ( NumParam == 3 && Scr_GetType(scrContext, 2u) )
    cancelTransitions = Scr_GetInt(scrContext, 2u) > 0;
  if ( !Entity->client )
  {
    Scr_Error(COM_ERR_4474, scrContext, "self must be a player");
    if ( !Entity->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 18106, ASSERT_TYPE_ASSERT, "(player->client)", (const char *)&queryFormat, "player->client") )
      __debugbreak();
  }
  p_ps = &Entity->client->ps;
  if ( v6 )
  {
    BG_Gesture_StopAll(p_ps, level.time, v7, _EBP, cancelTransitions);
  }
  else
  {
    IndexFromName = BG_Gesture_GetIndexFromName(v4);
    if ( IndexFromName == 256 )
      Scr_Error(COM_ERR_4475, scrContext, "StopGestureViewmodel() invalid gesture asset name.\n");
    BG_Gesture_StopByIndex(p_ps, IndexFromName, level.time, v7, _EBP, cancelTransitions);
  }
}

/*
==============
GScr_GetGestureAnimLength
==============
*/
void GScr_GetGestureAnimLength(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *String; 
  const char *v6; 
  gclient_s *client; 
  unsigned int IndexFromName; 
  const Gesture *AssetFromIndex; 

  Entity = GetEntity(entref);
  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    String = Scr_GetString(scrContext, 0);
    v6 = String;
    if ( String && *String )
    {
      client = Entity->client;
      if ( !client )
      {
        Scr_Error(COM_ERR_4478, scrContext, "self must be a player");
        client = Entity->client;
      }
      if ( !client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 18164, ASSERT_TYPE_ASSERT, "(player->client)", (const char *)&queryFormat, "player->client") )
        __debugbreak();
      IndexFromName = BG_Gesture_GetIndexFromName(v6);
      if ( IndexFromName == 256 )
        Scr_Error(COM_ERR_4479, scrContext, "GetGestureAnimLength() invalid gesture asset name.\n");
      AssetFromIndex = BG_Gesture_GetAssetFromIndex(IndexFromName);
      if ( !AssetFromIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 18174, ASSERT_TYPE_ASSERT, "(gesture)", (const char *)&queryFormat, "gesture") )
        __debugbreak();
      *(double *)&_XMM0 = BG_Gesture_GetAnimLengthInSeconds(AssetFromIndex);
      __asm { vmovaps xmm1, xmm0; value }
      Scr_AddFloat(scrContext, *(float *)&_XMM1);
    }
    else
    {
      Scr_Error(COM_ERR_4477, scrContext, "GetGestureAnimLength() missing gesture asset name");
    }
  }
  else
  {
    Scr_Error(COM_ERR_4476, scrContext, "too many parameters");
  }
}

/*
==============
GScr_GetGestureStartTime
==============
*/
void GScr_GetGestureStartTime(scrContext_t *scrContext, scr_entref_t entref)
{
  GestureSectionType v4; 
  gentity_s *Entity; 
  const char *String; 
  const char *v7; 
  const char *v8; 
  const char *v9; 
  const char *v10; 
  scrContext_t *v11; 
  ComErrorCode v12; 
  unsigned int IndexFromName; 

  v4 = GESTURE_SECTION_NUM;
  Entity = GetEntity(entref);
  if ( Scr_GetNumParam(scrContext) != 2 )
  {
    Scr_Error(COM_ERR_4480, scrContext, "GScr_GetGestureStartTime(): invalid parameters.");
    return;
  }
  String = Scr_GetString(scrContext, 0);
  v7 = String;
  if ( !String || !*String )
  {
    Scr_Error(COM_ERR_4481, scrContext, "GScr_GetGestureStartTime() missing gesture asset name");
    return;
  }
  v8 = Scr_GetString(scrContext, 1u);
  v9 = v8;
  if ( !v8 || !*v8 )
  {
    v10 = "GScr_GetGestureStartTime() invalid gesture section.";
    v11 = scrContext;
    v12 = COM_ERR_4482;
    goto LABEL_9;
  }
  if ( !Entity->client )
  {
    v10 = "self must be a player";
    v11 = scrContext;
    v12 = COM_ERR_4483;
LABEL_9:
    Scr_Error(v12, v11, v10);
    return;
  }
  IndexFromName = BG_Gesture_GetIndexFromName(v7);
  if ( IndexFromName == 256 )
  {
    v10 = "GScr_GetGestureStartTime() invalid gesture asset name.\n";
    v11 = scrContext;
    v12 = COM_ERR_4484;
    goto LABEL_9;
  }
  if ( I_stricmp(v9, "in") )
  {
    if ( I_stricmp(v9, "loop") )
    {
      if ( I_stricmp(v9, "out") )
        Scr_Error(COM_ERR_4485, scrContext, "GScr_GetGestureStartTime() invalid gesture section. Valid values are: 'in', 'loop', and 'out'.");
      else
        v4 = GESTURE_SECTION_OUT;
    }
    else
    {
      v4 = GESTURE_SECTION_LOOP;
    }
  }
  else
  {
    v4 = GESTURE_SECTION_IN;
  }
  BG_Gesture_GetSectionStartTime(IndexFromName, v4);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, eax
    vmulss  xmm1, xmm0, cs:__real@3a83126f; value
  }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
GScr_IsGestureLooped
==============
*/
void GScr_IsGestureLooped(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *String; 
  const char *v5; 
  gclient_s *client; 
  unsigned int IndexFromName; 
  const Gesture *AssetFromIndex; 

  Entity = GetEntity(entref);
  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    String = Scr_GetString(scrContext, 0);
    v5 = String;
    if ( String && *String )
    {
      client = Entity->client;
      if ( !client )
      {
        Scr_Error(COM_ERR_4488, scrContext, "IsGestureLooped() self must be a player.");
        client = Entity->client;
      }
      if ( !client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 18299, ASSERT_TYPE_ASSERT, "(player->client)", (const char *)&queryFormat, "player->client") )
        __debugbreak();
      IndexFromName = BG_Gesture_GetIndexFromName(v5);
      if ( IndexFromName == 256 )
        Scr_Error(COM_ERR_4489, scrContext, "IsGestureLooped() invalid gesture asset name.\n");
      AssetFromIndex = BG_Gesture_GetAssetFromIndex(IndexFromName);
      if ( !AssetFromIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 18309, ASSERT_TYPE_ASSERT, "(gesture)", (const char *)&queryFormat, "gesture") )
        __debugbreak();
      Scr_AddBool(scrContext, AssetFromIndex->looping);
    }
    else
    {
      Scr_Error(COM_ERR_4487, scrContext, "IsGestureLooped() missing gesture asset name.");
    }
  }
  else
  {
    Scr_Error(COM_ERR_4486, scrContext, "IsGestureLooped() too many parameters");
  }
}

/*
==============
GScr_IsGesturePlaying
==============
*/
void GScr_IsGesturePlaying(scrContext_t *scrContext, scr_entref_t entref)
{
  const char *v3; 
  char v4; 
  gentity_s *Entity; 
  const char *String; 
  const playerState_s *p_ps; 
  bool IsPlaying; 
  unsigned int IndexFromName; 

  v3 = NULL;
  v4 = 1;
  Entity = GetEntity(entref);
  if ( Scr_GetNumParam(scrContext) > 1 )
  {
    Scr_Error(COM_ERR_4490, scrContext, "IsGesturePlaying() too many parameters");
    return;
  }
  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    String = Scr_GetString(scrContext, 0);
    v3 = String;
    if ( !String || !*String )
    {
      Scr_Error(COM_ERR_4491, scrContext, "IsGesturePlaying() missing gesture asset name.");
      return;
    }
    v4 = 0;
  }
  if ( !Entity->client )
  {
    Scr_Error(COM_ERR_4492, scrContext, "IsGesturePlaying() self must be a player.");
    if ( !Entity->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 18361, ASSERT_TYPE_ASSERT, "(player->client)", (const char *)&queryFormat, "player->client") )
      __debugbreak();
  }
  p_ps = &Entity->client->ps;
  if ( v4 )
  {
    IsPlaying = BG_Gesture_IsPlaying(p_ps, level.time, 0);
  }
  else
  {
    IndexFromName = BG_Gesture_GetIndexFromName(v3);
    if ( IndexFromName == 256 )
      Scr_Error(COM_ERR_4493, scrContext, "IsGesturePlaying() invalid gesture asset name.\n");
    IsPlaying = BG_Gesture_IsPlayingByIndex(p_ps, IndexFromName, NULL);
  }
  Scr_AddBool(scrContext, IsPlaying);
}

/*
==============
GScr_GetGestureViewmodel
==============
*/
void GScr_GetGestureViewmodel(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const playerState_s *p_ps; 
  unsigned int i; 
  const Gesture *CurrentAsset; 

  Entity = GetEntity(entref);
  if ( !Entity->client )
  {
    Scr_Error(COM_ERR_4494, scrContext, "self must be a player");
    if ( !Entity->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 18407, ASSERT_TYPE_ASSERT, "(player->client)", (const char *)&queryFormat, "player->client") )
      __debugbreak();
  }
  p_ps = &Entity->client->ps;
  Scr_MakeArray(scrContext);
  for ( i = 0; i < 2; ++i )
  {
    CurrentAsset = BG_Gesture_GetCurrentAsset(p_ps, i);
    if ( CurrentAsset )
    {
      if ( BG_Gesture_IsPlayingBySlot(p_ps, i, NULL) )
      {
        Scr_AddString(scrContext, CurrentAsset->name);
        Scr_AddArray(scrContext);
      }
    }
  }
}

/*
==============
GScr_GetGestureNotetrackTimes
==============
*/
void GScr_GetGestureNotetrackTimes(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *String; 
  const char *v5; 
  scr_string_t ConstString; 
  unsigned int IndexFromName; 
  const Gesture *AssetFromIndex; 
  int v9; 
  int outNumNotetracks; 
  float outTimes[10]; 

  Entity = GetEntity(entref);
  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    String = Scr_GetString(scrContext, 0);
    v5 = String;
    if ( String && *String )
    {
      ConstString = Scr_GetConstString(scrContext, 1u);
      if ( !ConstString && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 18465, ASSERT_TYPE_ASSERT, "(notetrack != ( static_cast< scr_string_t >( 0 ) ))", (const char *)&queryFormat, "notetrack != NULL_SCR_STRING") )
        __debugbreak();
      if ( !Entity->client )
      {
        Scr_Error(COM_ERR_4497, scrContext, "GScr_GetGestureNotetrackTimes() self must be a player");
        if ( !Entity->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 18474, ASSERT_TYPE_ASSERT, "(player->client)", (const char *)&queryFormat, "player->client") )
          __debugbreak();
      }
      IndexFromName = BG_Gesture_GetIndexFromName(v5);
      if ( IndexFromName == 256 )
        Scr_Error(COM_ERR_4498, scrContext, "GScr_GetGestureNotetrackTimes() invalid gesture asset name.\n");
      AssetFromIndex = BG_Gesture_GetAssetFromIndex(IndexFromName);
      if ( !AssetFromIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 18484, ASSERT_TYPE_ASSERT, "(gesture)", (const char *)&queryFormat, "gesture") )
        __debugbreak();
      BG_Gesture_GetNotetrackTimes(AssetFromIndex, ConstString, 10, outTimes, &outNumNotetracks);
      Scr_MakeArray(scrContext);
      v9 = 0;
      if ( outNumNotetracks > 0 )
      {
        _RDI = outTimes;
        do
        {
          __asm { vmovss  xmm1, dword ptr [rdi]; value }
          Scr_AddFloat(scrContext, *(float *)&_XMM1);
          Scr_AddArray(scrContext);
          ++v9;
          ++_RDI;
        }
        while ( v9 < outNumNotetracks );
      }
    }
    else
    {
      Scr_Error(COM_ERR_4496, scrContext, "GScr_GetGestureNotetrackTimes() missing gesture asset name");
    }
  }
  else
  {
    Scr_Error(COM_ERR_4495, scrContext, "GScr_GetGestureNotetrackTimes() wrong number of parameters");
  }
}

/*
==============
GScr_SetViewModelDepthOfField
==============
*/
void GScr_SetViewModelDepthOfField(scrContext_t *scrContext, scr_entref_t entref)
{
  Com_PrintWarning(24, "GScr_SetViewModelDepthOfField: Legacy DoF controls deprecated. Please update script to physical DoF controls!\n");
}

/*
==============
GScr_EnablePhysicalDepthOfFieldScripting
==============
*/
void GScr_EnablePhysicalDepthOfFieldScripting(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *PlayerEntity; 
  unsigned int NumParam; 
  unsigned int Int; 
  bool v6; 
  __int64 v7; 

  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam > 1 )
  {
    Scr_Error(COM_ERR_4502, scrContext, "Incorrect number of parameters\n");
    return;
  }
  if ( NumParam )
  {
    Int = Scr_GetInt(scrContext, 0);
    if ( Int != Scr_GetInt(scrContext, 0) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 18549, ASSERT_TYPE_ASSERT, "((int)dofPhysicalScriptingState == Scr_GetInt( scrContext, 0 ))", (const char *)&queryFormat, "(int)dofPhysicalScriptingState == Scr_GetInt( scrContext, 0 )") )
      __debugbreak();
    if ( !Int )
    {
      v6 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 18550, ASSERT_TYPE_ASSERT, "(dofPhysicalScriptingState != DOF_PHYSICAL_SCRIPTING_DISABLED)", (const char *)&queryFormat, "dofPhysicalScriptingState != DOF_PHYSICAL_SCRIPTING_DISABLED");
      goto LABEL_11;
    }
    if ( Int >= 4 )
    {
      LODWORD(v7) = Int;
      v6 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 18551, ASSERT_TYPE_ASSERT, "(unsigned)( dofPhysicalScriptingState ) < (unsigned)( DOF_PHYSICAL_SCRIPTING_COUNT )", "dofPhysicalScriptingState doesn't index DOF_PHYSICAL_SCRIPTING_COUNT\n\t%i not in [0, %i)", v7, 4);
LABEL_11:
      if ( v6 )
        __debugbreak();
    }
  }
  else
  {
    Int = 1;
  }
  PlayerEntity->client->ps.dofPhysicalScriptingState = Int;
}

/*
==============
GScr_DisablePhysicalDepthOfFieldScripting
==============
*/
void GScr_DisablePhysicalDepthOfFieldScripting(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *PlayerEntity; 
  gclient_s *client; 

  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  if ( Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_4503, scrContext, "Incorrect number of parameters\n");
  PlayerEntity->client->ps.dofPhysicalScriptingState = DOF_PHYSICAL_SCRIPTING_DISABLED;
  PlayerEntity->client->ps.dofPhysicalFstop = 22.0;
  PlayerEntity->client->ps.dofPhysicalFocusDistance = 29.301001;
  PlayerEntity->client->ps.dofPhysicalFocusSpeed = 1.0;
  PlayerEntity->client->ps.dofPhysicalApertureSpeed = 2.0;
  PlayerEntity->client->ps.dofPhysicalViewModelFstop = 22.0;
  PlayerEntity->client->ps.dofPhysicalViewModelFocusDistance = 29.301001;
  PlayerEntity->client->ps.dofPhysicalAdsStart = 29.301001;
  PlayerEntity->client->ps.dofPhysicalAdsEnd = 29.301001;
  client = PlayerEntity->client;
  *(_QWORD *)client->ps.dofPhysicalFocalPoint.v = 0i64;
  client->ps.dofPhysicalFocalPoint.v[2] = 0.0;
}

/*
==============
GScr_SetPhysicalDepthOfField
==============
*/
void GScr_SetPhysicalDepthOfField(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *PlayerEntity; 
  unsigned int NumParam; 
  bool v17; 
  bool v18; 
  vec3_t vectorValue; 
  char v34; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-18h], xmm6
    vmovaps xmmword ptr [rax-28h], xmm7
    vmovaps xmmword ptr [rax-38h], xmm8
    vmovaps xmmword ptr [rax-48h], xmm9
    vmovaps xmmword ptr [rax-58h], xmm10
  }
  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  if ( Scr_GetNumParam(scrContext) < 2 )
    Scr_Error(COM_ERR_4504, scrContext, "Incorrect number of parameters\n");
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm { vmovaps xmm9, xmm0 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm { vmovaps xmm10, xmm0 }
  if ( Scr_GetNumParam(scrContext) < 3 )
  {
    __asm { vmovss  xmm8, cs:__real@3f800000 }
  }
  else
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
    __asm { vmovaps xmm8, xmm0 }
  }
  if ( Scr_GetNumParam(scrContext) < 4 )
  {
    __asm { vmovss  xmm7, cs:__real@40000000 }
  }
  else
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
    __asm { vmovaps xmm7, xmm0 }
  }
  NumParam = Scr_GetNumParam(scrContext);
  __asm { vxorps  xmm6, xmm6, xmm6 }
  v17 = NumParam < 5;
  v18 = NumParam == 5;
  if ( NumParam < 5 )
  {
    __asm
    {
      vmovss  dword ptr [rsp+98h+vectorValue], xmm6
      vmovss  dword ptr [rsp+98h+vectorValue+4], xmm6
      vmovss  dword ptr [rsp+98h+vectorValue+8], xmm6
    }
  }
  else
  {
    Scr_GetVector(scrContext, 4u, &vectorValue);
  }
  __asm { vcomiss xmm9, cs:__real@3e000000 }
  if ( v17 )
    goto LABEL_14;
  __asm { vcomiss xmm9, cs:__real@41f00000 }
  if ( !v17 && !v18 )
LABEL_14:
    Scr_ParamError(COM_ERR_4505, scrContext, 0, "Invalid f-stop value");
  __asm { vcomiss xmm10, xmm6 }
  if ( v17 )
    Scr_ParamError(COM_ERR_4506, scrContext, 0, "Focus distance must be >= 0");
  __asm { vcomiss xmm8, xmm6 }
  if ( v17 )
    Scr_ParamError(COM_ERR_4507, scrContext, 0, "Focus speed must be >= 0");
  __asm { vcomiss xmm7, xmm6 }
  if ( v17 )
    Scr_ParamError(COM_ERR_4508, scrContext, 0, "Aperture speed must be >= 0");
  _RAX = PlayerEntity->client;
  __asm
  {
    vmovss  xmm0, dword ptr [rsp+98h+vectorValue]
    vmovss  dword ptr [rax+1204h], xmm0
    vmovss  xmm1, dword ptr [rsp+98h+vectorValue+4]
    vmovss  dword ptr [rax+1208h], xmm1
    vmovss  xmm0, dword ptr [rsp+98h+vectorValue+8]
    vmovss  dword ptr [rax+120Ch], xmm0
    vmovss  dword ptr [rax+1210h], xmm9
  }
  _RAX = PlayerEntity->client;
  __asm { vmovss  dword ptr [rax+1214h], xmm10 }
  _RAX = PlayerEntity->client;
  __asm { vmovss  dword ptr [rax+1218h], xmm8 }
  _RAX = PlayerEntity->client;
  __asm { vmovss  dword ptr [rax+121Ch], xmm7 }
  _R11 = &v34;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, [rsp+98h+var_28]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
  }
}

/*
==============
GScr_SetPhysicalViewModelDepthOfField
==============
*/
void GScr_SetPhysicalViewModelDepthOfField(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *PlayerEntity; 
  char v8; 
  char v9; 

  __asm
  {
    vmovaps [rsp+48h+var_18], xmm6
    vmovaps [rsp+48h+var_28], xmm7
  }
  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_Error(COM_ERR_4509, scrContext, "Incorrect number of parameters\n");
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm { vmovaps xmm6, xmm0 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm
  {
    vcomiss xmm6, cs:__real@3e000000
    vmovaps xmm7, xmm0
  }
  if ( v8 )
    goto LABEL_5;
  __asm { vcomiss xmm6, cs:__real@41f00000 }
  if ( !(v8 | v9) )
LABEL_5:
    Scr_ParamError(COM_ERR_4510, scrContext, 0, "Invalid f-stop value");
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm7, xmm0
  }
  if ( v8 )
    Scr_ParamError(COM_ERR_4511, scrContext, 0, "Focus distance must be >= 0");
  _RAX = PlayerEntity->client;
  __asm { vmovss  dword ptr [rax+1220h], xmm6 }
  _RAX = PlayerEntity->client;
  __asm
  {
    vmovaps xmm6, [rsp+48h+var_18]
    vmovss  dword ptr [rax+1224h], xmm7
    vmovaps xmm7, [rsp+48h+var_28]
  }
}

/*
==============
GScr_SetAdsPhysicalDepthOfField
==============
*/
void GScr_SetAdsPhysicalDepthOfField(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *PlayerEntity; 

  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_Error(COM_ERR_4512, scrContext, "Incorrect number of parameters\n");
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  _RAX = PlayerEntity->client;
  __asm { vmovss  dword ptr [rax+1228h], xmm0 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  _RAX = PlayerEntity->client;
  __asm { vmovss  dword ptr [rax+122Ch], xmm0 }
}

/*
==============
GScr_SetLensProfileDistort
==============
*/
void GScr_SetLensProfileDistort(scrContext_t *scrContext, scr_entref_t entref)
{
  int v9; 
  gentity_s *PlayerEntity; 
  const char *String; 
  __int64 v12; 
  char v13; 
  __int64 v14; 
  char v15; 
  char v31; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-18h], xmm6
    vmovaps xmmword ptr [rax-28h], xmm7
  }
  v9 = 0;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm8
    vmovaps xmmword ptr [rax-48h], xmm9
  }
  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  if ( !Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_4513, scrContext, "Incorrect number of parameters\n");
  String = Scr_GetString(scrContext, 0);
  v12 = 0i64;
  while ( 1 )
  {
    v13 = String[v12++];
    if ( v13 != val[v12 - 1] )
      break;
    if ( v12 == 5 )
      goto LABEL_24;
  }
  if ( !strcmp_0(String, "compact portable") )
  {
    v9 = 1;
  }
  else if ( !strcmp_0(String, "smartphone") )
  {
    v9 = 2;
  }
  else if ( !strcmp_0(String, "cinematic prime") )
  {
    v9 = 3;
  }
  else if ( !strcmp_0(String, "action cam 1") )
  {
    v9 = 4;
  }
  else if ( !strcmp_0(String, "action cam 2") )
  {
    v9 = 5;
  }
  else
  {
    v14 = 0i64;
    while ( 1 )
    {
      v15 = String[v14++];
      if ( v15 != aDrone[v14 - 1] )
        break;
      if ( v14 == 6 )
      {
        v9 = 6;
        goto LABEL_24;
      }
    }
    if ( !strcmp_0(String, "telescopic") )
      v9 = 7;
    else
      Scr_Error(COM_ERR_4514, scrContext, "Unknown lens profile mode.\n");
  }
LABEL_24:
  __asm { vxorps  xmm7, xmm7, xmm7 }
  if ( Scr_GetNumParam(scrContext) < 2 )
  {
    __asm { vxorps  xmm9, xmm9, xmm9 }
  }
  else
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
    __asm { vmovaps xmm9, xmm0 }
  }
  if ( Scr_GetNumParam(scrContext) >= 3 )
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
    __asm { vmovaps xmm7, xmm0 }
  }
  __asm { vmovss  xmm6, cs:__real@3f800000 }
  if ( Scr_GetNumParam(scrContext) < 4 )
  {
    __asm { vmovaps xmm8, xmm6 }
  }
  else
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
    __asm { vmovaps xmm8, xmm0 }
  }
  if ( Scr_GetNumParam(scrContext) >= 5 )
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 4u);
    __asm { vmovaps xmm6, xmm0 }
  }
  _R11 = &v31;
  PlayerEntity->client->ps.lensProfileMode = v9;
  _RAX = PlayerEntity->client;
  __asm { vmovss  dword ptr [rax+1234h], xmm9 }
  _RAX = PlayerEntity->client;
  __asm
  {
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovss  dword ptr [rax+1238h], xmm7
  }
  _RAX = PlayerEntity->client;
  __asm
  {
    vmovaps xmm7, [rsp+68h+var_28]
    vmovss  dword ptr [rax+123Ch], xmm8
  }
  _RAX = PlayerEntity->client;
  __asm
  {
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovss  dword ptr [rax+1240h], xmm6
    vmovaps xmm6, [rsp+68h+var_18]
  }
}

/*
==============
GScr_ViewKick
==============
*/
void GScr_ViewKick(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *PlayerEntity; 
  int v5; 
  const char *v8; 
  bool v10; 
  gclient_s *client; 
  vec3_t vectorValue; 

  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  if ( Scr_GetNumParam(scrContext) > 3 )
    Scr_Error(COM_ERR_4515, scrContext, "USAGE: <player> viewkick <force 0-127> <source position> [optional]<bool displayIndicator>\n");
  v5 = (PlayerEntity->maxHealth * Scr_GetInt(scrContext, 0) + 50) / 100;
  if ( v5 < 0 )
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
    __asm
    {
      vcvtss2sd xmm1, xmm0, xmm0
      vmovq   rdx, xmm1
    }
    v8 = j_va("viewkick: damage %g < 0\n", _RDX);
    Scr_Error(COM_ERR_4516, scrContext, v8);
  }
  Scr_GetVector(scrContext, 1u, &vectorValue);
  _RAX = PlayerEntity->client;
  v10 = 1;
  __asm
  {
    vmovss  xmm0, dword ptr [rax+30h]
    vsubss  xmm1, xmm0, dword ptr [rsp+58h+vectorValue]
    vmovss  dword ptr [rax+5E88h], xmm1
    vmovss  xmm2, dword ptr [rax+34h]
    vsubss  xmm0, xmm2, dword ptr [rsp+58h+vectorValue+4]
    vmovss  dword ptr [rax+5E8Ch], xmm0
    vmovss  xmm1, dword ptr [rax+38h]
    vsubss  xmm2, xmm1, dword ptr [rsp+58h+vectorValue+8]
    vmovss  dword ptr [rax+5E90h], xmm2
  }
  if ( Scr_GetNumParam(scrContext) > 2 )
    v10 = Scr_GetInt(scrContext, 2u) != 0;
  client = PlayerEntity->client;
  if ( v10 )
    client->damage_blood += v5;
  else
    client->damage_kick += v5;
}

/*
==============
GScr_OpenFile
==============
*/
void GScr_OpenFile(scrContext_t *scrContext)
{
  const char *String; 
  const char *v3; 
  fileHandle_t *openScriptIOFileHandles; 
  __int64 v5; 
  const char *v6; 
  int v7; 
  __int64 v8; 
  char v9; 
  const char *v10; 
  __int64 v11; 
  unsigned __int64 v12; 
  char *v13; 
  __int64 handle; 
  int v15; 
  __int64 v16; 
  char v17; 
  fileHandle_t *v18; 
  const char *v19; 
  fileHandle_t *v20; 
  char v21; 
  const char *v22; 
  fileHandle_t f; 

  if ( Scr_GetNumParam(scrContext) > 1 )
  {
    String = Scr_GetString(scrContext, 0);
    v3 = Scr_GetString(scrContext, 1u);
    openScriptIOFileHandles = level.openScriptIOFileHandles;
    v5 = 0i64;
    v6 = v3;
    v7 = 0;
    while ( openScriptIOFileHandles->handle.handle != -1 )
    {
      ++v7;
      if ( (__int64)++openScriptIOFileHandles >= (__int64)level.openScriptIOFileBuffers )
        goto LABEL_7;
    }
    if ( (level_locals_t *)((char *)&level + 8 * v7) == (level_locals_t *)-74864i64 )
    {
LABEL_7:
      Com_Printf(23, "OpenFile failed.  %i files already open\n", 1i64);
LABEL_25:
      v15 = -1;
      goto LABEL_26;
    }
    v8 = 0i64;
    do
    {
      v9 = v6[v8++];
      if ( v9 != aRead_1[v8 - 1] )
      {
        v16 = 0i64;
        while ( 1 )
        {
          v17 = v6[v16++];
          if ( v17 != aWrite_0[v16 - 1] )
            break;
          if ( v16 == 6 )
          {
            v18 = (fileHandle_t *)j_va("%s/%s", "scriptdata", String);
            v20 = FS_FOpenTextFileWrite(v18, v19);
            level.openScriptIOFileHandles[v7].handle.handle = (__int64)v20;
            if ( v20 == (fileHandle_t *)-1i64 )
              v7 = -1;
            v15 = v7;
            goto LABEL_26;
          }
        }
        do
        {
          v21 = v6[v5++];
          if ( v21 != aAppend[v5 - 1] )
          {
            Com_Printf(23, "Valid openfile modes are 'write', 'read', and 'append'\n", "write");
            goto LABEL_25;
          }
        }
        while ( v5 != 7 );
        v22 = j_va("%s/%s", "scriptdata", String);
        if ( FS_FOpenFileByMode(v22, &level.openScriptIOFileHandles[v7], FS_APPEND) < 0 )
          v7 = -1;
        v15 = v7;
        goto LABEL_26;
      }
    }
    while ( v8 != 5 );
    v10 = j_va("%s/%s", "scriptdata", String);
    v11 = FS_FOpenFileByMode(v10, &f, FS_READ);
    v12 = v11;
    if ( v11 < 0 )
      goto LABEL_25;
    v13 = (char *)Mem_Virtual_Alloc(v11 + 1, "GScr_OpenFile", TRACK_MISC);
    handle = f.handle.handle;
    level.openScriptIOFileBuffers[v7] = v13;
    FS_Read(v13, v12, (fileHandle_t)handle);
    FS_FCloseFile(f);
    level.openScriptIOFileBuffers[v7][v12] = 0;
    Com_BeginParseSession(String);
    Com_SetCSV(1);
    v15 = v7;
    level.currentScriptIOLineMark[v7].lines = 0;
LABEL_26:
    Scr_AddInt(scrContext, v15);
  }
}

/*
==============
GScr_CloseFile
==============
*/
void GScr_CloseFile(scrContext_t *scrContext)
{
  unsigned int Int; 
  fileHandle_t *v3; 
  void **v4; 
  void *v5; 
  int v6; 

  if ( Scr_GetNumParam(scrContext) )
  {
    Int = Scr_GetInt(scrContext, 0);
    if ( Int > 1 )
    {
      Com_Printf(23, "CloseFile failed, invalid file number %i\n", Int);
      Scr_AddInt(scrContext, -1);
      return;
    }
    v3 = &level.openScriptIOFileHandles[Int];
    v4 = (void **)&level.openScriptIOFileBuffers[Int];
    v5 = *v4;
    if ( v3->handle.handle == -1 )
    {
      if ( !v5 )
      {
        Com_Printf(23, "CloseFile failed, file number %i was not open\n", Int);
        v6 = -1;
        goto LABEL_11;
      }
      Com_EndParseSession();
      Mem_Virtual_Free(*v4);
      *v4 = NULL;
    }
    else
    {
      if ( v5 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 18995, ASSERT_TYPE_ASSERT, "(level.openScriptIOFileBuffers[filenum] == nullptr)", (const char *)&queryFormat, "level.openScriptIOFileBuffers[filenum] == nullptr") )
          __debugbreak();
      }
      FS_FCloseFile((fileHandle_t)v3->handle.handle);
      v3->handle.handle = -1i64;
    }
    v6 = 1;
LABEL_11:
    Scr_AddInt(scrContext, v6);
  }
}

/*
==============
GScr_FPrintln
==============
*/
void GScr_FPrintln(scrContext_t *scrContext)
{
  Scr_FPrint_internal(scrContext, 0);
}

/*
==============
GScr_FPrintFields
==============
*/
void GScr_FPrintFields(scrContext_t *scrContext)
{
  Scr_FPrint_internal(scrContext, 1);
}

/*
==============
GScr_FReadLn
==============
*/
void GScr_FReadLn(scrContext_t *scrContext)
{
  unsigned int Int; 
  com_parse_mark_t *v3; 
  int ArgCountOnLine; 
  char v5; 
  char *text; 

  if ( !Scr_GetNumParam(scrContext) )
  {
    Com_Printf(23, "freadln requires a parameter - the file to read from\n");
LABEL_11:
    ArgCountOnLine = -1;
    goto LABEL_12;
  }
  Int = Scr_GetInt(scrContext, 0);
  if ( Int > 1 )
  {
    Com_Printf(23, "freadln failed, invalid file number %i\n", Int);
    goto LABEL_11;
  }
  if ( !level.openScriptIOFileBuffers[Int] )
  {
    Com_Printf(23, "freadln failed, file number %i was not open for reading\n", Int);
    goto LABEL_11;
  }
  text = level.openScriptIOFileBuffers[Int];
  v3 = &level.currentScriptIOLineMark[Int];
  if ( v3->lines )
  {
    Com_ParseReturnToMark((const char **)&text, v3);
    Com_SkipRestOfLine((const char **)&text);
    Com_ParseSetMark((const char **)&text, v3);
    v5 = *Com_Parse((const char **)&text);
    Com_ParseReturnToMark((const char **)&text, v3);
    if ( !v5 )
      goto LABEL_11;
    ArgCountOnLine = Com_GetArgCountOnLine((const char **)&text);
  }
  else
  {
    Com_ParseSetMark((const char **)&text, v3);
    ArgCountOnLine = Com_GetArgCountOnLine((const char **)&text);
  }
LABEL_12:
  Scr_AddInt(scrContext, ArgCountOnLine);
}

/*
==============
GScr_FGetArg
==============
*/
void GScr_FGetArg(scrContext_t *scrContext)
{
  const char *v2; 
  __int64 Int; 
  int v4; 
  int v5; 
  const char *v6; 
  com_parse_mark_t *v7; 
  unsigned int v8; 
  char *text; 

  if ( Scr_GetNumParam(scrContext) > 1 )
  {
    Int = Scr_GetInt(scrContext, 0);
    v4 = Scr_GetInt(scrContext, 1u);
    v5 = v4;
    if ( (unsigned int)Int > 1 )
    {
      v6 = "freadline failed, invalid file number %i\n";
    }
    else
    {
      if ( v4 < 0 )
      {
        Com_Printf(23, "freadline failed, invalid argument number %i\n", (unsigned int)v4);
        goto LABEL_15;
      }
      if ( level.openScriptIOFileBuffers[Int] )
      {
        text = level.openScriptIOFileBuffers[Int];
        v7 = &level.currentScriptIOLineMark[Int];
        v2 = NULL;
        Com_ParseReturnToMark((const char **)&text, v7);
        v8 = 0;
        if ( v5 < 0 )
          goto LABEL_16;
        while ( 1 )
        {
          v2 = Com_ParseOnLine((const char **)&text);
          if ( !*v2 )
            break;
          if ( (int)++v8 > v5 )
            goto LABEL_16;
        }
        Com_Printf(23, "freadline failed, there aren't %i arguments on this line, there are only %i arguments\n", (unsigned int)(v5 + 1), v8);
LABEL_15:
        v2 = (char *)&queryFormat.fmt + 3;
        goto LABEL_16;
      }
      v6 = "freadline failed, file number %i was not open for reading\n";
    }
    Com_Printf(23, v6, (unsigned int)Int);
    goto LABEL_15;
  }
  Com_Printf(23, "freadline requires at least 2 parameters (file, string)\n");
  v2 = (char *)&queryFormat.fmt + 3;
LABEL_16:
  Scr_AddString(scrContext, v2);
}

/*
==============
GScr_SetMiniMap
==============
*/
void GScr_SetMiniMap(scrContext_t *scrContext)
{
  const char *v10; 
  unsigned int NumParam; 
  const char *String; 
  int Int; 
  bool v20; 
  char v21; 
  const char *v40; 
  __int64 v50; 
  double v51; 
  __int64 v52; 
  double v53; 
  __int64 v54; 
  float c; 
  float s; 
  char buffer[32]; 
  char v58; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-28h], xmm6
    vmovaps xmmword ptr [rax-38h], xmm7
    vmovaps xmmword ptr [rax-48h], xmm8
    vmovaps xmmword ptr [rax-58h], xmm9
    vmovaps xmmword ptr [rax-68h], xmm10
    vmovaps xmmword ptr [rax-78h], xmm11
  }
  v10 = NULL;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam < 6 )
    Scr_Error(COM_ERR_4517, scrContext, "Expecting 6 arguments");
  String = Scr_GetString(scrContext, 0);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm { vmovaps xmm8, xmm0 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
  __asm { vmovaps xmm9, xmm0 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
  __asm { vmovaps xmm10, xmm0 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 4u);
  __asm { vmovaps xmm11, xmm0 }
  Int = Scr_GetInt(scrContext, 5u);
  if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_FREEFALL_RAISE|WEAPON_FIRING) )
  {
    if ( NumParam < 7 )
      v10 = String;
    else
      v10 = Scr_GetString(scrContext, 6u);
  }
  if ( Int < 1 )
    Scr_Error(COM_ERR_6130, scrContext, "numTiles should be >= 1");
  __asm
  {
    vsubss  xmm6, xmm10, xmm8
    vsubss  xmm7, xmm11, xmm9
  }
  v20 = Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_STILL_LAND|0x80);
  v21 = 0;
  if ( v20 )
  {
    __asm
    {
      vmulss  xmm1, xmm6, dword ptr cs:?level@@3Ulevel_locals_t@@A.compassNorth+4; level_locals_t level
      vmulss  xmm0, xmm7, dword ptr cs:?level@@3Ulevel_locals_t@@A.compassNorth; level_locals_t level
      vsubss  xmm4, xmm1, xmm0
      vmulss  xmm1, xmm6, dword ptr cs:?level@@3Ulevel_locals_t@@A.compassNorth; level_locals_t level
      vmulss  xmm0, xmm7, dword ptr cs:?level@@3Ulevel_locals_t@@A.compassNorth+4; level_locals_t level
    }
  }
  else
  {
    SV_GetConfigstring(9u, buffer, 32);
    *(double *)&_XMM0 = atof(buffer);
    __asm
    {
      vcvtsd2ss xmm1, xmm0, xmm0
      vmulss  xmm0, xmm1, cs:__real@3c8efa35; radians
    }
    FastSinCos(*(const float *)&_XMM0, &s, &c);
    __asm
    {
      vmulss  xmm1, xmm6, [rsp+0E8h+s]
      vmulss  xmm0, xmm7, [rsp+0E8h+c]
      vsubss  xmm4, xmm1, xmm0
      vmulss  xmm1, xmm6, [rsp+0E8h+c]
      vmulss  xmm0, xmm7, [rsp+0E8h+s]
    }
  }
  __asm
  {
    vxorps  xmm2, xmm1, cs:__xmm@80000000800000008000000080000000
    vsubss  xmm5, xmm2, xmm0
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm4, xmm0
    vmovss  dword ptr cs:?level@@3Ulevel_locals_t@@A.compassMapWorldSize+4, xmm5; level_locals_t level
    vmovss  dword ptr cs:?level@@3Ulevel_locals_t@@A.compassMapWorldSize, xmm4; level_locals_t level
  }
  if ( v21 )
    goto LABEL_14;
  __asm { vcomiss xmm5, xmm0 }
  if ( v21 )
LABEL_14:
    Scr_Error(COM_ERR_4518, scrContext, "lower-right X and Y coordinates must be both south and east of upper-left X and Y coordinates in terms of the northyaw");
  __asm
  {
    vmovss  dword ptr cs:?level@@3Ulevel_locals_t@@A.compassMapUpperLeft, xmm8; level_locals_t level
    vmovss  dword ptr cs:?level@@3Ulevel_locals_t@@A.compassMapUpperLeft+4, xmm9; level_locals_t level
    vcvtss2sd xmm0, xmm11, xmm11
    vcvtss2sd xmm1, xmm10, xmm10
    vcvtss2sd xmm3, xmm9, xmm9
    vcvtss2sd xmm2, xmm8, xmm8
  }
  if ( v10 )
  {
    __asm
    {
      vmovsd  [rsp+0E8h+var_B8], xmm0
      vmovsd  [rsp+0E8h+var_C0], xmm1
      vmovsd  [rsp+0E8h+var_C8], xmm3
      vmovaps xmm3, xmm2
      vmovq   r9, xmm3
    }
    v40 = j_va("\"%s\" \"%s\" %f %f %f %f %d", String, v10, _R9, v50, v52, v54, Int);
  }
  else
  {
    __asm
    {
      vmovsd  [rsp+0E8h+var_C0], xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+0E8h+var_C8], xmm1
    }
    v40 = j_va("\"%s\" %f %f %f %f %d", String, *(double *)&_XMM2, *(double *)&_XMM3, v51, v53, Int);
  }
  SV_SetConfigstring(0xAu, v40);
  _R11 = &v58;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
  }
}

/*
==============
GScr_SetMiniMapCPRaidMaze
==============
*/
void GScr_SetMiniMapCPRaidMaze(scrContext_t *scrContext)
{
  const char *String; 
  const char *v16; 
  __int64 v20; 
  __int64 v21; 

  __asm
  {
    vmovaps [rsp+68h+var_18], xmm6
    vmovaps [rsp+68h+var_28], xmm7
    vmovaps [rsp+68h+var_38], xmm8
  }
  if ( Scr_GetNumParam(scrContext) < 5 )
    Scr_Error(COM_ERR_6561, scrContext, "Expecting 5 arguments");
  String = Scr_GetString(scrContext, 0);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm { vmovaps xmm8, xmm0 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
  __asm { vmovaps xmm7, xmm0 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
  __asm { vmovaps xmm6, xmm0 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 4u);
  __asm
  {
    vcvtss2sd xmm1, xmm0, xmm0
    vcvtss2sd xmm3, xmm7, xmm7
    vcvtss2sd xmm2, xmm8, xmm8
    vcvtss2sd xmm4, xmm6, xmm6
    vmovsd  [rsp+68h+var_40], xmm1
    vmovq   r9, xmm3
    vmovq   r8, xmm2
    vmovsd  [rsp+68h+var_48], xmm4
  }
  v16 = j_va("\"%s\" %f %f %f %f", String, _R8, _R9, v20, v21);
  __asm
  {
    vmovaps xmm6, [rsp+68h+var_18]
    vmovaps xmm7, [rsp+68h+var_28]
    vmovaps xmm8, [rsp+68h+var_38]
  }
  SV_SetConfigstring(0xFu, v16);
}

/*
==============
GScr_SetThermalBodyMaterial
==============
*/
void GScr_SetThermalBodyMaterial(scrContext_t *scrContext)
{
  const char *String; 

  String = Scr_GetString(scrContext, 0);
  SV_SetConfigstring(0xBu, String);
}

/*
==============
GScr_SetGlareGrimeMaterial
==============
*/
void GScr_SetGlareGrimeMaterial(scrContext_t *scrContext)
{
  Scr_Error(COM_ERR_4519, scrContext, "SetGlareGrimeMaterial is gen4 only (use is_gen4()).");
}

/*
==============
GScr_SortByDistance
==============
*/
void GScr_SortByDistance(scrContext_t *scrContext)
{
  unsigned int *m_ptr; 
  EntityOrigin *v3; 
  unsigned int ArrayObject; 
  unsigned int ArraySize; 
  __int64 v6; 
  const char *v7; 
  const char *NameForType; 
  const char *v9; 
  unsigned int v10; 
  unsigned int *p_obj; 
  vec3_t *p_origin; 
  const char *v13; 
  __int64 v14; 
  unsigned int *v15; 
  Mem_LargeLocal v16; 
  Mem_LargeLocal v17; 
  VariableType failureType; 
  unsigned int failureIndex; 

  Mem_LargeLocal::Mem_LargeLocal(&v17, 0x2000ui64, "scr_objectIdArray_t objects");
  m_ptr = (unsigned int *)v17.m_ptr;
  Mem_LargeLocal::Mem_LargeLocal(&v16, 0x8000ui64, "entityOriginArray_t entityOriginArray");
  v3 = (EntityOrigin *)v16.m_ptr;
  ArrayObject = BGScr_Main_GetArrayObject(scrContext, 0);
  ArraySize = GetArraySize(scrContext, ArrayObject);
  v6 = ArraySize;
  if ( ArraySize > 0x800 )
  {
    v7 = j_va("array is too large (%d > %d), need to increase sortable array size", ArraySize, 2048i64);
    Scr_ParamError(COM_ERR_4520, scrContext, 0, v7);
  }
  if ( !Scr_GetObjectArray(scrContext, ArrayObject, 0x800u, m_ptr, &failureIndex, &failureType) )
  {
    NameForType = Scr_GetNameForType(failureType);
    v9 = j_va("element %i of array: type %s is not an object", failureIndex, NameForType);
    Scr_ParamError(COM_ERR_4521, scrContext, 0, v9);
  }
  Scr_GetVector(scrContext, 1u, &g_entitySortOrigin);
  AddRefToObject(scrContext, ArrayObject);
  Scr_ClearOutParams(scrContext);
  v10 = 0;
  if ( (_DWORD)v6 )
  {
    p_obj = &v3->obj;
    p_origin = &v3->origin;
    do
    {
      if ( !Scr_GetObjectOrigin(scrContext, *m_ptr, p_origin) )
      {
        RemoveRefToObject(scrContext, ArrayObject);
        v13 = j_va("element %i of array: object's origin property is not a vector", v10);
        Scr_ParamError(COM_ERR_4522, scrContext, 0, v13);
      }
      *p_obj = *m_ptr;
      ++v10;
      p_origin = (vec3_t *)((char *)p_origin + 16);
      ++m_ptr;
      p_obj += 4;
    }
    while ( v10 < (unsigned int)v6 );
  }
  v14 = v6;
  std::_Sort_unchecked<EntityOrigin *,bool (*)(EntityOrigin const &,EntityOrigin const &)>(v3, &v3[v6], v6, CompareScriptObjectDistanceIncreasing);
  Scr_MakeArray(scrContext);
  if ( (_DWORD)v6 )
  {
    v15 = &v3->obj;
    do
    {
      Scr_AddObject(scrContext, *v15);
      Scr_AddArray(scrContext);
      v15 += 4;
      --v14;
    }
    while ( v14 );
  }
  RemoveRefToObject(scrContext, ArrayObject);
  Mem_LargeLocal::~Mem_LargeLocal(&v16);
  Mem_LargeLocal::~Mem_LargeLocal(&v17);
}

/*
==============
GScr_SortByDistanceCullByRadius
==============
*/
void GScr_SortByDistanceCullByRadius(scrContext_t *scrContext)
{
  unsigned int *m_ptr; 
  EntityOrigin *v6; 
  unsigned int ArrayObject; 
  unsigned int ArraySize; 
  unsigned int v9; 
  const char *v10; 
  const char *NameForType; 
  const char *v12; 
  unsigned int v14; 
  unsigned int i; 
  int ObjectOrigin; 
  char v17; 
  bool v18; 
  const char *v19; 
  __int64 v31; 
  unsigned int *p_obj; 
  VariableType failureType[4]; 
  unsigned int failureIndex; 
  __int64 v36; 
  Mem_LargeLocal v37; 
  Mem_LargeLocal buffer; 
  void *retaddr; 

  _RAX = &retaddr;
  v36 = -2i64;
  __asm { vmovaps xmmword ptr [rax-38h], xmm6 }
  Mem_LargeLocal::Mem_LargeLocal(&buffer, 0x2000ui64, "scr_objectIdArray_t objects");
  m_ptr = (unsigned int *)buffer.m_ptr;
  Mem_LargeLocal::Mem_LargeLocal(&v37, 0x8000ui64, "entityOriginArray_t entityOriginArray");
  v6 = (EntityOrigin *)v37.m_ptr;
  ArrayObject = BGScr_Main_GetArrayObject(scrContext, 0);
  ArraySize = GetArraySize(scrContext, ArrayObject);
  v9 = ArraySize;
  if ( ArraySize > 0x800 )
  {
    v10 = j_va("array is too large (%d > %d), need to increase sortable array size", ArraySize, 2048i64);
    Scr_ParamError(COM_ERR_6306, scrContext, 0, v10);
  }
  if ( !Scr_GetObjectArray(scrContext, ArrayObject, 0x800u, m_ptr, &failureIndex, failureType) )
  {
    NameForType = Scr_GetNameForType(failureType[0]);
    v12 = j_va("element %i of array: type %s is not an object", failureIndex, NameForType);
    Scr_ParamError(COM_ERR_6307, scrContext, 0, v12);
  }
  Scr_GetVector(scrContext, 1u, &g_entitySortOrigin);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
  __asm { vmulss  xmm6, xmm0, xmm0 }
  AddRefToObject(scrContext, ArrayObject);
  Scr_ClearOutParams(scrContext);
  v14 = 0;
  for ( i = 0; i < v9; ++m_ptr )
  {
    ObjectOrigin = Scr_GetObjectOrigin(scrContext, *m_ptr, &v6[v14].origin);
    v17 = 0;
    v18 = ObjectOrigin == 0;
    if ( !ObjectOrigin )
    {
      RemoveRefToObject(scrContext, ArrayObject);
      v19 = j_va("element %i of array: object's origin property is not a vector", i);
      Scr_ParamError(COM_ERR_6308, scrContext, 0, v19);
    }
    __asm
    {
      vmovss  xmm0, dword ptr cs:g_entitySortOrigin
      vsubss  xmm3, xmm0, dword ptr [rbp+0]
      vmovss  xmm1, dword ptr cs:g_entitySortOrigin+4
      vsubss  xmm2, xmm1, dword ptr [rbp+4]
      vmovss  xmm0, dword ptr cs:g_entitySortOrigin+8
      vsubss  xmm4, xmm0, dword ptr [rbp+8]
      vmulss  xmm2, xmm2, xmm2
      vmulss  xmm1, xmm3, xmm3
      vaddss  xmm3, xmm2, xmm1
      vmulss  xmm0, xmm4, xmm4
      vaddss  xmm2, xmm3, xmm0
      vcomiss xmm2, xmm6
    }
    if ( v17 | v18 )
      v6[v14++].obj = *m_ptr;
    ++i;
  }
  v31 = v14;
  std::_Sort_unchecked<EntityOrigin *,bool (*)(EntityOrigin const &,EntityOrigin const &)>(v6, &v6[v14], v14, CompareScriptObjectDistanceIncreasing);
  Scr_MakeArray(scrContext);
  if ( v14 )
  {
    p_obj = &v6->obj;
    do
    {
      Scr_AddObject(scrContext, *p_obj);
      Scr_AddArray(scrContext);
      p_obj += 4;
      --v31;
    }
    while ( v31 );
  }
  RemoveRefToObject(scrContext, ArrayObject);
  Mem_LargeLocal::~Mem_LargeLocal(&v37);
  Mem_LargeLocal::~Mem_LargeLocal(&buffer);
  __asm { vmovaps xmm6, [rsp+0A8h+var_38] }
}

/*
==============
GScr_GetLightIntensity
==============
*/
void GScr_GetLightIntensity(scrContext_t *scrContext, scr_entref_t entref)
{
  _RAX = GScr_SetupLightEntity(scrContext, entref);
  __asm
  {
    vmovss  xmm0, dword ptr [rax+60h]
    vmulss  xmm1, xmm0, cs:__real@3b04d490; value
  }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
GScr_SetLightIntensity
==============
*/
void GScr_SetLightIntensity(scrContext_t *scrContext, scr_entref_t entref)
{
  char v7; 

  __asm { vmovaps [rsp+38h+var_18], xmm6 }
  _RDI = GScr_SetupLightEntity(scrContext, entref);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm
  {
    vcomiss xmm0, cs:__real@ba83126f
    vmovaps xmm6, xmm0
  }
  if ( v7 )
    Scr_ParamError(COM_ERR_4524, scrContext, 0, "intensity must be >= 0");
  __asm
  {
    vmulss  xmm1, xmm6, cs:__real@43f6b0cf
    vmovaps xmm6, [rsp+38h+var_18]
    vxorps  xmm0, xmm0, xmm0
    vmaxss  xmm1, xmm1, xmm0
    vmovss  dword ptr [rdi+60h], xmm1
  }
}

/*
==============
GScr_GetLightUVIntensity
==============
*/
void GScr_GetLightUVIntensity(scrContext_t *scrContext, scr_entref_t entref)
{
  _RAX = GScr_SetupLightEntity(scrContext, entref);
  __asm
  {
    vmovss  xmm0, dword ptr [rax+64h]
    vmulss  xmm1, xmm0, cs:__real@3b04d490; value
  }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
GScr_SetLightUVIntensity
==============
*/
void GScr_SetLightUVIntensity(scrContext_t *scrContext, scr_entref_t entref)
{
  char v7; 

  __asm { vmovaps [rsp+38h+var_18], xmm6 }
  _RDI = GScr_SetupLightEntity(scrContext, entref);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm
  {
    vcomiss xmm0, cs:__real@ba83126f
    vmovaps xmm6, xmm0
  }
  if ( v7 )
    Scr_ParamError(COM_ERR_4525, scrContext, 0, "intensity must be >= 0");
  __asm
  {
    vmulss  xmm1, xmm6, cs:__real@43f6b0cf
    vmovaps xmm6, [rsp+38h+var_18]
    vxorps  xmm0, xmm0, xmm0
    vmaxss  xmm1, xmm1, xmm0
    vmovss  dword ptr [rdi+64h], xmm1
  }
}

/*
==============
GScr_GetLightColor
==============
*/
void GScr_GetLightColor(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *v3; 
  char v4; 
  char v5; 
  float value[4]; 
  LerpEntityStatePrimaryLightUnpacked out; 

  v3 = GScr_SetupLightEntity(scrContext, entref);
  LerpEntityStatePrimaryLightUnpack((const LerpEntityStatePrimaryLightPacked *)&v3->s.lerp.u, &out);
  __asm
  {
    vmovss  xmm0, dword ptr [rsp+68h+out.colorLinearSrgb]; X
    vcomiss xmm0, cs:__real@3b4d2e1c
  }
  if ( v4 | v5 )
  {
    __asm { vmulss  xmm0, xmm0, cs:__real@414eb852 }
  }
  else
  {
    __asm { vmovss  xmm1, cs:__real@3ed55555; Y }
    *(float *)&_XMM0 = powf_0(*(float *)&_XMM0, *(float *)&_XMM1);
    __asm
    {
      vmulss  xmm1, xmm0, cs:__real@3f870a3d
      vsubss  xmm0, xmm1, cs:__real@3d6147ae
    }
  }
  __asm
  {
    vmovss  [rsp+68h+value], xmm0
    vmovss  xmm0, dword ptr [rsp+68h+out.colorLinearSrgb+4]; X
    vcomiss xmm0, cs:__real@3b4d2e1c
  }
  if ( v4 | v5 )
  {
    __asm { vmulss  xmm1, xmm0, cs:__real@414eb852 }
  }
  else
  {
    __asm { vmovss  xmm1, cs:__real@3ed55555; Y }
    *(float *)&_XMM0 = powf_0(*(float *)&_XMM0, *(float *)&_XMM1);
    __asm
    {
      vmulss  xmm1, xmm0, cs:__real@3f870a3d
      vsubss  xmm1, xmm1, cs:__real@3d6147ae
    }
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rsp+68h+out.colorLinearSrgb+8]; X
    vcomiss xmm0, cs:__real@3b4d2e1c
    vmovss  [rsp+68h+var_44], xmm1
  }
  if ( v4 | v5 )
  {
    __asm { vmulss  xmm1, xmm0, cs:__real@414eb852 }
  }
  else
  {
    __asm { vmovss  xmm1, cs:__real@3ed55555; Y }
    *(float *)&_XMM0 = powf_0(*(float *)&_XMM0, *(float *)&_XMM1);
    __asm
    {
      vmulss  xmm1, xmm0, cs:__real@3f870a3d
      vsubss  xmm1, xmm1, cs:__real@3d6147ae
    }
  }
  __asm { vmovss  [rsp+68h+var_40], xmm1 }
  Scr_AddVector(scrContext, value);
}

/*
==============
GScr_SetLightColor
==============
*/
void GScr_SetLightColor(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *v5; 
  char v6; 
  char v7; 
  vec3_t vectorValue; 
  LerpEntityStatePrimaryLightUnpacked out; 

  __asm
  {
    vmovaps [rsp+88h+var_18], xmm6
    vmovaps [rsp+88h+var_28], xmm7
  }
  v5 = GScr_SetupLightEntity(scrContext, entref);
  Scr_GetVector(scrContext, 0, &vectorValue);
  __asm
  {
    vmovss  xmm0, dword ptr [rsp+88h+vectorValue]
    vcomiss xmm0, cs:__real@3d20e411
  }
  if ( v6 | v7 )
  {
    __asm { vmulss  xmm7, xmm0, cs:__real@3d9e8391 }
  }
  else
  {
    __asm
    {
      vmulss  xmm0, xmm0, cs:__real@3f72a76f
      vaddss  xmm0, xmm0, cs:__real@3d55891a; X
      vmovss  xmm1, cs:__real@4019999a; Y
    }
    *(float *)&_XMM0 = powf_0(*(float *)&_XMM0, *(float *)&_XMM1);
    __asm { vmovaps xmm7, xmm0 }
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rsp+88h+vectorValue+4]
    vcomiss xmm0, cs:__real@3d20e411
    vmovss  dword ptr [rsp+88h+vectorValue], xmm7
  }
  if ( v6 | v7 )
  {
    __asm { vmulss  xmm6, xmm0, cs:__real@3d9e8391 }
  }
  else
  {
    __asm
    {
      vmulss  xmm0, xmm0, cs:__real@3f72a76f
      vaddss  xmm0, xmm0, cs:__real@3d55891a; X
      vmovss  xmm1, cs:__real@4019999a; Y
    }
    *(float *)&_XMM0 = powf_0(*(float *)&_XMM0, *(float *)&_XMM1);
    __asm { vmovaps xmm6, xmm0 }
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rsp+88h+vectorValue+8]
    vcomiss xmm0, cs:__real@3d20e411
    vmovss  dword ptr [rsp+88h+vectorValue+4], xmm6
  }
  if ( v6 | v7 )
  {
    __asm { vmulss  xmm4, xmm0, cs:__real@3d9e8391 }
  }
  else
  {
    __asm
    {
      vmulss  xmm0, xmm0, cs:__real@3f72a76f
      vaddss  xmm0, xmm0, cs:__real@3d55891a; X
      vmovss  xmm1, cs:__real@4019999a; Y
    }
    *(float *)&_XMM0 = powf_0(*(float *)&_XMM0, *(float *)&_XMM1);
    __asm { vmovaps xmm4, xmm0 }
  }
  __asm
  {
    vmulss  xmm2, xmm7, dword ptr cs:?luminanceCoefficientsBT709@@3Tvec3_t@@B; vec3_t const luminanceCoefficientsBT709
    vmulss  xmm1, xmm6, dword ptr cs:?luminanceCoefficientsBT709@@3Tvec3_t@@B+4; vec3_t const luminanceCoefficientsBT709
    vaddss  xmm3, xmm2, xmm1
    vmulss  xmm2, xmm4, dword ptr cs:?luminanceCoefficientsBT709@@3Tvec3_t@@B+8; vec3_t const luminanceCoefficientsBT709
    vaddss  xmm0, xmm3, xmm2
    vxorps  xmm1, xmm1, xmm1
    vcomiss xmm0, xmm1
    vmovss  dword ptr [rsp+88h+vectorValue+8], xmm4
  }
  if ( !(v6 | v7) )
  {
    __asm
    {
      vmovss  xmm1, cs:__real@3f800000
      vdivss  xmm2, xmm1, xmm0
      vmulss  xmm0, xmm2, xmm7
      vmovss  dword ptr [rsp+88h+vectorValue], xmm0
      vmulss  xmm0, xmm2, xmm4
      vmulss  xmm1, xmm2, xmm6
      vmovss  dword ptr [rsp+88h+vectorValue+8], xmm0
      vmovss  dword ptr [rsp+88h+vectorValue+4], xmm1
    }
  }
  LerpEntityStatePrimaryLightUnpack((const LerpEntityStatePrimaryLightPacked *)&v5->s.lerp.u, &out);
  __asm
  {
    vmovss  xmm0, dword ptr [rsp+88h+vectorValue]
    vmovss  xmm1, dword ptr [rsp+88h+vectorValue+4]
    vmovss  dword ptr [rsp+88h+out.colorLinearSrgb], xmm0
    vmovss  xmm0, dword ptr [rsp+88h+vectorValue+8]
    vmovss  dword ptr [rsp+88h+out.colorLinearSrgb+8], xmm0
    vmovss  dword ptr [rsp+88h+out.colorLinearSrgb+4], xmm1
  }
  LerpEntityStatePrimaryLightPack(&out, (LerpEntityStatePrimaryLightPacked *)&v5->s.lerp.u);
  __asm
  {
    vmovaps xmm6, [rsp+88h+var_18]
    vmovaps xmm7, [rsp+88h+var_28]
  }
}

/*
==============
GScr_GetLightRadius
==============
*/
void GScr_GetLightRadius(scrContext_t *scrContext, scr_entref_t entref)
{
  _RAX = GScr_SetupLightEntity(scrContext, entref);
  __asm { vmovss  xmm1, dword ptr [rax+68h]; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
GScr_SetLightRadius
==============
*/
void GScr_SetLightRadius(scrContext_t *scrContext, scr_entref_t entref)
{
  signed int v5; 
  bool v7; 
  bool v8; 

  _RSI = GScr_SetupLightEntity(scrContext, entref);
  v5 = comWorld.firstScriptablePrimaryLight + _RSI->s.staticState.general.xmodel;
  if ( (v5 < (int)comWorld.firstScriptablePrimaryLight || v5 >= (int)comWorld.primaryLightCount) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_bsp_api.h", 106, ASSERT_TYPE_ASSERT, "(primaryLightIndex >= static_cast<int>( comWorld.firstScriptablePrimaryLight ) && primaryLightIndex < static_cast<int>( comWorld.primaryLightCount ))", (const char *)&queryFormat, "primaryLightIndex >= static_cast<int>( comWorld.firstScriptablePrimaryLight ) && primaryLightIndex < static_cast<int>( comWorld.primaryLightCount )") )
    __debugbreak();
  _RBX = Com_GetPrimaryLight(v5);
  v7 = _RBX == NULL;
  if ( !_RBX )
  {
    v8 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 19752, ASSERT_TYPE_ASSERT, "(refLight)", (const char *)&queryFormat, "refLight");
    v7 = !v8;
    if ( v8 )
      __debugbreak();
  }
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vucomiss xmm0, dword ptr [rbx+90h]
  }
  if ( !v7 )
    goto LABEL_11;
  __asm
  {
    vmovss  xmm0, cs:__real@3f800000
    vucomiss xmm0, dword ptr [rbx+8Ch]
  }
  if ( v7 )
  {
    Scr_Error(COM_ERR_2199, scrContext, "SetLightRadius only works for lights with maxmove or maxturn KVP specified in Radiant\n");
  }
  else
  {
LABEL_11:
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
    __asm
    {
      vmovss  xmm2, dword ptr [rbx+50h]; max
      vmovss  xmm1, cs:__real@3f8147ae; min
    }
    *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
    __asm { vmovss  dword ptr [rsi+68h], xmm0 }
  }
}

/*
==============
GScr_GetLightFovInner
==============
*/
void GScr_GetLightFovInner(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *v3; 
  LerpEntityStatePrimaryLightUnpacked out; 

  v3 = GScr_SetupLightEntity(scrContext, entref);
  LerpEntityStatePrimaryLightUnpack((const LerpEntityStatePrimaryLightPacked *)&v3->s.lerp.u, &out);
  __asm { vmovss  xmm0, [rsp+58h+out.cosHalfFovInner]; X }
  *(float *)&_XMM0 = acosf_0(*(float *)&_XMM0);
  __asm
  {
    vmulss  xmm1, xmm0, cs:__real@42652ee0
    vmulss  xmm1, xmm1, cs:__real@40000000; value
  }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
GScr_GetLightFovOuter
==============
*/
void GScr_GetLightFovOuter(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *v3; 
  LerpEntityStatePrimaryLightUnpacked out; 

  v3 = GScr_SetupLightEntity(scrContext, entref);
  LerpEntityStatePrimaryLightUnpack((const LerpEntityStatePrimaryLightPacked *)&v3->s.lerp.u, &out);
  __asm { vmovss  xmm0, [rsp+58h+out.cosHalfFovOuter]; X }
  *(float *)&_XMM0 = acosf_0(*(float *)&_XMM0);
  __asm
  {
    vmulss  xmm1, xmm0, cs:__real@42652ee0
    vmulss  xmm1, xmm1, cs:__real@40000000; value
  }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
GScr_SetLightFovRange
==============
*/
void GScr_SetLightFovRange(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *v11; 
  signed int v12; 
  bool v14; 
  bool v15; 
  char v37; 
  char v38; 
  double v46; 
  double v47; 
  LerpEntityStatePrimaryLightUnpacked out; 
  void *retaddr; 

  _R11 = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [r11-48h], xmm8
    vmovaps xmmword ptr [r11-78h], xmm11
  }
  v11 = GScr_SetupLightEntity(scrContext, entref);
  v12 = comWorld.firstScriptablePrimaryLight + v11->s.staticState.general.xmodel;
  if ( (v12 < (int)comWorld.firstScriptablePrimaryLight || v12 >= (int)comWorld.primaryLightCount) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_bsp_api.h", 106, ASSERT_TYPE_ASSERT, "(primaryLightIndex >= static_cast<int>( comWorld.firstScriptablePrimaryLight ) && primaryLightIndex < static_cast<int>( comWorld.primaryLightCount ))", (const char *)&queryFormat, "primaryLightIndex >= static_cast<int>( comWorld.firstScriptablePrimaryLight ) && primaryLightIndex < static_cast<int>( comWorld.primaryLightCount )") )
    __debugbreak();
  _RBX = Com_GetPrimaryLight(v12);
  v14 = _RBX == NULL;
  if ( !_RBX )
  {
    v15 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 19837, ASSERT_TYPE_ASSERT, "(refLight)", (const char *)&queryFormat, "refLight");
    v14 = !v15;
    if ( v15 )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm8, cs:__real@3f800000
    vxorps  xmm11, xmm11, xmm11
    vucomiss xmm11, dword ptr [rbx+90h]
  }
  if ( !v14 )
    goto LABEL_11;
  __asm { vucomiss xmm8, dword ptr [rbx+8Ch] }
  if ( v14 )
  {
    Scr_Error(COM_ERR_2201, scrContext, "SetLightFovRange only works for lights with maxmove or maxturn KVP specified in Radiant\n");
  }
  else
  {
LABEL_11:
    __asm
    {
      vmovaps [rsp+0E8h+var_28], xmm6
      vmovaps [rsp+0E8h+var_38], xmm7
      vmovaps [rsp+0E8h+var_58], xmm9
    }
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
    __asm
    {
      vcomiss xmm0, cs:__real@3f7fbe77
      vmovaps xmm6, xmm0
    }
    if ( !v37 )
      __asm { vcomiss xmm0, cs:__real@42f00083 }
    Scr_ParamError(COM_ERR_2202, scrContext, 0, "outer fov must be in the range of 1 to 120");
    __asm { vmulss  xmm0, xmm6, cs:__real@3c0efa35; X }
    *(float *)&_XMM0 = cosf_0(*(float *)&_XMM0);
    __asm
    {
      vmovss  xmm3, dword ptr [rbx+6Ch]
      vmovss  xmm9, cs:__real@3a83126f
      vsubss  xmm1, xmm3, xmm9
      vcomiss xmm0, xmm1
      vmovaps xmm7, xmm0
    }
    if ( v37 )
    {
      Scr_ParamError(COM_ERR_2203, scrContext, 0, "outer fov cannot be larger than the fov when the map was compiled");
      __asm { vmovss  xmm3, dword ptr [rbx+6Ch] }
    }
    __asm
    {
      vmovaps xmm2, xmm8; max
      vmovaps xmm1, xmm3; min
      vmovaps xmm0, xmm7; val
    }
    *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
    __asm { vmovaps xmm7, xmm0 }
    if ( Scr_GetNumParam(scrContext) == 2 )
    {
      __asm { vmovaps [rsp+0E8h+var_68], xmm10 }
      *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
      __asm
      {
        vcomiss xmm0, cs:__real@ba83126f
        vmovaps xmm10, xmm0
      }
      if ( !v37 )
      {
        __asm
        {
          vaddss  xmm1, xmm6, xmm9
          vcomiss xmm0, xmm1
        }
      }
      Scr_ParamError(COM_ERR_2204, scrContext, 1u, "inner fov must be in the range of 0 to outer fov");
      __asm
      {
        vmulss  xmm0, xmm10, cs:__real@3c0efa35; X
        vaddss  xmm6, xmm7, xmm9
      }
      *(float *)&_XMM0 = cosf_0(*(float *)&_XMM0);
      __asm
      {
        vmovaps xmm2, xmm8; max
        vmovaps xmm1, xmm6; min
      }
      *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
      __asm
      {
        vmovaps xmm10, [rsp+0E8h+var_68]
        vmovaps xmm6, xmm0
      }
    }
    else
    {
      __asm
      {
        vaddss  xmm0, xmm7, xmm9
        vminss  xmm6, xmm0, dword ptr [rbx+70h]
      }
    }
    LerpEntityStatePrimaryLightUnpack((const LerpEntityStatePrimaryLightPacked *)&v11->s.lerp.u, &out);
    __asm
    {
      vcomiss xmm7, xmm11
      vmovaps xmm9, [rsp+0E8h+var_58]
    }
    if ( v37 | v38 )
      goto LABEL_25;
    __asm { vcomiss xmm7, xmm6 }
    if ( !v37 )
      goto LABEL_25;
    __asm { vcomiss xmm6, xmm8 }
    if ( !(v37 | v38) )
    {
LABEL_25:
      __asm
      {
        vcvtss2sd xmm0, xmm6, xmm6
        vmovsd  [rsp+0E8h+var_B0], xmm0
        vcvtss2sd xmm1, xmm7, xmm7
        vmovsd  [rsp+0E8h+var_B8], xmm1
      }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 19869, ASSERT_TYPE_ASSERT, "(0.0f < cosHalfFovOuter && cosHalfFovOuter < cosHalfFovInner && cosHalfFovInner <= 1.0f)", "%s\n\t%g, %g", "0.0f < cosHalfFovOuter && cosHalfFovOuter < cosHalfFovInner && cosHalfFovInner <= 1.0f", v46, v47) )
        __debugbreak();
    }
    __asm
    {
      vmovss  [rsp+0E8h+out.cosHalfFovInner], xmm6
      vmovss  [rsp+0E8h+out.cosHalfFovOuter], xmm7
    }
    LerpEntityStatePrimaryLightPack(&out, (LerpEntityStatePrimaryLightPacked *)&v11->s.lerp.u);
    __asm
    {
      vmovaps xmm7, [rsp+0E8h+var_38]
      vmovaps xmm6, [rsp+0E8h+var_28]
    }
  }
  __asm
  {
    vmovaps xmm8, [rsp+0E8h+var_48]
    vmovaps xmm11, [rsp+0E8h+var_78]
  }
}

/*
==============
GScr_IsScriptable
==============
*/
void GScr_IsScriptable(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  unsigned int ScriptableIndexForEntity; 

  Entity = GetEntity(entref);
  ScriptableIndexForEntity = ScriptableSv_GetScriptableIndexForEntity(Entity);
  Scr_AddInt(scrContext, ScriptableIndexForEntity != -1);
}

/*
==============
GScr_IsRagdoll
==============
*/
void GScr_IsRagdoll(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  trajectory_t_secure *p_pos; 

  Entity = GetEntity(entref);
  p_pos = &Entity->s.lerp.pos;
  if ( Entity == (gentity_s *)-16i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\q_shared.h", 2263, ASSERT_TYPE_ASSERT, "(trajectory)", (const char *)&queryFormat, "trajectory") )
    __debugbreak();
  Scr_AddInt(scrContext, (unsigned int)(p_pos->trType - 23) <= 5);
}

/*
==============
Scr_GetWeaponArray
==============
*/
void Scr_GetWeaponArray(scrContext_t *scrContext)
{
  EntHandle *droppedWeaponCue; 
  __int64 v3; 
  unsigned __int16 number; 
  __int64 v5; 
  unsigned int v6; 
  __int64 v7; 
  unsigned __int16 v8; 
  __int64 v9; 
  __int64 v10; 
  EntHandle *droppedEquipmentCue; 
  __int64 v12; 
  unsigned __int16 v13; 
  __int64 v14; 
  unsigned int v15; 
  __int64 v16; 
  unsigned __int16 v17; 
  __int64 v18; 
  __int64 v19; 
  __int64 v20; 
  __int64 v21; 

  Scr_MakeArray(scrContext);
  droppedWeaponCue = level.droppedWeaponCue;
  v3 = 32i64;
  do
  {
    number = droppedWeaponCue->number;
    if ( droppedWeaponCue->number )
    {
      v5 = number;
      v6 = number - 1;
      if ( v6 >= 0x800 )
      {
        LODWORD(v21) = 2048;
        LODWORD(v20) = v6;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v20, v21) )
          __debugbreak();
      }
      if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
        __debugbreak();
      v7 = v5 - 1;
      if ( g_entities[v7].r.isInUse != g_entityIsInUse[v7] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
        __debugbreak();
      if ( !g_entityIsInUse[v7] )
      {
        LODWORD(v21) = droppedWeaponCue->number - 1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 216, ASSERT_TYPE_ASSERT, "( ( !number || G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( !number || G_IsEntityInUse( number - 1 ) )", v21) )
          __debugbreak();
      }
      v8 = droppedWeaponCue->number;
      if ( droppedWeaponCue->number )
      {
        if ( (unsigned int)v8 - 1 >= 0x7FF )
        {
          LODWORD(v21) = 2047;
          LODWORD(v20) = v8 - 1;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 223, ASSERT_TYPE_ASSERT, "(unsigned)( number - 1 ) < (unsigned)( ENTITYNUM_NONE )", "number - 1 doesn't index ENTITYNUM_NONE\n\t%i not in [0, %i)", v20, v21) )
            __debugbreak();
        }
        v9 = droppedWeaponCue->number;
        if ( (unsigned int)(v9 - 1) >= 0x800 )
        {
          LODWORD(v21) = 2048;
          LODWORD(v20) = v9 - 1;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v20, v21) )
            __debugbreak();
        }
        if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
          __debugbreak();
        v10 = v9 - 1;
        if ( g_entities[v10].r.isInUse != g_entityIsInUse[v10] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
          __debugbreak();
        if ( !g_entityIsInUse[v10] )
        {
          LODWORD(v21) = droppedWeaponCue->number - 1;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 224, ASSERT_TYPE_ASSERT, "( ( G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( G_IsEntityInUse( number - 1 ) )", v21) )
            __debugbreak();
        }
        GScr_AddEntity(&g_entities[droppedWeaponCue->number - 1]);
        Scr_AddArray(scrContext);
      }
    }
    ++droppedWeaponCue;
    --v3;
  }
  while ( v3 );
  droppedEquipmentCue = level.droppedEquipmentCue;
  v12 = 8i64;
  do
  {
    v13 = droppedEquipmentCue->number;
    if ( droppedEquipmentCue->number )
    {
      v14 = v13;
      v15 = v13 - 1;
      if ( v15 >= 0x800 )
      {
        LODWORD(v21) = 2048;
        LODWORD(v20) = v15;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v20, v21) )
          __debugbreak();
      }
      if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
        __debugbreak();
      v16 = v14 - 1;
      if ( g_entities[v16].r.isInUse != g_entityIsInUse[v16] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
        __debugbreak();
      if ( !g_entityIsInUse[v16] )
      {
        LODWORD(v21) = droppedEquipmentCue->number - 1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 216, ASSERT_TYPE_ASSERT, "( ( !number || G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( !number || G_IsEntityInUse( number - 1 ) )", v21) )
          __debugbreak();
      }
      v17 = droppedEquipmentCue->number;
      if ( droppedEquipmentCue->number )
      {
        if ( (unsigned int)v17 - 1 >= 0x7FF )
        {
          LODWORD(v21) = 2047;
          LODWORD(v20) = v17 - 1;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 223, ASSERT_TYPE_ASSERT, "(unsigned)( number - 1 ) < (unsigned)( ENTITYNUM_NONE )", "number - 1 doesn't index ENTITYNUM_NONE\n\t%i not in [0, %i)", v20, v21) )
            __debugbreak();
        }
        v18 = droppedEquipmentCue->number;
        if ( (unsigned int)(v18 - 1) >= 0x800 )
        {
          LODWORD(v21) = 2048;
          LODWORD(v20) = v18 - 1;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v20, v21) )
            __debugbreak();
        }
        if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
          __debugbreak();
        v19 = v18 - 1;
        if ( g_entities[v19].r.isInUse != g_entityIsInUse[v19] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
          __debugbreak();
        if ( !g_entityIsInUse[v19] )
        {
          LODWORD(v21) = droppedEquipmentCue->number - 1;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 224, ASSERT_TYPE_ASSERT, "( ( G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( G_IsEntityInUse( number - 1 ) )", v21) )
            __debugbreak();
        }
        GScr_AddEntity(&g_entities[droppedEquipmentCue->number - 1]);
        Scr_AddArray(scrContext);
      }
    }
    ++droppedEquipmentCue;
    --v12;
  }
  while ( v12 );
}

/*
==============
Scr_GetWeaponArrayInRadius
==============
*/
void Scr_GetWeaponArrayInRadius(scrContext_t *scrContext)
{
  EntHandle *droppedWeaponCue; 
  __int64 v6; 
  unsigned __int16 number; 
  __int64 v8; 
  unsigned int v9; 
  __int64 v10; 
  unsigned __int16 v11; 
  __int64 v12; 
  __int64 v13; 
  int v14; 
  char v17; 
  __int64 v27; 
  __int64 v28; 
  EntHandle *droppedEquipmentCue; 
  __int64 v30; 
  unsigned __int16 v31; 
  __int64 v32; 
  unsigned int v33; 
  __int64 v34; 
  unsigned __int16 v35; 
  __int64 v36; 
  __int64 v37; 
  int v38; 
  __int64 v50; 
  __int64 v51; 
  __int64 v53; 
  __int64 v54; 
  vec3_t vectorValue; 

  __asm { vmovaps [rsp+98h+var_38], xmm6 }
  Scr_GetVector(scrContext, 0, &vectorValue);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm { vmulss  xmm6, xmm0, xmm0 }
  Scr_MakeArray(scrContext);
  droppedWeaponCue = level.droppedWeaponCue;
  v6 = 32i64;
  do
  {
    number = droppedWeaponCue->number;
    if ( droppedWeaponCue->number )
    {
      v8 = number;
      v9 = number - 1;
      if ( v9 >= 0x800 )
      {
        LODWORD(v54) = 2048;
        LODWORD(v53) = v9;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v53, v54) )
          __debugbreak();
      }
      if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
        __debugbreak();
      v10 = v8 - 1;
      if ( g_entities[v10].r.isInUse != g_entityIsInUse[v10] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
        __debugbreak();
      if ( !g_entityIsInUse[v10] )
      {
        LODWORD(v54) = droppedWeaponCue->number - 1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 216, ASSERT_TYPE_ASSERT, "( ( !number || G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( !number || G_IsEntityInUse( number - 1 ) )", v54) )
          __debugbreak();
      }
      v11 = droppedWeaponCue->number;
      if ( droppedWeaponCue->number )
      {
        if ( (unsigned int)v11 - 1 >= 0x7FF )
        {
          LODWORD(v54) = 2047;
          LODWORD(v53) = v11 - 1;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 223, ASSERT_TYPE_ASSERT, "(unsigned)( number - 1 ) < (unsigned)( ENTITYNUM_NONE )", "number - 1 doesn't index ENTITYNUM_NONE\n\t%i not in [0, %i)", v53, v54) )
            __debugbreak();
        }
        v12 = droppedWeaponCue->number;
        if ( (unsigned int)(v12 - 1) >= 0x800 )
        {
          LODWORD(v54) = 2048;
          LODWORD(v53) = v12 - 1;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v53, v54) )
            __debugbreak();
        }
        if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
          __debugbreak();
        v13 = v12 - 1;
        if ( g_entities[v13].r.isInUse != g_entityIsInUse[v13] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
          __debugbreak();
        if ( !g_entityIsInUse[v13] )
        {
          LODWORD(v54) = droppedWeaponCue->number - 1;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 224, ASSERT_TYPE_ASSERT, "( ( G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( G_IsEntityInUse( number - 1 ) )", v54) )
            __debugbreak();
        }
        v14 = droppedWeaponCue->number;
        __asm
        {
          vmovss  xmm0, dword ptr [rsp+98h+vectorValue]
          vmovss  xmm1, dword ptr [rsp+98h+vectorValue+4]
          vsubss  xmm3, xmm0, dword ptr [rcx+rax-480h]
          vsubss  xmm2, xmm1, dword ptr [rcx+rax-47Ch]
          vmovss  xmm0, dword ptr [rsp+98h+vectorValue+8]
          vsubss  xmm4, xmm0, dword ptr [rcx+rax-478h]
          vmulss  xmm2, xmm2, xmm2
          vmulss  xmm1, xmm3, xmm3
          vmulss  xmm0, xmm4, xmm4
          vaddss  xmm3, xmm2, xmm1
          vaddss  xmm2, xmm3, xmm0
          vcomiss xmm2, xmm6
        }
        if ( ((1456 * (unsigned __int128)droppedWeaponCue->number) >> 64 != 0) | v17 )
        {
          if ( (unsigned int)(v14 - 1) >= 0x7FF )
          {
            LODWORD(v54) = 2047;
            LODWORD(v53) = v14 - 1;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 223, ASSERT_TYPE_ASSERT, "(unsigned)( number - 1 ) < (unsigned)( ENTITYNUM_NONE )", "number - 1 doesn't index ENTITYNUM_NONE\n\t%i not in [0, %i)", v53, v54) )
              __debugbreak();
          }
          v27 = droppedWeaponCue->number;
          if ( (unsigned int)(v27 - 1) >= 0x800 )
          {
            LODWORD(v54) = 2048;
            LODWORD(v53) = v27 - 1;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v53, v54) )
              __debugbreak();
          }
          if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
            __debugbreak();
          v28 = v27 - 1;
          if ( g_entities[v28].r.isInUse != g_entityIsInUse[v28] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
            __debugbreak();
          if ( !g_entityIsInUse[v28] )
          {
            LODWORD(v54) = droppedWeaponCue->number - 1;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 224, ASSERT_TYPE_ASSERT, "( ( G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( G_IsEntityInUse( number - 1 ) )", v54) )
              __debugbreak();
          }
          GScr_AddEntity(&g_entities[droppedWeaponCue->number - 1]);
          Scr_AddArray(scrContext);
        }
      }
    }
    ++droppedWeaponCue;
    --v6;
  }
  while ( v6 );
  droppedEquipmentCue = level.droppedEquipmentCue;
  v30 = 8i64;
  do
  {
    v31 = droppedEquipmentCue->number;
    if ( droppedEquipmentCue->number )
    {
      v32 = v31;
      v33 = v31 - 1;
      if ( v33 >= 0x800 )
      {
        LODWORD(v54) = 2048;
        LODWORD(v53) = v33;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v53, v54) )
          __debugbreak();
      }
      if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
        __debugbreak();
      v34 = v32 - 1;
      if ( g_entities[v34].r.isInUse != g_entityIsInUse[v34] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
        __debugbreak();
      if ( !g_entityIsInUse[v34] )
      {
        LODWORD(v54) = droppedEquipmentCue->number - 1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 216, ASSERT_TYPE_ASSERT, "( ( !number || G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( !number || G_IsEntityInUse( number - 1 ) )", v54) )
          __debugbreak();
      }
      v35 = droppedEquipmentCue->number;
      if ( droppedEquipmentCue->number )
      {
        if ( (unsigned int)v35 - 1 >= 0x7FF )
        {
          LODWORD(v54) = 2047;
          LODWORD(v53) = v35 - 1;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 223, ASSERT_TYPE_ASSERT, "(unsigned)( number - 1 ) < (unsigned)( ENTITYNUM_NONE )", "number - 1 doesn't index ENTITYNUM_NONE\n\t%i not in [0, %i)", v53, v54) )
            __debugbreak();
        }
        v36 = droppedEquipmentCue->number;
        if ( (unsigned int)(v36 - 1) >= 0x800 )
        {
          LODWORD(v54) = 2048;
          LODWORD(v53) = v36 - 1;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v53, v54) )
            __debugbreak();
        }
        if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
          __debugbreak();
        v37 = v36 - 1;
        if ( g_entities[v37].r.isInUse != g_entityIsInUse[v37] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
          __debugbreak();
        if ( !g_entityIsInUse[v37] )
        {
          LODWORD(v54) = droppedEquipmentCue->number - 1;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 224, ASSERT_TYPE_ASSERT, "( ( G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( G_IsEntityInUse( number - 1 ) )", v54) )
            __debugbreak();
        }
        v38 = droppedEquipmentCue->number;
        __asm
        {
          vmovss  xmm0, dword ptr [rsp+98h+vectorValue]
          vmovss  xmm1, dword ptr [rsp+98h+vectorValue+4]
          vsubss  xmm3, xmm0, dword ptr [rcx+rax-480h]
          vsubss  xmm2, xmm1, dword ptr [rcx+rax-47Ch]
          vmovss  xmm0, dword ptr [rsp+98h+vectorValue+8]
          vsubss  xmm4, xmm0, dword ptr [rcx+rax-478h]
          vmulss  xmm2, xmm2, xmm2
          vmulss  xmm1, xmm3, xmm3
          vmulss  xmm0, xmm4, xmm4
          vaddss  xmm3, xmm2, xmm1
          vaddss  xmm2, xmm3, xmm0
          vcomiss xmm2, xmm6
        }
        if ( ((1456 * (unsigned __int128)droppedEquipmentCue->number) >> 64 != 0) | v17 )
        {
          if ( (unsigned int)(v38 - 1) >= 0x7FF )
          {
            LODWORD(v54) = 2047;
            LODWORD(v53) = v38 - 1;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 223, ASSERT_TYPE_ASSERT, "(unsigned)( number - 1 ) < (unsigned)( ENTITYNUM_NONE )", "number - 1 doesn't index ENTITYNUM_NONE\n\t%i not in [0, %i)", v53, v54) )
              __debugbreak();
          }
          v50 = droppedEquipmentCue->number;
          if ( (unsigned int)(v50 - 1) >= 0x800 )
          {
            LODWORD(v54) = 2048;
            LODWORD(v53) = v50 - 1;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v53, v54) )
              __debugbreak();
          }
          if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
            __debugbreak();
          v51 = v50 - 1;
          if ( g_entities[v51].r.isInUse != g_entityIsInUse[v51] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
            __debugbreak();
          if ( !g_entityIsInUse[v51] )
          {
            LODWORD(v54) = droppedEquipmentCue->number - 1;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 224, ASSERT_TYPE_ASSERT, "( ( G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( G_IsEntityInUse( number - 1 ) )", v54) )
              __debugbreak();
          }
          GScr_AddEntity(&g_entities[droppedEquipmentCue->number - 1]);
          Scr_AddArray(scrContext);
        }
      }
    }
    ++droppedEquipmentCue;
    --v30;
  }
  while ( v30 );
  __asm { vmovaps xmm6, [rsp+98h+var_38] }
}

/*
==============
GScr_CameraLinkTo
==============
*/
void GScr_CameraLinkTo(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *PlayerEntity; 
  gentity_s *Entity; 
  playerState_s *p_ps; 
  __int16 *p_number; 
  const char *String; 
  unsigned int v8; 
  const char *v9; 
  bool v10; 
  bool v11; 

  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  Entity = GScr_GetEntity(0);
  p_ps = &PlayerEntity->client->ps;
  p_number = &Entity->s.number;
  String = Scr_GetString(scrContext, 1u);
  if ( !GConfigStrings::ms_gConfigStrings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_configstrings.h", 71, ASSERT_TYPE_ASSERT, "( ms_gConfigStrings )", (const char *)&queryFormat, "ms_gConfigStrings") )
    __debugbreak();
  v8 = GConfigStrings::ms_gConfigStrings->GetClientTagIndex(GConfigStrings::ms_gConfigStrings, String);
  if ( !v8 )
  {
    v9 = j_va("Can't find/allocate ID for tag '%s'", String);
    Scr_ParamError(COM_ERR_4531, scrContext, 1u, v9);
  }
  v10 = 0;
  if ( Scr_GetNumParam(scrContext) > 2 )
    v10 = Scr_GetInt(scrContext, 2u) != 0;
  v11 = 0;
  if ( Scr_GetNumParam(scrContext) > 3 )
    v11 = Scr_GetInt(scrContext, 3u) != 0;
  GScr_RemoteEyesSet_Internal(p_ps, *p_number, v10, v11);
  p_ps->remoteEyesTagname = v8;
}

/*
==============
GScr_CameraUnlink
==============
*/
void GScr_CameraUnlink(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *PlayerEntity; 

  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  GScr_RemoteEyesClear_Internal(&PlayerEntity->client->ps);
}

/*
==============
GScrCmd_SetWaterSheeting
==============
*/
void GScrCmd_SetWaterSheeting(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  int number; 
  const char *v7; 
  const char *v8; 
  unsigned int Int; 
  const char *v12; 
  const char *v13; 
  SvClient *CommonClient; 
  int outControllingClientNum; 

  entnum = entref.entnum;
  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 20186, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( ((Entity->s.eType - 1) & 0xFFEF) != 0 )
    Scr_Error(COM_ERR_4532, scrContext, "SetWaterSheeting called on an ent that's not a player or agent.");
  number = Entity->s.number;
  outControllingClientNum = number;
  if ( !SV_IsAgent(number) || SV_GetAgentControlledByPlayerNum(outControllingClientNum, &outControllingClientNum) )
  {
    if ( outControllingClientNum < level.maxclients )
    {
      Int = Scr_GetInt(scrContext, 0);
      if ( Scr_GetNumParam(scrContext) == 2 )
      {
        *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
        __asm
        {
          vmulss  xmm1, xmm0, cs:__real@447a0000
          vcvttss2si r9d, xmm1
        }
      }
      else
      {
        _R9 = 0i64;
      }
      v12 = j_va("%c %i %i", 80i64, Int, _R9);
      v13 = v12;
      if ( outControllingClientNum == -1 )
      {
        SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v12);
      }
      else
      {
        CommonClient = SvClient::GetCommonClient(outControllingClientNum);
        CommonClient->SendServerCommand(CommonClient, SV_CMD_RELIABLE, v13);
      }
    }
    else
    {
      v8 = j_va("Invalid entity index %d before SV_Game_SendServerCommand\n", (unsigned int)outControllingClientNum);
      Scr_Error(COM_ERR_6407, scrContext, v8);
    }
  }
  else
  {
    v7 = j_va("entity %i is not a player or player-controlled agent", entnum);
    Scr_ObjectError(COM_ERR_4533, scrContext, v7);
  }
}

/*
==============
GScr_ControlsLinkTo
==============
*/
void GScr_ControlsLinkTo(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *PlayerEntity; 
  gclient_s *client; 
  gentity_s *Entity; 
  gentity_s *v6; 
  Vehicle *vehicle; 
  bool v8; 
  entityType_s eType; 

  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  client = PlayerEntity->client;
  Entity = GScr_GetEntity(0);
  v6 = Entity;
  v8 = 0;
  if ( Entity->s.eType == ET_VEHICLE )
  {
    vehicle = Entity->vehicle;
    if ( vehicle )
    {
      if ( vehicle->drivingState == VEH_DRIVE_NONE )
        v8 = 1;
    }
  }
  if ( GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&client->ps.pm_flags, ACTIVE, 0x1Cu) && !v8 )
    Scr_Error(COM_ERR_4534, scrContext, "Player's controls are already linked.");
  GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::SetFlagInternal(&client->ps.pm_flags, ACTIVE, 0x1Cu);
  client->ps.remoteControlEnt = v6->s.number;
  EntHandle::setEnt(&v6->remoteControlledOwner, PlayerEntity);
  eType = v6->s.eType;
  if ( eType == ET_MISSILE )
  {
    v6->c.missile.flags |= 0x80u;
  }
  else if ( ((eType - 12) & 0xFFFD) == 0 && Com_GameMode_SupportsFeature(WEAPON_ANIM_SCRIPTED) )
  {
    G_Vehicle_PlayerRemoteControl(v6, PlayerEntity);
  }
}

/*
==============
GScr_RemoteControlTurret
==============
*/
void GScr_RemoteControlTurret(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  gentity_s *Entity; 
  gentity_s *v7; 
  const char *v8; 
  const char *v9; 
  bool v10; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 20284, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  if ( !Com_GameMode_SupportsFeature(WEAPON_DROPPING_LADDER_CLIMB) )
    Scr_Error(COM_ERR_4535, scrContext, "Remote turret control is not supported in this game mode");
  Entity = GScr_GetEntity(0);
  v7 = Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v8 = SL_ConvertToString(Entity->classname);
    v9 = j_va("entity type '%s' is not a turret", v8);
    Scr_Error(COM_ERR_4536, scrContext, v9);
  }
  v10 = G_Turret_ScrRemoteUse(scrContext, v7, v4);
  Scr_AddBool(scrContext, v10);
}

/*
==============
GScr_RemoteControlTurretOff
==============
*/
void GScr_RemoteControlTurretOff(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  gentity_s *Entity; 
  gentity_s *v7; 
  const char *v8; 
  const char *v9; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 20313, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  if ( !Com_GameMode_SupportsFeature(WEAPON_DROPPING_LADDER_CLIMB) )
    Scr_Error(COM_ERR_4537, scrContext, "Remote turret control is not supported in this game mode");
  Entity = GScr_GetEntity(0);
  v7 = Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v8 = SL_ConvertToString(Entity->classname);
    v9 = j_va("entity type '%s' is not a turret", v8);
    Scr_Error(COM_ERR_4538, scrContext, v9);
  }
  G_Turret_ScrStopRemoteUse(v7, v4);
}

/*
==============
ScrCmd_SetEntityOwner
==============
*/
void ScrCmd_SetEntityOwner(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 

  Entity = GetEntity(entref);
  if ( Entity->client )
  {
    Scr_Error(COM_ERR_4539, scrContext, "SetEntityOwner() cannot be called on a client");
  }
  else if ( Scr_GetType(scrContext, 0) )
  {
    v4 = GScr_GetEntity(0);
    EntHandle::setEnt(&Entity->r.ownerNum, v4);
    if ( BG_IsVehicleEntity(&Entity->s) && v4->s.eType == ET_PLAYER )
      G_Vehicle_HandleOwnerChange(Entity, v4);
  }
  else
  {
    if ( BG_IsVehicleEntity(&Entity->s) )
      G_Vehicle_HandleOwnerChange(Entity, NULL);
    EntHandle::setEnt(&Entity->r.ownerNum, NULL);
  }
}

/*
==============
GScr_ControlsUnlink
==============
*/
void GScr_ControlsUnlink(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *PlayerEntity; 
  gclient_s *client; 
  bool v5; 
  __int64 remoteControlEnt; 
  gentity_s *v7; 
  entityType_s eType; 

  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  client = PlayerEntity->client;
  if ( client->sess.sessionState == SESS_STATE_SPECTATOR )
  {
    Com_PrintWarning(23, "WARNING: ControlsUnlink() called on a player who is currently spectating (spectator mode or in killcam).\n");
  }
  else if ( GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&client->ps.pm_flags, ACTIVE, 0x1Cu) )
  {
    v5 = 1;
    if ( Scr_GetNumParam(scrContext) )
      v5 = Scr_GetInt(scrContext, 0) != 0;
    if ( client->ps.remoteControlEnt >= 0x800u && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 20410, ASSERT_TYPE_ASSERT, "((unsigned)ps->remoteControlEnt < ( 2048 ))", (const char *)&queryFormat, "(unsigned)ps->remoteControlEnt < MAX_GENTITIES") )
      __debugbreak();
    remoteControlEnt = client->ps.remoteControlEnt;
    v7 = &g_entities[remoteControlEnt];
    if ( G_IsEntityInUse(remoteControlEnt) )
    {
      EntHandle::setEnt(&v7->remoteControlledOwner, NULL);
      eType = v7->s.eType;
      if ( eType == ET_MISSILE )
      {
        v7->c.missile.flags &= ~0x80u;
      }
      else if ( ((eType - 12) & 0xFFFD) == 0 && Com_GameMode_SupportsFeature(WEAPON_ANIM_SCRIPTED) )
      {
        G_Vehicle_PlayerRemoteControlOff(v7, PlayerEntity);
      }
    }
    if ( v5 )
    {
      GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(&client->ps.pm_flags, ACTIVE, 0x1Cu);
      client->ps.remoteControlEnt = 2047;
    }
  }
  else
  {
    Com_PrintWarning(23, "WARNING: ControlsUnlink() called on a player who's controls were not linked.\n");
  }
}

/*
==============
GScr_MakeVehicleSolidCapsule
==============
*/
void GScr_MakeVehicleSolidCapsule(scrContext_t *scrContext, scr_entref_t entref)
{
  __asm
  {
    vmovaps [rsp+68h+var_18], xmm6
    vmovaps [rsp+68h+var_28], xmm7
    vmovaps [rsp+68h+var_38], xmm8
  }
  _RBX = GetEntity(entref);
  if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 20490, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !_RBX->vehicle )
    Scr_Error(COM_ERR_4540, scrContext, "MakeVehicleSolidCapsule must be called on a vehicle entity.\n");
  if ( Scr_GetNumParam(scrContext) < 3 )
    Scr_Error(COM_ERR_4541, scrContext, "Usage: MakeVehicleSolidCapsule( <radius>, <midz>, <height> ).");
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm { vmovaps xmm8, xmm0 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm { vmovaps xmm6, xmm0 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
  __asm
  {
    vmovaps xmm1, xmm8; vehRadius
    vmovaps xmm7, xmm0
  }
  SetupVehicleCollision(_RBX, *(float *)&_XMM1);
  __asm { vmovss  dword ptr [rbx+108h], xmm6 }
  *(_QWORD *)_RBX->r.box.midPoint.v = 0i64;
  __asm
  {
    vmovss  dword ptr [rbx+10Ch], xmm8
    vmovss  dword ptr [rbx+110h], xmm8
    vmovss  dword ptr [rbx+114h], xmm7
    vmovaps xmm6, [rsp+68h+var_18]
    vmovaps xmm7, [rsp+68h+var_28]
    vmovaps xmm8, [rsp+68h+var_38]
  }
  SV_LinkEntity(_RBX);
}

/*
==============
GScr_MakeVehicleSolidSphere
==============
*/
void GScr_MakeVehicleSolidSphere(scrContext_t *scrContext, scr_entref_t entref)
{
  __asm
  {
    vmovaps [rsp+58h+var_18], xmm6
    vmovaps [rsp+58h+var_28], xmm7
  }
  _RBX = GetEntity(entref);
  if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 20528, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !_RBX->vehicle )
    Scr_Error(COM_ERR_4542, scrContext, "MakeVehicleSolidSphere must be called on a vehicle entity.\n");
  if ( !Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_4543, scrContext, "Usage: MakeVehicleSolidSphere( <radius> ).");
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm
  {
    vmovaps xmm6, xmm0
    vxorps  xmm7, xmm7, xmm7
  }
  if ( Scr_GetNumParam(scrContext) > 1 )
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
    __asm { vmovaps xmm7, xmm0 }
  }
  __asm { vmovaps xmm1, xmm6; vehRadius }
  SetupVehicleCollision(_RBX, *(float *)&_XMM1);
  __asm { vmovss  dword ptr [rbx+108h], xmm7 }
  *(_QWORD *)_RBX->r.box.midPoint.v = 0i64;
  __asm
  {
    vmovss  dword ptr [rbx+10Ch], xmm6
    vmovss  dword ptr [rbx+110h], xmm6
    vmovss  dword ptr [rbx+114h], xmm6
    vmovaps xmm6, [rsp+58h+var_18]
    vmovaps xmm7, [rsp+58h+var_28]
  }
  SV_LinkEntity(_RBX);
}

/*
==============
ScrCmd_GetCollision
==============
*/
void ScrCmd_GetCollision(scrContext_t *scrContext, scr_entref_t entref)
{
  EffectiveStance v2; 
  unsigned int entnum; 
  gentity_s *v5; 
  void *client; 
  const char *v7; 
  ComErrorCode v8; 
  const char *v9; 
  ComErrorCode v10; 
  scr_string_t ConstString; 
  unsigned int CanonicalString; 
  unsigned int v18; 
  unsigned int v20; 
  Bounds bounds; 

  v2 = PM_EFF_STANCE_DEFAULT;
  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v7 = "not an entity";
    v8 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 21247, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v5 = &g_entities[entnum];
  client = v5->client;
  if ( !client )
  {
    client = v5->agent;
    if ( !client )
    {
      v7 = j_va("entity %i is not a player or agent", entnum);
      v8 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v8, scrContext, v7);
      client = NULL;
    }
  }
  if ( Scr_GetNumParam(scrContext) != 1 )
  {
    v9 = "GetCollision() requires exactly one argument.";
    v10 = COM_ERR_4576;
LABEL_21:
    Scr_Error(v10, scrContext, v9);
    return;
  }
  ConstString = Scr_GetConstString(scrContext, 0);
  if ( ConstString != scr_const.stand )
  {
    if ( ConstString == scr_const.crouch )
    {
      v2 = PM_EFF_STANCE_DUCKED;
    }
    else
    {
      if ( ConstString != scr_const.prone )
      {
        v9 = "GetCollision() unknown stance argument provided.";
        v10 = COM_ERR_4577;
        goto LABEL_21;
      }
      v2 = PM_EFF_STANCE_PRONE;
    }
  }
  _RAX = BG_Suit_GetBounds(*((_DWORD *)client + 221), v2);
  __asm
  {
    vmovups xmm0, xmmword ptr [rax]
    vmovups xmmword ptr [rsp+68h+bounds.midPoint], xmm0
    vmovsd  xmm1, qword ptr [rax+10h]
    vmovsd  qword ptr [rsp+68h+bounds.halfSize+4], xmm1
  }
  if ( BG_UsingNewPlayerCollision() )
    BG_PlayerCollision_AdjustCapsuleBoundsForStickSystem(&bounds);
  Scr_MakeStruct(scrContext);
  __asm { vmovss  xmm1, dword ptr [rsp+68h+bounds.halfSize]; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
  CanonicalString = SL_GetCanonicalString("capsule_radius");
  Scr_AddStructField(scrContext, CanonicalString);
  __asm { vmovss  xmm1, dword ptr [rsp+68h+bounds.halfSize+8]; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
  v18 = SL_GetCanonicalString("capsule_halfheight");
  Scr_AddStructField(scrContext, v18);
  __asm { vmovss  xmm1, dword ptr [rsp+68h+bounds.midPoint+8]; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
  v20 = SL_GetCanonicalString("capsule_midpoint_height");
  Scr_AddStructField(scrContext, v20);
}

/*
==============
ScrCmd_ControlAgent
==============
*/
void ScrCmd_ControlAgent(scrContext_t *scrContext, scr_entref_t playerRef)
{
  Scr_Error(COM_ERR_4582, scrContext, "ControlAgent() functionality is disbled");
}

/*
==============
ScrCmd_RestoreControlAgent
==============
*/
void ScrCmd_RestoreControlAgent(scrContext_t *scrContext, scr_entref_t playerRef)
{
  Scr_Error(COM_ERR_4586, scrContext, "RestoreControlAgent() functionality is disbled");
}

/*
==============
ScrCmd_SetSolid
==============
*/
void ScrCmd_SetSolid(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *client; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *v6; 
  const char *v7; 
  ComErrorCode v8; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v7 = "not an entity";
    v8 = COM_ERR_3682;
    goto LABEL_20;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 21396, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = (GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *)v4->client;
  if ( !client )
  {
    client = (GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *)v4->agent;
    if ( !client )
    {
      v7 = j_va("entity %i is not a player or agent", entnum);
      v8 = COM_ERR_3679;
LABEL_20:
      Scr_ObjectError(v8, scrContext, v7);
      Scr_Error(COM_ERR_4587, scrContext, "SetSolid() called on entity without a playerState.\n");
      return;
    }
  }
  v6 = client + 94;
  if ( Scr_GetInt(scrContext, 0) )
  {
    if ( GameModeFlagValues::ms_mpValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 212, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a MP-only context", "IsFlagActive( index )") )
      __debugbreak();
    GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(v6, ACTIVE, 0x1Cu);
  }
  else
  {
    if ( GameModeFlagValues::ms_mpValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 201, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a MP-only context", "IsFlagActive( index )") )
      __debugbreak();
    GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(v6, ACTIVE, 0x1Cu);
  }
  if ( v4->agent )
    SV_LinkEntity(v4);
}

/*
==============
ScrCmd_NotifyOnPlayerUpdate
==============
*/
void ScrCmd_NotifyOnPlayerUpdate(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  gclient_s *client; 
  int flags; 

  Entity = GetEntity(entref);
  if ( Entity->client )
  {
    Int = Scr_GetInt(scrContext, 0);
    client = Entity->client;
    flags = client->flags;
    if ( Int )
      client->flags = flags | 0x80;
    else
      client->flags = flags & 0xFFFFFF7F;
  }
  else
  {
    Scr_Error(COM_ERR_4588, scrContext, "NotifyOnPlayerUpdate can only be set on clients.\n");
  }
}

/*
==============
ScrCmd_SetWorldUpTrigger
==============
*/
void ScrCmd_SetWorldUpTrigger(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *p_eFlags; 

  Entity = GetEntity(entref);
  Int = Scr_GetInt(scrContext, 0);
  p_eFlags = &Entity->s.lerp.eFlags;
  if ( Int )
  {
    GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(p_eFlags, ACTIVE, 0xFu);
    Entity->r.svFlags &= ~1u;
  }
  else
  {
    GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(p_eFlags, ACTIVE, 0xFu);
  }
}

/*
==============
GScr_RemoteControlVehicle
==============
*/
void GScr_RemoteControlVehicle(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *PlayerEntity; 
  gentity_s *Entity; 
  Vehicle *vehicle; 
  gclient_s *client; 
  __int64 v7; 
  DObj *ServerDObjForEnt; 
  int v9; 

  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  Entity = GScr_GetEntity(0);
  vehicle = Entity->vehicle;
  if ( !vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 21531, ASSERT_TYPE_ASSERT, "( vehicle )", (const char *)&queryFormat, "vehicle") )
    __debugbreak();
  if ( BGVehicles::PhysicsIsValid(vehicle->physicsVehicle) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 21532, ASSERT_TYPE_ASSERT, "( !BGVehicles::PhysicsIsValid( vehicle->physicsVehicle ) )", "RemoteControlVehicle() should be called only for non-physics vehicles") )
    __debugbreak();
  if ( ((Entity->s.eType - 12) & 0xFFFD) != 0 )
    Scr_ParamError(COM_ERR_4589, scrContext, 0, "Cannot control an entity that isn't a vehicle or helicopter");
  client = PlayerEntity->client;
  v7 = client->ps.vehicleState.entity;
  if ( (_DWORD)v7 != 2047 )
    EntHandle::setEnt(&g_entities[v7].r.ownerNum, NULL);
  memset_0(&client->ps.vehicleState, 0, sizeof(client->ps.vehicleState));
  client->ps.vehicleState.entity = Entity->s.number;
  EntHandle::setEnt(&Entity->r.ownerNum, PlayerEntity);
  client->ps.vehicleState.targetEntity = 2047;
  client->ps.vehicleState.origin.v[0] = vehicle->phys.origin.v[0];
  client->ps.vehicleState.origin.v[1] = vehicle->phys.origin.v[1];
  client->ps.vehicleState.origin.v[2] = vehicle->phys.origin.v[2];
  client->ps.vehicleState.angles.v[0] = vehicle->phys.angles.v[0];
  client->ps.vehicleState.angles.v[1] = vehicle->phys.angles.v[1];
  client->ps.vehicleState.angles.v[2] = vehicle->phys.angles.v[2];
  client->ps.vehicleState.velocity.v[0] = vehicle->phys.vel.v[0];
  client->ps.vehicleState.velocity.v[1] = vehicle->phys.vel.v[1];
  client->ps.vehicleState.velocity.v[2] = vehicle->phys.vel.v[2];
  client->ps.vehicleState.angVelocity.v[0] = vehicle->phys.rotVel.v[0];
  client->ps.vehicleState.angVelocity.v[1] = vehicle->phys.rotVel.v[1];
  client->ps.vehicleState.angVelocity.v[2] = vehicle->phys.rotVel.v[2];
  client->ps.vehicleState.tilt.v[0] = vehicle->phys.worldTilt.v[0];
  client->ps.vehicleState.tilt.v[1] = vehicle->phys.worldTilt.v[1];
  client->ps.vehicleState.tiltVelocity.v[0] = vehicle->phys.worldTiltVel.v[0];
  client->ps.vehicleState.tiltVelocity.v[1] = vehicle->phys.worldTiltVel.v[1];
  if ( G_Vehicle_IsRemoteDrive(Entity) )
  {
    GScr_RemoteEyesSet_Internal(&client->ps, Entity->s.number, 0, 0);
    if ( Com_GameMode_SupportsFeature(WEAPON_DROPPING_LADDER_CLIMB) )
    {
      if ( G_Vehicle_HasTurret(Entity) )
      {
        if ( !Com_GameMode_SupportsFeature(WEAPON_DROPPING_LADDER_CLIMB) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2417, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::TURRET_REMOTE_CONTROL ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::TURRET_REMOTE_CONTROL )") )
          __debugbreak();
        GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal(&client->ps.otherFlags, ACTIVE, 0x18u);
        client->ps.remoteTurretEnt = Entity->s.number;
      }
    }
  }
  ServerDObjForEnt = Com_GetServerDObjForEnt(Entity);
  v9 = XAnimIKGetCacheKey(ServerDObjForEnt);
  XAnimIKPreCacheDObj(ServerDObjForEnt, ServerDObjForEnt->entnum, v9);
}

/*
==============
GScr_CreatePrintChannel
==============
*/
void GScr_CreatePrintChannel(scrContext_t *scrContext)
{
  const char *String; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_3946, scrContext, "illegal call to createprintchannel()");
  String = Scr_GetString(scrContext, 0);
  if ( !Con_OpenChannel(String, 1) )
    Scr_Error(COM_ERR_3947, scrContext, "Unable to create new channel.  Maximum number of channels exeeded.");
}

/*
==============
GScr_printChannelSet
==============
*/
void GScr_printChannelSet(scrContext_t *scrContext)
{
  int scriptPrintChannel; 
  VariableType Type; 
  const char *String; 
  int channel_result; 

  channel_result = 24;
  if ( Scr_GetNumParam(scrContext) != 1 )
  {
    Scr_Error(COM_ERR_3948, scrContext, "illegal call to setprintchannel()");
    return;
  }
  scriptPrintChannel = level.scriptPrintChannel;
  Type = Scr_GetType(scrContext, 0);
  if ( Type == VAR_STRING )
  {
    String = Scr_GetString(scrContext, 0);
    if ( !Con_GetChannel(String, &channel_result) )
    {
      Scr_ParamError(COM_ERR_3949, scrContext, 0, "Invalid Print Channel");
      return;
    }
  }
  else
  {
    if ( Type != VAR_INTEGER )
    {
      Scr_ParamError(COM_ERR_3951, scrContext, 0, "Invalid Print Channel");
      return;
    }
    channel_result = Scr_GetInt(scrContext, 0);
    if ( !Con_IsChannelOpen(channel_result) )
    {
      Scr_ParamError(COM_ERR_3950, scrContext, 0, "Invalid Print Channel");
      return;
    }
  }
  if ( Con_ScriptHasPermission(channel_result) )
  {
    level.scriptPrintChannel = channel_result;
    Scr_AddInt(scrContext, scriptPrintChannel);
  }
  else
  {
    Scr_ParamError(COM_ERR_3952, scrContext, 0, "Script does not have permission to print to this channel");
  }
}

/*
==============
Scr_Print
==============
*/
void Scr_Print(scrContext_t *scrContext)
{
  signed int v2; 
  int NumParam; 
  const char *DebugString; 

  v2 = 0;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam > 0 )
  {
    do
    {
      DebugString = Scr_GetDebugString(scrContext, v2);
      Com_Printf(level.scriptPrintChannel, (const char *)&queryFormat, DebugString);
      ++v2;
    }
    while ( v2 < NumParam );
  }
}

/*
==============
GScr_RemoteControlVehicleOff
==============
*/
void GScr_RemoteControlVehicleOff(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *PlayerEntity; 
  gclient_s *client; 
  __int64 entity; 
  gentity_s *v5; 
  Vehicle *vehicle; 
  int time; 
  GUtils *v8; 

  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  client = PlayerEntity->client;
  entity = client->ps.vehicleState.entity;
  if ( (_DWORD)entity != 2047 )
  {
    v5 = &g_entities[entity];
    EntHandle::setEnt(&v5->r.ownerNum, NULL);
    vehicle = v5->vehicle;
    if ( !vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 21617, ASSERT_TYPE_ASSERT, "( vehicle )", (const char *)&queryFormat, "vehicle") )
      __debugbreak();
    if ( BGVehicles::PhysicsIsValid(vehicle->physicsVehicle) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 21619, ASSERT_TYPE_ASSERT, "( !BGVehicles::PhysicsIsValid( vehicle->physicsVehicle ) )", "RemoteControlVehicleOff() should be called only for non-physics vehicles") )
      __debugbreak();
    vehicle->phys.origin.v[0] = client->ps.vehicleState.origin.v[0];
    vehicle->phys.origin.v[1] = client->ps.vehicleState.origin.v[1];
    vehicle->phys.origin.v[2] = client->ps.vehicleState.origin.v[2];
    vehicle->phys.angles.v[0] = client->ps.vehicleState.angles.v[0];
    vehicle->phys.angles.v[1] = client->ps.vehicleState.angles.v[1];
    vehicle->phys.angles.v[2] = client->ps.vehicleState.angles.v[2];
    vehicle->phys.vel.v[0] = client->ps.vehicleState.velocity.v[0];
    vehicle->phys.vel.v[1] = client->ps.vehicleState.velocity.v[1];
    vehicle->phys.vel.v[2] = client->ps.vehicleState.velocity.v[2];
    vehicle->phys.rotVel.v[0] = client->ps.vehicleState.angVelocity.v[0];
    vehicle->phys.rotVel.v[1] = client->ps.vehicleState.angVelocity.v[1];
    vehicle->phys.rotVel.v[2] = client->ps.vehicleState.angVelocity.v[2];
    vehicle->phys.worldTilt.v[0] = client->ps.vehicleState.tilt.v[0];
    vehicle->phys.worldTilt.v[1] = client->ps.vehicleState.tilt.v[1];
    vehicle->phys.worldTiltVel.v[0] = client->ps.vehicleState.tiltVelocity.v[0];
    vehicle->phys.worldTiltVel.v[1] = client->ps.vehicleState.tiltVelocity.v[1];
    time = level.time;
    v5->s.lerp.u.anonymous.data[1] &= ~0x40u;
    v5->nextthink = time;
  }
  if ( GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&client->ps.otherFlags, ACTIVE, 1u) && client->ps.remoteEyesEnt == client->ps.vehicleState.entity )
    GScr_RemoteEyesClear_Internal(&client->ps);
  if ( !GUtils::ms_gUtils && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_utils.h", 112, ASSERT_TYPE_ASSERT, "( ms_gUtils )", (const char *)&queryFormat, "ms_gUtils") )
    __debugbreak();
  v8 = GUtils::ms_gUtils;
  client->ps.viewangles.v[2] = 0.0;
  v8->SetPlayerViewAngles(v8, PlayerEntity, &client->ps.viewangles);
  if ( GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&client->ps.otherFlags, ACTIVE, 0x18u) )
  {
    if ( !Com_GameMode_SupportsFeature(WEAPON_DROPPING_LADDER_CLIMB) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2396, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::TURRET_REMOTE_CONTROL ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::TURRET_REMOTE_CONTROL )") )
      __debugbreak();
    if ( !Com_GameMode_SupportsFeature(WEAPON_DROPPING_LADDER_CLIMB) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 21647, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::TURRET_REMOTE_CONTROL ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::TURRET_REMOTE_CONTROL )") )
      __debugbreak();
    if ( client->ps.remoteTurretEnt == client->ps.vehicleState.entity )
    {
      if ( !Com_GameMode_SupportsFeature(WEAPON_DROPPING_LADDER_CLIMB) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2409, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::TURRET_REMOTE_CONTROL ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::TURRET_REMOTE_CONTROL )") )
        __debugbreak();
      GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal(&client->ps.otherFlags, ACTIVE, 0x18u);
    }
  }
  BG_InitPlayerstateVehicle(&client->ps);
  client->ps.vehicleState.flags &= ~0x40u;
}

/*
==============
Scr_PrintLn
==============
*/
void Scr_PrintLn(scrContext_t *scrContext)
{
  signed int v2; 
  int NumParam; 
  const char *DebugString; 

  v2 = 0;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam > 0 )
  {
    do
    {
      DebugString = Scr_GetDebugString(scrContext, v2);
      Com_Printf(level.scriptPrintChannel, (const char *)&queryFormat, DebugString);
      ++v2;
    }
    while ( v2 < NumParam );
  }
  Com_Printf(level.scriptPrintChannel, "\n");
}

/*
==============
GScr_IsPlayer
==============
*/
void GScr_IsPlayer(scrContext_t *scrContext)
{
  if ( Scr_GetType(scrContext, 0) == VAR_POINTER && Scr_GetPointerType(scrContext, 0) == VAR_ENTITY && GScr_GetEntity(0)->client )
    Scr_AddInt(scrContext, 1);
  else
    Scr_AddInt(scrContext, 0);
}

/*
==============
GScr_GetMaxClients
==============
*/
void GScr_GetMaxClients(scrContext_t *scrContext)
{
  Scr_AddInt(scrContext, SvClient::ms_clientCount);
}

/*
==============
GScr_Turret_IsFiringTurret
==============
*/
void GScr_Turret_IsFiringTurret(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int v4; 

  Entity = GetEntity(entref);
  if ( !Entity->turretHandle.m_objIndex )
    Scr_Error(COM_ERR_4592, scrContext, "IsVehicleTurretFiring must be called on a turret entity\n");
  v4 = GTurret::GetTurret(&Entity->turretHandle)->m_data.triggerDown && G_Turret_CanShoot(Entity);
  Scr_AddBool(scrContext, v4);
}

/*
==============
ScrCmd_MakeCollideWithItemClip
==============
*/
void ScrCmd_MakeCollideWithItemClip(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  BOOL v4; 
  unsigned int v5; 

  Entity = GetEntity(entref);
  if ( !Entity )
    Scr_Error(COM_ERR_4593, scrContext, "MakeCollideWithItemClip must be called on an entity.\n");
  if ( Entity->s.eType != ET_MISSILE )
    Scr_Error(COM_ERR_4594, scrContext, "MakeCollideWithItemClip is currently limited to missile entities.\n");
  if ( Scr_GetNumParam(scrContext) > 1 )
    Scr_Error(COM_ERR_4595, scrContext, "Usage: MakeCollideWithItemClip () or MakeCollideWithItemClip (enable).");
  v4 = 1;
  if ( Scr_GetNumParam(scrContext) == 1 )
    v4 = Scr_GetInt(scrContext, 0) != 0;
  v5 = Entity->clipmask | 0x400;
  if ( !v4 )
    v5 = Entity->clipmask & 0xFFFFFBFF;
  Entity->clipmask = v5;
}

/*
==============
GScr_PrintToScreen2D
==============
*/
void GScr_PrintToScreen2D(scrContext_t *scrContext)
{
  unsigned int v7; 
  unsigned int v8; 
  const char *text; 
  vec4_t color; 

  __asm
  {
    vmovaps [rsp+88h+var_38], xmm8
    vmovups xmm0, cs:__xmm@3f8000003f8000003f8000003f800000
    vmovss  xmm8, cs:__real@3f800000
    vmovups xmmword ptr [rsp+88h+color], xmm0
  }
  v7 = Scr_GetNumParam(scrContext) - 3;
  if ( !v7 )
    goto LABEL_7;
  v8 = v7 - 1;
  if ( !v8 )
  {
LABEL_6:
    Scr_GetVector(scrContext, 3u, (vec3_t *)&color);
LABEL_7:
    __asm
    {
      vmovaps [rsp+88h+var_18], xmm6
      vmovaps [rsp+88h+var_28], xmm7
    }
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
    __asm { vmovaps xmm7, xmm0 }
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
    __asm { vmovaps xmm6, xmm0 }
    text = Scr_GetString(scrContext, 2u);
    __asm
    {
      vmovaps xmm3, xmm8; scale
      vmovaps xmm1, xmm6; y
      vmovaps xmm0, xmm7; x
    }
    G_Main_AddDebugString2D(*(float *)&_XMM0, *(float *)&_XMM1, &color, *(float *)&_XMM3, text);
    __asm
    {
      vmovaps xmm7, [rsp+88h+var_28]
      vmovaps xmm6, [rsp+88h+var_18]
    }
    goto LABEL_8;
  }
  if ( v8 == 1 )
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 4u);
    __asm { vmovaps xmm8, xmm0 }
    goto LABEL_6;
  }
  Scr_Error(COM_ERR_3959, scrContext, "invalid args to printtoscreen3d");
LABEL_8:
  __asm { vmovaps xmm8, [rsp+88h+var_38] }
}

/*
==============
GScr_SpawnRagdollConstraint
==============
*/
void GScr_SpawnRagdollConstraint(scrContext_t *scrContext)
{
  gentity_s *Entity; 
  gentity_s *v3; 
  scr_string_t ConstString; 
  hitLocation_t HitLocationIndexFromString; 
  scr_string_t ConstLowercaseString; 
  bool v7; 
  const gentity_s *v8; 
  vec3_t vectorValue; 

  Entity = GScr_GetEntity(0);
  v3 = Entity;
  if ( !Entity || !BG_IsCorpseEntity(&Entity->s) )
    Scr_Error(COM_ERR_4596, scrContext, "ERROR: SpawnRagdollConstraint(), specified entity is not a corpse.");
  if ( v3 == (gentity_s *)-16i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\q_shared.h", 2263, ASSERT_TYPE_ASSERT, "(trajectory)", (const char *)&queryFormat, "trajectory") )
    __debugbreak();
  if ( (unsigned int)(v3->s.lerp.pos.trType - 23) > 5 )
    Scr_Error(COM_ERR_4597, scrContext, "ERROR: SpawnRagdollConstraint(), specified corpse entity is not in ragdoll.");
  ConstString = Scr_GetConstString(scrContext, 1u);
  HitLocationIndexFromString = G_Combat_GetHitLocationIndexFromString(ConstString);
  if ( HitLocationIndexFromString == HITLOC_NUM )
    Scr_Error(COM_ERR_4598, scrContext, "ERROR: SpawnRagdollConstraint(), invalid hitLocation provided.");
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 2u);
  if ( !ConstLowercaseString )
    Scr_Error(COM_ERR_4599, scrContext, "ERROR: SpawnRagdollConstraint(), invalid partName provided.");
  Scr_GetVector(scrContext, 3u, &vectorValue);
  v7 = 1;
  if ( Scr_GetNumParam(scrContext) > 4 )
    v7 = Scr_GetInt(scrContext, 4u) != 0;
  v8 = G_RagdollConstraintEntity_Spawn(v3, HitLocationIndexFromString, ConstLowercaseString, &vectorValue, v7);
  if ( v8 )
    GScr_AddEntity(v8);
  else
    Scr_AddUndefined(scrContext);
}

/*
==============
GScr_print3d
==============
*/
void GScr_print3d(scrContext_t *scrContext)
{
  bool v5; 
  int duration; 
  const char *String; 
  vec4_t color; 
  vec3_t vectorValue; 
  vec3_t xyz; 

  __asm
  {
    vmovaps [rsp+88h+var_18], xmm6
    vmovups xmm0, cs:__xmm@3f8000003f8000003f8000003f800000
    vmovss  xmm6, cs:__real@3f800000
    vmovups xmmword ptr [rsp+88h+color], xmm0
  }
  v5 = 0;
  duration = 1;
  switch ( Scr_GetNumParam(scrContext) )
  {
    case 2u:
      goto $LN9_64;
    case 3u:
      goto $LN8_50;
    case 4u:
      goto $LN7_87;
    case 5u:
      goto $LN6_42;
    case 6u:
      goto $LN5_39;
    case 7u:
      v5 = Scr_GetInt(scrContext, 6u) != 0;
$LN5_39:
      duration = Scr_GetInt(scrContext, 5u);
$LN6_42:
      *(double *)&_XMM0 = Scr_GetFloat(scrContext, 4u);
      __asm { vmovaps xmm6, xmm0 }
$LN7_87:
      *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
      __asm { vmovss  dword ptr [rsp+88h+color+0Ch], xmm0 }
$LN8_50:
      Scr_GetVector(scrContext, 2u, &vectorValue);
      __asm
      {
        vmovss  xmm1, dword ptr [rsp+88h+vectorValue]
        vmovss  xmm0, dword ptr [rsp+88h+vectorValue+4]
        vmovss  dword ptr [rsp+88h+color], xmm1
        vmovss  xmm1, dword ptr [rsp+88h+vectorValue+8]
        vmovss  dword ptr [rsp+88h+color+8], xmm1
        vmovss  dword ptr [rsp+88h+color+4], xmm0
      }
$LN9_64:
      String = Scr_GetString(scrContext, 1u);
      Scr_GetVector(scrContext, 0, &xyz);
      __asm { vmovaps xmm2, xmm6; scale }
      if ( v5 )
        G_Main_AddDebugStringWithDurationCentered(&xyz, &color, *(float *)&_XMM2, String, duration);
      else
        G_Main_AddDebugStringWithDuration(&xyz, &color, *(float *)&_XMM2, String, duration);
      break;
    default:
      Scr_Error(COM_ERR_3960, scrContext, "illegal call to print3d()");
      break;
  }
  __asm { vmovaps xmm6, [rsp+88h+var_18] }
}

/*
==============
Scr_MagicBullet
==============
*/

void __fastcall Scr_MagicBullet(scrContext_t *scrContext, __int64 a2, double _XMM2_8)
{
  int NumParam; 
  unsigned int v10; 
  gentity_s *Entity; 
  gentity_s *v12; 
  ComErrorCode v13; 
  const char *String; 
  const char *v15; 
  char v17; 
  const char *v20; 
  bool v29; 
  bool v30; 
  const WeaponDef *v34; 
  weapType_t WeaponType; 
  int time; 
  int WeaponClass; 
  const char *v63; 
  ComErrorCode v64; 
  gentity_s *v65; 
  const gentity_s *v66; 
  gentity_s *v67; 
  EntHandle *v68; 
  weapType_t v69; 
  const char *WeaponTypeName; 
  gentity_s *v71; 
  GWeaponMap *Instance; 
  int v73; 
  const DObj *ServerDObjForEnt; 
  float hipSpreadDuckedMin; 
  float *hipSpreadDuckedMax; 
  float *hipSpreadProneMin; 
  bool outIsAlternate[4]; 
  float hipSpreadStandMin; 
  scr_string_t outTagName; 
  TagPair hipSpreadStandMax; 
  float hipSpreadInAirMin; 
  float hipSpreadSprintMax; 
  float hipSpreadSprintMin; 
  float hipSpreadProneMax; 
  float v87; 
  float v88; 
  float v89[4]; 
  BgWeaponParms forward; 
  vec3_t vectorValue; 
  vec3_t origin; 
  Weapon outWeapon; 
  tmat33_t<vec3_t> outAxis; 
  tmat33_t<vec3_t> out; 

  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam < 3 )
    Scr_Error(COM_ERR_4600, scrContext, "MagicBullet invalid parameters\n");
  v10 = 0;
  Entity = NULL;
  if ( NumParam >= 4 )
  {
    if ( Scr_GetType(scrContext, 3u) )
    {
      Entity = GScr_GetEntity(3u);
      if ( !G_Utils_IsClientOrActorOrAgent(Entity) )
        Scr_Error(COM_ERR_4601, scrContext, "Owner must be a player, actor, or agent.\n");
    }
  }
  v12 = NULL;
  if ( NumParam >= 5 && Scr_GetType(scrContext, 4u) )
    v12 = GScr_GetEntity(4u);
  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, outIsAlternate);
  if ( outWeapon.weaponIdx )
  {
    __asm
    {
      vmovaps [rsp+250h+var_40], xmm7
      vxorps  xmm7, xmm7, xmm7
      vmovss  [rsp+250h+hipSpreadStandMin], xmm7
    }
    if ( BG_GetWeaponClass(&outWeapon, 0) == WEAPCLASS_SPREAD )
      BG_GetHipSpread(&outWeapon, 0, &hipSpreadStandMin, (float *)&hipSpreadStandMax, v89, &v88, &v87, &hipSpreadProneMax, &hipSpreadSprintMin, &hipSpreadSprintMax, &hipSpreadInAirMin, (float *)&outTagName);
    if ( NumParam >= 6 )
    {
      if ( Scr_GetType(scrContext, 5u) )
      {
        *(double *)&_XMM0 = Scr_GetFloat(scrContext, 5u);
        __asm
        {
          vcomiss xmm0, xmm7
          vmovss  [rsp+250h+hipSpreadStandMin], xmm0
        }
        if ( v17 )
        {
          __asm
          {
            vcvtss2sd xmm1, xmm0, xmm0
            vmovq   rdx, xmm1
          }
          v20 = j_va("MagicBullet called with an invalid spread value %f\n", _RDX);
          Scr_ParamError(COM_ERR_6491, scrContext, 0, v20);
LABEL_72:
          __asm { vmovaps xmm7, [rsp+250h+var_40] }
          return;
        }
      }
    }
    __asm
    {
      vmovaps [rsp+250h+var_30], xmm6
      vmovaps [rsp+250h+var_50], xmm8
      vmovaps [rsp+250h+var_60], xmm9
    }
    Scr_GetVector(scrContext, 1u, &vectorValue);
    __asm { vmovsd  xmm0, qword ptr [rbp+150h+vectorValue] }
    origin.v[2] = vectorValue.v[2];
    __asm { vmovsd  qword ptr [rbp+150h+origin], xmm0 }
    Scr_GetVector(scrContext, 2u, &vectorValue);
    __asm
    {
      vmovups ymm2, ymmword ptr [rbp+150h+outWeapon.weaponIdx]
      vmovups xmm0, xmmword ptr [rbp+150h+outWeapon.attachmentVariationIndices+5]
      vmovsd  xmm1, qword ptr [rbp+150h+outWeapon.attachmentVariationIndices+15h]
      vmovss  xmm6, dword ptr [rbp+150h+vectorValue]
      vmovss  xmm8, dword ptr [rbp+150h+vectorValue+4]
      vmovss  xmm9, dword ptr [rbp+150h+vectorValue+8]
      vmovd   r14d, xmm2
    }
    *(_DWORD *)&forward.weapon.weaponCamo = *(_DWORD *)&outWeapon.weaponCamo;
    forward.isAlternate = 0;
    __asm
    {
      vmovups ymmword ptr [rbp+150h+r_weapon.weaponIdx], ymm2
      vmovups xmmword ptr [rbp+150h+r_weapon.attachmentVariationIndices+5], xmm0
      vmovsd  qword ptr [rbp+150h+r_weapon.attachmentVariationIndices+15h], xmm1
    }
    if ( (unsigned __int16)_R14 > bg_lastParsedWeaponIndex )
    {
      LODWORD(hipSpreadProneMin) = bg_lastParsedWeaponIndex;
      LODWORD(hipSpreadDuckedMax) = (unsigned __int16)_R14;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1203, ASSERT_TYPE_ASSERT, "( weaponIdx ) <= ( bg_lastParsedWeaponIndex )", "weaponIdx not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", hipSpreadDuckedMax, hipSpreadProneMin) )
        __debugbreak();
    }
    _R14 = (unsigned __int16)_R14;
    v29 = bg_weaponDefs[(unsigned __int16)_R14] == NULL;
    if ( !bg_weaponDefs[(unsigned __int16)_R14] )
    {
      v30 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1204, ASSERT_TYPE_ASSERT, "(bg_weaponDefs[weaponIdx])", (const char *)&queryFormat, "bg_weaponDefs[weaponIdx]");
      v29 = !v30;
      if ( v30 )
        __debugbreak();
    }
    __asm
    {
      vmovss  xmm2, dword ptr [rbp+150h+origin]
      vmovss  xmm1, dword ptr [rbp+150h+origin+4]
      vmovss  xmm0, dword ptr [rbp+150h+origin+8]
    }
    v34 = bg_weaponDefs[_R14];
    __asm
    {
      vsubss  xmm4, xmm6, xmm2
      vsubss  xmm6, xmm9, xmm0
      vmovaps xmm9, [rsp+250h+var_60]
      vsubss  xmm5, xmm8, xmm1
      vmovaps xmm8, [rsp+250h+var_50]
      vmovss  [rbp+150h+var_184], xmm0
      vmovss  [rbp+150h+var_188], xmm1
      vmulss  xmm0, xmm4, xmm4
      vmovss  [rbp+150h+var_18C], xmm2
      vmulss  xmm1, xmm5, xmm5
      vaddss  xmm2, xmm1, xmm0
      vmulss  xmm1, xmm6, xmm6
      vaddss  xmm2, xmm2, xmm1
      vmovss  xmm1, cs:__real@3f800000
      vsqrtss xmm3, xmm2, xmm2
      vcmpless xmm0, xmm3, cs:__real@80000000
      vblendvps xmm0, xmm3, xmm1, xmm0
      vdivss  xmm1, xmm1, xmm0
      vmulss  xmm0, xmm6, xmm1
      vmovaps xmm6, [rsp+250h+var_30]
      vmovss  dword ptr [rbp+150h+forward+8], xmm0
      vmovss  xmm0, [rsp+250h+hipSpreadStandMin]
      vcomiss xmm0, xmm7
      vmulss  xmm2, xmm4, xmm1
      vmulss  xmm3, xmm5, xmm1
      vmovss  dword ptr [rbp+150h+forward], xmm2
      vmovss  dword ptr [rbp+150h+forward+4], xmm3
    }
    forward.weapDef = v34;
    if ( v29 )
    {
      __asm
      {
        vxorps  xmm0, xmm0, xmm0
        vmovups [rbp+150h+var_1A4+4], xmm0
        vmovss  dword ptr [rbp+150h+var_1A4], xmm7
        vmovss  [rbp+150h+var_190], xmm7
      }
    }
    else
    {
      MatrixIdentity33(&out);
      GenerateAxisFromForwardVector(&forward.forward, &out, &outAxis);
      __asm
      {
        vmovups xmm0, xmmword ptr [rbp+150h+outAxis+0Ch]
        vmovss  xmm1, dword ptr [rbp+150h+outAxis+20h]
        vmovups [rbp+150h+var_1A4], xmm0
        vmovss  xmm0, dword ptr [rbp+150h+outAxis+1Ch]
        vmovss  [rbp+150h+var_194], xmm0
        vmovss  [rbp+150h+var_190], xmm1
      }
    }
    G_Weapon_ClearSimulateTracerFlag(Entity);
    WeaponType = BG_GetWeaponType(&forward.weapon, forward.isAlternate);
    time = level.time;
    switch ( WeaponType )
    {
      case WEAPTYPE_BULLET:
        if ( !Entity )
          Entity = g_entities + 2046;
        if ( Entity->client )
          Scr_Error(COM_ERR_4613, scrContext, "MagicBullet() invoked with a client entity as the bullet weapon 'owner'.  This is not supported.  Specify a different owner entity.\n");
        __asm { vmovss  xmm1, [rsp+250h+hipSpreadStandMin]; spread }
        G_Bullet_Fire(Entity, *(float *)&_XMM1, &forward, Entity, WEAPON_HAND_DEFAULT, time);
        goto LABEL_61;
      case WEAPTYPE_GRENADE:
        Scr_Error(COM_ERR_4604, scrContext, "MagicBullet() does not work with grenade-type weapons.\n");
        goto LABEL_72;
      case WEAPTYPE_PROJECTILE:
        WeaponClass = BG_GetWeaponClass(&forward.weapon, forward.isAlternate);
        if ( WeaponClass < 0 )
          goto LABEL_47;
        if ( WeaponClass <= 5 )
          goto LABEL_52;
        if ( WeaponClass == 6 )
        {
          if ( Entity )
            v65 = Entity;
          else
            v65 = g_entities + 2046;
          v66 = G_Weapon_GrenadeLauncher_Fire(v65, &outWeapon, WEAPON_HAND_DEFAULT, time, &forward);
        }
        else
        {
          if ( WeaponClass != 7 && WeaponClass != 12 )
          {
LABEL_47:
            v63 = "MagicBullet(): Unhandled projectile weapClass.\n";
            v64 = COM_ERR_4614;
LABEL_60:
            Scr_Error(v64, scrContext, v63);
            goto LABEL_61;
          }
LABEL_52:
          if ( Entity )
            v67 = Entity;
          else
            v67 = g_entities + 2046;
          __asm { vmovss  dword ptr [rsp+250h+hipSpreadDuckedMin], xmm7 }
          v66 = G_Weapon_RocketLauncher_Fire(v67, &outWeapon, forward.isAlternate, WEAPON_HAND_DEFAULT, hipSpreadDuckedMin, &forward, &vec3_origin, time, NULL, 1);
        }
        v68 = (EntHandle *)v66;
        if ( v66 )
        {
          GScr_AddEntity(v66);
          if ( Entity )
          {
            EntHandle::setEnt(v68 + 82, Entity);
            EntHandle::setEnt(v68 + 108, Entity);
          }
LABEL_62:
          if ( v12 )
          {
            if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_STILL_LAND|0x80) )
            {
              BG_GetWeaponFlashTagname(&hipSpreadStandMax, &outWeapon, 0, 0);
              outIsAlternate[0] = -2;
              v73 = -1;
              outTagName = 0;
              ServerDObjForEnt = Com_GetServerDObjForEnt(v12);
              if ( TagPair::GetTagNameAndBoneIndex(&hipSpreadStandMax, ServerDObjForEnt, &outTagName, (unsigned __int8 *)outIsAlternate) )
                v73 = outIsAlternate[0];
              v10 = BG_CreateWeaponFireParam(v73, &outWeapon);
            }
            G_Utils_AddEvent(v12, 0x28u, v10);
          }
          else
          {
            v71 = G_Utils_SpawnEventEntity(&origin, 40);
            v71->s.eventParm2 = 0;
            Instance = GWeaponMap::GetInstance();
            if ( !Instance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 447, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
              __debugbreak();
            Instance->SetWeapon(Instance, &v71->s.weaponHandle, &outWeapon);
            v71->s.eventParm = 0;
          }
          goto LABEL_72;
        }
LABEL_61:
        Scr_AddUndefined(scrContext);
        goto LABEL_62;
      case WEAPTYPE_SCRIPT:
        Scr_Error(COM_ERR_4605, scrContext, "MagicBullet() does not work with script-type weapons.\n");
        goto LABEL_72;
      case WEAPTYPE_SHIELD:
        Scr_Error(COM_ERR_4609, scrContext, "MagicBullet() does not work with shield-type weapons.\n");
        goto LABEL_72;
      case WEAPTYPE_CHARGE_SHIELD:
        Scr_Error(COM_ERR_4610, scrContext, "MagicBullet() does not work with charge shield-type weapons.\n");
        goto LABEL_72;
      case WEAPTYPE_LOCATION_SELECT:
        Scr_Error(COM_ERR_4611, scrContext, "MagicBullet() does not work with location select-type weapons.\n");
        goto LABEL_72;
      case WEAPTYPE_EQUIP_DEPLOY:
        Scr_Error(COM_ERR_4612, scrContext, "MagicBullet() does not work with equipment deploy-type weapons.\n");
        goto LABEL_72;
      default:
        v69 = BG_GetWeaponType(&forward.weapon, forward.isAlternate);
        WeaponTypeName = BG_GetWeaponTypeName(v69);
        v63 = j_va("MagicBullet(): Unhandled weapType \"%s\".\n", WeaponTypeName);
        v64 = COM_ERR_4615;
        goto LABEL_60;
    }
  }
  if ( Scr_GetType(scrContext, 0) == VAR_STRING )
  {
    v13 = COM_ERR_4602;
    String = Scr_GetString(scrContext, 0);
    v15 = j_va("MagicBullet called with unknown weapon name %s\n", String);
  }
  else
  {
    v13 = COM_ERR_4603;
    v15 = "MagicBullet called with unknown weapon\n";
  }
  Scr_ParamError(v13, scrContext, 0, v15);
}

/*
==============
GScr_line
==============
*/
void GScr_line(scrContext_t *scrContext)
{
  int duration; 
  int Int; 
  unsigned int v5; 
  unsigned int v6; 
  unsigned int v7; 
  unsigned int v8; 
  vec4_t color; 
  vec3_t vectorValue; 
  vec3_t start; 

  __asm { vmovups xmm0, cs:__xmm@3f8000003f8000003f8000003f800000 }
  duration = 0;
  Int = 0;
  __asm { vmovups xmmword ptr [rsp+78h+color], xmm0 }
  v5 = Scr_GetNumParam(scrContext) - 2;
  if ( !v5 )
    goto LABEL_11;
  v6 = v5 - 1;
  if ( !v6 )
  {
LABEL_10:
    Scr_GetVector(scrContext, 2u, (vec3_t *)&color);
LABEL_11:
    Scr_GetVector(scrContext, 1u, &vectorValue);
    Scr_GetVector(scrContext, 0, &start);
    goto LABEL_12;
  }
  v7 = v6 - 1;
  if ( !v7 )
  {
LABEL_9:
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
    __asm { vmovss  dword ptr [rsp+78h+color+0Ch], xmm0 }
    goto LABEL_10;
  }
  v8 = v7 - 1;
  if ( !v8 )
  {
LABEL_8:
    Int = Scr_GetInt(scrContext, 4u);
    goto LABEL_9;
  }
  if ( v8 == 1 )
  {
    duration = Scr_GetInt(scrContext, 5u);
    goto LABEL_8;
  }
  Scr_Error(COM_ERR_3961, scrContext, "illegal call to line()");
LABEL_12:
  CL_AddDebugLine(&start, &vectorValue, &color, Int, duration, 1);
}

/*
==============
GScr_Box
==============
*/
void GScr_Box(scrContext_t *scrContext)
{
  int duration; 
  int depthTest; 
  unsigned int v7; 
  unsigned int v8; 
  unsigned int v9; 
  unsigned int v10; 
  vec4_t color; 
  vec3_t vectorValue; 
  Bounds box; 

  __asm
  {
    vmovaps [rsp+88h+var_18], xmm6
    vmovups xmm0, cs:__xmm@3f8000003f8000003f8000003f800000
    vmovups xmmword ptr [rsp+88h+color], xmm0
  }
  duration = 1;
  __asm { vxorps  xmm6, xmm6, xmm6 }
  depthTest = 0;
  v7 = Scr_GetNumParam(scrContext) - 1;
  if ( !v7 )
    goto LABEL_11;
  v8 = v7 - 1;
  if ( !v8 )
  {
LABEL_10:
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
    __asm { vmovaps xmm6, xmm0 }
LABEL_11:
    Scr_GetVector(scrContext, 0, &vectorValue);
    __asm
    {
      vmovups xmm1, cs:__xmm@41800000410000000000000000000000
      vmovss  xmm2, cs:__real@41800000
      vmovups xmmword ptr [rsp+88h+box.midPoint], xmm1
      vmovss  xmm1, cs:__real@41000000
      vmovss  dword ptr [rsp+88h+box.halfSize+4], xmm2
      vmovaps xmm2, xmm6; yaw
      vmovss  dword ptr [rsp+88h+box.halfSize+8], xmm1
    }
    G_DebugBox(&vectorValue, &box, *(float *)&_XMM2, &color, depthTest, duration);
    goto LABEL_12;
  }
  v9 = v8 - 1;
  if ( !v9 )
  {
LABEL_9:
    Scr_GetVector(scrContext, 2u, (vec3_t *)&color);
    goto LABEL_10;
  }
  v10 = v9 - 1;
  if ( !v10 )
  {
LABEL_8:
    depthTest = Scr_GetInt(scrContext, 3u);
    goto LABEL_9;
  }
  if ( v10 == 1 )
  {
    duration = Scr_GetInt(scrContext, 4u);
    goto LABEL_8;
  }
  Scr_Error(COM_ERR_3962, scrContext, "illegal call to box()");
LABEL_12:
  __asm { vmovaps xmm6, [rsp+88h+var_18] }
}

/*
==============
GScr_DrawEntityBounds
==============
*/
void GScr_DrawEntityBounds(scrContext_t *scrContext)
{
  int duration; 
  int depthTest; 
  unsigned int v5; 
  unsigned int v6; 
  unsigned int v7; 
  vec4_t color; 

  __asm
  {
    vmovups xmm0, cs:__xmm@3f8000003f8000003f8000003f800000
    vmovups xmmword ptr [rsp+58h+color], xmm0
  }
  duration = 1;
  depthTest = 0;
  v5 = Scr_GetNumParam(scrContext) - 1;
  if ( v5 )
  {
    v6 = v5 - 1;
    if ( v6 )
    {
      v7 = v6 - 1;
      if ( v7 )
      {
        if ( v7 != 1 )
        {
          Scr_Error(COM_ERR_3963, scrContext, "illegal call to DrawEntityBounds()");
          return;
        }
        duration = Scr_GetInt(scrContext, 3u);
      }
      depthTest = Scr_GetInt(scrContext, 2u);
    }
    Scr_GetVector(scrContext, 1u, (vec3_t *)&color);
  }
  _RAX = GScr_GetEntity(0);
  if ( _RAX )
  {
    __asm { vmovss  xmm2, dword ptr [rax+140h]; yaw }
    G_DebugBox(&_RAX->r.currentOrigin, &_RAX->r.box, *(float *)&_XMM2, &color, depthTest, duration);
  }
}

/*
==============
GScr_DebugStar
==============
*/
void GScr_DebugStar(scrContext_t *scrContext)
{
  const char *String; 
  int duration; 
  unsigned int v7; 
  unsigned int v8; 
  unsigned int v9; 
  unsigned int v10; 
  float v12; 
  vec4_t color; 
  vec3_t vectorValue; 

  __asm
  {
    vmovaps [rsp+78h+var_18], xmm6
    vmovups xmm0, xmmword ptr cs:?colorWhite@@3Tvec4_t@@B; vec4_t const colorWhite
    vmovss  xmm6, cs:__real@3f800000
  }
  String = NULL;
  __asm { vmovups xmmword ptr [rsp+78h+color], xmm0 }
  duration = 10;
  v7 = Scr_GetNumParam(scrContext) - 1;
  if ( v7 )
  {
    v8 = v7 - 1;
    if ( v8 )
    {
      v9 = v8 - 1;
      if ( v9 )
      {
        v10 = v9 - 1;
        if ( v10 )
        {
          if ( v10 != 1 )
          {
            Scr_Error(COM_ERR_5913, scrContext, "Bad call to GetVector().  Pass in a mandatory origin parameter.");
            goto LABEL_18;
          }
          if ( Scr_GetType(scrContext, 4u) )
          {
            *(double *)&_XMM0 = Scr_GetFloat(scrContext, 4u);
            __asm { vmovaps xmm6, xmm0 }
          }
        }
        if ( Scr_GetType(scrContext, 3u) )
          String = Scr_GetString(scrContext, 3u);
      }
      if ( Scr_GetType(scrContext, 2u) )
        duration = Scr_GetInt(scrContext, 2u);
    }
    if ( Scr_GetType(scrContext, 1u) )
      Scr_GetVector(scrContext, 1u, (vec3_t *)&color);
  }
  Scr_GetVector(scrContext, 0, &vectorValue);
  if ( String )
  {
    __asm { vmovss  [rsp+78h+var_58], xmm6 }
    G_DebugStarWithTextDuration(&vectorValue, &color, &color, String, v12, duration);
  }
  else
  {
    G_DebugStarWithDuration(&vectorValue, &color, duration);
  }
LABEL_18:
  __asm { vmovaps xmm6, [rsp+78h+var_18] }
}

/*
==============
GScr_OrientedBox
==============
*/
void GScr_OrientedBox(scrContext_t *scrContext)
{
  int duration; 
  int depthTest; 
  vec3_t v10; 
  Bounds box; 
  vec4_t color; 
  vec3_t vectorValue; 
  vec3_t origin; 
  tmat33_t<vec3_t> axis; 

  __asm
  {
    vmovups xmm0, cs:__xmm@3f8000003f8000003f8000003f800000
    vmovups xmmword ptr [rsp+0C8h+color], xmm0
  }
  duration = 1;
  depthTest = 0;
  switch ( Scr_GetNumParam(scrContext) )
  {
    case 1u:
      goto $LN9_65;
    case 2u:
      goto $LN8_51;
    case 3u:
      goto $LN7_88;
    case 4u:
      goto $LN6_43;
    case 5u:
      goto $LN5_40;
    case 6u:
      duration = Scr_GetInt(scrContext, 5u);
$LN5_40:
      depthTest = Scr_GetInt(scrContext, 4u);
$LN6_43:
      Scr_GetVector(scrContext, 3u, (vec3_t *)&color);
$LN7_88:
      Scr_GetVector(scrContext, 2u, &vectorValue);
$LN8_51:
      Scr_GetVector(scrContext, 1u, &v10);
$LN9_65:
      Scr_GetVector(scrContext, 0, &origin);
      __asm
      {
        vmovss  xmm3, cs:__real@3f000000
        vmulss  xmm0, xmm3, dword ptr [rsp+0C8h+var_98+4]
        vmulss  xmm1, xmm3, dword ptr [rsp+0C8h+var_98]
        vmulss  xmm2, xmm3, dword ptr [rsp+0C8h+var_98+8]
        vmovss  dword ptr [rsp+0C8h+box.halfSize+4], xmm0
        vxorps  xmm0, xmm0, xmm0
        vmovss  dword ptr [rsp+0C8h+box.midPoint], xmm0
        vmovss  dword ptr [rsp+0C8h+box.midPoint+4], xmm0
        vmovss  dword ptr [rsp+0C8h+box.midPoint+8], xmm0
        vmovss  dword ptr [rsp+0C8h+box.halfSize], xmm1
        vmovss  dword ptr [rsp+0C8h+box.halfSize+8], xmm2
      }
      AnglesToAxis(&vectorValue, &axis);
      G_DebugBoxOriented(&origin, &box, &axis, &color, depthTest, duration);
      break;
    default:
      Scr_Error(COM_ERR_3964, scrContext, "illegal call to OrientedBox()");
      break;
  }
}

/*
==============
Scr_GetWeaponFlashTagname
==============
*/
void Scr_GetWeaponFlashTagname(scrContext_t *scrContext)
{
  ComErrorCode v2; 
  const char *String; 
  const char *v4; 
  scr_string_t PrimaryTagName; 
  bool outIsAlternate; 
  TagPair result; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( outWeapon.weaponIdx )
  {
    BG_GetWeaponFlashTagname(&result, &outWeapon, 0, 0);
    PrimaryTagName = TagPair::GetPrimaryTagName(&result);
    Scr_AddConstString(scrContext, PrimaryTagName);
  }
  else
  {
    if ( Scr_GetType(scrContext, 0) == VAR_STRING )
    {
      v2 = COM_ERR_4616;
      String = Scr_GetString(scrContext, 0);
      v4 = j_va("Unknown weapon name \"%s\"\n", String);
    }
    else
    {
      v2 = COM_ERR_4617;
      v4 = "Unknown weapon specified for GetWeaponFlashTagname\n";
    }
    Scr_Error(v2, scrContext, v4);
  }
}

/*
==============
GScr_RemoteCameraSoundscapeOn
==============
*/
void GScr_RemoteCameraSoundscapeOn(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gclient_s *client; 

  Entity = GetEntity(entref);
  client = Entity->client;
  if ( !client )
  {
    Scr_ObjectError(COM_ERR_4618, scrContext, "not a player entity");
    client = Entity->client;
  }
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal(&client->ps.otherFlags, ACTIVE, 5u);
}

/*
==============
GScr_DebugAxis
==============
*/

void __fastcall GScr_DebugAxis(scrContext_t *scrContext, double _XMM1_8)
{
  int duration; 
  int depthTest; 
  char v12; 
  char v13; 
  vec3_t vectorValue; 
  vec3_t pos; 
  tmat33_t<vec3_t> axis; 
  char v28; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-18h], xmm6
    vmovaps xmmword ptr [rax-38h], xmm9
    vmovss  xmm9, cs:__real@41800000
    vmovss  xmm6, cs:__real@3f800000
  }
  duration = 1;
  depthTest = 0;
  switch ( Scr_GetNumParam(scrContext) )
  {
    case 1u:
      goto $LN13_46;
    case 2u:
      goto $LN11_53;
    case 3u:
      goto $LN7_89;
    case 4u:
      goto $LN6_44;
    case 5u:
      goto $LN5_41;
    case 6u:
      duration = Scr_GetInt(scrContext, 5u);
$LN5_41:
      depthTest = Scr_GetInt(scrContext, 4u);
$LN6_44:
      if ( Scr_GetType(scrContext, 3u) )
      {
        __asm { vmovaps [rsp+0B8h+var_28], xmm8 }
        *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
        __asm
        {
          vxorps  xmm8, xmm8, xmm8
          vcomiss xmm0, xmm8
          vmovaps xmm6, xmm0
        }
        if ( v12 )
          goto LABEL_7;
        __asm { vcomiss xmm0, cs:__real@40000000 }
        if ( !(v12 | v13) )
LABEL_7:
          Scr_Error(COM_ERR_5914, scrContext, "Bad call to DebugAxis().  ColorScale must be a multiplier float between 0.0 and 2.0");
        __asm
        {
          vmovss  xmm2, cs:__real@40000000; max
          vxorps  xmm1, xmm1, xmm1; min
          vmovaps xmm0, xmm6; val
        }
        *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
        __asm
        {
          vmovaps xmm8, [rsp+0B8h+var_28]
          vmovaps xmm6, xmm0
        }
      }
$LN7_89:
      if ( Scr_GetType(scrContext, 2u) )
      {
        *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
        __asm { vmovaps xmm9, xmm0 }
      }
$LN11_53:
      Scr_GetVector(scrContext, 1u, &vectorValue);
$LN13_46:
      Scr_GetVector(scrContext, 0, &pos);
      AnglesToAxis(&vectorValue, &axis);
      __asm
      {
        vmovaps xmm3, xmm6; colorScale
        vmovaps xmm2, xmm9; length
      }
      G_DebugAxisWithColor(&axis, &pos, *(float *)&_XMM2, *(float *)&_XMM3, depthTest, duration);
      break;
    default:
      Scr_Error(COM_ERR_5915, scrContext, "Bad call to DebugAxis().  Mandatory parameters are the origin and angles.");
      break;
  }
  _R11 = &v28;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm9, xmmword ptr [r11-30h]
  }
}

/*
==============
GScr_RemoteCameraSoundscapeOff
==============
*/
void GScr_RemoteCameraSoundscapeOff(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gclient_s *client; 

  Entity = GetEntity(entref);
  client = Entity->client;
  if ( !client )
  {
    Scr_ObjectError(COM_ERR_4619, scrContext, "not a player entity");
    client = Entity->client;
  }
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal(&client->ps.otherFlags, ACTIVE, 5u);
}

/*
==============
GScr_Sphere
==============
*/
void GScr_Sphere(scrContext_t *scrContext)
{
  int duration; 
  int Int; 
  unsigned int v7; 
  unsigned int v8; 
  unsigned int v9; 
  unsigned int v10; 
  vec4_t color; 
  vec3_t vectorValue; 

  __asm
  {
    vmovaps [rsp+78h+var_18], xmm6
    vmovups xmm0, cs:__xmm@3f8000003f8000003f8000003f800000
    vmovups xmmword ptr [rsp+78h+color], xmm0
  }
  duration = 1;
  __asm { vxorps  xmm6, xmm6, xmm6 }
  Int = 0;
  v7 = Scr_GetNumParam(scrContext) - 1;
  if ( !v7 )
    goto LABEL_11;
  v8 = v7 - 1;
  if ( !v8 )
  {
LABEL_10:
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
    __asm { vmovaps xmm6, xmm0 }
LABEL_11:
    Scr_GetVector(scrContext, 0, &vectorValue);
    __asm { vmovaps xmm1, xmm6; radius }
    G_DebugSphere(&vectorValue, *(float *)&_XMM1, &color, Int, duration);
    goto LABEL_12;
  }
  v9 = v8 - 1;
  if ( !v9 )
  {
LABEL_9:
    Scr_GetVector(scrContext, 2u, (vec3_t *)&color);
    goto LABEL_10;
  }
  v10 = v9 - 1;
  if ( !v10 )
  {
LABEL_8:
    Int = Scr_GetInt(scrContext, 3u);
    goto LABEL_9;
  }
  if ( v10 == 1 )
  {
    duration = Scr_GetInt(scrContext, 4u);
    goto LABEL_8;
  }
  Scr_Error(COM_ERR_3965, scrContext, "illegal call to Sphere()");
LABEL_12:
  __asm { vmovaps xmm6, [rsp+78h+var_18] }
}

/*
==============
GScr_Cylinder
==============
*/
void GScr_Cylinder(scrContext_t *scrContext)
{
  int duration; 
  int depthTest; 
  vec4_t color; 
  vec3_t vectorValue; 
  vec3_t start; 

  __asm
  {
    vmovaps [rsp+88h+var_18], xmm6
    vmovups xmm0, cs:__xmm@3f8000003f8000003f8000003f800000
    vmovups xmmword ptr [rsp+88h+color], xmm0
  }
  duration = 1;
  __asm { vxorps  xmm6, xmm6, xmm6 }
  depthTest = 0;
  switch ( Scr_GetNumParam(scrContext) )
  {
    case 1u:
      goto $LN9_66;
    case 2u:
      goto $LN8_52;
    case 3u:
      goto $LN7_90;
    case 4u:
      goto $LN6_45;
    case 5u:
      goto $LN5_42;
    case 6u:
      duration = Scr_GetInt(scrContext, 5u);
$LN5_42:
      depthTest = Scr_GetInt(scrContext, 4u);
$LN6_45:
      Scr_GetVector(scrContext, 3u, (vec3_t *)&color);
$LN7_90:
      *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
      __asm { vmovaps xmm6, xmm0 }
$LN8_52:
      Scr_GetVector(scrContext, 1u, &vectorValue);
$LN9_66:
      Scr_GetVector(scrContext, 0, &start);
      __asm { vmovaps xmm2, xmm6; radius }
      G_DebugCylinder(&start, &vectorValue, *(float *)&_XMM2, &color, depthTest, duration);
      break;
    default:
      Scr_Error(COM_ERR_3966, scrContext, "illegal call to Cylinder()");
      break;
  }
  __asm { vmovaps xmm6, [rsp+88h+var_18] }
}

/*
==============
GScrCmd_SetWeaponHudIconOverride
==============
*/
void GScrCmd_SetWeaponHudIconOverride(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int v2; 
  unsigned int entnum; 
  gentity_s *v5; 
  const char *v6; 
  scr_string_t ConstString; 
  scr_string_t v8; 
  __int64 v9; 
  const char *v10; 
  bool v11; 
  gclient_s *client; 
  unsigned int outWeaponTypeIndex; 

  v2 = 0;
  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v5 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 22313, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v5 = &g_entities[entnum];
    if ( !v5->client )
    {
      v6 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v6);
    }
  }
  ConstString = Scr_GetConstString(scrContext, 0);
  v8 = Scr_GetConstString(scrContext, 1u);
  GetWeaponHudIconOverrideIndex(scrContext, ConstString, &outWeaponTypeIndex);
  v9 = (int)outWeaponTypeIndex;
  if ( v8 != scr_const.none )
  {
    v10 = SL_ConvertToString(v8);
    if ( !GConfigStrings::ms_gConfigStrings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_configstrings.h", 71, ASSERT_TYPE_ASSERT, "( ms_gConfigStrings )", (const char *)&queryFormat, "ms_gConfigStrings") )
      __debugbreak();
    v2 = GConfigStrings::ms_gConfigStrings->GetMaterialIndex(GConfigStrings::ms_gConfigStrings, v10);
  }
  v11 = Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_STILL_LAND|0x80);
  client = v5->client;
  if ( v11 )
  {
    client->ps.weaponHudIconOverrides[v9] = v2;
    BG_SetWeaponHudIconOverrideAmmo(&v5->client->ps, v9, -1);
  }
  else
  {
    client->sess.weaponHudIconOverrides[v9] = v2;
  }
}

/*
==============
GScr_AddDebugCommand
==============
*/
void GScr_AddDebugCommand(scrContext_t *scrContext)
{
  const char *String; 
  int v2; 
  int v3; 
  scrContext_t *v4; 

  String = Scr_GetString(scrContext, 0);
  Sys_EnterCriticalSection(CRITSECT_CBUF);
  v2 = strlen_noncrt(String);
  v3 = v2;
  if ( s_cmd_textArray[0].cmdsize + v2 < s_cmd_textArray[0].maxsize )
  {
    memcpy_noncrt(&s_cmd_textArray[0].data[s_cmd_textArray[0].cmdsize], String, v2 + 1);
    s_cmd_textArray[0].cmdsize += v3;
    v4 = ScriptContext_Server();
    Scr_MonitorCommand(v4, String);
  }
  else
  {
    Com_Printf(16, "Cbuf_AddText: overflow (adding '%s')\n", String);
  }
  Sys_LeaveCriticalSection(CRITSECT_CBUF);
}

/*
==============
GScr_IsValidMissile
==============
*/
void GScr_IsValidMissile(scrContext_t *scrContext)
{
  if ( Scr_GetType(scrContext, 0) == VAR_POINTER && Scr_GetPointerType(scrContext, 0) == VAR_ENTITY && GScr_GetEntity(0)->s.eType == ET_MISSILE )
    Scr_AddInt(scrContext, 1);
  else
    Scr_AddInt(scrContext, 0);
}

/*
==============
GScr_IsSentient
==============
*/
void GScr_IsSentient(scrContext_t *scrContext)
{
  if ( Scr_GetType(scrContext, 0) == VAR_POINTER && Scr_GetPointerType(scrContext, 0) == VAR_ENTITY && GScr_GetEntity(0)->sentient )
    Scr_AddInt(scrContext, 1);
  else
    Scr_AddInt(scrContext, 0);
}

/*
==============
GScr_GetIndexForLuiNCString
==============
*/
void GScr_GetIndexForLuiNCString(scrContext_t *scrContext)
{
  const char *String; 
  unsigned int luiStringIndex; 

  String = Scr_GetString(scrContext, 0);
  if ( NetConstStrings_GetLuiStringIndex(String, &luiStringIndex) || (Com_PrintError(24, "%s not found in the Lui NetConstStrings. Did you add it to ncsLuiStrings.txt? Returning index for 'unknown' instead.", String), NetConstStrings_GetLuiStringIndex("unknown", &luiStringIndex)) )
    Scr_AddInt(scrContext, luiStringIndex);
  else
    Com_ScriptError("Couldn't find 'unknown' in the Lui NetConstStrings.");
}

/*
==============
GScrCmd_GetWeaponHudIconOverride
==============
*/
void GScrCmd_GetWeaponHudIconOverride(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  scr_string_t ConstString; 
  bool v7; 
  gclient_s *client; 
  unsigned int v9; 
  unsigned int outWeaponTypeIndex[4]; 
  char value[64]; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 22363, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  ConstString = Scr_GetConstString(scrContext, 0);
  GetWeaponHudIconOverrideIndex(scrContext, ConstString, outWeaponTypeIndex);
  v7 = Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_STILL_LAND|0x80);
  client = v4->client;
  if ( v7 )
    v9 = client->ps.weaponHudIconOverrides[outWeaponTypeIndex[0]];
  else
    v9 = client->sess.weaponHudIconOverrides[outWeaponTypeIndex[0]];
  if ( v9 )
  {
    if ( !GConfigStrings::ms_gConfigStrings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_configstrings.h", 71, ASSERT_TYPE_ASSERT, "( ms_gConfigStrings )", (const char *)&queryFormat, "ms_gConfigStrings") )
      __debugbreak();
    GConfigStrings::ms_gConfigStrings->GetMaterialName(GConfigStrings::ms_gConfigStrings, v9, value, 64);
    Scr_AddString(scrContext, value);
  }
  else
  {
    Scr_AddConstString(scrContext, scr_const.none);
  }
}

/*
==============
GScrCmd_SetWeaponHudIconOverrideAmmo
==============
*/
void GScrCmd_SetWeaponHudIconOverrideAmmo(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  scr_string_t ConstString; 
  int Int; 
  unsigned int outWeaponTypeIndex; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 22414, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  ConstString = Scr_GetConstString(scrContext, 0);
  Int = Scr_GetInt(scrContext, 1u);
  GetWeaponHudIconOverrideIndex(scrContext, ConstString, &outWeaponTypeIndex);
  if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_STILL_LAND|0x80) )
    BG_SetWeaponHudIconOverrideAmmo(&v4->client->ps, outWeaponTypeIndex, Int);
}

/*
==============
GScrCmd_GetWeaponHudIconOverrideAmmo
==============
*/
void GScrCmd_GetWeaponHudIconOverrideAmmo(scrContext_t *scrContext, scr_entref_t entref)
{
  int WeaponHudIconOverrideAmmo; 
  unsigned int entnum; 
  gentity_s *v5; 
  const char *v6; 
  scr_string_t ConstString; 
  unsigned int outWeaponTypeIndex; 

  WeaponHudIconOverrideAmmo = 0;
  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v5 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 22451, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v5 = &g_entities[entnum];
    if ( !v5->client )
    {
      v6 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v6);
    }
  }
  ConstString = Scr_GetConstString(scrContext, 0);
  GetWeaponHudIconOverrideIndex(scrContext, ConstString, &outWeaponTypeIndex);
  if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_STILL_LAND|0x80) )
    WeaponHudIconOverrideAmmo = BG_GetWeaponHudIconOverrideAmmo(&v5->client->ps, outWeaponTypeIndex);
  Scr_AddInt(scrContext, WeaponHudIconOverrideAmmo);
}

/*
==============
GScr_SetOmnvar
==============
*/
void GScr_SetOmnvar(scrContext_t *scrContext)
{
  const char *String; 
  unsigned int IndexByName; 
  const char *v4; 
  const OmnvarDef *Def; 
  const char *v6; 
  OmnvarData *Data; 

  String = Scr_GetString(scrContext, 0);
  IndexByName = BG_Omnvar_GetIndexByName(String);
  if ( IndexByName == -1 )
  {
    v4 = j_va("SetOmnvar - '%s' not found", String);
    Scr_Error(COM_ERR_3975, scrContext, v4);
  }
  Def = BG_Omnvar_GetDef(IndexByName);
  if ( (Def->flags & 2) != 0 )
  {
    v6 = j_va("SetOmnvar '%s' must be done on a game-scope Omnvar", String);
    Scr_Error(COM_ERR_3976, scrContext, v6);
  }
  Data = G_Omnvar_GetData(IndexByName, -1, NULL);
  GScr_SetOmnvarInternal(scrContext, Def, Data, 1);
}

/*
==============
GScr_SetOmnvarBit
==============
*/
void GScr_SetOmnvarBit(scrContext_t *scrContext)
{
  const char *String; 
  unsigned int IndexByName; 
  const char *v4; 
  const OmnvarDef *Def; 
  const char *v6; 
  OmnvarData *Data; 
  OmnvarValue current; 
  unsigned int NumParam; 
  const char *v10; 
  const char *v11; 
  char Int; 
  int v13; 
  const char *v14; 

  String = Scr_GetString(scrContext, 0);
  IndexByName = BG_Omnvar_GetIndexByName(String);
  if ( IndexByName == -1 )
  {
    v4 = j_va("SetOmnvarBit - '%s' not found", String);
    Scr_Error(COM_ERR_3977, scrContext, v4);
  }
  Def = BG_Omnvar_GetDef(IndexByName);
  if ( (Def->flags & 2) != 0 )
  {
    v6 = j_va("SetOmnvar '%s' must be done on a game-scope Omnvar", String);
    Scr_Error(COM_ERR_3978, scrContext, v6);
  }
  Data = G_Omnvar_GetData(IndexByName, -1, NULL);
  current = Data->current;
  NumParam = Scr_GetNumParam(scrContext);
  if ( Def->type != OMNVAR_TYPE_UINT || Def->userType != OMNVAR_USER_TYPE_BIT_FIELD )
  {
    v10 = j_va("SetOmnvarBit - '%s' expects a bit field omnvar", String);
    Scr_Error(COM_ERR_3979, scrContext, v10);
  }
  if ( NumParam != 3 )
  {
    v11 = j_va("SetOmnvarBit - '%s' expects three paramaters: <bit field omnvar>, <index>, and <value>", String);
    Scr_Error(COM_ERR_3980, scrContext, v11);
  }
  Int = Scr_GetInt(scrContext, 1u);
  v13 = Scr_GetInt(scrContext, 2u);
  if ( v13 == 1 )
  {
    current.integer |= 1 << Int;
  }
  else if ( v13 )
  {
    v14 = j_va("SetOmnvarBit - '%s' third parameter should be a boolean.", String);
    Scr_Error(COM_ERR_3981, scrContext, v14);
  }
  else
  {
    current.integer &= ~(1 << Int);
  }
  Data->current = current;
  G_Omnvar_MarkChanged(Data);
}

/*
==============
GScr_SetEMPJammed
==============
*/
void GScr_SetEMPJammed(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *p_otherFlags; 

  Entity = GetEntity(entref);
  if ( !Entity->client )
    Scr_Error(COM_ERR_4621, scrContext, "SetEMPJammed: Entity must be a player entity");
  Int = Scr_GetInt(scrContext, 0);
  p_otherFlags = &Entity->client->ps.otherFlags;
  if ( Int )
    GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal(p_otherFlags, ACTIVE, 0xAu);
  else
    GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal(p_otherFlags, ACTIVE, 0xAu);
}

/*
==============
ScrCmd_WorldPointToScreenPos
==============
*/
void ScrCmd_WorldPointToScreenPos(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v6; 
  const char *v7; 
  char v13; 
  const char *VariantString; 
  int v15; 
  vec2_t outScreenPos; 
  float value[4]; 
  vec3_t vectorValue; 
  vec3_t outOrigin; 
  tmat33_t<vec3_t> outForward; 
  char v33; 

  __asm { vmovaps [rsp+0B8h+var_18], xmm6 }
  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v6 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 22526, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v6 = &g_entities[entnum];
    if ( !v6->client )
    {
      v7 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v7);
    }
  }
  Scr_GetVector(scrContext, 0, &vectorValue);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm { vmovaps xmm6, xmm0 }
  G_Client_GetViewOrigin(&v6->client->ps, &outOrigin);
  G_Client_GetViewDirectionLinked(v6, outForward.m, &outForward.m[1], &outForward.m[2]);
  __asm { vmovaps xmm2, xmm6; viewFOV }
  G_Main_WorldPointToScreenPos(&outOrigin, &outForward, *(float *)&_XMM2, &vectorValue, &outScreenPos);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, eax
    vxorps  xmm6, xmm6, xmm6
    vucomiss xmm0, xmm6
  }
  if ( v13 )
    goto LABEL_12;
  VariantString = Dvar_GetVariantString("TQQKORSSM");
  v15 = atoi(VariantString);
  __asm
  {
    vmovss  xmm4, dword ptr [rsp+0B8h+outScreenPos]
    vmovss  xmm3, dword ptr cs:__xmm@7fffffff7fffffff7fffffff7fffffff
    vandps  xmm0, xmm4, xmm3
    vcvtss2sd xmm2, xmm0, xmm0
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2sd xmm0, xmm0, ecx
    vmulsd  xmm1, xmm0, cs:__real@3fe0000000000000
    vcomisd xmm2, xmm1
  }
  if ( v15 )
  {
LABEL_12:
    Scr_AddUndefined(scrContext);
  }
  else
  {
    __asm
    {
      vmovss  xmm1, dword ptr [rsp+0B8h+outScreenPos+4]
      vandps  xmm0, xmm1, xmm3
      vcomiss xmm0, cs:__real@43700000
      vmovss  [rsp+0B8h+value], xmm4
      vmovss  [rsp+0B8h+var_7C], xmm1
      vmovss  [rsp+0B8h+var_78], xmm6
    }
    Scr_AddVector(scrContext, value);
  }
  _R11 = &v33;
  __asm { vmovaps xmm6, xmmword ptr [r11-10h] }
}

/*
==============
GScr_GetOmnvar
==============
*/
void GScr_GetOmnvar(scrContext_t *scrContext)
{
  const char *String; 
  unsigned int IndexByName; 
  const char *v4; 
  const OmnvarDef *Def; 
  const char *v6; 
  unsigned int v8; 
  OmnvarValue current; 
  char Int; 
  __int64 v12; 
  char *outStringValue; 

  String = Scr_GetString(scrContext, 0);
  IndexByName = BG_Omnvar_GetIndexByName(String);
  if ( IndexByName == -1 )
  {
    v4 = j_va("GetOmnvar - '%s' not found", String);
    Scr_Error(COM_ERR_3982, scrContext, v4);
  }
  Def = BG_Omnvar_GetDef(IndexByName);
  if ( (Def->flags & 2) != 0 )
  {
    v6 = j_va("GetOmnvar '%s' must be done on a a game-scope Omnvar", String);
    Scr_Error(COM_ERR_3983, scrContext, v6);
  }
  _RBX = G_Omnvar_GetData(IndexByName, -1, NULL);
  switch ( Def->type )
  {
    case OMNVAR_TYPE_BOOL:
      Scr_AddBool(scrContext, _RBX->current.enabled);
      break;
    case OMNVAR_TYPE_FLOAT:
      __asm { vmovss  xmm1, dword ptr [rbx+4]; jumptable 0000000141308031 case 1 }
      Scr_AddFloat(scrContext, *(float *)&_XMM1);
      break;
    case OMNVAR_TYPE_INT:
      if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_omnvar.h", 207, ASSERT_TYPE_ASSERT, "(data)", (const char *)&queryFormat, "data") )
        __debugbreak();
      if ( Def->type != OMNVAR_TYPE_INT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_omnvar.h", 208, ASSERT_TYPE_ASSERT, "(def->type == OMNVAR_TYPE_INT)", (const char *)&queryFormat, "def->type == OMNVAR_TYPE_INT") )
        __debugbreak();
      v8 = Def->minvalue + _RBX->current.integer;
      if ( Def->userType != OMNVAR_USER_TYPE_ENTITY )
        goto LABEL_23;
      if ( v8 != 2047 )
      {
        if ( v8 >= 0x7FE )
        {
          LODWORD(v12) = v8;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 2299, ASSERT_TYPE_ASSERT, "(unsigned)( omnvarValue ) < (unsigned)( ENTITYNUM_ORDINARY_END )", "omnvarValue doesn't index ENTITYNUM_ORDINARY_END\n\t%i not in [0, %i)", v12, 2046) )
            __debugbreak();
        }
        GScr_AddEntity(&g_entities[v8]);
      }
      break;
    case OMNVAR_TYPE_UINT:
      current = _RBX->current;
      if ( Def->userType != OMNVAR_USER_TYPE_BIT_FIELD || Scr_GetNumParam(scrContext) != 2 )
        goto $LN13_47;
      Int = Scr_GetInt(scrContext, 1u);
      v8 = (current.integer & (unsigned int)(1 << Int)) >> Int;
LABEL_23:
      Scr_AddInt(scrContext, v8);
      break;
    case OMNVAR_TYPE_TIME:
$LN13_47:
      Scr_AddInt(scrContext, _RBX->current.integer);
      break;
    case OMNVAR_TYPE_NCS_LUI:
      outStringValue = NULL;
      BG_Omnvar_GetNCString(Def, _RBX, (const char **)&outStringValue);
      if ( !outStringValue && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 2338, ASSERT_TYPE_ASSERT, "(stringValue)", (const char *)&queryFormat, "stringValue") )
        __debugbreak();
      Scr_AddString(scrContext, outStringValue);
      break;
    default:
      Scr_Error(COM_ERR_3984, scrContext, "SetOmnvar - Type for paramater 1 not recognized");
      break;
  }
}

/*
==============
GScr_SetDvar
==============
*/
void GScr_SetDvar(scrContext_t *scrContext)
{
  const char *String; 
  const char *UnobfuscatedName; 
  const char *v4; 
  GScript *v5; 
  void (__fastcall *ConstructMessageString)(GScript *, scrContext_t *, int, int, const char *, char *, unsigned int); 
  unsigned int NumParam; 
  char *v8; 
  bool v9; 
  unsigned int v10; 
  char inString[1024]; 
  char outString[1024]; 

  String = Scr_GetString(scrContext, 0);
  if ( !Dvar_IsValidName(String) )
  {
    UnobfuscatedName = Dvar_DevGetUnobfuscatedName(String);
    v4 = j_va("Dvar %s has an invalid dvar name", UnobfuscatedName);
    Scr_Error(COM_ERR_3986, scrContext, v4);
  }
  if ( Scr_GetType(scrContext, 1u) == VAR_ISTRING )
  {
    if ( !GScript::ms_gScriptSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.h", 183, ASSERT_TYPE_ASSERT, "( ms_gScriptSystem )", (const char *)&queryFormat, "ms_gScriptSystem") )
      __debugbreak();
    v5 = GScript::ms_gScriptSystem;
    ConstructMessageString = GScript::ms_gScriptSystem->ConstructMessageString;
    NumParam = Scr_GetNumParam(scrContext);
    ConstructMessageString(v5, scrContext, 1, NumParam - 1, "Dvar Value", inString, 1024u);
    v8 = inString;
  }
  else
  {
    v8 = (char *)Scr_GetString(scrContext, 1u);
  }
  Com_CleanStringForNetwork(v8, outString, 1024);
  v9 = Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_SLOW_SOFT_LAND|0x80);
  v10 = 525448;
  if ( v9 )
    v10 = -1;
  GScr_SetDvar_Internal(scrContext, String, outString, v10);
}

/*
==============
GScr_SetDynamicDvar
==============
*/
void GScr_SetDynamicDvar(scrContext_t *scrContext)
{
  const char *String; 
  const char *UnobfuscatedName; 
  const char *v4; 
  GScript *v5; 
  void (__fastcall *ConstructMessageString)(GScript *, scrContext_t *, int, int, const char *, char *, unsigned int); 
  unsigned int NumParam; 
  char *v8; 
  char inString[1024]; 
  char outString[1024]; 

  if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_SLOW_SOFT_LAND|0x80) )
    Scr_Error(COM_ERR_3987, scrContext, "SetDynamicDvar is only necessary in Multiplayer. Use SetDvar instead.");
  String = Scr_GetString(scrContext, 0);
  if ( !Dvar_IsValidName(String) )
  {
    UnobfuscatedName = Dvar_DevGetUnobfuscatedName(String);
    v4 = j_va("Dvar %s has an invalid dvar name", UnobfuscatedName);
    Scr_Error(COM_ERR_3988, scrContext, v4);
  }
  if ( Scr_GetType(scrContext, 1u) == VAR_ISTRING )
  {
    if ( !GScript::ms_gScriptSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.h", 183, ASSERT_TYPE_ASSERT, "( ms_gScriptSystem )", (const char *)&queryFormat, "ms_gScriptSystem") )
      __debugbreak();
    v5 = GScript::ms_gScriptSystem;
    ConstructMessageString = GScript::ms_gScriptSystem->ConstructMessageString;
    NumParam = Scr_GetNumParam(scrContext);
    ConstructMessageString(v5, scrContext, 1, NumParam - 1, "Dvar Value", inString, 1024u);
    v8 = inString;
  }
  else
  {
    v8 = (char *)Scr_GetString(scrContext, 1u);
  }
  Com_CleanStringForNetwork(v8, outString, 1024);
  Dvar_SetFromStringByNameFromScript(SCRIPTINSTANCE_SERVER, String, outString);
}

/*
==============
GScr_SetDevDvar
==============
*/
void GScr_SetDevDvar(scrContext_t *scrContext)
{
  const char *String; 
  const char *UnobfuscatedName; 
  const char *v4; 
  GScript *v5; 
  void (__fastcall *ConstructMessageString)(GScript *, scrContext_t *, int, int, const char *, char *, unsigned int); 
  unsigned int NumParam; 
  char *v8; 
  bool v9; 
  const dvar_t *VarByName; 
  const char *v11; 
  const char *v12; 
  char inString[1024]; 
  char outString[1024]; 

  String = Scr_GetString(scrContext, 0);
  if ( !Dvar_IsValidName(String) )
  {
    UnobfuscatedName = Dvar_DevGetUnobfuscatedName(String);
    v4 = j_va("Dvar %s has an invalid dvar name", UnobfuscatedName);
    Scr_Error(COM_ERR_3989, scrContext, v4);
  }
  if ( Scr_GetType(scrContext, 1u) == VAR_ISTRING )
  {
    if ( !GScript::ms_gScriptSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.h", 183, ASSERT_TYPE_ASSERT, "( ms_gScriptSystem )", (const char *)&queryFormat, "ms_gScriptSystem") )
      __debugbreak();
    v5 = GScript::ms_gScriptSystem;
    ConstructMessageString = GScript::ms_gScriptSystem->ConstructMessageString;
    NumParam = Scr_GetNumParam(scrContext);
    ConstructMessageString(v5, scrContext, 1, NumParam - 1, "Dvar Value", inString, 1024u);
    v8 = inString;
  }
  else
  {
    v8 = (char *)Scr_GetString(scrContext, 1u);
  }
  Com_CleanStringForNetwork(v8, outString, 1024);
  v9 = Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_SLOW_SOFT_LAND|0x80);
  Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_SLOW_SOFT_LAND|0x80);
  VarByName = Dvar_FindVarByName(String);
  if ( v9 && VarByName && (VarByName->flags & 0x100) == 0 )
  {
    v11 = Dvar_DevGetUnobfuscatedName(String);
    v12 = j_va("Invalid Dvar set: %s - Internal Dvars cannot be changed by script. Use 'setsaveddvar' to alter SAVED internal dvars\n", v11);
    Scr_Error(COM_ERR_3985, scrContext, v12);
  }
  Dvar_SetFromStringByNameFromScript(SCRIPTINSTANCE_SERVER, String, outString);
}

/*
==============
GScr_SetDvarIfUninitialized
==============
*/
void GScr_SetDvarIfUninitialized(scrContext_t *scrContext)
{
  const char *String; 
  const char *Demo_VariantString; 
  const char *v6; 
  bool v7; 
  unsigned int v8; 
  DvarValue v9; 

  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_Error(COM_ERR_3990, scrContext, "GScr_SetDvarIfUninitialized( dvarName, initialValue ) requires two parameters");
  String = Scr_GetString(scrContext, 0);
  g_lastDvarName = String;
  if ( g_archiveGetDvar )
  {
    Demo_VariantString = SV_Game_GetDemo_VariantString(String, (const char *)&queryFormat.fmt + 3);
    goto LABEL_7;
  }
  _RAX = Dvar_FindVarByName(String);
  if ( _RAX )
  {
    __asm
    {
      vmovups xmm0, xmmword ptr [rax+28h]
      vmovups xmmword ptr [rsp+38h+var_18], xmm0
    }
    Demo_VariantString = Dvar_ValueToString(_RAX, &v9);
LABEL_7:
    if ( *Demo_VariantString )
      return;
  }
  v6 = Scr_GetString(scrContext, 1u);
  v7 = Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_SLOW_SOFT_LAND|0x80);
  v8 = 525448;
  if ( v7 )
    v8 = -1;
  GScr_SetDvar_Internal(scrContext, String, v6, v8);
}

/*
==============
GScr_SetDevDvarIfUninitialized
==============
*/
void GScr_SetDevDvarIfUninitialized(scrContext_t *scrContext)
{
  const char *String; 
  const char *Demo_VariantString; 
  const char *v6; 
  bool v7; 
  const dvar_t *VarByName; 
  const char *UnobfuscatedName; 
  const char *v10; 
  DvarValue v11; 

  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_Error(COM_ERR_3991, scrContext, "GScr_SetDevDvarIfUninitialized( dvarName, initialValue ) requires two parameters");
  String = Scr_GetString(scrContext, 0);
  g_lastDvarName = String;
  if ( g_archiveGetDvar )
  {
    Demo_VariantString = SV_Game_GetDemo_VariantString(String, (const char *)&queryFormat.fmt + 3);
    goto LABEL_7;
  }
  _RAX = Dvar_FindVarByName(String);
  if ( _RAX )
  {
    __asm
    {
      vmovups xmm0, xmmword ptr [rax+28h]
      vmovups xmmword ptr [rsp+38h+var_18], xmm0
    }
    Demo_VariantString = Dvar_ValueToString(_RAX, &v11);
LABEL_7:
    if ( *Demo_VariantString )
      return;
  }
  v6 = Scr_GetString(scrContext, 1u);
  v7 = Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_SLOW_SOFT_LAND|0x80);
  Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_SLOW_SOFT_LAND|0x80);
  VarByName = Dvar_FindVarByName(String);
  if ( v7 && VarByName && (VarByName->flags & 0x100) == 0 )
  {
    UnobfuscatedName = Dvar_DevGetUnobfuscatedName(String);
    v10 = j_va("Invalid Dvar set: %s - Internal Dvars cannot be changed by script. Use 'setsaveddvar' to alter SAVED internal dvars\n", UnobfuscatedName);
    Scr_Error(COM_ERR_3985, scrContext, v10);
  }
  Dvar_SetFromStringByNameFromScript(SCRIPTINSTANCE_SERVER, String, v6);
}

/*
==============
GScr_GetDvar
==============
*/
void GScr_GetDvar(scrContext_t *scrContext)
{
  const char *String; 
  unsigned int NumParam; 
  const char *v4; 
  const char *Demo_VariantString; 

  String = (char *)&queryFormat.fmt + 3;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam != 1 )
  {
    if ( NumParam != 2 )
    {
      Scr_Error(COM_ERR_3992, scrContext, "GetDvar( <dvar>, <default> ) takes either one or two parameters");
      return;
    }
    String = Scr_GetString(scrContext, 1u);
  }
  v4 = Scr_GetString(scrContext, 0);
  g_lastDvarName = v4;
  if ( g_archiveGetDvar )
    Demo_VariantString = SV_Game_GetDemo_VariantString(v4, String);
  else
    Demo_VariantString = Dvar_GetVariantStringWithDefault(v4, String);
  Scr_AddString(scrContext, Demo_VariantString);
}

/*
==============
GScr_GetDvarInt
==============
*/
void GScr_GetDvarInt(scrContext_t *scrContext)
{
  const char *String; 
  unsigned int NumParam; 
  const char *v4; 
  const char *Demo_VariantString; 
  int v6; 

  String = (char *)&queryFormat.fmt + 3;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam != 1 )
  {
    if ( NumParam != 2 )
    {
      Scr_Error(COM_ERR_3993, scrContext, "GetDvarInt( <dvar>, <default> ) takes either one or two parameters");
      return;
    }
    String = Scr_GetString(scrContext, 1u);
  }
  v4 = Scr_GetString(scrContext, 0);
  g_lastDvarName = v4;
  if ( g_archiveGetDvar )
    Demo_VariantString = SV_Game_GetDemo_VariantString(v4, String);
  else
    Demo_VariantString = Dvar_GetVariantStringWithDefault(v4, String);
  v6 = atoi(Demo_VariantString);
  Scr_AddInt(scrContext, v6);
}

/*
==============
GScr_GetGameBattleMatchReportState
==============
*/
void GScr_GetGameBattleMatchReportState(scrContext_t *scrContext)
{
  int MatchReportState; 

  MatchReportState = GameBattles_GetMatchReportState();
  Scr_AddInt(scrContext, MatchReportState);
}

/*
==============
GScr_SetGameBattlePlayerStats
==============
*/
void GScr_SetGameBattlePlayerStats(scrContext_t *scrContext)
{
  const char *String; 
  const char *v3; 
  int Int; 
  XUID result; 

  if ( Scr_GetNumParam(scrContext) == 3 )
  {
    String = Scr_GetString(scrContext, 0);
    XUID::FromHexString(&result, String);
    v3 = Scr_GetString(scrContext, 1u);
    Int = Scr_GetInt(scrContext, 2u);
    GameBattles_SetPlayerStats(&result, v3, Int);
  }
  else
  {
    Scr_Error(COM_ERR_6397, scrContext, "GScr_SetGameBattlePlayerStats( xuid, team, score ) requires 3 parameters");
  }
}

/*
==============
GScr_SetGameBattleMatchStats
==============
*/
void GScr_SetGameBattleMatchStats(scrContext_t *scrContext)
{
  const char *String; 
  const char *v3; 
  const char *v4; 
  int Int; 
  int axisScore; 
  int matchStart; 
  int matchEnd; 

  if ( Scr_GetNumParam(scrContext) == 7 )
  {
    String = Scr_GetString(scrContext, 0);
    v3 = Scr_GetString(scrContext, 1u);
    v4 = Scr_GetString(scrContext, 2u);
    Int = Scr_GetInt(scrContext, 3u);
    axisScore = Scr_GetInt(scrContext, 4u);
    matchStart = Scr_GetInt(scrContext, 5u);
    matchEnd = Scr_GetInt(scrContext, 6u);
    GameBattles_SetMatchStats(String, v3, v4, Int, axisScore, matchStart, matchEnd);
  }
  else
  {
    Scr_Error(COM_ERR_6398, scrContext, "GScr_SetGameBattleMatchStats( mapname, gametype, victor, alliesScore, axisScore, matchStart, matchEnd ) requires 7 parameters");
  }
}

/*
==============
GScr_GetDvarFloat
==============
*/
void GScr_GetDvarFloat(scrContext_t *scrContext)
{
  const char *String; 
  unsigned int NumParam; 
  const char *v5; 
  const char *Demo_VariantString; 

  String = (char *)&queryFormat.fmt + 3;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam != 1 )
  {
    if ( NumParam != 2 )
    {
      Scr_Error(COM_ERR_3994, scrContext, "GetDvarFloat( <dvar>, <default> ) takes either one or two parameters");
      return;
    }
    String = Scr_GetString(scrContext, 1u);
  }
  v5 = Scr_GetString(scrContext, 0);
  g_lastDvarName = v5;
  if ( g_archiveGetDvar )
    Demo_VariantString = SV_Game_GetDemo_VariantString(v5, String);
  else
    Demo_VariantString = Dvar_GetVariantStringWithDefault(v5, String);
  *(double *)&_XMM0 = atof(Demo_VariantString);
  __asm { vcvtsd2ss xmm1, xmm0, xmm0; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
GScr_GetDvarVector
==============
*/
void GScr_GetDvarVector(scrContext_t *scrContext)
{
  const char *String; 
  unsigned int NumParam; 
  const char *v4; 
  const char *Demo_VariantString; 
  const char *v6; 
  const char *UnobfuscatedName; 
  const char *v8; 
  vec3_t vec3Value; 

  String = "0.0 0.0 0.0";
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam != 1 )
  {
    if ( NumParam != 2 )
    {
      Scr_Error(COM_ERR_3995, scrContext, "GetDvarVector( <dvar>, <default> ) takes either one or two parameters");
      return;
    }
    String = Scr_GetString(scrContext, 1u);
  }
  v4 = Scr_GetString(scrContext, 0);
  g_lastDvarName = v4;
  if ( g_archiveGetDvar )
    Demo_VariantString = SV_Game_GetDemo_VariantString(v4, String);
  else
    Demo_VariantString = Dvar_GetVariantStringWithDefault(v4, String);
  v6 = Demo_VariantString;
  if ( !Dvar_ConvertStringToVec3(Demo_VariantString, &vec3Value) )
  {
    UnobfuscatedName = Dvar_DevGetUnobfuscatedName(v4);
    v8 = j_va("GetDvarVector: Dvar %s '%s' isn't parsable as a vector\n", UnobfuscatedName, v6);
    Scr_Error(COM_ERR_3996, scrContext, v8);
  }
  Scr_AddVector(scrContext, vec3Value.v);
}

/*
==============
GScr_GetTime
==============
*/
void GScr_GetTime(scrContext_t *scrContext)
{
  Scr_AddInt(scrContext, level.time);
}

/*
==============
Scr_GetEntByNum
==============
*/
void Scr_GetEntByNum(scrContext_t *scrContext)
{
  unsigned int Int; 
  const gentity_s *v2; 

  Int = Scr_GetInt(scrContext, 0);
  if ( Int < 0x800 )
  {
    v2 = &g_entities[Int];
    if ( G_IsEntityInUse(Int) )
      GScr_AddEntity(v2);
  }
}

/*
==============
Scr_GetWeaponModel
==============
*/
void Scr_GetWeaponModel(scrContext_t *scrContext)
{
  unsigned __int16 weaponIdx; 
  bool v3; 
  WeaponDef **v4; 
  const XModel *worldModel; 
  const char *Name; 
  const char *WeaponBaseName; 
  int v8; 
  unsigned int v9; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  weaponIdx = outWeapon.weaponIdx;
  if ( !outWeapon.weaponIdx )
    goto LABEL_11;
  if ( outWeapon.weaponIdx > bg_lastParsedWeaponIndex )
  {
    v9 = bg_lastParsedWeaponIndex;
    v8 = outWeapon.weaponIdx;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1203, ASSERT_TYPE_ASSERT, "( weaponIdx ) <= ( bg_lastParsedWeaponIndex )", "weaponIdx not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", v8, v9) )
      __debugbreak();
  }
  v3 = bg_weaponDefs[weaponIdx] == NULL;
  v4 = &bg_weaponDefs[weaponIdx];
  if ( v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1204, ASSERT_TYPE_ASSERT, "(bg_weaponDefs[weaponIdx])", (const char *)&queryFormat, "bg_weaponDefs[weaponIdx]") )
    __debugbreak();
  worldModel = (*v4)->worldModel;
  if ( !worldModel )
  {
    WeaponBaseName = BG_GetWeaponBaseName(&outWeapon, outIsAlternate);
    Com_Printf(17, "getWeaponModel: weapon '%s' does not have a world model\n", WeaponBaseName);
LABEL_11:
    Name = (char *)&queryFormat.fmt + 3;
    goto LABEL_12;
  }
  Name = XModelGetName(worldModel);
LABEL_12:
  Scr_AddString(scrContext, Name);
}

/*
==============
Scr_GetWeaponViewmodel
==============
*/
void Scr_GetWeaponViewmodel(scrContext_t *scrContext)
{
  unsigned __int16 weaponIdx; 
  const char *Name; 
  bool v4; 
  WeaponDef **v5; 
  const XModel *gunXModel; 
  const char *WeaponBaseName; 
  int v8; 
  unsigned int v9; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  weaponIdx = outWeapon.weaponIdx;
  Name = (char *)&queryFormat.fmt + 3;
  if ( outWeapon.weaponIdx )
  {
    if ( outWeapon.weaponIdx > bg_lastParsedWeaponIndex )
    {
      v9 = bg_lastParsedWeaponIndex;
      v8 = outWeapon.weaponIdx;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1203, ASSERT_TYPE_ASSERT, "( weaponIdx ) <= ( bg_lastParsedWeaponIndex )", "weaponIdx not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", v8, v9) )
        __debugbreak();
    }
    v4 = bg_weaponDefs[weaponIdx] == NULL;
    v5 = &bg_weaponDefs[weaponIdx];
    if ( v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1204, ASSERT_TYPE_ASSERT, "(bg_weaponDefs[weaponIdx])", (const char *)&queryFormat, "bg_weaponDefs[weaponIdx]") )
      __debugbreak();
    gunXModel = (*v5)->gunXModel;
    if ( !gunXModel || (Name = XModelGetName(gunXModel), !*Name) )
    {
      WeaponBaseName = BG_GetWeaponBaseName(&outWeapon, outIsAlternate);
      Com_Printf(17, "getWeaponViewmodel: weapon '%s' does not have a viewmodel\n", WeaponBaseName);
    }
  }
  Scr_AddString(scrContext, Name);
}

/*
==============
Scr_GetWeaponBaseName
==============
*/
void Scr_GetWeaponBaseName(scrContext_t *scrContext)
{
  const char *WeaponBaseName; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( outWeapon.weaponIdx )
  {
    WeaponBaseName = BG_GetWeaponBaseName(&outWeapon, outIsAlternate);
    Scr_AddString(scrContext, WeaponBaseName);
  }
  else
  {
    Scr_AddConstString(scrContext, scr_const.none);
  }
}

/*
==============
Scr_GetWeaponAttachments
==============
*/
void Scr_GetWeaponAttachments(scrContext_t *scrContext)
{
  __int64 AllWeaponAttachments; 
  WeaponAttachment **v3; 
  bool outIsAlternate; 
  Weapon outWeapon; 
  WeaponAttachment *attachments[30]; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( outWeapon.weaponIdx )
  {
    AllWeaponAttachments = BG_GetAllWeaponAttachments(&outWeapon, (const WeaponAttachment **)attachments);
    Scr_MakeArray(scrContext);
    if ( (_DWORD)AllWeaponAttachments )
    {
      v3 = attachments;
      do
      {
        if ( !*v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 3085, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
          __debugbreak();
        Scr_AddConstString(scrContext, (*v3)->internalName);
        Scr_AddArray(scrContext);
        ++v3;
        --AllWeaponAttachments;
      }
      while ( AllWeaponAttachments );
    }
  }
  else
  {
    Scr_AddUndefined(scrContext);
  }
}

/*
==============
Scr_GetWeaponAttachmentWorldModels
==============
*/
void Scr_GetWeaponAttachmentWorldModels(scrContext_t *scrContext)
{
  signed int v2; 
  __int64 i; 
  const XModel *AttachmentModel; 
  bool outIsAlternate; 
  Weapon outWeapon; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( outWeapon.weaponIdx )
  {
    Scr_MakeArray(scrContext);
    v2 = BG_GetAllWeaponAttachmentsWithIds(&outWeapon, (const WeaponAttachment **)attachments, attachmentIds) - 1;
    for ( i = v2; i >= 0; --i )
    {
      if ( !attachments[i] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 3123, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      AttachmentModel = BG_GetAttachmentModel(attachments[i], outWeapon.attachmentVariationIndices[attachmentIds[i]], 0);
      if ( AttachmentModel )
      {
        Scr_AddString(scrContext, AttachmentModel->name);
        Scr_AddArray(scrContext);
      }
    }
  }
  else
  {
    Scr_AddUndefined(scrContext);
  }
}

/*
==============
Scr_GetWeaponCamoName
==============
*/
void Scr_GetWeaponCamoName(scrContext_t *scrContext)
{
  const Camo *Camo; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( outWeapon.weaponIdx )
  {
    Camo = BG_Camo_GetCamo(outWeapon.weaponCamo);
    if ( !Camo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 3157, ASSERT_TYPE_ASSERT, "(camo)", (const char *)&queryFormat, "camo") )
      __debugbreak();
    Scr_AddConstString(scrContext, Camo->internalName);
  }
}

/*
==============
Scr_GetWeaponReticleName
==============
*/
void Scr_GetWeaponReticleName(scrContext_t *scrContext)
{
  bool outIsAlternate; 
  Weapon outWeapon; 
  char dest[8]; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( outWeapon.weaponIdx )
  {
    Com_sprintf(dest, 8ui64, "scope%d", outWeapon.scopeVariation);
    Scr_AddString(scrContext, dest);
  }
}

/*
==============
ScrCmd_WorldPointInReticle_Circle
==============
*/
void ScrCmd_WorldPointInReticle_Circle(scrContext_t *scrContext, scr_entref_t entref)
{
  int v7; 
  unsigned int entnum; 
  gentity_s *v10; 
  const char *v11; 
  char v15; 
  char v16; 
  vec2_t outScreenPos; 
  vec3_t vectorValue; 
  vec3_t outOrigin; 
  tmat33_t<vec3_t> outForward; 
  char v33; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-28h], xmm6
    vmovaps xmmword ptr [rax-38h], xmm7
  }
  v7 = 0;
  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v10 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 22579, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v10 = &g_entities[entnum];
    if ( !v10->client )
    {
      v11 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v11);
    }
  }
  Scr_GetVector(scrContext, 0, &vectorValue);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm { vmovaps xmm6, xmm0 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
  __asm { vmovaps xmm7, xmm0 }
  G_Client_GetViewOrigin(&v10->client->ps, &outOrigin);
  G_Client_GetViewDirectionLinked(v10, outForward.m, &outForward.m[1], &outForward.m[2]);
  __asm { vmovaps xmm2, xmm6; viewFOV }
  G_Main_WorldPointToScreenPos(&outOrigin, &outForward, *(float *)&_XMM2, &vectorValue, &outScreenPos);
  __asm
  {
    vxorps  xmm1, xmm1, xmm1
    vcvtsi2ss xmm1, xmm1, eax
    vxorps  xmm0, xmm0, xmm0
    vucomiss xmm1, xmm0
  }
  if ( !v16 )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rsp+0C8h+outScreenPos]
      vmovss  xmm1, dword ptr [rsp+0C8h+outScreenPos+4]
      vmulss  xmm3, xmm0, xmm0
      vmulss  xmm2, xmm1, xmm1
      vaddss  xmm4, xmm3, xmm2
      vmulss  xmm0, xmm7, xmm7
      vcomiss xmm0, xmm4
    }
    LOBYTE(v7) = !(v15 | v16);
  }
  Scr_AddBool(scrContext, v7);
  _R11 = &v33;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
  }
}

/*
==============
Scr_GetWeaponHideTags
==============
*/
void Scr_GetWeaponHideTags(scrContext_t *scrContext)
{
  unsigned __int64 v2; 
  bool outIsAlternate; 
  unsigned __int64 outHideTagCount; 
  Weapon outWeapon; 
  scr_string_t value[324]; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( outWeapon.weaponIdx )
  {
    v2 = 0i64;
    outHideTagCount = 0i64;
    BG_GetWeaponExplicitHideTags(&outWeapon, outIsAlternate, 0, 0x142ui64, value, &outHideTagCount);
    Scr_MakeArray(scrContext);
    if ( outHideTagCount )
    {
      do
      {
        Scr_AddConstString(scrContext, value[v2]);
        Scr_AddArray(scrContext);
        ++v2;
      }
      while ( v2 < outHideTagCount );
    }
  }
}

/*
==============
ScrCmd_WorldPointInReticle_Rect
==============
*/
void ScrCmd_WorldPointInReticle_Rect(scrContext_t *scrContext, scr_entref_t entref)
{
  int v8; 
  unsigned int entnum; 
  gentity_s *v11; 
  const char *v12; 
  char v17; 
  char v21; 
  vec2_t outScreenPos; 
  vec3_t vectorValue; 
  vec3_t outOrigin; 
  tmat33_t<vec3_t> outForward; 
  char v37; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-28h], xmm6
    vmovaps xmmword ptr [rax-38h], xmm7
    vmovaps xmmword ptr [rax-48h], xmm8
  }
  v8 = 0;
  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v11 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 22625, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v11 = &g_entities[entnum];
    if ( !v11->client )
    {
      v12 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v12);
    }
  }
  Scr_GetVector(scrContext, 0, &vectorValue);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm { vmovaps xmm7, xmm0 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
  __asm { vmulss  xmm8, xmm0, cs:__real@3f000000 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
  __asm { vmulss  xmm6, xmm0, cs:__real@3f000000 }
  G_Client_GetViewOrigin(&v11->client->ps, &outOrigin);
  G_Client_GetViewDirectionLinked(v11, outForward.m, &outForward.m[1], &outForward.m[2]);
  __asm { vmovaps xmm2, xmm7; viewFOV }
  G_Main_WorldPointToScreenPos(&outOrigin, &outForward, *(float *)&_XMM2, &vectorValue, &outScreenPos);
  __asm
  {
    vxorps  xmm1, xmm1, xmm1
    vcvtsi2ss xmm1, xmm1, eax
    vxorps  xmm0, xmm0, xmm0
    vucomiss xmm1, xmm0
  }
  if ( !v21 )
  {
    __asm
    {
      vmovss  xmm1, dword ptr cs:__xmm@7fffffff7fffffff7fffffff7fffffff
      vmovss  xmm0, dword ptr [rsp+0D8h+outScreenPos]
      vandps  xmm0, xmm0, xmm1
      vandps  xmm8, xmm8, xmm1
      vcomiss xmm0, xmm8
    }
    if ( v17 )
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rsp+0D8h+outScreenPos+4]
        vandps  xmm0, xmm0, xmm1
        vandps  xmm6, xmm6, xmm1
        vcomiss xmm0, xmm6
      }
      if ( v17 )
        v8 = 1;
    }
  }
  Scr_AddBool(scrContext, v8);
  _R11 = &v37;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
  }
}

/*
==============
Scr_GetWeaponLootTable
==============
*/
void Scr_GetWeaponLootTable(scrContext_t *scrContext)
{
  __int64 weaponIdx; 
  bool v3; 
  WeaponCompleteDef **v4; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( outWeapon.weaponIdx )
  {
    weaponIdx = outWeapon.weaponIdx;
    if ( outWeapon.weaponIdx > bg_lastParsedWeaponIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1218, ASSERT_TYPE_ASSERT, "( weaponIndex ) <= ( bg_lastParsedWeaponIndex )", "weaponIndex not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", outWeapon.weaponIdx, bg_lastParsedWeaponIndex) )
      __debugbreak();
    v3 = bg_weaponCompleteDefs[weaponIdx] == NULL;
    v4 = &bg_weaponCompleteDefs[weaponIdx];
    if ( v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1219, ASSERT_TYPE_ASSERT, "(bg_weaponCompleteDefs[weaponIndex])", (const char *)&queryFormat, "bg_weaponCompleteDefs[weaponIndex]") )
      __debugbreak();
    Scr_AddString(scrContext, (*v4)->szLootTable);
  }
  else
  {
    Scr_AddUndefined(scrContext);
  }
}

/*
==============
Scr_GetWeaponVariantIndex
==============
*/
void Scr_GetWeaponVariantIndex(scrContext_t *scrContext)
{
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( outWeapon.weaponIdx && outWeapon.weaponLootId )
    Scr_AddInt(scrContext, outWeapon.weaponLootId - 1);
  else
    Scr_AddUndefined(scrContext);
}

/*
==============
ScrCmd_GetPointInBounds
==============
*/
void ScrCmd_GetPointInBounds(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  vec3_t outPoint; 

  __asm
  {
    vmovaps [rsp+78h+var_18], xmm6
    vmovaps [rsp+78h+var_28], xmm7
  }
  Entity = GetEntity(entref);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm { vmovaps xmm7, xmm0 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm { vmovaps xmm6, xmm0 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
  __asm
  {
    vmovaps xmm3, xmm0; ratioFromCenterZ
    vmovaps xmm2, xmm6; ratioFromCenterY
    vmovaps xmm1, xmm7; ratioFromCenterX
  }
  G_Utils_GetEntityBoundsPoint(Entity, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, &outPoint);
  Scr_AddVector(scrContext, outPoint.v);
  __asm
  {
    vmovaps xmm6, [rsp+78h+var_18]
    vmovaps xmm7, [rsp+78h+var_28]
  }
}

/*
==============
Scr_GetWeaponAmmoPoolName
==============
*/
void Scr_GetWeaponAmmoPoolName(scrContext_t *scrContext)
{
  GHandler *Handler; 
  const char *WeaponBaseName; 
  const char *v4; 
  bool outIsAlternate; 
  Weapon outWeapon; 
  char outAmmoName[1024]; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  Handler = GHandler::getHandler();
  if ( BG_GetWeaponAmmoPoolName(&outWeapon, outIsAlternate, Handler, outAmmoName, 0x400ui64) )
  {
    Scr_AddString(scrContext, outAmmoName);
  }
  else
  {
    WeaponBaseName = BG_GetWeaponBaseName(&outWeapon, outIsAlternate);
    v4 = j_va("unknown ammo name pool for weapon '%s' \n", WeaponBaseName);
    Scr_ParamError(COM_ERR_3997, scrContext, 0, v4);
    Scr_AddUndefined(scrContext);
  }
}

/*
==============
ScrCmd_TransferMarksToNewScriptModel
==============
*/
void ScrCmd_TransferMarksToNewScriptModel(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  __int16 scriptMoverType; 

  Entity = GetEntity(entref);
  v4 = GScr_GetEntity(0);
  if ( v4->s.eType != ET_SCRIPTMOVER )
    Scr_Error(COM_ERR_4622, scrContext, "Only script model/movers are allowed to be passed to this function.");
  scriptMoverType = v4->s.un.scriptMoverType;
  if ( scriptMoverType == 3 )
  {
    Scr_Error(COM_ERR_4623, scrContext, "Reflection probe entities are not allowed to be passed to this function.");
    scriptMoverType = v4->s.un.scriptMoverType;
  }
  if ( scriptMoverType == 4 )
  {
    Scr_Error(COM_ERR_6297, scrContext, "Server arms entities are not allowed to be passed to this function.");
    scriptMoverType = v4->s.un.scriptMoverType;
  }
  if ( scriptMoverType == 5 )
  {
    Scr_Error(COM_ERR_4624, scrContext, "Client weapon entities are not allowed to be passed to this function.");
    scriptMoverType = v4->s.un.scriptMoverType;
  }
  if ( scriptMoverType == 6 )
  {
    Scr_Error(COM_ERR_4625, scrContext, "Server weapon entities are not allowed to be passed to this function.");
    scriptMoverType = v4->s.un.scriptMoverType;
  }
  if ( scriptMoverType == 8 )
  {
    Scr_Error(COM_ERR_4626, scrContext, "Avatar entities are not allowed to be passed to this function.");
    scriptMoverType = v4->s.un.scriptMoverType;
  }
  if ( scriptMoverType == 9 )
  {
    Scr_Error(COM_ERR_5713, scrContext, "Battle Royale Circle entities are not allowed to be passed to this function.");
    scriptMoverType = v4->s.un.scriptMoverType;
  }
  if ( scriptMoverType == 10 )
    Scr_Error(COM_ERR_6075, scrContext, "Map Circle entities are not allowed to be passed to this function.");
  if ( v4->s.staticState.player.stowedWeaponHandle.m_mapEntryId )
    Scr_Error(COM_ERR_4627, scrContext, "Only non-scriptable entities are allowed to be passed to this function.");
  v4->s.lerp.u.anonymous.data[0] = Entity->s.number;
}

/*
==============
GScr_GetAnimLength
==============
*/
void GScr_GetAnimLength(scrContext_t *scrContext)
{
  int linkPointer; 
  unsigned int v4; 
  XAnim_s *Anims; 
  const char *AnimDebugName; 
  const char *v7; 

  linkPointer = Scr_GetAnim(scrContext, 0, NULL).linkPointer;
  v4 = (unsigned __int16)linkPointer;
  Anims = Scr_GetAnims(scrContext, HIWORD(linkPointer));
  if ( !XAnimIsPrimitive(Anims, v4) )
  {
    AnimDebugName = XAnimGetAnimDebugName(Anims, v4);
    v7 = j_va("non-primitive animation '%s' has no concept of length", AnimDebugName);
    Scr_ParamError(COM_ERR_3998, scrContext, 0, v7);
  }
  *(double *)&_XMM0 = XAnimGetLength(Anims, v4);
  __asm { vmovaps xmm1, xmm0; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
GScr_AnimHasNotetrack
==============
*/
void GScr_AnimHasNotetrack(scrContext_t *scrContext)
{
  bool v2; 
  scr_string_t ConstString; 
  const XAnim_s *Anims; 
  int linkPointer; 

  v2 = 0;
  linkPointer = Scr_GetAnim(scrContext, 0, NULL).linkPointer;
  ConstString = Scr_GetConstString(scrContext, 1u);
  Anims = Scr_GetAnims(scrContext, HIWORD(linkPointer));
  if ( XAnimIsLeafNode(Anims, (unsigned __int16)linkPointer) )
    v2 = XAnimNotetrackExists(Anims, (unsigned __int16)linkPointer, ConstString);
  Scr_AddBool(scrContext, v2);
}

/*
==============
GScr_GetNotetrackTimes
==============
*/
void GScr_GetNotetrackTimes(scrContext_t *scrContext)
{
  int linkPointer; 
  unsigned __int16 v3; 
  scr_string_t ConstString; 
  const XAnim_s *Anims; 
  unsigned __int16 v6; 

  linkPointer = Scr_GetAnim(scrContext, 0, NULL).linkPointer;
  v6 = HIWORD(linkPointer);
  v3 = linkPointer;
  ConstString = Scr_GetConstString(scrContext, 1u);
  Scr_MakeArray(scrContext);
  Anims = Scr_GetAnims(scrContext, v6);
  XAnimAddNotetrackTimesToScriptArray(scrContext, Anims, v3, ConstString);
}

/*
==============
GScr_GetGlass
==============
*/
void GScr_GetGlass(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const unsigned __int16 *IndicesFromName; 
  const char *v4; 
  const char *v5; 
  unsigned int count; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4628, scrContext, "Wrong number of parameters to GetGlass( targetname )");
  ConstString = Scr_GetConstString(scrContext, 0);
  IndicesFromName = G_Glass_GetIndicesFromName(ConstString, &count);
  if ( count )
  {
    if ( count > 1 )
    {
      v4 = SL_ConvertToString(ConstString);
      v5 = j_va("GetGlass used with more than one piece of glass (\"targetname\" = \"%s\")", v4);
      Scr_Error(COM_ERR_4629, scrContext, v5);
    }
    Scr_AddInt(scrContext, *IndicesFromName);
  }
}

/*
==============
GScr_AnimIsLeaf
==============
*/
void GScr_AnimIsLeaf(scrContext_t *scrContext)
{
  int linkPointer; 
  unsigned int v3; 
  const XAnim_s *Anims; 
  int IsLeafNode; 

  linkPointer = Scr_GetAnim(scrContext, 0, NULL).linkPointer;
  v3 = (unsigned __int16)linkPointer;
  Anims = Scr_GetAnims(scrContext, HIWORD(linkPointer));
  IsLeafNode = XAnimIsLeafNode(Anims, v3);
  Scr_AddBool(scrContext, IsLeafNode != 0);
}

/*
==============
GScr_GetGlassArray
==============
*/
void GScr_GetGlassArray(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const unsigned __int16 *IndicesFromName; 
  __int64 i; 
  unsigned int count; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4630, scrContext, "Wrong number of parameters to GetGlassArray( targetname )");
  ConstString = Scr_GetConstString(scrContext, 0);
  IndicesFromName = G_Glass_GetIndicesFromName(ConstString, &count);
  Scr_MakeArray(scrContext);
  for ( i = 0i64; (unsigned int)i < count; i = (unsigned int)(i + 1) )
  {
    Scr_AddInt(scrContext, IndicesFromName[i]);
    Scr_AddArray(scrContext);
  }
}

/*
==============
GScr_GetGlassOrigin
==============
*/
void GScr_GetGlassOrigin(scrContext_t *scrContext)
{
  unsigned int Int; 
  const char *v3; 
  vec3_t outOrigin; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4631, scrContext, "Wrong number of parameters to GetGlassOrigin( glassID )");
  Int = Scr_GetInt(scrContext, 0);
  if ( !G_Glass_IsIndexValid(Int) )
  {
    v3 = j_va("Invalid glass ID %i", Int);
    Scr_ParamError(COM_ERR_4632, scrContext, 0, v3);
  }
  G_Glass_GetPieceOrigin(Int, &outOrigin);
  Scr_AddVector(scrContext, outOrigin.v);
}

/*
==============
GScr_IsGlassDestroyed
==============
*/
void GScr_IsGlassDestroyed(scrContext_t *scrContext)
{
  unsigned int Int; 
  const char *v3; 
  GlassPieceState PieceState; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4633, scrContext, "Wrong number of parameters to IsGlassDestroyed( glassID )");
  Int = Scr_GetInt(scrContext, 0);
  if ( !G_Glass_IsIndexValid(Int) )
  {
    v3 = j_va("Invalid glass ID %i", Int);
    Scr_ParamError(COM_ERR_4634, scrContext, 0, v3);
  }
  PieceState = G_Glass_GetPieceState(Int);
  Scr_AddBool(scrContext, PieceState >= GLASS_DESTROYED);
}

/*
==============
GScr_DestroyGlass
==============
*/
void GScr_DestroyGlass(scrContext_t *scrContext)
{
  unsigned int Int; 
  const char *v4; 
  vec3_t vectorValue; 
  vec3_t outOrigin; 

  if ( !Scr_GetNumParam(scrContext) && Scr_GetNumParam(scrContext) > 2 )
    Scr_Error(COM_ERR_4635, scrContext, "Wrong number of parameters to DestroyGlass( glassID, direction )");
  Int = Scr_GetInt(scrContext, 0);
  if ( !G_Glass_IsIndexValid(Int) )
  {
    v4 = j_va("Invalid glass ID %i", Int);
    Scr_ParamError(COM_ERR_4636, scrContext, 0, v4);
  }
  if ( Scr_GetNumParam(scrContext) < 2 )
  {
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vmovss  dword ptr [rsp+58h+vectorValue], xmm0
      vmovss  dword ptr [rsp+58h+vectorValue+4], xmm0
      vmovss  dword ptr [rsp+58h+vectorValue+8], xmm0
    }
  }
  else
  {
    Scr_GetVector(scrContext, 1u, &vectorValue);
  }
  G_Glass_GetPieceOrigin(Int, &outOrigin);
  G_Glass_DestroyPiece(Int, &outOrigin, &vectorValue);
}

/*
==============
GScr_DeleteGlass
==============
*/
void GScr_DeleteGlass(scrContext_t *scrContext)
{
  unsigned int Int; 
  const char *v3; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4637, scrContext, "Wrong number of parameters to DeleteGlass( glassID )");
  Int = Scr_GetInt(scrContext, 0);
  if ( !G_Glass_IsIndexValid(Int) )
  {
    v3 = j_va("Invalid glass ID %i", Int);
    Scr_ParamError(COM_ERR_4638, scrContext, 0, v3);
  }
  G_Glass_DeletePiece(Int);
}

/*
==============
ScrCmd_IsTouching
==============
*/
void ScrCmd_IsTouching(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  const gentity_s *v4; 
  int IsTouchingInternal; 

  Entity = GetEntity(entref);
  v4 = GScr_GetEntity(0);
  IsTouchingInternal = Scr_IsTouchingInternal(scrContext, Entity, v4);
  Scr_AddInt(scrContext, IsTouchingInternal);
}

/*
==============
GScr_ResetGlass
==============
*/
void GScr_ResetGlass(scrContext_t *scrContext)
{
  const char *v1; 

  G_ResetGlass();
  v1 = j_va("%c", 60i64);
  SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v1);
}

/*
==============
ScrCmd_GetIsTouchingEntities
==============
*/
void ScrCmd_GetIsTouchingEntities(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ArrayObject; 
  unsigned int ArraySize; 
  const char *v6; 
  const char *NameForType; 
  const char *v8; 
  const gentity_s *Entity; 
  __int64 i; 
  scr_entref_t EntityIdRef; 
  const gentity_s *v12; 
  VariableType failureType[4]; 
  unsigned int count; 
  unsigned int failureIndex; 
  unsigned int buffer[128]; 

  Sys_ProfBeginNamedEvent(0xFFFFFFFF, "GetIsTouchingEntities");
  ArrayObject = BGScr_Main_GetArrayObject(scrContext, 0);
  ArraySize = GetArraySize(scrContext, ArrayObject);
  count = ArraySize;
  if ( ArraySize > 0x80 )
  {
    v6 = j_va("array is too large (%d > %d)", ArraySize, 128i64);
    Scr_ParamError(COM_ERR_4000, scrContext, 0, v6);
  }
  if ( !Scr_GetEntityArray(scrContext, ArrayObject, 0x80u, buffer, &count, &failureIndex, failureType) )
  {
    NameForType = Scr_GetNameForType(failureType[0]);
    v8 = j_va("element %i of array: type %s is not an entity", failureIndex, NameForType);
    Scr_ParamError(COM_ERR_4001, scrContext, 0, v8);
  }
  Entity = GetEntity(entref);
  Scr_MakeArray(scrContext);
  for ( i = 0i64; (unsigned int)i < count; i = (unsigned int)(i + 1) )
  {
    EntityIdRef = Scr_GetEntityIdRef(scrContext, buffer[i]);
    v12 = GetEntity(EntityIdRef);
    if ( Scr_IsTouchingInternal(scrContext, Entity, v12) )
    {
      GScr_AddEntity(v12);
      Scr_AddArray(scrContext);
    }
  }
  Sys_ProfEndNamedEvent();
}

/*
==============
ScrCmd_SetSlowMotion
==============
*/
void ScrCmd_SetSlowMotion(scrContext_t *scrContext)
{
  const char *v29; 
  __int64 v33; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-18h], xmm6
    vmovaps xmmword ptr [rax-38h], xmm8
    vmovaps xmmword ptr [rax-48h], xmm9
  }
  if ( !Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_4639, scrContext, "SetSlowMotion requires at least 1 parameter.");
  __asm
  {
    vmovss  xmm6, cs:__real@3f800000
    vmovaps xmm8, xmm6
  }
  _EDI = 1000;
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm { vmovaps xmm9, xmm0 }
  if ( Scr_GetNumParam(scrContext) >= 2 )
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
    __asm { vmovaps xmm8, xmm0 }
  }
  if ( Scr_GetNumParam(scrContext) >= 3 )
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
    __asm
    {
      vmulss  xmm1, xmm0, cs:__real@447a0000
      vcvttss2si edi, xmm1
    }
  }
  if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_STILL_LAND|0x80) )
  {
    __asm
    {
      vmovaps [rsp+78h+var_28], xmm7
      vsubss  xmm0, xmm8, xmm9
      vmovd   xmm7, edi
      vcvtdq2ps xmm7, xmm7
      vmovss  cs:?g_slowmoCommon@@3USlowMotionCommon@@A.startTimescale, xmm9; SlowMotionCommon g_slowmoCommon
      vmovss  cs:?g_slowmoCommon@@3USlowMotionCommon@@A.endTimescale, xmm8; SlowMotionCommon g_slowmoCommon
    }
    g_slowmoCommon.type = 0;
    __asm { vdivss  xmm6, xmm6, xmm0 }
    Com_GetTimeScale();
    __asm
    {
      vsubss  xmm1, xmm9, xmm0
      vmulss  xmm2, xmm1, xmm7
      vmulss  xmm3, xmm2, xmm6
      vcvttss2si eax, xmm3
    }
    g_slowmoCommon.startMsec = com_frameTime + _EAX;
    Com_GetTimeScale();
    __asm
    {
      vsubss  xmm1, xmm8, xmm0
      vmulss  xmm2, xmm1, xmm7
      vmovaps xmm7, [rsp+78h+var_28]
      vmulss  xmm3, xmm2, xmm6
      vcvttss2si eax, xmm3
    }
    g_slowmoCommon.endMsec = com_frameTime + _EAX;
    g_slowmoCommon.enable = 1;
  }
  else
  {
    __asm
    {
      vcvtss2sd xmm3, xmm9, xmm9
      vcvtss2sd xmm0, xmm8, xmm8
      vmovq   r9, xmm3
      vmovsd  [rsp+78h+var_58], xmm0
    }
    v29 = j_va("%i %i %g %g", (unsigned int)level.time, _EDI, _R9, v33);
    SV_SetConfigstring(0x217u, v29);
  }
  __asm
  {
    vmovaps xmm6, [rsp+78h+var_18]
    vmovaps xmm8, [rsp+78h+var_38]
    vmovaps xmm9, [rsp+78h+var_48]
  }
}

/*
==============
ScrCmd_LerpFOVByPreset
==============
*/
void ScrCmd_LerpFOVByPreset(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  _DWORD *p_commandTime; 
  const char *v6; 
  ComErrorCode v7; 
  const char *String; 
  int PresetIndex; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
LABEL_9:
    Scr_ObjectError(v7, scrContext, v6);
    p_commandTime = NULL;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 23007, ASSERT_TYPE_ASSERT, "(ps)", "%s\n\tLerpFOVByPreset can only be called on a player or agent.", "ps") )
      __debugbreak();
    goto LABEL_11;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 23005, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  p_commandTime = &v4->client->ps.commandTime;
  if ( !p_commandTime )
  {
    p_commandTime = &v4->agent->playerState.commandTime;
    if ( !p_commandTime )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
      goto LABEL_9;
    }
  }
LABEL_11:
  if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_PARACHUTE_IDLE|WEAPON_OFFHAND_END) )
    Scr_Error(COM_ERR_4640, scrContext, "LerpFOVByPreset is not supported in this gamemode");
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4641, scrContext, "LerpFOVByPreset must have only one parameter.\n");
  String = Scr_GetString(scrContext, 0);
  PresetIndex = BG_FovLerp_GetPresetIndex(String);
  if ( !PresetIndex )
    Scr_Error(COM_ERR_4642, scrContext, "Invalid preset name is passed into LerpFOVByPreset.\n");
  p_commandTime[327] = PresetIndex;
}

/*
==============
ScrCmd_SoundExists
==============
*/
void ScrCmd_SoundExists(scrContext_t *scrContext)
{
  const char *String; 
  SndAliasList *Alias; 

  String = Scr_GetString(scrContext, 0);
  Alias = SND_TryFindAlias(String);
  Scr_AddBool(scrContext, Alias != NULL);
}

/*
==============
Scr_SoundIsLooping
==============
*/
void Scr_SoundIsLooping(scrContext_t *scrContext)
{
  const char *String; 
  SndAliasList *Alias; 
  SndAlias *head; 

  String = Scr_GetString(scrContext, 0);
  Alias = SND_FindAlias(String);
  if ( Alias && (head = Alias->head) != NULL )
    Scr_AddBool(scrContext, (head->flags & 3) != 0);
  else
    Scr_AddUndefined(scrContext);
}

/*
==============
ScrCmd_StopSounds
==============
*/
void ScrCmd_StopSounds(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *v4; 

  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 3607, ASSERT_TYPE_SANITY, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( Entity->s.eType >= ET_EVENTS )
  {
    v4 = j_va("StopSounds() does not support entities of type 'ET_EVENTS' [Ent #%i].", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_4002, scrContext, v4);
  }
  Entity->r.svFlags &= ~1u;
  G_Utils_AddEvent(Entity, 9u, 0);
}

/*
==============
ScrCmd_MagicGrenadeManual
==============
*/
void ScrCmd_MagicGrenadeManual(scrContext_t *scrContext)
{
  ComErrorCode v3; 
  const char *String; 
  const char *v5; 
  int fuseTime; 
  gentity_s *Entity; 
  const gentity_s *v9; 
  bool outIsAlternate; 
  vec3_t dir; 
  vec3_t vectorValue; 
  Weapon outWeapon; 

  if ( Scr_GetNumParam(scrContext) < 3 || Scr_GetNumParam(scrContext) > 5 )
    Scr_Error(COM_ERR_4003, scrContext, "MagicGrenadeManual <grenade type> <origin> <velocity> [time To Blow (seconds)].\n");
  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( outWeapon.weaponIdx )
  {
    Scr_GetVector(scrContext, 1u, &vectorValue);
    Scr_GetVector(scrContext, 2u, &dir);
    if ( Scr_GetNumParam(scrContext) <= 3 )
    {
      fuseTime = 5000;
    }
    else
    {
      *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
      __asm
      {
        vmulss  xmm1, xmm0, cs:__real@447a0000
        vcvttss2si edi, xmm1
      }
    }
    if ( Scr_GetNumParam(scrContext) <= 4 )
      Entity = NULL;
    else
      Entity = GScr_GetEntity(4u);
    v9 = G_Missile_FireGrenade(Entity, &vectorValue, &dir, &outWeapon, 0, WEAPON_HAND_DEFAULT, 1, fuseTime, 1, level.time);
    GScr_AddEntity(v9);
  }
  else
  {
    if ( Scr_GetType(scrContext, 0) == VAR_STRING )
    {
      v3 = COM_ERR_4004;
      String = Scr_GetString(scrContext, 0);
      v5 = j_va("\"%s\" grenade weapon is not precached", String);
    }
    else
    {
      v3 = COM_ERR_4005;
      v5 = "Invalid grenade weapon specified for MagicGrenadeManual";
    }
    Scr_ParamError(v3, scrContext, 0, v5);
  }
}

/*
==============
ScrCmd_LerpFOVScaleFactor
==============
*/

void __fastcall ScrCmd_LerpFOVScaleFactor(scrContext_t *scrContext, scr_entref_t entref, double _XMM2_8)
{
  unsigned int entnum; 
  gentity_s *v7; 
  const char *v8; 
  const char *v18; 
  const char *v19; 
  unsigned int clientIndex; 
  SvClient *CommonClient; 

  __asm { vmovaps [rsp+48h+var_18], xmm6 }
  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v7 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 23048, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v7 = &g_entities[entnum];
    if ( !v7->client )
    {
      v8 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v8);
    }
  }
  if ( (int)Scr_GetNumParam(scrContext) < 2 )
    Scr_Error(COM_ERR_5923, scrContext, "Not enough parameters.\n");
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm
  {
    vmulss  xmm1, xmm0, cs:__real@447a0000
    vaddss  xmm3, xmm1, cs:__real@3f000000
    vxorps  xmm2, xmm2, xmm2
    vmovss  xmm4, xmm2, xmm3
    vxorps  xmm0, xmm0, xmm0
    vroundss xmm6, xmm0, xmm4, 1
  }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm
  {
    vcvtss2sd xmm2, xmm0, xmm0
    vmovq   r8, xmm2
    vcvttss2si r9d, xmm6
  }
  v18 = j_va("%c %f %d", 62i64, _R8, _R9);
  v19 = v18;
  clientIndex = v7->client->sess.cs.clientIndex;
  if ( clientIndex == -1 )
  {
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v18);
  }
  else
  {
    CommonClient = SvClient::GetCommonClient(clientIndex);
    CommonClient->SendServerCommand(CommonClient, SV_CMD_RELIABLE, v19);
  }
  __asm { vmovaps xmm6, [rsp+48h+var_18] }
}

/*
==============
GScr_GetEntChannelsCount
==============
*/
void GScr_GetEntChannelsCount(scrContext_t *scrContext)
{
  int EntChannelCount; 

  EntChannelCount = SND_GetEntChannelCount();
  Scr_AddInt(scrContext, EntChannelCount);
}

/*
==============
GScr_GetEntChannelName
==============
*/
void GScr_GetEntChannelName(scrContext_t *scrContext)
{
  unsigned int Int; 
  const char *v3; 
  const char *EntChannelName; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4643, scrContext, "Wrong number of parameters to GetEntChannelName( <index> )");
  Int = Scr_GetInt(scrContext, 0);
  if ( Int >= SND_GetEntChannelCount() )
  {
    v3 = j_va("Invalid channel index %i", Int);
    Scr_ParamError(COM_ERR_4644, scrContext, 0, v3);
  }
  EntChannelName = SND_GetEntChannelName(Int);
  Scr_AddString(scrContext, EntChannelName);
}

/*
==============
GScr_StartFiring
==============
*/
void GScr_StartFiring(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4006, scrContext, v6);
  }
  Turret = GTurret::GetTurret(p_turretHandle);
  Turret->m_data.flags |= 0x10u;
}

/*
==============
GScr_StopFiring
==============
*/
void GScr_StopFiring(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4007, scrContext, v6);
  }
  Turret = GTurret::GetTurret(p_turretHandle);
  Turret->m_data.flags &= ~0x10u;
}

/*
==============
GScr_IsFiringTurret
==============
*/
void GScr_IsFiringTurret(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  const char *v5; 
  const char *v6; 
  bool IsFiring; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4008, scrContext, v6);
  }
  IsFiring = G_Turret_IsFiring(v4);
  Scr_AddBool(scrContext, IsFiring);
}

/*
==============
GScr_DisconnectPaths
==============
*/
void GScr_DisconnectPaths(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Sys_ProfBeginNamedEvent(0xFFFFFFFF, "GScr_DisconnectPaths");
  Entity = GetEntity(entref);
  if ( GScr_Main_ValidateDisconnectPathsEnt(scrContext, Entity) )
    Path_DisconnectPathsForEntity(Entity, 0);
  Sys_ProfEndNamedEvent();
}

/*
==============
GScr_StartBarrelSpin
==============
*/
void GScr_StartBarrelSpin(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  const char *v5; 
  const char *v6; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4009, scrContext, v6);
  }
  G_Turret_SetManualSpinning(v4, 1);
}

/*
==============
GScr_ConnectPaths
==============
*/
void GScr_ConnectPaths(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Sys_ProfBeginNamedEvent(0xFFFFFFFF, "GScr_ConnectPaths");
  Entity = GetEntity(entref);
  if ( GScr_Main_ValidateDisconnectPathsEnt(scrContext, Entity) )
    Path_ConnectPathsForEntity(Entity);
  Sys_ProfEndNamedEvent();
}

/*
==============
GScr_StopBarrelSpin
==============
*/
void GScr_StopBarrelSpin(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  const char *v5; 
  const char *v6; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4010, scrContext, v6);
  }
  G_Turret_SetManualSpinning(v4, 0);
}

/*
==============
GScr_GetBarrelSpinRate
==============
*/
void GScr_GetBarrelSpinRate(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v5; 
  const char *v6; 
  const char *v7; 

  Entity = GetEntity(entref);
  v5 = Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v6 = SL_ConvertToString(Entity->classname);
    v7 = j_va("entity type '%s' is not a turret", v6);
    Scr_Error(COM_ERR_4011, scrContext, v7);
  }
  *(double *)&_XMM0 = G_Turret_GetBarrelSpinRate(v5);
  __asm { vmovaps xmm1, xmm0; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
GScr_DisconnectNode
==============
*/
void GScr_DisconnectNode(scrContext_t *scrContext, scr_entref_t entref)
{
  Path_GetNodeFromEntref(scrContext, entref)->dynamic.bInactive = 1;
}

/*
==============
GScr_ConnectNode
==============
*/
void GScr_ConnectNode(scrContext_t *scrContext, scr_entref_t entref)
{
  Path_GetNodeFromEntref(scrContext, entref)->dynamic.bInactive = 0;
}

/*
==============
Scr_NodeIsDisconnected
==============
*/
void Scr_NodeIsDisconnected(scrContext_t *scrContext, scr_entref_t entref)
{
  const pathnode_t *NodeFromEntref; 
  unsigned __int16 v4; 
  bool IsNodeDisconnected; 

  NodeFromEntref = Path_GetNodeFromEntref(scrContext, entref);
  v4 = Path_ConvertNodeToIndex(NodeFromEntref);
  IsNodeDisconnected = Path_IsNodeDisconnected(v4);
  Scr_AddBool(scrContext, IsNodeDisconnected);
}

/*
==============
GScr_SetWorldUpReference
==============
*/
void GScr_SetWorldUpReference(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  const char *v5; 
  const char *v6; 
  playerState_s *EntityPlayerState; 
  const char *v8; 
  GHandler *Handler; 
  GHandler *v10; 
  gentity_s *v11; 
  const char *v12; 
  __int16 number; 
  GHandler *v14; 
  WorldUpReferenceFrame v15; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( !Entity->client )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a client, can only set world up ref on client.", v5);
    Scr_Error(COM_ERR_4013, scrContext, v6);
    return;
  }
  EntityPlayerState = G_GetEntityPlayerState(Entity);
  if ( !EntityPlayerState )
  {
    v8 = j_va("Could not get playerstate.");
    Scr_Error(COM_ERR_4014, scrContext, v8);
    return;
  }
  Handler = GHandler::getHandler();
  WorldUpReferenceFrame::WorldUpReferenceFrame(&v15, EntityPlayerState, Handler);
  if ( Scr_GetType(scrContext, 0) )
  {
    v11 = GScr_GetEntity(0);
    if ( EntityPlayerState->worldUpRefEnt == v11->s.number )
      return;
    if ( BG_IsPlayerLinked(EntityPlayerState) )
    {
      if ( !v4->tagInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 3927, ASSERT_TYPE_ASSERT, "(playerEnt->tagInfo)", (const char *)&queryFormat, "playerEnt->tagInfo") )
        __debugbreak();
      if ( !v4->tagInfo->parent->s.number && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 3928, ASSERT_TYPE_ASSERT, "(playerEnt->tagInfo->parent->s.number)", (const char *)&queryFormat, "playerEnt->tagInfo->parent->s.number") )
        __debugbreak();
      if ( !GUtils::AreEntsInSameLinkTree(v11, v4) )
      {
        v12 = j_va("Setting the world up while linked is only allowed if the world up ent is in the same hierarchy as the linked parent. entNum = %d", (unsigned int)v11->s.number);
        Scr_Error(COM_ERR_4015, scrContext, v12);
      }
      WorldUpReferenceFrame::SetEntity(&v15, EntityPlayerState, v11->s.number);
      v4->c.item[0].weapon.attachmentVariationIndices[19] = 1;
    }
    else
    {
      number = v11->s.number;
      v14 = GHandler::getHandler();
      WorldUpReferenceFrame::SetEntityAndNormalizeViewAngles(&v15, EntityPlayerState, v14, number);
    }
    v11->r.svFlags &= ~1u;
    v11->s.lerp.eFlags.m_flags[0] ^= 4u;
  }
  else
  {
    if ( !WorldUpReferenceFrame::HasValidWorldUpEnt(EntityPlayerState) )
      return;
    if ( BG_IsPlayerLinked(EntityPlayerState) )
    {
      WorldUpReferenceFrame::SetEntity(&v15, EntityPlayerState, 0);
    }
    else
    {
      v10 = GHandler::getHandler();
      WorldUpReferenceFrame::SetEntityAndNormalizeViewAngles(&v15, EntityPlayerState, v10, 0);
    }
  }
  G_ValidateWorldUpIsSafe(scrContext, v4);
}

/*
==============
Scr_NodeIsActivated
==============
*/
void Scr_NodeIsActivated(scrContext_t *scrContext, scr_entref_t entref)
{
  pathnode_t *NodeFromEntref; 

  NodeFromEntref = Path_GetNodeFromEntref(scrContext, entref);
  Scr_AddBool(scrContext, NodeFromEntref->dynamic.bInactive == 0);
}

/*
==============
GScr_DisconnectNodePair
==============
*/
void GScr_DisconnectNodePair(scrContext_t *scrContext)
{
  Scr_Error(COM_ERR_4647, scrContext, "DisconnectNodePair() functionality not currently supported.  Similar functionality will be provided for links in the near future.");
}

/*
==============
GScr_ConnectNodePair
==============
*/
void GScr_ConnectNodePair(scrContext_t *scrContext)
{
  Scr_Error(COM_ERR_4648, scrContext, "ConnectNodePair() functionality not currently supported.  Similar functionality will be provided for links in the near future.");
}

/*
==============
Scr_BadPlace_Delete
==============
*/
void Scr_BadPlace_Delete(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  scr_string_t v3; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    if ( *Scr_GetString(scrContext, 0) )
    {
      ConstString = Scr_GetConstString(scrContext, 0);
      Path_RemoveBadPlace(ConstString);
    }
    else
    {
      Scr_Error(COM_ERR_4650, scrContext, "badplace_delete called with name \"\"");
    }
    v3 = Scr_GetConstString(scrContext, 0);
    Nav_DestroyRepulsorByName(v3);
  }
  else
  {
    Scr_Error(COM_ERR_4649, scrContext, "Incorrect number of parameters\n");
  }
}

/*
==============
GScr_TeleportWorldUpReferenceAngles
==============
*/
void GScr_TeleportWorldUpReferenceAngles(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *v4; 
  const char *v5; 
  gentity_s *v6; 
  const char *v8; 
  GHandler *Handler; 
  GUtils *Utils; 
  vec3_t inOutViewAngles; 
  vec3_t vectorValue; 
  vec3_t angles; 
  tmat33_t<vec3_t> axis; 
  tmat33_t<vec3_t> in; 
  tmat33_t<vec3_t> out; 
  tmat33_t<vec3_t> v20; 
  WorldUpReferenceFrame v21; 

  Entity = GetEntity(entref);
  Sys_ProfBeginNamedEvent(0xFFFF0000, "GScr_TeleportWorldUpReferenceAngles");
  if ( Entity->client )
  {
    v6 = GScr_GetEntity(0);
    Scr_GetVector(scrContext, 1u, &vectorValue);
    _RSI = G_GetEntityPlayerState(Entity);
    if ( _RSI )
    {
      Handler = GHandler::getHandler();
      WorldUpReferenceFrame::WorldUpReferenceFrame(&v21, _RSI, Handler);
      G_SetAngle(v6, &vectorValue, 1, 1);
      v6->r.svFlags &= ~1u;
      v6->s.lerp.eFlags.m_flags[0] ^= 4u;
      __asm
      {
        vmovss  xmm0, dword ptr [rsi+1D8h]
        vmovss  dword ptr [rsp+138h+inOutViewAngles], xmm0
        vmovss  xmm1, dword ptr [rsi+1DCh]
        vmovss  dword ptr [rsp+138h+inOutViewAngles+4], xmm1
        vmovss  xmm0, dword ptr [rsi+1E0h]
        vmovss  dword ptr [rsp+138h+inOutViewAngles+8], xmm0
      }
      BG_CalcLinkedViewValues(_RSI, &inOutViewAngles);
      AnglesToAxis(&inOutViewAngles, &axis);
      WorldUpReferenceFrame::ApplyReferenceFrameToAxis(&v21, &axis);
      AnglesToAxis(&v6->r.currentAngles, &in);
      MatrixTranspose(&in, &out);
      MatrixMultiply(&axis, &out, &v20);
      AxisToAngles(&v20, &angles);
      Utils = GUtils::GetUtils();
      Utils->SetPlayerViewAngles(Utils, Entity, &angles);
      Sys_ProfEndNamedEvent();
      G_ValidateWorldUpIsSafe(scrContext, Entity);
    }
    else
    {
      v8 = j_va("Could not get playerstate.");
      Scr_Error(COM_ERR_4017, scrContext, v8);
      Sys_ProfEndNamedEvent();
    }
  }
  else
  {
    v4 = SL_ConvertToString(Entity->classname);
    v5 = j_va("entity type '%s' is not a client, can only teleport world up ref on client.", v4);
    Scr_Error(COM_ERR_4016, scrContext, v5);
    Sys_ProfEndNamedEvent();
  }
}

/*
==============
GScr_SetWorldUpReferenceAngles
==============
*/
void GScr_SetWorldUpReferenceAngles(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  playerState_s *p_ps; 
  const char *v6; 
  const char *v7; 
  GHandler *Handler; 
  int Int; 
  bool v10; 
  GHandler *v11; 
  GHandler *v12; 
  GWeaponMap *Instance; 
  vec3_t vectorValue; 
  WorldUpReferenceFrame refFrame; 

  Entity = GetEntity(entref);
  v4 = Entity;
  p_ps = &Entity->client->ps;
  if ( !p_ps )
  {
    v6 = SL_ConvertToString(Entity->classname);
    v7 = j_va("SetWorldUpReferenceAngles for %s can only be called on a client.", v6);
    Scr_Error(COM_ERR_4018, scrContext, v7);
    return;
  }
  Handler = GHandler::getHandler();
  WorldUpReferenceFrame::WorldUpReferenceFrame(&refFrame, p_ps, Handler);
  Scr_GetVector(scrContext, 0, &vectorValue);
  if ( Scr_GetNumParam(scrContext) < 2 )
  {
    v10 = 1;
  }
  else
  {
    Int = Scr_GetInt(scrContext, 1u);
    v10 = Int != 0;
    if ( !Int )
    {
LABEL_5:
      v11 = GHandler::getHandler();
      WorldUpReferenceFrame::SetAngles(&refFrame, p_ps, v11, &vectorValue);
      goto LABEL_6;
    }
  }
  if ( !BG_IsPlayerZeroG(p_ps) )
    goto LABEL_5;
  v12 = GHandler::getHandler();
  Instance = GWeaponMap::GetInstance();
  PM_ZeroGravity_SetWorldUpAngles(p_ps, Instance, &refFrame, v12, &vectorValue);
LABEL_6:
  if ( v10 )
    G_ValidateWorldUpIsSafe(scrContext, v4);
}

/*
==============
Scr_BadPlace_Cylinder
==============
*/

void __fastcall Scr_BadPlace_Cylinder(scrContext_t *scrContext, double _XMM1_8)
{
  unsigned int v6; 
  scr_string_t name; 
  bitarray<224> *p_result; 
  int usageFlags; 
  nav_space_s *MostLikelySpace; 
  const char *v21; 
  float v24; 
  vec3_t vectorValue; 
  bitarray<224> result; 
  char v27; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm { vmovaps xmmword ptr [rax-18h], xmm6 }
  v6 = 0;
  if ( Scr_GetType(scrContext, 0) && *Scr_GetString(scrContext, 0) )
    name = Scr_GetConstString(scrContext, 0);
  else
    name = 0;
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm
  {
    vmulss  xmm2, xmm0, cs:__real@447a0000
    vxorps  xmm1, xmm1, xmm1
    vmovss  xmm3, xmm1, xmm2
    vxorps  xmm0, xmm0, xmm0
    vroundss xmm4, xmm0, xmm3, 2
    vcvttss2si ebp, xmm4
  }
  Scr_GetVector(scrContext, 2u, &vectorValue);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
  __asm { vmovaps xmm6, xmm0 }
  Scr_GetTeamFlags(&result, scrContext, 5u);
  p_result = &result;
  while ( !p_result->array[0] )
  {
    ++v6;
    p_result = (bitarray<224> *)((char *)p_result + 4);
    if ( v6 >= 7 )
    {
      if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_WEAPON_DROP|0x80) )
        _RAX = Com_TeamsSP_GetAllCombatTeamFlags();
      else
        _RAX = Com_TeamsMP_GetAllTeamFlags();
      __asm
      {
        vmovups xmm0, xmmword ptr [rax]
        vmovups xmmword ptr [rsp+0A8h+result.array], xmm0
        vmovsd  xmm1, qword ptr [rax+10h]
        vmovsd  qword ptr [rsp+0A8h+result.array+10h], xmm1
      }
      result.array[6] = _RAX->array[6];
      break;
    }
  }
  usageFlags = Nav_TranslateTeamFlagsToRepulsorUsageFlags(&result);
  MostLikelySpace = Nav_FindMostLikelySpace(&vectorValue, NAV_LAYER_HUMAN, NULL);
  if ( MostLikelySpace )
  {
    __asm { vmovss  [rsp+0A8h+var_88], xmm6 }
    if ( !Nav_CreateRepulsor(MostLikelySpace, &vectorValue, &vec3_origin, _EBP, v24, 2047, usageFlags, name, 1) )
    {
      v21 = j_va("BadPlace: Unable to allocate repulsor.  Exceeded max (%d)?", 256i64);
      Scr_Error(COM_ERR_4651, scrContext, v21);
    }
  }
  _R11 = &v27;
  __asm { vmovaps xmm6, xmmword ptr [r11-10h] }
}

/*
==============
GScr_GetWorldUpReferenceAngles
==============
*/
void GScr_GetWorldUpReferenceAngles(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const playerState_s *p_ps; 
  const char *v5; 
  const char *v6; 
  GHandler *Handler; 
  vec3_t outAngles; 
  WorldUpReferenceFrame v9; 

  Entity = GetEntity(entref);
  p_ps = &Entity->client->ps;
  if ( p_ps )
  {
    Handler = GHandler::getHandler();
    WorldUpReferenceFrame::WorldUpReferenceFrame(&v9, p_ps, Handler);
    WorldUpReferenceFrame::GetAngles(&v9, &outAngles);
    Scr_AddVector(scrContext, outAngles.v);
  }
  else
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("GetWorldUpReferenceAngles for %s can only be called on a client.", v5);
    Scr_Error(COM_ERR_4019, scrContext, v6);
  }
}

/*
==============
GScr_NormalizeWorldUpReferenceAngles
==============
*/
void GScr_NormalizeWorldUpReferenceAngles(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  const char *v5; 
  const char *v6; 
  GHandler *Handler; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( Entity->client )
  {
    Handler = GHandler::getHandler();
    BG_NormalizeWorldUpReferenceAngles(&v4->client->ps, Handler);
  }
  else
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("GetWorldUpReferenceAngles for %s can only be called on a client.", v5);
    Scr_Error(COM_ERR_4020, scrContext, v6);
  }
}

/*
==============
GScr_Turret_Shoot
==============
*/
void GScr_Turret_Shoot(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  gentity_s *v5; 
  const char *v6; 
  const char *v7; 
  scr_string_t ConstString; 

  Entity = GetEntity(entref);
  Int = 0;
  v5 = Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v6 = SL_ConvertToString(Entity->classname);
    v7 = j_va("entity type '%s' is not a turret", v6);
    Scr_Error(COM_ERR_4021, scrContext, v7);
  }
  if ( Scr_GetNumParam(scrContext) && Scr_GetType(scrContext, 0) )
    ConstString = Scr_GetConstString(scrContext, 0);
  else
    ConstString = scr_const.tag_aim;
  if ( Scr_GetNumParam(scrContext) > 1 )
    Int = Scr_GetInt(scrContext, 1u);
  G_Turret_ScrShoot(v5, ConstString, Int);
}

/*
==============
Scr_BadPlace_Global
==============
*/

void __fastcall Scr_BadPlace_Global(scrContext_t *scrContext, double _XMM1_8)
{
  unsigned int v6; 
  int v7; 
  scr_string_t ConstString; 
  unsigned int v15; 
  bitarray<224> *p_result; 
  unsigned int v20; 
  bitarray<224> result; 

  __asm
  {
    vmovaps [rsp+0A8h+var_38], xmm6
    vmovaps [rsp+0A8h+var_48], xmm7
  }
  v6 = 2;
  if ( !Com_GameMode_SupportsFeature(WEAPON_RAISING_ALTSWITCH) )
    Scr_Error(COM_ERR_4652, scrContext, "Global bad place system must be active to use this function");
  if ( Scr_GetNumParam(scrContext) < 2 )
    Scr_Error(COM_ERR_4653, scrContext, "Incorrect BadPlace_Global() call.");
  v7 = 0;
  if ( *Scr_GetString(scrContext, 0) )
    ConstString = Scr_GetConstString(scrContext, 0);
  else
    ConstString = 0;
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm
  {
    vmulss  xmm2, xmm0, cs:__real@447a0000
    vxorps  xmm1, xmm1, xmm1
    vmovss  xmm3, xmm1, xmm2
    vxorps  xmm0, xmm0, xmm0
    vroundss xmm4, xmm0, xmm3, 2
    vcvttss2si r12d, xmm4
  }
  Scr_GetTeamFlags(&result, scrContext, 2u);
  v15 = 0;
  p_result = &result;
  do
  {
    if ( p_result->array[0] )
    {
      v20 = result.array[6];
      __asm
      {
        vmovsd  xmm7, qword ptr [rsp+0A8h+result.array+10h]
        vmovups xmm6, xmmword ptr [rsp+0A8h+result.array]
      }
      goto LABEL_16;
    }
    ++v15;
    p_result = (bitarray<224> *)((char *)p_result + 4);
  }
  while ( v15 < 7 );
  if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_WEAPON_DROP|0x80) )
    _RAX = Com_TeamsSP_GetAllCombatTeamFlags();
  else
    _RAX = Com_TeamsMP_GetAllTeamFlags();
  __asm
  {
    vmovups xmm6, xmmword ptr [rax]
    vmovsd  xmm7, qword ptr [rax+10h]
  }
  v20 = _RAX->array[6];
  __asm { vmovups xmmword ptr [rsp+0A8h+result.array], xmm6 }
LABEL_16:
  if ( !Com_GameMode_SupportsFeature(WEAPON_RAISING_ALTSWITCH) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 23450, ASSERT_TYPE_ASSERT, "( G_Bot_UseBadPlaceRestrictions() )", (const char *)&queryFormat, "G_Bot_UseBadPlaceRestrictions()") )
    __debugbreak();
  if ( !Com_GameMode_SupportsFeature(WEAPON_RAISING_ALTSWITCH) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 23340, ASSERT_TYPE_ASSERT, "( G_Bot_UseBadPlaceRestrictions() )", (const char *)&queryFormat, "G_Bot_UseBadPlaceRestrictions()") )
    __debugbreak();
  if ( !Path_UsePathExtraData() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 23341, ASSERT_TYPE_ASSERT, "( Path_UsePathExtraData() )", (const char *)&queryFormat, "Path_UsePathExtraData()") )
    __debugbreak();
  __asm { vmovd   edi, xmm6 }
  result.array[0] = _EDI;
  if ( _EDI < 0 && Scr_GetNumParam(scrContext) > 2 )
  {
    do
    {
      if ( Scr_GetConstString(scrContext, v6) == scr_const.only_sky )
      {
        v7 |= 1u;
        _EDI &= ~0x80000000;
      }
      ++v6;
    }
    while ( v6 < Scr_GetNumParam(scrContext) );
    result.array[0] = _EDI;
    __asm { vmovups xmm6, xmmword ptr [rsp+0A8h+result.array] }
  }
  result.array[6] = v20;
  __asm
  {
    vmovups xmmword ptr [rsp+0A8h+result.array], xmm6
    vmovsd  qword ptr [rsp+0A8h+result.array+10h], xmm7
  }
  if ( !Path_MakeGlobalBadPlace(ConstString, _ER12, &result, v7) )
    Scr_Error(COM_ERR_4654, scrContext, "Error creating BadPlace, see log for details");
  __asm
  {
    vmovaps xmm6, [rsp+0A8h+var_38]
    vmovaps xmm7, [rsp+0A8h+var_48]
  }
}

/*
==============
GScr_GetOwnedVehicle
==============
*/
void GScr_GetOwnedVehicle(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  int *p_commandTime; 
  const char *v7; 
  __int64 v8; 
  EntHandle *p_ownerNum; 
  const gentity_s *v10; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3678, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 4188, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client && !v4->agent )
    {
      v5 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3677, scrContext, v5);
    }
  }
  p_commandTime = &v4->client->ps.commandTime;
  if ( !p_commandTime )
  {
    p_commandTime = &v4->agent->playerState.commandTime;
    if ( !p_commandTime )
    {
      v7 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3679, scrContext, v7);
    }
  }
  if ( GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal((GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *)p_commandTime + 94, ACTIVE, 0xBu) )
  {
    v8 = p_commandTime[72];
    if ( (_DWORD)v8 != 2047 )
      goto LABEL_20;
  }
  p_ownerNum = &v4->r.ownerNum;
  if ( EntHandle::isDefined(p_ownerNum) && EntHandle::ent(p_ownerNum)->vehicle )
  {
    v10 = EntHandle::ent(p_ownerNum);
    GScr_AddEntity(v10);
    return;
  }
  if ( GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal((GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64> *)(p_commandTime + 5), ACTIVE, 0x1Cu) )
  {
    LOWORD(v8) = *((_WORD *)p_commandTime + 78);
    if ( (_WORD)v8 != 2047 )
    {
      v8 = (__int16)v8;
LABEL_20:
      GScr_AddEntity(&g_entities[v8]);
      return;
    }
  }
  Scr_AddUndefined(scrContext);
}

/*
==============
GScr_Turret_GetOwner
==============
*/
void GScr_Turret_GetOwner(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  const char *v5; 
  const char *v6; 
  const gentity_s *v7; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4022, scrContext, v6);
  }
  if ( v4->active )
  {
    if ( EntHandle::isDefined(&v4->r.ownerNum) )
    {
      v7 = EntHandle::ent(&v4->r.ownerNum);
      GScr_AddEntity(v7);
    }
    else
    {
      GScr_AddEntity(g_entities + 2047);
    }
  }
}

/*
==============
GScr_Turret_SetSentryOwner
==============
*/
void GScr_Turret_SetSentryOwner(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  const char *v5; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  const gentity_s *v9; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4023, scrContext, v6);
  }
  if ( (GTurret::GetTurret(&v4->turretHandle)->m_data.flags & 0xC) == 0 )
  {
    v7 = j_va("turret number '%i' is not auto or sentry", (unsigned int)v4->s.number);
    Scr_Error(COM_ERR_4024, scrContext, v7);
  }
  if ( Scr_GetType(scrContext, 0) )
  {
    v9 = GScr_GetEntity(0);
    if ( !G_Utils_IsClientOrActor(v9) )
      Scr_ParamError(COM_ERR_4026, scrContext, 0, "turrets can only be owned by clients or actors");
  }
  else
  {
    if ( v4->s.staticState.player.stowedWeaponHandle.m_mapEntryId != 2047 )
    {
      v8 = j_va("turret number '%i' is being carried and cannot have its owner cleared.", (unsigned int)v4->s.number);
      Scr_Error(COM_ERR_4025, scrContext, v8);
    }
    v9 = NULL;
  }
  G_Turret_SetSentryOwner(v4, v9);
}

/*
==============
Scr_HaveMapEntsEffects
==============
*/
void Scr_HaveMapEntsEffects(scrContext_t *scrContext)
{
  Scr_AddBool(scrContext, cm.mapEnts->createFxEffectTotal != 0);
}

/*
==============
GScr_Turret_SetTurretOwner
==============
*/
void GScr_Turret_SetTurretOwner(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  const char *v5; 
  const char *v6; 
  const char *v7; 
  const gentity_s *v8; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4027, scrContext, v6);
  }
  if ( Scr_GetType(scrContext, 0) )
  {
    v8 = GScr_GetEntity(0);
    if ( !G_Utils_IsClientOrActor(v8) )
      Scr_ParamError(COM_ERR_4029, scrContext, 0, "turrets can only be owned by clients or actors");
  }
  else
  {
    if ( v4->s.staticState.player.stowedWeaponHandle.m_mapEntryId != 2047 )
    {
      v7 = j_va("turret number '%i' is being carried and cannot have its owner cleared.", (unsigned int)v4->s.number);
      Scr_Error(COM_ERR_4028, scrContext, v7);
    }
    v8 = NULL;
  }
  G_Turret_SetSentryOwner(v4, v8);
}

/*
==============
GScr_Turret_SetSentryCarrier
==============
*/
void GScr_Turret_SetSentryCarrier(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  const char *v5; 
  const char *v6; 
  const char *v7; 
  const gentity_s *v8; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4030, scrContext, v6);
  }
  if ( (GTurret::GetTurret(&v4->turretHandle)->m_data.flags & 8) == 0 )
  {
    v7 = j_va("turret number '%i' is not a sentry", (unsigned int)v4->s.number);
    Scr_Error(COM_ERR_4031, scrContext, v7);
  }
  if ( Scr_GetType(scrContext, 0) )
  {
    v8 = GScr_GetEntity(0);
    if ( !G_Utils_IsClientOrActor(v8) )
      Scr_ParamError(COM_ERR_4032, scrContext, 0, "turrets can only be carried by clients or actors");
  }
  else
  {
    v8 = NULL;
  }
  G_Turret_ScrSetSentryCarrier(v4, v8);
}

/*
==============
GScr_Turret_SetMinimapVisible
==============
*/
void GScr_Turret_SetMinimapVisible(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *v4; 
  const char *v5; 
  const char *v6; 
  unsigned int Int; 
  const char *String; 
  GTurret *Turret; 

  Entity = GetEntity(entref);
  v4 = (const BgObjectHandle<GTurret> *)Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4033, scrContext, v6);
  }
  Int = Scr_GetInt(scrContext, 0);
  if ( Scr_GetNumParam(scrContext) < 2 )
    String = NULL;
  else
    String = Scr_GetString(scrContext, 1u);
  Turret = GTurret::GetTurret(v4 + 94);
  Turret->SetMinimapVisible(Turret, (gentity_s *)v4, Int, String);
}

/*
==============
GScr_Turret_SetTargetEntity
==============
*/
void GScr_Turret_SetTargetEntity(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 
  const gentity_s *v8; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4034, scrContext, v6);
  }
  Turret = GTurret::GetTurret(p_turretHandle);
  v8 = GScr_GetEntity(0);
  EntHandle::setEnt(&Turret->m_data.manualTarget, v8);
  if ( Scr_GetNumParam(scrContext) <= 1 )
  {
    *(_QWORD *)Turret->m_data.manualTargetOffset.v = 0i64;
    Turret->m_data.manualTargetOffset.v[2] = 0.0;
  }
  else
  {
    Scr_GetVector(scrContext, 1u, &Turret->m_data.manualTargetOffset);
  }
}

/*
==============
Scr_ActivateClientExploder
==============
*/

void __fastcall Scr_ActivateClientExploder(scrContext_t *scrContext, __int64 a2, double _XMM2_8)
{
  gentity_s *v5; 
  __int64 v6; 
  unsigned int ArrayObject; 
  unsigned int ArraySize; 
  int maxclients; 
  const char *NameForType; 
  const char *v11; 
  scr_entref_t EntityIdRef; 
  gentity_s *Entity; 
  gentity_s *v14; 
  const char *v15; 
  unsigned int *failureIndex; 
  VariableType failureType[4]; 
  unsigned int count; 
  unsigned int v26; 
  unsigned int outExploderID; 
  unsigned int buffer[200]; 

  if ( !Com_GameMode_SupportsFeature(WEAPON_RECHAMBERING) )
    Scr_Error(COM_ERR_4657, scrContext, "ActivateClientExploder is not supported in this game mode");
  if ( !Scr_GetNumParam(scrContext) || Scr_GetNumParam(scrContext) > 3 )
    Scr_Error(COM_ERR_6562, scrContext, "Incorrect number of parameters: ActivateClientExploder( exploder_num, <optional_player>, <optional_startTime> )\n");
  if ( Scr_GetExploderID(scrContext, &outExploderID) )
  {
    v5 = G_Utils_SpawnEventEntity(&vec3_origin, 195);
    if ( !v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 23600, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
      __debugbreak();
    if ( v5->s.lerp.apos.trType && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 23601, ASSERT_TYPE_SANITY, "( ent->s.lerp.apos.trType == TR_STATIONARY )", (const char *)&queryFormat, "ent->s.lerp.apos.trType == TR_STATIONARY") )
      __debugbreak();
    if ( Scr_GetNumParam(scrContext) >= 2 && Scr_GetType(scrContext, 1u) )
    {
      v6 = 0i64;
      count = 0;
      GScr_Main_ClientmaskSetAllHidden(v5);
      if ( Scr_GetType(scrContext, 1u) == VAR_POINTER && Scr_GetPointerType(scrContext, 1u) == VAR_ARRAY )
      {
        ArrayObject = BGScr_Main_GetArrayObject(scrContext, 1u);
        ArraySize = GetArraySize(scrContext, ArrayObject);
        maxclients = level.maxclients;
        count = ArraySize;
        if ( level.maxclients < 1 || (unsigned __int64)level.maxclients > 0xC8 )
        {
          LODWORD(failureIndex) = level.maxclients;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 23613, ASSERT_TYPE_ASSERT, "( 1 ) <= ( level.maxclients ) && ( level.maxclients ) <= ( ( sizeof( *array_counter( entities ) ) + 0 ) )", "level.maxclients not in [1, ARRAY_COUNT( entities )]\n\t%i not in [%i, %i]", failureIndex, 1, 200) )
            __debugbreak();
          maxclients = level.maxclients;
        }
        if ( !Scr_GetEntityArray(scrContext, ArrayObject, maxclients, buffer, &count, &v26, failureType) )
        {
          NameForType = Scr_GetNameForType(failureType[0]);
          v11 = j_va("element %i of array: type %s is not an entity", v26, NameForType);
          Scr_ParamError(COM_ERR_6563, scrContext, 0, v11);
        }
      }
      else if ( Scr_GetType(scrContext, 1u) == VAR_POINTER && Scr_GetPointerType(scrContext, 1u) == VAR_ENTITY )
      {
        count = 1;
        buffer[0] = Scr_GetObject(scrContext, 1u);
      }
      if ( count )
      {
        do
        {
          EntityIdRef = Scr_GetEntityIdRef(scrContext, buffer[v6]);
          Entity = GetEntity(EntityIdRef);
          v14 = Entity;
          if ( !Entity->client )
          {
            v15 = j_va("entity %i is not a player", (unsigned int)Entity->s.number);
            Scr_ObjectError(COM_ERR_6564, scrContext, v15);
          }
          GScr_Main_ClientmaskSetFlagVisible(v5, v14->s.number);
          v6 = (unsigned int)(v6 + 1);
        }
        while ( (unsigned int)v6 < count );
      }
    }
    v5->s.eventParm = outExploderID;
    if ( Scr_GetNumParam(scrContext) == 3 && Scr_GetType(scrContext, 2u) )
    {
      *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
      __asm
      {
        vmulss  xmm1, xmm0, cs:__real@447a0000
        vaddss  xmm3, xmm1, cs:__real@3f000000
        vxorps  xmm2, xmm2, xmm2
        vmovss  xmm4, xmm2, xmm3
        vxorps  xmm0, xmm0, xmm0
        vroundss xmm1, xmm0, xmm4, 1
        vcvttss2si eax, xmm1
      }
    }
    else
    {
      _EAX = level.time;
    }
    v5->s.time2 = _EAX;
  }
}

/*
==============
GScr_Turret_GetTargetEntity
==============
*/
void GScr_Turret_GetTargetEntity(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 
  const gentity_s *v8; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4035, scrContext, v6);
  }
  Turret = GTurret::GetTurret(p_turretHandle);
  if ( !Scr_GetNumParam(scrContext) || !Scr_GetInt(scrContext, 0) || (Turret->m_data.flags & 0x20) != 0 )
  {
    if ( EntHandle::isDefined(&Turret->m_data.manualTarget) )
    {
      v8 = EntHandle::ent(&Turret->m_data.manualTarget);
      GScr_AddEntity(v8);
    }
  }
}

/*
==============
GScr_Turret_SnapToTargetEntity
==============
*/
void GScr_Turret_SnapToTargetEntity(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  const char *v5; 
  const char *v6; 
  const gentity_s *v8; 
  int v12; 
  int v13; 
  int v14; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4036, scrContext, v6);
  }
  _RBP = GTurret::GetTurret(&v4->turretHandle);
  v8 = GScr_GetEntity(0);
  EntHandle::setEnt(&_RBP->m_data.manualTarget, v8);
  if ( Scr_GetNumParam(scrContext) <= 1 )
  {
    *(_QWORD *)_RBP->m_data.manualTargetOffset.v = 0i64;
    _RBP->m_data.manualTargetOffset.v[2] = 0.0;
  }
  else
  {
    Scr_GetVector(scrContext, 1u, &_RBP->m_data.manualTargetOffset);
    __asm
    {
      vmovss  xmm0, dword ptr [rbp+60h]
      vmovss  [rsp+28h+arg_10], xmm0
    }
    if ( (v12 & 0x7F800000) == 2139095040 )
      goto LABEL_7;
    __asm
    {
      vmovss  xmm0, dword ptr [rbp+64h]
      vmovss  [rsp+28h+arg_10], xmm0
    }
    if ( (v13 & 0x7F800000) == 2139095040 )
      goto LABEL_7;
    __asm
    {
      vmovss  xmm0, dword ptr [rbp+68h]
      vmovss  [rsp+28h+arg_10], xmm0
    }
    if ( (v14 & 0x7F800000) == 2139095040 )
LABEL_7:
      Scr_ParamError(COM_ERR_4037, scrContext, 1u, "Vector target offset has NAN");
  }
  G_Turret_ScrSnapToTarget(scrContext, v4);
}

/*
==============
GScr_Turret_ClearTarget
==============
*/
void GScr_Turret_ClearTarget(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4038, scrContext, v6);
  }
  Turret = GTurret::GetTurret(p_turretHandle);
  EntHandle::setEnt(&Turret->m_data.manualTarget, NULL);
}

/*
==============
GScr_Turret_GetTarget
==============
*/
void GScr_Turret_GetTarget(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 
  const gentity_s *v8; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4039, scrContext, v6);
  }
  Turret = GTurret::GetTurret(p_turretHandle);
  if ( !Scr_GetInt(scrContext, 0) || (Turret->m_data.flags & 0x20) != 0 )
  {
    if ( EntHandle::isDefined(&Turret->m_data.target) )
    {
      v8 = EntHandle::ent(&Turret->m_data.target);
      GScr_AddEntity(v8);
    }
  }
}

/*
==============
GScr_Turret_GetTurretWeaponInfo
==============
*/
void GScr_Turret_GetTurretWeaponInfo(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const entityState_t *p_s; 
  const Weapon *WeaponForEntity; 
  GWeaponMap *Instance; 

  Entity = GetEntity(entref);
  p_s = &Entity->s;
  if ( Entity->turretHandle.m_objIndex || Entity->vehicle )
  {
    Instance = GWeaponMap::GetInstance();
    WeaponForEntity = BG_GetWeaponForEntity(Instance, p_s);
  }
  else
  {
    WeaponForEntity = &NULL_WEAPON;
  }
  GScr_Weapon_AddParam(scrContext, WeaponForEntity, 0);
}

/*
==============
GScr_Turret_SetPlayerSpread
==============
*/
void GScr_Turret_SetPlayerSpread(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v6; 
  const char *v7; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v6 = SL_ConvertToString(Entity->classname);
    v7 = j_va("entity type '%s' is not a turret", v6);
    Scr_Error(COM_ERR_4040, scrContext, v7);
  }
  _RBX = GTurret::GetTurret(p_turretHandle);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm { vmovss  dword ptr [rbx+48h], xmm0 }
}

/*
==============
Scr_StopClientExploder
==============
*/
void Scr_StopClientExploder(scrContext_t *scrContext)
{
  int Int; 
  int v3; 
  gentity_s *v4; 
  int maxclients; 
  __int64 v6; 
  unsigned int ArrayObject; 
  const char *NameForType; 
  const char *v9; 
  scr_entref_t EntityIdRef; 
  gentity_s *Entity; 
  gentity_s *v12; 
  const char *v13; 
  VariableType failureType[4]; 
  unsigned int count; 
  unsigned int failureIndex; 
  unsigned int outExploderID; 
  unsigned int buffer[200]; 

  if ( !Com_GameMode_SupportsFeature(WEAPON_RECHAMBERING) )
    Scr_Error(COM_ERR_4661, scrContext, "StopClientExploder is not supported in this game mode");
  if ( !Scr_GetNumParam(scrContext) || Scr_GetNumParam(scrContext) > 3 )
    Scr_Error(COM_ERR_4662, scrContext, "Incorrect number of parameters: StopClientExploder( exploder_num, <optional_player>, <optional_kill> )\n");
  if ( Scr_GetExploderID(scrContext, &outExploderID) )
  {
    if ( Scr_GetNumParam(scrContext) < 3 || Scr_GetType(scrContext, 2u) == VAR_UNDEFINED || (Int = Scr_GetInt(scrContext, 2u), v3 = 197, !Int) )
      v3 = 196;
    v4 = G_Utils_SpawnEventEntity(&vec3_origin, v3);
    if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 23690, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
      __debugbreak();
    if ( v4->s.lerp.apos.trType && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 23691, ASSERT_TYPE_SANITY, "( ent->s.lerp.apos.trType == TR_STATIONARY )", (const char *)&queryFormat, "ent->s.lerp.apos.trType == TR_STATIONARY") )
      __debugbreak();
    if ( Scr_GetNumParam(scrContext) >= 2 && Scr_GetType(scrContext, 1u) )
    {
      GScr_Main_ClientmaskSetAllHidden(v4);
      if ( level.maxclients > 200 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 23700, ASSERT_TYPE_ASSERT, "( level.maxclients <= ((1 >= 200) ? 1 : 200) )", (const char *)&queryFormat, "level.maxclients <= MAX_CLIENTS_STATIC") )
        __debugbreak();
      maxclients = level.maxclients;
      v6 = 0i64;
      count = 0;
      if ( Scr_GetType(scrContext, 1u) == VAR_POINTER )
      {
        if ( Scr_GetPointerType(scrContext, 1u) == VAR_ARRAY )
        {
          ArrayObject = BGScr_Main_GetArrayObject(scrContext, 1u);
          count = GetArraySize(scrContext, ArrayObject);
          if ( !Scr_GetEntityArray(scrContext, ArrayObject, maxclients, buffer, &count, &failureIndex, failureType) )
          {
            NameForType = Scr_GetNameForType(failureType[0]);
            v9 = j_va("element %u of array: type %s is not an entity", failureIndex, NameForType);
            Scr_ParamError(COM_ERR_4655, scrContext, 1u, v9);
          }
        }
        else if ( Scr_GetPointerType(scrContext, 1u) == VAR_ENTITY )
        {
          count = 1;
          if ( !maxclients && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 23487, ASSERT_TYPE_ASSERT, "( entBufferSize >= 1 )", (const char *)&queryFormat, "entBufferSize >= 1") )
            __debugbreak();
          buffer[0] = Scr_GetObject(scrContext, 1u);
        }
      }
      if ( count )
      {
        do
        {
          EntityIdRef = Scr_GetEntityIdRef(scrContext, buffer[v6]);
          Entity = GetEntity(EntityIdRef);
          v12 = Entity;
          if ( !Entity->client )
          {
            v13 = j_va("entity %i is not a player", (unsigned int)Entity->s.number);
            Scr_ObjectError(COM_ERR_4663, scrContext, v13);
          }
          GScr_Main_ClientmaskSetFlagVisible(v4, v12->s.number);
          v6 = (unsigned int)(v6 + 1);
        }
        while ( (unsigned int)v6 < count );
      }
    }
    v4->s.eventParm = outExploderID;
  }
}

/*
==============
GScr_Turret_SetConvergenceTime
==============
*/
void GScr_Turret_SetConvergenceTime(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v6; 
  const char *v7; 
  __int64 v8; 
  const char *String; 
  __int64 v10; 
  char v11; 
  __int64 v12; 
  char v13; 
  GTurret *Turret; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v6 = SL_ConvertToString(Entity->classname);
    v7 = j_va("entity type '%s' is not a turret", v6);
    Scr_Error(COM_ERR_4041, scrContext, v7);
  }
  v8 = 1i64;
  if ( (int)Scr_GetNumParam(scrContext) > 1 )
  {
    String = Scr_GetString(scrContext, 1u);
    v10 = 0i64;
    while ( 1 )
    {
      v11 = String[v10++];
      if ( v11 != aYaw[v10 - 1] )
        break;
      if ( v10 == 4 )
        goto LABEL_13;
    }
    v12 = 0i64;
    while ( 1 )
    {
      v13 = String[v12++];
      if ( v13 != aPitch[v12 - 1] )
        break;
      if ( v12 == 6 )
      {
        v8 = 0i64;
        goto LABEL_13;
      }
    }
    Scr_Error(COM_ERR_4042, scrContext, "Convergence type should be either 'pitch' or 'yaw'");
  }
LABEL_13:
  Turret = GTurret::GetTurret(p_turretHandle);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm
  {
    vmulss  xmm1, xmm0, cs:__real@447a0000
    vcvttss2si ecx, xmm1
  }
  Turret->m_data.convergenceTime[v8] = _ECX;
}

/*
==============
GScr_Turret_SetConvergenceHeightPercent
==============
*/
void GScr_Turret_SetConvergenceHeightPercent(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v9; 
  const char *v10; 
  char v11; 
  char v12; 
  double v21; 
  double v22; 
  double v23; 

  __asm
  {
    vmovaps [rsp+68h+var_18], xmm6
    vmovaps [rsp+68h+var_28], xmm8
  }
  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v9 = SL_ConvertToString(Entity->classname);
    v10 = j_va("entity type '%s' is not a turret", v9);
    Scr_Error(COM_ERR_4043, scrContext, v10);
  }
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4044, scrContext, "expecting one float argument");
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm
  {
    vxorps  xmm8, xmm8, xmm8
    vcomiss xmm0, xmm8
    vmovaps xmm6, xmm0
  }
  if ( v11 )
    goto LABEL_7;
  __asm { vcomiss xmm0, cs:__real@3f800000 }
  if ( !(v11 | v12) )
LABEL_7:
    Scr_ParamError(COM_ERR_4045, scrContext, 0, "<scaler> must between 0 and 1 inclusive");
  __asm { vcomiss xmm6, xmm8 }
  if ( v11 )
    goto LABEL_10;
  __asm { vcomiss xmm6, cs:__real@3f800000 }
  if ( !(v11 | v12) )
  {
LABEL_10:
    __asm
    {
      vmovsd  xmm0, cs:__real@3ff0000000000000
      vmovsd  [rsp+68h+var_30], xmm0
      vxorpd  xmm1, xmm1, xmm1
      vmovsd  [rsp+68h+var_38], xmm1
      vcvtss2sd xmm2, xmm6, xmm6
      vmovsd  [rsp+68h+var_40], xmm2
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 4681, ASSERT_TYPE_ASSERT, "( 0.f ) <= ( percent ) && ( percent ) <= ( 1.f )", "percent not in [0.f, 1.f]\n\t%g not in [%g, %g]", v21, v22, v23) )
      __debugbreak();
  }
  _RAX = GTurret::GetTurret(p_turretHandle);
  __asm
  {
    vmovaps xmm8, [rsp+68h+var_28]
    vmovss  dword ptr [rax+8Ch], xmm6
    vmovaps xmm6, [rsp+68h+var_18]
  }
}

/*
==============
Scr_TrajectoryCalculateInitialVelocity
==============
*/
void Scr_TrajectoryCalculateInitialVelocity(scrContext_t *scrContext)
{
  vec3_t returnVector; 
  vec3_t gravityVector; 
  vec3_t endPos; 
  vec3_t vectorValue; 

  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmovss  dword ptr [rsp+88h+var_58], xmm0
    vmovss  dword ptr [rsp+88h+var_58+4], xmm0
    vmovss  dword ptr [rsp+88h+var_58+8], xmm0
  }
  if ( Scr_GetNumParam(scrContext) == 4 )
  {
    Scr_GetVector(scrContext, 0, &vectorValue);
    Scr_GetVector(scrContext, 1u, &endPos);
    Scr_GetVector(scrContext, 2u, &gravityVector);
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
    __asm { vmovaps xmm3, xmm0; totalTime }
    TrajectoryCalculateInitialVelocity(&vectorValue, &endPos, &gravityVector, *(const float *)&_XMM3, &returnVector);
  }
  else
  {
    Scr_Error(COM_ERR_4664, scrContext, "Wrong number of parameters to TrajectoryCalculateInitialVelocity()!");
  }
  Scr_AddVector(scrContext, returnVector.v);
}

/*
==============
Scr_TrajectoryCalculateMinimumVelocity
==============
*/
void Scr_TrajectoryCalculateMinimumVelocity(scrContext_t *scrContext)
{
  vec3_t endPos; 
  vec3_t vectorValue; 

  __asm
  {
    vmovaps [rsp+68h+var_18], xmm6
    vxorps  xmm6, xmm6, xmm6
  }
  if ( Scr_GetNumParam(scrContext) == 3 )
  {
    Scr_GetVector(scrContext, 0, &vectorValue);
    Scr_GetVector(scrContext, 1u, &endPos);
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
    __asm { vmovaps xmm2, xmm0; gravity }
    *(double *)&_XMM0 = TrajectoryCalculateMinimumVelocity(&vectorValue, &endPos, *(const float *)&_XMM2);
    __asm { vmovaps xmm6, xmm0 }
  }
  else
  {
    Scr_Error(COM_ERR_4665, scrContext, "Wrong number of parameters to TrajectoryCalculateMinimumVelocity()!");
  }
  __asm { vmovaps xmm1, xmm6; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
  __asm { vmovaps xmm6, [rsp+68h+var_18] }
}

/*
==============
GScr_Turret_SetTeam
==============
*/
void GScr_Turret_SetTeam(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 
  scr_string_t ConstString; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4046, scrContext, v6);
  }
  Turret = GTurret::GetTurret(p_turretHandle);
  ConstString = Scr_GetConstString(scrContext, 0);
  Turret->ScrSetTeam(Turret, scrContext, ConstString);
}

/*
==============
Scr_TrajectoryCalculateExitAngle
==============
*/
void Scr_TrajectoryCalculateExitAngle(scrContext_t *scrContext)
{
  __asm
  {
    vmovaps [rsp+58h+var_18], xmm6
    vxorps  xmm6, xmm6, xmm6
  }
  if ( Scr_GetNumParam(scrContext) == 4 )
  {
    __asm
    {
      vmovaps [rsp+58h+var_28], xmm7
      vmovaps [rsp+58h+var_38], xmm8
    }
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
    __asm { vmovaps xmm8, xmm0 }
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
    __asm { vmovaps xmm7, xmm0 }
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
    __asm { vmovaps xmm6, xmm0 }
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
    __asm
    {
      vmovaps xmm3, xmm0; verticalDistance
      vmovaps xmm0, xmm8; velocity
      vmovaps xmm2, xmm6; horizontalDistance
      vmovaps xmm1, xmm7; gravity
    }
    *(double *)&_XMM0 = TrajectoryCalculateExitAngle(*(const float *)&_XMM0, *(const float *)&_XMM1, *(const float *)&_XMM2, *(const float *)&_XMM3);
    __asm
    {
      vmovaps xmm8, [rsp+58h+var_38]
      vmovaps xmm7, [rsp+58h+var_28]
      vmovaps xmm6, xmm0
    }
  }
  else
  {
    Scr_Error(COM_ERR_4666, scrContext, "Wrong number of parameters to TrajectoryCalculateExitAngle()!");
  }
  __asm
  {
    vmovaps xmm1, xmm6; value
    vmovaps xmm6, [rsp+58h+var_18]
  }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
GScr_Turret_MakeOperable
==============
*/
void GScr_Turret_MakeOperable(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4047, scrContext, v6);
  }
  Turret = GTurret::GetTurret(p_turretHandle);
  Turret->m_data.flags &= ~0x200u;
}

/*
==============
Scr_TrajectoryEstimateDesiredInAirTime
==============
*/
void Scr_TrajectoryEstimateDesiredInAirTime(scrContext_t *scrContext)
{
  vec3_t endPos; 
  vec3_t vectorValue; 

  __asm
  {
    vmovaps [rsp+68h+var_18], xmm6
    vxorps  xmm6, xmm6, xmm6
  }
  if ( Scr_GetNumParam(scrContext) == 4 )
  {
    Scr_GetVector(scrContext, 0, &vectorValue);
    Scr_GetVector(scrContext, 1u, &endPos);
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
    __asm { vmovaps xmm6, xmm0 }
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
    __asm
    {
      vmovaps xmm3, xmm0; gravity
      vmovaps xmm2, xmm6; velocity
    }
    *(double *)&_XMM0 = TrajectoryEstimateDesiredInAirTime(&vectorValue, &endPos, *(const float *)&_XMM2, *(const float *)&_XMM3);
    __asm { vmovaps xmm6, xmm0 }
  }
  else
  {
    Scr_Error(COM_ERR_4667, scrContext, "Wrong number of parameters to TrajectoryEstimateDesiredInAirTime()!");
  }
  __asm { vmovaps xmm1, xmm6; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
  __asm { vmovaps xmm6, [rsp+68h+var_18] }
}

/*
==============
GScr_Turret_MakeInoperable
==============
*/
void GScr_Turret_MakeInoperable(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4048, scrContext, v6);
  }
  Turret = GTurret::GetTurret(p_turretHandle);
  Turret->m_data.flags |= 0x200u;
}

/*
==============
GScr_Turret_IsInoperable
==============
*/
void GScr_Turret_IsInoperable(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_5916, scrContext, v6);
  }
  Turret = GTurret::GetTurret(p_turretHandle);
  Scr_AddBool(scrContext, ((unsigned int)Turret->m_data.flags >> 9) & 1);
}

/*
==============
Scr_TrajectoryComputeDeltaHeightAtTime
==============
*/
void Scr_TrajectoryComputeDeltaHeightAtTime(scrContext_t *scrContext)
{
  __asm
  {
    vmovaps [rsp+48h+var_18], xmm6
    vxorps  xmm6, xmm6, xmm6
  }
  if ( Scr_GetNumParam(scrContext) == 3 )
  {
    __asm { vmovaps [rsp+48h+var_28], xmm7 }
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
    __asm { vmovaps xmm7, xmm0 }
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
    __asm { vmovaps xmm6, xmm0 }
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
    __asm
    {
      vmovaps xmm2, xmm0; time
      vmovaps xmm0, xmm7; verticalVelocity
      vmovaps xmm1, xmm6; gravity
    }
    *(double *)&_XMM0 = TrajectoryComputeDeltaHeightAtTime(*(const float *)&_XMM0, *(const float *)&_XMM1, *(const float *)&_XMM2);
    __asm
    {
      vmovaps xmm7, [rsp+48h+var_28]
      vmovaps xmm6, xmm0
    }
  }
  else
  {
    Scr_Error(COM_ERR_4668, scrContext, "Wrong number of parameters to TrajectoryComputeDeltaHeightAtTime()!");
  }
  __asm
  {
    vmovaps xmm1, xmm6; value
    vmovaps xmm6, [rsp+48h+var_18]
  }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
GScr_Turret_GetRightArc
==============
*/
void GScr_Turret_GetRightArc(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_5917, scrContext, v6);
  }
  _RAX = GTurret::GetTurret(p_turretHandle);
  __asm
  {
    vmovss  xmm0, dword ptr [rax+20h]
    vxorps  xmm1, xmm0, cs:__xmm@80000000800000008000000080000000; value
  }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
Scr_TrajectoryCanAttemptAccurateJump
==============
*/
void Scr_TrajectoryCanAttemptAccurateJump(scrContext_t *scrContext)
{
  int v4; 
  int CanAttemptAccurateJump; 
  float v8; 
  float v9; 
  vec3_t toNormal; 
  vec3_t toPoint; 
  vec3_t fromNormal; 
  vec3_t vectorValue; 
  PathJumpLinkWorkData workData; 

  v4 = 0;
  if ( Scr_GetNumParam(scrContext) == 6 )
  {
    __asm { vmovaps [rsp+0E8h+var_18], xmm6 }
    Scr_GetVector(scrContext, 0, &vectorValue);
    Scr_GetVector(scrContext, 1u, &fromNormal);
    Scr_GetVector(scrContext, 2u, &toPoint);
    Scr_GetVector(scrContext, 3u, &toNormal);
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 4u);
    __asm { vmovaps xmm6, xmm0 }
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 5u);
    __asm
    {
      vmovss  [rsp+0E8h+var_C0], xmm0
      vmovss  [rsp+0E8h+var_C8], xmm6
    }
    CanAttemptAccurateJump = Path_TrajectoryCanAttemptAccurateJump(&vectorValue, &fromNormal, &toPoint, &toNormal, v8, v9, &workData);
    __asm { vmovaps xmm6, [rsp+0E8h+var_18] }
    if ( CanAttemptAccurateJump )
      v4 = 1;
  }
  else
  {
    Scr_Error(COM_ERR_4669, scrContext, "Wrong number of parameters to TrajectoryCanAttemptAccurateJump()!");
  }
  Scr_AddBool(scrContext, v4);
}

/*
==============
GScr_Turret_SetRightArc
==============
*/
void GScr_Turret_SetRightArc(scrContext_t *scrContext, scr_entref_t entref)
{
  BgObjectHandle<GTurret> *p_turretHandle; 
  char v8; 
  char v9; 

  p_turretHandle = &GetEntity(entref)->turretHandle;
  if ( !p_turretHandle->m_objIndex )
    Scr_Error(COM_ERR_4049, scrContext, "entity is not a turret");
  _RBX = GTurret::GetTurret(p_turretHandle);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm
  {
    vxorps  xmm1, xmm0, cs:__xmm@80000000800000008000000080000000
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm1, xmm0
    vmovss  dword ptr [rbx+20h], xmm1
  }
  if ( !(v8 | v9) )
    _RBX->m_data.arcmin.v[1] = 0.0;
}

/*
==============
GScr_Turret_GetLeftArc
==============
*/
void GScr_Turret_GetLeftArc(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_5716, scrContext, v6);
  }
  _RAX = GTurret::GetTurret(p_turretHandle);
  __asm { vmovss  xmm1, dword ptr [rax+28h]; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
GScr_Turret_SetLeftArc
==============
*/
void GScr_Turret_SetLeftArc(scrContext_t *scrContext, scr_entref_t entref)
{
  BgObjectHandle<GTurret> *p_turretHandle; 
  char v8; 

  p_turretHandle = &GetEntity(entref)->turretHandle;
  if ( !p_turretHandle->m_objIndex )
    Scr_Error(COM_ERR_4050, scrContext, "entity is not a turret");
  _RBX = GTurret::GetTurret(p_turretHandle);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm
  {
    vxorps  xmm1, xmm1, xmm1
    vcomiss xmm0, xmm1
    vmovss  dword ptr [rbx+28h], xmm0
  }
  if ( v8 )
    _RBX->m_data.arcmax.v[1] = 0.0;
}

/*
==============
GScr_drawSoundShape
==============
*/
void GScr_drawSoundShape(scrContext_t *scrContext)
{
  const char *String; 
  SndAliasList *Alias; 
  SndAliasList *v8; 
  SndAlias *head; 
  const char *v11; 
  int v12; 
  char v13; 
  char v14; 
  vec4_t color; 
  vec3_t v35; 
  vec3_t angles; 
  vec3_t vectorValue; 

  if ( Scr_GetNumParam(scrContext) != 5 )
    Scr_Error(COM_ERR_4670, scrContext, "illegal call to drawSoundShape()");
  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &angles);
  String = Scr_GetString(scrContext, 2u);
  Scr_GetVector(scrContext, 3u, &v35);
  __asm
  {
    vmovss  xmm0, dword ptr [rsp+98h+var_58]
    vmovss  xmm1, dword ptr [rsp+98h+var_58+4]
    vmovss  dword ptr [rsp+98h+var_68], xmm0
    vmovss  xmm0, dword ptr [rsp+98h+var_58+8]
    vmovss  dword ptr [rsp+98h+var_68+8], xmm0
    vmovss  dword ptr [rsp+98h+var_68+4], xmm1
  }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 4u);
  __asm { vmovss  dword ptr [rsp+98h+var_68+0Ch], xmm0 }
  if ( String )
  {
    if ( *String )
    {
      Alias = SND_TryFindAlias(String);
      v8 = Alias;
      if ( Alias )
      {
        if ( Alias->count )
        {
          head = Alias->head;
          if ( head )
          {
            _RDI = SND_GetOcclusionShapeById(head->occlusionShape);
            if ( _RDI )
            {
              v11 = "default";
              v12 = 5381;
              v13 = 100;
              do
              {
                ++v11;
                v14 = v13 | 0x20;
                if ( (unsigned int)(v13 - 65) >= 0x1A )
                  v14 = v13;
                v12 = 65599 * v12 + v14;
                v13 = *v11;
              }
              while ( *v11 );
              if ( !v12 )
                v12 = 1;
              if ( _RDI->id != v12 )
              {
                _RAX = v8->head;
                __asm
                {
                  vmovss  xmm2, cs:__real@42b40000; max
                  vmovss  xmm1, cs:__real@c2b40000; min
                  vmovss  xmm0, dword ptr [rdi+48h]; val
                  vmovaps [rsp+98h+var_18], xmm6
                  vmovss  xmm6, dword ptr [rax+68h]
                }
                *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
                __asm
                {
                  vmovaps xmm3, xmm6; range
                  vmovaps xmm2, xmm0; coneAngle
                }
                Scr_DrawCone(&vectorValue, &angles, *(float *)&_XMM2, *(float *)&_XMM3, &color);
                __asm
                {
                  vmovss  xmm5, cs:__real@3f000000
                  vmulss  xmm0, xmm5, dword ptr [rsp+98h+var_68+4]
                  vmulss  xmm3, xmm5, dword ptr [rsp+98h+var_68]
                  vmulss  xmm4, xmm5, dword ptr [rsp+98h+var_68+8]
                  vmovss  xmm2, cs:__real@42b40000; max
                  vmovss  xmm1, cs:__real@c2b40000; min
                  vmovss  dword ptr [rsp+98h+var_68], xmm3
                  vmovss  dword ptr [rsp+98h+var_68+4], xmm0
                  vmovss  dword ptr [rsp+98h+var_68+8], xmm4
                }
                _RAX = v8->head;
                __asm
                {
                  vmovss  xmm0, dword ptr [rdi+44h]; val
                  vmovss  xmm6, dword ptr [rax+68h]
                }
                *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
                __asm
                {
                  vmovaps xmm3, xmm6; range
                  vmovaps xmm2, xmm0; coneAngle
                }
                Scr_DrawCone(&vectorValue, &angles, *(float *)&_XMM2, *(float *)&_XMM3, &color);
                __asm { vmovaps xmm6, [rsp+98h+var_18] }
              }
            }
          }
        }
      }
    }
  }
}

/*
==============
GScr_Turret_GetTopArc
==============
*/
void GScr_Turret_GetTopArc(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_5717, scrContext, v6);
  }
  _RAX = GTurret::GetTurret(p_turretHandle);
  __asm
  {
    vmovss  xmm0, dword ptr [rax+1Ch]
    vxorps  xmm1, xmm0, cs:__xmm@80000000800000008000000080000000; value
  }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
GScr_Turret_SetTopArc
==============
*/
void GScr_Turret_SetTopArc(scrContext_t *scrContext, scr_entref_t entref)
{
  BgObjectHandle<GTurret> *p_turretHandle; 
  char v8; 
  char v9; 

  p_turretHandle = &GetEntity(entref)->turretHandle;
  if ( !p_turretHandle->m_objIndex )
    Scr_Error(COM_ERR_4051, scrContext, "entity is not a turret");
  _RBX = GTurret::GetTurret(p_turretHandle);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm
  {
    vxorps  xmm1, xmm0, cs:__xmm@80000000800000008000000080000000
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm1, xmm0
    vmovss  dword ptr [rbx+1Ch], xmm1
  }
  if ( !(v8 | v9) )
    _RBX->m_data.arcmin.v[0] = 0.0;
}

/*
==============
GScr_SendScriptUsageAnalysisData
==============
*/
void GScr_SendScriptUsageAnalysisData(scrContext_t *scrContext)
{
  int Int; 
  ScriptInstanceType v3; 

  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_Error(COM_ERR_4671, scrContext, "sendScriptUsageAnalysisData: Must have two int parameters. First indicates report to log, the second to black box server.");
  if ( script_usage_tracking && script_usage_tracking->current.integer )
  {
    Int = Scr_GetInt(scrContext, 0);
    v3 = g_reportScriptContextUsage;
    if ( Int )
      v3 = SCRIPTINSTANCE_SERVER;
    g_reportScriptContextUsage = v3;
    if ( Scr_GetInt(scrContext, 1u) )
      Scr_ScriptProfilePrintUsageReportToBlackBox(scrContext);
  }
}

/*
==============
GScr_Turret_GetBottomArc
==============
*/
void GScr_Turret_GetBottomArc(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_5718, scrContext, v6);
  }
  _RAX = GTurret::GetTurret(p_turretHandle);
  __asm { vmovss  xmm1, dword ptr [rax+24h]; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
GScr_ResetScriptUsageAnalysisData
==============
*/

void __fastcall GScr_ResetScriptUsageAnalysisData(scrContext_t *scrContext)
{
  Scr_ScriptProfileResetUsageReport(scrContext);
}

/*
==============
GScr_InstantlyLogUsageAnalysisData
==============
*/

void __fastcall GScr_InstantlyLogUsageAnalysisData(scrContext_t *scrContext, double _XMM1_8)
{
  Scr_CalcScriptProfileTrackServerTime(scrContext);
  __asm { vxorps  xmm1, xmm1, xmm1; framtTime }
  Profile_TrackUsageAnalysis(scrContext, *(float *)&_XMM1, 1);
  Scr_ScriptProfilePrintUsageReportToLog(scrContext);
}

/*
==============
GScr_Turret_SetBottomArc
==============
*/
void GScr_Turret_SetBottomArc(scrContext_t *scrContext, scr_entref_t entref)
{
  BgObjectHandle<GTurret> *p_turretHandle; 
  char v8; 

  p_turretHandle = &GetEntity(entref)->turretHandle;
  if ( !p_turretHandle->m_objIndex )
    Scr_Error(COM_ERR_4052, scrContext, "entity is not a turret");
  _RBX = GTurret::GetTurret(p_turretHandle);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm
  {
    vxorps  xmm1, xmm1, xmm1
    vcomiss xmm0, xmm1
    vmovss  dword ptr [rbx+24h], xmm0
  }
  if ( v8 )
    _RBX->m_data.arcmax.v[0] = 0.0;
}

/*
==============
Scr_GetEnt
==============
*/
void Scr_GetEnt(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const char *String; 
  int Offset; 

  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_Error(COM_ERR_4672, scrContext, "GetEnt() requires two arguments (name, key)");
  ConstString = Scr_GetConstString(scrContext, 0);
  String = Scr_GetString(scrContext, 1u);
  Offset = Scr_GetOffset(scrContext, ENTITY_CLASS_GENTITY, String);
  if ( Offset >= 0 )
  {
    if ( (Offset & 0xE000) != 0 )
      Scr_ParamError(COM_ERR_4673, scrContext, 1u, "GetEnt() key must be a generic entity key");
    else
      Scr_GetGenericEnt(scrContext, Offset, String, ConstString, 0, "GetEnt()");
  }
}

/*
==============
GScr_Turret_SetAutoRotationDelay
==============
*/
void GScr_Turret_SetAutoRotationDelay(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  char v9; 

  __asm { vmovaps [rsp+38h+var_18], xmm6 }
  Entity = GetEntity(entref);
  if ( !Entity->turretHandle.m_objIndex )
    Scr_Error(COM_ERR_4053, scrContext, "entity is not a turret");
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm
  {
    vxorps  xmm1, xmm1, xmm1
    vcomiss xmm0, xmm1
    vmovaps xmm6, xmm0
  }
  if ( v9 )
    Scr_Error(COM_ERR_4054, scrContext, "need a positive duration");
  __asm
  {
    vmulss  xmm0, xmm6, cs:__real@447a0000
    vaddss  xmm2, xmm0, cs:__real@3f000000
    vxorps  xmm1, xmm1, xmm1
    vmovss  xmm3, xmm1, xmm2
    vxorps  xmm0, xmm0, xmm0
    vroundss xmm4, xmm0, xmm3, 1
    vcvttss2si edx, xmm4; delayMS
    vmovaps xmm6, [rsp+38h+var_18]
  }
  G_Turret_SetAutoRotationStopDelay(Entity, _EDX);
}

/*
==============
GScr_Turret_SetDefaultDropPitch
==============
*/
void GScr_Turret_SetDefaultDropPitch(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4055, scrContext, "illegal call to setdefaultdroppitch()");
  Entity = GetEntity(entref);
  if ( !Entity->turretHandle.m_objIndex )
    Scr_Error(COM_ERR_4056, scrContext, "entity is not a turret");
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm { vmovaps xmm1, xmm0; pitch }
  G_Turret_SetDefaultDropPitch(Entity, *(float *)&_XMM1);
}

/*
==============
GScr_Turret_RestoreDefaultDropPitch
==============
*/
void GScr_Turret_RestoreDefaultDropPitch(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  if ( Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_4057, scrContext, "illegal call to restoredefaultdroppitch()");
  Entity = GetEntity(entref);
  if ( Entity->turretHandle.m_objIndex )
    G_Turret_RestoreDefaultDropPitch(Entity);
  else
    Scr_Error(COM_ERR_4058, scrContext, "entity is not a turret");
}

/*
==============
GScr_Turret_GetCurrentYaw
==============
*/
void GScr_Turret_GetCurrentYaw(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *v5; 
  const char *v6; 

  Entity = GetEntity(entref);
  _RBX = Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_5719, scrContext, v6);
  }
  __asm { vmovss  xmm1, dword ptr [rbx+5Ch]; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
Scr_GetEntArray
==============
*/
void Scr_GetEntArray(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const char *String; 
  int Offset; 
  const char *v5; 
  ComErrorCode v6; 

  if ( !Scr_GetNumParam(scrContext) )
  {
    Scr_GetGenericEntArray(scrContext, 0);
    return;
  }
  ConstString = Scr_GetConstString(scrContext, 0);
  String = Scr_GetString(scrContext, 1u);
  Offset = Scr_GetOffset(scrContext, ENTITY_CLASS_GENTITY, String);
  if ( Offset >= 0 )
  {
    if ( (Offset & 0xE000) == 0 )
    {
      Scr_GetGenericEntArray(scrContext, Offset, ConstString, 0);
      return;
    }
    v5 = j_va("key '%s' does not internally belong to generic entities", String);
    v6 = COM_ERR_4678;
  }
  else
  {
    v5 = j_va("key '%s' does not internally belong to entities", String);
    v6 = COM_ERR_4677;
  }
  Scr_ParamError(v6, scrContext, 1u, v5);
}

/*
==============
GScr_Turret_GetCurrentPitch
==============
*/
void GScr_Turret_GetCurrentPitch(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *v5; 
  const char *v6; 

  Entity = GetEntity(entref);
  _RBX = Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_5720, scrContext, v6);
  }
  __asm { vmovss  xmm1, dword ptr [rbx+58h]; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
Scr_GetEntArrayInRadius
==============
*/
void Scr_GetEntArrayInRadius(scrContext_t *scrContext)
{
  Scr_GetEntArrayInRadius_Internal(scrContext, 0);
}

/*
==============
GScr_Turret_OverheatDisable
==============
*/
void GScr_Turret_OverheatDisable(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 
  int Int; 
  unsigned int v9; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_5721, scrContext, v6);
  }
  Turret = GTurret::GetTurret(p_turretHandle);
  Int = Scr_GetInt(scrContext, 0);
  v9 = Turret->m_data.flags & 0xEFFFFFFF;
  if ( Int )
    v9 = Turret->m_data.flags | 0x10000000;
  Turret->m_data.flags = v9;
}

/*
==============
GScr_GetScriptableArray
==============
*/
void GScr_GetScriptableArray(scrContext_t *scrContext)
{
  scr_string_t ConstLowercaseString; 
  const char *String; 
  int Offset; 
  const char *v5; 

  if ( Scr_GetNumParam(scrContext) )
  {
    ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
    String = Scr_GetString(scrContext, 1u);
    Offset = Scr_GetOffset(scrContext, ENTITY_CLASS_GENTITY, String);
    if ( Offset >= 0 )
    {
      if ( (Offset & 0xE000) == 0 )
        Scr_GetGenericEntArray(scrContext, Offset, ConstLowercaseString, 1);
    }
    else
    {
      v5 = j_va("key '%s' does not internally belong to scriptables", String);
      Scr_ParamError(COM_ERR_4679, scrContext, 1u, v5);
    }
  }
  else
  {
    Scr_GetGenericEntArray(scrContext, 1);
  }
}

/*
==============
GScr_Turret_IsOverheatDisabled
==============
*/
void GScr_Turret_IsOverheatDisabled(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_5722, scrContext, v6);
  }
  Turret = GTurret::GetTurret(p_turretHandle);
  Scr_AddBool(scrContext, ((unsigned int)Turret->m_data.flags >> 28) & 1);
}

/*
==============
GScr_GetScriptableArrayInRadius
==============
*/
void GScr_GetScriptableArrayInRadius(scrContext_t *scrContext)
{
  Scr_GetEntArrayInRadius_Internal(scrContext, 1);
}

/*
==============
GScr_Turret_FireDisable
==============
*/
void GScr_Turret_FireDisable(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *v4; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 

  Entity = GetEntity(entref);
  v4 = (const BgObjectHandle<GTurret> *)Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4059, scrContext, v6);
  }
  Turret = GTurret::GetTurret(v4 + 94);
  Turret->m_data.flags |= 2u;
  if ( Com_GameMode_SupportsFeature(WEAPON_DROPPING_LADDER_CLIMB) )
  {
    if ( !Com_GameMode_SupportsFeature(WEAPON_DROPPING_LADDER_CLIMB) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2135, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::TURRET_REMOTE_CONTROL ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::TURRET_REMOTE_CONTROL )") )
      __debugbreak();
    v4[27].m_objIndex |= 0x40u;
  }
}

/*
==============
GScr_Turret_FireEnable
==============
*/
void GScr_Turret_FireEnable(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *v4; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 

  Entity = GetEntity(entref);
  v4 = (const BgObjectHandle<GTurret> *)Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4060, scrContext, v6);
  }
  Turret = GTurret::GetTurret(v4 + 94);
  Turret->m_data.flags &= ~2u;
  if ( Com_GameMode_SupportsFeature(WEAPON_DROPPING_LADDER_CLIMB) )
  {
    if ( !Com_GameMode_SupportsFeature(WEAPON_DROPPING_LADDER_CLIMB) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2144, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::TURRET_REMOTE_CONTROL ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::TURRET_REMOTE_CONTROL )") )
      __debugbreak();
    v4[27].m_objIndex &= ~0x40u;
  }
}

/*
==============
GScr_Turret_SetBarrelSpinEnabled
==============
*/
void GScr_Turret_SetBarrelSpinEnabled(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v6; 
  const char *v7; 
  GTurret *Turret; 
  int Int; 
  unsigned int v10; 

  if ( !Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_4061, scrContext, "Missing parameter: turret TurretSetBarrelSpinEnabled( <enabled> );");
  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v6 = SL_ConvertToString(Entity->classname);
    v7 = j_va("In TurretSetBarrelSpinEnabled: entity type '%s' is not a turret", v6);
    Scr_Error(COM_ERR_4062, scrContext, v7);
  }
  Turret = GTurret::GetTurret(p_turretHandle);
  Int = Scr_GetInt(scrContext, 0);
  v10 = Turret->m_data.flags | 0x2000;
  if ( Int )
    v10 = Turret->m_data.flags & 0xFFFFDFFF;
  Turret->m_data.flags = v10;
}

/*
==============
GScr_Turret_CanTarget
==============
*/
void GScr_Turret_CanTarget(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const gentity_s *v4; 
  const char *v5; 
  const char *v6; 
  bool CanTargetPoint; 
  vec3_t vectorValue; 
  vec2_t out_localAngles; 
  vec3_t out_sourcePosition; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4063, scrContext, v6);
  }
  Scr_GetVector(scrContext, 0, &vectorValue);
  CanTargetPoint = G_Turret_CanTargetPoint(v4, &vectorValue, &out_sourcePosition, &out_localAngles);
  Scr_AddInt(scrContext, CanTargetPoint);
}

/*
==============
GScr_GetEntitylessScriptableArray
==============
*/
void GScr_GetEntitylessScriptableArray(scrContext_t *scrContext)
{
  GetScriptableArray_Internal(scrContext, GScr_Scriptable_GetEntitylessScriptableArray);
}

/*
==============
GScr_GetLootScriptableArray
==============
*/
void GScr_GetLootScriptableArray(scrContext_t *scrContext)
{
  GetScriptableArray_Internal(scrContext, GScr_Scriptable_GetLootScriptableArray);
}

/*
==============
GScr_GetLootScriptableArrayInRadius
==============
*/
void GScr_GetLootScriptableArrayInRadius(scrContext_t *scrContext)
{
  GetScriptableArray_Internal(scrContext, GScr_Scriptable_GetLootScriptableArray);
}

/*
==============
GScr_Scriptable_GetScriptableInstanceFromIndex
==============
*/
void GScr_Scriptable_GetScriptableInstanceFromIndex(scrContext_t *scrContext)
{
  unsigned int Int; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    Int = Scr_GetInt(scrContext, 0);
    if ( ScriptableSv_GetInstanceInUse(Int) )
    {
      ScriptableCommon_AssertCountsInitialized();
      if ( Int <= g_scriptableWorldCounts.serverInstanceCount )
        Scr_AddEntityNum(scrContext, Int, ENTITY_CLASS_SCRIPTABLE);
      else
        Scr_Error(COM_ERR_5960, scrContext, "GetScriptableInstanceFromIndex requires a valid loot scriptable index to be passed in.");
    }
    else
    {
      Scr_AddUndefined(scrContext);
    }
  }
  else
  {
    Scr_Error(COM_ERR_5959, scrContext, "GetScriptableInstanceFromIndex requires an index to be passed in.");
  }
}

/*
==============
GScr_Turret_SetModeChangeWait
==============
*/
void GScr_Turret_SetModeChangeWait(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 
  int Int; 
  unsigned int v9; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4064, scrContext, v6);
  }
  Turret = GTurret::GetTurret(p_turretHandle);
  Int = Scr_GetInt(scrContext, 0);
  v9 = Turret->m_data.flags & 0xFFFFBFFF;
  if ( Int )
    v9 = Turret->m_data.flags | 0x4000;
  Turret->m_data.flags = v9;
}

/*
==============
GScr_SpawnScriptable
==============
*/
void GScr_SpawnScriptable(scrContext_t *scrContext)
{
  const char *String; 
  unsigned int Int; 
  const char *v6; 
  ComErrorCode v7; 
  unsigned int outInstanceIndex; 
  vec3_t angles; 
  vec3_t vectorValue; 

  String = Scr_GetString(scrContext, 0);
  Scr_GetVector(scrContext, 1u, &vectorValue);
  if ( Scr_GetNumParam(scrContext) <= 2 )
  {
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vmovss  dword ptr [rsp+68h+angles], xmm0
      vmovss  dword ptr [rsp+68h+angles+4], xmm0
      vmovss  dword ptr [rsp+68h+angles+8], xmm0
    }
  }
  else
  {
    Scr_GetVector(scrContext, 2u, &angles);
  }
  if ( Scr_GetNumParam(scrContext) <= 3 )
  {
    LOWORD(Int) = 0;
  }
  else
  {
    Int = Scr_GetInt(scrContext, 3u);
    if ( Int > 0xFFFE )
    {
      v6 = "GScr_SpawnScriptable payload needs to be between 0 and 65535.";
      v7 = COM_ERR_6090;
      goto LABEL_11;
    }
  }
  if ( ScriptableSv_StandaloneSpawnInstance(String, &vectorValue, &angles, Int, 0, &outInstanceIndex) )
  {
    Scr_AddEntityNum(scrContext, outInstanceIndex, ENTITY_CLASS_SCRIPTABLE);
    return;
  }
  v6 = "Failed to spawn standalone instance. See log for details.";
  v7 = COM_ERR_4682;
LABEL_11:
  Scr_Error(v7, scrContext, v6);
}

/*
==============
GScr_GetEntityNumber
==============
*/
void GScr_GetEntityNumber(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  Scr_AddInt(scrContext, Entity->s.number);
}

/*
==============
GScr_TrajectoryUpdateOriginAndAngles
==============
*/
void GScr_TrajectoryUpdateOriginAndAngles(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  char v4; 
  int NumParam; 
  vec3_t vectorValue; 
  vec3_t origin; 

  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 5359, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  v4 = 0;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam > 1 && Scr_GetType(scrContext, 1u) )
  {
    Scr_GetVector(scrContext, 1u, &vectorValue);
    G_Utils_UpdateAnglesTrajectory(Entity, &vectorValue, 0, 0);
    v4 = 1;
  }
  if ( NumParam > 0 && Scr_GetType(scrContext, 0) )
  {
    Scr_GetVector(scrContext, 0, &origin);
    G_Utils_UpdateOriginTrajectory(Entity, &origin, 0, 0);
    G_PhysicsObject_WarpToCurrentTransform(Entity, 1);
  }
  else if ( v4 )
  {
    G_PhysicsObject_WarpToCurrentTransform(Entity, 1);
  }
  else
  {
    Scr_Error(COM_ERR_6340, scrContext, "Not a valid origin or angle.\n");
  }
}

/*
==============
GScr_SpawnCustomWeaponScriptable
==============
*/
void GScr_SpawnCustomWeaponScriptable(scrContext_t *scrContext)
{
  const char *String; 
  unsigned int Int; 
  unsigned __int16 v4; 
  GWeaponMap *Instance; 
  unsigned __int16 extraPayload; 
  BgWeaponHandle handle; 
  bool outIsAlternate; 
  unsigned int outInstanceIndex; 
  vec3_t angles; 
  vec3_t vectorValue; 
  Weapon outWeapon; 

  String = Scr_GetString(scrContext, 0);
  if ( ScriptableSv_IsLootCustomWeapon(String) )
  {
    Scr_GetVector(scrContext, 1u, &vectorValue);
    Scr_GetVector(scrContext, 2u, &angles);
    Int = Scr_GetInt(scrContext, 3u);
    v4 = Int;
    if ( Int > 0xFFFE )
    {
      Scr_Error(COM_ERR_6298, scrContext, "GScr_SpawnScriptable payload needs to be between 0 and 65535.");
    }
    else
    {
      handle.m_mapEntryId = 0;
      Instance = GWeaponMap::GetInstance();
      GScr_Main_GetWeaponParam(scrContext, 4u, &outWeapon, &outIsAlternate);
      GWeaponMap::SetWeapon(Instance, &handle, &outWeapon);
      extraPayload = truncate_cast<unsigned short,unsigned int>(handle.m_mapEntryId);
      if ( ScriptableSv_StandaloneSpawnInstance(String, &vectorValue, &angles, v4, extraPayload, &outInstanceIndex) )
      {
        Scr_AddEntityNum(scrContext, outInstanceIndex, ENTITY_CLASS_SCRIPTABLE);
      }
      else
      {
        if ( handle.m_mapEntryId )
          GWeaponMap::ClearWeapon(Instance, &handle);
        Scr_Error(COM_ERR_6565, scrContext, "Failed to spawn standalone instance. See log for details.");
      }
    }
  }
  else
  {
    Scr_Error(COM_ERR_6299, scrContext, "SpawnCustomWeaponScriptable failed, see log for details.");
  }
}

/*
==============
GScr_GetMissileVelocity
==============
*/
void GScr_GetMissileVelocity(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v5; 
  trType_t trType; 
  GHandler *Handler; 
  const char *v9; 
  vec3_t outVelocity; 

  Entity = GetEntity(entref);
  v5 = Entity;
  if ( Entity )
  {
    if ( Entity->s.eType == ET_MISSILE )
      goto LABEL_6;
  }
  else if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 5408, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
  {
    __debugbreak();
  }
  Scr_Error(COM_ERR_6196, scrContext, "GetMissileVelocity() invoked on invalid or non-missile entity.");
LABEL_6:
  trType = v5->s.lerp.pos.trType;
  if ( trType )
  {
    if ( ((trType - 2) & 0xFFFFFFFA) != 0 || trType == TR_LINEAR_STOP )
    {
      __asm
      {
        vxorps  xmm0, xmm0, xmm0
        vmovss  dword ptr [rsp+58h+outVelocity], xmm0
        vmovss  dword ptr [rsp+58h+outVelocity+4], xmm0
        vmovss  dword ptr [rsp+58h+outVelocity+8], xmm0
      }
      v9 = j_va("GetMissileVelocity() unsupported Trajectory Type %i for entity %i", (unsigned int)v5->s.lerp.apos.trType, (unsigned int)v5->s.number);
      Scr_Error(COM_ERR_6197, scrContext, v9);
    }
    else
    {
      Handler = GHandler::getHandler();
      GHandler::GetEntityVelocity(Handler, v5->s.number, &outVelocity);
    }
  }
  else
  {
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vmovss  dword ptr [rsp+58h+outVelocity], xmm0
      vmovss  dword ptr [rsp+58h+outVelocity+4], xmm0
      vmovss  dword ptr [rsp+58h+outVelocity+8], xmm0
    }
  }
  Scr_AddVector(scrContext, outVelocity.v);
}

/*
==============
GScr_GetScriptableLootSpawnedCountByName
==============
*/
void GScr_GetScriptableLootSpawnedCountByName(scrContext_t *scrContext)
{
  const char *String; 
  unsigned __int16 LootSpawnedCountForItem; 

  String = Scr_GetString(scrContext, 0);
  LootSpawnedCountForItem = ScriptableSv_GetLootSpawnedCountForItem(String);
  Scr_AddInt(scrContext, LootSpawnedCountForItem);
}

/*
==============
GScr_ValidateCollision
==============
*/
void GScr_ValidateCollision(scrContext_t *scrContext, scr_entref_t entref)
{
  ;
}

/*
==============
GScr_GetScriptableLootSpawnedCountByRarity
==============
*/
void GScr_GetScriptableLootSpawnedCountByRarity(scrContext_t *scrContext)
{
  int Int; 
  unsigned __int16 LootSpawnedCountForRarity; 

  Int = Scr_GetInt(scrContext, 0);
  LootSpawnedCountForRarity = ScriptableSv_GetLootSpawnedCountForRarity(Int);
  Scr_AddInt(scrContext, LootSpawnedCountForRarity);
}

/*
==============
GScr_GetEntityVelocity
==============
*/
void GScr_GetEntityVelocity(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  gclient_s *client; 
  int v6; 
  const char *v7; 
  const float *p_commandTime; 
  const char *v9; 
  const char *v10; 

  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 5548, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( Entity->vehicle )
  {
    if ( EntHandle::isDefined(&Entity->r.ownerNum) && (v4 = EntHandle::ent(&Entity->r.ownerNum)) != NULL && (client = v4->client) != NULL && (v6 = client->ps.vehicleState.entity, v6 != 2047) && v6 == Entity->s.number )
    {
      Scr_AddVector(scrContext, client->ps.vehicleState.velocity.v);
    }
    else
    {
      v7 = j_va("vehicle entity %i is not being controlled by the player. ", (unsigned int)Entity->s.number);
      Scr_Error(COM_ERR_4065, scrContext, v7);
    }
  }
  else
  {
    p_commandTime = (const float *)&Entity->client->ps.commandTime;
    if ( p_commandTime || (p_commandTime = (const float *)&Entity->agent->playerState.commandTime) != NULL )
    {
      Scr_AddVector(scrContext, p_commandTime + 15);
    }
    else
    {
      v9 = SL_ConvertToString(Entity->classname);
      v10 = j_va("entity type '%s' is not a player nor a player controlled vehicle ", v9);
      Scr_Error(COM_ERR_4066, scrContext, v10);
    }
  }
}

/*
==============
GScr_GetScriptableLootSpawnedCountByType
==============
*/
void GScr_GetScriptableLootSpawnedCountByType(scrContext_t *scrContext)
{
  const char *String; 
  unsigned __int16 LootSpawnedCountForType; 

  String = Scr_GetString(scrContext, 0);
  LootSpawnedCountForType = ScriptableSv_GetLootSpawnedCountForType(String);
  Scr_AddInt(scrContext, LootSpawnedCountForType);
}

/*
==============
GScr_GetScriptableLootCacheContents
==============
*/
void GScr_GetScriptableLootCacheContents(scrContext_t *scrContext)
{
  scr_entref_t EntityRef; 
  unsigned int entnum; 
  int v4; 
  int Int; 
  char **v6; 
  int out_itemCount[4]; 
  char *out_itemNames[10]; 

  EntityRef = Scr_GetEntityRef(scrContext, 0);
  entnum = EntityRef.entnum;
  if ( EntityRef.entclass == ENTITY_CLASS_SCRIPTABLE )
  {
    v4 = 0;
    Int = 0;
    if ( Scr_GetNumParam(scrContext) > 1 )
      Int = Scr_GetInt(scrContext, 1u);
    out_itemCount[0] = 10;
    if ( ScriptableSv_GetLootCache(entnum, Int, (const char **)out_itemNames, out_itemCount) )
    {
      Scr_MakeArray(scrContext);
      if ( out_itemCount[0] > 0 )
      {
        v6 = out_itemNames;
        do
        {
          Scr_AddString(scrContext, *v6);
          Scr_AddArray(scrContext);
          ++v4;
          ++v6;
        }
        while ( v4 < out_itemCount[0] );
      }
    }
  }
  else
  {
    Scr_Error(COM_ERR_6566, scrContext, "GetScriptableLootCacheContents must be given a lootInstance.");
  }
}

/*
==============
GScr_GetPlayerRollVelocity
==============
*/
void GScr_GetPlayerRollVelocity(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 5597, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_GetEntityPlayerState(Entity) )
    Scr_Error(COM_ERR_4067, scrContext, "GetPlayerRollVelocity must be called on a player.\n");
  __asm { vmovss  xmm1, dword ptr [rbx+48h]; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
GScr_GetScriptCacheContents
==============
*/
void GScr_GetScriptCacheContents(scrContext_t *scrContext)
{
  int v2; 
  unsigned __int16 v3; 
  const char *String; 
  int Int; 
  bool ScriptCache; 
  char **v7; 
  int out_itemCount[4]; 
  char *out_itemNames[24]; 

  if ( ScriptableSv_GetLootTable() )
  {
    if ( Scr_GetNumParam(scrContext) )
    {
      v2 = 0;
      v3 = 0;
      String = Scr_GetString(scrContext, 0);
      if ( Scr_GetNumParam(scrContext) <= 1 || (Int = Scr_GetInt(scrContext, 1u), v3 = Int, Int >= 0) )
      {
        out_itemCount[0] = 24;
        ScriptCache = ScriptableSv_GetScriptCache(String, v3, (const char **)out_itemNames, out_itemCount);
        if ( out_itemCount[0] > 24 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 24849, ASSERT_TYPE_ASSERT, "(itemCount <= 24)", (const char *)&queryFormat, "itemCount <= SPAWNGROUP_LOOT_MAX_CACHE_ITEMS") )
          __debugbreak();
        if ( ScriptCache )
        {
          Scr_MakeArray(scrContext);
          if ( out_itemCount[0] > 0 )
          {
            v7 = out_itemNames;
            do
            {
              Scr_AddString(scrContext, *v7);
              Scr_AddArray(scrContext);
              ++v2;
              ++v7;
            }
            while ( v2 < out_itemCount[0] );
          }
        }
      }
      else
      {
        Scr_Error(COM_ERR_6568, scrContext, "GScr_GetScriptCacheContents: invalid cacheIndex value\n");
      }
    }
    else
    {
      Scr_Error(COM_ERR_6567, scrContext, "GScr_GetScriptCacheContents: must be called with a valid <setName>\n");
    }
  }
  else
  {
    Scr_Error(COM_ERR_6624, scrContext, "GScr_GetScriptCacheContents: no loot table currently loaded\n");
  }
}

/*
==============
ScrCmd_CanAttackEnemyNodeFromExposed
==============
*/
void ScrCmd_CanAttackEnemyNodeFromExposed(scrContext_t *scrContext, scr_entref_t entref)
{
  int HasDecentVisFromExposed; 
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  sentient_s *TargetSentient; 
  sentient_s *v8; 
  AIWrapper v9; 

  AIActorInterface::AIActorInterface(&v9.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v9.m_newAgentInterface);
  HasDecentVisFromExposed = 0;
  v9.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  v9.m_pAI = NULL;
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v9, Entity);
  m_pAI = v9.m_pAI;
  if ( !v9.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 5621, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  if ( !m_pAI->GetSentient(m_pAI) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 5623, ASSERT_TYPE_ASSERT, "(pAI->GetSentient())", (const char *)&queryFormat, "pAI->GetSentient()") )
    __debugbreak();
  TargetSentient = AICommonInterface::GetTargetSentient(m_pAI);
  if ( TargetSentient )
  {
    v8 = m_pAI->GetSentient(m_pAI);
    HasDecentVisFromExposed = Sentient_HasDecentVisFromExposed(v8, TargetSentient);
  }
  Scr_AddBool(scrContext, HasDecentVisFromExposed);
}

/*
==============
GScr_PickScriptableLootItem
==============
*/
void GScr_PickScriptableLootItem(scrContext_t *scrContext)
{
  const char *v1; 
  const char *String; 
  int v4; 
  int Int; 
  const char *v6; 

  v1 = (char *)&queryFormat.fmt + 3;
  String = (char *)&queryFormat.fmt + 3;
  if ( Scr_GetNumParam(scrContext) )
    String = Scr_GetString(scrContext, 0);
  v4 = 0;
  Int = 0;
  if ( Scr_GetNumParam(scrContext) > 1 )
    Int = Scr_GetInt(scrContext, 1u);
  if ( Scr_GetNumParam(scrContext) > 2 )
    v4 = Scr_GetInt(scrContext, 2u);
  if ( Scr_GetNumParam(scrContext) > 3 )
    v1 = Scr_GetString(scrContext, 3u);
  v6 = ScriptableSv_PickLootItem(String, Int, v4, v1);
  Scr_AddString(scrContext, v6);
}

/*
==============
ScrCmd_CanAttackEnemyNode
==============
*/
void ScrCmd_CanAttackEnemyNode(scrContext_t *scrContext, scr_entref_t entref)
{
  int HasDecentVis; 
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  sentient_s *TargetSentient; 
  sentient_s *v8; 
  AIWrapper v9; 

  AIActorInterface::AIActorInterface(&v9.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v9.m_newAgentInterface);
  HasDecentVis = 0;
  v9.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  v9.m_pAI = NULL;
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v9, Entity);
  m_pAI = v9.m_pAI;
  if ( !v9.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 5648, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  if ( !m_pAI->GetSentient(m_pAI) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 5650, ASSERT_TYPE_ASSERT, "(pAI->GetSentient())", (const char *)&queryFormat, "pAI->GetSentient()") )
    __debugbreak();
  TargetSentient = AICommonInterface::GetTargetSentient(m_pAI);
  if ( TargetSentient )
  {
    v8 = m_pAI->GetSentient(m_pAI);
    HasDecentVis = Sentient_HasDecentVis(v8, TargetSentient);
  }
  Scr_AddBool(scrContext, HasDecentVis);
}

/*
==============
GScr_IsScriptableDefined
==============
*/
void GScr_IsScriptableDefined(scrContext_t *scrContext)
{
  const char *String; 
  const ScriptableDef *NetConstStringDefAtIndex; 
  unsigned int outIndex; 

  String = Scr_GetString(scrContext, 0);
  if ( NetConstStrings_GetIndexFromName(NETCONSTSTRINGTYPE_SCRIPTABLEDEF, String, &outIndex) )
  {
    NetConstStringDefAtIndex = ScriptableBg_GetNetConstStringDefAtIndex(outIndex);
    Scr_AddBool(scrContext, NetConstStringDefAtIndex != NULL);
  }
  else
  {
    Scr_AddBool(scrContext, 0);
  }
}

/*
==============
GScr_EnableGrenadeTouchDamage
==============
*/
void GScr_EnableGrenadeTouchDamage(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( Entity->classname == scr_const.trigger_damage )
  {
    Entity->flags.m_flags[0] |= 0x2000u;
  }
  else
  {
    Scr_Error(COM_ERR_4068, scrContext, "Currently on supported on damage triggers");
    v4->flags.m_flags[0] |= 0x2000u;
  }
}

/*
==============
GScr_DisableGrenadeTouchDamage
==============
*/
void GScr_DisableGrenadeTouchDamage(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( Entity->classname == scr_const.trigger_damage )
  {
    Entity->flags.m_flags[0] &= ~0x2000u;
  }
  else
  {
    Scr_Error(COM_ERR_4069, scrContext, "Currently on supported on damage triggers");
    v4->flags.m_flags[0] &= ~0x2000u;
  }
}

/*
==============
GScr_FreeScriptable
==============
*/
void GScr_FreeScriptable(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 

  entnum = entref.entnum;
  if ( entref.entclass != ENTITY_CLASS_SCRIPTABLE )
    Scr_ObjectError(COM_ERR_4683, scrContext, "Must be called on objects of class 'Scriptable'");
  ScriptableCommon_AssertCountsInitialized();
  if ( entnum >= g_scriptableWorldCounts.runtimeInstanceCount )
    Scr_ObjectError(COM_ERR_4684, scrContext, "Must be called on a standalone dynamic scriptable");
  if ( ScriptableSv_GetInstanceCommonContext(entnum)->linkedObjectType == SCRIPTABLE_LINK_ENTITY )
    Scr_ObjectError(COM_ERR_4685, scrContext, "Must be called on a standalone (non-entity) scriptable");
  if ( !ScriptableSv_StandaloneFreeInstance(entnum) )
    Scr_Error(COM_ERR_4686, scrContext, "Failed to free standalone instance. See log for details.");
}

/*
==============
GScr_ForceHideGrenadeHudWarning
==============
*/
void GScr_ForceHideGrenadeHudWarning(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  int Int; 
  unsigned int v6; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( !Entity || Entity->s.eType != ET_MISSILE )
    Scr_Error(COM_ERR_4070, scrContext, "ForceHideGrenadeHudWarning() invoked on invalid or non-grenade entity.");
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4071, scrContext, "USAGE: <ent> ForceHideGrenadeHudWarning( <bool> )\n");
  Int = Scr_GetInt(scrContext, 0);
  v6 = v4->s.lerp.u.anonymous.data[4] & 0xFFFFFFEF;
  if ( Int )
    v6 = v4->s.lerp.u.anonymous.data[4] | 0x10;
  v4->s.lerp.u.anonymous.data[4] = v6;
}

/*
==============
GScr_SetScriptablePayloadModel
==============
*/
void GScr_SetScriptablePayloadModel(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 

  entnum = entref.entnum;
  if ( entref.entclass != ENTITY_CLASS_SCRIPTABLE )
    Scr_ObjectError(COM_ERR_4683, scrContext, "Must be called on objects of class 'Scriptable'");
  ScriptableCommon_AssertCountsInitialized();
  if ( entnum >= g_scriptableWorldCounts.runtimeInstanceCount )
    Scr_ObjectError(COM_ERR_4684, scrContext, "Must be called on a standalone dynamic scriptable");
  if ( ScriptableSv_GetInstanceCommonContext(entnum)->linkedObjectType == SCRIPTABLE_LINK_ENTITY )
    Scr_ObjectError(COM_ERR_4685, scrContext, "Must be called on a standalone (non-entity) scriptable");
}

/*
==============
GScr_SetScriptablePayloadWeapon
==============
*/
void GScr_SetScriptablePayloadWeapon(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 

  entnum = entref.entnum;
  if ( entref.entclass != ENTITY_CLASS_SCRIPTABLE )
    Scr_ObjectError(COM_ERR_4683, scrContext, "Must be called on objects of class 'Scriptable'");
  ScriptableCommon_AssertCountsInitialized();
  if ( entnum >= g_scriptableWorldCounts.runtimeInstanceCount )
    Scr_ObjectError(COM_ERR_4684, scrContext, "Must be called on a standalone dynamic scriptable");
  if ( ScriptableSv_GetInstanceCommonContext(entnum)->linkedObjectType == SCRIPTABLE_LINK_ENTITY )
    Scr_ObjectError(COM_ERR_4685, scrContext, "Must be called on a standalone (non-entity) scriptable");
}

/*
==============
GScr_MissileSetPhaseState
==============
*/
void GScr_MissileSetPhaseState(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  int Int; 
  unsigned int v6; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( !Entity || Entity->s.eType != ET_MISSILE )
    Scr_Error(COM_ERR_4072, scrContext, "Missile_SetPhaseState() invoked on invalid or non-missile entity.");
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4073, scrContext, "USAGE: <ent> Missile_SetPhaseState( <bool> )\n");
  Int = Scr_GetInt(scrContext, 0);
  v6 = v4->s.lerp.u.anonymous.data[4] & 0xFFFFFEFF;
  if ( Int )
    v6 = v4->s.lerp.u.anonymous.data[4] | 0x100;
  v4->s.lerp.u.anonymous.data[4] = v6;
}

/*
==============
GScr_MissileSetTargetEnt
==============
*/
void GScr_MissileSetTargetEnt(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 

  Entity = GetEntity(entref);
  GScr_CheckRocketEntity(scrContext, Entity);
  v4 = GScr_GetEntity(0);
  Entity->c.missile.flags = Entity->c.missile.flags & 0xFFFFFFE1 | 6;
  EntHandle::setEnt(&Entity->missileTargetEnt, v4);
  Entity->c.item[1].clipAmmoCount[0] = LODWORD(v4->r.currentOrigin.v[0]);
  Entity->c.item[1].clipAmmoCount[1] = LODWORD(v4->r.currentOrigin.v[1]);
  Entity->c.mover.angle.pos3.v[2] = v4->r.currentOrigin.v[2];
  if ( Scr_GetNumParam(scrContext) <= 1 )
  {
    *((_QWORD *)&Entity->c.beam + 9) = 0i64;
    Entity->c.item[1].ammoCount = 0;
  }
  else
  {
    Scr_GetVector(scrContext, 1u, &Entity->c.mover.angle.pos2);
  }
}

/*
==============
GScr_GetCSplineId
==============
*/
void GScr_GetCSplineId(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  int CSplineIdByTargetName; 
  const char *v4; 
  const char *v5; 
  const char *v6; 
  const char *v7; 

  ConstString = Scr_GetConstString(scrContext, 0);
  CSplineIdByTargetName = Com_GetCSplineIdByTargetName(ConstString);
  if ( CSplineIdByTargetName == -1 )
  {
    v4 = SL_ConvertToString(ConstString);
    v5 = j_va("GetCSplineId was unable to find targetname: %s", v4);
    Scr_Error(COM_ERR_4690, scrContext, v5);
    Scr_AddUndefined(scrContext);
  }
  else if ( CSplineIdByTargetName == -3 )
  {
    v6 = SL_ConvertToString(ConstString);
    v7 = j_va("GetCSplineId found multiple splines with the same targetname: %s", v6);
    Scr_Error(COM_ERR_4691, scrContext, v7);
    Scr_AddUndefined(scrContext);
  }
  else
  {
    Scr_AddInt(scrContext, CSplineIdByTargetName);
  }
}

/*
==============
GScr_MissileSetTargetPos
==============
*/
void GScr_MissileSetTargetPos(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  GScr_CheckRocketEntity(scrContext, Entity);
  Entity->c.missile.flags = Entity->c.missile.flags & 0xFFFFFFE1 | 2;
  EntHandle::setEnt(&Entity->missileTargetEnt, NULL);
  *((_QWORD *)&Entity->c.beam + 9) = 0i64;
  Entity->c.item[1].ammoCount = 0;
  Scr_GetVector(scrContext, 0, &Entity->c.mover.angle.pos3);
}

/*
==============
GScr_GetCSplineIdArray
==============
*/
void GScr_GetCSplineIdArray(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  __int64 v3; 
  unsigned __int16 v4; 

  ConstString = Scr_GetConstString(scrContext, 0);
  LOWORD(v3) = Com_GetCSplineCount();
  Scr_MakeArray(scrContext);
  if ( (_WORD)v3 )
  {
    v4 = 1;
    v3 = (unsigned __int16)v3;
    do
    {
      if ( Com_GetCSplineTargetname(v4) == ConstString )
      {
        Scr_AddInt(scrContext, v4);
        Scr_AddArray(scrContext);
      }
      ++v4;
      --v3;
    }
    while ( v3 );
  }
}

/*
==============
GScr_MissileClearTarget
==============
*/
void GScr_MissileClearTarget(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  GScr_CheckRocketEntity(scrContext, Entity);
  Entity->c.missile.flags &= 0xFFFFFFE9;
  EntHandle::setEnt(&Entity->missileTargetEnt, NULL);
  *((_QWORD *)&Entity->c.beam + 9) = 0i64;
  *((_QWORD *)&Entity->c.beam + 10) = 0i64;
  *((_QWORD *)&Entity->c.beam + 11) = 0i64;
}

/*
==============
GScr_GetCSplineCount
==============
*/
void GScr_GetCSplineCount(scrContext_t *scrContext)
{
  unsigned __int16 CSplineCount; 

  CSplineCount = Com_GetCSplineCount();
  Scr_AddInt(scrContext, CSplineCount);
}

/*
==============
GScr_GetCSplinePointCount
==============
*/
void GScr_GetCSplinePointCount(scrContext_t *scrContext)
{
  int Int; 
  unsigned int v3; 
  const char *v4; 
  unsigned __int16 CSplinePointCount; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    Int = Scr_GetInt(scrContext, 0);
    v3 = truncate_cast<unsigned short,int>(Int);
    if ( v3 <= Com_GetCSplineCount() )
    {
      CSplinePointCount = Com_GetCSplinePointCount(v3);
      Scr_AddInt(scrContext, CSplinePointCount);
    }
    else
    {
      v4 = j_va("'%s' - Invalid CSpline Id '%i'\n", "GetCSplinePointCount", v3);
      Scr_Error(COM_ERR_4687, scrContext, v4);
    }
  }
  else
  {
    Scr_Error(COM_ERR_4692, scrContext, "USAGE: GetCSplinePointCount(splineId)\n");
  }
}

/*
==============
GScr_MissileSetFlightmodeDirect
==============
*/
void GScr_MissileSetFlightmodeDirect(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *v4; 

  Entity = GetEntity(entref);
  GScr_CheckRocketEntity(scrContext, Entity);
  if ( (Entity->c.item[0].weapon.attachmentVariationIndices[5] & 2) == 0 )
  {
    v4 = j_va("Entity %i is not locked on to anything.", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_4077, scrContext, v4);
  }
  Entity->s.lerp.u.anonymous.data[3] = 1;
}

/*
==============
GScr_MissileSetFlightmodeTop
==============
*/
void GScr_MissileSetFlightmodeTop(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *v4; 

  Entity = GetEntity(entref);
  GScr_CheckRocketEntity(scrContext, Entity);
  if ( (Entity->c.item[0].weapon.attachmentVariationIndices[5] & 2) == 0 )
  {
    v4 = j_va("Entity %i is not locked on to anything.", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_4077, scrContext, v4);
  }
  Entity->s.lerp.u.anonymous.data[3] = 0;
}

/*
==============
GScr_GetCSplineLength
==============
*/
void GScr_GetCSplineLength(scrContext_t *scrContext)
{
  int Int; 
  unsigned int v4; 
  const char *v5; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    Int = Scr_GetInt(scrContext, 0);
    v4 = truncate_cast<unsigned short,int>(Int);
    if ( v4 <= Com_GetCSplineCount() )
    {
      *(double *)&_XMM0 = Com_GetCSplineLength(v4);
      __asm { vmovaps xmm1, xmm0; value }
      Scr_AddFloat(scrContext, *(float *)&_XMM1);
    }
    else
    {
      v5 = j_va("'%s' - Invalid CSpline Id '%i'\n", "GetCSplineLength", v4);
      Scr_Error(COM_ERR_4687, scrContext, v5);
    }
  }
  else
  {
    Scr_Error(COM_ERR_4693, scrContext, "USAGE: GetCSplineLength(splineId)\n");
  }
}

/*
==============
GScr_GetMissileOwner
==============
*/
void GScr_GetMissileOwner(scrContext_t *scrContext)
{
  gentity_s *Entity; 
  EntHandle *v3; 
  const char *v4; 
  const char *v5; 
  const gentity_s *v6; 

  Entity = GScr_GetEntity(0);
  v3 = (EntHandle *)Entity;
  if ( Entity->s.eType != ET_MISSILE )
  {
    v4 = SL_ConvertToString(Entity->classname);
    v5 = j_va("entity type '%s' is not a missile", v4);
    Scr_Error(COM_ERR_4078, scrContext, v5);
  }
  if ( EntHandle::isDefined(v3 + 82) )
  {
    v6 = EntHandle::ent(v3 + 82);
    GScr_AddEntity(v6);
  }
  else
  {
    Scr_AddUndefined(scrContext);
  }
}

/*
==============
GScr_GetCSplineTargetname
==============
*/
void GScr_GetCSplineTargetname(scrContext_t *scrContext)
{
  int Int; 
  unsigned int v3; 
  const char *v4; 
  scr_string_t CSplineTargetname; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    Int = Scr_GetInt(scrContext, 0);
    v3 = truncate_cast<unsigned short,int>(Int);
    if ( v3 <= Com_GetCSplineCount() )
    {
      CSplineTargetname = Com_GetCSplineTargetname(v3);
      if ( CSplineTargetname )
        Scr_AddConstString(scrContext, CSplineTargetname);
      else
        Scr_AddUndefined(scrContext);
    }
    else
    {
      v4 = j_va("'%s' - Invalid CSpline Id '%i'\n", "GetCSplineTargetname", v3);
      Scr_Error(COM_ERR_4687, scrContext, v4);
    }
  }
  else
  {
    Scr_Error(COM_ERR_4694, scrContext, "USAGE: GetCSplineTargetname(splineId)\n");
  }
}

/*
==============
GScr_IsOnLadder
==============
*/
void GScr_IsOnLadder(scrContext_t *scrContext, scr_entref_t entref)
{
  int v2; 
  unsigned int entnum; 
  gentity_s *v5; 
  char *client; 
  const char *v7; 
  ComErrorCode v8; 

  v2 = 0;
  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v7 = "not an entity";
    v8 = COM_ERR_3682;
LABEL_9:
    Scr_ObjectError(v8, scrContext, v7);
    client = NULL;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 5962, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
      __debugbreak();
    goto LABEL_11;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 5960, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v5 = &g_entities[entnum];
  client = (char *)v5->client;
  if ( !client )
  {
    client = (char *)v5->agent;
    if ( !client )
    {
      v7 = j_va("entity %i is not a player or agent", entnum);
      v8 = COM_ERR_3679;
      goto LABEL_9;
    }
  }
LABEL_11:
  LOBYTE(v2) = GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal((GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64> *)(client + 20), ACTIVE, 6u);
  Scr_AddBool(scrContext, v2);
}

/*
==============
GScr_GetCSplinePointId
==============
*/
void GScr_GetCSplinePointId(scrContext_t *scrContext)
{
  int Int; 
  unsigned int v3; 
  const char *v4; 
  int v5; 
  unsigned __int16 v6; 
  const char *v7; 
  int CSplinePointId; 

  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    Int = Scr_GetInt(scrContext, 0);
    v3 = truncate_cast<unsigned short,int>(Int);
    if ( v3 <= Com_GetCSplineCount() )
    {
      v5 = Scr_GetInt(scrContext, 1u);
      v6 = truncate_cast<unsigned short,int>(v5);
      if ( v6 < Com_GetCSplinePointCount(v3) )
      {
        CSplinePointId = Com_GetCSplinePointId(v3, v6);
        Scr_AddInt(scrContext, CSplinePointId);
      }
      else
      {
        v7 = j_va("'%s' - Invalid CSpline Node Index '%i' for Spline '%i'\n", "GetCSplinePointId", v6, v3);
        Scr_Error(COM_ERR_4688, scrContext, v7);
      }
    }
    else
    {
      v4 = j_va("'%s' - Invalid CSpline Id '%i'\n", "GetCSplinePointId", v3);
      Scr_Error(COM_ERR_4687, scrContext, v4);
    }
  }
  else
  {
    Scr_Error(COM_ERR_4695, scrContext, "USAGE: GetCSplinePointId(splineId, splineNodeIndex)\n");
  }
}

/*
==============
GScr_GetCSplinePointLabel
==============
*/
void GScr_GetCSplinePointLabel(scrContext_t *scrContext)
{
  int Int; 
  unsigned int v3; 
  const char *v4; 
  int v5; 
  unsigned __int16 v6; 
  const char *v7; 
  scr_string_t CSplinePointLabel; 

  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    Int = Scr_GetInt(scrContext, 0);
    v3 = truncate_cast<unsigned short,int>(Int);
    if ( v3 <= Com_GetCSplineCount() )
    {
      v5 = Scr_GetInt(scrContext, 1u);
      v6 = truncate_cast<unsigned short,int>(v5);
      if ( v6 < Com_GetCSplinePointCount(v3) )
      {
        CSplinePointLabel = Com_GetCSplinePointLabel(v3, v6);
        if ( CSplinePointLabel )
          Scr_AddConstString(scrContext, CSplinePointLabel);
        else
          Scr_AddUndefined(scrContext);
      }
      else
      {
        v7 = j_va("'%s' - Invalid CSpline Node Index '%i' for Spline '%i'\n", "GetCSplinePointLabel", v6, v3);
        Scr_Error(COM_ERR_4688, scrContext, v7);
      }
    }
    else
    {
      v4 = j_va("'%s' - Invalid CSpline Id '%i'\n", "GetCSplinePointLabel", v3);
      Scr_Error(COM_ERR_4687, scrContext, v4);
    }
  }
  else
  {
    Scr_Error(COM_ERR_4696, scrContext, "USAGE: GetCSplinePointLabel(splineId, splineNodeIndex)\n");
  }
}

/*
==============
GScr_SetBountyCount
==============
*/
void GScr_SetBountyCount(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v16; 
  int Int; 
  const char *v18; 
  __int64 v19; 

  entnum = entref.entnum;
  _RSI = GScr_Main_GetPlayerEntity(scrContext, entref);
  if ( !G_Utils_IsClient(_RSI) )
  {
    targetname = _RSI->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(_RSI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rsi+134h]
      vmovss  xmm2, dword ptr [rsi+130h]
      vmovss  xmm0, dword ptr [rsi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+48h+var_28], xmm0
    }
    v16 = j_va("SetBountyCount(). Only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, v19, v7, v6);
    Scr_Error(COM_ERR_4079, scrContext, v16);
  }
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4080, scrContext, "USAGE: <player> SetBountyCount( <int> )\n");
  Int = Scr_GetInt(scrContext, 0);
  if ( Int > 7 )
  {
    v18 = j_va("Bounty count limit exceeded! The maximum supported bounty count is %d\n", 7i64);
    Scr_Error(COM_ERR_4081, scrContext, v18);
  }
  _RSI->client->sess.cs.bountyCount = truncate_cast<signed char,int>(Int);
}

/*
==============
GScr_GetCSplinePointString
==============
*/
void GScr_GetCSplinePointString(scrContext_t *scrContext)
{
  int Int; 
  unsigned int v3; 
  const char *v4; 
  int v5; 
  unsigned __int16 v6; 
  const char *v7; 
  scr_string_t CSplinePointString; 

  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    Int = Scr_GetInt(scrContext, 0);
    v3 = truncate_cast<unsigned short,int>(Int);
    if ( v3 <= Com_GetCSplineCount() )
    {
      v5 = Scr_GetInt(scrContext, 1u);
      v6 = truncate_cast<unsigned short,int>(v5);
      if ( v6 < Com_GetCSplinePointCount(v3) )
      {
        CSplinePointString = Com_GetCSplinePointString(v3, v6);
        if ( CSplinePointString )
          Scr_AddConstString(scrContext, CSplinePointString);
        else
          Scr_AddUndefined(scrContext);
      }
      else
      {
        v7 = j_va("'%s' - Invalid CSpline Node Index '%i' for Spline '%i'\n", "GetCSplinePointString", v6, v3);
        Scr_Error(COM_ERR_4688, scrContext, v7);
      }
    }
    else
    {
      v4 = j_va("'%s' - Invalid CSpline Id '%i'\n", "GetCSplinePointString", v3);
      Scr_Error(COM_ERR_4687, scrContext, v4);
    }
  }
  else
  {
    Scr_Error(COM_ERR_4697, scrContext, "USAGE: GetCSplinePointString(splineId, splineNodeIndex)\n");
  }
}

/*
==============
GScr_SetPerkIcon
==============
*/
void GScr_SetPerkIcon(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v16; 
  const char *String; 
  const char *v18; 
  __int64 v19; 
  unsigned int outIndex; 

  entnum = entref.entnum;
  _RSI = GScr_Main_GetPlayerEntity(scrContext, entref);
  if ( !G_Utils_IsClient(_RSI) )
  {
    targetname = _RSI->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(_RSI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rsi+134h]
      vmovss  xmm2, dword ptr [rsi+130h]
      vmovss  xmm0, dword ptr [rsi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+48h+var_28], xmm0
    }
    v16 = j_va("SetPerkIcon(). Only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, v19, v7, v6);
    Scr_Error(COM_ERR_4082, scrContext, v16);
  }
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4083, scrContext, "USAGE: <player> SetPerkIcon( <string> )\n");
  String = Scr_GetString(scrContext, 0);
  if ( !NetConstStrings_GetIndexFromName(NETCONSTSTRINGTYPE_IMAGE, String, &outIndex) )
  {
    v18 = j_va("'%s' is not a valid perk icon image. Please make sure it is included as precache_image in zone_source.", String);
    Scr_Error(COM_ERR_4084, scrContext, v18);
  }
  _RSI->client->sess.cs.perkIconName = outIndex;
}

/*
==============
GScr_GetCSplinePointTargetname
==============
*/
void GScr_GetCSplinePointTargetname(scrContext_t *scrContext)
{
  int Int; 
  unsigned int v3; 
  const char *v4; 
  int v5; 
  unsigned __int16 v6; 
  const char *v7; 
  scr_string_t CSplinePointTargetName; 

  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    Int = Scr_GetInt(scrContext, 0);
    v3 = truncate_cast<unsigned short,int>(Int);
    if ( v3 <= Com_GetCSplineCount() )
    {
      v5 = Scr_GetInt(scrContext, 1u);
      v6 = truncate_cast<unsigned short,int>(v5);
      if ( v6 < Com_GetCSplinePointCount(v3) )
      {
        CSplinePointTargetName = Com_GetCSplinePointTargetName(v3, v6);
        if ( CSplinePointTargetName )
          Scr_AddConstString(scrContext, CSplinePointTargetName);
        else
          Scr_AddUndefined(scrContext);
      }
      else
      {
        v7 = j_va("'%s' - Invalid CSpline Node Index '%i' for Spline '%i'\n", "GetCSplinePointTargetname", v6, v3);
        Scr_Error(COM_ERR_4688, scrContext, v7);
      }
    }
    else
    {
      v4 = j_va("'%s' - Invalid CSpline Id '%i'\n", "GetCSplinePointTargetname", v3);
      Scr_Error(COM_ERR_4687, scrContext, v4);
    }
  }
  else
  {
    Scr_Error(COM_ERR_4698, scrContext, "USAGE: GetCSplinePointTargetname(splineId, splineNodeIndex)\n");
  }
}

/*
==============
GScr_GetCSplinePointTarget
==============
*/
void GScr_GetCSplinePointTarget(scrContext_t *scrContext)
{
  int Int; 
  unsigned int v3; 
  const char *v4; 
  int v5; 
  unsigned __int16 v6; 
  const char *v7; 
  scr_string_t CSplinePointTarget; 

  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    Int = Scr_GetInt(scrContext, 0);
    v3 = truncate_cast<unsigned short,int>(Int);
    if ( v3 <= Com_GetCSplineCount() )
    {
      v5 = Scr_GetInt(scrContext, 1u);
      v6 = truncate_cast<unsigned short,int>(v5);
      if ( v6 < Com_GetCSplinePointCount(v3) )
      {
        CSplinePointTarget = Com_GetCSplinePointTarget(v3, v6);
        if ( CSplinePointTarget )
          Scr_AddConstString(scrContext, CSplinePointTarget);
        else
          Scr_AddUndefined(scrContext);
      }
      else
      {
        v7 = j_va("'%s' - Invalid CSpline Node Index '%i' for Spline '%i'\n", "GetCSplinePointTarget", v6, v3);
        Scr_Error(COM_ERR_4688, scrContext, v7);
      }
    }
    else
    {
      v4 = j_va("'%s' - Invalid CSpline Id '%i'\n", "GetCSplinePointTarget", v3);
      Scr_Error(COM_ERR_4687, scrContext, v4);
    }
  }
  else
  {
    Scr_Error(COM_ERR_4699, scrContext, "USAGE: GetCSplinePointTarget(splineId, splineNodeIndex)\n");
  }
}

/*
==============
GScr_SetSquadIndex
==============
*/
void GScr_SetSquadIndex(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v16; 
  int Int; 
  const char *v18; 
  __int64 v19; 

  entnum = entref.entnum;
  _RSI = GScr_Main_GetPlayerEntity(scrContext, entref);
  if ( !G_Utils_IsClient(_RSI) )
  {
    targetname = _RSI->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(_RSI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rsi+134h]
      vmovss  xmm2, dword ptr [rsi+130h]
      vmovss  xmm0, dword ptr [rsi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+48h+var_28], xmm0
    }
    v16 = j_va("SetSquadIndex(). Only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, v19, v7, v6);
    Scr_Error(COM_ERR_4085, scrContext, v16);
  }
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4086, scrContext, "USAGE: <player> SetSquadIndex( <int> )\n");
  if ( !SV_Game_IsPrivateMatch() )
    Scr_Error(COM_ERR_6125, scrContext, "SetSquadIndex() only valid for private matches, public matches squads are assigned via the matchmaker\n");
  Int = Scr_GetInt(scrContext, 0);
  if ( Int > 255 )
  {
    v18 = j_va("Squad index limit exceeded! The maximum supported squad index is %d\n", 255i64);
    Scr_Error(COM_ERR_4087, scrContext, v18);
  }
  _RSI->client->sess.cs.squadIndex = Int;
}

/*
==============
GScr_GetCSplinePointTension
==============
*/
void GScr_GetCSplinePointTension(scrContext_t *scrContext)
{
  int Int; 
  unsigned int v4; 
  const char *v5; 
  int v6; 
  unsigned __int16 v7; 
  const char *v8; 

  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    Int = Scr_GetInt(scrContext, 0);
    v4 = truncate_cast<unsigned short,int>(Int);
    if ( v4 <= Com_GetCSplineCount() )
    {
      v6 = Scr_GetInt(scrContext, 1u);
      v7 = truncate_cast<unsigned short,int>(v6);
      if ( v7 < Com_GetCSplinePointCount(v4) )
      {
        *(double *)&_XMM0 = Com_GetCSplinePointTension(v4, v7);
        __asm { vmovaps xmm1, xmm0; value }
        Scr_AddFloat(scrContext, *(float *)&_XMM1);
      }
      else
      {
        v8 = j_va("'%s' - Invalid CSpline Node Index '%i' for Spline '%i'\n", "GetCSplinePointTension", v7, v4);
        Scr_Error(COM_ERR_4688, scrContext, v8);
      }
    }
    else
    {
      v5 = j_va("'%s' - Invalid CSpline Id '%i'\n", "GetCSplinePointTension", v4);
      Scr_Error(COM_ERR_4687, scrContext, v5);
    }
  }
  else
  {
    Scr_Error(COM_ERR_4700, scrContext, "USAGE: GetCSplinePointTension(splineId, splineNodeIndex)\n");
  }
}

/*
==============
GScr_GetSquadIndex
==============
*/
void GScr_GetSquadIndex(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v16; 
  __int64 v17; 

  entnum = entref.entnum;
  _RSI = GScr_Main_GetPlayerEntity(scrContext, entref);
  if ( !G_Utils_IsClient(_RSI) )
  {
    targetname = _RSI->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(_RSI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rsi+134h]
      vmovss  xmm2, dword ptr [rsi+130h]
      vmovss  xmm0, dword ptr [rsi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+48h+var_28], xmm0
    }
    v16 = j_va("GetSquadIndex(). Only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, v17, v7, v6);
    Scr_Error(COM_ERR_6126, scrContext, v16);
  }
  if ( Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_6127, scrContext, "USAGE: <player> GetSquadIndex()\n");
  Scr_AddInt(scrContext, _RSI->client->sess.cs.squadIndex);
}

/*
==============
GScr_GetCSplinePointPosition
==============
*/
void GScr_GetCSplinePointPosition(scrContext_t *scrContext)
{
  int Int; 
  unsigned int v3; 
  const char *v4; 
  int v5; 
  unsigned __int16 v6; 
  const char *v7; 
  vec3_t out_position; 

  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    Int = Scr_GetInt(scrContext, 0);
    v3 = truncate_cast<unsigned short,int>(Int);
    if ( v3 <= Com_GetCSplineCount() )
    {
      v5 = Scr_GetInt(scrContext, 1u);
      v6 = truncate_cast<unsigned short,int>(v5);
      if ( v6 < Com_GetCSplinePointCount(v3) )
      {
        Com_GetCSplinePointPosition(v3, v6, &out_position);
        Scr_AddVector(scrContext, out_position.v);
      }
      else
      {
        v7 = j_va("'%s' - Invalid CSpline Node Index '%i' for Spline '%i'\n", "GetCSplinePointPosition", v6, v3);
        Scr_Error(COM_ERR_4688, scrContext, v7);
      }
    }
    else
    {
      v4 = j_va("'%s' - Invalid CSpline Id '%i'\n", "GetCSplinePointPosition", v3);
      Scr_Error(COM_ERR_4687, scrContext, v4);
    }
  }
  else
  {
    Scr_Error(COM_ERR_4701, scrContext, "USAGE: GetCSplinePointPosition(splineId, splineNodeIndex)\n");
  }
}

/*
==============
ScrCmd_SetNonStick
==============
*/
void ScrCmd_SetNonStick(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  unsigned int v5; 

  Entity = GetEntity(entref);
  if ( !Entity )
    Scr_Error(COM_ERR_4088, scrContext, "SetNonStick() invoked on invalid entity.");
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4089, scrContext, "USAGE: <ent> SetNonStick( <bool> )\n");
  Int = Scr_GetInt(scrContext, 0);
  v5 = Entity->flags.m_flags[0] & 0xFFFFEFFF;
  if ( Int )
    v5 = Entity->flags.m_flags[0] | 0x1000;
  Entity->flags.m_flags[0] = v5;
}

/*
==============
GScr_GetCSplinePointCorridorDims
==============
*/
void GScr_GetCSplinePointCorridorDims(scrContext_t *scrContext)
{
  int Int; 
  unsigned int v3; 
  const char *v4; 
  int v5; 
  unsigned __int16 v6; 
  const char *v7; 
  vec2_t out_dims; 

  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    Int = Scr_GetInt(scrContext, 0);
    v3 = truncate_cast<unsigned short,int>(Int);
    if ( v3 <= Com_GetCSplineCount() )
    {
      v5 = Scr_GetInt(scrContext, 1u);
      v6 = truncate_cast<unsigned short,int>(v5);
      if ( v6 < Com_GetCSplinePointCount(v3) )
      {
        Com_GetCSplinePointCorridorDims(v3, v6, &out_dims);
        Scr_AddVector(scrContext, (const float *)&out_dims);
      }
      else
      {
        v7 = j_va("'%s' - Invalid CSpline Node Index '%i' for Spline '%i'\n", "GetCSplinePointCorridorDims", v6, v3);
        Scr_Error(COM_ERR_4688, scrContext, v7);
      }
    }
    else
    {
      v4 = j_va("'%s' - Invalid CSpline Id '%i'\n", "GetCSplinePointCorridorDims", v3);
      Scr_Error(COM_ERR_4687, scrContext, v4);
    }
  }
  else
  {
    Scr_Error(COM_ERR_4702, scrContext, "USAGE: GetCSplinePointCorridorDims(splineId, splineNodeIndex)\n");
  }
}

/*
==============
GScr_GetCSplinePointTangent
==============
*/
void GScr_GetCSplinePointTangent(scrContext_t *scrContext)
{
  int Int; 
  unsigned int v3; 
  const char *v4; 
  int v5; 
  unsigned __int16 v6; 
  const char *v7; 
  vec3_t out_tangent; 

  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    Int = Scr_GetInt(scrContext, 0);
    v3 = truncate_cast<unsigned short,int>(Int);
    if ( v3 <= Com_GetCSplineCount() )
    {
      v5 = Scr_GetInt(scrContext, 1u);
      v6 = truncate_cast<unsigned short,int>(v5);
      if ( v6 < Com_GetCSplinePointCount(v3) )
      {
        Com_GetCSplinePointTangent(v3, v6, &out_tangent);
        Scr_AddVector(scrContext, out_tangent.v);
      }
      else
      {
        v7 = j_va("'%s' - Invalid CSpline Node Index '%i' for Spline '%i'\n", "GetCSplinePointTangent", v6, v3);
        Scr_Error(COM_ERR_4688, scrContext, v7);
      }
    }
    else
    {
      v4 = j_va("'%s' - Invalid CSpline Id '%i'\n", "GetCSplinePointTangent", v3);
      Scr_Error(COM_ERR_4687, scrContext, v4);
    }
  }
  else
  {
    Scr_Error(COM_ERR_4703, scrContext, "USAGE: GetCSplinePointTangent(splineId, splineNodeIndex)\n");
  }
}

/*
==============
ScrCmd_GetNonStick
==============
*/
void ScrCmd_GetNonStick(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( !Entity )
    Scr_Error(COM_ERR_4090, scrContext, "GetNonStick() invoked on invalid entity.");
  Scr_AddBool(scrContext, (Entity->flags.m_flags[0] >> 12) & 1);
}

/*
==============
ScrCmd_SetScriptableBeamLength
==============
*/
void ScrCmd_SetScriptableBeamLength(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  char v7; 
  char v8; 
  const char *v11; 
  const char *v12; 

  __asm { vmovaps [rsp+38h+var_18], xmm6 }
  Entity = GetEntity(entref);
  if ( !Entity )
    Scr_Error(COM_ERR_4091, scrContext, "SetScriptableBeamLength() invoked on invalid entity.");
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm
  {
    vcomiss xmm0, cs:__real@461c4000
    vmovaps xmm6, xmm0
  }
  if ( !(v7 | v8) )
  {
    __asm
    {
      vmovsd  xmm1, cs:__real@40c3880000000000
      vmovq   rdx, xmm1
    }
    v11 = j_va("SetScriptableBeamLength() length is longer than LERP_ENTITY_STATE_MISSILE_EFFECT_MAX_LENGTH %f\n", _RDX);
    Scr_Error(COM_ERR_4092, scrContext, v11);
  }
  if ( Entity->s.eType != ET_MISSILE )
  {
    v12 = j_va("SetScriptableBeamLength() currently only supports missile ents, but could be changed by code with additional work and bandwidth cost.\n");
    Scr_Error(COM_ERR_4093, scrContext, v12);
  }
  __asm
  {
    vmovss  xmm1, cs:__real@461c4000; maxAbsValueSize
    vmovaps xmm0, xmm6; value
    vmovaps xmm6, [rsp+38h+var_18]
  }
  Entity->s.lerp.u.anonymous.data[6] = MSG_PackUnsignedFloat(*(float *)&_XMM0, *(float *)&_XMM1, 0x10u);
}

/*
==============
GScr_GetCSplinePointDistToNextPoint
==============
*/
void GScr_GetCSplinePointDistToNextPoint(scrContext_t *scrContext)
{
  int Int; 
  unsigned int v4; 
  const char *v5; 
  int v6; 
  unsigned __int16 v7; 
  const char *v8; 

  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    Int = Scr_GetInt(scrContext, 0);
    v4 = truncate_cast<unsigned short,int>(Int);
    if ( v4 <= Com_GetCSplineCount() )
    {
      v6 = Scr_GetInt(scrContext, 1u);
      v7 = truncate_cast<unsigned short,int>(v6);
      if ( v7 < Com_GetCSplinePointCount(v4) )
      {
        *(double *)&_XMM0 = Com_GetCSplinePointDistToNextPoint(v4, v7);
        __asm { vmovaps xmm1, xmm0; value }
        Scr_AddFloat(scrContext, *(float *)&_XMM1);
      }
      else
      {
        v8 = j_va("'%s' - Invalid CSpline Node Index '%i' for Spline '%i'\n", "GetCSplinePointDistToNextPoint", v7, v4);
        Scr_Error(COM_ERR_4688, scrContext, v8);
      }
    }
    else
    {
      v5 = j_va("'%s' - Invalid CSpline Id '%i'\n", "GetCSplinePointDistToNextPoint", v4);
      Scr_Error(COM_ERR_4687, scrContext, v5);
    }
  }
  else
  {
    Scr_Error(COM_ERR_4704, scrContext, "USAGE: GetCSplinePointDistToNextPoint(splineId, splineNodeIndex)\n");
  }
}

/*
==============
GScr_CalcCSplinePosition
==============
*/

void __fastcall GScr_CalcCSplinePosition(scrContext_t *scrContext, double _XMM1_8)
{
  int Int; 
  unsigned int v5; 
  const char *v6; 
  int v7; 
  unsigned __int16 v8; 
  const char *v9; 
  ComErrorCode v10; 
  char v11; 
  char v12; 
  unsigned int v17; 
  vec3_t out_position; 

  if ( Scr_GetNumParam(scrContext) != 3 )
  {
    Scr_Error(COM_ERR_4705, scrContext, "USAGE: CalcCSplinePosition(splineId, splineNodeIndex, lambda)\n");
    return;
  }
  Int = Scr_GetInt(scrContext, 0);
  v5 = truncate_cast<unsigned short,int>(Int);
  if ( v5 > Com_GetCSplineCount() )
  {
    v6 = j_va("'%s' - Invalid CSpline Id '%i'\n", "CalcCSplinePosition", v5);
    Scr_Error(COM_ERR_4687, scrContext, v6);
    return;
  }
  v7 = Scr_GetInt(scrContext, 1u);
  v8 = truncate_cast<unsigned short,int>(v7);
  if ( v8 < Com_GetCSplinePointCount(v5) )
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
    __asm
    {
      vxorps  xmm1, xmm1, xmm1
      vcomiss xmm0, xmm1
    }
    if ( !v11 )
    {
      __asm { vcomiss xmm0, cs:__real@3f800000 }
      if ( v11 | v12 )
      {
        __asm { vmovaps xmm2, xmm0; lambda }
        Com_CalcCSplinePosition(v5, v8, *(float *)&_XMM2, &out_position);
        Scr_AddVector(scrContext, out_position.v);
        return;
      }
    }
    __asm
    {
      vcvtss2sd xmm2, xmm0, xmm0
      vmovq   r8, xmm2
    }
    v17 = v5;
    v9 = j_va("'%s' - Invalid CSpline Lambda '%f' for Index '%i' for Spline '%i'\n", "CalcCSplinePosition", _R8, v8, v17);
    v10 = COM_ERR_4689;
  }
  else
  {
    v9 = j_va("'%s' - Invalid CSpline Node Index '%i' for Spline '%i'\n", "CalcCSplinePosition", v8, v5);
    v10 = COM_ERR_4688;
  }
  Scr_Error(v10, scrContext, v9);
}

/*
==============
ScrCmd_SetNoDeploy
==============
*/
void ScrCmd_SetNoDeploy(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  unsigned int v5; 

  Entity = GetEntity(entref);
  if ( !Entity )
    Scr_Error(COM_ERR_4094, scrContext, "SetNoDeploy() invoked on invalid entity.");
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4095, scrContext, "USAGE: <ent> SetNoDeploy( <bool> )\n");
  Int = Scr_GetInt(scrContext, 0);
  v5 = Entity->flags.m_flags[0] & 0xF7FFFFFF;
  if ( Int )
    v5 = Entity->flags.m_flags[0] | 0x8000000;
  Entity->flags.m_flags[0] = v5;
}

/*
==============
GScr_CalcCSplineTangent
==============
*/

void __fastcall GScr_CalcCSplineTangent(scrContext_t *scrContext, double _XMM1_8)
{
  int Int; 
  unsigned int v5; 
  const char *v6; 
  int v7; 
  unsigned __int16 v8; 
  const char *v9; 
  ComErrorCode v10; 
  char v11; 
  char v12; 
  unsigned int v17; 
  vec3_t out_tangent; 

  if ( Scr_GetNumParam(scrContext) != 3 )
  {
    Scr_Error(COM_ERR_4706, scrContext, "USAGE: CalcCSplineTangent(splineId, splineNodeIndex, lambda)\n");
    return;
  }
  Int = Scr_GetInt(scrContext, 0);
  v5 = truncate_cast<unsigned short,int>(Int);
  if ( v5 > Com_GetCSplineCount() )
  {
    v6 = j_va("'%s' - Invalid CSpline Id '%i'\n", "CalcCSplineTangent", v5);
    Scr_Error(COM_ERR_4687, scrContext, v6);
    return;
  }
  v7 = Scr_GetInt(scrContext, 1u);
  v8 = truncate_cast<unsigned short,int>(v7);
  if ( v8 < Com_GetCSplinePointCount(v5) )
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
    __asm
    {
      vxorps  xmm1, xmm1, xmm1
      vcomiss xmm0, xmm1
    }
    if ( !v11 )
    {
      __asm { vcomiss xmm0, cs:__real@3f800000 }
      if ( v11 | v12 )
      {
        __asm { vmovaps xmm2, xmm0; lambda }
        Com_CalcCSplineTangent(v5, v8, *(float *)&_XMM2, &out_tangent);
        Scr_AddVector(scrContext, out_tangent.v);
        return;
      }
    }
    __asm
    {
      vcvtss2sd xmm2, xmm0, xmm0
      vmovq   r8, xmm2
    }
    v17 = v5;
    v9 = j_va("'%s' - Invalid CSpline Lambda '%f' for Index '%i' for Spline '%i'\n", "CalcCSplineTangent", _R8, v8, v17);
    v10 = COM_ERR_4689;
  }
  else
  {
    v9 = j_va("'%s' - Invalid CSpline Node Index '%i' for Spline '%i'\n", "CalcCSplineTangent", v8, v5);
    v10 = COM_ERR_4688;
  }
  Scr_Error(v10, scrContext, v9);
}

/*
==============
GScr_CalcCSplineCorridor
==============
*/

void __fastcall GScr_CalcCSplineCorridor(scrContext_t *scrContext, double _XMM1_8)
{
  int Int; 
  unsigned int v5; 
  const char *v6; 
  int v7; 
  unsigned __int16 v8; 
  const char *v9; 
  ComErrorCode v10; 
  char v11; 
  char v12; 
  unsigned int v17; 
  vec2_t out_dims; 

  if ( Scr_GetNumParam(scrContext) != 3 )
  {
    Scr_Error(COM_ERR_4707, scrContext, "USAGE: CalcCSplineCorridor(splineId, splineNodeIndex, lambda)\n");
    return;
  }
  Int = Scr_GetInt(scrContext, 0);
  v5 = truncate_cast<unsigned short,int>(Int);
  if ( v5 > Com_GetCSplineCount() )
  {
    v6 = j_va("'%s' - Invalid CSpline Id '%i'\n", "CalcCSplineCorridor", v5);
    Scr_Error(COM_ERR_4687, scrContext, v6);
    return;
  }
  v7 = Scr_GetInt(scrContext, 1u);
  v8 = truncate_cast<unsigned short,int>(v7);
  if ( v8 < Com_GetCSplinePointCount(v5) )
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
    __asm
    {
      vxorps  xmm1, xmm1, xmm1
      vcomiss xmm0, xmm1
    }
    if ( !v11 )
    {
      __asm { vcomiss xmm0, cs:__real@3f800000 }
      if ( v11 | v12 )
      {
        __asm { vmovaps xmm2, xmm0; lambda }
        Com_CalcCSplineCorridor(v5, v8, *(float *)&_XMM2, &out_dims);
        Scr_AddVector(scrContext, (const float *)&out_dims);
        return;
      }
    }
    __asm
    {
      vcvtss2sd xmm2, xmm0, xmm0
      vmovq   r8, xmm2
    }
    v17 = v5;
    v9 = j_va("'%s' - Invalid CSpline Lambda '%f' for Index '%i' for Spline '%i'\n", "CalcCSplineCorridor", _R8, v8, v17);
    v10 = COM_ERR_4689;
  }
  else
  {
    v9 = j_va("'%s' - Invalid CSpline Node Index '%i' for Spline '%i'\n", "CalcCSplineCorridor", v8, v5);
    v10 = COM_ERR_4688;
  }
  Scr_Error(v10, scrContext, v9);
}

/*
==============
GScr_CalcCSplineClosestPoint
==============
*/
void GScr_CalcCSplineClosestPoint(scrContext_t *scrContext)
{
  int Int; 
  unsigned int v3; 
  const char *v4; 
  unsigned __int16 out_splinePointIndex[2]; 
  float out_lambda; 
  vec3_t vectorValue; 
  vec3_t out_position; 

  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    Int = Scr_GetInt(scrContext, 0);
    v3 = truncate_cast<unsigned short,int>(Int);
    if ( v3 <= Com_GetCSplineCount() )
    {
      Scr_GetVector(scrContext, 1u, &vectorValue);
      Com_CalcCSplineClosestPointOnSpline(v3, &vectorValue, out_splinePointIndex, &out_lambda);
      __asm { vmovss  xmm2, [rsp+58h+out_lambda]; lambda }
      Com_CalcCSplinePosition(v3, out_splinePointIndex[0], *(float *)&_XMM2, &out_position);
      Scr_AddVector(scrContext, out_position.v);
    }
    else
    {
      v4 = j_va("'%s' - Invalid CSpline Id '%i'\n", "CalcCSplineClosestPoint", v3);
      Scr_Error(COM_ERR_4687, scrContext, v4);
    }
  }
  else
  {
    Scr_Error(COM_ERR_4708, scrContext, "USAGE: CalcCSplineClosestPoint(splineId, point)\n");
  }
}

/*
==============
GScr_LocalToWorldCoords
==============
*/
void GScr_LocalToWorldCoords(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  vec3_t vectorValue; 
  float value[4]; 
  tmat33_t<vec3_t> axis; 
  char v42; 

  __asm
  {
    vmovaps [rsp+98h+var_18], xmm6
    vmovaps [rsp+98h+var_28], xmm9
  }
  Entity = GetEntity(entref);
  Scr_GetVector(scrContext, 0, &vectorValue);
  AnglesToAxis(&Entity->r.currentAngles, &axis);
  __asm
  {
    vmovss  xmm6, dword ptr [rsp+98h+vectorValue+8]
    vmovss  xmm0, dword ptr [rsp+98h+axis]
    vmulss  xmm2, xmm0, dword ptr [rsp+98h+vectorValue]
    vmovss  xmm1, dword ptr [rsp+98h+axis+0Ch]
    vmulss  xmm0, xmm1, dword ptr [rsp+98h+vectorValue+4]
    vmulss  xmm1, xmm6, dword ptr [rsp+98h+axis+18h]
    vaddss  xmm2, xmm2, xmm0
    vmovss  xmm0, dword ptr [rsp+98h+axis+4]
    vmulss  xmm3, xmm0, dword ptr [rsp+98h+vectorValue]
    vmovss  xmm0, dword ptr [rsp+98h+axis+8]
    vaddss  xmm9, xmm2, xmm1
    vmovss  xmm1, dword ptr [rsp+98h+axis+10h]
    vmulss  xmm2, xmm1, dword ptr [rsp+98h+vectorValue+4]
    vmulss  xmm1, xmm6, dword ptr [rsp+98h+axis+1Ch]
    vaddss  xmm4, xmm3, xmm2
    vmulss  xmm3, xmm0, dword ptr [rsp+98h+vectorValue]
    vaddss  xmm5, xmm4, xmm1
    vmovss  xmm1, dword ptr [rsp+98h+axis+14h]
    vmulss  xmm2, xmm1, dword ptr [rsp+98h+vectorValue+4]
    vmulss  xmm1, xmm6, dword ptr [rsp+98h+axis+20h]
    vmovss  [rsp+98h+value], xmm9
    vmovss  [rsp+98h+var_64], xmm5
    vaddss  xmm4, xmm3, xmm2
    vaddss  xmm2, xmm4, xmm1
    vmovss  [rsp+98h+var_60], xmm2
    vaddss  xmm0, xmm9, dword ptr [rbx+130h]
    vmovss  [rsp+98h+value], xmm0
    vaddss  xmm1, xmm5, dword ptr [rbx+134h]
    vmovss  [rsp+98h+var_64], xmm1
    vaddss  xmm0, xmm2, dword ptr [rbx+138h]
    vmovss  [rsp+98h+var_60], xmm0
  }
  Scr_AddVector(scrContext, value);
  _R11 = &v42;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm9, xmmword ptr [r11-20h]
  }
}

/*
==============
GScr_GameDVRProhibitRecording
==============
*/
void GScr_GameDVRProhibitRecording(scrContext_t *scrContext)
{
  int Int; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4709, scrContext, "USAGE: ProhibitRecording( prohibit )\n");
  Int = Scr_GetInt(scrContext, 0);
  GameDVR_ProhibitRecording(Int != 0);
}

/*
==============
GScr_GameDVRStartRecording
==============
*/

void __fastcall GScr_GameDVRStartRecording(scrContext_t *scrContext)
{
  GameDVR_StartRecording();
}

/*
==============
GScr_GameDVRStopRecording
==============
*/
void GScr_GameDVRStopRecording(scrContext_t *scrContext)
{
  int Int; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4710, scrContext, "USAGE: StopRecording( discard )\n");
  Int = Scr_GetInt(scrContext, 0);
  GameDVR_StopRecording(Int != 0);
}

/*
==============
GScr_GameDVRSetVideoMetadata
==============
*/
void GScr_GameDVRSetVideoMetadata(scrContext_t *scrContext)
{
  const char *String; 
  const char *v3; 
  const char *v4; 
  const char *v5; 

  if ( Scr_GetNumParam(scrContext) != 4 )
    Scr_Error(COM_ERR_4711, scrContext, "USAGE: SetVideoMetadata( title, description, comment, copyright )\n");
  String = Scr_GetString(scrContext, 3u);
  v3 = Scr_GetString(scrContext, 2u);
  v4 = Scr_GetString(scrContext, 1u);
  v5 = Scr_GetString(scrContext, 0);
  GameDVR_SetVideoMetadata(v5, v4, v3, String);
}

/*
==============
GScr_Earthquake
==============
*/
void GScr_Earthquake(scrContext_t *scrContext)
{
  GScr_Earthquake_Internal(scrContext, -1);
}

/*
==============
GScr_GameDVRProhibitScreenshots
==============
*/
void GScr_GameDVRProhibitScreenshots(scrContext_t *scrContext)
{
  int Int; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4712, scrContext, "USAGE: ProhibitScreenshots( prohibit )\n");
  Int = Scr_GetInt(scrContext, 0);
  GameDVR_ProhibitScreenshots(Int != 0);
}

/*
==============
GScr_EarthquakeForPlayer
==============
*/
void GScr_EarthquakeForPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  const char *v5; 
  scr_string_t targetname; 
  const char *v7; 
  const char *v8; 
  const char *v17; 
  char *fmt; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    _RDI = NULL;
LABEL_8:
    if ( !_RDI->client )
    {
      targetname = _RDI->targetname;
      if ( targetname )
        v7 = SL_ConvertToString(targetname);
      else
        v7 = "<undefined>";
      v8 = SL_ConvertToString(_RDI->classname);
      __asm
      {
        vmovss  xmm3, dword ptr [rdi+134h]
        vmovss  xmm2, dword ptr [rdi+130h]
        vmovss  xmm0, dword ptr [rdi+138h]
        vcvtss2sd xmm3, xmm3, xmm3
        vcvtss2sd xmm2, xmm2, xmm2
        vcvtss2sd xmm0, xmm0, xmm0
        vmovq   r9, xmm3
        vmovq   r8, xmm2
        vmovsd  [rsp+48h+fmt], xmm0
      }
      v17 = j_va("only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, fmt, v8, v7);
      Scr_Error(COM_ERR_4099, scrContext, v17);
    }
    goto LABEL_13;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 6374, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  _RDI = &g_entities[entnum];
  if ( !_RDI->client )
  {
    v5 = j_va("entity %i is not a player", entnum);
    Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    goto LABEL_8;
  }
LABEL_13:
  GScr_Earthquake_Internal(scrContext, _RDI->s.number);
}

/*
==============
GScr_GameDVRSetScreenshotMetadata
==============
*/
void GScr_GameDVRSetScreenshotMetadata(scrContext_t *scrContext)
{
  const char *String; 
  const char *v3; 
  const char *v4; 

  if ( Scr_GetNumParam(scrContext) != 3 )
    Scr_Error(COM_ERR_4713, scrContext, "USAGE: SetScreenshotMetadata( game, title, comment )\n");
  String = Scr_GetString(scrContext, 2u);
  v3 = Scr_GetString(scrContext, 1u);
  v4 = Scr_GetString(scrContext, 0);
  GameDVR_SetScreenshotMetadata(v4, v3, String);
}

/*
==============
GScr_LiveStreamingEnable
==============
*/
void GScr_LiveStreamingEnable(scrContext_t *scrContext)
{
  ;
}

/*
==============
GScr_LiveStreamingSetBitrate
==============
*/
void GScr_LiveStreamingSetBitrate(scrContext_t *scrContext)
{
  ;
}

/*
==============
GScr_StopShellShock
==============
*/
void GScr_StopShellShock(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v16; 
  playerState_s *EntityPlayerState; 
  char *fmt; 

  entnum = entref.entnum;
  _RDI = GetEntity(entref);
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 6399, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClientOrAgent(_RDI) )
  {
    targetname = _RDI->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(_RDI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rdi+134h]
      vmovss  xmm2, dword ptr [rdi+130h]
      vmovss  xmm0, dword ptr [rdi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+48h+fmt], xmm0
    }
    v16 = j_va("only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, fmt, v7, v6);
    Scr_Error(COM_ERR_4100, scrContext, v16);
  }
  EntityPlayerState = G_GetEntityPlayerState(_RDI);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 6405, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_4101, scrContext, "USAGE: <player> stopshellshock()\n");
  *(_QWORD *)&EntityPlayerState->shellshockIndex = 0i64;
  EntityPlayerState->shellshockDuration = 0;
  GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(&EntityPlayerState->pm_flags, ACTIVE, 0x15u);
}

/*
==============
GScr_FadeOutShellShock
==============
*/
void GScr_FadeOutShellShock(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v16; 
  playerState_s *EntityPlayerState; 
  shellshock_parms_t *ShellshockParms; 
  int fadeTime; 
  int shellshockDuration; 
  int time; 
  gclient_s *client; 
  __int64 v23; 
  const char *v24; 
  unsigned int v25; 
  unsigned __int16 v26; 
  unsigned int v27; 
  char *fmt; 

  entnum = entref.entnum;
  _RDI = GetEntity(entref);
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 6437, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClientOrAgent(_RDI) )
  {
    targetname = _RDI->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(_RDI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rdi+134h]
      vmovss  xmm2, dword ptr [rdi+130h]
      vmovss  xmm0, dword ptr [rdi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+48h+fmt], xmm0
    }
    v16 = j_va("only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, fmt, v7, v6);
    Scr_Error(COM_ERR_4102, scrContext, v16);
  }
  EntityPlayerState = G_GetEntityPlayerState(_RDI);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 6443, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_4103, scrContext, "USAGE: <player> FadeOutShellShock()\n");
  if ( GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&EntityPlayerState->pm_flags, ACTIVE, 0x15u) && EntityPlayerState->shellshockDuration )
  {
    ShellshockParms = BG_GetShellshockParms(EntityPlayerState->shellshockIndex);
    if ( !ShellshockParms && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 6454, ASSERT_TYPE_ASSERT, "(shockParms)", (const char *)&queryFormat, "shockParms") )
      __debugbreak();
    fadeTime = ShellshockParms->view.fadeTime;
    shellshockDuration = EntityPlayerState->shellshockDuration;
    time = level.time;
    if ( shellshockDuration + EntityPlayerState->shellshockTime - fadeTime > level.time )
    {
      client = _RDI->client;
      v23 = (unsigned int)(level.time + fadeTime - client->ps.shellshockTime);
      if ( (int)v23 > 0xFFFF )
      {
        v24 = j_va("Invalid shellshockDuration %d. It must be < %d\n", v23, 0xFFFFi64);
        Scr_Error(COM_ERR_4104, scrContext, v24);
        LOWORD(shellshockDuration) = EntityPlayerState->shellshockDuration;
        client = _RDI->client;
        fadeTime = ShellshockParms->view.fadeTime;
        time = level.time;
      }
      v25 = shellshockDuration & 0x7F;
      v26 = truncate_cast<unsigned short,int>(time + fadeTime - client->ps.shellshockTime);
      EntityPlayerState->shellshockDuration = v26;
      v27 = v26 & 0x7F;
      if ( v25 > v27 )
        EntityPlayerState->shellshockDuration += truncate_cast<unsigned short,int>(v25 - v27);
    }
  }
}

/*
==============
ScrCmd_SetModel
==============
*/
void ScrCmd_SetModel(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *String; 
  bool IsNameCompositeModel; 
  const char *v6; 
  unsigned __int16 model; 
  const DObj *ServerDObjForEnt; 
  DObj *v9; 
  const char *v10; 

  Entity = GetEntity(entref);
  String = Scr_GetString(scrContext, 0);
  IsNameCompositeModel = G_Utils_IsNameCompositeModel(String);
  if ( !GUtils::ms_gUtils && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_utils.h", 112, ASSERT_TYPE_ASSERT, "( ms_gUtils )", (const char *)&queryFormat, "ms_gUtils") )
    __debugbreak();
  if ( GUtils::ms_gUtils->IsTransientCustomizationModel(GUtils::ms_gUtils, String) )
  {
    v6 = j_va("Can't set the model '%s' to a transient model from the server", String);
    Scr_Error(COM_ERR_4105, scrContext, v6);
  }
  G_XCompositeModel_Clear(Entity->s.eType, Entity);
  if ( IsNameCompositeModel )
    G_Utils_SetCompositeModel(Entity, Entity->s.eType, String);
  else
    G_Utils_SetModel(Entity, String);
  model = Entity->model;
  if ( model && G_Utils_IsModelBad(model) && G_Utils_IsActor(Entity) )
  {
    Com_PrintWarning(23, "WARNING: actor model '%s' couldn't be found! switching to default actor model.\n", String);
    G_Utils_OverrideModel(Entity->model, "defaultactor");
  }
  if ( Com_GameMode_SupportsFeature(WEAPON_DROPPING_ALT) )
  {
    ServerDObjForEnt = Com_GetServerDObjForEnt(Entity);
    if ( ServerDObjForEnt )
    {
      if ( DObjGetTree(ServerDObjForEnt) && !Entity->model )
        Scr_Error(COM_ERR_4106, scrContext, "Cannot remove an entity's model while it is playing an animation. Call scriptmodelclearanim first.\n");
    }
  }
  if ( !GUtils::ms_gUtils && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_utils.h", 112, ASSERT_TYPE_ASSERT, "( ms_gUtils )", (const char *)&queryFormat, "ms_gUtils") )
    __debugbreak();
  GUtils::ms_gUtils->DObjUpdate(GUtils::ms_gUtils, Entity, 1);
  if ( Entity->s.eType == ET_TURRET )
    G_Turret_SetDObjTransferFlag(Entity);
  v9 = Com_GetServerDObjForEnt(Entity);
  if ( v9 )
  {
    if ( (v9->flags & 0x10) != 0 )
    {
      v10 = j_va("Trying to set model for entity in a way where the existing child models will no longer have the correct attach bones, this will cause child models to appear in front of the camera. %s\n", String);
      Scr_Error(COM_ERR_4107, scrContext, v10);
    }
  }
}

/*
==============
ScrCmd_SetAsGametypeObjective
==============
*/
void ScrCmd_SetAsGametypeObjective(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  HudData *HudData; 

  if ( MLG_IsCoDCasterEnabled() )
  {
    Entity = GetEntity(entref);
    HudData = G_HudOutline_GetHudData(Entity);
    if ( !HudData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 6581, ASSERT_TYPE_ASSERT, "( hudData ) != ( nullptr )", "%s != %s\n\t%p, %p", "hudData", "nullptr", NULL, NULL) )
      __debugbreak();
    HudData->data |= 0x40u;
  }
}

/*
==============
GScr_ScriptBundleContextScoped::~GScr_ScriptBundleContextScoped
==============
*/
void GScr_ScriptBundleContextScoped::~GScr_ScriptBundleContextScoped(GScr_ScriptBundleContextScoped *this)
{
  _RAX = this->scoped;
  __asm
  {
    vmovups ymm0, ymmword ptr [rcx+8]
    vmovups ymmword ptr [rax], ymm0
  }
}

/*
==============
AddLinkedChildren
==============
*/
void AddLinkedChildren(scrContext_t *scrContext, const gentity_s *parent, int fullTree)
{
  gentity_s *i; 
  __int64 v6; 
  __int64 v7; 
  __int64 number; 
  scrContext_t *v9; 
  __int64 v10; 
  __int64 v11; 
  __int64 v12; 
  __int64 v13; 

  for ( i = parent->tagChildren; i; i = i->tagInfo->next )
  {
    if ( fullTree )
      AddLinkedChildren(scrContext, i, fullTree);
    if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 196, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
      __debugbreak();
    v6 = i - g_entities;
    if ( (unsigned int)v6 >= 0x800 )
    {
      LODWORD(v11) = 2048;
      LODWORD(v10) = ((int)i - (int)g_entities) / 1456;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 199, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( ( 2048 ) )", "index doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v10, v11) )
        __debugbreak();
    }
    if ( i->s.number != (_WORD)v6 )
    {
      if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 196, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
        __debugbreak();
      v7 = i - g_entities;
      if ( (unsigned int)v7 >= 0x800 )
      {
        LODWORD(v11) = 2048;
        LODWORD(v10) = ((int)i - (int)g_entities) / 1456;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 199, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( ( 2048 ) )", "index doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v10, v11) )
          __debugbreak();
      }
      LODWORD(v13) = (__int16)v7;
      LODWORD(v12) = i->s.number;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 948, ASSERT_TYPE_ASSERT, "( ent->s.number ) == ( G_GetEntityIndex( ent ) )", "%s == %s\n\t%i, %i", "ent->s.number", "G_GetEntityIndex( ent )", v12, v13) )
        __debugbreak();
    }
    number = i->s.number;
    if ( (unsigned int)number >= 0x800 )
    {
      LODWORD(v11) = 2048;
      LODWORD(v10) = i->s.number;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v10, v11) )
        __debugbreak();
    }
    if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
      __debugbreak();
    if ( g_entities[number].r.isInUse != g_entityIsInUse[number] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
      __debugbreak();
    if ( !g_entityIsInUse[number] )
    {
      LODWORD(v10) = i->s.number;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 949, ASSERT_TYPE_ASSERT, "( ( G_IsEntityInUse( ent->s.number ) ) )", "( ent->s.number ) = %i", v10) )
        __debugbreak();
    }
    v9 = ScriptContext_Server();
    Scr_AddEntityNum(v9, i->s.number, ENTITY_CLASS_GENTITY);
    Scr_AddArray(scrContext);
  }
}

/*
==============
AttachCmd
==============
*/
char AttachCmd(scrContext_t *scrContext, gentity_s *ent, scr_string_t *tagNameResult)
{
  const char *String; 
  scr_string_t ConstLowercaseString; 
  bool v8; 
  GUtils *v9; 
  const dvar_t *v10; 
  bool enabled; 
  const char *v12; 
  const char *v13; 
  const dvar_t *v14; 
  bool v15; 
  const char *v16; 
  const char *v17; 
  BOOL fmt; 
  BOOL v20; 
  bool v21; 

  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 6966, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  String = Scr_GetString(scrContext, 0);
  if ( Scr_GetNumParam(scrContext) < 2 )
    ConstLowercaseString = scr_const._;
  else
    ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 1u);
  v21 = Scr_GetNumParam(scrContext) >= 3 && Scr_GetInt(scrContext, 2u) != 0;
  v8 = Scr_GetNumParam(scrContext) >= 4 && Scr_GetInt(scrContext, 3u) != 0;
  if ( !GUtils::ms_gUtils && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_utils.h", 112, ASSERT_TYPE_ASSERT, "( ms_gUtils )", (const char *)&queryFormat, "ms_gUtils") )
    __debugbreak();
  v9 = GUtils::ms_gUtils;
  if ( GUtils::ms_gUtils->IsTransientCustomizationModel(GUtils::ms_gUtils, String) )
    Scr_Error(COM_ERR_4116, scrContext, "Should not be using transient models on the server");
  if ( v9->EntDetach(v9, ent, String, ConstLowercaseString) )
  {
    v10 = DVARBOOL_g_assertOnModelAttachFailure;
    if ( !DVARBOOL_g_assertOnModelAttachFailure && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "g_assertOnModelAttachFailure") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v10);
    enabled = v10->current.enabled;
    v12 = SL_ConvertToString(ConstLowercaseString);
    if ( enabled )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 6986, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "model '%s' already attached to tag '%s'", String, v12) )
        __debugbreak();
    }
    else
    {
      v13 = j_va("model '%s' already attached to tag '%s'", String, v12);
      Scr_Error(COM_ERR_4117, scrContext, v13);
    }
  }
  LOBYTE(v20) = v8;
  LOBYTE(fmt) = v21;
  if ( !v9->EntAttach(v9, ent, String, ConstLowercaseString, fmt, v20) )
  {
    v14 = DVARBOOL_g_assertOnModelAttachFailure;
    if ( !DVARBOOL_g_assertOnModelAttachFailure && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "g_assertOnModelAttachFailure") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v14);
    v15 = v14->current.enabled;
    v16 = SL_ConvertToString(ConstLowercaseString);
    if ( v15 )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 7000, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "failed to attach model '%s' to tag '%s'", String, v16) )
        __debugbreak();
    }
    else
    {
      v17 = j_va("failed to attach model '%s' to tag '%s'", String, v16);
      Scr_Error(COM_ERR_4118, scrContext, v17);
    }
  }
  *tagNameResult = ConstLowercaseString;
  return 1;
}

/*
==============
CheckTimes
==============
*/

void __fastcall CheckTimes(scrContext_t *scrContext, float *totalTime, double accelTime, double decelTime)
{
  char v12; 
  char v13; 

  __asm { vmovaps [rsp+58h+var_18], xmm6 }
  _RDI = totalTime;
  __asm
  {
    vmovaps [rsp+58h+var_28], xmm7
    vxorps  xmm6, xmm6, xmm6
    vcomiss xmm6, dword ptr [rdx]
    vmovaps [rsp+58h+var_38], xmm8
    vmovaps xmm7, xmm3
    vmovaps xmm8, xmm2
  }
  Scr_Error(COM_ERR_4185, scrContext, "total time must be non negative");
  __asm { vcomiss xmm8, xmm6 }
  if ( v12 )
    Scr_Error(COM_ERR_4186, scrContext, "acceleration time must be non negative");
  __asm { vcomiss xmm7, xmm6 }
  if ( v12 )
    Scr_Error(COM_ERR_4187, scrContext, "deceleration time must be non negative");
  __asm
  {
    vmovss  xmm0, dword ptr [rdi]
    vaddss  xmm1, xmm8, xmm7
    vcomiss xmm1, xmm0
  }
  if ( !(v12 | v13) )
  {
    __asm
    {
      vaddss  xmm0, xmm0, cs:__real@3f800004
      vcomiss xmm1, xmm0
    }
    if ( v12 | v13 )
      __asm { vmovss  dword ptr [rdi], xmm0 }
    else
      Scr_Error(COM_ERR_4188, scrContext, "accel time plus decel time is greater than total time");
  }
  __asm
  {
    vmovaps xmm6, [rsp+58h+var_18]
    vmovaps xmm7, [rsp+58h+var_28]
    vmovaps xmm8, [rsp+58h+var_38]
  }
}

/*
==============
CompareScriptObjectDistanceIncreasing
==============
*/
char CompareScriptObjectDistanceIncreasing(const EntityOrigin *obj1, const EntityOrigin *obj2)
{
  __asm
  {
    vmovss  xmm2, dword ptr cs:g_entitySortOrigin
    vmovss  xmm1, dword ptr cs:g_entitySortOrigin+4
    vsubss  xmm3, xmm1, dword ptr [rcx+4]
    vsubss  xmm5, xmm1, dword ptr [rdx+4]
    vmovss  xmm0, dword ptr cs:g_entitySortOrigin+8
    vsubss  xmm4, xmm0, dword ptr [rcx+8]
    vmovaps [rsp+38h+var_18], xmm6
    vsubss  xmm6, xmm2, dword ptr [rcx]
    vmovaps [rsp+38h+var_28], xmm7
    vsubss  xmm7, xmm2, dword ptr [rdx]
    vmovaps [rsp+38h+var_38], xmm8
    vsubss  xmm8, xmm0, dword ptr [rdx+8]
    vmulss  xmm1, xmm3, xmm3
    vmulss  xmm0, xmm6, xmm6
    vmovaps xmm6, [rsp+38h+var_18]
    vaddss  xmm2, xmm1, xmm0
    vmulss  xmm1, xmm4, xmm4
    vaddss  xmm4, xmm2, xmm1
    vmulss  xmm0, xmm7, xmm7
    vmovaps xmm7, [rsp+38h+var_28]
    vmulss  xmm1, xmm8, xmm8
    vmovaps xmm8, [rsp+38h+var_38]
    vmulss  xmm3, xmm5, xmm5
    vaddss  xmm2, xmm3, xmm0
    vaddss  xmm2, xmm2, xmm1
    vcomiss xmm2, xmm4
  }
  return 1;
}

/*
==============
DetachCmd
==============
*/
void DetachCmd(scrContext_t *scrContext, gentity_s *ent)
{
  const char *String; 
  scr_string_t ConstLowercaseString; 
  unsigned __int16 *attachModelNames; 
  __int64 v7; 
  scr_string_t *attachTagNames; 
  const char *v9; 
  const char *ModelName; 
  const char *v11; 
  const char *v12; 

  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 7608, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  String = Scr_GetString(scrContext, 0);
  if ( Scr_GetNumParam(scrContext) < 2 )
    ConstLowercaseString = scr_const._;
  else
    ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 1u);
  if ( !GUtils::ms_gUtils && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_utils.h", 112, ASSERT_TYPE_ASSERT, "( ms_gUtils )", (const char *)&queryFormat, "ms_gUtils") )
    __debugbreak();
  if ( !GUtils::ms_gUtils->EntDetach(GUtils::ms_gUtils, ent, String, ConstLowercaseString) )
  {
    Com_Printf(23, "Current attachments:\n");
    attachModelNames = ent->attachModelNames;
    v7 = 28i64;
    attachTagNames = ent->attachTagNames;
    do
    {
      if ( *attachModelNames )
      {
        if ( *attachTagNames )
        {
          v9 = SL_ConvertToString(*attachTagNames);
          ModelName = G_CString_GetModelName(*attachModelNames);
          Com_Printf(23, "model: '%s', tag: '%s'\n", ModelName, v9);
        }
      }
      ++attachTagNames;
      ++attachModelNames;
      --v7;
    }
    while ( v7 );
    v11 = SL_ConvertToString(ConstLowercaseString);
    v12 = j_va("failed to detach model '%s' from tag '%s'", String, v11);
    Scr_Error(COM_ERR_4139, scrContext, v12);
  }
}

/*
==============
GSCr_FilterPlayerMarks_AddEntRefInternal
==============
*/
void GSCr_FilterPlayerMarks_AddEntRefInternal(scrContext_t *scrContext, const scr_entref_t filterEntRef, unsigned int (*entFilterBits)[7])
{
  unsigned int entnum; 
  int v6; 
  int v7; 
  int v8; 

  entnum = filterEntRef.entnum;
  if ( filterEntRef.entclass )
    Scr_ParamError(COM_ERR_6354, scrContext, 0, "Invalid mark filter specified. Not a player entity.");
  v6 = truncate_cast<short,unsigned int>(entnum);
  if ( v6 > level.maxclients || (v6 & 0x8000u) != 0 )
    Scr_ParamError(COM_ERR_6355, scrContext, 0, "Invalid mark filter specified. Not a player entity.");
  if ( (unsigned __int16)((__int16)v6 >> 5) >= 7u )
  {
    v8 = 7;
    v7 = v6 >> 5;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31810, ASSERT_TYPE_ASSERT, "(unsigned)( entNum >> 5 ) < (unsigned)( ( sizeof( *array_counter( entFilterBits ) ) + 0 ) )", "entNum >> 5 doesn't index ARRAY_COUNT( entFilterBits )\n\t%i not in [0, %i)", v7, v8) )
      __debugbreak();
  }
  (*entFilterBits)[(__int64)(__int16)v6 >> 5] |= 0x80000000 >> (v6 & 0x1F);
}

/*
==============
GScr_AddEntity
==============
*/
void GScr_AddEntity(const gentity_s *ent)
{
  signed __int64 v2; 
  signed __int64 v3; 
  __int64 number; 
  scrContext_t *v5; 
  __int64 v6; 
  __int64 v7; 

  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 947, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 196, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
    __debugbreak();
  v2 = ent - g_entities;
  if ( (unsigned int)v2 >= 0x800 )
  {
    LODWORD(v6) = ent - g_entities;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 199, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( ( 2048 ) )", "index doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v6, 2048) )
      __debugbreak();
  }
  if ( ent->s.number != (_WORD)v2 )
  {
    if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 196, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
      __debugbreak();
    v3 = ent - g_entities;
    if ( (unsigned int)v3 >= 0x800 )
    {
      LODWORD(v7) = 2048;
      LODWORD(v6) = ((int)ent - (int)g_entities) / 1456;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 199, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( ( 2048 ) )", "index doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v6, v7) )
        __debugbreak();
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 948, ASSERT_TYPE_ASSERT, "( ent->s.number ) == ( G_GetEntityIndex( ent ) )", "%s == %s\n\t%i, %i", "ent->s.number", "G_GetEntityIndex( ent )", ent->s.number, (__int16)v3) )
      __debugbreak();
  }
  number = ent->s.number;
  if ( (unsigned int)number >= 0x800 )
  {
    LODWORD(v7) = 2048;
    LODWORD(v6) = ent->s.number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v6, v7) )
      __debugbreak();
  }
  if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
    __debugbreak();
  if ( g_entities[number].r.isInUse != g_entityIsInUse[number] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
    __debugbreak();
  if ( !g_entityIsInUse[number] )
  {
    LODWORD(v6) = ent->s.number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 949, ASSERT_TYPE_ASSERT, "( ( G_IsEntityInUse( ent->s.number ) ) )", "( ent->s.number ) = %i", v6) )
      __debugbreak();
  }
  v5 = ScriptContext_Server();
  Scr_AddEntityNum(v5, ent->s.number, ENTITY_CLASS_GENTITY);
}

/*
==============
GScr_AllocString
==============
*/
scr_string_t GScr_AllocString(const char *s)
{
  return Scr_AllocGameString(s, 1);
}

/*
==============
GScr_CheckRocketEntity
==============
*/
void GScr_CheckRocketEntity(scrContext_t *scrContext, gentity_s *missile)
{
  entityType_s eType; 
  const char *v5; 
  scr_string_t classname; 
  const char *v7; 
  const char *v8; 
  const char *v9; 

  if ( !missile && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 5779, ASSERT_TYPE_ASSERT, "(missile)", (const char *)&queryFormat, "missile") )
    __debugbreak();
  eType = missile->s.eType;
  if ( eType != ET_MISSILE )
  {
    v5 = j_va("Entity %i is not a rocket - eType '%i'\n", (unsigned int)missile->s.number, (unsigned int)eType);
    Scr_Error(COM_ERR_4074, scrContext, v5);
  }
  classname = missile->classname;
  if ( classname != scr_const.rocket )
  {
    v7 = SL_ConvertToString(classname);
    v8 = j_va("Entity %i is not a rocket - classname '%s'\n", (unsigned int)missile->s.number, v7);
    Scr_Error(COM_ERR_4075, scrContext, v8);
  }
  if ( G_Missile_IsGrenade(missile) )
  {
    v9 = j_va("Entity %i is not a rocket - it is a grenade\n", (unsigned int)missile->s.number);
    Scr_Error(COM_ERR_4076, scrContext, v9);
  }
}

/*
==============
GScr_DamageConeTraceInternal
==============
*/
void GScr_DamageConeTraceInternal(scrContext_t *scrContext, scr_entref_t entref, int contentMask)
{
  gentity_s *Entity; 
  gentity_s *v7; 
  int v9; 
  vec3_t vectorValue; 

  Entity = GetEntity(entref);
  if ( Scr_GetNumParam(scrContext) <= 1 )
    v7 = NULL;
  else
    v7 = GScr_GetEntity(1u);
  Scr_GetVector(scrContext, 0, &vectorValue);
  if ( !GCombat::ms_gCombatSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_combat.h", 177, ASSERT_TYPE_ASSERT, "( ms_gCombatSystem )", (const char *)&queryFormat, "ms_gCombatSystem") )
    __debugbreak();
  LOBYTE(v9) = 0;
  *(double *)&_XMM0 = ((double (__fastcall *)(GCombat *, gentity_s *, gentity_s *, vec3_t *, int, int, _QWORD))GCombat::ms_gCombatSystem->GetRadiusDamageFromPos)(GCombat::ms_gCombatSystem, Entity, v7, &vectorValue, contentMask, v9, 0i64);
  __asm { vmovaps xmm1, xmm0; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
GScr_Earthquake_Internal
==============
*/

void __fastcall GScr_Earthquake_Internal(scrContext_t *scrContext, int clientNum, double _XMM2_8)
{
  unsigned __int64 v8; 
  char v20; 
  char v21; 
  const dvar_t *v22; 
  int v28; 
  int v29; 
  vec3_t vectorValue; 
  char v31; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-18h], xmm6
    vmovaps xmmword ptr [rax-28h], xmm7
    vmovaps xmmword ptr [rax-38h], xmm8
  }
  v8 = (unsigned int)clientNum;
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm { vmovaps xmm8, xmm0 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm
  {
    vmulss  xmm1, xmm0, cs:__real@447a0000
    vaddss  xmm3, xmm1, cs:__real@3f000000
    vxorps  xmm2, xmm2, xmm2
    vmovss  xmm4, xmm2, xmm3
    vxorps  xmm1, xmm1, xmm1
    vroundss xmm5, xmm1, xmm4, 1
    vcvttss2si esi, xmm5
  }
  Scr_GetVector(scrContext, 2u, &vectorValue);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
  __asm
  {
    vxorps  xmm7, xmm7, xmm7
    vcomiss xmm8, xmm7
    vmovaps xmm6, xmm0
  }
  if ( v21 | v20 )
    Scr_ParamError(COM_ERR_4096, scrContext, 0, "Scale must be greater than 0");
  v21 = 0;
  if ( _ESI <= 0 )
    Scr_ParamError(COM_ERR_4097, scrContext, 1u, "duration must be greater than 0");
  __asm { vcomiss xmm6, xmm7 }
  if ( v21 )
    Scr_ParamError(COM_ERR_4098, scrContext, 3u, "Radius must be greater than 0");
  v22 = DVARBOOL_g_earthquakeEnable;
  if ( !DVARBOOL_g_earthquakeEnable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "g_earthquakeEnable") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v22);
  if ( v22->current.enabled )
  {
    _RBX = G_Utils_SpawnEventEntity(&vectorValue, 134);
    _RBX->s.eventParm = 0;
    _RBX->s.eventParm2 = 0;
    _RBX->s.lerp.u.anonymous.data[2] = _ESI;
    __asm
    {
      vmovss  dword ptr [rbx+58h], xmm8
      vmovss  dword ptr [rbx+5Ch], xmm6
    }
    if ( (v8 & 0x80000000) != 0i64 )
    {
      *(_QWORD *)_RBX->clientMask.array = 0i64;
      *(_QWORD *)&_RBX->clientMask.array[2] = 0i64;
      *(_QWORD *)&_RBX->clientMask.array[4] = 0i64;
      _RBX->clientMask.array[6] = 0;
    }
    else
    {
      *(_QWORD *)_RBX->clientMask.array = -1i64;
      *(_QWORD *)&_RBX->clientMask.array[2] = -1i64;
      *(_QWORD *)&_RBX->clientMask.array[4] = -1i64;
      _RBX->clientMask.array[6] = -1;
      if ( (unsigned int)v8 >= 0xE0 )
      {
        v29 = 224;
        v28 = v8;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 290, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v28, v29) )
          __debugbreak();
      }
      _RBX->clientMask.array[v8 >> 5] &= ~(0x80000000 >> (v8 & 0x1F));
    }
  }
  _R11 = &v31;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
  }
}

/*
==============
GScr_EntityGetAIScriptedData
==============
*/
actor_s *GScr_EntityGetAIScriptedData(scrContext_t *scrContext, gentity_s *ent)
{
  actor_s *result; 
  ai_scripted_t *AIScriptedData; 

  result = ent->actor;
  if ( !result )
  {
    AIScriptedData = Agent_GetAIScriptedData(ent);
    if ( !AIScriptedData )
      Scr_Error(COM_ERR_3941, scrContext, "Entity is not an actor or a Scripted Agent");
    return (actor_s *)AIScriptedData;
  }
  return result;
}

/*
==============
GScr_EntityGetShootAtPos
==============
*/
void GScr_EntityGetShootAtPos(scrContext_t *scrContext, gentity_s *ent, vec3_t *outShootAtPos)
{
  sentient_s *sentient; 
  gclient_s *client; 
  scr_string_t tag_eye; 

  sentient = ent->sentient;
  _RDI = outShootAtPos;
  if ( !sentient )
  {
    tag_eye = scr_const.tag_eye;
    if ( ent->s.number != level.cachedEntTargetTagMat.entnum || level.time != level.cachedEntTargetTagMat.time || scr_const.tag_eye != level.cachedEntTargetTagMat.name )
    {
      if ( !SV_Game_DObjExists(ent) || !G_Utils_DObjGetWorldTagMatrix(ent, tag_eye, &level.cachedEntTargetTagMat.tagMat) )
      {
        G_Utils_EntityCentroid(ent, _RDI);
        return;
      }
      level.cachedEntTargetTagMat.entnum = ent->s.number;
      level.cachedEntTargetTagMat.time = level.time;
      Scr_SetString(&level.cachedEntTargetTagMat.name, tag_eye);
    }
    __asm
    {
      vmovss  xmm0, dword ptr cs:?level@@3Ulevel_locals_t@@A.cachedEntTargetTagMat.tagMat+24h; level_locals_t level
      vmovss  dword ptr [rdi], xmm0
      vmovss  xmm1, dword ptr cs:?level@@3Ulevel_locals_t@@A.cachedEntTargetTagMat.tagMat+28h; level_locals_t level
      vmovss  dword ptr [rdi+4], xmm1
      vmovss  xmm0, dword ptr cs:?level@@3Ulevel_locals_t@@A.cachedEntTargetTagMat.tagMat+2Ch; level_locals_t level
      vmovss  dword ptr [rdi+8], xmm0
    }
    return;
  }
  client = ent->client;
  if ( client && client->sess.sessionState )
  {
    Com_PrintWarning(23, "GetShootAtPos() called while not in SESS_STATE_PLAYING");
    G_Utils_EntityCentroid(ent, _RDI);
  }
  else
  {
    Sentient_GetEyePosition(sentient, outShootAtPos);
  }
}

/*
==============
GScr_ExecEntThread
==============
*/
unsigned int GScr_ExecEntThread(const gentity_s *ent, int handle, unsigned int paramcount)
{
  return GScr_ExecEntThreadWithReturnValue(ent, handle, paramcount, NULL, NULL, NULL);
}

/*
==============
GScr_ExecEntThreadWithReturnValue
==============
*/
unsigned int GScr_ExecEntThreadWithReturnValue(const gentity_s *ent, int handle, unsigned int paramcount, void (*callback)(scrContext_t *, const void *, void *), const void *cbUserData, void *outReturnValue)
{
  signed __int64 v10; 
  signed __int64 v11; 
  __int64 number; 
  scrContext_t *v13; 
  __int64 paramcounta; 
  void (__fastcall *callbacka)(scrContext_t *, const void *, void *); 

  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 875, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 196, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
    __debugbreak();
  v10 = ent - g_entities;
  if ( (unsigned int)v10 >= 0x800 )
  {
    LODWORD(paramcounta) = ent - g_entities;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 199, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( ( 2048 ) )", "index doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", paramcounta, 2048) )
      __debugbreak();
  }
  if ( ent->s.number != (_WORD)v10 )
  {
    if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 196, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
      __debugbreak();
    v11 = ent - g_entities;
    if ( (unsigned int)v11 >= 0x800 )
    {
      LODWORD(callbacka) = 2048;
      LODWORD(paramcounta) = ent - g_entities;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 199, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( ( 2048 ) )", "index doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", paramcounta, callbacka) )
        __debugbreak();
    }
    LODWORD(callbacka) = (__int16)v11;
    LODWORD(paramcounta) = ent->s.number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 876, ASSERT_TYPE_ASSERT, "( ent->s.number ) == ( G_GetEntityIndex( ent ) )", "ent->s.number == G_GetEntityIndex( ent )\n\t%i, %i", paramcounta, callbacka) )
      __debugbreak();
  }
  number = ent->s.number;
  if ( (unsigned int)number >= 0x800 )
  {
    LODWORD(callbacka) = 2048;
    LODWORD(paramcounta) = ent->s.number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", paramcounta, callbacka) )
      __debugbreak();
  }
  if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
    __debugbreak();
  if ( g_entities[number].r.isInUse != g_entityIsInUse[number] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
    __debugbreak();
  if ( !g_entityIsInUse[number] )
  {
    LODWORD(callbacka) = ent->s.number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 877, ASSERT_TYPE_ASSERT, "( ( G_IsEntityInUse( ent->s.number ) ) )", "%s\n\t( ent->s.number ) = %i", "( G_IsEntityInUse( ent->s.number ) )", callbacka) )
      __debugbreak();
  }
  if ( Sys_IsServerUserMoveWorker() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 878, ASSERT_TYPE_ASSERT, "(!Sys_IsServerUserMoveWorker())", "%s\n\tShouldn't process script from server worker threads", "!Sys_IsServerUserMoveWorker()") )
    __debugbreak();
  v13 = ScriptContext_Server();
  return Scr_ExecEntThreadNumWithReturnValue(v13, LOCAL_CLIENT_0, ent->s.number, ENTITY_CLASS_GENTITY, handle, paramcount, callback, cbUserData, outReturnValue);
}

/*
==============
GScr_ExecSpawnerThread
==============
*/
unsigned int GScr_ExecSpawnerThread(const spawner_t *spawner, int handle, unsigned int paramcount)
{
  scrContext_t *v6; 

  if ( !spawner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 893, ASSERT_TYPE_ASSERT, "(spawner)", (const char *)&queryFormat, "spawner") )
    __debugbreak();
  v6 = ScriptContext_Server();
  return Scr_ExecEntThreadNumWithReturnValue(v6, LOCAL_CLIENT_0, spawner->number, ENTITY_CLASS_SPAWNER, handle, paramcount, NULL, NULL, NULL);
}

/*
==============
GScr_FilterPlayerMarks_Internal
==============
*/
void GScr_FilterPlayerMarks_Internal(scrContext_t *scrContext, unsigned int (*entFilterBits)[7])
{
  VariableType Type; 
  EntityMarkFilterType ActiveFilterType; 
  scr_string_t ConstString; 
  const char *String; 
  const char *v8; 
  __int64 v9; 
  __int64 v10; 
  __int64 v11; 
  team_t outTeam; 

  *(_QWORD *)entFilterBits = 0i64;
  *(_QWORD *)&(*entFilterBits)[2] = 0i64;
  *(_QWORD *)&(*entFilterBits)[4] = 0i64;
  (*entFilterBits)[6] = 0;
  if ( !Scr_GetNumParam(scrContext) )
    return;
  Type = Scr_GetType(scrContext, 0);
  if ( Type == VAR_UNDEFINED )
    return;
  if ( Type == VAR_POINTER )
  {
    GScr_FilterPlayerMarks_InternalHandlePointer(scrContext, entFilterBits);
    return;
  }
  if ( Type != VAR_STRING )
  {
    Scr_ParamError(COM_ERR_6100, scrContext, 0, "Invalid mark filter specified. Value is not a team/player or array of teams/players.");
    return;
  }
  ActiveFilterType = G_EntityMarks_GetActiveFilterType();
  if ( ActiveFilterType == Player )
  {
    Scr_ParamError(COM_ERR_6093, scrContext, 0, "Invalid mark player specified. Not a player entity");
    goto LABEL_9;
  }
  if ( ActiveFilterType )
  {
LABEL_9:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31826, ASSERT_TYPE_ASSERT, "( filterType ) == ( EntityMarkFilterType::Team )", "filterType == EntityMarkFilterType::Team\n\t%i, %i", (unsigned __int8)ActiveFilterType, 0i64) )
      __debugbreak();
  }
  ConstString = Scr_GetConstString(scrContext, 0);
  if ( !Com_Teams_TeamFromString(ConstString, &outTeam) )
  {
    String = Scr_GetString(scrContext, 0);
    v8 = j_va("Invalid mark team specified: %s.", String);
    Scr_ParamError(COM_ERR_6094, scrContext, 0, v8);
  }
  v9 = outTeam;
  if ( (unsigned int)(outTeam >> 5) >= TEAM_SEVEN )
  {
    LODWORD(v11) = 7;
    LODWORD(v10) = outTeam >> 5;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31834, ASSERT_TYPE_ASSERT, "(unsigned)( filterTeam >> 5 ) < (unsigned)( ( sizeof( *array_counter( entFilterBits ) ) + 0 ) )", "filterTeam >> 5 doesn't index ARRAY_COUNT( entFilterBits )\n\t%i not in [0, %i)", v10, v11) )
      __debugbreak();
  }
  (*entFilterBits)[v9 >> 5] |= 0x80000000 >> (v9 & 0x1F);
}

/*
==============
GScr_FilterPlayerMarks_InternalHandlePointer
==============
*/
void GScr_FilterPlayerMarks_InternalHandlePointer(scrContext_t *scrContext, unsigned int (*entFilterBits)[7])
{
  EntityMarkFilterType ActiveFilterType; 
  EntityMarkFilterType v5; 
  VariableType PointerType; 
  unsigned int ArrayObject; 
  unsigned int i; 
  VariableUnion *VariableValueAddress; 
  scr_entref_t EntityIdRef; 
  scr_string_t *v11; 
  const char *String; 
  const char *v13; 
  scr_entref_t EntityRef; 
  team_t outTeam; 

  ActiveFilterType = G_EntityMarks_GetActiveFilterType();
  v5 = ActiveFilterType;
  if ( (unsigned __int8)ActiveFilterType >= 2u && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31842, ASSERT_TYPE_ASSERT, "( ( filterType == EntityMarkFilterType::Player || filterType == EntityMarkFilterType::Team ) )", "%s\n\t( static_cast<int>( filterType ) ) = %i", "( filterType == EntityMarkFilterType::Player || filterType == EntityMarkFilterType::Team )", (unsigned __int8)ActiveFilterType) )
    __debugbreak();
  PointerType = Scr_GetPointerType(scrContext, 0);
  if ( PointerType == VAR_ENTITY )
  {
    if ( v5 == Player )
    {
      EntityRef = Scr_GetEntityRef(scrContext, 0);
      GSCr_FilterPlayerMarks_AddEntRefInternal(scrContext, EntityRef, entFilterBits);
    }
    else
    {
      Scr_ParamError(COM_ERR_6098, scrContext, 0, "Invalid mark filter specified. Can't provide player entities when in team-filtering mode");
    }
  }
  else if ( PointerType == VAR_ARRAY )
  {
    ArrayObject = BGScr_Main_GetArrayObject(scrContext, 0);
    for ( i = FindFirstSibling(scrContext, ArrayObject); i; i = FindNextSibling(scrContext, i) )
    {
      if ( v5 == Player )
      {
        VariableValueAddress = GetVariableValueAddress(scrContext, i);
        if ( GetObjectType(scrContext, VariableValueAddress->intValue) != VAR_ENTITY )
          Scr_ParamError(COM_ERR_6095, scrContext, 0, "Invalid mark player specified. Array entry is not player entity.");
        EntityIdRef = Scr_GetEntityIdRef(scrContext, VariableValueAddress->intValue);
        GSCr_FilterPlayerMarks_AddEntRefInternal(scrContext, EntityIdRef, entFilterBits);
      }
      else
      {
        if ( GetValueType(scrContext, i) != VAR_STRING )
          Scr_ParamError(COM_ERR_6096, scrContext, 0, "Invalid mark team specified. Array entry is not a string.");
        v11 = (scr_string_t *)GetVariableValueAddress(scrContext, i);
        if ( !Com_Teams_TeamFromString(*v11, &outTeam) )
        {
          String = Scr_GetString(scrContext, 0);
          v13 = j_va("Invalid mark team specified: %s.", String);
          Scr_ParamError(COM_ERR_6097, scrContext, 0, v13);
        }
        (*entFilterBits)[(__int64)(int)outTeam >> 5] |= 0x80000000 >> (outTeam & 0x1F);
      }
    }
  }
  else
  {
    Scr_ParamError(COM_ERR_6099, scrContext, 0, "Invalid parameter array type for filtering");
  }
}

/*
==============
GScr_FreeEntity
==============
*/
void GScr_FreeEntity(gentity_s *ent)
{
  signed __int64 v2; 
  signed __int64 v3; 
  __int64 number; 
  GSave *v5; 
  scrContext_t *v6; 
  __int64 v7; 
  __int64 v8; 

  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 919, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 196, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
    __debugbreak();
  v2 = ent - g_entities;
  if ( (unsigned int)v2 >= 0x800 )
  {
    LODWORD(v7) = ent - g_entities;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 199, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( ( 2048 ) )", "index doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v7, 2048) )
      __debugbreak();
  }
  if ( ent->s.number != (_WORD)v2 )
  {
    if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 196, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
      __debugbreak();
    v3 = ent - g_entities;
    if ( (unsigned int)v3 >= 0x800 )
    {
      LODWORD(v8) = 2048;
      LODWORD(v7) = ((int)ent - (int)g_entities) / 1456;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 199, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( ( 2048 ) )", "index doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v7, v8) )
        __debugbreak();
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 920, ASSERT_TYPE_ASSERT, "( ent->s.number ) == ( G_GetEntityIndex( ent ) )", "%s == %s\n\t%i, %i", "ent->s.number", "G_GetEntityIndex( ent )", ent->s.number, (__int16)v3) )
      __debugbreak();
  }
  number = ent->s.number;
  if ( (unsigned int)number >= 0x800 )
  {
    LODWORD(v8) = 2048;
    LODWORD(v7) = ent->s.number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v7, v8) )
      __debugbreak();
  }
  if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
    __debugbreak();
  if ( g_entities[number].r.isInUse != g_entityIsInUse[number] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
    __debugbreak();
  if ( !g_entityIsInUse[number] )
  {
    LODWORD(v7) = ent->s.number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 921, ASSERT_TYPE_ASSERT, "( ( G_IsEntityInUse( ent->s.number ) ) )", "( ent->s.number ) = %i", v7) )
      __debugbreak();
  }
  if ( !GSave::ms_gSave && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_save.h", 71, ASSERT_TYPE_ASSERT, "( ms_gSave )", (const char *)&queryFormat, "ms_gSave") )
    __debugbreak();
  v5 = GSave::ms_gSave;
  if ( ent->client )
    ((void (__fastcall *)(GSave *))GSave::ms_gSave->ScrFreeClientFields)(GSave::ms_gSave);
  v5->ScrFreeEntityFields(v5, ent);
  v6 = ScriptContext_Server();
  Scr_FreeEntityNum(v6, ent->s.number, ENTITY_CLASS_GENTITY);
}

/*
==============
GScr_FreeScripts
==============
*/
void GScr_FreeScripts(void)
{
  scrContext_t *v0; 
  int i; 

  v0 = ScriptContext_Server();
  for ( i = 0; i < 11; ++i )
    Scr_RemoveClassMap(v0, (EntityClass)i);
}

/*
==============
GScr_GetEntity
==============
*/
gentity_s *GScr_GetEntity(unsigned int index)
{
  scrContext_t *v2; 
  scr_entref_t EntityRef; 

  v2 = ScriptContext_Server();
  EntityRef = Scr_GetEntityRef(v2, index);
  if ( EntityRef.entclass )
  {
    Scr_ParamError(COM_ERR_3942, v2, index, "not an entity");
    return 0i64;
  }
  else
  {
    if ( EntityRef.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 964, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    return &g_entities[EntityRef.entnum];
  }
}

/*
==============
GScr_GetEntityAllowNull
==============
*/
gentity_s *GScr_GetEntityAllowNull(unsigned int index)
{
  scrContext_t *v2; 
  scr_entref_t EntityRef; 

  v2 = ScriptContext_Server();
  if ( Scr_GetType(v2, index) == VAR_UNDEFINED )
    return 0i64;
  EntityRef = Scr_GetEntityRef(v2, index);
  if ( EntityRef.entclass )
    return 0i64;
  if ( EntityRef.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 985, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  return &g_entities[EntityRef.entnum];
}

/*
==============
GScr_GetFunction
==============
*/
__int64 GScr_GetFunction(const char **pName, BuiltinType *type)
{
  if ( !GScript::ms_gScriptSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.h", 183, ASSERT_TYPE_ASSERT, "( ms_gScriptSystem )", (const char *)&queryFormat, "ms_gScriptSystem") )
    __debugbreak();
  return ((__int64 (__fastcall *)(GScript *, const char **, BuiltinType *))GScript::ms_gScriptSystem->GetFunction)(GScript::ms_gScriptSystem, pName, type);
}

/*
==============
GScr_GetMethod
==============
*/
__int64 GScr_GetMethod(const char **pName, BuiltinType *type)
{
  if ( !GScript::ms_gScriptSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.h", 183, ASSERT_TYPE_ASSERT, "( ms_gScriptSystem )", (const char *)&queryFormat, "ms_gScriptSystem") )
    __debugbreak();
  return ((__int64 (__fastcall *)(GScript *, const char **, BuiltinType *))GScript::ms_gScriptSystem->GetMethod)(GScript::ms_gScriptSystem, pName, type);
}

/*
==============
GScr_GetStandaloneScriptableIndex
==============
*/
__int64 GScr_GetStandaloneScriptableIndex(scrContext_t *scrContext, const scr_entref_t *entref)
{
  unsigned int entnum; 

  if ( entref->entclass != ENTITY_CLASS_SCRIPTABLE )
    Scr_ObjectError(COM_ERR_4683, scrContext, "Must be called on objects of class 'Scriptable'");
  ScriptableCommon_AssertCountsInitialized();
  entnum = entref->entnum;
  if ( entref->entnum >= g_scriptableWorldCounts.runtimeInstanceCount )
  {
    Scr_ObjectError(COM_ERR_4684, scrContext, "Must be called on a standalone dynamic scriptable");
    entnum = entref->entnum;
  }
  if ( ScriptableSv_GetInstanceCommonContext(entnum)->linkedObjectType == SCRIPTABLE_LINK_ENTITY )
    Scr_ObjectError(COM_ERR_4685, scrContext, "Must be called on a standalone (non-entity) scriptable");
  return entnum;
}

/*
==============
GScr_LoadLevel
==============
*/
void GScr_LoadLevel(void)
{
  GameScriptData *v0; 
  scrContext_t *v1; 
  unsigned int v2; 

  if ( !GameScriptData::ms_gScriptData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_data.h", 78, ASSERT_TYPE_ASSERT, "(ms_gScriptData)", "%s\n\tAttempting to access game data outside of an active game context", "ms_gScriptData") )
    __debugbreak();
  if ( !(_BYTE)GameScriptData::ms_allocatedType && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_data.h", 79, ASSERT_TYPE_ASSERT, "(ms_allocatedType != GameModeType::NONE)", "%s\n\tAttempting to access game data outside of an active game context", "ms_allocatedType != GameModeType::NONE") )
    __debugbreak();
  v0 = GameScriptData::ms_gScriptData;
  if ( GameScriptData::ms_gScriptData->levelscript )
  {
    v1 = ScriptContext_Server();
    v2 = Scr_ExecThread(v1, v0->levelscript, 0);
    Scr_FreeThread(v1, v2);
  }
}

/*
==============
GScr_Main_ClientmaskSetAllHidden
==============
*/
void GScr_Main_ClientmaskSetAllHidden(gentity_s *ent)
{
  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 8636, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  *(_QWORD *)ent->clientMask.array = -1i64;
  *(_QWORD *)&ent->clientMask.array[2] = -1i64;
  *(_QWORD *)&ent->clientMask.array[4] = -1i64;
  ent->clientMask.array[6] = -1;
}

/*
==============
GScr_Main_ClientmaskSetAllVisible
==============
*/
void GScr_Main_ClientmaskSetAllVisible(gentity_s *ent)
{
  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 8628, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  *(_QWORD *)ent->clientMask.array = 0i64;
  *(_QWORD *)&ent->clientMask.array[2] = 0i64;
  *(_QWORD *)&ent->clientMask.array[4] = 0i64;
  ent->clientMask.array[6] = 0;
}

/*
==============
GScr_Main_ClientmaskSetFlagVisible
==============
*/
void GScr_Main_ClientmaskSetFlagVisible(gentity_s *ent, unsigned int clientNum)
{
  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 8644, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( clientNum >= level.maxclients && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 8645, ASSERT_TYPE_ASSERT, "( clientNum < static_cast<uint>(level.maxclients) )", (const char *)&queryFormat, "clientNum < static_cast<uint>(level.maxclients)") )
    __debugbreak();
  bitarray_base<bitarray<224>>::resetBit(&ent->clientMask, clientNum);
}

/*
==============
GScr_Main_DeleteCommon
==============
*/
void GScr_Main_DeleteCommon(scrContext_t *scrContext, gentity_s *ent)
{
  __int64 number; 
  const char *v5; 
  unsigned int ScriptableIndexForEntity; 

  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 11640, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( ent->client )
    Scr_Error(COM_ERR_4246, scrContext, "Cannot delete a client entity");
  if ( ent->agent )
    Scr_Error(COM_ERR_4247, scrContext, "Cannot delete an agent entity");
  number = (unsigned int)ent->s.number;
  if ( level.currentEntityThink == (_DWORD)number )
  {
    v5 = j_va("Cannot delete entity '%i' during its think", number);
    Scr_Error(COM_ERR_4248, scrContext, v5);
  }
  if ( GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&ent->s.lerp.eFlags, GameModeFlagValues::ms_mpValue, 0x1Eu) )
    Scr_Error(COM_ERR_4249, scrContext, "Cannot delete a 'willNeverChange' entity");
  ScriptableIndexForEntity = ScriptableSv_GetScriptableIndexForEntity(ent);
  if ( ScriptableIndexForEntity != -1 )
  {
    ScriptableCommon_AssertCountsInitialized();
    if ( ScriptableIndexForEntity >= g_scriptableWorldCounts.runtimeInstanceCount )
    {
      ScriptableSv_VerifyScriptableMoverEntity(ent);
      Scr_Error(COM_ERR_4250, scrContext, "Cannot delete a radiant placed scriptable");
    }
  }
  GScr_Notify(ent, scr_const.death, 0);
  GScr_Notify(ent, scr_const.death_or_disconnect, 0);
  G_FreeEntity(ent);
}

/*
==============
GScr_Main_DisableAimAssistCommon
==============
*/
void GScr_Main_DisableAimAssistCommon(gentity_s *ent)
{
  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 6255, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(&ent->s.lerp.eFlags, ACTIVE, 8u);
}

/*
==============
GScr_Main_EnableAimAssistCommon
==============
*/
void GScr_Main_EnableAimAssistCommon(gentity_s *ent)
{
  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 6238, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(&ent->s.lerp.eFlags, ACTIVE, 8u);
}

/*
==============
GScr_Main_FillWeaponArray
==============
*/
__int64 GScr_Main_FillWeaponArray(scrContext_t *scrContext, Weapon *outWeapons, const unsigned int weaponIndexCount)
{
  unsigned int ArrayObject; 
  unsigned int ArraySize; 
  unsigned int v8; 
  const char *v9; 
  unsigned int i; 
  unsigned int ArrayVariable; 
  VariableType ValueType; 
  scr_string_t *VariableValueAddress; 
  const char *v14; 
  bool IsAlternate; 
  VariableUnion *v20; 
  scr_entref_t EntityIdRef; 
  signed int entnum; 
  int v32; 
  Weapon result; 
  Weapon r_weapon; 

  _RSI = outWeapons;
  if ( !outWeapons && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 403, ASSERT_TYPE_ASSERT, "( outWeapons )", (const char *)&queryFormat, "outWeapons") )
    __debugbreak();
  ArrayObject = BGScr_Main_GetArrayObject(scrContext, 0);
  ArraySize = GetArraySize(scrContext, ArrayObject);
  v8 = ArraySize;
  if ( ArraySize > weaponIndexCount )
  {
    v9 = j_va("Too many weapons requested. Requested %d weapons but only %d are supported for this call.", ArraySize, weaponIndexCount);
    Scr_Error(COM_ERR_3932, scrContext, v9);
  }
  for ( i = 0; i < v8; ++_RSI )
  {
    ArrayVariable = GetArrayVariable(scrContext, ArrayObject, i);
    ValueType = GetValueType(scrContext, ArrayVariable);
    if ( ValueType == VAR_STRING )
    {
      VariableValueAddress = (scr_string_t *)GetVariableValueAddress(scrContext, ArrayVariable);
      v14 = SL_ConvertToString(*VariableValueAddress);
      if ( !v14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 366, ASSERT_TYPE_ASSERT, "(weaponName)", (const char *)&queryFormat, "weaponName") )
        __debugbreak();
      _RAX = GScr_Main_GetWeaponForName(&result, scrContext, v14);
      __asm
      {
        vmovups ymm0, ymmword ptr [rax]
        vmovups ymmword ptr [rsp+0F8h+r_weapon.weaponIdx], ymm0
        vmovups xmm1, xmmword ptr [rax+20h]
        vmovups xmmword ptr [rsp+0F8h+r_weapon.attachmentVariationIndices+5], xmm1
        vmovsd  xmm0, qword ptr [rax+30h]
        vmovsd  qword ptr [rsp+0F8h+r_weapon.attachmentVariationIndices+15h], xmm0
      }
      *(_DWORD *)&r_weapon.weaponCamo = *(_DWORD *)&_RAX->weaponCamo;
      IsAlternate = BG_IsAlternate(v14);
      Scr_VerifyWeapon(scrContext, &r_weapon, IsAlternate, v14);
    }
    else if ( ValueType == VAR_POINTER && (v20 = GetVariableValueAddress(scrContext, ArrayVariable), GetObjectType(scrContext, v20->intValue) == VAR_ENTITY) && (EntityIdRef = Scr_GetEntityIdRef(scrContext, v20->intValue), entnum = EntityIdRef.entnum, EntityIdRef.entclass == ENTITY_CLASS_SAVED_COUNT) )
    {
      _RAX = GScr_Weapon_GetWeapon(scrContext, (const scr_weapon_t)EntityIdRef.entnum);
      __asm
      {
        vmovups ymm0, ymmword ptr [rax]
        vmovups ymmword ptr [rsp+0F8h+r_weapon.weaponIdx], ymm0
        vmovups xmm1, xmmword ptr [rax+20h]
        vmovups xmmword ptr [rsp+0F8h+r_weapon.attachmentVariationIndices+5], xmm1
        vmovsd  xmm0, qword ptr [rax+30h]
        vmovsd  qword ptr [rsp+0F8h+r_weapon.attachmentVariationIndices+15h], xmm0
      }
      *(_DWORD *)&r_weapon.weaponCamo = *(_DWORD *)&_RAX->weaponCamo;
      GScr_Weapon_IsAlternate(scrContext, (const scr_weapon_t)entnum);
    }
    else
    {
      __asm
      {
        vmovups ymm0, ymmword ptr cs:?NULL_WEAPON@@3UWeapon@@B.weaponIdx; Weapon const NULL_WEAPON
        vmovups xmm1, xmmword ptr cs:?NULL_WEAPON@@3UWeapon@@B.attachmentVariationIndices+5; Weapon const NULL_WEAPON
        vmovups ymmword ptr [rsp+0F8h+r_weapon.weaponIdx], ymm0
        vmovsd  xmm0, qword ptr cs:?NULL_WEAPON@@3UWeapon@@B.attachmentVariationIndices+15h; Weapon const NULL_WEAPON
      }
      *(_DWORD *)&r_weapon.weaponCamo = *(_DWORD *)&NULL_WEAPON.weaponCamo;
      __asm
      {
        vmovsd  qword ptr [rsp+0F8h+r_weapon.attachmentVariationIndices+15h], xmm0
        vmovups xmmword ptr [rsp+0F8h+r_weapon.attachmentVariationIndices+5], xmm1
      }
      Scr_ParamError(COM_ERR_3933, scrContext, i, "All weapons in the array need to be weapon strings or weapon objects.");
    }
    __asm
    {
      vmovups ymm0, ymmword ptr [rsp+0F8h+r_weapon.weaponIdx]
      vmovups xmm1, xmmword ptr [rsp+0F8h+r_weapon.attachmentVariationIndices+5]
    }
    v32 = *(_DWORD *)&r_weapon.weaponCamo;
    ++i;
    __asm
    {
      vmovups ymmword ptr [rsi], ymm0
      vmovsd  xmm0, qword ptr [rsp+0F8h+r_weapon.attachmentVariationIndices+15h]
      vmovups xmmword ptr [rsi+20h], xmm1
      vmovsd  qword ptr [rsi+30h], xmm0
    }
    *(_DWORD *)&_RSI->weaponCamo = v32;
  }
  return v8;
}

/*
==============
GScr_Main_GetAudioTriggerPriorityIndex
==============
*/
__int64 GScr_Main_GetAudioTriggerPriorityIndex(const char *name)
{
  const char **v2; 
  unsigned int i; 
  const char *v4; 
  __int64 v5; 
  const char *v6; 
  signed __int64 v7; 
  int v8; 
  __int64 v9; 
  int v10; 
  int v11; 
  int v12; 

  v2 = s_audioTriggerOverrideTypeNames;
  for ( i = 0; i < 7; ++i )
  {
    v4 = *v2;
    v5 = 0x7FFFFFFFi64;
    v6 = name;
    if ( !*v2 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
      __debugbreak();
    if ( !name && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 213, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
      __debugbreak();
    v7 = v4 - name;
    while ( 1 )
    {
      v8 = (unsigned __int8)v6[v7];
      v9 = v5;
      v10 = *(unsigned __int8 *)v6++;
      --v5;
      if ( !v9 )
        return i;
      if ( v8 != v10 )
      {
        v11 = v8 + 32;
        if ( (unsigned int)(v8 - 65) > 0x19 )
          v11 = v8;
        v8 = v11;
        v12 = v10 + 32;
        if ( (unsigned int)(v10 - 65) > 0x19 )
          v12 = v10;
        if ( v8 != v12 )
          break;
      }
      if ( !v8 )
        return i;
    }
    ++v2;
  }
  return 0xFFFFFFFFi64;
}

/*
==============
GScr_Main_GetDDL
==============
*/
void GScr_Main_GetDDL(scrContext_t *scrContext, DDLState *state, const DDLDef *def, const DDLContext *context, const char *callingFunction, int firstArgIndex)
{
  unsigned int NumParam; 
  int Int; 
  int v12; 
  int v14; 
  int v15; 
  int v16; 
  const char *EnumString; 
  const char *String; 
  int BitSize; 
  int Type; 
  const char *stringPtr; 
  bool Bool; 
  int v23; 
  unsigned __int16 Short; 
  unsigned __int8 Byte; 
  const char *Enum; 
  int v29; 
  __int64 v30; 
  __int64 v31; 
  int finalArgumentIndex[2]; 

  finalArgumentIndex[0] = -1;
  GScr_Main_NavigateDDL(scrContext, def, callingFunction, state, firstArgIndex, finalArgumentIndex);
  NumParam = Scr_GetNumParam(scrContext);
  if ( finalArgumentIndex[0] == NumParam )
  {
    if ( state->member )
    {
      if ( Com_GameMode_SupportsFeature(WEAPON_RELOAD_END|0x80) && g_archiveGetDvar && SV_IsDemoPlaying() )
      {
        Int = SV_Demo_GetInt();
        v12 = SV_Demo_GetInt();
        if ( SV_IsDemoPlaying() )
        {
          switch ( Int )
          {
            case 0:
            case 1:
            case 3:
              goto LABEL_14;
            case 2:
              if ( v12 == 1 )
              {
                v14 = SV_Demo_GetInt();
                Scr_AddBool(scrContext, v14 != 0);
              }
              else
              {
LABEL_14:
                v15 = SV_Demo_GetInt();
                Scr_AddInt(scrContext, v15);
              }
              break;
            case 6:
              *(double *)&_XMM0 = SV_Demo_GetFloat();
              __asm { vmovaps xmm1, xmm0; value }
              Scr_AddFloat(scrContext, *(float *)&_XMM1);
              break;
            case 10:
              v16 = SV_Demo_GetInt();
              EnumString = DDL::DDL_Lookup_GetEnumString(state, v16);
              Scr_AddString(scrContext, EnumString);
              break;
            default:
              if ( Int != 8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 693, ASSERT_TYPE_ASSERT, "( resultType ) == ( DDL_STRING_TYPE )", "%s == %s\n\t%i, %i", "resultType", "DDL_STRING_TYPE", Int, 8) )
                __debugbreak();
              String = SV_Demo_GetString();
              Scr_AddString(scrContext, String);
              break;
          }
        }
        else
        {
          Scr_AddInt(scrContext, 0);
        }
      }
      else
      {
        BitSize = DDL_StateGetBitSize(state);
        Type = DDL_GetType(state);
        stringPtr = DDL_GetValue(state, context).stringPtr;
        switch ( Type )
        {
          case 0:
            Byte = DDL_GetByte(state, context);
            Scr_AddInt(scrContext, Byte);
            break;
          case 1:
            Short = DDL_GetShort(state, context);
            Scr_AddInt(scrContext, Short);
            break;
          case 2:
            if ( BitSize != 1 )
              goto $LN11_54;
            Bool = DDL_GetBool(state, context);
            Scr_AddBool(scrContext, Bool);
            break;
          case 3:
$LN11_54:
            v23 = DDL_GetInt(state, context);
            Scr_AddInt(scrContext, v23);
            break;
          case 6:
            *(double *)&_XMM0 = DDL_GetFloat(state, context);
            __asm { vmovaps xmm1, xmm0; value }
            Scr_AddFloat(scrContext, *(float *)&_XMM1);
            break;
          case 10:
            Enum = DDL_GetEnum(state, context);
            goto LABEL_32;
          default:
            if ( Type != 8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 816, ASSERT_TYPE_ASSERT, "( resultType ) == ( DDL_STRING_TYPE )", "%s == %s\n\t%i, %i", "resultType", "DDL_STRING_TYPE", Type, 8) )
              __debugbreak();
            Enum = DDL_GetString(state, context);
LABEL_32:
            Scr_AddString(scrContext, Enum);
            break;
        }
        *(_QWORD *)finalArgumentIndex = stringPtr;
        if ( Com_GameMode_SupportsFeature(WEAPON_RELOAD_END|0x80) && g_archiveGetDvar && !SV_IsDemoPlaying() )
        {
          SV_Record_GetInt(Type);
          SV_Record_GetInt(BitSize);
          switch ( Type )
          {
            case 0:
            case 1:
            case 3:
              goto LABEL_39;
            case 2:
              if ( BitSize == 1 )
                goto LABEL_40;
LABEL_39:
              SV_Record_GetInt((int)stringPtr);
              break;
            case 6:
              __asm { vmovss  xmm0, [rsp+88h+var_38]; jumptable 000000014131B8A9 case 6 }
              SV_Record_GetFloat(*(float *)&_XMM0);
              return;
            case 10:
LABEL_40:
              v29 = truncate_cast<int,unsigned int>((unsigned int)stringPtr);
              SV_Record_GetInt(v29);
              break;
            default:
              if ( Type != 8 )
              {
                LODWORD(v31) = 8;
                LODWORD(v30) = Type;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 744, ASSERT_TYPE_ASSERT, "( resultType ) == ( DDL_STRING_TYPE )", "%s == %s\n\t%i, %i", "resultType", "DDL_STRING_TYPE", v30, v31) )
                  __debugbreak();
              }
              SV_Record_GetString(stringPtr);
              break;
          }
        }
      }
    }
    else
    {
      GScr_Main_StructuredDataPrintArgs(scrContext, callingFunction);
      Scr_Error(COM_ERR_3940, scrContext, "DDL navigation failed at root.");
    }
  }
  else
  {
    GScr_Main_StructuredDataPrintArgs(scrContext, callingFunction);
    Scr_Error(COM_ERR_3939, scrContext, "Too many arguments. See log.");
  }
}

/*
==============
GScr_Main_GetPlayerEntity
==============
*/
gentity_s *GScr_Main_GetPlayerEntity(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v16; 
  char *fmt; 

  entnum = entref.entnum;
  _RDI = GetEntity(entref);
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 1061, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !_RDI->client )
  {
    targetname = _RDI->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(_RDI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rdi+134h]
      vmovss  xmm2, dword ptr [rdi+130h]
      vmovss  xmm0, dword ptr [rdi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+48h+fmt], xmm0
    }
    v16 = j_va("Only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, fmt, v7, v6);
    Scr_Error(COM_ERR_3944, scrContext, v16);
  }
  return _RDI;
}

/*
==============
GScr_Main_GetWeaponForName
==============
*/
Weapon *GScr_Main_GetWeaponForName(Weapon *result, scrContext_t *scrContext, const char *weaponName)
{
  const dvar_t *v6; 
  const char *v7; 

  if ( !BG_Weapons_GetFullWeaponForName(weaponName, result, BG_FindBaseWeaponForName) )
  {
    v6 = DCONST_DVARBOOL_g_weaponEnforceNames;
    if ( !DCONST_DVARBOOL_g_weaponEnforceNames && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "g_weaponEnforceNames") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v6);
    if ( v6->current.enabled )
    {
      v7 = j_va("Invalid weapon name (%s) specified. See console log for details.", weaponName);
      Scr_Error(COM_ERR_3928, scrContext, v7);
    }
  }
  return result;
}

/*
==============
GScr_Main_GetWeaponParam
==============
*/
void GScr_Main_GetWeaponParam(scrContext_t *scrContext, const unsigned int index, Weapon *outWeapon, bool *outIsAlternate)
{
  const char *String; 
  const char *v9; 
  scr_entref_t EntityRef; 
  bool IsAlternate; 
  const char *v16; 
  scr_entref_t v21; 
  char v22[512]; 
  char output[1024]; 
  char dest[1024]; 

  _RDI = outWeapon;
  if ( Scr_GetType(scrContext, index) == VAR_STRING )
  {
    String = Scr_GetString(scrContext, index);
    *outIsAlternate = BG_IsAlternate(String);
    if ( !BG_Weapons_GetFullWeaponForName(String, _RDI, BG_FindBaseWeaponForName) )
    {
      v9 = j_va("Invalid weapon name (%s) specified. See console log for details.", String);
      Scr_ParamError(COM_ERR_3929, scrContext, index, v9);
    }
    Scr_VerifyWeapon(scrContext, _RDI, *outIsAlternate, String);
    return;
  }
  if ( Scr_GetType(scrContext, index) != VAR_POINTER || Scr_GetPointerType(scrContext, index) != VAR_ENTITY )
  {
LABEL_14:
    Scr_ParamError(COM_ERR_3930, scrContext, index, "Invalid weapon parameter specified. Weapon must be a weapon string, weapon object or weapon item entity. ");
    return;
  }
  EntityRef = Scr_GetEntityRef(scrContext, index);
  v21 = EntityRef;
  if ( EntityRef.entclass != ENTITY_CLASS_SAVED_COUNT )
  {
    if ( EntityRef.entclass == ENTITY_CLASS_GENTITY )
    {
      _RAX = GetEntity(EntityRef);
      if ( _RAX->s.eType == ET_ITEM )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rax+1CCh]
          vmovups ymmword ptr [rdi], ymm0
          vmovups xmm1, xmmword ptr [rax+1ECh]
          vmovups xmmword ptr [rdi+20h], xmm1
          vmovsd  xmm0, qword ptr [rax+1FCh]
          vmovsd  qword ptr [rdi+30h], xmm0
        }
        *(float *)&_RDI->weaponCamo = _RAX->c.mover.angle.pos1.v[2];
        *outIsAlternate = 0;
        return;
      }
    }
    goto LABEL_14;
  }
  _RAX = GScr_Weapon_GetWeapon(scrContext, (const scr_weapon_t)EntityRef.entnum);
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovups ymmword ptr [rdi], ymm0
    vmovups xmm1, xmmword ptr [rax+20h]
    vmovups xmmword ptr [rdi+20h], xmm1
    vmovsd  xmm0, qword ptr [rax+30h]
    vmovsd  qword ptr [rdi+30h], xmm0
  }
  *(_DWORD *)&_RDI->weaponCamo = *(_DWORD *)&_RAX->weaponCamo;
  IsAlternate = GScr_Weapon_IsAlternate(scrContext, (const scr_weapon_t)EntityRef.entnum);
  *outIsAlternate = IsAlternate;
  if ( IsAlternate && !BG_ActiveUnderbarrel(_RDI) )
  {
    BG_GetWeaponNameComplete(_RDI, *outIsAlternate, output, 0x400u);
    v16 = j_va("Weapon must have an 'active underbarrel' attachment if it's in alt mode: %s", output);
    BG_GetWeaponName(_RDI, v22, 0x200u);
    Com_sprintf(dest, 0x400ui64, v16, v22, v21);
    Scr_ParamError(COM_ERR_6290, scrContext, 0, dest);
    *outIsAlternate = 0;
  }
}

/*
==============
GScr_Main_NavigateDDL
==============
*/
void GScr_Main_NavigateDDL(scrContext_t *scrContext, const DDLDef *def, const char *functionName, DDLState *state, int firstArgIndex, int *finalArgumentIndex)
{
  signed int v9; 
  char v10; 
  int Int; 
  unsigned int v12; 
  const char *v13; 
  ComErrorCode v14; 
  scr_string_t ConstString; 
  unsigned int RawHash; 
  const char *String; 

  if ( !def && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 493, ASSERT_TYPE_ASSERT, "(def)", (const char *)&queryFormat, "def") )
    __debugbreak();
  if ( !state && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 494, ASSERT_TYPE_ASSERT, "(state)", (const char *)&queryFormat, "state") )
    __debugbreak();
  if ( !finalArgumentIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 495, ASSERT_TYPE_ASSERT, "(finalArgumentIndex)", (const char *)&queryFormat, "finalArgumentIndex") )
    __debugbreak();
  v9 = firstArgIndex - 1;
  v10 = 1;
  if ( DDL_StateIsLeaf(state) )
    goto LABEL_25;
  while ( 1 )
  {
    ++v9;
    if ( !DDL_StateIsArrayRoot(state) )
      break;
    Int = Scr_GetInt(scrContext, v9);
    v10 &= DDL_MoveToIndex(state, state, Int);
    if ( !v10 )
    {
      if ( v9 < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 515, ASSERT_TYPE_ASSERT, "(argumentIndex >= 0)", (const char *)&queryFormat, "argumentIndex >= 0") )
        __debugbreak();
      GScr_Main_StructuredDataPrintArgs(scrContext, functionName);
      v12 = Scr_GetInt(scrContext, v9);
      v13 = j_va("Failed to navigate into DDL array index %d", v12);
      v14 = COM_ERR_3934;
      goto LABEL_24;
    }
LABEL_18:
    if ( DDL_StateIsLeaf(state) )
      goto LABEL_25;
  }
  ConstString = Scr_GetConstString(scrContext, v9);
  RawHash = j_SL_GetRawHash(ConstString);
  v10 &= DDL_MoveToNameByHash(state, state, RawHash, NULL);
  if ( v10 )
    goto LABEL_18;
  if ( v9 < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 530, ASSERT_TYPE_ASSERT, "(argumentIndex >= 0)", (const char *)&queryFormat, "argumentIndex >= 0") )
    __debugbreak();
  GScr_Main_StructuredDataPrintArgs(scrContext, functionName);
  String = Scr_GetString(scrContext, v9);
  v13 = j_va("Failed to navigate into DDL field %s", String);
  v14 = COM_ERR_3935;
LABEL_24:
  Scr_ParamError(v14, scrContext, v9, v13);
LABEL_25:
  *finalArgumentIndex = v9 + 1;
}

/*
==============
GScr_Main_PlayerLinkTo_Internal
==============
*/
void GScr_Main_PlayerLinkTo_Internal(scrContext_t *scrContext, scr_entref_t entref, PlayerLinkToType linkType)
{
  gentity_s *Entity; 
  gentity_s *v10; 
  int NumParam; 
  scr_string_t ConstLowercaseString; 
  GHandler *Handler; 
  bool v14; 
  bool v15; 
  bool v16; 
  bool v17; 
  bool v18; 
  const dvar_t *v30; 
  int time; 
  GWeaponMap *Instance; 
  GHandler *v33; 
  const char *v34; 
  char outErrorMessage[256]; 

  __asm { vmovaps [rsp+198h+var_48], xmm6 }
  Entity = GetEntity(entref);
  if ( Scr_GetType(scrContext, 0) != VAR_POINTER || Scr_GetPointerType(scrContext, 0) != VAR_ENTITY )
    Scr_ParamError(COM_ERR_4169, scrContext, 0, "not an entity");
  if ( !Entity->client )
    Scr_ObjectError(COM_ERR_4170, scrContext, "not a player entity");
  if ( (Entity->flags.m_flags[0] & 0x200) == 0 )
    Scr_ObjectError(COM_ERR_4171, scrContext, "player does not support linking");
  _RSI = Entity->client;
  v10 = GScr_GetEntity(0);
  NumParam = Scr_GetNumParam(scrContext);
  ConstLowercaseString = 0;
  if ( NumParam > 1 )
  {
    if ( Scr_GetType(scrContext, 1u) )
    {
      ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 1u);
      if ( ConstLowercaseString == scr_const._ )
        ConstLowercaseString = 0;
    }
  }
  if ( !_RSI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2605, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( BG_IsPlayerZeroG(&_RSI->ps) && !BG_IsPlayerZeroGWalking(&_RSI->ps) )
  {
    Handler = GHandler::getHandler();
    BG_NormalizeWorldUpReferenceAngles(&_RSI->ps, Handler);
  }
  GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::ClearFlagInternal(&_RSI->ps.linkFlags, ACTIVE, 6u);
  GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::ClearFlagInternal(&_RSI->ps.linkFlags, GameModeFlagValues::ms_mpValue, 7u);
  if ( linkType == PLAYERLINKTO_DELTA )
  {
    GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::ClearFlagInternal(&_RSI->ps.linkFlags, ACTIVE, 2u);
    v14 = NumParam <= 8 || Scr_GetInt(scrContext, 8u) != 0;
    _RSI->link_rotationMovesEyePos = v14;
    v15 = NumParam > 7 && Scr_GetInt(scrContext, 7u) != 0;
    _RSI->link_useTagAnglesForViewAngles = v15;
    v16 = NumParam <= 9 || Scr_GetInt(scrContext, 9u) != 0;
    _RSI->link_useTagScriptedCamera = v16;
    if ( v16 )
      GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::SetFlagInternal(&_RSI->ps.linkFlags, ACTIVE, 6u);
    _RSI->link_doCollision = 0;
  }
  else if ( linkType == PLAYERLINKTO_DELTA_WEAPONVIEWONLY )
  {
    if ( ConstLowercaseString != scr_const.tag_player )
      Scr_Error(COM_ERR_4172, scrContext, "This function only supports linking to tags named 'tag_player'.");
    _RSI->ps.linkWeaponAngles.v[0] = _RSI->ps.viewangles.v[0];
    _RSI->ps.linkWeaponAngles.v[1] = _RSI->ps.viewangles.v[1];
    _RSI->ps.linkWeaponAngles.v[2] = _RSI->ps.viewangles.v[2];
    GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::SetFlagInternal(&_RSI->ps.linkFlags, ACTIVE, 2u);
    GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::SetFlagInternal(&_RSI->ps.linkFlags, ACTIVE, 3u);
    _RSI->link_rotationMovesEyePos = 0;
    v17 = NumParam > 7 && Scr_GetInt(scrContext, 7u) != 0;
    _RSI->link_useTagAnglesForViewAngles = v17;
    _RSI->link_useTagScriptedCamera = 0;
    _RSI->link_doCollision = 0;
    if ( !SV_Game_IsSplitscreen() || SV_Game_IsOnlineGame() )
      GScr_Main_ClientmaskSetFlagVisible(v10, _RSI->ps.clientNum);
    else
      GScr_Main_ClientmaskSetAllVisible(v10);
  }
  else
  {
    if ( linkType && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 8737, ASSERT_TYPE_ASSERT, "(linkType == PLAYERLINKTO_NORMAL)", (const char *)&queryFormat, "linkType == PLAYERLINKTO_NORMAL") )
      __debugbreak();
    GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::ClearFlagInternal(&_RSI->ps.linkFlags, ACTIVE, 2u);
    _RSI->link_rotationMovesEyePos = 0;
    _RSI->link_useTagAnglesForViewAngles = 1;
    _RSI->link_useTagScriptedCamera = 0;
    v18 = NumParam > 7 && Scr_GetInt(scrContext, 7u) != 0;
    _RSI->link_doCollision = v18;
  }
  _RSI->link_useBaseAnglesForViewClamp = 0;
  if ( NumParam <= 2 )
    __asm { vxorps  xmm0, xmm0, xmm0 }
  else
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
  _RSI->flags &= ~4u;
  __asm
  {
    vmovss  xmm6, cs:__real@43340000
    vmovss  dword ptr [rsi+5EB8h], xmm0
  }
  if ( NumParam <= 3 )
    __asm { vmovaps xmm0, xmm6; val }
  else
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
  __asm
  {
    vmovaps xmm2, xmm6; max
    vxorps  xmm1, xmm1, xmm1; min
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm
  {
    vxorps  xmm0, xmm0, cs:__xmm@80000000800000008000000080000000
    vmovss  dword ptr [rsi+5ED0h], xmm0
  }
  if ( NumParam <= 4 )
    __asm { vmovaps xmm0, xmm6; val }
  else
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 4u);
  __asm
  {
    vmovaps xmm2, xmm6; max
    vxorps  xmm1, xmm1, xmm1; min
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm { vmovss  dword ptr [rsi+5EE8h], xmm0 }
  if ( NumParam <= 5 )
    __asm { vmovaps xmm0, xmm6; val }
  else
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 5u);
  __asm
  {
    vmovaps xmm2, xmm6; max
    vxorps  xmm1, xmm1, xmm1; min
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm
  {
    vxorps  xmm1, xmm0, cs:__xmm@80000000800000008000000080000000
    vmovss  dword ptr [rsi+5ECCh], xmm1
  }
  if ( NumParam <= 6 )
    __asm { vmovaps xmm0, xmm6; val }
  else
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 6u);
  __asm
  {
    vmovaps xmm2, xmm6; max
    vxorps  xmm1, xmm1, xmm1; min
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm { vmovss  dword ptr [rsi+5EE4h], xmm0 }
  if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_FREEFALL_IDLE|WEAPON_OFFHAND_END) )
  {
    _RSI->link_viewClamp.resistMin.goal = 0i64;
    _RSI->link_viewClamp.resistMax.goal = 0i64;
  }
  G_SnapToViewAngleClampGoal(&_RSI->link_viewClamp);
  GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::ClearFlagInternal(&_RSI->ps.linkFlags, ACTIVE, 0);
  GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::ClearFlagInternal(&_RSI->ps.linkFlags, GameModeFlagValues::ms_spValue, 7u);
  GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::ClearFlagInternal(&_RSI->ps.linkFlags, GameModeFlagValues::ms_spValue, 8u);
  _RSI->prevLinkAnglesSet = 0;
  if ( (v10->flags.m_flags[0] & 0x80000) != 0 )
    GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(&_RSI->ps.pm_flags, ACTIVE, 5u);
  if ( G_EntLinkTo(Entity, v10, ConstLowercaseString, 256, outErrorMessage) )
  {
    v30 = DVARBOOL_killswitch_prevent_mantle_while_linked_enabled;
    if ( !DVARBOOL_killswitch_prevent_mantle_while_linked_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_prevent_mantle_while_linked_enabled") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v30);
    if ( v30->current.enabled )
    {
      time = level.time;
      Instance = GWeaponMap::GetInstance();
      v33 = GHandler::getHandler();
      Mantle_CancelMantle(v33, Instance, &_RSI->ps, time);
    }
    if ( linkType == PLAYERLINKTO_DELTA_WEAPONVIEWONLY )
    {
      GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::SetFlagInternal(&_RSI->ps.linkFlags, ACTIVE, 2u);
      GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::SetFlagInternal(&_RSI->ps.linkFlags, ACTIVE, 3u);
    }
    G_InitPlayerLinkAngles(Entity);
  }
  else
  {
    v34 = j_va("failed to link entity %i to entity %i: %s", (unsigned int)Entity->s.number, (unsigned int)v10->s.number, outErrorMessage);
    Scr_Error(COM_ERR_4173, scrContext, v34);
  }
  __asm { vmovaps xmm6, [rsp+198h+var_48] }
}

/*
==============
GScr_Main_PostLoadScriptsCommon
==============
*/
void GScr_Main_PostLoadScriptsCommon(void)
{
  scrContext_t *v0; 

  v0 = ScriptContext_Server();
  GScr_AddFieldsForEntity(v0);
  G_HudElem_ScrAddFieldsForHudElems(v0);
  GScr_AddFieldsForPathnode(v0);
  GScr_Weapon_AddFields(v0);
  G_VehiclePathScr_AddFieldsForNode(v0);
  Scr_AddFieldsForRadiant(v0);
  if ( script_usage_tracking )
  {
    if ( script_usage_tracking->current.integer )
      Scr_InitSourceFuncInfo(v0);
  }
}

/*
==============
GScr_Main_SetDDL
==============
*/
void GScr_Main_SetDDL(scrContext_t *scrContext, DDLState *state, const DDLDef *def, DDLContext *context, const char *callingFunction, int firstArgIndex)
{
  unsigned int v10; 
  unsigned int v11; 
  DDLType Type; 
  int v13; 
  bool v14; 
  unsigned int v15; 
  int v16; 
  unsigned __int16 v18; 
  unsigned __int8 Int; 
  const char *String; 
  const char *v21; 
  const char *v22; 
  const char *v23; 
  unsigned int index[10]; 

  index[0] = -1;
  GScr_Main_NavigateDDL(scrContext, def, callingFunction, state, firstArgIndex, (int *)index);
  v10 = index[0];
  v11 = index[0] + 1;
  if ( v11 <= Scr_GetNumParam(scrContext) )
  {
    if ( v11 >= Scr_GetNumParam(scrContext) )
    {
      Type = DDL_GetType(state);
      switch ( Type )
      {
        case DDL_BYTE_TYPE:
          Int = Scr_GetInt(scrContext, v10);
          v14 = DDL_SetByte(state, context, Int);
          break;
        case DDL_SHORT_TYPE:
          v18 = Scr_GetInt(scrContext, v10);
          v14 = DDL_SetShort(state, context, v18);
          break;
        case DDL_UINT_TYPE:
          if ( DDL_StateGetBitSize(state) == 1 )
          {
            v13 = Scr_GetInt(scrContext, v10);
            v14 = DDL_SetBool(state, context, v13 != 0);
          }
          else
          {
            v15 = Scr_GetInt(scrContext, v10);
            v14 = DDL_SetUInt(state, context, v15);
          }
          break;
        case DDL_INT_TYPE:
          v16 = Scr_GetInt(scrContext, v10);
          v14 = DDL_SetInt(state, context, v16);
          break;
        case DDL_FLOAT_TYPE:
          *(double *)&_XMM0 = Scr_GetFloat(scrContext, v10);
          __asm { vmovaps xmm2, xmm0; val }
          v14 = DDL_SetFloat(state, context, *(float *)&_XMM2);
          break;
        case DDL_STRING_TYPE:
          goto $LN14_57;
        case DDL_ENUM_TYPE:
          String = Scr_GetString(scrContext, v10);
          v14 = DDL_SetEnum(state, context, String);
          break;
        default:
          Com_PrintWarning(28, "attempting to write to ddl type %d as a string?\n", (unsigned int)Type);
$LN14_57:
          v21 = Scr_GetString(scrContext, v10);
          v14 = DDL_SetString(state, context, v21);
          break;
      }
      if ( !v14 )
      {
        GScr_Main_StructuredDataPrintArgs(scrContext, callingFunction);
        v22 = Scr_GetString(scrContext, v10);
        v23 = j_va("%s: \"%s\" %s", callingFunction, v22, "DDL error");
        Scr_ParamError(COM_ERR_3938, scrContext, v10, v23);
      }
    }
    else
    {
      GScr_Main_StructuredDataPrintArgs(scrContext, callingFunction);
      Scr_Error(COM_ERR_3937, scrContext, "Too many arguments. See log.");
    }
  }
  else
  {
    GScr_Main_StructuredDataPrintArgs(scrContext, callingFunction);
    Scr_Error(COM_ERR_3936, scrContext, "Not enough arguments. See log.");
  }
}

/*
==============
GScr_Main_StructuredDataPrintArgs
==============
*/
void GScr_Main_StructuredDataPrintArgs(scrContext_t *scrContext, const char *functionName)
{
  int v4; 
  unsigned int v5; 
  int v6; 
  VariableType Type; 
  const char *TypeName; 
  int v9; 
  unsigned int Int; 
  const char *String; 
  char dest[1024]; 

  v4 = Com_sprintf_truncate(dest, 0x400ui64, "In call to %s( ", functionName);
  if ( v4 >= 0 )
  {
    v5 = 0;
    if ( Scr_GetNumParam(scrContext) )
    {
      while ( 1 )
      {
        if ( v5 )
        {
          v6 = Com_sprintf_truncate(&dest[v4], 1024 - v4, ", ");
          if ( v6 < 0 )
            break;
          v4 += v6;
        }
        Type = Scr_GetType(scrContext, v5);
        switch ( Type )
        {
          case VAR_STRING:
            String = Scr_GetString(scrContext, v5);
            v9 = Com_sprintf_truncate(&dest[v4], 1024 - v4, "\"%s\"", String);
            break;
          case VAR_FLOAT:
            *(double *)&_XMM0 = Scr_GetFloat(scrContext, v5);
            __asm
            {
              vcvtss2sd xmm3, xmm0, xmm0
              vmovq   r9, xmm3
            }
            v9 = Com_sprintf_truncate(&dest[v4], 1024 - v4, "\"%f\"", *(double *)&_XMM3);
            break;
          case VAR_INTEGER:
            Int = Scr_GetInt(scrContext, v5);
            v9 = Com_sprintf_truncate(&dest[v4], 1024 - v4, "\"%i\"", Int);
            break;
          default:
            TypeName = Scr_GetTypeName(scrContext, v5);
            v9 = Com_sprintf_truncate(&dest[v4], 1024 - v4, "[unhandled type %s]", TypeName);
            break;
        }
        if ( v9 < 0 )
          break;
        v4 += v9;
        if ( ++v5 >= Scr_GetNumParam(scrContext) )
          goto LABEL_15;
      }
    }
    else
    {
LABEL_15:
      Com_sprintf(&dest[v4], 1024 - v4, " )\n");
    }
  }
  Com_PrintError(23, (const char *)&queryFormat, dest);
}

/*
==============
GScr_Main_UpdateClassMap
==============
*/
void GScr_Main_UpdateClassMap(void)
{
  scrContext_t *v0; 
  int i; 

  v0 = ScriptContext_Server();
  for ( i = 0; i < 11; ++i )
    Scr_SetClassMap(v0, (EntityClass)i);
}

/*
==============
GScr_Main_ValidateDisconnectPathsEnt
==============
*/
__int64 GScr_Main_ValidateDisconnectPathsEnt(scrContext_t *scrContext, gentity_s *ent)
{
  const char *v5; 
  const char *v6; 

  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 23108, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !Path_IsDynamicBlockingEntity(ent) )
  {
    if ( ent->classname == scr_const.script_brushmodel )
    {
      Scr_Error(COM_ERR_4645, scrContext, "script_brushmodel must have DYNAMICPATH set to disconnect/connect paths");
      return 0i64;
    }
    if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_STILL_LAND|0x80) )
    {
      v5 = SL_ConvertToString(ent->classname);
      v6 = j_va("entity of type '%s' cannot disconnect/connect paths.\n \n ", v5);
      Scr_Error(COM_ERR_4646, scrContext, v6);
      return 0i64;
    }
    ent->flags.m_flags[0] |= 0x40u;
  }
  return 1i64;
}

/*
==============
GScr_Main_WeaponParamError
==============
*/
void GScr_Main_WeaponParamError(ComErrorCode uniqueErrorCode, scrContext_t *scrContext, const unsigned int index, const Weapon *r_weapon, const char *weaponFormatString)
{
  char output[512]; 
  char dest[1024]; 

  BG_GetWeaponName(r_weapon, output, 0x200u);
  Com_sprintf(dest, 0x400ui64, weaponFormatString, output);
  Scr_ParamError(uniqueErrorCode, scrContext, index, dest);
}

/*
==============
GScr_MakeGameMessage
==============
*/
void GScr_MakeGameMessage(scrContext_t *scrContext, __int64 clientNum, const char cmd)
{
  unsigned int v4; 
  const char *v6; 
  GScript *v7; 
  void (__fastcall *ConstructMessageString)(GScript *, scrContext_t *, int, int, const char *, char *, unsigned int); 
  unsigned int NumParam; 
  const char *v10; 
  const char *v11; 
  SvClient *CommonClient; 
  char v13[1024]; 

  v4 = clientNum;
  if ( (int)clientNum < level.maxclients )
  {
    if ( !GScript::ms_gScriptSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.h", 183, ASSERT_TYPE_ASSERT, "( ms_gScriptSystem )", (const char *)&queryFormat, "ms_gScriptSystem") )
      __debugbreak();
    v7 = GScript::ms_gScriptSystem;
    ConstructMessageString = GScript::ms_gScriptSystem->ConstructMessageString;
    NumParam = Scr_GetNumParam(scrContext);
    ConstructMessageString(v7, scrContext, 0, NumParam - 1, "Game Message", v13, 1024u);
    v10 = j_va("%c \"%s\"", (unsigned int)cmd, v13);
    v11 = v10;
    if ( v4 == -1 )
    {
      SV_Game_BroadcastServerCommand(SV_CMD_CAN_IGNORE, v10);
    }
    else
    {
      CommonClient = SvClient::GetCommonClient(v4);
      CommonClient->SendServerCommand(CommonClient, SV_CMD_CAN_IGNORE, v11);
    }
  }
  else
  {
    v6 = j_va("Invalid entity index %d before SV_Game_SendServerCommand\n", clientNum);
    Scr_Error(COM_ERR_6408, scrContext, v6);
  }
}

/*
==============
GScr_Notify
==============
*/
void GScr_Notify(const gentity_s *ent, scr_string_t stringValue, unsigned int paramcount)
{
  signed __int64 v6; 
  const char *v7; 
  signed __int64 v8; 
  __int64 number; 
  const char *v10; 
  scrContext_t *v11; 
  __int64 localClientNum; 
  __int64 v13; 

  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 908, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 196, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
    __debugbreak();
  v6 = ent - g_entities;
  if ( (unsigned int)v6 >= 0x800 )
  {
    LODWORD(localClientNum) = ent - g_entities;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 199, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( ( 2048 ) )", "index doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", localClientNum, 2048) )
      __debugbreak();
  }
  if ( ent->s.number != (_WORD)v6 )
  {
    v7 = SL_ConvertToString(stringValue);
    if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 196, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
      __debugbreak();
    v8 = ent - g_entities;
    if ( (unsigned int)v8 >= 0x800 )
    {
      LODWORD(v13) = 2048;
      LODWORD(localClientNum) = ent - g_entities;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 199, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( ( 2048 ) )", "index doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", localClientNum, v13) )
        __debugbreak();
    }
    LODWORD(v13) = ent->s.number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 909, ASSERT_TYPE_ASSERT, "(ent->s.number == G_GetEntityIndex( ent ))", "%s\n\ts.number = %i, index = %i, stringValue = %s", "ent->s.number == G_GetEntityIndex( ent )", v13, (__int16)v8, v7) )
      __debugbreak();
  }
  number = ent->s.number;
  if ( (unsigned int)number >= 0x800 )
  {
    LODWORD(v13) = 2048;
    LODWORD(localClientNum) = ent->s.number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", localClientNum, v13) )
      __debugbreak();
  }
  if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
    __debugbreak();
  if ( g_entities[number].r.isInUse != g_entityIsInUse[number] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
    __debugbreak();
  if ( !g_entityIsInUse[number] )
  {
    v10 = SL_ConvertToString(stringValue);
    LODWORD(v13) = ent->s.number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 910, ASSERT_TYPE_ASSERT, "(G_IsEntityInUse( ent->s.number ))", "%s\n\tent->s.number = %i, stringValue = %s", "G_IsEntityInUse( ent->s.number )", v13, v10) )
      __debugbreak();
  }
  v11 = ScriptContext_Server();
  Scr_NotifyNum(v11, ent->s.number, ENTITY_CLASS_GENTITY, stringValue, paramcount, LOCAL_CLIENT_0);
}

/*
==============
GScr_RadiusDamageInternal
==============
*/
void GScr_RadiusDamageInternal(scrContext_t *scrContext, gentity_s *inflictor)
{
  bool runOcclusionTraces; 
  char v16; 
  gentity_s *Entity; 
  meansOfDeath_t mod; 
  bool environmentOnly; 
  float v37; 
  float v38; 
  bool outIsAlternate; 
  vec3_t vectorValue; 
  Weapon outWeapon; 
  BgExplosionDamageRangeInfo outDamageRangeInfo; 
  char v43; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm6
    vmovaps xmmword ptr [rax-48h], xmm7
    vmovaps xmmword ptr [rax-58h], xmm8
    vmovaps xmmword ptr [rax-68h], xmm9
    vmovaps xmmword ptr [rax-78h], xmm10
  }
  Scr_GetVector(scrContext, 0, &vectorValue);
  runOcclusionTraces = 1;
  *(float *)&_XMM0 = GScr_ValidateRadiusDamageRange(scrContext, 1u);
  __asm { vmovaps xmm10, xmm0 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
  __asm
  {
    vmovss  xmm8, cs:__real@4f000000
    vxorps  xmm7, xmm7, xmm7
    vcomiss xmm0, xmm7
    vmovaps xmm9, xmm0
  }
  if ( !v16 )
    __asm { vcomiss xmm0, xmm8 }
  Scr_ParamError(COM_ERR_4303, scrContext, 2u, "Invalid damage value specified for radius damage.\n");
  __asm { vxorps  xmm9, xmm9, xmm9 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
  __asm
  {
    vcomiss xmm0, xmm7
    vmovaps xmm6, xmm0
  }
  if ( !v16 )
    __asm { vcomiss xmm0, xmm8 }
  Scr_ParamError(COM_ERR_4303, scrContext, 3u, "Invalid damage value specified for radius damage.\n");
  __asm { vxorps  xmm6, xmm6, xmm6 }
  Entity = g_entities + 2046;
  if ( Scr_GetNumParam(scrContext) > 4 && Scr_GetType(scrContext, 4u) )
    Entity = GScr_GetEntity(4u);
  mod = MOD_EXPLOSIVE;
  if ( Scr_GetNumParam(scrContext) > 5 && Scr_GetType(scrContext, 5u) )
    mod = G_Combat_MeansOfDeathFromScriptParam(scrContext, 5);
  __asm
  {
    vmovups ymm0, ymmword ptr cs:?NULL_WEAPON@@3UWeapon@@B.weaponIdx; Weapon const NULL_WEAPON
    vmovups xmm1, xmmword ptr cs:?NULL_WEAPON@@3UWeapon@@B.attachmentVariationIndices+5; Weapon const NULL_WEAPON
    vmovss  xmm8, cs:__real@3f800000
    vmovups ymmword ptr [rsp+148h+outWeapon.weaponIdx], ymm0
    vmovsd  xmm0, qword ptr cs:?NULL_WEAPON@@3UWeapon@@B.attachmentVariationIndices+15h; Weapon const NULL_WEAPON
  }
  *(_DWORD *)&outWeapon.weaponCamo = *(_DWORD *)&NULL_WEAPON.weaponCamo;
  __asm
  {
    vmovsd  qword ptr [rsp+148h+outWeapon.attachmentVariationIndices+15h], xmm0
    vmovups xmmword ptr [rsp+148h+outWeapon.attachmentVariationIndices+5], xmm1
  }
  if ( Scr_GetNumParam(scrContext) > 6 && Scr_GetType(scrContext, 6u) )
  {
    GScr_Main_GetWeaponParam(scrContext, 6u, &outWeapon, &outIsAlternate);
    _RAX = BG_WeaponDef(&outWeapon, 0);
    __asm { vmovss  xmm7, dword ptr [rax+12E8h] }
    *(double *)&_XMM0 = BG_ExplosionForceScalar(&outWeapon, outIsAlternate);
    __asm { vmovaps xmm8, xmm0 }
  }
  environmentOnly = 0;
  if ( Scr_GetNumParam(scrContext) > 7 && Scr_GetType(scrContext, 7u) )
    environmentOnly = Scr_GetInt(scrContext, 7u) > 0;
  if ( Scr_GetNumParam(scrContext) > 8 && Scr_GetType(scrContext, 8u) )
    runOcclusionTraces = Scr_GetInt(scrContext, 8u) > 0;
  __asm
  {
    vmovaps xmm2, xmm10; damageRadius
    vmovaps xmm1, xmm6; outerDamage
    vmovaps xmm0, xmm9; innerDamage
  }
  BG_BuildExplosionDamageRangeInfo_Interpolated(*(const float *)&_XMM0, *(const float *)&_XMM1, *(const float *)&_XMM2, &outDamageRangeInfo);
  __asm
  {
    vmovss  [rsp+148h+var_110], xmm7
    vmovss  [rsp+148h+var_118], xmm8
  }
  GScr_RadiusDamageProcessInternal(&vectorValue, inflictor, Entity, &outDamageRangeInfo, mod, &outWeapon, v37, v38, environmentOnly, runOcclusionTraces);
  _R11 = &v43;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
  }
}

/*
==============
GScr_RadiusDamageProcessInternal
==============
*/
void GScr_RadiusDamageProcessInternal(const vec3_t *damageOrigin, gentity_s *const inflictor, gentity_s *const attacker, const BgExplosionDamageRangeInfo *damageRangeInfo, const meansOfDeath_t mod, const Weapon *weapon, const float forceScalar, const float reactiveEmitterDelay, const bool environmentOnly, const bool runOcclusionTraces)
{
  GCombat *v15; 
  __int64 v17; 
  int v30; 
  __int64 v31; 
  double v32; 

  level.bPlayerIgnoreRadiusDamage = level.bPlayerIgnoreRadiusDamageLatched;
  _RBP = damageRangeInfo;
  __asm { vmovaps [rsp+0A8h+var_38], xmm6 }
  if ( !GCombat::ms_gCombatSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_combat.h", 177, ASSERT_TYPE_ASSERT, "( ms_gCombatSystem )", (const char *)&queryFormat, "ms_gCombatSystem") )
    __debugbreak();
  v15 = GCombat::ms_gCombatSystem;
  __asm
  {
    vmovss  xmm0, cs:__real@3f800000
    vmovss  dword ptr [rsp+0A8h+var_80], xmm0
  }
  ((void (__fastcall *)(GCombat *, const vec3_t *, gentity_s *const, gentity_s *const, const BgExplosionDamageRangeInfo *, int, _QWORD, gentity_s *const, const meansOfDeath_t, const Weapon *, _BYTE, const bool, const bool))GCombat::ms_gCombatSystem->RadiusDamage)(GCombat::ms_gCombatSystem, damageOrigin, inflictor, attacker, _RBP, v30, 0i64, inflictor, mod, weapon, 0, environmentOnly, runOcclusionTraces);
  level.bPlayerIgnoreRadiusDamage = 0;
  if ( mod == MOD_EXPLOSIVE )
  {
    __asm { vmovss  xmm2, dword ptr [rbp+0Ch] }
    LOBYTE(v31) = 0;
    ((void (__fastcall *)(GCombat *, const vec3_t *, __int64, gentity_s *const, const Weapon *, _DWORD))v15->NotifyRadiusDamage)(v15, damageOrigin, v17, attacker, weapon, v31);
  }
  _RBX = G_Utils_SpawnEventEntity(damageOrigin, 132);
  if ( (mod < MOD_UNKNOWN || (unsigned int)mod > (MOD_NUM|MOD_PROJECTILE|0xE0)) && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned char __cdecl truncate_cast_impl<unsigned char,meansOfDeath_t>(meansOfDeath_t)", "unsigned", (unsigned __int8)mod, "signed", mod) )
    __debugbreak();
  _RBX->s.eventParm2 = (unsigned __int8)mod;
  if ( (unsigned __int8)mod != mod && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 13982, ASSERT_TYPE_ASSERT, "(static_cast<meansOfDeath_t>( eventEnt->s.eventParm2 ) == mod)", (const char *)&queryFormat, "static_cast<meansOfDeath_t>( eventEnt->s.eventParm2 ) == mod") )
    __debugbreak();
  __asm
  {
    vcvttss2si eax, dword ptr [rbp+10h]
    vmovss  xmm0, [rsp+0A8h+reactiveEmitterDelay]
    vmovss  xmm1, [rsp+0A8h+forceScalar]
  }
  _RBX->s.lerp.u.anonymous.data[3] = _EAX;
  __asm { vcvttss2si eax, dword ptr [rbp+18h] }
  _RBX->s.lerp.u.anonymous.data[2] = _EAX;
  __asm
  {
    vmovss  xmm2, dword ptr [rbp+0Ch]
    vxorps  xmm6, xmm6, xmm6
    vcomiss xmm2, xmm6
  }
  _RBX->s.lerp.u.anonymous.data[5] = runOcclusionTraces;
  __asm
  {
    vmovss  dword ptr [rbx+58h], xmm2
    vmovss  dword ptr [rbx+5Ch], xmm0
    vmovss  dword ptr [rbx+68h], xmm1
    vmovss  xmm0, dword ptr [rbx+5Ch]
    vcomiss xmm0, xmm6
    vmovss  xmm0, dword ptr [rbx+68h]
    vcomiss xmm0, xmm6
    vcomiss xmm0, cs:__real@40000000
  }
  if ( runOcclusionTraces )
  {
    __asm
    {
      vcvtss2sd xmm0, xmm0, xmm0
      vmovsd  [rsp+0A8h+var_80], xmm0
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 13997, ASSERT_TYPE_SANITY, "( ( ( ( eventEnt->s.lerp.u.event.radiusDamage.forceScalar >= 0.0f ) && ( eventEnt->s.lerp.u.event.radiusDamage.forceScalar <= PHYSICS_MAX_RADIUSFORCE_SCALAR ) ) ) )", "( eventEnt->s.lerp.u.event.radiusDamage.forceScalar ) = %g", v32) )
      __debugbreak();
  }
  if ( _RBX->s.lerp.u.anonymous.data[3] < 0 )
  {
    LODWORD(v31) = _RBX->s.lerp.u.anonymous.data[3];
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 13998, ASSERT_TYPE_SANITY, "( ( ( eventEnt->s.lerp.u.event.radiusDamage.damageMax >= 0 ) ) )", "( eventEnt->s.lerp.u.event.radiusDamage.damageMax ) = %i", v31) )
      __debugbreak();
  }
  if ( _RBX->s.lerp.u.anonymous.data[2] < 0 )
  {
    LODWORD(v31) = _RBX->s.lerp.u.anonymous.data[2];
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 13999, ASSERT_TYPE_SANITY, "( ( ( eventEnt->s.lerp.u.event.radiusDamage.damageMin >= 0 ) ) )", "( eventEnt->s.lerp.u.event.radiusDamage.damageMin ) = %i", v31) )
      __debugbreak();
  }
  __asm { vmovaps xmm6, [rsp+0A8h+var_38] }
}

/*
==============
GScr_RadiusDamageSteppedInternal
==============
*/
void GScr_RadiusDamageSteppedInternal(scrContext_t *scrContext, gentity_s *inflictor)
{
  bool runOcclusionTraces; 
  char v19; 
  gentity_s *Entity; 
  meansOfDeath_t v28; 
  bool environmentOnly; 
  meansOfDeath_t mod; 
  float weapon; 
  float outDamageRangeInfo; 
  float v51; 
  bool outIsAlternate; 
  vec3_t vectorValue; 
  Weapon outWeapon; 
  BgExplosionDamageRangeInfo damageRangeInfo; 
  char v56; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm6
    vmovaps xmmword ptr [rax-48h], xmm7
    vmovaps xmmword ptr [rax-58h], xmm8
    vmovaps xmmword ptr [rax-68h], xmm9
    vmovaps xmmword ptr [rax-78h], xmm10
    vmovaps xmmword ptr [rax-88h], xmm11
    vmovaps xmmword ptr [rax-98h], xmm12
    vmovaps xmmword ptr [rax-0A8h], xmm13
  }
  Scr_GetVector(scrContext, 0, &vectorValue);
  runOcclusionTraces = 1;
  *(float *)&_XMM0 = GScr_ValidateRadiusDamageRange(scrContext, 1u);
  __asm { vmovaps xmm13, xmm0 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
  __asm
  {
    vmovss  xmm6, cs:__real@4f000000
    vxorps  xmm7, xmm7, xmm7
    vcomiss xmm0, xmm7
    vmovaps xmm10, xmm0
  }
  if ( !v19 )
    __asm { vcomiss xmm0, xmm6 }
  Scr_ParamError(COM_ERR_4303, scrContext, 2u, "Invalid damage value specified for radius damage.\n");
  __asm { vxorps  xmm10, xmm10, xmm10 }
  *(float *)&_XMM0 = GScr_ValidateRadiusDamageRange(scrContext, 3u);
  __asm { vmovaps xmm12, xmm0 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 4u);
  __asm
  {
    vcomiss xmm0, xmm7
    vmovaps xmm8, xmm0
  }
  if ( !v19 )
    __asm { vcomiss xmm0, xmm6 }
  Scr_ParamError(COM_ERR_4303, scrContext, 4u, "Invalid damage value specified for radius damage.\n");
  __asm { vxorps  xmm8, xmm8, xmm8 }
  *(float *)&_XMM0 = GScr_ValidateRadiusDamageRange(scrContext, 5u);
  __asm { vmovaps xmm11, xmm0 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 6u);
  __asm
  {
    vcomiss xmm0, xmm7
    vmovaps xmm9, xmm0
  }
  if ( !v19 )
    __asm { vcomiss xmm0, xmm6 }
  Scr_ParamError(COM_ERR_4303, scrContext, 6u, "Invalid damage value specified for radius damage.\n");
  __asm { vxorps  xmm9, xmm9, xmm9 }
  Entity = g_entities + 2046;
  if ( Scr_GetNumParam(scrContext) > 7 && Scr_GetType(scrContext, 7u) )
    Entity = GScr_GetEntity(7u);
  v28 = MOD_EXPLOSIVE;
  if ( Scr_GetNumParam(scrContext) > 8 && Scr_GetType(scrContext, 8u) )
    v28 = G_Combat_MeansOfDeathFromScriptParam(scrContext, 8);
  __asm
  {
    vmovups ymm0, ymmword ptr cs:?NULL_WEAPON@@3UWeapon@@B.weaponIdx; Weapon const NULL_WEAPON
    vmovups xmm1, xmmword ptr cs:?NULL_WEAPON@@3UWeapon@@B.attachmentVariationIndices+5; Weapon const NULL_WEAPON
    vmovss  xmm6, cs:__real@3f800000
    vmovups ymmword ptr [rsp+178h+outWeapon.weaponIdx], ymm0
    vmovsd  xmm0, qword ptr cs:?NULL_WEAPON@@3UWeapon@@B.attachmentVariationIndices+15h; Weapon const NULL_WEAPON
  }
  *(_DWORD *)&outWeapon.weaponCamo = *(_DWORD *)&NULL_WEAPON.weaponCamo;
  __asm
  {
    vmovsd  qword ptr [rsp+178h+outWeapon.attachmentVariationIndices+15h], xmm0
    vmovups xmmword ptr [rsp+178h+outWeapon.attachmentVariationIndices+5], xmm1
  }
  if ( Scr_GetNumParam(scrContext) > 9 && Scr_GetType(scrContext, 9u) )
  {
    GScr_Main_GetWeaponParam(scrContext, 9u, &outWeapon, &outIsAlternate);
    _RAX = BG_WeaponDef(&outWeapon, 0);
    __asm { vmovss  xmm7, dword ptr [rax+12E8h] }
    *(double *)&_XMM0 = BG_ExplosionForceScalar(&outWeapon, outIsAlternate);
    __asm { vmovaps xmm6, xmm0 }
  }
  environmentOnly = 0;
  if ( Scr_GetNumParam(scrContext) > 0xA && Scr_GetType(scrContext, 0xAu) )
    environmentOnly = Scr_GetInt(scrContext, 0xAu) > 0;
  if ( Scr_GetNumParam(scrContext) > 0xB && Scr_GetType(scrContext, 0xBu) )
    runOcclusionTraces = Scr_GetInt(scrContext, 0xBu) > 0;
  __asm
  {
    vmovss  dword ptr [rsp+178h+weapon], xmm9
    vmovaps xmm3, xmm8; midDamage
    vmovaps xmm2, xmm12; midRange
    vmovaps xmm1, xmm10; innerDamage
    vmovaps xmm0, xmm13; innerRange
    vmovss  [rsp+178h+mod], xmm11
  }
  BG_BuildExplosionDamageRangeInfo_Stepped(*(const float *)&_XMM0, *(const float *)&_XMM1, *(const float *)&_XMM2, *(const float *)&_XMM3, *(const float *)&mod, weapon, &damageRangeInfo);
  __asm
  {
    vmovss  [rsp+178h+var_140], xmm7
    vmovss  dword ptr [rsp+178h+outDamageRangeInfo], xmm6
  }
  GScr_RadiusDamageProcessInternal(&vectorValue, inflictor, Entity, &damageRangeInfo, v28, &outWeapon, outDamageRangeInfo, v51, environmentOnly, runOcclusionTraces);
  _R11 = &v56;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
    vmovaps xmm13, xmmword ptr [r11-80h]
  }
}

/*
==============
GScr_RemoteEyesClear_Internal
==============
*/
void GScr_RemoteEyesClear_Internal(playerState_s *const ps)
{
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 20089, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal(&ps->otherFlags, ACTIVE, 1u);
  ps->remoteEyesEnt = 2047;
  GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::ClearFlagInternal(&ps->linkFlags, ACTIVE, 4u);
  GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::ClearFlagInternal(&ps->linkFlags, ACTIVE, 5u);
}

/*
==============
GScr_RemoteEyesSet_Internal
==============
*/
void GScr_RemoteEyesSet_Internal(playerState_s *const ps, __int16 remoteEyesEnt, bool setZNearClose, bool useTagAngles)
{
  __int64 v8; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 20070, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( (unsigned __int16)remoteEyesEnt >= 0x800u )
  {
    LODWORD(v8) = remoteEyesEnt;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 20071, ASSERT_TYPE_ASSERT, "(unsigned)( remoteEyesEnt ) < (unsigned)( ( 2048 ) )", "remoteEyesEnt doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v8, 2048) )
      __debugbreak();
  }
  ps->linkWeaponAngles.v[0] = ps->viewangles.v[0];
  ps->linkWeaponAngles.v[1] = ps->viewangles.v[1];
  ps->linkWeaponAngles.v[2] = ps->viewangles.v[2];
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal(&ps->otherFlags, ACTIVE, 1u);
  ps->remoteEyesEnt = remoteEyesEnt;
  if ( setZNearClose )
    GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::SetFlagInternal(&ps->linkFlags, ACTIVE, 4u);
  if ( useTagAngles )
    GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::SetFlagInternal(&ps->linkFlags, ACTIVE, 5u);
}

/*
==============
GScr_SBAddArray
==============
*/
int *GScr_SBAddArray(GScr_ScriptBundleContext *ctxt, ScriptBundleValue *arr)
{
  int *v2; 
  int v5; 
  bool v8; 

  v2 = (int *)&arr[1];
  if ( arr->type != SCR_SB_ARRAY && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 26032, ASSERT_TYPE_ASSERT, "(arr->type == ScriptBundleValue::ValueType::SCR_SB_ARRAY)", (const char *)&queryFormat, "arr->type == ScriptBundleValue::ValueType::SCR_SB_ARRAY") )
    __debugbreak();
  if ( !ctxt->pScrContext && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 26033, ASSERT_TYPE_ASSERT, "( ctxt.pScrContext )", (const char *)&queryFormat, "ctxt.pScrContext") )
    __debugbreak();
  Scr_MakeArray(ctxt->pScrContext);
  v5 = 0;
  if ( arr->string > 0 )
  {
    while ( 2 )
    {
      _RDX = (ScriptBundleValue *)v2;
      v2 += 2;
      switch ( _RDX->type )
      {
        case SCR_B_NONE:
          Scr_AddUndefined(ctxt->pScrContext);
          goto LABEL_21;
        case SCR_SB_BOOL:
          Scr_AddBool(ctxt->pScrContext, _RDX->string);
          goto LABEL_21;
        case SCR_SB_INT:
          Scr_AddInt(ctxt->pScrContext, _RDX->string);
          goto LABEL_21;
        case SCR_SB_FLOAT:
          __asm { vmovss  xmm1, dword ptr [rdx+4]; jumptable 000000014131E855 case 3 }
          Scr_AddFloat(ctxt->pScrContext, *(float *)&_XMM1);
          goto LABEL_21;
        case SCR_SB_STRING:
        case SCR_SB_ANIMTREE:
          Scr_AddString(ctxt->pScrContext, &ctxt->strPool[_RDX->string]);
          goto LABEL_21;
        case SCR_SB_OBJECT:
          v2 = GScr_SBAddObject(ctxt, _RDX);
          goto LABEL_21;
        case SCR_SB_ARRAY:
          v2 = GScr_SBAddArray(ctxt, _RDX);
          goto LABEL_21;
        case SCR_SB_ANIMATION:
          v8 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 26066, ASSERT_TYPE_ASSERT, "(!\"Script Bundle schema error - SCR_SB_ANIMATION in array???\")", (const char *)&queryFormat, "!\"Script Bundle schema error - SCR_SB_ANIMATION in array???\"");
          goto LABEL_19;
        case SCR_SB_ANIMTREEID:
          v8 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 26069, ASSERT_TYPE_ASSERT, "(!\"Script Bundle schema error - SCR_SB_ANIMTREEID should have been preprocessed to an SCR_SB_INT\")", (const char *)&queryFormat, "!\"Script Bundle schema error - SCR_SB_ANIMTREEID should have been preprocessed to an SCR_SB_INT\"");
          goto LABEL_19;
        default:
          v8 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 26072, ASSERT_TYPE_ASSERT, "(!\"Script Bundle parse error\")", (const char *)&queryFormat, "!\"Script Bundle parse error\"");
LABEL_19:
          if ( v8 )
            __debugbreak();
LABEL_21:
          Scr_AddArray(ctxt->pScrContext);
          if ( ++v5 >= arr->string )
            return v2;
          continue;
      }
    }
  }
  return v2;
}

/*
==============
GScr_SBAddObject
==============
*/
int *GScr_SBAddObject(GScr_ScriptBundleContext *ctxt, ScriptBundleValue *obj)
{
  int *v2; 
  int v5; 
  int *v7; 
  int v8; 
  ScriptBundleValue *v9; 
  __int64 v11; 
  unsigned int CanonicalString; 
  bool v13; 
  unsigned int v14; 

  v2 = (int *)&obj[1];
  if ( obj->type != SCR_SB_OBJECT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 25963, ASSERT_TYPE_ASSERT, "(obj->type == ScriptBundleValue::ValueType::SCR_SB_OBJECT)", (const char *)&queryFormat, "obj->type == ScriptBundleValue::ValueType::SCR_SB_OBJECT") )
    __debugbreak();
  if ( !ctxt->pScrContext && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 25964, ASSERT_TYPE_ASSERT, "( ctxt.pScrContext )", (const char *)&queryFormat, "ctxt.pScrContext") )
    __debugbreak();
  Scr_MakeStruct(ctxt->pScrContext);
  v5 = 0;
  if ( obj->string > 0 )
  {
    while ( 2 )
    {
      _RBP = v2;
      v7 = v2;
      v8 = *((unsigned __int8 *)v2 + 4);
      v9 = (ScriptBundleValue *)(v2 + 1);
      v2 += 3;
      switch ( v8 )
      {
        case 0:
          Scr_AddUndefined(ctxt->pScrContext);
          goto LABEL_23;
        case 1:
          Scr_AddBool(ctxt->pScrContext, _RBP[2]);
          goto LABEL_23;
        case 2:
          Scr_AddInt(ctxt->pScrContext, _RBP[2]);
          goto LABEL_23;
        case 3:
          __asm { vmovss  xmm1, dword ptr [rbp+8]; jumptable 000000014131EADE case 3 }
          Scr_AddFloat(ctxt->pScrContext, *(float *)&_XMM1);
          goto LABEL_23;
        case 4:
        case 8:
          goto $LN27_33;
        case 5:
          v2 = GScr_SBAddObject(ctxt, v9);
          goto LABEL_23;
        case 6:
          v2 = GScr_SBAddArray(ctxt, v9);
          goto LABEL_23;
        case 7:
          v11 = 4i64;
          if ( ((unsigned __int8)v2 & 4) == 0 )
            v11 = 3i64;
          Scr_AddAnim(ctxt->pScrContext, *(scr_anim_t *)&v7[v11]);
          v2 = v7 + 6;
          CanonicalString = SL_GetCanonicalString("animationid");
          Scr_AppendToArchiveCanonicalString(ctxt->pScrContext, CanonicalString);
          Scr_AddStructField(ctxt->pScrContext, CanonicalString);
$LN27_33:
          Scr_AddString(ctxt->pScrContext, &ctxt->strPool[_RBP[2]]);
          goto LABEL_23;
        case 9:
          v13 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 26012, ASSERT_TYPE_ASSERT, "(!\"Script Bundle schema error - SCR_SB_ANIMTREEID should have been preprocessed to an SCR_SB_INT\")", (const char *)&queryFormat, "!\"Script Bundle schema error - SCR_SB_ANIMTREEID should have been preprocessed to an SCR_SB_INT\"");
          goto LABEL_21;
        default:
          v13 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 26015, ASSERT_TYPE_ASSERT, "(!\"Script Bundle parse error\")", (const char *)&queryFormat, "!\"Script Bundle parse error\"");
LABEL_21:
          if ( v13 )
            __debugbreak();
LABEL_23:
          v14 = SL_GetCanonicalString(&ctxt->strPool[*_RBP]);
          Scr_AppendToArchiveCanonicalString(ctxt->pScrContext, v14);
          Scr_AddStructField(ctxt->pScrContext, v14);
          if ( ++v5 >= obj->string )
            return v2;
          continue;
      }
    }
  }
  return v2;
}

/*
==============
GScr_SetDvar_Internal
==============
*/
void GScr_SetDvar_Internal(scrContext_t *scrContext, const char *dvarName, const char *newValue, const unsigned int allowedModifyFlags)
{
  bool v8; 
  bool v9; 
  const dvar_t *VarByName; 
  const char *UnobfuscatedName; 
  const char *v12; 
  const dvar_t *v13; 
  unsigned int flags; 
  const char *v15; 

  v8 = Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_SLOW_SOFT_LAND|0x80);
  v9 = !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_SLOW_SOFT_LAND|0x80);
  VarByName = Dvar_FindVarByName(dvarName);
  if ( v8 && VarByName && (VarByName->flags & 0x100) == 0 )
  {
    UnobfuscatedName = Dvar_DevGetUnobfuscatedName(dvarName);
    v12 = j_va("Invalid Dvar set: %s - Internal Dvars cannot be changed by script. Use 'setsaveddvar' to alter SAVED internal dvars\n", UnobfuscatedName);
    Scr_Error(COM_ERR_3985, scrContext, v12);
  }
  v13 = Dvar_SetFromStringByNameFromScript(SCRIPTINSTANCE_SERVER, dvarName, newValue);
  if ( v9 && allowedModifyFlags != -1 )
  {
    flags = v13->flags;
    if ( (flags & allowedModifyFlags) == 0 )
    {
      v15 = Dvar_DevGetUnobfuscatedName(dvarName);
      Com_PrintError(15, "SetDvar: dvar '%s' not allowed to be modified.  flags are '%d'.  New value supposed to be %s.\n", v15, flags, newValue);
    }
  }
}

/*
==============
GScr_SetOmnvarInternal
==============
*/
void GScr_SetOmnvarInternal(scrContext_t *scrContext, const OmnvarDef *def, OmnvarData *data, int valueArgumentIndex)
{
  int time; 
  const char *v10; 
  VariableType Type; 
  OmnvarUserType userType; 
  const char *v13; 
  int entnum; 
  const char *v15; 
  const char *v16; 
  const char *v17; 
  const char *String; 
  const char *v19; 
  const char *v20; 

  _RDI = data;
  switch ( def->type )
  {
    case OMNVAR_TYPE_BOOL:
      data->current.enabled = Scr_GetInt(scrContext, valueArgumentIndex) != 0;
      G_Omnvar_MarkChanged(_RDI);
      break;
    case OMNVAR_TYPE_FLOAT:
      *(double *)&_XMM0 = Scr_GetFloat(scrContext, valueArgumentIndex);
      __asm { vmovss  dword ptr [rdi+4], xmm0 }
      G_Omnvar_MarkChanged(_RDI);
      break;
    case OMNVAR_TYPE_INT:
      Type = Scr_GetType(scrContext, valueArgumentIndex);
      userType = def->userType;
      if ( Type == VAR_POINTER )
      {
        if ( userType != OMNVAR_USER_TYPE_ENTITY )
        {
          v13 = j_va("SetOmnvarInternal - '%s' cannot be set to a value of type entity", def->name);
          Scr_Error(COM_ERR_3968, scrContext, v13);
        }
        entnum = Scr_GetEntityRef(scrContext, valueArgumentIndex).entnum;
      }
      else if ( Type )
      {
        if ( userType == OMNVAR_USER_TYPE_ENTITY )
        {
          v16 = j_va("SetOmnvarInternal - '%s' can only be set to an entity or undefined", def->name);
          Scr_Error(COM_ERR_3970, scrContext, v16);
        }
        entnum = Scr_GetInt(scrContext, valueArgumentIndex);
      }
      else
      {
        if ( userType != OMNVAR_USER_TYPE_ENTITY )
        {
          v15 = j_va("SetOmnvarInternal - '%s' cannot be set to a value of undefined", def->name);
          Scr_Error(COM_ERR_3969, scrContext, v15);
        }
        entnum = 2047;
      }
      if ( entnum > def->maxvalue || entnum < def->minvalue )
      {
        v17 = j_va("SetOmnvarInternal - '%s' setting to %d would exceed this omnvar's specified range [%d,%d]", def->name, (unsigned int)entnum, (unsigned int)def->minvalue, def->maxvalue);
        Scr_Error(COM_ERR_3971, scrContext, v17);
      }
      if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_omnvar.h", 21, ASSERT_TYPE_ASSERT, "(data)", (const char *)&queryFormat, "data") )
        __debugbreak();
      if ( def->type != OMNVAR_TYPE_INT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_omnvar.h", 22, ASSERT_TYPE_ASSERT, "(def->type == OMNVAR_TYPE_INT)", (const char *)&queryFormat, "def->type == OMNVAR_TYPE_INT") )
        __debugbreak();
      _RDI->current.integer = entnum - def->minvalue;
      G_Omnvar_MarkChanged(_RDI);
      break;
    case OMNVAR_TYPE_UINT:
      data->current.integer = Scr_GetInt(scrContext, valueArgumentIndex);
      G_Omnvar_MarkChanged(_RDI);
      break;
    case OMNVAR_TYPE_TIME:
      if ( def->userType == OMNVAR_USER_TYPE_NOTIFY )
        time = level.time;
      else
        time = Scr_GetInt(scrContext, valueArgumentIndex);
      if ( time < 0 )
      {
        v10 = j_va("SetOmnvarInternal - '%s' is a unsigned type, and can not be set to negative values", def->name);
        Scr_Error(COM_ERR_3967, scrContext, v10);
      }
      _RDI->current.integer = time;
      G_Omnvar_MarkChanged(_RDI);
      break;
    case OMNVAR_TYPE_NCS_LUI:
      String = Scr_GetString(scrContext, valueArgumentIndex);
      if ( !G_Omnvar_SetNCString(def, _RDI, String) )
      {
        v19 = j_va("SetOmnvarInternal - '%s' is a LUI NetConstString, and cannot be set to '%s'. Did you add this string to ncsLuiStrings.txt?", def->name, String);
        Scr_Error(COM_ERR_3973, scrContext, v19);
      }
      G_Omnvar_MarkChanged(_RDI);
      break;
    default:
      v20 = j_va("SetOmnvarInternal - Type for paramater %d not recognized", (unsigned int)valueArgumentIndex);
      Scr_Error(COM_ERR_3974, scrContext, v20);
      break;
  }
}

/*
==============
GScr_SetScriptablePartUsability
==============
*/
void GScr_SetScriptablePartUsability(scrContext_t *scrContext, scr_entref_t entref, const bool usable)
{
  unsigned int ScriptableIndex_Internal; 
  scr_string_t ConstString; 
  ScriptablePartDef *PartScriptedDefFromName; 
  const char *v8; 
  const char *v9; 
  gentity_s *Entity; 
  unsigned __int8 v11; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal != -1 )
  {
    ConstString = Scr_GetConstString(scrContext, 0);
    if ( !ConstString )
      Scr_ParamError(COM_ERR_4795, scrContext, 0, "Part name cannot be empty");
    PartScriptedDefFromName = ScriptableSv_GetPartScriptedDefFromName(ScriptableIndex_Internal, ConstString, 1);
    if ( !PartScriptedDefFromName )
    {
      v8 = SL_ConvertToString(ConstString);
      v9 = j_va("Failed to get part def for name '%s'", v8);
      Scr_ParamError(COM_ERR_4796, scrContext, 0, v9);
    }
    Entity = GScr_GetEntity(1u);
    if ( !Entity->client )
      Scr_ParamError(COM_ERR_5926, scrContext, 1u, "Entity must be a player");
    v11 = truncate_cast<unsigned char,unsigned int>(PartScriptedDefFromName->serverInstanceFlatId);
    G_PlayerUse_SetObjectUsableForClient(ScriptableIndex_Internal, USE_CLASS_SCRIPTABLE, v11, usable, Entity->s.number);
  }
}

/*
==============
GScr_SetScriptableUsability
==============
*/
void GScr_SetScriptableUsability(scrContext_t *scrContext, scr_entref_t entref, const bool usable)
{
  unsigned int ScriptableIndex_Internal; 
  unsigned int v6; 
  const ScriptableDef *def; 
  gentity_s *Entity; 
  unsigned int i; 
  const ScriptablePartDef *v10; 
  __int64 serverInstanceFlatId; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  v6 = ScriptableIndex_Internal;
  if ( ScriptableIndex_Internal != -1 )
  {
    if ( ScriptableIndex_Internal >= 0xFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 29133, ASSERT_TYPE_ASSERT, "( scriptableIndex < 0xffff )", (const char *)&queryFormat, "scriptableIndex < USHRT_MAX") )
      __debugbreak();
    def = ScriptableSv_GetInstanceCommonContext(v6)->def;
    if ( !def && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 29136, ASSERT_TYPE_ASSERT, "( scriptableDef )", (const char *)&queryFormat, "scriptableDef") )
      __debugbreak();
    Entity = GScr_GetEntity(0);
    if ( !Entity->client )
      Scr_ParamError(COM_ERR_5927, scrContext, 0, "Entity must be a player");
    for ( i = 0; i < def->numParts; ++i )
    {
      v10 = &def->parts[i];
      if ( ScriptableCommon_GetPartHasUsableState(v10) )
      {
        serverInstanceFlatId = v10->serverInstanceFlatId;
        if ( (unsigned int)serverInstanceFlatId > 0xFF && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned char __cdecl truncate_cast_impl<unsigned char,unsigned int>(unsigned int)", "unsigned", (unsigned __int8)serverInstanceFlatId, "unsigned", serverInstanceFlatId) )
          __debugbreak();
        G_PlayerUse_SetObjectUsableForClient(v6, USE_CLASS_SCRIPTABLE, serverInstanceFlatId, usable, Entity->s.number);
      }
    }
  }
}

/*
==============
GScr_SetupLightEntity
==============
*/
gentity_s *GScr_SetupLightEntity(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *v4; 
  const char *v5; 

  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 19563, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( Entity->s.eType != ET_PRIMARY_LIGHT )
  {
    v4 = SL_ConvertToString(Entity->classname);
    v5 = j_va("Function can only be called on a 'light' entity; actual classname is '%s'\n", v4);
    Scr_Error(COM_ERR_4523, scrContext, v5);
  }
  return Entity;
}

/*
==============
GScr_Shutdown
==============
*/
void GScr_Shutdown(void)
{
  if ( level.cachedTagMat.name )
    Scr_SetString(&level.cachedTagMat.name, (scr_string_t)0);
}

/*
==============
GScr_UpdateTagInternal
==============
*/
__int64 GScr_UpdateTagInternal(scrContext_t *scrContext, gentity_s *ent, scr_string_t tagName, cached_tag_mat_t *cachedTag, int shouldUseCache, int showScriptError)
{
  const char *v10; 
  const char *v11; 
  const char *ModelName; 
  actor_s *actor; 
  const char *v15; 
  const Weapon *Weapon; 
  bool IsAlternate; 
  const char *v18; 
  const char *v19; 
  const char *v20; 
  char output[512]; 

  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16125, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !shouldUseCache || ent->s.number != cachedTag->entnum || level.time != cachedTag->time || tagName != cachedTag->name )
  {
    if ( !SV_Game_DObjExists(ent) )
    {
      if ( showScriptError )
      {
        v10 = SL_ConvertToString(ent->classname);
        v11 = j_va("entity has no model defined (classname '%s')", v10);
        Scr_ObjectError(COM_ERR_4390, scrContext, v11);
        return 0i64;
      }
      return 0i64;
    }
    if ( !G_Utils_DObjGetWorldTagMatrix(ent, tagName, &cachedTag->tagMat) )
    {
      if ( showScriptError )
      {
        SV_Game_DObjDumpInfo(ent);
        ModelName = G_CString_GetModelName(ent->model);
        actor = ent->actor;
        v15 = ModelName;
        if ( actor )
        {
          Weapon = GScr_Weapon_GetWeapon(scrContext, (const scr_weapon_t)actor->currentWeapon);
          IsAlternate = GScr_Weapon_IsAlternate(scrContext, (const scr_weapon_t)ent->actor->currentWeapon);
          BG_GetWeaponNameComplete(Weapon, IsAlternate, output, 0x200u);
          v18 = j_va(" - '%s' ", output);
        }
        else
        {
          v18 = (char *)&queryFormat.fmt + 3;
        }
        v19 = SL_ConvertToString(tagName);
        v20 = j_va("tag '%s' does not exist in model '%s'%s(or any attached submodels)", v19, v15, v18);
        Scr_ParamError(COM_ERR_4391, scrContext, 0, v20);
      }
      return 0i64;
    }
    cachedTag->entnum = ent->s.number;
    cachedTag->time = level.time;
    Scr_SetString(&cachedTag->name, tagName);
  }
  return 1i64;
}

/*
==============
GScr_ValidateRadiusDamageRange
==============
*/
float GScr_ValidateRadiusDamageRange(scrContext_t *scrContext, unsigned int index)
{
  char v6; 
  char v7; 

  __asm { vmovaps [rsp+38h+var_18], xmm6 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, index);
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vcomiss xmm0, xmm6
  }
  if ( v6 )
  {
    Scr_ParamError(COM_ERR_4302, scrContext, index, "Invalid <range> value specified for radius damage.\n");
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vmovaps xmm6, [rsp+38h+var_18]
    }
  }
  else
  {
    __asm
    {
      vmovss  xmm6, cs:__real@44000000
      vcomiss xmm0, xmm6
    }
    if ( !(v6 | v7) )
    {
      __asm
      {
        vmovsd  xmm3, cs:__real@4080000000000000
        vcvtss2sd xmm2, xmm0, xmm0
        vmovq   r9, xmm3
        vmovq   r8, xmm2
      }
      Com_PrintWarning(24, "RadiusDamage called with extreme range %.2f - max is %.2f\n", _R8, _R9);
      __asm { vmovaps xmm0, xmm6 }
    }
    __asm { vmovaps xmm6, [rsp+38h+var_18] }
  }
  return *(float *)&_XMM0;
}

/*
==============
G_GetAngleDelta
==============
*/

float __fastcall G_GetAngleDelta(scrContext_t *scrContext, const scr_anim_t anim, double startTime, double endTime)
{
  unsigned __int16 index; 
  const XAnim_s *Anims; 
  double v10; 
  float v14; 
  float v15; 
  vec2_t rot; 
  vec3_t trans; 

  __asm
  {
    vmovaps [rsp+88h+var_18], xmm6
    vmovaps [rsp+88h+var_28], xmm7
  }
  index = anim.index;
  __asm
  {
    vmovaps xmm7, xmm3
    vmovaps xmm6, xmm2
  }
  Anims = Scr_GetAnims(scrContext, anim.tree);
  __asm
  {
    vmovss  [rsp+88h+var_60], xmm7
    vmovss  [rsp+88h+var_68], xmm6
  }
  XAnimGetRelDelta(Anims, index, &rot, &trans, v14, v15);
  v10 = RotationToYaw(&rot);
  __asm
  {
    vmovaps xmm6, [rsp+88h+var_18]
    vmovaps xmm7, [rsp+88h+var_28]
  }
  return *(float *)&v10;
}

/*
==============
G_GetMoveDelta
==============
*/

void __fastcall G_GetMoveDelta(scrContext_t *scrContext, const scr_anim_t anim, double startTime, double endTime, vec3_t *outMoveDelta)
{
  unsigned int index; 
  const XAnim_s *Anims; 
  float v13; 
  float v14; 
  vec4_t rot; 

  __asm
  {
    vmovaps [rsp+88h+var_28], xmm6
    vmovaps [rsp+88h+var_38], xmm7
  }
  index = anim.index;
  __asm
  {
    vmovaps xmm7, xmm3
    vmovaps xmm6, xmm2
  }
  Anims = Scr_GetAnims(scrContext, anim.tree);
  __asm
  {
    vmovss  [rsp+88h+var_60], xmm7
    vmovss  [rsp+88h+var_68], xmm6
  }
  XAnimGetRelDelta3D(Anims, index, &rot, outMoveDelta, v13, v14);
  __asm
  {
    vmovaps xmm6, [rsp+88h+var_28]
    vmovaps xmm7, [rsp+88h+var_38]
  }
}

/*
==============
G_LocalToWorldCoords
==============
*/
void G_LocalToWorldCoords(const gentity_s *pSelf, const vec3_t *local, vec3_t *outWorld)
{
  tmat33_t<vec3_t> axis; 

  _RDI = pSelf;
  _RSI = outWorld;
  AnglesToAxis(&pSelf->r.currentAngles, &axis);
  MatrixTransformVector(local, &axis, _RSI);
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+130h]
    vaddss  xmm1, xmm0, dword ptr [rsi]
    vmovss  dword ptr [rsi], xmm1
    vmovss  xmm0, dword ptr [rdi+134h]
    vaddss  xmm1, xmm0, dword ptr [rsi+4]
    vmovss  dword ptr [rsi+4], xmm1
    vmovss  xmm0, dword ptr [rdi+138h]
    vaddss  xmm1, xmm0, dword ptr [rsi+8]
    vmovss  dword ptr [rsi+8], xmm1
  }
}

/*
==============
G_ScrMain_GetHintStringMessage
==============
*/
__int64 G_ScrMain_GetHintStringMessage(scrContext_t *scrContext, int firstParmIndex, int lastParmIndex)
{
  __int64 result; 
  char v7[1024]; 

  if ( !GScript::ms_gScriptSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.h", 183, ASSERT_TYPE_ASSERT, "( ms_gScriptSystem )", (const char *)&queryFormat, "ms_gScriptSystem") )
    __debugbreak();
  GScript::ms_gScriptSystem->ConstructMessageString(GScript::ms_gScriptSystem, scrContext, firstParmIndex, lastParmIndex, "Hint String", v7, 1024u);
  if ( !GConfigStrings::ms_gConfigStrings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_configstrings.h", 71, ASSERT_TYPE_ASSERT, "( ms_gConfigStrings )", (const char *)&queryFormat, "ms_gConfigStrings") )
    __debugbreak();
  result = ((__int64 (__fastcall *)(GConfigStrings *, char *))GConfigStrings::ms_gConfigStrings->GetHintStringIndex)(GConfigStrings::ms_gConfigStrings, v7);
  if ( !(_DWORD)result )
  {
    Com_PrintError(15, "Could not find or allocate hint string id for message '%s'. See console log for details.\n", v7);
    return 0i64;
  }
  return result;
}

/*
==============
G_SetEntityFlag
==============
*/
void G_SetEntityFlag(gentity_s *ent, EntityStateFlagsCommon flag)
{
  gclient_s *client; 
  LerpEntityState *p_lerp; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *p_eFlags; 

  client = ent->client;
  p_lerp = &ent->s.lerp;
  p_eFlags = &client->ps.eFlags;
  if ( !client )
    p_eFlags = &p_lerp->eFlags;
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(p_eFlags, ACTIVE, flag);
}

/*
==============
G_ValidateWorldUpIsSafe
==============
*/
void G_ValidateWorldUpIsSafe(scrContext_t *scrContext, gentity_s *clientEnt)
{
  gclient_s *ps; 
  GPlayerTraceInfo *PlayerTraceInfo; 
  BgTrace v6; 
  trace_t results; 

  ps = clientEnt->client;
  if ( ps && !BG_IsPlayerLinked(&clientEnt->client->ps) )
  {
    PlayerTraceInfo = GPlayerTraceInfo::GetPlayerTraceInfo(clientEnt->s.number);
    BgTrace::BgTrace(&v6, PlayerTraceInfo);
    BgTrace::LegacyTraceHandler(&v6, PHYSICS_WORLD_ID_FIRST, &results, &ps->ps.origin, &ps->ps.origin, &clientEnt->r.box, ps->ps.clientNum, clientEnt->clipmask & 0xFDFFBFFF, &ps->ps);
    if ( results.allsolid )
      Scr_Error(COM_ERR_4012, scrContext, "Unsafely setting the player's world up in collision, talk to Ben K. with questions.");
  }
}

/*
==============
GetScriptableArray_Internal
==============
*/
void GetScriptableArray_Internal(scrContext_t *scrContext, void (*gScrGetScriptableArrayImpl)(scrContext_t *, const int *, const scr_string_t, const vec3_t *, const float, const scr_string_t))
{
  int NumParam; 
  int *p_Offset; 
  vec3_t *p_vectorValue; 
  scr_string_t v9; 
  scr_string_t ConstLowercaseString; 
  const char *String; 
  const char *v13; 
  const char *v14; 
  int fmt; 
  int Offset; 
  vec3_t vectorValue; 

  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam == 3 )
  {
    Scr_Error(COM_ERR_4680, scrContext, "Requires both an origin and a radius if one or the other is provided");
    return;
  }
  p_Offset = NULL;
  p_vectorValue = NULL;
  v9 = 0;
  ConstLowercaseString = 0;
  __asm
  {
    vmovaps [rsp+98h+var_48], xmm6
    vxorps  xmm6, xmm6, xmm6
  }
  if ( NumParam >= 1 && Scr_GetType(scrContext, 0) )
    ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  if ( NumParam < 2 )
    goto LABEL_20;
  if ( Scr_GetType(scrContext, 1u) == VAR_UNDEFINED )
    goto LABEL_15;
  String = Scr_GetString(scrContext, 1u);
  v13 = String;
  if ( !String )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 24445, ASSERT_TYPE_ASSERT, "( key )", (const char *)&queryFormat, "key") )
      __debugbreak();
    goto LABEL_15;
  }
  if ( !*String )
  {
LABEL_15:
    if ( NumParam >= 4 )
    {
      if ( Scr_GetType(scrContext, 2u) )
      {
        Scr_GetVector(scrContext, 2u, &vectorValue);
        p_vectorValue = &vectorValue;
        *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
        __asm { vmaxss  xmm6, xmm0, xmm6 }
      }
      if ( NumParam >= 5 )
        v9 = Scr_GetConstLowercaseString(scrContext, 4u);
    }
LABEL_20:
    __asm { vmovss  dword ptr [rsp+98h+fmt], xmm6 }
    ((void (__fastcall *)(scrContext_t *, int *, _QWORD, vec3_t *, int, scr_string_t, int))gScrGetScriptableArrayImpl)(scrContext, p_Offset, (unsigned int)ConstLowercaseString, p_vectorValue, fmt, v9, Offset);
    goto LABEL_21;
  }
  Offset = Scr_GetOffset(scrContext, ENTITY_CLASS_SCRIPTABLE, String);
  if ( Offset >= 0 )
  {
    p_Offset = &Offset;
    goto LABEL_15;
  }
  v14 = j_va("key '%s' does not internally belong to scriptables", v13);
  Scr_ParamError(COM_ERR_4681, scrContext, 1u, v14);
LABEL_21:
  __asm { vmovaps xmm6, [rsp+98h+var_48] }
}

/*
==============
GetWeaponHudIconOverrideIndex
==============
*/
void GetWeaponHudIconOverrideIndex(scrContext_t *scrContext, scr_string_t weaponTypeName, unsigned int *outWeaponTypeIndex)
{
  bool v6; 
  const scr_string_t **v7; 
  unsigned int v8; 
  unsigned int i; 
  bool v10; 
  const char *v11; 
  const char *v12; 
  unsigned int v13; 
  unsigned int v14; 

  Com_GameMode_SupportsFeature(WEAPON_DROPPING_QUICK);
  v6 = Com_GameMode_SupportsFeature(WEAPON_DROPPING_QUICK);
  v7 = S_WEAPON_HUD_ICON_TYPE_NAMES;
  v8 = 7;
  if ( v6 )
    v8 = 10;
  for ( i = 0; i < v8; ++i )
  {
    if ( weaponTypeName == **v7 )
      break;
    ++v7;
  }
  Com_Printf_NoFilter("icontypeindex: %d", i);
  v10 = i < v8;
  if ( i == v8 )
  {
    v11 = SL_ConvertToString(weaponTypeName);
    v12 = j_va("\"%s\" is not a valid weapon hud icon type to override", v11);
    Scr_ParamError(COM_ERR_4620, scrContext, 0, v12);
    v10 = i < v8;
  }
  if ( !v10 )
  {
    v14 = v8;
    v13 = i;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 22286, ASSERT_TYPE_ASSERT, "(unsigned)( weaponTypeIndex ) < (unsigned)( iconTypeCount )", "weaponTypeIndex doesn't index iconTypeCount\n\t%i not in [0, %i)", v13, v14) )
      __debugbreak();
  }
  *outWeaponTypeIndex = i;
}

/*
==============
ScrCmd_BuildHudOutlineClientMaskFromEntArray
==============
*/
void ScrCmd_BuildHudOutlineClientMaskFromEntArray(scrContext_t *scrContext, unsigned int paramIndex, ClientBits *outClientMask)
{
  unsigned int ArrayObject; 
  unsigned int ArraySize; 
  unsigned int v8; 
  unsigned int ArrayVariable; 
  int intValue; 
  scr_entref_t EntityIdRef; 
  __int64 v12; 
  __int64 v13; 

  if ( !outClientMask && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 11146, ASSERT_TYPE_ASSERT, "(outClientMask)", (const char *)&queryFormat, "outClientMask") )
    __debugbreak();
  ArrayObject = BGScr_Main_GetArrayObject(scrContext, paramIndex);
  ArraySize = GetArraySize(scrContext, ArrayObject);
  if ( !ArraySize )
    Scr_ParamError(COM_ERR_4234, scrContext, paramIndex, "An empty array is not valid.");
  v8 = 0;
  *(_QWORD *)outClientMask->array = 0i64;
  *(_QWORD *)&outClientMask->array[2] = 0i64;
  *(_QWORD *)&outClientMask->array[4] = 0i64;
  for ( outClientMask->array[6] = 0; v8 < ArraySize; ++v8 )
  {
    ArrayVariable = GetArrayVariable(scrContext, ArrayObject, v8);
    if ( GetValueType(scrContext, ArrayVariable) != VAR_POINTER )
      Scr_ParamError(COM_ERR_4235, scrContext, paramIndex, "All array elements need to be client entities.");
    intValue = GetVariableValueAddress(scrContext, ArrayVariable)->intValue;
    if ( GetObjectType(scrContext, intValue) != VAR_ENTITY )
      Scr_ParamError(COM_ERR_4236, scrContext, paramIndex, "All array elements need to be client entities.");
    EntityIdRef = Scr_GetEntityIdRef(scrContext, intValue);
    if ( EntityIdRef.entclass )
      Scr_ParamError(COM_ERR_4237, scrContext, paramIndex, "All array elements need to be client entities.");
    if ( (EntityIdRef.entnum > 0x7FFFFFFF || EntityIdRef.entnum + 0x8000 > 0xFFFF) && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "short __cdecl truncate_cast_impl<short,unsigned int>(unsigned int)", "signed", SLOWORD(EntityIdRef.entnum), "unsigned", EntityIdRef.entnum) )
      __debugbreak();
    if ( !ComCharacterLimits::ms_isGameDataValid && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_character_limits.h", 123, ASSERT_TYPE_ASSERT, "(ms_isGameDataValid)", (const char *)&queryFormat, "ms_isGameDataValid") )
      __debugbreak();
    if ( SLOWORD(EntityIdRef.entnum) >= (int)ComCharacterLimits::ms_gameData.m_characterCount )
      Scr_ParamError(COM_ERR_4238, scrContext, paramIndex, "All array elements need to be character entities.");
    if ( SLOWORD(EntityIdRef.entnum) < level.maxclients )
    {
      if ( (unsigned int)SLOWORD(EntityIdRef.entnum) >= 0xE0 )
      {
        LODWORD(v13) = 224;
        LODWORD(v12) = SLOWORD(EntityIdRef.entnum);
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 263, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v12, v13) )
          __debugbreak();
      }
      outClientMask->array[(unsigned __int64)(unsigned int)SLOWORD(EntityIdRef.entnum) >> 5] |= 0x80000000 >> (EntityIdRef.entnum & 0x1F);
    }
  }
}

/*
==============
ScrCmd_EnableDisableAudioTrigger
==============
*/
void ScrCmd_EnableDisableAudioTrigger(scrContext_t *scrContext, bool enabled)
{
  const char *String; 
  unsigned int v5; 
  const char *v6; 
  const char *v7; 
  int v8; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    String = Scr_GetString(scrContext, 0);
    v5 = SND_HashName(String);
    if ( !CG_CheckAudioStateId(String) )
    {
      v6 = j_va("Enable/DisableAudioTrigger: Bad state id name: %s\n", String);
      Scr_Error(COM_ERR_4725, scrContext, v6);
    }
    v8 = enabled + 48;
    v7 = j_va("%c %c %x %c", 109i64, 102i64, v5, v8);
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v7);
  }
  else
  {
    Scr_Error(COM_ERR_4724, scrContext, "DisableAudioTrigger: Incorrect number of parameters\n");
  }
}

/*
==============
ScrCmd_EnableDisablePASpeaker
==============
*/
void ScrCmd_EnableDisablePASpeaker(scrContext_t *scrContext, const char *name, bool enable)
{
  unsigned int v3; 
  const char *v5; 
  char v6; 
  unsigned int v7; 
  char v8; 
  unsigned int audioPASpeakerCount; 
  unsigned int *p_nameHash; 
  const char *v11; 
  const char *v12; 

  v3 = 0;
  v5 = name;
  if ( name && (v6 = *name) != 0 )
  {
    v7 = 5381;
    do
    {
      ++v5;
      v8 = v6 | 0x20;
      if ( (unsigned int)(v6 - 65) >= 0x1A )
        v8 = v6;
      v7 = 65599 * v7 + v8;
      v6 = *v5;
    }
    while ( *v5 );
    if ( !v7 )
      v7 = 1;
  }
  else
  {
    v7 = 0;
  }
  if ( cm.mapEnts )
  {
    audioPASpeakerCount = cm.mapEnts->audioPASpeakerCount;
    if ( !audioPASpeakerCount )
    {
LABEL_16:
      v11 = j_va("Enable/DisablePASpeaker: Speaker %s not found", name);
      Scr_Error(COM_ERR_4727, scrContext, v11);
      return;
    }
    p_nameHash = &cm.mapEnts->audioPASpeakers->nameHash;
    while ( *p_nameHash != v7 )
    {
      ++v3;
      p_nameHash += 5;
      if ( v3 >= audioPASpeakerCount )
        goto LABEL_16;
    }
  }
  v12 = j_va("%c %x %c", 120i64, v7, (unsigned int)enable + 48);
  SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v12);
}

/*
==============
ScrCmd_GetScriptableEventType_Internal
==============
*/
__int64 ScrCmd_GetScriptableEventType_Internal(scr_string_t name)
{
  if ( name == scr_const.scriptable_event_wait )
    return 1i64;
  if ( name == scr_const.scriptable_event_script )
    return 3i64;
  if ( name == scr_const.scriptable_event_model )
    return 4i64;
  if ( name == scr_const.scriptable_event_collision )
    return 5i64;
  if ( name == scr_const.scriptable_event_animation )
    return 6i64;
  if ( name == scr_const.scriptable_event_move )
    return 34i64;
  return (unsigned int)(name != scr_const.scriptable_event_script_damage) + 43;
}

/*
==============
ScrCmd_GetScriptableIndex_Internal
==============
*/
__int64 ScrCmd_GetScriptableIndex_Internal(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  unsigned int scriptableIndex; 

  scriptableIndex = 0;
  entnum = entref.entnum;
  if ( entref.entclass )
  {
    if ( entref.entclass == ENTITY_CLASS_SCRIPTABLE )
    {
      return entref.entnum;
    }
    else
    {
      Scr_ObjectError(COM_ERR_4757, scrContext, "self not an ENTITY_CLASS_GENTITY or ENTITY_CLASS_SCRIPTABLE");
      return 0xFFFFFFFFi64;
    }
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 188, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", entref.entnum, 2048) )
      __debugbreak();
    if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 189, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
      __debugbreak();
    if ( ScriptableSv_TryGetIndexForEntity(&g_entities[entnum], &scriptableIndex) )
    {
      return scriptableIndex;
    }
    else
    {
      Scr_Error(COM_ERR_4756, scrContext, "self entity must have an attached scriptable");
      return 0xFFFFFFFFi64;
    }
  }
}

/*
==============
ScrCmd_GetTableEntries
==============
*/
__int64 ScrCmd_GetTableEntries(scrContext_t *scrContext, const unsigned int arrayId, std::pair<unsigned int,VariableUnion const *> *outEntries, VariableType *outType)
{
  std::pair<unsigned int,VariableUnion const *> *v5; 
  unsigned int v8; 
  unsigned int FirstSibling; 
  unsigned int VariableName; 
  int ValueType; 
  const VariableUnion *VariableValueAddressConst; 
  const char *v13; 
  const char *v14; 
  const char *v15; 
  const char *v16; 
  const char *v17; 
  ComErrorCode v18; 
  const char *v19; 
  const char *v20; 
  const char *NameForType; 
  const char *v22; 

  v5 = outEntries;
  if ( !outEntries && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 33010, ASSERT_TYPE_ASSERT, "( outEntries != nullptr )", (const char *)&queryFormat, "outEntries != nullptr") )
    __debugbreak();
  if ( !outType && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 33011, ASSERT_TYPE_ASSERT, "( outType != nullptr )", (const char *)&queryFormat, "outType != nullptr") )
    __debugbreak();
  *outType = VAR_UNDEFINED;
  v8 = 0;
  FirstSibling = FindFirstSibling(scrContext, arrayId);
  if ( FirstSibling )
  {
    while ( 1 )
    {
      VariableName = GetVariableName(scrContext, FirstSibling);
      ValueType = (unsigned __int8)GetValueType(scrContext, FirstSibling);
      VariableValueAddressConst = GetVariableValueAddressConst(scrContext, FirstSibling);
      if ( ValueType == 2 )
      {
        if ( *outType == VAR_UNDEFINED )
        {
          *outType = VAR_STRING;
          goto LABEL_25;
        }
        if ( *outType == VAR_STRING )
          goto LABEL_25;
        NameForType = Scr_GetNameForType(VAR_STRING);
        v22 = Scr_GetNameForType(*outType);
        v17 = j_va("Array contains mismatching types: %s != %s", v22, NameForType);
        v18 = COM_ERR_6573;
        goto LABEL_24;
      }
      if ( ValueType == 5 )
        break;
      if ( ValueType == 6 )
      {
        if ( *outType == VAR_UNDEFINED )
        {
          *outType = VAR_INTEGER;
LABEL_25:
          v5->first = VariableName;
          ++v8;
          v5->second = VariableValueAddressConst;
          ++v5;
          goto LABEL_26;
        }
        if ( *outType == VAR_INTEGER )
          goto LABEL_25;
        v15 = Scr_GetNameForType((VariableType)ValueType);
        v16 = Scr_GetNameForType(*outType);
        v17 = j_va("Array contains mismatching types: %s != %s", v16, v15);
        v18 = COM_ERR_6437;
LABEL_24:
        Scr_ParamError(v18, scrContext, 0, v17);
        goto LABEL_25;
      }
      v13 = Scr_GetNameForType((VariableType)ValueType);
      v14 = j_va("Array contains value that is not a comparable: %s", v13);
      Scr_ParamError(COM_ERR_6574, scrContext, 0, v14);
LABEL_26:
      FirstSibling = FindNextSibling(scrContext, FirstSibling);
      if ( !FirstSibling )
        return v8;
    }
    if ( *outType == VAR_UNDEFINED )
    {
      *outType = VAR_FLOAT;
      goto LABEL_25;
    }
    if ( *outType == VAR_FLOAT )
      goto LABEL_25;
    v19 = Scr_GetNameForType((VariableType)ValueType);
    v20 = Scr_GetNameForType(*outType);
    v17 = j_va("Array contains mismatching types: %s != %s", v20, v19);
    v18 = COM_ERR_6572;
    goto LABEL_24;
  }
  return v8;
}

/*
==============
ScrCmd_PlayRumbleOnEntity_Internal
==============
*/
void ScrCmd_PlayRumbleOnEntity_Internal(scrContext_t *scrContext, scr_entref_t entref, int event)
{
  gentity_s *Entity; 
  const char *String; 
  const char *v7; 
  gclient_s *client; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *p_eFlags; 
  unsigned int outIndex; 

  Entity = GetEntity(entref);
  if ( !Entity->agent )
  {
    String = Scr_GetString(scrContext, 0);
    if ( !NetConstStrings_GetIndexFromName(NETCONSTSTRINGTYPE_RUMBLE, String, &outIndex) )
    {
      v7 = j_va("unknown rumble name '%s'", String);
      Scr_ParamError(COM_ERR_4284, scrContext, 0, v7);
    }
    Entity->r.svFlags &= ~1u;
    if ( Scr_GetNumParam(scrContext) == 1 )
    {
      if ( event == 150 )
      {
        client = Entity->client;
        if ( client )
          p_eFlags = &client->ps.eFlags;
        else
          p_eFlags = &Entity->s.lerp.eFlags;
        GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(p_eFlags, GameModeFlagValues::ms_mpValue, 0x17u);
      }
      G_Utils_AddEvent(Entity, event, outIndex);
    }
    else
    {
      Scr_Error(COM_ERR_4285, scrContext, "Incorrect number of parameters.\n");
    }
  }
}

/*
==============
ScrCmd_Unlink_Internal
==============
*/
void ScrCmd_Unlink_Internal(gentity_s *ent, int allowUnlinkIncollision)
{
  gclient_s *client; 
  gclient_s *v5; 
  GMovingPlatforms *v6; 
  unsigned int v7; 
  ai_scripted_t *m_pAI; 
  __int64 v9; 
  AIWrapper v10; 

  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 8348, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  G_AllowEntUnlinkInCollision(allowUnlinkIncollision != 0);
  G_EntUnlink(ent);
  G_AllowEntUnlinkInCollision(0);
  client = ent->client;
  if ( client )
  {
    client->linkAnglesFrac = 0.0;
    ent->client->flags &= ~4u;
    GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::ClearFlagInternal(&ent->client->ps.linkFlags, ACTIVE, 0);
    GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::ClearFlagInternal(&ent->client->ps.linkFlags, GameModeFlagValues::ms_spValue, 7u);
    v5 = ent->client;
    if ( !GMovingPlatforms::ms_instance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\movingplatforms\\g_moving_platforms.h", 207, ASSERT_TYPE_ASSERT, "(ms_instance)", (const char *)&queryFormat, "ms_instance") )
      __debugbreak();
    v6 = GMovingPlatforms::ms_instance;
    if ( !v5->movingPlatformHandle.m_objIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_object_handle.h", 36, ASSERT_TYPE_ASSERT, "(IsDefined())", "%s\n\tCan't get the index of an undefined handle", "IsDefined()") )
      __debugbreak();
    v7 = v5->movingPlatformHandle.m_objIndex - 1;
    if ( !(_BYTE)GMovingPlatforms::ms_allocatedType && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\movingplatforms\\g_moving_platforms.h", 198, ASSERT_TYPE_ASSERT, "( ms_allocatedType != GameModeType::NONE )", (const char *)&queryFormat, "ms_allocatedType != GameModeType::NONE") )
      __debugbreak();
    if ( v7 >= 0xF8 )
    {
      LODWORD(v9) = v7;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\movingplatforms\\g_moving_platforms.h", 199, ASSERT_TYPE_ASSERT, "(unsigned)( clientIndex ) < (unsigned)( ( sizeof( *array_counter( m_moverClientArray ) ) + 0 ) )", "clientIndex doesn't index ARRAY_COUNT( m_moverClientArray )\n\t%i not in [0, %i)", v9, 248) )
        __debugbreak();
    }
    GMovingPlatformClient::UpdatePlatformTrace(&v6->m_moverClientArray[v7], ent, 1);
  }
  AIActorInterface::AIActorInterface(&v10.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v10.m_newAgentInterface);
  v10.m_pAI = NULL;
  v10.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AIWrapper::Setup(&v10, ent);
  if ( v10.m_pAI )
  {
    m_pAI = v10.m_pAI->m_pAI;
    if ( m_pAI->eScriptSetAnimMode == AI_ANIM_POINT_RELATIVE )
      m_pAI->eScriptSetAnimMode = AI_ANIM_UNKNOWN;
  }
}

/*
==============
ScrLinkTo_Internal
==============
*/
void ScrLinkTo_Internal(scrContext_t *scrContext, scr_entref_t entref, bool blendToTag, bool movementChangesOffset)
{
  gentity_s *Entity; 
  unsigned int ScriptableIndexForEntity; 
  char v9; 
  const char *EntityTypeName; 
  const char *ModelName; 
  const char *v12; 
  ComErrorCode v13; 
  const char *v14; 
  gentity_s *v15; 
  int NumParam; 
  scr_string_t ConstLowercaseString; 
  const char *v18; 
  AIWrapper v19; 
  vec3_t anglesOffset; 
  vec3_t vectorValue; 
  char outErrorMessage[256]; 

  Entity = GetEntity(entref);
  if ( Scr_GetType(scrContext, 0) != VAR_POINTER || Scr_GetPointerType(scrContext, 0) != VAR_ENTITY )
    Scr_ParamError(COM_ERR_4156, scrContext, 0, "not an entity");
  if ( Entity->client )
    Scr_ParamError(COM_ERR_4157, scrContext, 0, "This function doesn't support player entities.");
  if ( (Entity->flags.m_flags[0] & 0x200) == 0 )
  {
    ScriptableIndexForEntity = ScriptableSv_GetScriptableIndexForEntity(Entity);
    if ( ScriptableIndexForEntity == -1 || (ScriptableCommon_AssertCountsInitialized(), ScriptableIndexForEntity < g_scriptableWorldCounts.runtimeInstanceCount) )
    {
      v9 = 0;
    }
    else
    {
      v9 = 1;
      ScriptableSv_VerifyScriptableMoverEntity(Entity);
    }
    EntityTypeName = G_GetEntityTypeName(Entity);
    if ( v9 )
    {
      ModelName = G_CString_GetModelName(Entity->model);
      v12 = j_va("scriptable (model: '%s', type: '%s') link failed.  Call EnableLinkTo() on the scriptable first before calling LinkTo()", ModelName, EntityTypeName);
      v13 = COM_ERR_4158;
    }
    else
    {
      v14 = SL_ConvertToString(Entity->classname);
      v12 = j_va("entity (classname: '%s', type: '%s') does not currently support linkTo", v14, EntityTypeName);
      v13 = COM_ERR_4160;
    }
    Scr_ObjectError(v13, scrContext, v12);
  }
  v15 = GScr_GetEntity(0);
  NumParam = Scr_GetNumParam(scrContext);
  ConstLowercaseString = 0;
  if ( NumParam >= 2 )
  {
    ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 1u);
    if ( ConstLowercaseString == scr_const._ )
      ConstLowercaseString = 0;
  }
  if ( NumParam > 2 && !blendToTag )
  {
    Scr_GetVector(scrContext, 2u, &vectorValue);
    Scr_GetVector(scrContext, 3u, &anglesOffset);
    if ( G_EntLinkToWithOffset(Entity, v15, ConstLowercaseString, &vectorValue, &anglesOffset, 256, outErrorMessage) )
    {
      Entity->tagInfo->movementChangesOffset = movementChangesOffset;
      return;
    }
    goto LABEL_37;
  }
  if ( !G_EntLinkTo(Entity, v15, ConstLowercaseString, 256, outErrorMessage) )
  {
LABEL_37:
    v18 = j_va("failed to link entity %i to entity %i: %s", (unsigned int)Entity->s.number, (unsigned int)v15->s.number, outErrorMessage);
    Scr_Error(COM_ERR_4162, scrContext, v18);
    return;
  }
  Entity->tagInfo->blendToParent = blendToTag;
  Entity->tagInfo->movementChangesOffset = movementChangesOffset;
  Entity->tagInfo->blendOnlyYaw = Com_GameMode_SupportsFeature(WEAPON_MELEE_END) && (!blendToTag || NumParam <= 2 || Scr_GetInt(scrContext, 2u) != 0);
  Entity->tagInfo->collisionPhysics = Com_GameMode_SupportsFeature(WEAPON_EXECUTION) && blendToTag && NumParam > 3 && Scr_GetInt(scrContext, 3u) != 0;
  AIActorInterface::AIActorInterface(&v19.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v19.m_newAgentInterface);
  v19.m_pAI = NULL;
  v19.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AIWrapper::Setup(&v19, Entity);
  if ( blendToTag )
  {
    if ( v19.m_pAI )
      *(_DWORD *)((__int64)v19.m_pAI->GetAI(v19.m_pAI) + 2424) = 10;
  }
}

/*
==============
Scr_DrawCone
==============
*/

void __fastcall Scr_DrawCone(const vec3_t *start, const vec3_t *angles, double coneAngle, double range, const vec4_t *color)
{
  __int64 v20; 
  __int64 v21; 
  __int64 v22; 
  __int64 v23; 
  char v53; 
  char v54; 
  vec3_t end; 
  tmat33_t<vec3_t> axis; 
  vec3_t starta; 
  char v67; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-18h], xmm6
    vmovaps xmmword ptr [rax-28h], xmm7
    vmovaps xmmword ptr [rax-38h], xmm8
    vmovaps xmmword ptr [rax-48h], xmm9
    vmovaps xmmword ptr [rax-58h], xmm10
    vmovaps xmmword ptr [rax-68h], xmm11
    vmovaps xmmword ptr [rax-78h], xmm12
    vmovaps xmmword ptr [rax-88h], xmm13
    vmovss  xmm10, cs:__real@3c8efa35
    vmulss  xmm0, xmm2, xmm10; X
    vmovaps xmm6, xmm3
  }
  *(float *)&_XMM0 = sinf_0(*(float *)&_XMM0);
  __asm { vmulss  xmm12, xmm0, xmm6 }
  AnglesToAxis(angles, &axis);
  __asm
  {
    vxorps  xmm11, xmm6, cs:__xmm@80000000800000008000000080000000
    vmovss  xmm13, cs:__real@41100000
    vmovss  xmm8, cs:__real@41900000
    vmovss  xmm9, cs:__real@43b40000
    vxorps  xmm7, xmm7, xmm7
  }
  do
  {
    __asm
    {
      vmulss  xmm1, xmm7, xmm10
      vxorps  xmm0, xmm0, xmm0
      vmovss  xmm0, xmm0, xmm1
    }
    *(double *)&_XMM0 = j___libm_sse2_sincosf_(v21, v20, v22, v23);
    __asm
    {
      vmulss  xmm2, xmm11, dword ptr [rsp+108h+axis+0Ch]
      vshufps xmm1, xmm0, xmm0, 1
      vmulss  xmm5, xmm1, xmm12
      vmulss  xmm1, xmm5, dword ptr [rsp+108h+axis]
      vaddss  xmm3, xmm1, dword ptr [rsi]
      vmulss  xmm6, xmm0, xmm12
      vmulss  xmm0, xmm6, dword ptr [rsp+108h+axis+18h]
      vmulss  xmm1, xmm6, dword ptr [rsp+108h+axis+1Ch]
      vaddss  xmm4, xmm3, xmm0
      vaddss  xmm0, xmm4, xmm2
      vmulss  xmm2, xmm5, dword ptr [rsp+108h+axis+4]
      vaddss  xmm3, xmm2, dword ptr [rsi+4]
      vmulss  xmm2, xmm6, dword ptr [rsp+108h+axis+20h]
      vaddss  xmm4, xmm3, xmm1
      vmovss  dword ptr [rsp+108h+end], xmm0
      vmulss  xmm0, xmm11, dword ptr [rsp+108h+axis+10h]
      vaddss  xmm1, xmm4, xmm0
      vmulss  xmm0, xmm5, dword ptr [rsp+108h+axis+8]
      vaddss  xmm3, xmm0, dword ptr [rsi+8]
      vmovss  dword ptr [rsp+108h+end+4], xmm1
      vmulss  xmm1, xmm11, dword ptr [rsp+108h+axis+14h]
      vaddss  xmm4, xmm3, xmm2
      vaddss  xmm2, xmm4, xmm1
      vmovss  dword ptr [rsp+108h+end+8], xmm2
    }
    CL_AddDebugLine(start, &end, color, 0, 0, 1);
    __asm { vcomiss xmm7, xmm13 }
    if ( !(v53 | v54) )
      CL_AddDebugLine(&starta, &end, color, 0, 0, 1);
    __asm
    {
      vmovsd  xmm0, qword ptr [rsp+108h+end]
      vaddss  xmm7, xmm7, xmm8
      vcomiss xmm7, xmm9
      vmovsd  qword ptr [rsp+108h+start], xmm0
    }
    starta.v[2] = end.v[2];
  }
  while ( v53 | v54 );
  _R11 = &v67;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm9, xmmword ptr [r11-40h]
    vmovaps xmm10, xmmword ptr [r11-50h]
    vmovaps xmm11, xmmword ptr [r11-60h]
    vmovaps xmm12, xmmword ptr [r11-70h]
    vmovaps xmm13, xmmword ptr [r11-80h]
  }
}

/*
==============
Scr_EmitScriptBundleAnimations
==============
*/
void Scr_EmitScriptBundleAnimations(XAssetHeader bundle, void *data)
{
  scrContext_t *v4; 
  ScriptBundleValue *v5; 
  GScr_ScriptBundleContext ctxt; 

  if ( !data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 26195, ASSERT_TYPE_ASSERT, "(data != nullptr)", (const char *)&queryFormat, "data != nullptr") )
    __debugbreak();
  if ( bundle.physicsLibrary )
  {
    if ( SLODWORD(bundle.physicsLibrary[1].name) <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 26199, ASSERT_TYPE_ASSERT, "(bundle.scriptBundle->rootSize > 0)", (const char *)&queryFormat, "bundle.scriptBundle->rootSize > 0") )
      __debugbreak();
    v4 = *(scrContext_t **)data;
    ctxt.strPool = bundle.physicsLibrary->havokData;
    ctxt.currentAnimTree = s_defaultScriptbundleAnimtree;
    ctxt.pScrContext = v4;
    ScriptContext_GetInstance(v4);
    v5 = *(ScriptBundleValue **)&bundle.physicsLibrary[1].isMaterialList;
    ctxt.anim_user = 1;
    Scr_SBPreScanObject(&ctxt, v5);
  }
}

/*
==============
Scr_EmitScriptBundlesAnimations
==============
*/
void Scr_EmitScriptBundlesAnimations(scrContext_t *scrContext)
{
  scrContext_t *inData; 

  inData = scrContext;
  DB_EnumXAssets(ASSET_TYPE_SCRIPTBUNDLE, Scr_EmitScriptBundleAnimations, &inData, 0);
}

/*
==============
Scr_ErrorOnDefaultAsset
==============
*/
void Scr_ErrorOnDefaultAsset(scrContext_t *scrContext, XAssetType type, const char *assetName)
{
  const char *XAssetTypeName; 
  const char *v7; 

  DB_FindXAssetHeader(type, assetName, 1);
  if ( DB_IsXAssetDefault(type, assetName) )
  {
    if ( !DB_CheckIfMissingAssetIsTransient(type, assetName) )
    {
      XAssetTypeName = DB_GetXAssetTypeName(type);
      v7 = j_va("precache %s '%s' failed", XAssetTypeName, assetName);
      Scr_NeverTerminalError(COM_ERR_4278, scrContext, v7);
    }
  }
}

/*
==============
Scr_FPrint_internal
==============
*/
void Scr_FPrint_internal(scrContext_t *scrContext, bool commaBetweenFields)
{
  unsigned int Int; 
  fileHandle_t *v5; 
  unsigned int i; 
  const char *String; 
  unsigned __int64 v8; 
  int v9; 

  if ( Scr_GetNumParam(scrContext) <= 1 )
  {
    Com_Printf(23, "fprintln requires at least 2 parameters (file, output)\n");
LABEL_14:
    v9 = -1;
    goto LABEL_15;
  }
  Int = Scr_GetInt(scrContext, 0);
  if ( Int > 1 )
  {
    Com_Printf(23, "FPrintln failed, invalid file number %i\n", Int);
    goto LABEL_14;
  }
  v5 = (fileHandle_t *)&level.openScriptIOFileBuffers[(int)Int - 1];
  if ( v5->handle.handle == -1 )
  {
    Com_Printf(23, "FPrintln failed, file number %i was not open for writing\n", Int);
    goto LABEL_14;
  }
  for ( i = 1; i < Scr_GetNumParam(scrContext); ++i )
  {
    String = Scr_GetString(scrContext, i);
    v8 = -1i64;
    do
      ++v8;
    while ( String[v8] );
    FS_Write(String, v8, (fileHandle_t)v5->handle.handle);
    if ( commaBetweenFields )
      FS_Write(",", 1ui64, (fileHandle_t)v5->handle.handle);
  }
  FS_Write("\n", 1ui64, (fileHandle_t)v5->handle.handle);
  v9 = Scr_GetNumParam(scrContext) - 1;
LABEL_15:
  Scr_AddInt(scrContext, v9);
}

/*
==============
Scr_FxParamError
==============
*/
void Scr_FxParamError(ComErrorCode uniqueErrorCode, scrContext_t *scrContext, int paramIndex, const char *errorString, int fxId)
{
  const char *v9; 
  char dest[1024]; 

  if ( !errorString && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 14973, ASSERT_TYPE_ASSERT, "(errorString)", (const char *)&queryFormat, "errorString") )
    __debugbreak();
  if ( fxId )
  {
    if ( !GConfigStrings::ms_gConfigStrings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_configstrings.h", 71, ASSERT_TYPE_ASSERT, "( ms_gConfigStrings )", (const char *)&queryFormat, "ms_gConfigStrings") )
      __debugbreak();
    GConfigStrings::ms_gConfigStrings->GetEffectName(GConfigStrings::ms_gConfigStrings, fxId, dest, 1024);
  }
  else
  {
    Core_strcpy(dest, 0x400ui64, "not successfully loaded");
  }
  v9 = j_va("%s (effect = %s)\n", errorString, dest);
  Scr_ParamError(uniqueErrorCode, scrContext, paramIndex, v9);
}

/*
==============
Scr_GetEntArrayInRadius_Internal
==============
*/
void Scr_GetEntArrayInRadius_Internal(scrContext_t *scrContext, int qbOnlyScriptables)
{
  unsigned int NumParam; 
  bool v10; 
  VariableType Type; 
  VariableType v12; 
  scr_string_t ConstString; 
  const char *String; 
  int Offset; 
  const char *v16; 
  scrContext_t *v17; 
  ComErrorCode v18; 
  float v22; 
  vec3_t vectorValue; 

  __asm
  {
    vmovaps [rsp+88h+var_28], xmm6
    vmovaps [rsp+88h+var_38], xmm7
    vxorps  xmm7, xmm7, xmm7
    vxorps  xmm6, xmm6, xmm6
  }
  if ( Scr_GetNumParam(scrContext) == 3 )
  {
    Scr_Error(COM_ERR_4674, scrContext, "Requires both an origin and a radius if one or the other is provided");
    Scr_MakeArray(scrContext);
    goto LABEL_12;
  }
  if ( Scr_GetNumParam(scrContext) >= 4 )
  {
    Scr_GetVector(scrContext, 2u, &vectorValue);
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
    __asm { vmovaps xmm6, xmm0 }
  }
  if ( !Scr_GetNumParam(scrContext) )
  {
LABEL_20:
    Scr_GetGenericEntArray(scrContext, qbOnlyScriptables);
    goto LABEL_12;
  }
  NumParam = Scr_GetNumParam(scrContext);
  v10 = NumParam <= 2;
  if ( NumParam < 2 || (Type = Scr_GetType(scrContext, 0), v10 = Type == VAR_UNDEFINED, Type == VAR_UNDEFINED) || (v12 = Scr_GetType(scrContext, 1u), v10 = v12 == VAR_UNDEFINED, v12 == VAR_UNDEFINED) )
  {
    __asm { vcomiss xmm6, xmm7 }
    if ( !v10 )
    {
      __asm { vmovaps xmm3, xmm6; radius }
      Scr_GetGenericEntArray(scrContext, qbOnlyScriptables, &vectorValue, *(float *)&_XMM3);
      goto LABEL_12;
    }
    goto LABEL_20;
  }
  ConstString = Scr_GetConstString(scrContext, 0);
  String = Scr_GetString(scrContext, 1u);
  Offset = Scr_GetOffset(scrContext, ENTITY_CLASS_GENTITY, String);
  if ( Offset < 0 )
  {
    v16 = j_va("key '%s' does not internally belong to entities", String);
    v17 = scrContext;
    v18 = COM_ERR_4675;
LABEL_11:
    Scr_ParamError(v18, v17, 1u, v16);
    goto LABEL_12;
  }
  if ( (Offset & 0xE000) != 0 )
  {
    v16 = j_va("key '%s' does not internally belong to generic entities", String);
    v17 = scrContext;
    v18 = COM_ERR_4676;
    goto LABEL_11;
  }
  __asm { vcomiss xmm6, xmm7 }
  if ( (Offset & 0xE000) != 0 )
  {
    __asm { vmovss  [rsp+88h+var_60], xmm6 }
    Scr_GetGenericEntArray(scrContext, Offset, ConstString, qbOnlyScriptables, &vectorValue, v22);
  }
  else
  {
    Scr_GetGenericEntArray(scrContext, Offset, ConstString, qbOnlyScriptables);
  }
LABEL_12:
  __asm
  {
    vmovaps xmm6, [rsp+88h+var_28]
    vmovaps xmm7, [rsp+88h+var_38]
  }
}

/*
==============
Scr_GetExploderID
==============
*/
char Scr_GetExploderID(scrContext_t *scrContext, unsigned int *outExploderID)
{
  const char *String; 
  unsigned int v6; 
  const char *v7; 
  const dvar_t *v8; 
  __int64 v9; 
  unsigned int exploderNameTotal; 
  scr_string_t *exploderNames; 

  if ( Scr_GetType(scrContext, 0) == VAR_INTEGER )
  {
    *outExploderID = Scr_GetInt(scrContext, 0);
    return 1;
  }
  if ( Scr_GetType(scrContext, 0) != VAR_STRING && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 23518, ASSERT_TYPE_ASSERT, "(Scr_GetType( scrContext, 0 ) == VAR_STRING)", (const char *)&queryFormat, "Scr_GetType( scrContext, 0 ) == VAR_STRING") )
    __debugbreak();
  if ( !cm.mapEnts->createFxEffectTotal && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 23519, ASSERT_TYPE_ASSERT, "(cm.mapEnts->createFxEffectTotal > 0)", (const char *)&queryFormat, "cm.mapEnts->createFxEffectTotal > 0") )
    __debugbreak();
  String = Scr_GetString(scrContext, 0);
  v6 = SL_FindString(String);
  if ( !v6 )
  {
    v7 = j_va("Failed to find script string for exploder name '%s'", String);
    Scr_Error(COM_ERR_4656, scrContext, v7);
  }
  if ( CG_CreateFx_HasBeenEnabled() )
    goto LABEL_26;
  v8 = DCONST_DVARBOOL_developer_createfx;
  if ( !DCONST_DVARBOOL_developer_createfx && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "developer_createfx") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v8);
  if ( v8->current.enabled )
  {
LABEL_26:
    *outExploderID = v6;
  }
  else
  {
    v9 = 0i64;
    exploderNameTotal = cm.mapEnts->exploderNameTotal;
    if ( !exploderNameTotal )
      goto LABEL_20;
    exploderNames = cm.mapEnts->exploderNames;
    while ( *exploderNames != v6 )
    {
      v9 = (unsigned int)(v9 + 1);
      ++exploderNames;
      if ( (unsigned int)v9 >= exploderNameTotal )
        goto LABEL_20;
    }
    if ( (_DWORD)v9 == exploderNameTotal )
    {
LABEL_20:
      Com_PrintWarning(24, "Warning: exploder name '%s' not found in mapents exploder data\n", String);
      return 0;
    }
    if ( cm.mapEnts->exploderNames[v9] != v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 23550, ASSERT_TYPE_ASSERT, "(cm.mapEnts->exploderNames[foundIndex] == exploderScriptName)", (const char *)&queryFormat, "cm.mapEnts->exploderNames[foundIndex] == exploderScriptName") )
      __debugbreak();
    *outExploderID = v9;
  }
  return 1;
}

/*
==============
Scr_GetNoTarget
==============
*/
void Scr_GetNoTarget(scrContext_t *scrContext, gentity_s *ent, int offset)
{
  Scr_AddInt(scrContext, (ent->flags.m_flags[0] >> 2) & 1);
}

/*
==============
Scr_GetTeamFlag
==============
*/
bitarray<224> *Scr_GetTeamFlag(bitarray<224> *result, scrContext_t *scrContext, scr_string_t teamName)
{
  unsigned int v9; 
  bitarray<224> *v10; 
  const char *v14; 
  const char *v15; 
  team_t outTeam[10]; 

  _RBX = result;
  if ( teamName == scr_const.all )
  {
    if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_WEAPON_DROP|0x80) )
      _RAX = Com_TeamsSP_GetAllTeamFlags();
    else
      _RAX = Com_TeamsMP_GetAllTeamFlags();
    __asm
    {
      vmovups xmm0, xmmword ptr [rax]
      vmovups xmmword ptr [rbx], xmm0
      vmovsd  xmm1, qword ptr [rax+10h]
      vmovsd  qword ptr [rbx+10h], xmm1
    }
    v9 = _RAX->array[6];
    v10 = _RBX;
    _RBX->array[6] = v9;
  }
  else if ( teamName == scr_const.bad_guys )
  {
    if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_WEAPON_DROP|0x80) )
      _RAX = Com_TeamsSP_GetBadGuyTeamFlags();
    else
      _RAX = Com_TeamsMP_GetBadGuyTeamFlags();
    __asm
    {
      vmovups xmm0, xmmword ptr [rax]
      vmovups xmmword ptr [rbx], xmm0
      vmovsd  xmm1, qword ptr [rax+10h]
      vmovsd  qword ptr [rbx+10h], xmm1
    }
    _RBX->array[6] = _RAX->array[6];
    return _RBX;
  }
  else
  {
    if ( Com_Teams_TeamFromString(teamName, outTeam) )
    {
      Com_Teams_GetTeamFlag(_RBX, outTeam[0]);
    }
    else
    {
      v14 = SL_ConvertToString(teamName);
      v15 = j_va("unknown team '%s'", v14);
      Scr_Error(COM_ERR_3945, scrContext, v15);
      _RBX->array[0] = 0x80000000;
      *(_QWORD *)&_RBX->array[1] = 0i64;
      *(_QWORD *)&_RBX->array[3] = 0i64;
      *(_QWORD *)&_RBX->array[5] = 0i64;
    }
    return _RBX;
  }
  return v10;
}

/*
==============
Scr_GetTeamFlags
==============
*/
bitarray<224> *Scr_GetTeamFlags(bitarray<224> *result, scrContext_t *scrContext, unsigned int i)
{
  unsigned int v4; 
  scr_string_t ConstString; 
  scr_string_t v7; 
  const bitarray<224> *BadGuyTeamFlags; 
  const char *v9; 
  const char *v10; 
  int v11; 
  int v12; 
  int v13; 
  int v14; 
  int v15; 
  int v16; 
  unsigned int v17; 
  unsigned __int64 v18; 
  const bitarray<224> *AllTeamFlags; 
  __int64 v21; 
  __int64 v22; 
  team_t outTeam; 
  __int64 v24; 
  __int64 v25; 
  __int64 v26; 
  int v27; 

  *(_QWORD *)result->array = 0i64;
  v4 = i;
  *(_QWORD *)&result->array[2] = 0i64;
  *(_QWORD *)&result->array[4] = 0i64;
  result->array[6] = 0;
  if ( i < Scr_GetNumParam(scrContext) )
  {
    while ( 1 )
    {
      ConstString = Scr_GetConstString(scrContext, v4);
      v7 = ConstString;
      if ( ConstString == scr_const.all )
        break;
      if ( ConstString == scr_const.bad_guys )
      {
        if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_WEAPON_DROP|0x80) )
          BadGuyTeamFlags = Com_TeamsSP_GetBadGuyTeamFlags();
        else
          BadGuyTeamFlags = Com_TeamsMP_GetBadGuyTeamFlags();
        result->array[0] |= BadGuyTeamFlags->array[0];
        result->array[1] |= BadGuyTeamFlags->array[1];
        result->array[2] |= BadGuyTeamFlags->array[2];
        result->array[3] |= BadGuyTeamFlags->array[3];
        result->array[4] |= BadGuyTeamFlags->array[4];
        result->array[5] |= BadGuyTeamFlags->array[5];
        result->array[6] |= BadGuyTeamFlags->array[6];
      }
      else
      {
        if ( Com_Teams_TeamFromString(ConstString, &outTeam) )
        {
          v18 = (unsigned int)outTeam;
          v24 = 0i64;
          v25 = 0i64;
          v26 = 0i64;
          v27 = 0;
          if ( (unsigned int)outTeam >= (TEAM_HUNDRED_NINETY_TWO|TEAM_THIRTY_TWO) )
          {
            LODWORD(v22) = 224;
            LODWORD(v21) = outTeam;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 263, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v21, v22) )
              __debugbreak();
          }
          *((_DWORD *)&v24 + (v18 >> 5)) |= 0x80000000 >> (v18 & 0x1F);
          v16 = v27;
          v15 = HIDWORD(v26);
          v14 = v26;
          v13 = HIDWORD(v25);
          v12 = v25;
          v11 = HIDWORD(v24);
          v17 = v24;
        }
        else
        {
          v9 = SL_ConvertToString(v7);
          v10 = j_va("unknown team '%s'", v9);
          Scr_Error(COM_ERR_3945, scrContext, v10);
          v11 = 0;
          v12 = 0;
          v13 = 0;
          v14 = 0;
          v15 = 0;
          v16 = 0;
          v17 = 0x80000000;
        }
        result->array[0] |= v17;
        result->array[1] |= v11;
        result->array[2] |= v12;
        result->array[3] |= v13;
        result->array[4] |= v14;
        result->array[5] |= v15;
        result->array[6] |= v16;
      }
      if ( ++v4 >= Scr_GetNumParam(scrContext) )
        return result;
    }
    if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_WEAPON_DROP|0x80) )
      AllTeamFlags = Com_TeamsSP_GetAllTeamFlags();
    else
      AllTeamFlags = Com_TeamsMP_GetAllTeamFlags();
    result->array[0] |= AllTeamFlags->array[0];
    result->array[1] |= AllTeamFlags->array[1];
    result->array[2] |= AllTeamFlags->array[2];
    result->array[3] |= AllTeamFlags->array[3];
    result->array[4] |= AllTeamFlags->array[4];
    result->array[5] |= AllTeamFlags->array[5];
    result->array[6] |= AllTeamFlags->array[6];
  }
  return result;
}

/*
==============
Scr_IsTouchingInternal
==============
*/
int Scr_IsTouchingInternal(scrContext_t *scrContext, const gentity_s *ent1, const gentity_s *ent2)
{
  const gentity_s *v5; 
  bool v8; 
  bool v9; 
  const char *v11; 
  bool v18; 
  const char *v19; 
  bool v26; 
  const char *v27; 
  unsigned int Instance; 
  __int64 v51; 
  double v52; 
  double v53; 
  double v54; 
  double v55; 
  double v56; 
  double v57; 
  double v58; 
  double v59; 
  double v60; 
  bool result; 
  Bounds bounds; 

  v5 = ent1;
  if ( G_Vehicle_IsTouching(scrContext, ent1, ent2, &result) )
    return result;
  v8 = v5->r.modelType == 0;
  __asm { vmovaps [rsp+0B8h+var_28], xmm6 }
  if ( v8 || v5->vehicle )
  {
    _RBX = v5;
    v5 = ent2;
  }
  else
  {
    _RBX = ent2;
  }
  v8 = _RBX == NULL;
  if ( !_RBX )
  {
    v9 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 3449, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent");
    v8 = !v9;
    if ( v9 )
      __debugbreak();
  }
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vcomiss xmm6, dword ptr [rbx+10Ch]
  }
  if ( !v8 )
  {
    v11 = SL_ConvertToString(_RBX->classname);
    __asm
    {
      vmovss  xmm0, dword ptr [rbx+138h]
      vmovss  xmm1, dword ptr [rbx+134h]
      vmovss  xmm2, dword ptr [rbx+130h]
      vcvtss2sd xmm0, xmm0, xmm0
      vmovsd  [rsp+0B8h+var_70], xmm0
      vcvtss2sd xmm1, xmm1, xmm1
      vmovsd  [rsp+0B8h+var_78], xmm1
      vcvtss2sd xmm2, xmm2, xmm2
      vmovsd  [rsp+0B8h+var_80], xmm2
    }
    v18 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 3450, ASSERT_TYPE_ASSERT, "(ent->r.box.halfSize[0] >= 0.0f)", "%s\n\tentnum: %d, origin: %g %g %g, classname: %s", "ent->r.box.halfSize[0] >= 0.0f", _RBX->s.number, v52, v55, v58, v11);
    v8 = !v18;
    if ( v18 )
      __debugbreak();
  }
  __asm { vcomiss xmm6, dword ptr [rbx+110h] }
  if ( !v8 )
  {
    v19 = SL_ConvertToString(_RBX->classname);
    __asm
    {
      vmovss  xmm0, dword ptr [rbx+138h]
      vmovss  xmm1, dword ptr [rbx+134h]
      vmovss  xmm2, dword ptr [rbx+130h]
      vcvtss2sd xmm0, xmm0, xmm0
      vmovsd  [rsp+0B8h+var_70], xmm0
      vcvtss2sd xmm1, xmm1, xmm1
      vmovsd  [rsp+0B8h+var_78], xmm1
      vcvtss2sd xmm2, xmm2, xmm2
      vmovsd  [rsp+0B8h+var_80], xmm2
    }
    LODWORD(v51) = _RBX->s.number;
    v26 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 3451, ASSERT_TYPE_ASSERT, "(ent->r.box.halfSize[1] >= 0.0f)", "%s\n\tentnum: %d, origin: %g %g %g, classname: %s", "ent->r.box.halfSize[1] >= 0.0f", v51, v53, v56, v59, v19);
    v8 = !v26;
    if ( v26 )
      __debugbreak();
  }
  __asm { vcomiss xmm6, dword ptr [rbx+114h] }
  if ( !v8 )
  {
    v27 = SL_ConvertToString(_RBX->classname);
    __asm
    {
      vmovss  xmm0, dword ptr [rbx+138h]
      vmovss  xmm1, dword ptr [rbx+134h]
      vmovss  xmm2, dword ptr [rbx+130h]
      vcvtss2sd xmm0, xmm0, xmm0
      vmovsd  [rsp+0B8h+var_70], xmm0
      vcvtss2sd xmm1, xmm1, xmm1
      vmovsd  [rsp+0B8h+var_78], xmm1
      vcvtss2sd xmm2, xmm2, xmm2
      vmovsd  [rsp+0B8h+var_80], xmm2
    }
    LODWORD(v51) = _RBX->s.number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 3452, ASSERT_TYPE_ASSERT, "(ent->r.box.halfSize[2] >= 0.0f)", "%s\n\tentnum: %d, origin: %g %g %g, classname: %s", "ent->r.box.halfSize[2] >= 0.0f", v51, v54, v57, v60, v27) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+100h]
    vaddss  xmm1, xmm0, dword ptr [rbx+130h]
    vmovss  xmm2, dword ptr [rbx+104h]
    vaddss  xmm0, xmm2, dword ptr [rbx+134h]
    vmovss  xmm3, dword ptr [rbx+10Ch]
    vcomiss xmm3, xmm6
    vmovss  dword ptr [rsp+0B8h+bounds.midPoint], xmm1
    vmovss  xmm1, dword ptr [rbx+108h]
    vaddss  xmm2, xmm1, dword ptr [rbx+138h]
    vmovss  xmm1, dword ptr [rbx+114h]
    vmovss  dword ptr [rsp+0B8h+bounds.midPoint+4], xmm0
    vmovss  xmm0, dword ptr [rbx+110h]
    vmovss  dword ptr [rsp+0B8h+bounds.halfSize+8], xmm1
    vmovss  dword ptr [rsp+0B8h+bounds.midPoint+8], xmm2
    vmovss  dword ptr [rsp+0B8h+bounds.halfSize], xmm3
    vmovss  dword ptr [rsp+0B8h+bounds.halfSize+4], xmm0
    vmovss  xmm0, dword ptr [rsp+0B8h+bounds.halfSize+4]
    vcomiss xmm0, xmm6
    vmovss  xmm0, dword ptr [rsp+0B8h+bounds.halfSize+8]
    vcomiss xmm0, xmm6
    vmovaps xmm6, [rsp+0B8h+var_28]
    vmovss  xmm0, dword ptr [rsp+0B8h+bounds.halfSize+4]
    vmaxss  xmm1, xmm0, dword ptr [rsp+0B8h+bounds.halfSize]
    vmovss  xmm0, dword ptr [rsp+0B8h+bounds.halfSize+8]
    vmovss  dword ptr [rsp+0B8h+bounds.halfSize], xmm1
    vmovss  dword ptr [rsp+0B8h+bounds.halfSize+4], xmm1
    vmaxss  xmm1, xmm0, xmm1
    vmovss  dword ptr [rsp+0B8h+bounds.halfSize+8], xmm1
  }
  Instance = G_PhysicsObject_GetInstance(PHYSICS_WORLD_ID_FIRST, v5);
  return PhysicsQuery_LegacyEntityContactCapsule(PHYSICS_WORLD_ID_FIRST, &bounds, Instance, v5);
}

/*
==============
Scr_LocalizationError
==============
*/
void Scr_LocalizationError(scrContext_t *scrContext, int iParm, const char *pszErrorMessage)
{
  Scr_ParamError(COM_ERR_3953, scrContext, iParm, pszErrorMessage);
}

/*
==============
Scr_PlayFXInternal
==============
*/
gentity_s *Scr_PlayFXInternal(scrContext_t *scrContext, int fxId, const vec3_t *pos, vec3_t *forward, vec3_t *up)
{
  const char *v12; 
  gentity_s *v13; 
  tmat33_t<vec3_t> vec; 

  _RBP = forward;
  if ( !FX_IsValidFxId(fxId) )
  {
    v12 = j_va("Scr_PlayFX: invalid effect id %d", (unsigned int)fxId);
    Scr_Error(COM_ERR_4330, scrContext, v12);
  }
  G_Debug_LogFxInfo(pos, fxId, (const scr_string_t)0);
  v13 = G_Utils_SpawnEventEntity(pos, 122);
  if ( v13->s.lerp.apos.trType && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 15002, ASSERT_TYPE_SANITY, "( ent->s.lerp.apos.trType == TR_STATIONARY )", (const char *)&queryFormat, "ent->s.lerp.apos.trType == TR_STATIONARY") )
    __debugbreak();
  v13->s.eventParm2 = 0;
  v13->s.eventParm = fxId;
  if ( _RBP )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rbp+4]
      vmovss  xmm5, dword ptr [rbp+0]
      vmovss  xmm3, dword ptr [rbp+8]
      vmulss  xmm1, xmm0, xmm0
      vmovss  dword ptr [rsp+0B8h+vec+4], xmm0
      vmulss  xmm0, xmm5, xmm5
      vaddss  xmm2, xmm1, xmm0
      vmulss  xmm1, xmm3, xmm3
      vaddss  xmm2, xmm2, xmm1
      vsqrtss xmm4, xmm2, xmm2
      vcmpless xmm0, xmm4, cs:__real@80000000
      vmovaps [rsp+0B8h+var_48], xmm7
      vmovss  xmm7, cs:__real@3f800000
      vblendvps xmm0, xmm4, xmm7, xmm0
      vdivss  xmm2, xmm7, xmm0
      vmulss  xmm0, xmm5, xmm2
      vmovss  dword ptr [rbp+0], xmm0
      vmulss  xmm1, xmm2, dword ptr [rbp+4]
      vmovss  dword ptr [rbp+4], xmm1
      vmulss  xmm0, xmm2, dword ptr [rbp+8]
      vmovaps [rsp+0B8h+var_58], xmm9
      vxorps  xmm9, xmm9, xmm9
      vucomiss xmm4, xmm9
      vmovss  dword ptr [rbp+8], xmm0
      vmovss  dword ptr [rsp+0B8h+vec], xmm5
      vmovss  dword ptr [rsp+0B8h+vec+8], xmm3
    }
    _RAX = up;
    if ( up )
    {
      __asm
      {
        vmovss  xmm4, dword ptr [rax]
        vmovss  xmm5, dword ptr [rax+4]
        vmulss  xmm0, xmm4, xmm4
        vmulss  xmm1, xmm5, xmm5
        vaddss  xmm2, xmm1, xmm0
        vmovaps [rsp+0B8h+var_38], xmm6
        vmovss  xmm6, dword ptr [rax+8]
        vmulss  xmm1, xmm6, xmm6
        vaddss  xmm2, xmm2, xmm1
        vsqrtss xmm3, xmm2, xmm2
        vucomiss xmm3, xmm9
        vcmpless xmm0, xmm3, cs:__real@80000000
        vblendvps xmm0, xmm3, xmm7, xmm0
        vdivss  xmm2, xmm7, xmm0
        vmulss  xmm0, xmm2, xmm4
        vmovss  [rsp+0B8h+var_70], xmm0
        vmulss  xmm0, xmm2, xmm6
        vmovaps xmm6, [rsp+0B8h+var_38]
        vmulss  xmm1, xmm2, xmm5
        vmovss  [rsp+0B8h+var_68], xmm0
        vmovss  [rsp+0B8h+var_6C], xmm1
      }
      Scr_SetFxAngles(scrContext, 2, &vec, &v13->s.lerp.apos.trBase, fxId);
    }
    else
    {
      vectoangles(vec.m, &v13->s.lerp.apos.trBase);
    }
    __asm
    {
      vmovaps xmm7, [rsp+0B8h+var_48]
      vmovaps xmm9, [rsp+0B8h+var_58]
    }
  }
  return v13;
}

/*
==============
Scr_PlayFxOnTagInternal
==============
*/
void Scr_PlayFxOnTagInternal(scrContext_t *scrContext, gentity_s *ent, const unsigned int fxId, scr_string_t tag, int onlyClientIndex)
{
  const char *v9; 
  const char *v10; 
  int BoneIndex; 
  const char *ModelName; 
  const char *v13; 
  const char *v14; 
  unsigned int FxEventParam; 
  unsigned int v16; 
  vec3_t trBase; 

  if ( !FX_IsValidFxId(fxId) )
  {
    v9 = j_va("effect id %i is invalid\n", fxId);
    Scr_ParamError(COM_ERR_4333, scrContext, 0, v9);
  }
  v10 = SL_ConvertToString(tag);
  if ( strchr_0(v10, 34) )
    Scr_ParamError(COM_ERR_4334, scrContext, 2u, "cannot use \" characters in tag names\n");
  BoneIndex = SV_Game_DObjGetBoneIndex(ent, tag);
  if ( BoneIndex < 0 )
  {
    SV_Game_DObjDumpInfo(ent);
    ModelName = G_CString_GetModelName(ent->model);
    v13 = SL_ConvertToString(tag);
    v14 = j_va("tag '%s' does not exist on entity with model '%s'", v13, ModelName);
    Scr_ParamError(COM_ERR_4335, scrContext, 2u, v14);
  }
  FxEventParam = Scr_GetFxEventParam(fxId, BoneIndex, onlyClientIndex);
  v16 = 127;
  if ( onlyClientIndex == -1 )
    v16 = 124;
  G_Utils_AddEvent(ent, v16, FxEventParam);
  Trajectory_GetTrBase(&ent->s.lerp.pos, &trBase);
  G_Debug_LogFxInfo(&trBase, fxId, tag);
  memset(&trBase, 0, sizeof(trBase));
}

/*
==============
Scr_PlayRumbleOnPosition_Internal
==============
*/
gentity_s *Scr_PlayRumbleOnPosition_Internal(scrContext_t *scrContext, int event)
{
  const char *String; 
  const char *v5; 
  gentity_s *result; 
  unsigned int outIndex; 
  vec3_t vectorValue; 

  String = Scr_GetString(scrContext, 0);
  if ( !NetConstStrings_GetIndexFromName(NETCONSTSTRINGTYPE_RUMBLE, String, &outIndex) )
  {
    v5 = j_va("unknown rumble name '%s'", String);
    Scr_ParamError(COM_ERR_4286, scrContext, 0, v5);
  }
  Scr_GetVector(scrContext, 1u, &vectorValue);
  result = G_Utils_SpawnEventEntity(&vectorValue, event);
  result->s.eventParm2 = 0;
  result->s.eventParm = outIndex;
  return result;
}

/*
==============
Scr_SBPreScanArray
==============
*/
int *Scr_SBPreScanArray(GScr_ScriptBundleContext *ctxt, ScriptBundleValue *arr)
{
  int *v2; 
  int i; 
  ScriptBundleValue *v6; 
  bool v7; 

  v2 = (int *)&arr[1];
  if ( arr->type != SCR_SB_ARRAY && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 26142, ASSERT_TYPE_ASSERT, "(arr->type == ScriptBundleValue::ValueType::SCR_SB_ARRAY)", (const char *)&queryFormat, "arr->type == ScriptBundleValue::ValueType::SCR_SB_ARRAY") )
    __debugbreak();
  for ( i = 0; i < arr->string; ++i )
  {
    v6 = (ScriptBundleValue *)v2;
    v2 += 2;
    switch ( v6->type )
    {
      case SCR_B_NONE:
      case SCR_SB_BOOL:
      case SCR_SB_INT:
      case SCR_SB_FLOAT:
      case SCR_SB_STRING:
      case SCR_SB_ANIMTREE:
        continue;
      case SCR_SB_OBJECT:
        v2 = Scr_SBPreScanObject(ctxt, v6);
        break;
      case SCR_SB_ARRAY:
        v2 = Scr_SBPreScanArray(ctxt, v6);
        break;
      case SCR_SB_ANIMATION:
        v7 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 26177, ASSERT_TYPE_ASSERT, "(!\"Script Bundle schema error - SCR_SB_ANIMATION in array???\")", (const char *)&queryFormat, "!\"Script Bundle schema error - SCR_SB_ANIMATION in array???\"");
        goto LABEL_11;
      case SCR_SB_ANIMTREEID:
        v6->string = Scr_FindAnimTreeID(&ctxt->strPool[v6->string], ctxt->anim_user);
        v6->type = SCR_SB_INT;
        break;
      default:
        v7 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 26180, ASSERT_TYPE_ASSERT, "(!\"Script Bundle parse error\")", (const char *)&queryFormat, "!\"Script Bundle parse error\"");
LABEL_11:
        if ( v7 )
          __debugbreak();
        break;
    }
  }
  return v2;
}

/*
==============
Scr_SBPreScanObject
==============
*/
int *Scr_SBPreScanObject(GScr_ScriptBundleContext *ctxt, ScriptBundleValue *obj)
{
  int *v4; 
  int v6; 
  int *v7; 
  scr_anim_t *v8; 

  _RSI = ctxt;
  v4 = (int *)&obj[1];
  if ( obj->type != SCR_SB_OBJECT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 26085, ASSERT_TYPE_ASSERT, "(obj->type == ScriptBundleValue::ValueType::SCR_SB_OBJECT)", (const char *)&queryFormat, "obj->type == ScriptBundleValue::ValueType::SCR_SB_OBJECT", -2i64) )
    __debugbreak();
  __asm
  {
    vmovups ymm0, ymmword ptr [rsi]
    vmovups [rsp+0A8h+var_70], ymm0
    vmovups [rsp+0A8h+var_48], ymm0
  }
  v6 = 0;
  if ( obj->string > 0 )
  {
    do
    {
      v7 = v4;
      v4 += 3;
      switch ( *((_BYTE *)v7 + 4) )
      {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
          break;
        case 5:
          v4 = Scr_SBPreScanObject(_RSI, (ScriptBundleValue *)(v7 + 1));
          break;
        case 6:
          v4 = Scr_SBPreScanArray(_RSI, (ScriptBundleValue *)(v7 + 1));
          break;
        case 7:
          v8 = (scr_anim_t *)(v4 + 1);
          if ( ((unsigned __int8)v4 & 4) == 0 )
            v8 = (scr_anim_t *)v4;
          Scr_FindAnim(_RSI->currentAnimTree, &_RSI->strPool[v7[2]], v8, _RSI->anim_user);
          v4 += 3;
          break;
        case 8:
          _RSI->currentAnimTree = &_RSI->strPool[v7[2]];
          break;
        case 9:
          v7[2] = Scr_FindAnimTreeID(&_RSI->strPool[v7[2]], _RSI->anim_user);
          *((_BYTE *)v7 + 4) = 2;
          break;
        default:
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 26129, ASSERT_TYPE_ASSERT, "(!\"Script Bundle prescan error\")", (const char *)&queryFormat, "!\"Script Bundle prescan error\"") )
            __debugbreak();
          break;
      }
      ++v6;
    }
    while ( v6 < obj->string );
    __asm { vmovups ymm0, [rsp+0A8h+var_70] }
  }
  __asm { vmovups ymmword ptr [rsi], ymm0 }
  return v4;
}

/*
==============
Scr_SetAngles
==============
*/
void Scr_SetAngles(scrContext_t *scrContext, gentity_s *ent, int offset)
{
  vec3_t vectorValue; 

  if ( ent->actor )
    Scr_Error(COM_ERR_4529, scrContext, "cannot directly set the angles on AI.  Use the teleport command instead.\n");
  if ( ent->s.lerp.apos.trType == TR_ANIMATED_MOVER )
  {
    if ( !Com_GameMode_SupportsFeature(WEAPON_DROPPING_ALT) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_trajectory.h", 90, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::ANIMATED_TRAJECTORIES ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::ANIMATED_TRAJECTORIES )") )
      __debugbreak();
    Scr_Error(COM_ERR_4530, scrContext, "Cannot set an entity's angles while it is playing a delta animation. Call scriptmodelclearanim first.\n");
    Sys_ProfEndNamedEvent();
  }
  else
  {
    Scr_GetVector(scrContext, 0, &vectorValue);
    if ( G_SetAngle(ent, &vectorValue, 1, 0) )
    {
      Physics_SetBroadphaseNeedsRefresh(PHYSICS_WORLD_ID_FIRST, 1);
      Physics_SetBroadphaseNeedsRefresh(PHYSICS_WORLD_ID_SERVER_DETAIL, 1);
    }
    if ( ent->r.isLinked )
      SV_LinkEntity(ent);
  }
}

/*
==============
Scr_SetFxAngles
==============
*/
void Scr_SetFxAngles(scrContext_t *scrContext, int givenAxisCount, tmat33_t<vec3_t> *inOutAxis, vec3_t *outAngles)
{
  int v9; 
  const char *v40; 

  _RDI = inOutAxis;
  if ( (unsigned int)givenAxisCount > 2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 14895, ASSERT_TYPE_ASSERT, "( 0 ) <= ( givenAxisCount ) && ( givenAxisCount ) <= ( 2 )", "givenAxisCount not in [0, 2]\n\t%i not in [%i, %i]", givenAxisCount, 0i64, 2) )
    __debugbreak();
  v9 = givenAxisCount - 1;
  if ( v9 )
  {
    if ( v9 == 1 )
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rdi+4]
        vmulss  xmm1, xmm0, dword ptr [rdi+1Ch]
        vmovaps [rsp+58h+var_18], xmm6
        vmovss  xmm6, dword ptr [rdi+18h]
        vmulss  xmm2, xmm6, dword ptr [rdi]
        vaddss  xmm3, xmm2, xmm1
        vmovss  xmm2, dword ptr [rdi+20h]
        vmulss  xmm0, xmm2, dword ptr [rdi+8]
        vaddss  xmm1, xmm3, xmm0
        vxorps  xmm4, xmm1, cs:__xmm@80000000800000008000000080000000
        vmulss  xmm2, xmm4, dword ptr [rdi]
        vaddss  xmm5, xmm2, xmm6
        vmovaps xmm6, [rsp+58h+var_18]
        vmovss  dword ptr [rdi+18h], xmm5
        vmulss  xmm0, xmm4, dword ptr [rdi+4]
        vaddss  xmm2, xmm0, dword ptr [rdi+1Ch]
        vmovss  dword ptr [rdi+1Ch], xmm2
        vmulss  xmm1, xmm4, dword ptr [rdi+8]
        vaddss  xmm3, xmm1, dword ptr [rdi+20h]
        vmovss  dword ptr [rdi+20h], xmm3
        vmulss  xmm1, xmm5, dword ptr [rdi+18h]
        vmulss  xmm0, xmm2, xmm2
        vaddss  xmm2, xmm1, xmm0
        vmulss  xmm1, xmm3, xmm3
        vaddss  xmm2, xmm2, xmm1
        vmovss  xmm1, cs:__real@3f800000
        vsqrtss xmm5, xmm2, xmm2
        vcmpless xmm0, xmm5, cs:__real@80000000
        vblendvps xmm0, xmm5, xmm1, xmm0
        vdivss  xmm2, xmm1, xmm0
        vmulss  xmm0, xmm2, dword ptr [rdi+18h]
        vmovss  dword ptr [rdi+18h], xmm0
        vmulss  xmm1, xmm2, dword ptr [rdi+1Ch]
        vmovss  dword ptr [rdi+1Ch], xmm1
        vmulss  xmm0, xmm2, dword ptr [rdi+20h]
        vxorps  xmm1, xmm1, xmm1
        vucomiss xmm5, xmm1
        vmovss  dword ptr [rdi+20h], xmm0
      }
      v40 = j_va("forward and up vectors are the same direction or exact opposite directions");
      Scr_Error(COM_ERR_4326, scrContext, v40);
      Vec3Cross(&_RDI->m[2], _RDI->m, &_RDI->m[1]);
      AxisToAngles(_RDI, outAngles);
    }
  }
  else
  {
    vectoangles(_RDI->m, outAngles);
  }
}

/*
==============
Scr_SetOrigin
==============
*/
void Scr_SetOrigin(scrContext_t *scrContext, gentity_s *ent, int offset)
{
  sentient_s *sentient; 
  int v9; 
  int v10; 
  int v11; 
  vec3_t vectorValue; 

  if ( ent->actor )
    Scr_Error(COM_ERR_4526, scrContext, "cannot directly set the origin on AI.  Use the teleport command instead.\n");
  Scr_GetVector(scrContext, 0, &vectorValue);
  __asm
  {
    vmovss  xmm0, dword ptr [rsp+58h+vectorValue]
    vmovss  [rsp+58h+var_28], xmm0
  }
  if ( (v9 & 0x7F800000) == 2139095040 )
    goto LABEL_6;
  __asm
  {
    vmovss  xmm0, dword ptr [rsp+58h+vectorValue+4]
    vmovss  [rsp+58h+var_28], xmm0
  }
  if ( (v10 & 0x7F800000) == 2139095040 )
    goto LABEL_6;
  __asm
  {
    vmovss  xmm0, dword ptr [rsp+58h+vectorValue+8]
    vmovss  [rsp+58h+var_28], xmm0
  }
  if ( (v11 & 0x7F800000) == 2139095040 )
LABEL_6:
    Scr_Error(COM_ERR_4527, scrContext, "origin being set to NAN.");
  if ( ent->s.lerp.pos.trType == TR_ANIMATED_MOVER )
  {
    if ( !Com_GameMode_SupportsFeature(WEAPON_DROPPING_ALT) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_trajectory.h", 90, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::ANIMATED_TRAJECTORIES ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::ANIMATED_TRAJECTORIES )") )
      __debugbreak();
    Scr_Error(COM_ERR_4528, scrContext, "Cannot set an entity's origin while it is playing a delta animation. Call scriptmodelclearanim first.\n");
    Sys_ProfEndNamedEvent();
  }
  else
  {
    if ( G_SetOrigin(ent, &vectorValue, 1, 0) )
    {
      Physics_SetBroadphaseNeedsRefresh(PHYSICS_WORLD_ID_FIRST, 1);
      Physics_SetBroadphaseNeedsRefresh(PHYSICS_WORLD_ID_SERVER_DETAIL, 1);
    }
    sentient = ent->sentient;
    if ( sentient )
    {
      Sentient_InvalidateNearestNode(sentient);
      Sentient_InvalidateNearestTacPoint(ent->sentient);
    }
    if ( ent->r.isLinked )
      SV_LinkEntity(ent);
  }
}

/*
==============
Scr_StopFxOnTagInternal
==============
*/
void Scr_StopFxOnTagInternal(scrContext_t *scrContext, gentity_s *ent, const unsigned int fxId, scr_string_t tag, int onlyClientIndex)
{
  const char *v9; 
  const char *v10; 
  int BoneIndex; 
  const char *ModelName; 
  const char *v13; 
  const char *v14; 
  unsigned int FxEventParam; 
  unsigned int v16; 
  vec3_t trBase; 

  if ( !FX_IsValidFxId(fxId) )
  {
    v9 = j_va("effect id %i is invalid\n", fxId);
    Scr_ParamError(COM_ERR_4340, scrContext, 0, v9);
  }
  v10 = SL_ConvertToString(tag);
  if ( strchr_0(v10, 34) )
    Scr_ParamError(COM_ERR_4341, scrContext, 2u, "cannot use \" characters in tag names\n");
  BoneIndex = SV_Game_DObjGetBoneIndex(ent, tag);
  if ( BoneIndex < 0 )
  {
    SV_Game_DObjDumpInfo(ent);
    ModelName = G_CString_GetModelName(ent->model);
    v13 = SL_ConvertToString(tag);
    v14 = j_va("tag '%s' does not exist on entity with model '%s'", v13, ModelName);
    Scr_ParamError(COM_ERR_4342, scrContext, 2u, v14);
  }
  FxEventParam = Scr_GetFxEventParam(fxId, BoneIndex, onlyClientIndex);
  v16 = 128;
  if ( onlyClientIndex == -1 )
    v16 = 125;
  G_Utils_AddEvent(ent, v16, FxEventParam);
  Trajectory_GetTrBase(&ent->s.lerp.pos, &trBase);
  G_Debug_LogFxInfo(&trBase, fxId, tag);
  memset(&trBase, 0, sizeof(trBase));
}

/*
==============
Scr_ValidateLocalizedStringRef
==============
*/
void Scr_ValidateLocalizedStringRef(scrContext_t *scrContext, int parmIndex, const char *token, int tokenLen)
{
  __int64 v4; 
  __int64 v8; 
  const char *v9; 
  const char *v10; 

  v4 = tokenLen;
  if ( !token && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 1273, ASSERT_TYPE_ASSERT, "(token)", (const char *)&queryFormat, "token") )
    __debugbreak();
  if ( (int)v4 < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 1274, ASSERT_TYPE_ASSERT, "(tokenLen >= 0)", (const char *)&queryFormat, "tokenLen >= 0") )
    __debugbreak();
  v8 = v4;
  if ( v4 >= 2 )
  {
    v9 = token;
    do
    {
      if ( !isalnum(*v9) && *v9 != 95 && *v9 != 47 )
      {
        v10 = j_va("Illegal localized string reference: %s must contain only alpha-numeric characters and underscore or '/'", token);
        Scr_ParamError(COM_ERR_3954, scrContext, parmIndex, v10);
      }
      ++v9;
      --v8;
    }
    while ( v8 );
  }
}

/*
==============
Scr_VerifyWeapon
==============
*/
void Scr_VerifyWeapon(scrContext_t *scrContext, const Weapon *r_weapon, bool isAlternate, const char *weaponName)
{
  const char *v8; 
  ComErrorCode v9; 
  const char *v10; 
  char output[1024]; 

  if ( !weaponName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 1294, ASSERT_TYPE_ASSERT, "(weaponName)", (const char *)&queryFormat, "weaponName") )
    __debugbreak();
  if ( r_weapon->weaponIdx )
  {
    if ( !BG_IsValidWeapon(r_weapon, isAlternate) )
    {
      v10 = j_va("Weapon '%s' is does not define a valid weapon\n", weaponName);
      Scr_Error(COM_ERR_3957, scrContext, v10);
    }
    BG_GetWeaponNameComplete(r_weapon, isAlternate, output, 0x400u);
    if ( !BG_AreWeaponNamesEquivalent(output, weaponName) )
    {
      v8 = j_va("Asked for weapon \"%s\", but got weapon \"%s\" - check for missing or misspelled attachments, and make sure they are sorted alphabetically ", weaponName, output);
      v9 = COM_ERR_3958;
      goto LABEL_13;
    }
  }
  else if ( *weaponName && I_stricmp("none", weaponName) && I_stricmp("alt_none", weaponName) )
  {
    v8 = j_va("Unknown weapon name \"%s\": weapon may need to be added to the fast file. Or add attachments to the base weapon description.\n", weaponName);
    v9 = COM_ERR_3956;
LABEL_13:
    Scr_Error(v9, scrContext, v8);
  }
}

/*
==============
SetClientTriggerAudioZonePartial
==============
*/
void SetClientTriggerAudioZonePartial(scrContext_t *scrContext, scr_entref_t entref, const char *zoneName, int priorityIndex, const float fadetime, const int startParamIndex)
{
  int v6; 
  const char *v7; 
  unsigned int v8; 
  signed int v10; 
  int v11; 
  int NumParam; 
  const char *v13; 
  const char *String; 
  __int64 v15; 
  int v16; 
  __int64 v17; 
  int v18; 
  int v19; 
  int v20; 
  const char *v21; 
  const char *v22; 
  __int64 v23; 
  int v24; 
  __int64 v25; 
  int v26; 
  int v27; 
  int v28; 
  const char *v29; 
  __int64 v30; 
  int v31; 
  __int64 v32; 
  int v33; 
  int v34; 
  int v35; 
  const char *v36; 
  const char *v37; 
  const char *v40; 
  const char *v41; 
  SvClient *CommonClient; 
  char *fmt; 
  __int64 v44; 
  double v45; 
  int outControllingClientNum[4]; 
  unsigned int entnum; 

  entnum = entref.entnum;
  v6 = priorityIndex;
  v7 = zoneName;
  v8 = entref.entnum;
  v10 = startParamIndex;
  v11 = 0;
  NumParam = Scr_GetNumParam(scrContext);
  if ( startParamIndex < NumParam )
  {
    v13 = "reverb";
    do
    {
      String = Scr_GetString(scrContext, v10);
      v15 = 0x7FFFFFFFi64;
      if ( !String && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
        __debugbreak();
      while ( 1 )
      {
        v16 = (unsigned __int8)v13[String - "reverb"];
        v17 = v15;
        v18 = *(unsigned __int8 *)v13++;
        --v15;
        if ( !v17 )
        {
LABEL_14:
          v11 |= 1u;
          goto LABEL_15;
        }
        if ( v16 != v18 )
        {
          v19 = v16 + 32;
          if ( (unsigned int)(v16 - 65) > 0x19 )
            v19 = v16;
          v16 = v19;
          v20 = v18 + 32;
          if ( (unsigned int)(v18 - 65) > 0x19 )
            v20 = v18;
          if ( v16 != v20 )
            break;
        }
        if ( !v16 )
          goto LABEL_14;
      }
      v22 = "mix";
      v23 = 0x7FFFFFFFi64;
      if ( !String && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
        __debugbreak();
      while ( 1 )
      {
        v24 = (unsigned __int8)v22[String - "mix"];
        v25 = v23;
        v26 = *(unsigned __int8 *)v22++;
        --v23;
        if ( !v25 )
        {
LABEL_31:
          v11 |= 2u;
          goto LABEL_15;
        }
        if ( v24 != v26 )
        {
          v27 = v24 + 32;
          if ( (unsigned int)(v24 - 65) > 0x19 )
            v27 = v24;
          v24 = v27;
          v28 = v26 + 32;
          if ( (unsigned int)(v26 - 65) > 0x19 )
            v28 = v26;
          if ( v24 != v28 )
            break;
        }
        if ( !v24 )
          goto LABEL_31;
      }
      v29 = "filter";
      v30 = 0x7FFFFFFFi64;
      if ( !String && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
        __debugbreak();
      while ( 1 )
      {
        v31 = (unsigned __int8)v29[String - "filter"];
        v32 = v30;
        v33 = *(unsigned __int8 *)v29++;
        --v30;
        if ( !v32 )
        {
LABEL_43:
          v11 |= 4u;
          goto LABEL_15;
        }
        if ( v31 != v33 )
        {
          v34 = v31 + 32;
          if ( (unsigned int)(v31 - 65) > 0x19 )
            v34 = v31;
          v31 = v34;
          v35 = v33 + 32;
          if ( (unsigned int)(v33 - 65) > 0x19 )
            v35 = v33;
          if ( v31 != v35 )
            break;
        }
        if ( !v31 )
          goto LABEL_43;
      }
      if ( I_stricmp(String, "occlusion") )
      {
        if ( I_stricmp(String, "ambient") )
        {
          if ( I_stricmp(String, "ambient_events") )
          {
            if ( I_stricmp(String, "player_adsr") )
            {
              if ( I_stricmp(String, "weapon_reflection") )
              {
                if ( I_stricmp(String, "contexts") )
                {
                  if ( I_stricmp(String, "full_occlusion") )
                  {
                    v36 = j_va("SetClientTriggerAudioZonePartial: bad parameter: '%s'", String);
                    Scr_ParamError(COM_ERR_4807, scrContext, v10, v36);
                  }
                  else
                  {
                    v11 |= 0x200u;
                  }
                }
                else
                {
                  v11 |= 0x100u;
                }
              }
              else
              {
                v11 |= 0x80u;
              }
            }
            else
            {
              v11 |= 0x40u;
            }
          }
          else
          {
            v11 |= 0x20u;
          }
        }
        else
        {
          v11 |= 0x10u;
        }
      }
      else
      {
        v11 |= 8u;
      }
LABEL_15:
      ++v10;
      v13 = "reverb";
    }
    while ( v10 < NumParam );
    v8 = entnum;
    v6 = priorityIndex;
    v7 = zoneName;
  }
  outControllingClientNum[0] = v8;
  if ( !SV_IsAgent(v8) || SV_GetAgentControlledByPlayerNum(outControllingClientNum[0], outControllingClientNum) )
  {
    if ( outControllingClientNum[0] < level.maxclients )
    {
      __asm
      {
        vmovss  xmm0, [rsp+88h+fadetime]
        vcvtss2sd xmm0, xmm0, xmm0
        vmovsd  [rsp+88h+var_58], xmm0
      }
      LODWORD(v44) = v11;
      LODWORD(fmt) = v6;
      v40 = j_va("%c %c %s %d %d %f", 109i64, 100i64, v7, fmt, v44, v45);
      v41 = v40;
      if ( outControllingClientNum[0] == -1 )
      {
        SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v40);
      }
      else
      {
        CommonClient = SvClient::GetCommonClient(outControllingClientNum[0]);
        CommonClient->SendServerCommand(CommonClient, SV_CMD_RELIABLE, v41);
      }
    }
    else
    {
      v37 = j_va("Invalid entity index %d before SV_Game_SendServerCommand\n", (unsigned int)outControllingClientNum[0]);
      Scr_Error(COM_ERR_6414, scrContext, v37);
    }
  }
  else
  {
    v21 = j_va("entity %i is not a player or player-controlled agent", v8);
    Scr_ObjectError(COM_ERR_4808, scrContext, v21);
  }
}

/*
==============
SetHUDWarningOmnvars
==============
*/
void SetHUDWarningOmnvars(scrContext_t *scrContext, const int warningIndex, const bool showWarning)
{
  unsigned int IndexByName; 
  unsigned int v7; 
  unsigned int v8; 
  OmnvarData *Data; 
  OmnvarData *v10; 
  OmnvarData *v11; 

  IndexByName = BG_Omnvar_GetIndexByName("ui_hud_warning");
  v7 = BG_Omnvar_GetIndexByName("ui_hud_warning_notify");
  v8 = v7;
  if ( IndexByName == -1 || v7 == -1 )
    Scr_Error(COM_ERR_4215, scrContext, "SetHUDWarningOmnvars can't find omnvars - check omnvars.csv");
  Data = G_Omnvar_GetData(IndexByName, -1, NULL);
  v10 = G_Omnvar_GetData(v8, -1, NULL);
  Data->current.integer = warningIndex;
  v11 = v10;
  v10->current.enabled = showWarning;
  G_Omnvar_MarkChanged(Data);
  G_Omnvar_MarkChanged(v11);
}

/*
==============
SetupVehicleCollision
==============
*/

void __fastcall SetupVehicleCollision(gentity_s *ent, double vehRadius)
{
  __int16 otherEntityNum; 
  bool v8; 
  vec3_t forward; 
  vec3_t origin; 

  __asm
  {
    vmovaps [rsp+78h+var_18], xmm6
    vmovaps xmm6, xmm1
  }
  Sys_ProfBeginNamedEvent(0xFFFF0000, "SetupVehicleCollision");
  otherEntityNum = ent->s.otherEntityNum;
  ent->r.svFlags |= 4u;
  ent->clipmask = 8389137;
  if ( otherEntityNum )
  {
    __asm { vaddss  xmm6, xmm6, cs:__real@41720000 }
    _RCX = 1456i64 * otherEntityNum;
    v8 = (unsigned __int128)(1456 * (__int128)otherEntityNum) >> 64 != 0;
    __asm { vmovaps [rsp+78h+var_28], xmm7 }
    _RAX = g_entities;
    __asm
    {
      vmovss  xmm0, dword ptr [rcx+rax+130h]
      vmovss  xmm1, dword ptr [rcx+rax+134h]
      vsubss  xmm2, xmm1, dword ptr [rbx+134h]
      vsubss  xmm4, xmm0, dword ptr [rbx+130h]
      vmulss  xmm3, xmm2, xmm2
      vmulss  xmm0, xmm4, xmm4
      vaddss  xmm7, xmm3, xmm0
      vmulss  xmm1, xmm6, xmm6
      vcomiss xmm7, xmm1
    }
    if ( v8 )
    {
      AngleVectors(&ent->r.currentAngles, &forward, NULL, NULL);
      __asm
      {
        vsqrtss xmm0, xmm7, xmm7
        vsubss  xmm3, xmm6, xmm0
        vmulss  xmm0, xmm3, dword ptr [rsp+78h+forward]
        vaddss  xmm2, xmm0, dword ptr [rbx+130h]
        vmulss  xmm0, xmm3, dword ptr [rsp+78h+forward+4]
        vmovss  dword ptr [rsp+78h+origin], xmm2
        vaddss  xmm2, xmm0, dword ptr [rbx+134h]
        vmulss  xmm0, xmm3, dword ptr [rsp+78h+forward+8]
        vmovss  dword ptr [rsp+78h+origin+4], xmm2
        vaddss  xmm2, xmm0, dword ptr [rbx+138h]
        vmovss  dword ptr [rsp+78h+origin+8], xmm2
      }
      G_SetOrigin(ent, &origin, 1, 1);
    }
    __asm { vmovaps xmm7, [rsp+78h+var_28] }
  }
  Sys_ProfEndNamedEvent();
  __asm { vmovaps xmm6, [rsp+78h+var_18] }
}

/*
==============
VisionSetSendToClient
==============
*/

void __fastcall VisionSetSendToClient(scrContext_t *scrContext, visionSetMode_t visionMode, double _XMM2_8)
{
  __int64 v4; 
  unsigned int v7; 
  scr_string_t ConstLowercaseString; 
  const char *v15; 
  const char *v16; 
  __int64 v17; 
  const char *v18; 
  char *fmt; 
  unsigned int outVisionSetIndex[4]; 
  char dest[64]; 

  v4 = visionMode;
  _EBP = 1000;
  v7 = Scr_GetNumParam(scrContext) - 1;
  if ( v7 )
  {
    if ( v7 != 1 )
    {
      Scr_Error(COM_ERR_4376, scrContext, "Invalid parameters.");
      return;
    }
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
    __asm
    {
      vmulss  xmm1, xmm0, cs:__real@447a0000
      vaddss  xmm3, xmm1, cs:__real@3f000000
      vxorps  xmm2, xmm2, xmm2
      vmovss  xmm4, xmm2, xmm3
      vxorps  xmm0, xmm0, xmm0
      vroundss xmm1, xmm0, xmm4, 1
      vcvttss2si ebp, xmm1
    }
  }
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  v15 = SL_ConvertToString(ConstLowercaseString);
  v16 = v15;
  if ( *v15 )
  {
    if ( !NetConstStrings_GetVisionSetIndex(v15, outVisionSetIndex) )
    {
      v18 = j_va("visionset %s has not been precached, include with precache_vision", v16);
      Scr_Error(COM_ERR_4375, scrContext, v18);
    }
    v17 = outVisionSetIndex[0];
    if ( !outVisionSetIndex[0] )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 15723, ASSERT_TYPE_ASSERT, "( visionSetIndex != 0 )", (const char *)&queryFormat, "visionSetIndex != 0") )
        __debugbreak();
      v17 = outVisionSetIndex[0];
    }
  }
  else
  {
    v17 = 0i64;
    outVisionSetIndex[0] = 0;
  }
  if ( !(_DWORD)v4 || (_DWORD)v4 == 5 )
  {
    LODWORD(fmt) = _EBP;
    Com_sprintf(dest, 0x40ui64, "%d %i", v17, fmt);
  }
  else
  {
    Com_sprintf(dest, 0x40ui64, "%d", v17);
  }
  SV_SetConfigstring(dword_143FD1A68[v4], dest);
}

