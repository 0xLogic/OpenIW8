/*
==============
cRBT_SSS_AsyncClear<R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_SSS_AsyncClear<R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>)
{
  return ??$cRBT_SSS_AsyncClear@UR_TG_Handle@@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@@Z(context, <args_0>);
}

/*
==============
RBT_SSS_BlurX_Common
==============
*/

void __fastcall RBT_SSS_BlurX_Common(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data, bool isVRS)
{
  ?RBT_SSS_BlurX_Common@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@_N@Z(gfxContext, taskInfo, viewInfo, data, isVRS);
}

/*
==============
cRBT_DrawOpaqueSSS_VRS<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_DrawOpaqueSSS_VRS<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>, const R_TG_Handle *<args_11>, const R_TG_Handle *<args_12>, const R_TG_Handle *<args_13>, const R_TG_Handle *<args_14>, const R_TG_Handle *<args_15>, const R_TG_Handle *<args_16>, const R_TG_Handle *<args_17>, const R_TG_Handle *<args_18>, const R_TG_Handle *<args_19>, const R_TG_Handle *<args_20>)
{
  return ??$cRBT_DrawOpaqueSSS_VRS@UR_TG_Handle@@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11111111111111111111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>, <args_11>, <args_12>, <args_13>, <args_14>, <args_15>, <args_16>, <args_17>, <args_18>, <args_19>, <args_20>);
}

/*
==============
RBT_DrawOpaqueSSS_Common
==============
*/

void __fastcall RBT_DrawOpaqueSSS_Common(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DrawOpaqueSSS_Common@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBT_SSS_BlurY<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_SSS_BlurY<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>)
{
  return ??$cRBT_SSS_BlurY@UR_TG_Handle@@U1@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@111111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>);
}

/*
==============
RBT_DrawOpaqueSSS_VRS
==============
*/

void __fastcall RBT_DrawOpaqueSSS_VRS(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DrawOpaqueSSS_VRS@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_SSS_AsyncClear
==============
*/

void __fastcall RBT_SSS_AsyncClear(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SSS_AsyncClear@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBT_SSS_BlurX_VRS<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_SSS_BlurX_VRS<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>)
{
  return ??$cRBT_SSS_BlurX_VRS@UR_TG_Handle@@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>);
}

/*
==============
RBT_SSS_BlurX
==============
*/

void __fastcall RBT_SSS_BlurX(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SSS_BlurX@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_SSS_TileMaskClear
==============
*/

void __fastcall RBT_SSS_TileMaskClear(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SSS_TileMaskClear@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RT_DrawOpaqueSSSSetup_Common
==============
*/

void __fastcall RT_DrawOpaqueSSSSetup_Common(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  ?RT_DrawOpaqueSSSSetup_Common@@YAXPEBUGfxTaskInfo@@PEAUGfxViewInfo@@@Z(taskInfo, viewInfo);
}

/*
==============
RT_DrawOpaqueSSSSetup_VRS
==============
*/

void __fastcall RT_DrawOpaqueSSSSetup_VRS(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  ?RT_DrawOpaqueSSSSetup_VRS@@YAXPEBUGfxTaskInfo@@PEAUGfxViewInfo@@@Z(taskInfo, viewInfo);
}

/*
==============
RBT_SSS_BlurY
==============
*/

void __fastcall RBT_SSS_BlurY(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SSS_BlurY@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBT_DrawOpaqueSSS<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_DrawOpaqueSSS<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>, const R_TG_Handle *<args_11>, const R_TG_Handle *<args_12>, const R_TG_Handle *<args_13>, const R_TG_Handle *<args_14>, const R_TG_Handle *<args_15>, const R_TG_Handle *<args_16>, const R_TG_Handle *<args_17>, const R_TG_Handle *<args_18>, const R_TG_Handle *<args_19>, const R_TG_Handle *<args_20>)
{
  return ??$cRBT_DrawOpaqueSSS@UR_TG_Handle@@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11111111111111111111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>, <args_11>, <args_12>, <args_13>, <args_14>, <args_15>, <args_16>, <args_17>, <args_18>, <args_19>, <args_20>);
}

/*
==============
RBT_SSS_BlurX_VRS
==============
*/

void __fastcall RBT_SSS_BlurX_VRS(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_SSS_BlurX_VRS@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RT_DrawOpaqueSSSSetup
==============
*/

void __fastcall RT_DrawOpaqueSSSSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  ?RT_DrawOpaqueSSSSetup@@YAXPEBUGfxTaskInfo@@PEAUGfxViewInfo@@@Z(taskInfo, viewInfo);
}

/*
==============
cRBT_SSS_BlurX<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_SSS_BlurX<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>)
{
  return ??$cRBT_SSS_BlurX@UR_TG_Handle@@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>);
}

/*
==============
RBT_DrawOpaqueSSS
==============
*/

void __fastcall RBT_DrawOpaqueSSS(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DrawOpaqueSSS@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBT_DrawOpaqueSSS<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_DrawOpaqueSSS<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>, const R_TG_Handle *<args_11>, const R_TG_Handle *<args_12>, const R_TG_Handle *<args_13>, const R_TG_Handle *<args_14>, const R_TG_Handle *<args_15>, const R_TG_Handle *<args_16>, const R_TG_Handle *<args_17>, const R_TG_Handle *<args_18>, const R_TG_Handle *<args_19>, const R_TG_Handle *<args_20>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(context, g_R_TG_Def_RBT_DrawOpaqueSSS.m_index, &arguments, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>, <args_11>, <args_12>, <args_13>, <args_14>, <args_15>, <args_16>, <args_17>, <args_18>, <args_19>, <args_20>);
}

/*
==============
cRBT_DrawOpaqueSSS_VRS<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_DrawOpaqueSSS_VRS<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>, const R_TG_Handle *<args_11>, const R_TG_Handle *<args_12>, const R_TG_Handle *<args_13>, const R_TG_Handle *<args_14>, const R_TG_Handle *<args_15>, const R_TG_Handle *<args_16>, const R_TG_Handle *<args_17>, const R_TG_Handle *<args_18>, const R_TG_Handle *<args_19>, const R_TG_Handle *<args_20>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(context, g_R_TG_Def_RBT_DrawOpaqueSSS_VRS.m_index, &arguments, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>, <args_11>, <args_12>, <args_13>, <args_14>, <args_15>, <args_16>, <args_17>, <args_18>, <args_19>, <args_20>);
}

/*
==============
cRBT_SSS_AsyncClear<R_TG_Handle>
==============
*/
unsigned int cRBT_SSS_AsyncClear<R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>)
{
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  ++stack.handleArgCount;
  stack.handleArgs[0] = &<args_0>->index;
  return R_TG_AddTask(context, g_R_TG_Def_RBT_SSS_AsyncClear.m_index, &stack);
}

/*
==============
cRBT_SSS_BlurX<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_SSS_BlurX<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v11; 
  unsigned int v12; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_SSS_BlurX.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v11 = stack.handleArgCount + 1;
  stack.handleArgCount = v11;
  if ( (unsigned int)v11 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v11 = stack.handleArgCount;
  }
  stack.handleArgs[v11] = &<args_2>->index;
  v12 = stack.handleArgCount + 1;
  stack.handleArgCount = v12;
  if ( v12 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v12 = stack.handleArgCount;
  }
  stack.handleArgs[v12] = &<args_3>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_SSS_BlurX_VRS<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_SSS_BlurX_VRS<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v11; 
  unsigned int v12; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_SSS_BlurX_VRS.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v11 = stack.handleArgCount + 1;
  stack.handleArgCount = v11;
  if ( (unsigned int)v11 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v11 = stack.handleArgCount;
  }
  stack.handleArgs[v11] = &<args_2>->index;
  v12 = stack.handleArgCount + 1;
  stack.handleArgCount = v12;
  if ( v12 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v12 = stack.handleArgCount;
  }
  stack.handleArgs[v12] = &<args_3>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_SSS_BlurY<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_SSS_BlurY<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>)
{
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(context, g_R_TG_Def_RBT_SSS_BlurY.m_index, &arguments, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>);
}

/*
==============
RBT_DrawOpaqueSSS
==============
*/
void RBT_DrawOpaqueSSS(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufContext v4; 

  v4 = *gfxContext;
  RBT_DrawOpaqueSSS_Common(&v4, taskInfo, viewInfo, data);
}

/*
==============
RBT_DrawOpaqueSSS_Common
==============
*/
void RBT_DrawOpaqueSSS_Common(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Group *p_rtGroup; 
  const dvar_t *v7; 

  p_rtGroup = &taskInfo->rtGroup;
  RB_RunDrawList(viewInfo, data, &taskInfo->rtGroup, DRAWLIST_PRE_DEPTH_HACK_SSS);
  RB_RunDrawList(viewInfo, data, p_rtGroup, DRAWLIST_DEPTH_HACK_SSS);
  RB_RunDrawList(viewInfo, data, p_rtGroup, DRAWLIST_PRE_SSS);
  RB_RunDrawList(viewInfo, data, p_rtGroup, DRAWLIST_LIT_OPAQUE_END);
  v7 = r_flushCommandListsAt_Flags;
  if ( !r_flushCommandListsAt_Flags && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 627, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar accessed after deregistration", "dvar") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v7);
}

/*
==============
RBT_DrawOpaqueSSS_VRS
==============
*/
void RBT_DrawOpaqueSSS_VRS(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufContext v4; 

  v4 = *gfxContext;
  RBT_DrawOpaqueSSS_Common(&v4, taskInfo, viewInfo, data);
}

/*
==============
RBT_SSS_AsyncClear
==============
*/
void RBT_SSS_AsyncClear(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Handle v7; 
  unsigned int width; 
  unsigned int height; 
  const R_RT_Surface *Surface; 
  const R_RT_Surface *v12; 
  const GfxTexture *Resident; 
  R_RT_Handle v14; 
  R_RT_Handle v15; 

  v7 = *taskInfo->attachments;
  v15 = v7;
  v14 = v7;
  if ( (_WORD)_XMM0 )
  {
    R_RT_Handle::GetSurface(&v14);
    if ( (R_RT_Handle::GetSurface(&v14)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      v7 = v14;
      __debugbreak();
    }
    else
    {
      v7 = v14;
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v7 = v15;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
  }
  v14 = v7;
  if ( R_SSS_Enabled(viewInfo) )
  {
    width = R_RT_Handle::GetSurface(&v14)->m_image.m_base.width;
    height = R_RT_Handle::GetSurface(&v14)->m_image.m_base.height;
  }
  else
  {
    width = 8;
    height = 8;
  }
  if ( (R_RT_Handle::GetSurface(&v14)->m_rtFlags & 9) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_sss.h", 216, ASSERT_TYPE_ASSERT, "((colorRt.GetFlags() & (R_RT_Flag_FastClear | R_RT_Flag_Dcc)) == 0)", "%s\n\tclear not possible for rts with meta data", "(colorRt.GetFlags() & (R_RT_Flag_FastClear | R_RT_Flag_Dcc)) == 0") )
    __debugbreak();
  Surface = R_RT_Handle::GetSurface(&v14);
  if ( (Surface->m_rtFlagsInternal & 0x10) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 324, ASSERT_TYPE_ASSERT, "(!( surface->m_rtFlagsInternal & R_RT_FlagInternal_Depth ))", (const char *)&queryFormat, "!( surface->m_rtFlagsInternal & R_RT_FlagInternal_Depth )") )
    __debugbreak();
  v12 = R_RT_Handle::GetSurface(&v14);
  Resident = R_Texture_GetResident(v12->m_image.m_base.textureId);
  R_SetTextureRect(computeState, Resident, &Surface->m_color.m_clearColor, 0, 0, width, height);
}

/*
==============
RBT_SSS_BlurX
==============
*/
void RBT_SSS_BlurX(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufContext v4; 

  v4 = *gfxContext;
  RBT_SSS_BlurX_Common(&v4, taskInfo, viewInfo, data, 0);
}

/*
==============
RBT_SSS_BlurX_Common
==============
*/
void RBT_SSS_BlurX_Common(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data, bool isVRS)
{
  R_RT_Handle v9; 
  const R_RT_Surface *Surface; 
  R_RT_Handle v12; 
  bool v14; 
  const R_RT_Surface *v15; 
  R_RT_Handle v16; 
  bool v18; 
  R_RT_Image *p_m_image; 
  R_RT_Handle v20; 
  R_RT_Handle v21; 

  if ( R_SSS_Enabled(viewInfo) )
  {
    v9 = *taskInfo->attachments;
    v21 = v9;
    v20 = v9;
    if ( (_WORD)_XMM0 )
    {
      R_RT_Handle::GetSurface(&v20);
      if ( (R_RT_Handle::GetSurface(&v20)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        v9 = v20;
        __debugbreak();
      }
      else
      {
        v9 = v20;
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v9 = v21;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
          __debugbreak();
      }
    }
    v21 = v9;
    Surface = R_RT_Handle::GetSurface(&v21);
    v12 = taskInfo->attachments[1];
    v21 = v12;
    v20 = v12;
    if ( (_WORD)_XMM0 )
    {
      R_RT_Handle::GetSurface(&v20);
      if ( (R_RT_Handle::GetSurface(&v20)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        v12 = v20;
        __debugbreak();
      }
      else
      {
        v12 = v20;
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v14 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        v12 = v21;
        if ( v14 )
          __debugbreak();
      }
    }
    v21 = v12;
    v15 = R_RT_Handle::GetSurface(&v21);
    if ( isVRS )
    {
      v16 = taskInfo->attachments[2];
      v21 = v16;
      v20 = v16;
      if ( (_WORD)_XMM0 )
      {
        R_RT_Handle::GetSurface(&v20);
        if ( (R_RT_Handle::GetSurface(&v20)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
        {
          v16 = v20;
          __debugbreak();
        }
        else
        {
          v16 = v20;
        }
      }
      else
      {
        __asm { vpextrd rax, xmm0, 2 }
        if ( (_DWORD)_RAX )
        {
          v18 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
          v16 = v21;
          if ( v18 )
            __debugbreak();
        }
      }
      v21 = v16;
      p_m_image = &R_RT_Handle::GetSurface(&v21)->m_image;
    }
    else
    {
      p_m_image = (R_RT_Image *)rgp.blackImage;
    }
    R_SSS_Bind(gfxContext->source, viewInfo);
    *(GfxCmdBufContext *)&v20.m_surfaceID = *gfxContext;
    R_SSS_BlurX((GfxCmdBufContext *)&v20, viewInfo, &Surface->m_image.m_base, &v15->m_image.m_base, &p_m_image->m_base);
  }
}

/*
==============
RBT_SSS_BlurX_VRS
==============
*/
void RBT_SSS_BlurX_VRS(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufContext v4; 

  v4 = *gfxContext;
  RBT_SSS_BlurX_Common(&v4, taskInfo, viewInfo, data, 1);
}

/*
==============
RBT_SSS_BlurY
==============
*/
void RBT_SSS_BlurY(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Handle v8; 
  const R_RT_Surface *Surface; 
  R_RT_Handle v11; 
  bool v13; 
  const R_RT_Surface *v14; 
  R_RT_Handle v15; 
  bool v17; 
  R_RT_Image *p_m_image; 
  R_RT_Handle v19; 
  bool v21; 
  const R_RT_Surface *v22; 
  R_RT_Handle *attachments; 
  R_RT_Image *blackImage; 
  const GfxImage *p_m_base; 
  R_RT_Handle v26; 
  R_RT_Handle v27; 

  if ( R_SSS_Enabled(viewInfo) )
  {
    v8 = *taskInfo->attachments;
    v27 = v8;
    v26 = v8;
    if ( (_WORD)_XMM0 )
    {
      R_RT_Handle::GetSurface(&v26);
      if ( (R_RT_Handle::GetSurface(&v26)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        v8 = v26;
        __debugbreak();
      }
      else
      {
        v8 = v26;
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v8 = v27;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
          __debugbreak();
      }
    }
    v27 = v8;
    Surface = R_RT_Handle::GetSurface(&v27);
    v11 = taskInfo->attachments[1];
    v27 = v11;
    v26 = v11;
    if ( (_WORD)_XMM0 )
    {
      R_RT_Handle::GetSurface(&v26);
      if ( (R_RT_Handle::GetSurface(&v26)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        v11 = v26;
        __debugbreak();
      }
      else
      {
        v11 = v26;
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v13 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        v11 = v27;
        if ( v13 )
          __debugbreak();
      }
    }
    v27 = v11;
    v14 = R_RT_Handle::GetSurface(&v27);
    v15 = taskInfo->attachments[2];
    v27 = v15;
    v26 = v15;
    if ( (_WORD)_XMM0 )
    {
      R_RT_Handle::GetSurface(&v26);
      if ( (R_RT_Handle::GetSurface(&v26)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        v15 = v26;
        __debugbreak();
      }
      else
      {
        v15 = v26;
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v17 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        v15 = v27;
        if ( v17 )
          __debugbreak();
      }
    }
    v27 = v15;
    p_m_image = &R_RT_Handle::GetSurface(&v27)->m_image;
    v19 = taskInfo->attachments[3];
    v27 = v19;
    v26 = v19;
    if ( (_WORD)_XMM0 )
    {
      R_RT_Handle::GetSurface(&v26);
      if ( (R_RT_Handle::GetSurface(&v26)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        v19 = v26;
        __debugbreak();
      }
      else
      {
        v19 = v26;
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v21 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", (unsigned __int16)_XMM0 + 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        v19 = v27;
        if ( v21 )
          __debugbreak();
      }
    }
    v27 = v19;
    v22 = R_RT_Handle::GetSurface(&v27);
    attachments = taskInfo->attachments;
    blackImage = (R_RT_Image *)rgp.blackImage;
    p_m_base = &v22->m_image.m_base;
    v26 = attachments[4];
    if ( (_WORD)_XMM0 )
    {
      R_RT_Handle::GetSurface(&v26);
      blackImage = &R_RT_Handle::GetSurface(&v26)->m_image;
    }
    else if ( v26.m_tracking.m_allocCounter )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    R_SSS_Bind(gfxContext->source, viewInfo);
    *(GfxCmdBufContext *)&v26.m_surfaceID = *gfxContext;
    R_SSS_BlurY((GfxCmdBufContext *)&v26, viewInfo, &Surface->m_image.m_base, &v14->m_image.m_base, &p_m_image->m_base, p_m_base, &blackImage->m_base);
  }
}

/*
==============
RBT_SSS_TileMaskClear
==============
*/
void RBT_SSS_TileMaskClear(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Handle v8; 
  const R_RT_Surface *Surface; 
  unsigned int v11; 
  const R_RT_Surface *v12; 
  R_RT_Handle v13; 
  R_RT_Handle v14; 
  ID3D12Resource *buffers; 

  R_SetComputeShader(computeState, rgp.csSSSTileClear);
  buffers = data->globalSceneConstantBuffer->buffer;
  R_SetComputeConstantBuffers(computeState, 7, 1, &buffers);
  v8 = *taskInfo->attachments;
  v14 = v8;
  v13 = v8;
  if ( (_WORD)_XMM0 )
  {
    R_RT_Handle::GetSurface(&v13);
    if ( (R_RT_Handle::GetSurface(&v13)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      v8 = v13;
      __debugbreak();
    }
    else
    {
      v8 = v13;
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v8 = v14;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
  }
  v13 = v8;
  Surface = R_RT_Handle::GetSurface(&v13);
  buffers = (ID3D12Resource *)R_Texture_GetResident(Surface->m_image.m_base.textureId);
  R_SetComputeRWTextures(computeState, 0, 1, (const GfxTexture *const *)&buffers);
  buffers = (ID3D12Resource *)&R_RT_Handle::GetWrappedBuffer(taskInfo->attachments + 1)->view;
  R_SetComputeViews(computeState, 0, 1, (const GfxShaderBufferView *const *)&buffers);
  if ( (R_RT_Handle::GetSurface(&v13)->m_rtFlags & 9) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_sss.h", 238, ASSERT_TYPE_ASSERT, "(( colorRt.GetFlags() & ( R_RT_Flag_FastClear | R_RT_Flag_Dcc ) ) == 0)", "%s\n\tclear not possible for rts with meta data", "( colorRt.GetFlags() & ( R_RT_Flag_FastClear | R_RT_Flag_Dcc ) ) == 0") )
    __debugbreak();
  v11 = ((((unsigned int)R_RT_Handle::GetSurface(&v13)->m_image.m_base.height + 7) >> 3) + 7) >> 3;
  v12 = R_RT_Handle::GetSurface(&v13);
  R_Dispatch(computeState, ((((unsigned int)v12->m_image.m_base.width + 7) >> 3) + 7) >> 3, v11, 1u);
}

/*
==============
RT_DrawOpaqueSSSSetup
==============
*/

void __fastcall RT_DrawOpaqueSSSSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  RT_DrawOpaqueSSSSetup_Common(taskInfo, viewInfo);
}

/*
==============
RT_DrawOpaqueSSSSetup_Common
==============
*/
void RT_DrawOpaqueSSSSetup_Common(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  R_RT_Group *p_rtGroup; 

  p_rtGroup = &taskInfo->rtGroup;
  R_AddDrawCall(viewInfo, &taskInfo->rtGroup, DRAWLIST_PRE_DEPTH_HACK_SSS, 0x5Du);
  R_AddDrawCall(viewInfo, p_rtGroup, DRAWLIST_DEPTH_HACK_SSS, 0x5Du);
  R_AddDrawCall(viewInfo, p_rtGroup, DRAWLIST_PRE_SSS, 0x5Du);
  R_AddDrawCall(viewInfo, p_rtGroup, DRAWLIST_LIT_OPAQUE_END, 0x5Du);
}

/*
==============
RT_DrawOpaqueSSSSetup_VRS
==============
*/
void RT_DrawOpaqueSSSSetup_VRS(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  __int16 v2; 
  R_RT_Image *blackUintImage; 
  R_RT_Image *p_m_image; 
  R_RT_Handle v7; 

  blackUintImage = (R_RT_Image *)rgp.blackUintImage;
  v7 = taskInfo->attachments[16];
  if ( v2 )
  {
    R_RT_Handle::GetSurface(&v7);
    blackUintImage = &R_RT_Handle::GetSurface(&v7)->m_image;
  }
  else if ( v7.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v7.m_surfaceID) )
  {
    __debugbreak();
  }
  if ( viewInfo == (GfxViewInfo *)-3760i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  viewInfo->input.codeImages[84] = &blackUintImage->m_base;
  p_m_image = (R_RT_Image *)rgp.blackUintImage;
  v7 = taskInfo->attachments[17];
  if ( v2 )
  {
    R_RT_Handle::GetSurface(&v7);
    p_m_image = &R_RT_Handle::GetSurface(&v7)->m_image;
  }
  else if ( v7.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v7.m_surfaceID) )
  {
    __debugbreak();
  }
  if ( viewInfo == (GfxViewInfo *)-3760i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  viewInfo->input.codeImages[85] = &p_m_image->m_base;
  RT_DrawOpaqueSSSSetup_Common(taskInfo, viewInfo);
}

