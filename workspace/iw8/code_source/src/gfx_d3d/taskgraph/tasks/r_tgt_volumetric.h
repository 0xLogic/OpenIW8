/*
==============
RBT_VOL_ScatteringSetup
==============
*/

void __fastcall RBT_VOL_ScatteringSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  ?RBT_VOL_ScatteringSetup@@YAXPEBUGfxTaskInfo@@PEAUGfxViewInfo@@@Z(taskInfo, viewInfo);
}

/*
==============
RBT_VOL_ClearIndirectScattering
==============
*/

void __fastcall RBT_VOL_ClearIndirectScattering(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_VOL_ClearIndirectScattering@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_VOL_WriteClusterBuffer
==============
*/

void __fastcall RBT_VOL_WriteClusterBuffer(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_VOL_WriteClusterBuffer@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_VOL_CombineAmbientMultiLightGrid
==============
*/

void __fastcall RBT_VOL_CombineAmbientMultiLightGrid(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_VOL_CombineAmbientMultiLightGrid@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBTD_VOL_ShowVolumetricDebug<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBTD_VOL_ShowVolumetricDebug<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cRBTD_VOL_ShowVolumetricDebug@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
cRBT_VOL_ClearIndirectScattering<R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_VOL_ClearIndirectScattering<R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>)
{
  return ??$cRBT_VOL_ClearIndirectScattering@UR_TG_Handle@@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@@Z(context, <args_0>);
}

/*
==============
RBT_VOL_MaxFloatZ
==============
*/

void __fastcall RBT_VOL_MaxFloatZ(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_VOL_MaxFloatZ@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_VOL_FillIndirectScattering
==============
*/

void __fastcall RBT_VOL_FillIndirectScattering(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_VOL_FillIndirectScattering@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_VOL_Scattering
==============
*/

void __fastcall RBT_VOL_Scattering(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_VOL_Scattering@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_VOL_Accumulate
==============
*/

void __fastcall RBT_VOL_Accumulate(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_VOL_Accumulate@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
cRBT_VOL_Scattering<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,int>
==============
*/

unsigned int __fastcall cRBT_VOL_Scattering<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,int>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>, const R_TG_Handle *<args_11>, const R_TG_Handle *<args_12>, const R_TG_Handle *<args_13>, const R_TG_Handle *<args_14>, const R_TG_Handle *<args_15>, const R_TG_Handle *<args_16>, const int *<args_17>)
{
  return ??$cRBT_VOL_Scattering@UR_TG_Handle@@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@U1@H@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1111111111111111AEBH@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>, <args_11>, <args_12>, <args_13>, <args_14>, <args_15>, <args_16>, <args_17>);
}

/*
==============
RBT_VOL_SampleAmbient
==============
*/

void __fastcall RBT_VOL_SampleAmbient(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_VOL_SampleAmbient@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBT_VOL_SampleAmbientMultiLightGrid
==============
*/

void __fastcall RBT_VOL_SampleAmbientMultiLightGrid(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_VOL_SampleAmbientMultiLightGrid@@YAXPEAUComputeCmdBufState@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(computeState, taskInfo, viewInfo, data);
}

/*
==============
RBTD_VOL_ShowVolumetricDebug
==============
*/

void __fastcall RBTD_VOL_ShowVolumetricDebug(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBTD_VOL_ShowVolumetricDebug@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBTD_VOL_ShowVolumetricDebug<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBTD_VOL_ShowVolumetricDebug<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBTD_VOL_ShowVolumetricDebug.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_VOL_ClearIndirectScattering<R_TG_Handle>
==============
*/
unsigned int cRBT_VOL_ClearIndirectScattering<R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>)
{
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  ++stack.handleArgCount;
  stack.handleArgs[0] = &<args_0>->index;
  return R_TG_AddTask(context, g_R_TG_Def_RBT_VOL_ClearIndirectScattering.m_index, &stack);
}

/*
==============
cRBT_VOL_Scattering<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,int>
==============
*/
unsigned int cRBT_VOL_Scattering<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,int>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>, const R_TG_Handle *<args_6>, const R_TG_Handle *<args_7>, const R_TG_Handle *<args_8>, const R_TG_Handle *<args_9>, const R_TG_Handle *<args_10>, const R_TG_Handle *<args_11>, const R_TG_Handle *<args_12>, const R_TG_Handle *<args_13>, const R_TG_Handle *<args_14>, const R_TG_Handle *<args_15>, const R_TG_Handle *<args_16>, const int *<args_17>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack arguments; 

  memset_0(&arguments, 0, sizeof(arguments));
  m_index = g_R_TG_Def_RBT_VOL_Scattering.m_index;
  handleArgCount = arguments.handleArgCount + 1;
  arguments.handleArgs[0] = &<args_0>->index;
  arguments.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = arguments.handleArgCount;
  }
  arguments.handleArgs[handleArgCount] = &<args_1>->index;
  ++arguments.handleArgCount;
  return R_TG_AddTask<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,int>(context, m_index, &arguments, <args_2>, <args_3>, <args_4>, <args_5>, <args_6>, <args_7>, <args_8>, <args_9>, <args_10>, <args_11>, <args_12>, <args_13>, <args_14>, <args_15>, <args_16>, <args_17>);
}

/*
==============
RBTD_VOL_ShowVolumetricDebug
==============
*/
void RBTD_VOL_ShowVolumetricDebug(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  const R_RT_Surface *Surface; 
  GfxCmdBufContext v9; 

  _RBX = gfxContext;
  Surface = R_RT_Handle::GetSurface(taskInfo->attachments);
  __asm
  {
    vmovups xmm0, xmmword ptr [rbx]
    vmovups xmmword ptr [rsp+38h+var_18.source], xmm0
  }
  RB_ShowVolumetricDebug(&v9, viewInfo, data, &Surface->m_image.m_base);
}

/*
==============
RBT_VOL_Accumulate
==============
*/
void RBT_VOL_Accumulate(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  bool v9; 
  R_RT_Handle *attachments; 
  unsigned int v11; 
  const R_RT_Surface *Surface; 
  GfxImage *blackImage3D; 
  const R_RT_Surface *v16; 
  R_RT_Handle *v17; 
  const R_RT_Surface *v18; 
  GfxImage *blackImage; 
  const R_RT_Surface *v22; 
  R_RT_Handle *v23; 
  const R_RT_Surface *v24; 
  R_RT_Handle *v25; 
  const R_RT_Surface *v26; 
  R_RT_Handle *v27; 
  R_RT_Handle v28; 
  VolumetricDrawStream drawStream; 
  VolumetricAccumulateResources resources; 
  ID3D12Resource *buffers; 

  drawStream.state = computeState;
  drawStream.data = data;
  v9 = R_VOL_UseLocalMedia(data, viewInfo);
  attachments = taskInfo->attachments;
  drawStream.useLocalMedia = v9;
  drawStream.useLocalMediaPrev = v9;
  v11 = data->volumetricsIndex & 1;
  drawStream.viewInfo = viewInfo;
  drawStream.toggle = v11;
  Surface = R_RT_Handle::GetSurface(attachments);
  blackImage3D = rgp.blackImage3D;
  resources.scatterTemporalWriteImage = &Surface->m_image.m_base;
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v28);
    resources.scatterTemporalReadImage = &R_RT_Handle::GetSurface(&v28)->m_image.m_base;
  }
  else
  {
    if ( v28.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v28.m_surfaceID) )
      __debugbreak();
    resources.scatterTemporalReadImage = blackImage3D;
  }
  v16 = R_RT_Handle::GetSurface(taskInfo->attachments + 2);
  v17 = taskInfo->attachments + 3;
  resources.extinctionTemporalReadImage = &v16->m_image.m_base;
  v18 = R_RT_Handle::GetSurface(v17);
  blackImage = rgp.blackImage;
  resources.visibilityImage = &v18->m_image.m_base;
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+80h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rbp+57h+var_C0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v28);
    resources.visibilityPrevFrameImage = &R_RT_Handle::GetSurface(&v28)->m_image.m_base;
  }
  else
  {
    if ( v28.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v28.m_surfaceID) )
      __debugbreak();
    resources.visibilityPrevFrameImage = blackImage;
  }
  v22 = R_RT_Handle::GetSurface(taskInfo->attachments + 5);
  v23 = taskInfo->attachments + 6;
  resources.scatterIntegralImage = &v22->m_image.m_base;
  v24 = R_RT_Handle::GetSurface(v23);
  v25 = taskInfo->attachments + 7;
  resources.extinctionIntegralImage = &v24->m_image.m_base;
  v26 = R_RT_Handle::GetSurface(v25);
  v27 = taskInfo->attachments + 8;
  resources.scatterCurrentTexture = &v26->m_image.m_base;
  resources.scatterCurrentMomentsTexture = &R_RT_Handle::GetSurface(v27)->m_image.m_base;
  buffers = data->globalSceneConstantBuffer->buffer;
  R_SetComputeConstantBuffers(computeState, 7, 1, &buffers);
  R_VOL_AccumulateScattering(&drawStream, &resources);
}

/*
==============
RBT_VOL_ClearIndirectScattering
==============
*/
void RBT_VOL_ClearIndirectScattering(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxShaderBufferRWView *views; 

  views = &R_RT_Handle::GetWrappedBuffer(taskInfo->attachments)->rwView;
  R_SetComputeRWViewsWithCounters(computeState, 0, 1, (const GfxShaderBufferRWView *const *)&views, NULL);
  R_SetComputeShader(computeState, rgp.clearIndirectScattering);
  R_Dispatch(computeState, 1u, 1u, 1u);
}

/*
==============
RBT_VOL_CombineAmbientMultiLightGrid
==============
*/
void RBT_VOL_CombineAmbientMultiLightGrid(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Handle *attachments; 
  ID3D12Resource *buffers; 

  attachments = taskInfo->attachments;
  buffers = data->globalSceneConstantBuffer->buffer;
  R_SetComputeConstantBuffers(computeState, 7, 1, &buffers);
  R_VOL_CombineAmbientMultiLightGrid(computeState, viewInfo, attachments, attachments + 1, attachments + 2, attachments + 3, attachments + 4, attachments + 5, attachments + 6, attachments + 7);
}

/*
==============
RBT_VOL_FillIndirectScattering
==============
*/
void RBT_VOL_FillIndirectScattering(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Handle *v12; 
  const R_RT_Surface *Surface; 
  const GfxWrappedBuffer *v14; 
  const R_RT_Surface *v15; 
  const GfxWrappedBuffer *v16; 
  const R_RT_Surface *v17; 
  const GfxWrappedBuffer *v19; 
  bool v22; 
  bool v26; 
  GfxWrappedBuffer *globalSceneConstantBuffer; 
  R_RT_Handle v28; 
  ID3D12Resource *buffers; 
  R_RT_ColorHandle visibilityTexture; 
  R_RT_BufferHandle froxelIDBuffer; 
  R_RT_BufferHandle froxelIndirectBuffer; 

  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups [rsp+138h+var_D8], ymm0
    vmovups ymmword ptr [rsp+138h+var_F8.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v28);
    if ( (R_RT_Handle::GetSurface(&v28)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+138h+var_F8.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+138h+var_F8.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      __asm { vmovups ymm0, [rsp+138h+var_D8] }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
  }
  v12 = taskInfo->attachments + 1;
  __asm { vmovups ymmword ptr [rsp+138h+var_B0.baseclass_0.m_surfaceID], ymm0 }
  Surface = R_RT_Handle::GetSurface(v12);
  if ( (Surface->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
    __debugbreak();
  v14 = (const GfxWrappedBuffer *)&Surface->1080;
  v15 = R_RT_Handle::GetSurface(taskInfo->attachments + 2);
  if ( (v15->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
    __debugbreak();
  v16 = (const GfxWrappedBuffer *)&v15->1080;
  v17 = R_RT_Handle::GetSurface(taskInfo->attachments + 3);
  if ( (v17->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
    __debugbreak();
  _RAX = taskInfo->attachments;
  v19 = (const GfxWrappedBuffer *)&v17->1080;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+80h]
    vmovd   eax, xmm0
    vmovups [rsp+138h+var_D8], ymm0
    vmovups ymmword ptr [rsp+138h+var_F8.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v28);
    if ( (R_RT_Handle::GetSurface(&v28)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+138h+var_F8.m_surfaceID] }
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+138h+var_F8.m_surfaceID] }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v22 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, [rsp+138h+var_D8] }
      if ( v22 )
        __debugbreak();
    }
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymmword ptr [rsp+138h+var_70.baseclass_0.m_surfaceID], ymm0
    vmovups ymm0, ymmword ptr [rax+0A0h]
    vmovd   eax, xmm0
    vmovups [rsp+138h+var_D8], ymm0
    vmovups ymmword ptr [rsp+138h+var_F8.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v28);
    if ( (R_RT_Handle::GetSurface(&v28)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+138h+var_F8.m_surfaceID] }
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+138h+var_F8.m_surfaceID] }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v26 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, [rsp+138h+var_D8] }
      if ( v26 )
        __debugbreak();
    }
  }
  globalSceneConstantBuffer = data->globalSceneConstantBuffer;
  __asm { vmovups ymmword ptr [rsp+138h+var_90.baseclass_0.m_surfaceID], ymm0 }
  buffers = globalSceneConstantBuffer->buffer;
  R_SetComputeConstantBuffers(computeState, 7, 1, &buffers);
  R_VOL_FillIndirectScattering(computeState, viewInfo, v14, v16, v19, &froxelIndirectBuffer, &froxelIDBuffer, &visibilityTexture);
}

/*
==============
RBT_VOL_MaxFloatZ
==============
*/
void RBT_VOL_MaxFloatZ(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Handle *dstVolVisibilityRt; 
  int reProjFloatZMipMap; 
  bool v14; 
  int ambientVisibilityMipMap; 
  bool v20; 
  GfxWrappedBuffer *globalSceneConstantBuffer; 
  const R_RT_Surface *Surface; 
  const R_RT_Surface *v23; 
  R_RT_Handle v24; 
  R_RT_Handle v25; 
  R_RT_Handle v26; 
  R_RT_Handle v27; 
  ID3D12Resource *buffers; 

  dstVolVisibilityRt = taskInfo->attachments;
  reProjFloatZMipMap = viewInfo->reProjFloatZMipMap;
  __asm
  {
    vmovups ymm0, ymmword ptr [rdi+0C0h]
    vmovups ymmword ptr [rsp+0E8h+var_88.m_surfaceID], ymm0
  }
  _RAX = R_RT_GetViewInternal(&v26, &v25, 0, reProjFloatZMipMap);
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rsp+0E8h+var_88.m_surfaceID], ymm0
    vmovups ymmword ptr [rsp+0E8h+var_A8.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v24);
    if ( (R_RT_Handle::GetSurface(&v24)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+0E8h+var_A8.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+0E8h+var_A8.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v14 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, ymmword ptr [rsp+0E8h+var_88.m_surfaceID] }
      if ( v14 )
        __debugbreak();
    }
  }
  ambientVisibilityMipMap = viewInfo->ambientVisibilityMipMap;
  __asm
  {
    vmovups ymmword ptr [rsp+0E8h+var_68.m_surfaceID], ymm0
    vmovups ymm0, ymmword ptr [rdi+0C0h]
    vmovups ymmword ptr [rsp+0E8h+var_88.m_surfaceID], ymm0
  }
  _RAX = R_RT_GetViewInternal(&v27, &v25, 0, ambientVisibilityMipMap);
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rsp+0E8h+var_88.m_surfaceID], ymm0
    vmovups ymmword ptr [rsp+0E8h+var_A8.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v24);
    if ( (R_RT_Handle::GetSurface(&v24)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+0E8h+var_A8.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+0E8h+var_A8.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v20 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, ymmword ptr [rsp+0E8h+var_88.m_surfaceID] }
      if ( v20 )
        __debugbreak();
    }
  }
  globalSceneConstantBuffer = data->globalSceneConstantBuffer;
  __asm { vmovups ymmword ptr [rsp+0E8h+var_88.m_surfaceID], ymm0 }
  buffers = globalSceneConstantBuffer->buffer;
  R_SetComputeConstantBuffers(computeState, 7, 1, &buffers);
  Surface = R_RT_Handle::GetSurface(&v25);
  v23 = R_RT_Handle::GetSurface(&v26);
  R_VOL_MaxFloatZ(computeState, viewInfo, &v23->m_image.m_base, &Surface->m_image.m_base, dstVolVisibilityRt + 4, dstVolVisibilityRt + 5, dstVolVisibilityRt, dstVolVisibilityRt + 2);
}

/*
==============
RBT_VOL_SampleAmbient
==============
*/
void RBT_VOL_SampleAmbient(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Image *visibilityPrev; 
  const R_RT_Handle *v13; 
  R_RT_Handle v14; 
  ID3D12Resource *buffers; 

  _RSI = taskInfo->attachments;
  visibilityPrev = (R_RT_Image *)rgp.blackImage;
  __asm
  {
    vmovups ymm0, ymmword ptr [rsi+0C0h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rsp+98h+var_48.m_surfaceID], ymm0
  }
  if ( (_WORD)_EAX )
  {
    R_RT_Handle::GetSurface(&v14);
    visibilityPrev = &R_RT_Handle::GetSurface(&v14)->m_image;
  }
  else if ( v14.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
  {
    __debugbreak();
  }
  v13 = taskInfo->attachments + 7;
  buffers = data->globalSceneConstantBuffer->buffer;
  R_SetComputeConstantBuffers(computeState, 7, 1, &buffers);
  R_VOL_SampleLightgridImages(computeState, viewInfo, _RSI + 1, _RSI, v13, _RSI + 2, _RSI + 3, _RSI + 4, _RSI + 5, &visibilityPrev->m_base);
}

/*
==============
RBT_VOL_SampleAmbientMultiLightGrid
==============
*/
void RBT_VOL_SampleAmbientMultiLightGrid(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  R_RT_Handle *attachments; 
  ID3D12Resource *buffers; 

  attachments = taskInfo->attachments;
  buffers = data->globalSceneConstantBuffer->buffer;
  R_SetComputeConstantBuffers(computeState, 7, 1, &buffers);
  R_VOL_SampleAmbientMultiLightGrid(computeState, viewInfo, attachments, attachments + 1, attachments + 2, attachments + 4, attachments + 6, attachments + 7);
}

/*
==============
RBT_VOL_Scattering
==============
*/
void RBT_VOL_Scattering(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  unsigned int v9; 
  bool v10; 
  R_RT_Handle *attachments; 
  unsigned int v12; 
  const R_RT_Surface *Surface; 
  GfxImage *blackImage3D; 
  const GfxWrappedRWBuffer *WrappedBuffer; 
  R_RT_Handle *v18; 
  const GfxWrappedRWBuffer *v19; 
  R_RT_Handle *v20; 
  const GfxWrappedRWBuffer *v21; 
  R_RT_Handle *v22; 
  const R_RT_Surface *v23; 
  R_RT_Handle *v24; 
  const R_RT_Surface *v25; 
  R_RT_Handle *v26; 
  const R_RT_Surface *v27; 
  GfxImage *v28; 
  GfxImage *blackShadowImage; 
  bool v33; 
  GfxImage *zeroImage; 
  bool v37; 
  bool v39; 
  GfxImage *blackImage; 
  bool v43; 
  bool v45; 
  GfxImage *v49; 
  bool v51; 
  const GfxWrappedRWBuffer *v52; 
  R_RT_Handle *v53; 
  GfxImage *v55; 
  R_RT_Handle v57; 
  VolumetricScatteringResources resources; 
  VolumetricDrawStream drawStream; 
  ID3D12Resource *buffers; 

  v9 = *taskInfo->pTaskData;
  drawStream.state = computeState;
  drawStream.data = data;
  v10 = R_VOL_UseLocalMedia(data, viewInfo);
  attachments = taskInfo->attachments;
  drawStream.useLocalMedia = v10;
  drawStream.useLocalMediaPrev = v10;
  v12 = data->volumetricsIndex & 1;
  drawStream.viewInfo = viewInfo;
  drawStream.toggle = v12;
  Surface = R_RT_Handle::GetSurface(attachments);
  blackImage3D = rgp.blackImage3D;
  resources.maxFloatzImage = &Surface->m_image.m_base;
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rsp+120h+var_F0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v57);
    resources.ambientImage = &R_RT_Handle::GetSurface(&v57)->m_image.m_base;
  }
  else
  {
    if ( v57.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v57.m_surfaceID) )
      __debugbreak();
    resources.ambientImage = blackImage3D;
  }
  WrappedBuffer = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments + 2);
  v18 = taskInfo->attachments + 3;
  resources.volumesClusterBuffer = WrappedBuffer;
  v19 = R_RT_Handle::GetWrappedBuffer(v18);
  v20 = taskInfo->attachments + 4;
  resources.featureClusterBuffer = v19;
  v21 = R_RT_Handle::GetWrappedBuffer(v20);
  v22 = taskInfo->attachments + 5;
  resources.lightsClusterBuffer = v21;
  v23 = R_RT_Handle::GetSurface(v22);
  v24 = taskInfo->attachments + 6;
  resources.scatterTemporalWriteImage = &v23->m_image.m_base;
  v25 = R_RT_Handle::GetSurface(v24);
  v26 = taskInfo->attachments + 7;
  resources.scatterMomentsWriteImage = &v25->m_image.m_base;
  v27 = R_RT_Handle::GetSurface(v26);
  v28 = rgp.blackImage3D;
  resources.extinctionTemporalWriteImage = &v27->m_image.m_base;
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+100h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rsp+120h+var_F0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v57);
    resources.extinctionTemporalReadImage = &R_RT_Handle::GetSurface(&v57)->m_image.m_base;
  }
  else
  {
    if ( v57.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v57.m_surfaceID) )
      __debugbreak();
    resources.extinctionTemporalReadImage = v28;
  }
  blackShadowImage = rgp.blackShadowImage;
  _RCX = 320i64;
  v33 = (*((_DWORD *)&viewInfo->viewportFeatures + 11) & 4) != 0;
  if ( data->sunShadow.opaqueCascadeCount <= 1u )
    _RCX = 288i64;
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rcx+rax]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rsp+120h+var_F0.m_surfaceID], ymm0
  }
  if ( !(_WORD)_RAX )
  {
    if ( v57.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v57.m_surfaceID) )
      __debugbreak();
    goto LABEL_19;
  }
  R_RT_Handle::GetSurface(&v57);
  if ( !v33 )
  {
LABEL_19:
    resources.sunShadowImage = blackShadowImage;
    goto LABEL_20;
  }
  resources.sunShadowImage = &R_RT_Handle::GetSurface(&v57)->m_image.m_base;
LABEL_20:
  zeroImage = rgp.zeroImage;
  v37 = R_SunShadow_TranslucentEnabled(viewInfo);
  _RCX = taskInfo->attachments;
  v39 = v37;
  __asm
  {
    vmovups ymm0, ymmword ptr [rcx+160h]
    vmovd   ecx, xmm0
    vmovups ymmword ptr [rsp+120h+var_F0.m_surfaceID], ymm0
  }
  if ( !(_WORD)_ECX )
  {
    if ( v57.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", (unsigned __int16)_ECX + 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v57.m_surfaceID) )
      __debugbreak();
    goto LABEL_24;
  }
  R_RT_Handle::GetSurface(&v57);
  if ( !v39 )
  {
LABEL_24:
    resources.translucentSunShadowImage = zeroImage;
    goto LABEL_25;
  }
  resources.translucentSunShadowImage = &R_RT_Handle::GetSurface(&v57)->m_image.m_base;
LABEL_25:
  blackImage = rgp.blackImage;
  v43 = R_SunShadow_TranslucentEnabled(viewInfo);
  _RCX = taskInfo->attachments;
  v45 = v43;
  __asm
  {
    vmovups ymm0, ymmword ptr [rcx+180h]
    vmovd   ecx, xmm0
    vmovups ymmword ptr [rsp+120h+var_F0.m_surfaceID], ymm0
  }
  if ( !(_WORD)_ECX )
  {
    if ( v57.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", (unsigned __int16)_ECX + 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v57.m_surfaceID) )
      __debugbreak();
    goto LABEL_29;
  }
  R_RT_Handle::GetSurface(&v57);
  if ( !v45 )
  {
LABEL_29:
    resources.translucentSunShadowMaskImage = blackImage;
    goto LABEL_30;
  }
  resources.translucentSunShadowMaskImage = &R_RT_Handle::GetSurface(&v57)->m_image.m_base;
LABEL_30:
  _RAX = taskInfo->attachments;
  v49 = rgp.blackShadowImage;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+1A0h]
    vmovd   eax, xmm0
  }
  v51 = (*((_DWORD *)&viewInfo->viewportFeatures + 11) & 2) != 0;
  __asm { vmovups ymmword ptr [rsp+120h+var_F0.m_surfaceID], ymm0 }
  if ( !(_WORD)_RAX )
  {
    if ( v57.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v57.m_surfaceID) )
      __debugbreak();
    goto LABEL_34;
  }
  R_RT_Handle::GetSurface(&v57);
  if ( !v51 )
  {
LABEL_34:
    resources.spotShadowCacheStale = v49;
    goto LABEL_35;
  }
  resources.spotShadowCacheStale = &R_RT_Handle::GetSurface(&v57)->m_image.m_base;
LABEL_35:
  v52 = R_RT_Handle::GetWrappedBuffer(taskInfo->attachments + 14);
  v53 = taskInfo->attachments + 15;
  resources.indirectScatteringBuffer = v52;
  resources.froxelIDBuffer = R_RT_Handle::GetWrappedBuffer(v53);
  _RAX = taskInfo->attachments;
  v55 = rgp.blackImage;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+200h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rsp+120h+var_F0.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v57);
    resources.visibilityPrevFrameImage = &R_RT_Handle::GetSurface(&v57)->m_image.m_base;
  }
  else
  {
    if ( v57.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v57.m_surfaceID) )
      __debugbreak();
    resources.visibilityPrevFrameImage = v55;
  }
  buffers = data->globalSceneConstantBuffer->buffer;
  R_SetComputeConstantBuffers(computeState, 7, 1, &buffers);
  R_VOL_EvaluateScattering(&drawStream, &resources, v9);
}

/*
==============
RBT_VOL_ScatteringSetup
==============
*/
void RBT_VOL_ScatteringSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  unsigned int height; 
  const R_RT_Surface *Surface; 
  signed int width; 
  signed int v12; 
  signed int v13; 
  unsigned int v14; 
  int v15; 
  unsigned int reProjFloatZHeight; 
  unsigned int reProjFloatZWidth; 
  unsigned int reProjFloatZMipMap; 
  signed int v21; 
  signed int v22; 
  R_RT_Handle v23; 
  R_RT_Handle v24; 
  R_RT_Handle v25; 

  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+40h]
    vmovups [rsp+0A8h+var_38], ymm0
  }
  R_SetInputCodePersistentBuffer(&viewInfo->input, 0xDu, &v25);
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+0A0h]
    vmovups ymmword ptr [rsp+0A8h+var_58.m_surfaceID], ymm0
  }
  height = R_RT_Handle::GetSurface(&v24)->m_image.m_base.height;
  Surface = R_RT_Handle::GetSurface(&v24);
  R_SetForwardPlusClusterInfo(viewInfo, Surface->m_image.m_base.width, height);
  width = viewInfo->sceneViewport.width;
  v12 = viewInfo->sceneViewport.height;
  v13 = v12 / (signed int)viewInfo->frustumGrid.voxelCountY;
  if ( width / (signed int)viewInfo->frustumGrid.voxelCountX < v13 )
    v13 = (signed int)viewInfo->sceneViewport.width / (signed int)viewInfo->frustumGrid.voxelCountX;
  v14 = __lzcnt(v13);
  v15 = 1 << (31 - v14);
  viewInfo->reProjFloatZMipMap = 31 - v14;
  viewInfo->reProjFloatZWidth = width / v15;
  viewInfo->reProjFloatZHeight = v12 / v15;
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rsp+0A8h+var_78.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v23);
    v21 = width / (unsigned int)R_RT_Handle::GetSurface(&v23)->m_image.m_base.width;
    v22 = v12 / (unsigned int)R_RT_Handle::GetSurface(&v23)->m_image.m_base.height;
    if ( v21 < v22 )
      v22 = v21;
    reProjFloatZMipMap = 31 - __lzcnt(v22);
    reProjFloatZHeight = v12 / (1 << reProjFloatZMipMap);
    reProjFloatZWidth = width / (1 << reProjFloatZMipMap);
  }
  else
  {
    if ( v23.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v23.m_surfaceID) )
      __debugbreak();
    reProjFloatZHeight = viewInfo->reProjFloatZHeight;
    reProjFloatZWidth = viewInfo->reProjFloatZWidth;
    reProjFloatZMipMap = viewInfo->reProjFloatZMipMap;
  }
  viewInfo->ambientVisibilityMipMap = reProjFloatZMipMap;
  viewInfo->ambientVisibilityWidth = reProjFloatZWidth;
  viewInfo->ambientVisibilityHeight = reProjFloatZHeight;
}

/*
==============
RBT_VOL_WriteClusterBuffer
==============
*/
void RBT_VOL_WriteClusterBuffer(ComputeCmdBufState *computeState, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  bool v15; 
  const R_RT_Surface *Surface; 
  const GfxWrappedRWBuffer *v17; 
  const R_RT_Surface *v18; 
  R_RT_Handle v19; 
  R_RT_Handle v20; 
  R_RT_Handle v21; 

  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rsp+0A8h+var_58.m_surfaceID], ymm0
    vmovups ymmword ptr [rsp+0A8h+var_78.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v19);
    if ( (R_RT_Handle::GetSurface(&v19)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+0A8h+var_78.m_surfaceID] }
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+0A8h+var_78.m_surfaceID] }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+0A8h+var_58.m_surfaceID] }
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
  }
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymmword ptr [rsp+0A8h+var_38.m_surfaceID], ymm0
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rsp+0A8h+var_58.m_surfaceID], ymm0
    vmovups ymmword ptr [rsp+0A8h+var_78.m_surfaceID], ymm0
  }
  if ( (_WORD)_RAX )
  {
    R_RT_Handle::GetSurface(&v19);
    if ( (R_RT_Handle::GetSurface(&v19)->m_rtFlagsInternal & 8) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 348, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsBuffer())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsBuffer()") )
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+0A8h+var_78.m_surfaceID] }
    }
    else
    {
      __asm { vmovups ymm0, ymmword ptr [rsp+0A8h+var_78.m_surfaceID] }
      __debugbreak();
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX )
    {
      v15 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, ymmword ptr [rsp+0A8h+var_58.m_surfaceID] }
      if ( v15 )
        __debugbreak();
    }
  }
  __asm { vmovups ymmword ptr [rsp+0A8h+var_58.m_surfaceID], ymm0 }
  Surface = R_RT_Handle::GetSurface(&v20);
  if ( (Surface->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
    __debugbreak();
  v17 = (const GfxWrappedRWBuffer *)&Surface->1080;
  v18 = R_RT_Handle::GetSurface(&v21);
  if ( (v18->m_rtFlagsInternal & 8) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 283, ASSERT_TYPE_ASSERT, "(surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer)", (const char *)&queryFormat, "surface->m_rtFlagsInternal & R_RT_FlagInternal_Buffer") )
    __debugbreak();
  R_VOL_FrustumGridCluster(computeState, viewInfo, data, (const GfxWrappedRWBuffer *)&v18->1080, v17);
}

