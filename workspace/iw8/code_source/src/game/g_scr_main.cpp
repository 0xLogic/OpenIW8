/*
==============
Scr_PlayFXInternal
==============
*/

gentity_s *__fastcall Scr_PlayFXInternal(scrContext_t *scrContext, int fxId, const vec3_t *pos, vec3_t *forward, vec3_t *up)
{
  return ?Scr_PlayFXInternal@@YAPEAUgentity_s@@AEAUscrContext_t@@HAEBTvec3_t@@PEAT3@2@Z(scrContext, fxId, pos, forward, up);
}

/*
==============
GScr_Main_DisableAimAssistCommon
==============
*/

void __fastcall GScr_Main_DisableAimAssistCommon(gentity_s *ent)
{
  ?GScr_Main_DisableAimAssistCommon@@YAXPEAUgentity_s@@@Z(ent);
}

/*
==============
GScr_Main_NavigateDDL
==============
*/

void __fastcall GScr_Main_NavigateDDL(scrContext_t *scrContext, const DDLDef *def, const char *functionName, DDLState *state, int firstArgIndex, int *finalArgumentIndex)
{
  ?GScr_Main_NavigateDDL@@YAXAEAUscrContext_t@@PEBUDDLDef@@PEBDPEAUDDLState@@HPEAH@Z(scrContext, def, functionName, state, firstArgIndex, finalArgumentIndex);
}

/*
==============
GScr_Main_GetDDL
==============
*/

void __fastcall GScr_Main_GetDDL(scrContext_t *scrContext, DDLState *state, const DDLDef *def, const DDLContext *context, const char *callingFunction, int firstArgIndex)
{
  ?GScr_Main_GetDDL@@YAXAEAUscrContext_t@@PEAUDDLState@@PEBUDDLDef@@PEBUDDLContext@@PEBDH@Z(scrContext, state, def, context, callingFunction, firstArgIndex);
}

/*
==============
GScr_Notify
==============
*/

void __fastcall GScr_Notify(const gentity_s *ent, scr_string_t stringValue, unsigned int paramcount)
{
  ?GScr_Notify@@YAXPEBUgentity_s@@W4scr_string_t@@I@Z(ent, stringValue, paramcount);
}

/*
==============
GScr_GetScriptableLootSpawnedCountByRarity
==============
*/

void __fastcall GScr_GetScriptableLootSpawnedCountByRarity(scrContext_t *scrContext)
{
  ?GScr_GetScriptableLootSpawnedCountByRarity@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_GetWeaponFlashTagname
==============
*/

void __fastcall Scr_GetWeaponFlashTagname(scrContext_t *scrContext)
{
  ?Scr_GetWeaponFlashTagname@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_IsTouchingInternal
==============
*/

int __fastcall Scr_IsTouchingInternal(scrContext_t *scrContext, const gentity_s *ent1, const gentity_s *ent2)
{
  return ?Scr_IsTouchingInternal@@YAHAEAUscrContext_t@@PEBUgentity_s@@1@Z(scrContext, ent1, ent2);
}

/*
==============
Scr_SetFxAngles
==============
*/

void __fastcall Scr_SetFxAngles(scrContext_t *scrContext, int givenAxisCount, tmat33_t<vec3_t> *inOutAxis, vec3_t *outAngles, int fxId)
{
  ?Scr_SetFxAngles@@YAXAEAUscrContext_t@@HAEAT?$tmat33_t@Tvec3_t@@@@AEATvec3_t@@H@Z(scrContext, givenAxisCount, inOutAxis, outAngles, fxId);
}

/*
==============
GScr_Main_GetWeaponForName
==============
*/

Weapon *__fastcall GScr_Main_GetWeaponForName(Weapon *result, scrContext_t *scrContext, const char *weaponName)
{
  return ?GScr_Main_GetWeaponForName@@YA?AUWeapon@@AEAUscrContext_t@@PEBD@Z(result, scrContext, weaponName);
}

/*
==============
GScr_Main_FillWeaponArray
==============
*/

unsigned int __fastcall GScr_Main_FillWeaponArray(scrContext_t *scrContext, Weapon *outWeapons, const unsigned int weaponIndexCount)
{
  return ?GScr_Main_FillWeaponArray@@YAIAEAUscrContext_t@@PEAUWeapon@@I@Z(scrContext, outWeapons, weaponIndexCount);
}

/*
==============
GScr_GetScriptableLootCacheContents
==============
*/

void __fastcall GScr_GetScriptableLootCacheContents(scrContext_t *scrContext)
{
  ?GScr_GetScriptableLootCacheContents@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_EntityGetAIScriptedData
==============
*/

ai_scripted_t *__fastcall GScr_EntityGetAIScriptedData(scrContext_t *scrContext, gentity_s *ent)
{
  return ?GScr_EntityGetAIScriptedData@@YAPEAUai_scripted_t@@AEAUscrContext_t@@PEAUgentity_s@@@Z(scrContext, ent);
}

/*
==============
ScrCmd_GetPlayerLightLevel
==============
*/

void __fastcall ScrCmd_GetPlayerLightLevel(scrContext_t *scrContext, scr_entref_t entref)
{
  ?ScrCmd_GetPlayerLightLevel@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
Scr_FxParamError
==============
*/

void __fastcall Scr_FxParamError(ComErrorCode uniqueErrorCode, scrContext_t *scrContext, int paramIndex, const char *errorString, int fxId)
{
  ?Scr_FxParamError@@YAXW4ComErrorCode@@AEAUscrContext_t@@HPEBDH@Z(uniqueErrorCode, scrContext, paramIndex, errorString, fxId);
}

/*
==============
G_GetAngleDelta
==============
*/

double __fastcall G_GetAngleDelta(scrContext_t *scrContext, const scr_anim_t anim, const float startTime, float endTime)
{
  double result; 

  *(float *)&result = ?G_GetAngleDelta@@YAMAEAUscrContext_t@@Uscr_anim_t@@MM@Z(scrContext, anim, startTime, endTime);
  return result;
}

/*
==============
GScr_Main_PostLoadScriptsCommon
==============
*/

void GScr_Main_PostLoadScriptsCommon(void)
{
  ?GScr_Main_PostLoadScriptsCommon@@YAXXZ();
}

/*
==============
GScr_GetScriptableArrayInRadius
==============
*/

void __fastcall GScr_GetScriptableArrayInRadius(scrContext_t *scrContext)
{
  ?GScr_GetScriptableArrayInRadius@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
G_GetMoveDelta
==============
*/

void __fastcall G_GetMoveDelta(scrContext_t *scrContext, const scr_anim_t anim, const float startTime, const float endTime, vec3_t *outMoveDelta)
{
  ?G_GetMoveDelta@@YAXAEAUscrContext_t@@Uscr_anim_t@@MMAEATvec3_t@@@Z(scrContext, anim, startTime, endTime, outMoveDelta);
}

/*
==============
GScr_GetEntitylessScriptableArray
==============
*/

void __fastcall GScr_GetEntitylessScriptableArray(scrContext_t *scrContext)
{
  ?GScr_GetEntitylessScriptableArray@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_GetScriptableLootSpawnedCountByName
==============
*/

void __fastcall GScr_GetScriptableLootSpawnedCountByName(scrContext_t *scrContext)
{
  ?GScr_GetScriptableLootSpawnedCountByName@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
ScrCmd_MotionBlurHQEnable
==============
*/

void __fastcall ScrCmd_MotionBlurHQEnable(scrContext_t *scrContext, scr_entref_t entref)
{
  ?ScrCmd_MotionBlurHQEnable@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
Scr_VerifyWeapon
==============
*/

void __fastcall Scr_VerifyWeapon(scrContext_t *scrContext, const Weapon *r_weapon, bool isAlternate, const char *weaponName)
{
  ?Scr_VerifyWeapon@@YAXAEAUscrContext_t@@AEBUWeapon@@_NPEBD@Z(scrContext, r_weapon, isAlternate, weaponName);
}

/*
==============
GScr_FreeScriptable
==============
*/

void __fastcall GScr_FreeScriptable(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScr_FreeScriptable@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_GetEntityAllowNull
==============
*/

gentity_s *__fastcall GScr_GetEntityAllowNull(unsigned int index)
{
  return ?GScr_GetEntityAllowNull@@YAPEAUgentity_s@@I@Z(index);
}

/*
==============
Scr_GetWeaponArrayInRadius
==============
*/

void __fastcall Scr_GetWeaponArrayInRadius(scrContext_t *scrContext)
{
  ?Scr_GetWeaponArrayInRadius@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_Main_WeaponParamError
==============
*/

void __fastcall GScr_Main_WeaponParamError(ComErrorCode uniqueErrorCode, scrContext_t *scrContext, const unsigned int index, const Weapon *r_weapon, const char *weaponFormatString)
{
  ?GScr_Main_WeaponParamError@@YAXW4ComErrorCode@@AEAUscrContext_t@@IAEBUWeapon@@PEBD@Z(uniqueErrorCode, scrContext, index, r_weapon, weaponFormatString);
}

/*
==============
GScr_GetLootScriptableArrayInRadius
==============
*/

void __fastcall GScr_GetLootScriptableArrayInRadius(scrContext_t *scrContext)
{
  ?GScr_GetLootScriptableArrayInRadius@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
ScrCmd_SetSolid
==============
*/

void __fastcall ScrCmd_SetSolid(scrContext_t *scrContext, scr_entref_t entref)
{
  ?ScrCmd_SetSolid@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_FreeScripts
==============
*/

void GScr_FreeScripts(void)
{
  ?GScr_FreeScripts@@YAXXZ();
}

/*
==============
GScr_UpdateTagInternal
==============
*/

int __fastcall GScr_UpdateTagInternal(scrContext_t *scrContext, gentity_s *ent, scr_string_t tagName, cached_tag_mat_t *cachedTag, int shouldUseCache, int showScriptError)
{
  return ?GScr_UpdateTagInternal@@YAHAEAUscrContext_t@@PEAUgentity_s@@W4scr_string_t@@PEAUcached_tag_mat_t@@HH@Z(scrContext, ent, tagName, cachedTag, shouldUseCache, showScriptError);
}

/*
==============
GScr_IsScriptableDefined
==============
*/

void __fastcall GScr_IsScriptableDefined(scrContext_t *scrContext)
{
  ?GScr_IsScriptableDefined@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
ScrCmd_MotionBlurHQDisable
==============
*/

void __fastcall ScrCmd_MotionBlurHQDisable(scrContext_t *scrContext, scr_entref_t entref)
{
  ?ScrCmd_MotionBlurHQDisable@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_Main_EnableAimAssistCommon
==============
*/

void __fastcall GScr_Main_EnableAimAssistCommon(gentity_s *ent)
{
  ?GScr_Main_EnableAimAssistCommon@@YAXPEAUgentity_s@@@Z(ent);
}

/*
==============
GScr_Main_GetWeaponParam
==============
*/

void __fastcall GScr_Main_GetWeaponParam(scrContext_t *scrContext, const unsigned int index, Weapon *outWeapon, bool *outIsAlternate)
{
  ?GScr_Main_GetWeaponParam@@YAXAEAUscrContext_t@@IPEAUWeapon@@PEA_N@Z(scrContext, index, outWeapon, outIsAlternate);
}

/*
==============
GScr_EntityGetShootAtPos
==============
*/

void __fastcall GScr_EntityGetShootAtPos(scrContext_t *scrContext, gentity_s *ent, vec3_t *outShootAtPos)
{
  ?GScr_EntityGetShootAtPos@@YAXAEAUscrContext_t@@PEAUgentity_s@@AEATvec3_t@@@Z(scrContext, ent, outShootAtPos);
}

/*
==============
G_SetEntityFlag
==============
*/

void __fastcall G_SetEntityFlag(gentity_s *ent, EntityStateFlagsCommon flag)
{
  ?G_SetEntityFlag@@YAXPEAUgentity_s@@W4EntityStateFlagsCommon@@@Z(ent, flag);
}

/*
==============
GScr_GetMethod
==============
*/

unsigned int __fastcall GScr_GetMethod(const char **pName, BuiltinType *type)
{
  return ?GScr_GetMethod@@YAIPEAPEBDPEAW4BuiltinType@@@Z(pName, type);
}

/*
==============
GScr_ExecSpawnerThread
==============
*/

unsigned int __fastcall GScr_ExecSpawnerThread(const spawner_t *spawner, int handle, unsigned int paramcount)
{
  return ?GScr_ExecSpawnerThread@@YAIPEBUspawner_t@@HI@Z(spawner, handle, paramcount);
}

/*
==============
GScr_AddEntity
==============
*/

void __fastcall GScr_AddEntity(const gentity_s *ent)
{
  ?GScr_AddEntity@@YAXPEBUgentity_s@@@Z(ent);
}

/*
==============
GScr_SpawnScriptable
==============
*/

void __fastcall GScr_SpawnScriptable(scrContext_t *scrContext)
{
  ?GScr_SpawnScriptable@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_Main_UpdateClassMap
==============
*/

void GScr_Main_UpdateClassMap(void)
{
  ?GScr_Main_UpdateClassMap@@YAXXZ();
}

/*
==============
Scr_GetWeaponArray
==============
*/

void __fastcall Scr_GetWeaponArray(scrContext_t *scrContext)
{
  ?Scr_GetWeaponArray@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_AllocString
==============
*/

scr_string_t __fastcall GScr_AllocString(const char *s)
{
  return ?GScr_AllocString@@YA?AW4scr_string_t@@PEBD@Z(s);
}

/*
==============
GScr_Main_RagdollBlendInit
==============
*/

void __fastcall GScr_Main_RagdollBlendInit(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScr_Main_RagdollBlendInit@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_SpawnRagdollConstraint
==============
*/

void __fastcall GScr_SpawnRagdollConstraint(scrContext_t *scrContext)
{
  ?GScr_SpawnRagdollConstraint@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_ExecEntThreadWithReturnValue
==============
*/

unsigned int __fastcall GScr_ExecEntThreadWithReturnValue(const gentity_s *ent, int handle, unsigned int paramcount, void (__fastcall *callback)(scrContext_t *, const void *, void *), const void *cbUserData, void *outReturnValue)
{
  return ?GScr_ExecEntThreadWithReturnValue@@YAIPEBUgentity_s@@HIP6AXAEAUscrContext_t@@PEBXPEAX@Z23@Z(ent, handle, paramcount, callback, cbUserData, outReturnValue);
}

/*
==============
GScr_MakeVehicleSolidSphere
==============
*/

void __fastcall GScr_MakeVehicleSolidSphere(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScr_MakeVehicleSolidSphere@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
G_LocalToWorldCoords
==============
*/

void __fastcall G_LocalToWorldCoords(const gentity_s *pSelf, const vec3_t *local, vec3_t *outWorld)
{
  ?G_LocalToWorldCoords@@YAXPEBUgentity_s@@AEBTvec3_t@@AEAT2@@Z(pSelf, local, outWorld);
}

/*
==============
GScrCmd_SetWaterSheeting
==============
*/

void __fastcall GScrCmd_SetWaterSheeting(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScrCmd_SetWaterSheeting@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
Scr_MagicBullet
==============
*/

void __fastcall Scr_MagicBullet(scrContext_t *scrContext)
{
  ?Scr_MagicBullet@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_FreeEntity
==============
*/

void __fastcall GScr_FreeEntity(gentity_s *ent)
{
  ?GScr_FreeEntity@@YAXPEAUgentity_s@@@Z(ent);
}

/*
==============
GScr_DisconnectNodePair
==============
*/

void __fastcall GScr_DisconnectNodePair(scrContext_t *scrContext)
{
  ?GScr_DisconnectNodePair@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_SpawnCustomWeaponScriptable
==============
*/

void __fastcall GScr_SpawnCustomWeaponScriptable(scrContext_t *scrContext)
{
  ?GScr_SpawnCustomWeaponScriptable@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_GetScriptCacheContents
==============
*/

void __fastcall GScr_GetScriptCacheContents(scrContext_t *scrContext)
{
  ?GScr_GetScriptCacheContents@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_GetNoTarget
==============
*/

void __fastcall Scr_GetNoTarget(scrContext_t *scrContext, gentity_s *ent, int offset)
{
  ?Scr_GetNoTarget@@YAXAEAUscrContext_t@@PEAUgentity_s@@H@Z(scrContext, ent, offset);
}

/*
==============
GScr_SetChargeMeleeHudVisible
==============
*/

void __fastcall GScr_SetChargeMeleeHudVisible(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScr_SetChargeMeleeHudVisible@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
Scr_GetTeamFlags
==============
*/

bitarray<224> *__fastcall Scr_GetTeamFlags(bitarray<224> *result, scrContext_t *scrContext, unsigned int i)
{
  return ?Scr_GetTeamFlags@@YA?AV?$bitarray@$0OA@@@AEAUscrContext_t@@I@Z(result, scrContext, i);
}

/*
==============
GScr_GetScriptableArray
==============
*/

void __fastcall GScr_GetScriptableArray(scrContext_t *scrContext)
{
  ?GScr_GetScriptableArray@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_Main_SetDDL
==============
*/

void __fastcall GScr_Main_SetDDL(scrContext_t *scrContext, DDLState *state, const DDLDef *def, DDLContext *context, const char *callingFunction, int firstArgIndex)
{
  ?GScr_Main_SetDDL@@YAXAEAUscrContext_t@@PEAUDDLState@@PEBUDDLDef@@PEAUDDLContext@@PEBDH@Z(scrContext, state, def, context, callingFunction, firstArgIndex);
}

/*
==============
Scr_EmitScriptBundlesAnimations
==============
*/

void __fastcall Scr_EmitScriptBundlesAnimations(scrContext_t *scrContext)
{
  ?Scr_EmitScriptBundlesAnimations@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_Main_GetPlayerEntity
==============
*/

gentity_s *__fastcall GScr_Main_GetPlayerEntity(scrContext_t *scrContext, scr_entref_t entref)
{
  return ?GScr_Main_GetPlayerEntity@@YAPEAUgentity_s@@AEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
ScrCmd_SetScriptablePartZeroState_Hack
==============
*/

void __fastcall ScrCmd_SetScriptablePartZeroState_Hack(scrContext_t *scrContext, scr_entref_t entref)
{
  ?ScrCmd_SetScriptablePartZeroState_Hack@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_Main_DeleteCommon
==============
*/

void __fastcall GScr_Main_DeleteCommon(scrContext_t *scrContext, gentity_s *ent)
{
  ?GScr_Main_DeleteCommon@@YAXAEAUscrContext_t@@PEAUgentity_s@@@Z(scrContext, ent);
}

/*
==============
GScr_MakeVehicleSolidCapsule
==============
*/

void __fastcall GScr_MakeVehicleSolidCapsule(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScr_MakeVehicleSolidCapsule@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_PickScriptableLootItem
==============
*/

void __fastcall GScr_PickScriptableLootItem(scrContext_t *scrContext)
{
  ?GScr_PickScriptableLootItem@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_Main_StructuredDataPrintArgs
==============
*/

void __fastcall GScr_Main_StructuredDataPrintArgs(scrContext_t *scrContext, const char *functionName)
{
  ?GScr_Main_StructuredDataPrintArgs@@YAXAEAUscrContext_t@@PEBD@Z(scrContext, functionName);
}

/*
==============
GScr_ScriptBundleContextScoped::~GScr_ScriptBundleContextScoped
==============
*/

void __fastcall GScr_ScriptBundleContextScoped::~GScr_ScriptBundleContextScoped(GScr_ScriptBundleContextScoped *this)
{
  ??1GScr_ScriptBundleContextScoped@@QEAA@XZ(this);
}

/*
==============
Scr_SetAngles
==============
*/

void __fastcall Scr_SetAngles(scrContext_t *scrContext, gentity_s *ent, int offset)
{
  ?Scr_SetAngles@@YAXAEAUscrContext_t@@PEAUgentity_s@@H@Z(scrContext, ent, offset);
}

/*
==============
GScr_IsOnLadder
==============
*/

void __fastcall GScr_IsOnLadder(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScr_IsOnLadder@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_Shutdown
==============
*/

void GScr_Shutdown(void)
{
  ?GScr_Shutdown@@YAXXZ();
}

/*
==============
GScr_GetScriptableLootSpawnedCountByType
==============
*/

void __fastcall GScr_GetScriptableLootSpawnedCountByType(scrContext_t *scrContext)
{
  ?GScr_GetScriptableLootSpawnedCountByType@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_MakeGameMessage
==============
*/

void __fastcall GScr_MakeGameMessage(scrContext_t *scrContext, int clientNum, const char cmd)
{
  ?GScr_MakeGameMessage@@YAXAEAUscrContext_t@@HD@Z(scrContext, clientNum, cmd);
}

/*
==============
GScr_GetEntity
==============
*/

gentity_s *__fastcall GScr_GetEntity(unsigned int index)
{
  return ?GScr_GetEntity@@YAPEAUgentity_s@@I@Z(index);
}

/*
==============
GScr_SetOmnvarInternal
==============
*/

void __fastcall GScr_SetOmnvarInternal(scrContext_t *scrContext, const OmnvarDef *def, OmnvarData *data, int valueArgumentIndex)
{
  ?GScr_SetOmnvarInternal@@YAXAEAUscrContext_t@@PEBUOmnvarDef@@PEAUOmnvarData@@H@Z(scrContext, def, data, valueArgumentIndex);
}

/*
==============
GScr_ExecEntThread
==============
*/

unsigned int __fastcall GScr_ExecEntThread(const gentity_s *ent, int handle, unsigned int paramcount)
{
  return ?GScr_ExecEntThread@@YAIPEBUgentity_s@@HI@Z(ent, handle, paramcount);
}

/*
==============
Scr_LocalizationError
==============
*/

void __fastcall Scr_LocalizationError(scrContext_t *scrContext, int iParm, const char *pszErrorMessage)
{
  ?Scr_LocalizationError@@YAXAEAUscrContext_t@@HPEBD@Z(scrContext, iParm, pszErrorMessage);
}

/*
==============
Scr_GetTeamFlag
==============
*/

bitarray<224> *__fastcall Scr_GetTeamFlag(bitarray<224> *result, scrContext_t *scrContext, scr_string_t teamName)
{
  return ?Scr_GetTeamFlag@@YA?AV?$bitarray@$0OA@@@AEAUscrContext_t@@W4scr_string_t@@@Z(result, scrContext, teamName);
}

/*
==============
Scr_ValidateLocalizedStringRef
==============
*/

void __fastcall Scr_ValidateLocalizedStringRef(scrContext_t *scrContext, int parmIndex, const char *token, int tokenLen)
{
  ?Scr_ValidateLocalizedStringRef@@YAXAEAUscrContext_t@@HPEBDH@Z(scrContext, parmIndex, token, tokenLen);
}

/*
==============
GScr_GetStandaloneScriptableIndex
==============
*/

unsigned int __fastcall GScr_GetStandaloneScriptableIndex(scrContext_t *scrContext, const scr_entref_t *entref)
{
  return ?GScr_GetStandaloneScriptableIndex@@YAIAEAUscrContext_t@@AEBUscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_ConnectNodePair
==============
*/

void __fastcall GScr_ConnectNodePair(scrContext_t *scrContext)
{
  ?GScr_ConnectNodePair@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_GetLootScriptableArray
==============
*/

void __fastcall GScr_GetLootScriptableArray(scrContext_t *scrContext)
{
  ?GScr_GetLootScriptableArray@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
ScrCmd_MakeCollideWithItemClip
==============
*/

void __fastcall ScrCmd_MakeCollideWithItemClip(scrContext_t *scrContext, scr_entref_t entref)
{
  ?ScrCmd_MakeCollideWithItemClip@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_GetFunction
==============
*/

unsigned int __fastcall GScr_GetFunction(const char **pName, BuiltinType *type)
{
  return ?GScr_GetFunction@@YAIPEAPEBDPEAW4BuiltinType@@@Z(pName, type);
}

/*
==============
Scr_SetOrigin
==============
*/

void __fastcall Scr_SetOrigin(scrContext_t *scrContext, gentity_s *ent, int offset)
{
  ?Scr_SetOrigin@@YAXAEAUscrContext_t@@PEAUgentity_s@@H@Z(scrContext, ent, offset);
}

/*
==============
GScr_SetScriptablePayloadModel
==============
*/

void __fastcall GScr_SetScriptablePayloadModel(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScr_SetScriptablePayloadModel@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_SetScriptablePayloadWeapon
==============
*/

void __fastcall GScr_SetScriptablePayloadWeapon(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScr_SetScriptablePayloadWeapon@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_Scriptable_GetScriptableInstanceFromIndex
==============
*/

void __fastcall GScr_Scriptable_GetScriptableInstanceFromIndex(scrContext_t *scrContext)
{
  ?GScr_Scriptable_GetScriptableInstanceFromIndex@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_LoadLevel
==============
*/

void GScr_LoadLevel(void)
{
  ?GScr_LoadLevel@@YAXXZ();
}

/*
==============
GScr_GetScriptableArray
==============
*/
void GScr_GetScriptableArray(scrContext_t *scrContext, const unsigned int begin, const unsigned int end, const int *offset, const scr_string_t name, const vec3_t *fromOrigin, const float radius, const scr_string_t partName)
{
  unsigned int v9; 
  unsigned int v10; 
  const scriptable_field_t *v12; 
  const char *v13; 
  ComErrorCode v14; 
  ScriptableInstance *v15; 
  int v16; 
  bool v17; 
  const vec3_t *InstanceOrigin; 
  float v19; 
  float v20; 
  __int64 v21; 
  ScriptableInstance *outInstance; 

  v9 = end;
  v10 = begin;
  if ( begin > end && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_scriptable.cpp", 357, ASSERT_TYPE_ASSERT, "( begin <= end )", (const char *)&queryFormat, "begin <= end") )
    __debugbreak();
  v12 = NULL;
  if ( fromOrigin )
  {
    *(float *)&outInstance = fromOrigin->v[0];
    if ( ((unsigned int)outInstance & 0x7F800000) == 2139095040 || (*(float *)&outInstance = fromOrigin->v[1], ((unsigned int)outInstance & 0x7F800000) == 2139095040) || (*(float *)&outInstance = fromOrigin->v[2], ((unsigned int)outInstance & 0x7F800000) == 2139095040) )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_scriptable.cpp", 364, ASSERT_TYPE_SANITY, "( !IS_NAN( ( *fromOrigin )[0] ) && !IS_NAN( ( *fromOrigin )[1] ) && !IS_NAN( ( *fromOrigin )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( *fromOrigin )[0] ) && !IS_NAN( ( *fromOrigin )[1] ) && !IS_NAN( ( *fromOrigin )[2] )") )
        __debugbreak();
    }
    if ( (float)(radius * radius) < 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_scriptable.cpp", 365, ASSERT_TYPE_ASSERT, "( radiusSq >= 0 )", (const char *)&queryFormat, "radiusSq >= 0") )
      __debugbreak();
  }
  if ( offset )
  {
    if ( *offset >= 0xCu )
    {
      LODWORD(v21) = *offset;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_scriptable.cpp", 371, ASSERT_TYPE_ASSERT, "(unsigned)( *offset ) < (unsigned)( S_SCRIPTABLE_FIELD_COUNT )", "*offset doesn't index S_SCRIPTABLE_FIELD_COUNT\n\t%i not in [0, %i)", v21, 12) )
        __debugbreak();
    }
    v12 = &s_scriptableFields[*offset];
    if ( v12->type == F_STRING )
    {
      if ( v12->ofs != -1 )
        goto LABEL_22;
      v13 = "key cannot be used for lookup";
      v14 = COM_ERR_2780;
    }
    else
    {
      v13 = "key is not internally a string";
      v14 = COM_ERR_2779;
    }
    Scr_ParamError(v14, scrContext, 1u, v13);
  }
LABEL_22:
  Scr_MakeArray(scrContext);
  while ( v10 < v9 )
  {
    if ( ScriptableSv_GetInstanceInUse(v10) && ScriptableSv_GetInstanceCommonContext(v10)->linkedObjectType == SCRIPTABLE_LINK_NONE )
    {
      if ( offset )
      {
        if ( !v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_scriptable.cpp", 401, ASSERT_TYPE_ASSERT, "( field )", (const char *)&queryFormat, "field") )
          __debugbreak();
        if ( !ScriptableCommon_GetMapInstance(v10, (const ScriptableInstance **)&outInstance) )
          goto LABEL_43;
        v15 = outInstance;
        if ( !outInstance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_scriptable.cpp", 409, ASSERT_TYPE_ASSERT, "( instance )", (const char *)&queryFormat, "instance") )
          __debugbreak();
        v16 = *(_DWORD *)((char *)&v15->initialDef + v12->ofs);
        v9 = end;
        if ( !v16 )
          goto LABEL_43;
        v17 = v16 == name;
      }
      else
      {
        if ( !name )
          goto LABEL_38;
        v17 = ScriptableSv_GetInstanceType(v10) == name;
      }
      if ( v17 )
      {
LABEL_38:
        if ( !fromOrigin || (InstanceOrigin = ScriptableSv_GetInstanceOrigin(v10), v19 = fromOrigin->v[1] - InstanceOrigin->v[1], v20 = fromOrigin->v[2] - InstanceOrigin->v[2], (float)((float)((float)(v19 * v19) + (float)((float)(fromOrigin->v[0] - InstanceOrigin->v[0]) * (float)(fromOrigin->v[0] - InstanceOrigin->v[0]))) + (float)(v20 * v20)) <= (float)(radius * radius)) )
        {
          if ( !partName || ScriptableSv_GetPartScriptedDefFromName(v10, partName, 0) )
          {
            Scr_AddEntityNum(scrContext, v10, ENTITY_CLASS_SCRIPTABLE);
            Scr_AddArray(scrContext);
          }
        }
      }
    }
LABEL_43:
    ++v10;
  }
}

/*
==============
ScrCmd_SetTeamInHudData
==============
*/
void ScrCmd_SetTeamInHudData(scrContext_t *scrContext, scr_entref_t entref)
{
  char Int; 
  gentity_s *Entity; 
  HudData *HudData; 

  if ( MLG_IsCoDCasterEnabled() )
  {
    if ( !Scr_GetNumParam(scrContext) )
      Scr_Error(COM_ERR_4108, scrContext, "SetTeamInHudData takes at least 1 parameter");
    Int = Scr_GetInt(scrContext, 0);
    Entity = GetEntity(entref);
    HudData = G_HudOutline_GetHudData(Entity);
    if ( !HudData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 6612, ASSERT_TYPE_ASSERT, "( hudData ) != ( nullptr )", "%s != %s\n\t%p, %p", "hudData", "nullptr", NULL, NULL) )
      __debugbreak();
    HudData->data &= 0xFFFFFE7F;
    HudData->data |= (Int & 3) << 7;
  }
}

/*
==============
Scr_GetMLGSettings
==============
*/
void Scr_GetMLGSettings(scrContext_t *scrContext)
{
  int Int; 
  const DDLDef *DDLDef; 
  const DDLContext *DDLContext; 
  DDLState state; 

  if ( !Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_4109, scrContext, "GetMLGSettings takes at least 1 parameter");
  Int = Scr_GetInt(scrContext, 0);
  if ( GamerProfile_IsDDLMounted(Int, MLG_SETTINGS) )
  {
    DDLDef = GamerProfile_GetDDLDef(Int, MLG_SETTINGS);
    __asm { vpxor   xmm0, xmm0, xmm0 }
    state.isValid = 0;
    state.offset = 0;
    state.arrayIndex = -1;
    *(_OWORD *)&state.member = _XMM0;
    DDLContext = GamerProfile_GetDDLContext(Int, MLG_SETTINGS);
    GamerProfile_GetDDLState(&state, Int, MLG_SETTINGS);
    GScr_Main_GetDDL(scrContext, &state, DDLDef, DDLContext, "GetMLGSettings", 1);
  }
  else
  {
    Scr_AddUndefined(scrContext);
  }
}

/*
==============
ScrCmd_SetOtherEnt
==============
*/
void ScrCmd_SetOtherEnt(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( Entity->client )
  {
    Scr_Error(COM_ERR_4110, scrContext, "SetOtherEnt() cannot be called on a client");
  }
  else if ( Scr_GetType(scrContext, 0) )
  {
    Entity->s.otherEntityNum = GScr_GetEntity(0)->s.number;
  }
  else
  {
    Entity->s.otherEntityNum = 2047;
  }
}

/*
==============
GScr_Spawn
==============
*/
void GScr_Spawn(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  int v3; 
  int Int; 
  gentity_s *v5; 
  const char *v6; 
  const char *v7; 
  vec3_t vectorValue; 

  ConstString = Scr_GetConstString(scrContext, 0);
  Scr_GetVector(scrContext, 1u, &vectorValue);
  v3 = 0;
  if ( Scr_GetNumParam(scrContext) <= 2 )
    Int = 0;
  else
    Int = Scr_GetInt(scrContext, 2u);
  if ( Scr_GetNumParam(scrContext) > 3 )
    v3 = Scr_GetInt(scrContext, 3u);
  v5 = G_Utils_SpawnEntity();
  Scr_SetString(&v5->script_classname, ConstString);
  v5->r.currentOrigin = vectorValue;
  v5->spawnflags = Int;
  if ( G_Spawn_CallForEntity(v5) )
  {
    if ( v3 == 1 )
      GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(&v5->s.lerp.eFlags, ACTIVE, 0);
    GScr_AddEntity(v5);
  }
  else
  {
    G_FreeEntity(v5);
    v6 = SL_ConvertToString(ConstString);
    v7 = j_va("unable to spawn \"%s\" entity", v6);
    Scr_Error(COM_ERR_4111, scrContext, v7);
  }
}

/*
==============
GScr_SpawnScriptItem
==============
*/
void GScr_SpawnScriptItem(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  gentity_s *v3; 
  const char *v4; 
  const char *v5; 

  ConstString = Scr_GetConstString(scrContext, 0);
  v3 = G_Utils_SpawnEntity();
  Scr_SetString(&v3->script_classname, ConstString);
  if ( G_Spawn_CallForEntity(v3) )
  {
    GScr_AddEntity(v3);
  }
  else
  {
    G_FreeEntity(v3);
    v4 = SL_ConvertToString(ConstString);
    v5 = j_va("unable to spawn \"%s\" entity", v4);
    Scr_Error(COM_ERR_4112, scrContext, v5);
  }
}

/*
==============
GScr_SpawnCoverWall
==============
*/
void GScr_SpawnCoverWall(scrContext_t *scrContext)
{
  unsigned int Int; 
  unsigned int NumParam; 
  const dvar_t *v4; 
  const gentity_s *v5; 
  vec3_t vectorValue; 
  vec3_t origin; 

  Int = 0;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam - 2 <= 1 )
  {
    Scr_GetVector(scrContext, 1u, &vectorValue);
    Scr_GetVector(scrContext, 0, &origin);
    if ( NumParam == 3 )
    {
      Int = Scr_GetInt(scrContext, 2u);
      if ( Int - 1 > 0xFE )
      {
        v4 = DVARINT_g_coverWall_coverHealth;
        if ( !DVARINT_g_coverWall_coverHealth && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "g_coverWall_coverHealth") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v4);
        Com_PrintWarning(16, "Warning: SpawnCoverWall - healthPerBlock %d is out of range [1,255], using default value %d\n", Int, v4->current.unsignedInt);
        Int = 0;
      }
    }
    v5 = G_CoverWall_Spawn(&origin, &vectorValue, Int);
    if ( v5 )
    {
      GScr_AddEntity(v5);
    }
    else
    {
      Com_PrintWarning(16, "Warning: SpawnCoverWall failed - reached max of %d coverwalls in the world.\n", 16i64);
      Scr_AddUndefined(scrContext);
    }
  }
  else
  {
    Scr_Error(COM_ERR_4113, scrContext, "USAGE: SpawnCoverWall( <origin>, <angles> <optional:healthPerBlock> )\n");
  }
}

/*
==============
ScrCmd_DeSpawnCoverWall
==============
*/
void ScrCmd_DeSpawnCoverWall(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  bool v4; 

  Entity = GetEntity(entref);
  if ( Entity->s.eType == ET_COVERWALL )
  {
    v4 = 0;
    if ( Scr_GetNumParam(scrContext) )
      v4 = Scr_GetInt(scrContext, 0) != 0;
    G_CoverWall_DeSpawn(Entity, v4);
  }
  else
  {
    Scr_Error(COM_ERR_4114, scrContext, " DeSpawnCoverWall() called on an entity that is not a cover wall.\n");
  }
}

/*
==============
GScr_Turret_Spawn
==============
*/
void GScr_Turret_Spawn(scrContext_t *scrContext)
{
  int Int; 
  scr_string_t ConstString; 
  gentity_s *v4; 
  bool outIsAlternate; 
  vec3_t vectorValue; 
  Weapon outWeapon; 

  Int = 1;
  ConstString = Scr_GetConstString(scrContext, 0);
  Scr_GetVector(scrContext, 1u, &vectorValue);
  GScr_Main_GetWeaponParam(scrContext, 2u, &outWeapon, &outIsAlternate);
  v4 = G_Utils_SpawnEntity();
  Scr_SetString(&v4->classname, ConstString);
  Scr_SetString(&v4->script_classname, ConstString);
  v4->r.currentOrigin = vectorValue;
  if ( Scr_GetNumParam(scrContext) > 3 )
    Int = Scr_GetInt(scrContext, 3u);
  G_Turret_Spawn(scrContext, v4, &outWeapon, Int);
  GScr_AddEntity(v4);
}

/*
==============
GScr_Turret_CanSpawn
==============
*/
void GScr_Turret_CanSpawn(scrContext_t *scrContext)
{
  bool CanSpawnTurret; 

  CanSpawnTurret = GTurret::CanSpawnTurret();
  Scr_AddBool(scrContext, CanSpawnTurret);
}

/*
==============
GScr_Turret_Precache
==============
*/
void GScr_Turret_Precache(scrContext_t *scrContext)
{
  const char *String; 
  Weapon result; 

  if ( NetConstStrings_IsPrecacheAllowed() )
  {
    if ( !level.initializing )
      Scr_Error(COM_ERR_4115, scrContext, "precacheTurret must be called before any wait statements in the level script\n");
    String = Scr_GetString(scrContext, 0);
    GScr_Main_GetWeaponForName(&result, scrContext, String);
  }
}

/*
==============
ScrCmd_attach
==============
*/
void ScrCmd_attach(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t tagNameResult; 

  Entity = GetEntity(entref);
  AttachCmd(scrContext, Entity, &tagNameResult);
}

/*
==============
ScrCmd_attachShieldModel
==============
*/
void ScrCmd_attachShieldModel(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  char *client; 
  const char *v6; 
  scr_string_t tagNameResult; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3682, scrContext, "not an entity");
    client = NULL;
    v4 = NULL;
LABEL_9:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 7059, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
      __debugbreak();
    goto LABEL_11;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 7057, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = (char *)v4->client;
  if ( !client )
  {
    client = (char *)v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3679, scrContext, v6);
      goto LABEL_9;
    }
  }
LABEL_11:
  if ( AttachCmd(scrContext, v4, &tagNameResult) )
  {
    GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal((GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *)(client + 28), ACTIVE, 8u);
    if ( G_Utils_IsAgent(v4) )
    {
      if ( !v4->agent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 7069, ASSERT_TYPE_ASSERT, "( pSelf->agent )", (const char *)&queryFormat, "pSelf->agent") )
        __debugbreak();
      Scr_SetString(&v4->agent->attachShieldTagName, tagNameResult);
    }
    else
    {
      if ( !v4->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 7074, ASSERT_TYPE_ASSERT, "( pSelf->client )", (const char *)&queryFormat, "pSelf->client") )
        __debugbreak();
      Scr_SetString(&v4->client->attachShieldTagName, tagNameResult);
    }
  }
}

/*
==============
GScr_GetScriptBundle
==============
*/
void GScr_GetScriptBundle(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  unsigned int v3; 
  XAssetHeader v4; 
  XAssetHeader v5; 
  ScriptBundleValue *v6; 
  GScr_ScriptBundleContext ctxt; 

  ConstString = Scr_GetConstString(scrContext, 0);
  if ( !ConstString && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\script\\scr_stringlist.h", 158, ASSERT_TYPE_ASSERT, "( stringValue )", (const char *)&queryFormat, "stringValue") )
    __debugbreak();
  v3 = 16 * ConstString;
  if ( v3 >= 0x800000 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\script\\scr_stringlist.h", 159, ASSERT_TYPE_ASSERT, "( stringValue * MT_NODE_SIZE < MT_SIZE )", (const char *)&queryFormat, "stringValue * MT_NODE_SIZE < MT_SIZE") )
    __debugbreak();
  v4.physicsLibrary = DB_FindXAssetHeader(ASSET_TYPE_SCRIPTBUNDLE, &scrMemTreePub.mt_buffer[v3 + 8], 0).physicsLibrary;
  v5.physicsLibrary = v4.physicsLibrary;
  if ( v4.physicsLibrary )
  {
    if ( SLODWORD(v4.physicsLibrary[1].name) <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 26230, ASSERT_TYPE_ASSERT, "(bundle.scriptBundle->rootSize > 0)", (const char *)&queryFormat, "bundle.scriptBundle->rootSize > 0") )
      __debugbreak();
    ctxt.strPool = v5.physicsLibrary->havokData;
    ctxt.currentAnimTree = s_defaultScriptbundleAnimtree;
    ctxt.pScrContext = scrContext;
    ScriptContext_GetInstance(scrContext);
    v6 = *(ScriptBundleValue **)&v5.physicsLibrary[1].isMaterialList;
    ctxt.anim_user = 1;
    GScr_SBAddObject(&ctxt, v6);
  }
  else
  {
    Scr_AddUndefined(scrContext);
  }
}

/*
==============
GScr_IPrintLn_f
==============
*/
void GScr_IPrintLn_f(scrContext_t *scrContext)
{
  GScr_MakeGameMessage(scrContext, -1, 102);
}

/*
==============
GScr_IPrintLnBold_f
==============
*/
void GScr_IPrintLnBold_f(scrContext_t *scrContext)
{
  GScr_MakeGameMessage(scrContext, -1, 103);
}

/*
==============
GScr_AssertDemo
==============
*/
void GScr_AssertDemo(scrContext_t *scrContext)
{
  ;
}

/*
==============
Scr_GetReflectionLocs
==============
*/
void Scr_GetReflectionLocs(scrContext_t *scrContext)
{
  Scr_MakeArray(scrContext);
}

/*
==============
ScrCmd_moveShieldModel
==============
*/
void ScrCmd_moveShieldModel(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  const char *String; 
  scr_string_t ConstLowercaseString; 
  scr_string_t v8; 
  bool v9; 
  const char *v10; 
  const char *v11; 
  bool v12; 
  unsigned int *p_attachModelIsOnBack; 
  __int64 v14; 
  scr_string_t *p_attachShieldTagName; 
  unsigned int outModelIndex; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3678, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 7104, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client && !v4->agent )
    {
      v5 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3677, scrContext, v5);
    }
  }
  String = Scr_GetString(scrContext, 0);
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 1u);
  v8 = Scr_GetConstLowercaseString(scrContext, 2u);
  v9 = Scr_GetNumParam(scrContext) >= 4 && Scr_GetInt(scrContext, 3u) != 0;
  if ( !G_Utils_EntChangeAttachTag(v4, String, ConstLowercaseString, v8, &outModelIndex) )
  {
    v10 = SL_ConvertToString(ConstLowercaseString);
    v11 = j_va("model '%s' not attached to tag '%s'", String, v10);
    Scr_Error(COM_ERR_4119, scrContext, v11);
  }
  v12 = !v9;
  p_attachModelIsOnBack = &v4->attachModelIsOnBack;
  v14 = (int)outModelIndex;
  if ( v12 )
  {
    if ( v4 == (gentity_s *)-1448i64 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_bitset.h", 28, ASSERT_TYPE_SANITY, "( array )", (const char *)&queryFormat, "array") )
      __debugbreak();
    p_attachModelIsOnBack[v14 >> 5] &= ~(1 << (v14 & 0x1F));
  }
  else
  {
    if ( v4 == (gentity_s *)-1448i64 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_bitset.h", 20, ASSERT_TYPE_SANITY, "( array )", (const char *)&queryFormat, "array") )
      __debugbreak();
    p_attachModelIsOnBack[v14 >> 5] |= 1 << (v14 & 0x1F);
  }
  if ( G_Utils_IsAgent(v4) )
  {
    if ( !v4->agent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 7128, ASSERT_TYPE_ASSERT, "( pSelf->agent )", (const char *)&queryFormat, "pSelf->agent") )
      __debugbreak();
    p_attachShieldTagName = &v4->agent->attachShieldTagName;
  }
  else
  {
    if ( !v4->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 7133, ASSERT_TYPE_ASSERT, "( pSelf->client )", (const char *)&queryFormat, "pSelf->client") )
      __debugbreak();
    p_attachShieldTagName = &v4->client->attachShieldTagName;
  }
  Scr_SetString(p_attachShieldTagName, v8);
}

/*
==============
ScrCmd_SetMusicState
==============
*/
void ScrCmd_SetMusicState(scrContext_t *scrContext)
{
  unsigned int NumParam; 
  const char *String; 
  unsigned int v4; 
  unsigned int v5; 
  int v6; 
  unsigned int ArrayObject; 
  unsigned int FirstSibling; 
  scr_string_t *VariableValueAddress; 
  const char *v10; 
  unsigned int v11; 
  SndMusicState *MusicState; 
  unsigned int loopCount; 
  int v14; 
  char dest[884]; 

  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam - 1 <= 1 )
  {
    String = Scr_GetString(scrContext, 0);
    v4 = SND_HashName(String);
    v5 = v4;
    if ( v4 )
    {
      if ( !SND_GetMusicState(v4) )
      {
        Com_PrintError(9, "SOUND: ScrCmd_SetMusicState - Unknown music state '%s' %x\n", String, v5);
        v5 = 0;
      }
    }
    v6 = Com_sprintf<884>((char (*)[884])dest, "%c %x %x", 112i64, v5, 0i64) - 1;
    if ( NumParam == 2 )
    {
      if ( Scr_GetType(scrContext, 1u) == VAR_POINTER )
      {
        if ( Scr_GetPointerType(scrContext, 1u) == VAR_ARRAY )
        {
          ArrayObject = BGScr_Main_GetArrayObject(scrContext, 1u);
          FirstSibling = FindFirstSibling(scrContext, ArrayObject);
          if ( FirstSibling )
          {
            while ( (unsigned __int64)v6 <= 0x36A )
            {
              if ( GetValueType(scrContext, FirstSibling) != VAR_STRING )
              {
                Scr_Error(COM_ERR_6509, scrContext, "SetMusicState: Array entry is not a string.");
                return;
              }
              VariableValueAddress = (scr_string_t *)GetVariableValueAddress(scrContext, FirstSibling);
              v10 = SL_ConvertToString(*VariableValueAddress);
              v11 = SND_HashName(v10);
              MusicState = SND_GetMusicState(v5);
              if ( MusicState )
              {
                loopCount = MusicState->loopCount;
                v14 = 0;
                if ( loopCount )
                {
                  while ( MusicState->loops[v14].aliasId != v11 )
                  {
                    if ( ++v14 >= loopCount )
                      goto LABEL_18;
                  }
                }
                else
                {
LABEL_18:
                  Com_PrintError(9, "SOUND: ScrCmd_SetMusicState - Loop alias '%s' not found in state '%s'\n", v10, String);
                  v11 = 0;
                }
              }
              v6 = v6 + Com_sprintf(&dest[v6], 884i64 - v6, " %x", v11) - 1;
              FirstSibling = FindNextSibling(scrContext, FirstSibling);
              if ( !FirstSibling )
                goto LABEL_20;
            }
            Scr_Error(COM_ERR_6508, scrContext, "SetMusicState: Out of memory for playlist array.");
          }
        }
        else
        {
          Scr_Error(COM_ERR_6507, scrContext, "SetMusicState: 2nd parameter is an incorrect type.");
        }
      }
      else
      {
        Scr_Error(COM_ERR_6506, scrContext, "SetMusicState: 2nd parameter is an incorrect type.");
      }
    }
    else
    {
LABEL_20:
      SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, dest);
    }
  }
  else
  {
    Scr_Error(COM_ERR_4718, scrContext, "SetMusicState: Incorrect number of parameters\n");
  }
}

/*
==============
ScrCmd_getShieldMaxEnergy
==============
*/
void ScrCmd_getShieldMaxEnergy(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  ComErrorCode v6; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v5 = "not an entity";
    v6 = COM_ERR_3682;
LABEL_9:
    Scr_ObjectError(v6, scrContext, v5);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 7151, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
      __debugbreak();
    goto LABEL_11;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 7150, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  if ( !v4->client && !v4->agent )
  {
    v5 = j_va("entity %i is not a player or agent", entnum);
    v6 = COM_ERR_3679;
    goto LABEL_9;
  }
LABEL_11:
  Scr_AddFloat(scrContext, 0.0);
}

/*
==============
ScrCmd_SetSpaceJump
==============
*/
void ScrCmd_SetSpaceJump(scrContext_t *scrContext, scr_entref_t entref)
{
  ;
}

/*
==============
ScrCmd_SetPlayerMusicState
==============
*/
void ScrCmd_SetPlayerMusicState(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  int number; 
  const char *v7; 
  const char *v8; 
  unsigned int NumParam; 
  const char *String; 
  unsigned int v11; 
  unsigned int v12; 
  int v13; 
  unsigned int ArrayObject; 
  unsigned int FirstSibling; 
  scr_string_t *VariableValueAddress; 
  const char *v17; 
  unsigned int v18; 
  SndMusicState *MusicState; 
  unsigned int loopCount; 
  int v21; 
  SvClient *CommonClient; 
  int outControllingClientNum[4]; 
  char dest[884]; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3678, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 26460, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client && !v4->agent )
    {
      v5 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3677, scrContext, v5);
    }
  }
  number = v4->s.number;
  outControllingClientNum[0] = number;
  if ( !SV_IsAgent(number) || SV_GetAgentControlledByPlayerNum(outControllingClientNum[0], outControllingClientNum) )
  {
    if ( outControllingClientNum[0] < level.maxclients )
    {
      NumParam = Scr_GetNumParam(scrContext);
      if ( NumParam - 1 <= 1 )
      {
        String = Scr_GetString(scrContext, 0);
        v11 = SND_HashName(String);
        v12 = v11;
        if ( v11 && !SND_GetMusicState(v11) )
        {
          Com_PrintError(9, "SOUND: ScrCmd_SetPlayerMusicState - Unknown music state '%s' %x\n", String, v12);
          v12 = 0;
        }
        v13 = Com_sprintf<884>((char (*)[884])dest, "%c %x %x", 112i64, v12, 0i64);
        if ( NumParam == 2 )
        {
          if ( Scr_GetType(scrContext, 1u) == VAR_POINTER )
          {
            if ( Scr_GetPointerType(scrContext, 1u) == VAR_ARRAY )
            {
              ArrayObject = BGScr_Main_GetArrayObject(scrContext, 1u);
              FirstSibling = FindFirstSibling(scrContext, ArrayObject);
              if ( FirstSibling )
              {
                while ( (unsigned __int64)v13 <= 0x36A )
                {
                  if ( GetValueType(scrContext, FirstSibling) != VAR_STRING )
                  {
                    Scr_Error(COM_ERR_6513, scrContext, "SetPlayerMusicState: Array entry is not a string.");
                    return;
                  }
                  VariableValueAddress = (scr_string_t *)GetVariableValueAddress(scrContext, FirstSibling);
                  v17 = SL_ConvertToString(*VariableValueAddress);
                  v18 = SND_HashName(v17);
                  MusicState = SND_GetMusicState(v12);
                  if ( MusicState )
                  {
                    loopCount = MusicState->loopCount;
                    v21 = 0;
                    if ( loopCount )
                    {
                      while ( MusicState->loops[v21].aliasId != v18 )
                      {
                        if ( ++v21 >= loopCount )
                          goto LABEL_31;
                      }
                    }
                    else
                    {
LABEL_31:
                      Com_PrintError(9, "SOUND: ScrCmd_SetPlayerMusicState - Loop alias '%s' not found in state '%s'\n", v17, String);
                      v18 = 0;
                    }
                  }
                  v13 += Com_sprintf(&dest[v13], 884i64 - v13, " %x", v18);
                  FirstSibling = FindNextSibling(scrContext, FirstSibling);
                  if ( !FirstSibling )
                    goto LABEL_33;
                }
                Scr_Error(COM_ERR_6512, scrContext, "SetPlayerMusicState: Out of memory for playlist array.");
              }
            }
            else
            {
              Scr_Error(COM_ERR_6511, scrContext, "SetPlayerMusicState: 2nd parameter is an incorrect type.");
            }
          }
          else
          {
            Scr_Error(COM_ERR_6510, scrContext, "SetPlayerMusicState: 2nd parameter is an incorrect type.");
          }
        }
        else
        {
LABEL_33:
          if ( outControllingClientNum[0] == -1 )
          {
            SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, dest);
          }
          else
          {
            CommonClient = SvClient::GetCommonClient(outControllingClientNum[0]);
            CommonClient->SendServerCommand(CommonClient, SV_CMD_RELIABLE, dest);
          }
        }
      }
      else
      {
        Scr_Error(COM_ERR_4720, scrContext, "SetPlayerMusicState: Incorrect number of parameters\n");
      }
    }
    else
    {
      v8 = j_va("Invalid entity index %d before SV_Game_SendServerCommand\n", (unsigned int)outControllingClientNum[0]);
      Scr_Error(COM_ERR_6409, scrContext, v8);
    }
  }
  else
  {
    v7 = j_va("entity %i is not a player or player-controlled agent", entnum);
    Scr_ObjectError(COM_ERR_4719, scrContext, v7);
  }
}

/*
==============
ScrCmd_ClearSpaceJump
==============
*/
void ScrCmd_ClearSpaceJump(scrContext_t *scrContext, scr_entref_t entref)
{
  ;
}

/*
==============
ScrCmd_ModifySpaceJumpPath
==============
*/
void ScrCmd_ModifySpaceJumpPath(scrContext_t *scrContext, scr_entref_t entref)
{
  ;
}

/*
==============
ScrCmd_StartSpaceJumpDeath
==============
*/
void ScrCmd_StartSpaceJumpDeath(scrContext_t *scrContext, scr_entref_t entref)
{
  ;
}

/*
==============
ScrCmd_GetSpaceJumpState
==============
*/
void ScrCmd_GetSpaceJumpState(scrContext_t *scrContext, scr_entref_t entref)
{
  ;
}

/*
==============
ScrCmd_SetSpaceJumpEntOverride
==============
*/
void ScrCmd_SetSpaceJumpEntOverride(scrContext_t *scrContext, scr_entref_t entref)
{
  ;
}

/*
==============
ScrCmd_ClearSpaceJumpEntOverride
==============
*/
void ScrCmd_ClearSpaceJumpEntOverride(scrContext_t *scrContext, scr_entref_t entref)
{
  ;
}

/*
==============
ScrCmd_ForceSpaceJump
==============
*/
void ScrCmd_ForceSpaceJump(scrContext_t *scrContext, scr_entref_t entref)
{
  ;
}

/*
==============
ScrCmd_TrackMovingPlatformTilt
==============
*/
void ScrCmd_TrackMovingPlatformTilt(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  char *client; 
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *v6; 
  const char *v7; 
  ComErrorCode v8; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v7 = "not an entity";
    v8 = COM_ERR_3682;
    goto LABEL_12;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 7556, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = (char *)v4->client;
  if ( !client )
  {
    client = (char *)v4->agent;
    if ( !client )
    {
      v7 = j_va("entity %i is not a player or agent", entnum);
      v8 = COM_ERR_3679;
LABEL_12:
      Scr_ObjectError(v8, scrContext, v7);
      Scr_Error(COM_ERR_4138, scrContext, "ModifySpaceJumpPath must be called on a player.");
      return;
    }
  }
  v6 = (GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *)(client + 28);
  if ( Scr_GetInt(scrContext, 0) )
    GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal(v6, ACTIVE, 0xFu);
  else
    GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal(v6, ACTIVE, 0xFu);
}

/*
==============
ScrCmd_getShieldCurrentEnergy
==============
*/
void ScrCmd_getShieldCurrentEnergy(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  ComErrorCode v6; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v5 = "not an entity";
    v6 = COM_ERR_3682;
LABEL_9:
    Scr_ObjectError(v6, scrContext, v5);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 7588, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
      __debugbreak();
    goto LABEL_11;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 7587, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  if ( !v4->client && !v4->agent )
  {
    v5 = j_va("entity %i is not a player or agent", entnum);
    v6 = COM_ERR_3679;
    goto LABEL_9;
  }
LABEL_11:
  Scr_AddFloat(scrContext, 0.0);
}

/*
==============
ScrCmd_StopMusicState
==============
*/
void ScrCmd_StopMusicState(scrContext_t *scrContext)
{
  const char *String; 
  unsigned int v3; 
  unsigned int v4; 
  const char *v5; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    String = Scr_GetString(scrContext, 0);
    v3 = SND_HashName(String);
    v4 = v3;
    if ( v3 )
    {
      if ( !SND_GetMusicState(v3) )
      {
        Com_PrintError(9, "SOUND: Unknown music state '%s' %x\n", String, v4);
        v4 = 0;
      }
    }
    v5 = j_va("%c %x %x", 112i64, v4, 1i64);
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v5);
  }
  else
  {
    Scr_Error(COM_ERR_6502, scrContext, "StopMusicState: Incorrect number of parameters\n");
  }
}

/*
==============
ScrCmd_StopPlayerMusicState
==============
*/
void ScrCmd_StopPlayerMusicState(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  int number; 
  const char *v7; 
  const char *v8; 
  const char *String; 
  unsigned int v10; 
  unsigned int v11; 
  const char *v12; 
  const char *v13; 
  SvClient *CommonClient; 
  int outControllingClientNum; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3678, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 26628, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client && !v4->agent )
    {
      v5 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3677, scrContext, v5);
    }
  }
  number = v4->s.number;
  outControllingClientNum = number;
  if ( !SV_IsAgent(number) || SV_GetAgentControlledByPlayerNum(outControllingClientNum, &outControllingClientNum) )
  {
    if ( outControllingClientNum < level.maxclients )
    {
      if ( Scr_GetNumParam(scrContext) == 1 )
      {
        String = Scr_GetString(scrContext, 0);
        v10 = SND_HashName(String);
        v11 = v10;
        if ( v10 && !SND_GetMusicState(v10) )
        {
          Com_PrintError(9, "SOUND: Unknown music state '%s' %x\n", String, v11);
          v11 = 0;
        }
        v12 = j_va("%c %x %x", 112i64, v11, 1i64);
        v13 = v12;
        if ( outControllingClientNum == -1 )
        {
          SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v12);
        }
        else
        {
          CommonClient = SvClient::GetCommonClient(outControllingClientNum);
          CommonClient->SendServerCommand(CommonClient, SV_CMD_RELIABLE, v13);
        }
      }
      else
      {
        Scr_Error(COM_ERR_6505, scrContext, "StopPlayerMusicState: Incorrect number of parameters\n");
      }
    }
    else
    {
      v8 = j_va("Invalid entity index %d before SV_Game_SendServerCommand\n", (unsigned int)outControllingClientNum);
      Scr_Error(COM_ERR_6504, scrContext, v8);
    }
  }
  else
  {
    v7 = j_va("entity %i is not a player or player-controlled agent", entnum);
    Scr_ObjectError(COM_ERR_6503, scrContext, v7);
  }
}

/*
==============
ScrCmd_detach
==============
*/
void ScrCmd_detach(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  DetachCmd(scrContext, Entity);
}

/*
==============
ScrCmd_SetAudioTriggerState
==============
*/
void ScrCmd_SetAudioTriggerState(scrContext_t *scrContext)
{
  unsigned int NumParam; 
  const char *String; 
  const char *v4; 
  unsigned int v5; 
  unsigned int v6; 
  const char *v7; 
  const char *v8; 
  double Float; 
  const char *v10; 

  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam - 2 > 1 )
  {
    Scr_Error(COM_ERR_4721, scrContext, "SetAudioTriggerState: Incorrect number of parameters\n");
  }
  else
  {
    String = Scr_GetString(scrContext, 0);
    v4 = Scr_GetString(scrContext, 1u);
    v5 = SND_HashName(String);
    v6 = SND_HashName(v4);
    if ( !CG_CheckAudioStateId(String) )
    {
      v7 = j_va("SetAudioZoneState: Bad state id name: %s\n", String);
      Scr_Error(COM_ERR_4722, scrContext, v7);
    }
    if ( !SV_CheckAudioStateName(v4) )
    {
      v8 = j_va("SetAudioZoneState: Bad state name: %s\n", v4);
      Scr_Error(COM_ERR_4723, scrContext, v8);
    }
    if ( NumParam == 3 )
    {
      Float = Scr_GetFloat(scrContext, 2u);
      v10 = j_va("%c %c %x %x %g", 109i64, 97i64, v5, v6, *(float *)&Float);
    }
    else
    {
      v10 = j_va("%c %c %x %x", 109i64, 97i64, v5, v6);
    }
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v10);
  }
}

/*
==============
ScrCmd_detachShieldModel
==============
*/
void ScrCmd_detachShieldModel(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  char *client; 
  const char *v6; 
  scr_string_t *p_attachShieldTagName; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3682, scrContext, "not an entity");
    client = NULL;
    v4 = NULL;
LABEL_9:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 7669, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
      __debugbreak();
    goto LABEL_11;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 7667, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = (char *)v4->client;
  if ( !client )
  {
    client = (char *)v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3679, scrContext, v6);
      goto LABEL_9;
    }
  }
LABEL_11:
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal((GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *)(client + 28), ACTIVE, 8u);
  if ( G_Utils_IsAgent(v4) )
  {
    if ( !v4->agent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 7675, ASSERT_TYPE_ASSERT, "( pSelf->agent )", (const char *)&queryFormat, "pSelf->agent") )
      __debugbreak();
    p_attachShieldTagName = &v4->agent->attachShieldTagName;
  }
  else
  {
    if ( !v4->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 7680, ASSERT_TYPE_ASSERT, "( pSelf->client )", (const char *)&queryFormat, "pSelf->client") )
      __debugbreak();
    p_attachShieldTagName = &v4->client->attachShieldTagName;
  }
  Scr_SetString(p_attachShieldTagName, (scr_string_t)0);
  DetachCmd(scrContext, v4);
}

/*
==============
ScrCmd_EnableAudioTrigger
==============
*/
void ScrCmd_EnableAudioTrigger(scrContext_t *scrContext)
{
  ScrCmd_EnableDisableAudioTrigger(scrContext, 1);
}

/*
==============
ScrCmd_DisableAudioTrigger
==============
*/
void ScrCmd_DisableAudioTrigger(scrContext_t *scrContext)
{
  ScrCmd_EnableDisableAudioTrigger(scrContext, 0);
}

/*
==============
ScrCmd_detachAll
==============
*/
void ScrCmd_detachAll(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gclient_s *client; 

  Entity = GetEntity(entref);
  if ( G_Utils_IsAgent(Entity) )
  {
    if ( !Entity->agent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 7706, ASSERT_TYPE_ASSERT, "( ent->agent )", (const char *)&queryFormat, "ent->agent") )
      __debugbreak();
    GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal(&Entity->agent->playerState.otherFlags, ACTIVE, 8u);
    Scr_SetString(&Entity->agent->attachShieldTagName, (scr_string_t)0);
  }
  client = Entity->client;
  if ( client )
  {
    GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal(&client->ps.otherFlags, ACTIVE, 8u);
    Scr_SetString(&Entity->client->attachShieldTagName, (scr_string_t)0);
  }
  if ( !GUtils::ms_gUtils && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_utils.h", 112, ASSERT_TYPE_ASSERT, "( ms_gUtils )", (const char *)&queryFormat, "ms_gUtils") )
    __debugbreak();
  GUtils::ms_gUtils->EntDetachAll(GUtils::ms_gUtils, Entity);
}

/*
==============
ScrCmd_SetGlobalSoundContext
==============
*/
void ScrCmd_SetGlobalSoundContext(scrContext_t *scrContext)
{
  unsigned int NumParam; 
  const char *String; 
  const char *v4; 
  unsigned int v5; 
  unsigned int v6; 
  double Float; 
  const char *v8; 

  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam - 2 > 1 )
  {
    Scr_Error(COM_ERR_4726, scrContext, "SetGlobalSoundContext: Incorrect number of parameters\n");
  }
  else
  {
    String = Scr_GetString(scrContext, 0);
    v4 = Scr_GetString(scrContext, 1u);
    v5 = SND_HashName(String);
    if ( *v4 )
      v6 = SND_HashName(v4);
    else
      v6 = 0;
    if ( NumParam == 3 )
    {
      Float = Scr_GetFloat(scrContext, 2u);
      v8 = j_va("%c %c %x %x %g", 105i64, 98i64, v5, v6, *(float *)&Float);
    }
    else
    {
      v8 = j_va("%c %c %x %x", 105i64, 98i64, v5, v6);
    }
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v8);
  }
}

/*
==============
ScrCmd_GetAttachSize
==============
*/
void ScrCmd_GetAttachSize(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int v4; 
  __int64 v5; 
  unsigned __int16 *v6; 

  Entity = GetEntity(entref);
  v4 = 0;
  v5 = 0i64;
  v6 = &Entity->attachModelNames[1];
  while ( *(v6 - 1) )
  {
    if ( !*v6 )
    {
      ++v4;
      break;
    }
    if ( !v6[1] )
    {
      Scr_AddInt(scrContext, v4 + 2);
      return;
    }
    if ( !v6[2] )
    {
      Scr_AddInt(scrContext, v4 + 3);
      return;
    }
    v5 += 4i64;
    v6 += 4;
    v4 += 4;
    if ( v5 >= 28 )
      break;
  }
  Scr_AddInt(scrContext, v4);
}

/*
==============
ScrCmd_GetAttachModelName
==============
*/
void ScrCmd_GetAttachModelName(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  __int64 v5; 
  unsigned int v6; 
  const char *v7; 

  Entity = GetEntity(entref);
  Int = Scr_GetInt(scrContext, 0);
  v5 = Int;
  if ( (unsigned int)Int >= 0x1C || !Entity->attachModelNames[Int] )
    Scr_ParamError(COM_ERR_4140, scrContext, 0, "bad index");
  v6 = Entity->attachModelNames[v5];
  if ( !GConfigStrings::ms_gConfigStrings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_configstrings.h", 71, ASSERT_TYPE_ASSERT, "( ms_gConfigStrings )", (const char *)&queryFormat, "ms_gConfigStrings") )
    __debugbreak();
  v7 = GConfigStrings::ms_gConfigStrings->GetModelNameString(GConfigStrings::ms_gConfigStrings, v6);
  Scr_AddString(scrContext, v7);
}

/*
==============
ScrCmd_EnablePlayerBreathSystem
==============
*/
void ScrCmd_EnablePlayerBreathSystem(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  int number; 
  const char *v7; 
  const char *v8; 
  unsigned int Int; 
  const char *v10; 
  const char *v11; 
  SvClient *CommonClient; 
  int outControllingClientNum; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3678, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 26898, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client && !v4->agent )
    {
      v5 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3677, scrContext, v5);
    }
  }
  number = v4->s.number;
  outControllingClientNum = number;
  if ( !SV_IsAgent(number) || SV_GetAgentControlledByPlayerNum(outControllingClientNum, &outControllingClientNum) )
  {
    if ( outControllingClientNum < level.maxclients )
    {
      if ( Scr_GetNumParam(scrContext) == 1 )
      {
        Int = Scr_GetInt(scrContext, 0);
        v10 = j_va("%c %d", 121i64, Int);
        v11 = v10;
        if ( outControllingClientNum == -1 )
        {
          SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v10);
        }
        else
        {
          CommonClient = SvClient::GetCommonClient(outControllingClientNum);
          CommonClient->SendServerCommand(CommonClient, SV_CMD_RELIABLE, v11);
        }
      }
      else
      {
        Scr_Error(COM_ERR_4729, scrContext, "EnablePlayerBreathSystem: Incorrect number of parameters\n");
      }
    }
    else
    {
      v8 = j_va("Invalid entity index %d before SV_Game_SendServerCommand\n", (unsigned int)outControllingClientNum);
      Scr_Error(COM_ERR_6410, scrContext, v8);
    }
  }
  else
  {
    v7 = j_va("entity %i is not a player or player-controlled agent", entnum);
    Scr_ObjectError(COM_ERR_4728, scrContext, v7);
  }
}

/*
==============
ScrCmd_GetAttachTagName
==============
*/
void ScrCmd_GetAttachTagName(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  __int64 v5; 

  Entity = GetEntity(entref);
  Int = Scr_GetInt(scrContext, 0);
  v5 = Int;
  if ( (unsigned int)Int >= 0x1C || !Entity->attachModelNames[Int] )
    Scr_ParamError(COM_ERR_4141, scrContext, 0, "bad index");
  if ( !Entity->attachTagNames[v5] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 7796, ASSERT_TYPE_ASSERT, "(ent->attachTagNames[i] != ( static_cast< scr_string_t >( 0 ) ))", (const char *)&queryFormat, "ent->attachTagNames[i] != NULL_SCR_STRING") )
    __debugbreak();
  Scr_AddConstString(scrContext, Entity->attachTagNames[v5]);
}

/*
==============
ScrCmd_EnablePASpeaker
==============
*/
void ScrCmd_EnablePASpeaker(scrContext_t *scrContext)
{
  const char *String; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    String = Scr_GetString(scrContext, 0);
    ScrCmd_EnableDisablePASpeaker(scrContext, String, 1);
  }
  else
  {
    Scr_Error(COM_ERR_4730, scrContext, "EnablePASpeaker: Incorrect number of parameters\n");
  }
}

/*
==============
ScrCmd_GetAttachIgnoreCollision
==============
*/
void ScrCmd_GetAttachIgnoreCollision(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  unsigned int v5; 
  unsigned int attachIgnoreCollision; 

  Entity = GetEntity(entref);
  Int = Scr_GetInt(scrContext, 0);
  v5 = Int;
  if ( (unsigned int)Int >= 0x1C || !Entity->attachModelNames[Int] )
    Scr_ParamError(COM_ERR_4142, scrContext, 0, "bad index");
  attachIgnoreCollision = Entity->attachIgnoreCollision;
  Scr_AddBool(scrContext, _bittest((const int *)&attachIgnoreCollision, v5));
}

/*
==============
ScrCmd_DisablePASpeaker
==============
*/
void ScrCmd_DisablePASpeaker(scrContext_t *scrContext)
{
  const char *String; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    String = Scr_GetString(scrContext, 0);
    ScrCmd_EnableDisablePASpeaker(scrContext, String, 0);
  }
  else
  {
    Scr_Error(COM_ERR_4731, scrContext, "DisablePASpeaker: Incorrect number of parameters\n");
  }
}

/*
==============
GScr_WeaponUsesEnergyBullets
==============
*/
void GScr_WeaponUsesEnergyBullets(scrContext_t *scrContext)
{
  unsigned __int16 weaponIdx; 
  bool v3; 
  WeaponDef **v4; 
  int v5; 
  unsigned int v6; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  weaponIdx = outWeapon.weaponIdx;
  if ( outWeapon.weaponIdx > bg_lastParsedWeaponIndex )
  {
    v6 = bg_lastParsedWeaponIndex;
    v5 = outWeapon.weaponIdx;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1203, ASSERT_TYPE_ASSERT, "( weaponIdx ) <= ( bg_lastParsedWeaponIndex )", "weaponIdx not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", v5, v6) )
      __debugbreak();
  }
  v3 = bg_weaponDefs[weaponIdx] == NULL;
  v4 = &bg_weaponDefs[weaponIdx];
  if ( v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1204, ASSERT_TYPE_ASSERT, "(bg_weaponDefs[weaponIdx])", (const char *)&queryFormat, "bg_weaponDefs[weaponIdx]") )
    __debugbreak();
  Scr_AddBool(scrContext, (*v4)->bEnergyBullet);
}

/*
==============
ScrCmd_hidepart
==============
*/
void ScrCmd_hidepart(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  DObj *ServerDObjForEnt; 
  scr_string_t ConstLowercaseString; 
  unsigned __int8 ReverseBoneIndex; 
  const char *v7; 
  const char *v8; 
  const char *String; 
  const char *v10; 
  const char *v11; 
  DObjPartBits partBits; 

  Entity = GetEntity(entref);
  ServerDObjForEnt = Com_GetServerDObjForEnt(Entity);
  if ( !ServerDObjForEnt )
    Scr_Error(COM_ERR_4143, scrContext, "entity has no model");
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    ReverseBoneIndex = DObjGetReverseBoneIndex(ServerDObjForEnt, ConstLowercaseString);
    if ( ReverseBoneIndex == 0xFF )
    {
      v7 = SL_ConvertToString(ConstLowercaseString);
      v8 = j_va("cannot find part '%s' in entity model", v7);
      Scr_Error(COM_ERR_4144, scrContext, v8);
    }
  }
  else
  {
    String = Scr_GetString(scrContext, 1u);
    ReverseBoneIndex = DObjGetReverseModelBoneIndex(ServerDObjForEnt, String, ConstLowercaseString);
    if ( ReverseBoneIndex == 0xFF )
    {
      v10 = SL_ConvertToString(ConstLowercaseString);
      v11 = j_va("cannot find part '%s' in entity model '%s'", v10, String);
      Scr_Error(COM_ERR_4145, scrContext, v11);
    }
  }
  DObjGetHidePartBits(ServerDObjForEnt, &partBits);
  partBits.array[(unsigned __int64)ReverseBoneIndex >> 5] |= 0x80000000 >> (ReverseBoneIndex & 0x1F);
  DObjSetHidePartBits(ServerDObjForEnt, &partBits);
  if ( !GUtils::ms_gUtils && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_utils.h", 112, ASSERT_TYPE_ASSERT, "( ms_gUtils )", (const char *)&queryFormat, "ms_gUtils") )
    __debugbreak();
  GUtils::ms_gUtils->EntityStateSetPartBits(GUtils::ms_gUtils, Entity, &partBits);
}

/*
==============
GScr_EnableCallouts
==============
*/
void GScr_EnableCallouts(scrContext_t *scrContext, scr_entref_t entref)
{
  ;
}

/*
==============
ScrCmd_SetDead
==============
*/
void ScrCmd_SetDead(scrContext_t *scrContext, scr_entref_t entref)
{
  bool v4; 
  gentity_s *Entity; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *client; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *p_eFlags; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    v4 = Scr_GetInt(scrContext, 0) != 0;
    Entity = GetEntity(entref);
    if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 1969, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
      __debugbreak();
    if ( ((Entity->s.eType - 1) & 0xFFEF) == 0 || BG_IsCorpseEntity(&Entity->s) )
    {
      Scr_Error(COM_ERR_4733, scrContext, "SetDead: You cannot use this method on players, agents and corpses.\n");
    }
    else
    {
      client = (GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *)Entity->client;
      if ( v4 )
      {
        p_eFlags = client + 94;
        if ( !client )
          p_eFlags = &Entity->s.lerp.eFlags;
        GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(p_eFlags, ACTIVE, 0x11u);
      }
      else if ( client )
      {
        GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(client + 94, ACTIVE, 0x11u);
      }
      else
      {
        GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(&Entity->s.lerp.eFlags, ACTIVE, 0x11u);
      }
    }
  }
  else
  {
    Scr_Error(COM_ERR_4732, scrContext, "SetDead: Incorrect number of parameters.\n");
  }
}

/*
==============
GScr_AIAnimsetAssetLoaded
==============
*/
void GScr_AIAnimsetAssetLoaded(scrContext_t *scrContext)
{
  scr_string_t ConstLowercaseString; 
  bool IsLoaded; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
    IsLoaded = BG_Animset_IsLoaded(ConstLowercaseString);
    Scr_AddBool(scrContext, IsLoaded);
  }
  else
  {
    Scr_Error(COM_ERR_4734, scrContext, "ArchetypeAssetExists called with incorrect number of parameters.");
  }
}

/*
==============
GScr_AIAnimsetGetAlias
==============
*/
void GScr_AIAnimsetGetAlias(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  scr_string_t v3; 
  scr_string_t v4; 
  int Int; 
  unsigned int v6; 
  int v7; 
  Animset *v8; 
  AnimsetAlias_Union v9; 
  AnimsetAnim *redAnims; 
  unsigned int v11; 
  AnimsetAlias_Union v12; 
  unsigned int v13; 
  AnimsetAlias_Union v14; 
  unsigned int CanonicalString; 
  AnimsetAlias *v16; 
  unsigned int i; 
  unsigned int v18; 
  AnimsetAlias *v19; 
  unsigned int v20; 
  AnimsetAlias *outAlias; 

  if ( Scr_GetNumParam(scrContext) != 4 )
  {
    Scr_Error(COM_ERR_4735, scrContext, "GScr_ArchetypeGetAlias called with incorrect number of parameters.");
    return;
  }
  Sys_ProfBeginNamedEvent(0xFFFFFFFF, "ArchGetAlias");
  ConstString = Scr_GetConstString(scrContext, 0);
  v3 = Scr_GetConstString(scrContext, 1u);
  v4 = Scr_GetConstString(scrContext, 2u);
  Int = Scr_GetInt(scrContext, 3u);
  v6 = 0;
  outAlias = NULL;
  v7 = Int;
  if ( BG_Animset_GetCompleteAliasInfo(ConstString, v3, v4, &outAlias) )
  {
    if ( !outAlias && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 27132, ASSERT_TYPE_ASSERT, "(alias)", (const char *)&queryFormat, "alias") )
      __debugbreak();
    if ( v7 )
    {
      v8 = Animset_Find(ConstString);
      if ( (!v8 || v8->mode) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 27139, ASSERT_TYPE_ASSERT, "(animset && animset->mode == ASM_MODE_AI)", (const char *)&queryFormat, "animset && animset->mode == ASM_MODE_AI") )
        __debugbreak();
      v9.m_AIAnimsetAlias = (AIAnimsetAlias *)outAlias->u;
      if ( v9.m_AIAnimsetAlias->numRedAnims == 1 )
      {
        Scr_MakeStruct(scrContext);
        redAnims = outAlias->u.m_AIAnimsetAlias->redAnims;
LABEL_22:
        Scr_AddAnim(scrContext, redAnims->anim);
        CanonicalString = SL_GetCanonicalString("anims");
        Scr_AddStructField(scrContext, CanonicalString);
        Scr_AddUndefined(scrContext);
LABEL_28:
        v20 = SL_GetCanonicalString("weights");
        Scr_AddStructField(scrContext, v20);
        Sys_ProfEndNamedEvent();
        return;
      }
      if ( v9.m_AIAnimsetAlias->numRedAnims > 1 )
      {
        Scr_MakeStruct(scrContext);
        Scr_MakeArray(scrContext);
        v11 = 0;
        for ( v12.m_AIAnimsetAlias = (AIAnimsetAlias *)outAlias->u; v11 < v12.m_AIAnimsetAlias->numRedAnims; v12.m_AIAnimsetAlias = (AIAnimsetAlias *)outAlias->u )
        {
          Scr_AddAnim(scrContext, v12.m_AIAnimsetAlias->redAnims[v11].anim);
          Scr_AddArray(scrContext);
          ++v11;
        }
        v13 = SL_GetCanonicalString("anims");
        Scr_AddStructField(scrContext, v13);
        Scr_MakeArray(scrContext);
        v14.m_AIAnimsetAlias = (AIAnimsetAlias *)outAlias->u;
        if ( v14.m_AIAnimsetAlias->numRedAnims )
        {
          do
          {
            Scr_AddFloat(scrContext, v14.m_AIAnimsetAlias->redAnims[v6].weight);
            Scr_AddArray(scrContext);
            ++v6;
            v14.m_AIAnimsetAlias = (AIAnimsetAlias *)outAlias->u;
          }
          while ( v6 < v14.m_AIAnimsetAlias->numRedAnims );
        }
        goto LABEL_28;
      }
    }
    if ( outAlias->numAnims == 1 )
    {
      Scr_MakeStruct(scrContext);
      redAnims = outAlias->anims;
      goto LABEL_22;
    }
    if ( outAlias->numAnims > 1 )
    {
      Scr_MakeStruct(scrContext);
      Scr_MakeArray(scrContext);
      v16 = outAlias;
      for ( i = 0; i < outAlias->numAnims; ++i )
      {
        Scr_AddAnim(scrContext, v16->anims[i].anim);
        Scr_AddArray(scrContext);
        v16 = outAlias;
      }
      v18 = SL_GetCanonicalString("anims");
      Scr_AddStructField(scrContext, v18);
      Scr_MakeArray(scrContext);
      v19 = outAlias;
      if ( outAlias->numAnims )
      {
        do
        {
          Scr_AddFloat(scrContext, v19->anims[v6].weight);
          Scr_AddArray(scrContext);
          v19 = outAlias;
          ++v6;
        }
        while ( v6 < outAlias->numAnims );
      }
      goto LABEL_28;
    }
    Scr_AddUndefined(scrContext);
    Sys_ProfEndNamedEvent();
  }
  else
  {
    Sys_ProfEndNamedEvent();
    Scr_AddUndefined(scrContext);
  }
}

/*
==============
ScrCmd_hidepartAndChildrenAllInstances
==============
*/
void ScrCmd_hidepartAndChildrenAllInstances(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  DObj *ServerDObjForEnt; 
  scr_string_t ConstLowercaseString; 
  unsigned __int8 i; 
  int v7; 
  const char *BoneName; 
  scr_string_t String; 
  unsigned __int8 j; 
  unsigned __int8 childIndex; 
  unsigned __int8 v12[3]; 
  DObjPartBits partBits; 

  Entity = GetEntity(entref);
  ServerDObjForEnt = Com_GetServerDObjForEnt(Entity);
  if ( !ServerDObjForEnt )
    Scr_Error(COM_ERR_4146, scrContext, "entity has no model");
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  if ( Scr_GetNumParam(scrContext) == 2 )
    Scr_GetString(scrContext, 1u);
  DObjGetHidePartBits(ServerDObjForEnt, &partBits);
  for ( i = DObjGetNextBoneIndex(ServerDObjForEnt, ConstLowercaseString, 0xFEu); i != 0xFF; i = DObjGetNextBoneIndex(ServerDObjForEnt, ConstLowercaseString, i) )
  {
    childIndex = -2;
    partBits.array[(unsigned __int64)i >> 5] |= 0x80000000 >> (i & 0x1F);
    while ( DObjGetNextChildBoneIndex(ServerDObjForEnt, i, &childIndex) )
    {
      v7 = childIndex;
      partBits.array[(unsigned __int64)childIndex >> 5] |= 0x80000000 >> (childIndex & 0x1F);
      BoneName = DObjGetBoneName(ServerDObjForEnt, v7);
      String = SL_FindString(BoneName);
      for ( j = DObjGetNextBoneIndex(ServerDObjForEnt, String, childIndex); j != 0xFF; j = DObjGetNextBoneIndex(ServerDObjForEnt, String, j) )
      {
        if ( j != childIndex )
        {
          for ( v12[0] = -2; DObjGetNextChildBoneIndex(ServerDObjForEnt, j, v12); partBits.array[(unsigned __int64)v12[0] >> 5] |= 0x80000000 >> (v12[0] & 0x1F) )
            ;
        }
      }
    }
  }
  DObjSetHidePartBits(ServerDObjForEnt, &partBits);
  if ( !GUtils::ms_gUtils && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_utils.h", 112, ASSERT_TYPE_ASSERT, "( ms_gUtils )", (const char *)&queryFormat, "ms_gUtils") )
    __debugbreak();
  GUtils::ms_gUtils->EntityStateSetPartBits(GUtils::ms_gUtils, Entity, &partBits);
}

/*
==============
ScrCmd_hidepartAllInstances
==============
*/
void ScrCmd_hidepartAllInstances(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  DObj *ServerDObjForEnt; 
  scr_string_t ConstLowercaseString; 
  int v6; 
  const char *String; 
  unsigned __int8 v8; 
  unsigned __int8 v9; 
  const char *v10; 
  const char *v11; 
  ComErrorCode v12; 
  DObjPartBits partBits; 

  Entity = GetEntity(entref);
  ServerDObjForEnt = Com_GetServerDObjForEnt(Entity);
  if ( !ServerDObjForEnt )
    Scr_Error(COM_ERR_4147, scrContext, "entity has no model");
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  v6 = 0;
  if ( Scr_GetNumParam(scrContext) == 2 )
    String = Scr_GetString(scrContext, 1u);
  else
    String = NULL;
  DObjGetHidePartBits(ServerDObjForEnt, &partBits);
  v8 = -2;
  while ( 1 )
  {
    v9 = String ? DObjGetNextModelBoneIndex(ServerDObjForEnt, String, ConstLowercaseString, v8) : DObjGetNextBoneIndex(ServerDObjForEnt, ConstLowercaseString, v8);
    v8 = v9;
    if ( v9 == 0xFF )
      break;
    partBits.array[(unsigned __int64)v9 >> 5] |= 0x80000000 >> (v9 & 0x1F);
    ++v6;
  }
  if ( !v6 )
  {
    v10 = SL_ConvertToString(ConstLowercaseString);
    if ( String )
    {
      v11 = j_va("cannot find part '%s' in entity model '%s'", v10, String);
      v12 = COM_ERR_4148;
    }
    else
    {
      v11 = j_va("cannot find part '%s' in entity model", v10);
      v12 = COM_ERR_4149;
    }
    Scr_Error(v12, scrContext, v11);
  }
  DObjSetHidePartBits(ServerDObjForEnt, &partBits);
  if ( !GUtils::ms_gUtils && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_utils.h", 112, ASSERT_TYPE_ASSERT, "( ms_gUtils )", (const char *)&queryFormat, "ms_gUtils") )
    __debugbreak();
  GUtils::ms_gUtils->EntityStateSetPartBits(GUtils::ms_gUtils, Entity, &partBits);
}

/*
==============
ScrCmd_hideallparts
==============
*/
void ScrCmd_hideallparts(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  DObj *ServerDObjForEnt; 
  unsigned int v5; 
  DObjPartBits *p_partBits; 
  DObjPartBits partBits; 

  Entity = GetEntity(entref);
  ServerDObjForEnt = Com_GetServerDObjForEnt(Entity);
  if ( !ServerDObjForEnt )
    Scr_Error(COM_ERR_4150, scrContext, "entity has no model");
  v5 = 0;
  p_partBits = &partBits;
  do
  {
    *(_OWORD *)p_partBits->array = _xmm_ffffffffffffffffffffffffffffffff;
    p_partBits = (DObjPartBits *)((char *)p_partBits + 16);
    ++v5;
  }
  while ( v5 < 2 );
  DObjSetHidePartBits(ServerDObjForEnt, &partBits);
  if ( !GUtils::ms_gUtils && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_utils.h", 112, ASSERT_TYPE_ASSERT, "( ms_gUtils )", (const char *)&queryFormat, "ms_gUtils") )
    __debugbreak();
  GUtils::ms_gUtils->EntityStateSetPartBits(GUtils::ms_gUtils, Entity, &partBits);
}

/*
==============
ScrCmd_showpart
==============
*/
void ScrCmd_showpart(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  DObj *ServerDObjForEnt; 
  scr_string_t ConstLowercaseString; 
  unsigned __int8 ReverseBoneIndex; 
  const char *v7; 
  const char *v8; 
  const char *String; 
  const char *v10; 
  const char *v11; 
  DObjPartBits partBits; 

  Entity = GetEntity(entref);
  ServerDObjForEnt = Com_GetServerDObjForEnt(Entity);
  if ( !ServerDObjForEnt )
    Scr_Error(COM_ERR_4151, scrContext, "entity has no model");
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    ReverseBoneIndex = DObjGetReverseBoneIndex(ServerDObjForEnt, ConstLowercaseString);
    if ( ReverseBoneIndex == 0xFF )
    {
      v7 = SL_ConvertToString(ConstLowercaseString);
      v8 = j_va("cannot find part '%s' in entity model", v7);
      Scr_Error(COM_ERR_4152, scrContext, v8);
    }
  }
  else
  {
    String = Scr_GetString(scrContext, 1u);
    ReverseBoneIndex = DObjGetReverseModelBoneIndex(ServerDObjForEnt, String, ConstLowercaseString);
    if ( ReverseBoneIndex == 0xFF )
    {
      v10 = SL_ConvertToString(ConstLowercaseString);
      v11 = j_va("cannot find part '%s' in entity model '%s'", v10, String);
      Scr_Error(COM_ERR_4153, scrContext, v11);
    }
  }
  DObjGetHidePartBits(ServerDObjForEnt, &partBits);
  partBits.array[(unsigned __int64)ReverseBoneIndex >> 5] &= ~(0x80000000 >> (ReverseBoneIndex & 0x1F));
  DObjSetHidePartBits(ServerDObjForEnt, &partBits);
  if ( !GUtils::ms_gUtils && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_utils.h", 112, ASSERT_TYPE_ASSERT, "( ms_gUtils )", (const char *)&queryFormat, "ms_gUtils") )
    __debugbreak();
  GUtils::ms_gUtils->EntityStateSetPartBits(GUtils::ms_gUtils, Entity, &partBits);
}

/*
==============
GScr_AIAnimsetGetRandomAlias
==============
*/
void GScr_AIAnimsetGetRandomAlias(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  scr_string_t v3; 
  scr_string_t v4; 
  int IndexOfRandomAnimFromAlias; 

  Sys_ProfBeginNamedEvent(0xFFFFFFFF, "ArchGetRandomAlias");
  if ( Scr_GetNumParam(scrContext) == 4 )
  {
    ConstString = Scr_GetConstString(scrContext, 0);
    v3 = Scr_GetConstString(scrContext, 1u);
    v4 = Scr_GetConstString(scrContext, 2u);
    IndexOfRandomAnimFromAlias = G_Animset_GetIndexOfRandomAnimFromAlias(ConstString, v3, v4);
    if ( IndexOfRandomAnimFromAlias < 0 )
      Scr_AddUndefined(scrContext);
    else
      Scr_AddInt(scrContext, IndexOfRandomAnimFromAlias);
    Sys_ProfEndNamedEvent();
  }
  else
  {
    Sys_ProfEndNamedEvent();
    Scr_Error(COM_ERR_4736, scrContext, "GScr_ArchetypeGetRandomAlias called with incorrect number of parameters.");
  }
}

/*
==============
GScr_AIAnimsetGetAnimFromIndex
==============
*/
void GScr_AIAnimsetGetAnimFromIndex(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  scr_string_t v3; 
  int Int; 
  const Animset *v5; 
  const Animset *v6; 
  unsigned __int16 AnimsIndex; 
  const XAnim_s *Anims; 
  int pOutAnimtreeIndex; 
  unsigned int pOutGraftNode; 
  scr_anim_t value; 
  AnimsetState *outState; 
  XAnimSubTreeID pOutAnimSubtreeID; 
  int pOutStateIndex; 
  unsigned int pOutAnimIndex; 

  ConstString = Scr_GetConstString(scrContext, 0);
  v3 = Scr_GetConstString(scrContext, 1u);
  Int = Scr_GetInt(scrContext, 2u);
  v5 = Animset_Find(ConstString);
  v6 = v5;
  if ( v5 )
  {
    outState = NULL;
    BG_Animset_GetStateInfoByName(v5, v3, &outState, &pOutStateIndex);
    if ( outState )
    {
      BG_Animset_GetAnimIndexFromStateIndexAndEntry(v6, pOutStateIndex, Int, &pOutAnimIndex, &pOutGraftNode, &pOutAnimSubtreeID, NULL, &pOutAnimtreeIndex, 1);
      value.index = pOutAnimIndex;
      AnimsIndex = pOutAnimtreeIndex;
      if ( pOutAnimtreeIndex < 0 )
      {
        Anims = BG_AnimationState_GetAnims(ConstString);
        AnimsIndex = Scr_GetAnimsIndex(Anims, 1u);
      }
      value.tree = AnimsIndex;
      Scr_AddAnim(scrContext, value);
    }
  }
}

/*
==============
ScrCmd_showallparts
==============
*/
void ScrCmd_showallparts(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  DObj *ServerDObjForEnt; 
  unsigned int v6; 
  DObjPartBits *p_partBits; 
  DObjPartBits partBits; 

  Entity = GetEntity(entref);
  ServerDObjForEnt = Com_GetServerDObjForEnt(Entity);
  if ( !ServerDObjForEnt )
    Scr_Error(COM_ERR_4154, scrContext, "entity has no model");
  v6 = 0;
  p_partBits = &partBits;
  __asm { vpxor   xmm6, xmm6, xmm6 }
  do
  {
    *(_OWORD *)p_partBits->array = _XMM6;
    p_partBits = (DObjPartBits *)((char *)p_partBits + 16);
    ++v6;
  }
  while ( v6 < 2 );
  DObjSetHidePartBits(ServerDObjForEnt, &partBits);
  if ( !GUtils::ms_gUtils && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_utils.h", 112, ASSERT_TYPE_ASSERT, "( ms_gUtils )", (const char *)&queryFormat, "ms_gUtils") )
    __debugbreak();
  GUtils::ms_gUtils->EntityStateSetPartBits(GUtils::ms_gUtils, Entity, &partBits);
}

/*
==============
ScrCmd_SetMoveSpeedScale
==============
*/
void ScrCmd_SetMoveSpeedScale(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  double Float; 
  const char *v7; 
  gagent_s *agent; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3678, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 8134, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client && !v4->agent )
    {
      v5 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3677, scrContext, v5);
    }
  }
  Float = Scr_GetFloat(scrContext, 0);
  if ( *(float *)&Float > 5.0 )
  {
    v7 = j_va("Value %f is greater than SPEED_SCALE_MULTIPLIER_MAX_SIZE, please increase define.", *(float *)&Float);
    Scr_Error(COM_ERR_4155, scrContext, v7);
  }
  if ( G_Utils_IsAgent(v4) )
  {
    agent = v4->agent;
    if ( !agent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_playerstate.h", 1145, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    agent->playerState.moveSpeedScaleMultiplier = MSG_PackUnsignedFloat(*(float *)&Float, 5.0, 0xCu);
  }
  else
  {
    if ( !v4->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 8150, ASSERT_TYPE_ASSERT, "( pSelf->client )", (const char *)&queryFormat, "pSelf->client") )
      __debugbreak();
    v4->client->sess.moveSpeedScaleMultiplier = *(float *)&Float;
  }
}

/*
==============
GScr_AIAnimsetGetAllAnimIndicesForAlias
==============
*/
void GScr_AIAnimsetGetAllAnimIndicesForAlias(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  scr_string_t v3; 
  scr_string_t v4; 
  int AllAnimIndicesForAlias; 
  __int64 v6; 
  __int64 v7; 
  __int64 i; 
  int pIndices[128]; 

  ConstString = Scr_GetConstString(scrContext, 0);
  v3 = Scr_GetConstString(scrContext, 1u);
  v4 = Scr_GetConstString(scrContext, 2u);
  AllAnimIndicesForAlias = BG_Animset_GetAllAnimIndicesForAlias(ConstString, v3, v4, pIndices, 0x80u);
  v6 = AllAnimIndicesForAlias;
  if ( AllAnimIndicesForAlias < 0 )
    Scr_Error(COM_ERR_4737, scrContext, "insufficient space in array for all the indices for this alias");
  if ( (int)v6 > 0 )
  {
    if ( (int)v6 > 128 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 27346, ASSERT_TYPE_ASSERT, "(numIndices <= cMaxIndices)", (const char *)&queryFormat, "numIndices <= cMaxIndices") )
      __debugbreak();
    Scr_MakeArray(scrContext);
    v7 = v6;
    if ( (int)v6 > 0 )
    {
      for ( i = 0i64; i < v7; ++i )
      {
        Scr_AddInt(scrContext, pIndices[i]);
        Scr_AddArray(scrContext);
      }
    }
  }
}

/*
==============
GScr_AIAnimsetGetAliases
==============
*/
void GScr_AIAnimsetGetAliases(scrContext_t *scrContext)
{
  scrContext_t *v2; 
  ntl::internal::pool_allocator_freelist<40> *p_m_freelist; 
  char *v4; 
  scr_string_t ConstLowercaseString; 
  scr_string_t v6; 
  int v7; 
  scr_string_t name; 
  ntl::red_black_tree_node_base *p_m_endNodeBase; 
  ntl::red_black_tree_node_base *mp_parent; 
  ntl::red_black_tree_node_base *v11; 
  ntl::red_black_tree_node_base *v12; 
  ntl::red_black_tree_node_base *v13; 
  bool v14; 
  ntl::red_black_tree_node_base *mp_left; 
  ntl::red_black_tree_node_base *i; 
  ntl::red_black_tree_node_base *v17; 
  ntl::internal::pool_allocator_pointer_freelist::free_item_pointer *mp_next; 
  ntl::red_black_tree_node_base *mp_right; 
  ntl::red_black_tree_node_base *j; 
  ntl::red_black_tree_node_base *v21; 
  ntl::red_black_tree_node_base *v22; 
  AnimsetState *outState; 
  ntl::pair<enum scr_string_t,bool> r_element; 
  scrContext_t *v25; 
  __m256i v26; 
  double v27; 
  __int64 v28; 
  ntl::red_black_tree_iterator<enum scr_string_t,ntl::red_black_tree_node<ntl::pair<enum scr_string_t,bool> >,ntl::pair<enum scr_string_t,bool> *,ntl::pair<enum scr_string_t,bool> &> result; 
  ntl::red_black_tree<enum scr_string_t,ntl::pair<enum scr_string_t,bool>,ntl::fixed_pool_allocator<ntl::red_black_tree_node<ntl::pair<enum scr_string_t,bool> >,4096,8>,ntl::return_pair_first<enum scr_string_t,bool>,ntl::less<enum scr_string_t,enum scr_string_t> > v30; 

  v28 = -2i64;
  v2 = scrContext;
  v25 = scrContext;
  p_m_freelist = &v30.m_freelist;
  v4 = &v30.m_data.m_buffer[163800];
  do
  {
    *(_QWORD *)v4 = p_m_freelist;
    p_m_freelist = (ntl::internal::pool_allocator_freelist<40> *)v4;
    v4 -= 40;
  }
  while ( v4 + 40 > (char *)&v30 );
  v30.m_freelist.m_head.mp_next = &p_m_freelist->m_head;
  if ( !p_m_freelist && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 112, ASSERT_TYPE_ASSERT, "( m_head.mp_next != 0 )", "This container was memset to zero") )
    __debugbreak();
  v30.m_size = 0i64;
  v30.m_endNodeBase.m_color = RB_NODE_COLOR_RED;
  v30.m_endNodeBase.mp_parent = NULL;
  v30.m_endNodeBase.mp_left = &v30.m_endNodeBase;
  v30.m_endNodeBase.mp_right = &v30.m_endNodeBase;
  if ( Scr_GetNumParam(v2) != 2 )
  {
    Scr_Error(COM_ERR_4738, v2, "ArchetypeGetAliases called with incorrect number of parameters.");
    goto LABEL_80;
  }
  ConstLowercaseString = Scr_GetConstLowercaseString(v2, 0);
  v6 = Scr_GetConstLowercaseString(v2, 1u);
  if ( !BG_Animset_IsLoaded(ConstLowercaseString) )
    goto LABEL_79;
  outState = NULL;
  if ( BG_Animset_GetStateInfoByName(ConstLowercaseString, v6, &outState, NULL) )
  {
    if ( !outState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 27393, ASSERT_TYPE_ASSERT, "(state)", (const char *)&queryFormat, "state") )
      __debugbreak();
    v7 = 0;
    if ( outState->numAnimAliases )
    {
      while ( 1 )
      {
        name = outState->animAliases[v7].name;
        if ( !name )
          goto LABEL_70;
        p_m_endNodeBase = &v30.m_endNodeBase;
        mp_parent = v30.m_endNodeBase.mp_parent;
        if ( v30.m_endNodeBase.mp_parent )
        {
          do
          {
            if ( mp_parent[1].m_color < name )
            {
              mp_parent = mp_parent->mp_right;
            }
            else
            {
              p_m_endNodeBase = mp_parent;
              mp_parent = mp_parent->mp_left;
            }
          }
          while ( mp_parent );
          if ( p_m_endNodeBase != &v30.m_endNodeBase )
          {
            v11 = &v30.m_endNodeBase;
            if ( name >= p_m_endNodeBase[1].m_color )
              v11 = p_m_endNodeBase;
            p_m_endNodeBase = v11;
          }
        }
        if ( p_m_endNodeBase != &v30.m_endNodeBase )
          goto LABEL_70;
        r_element.first = outState->animAliases[v7].name;
        r_element.second = 1;
        v12 = &v30.m_endNodeBase;
        v13 = v30.m_endNodeBase.mp_parent;
        v14 = 1;
        while ( v13 )
        {
          v12 = v13;
          v14 = name < v13[1].m_color;
          if ( name >= v13[1].m_color )
            v13 = v13->mp_right;
          else
            v13 = v13->mp_left;
        }
        mp_left = v12;
        if ( !v14 )
          goto LABEL_45;
        if ( v12 != v30.m_endNodeBase.mp_left )
          break;
        ntl::red_black_tree<enum scr_string_t,ntl::pair<enum scr_string_t,bool>,ntl::fixed_pool_allocator<ntl::red_black_tree_node<ntl::pair<enum scr_string_t,bool>>,4096,8>,ntl::return_pair_first<enum scr_string_t,bool>,ntl::less<enum scr_string_t,enum scr_string_t>>::insert_node(&v30, &result, v12, &r_element, 1, 0);
LABEL_70:
        if ( ++v7 >= outState->numAnimAliases )
        {
          v2 = v25;
          goto LABEL_72;
        }
      }
      if ( !v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\tree\\rb_tree.h", 108, ASSERT_TYPE_ASSERT, "( mp_node )", (const char *)&queryFormat, "mp_node") )
        __debugbreak();
      if ( v12->m_color || v12->mp_parent->mp_parent != v12 )
      {
        mp_left = v12->mp_left;
        if ( mp_left )
        {
          for ( i = mp_left->mp_right; i; i = i->mp_right )
            mp_left = i;
        }
        else
        {
          mp_left = v12->mp_parent;
          if ( v12 == mp_left->mp_left )
          {
            do
            {
              v17 = mp_left;
              mp_left = mp_left->mp_parent;
            }
            while ( v17 == mp_left->mp_left );
          }
        }
      }
      else
      {
        mp_left = v12->mp_right;
      }
LABEL_45:
      if ( !mp_left && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\tree\\rb_tree.h", 81, ASSERT_TYPE_ASSERT, "( mp_node )", (const char *)&queryFormat, "mp_node") )
        __debugbreak();
      if ( mp_left[1].m_color < name )
      {
        if ( !v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\tree\\rb_tree.h", 694, ASSERT_TYPE_ASSERT, "( p_insert != 0 )", (const char *)&queryFormat, "p_insert != NULL") )
          __debugbreak();
        if ( !v30.m_freelist.m_head.mp_next )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 112, ASSERT_TYPE_ASSERT, "( m_head.mp_next != 0 )", "This container was memset to zero") )
            __debugbreak();
          if ( !v30.m_freelist.m_head.mp_next && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 112, ASSERT_TYPE_ASSERT, "( m_head.mp_next != 0 )", "This container was memset to zero") )
            __debugbreak();
        }
        if ( (ntl::internal::pool_allocator_freelist<40> *)v30.m_freelist.m_head.mp_next == &v30.m_freelist && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\pool_allocator.h", 298, ASSERT_TYPE_ASSERT, "( !empty() )", "Pool out of elements to allocate (Elem size=%zu, Num elems=%zu)", 0x28ui64, 0x1000ui64) )
          __debugbreak();
        mp_next = v30.m_freelist.m_head.mp_next;
        v30.m_freelist.m_head.mp_next = v30.m_freelist.m_head.mp_next->mp_next;
        v26.m256i_i32[0] = 0;
        v26.m256i_i64[1] = (__int64)v12;
        __asm { vpxor   xmm0, xmm0, xmm0 }
        *(_OWORD *)&v26.m256i_u64[2] = _XMM0;
        v27 = *(double *)&r_element;
        *(__m256i *)&mp_next->mp_next = v26;
        *(double *)&mp_next[4].mp_next = v27;
        if ( v12 == &v30.m_endNodeBase )
        {
          v30.m_endNodeBase.mp_left = (ntl::red_black_tree_node_base *)mp_next;
          v30.m_endNodeBase.mp_parent = (ntl::red_black_tree_node_base *)mp_next;
          v30.m_endNodeBase.mp_right = (ntl::red_black_tree_node_base *)mp_next;
        }
        else if ( name >= v12[1].m_color )
        {
          v12->mp_right = (ntl::red_black_tree_node_base *)mp_next;
          mp_right = v30.m_endNodeBase.mp_right;
          if ( v12 == v30.m_endNodeBase.mp_right )
            mp_right = (ntl::red_black_tree_node_base *)mp_next;
          v30.m_endNodeBase.mp_right = mp_right;
        }
        else
        {
          v12->mp_left = (ntl::red_black_tree_node_base *)mp_next;
          if ( v12 == v30.m_endNodeBase.mp_left )
            v30.m_endNodeBase.mp_left = (ntl::red_black_tree_node_base *)mp_next;
        }
        ntl::red_black_tree_node_base::rebalance((ntl::red_black_tree_node_base *)mp_next, &v30.m_endNodeBase.mp_parent);
        ++v30.m_size;
      }
      goto LABEL_70;
    }
  }
LABEL_72:
  if ( !v30.m_size )
  {
LABEL_79:
    Scr_AddUndefined(v2);
    goto LABEL_80;
  }
  Scr_MakeArray(v2);
  for ( j = v30.m_endNodeBase.mp_left; j != &v30.m_endNodeBase; j = ntl::red_black_tree_node_base::get_next(j) )
  {
    if ( !j && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\tree\\rb_tree.h", 87, ASSERT_TYPE_ASSERT, "( mp_node )", (const char *)&queryFormat, "mp_node") )
      __debugbreak();
    Scr_AddConstString(v2, (scr_string_t)j[1].m_color);
    Scr_AddArray(v2);
  }
LABEL_80:
  if ( v30.m_size )
  {
    v21 = v30.m_endNodeBase.mp_parent;
    if ( v30.m_endNodeBase.mp_parent )
    {
      do
      {
        ntl::red_black_tree<enum scr_string_t,ntl::pair<enum scr_string_t,bool>,ntl::fixed_pool_allocator<ntl::red_black_tree_node<ntl::pair<enum scr_string_t,bool>>,4096,8>,ntl::return_pair_first<enum scr_string_t,bool>,ntl::less<enum scr_string_t,enum scr_string_t>>::erase_tree(&v30, (ntl::red_black_tree_node<ntl::pair<enum scr_string_t,bool> > *)v21->mp_right);
        v22 = v21->mp_left;
        *(_QWORD *)&v21->m_color = v30.m_freelist.m_head.mp_next;
        v30.m_freelist.m_head.mp_next = (ntl::internal::pool_allocator_pointer_freelist::free_item_pointer *)v21;
        v21 = v22;
      }
      while ( v22 );
    }
  }
}

/*
==============
ScrCmd_LinkTo
==============
*/
void ScrCmd_LinkTo(scrContext_t *scrContext, scr_entref_t entref)
{
  ScrLinkTo_Internal(scrContext, entref, 0, 0);
}

/*
==============
ScrCmd_FixLinkToInterpolationBug
==============
*/
void ScrCmd_FixLinkToInterpolationBug(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  unsigned int v6; 

  if ( !Com_GameMode_SupportsFeature(WEAPON_DROPPING_ALT_ADS) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 8291, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::LINKED_TRAJECTORIES ))", "%s\n\tFixLinkToInterpolationBug() is not supported in this game mode.", "Com_GameMode_SupportsFeature( Com_GameMode_Feature::LINKED_TRAJECTORIES )") )
    __debugbreak();
  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 8294, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  Int = Scr_GetInt(scrContext, 0);
  v6 = Entity->flags.m_flags[0] & 0xFFFFFBFF;
  if ( Int )
    v6 = Entity->flags.m_flags[0] | 0x400;
  Entity->flags.m_flags[0] = v6;
}

/*
==============
ScrCmd_LinkToBlendToTag
==============
*/
void ScrCmd_LinkToBlendToTag(scrContext_t *scrContext, scr_entref_t entref)
{
  ScrLinkTo_Internal(scrContext, entref, 1, 0);
}

/*
==============
ScrCmd_LinkToMoveOffset
==============
*/
void ScrCmd_LinkToMoveOffset(scrContext_t *scrContext, scr_entref_t entref)
{
  ScrLinkTo_Internal(scrContext, entref, 0, 1);
}

/*
==============
ScrCmd_Unlink
==============
*/
void ScrCmd_Unlink(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int v4; 

  Entity = GetEntity(entref);
  v4 = 0;
  if ( Scr_GetNumParam(scrContext) )
  {
    if ( Scr_GetType(scrContext, 0) != VAR_INTEGER )
      Scr_ParamError(COM_ERR_4163, scrContext, 0, "not a boolean - allowUnlinkInCollision");
    LOBYTE(v4) = Scr_GetInt(scrContext, 0) != 0;
  }
  ScrCmd_Unlink_Internal(Entity, v4);
}

/*
==============
ScrCmd_IsLinked
==============
*/
void ScrCmd_IsLinked(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  int IsLinked; 

  Entity = GetEntity(entref);
  IsLinked = G_EntIsLinked(Entity);
  Scr_AddBool(scrContext, IsLinked);
}

/*
==============
ScrCmd_GetLinkedParent
==============
*/
void ScrCmd_GetLinkedParent(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( G_EntIsLinked(Entity) )
    GScr_AddEntity(Entity->tagInfo->parent);
  else
    Scr_AddUndefined(scrContext);
}

/*
==============
ScrCmd_GetLinkedChildren
==============
*/
void ScrCmd_GetLinkedChildren(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  int Int; 

  Entity = GetEntity(entref);
  if ( Scr_GetNumParam(scrContext) )
    Int = Scr_GetInt(scrContext, 0);
  else
    Int = 0;
  Scr_MakeArray(scrContext);
  AddLinkedChildren(scrContext, Entity, Int);
}

/*
==============
ScrCmd_GetMovingPlatformParent
==============
*/
void ScrCmd_GetMovingPlatformParent(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  actor_s *actor; 
  playerState_s *EntityPlayerState; 
  const gentity_s *MoverEntityFromPs; 

  Entity = GetEntity(entref);
  if ( !G_Utils_IsClientOrActor(Entity) )
  {
    Scr_Error(COM_ERR_4164, scrContext, "This function only supports players and actors.");
LABEL_3:
    Scr_AddUndefined(scrContext);
    return;
  }
  actor = Entity->actor;
  if ( actor )
  {
    if ( !BGMovingPlatforms::IsMovingPlatform(actor->Physics.groundEntNum) || !G_IsEntityInUse(Entity->actor->Physics.groundEntNum) )
      goto LABEL_3;
    GScr_AddEntity(&g_entities[Entity->actor->Physics.groundEntNum]);
  }
  else
  {
    EntityPlayerState = G_GetEntityPlayerState(Entity);
    if ( !EntityPlayerState )
      goto LABEL_3;
    MoverEntityFromPs = GMovingPlatforms::GetMoverEntityFromPs(EntityPlayerState);
    if ( !MoverEntityFromPs )
      goto LABEL_3;
    GScr_AddEntity(MoverEntityFromPs);
  }
}

/*
==============
ScrCmd_AutoboltMissileEffects
==============
*/
void ScrCmd_AutoboltMissileEffects(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  unsigned int v5; 

  Entity = GetEntity(entref);
  if ( BGMovingPlatforms::IsPlatformType(Entity->s.eType) )
  {
    Int = Scr_GetInt(scrContext, 0);
    v5 = Entity->flags.m_flags[0];
    if ( Int )
      Entity->flags.m_flags[0] = v5 & 0xFFFF7FFF;
    else
      Entity->flags.m_flags[0] = v5 | 0x8000;
  }
  else
  {
    Scr_Error(COM_ERR_4165, scrContext, "This function only supports moving platform entity types.");
  }
}

/*
==============
ScrCmd_EnableLinkTo
==============
*/
void ScrCmd_EnableLinkTo(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  unsigned int ScriptableIndexForEntity; 
  entityType_s eType; 
  const char *EntityTypeName; 
  const char *v7; 
  const char *v8; 

  Entity = GetEntity(entref);
  if ( (Entity->flags.m_flags[0] & 0x200) != 0 )
    Scr_ObjectError(COM_ERR_4166, scrContext, "entity already has linkTo enabled");
  if ( ((Entity->s.eType - 2) & 0xFFEF) != 0 )
  {
    ScriptableIndexForEntity = ScriptableSv_GetScriptableIndexForEntity(Entity);
    if ( ScriptableIndexForEntity == -1 || (ScriptableCommon_AssertCountsInitialized(), ScriptableIndexForEntity < g_scriptableWorldCounts.runtimeInstanceCount) )
    {
      eType = Entity->s.eType;
      if ( eType && eType != ET_INFO_VOLUME_GRAPPLE )
        goto LABEL_10;
    }
    else
    {
      ScriptableSv_VerifyScriptableMoverEntity(Entity);
    }
    if ( !Entity->physicsObject )
    {
LABEL_11:
      if ( Entity->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 8620, ASSERT_TYPE_ASSERT, "(!ent->client)", (const char *)&queryFormat, "!ent->client") )
        __debugbreak();
      goto LABEL_14;
    }
LABEL_10:
    EntityTypeName = G_GetEntityTypeName(Entity);
    v7 = SL_ConvertToString(Entity->classname);
    v8 = j_va("entity (classname: '%s', type: '%s') does not currently support enableLinkTo", v7, EntityTypeName);
    Scr_ObjectError(COM_ERR_4167, scrContext, v8);
    goto LABEL_11;
  }
LABEL_14:
  Entity->flags.m_flags[0] |= 0x200u;
}

/*
==============
ScrCmd_PlayerLinkTo
==============
*/
void ScrCmd_PlayerLinkTo(scrContext_t *scrContext, scr_entref_t entref)
{
  GScr_Main_PlayerLinkTo_Internal(scrContext, entref, PLAYERLINKTO_NORMAL);
}

/*
==============
ScrCmd_PlayerLinkToDelta
==============
*/
void ScrCmd_PlayerLinkToDelta(scrContext_t *scrContext, scr_entref_t entref)
{
  GScr_Main_PlayerLinkTo_Internal(scrContext, entref, PLAYERLINKTO_DELTA);
}

/*
==============
ScrCmd_PlayerLinkWeaponViewToDelta
==============
*/
void ScrCmd_PlayerLinkWeaponViewToDelta(scrContext_t *scrContext, scr_entref_t entref)
{
  GScr_Main_PlayerLinkTo_Internal(scrContext, entref, PLAYERLINKTO_DELTA_WEAPONVIEWONLY);
}

/*
==============
ScrCmd_PlayerLinkToAbsolute
==============
*/
void ScrCmd_PlayerLinkToAbsolute(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  scr_string_t v5; 
  scr_string_t ConstLowercaseString; 
  const char *v7; 
  char outErrorMessage[256]; 

  Entity = GetEntity(entref);
  if ( Scr_GetType(scrContext, 0) != VAR_POINTER || Scr_GetPointerType(scrContext, 0) != VAR_ENTITY )
    Scr_ParamError(COM_ERR_4174, scrContext, 0, "Not an entity");
  if ( !Entity->client )
    Scr_ObjectError(COM_ERR_4175, scrContext, "Not a player entity");
  if ( (Entity->flags.m_flags[0] & 0x200) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 8896, ASSERT_TYPE_ASSERT, "( ent->flags.TestFlag( BgEntityFlagsCommon::SUPPORTS_LINKTO ) )", (const char *)&queryFormat, "ent->flags.TestFlag( BgEntityFlagsCommon::SUPPORTS_LINKTO )") )
    __debugbreak();
  v4 = GScr_GetEntity(0);
  v5 = 0;
  if ( (int)Scr_GetNumParam(scrContext) > 1 && Scr_GetType(scrContext, 1u) )
  {
    ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 1u);
    if ( ConstLowercaseString == scr_const._ )
      ConstLowercaseString = 0;
    v5 = ConstLowercaseString;
  }
  Entity->client->linkAnglesFrac = 1.0;
  Entity->client->flags |= 4u;
  GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::SetFlagInternal(&Entity->client->ps.linkFlags, ACTIVE, 0);
  GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::ClearFlagInternal(&Entity->client->ps.linkFlags, ACTIVE, 2u);
  GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::ClearFlagInternal(&Entity->client->ps.linkFlags, GameModeFlagValues::ms_spValue, 7u);
  GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::ClearFlagInternal(&Entity->client->ps.linkFlags, GameModeFlagValues::ms_spValue, 8u);
  Entity->client->link_rotationMovesEyePos = 1;
  Entity->client->link_useTagAnglesForViewAngles = 1;
  Entity->client->link_useBaseAnglesForViewClamp = 0;
  Entity->client->link_useTagScriptedCamera = 0;
  if ( G_EntLinkTo(Entity, v4, v5, 256, outErrorMessage) )
  {
    G_InitPlayerLinkAngles(Entity);
  }
  else
  {
    v7 = j_va("failed to link entity %i to entity %i: %s", (unsigned int)Entity->s.number, (unsigned int)v4->s.number, outErrorMessage);
    Scr_Error(COM_ERR_4176, scrContext, v7);
  }
}

/*
==============
ScrCmd_PlayerLinkedOffsetEnable
==============
*/
void ScrCmd_PlayerLinkedOffsetEnable(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32> *client; 
  const char *v6; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3682, scrContext, "not an entity");
    client = NULL;
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 8943, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    client = (GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32> *)v4->client;
    if ( !client )
    {
      client = (GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32> *)v4->agent;
      if ( !client )
      {
        v6 = j_va("entity %i is not a player or agent", entnum);
        Scr_ObjectError(COM_ERR_3679, scrContext, v6);
      }
    }
  }
  if ( !v4->tagInfo )
    Scr_Error(COM_ERR_4177, scrContext, "Player is not linked.");
  GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::SetFlagInternal(client + 9, ACTIVE, 1u);
}

/*
==============
ScrCmd_PlayerLinkedSetForceParentVisible
==============
*/
void ScrCmd_PlayerLinkedSetForceParentVisible(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  int Int; 
  GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32> *p_linkFlags; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3682, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 8963, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client && !v4->agent )
    {
      v5 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3679, scrContext, v5);
    }
  }
  if ( !v4->tagInfo )
    Scr_Error(COM_ERR_5729, scrContext, "Player is not linked.");
  Int = Scr_GetInt(scrContext, 0);
  p_linkFlags = &v4->client->ps.linkFlags;
  if ( Int )
    GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::SetFlagInternal(p_linkFlags, GameModeFlagValues::ms_mpValue, 7u);
  else
    GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::ClearFlagInternal(p_linkFlags, GameModeFlagValues::ms_mpValue, 7u);
}

/*
==============
ScrCmd_PlayerUnlinkOnJump
==============
*/
void ScrCmd_PlayerUnlinkOnJump(scrContext_t *scrContext, scr_entref_t entref)
{
  Scr_Error(COM_ERR_4179, scrContext, "PlayerUnlinkOnJump is disabled");
}

/*
==============
ScrCmd_PlayerLinkedOffsetDisable
==============
*/
void ScrCmd_PlayerLinkedOffsetDisable(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32> *client; 
  const char *v6; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3682, scrContext, "not an entity");
    client = NULL;
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 9026, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    client = (GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32> *)v4->client;
    if ( !client )
    {
      client = (GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32> *)v4->agent;
      if ( !client )
      {
        v6 = j_va("entity %i is not a player or agent", entnum);
        Scr_ObjectError(COM_ERR_3679, scrContext, v6);
      }
    }
  }
  if ( !v4->tagInfo )
    Scr_Error(COM_ERR_4180, scrContext, "Player is not linked.");
  GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::ClearFlagInternal(client + 9, ACTIVE, 1u);
}

/*
==============
ScrCmd_PlayerLinkedSetViewZnear
==============
*/
void ScrCmd_PlayerLinkedSetViewZnear(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  int Int; 
  GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32> *p_linkFlags; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 9046, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  if ( !v4->tagInfo )
    Scr_Error(COM_ERR_4181, scrContext, "Player is not linked.");
  if ( (v4->client->ps.linkFlags.m_flags[0] & 4) == 0 )
    Scr_Error(COM_ERR_4182, scrContext, "Player must be linked using PlayerLinkWeaponViewToDelta()");
  Int = Scr_GetInt(scrContext, 0);
  p_linkFlags = &v4->client->ps.linkFlags;
  if ( Int )
    GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::SetFlagInternal(p_linkFlags, ACTIVE, 3u);
  else
    GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::ClearFlagInternal(p_linkFlags, ACTIVE, 3u);
}

/*
==============
ScrCmd_PlayerLinkedSetUseBaseAngleForViewClamp
==============
*/
void ScrCmd_PlayerLinkedSetUseBaseAngleForViewClamp(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 9074, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  if ( !v4->tagInfo )
    Scr_Error(COM_ERR_4183, scrContext, "Player is not linked.");
  if ( (v4->client->ps.linkFlags.m_flags[0] & 4) == 0 )
    Scr_Error(COM_ERR_4184, scrContext, "Player must be linked using PlayerLinkWeaponViewToDelta()");
  v4->client->link_useBaseAnglesForViewClamp = Scr_GetInt(scrContext, 0) != 0;
}

/*
==============
ScrCmd_PlayerLinkToBlend
==============
*/
void ScrCmd_PlayerLinkToBlend(scrContext_t *scrContext, scr_entref_t entref)
{
  scr_string_t v2; 
  unsigned int entnum; 
  gentity_s *v5; 
  const char *v6; 
  int NumParam; 
  gentity_s *Entity; 
  scr_string_t ConstLowercaseString; 
  double Float; 
  float v11; 
  double v12; 
  float v13; 
  double v14; 
  float v15; 
  gclient_s *client; 
  gclient_s *v17; 
  const char *v18; 
  float totalTime; 
  vec3_t inOutViewAngles; 
  char outErrorMessage[256]; 

  v2 = 0;
  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v5 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 9135, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v5 = &g_entities[entnum];
    if ( !v5->client )
    {
      v6 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v6);
    }
  }
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam < 1 )
    Scr_Error(COM_ERR_4189, scrContext, "Not enough parameters.\n");
  if ( (v5->flags.m_flags[0] & 0x200) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 9141, ASSERT_TYPE_ASSERT, "( pSelf->flags.TestFlag( BgEntityFlagsCommon::SUPPORTS_LINKTO ) )", (const char *)&queryFormat, "pSelf->flags.TestFlag( BgEntityFlagsCommon::SUPPORTS_LINKTO )") )
    __debugbreak();
  if ( WorldUpReferenceFrame::HasValidWorldUpInPs(&v5->client->ps) )
    ScrCmd_Unlink_Internal(v5, 1);
  Entity = GScr_GetEntity(0);
  if ( NumParam > 1 && Scr_GetType(scrContext, 1u) )
  {
    ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 1u);
    if ( ConstLowercaseString == scr_const._ )
      ConstLowercaseString = 0;
    v2 = ConstLowercaseString;
  }
  if ( NumParam <= 2 )
    *(float *)&Float = FLOAT_1_0;
  else
    Float = Scr_GetFloat(scrContext, 2u);
  totalTime = *(float *)&Float;
  v11 = 0.0;
  if ( NumParam <= 3 )
  {
    v13 = 0.0;
  }
  else
  {
    v12 = Scr_GetFloat(scrContext, 3u);
    v13 = *(float *)&v12;
  }
  if ( NumParam > 4 )
  {
    v14 = Scr_GetFloat(scrContext, 4u);
    v11 = *(float *)&v14;
  }
  CheckTimes(scrContext, &totalTime, v13, v11);
  inOutViewAngles = v5->client->ps.viewangles;
  if ( v5->tagInfo )
    BG_ApplyLinkAngles(&v5->client->ps.linkAngles, &inOutViewAngles);
  AnglesToQuat(&inOutViewAngles, &v5->c.blend.viewQuat);
  v15 = totalTime;
  v5->c.item[0].ammoCount = LODWORD(v5->r.currentOrigin.v[0]);
  v5->c.item[0].clipAmmoCount[0] = LODWORD(v5->r.currentOrigin.v[1]);
  v5->c.item[0].clipAmmoCount[1] = LODWORD(v5->r.currentOrigin.v[2]);
  client = v5->client;
  v5->c.spawner.count = LODWORD(client->ps.velocity.v[0]);
  v5->c.mover.pos.pos1.v[1] = client->ps.velocity.v[1];
  v5->c.mover.pos.pos1.v[2] = client->ps.velocity.v[2];
  v17 = v5->client;
  v5->c.mover.pos.pos3.v[1] = v13;
  v5->c.mover.pos.pos3.v[2] = v11;
  v5->c.mover.angle.speed = v15;
  v5->c.mover.angle.decelTime = (float)level.time * 0.001;
  v5->c.item[0].weapon.attachmentVariationIndices[19] = 1;
  v5->c.blend.platformEnt = truncate_cast<unsigned short,int>(v17->ps.movingPlatforms.m_movingPlatformEntity);
  v5->client->linkAnglesFrac = 1.0;
  v5->client->link_rotationMovesEyePos = 1;
  v5->client->link_useTagAnglesForViewAngles = 1;
  v5->client->link_useBaseAnglesForViewClamp = 0;
  v5->client->link_useTagScriptedCamera = 0;
  v5->client->prevLinkAnglesSet = 0;
  GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::SetFlagInternal(&v5->client->ps.linkFlags, ACTIVE, 0);
  GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::ClearFlagInternal(&v5->client->ps.linkFlags, ACTIVE, 2u);
  GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::ClearFlagInternal(&v5->client->ps.linkFlags, GameModeFlagValues::ms_spValue, 8u);
  if ( G_EntLinkTo(v5, Entity, v2, 256, outErrorMessage) )
  {
    v5->tagInfo->blendToParent = 1;
    G_InitPlayerLinkAngles(v5);
  }
  else
  {
    v18 = j_va("failed to link entity %i to entity %i: %s", (unsigned int)v5->s.number, (unsigned int)Entity->s.number, outErrorMessage);
    Scr_Error(COM_ERR_4190, scrContext, v18);
  }
}

/*
==============
ScrCmd_LerpViewAngleClamp
==============
*/
void ScrCmd_LerpViewAngleClamp(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  int NumParam; 
  double Float; 
  double v8; 
  float v9; 
  double v10; 
  float v11; 
  double v12; 
  double v13; 
  float v14; 
  double v15; 
  double v16; 
  float v17; 
  double v18; 
  double v19; 
  float v20; 
  double v21; 
  double v22; 
  gclient_s *client; 
  float v24; 
  __int64 p_link_viewClamp; 
  float totalTime; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 9259, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam < 7 )
    Scr_Error(COM_ERR_4191, scrContext, "Incorrect number of parameters.  See script docs.\n");
  if ( (NumParam <= 7 || !Scr_GetInt(scrContext, 7u)) && !BG_IsPlayerLinked(&v4->client->ps) && (v4->client->ps.linkFlags.m_flags[0] & 4) == 0 )
    Scr_Error(COM_ERR_4192, scrContext, "Must be linked to an entity.\n");
  if ( (v4->client->ps.linkFlags.m_flags[0] & 1) != 0 )
    Scr_Error(COM_ERR_4193, scrContext, "Angle locked to linked entity.  View clamp is 0.\n");
  Float = Scr_GetFloat(scrContext, 0);
  totalTime = *(float *)&Float;
  v8 = Scr_GetFloat(scrContext, 1u);
  v9 = *(float *)&v8;
  v10 = Scr_GetFloat(scrContext, 2u);
  v11 = *(float *)&v10;
  CheckTimes(scrContext, &totalTime, v9, *(float *)&v10);
  v12 = Scr_GetFloat(scrContext, 3u);
  v13 = I_fclamp(*(float *)&v12, 0.0, 180.0);
  LODWORD(v14) = LODWORD(v13) ^ _xmm;
  v15 = Scr_GetFloat(scrContext, 4u);
  v16 = I_fclamp(*(float *)&v15, 0.0, 180.0);
  v17 = *(float *)&v16;
  v18 = Scr_GetFloat(scrContext, 5u);
  v19 = I_fclamp(*(float *)&v18, 0.0, 180.0);
  LODWORD(v20) = LODWORD(v19) ^ _xmm;
  v21 = Scr_GetFloat(scrContext, 6u);
  v22 = I_fclamp(*(float *)&v21, 0.0, 180.0);
  if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_FREEFALL_IDLE|WEAPON_OFFHAND_END) )
  {
    client = v4->client;
    client->link_viewClamp.resistMin.goal = 0i64;
    client->link_viewClamp.resistMax.goal = 0i64;
  }
  v24 = totalTime;
  p_link_viewClamp = (__int64)&v4->client->link_viewClamp;
  if ( v4->client == (gclient_s *)-24252i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 9206, ASSERT_TYPE_ASSERT, "(clamp)", (const char *)&queryFormat, "clamp") )
    __debugbreak();
  *(float *)(p_link_viewClamp + 104) = v24;
  *(float *)(p_link_viewClamp + 96) = v9;
  *(float *)(p_link_viewClamp + 100) = v11;
  *(float *)(p_link_viewClamp + 108) = (float)level.time * 0.001;
  *(float *)(p_link_viewClamp + 40) = *(float *)&v22;
  *(float *)(p_link_viewClamp + 44) = v17;
  *(float *)(p_link_viewClamp + 16) = v20;
  *(float *)(p_link_viewClamp + 20) = v14;
  *(_DWORD *)p_link_viewClamp = *(_DWORD *)(p_link_viewClamp + 8);
  *(_DWORD *)(p_link_viewClamp + 4) = *(_DWORD *)(p_link_viewClamp + 12);
  *(_DWORD *)(p_link_viewClamp + 24) = *(_DWORD *)(p_link_viewClamp + 32);
  *(_DWORD *)(p_link_viewClamp + 28) = *(_DWORD *)(p_link_viewClamp + 36);
  if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_FREEFALL_IDLE|WEAPON_OFFHAND_END) )
  {
    *(_DWORD *)(p_link_viewClamp + 72) = *(_DWORD *)(p_link_viewClamp + 80);
    *(_DWORD *)(p_link_viewClamp + 76) = *(_DWORD *)(p_link_viewClamp + 84);
    *(_DWORD *)(p_link_viewClamp + 48) = *(_DWORD *)(p_link_viewClamp + 56);
    *(_DWORD *)(p_link_viewClamp + 52) = *(_DWORD *)(p_link_viewClamp + 60);
  }
}

/*
==============
ScrCmd_SetViewAngleResistance
==============
*/
void ScrCmd_SetViewAngleResistance(scrContext_t *scrContext, scr_entref_t entref)
{
  int v2; 
  unsigned int entnum; 
  gentity_s *v5; 
  const char *v6; 
  unsigned int NumParam; 
  double Float; 
  double v9; 
  float v10; 
  double v11; 
  double v12; 
  float v13; 
  double v14; 
  double v15; 
  float v16; 
  double v17; 
  double v18; 
  gclient_s *client; 

  v2 = 0;
  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v5 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 9316, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v5 = &g_entities[entnum];
    if ( !v5->client )
    {
      v6 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v6);
    }
  }
  if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_FREEFALL_IDLE|WEAPON_OFFHAND_END) )
    Scr_Error(COM_ERR_4194, scrContext, "SetViewAngleResistance is not supported in this game mode");
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam - 4 > 1 )
    Scr_Error(COM_ERR_4195, scrContext, "Incorrect number of parameters.  See script docs.\n");
  Float = Scr_GetFloat(scrContext, 0);
  v9 = I_fclamp(*(float *)&Float, 0.0, 180.0);
  v10 = *(float *)&v9;
  v11 = Scr_GetFloat(scrContext, 1u);
  v12 = I_fclamp(*(float *)&v11, 0.0, 180.0);
  v13 = *(float *)&v12;
  v14 = Scr_GetFloat(scrContext, 2u);
  v15 = I_fclamp(*(float *)&v14, 0.0, 180.0);
  v16 = *(float *)&v15;
  v17 = Scr_GetFloat(scrContext, 3u);
  v18 = I_fclamp(*(float *)&v17, 0.0, 180.0);
  if ( NumParam == 5 )
    LOBYTE(v2) = Scr_GetInt(scrContext, 4u) != 0;
  else
    v2 = 1;
  client = v5->client;
  client->link_viewClamp.resistMin.goal.v[1] = v13;
  client->link_viewClamp.resistMin.goal.v[0] = *(float *)&v18;
  client->link_viewClamp.resistMax.goal.v[1] = v10;
  client->link_viewClamp.resistMax.goal.v[0] = v16;
  if ( v2 )
  {
    client->link_viewClamp.resistMin.current.v[0] = client->link_viewClamp.resistMin.goal.v[0];
    client->link_viewClamp.resistMin.current.v[1] = client->link_viewClamp.resistMin.goal.v[1];
    client->link_viewClamp.resistMax.current.v[0] = client->link_viewClamp.resistMax.goal.v[0];
    client->link_viewClamp.resistMax.current.v[1] = client->link_viewClamp.resistMax.goal.v[1];
  }
}

/*
==============
ScrCmd_MakeUsable
==============
*/
void ScrCmd_MakeUsable(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  __int16 scriptMoverType; 
  __int16 v5; 
  int v6; 
  int v7; 

  Entity = GetEntity(entref);
  if ( BG_IsCharacterEntity(&Entity->s) && !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_STILL_LAND|0x80) )
    Scr_Error(COM_ERR_4196, scrContext, "MakeUsable may not be called on player or agent type entities");
  if ( Entity->vehicle )
    Entity->spawnflags |= 1u;
  G_PlayerUse_SetEntityUsable(Entity, 1);
  if ( !Entity->hint.hintType )
  {
    if ( Entity->s.eType == ET_SCRIPTMOVER )
    {
      scriptMoverType = Entity->s.un.scriptMoverType;
      if ( (unsigned __int16)scriptMoverType >= 0xCu )
      {
        v7 = 12;
        v6 = scriptMoverType;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 9376, ASSERT_TYPE_ASSERT, "(unsigned)( ent->s.un.scriptMoverType ) < (unsigned)( ScriptMoverType_Count )", "ent->s.un.scriptMoverType doesn't index ScriptMoverType_Count\n\t%i not in [0, %i)", v6, v7) )
          __debugbreak();
      }
      v5 = 1;
      if ( (unsigned __int16)(Entity->s.un.scriptMoverType - 5) <= 1u )
        v5 = 6;
    }
    else
    {
      v5 = 1;
    }
    Entity->hint.hintType = v5;
  }
  SV_LinkEntity(Entity);
}

/*
==============
ScrCmd_MakeUnusable
==============
*/
void ScrCmd_MakeUnusable(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v3; 

  Entity = GetEntity(entref);
  v3 = Entity;
  if ( Entity->vehicle )
    Entity->spawnflags &= ~1u;
  G_PlayerUse_SetEntityUsable(Entity, 0);
  SV_LinkEntity(v3);
}

/*
==============
GScr_AIAnimsetHasState
==============
*/
void GScr_AIAnimsetHasState(scrContext_t *scrContext)
{
  scr_string_t ConstLowercaseString; 
  scr_string_t v3; 
  int StateInfoByName; 
  AnimsetState *outState; 

  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
    v3 = Scr_GetConstLowercaseString(scrContext, 1u);
    outState = NULL;
    StateInfoByName = BG_Animset_GetStateInfoByName(ConstLowercaseString, v3, &outState, NULL);
    Scr_AddBool(scrContext, StateInfoByName);
  }
  else
  {
    Scr_Error(COM_ERR_4739, scrContext, "GScr_ArchetypeHasState called with incorrect number of parameters.");
  }
}

/*
==============
ScrCmd_EnableMissileHint
==============
*/
void ScrCmd_EnableMissileHint(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  unsigned __int8 flags; 

  Entity = GetEntity(entref);
  Int = Scr_GetInt(scrContext, 0);
  flags = Entity->hint.flags;
  if ( Int )
    Entity->hint.flags = flags | 0x10;
  else
    Entity->hint.flags = flags & 0xEF;
}

/*
==============
GScr_SetUmbraPortalState
==============
*/
void GScr_SetUmbraPortalState(scrContext_t *scrContext)
{
  const char *String; 
  const char *v3; 
  int Int; 
  unsigned __int64 v5; 
  unsigned int gateIndexOut; 

  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_Error(COM_ERR_4740, scrContext, "SetUmbraPortalState() called with incorrect number of parameters.  Usage:  SetUmbraPortalState( <gate name>, <0/1> )\n");
  String = Scr_GetString(scrContext, 0);
  gateIndexOut = 0;
  v3 = String;
  if ( Com_GetUmbraGateIndex(String, &gateIndexOut) )
  {
    Int = Scr_GetInt(scrContext, 1u);
    v5 = gateIndexOut;
    if ( Int )
    {
      if ( gateIndexOut >= 0x180 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 263, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", gateIndexOut, 384) )
        __debugbreak();
      level.umbraGateStates.array[v5 >> 5] |= 0x80000000 >> (v5 & 0x1F);
    }
    else
    {
      if ( gateIndexOut >= 0x180 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 290, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", gateIndexOut, 384) )
        __debugbreak();
      level.umbraGateStates.array[v5 >> 5] &= ~(0x80000000 >> (v5 & 0x1F));
    }
  }
  else
  {
    Com_PrintWarning(24, "SetUmbraPortalState() called on an unknown gate:  %s\n", v3);
  }
}

/*
==============
GScr_SetCursorHint
==============
*/
void GScr_SetCursorHint(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  gentity_s *v5; 
  const char *String; 
  scr_string_t classname; 
  const char *v8; 
  const dvar_t *v9; 
  const dvar_t *v10; 
  int v11; 
  __int64 v12; 
  const char *v13; 
  signed __int64 v14; 
  int v15; 
  __int64 v16; 
  int v17; 
  int v18; 
  int v19; 
  const char **v20; 
  __int64 v21; 
  const char *v22; 

  entnum = entref.entnum;
  Entity = GetEntity(entref);
  v5 = Entity;
  if ( Entity->s.eType == ET_MISSILE && (Entity->hint.flags & 0x10) == 0 )
    Scr_Error(COM_ERR_4197, scrContext, "SetCursorHint called on missile without EnableMissileHint() activation.");
  if ( BG_IsCharacterEntity(&v5->s) && !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_STILL_LAND|0x80) )
    Scr_Error(COM_ERR_4198, scrContext, "SetCursorHint may not be called on player or agent type entities");
  if ( (v5->r.svFlags & 1) != 0 )
  {
    if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_STILL_LAND|0x80) )
    {
      Com_Printf(24, "SetCursorHint called on entity %d, which has SVF_NOCLIENT set. Flag will be removed and the entity will be passed to clients.\n", entnum);
      v5->r.svFlags &= ~1u;
    }
    else
    {
      Com_PrintWarning(24, "SetCursorHint called on entity %d, which has SVF_NOCLIENT set. This entity cannot support a cursor hint since it is not sent to the client!\n", entnum);
    }
  }
  String = Scr_GetString(scrContext, 0);
  classname = v5->classname;
  v8 = String;
  if ( (classname == scr_const.trigger_use || classname == scr_const.trigger_use_touch) && !I_stricmp(String, "HINT_NODISPLAY") )
  {
    v5->hint.hintType = 3;
  }
  else
  {
    if ( !I_stricmp(v8, "HINT_BUTTON") )
    {
      if ( v5->hint.displayRadius <= 0.0 )
      {
        v9 = DVARFLT_player_buttonHintRadius;
        if ( !DVARFLT_player_buttonHintRadius && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_buttonHintRadius") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v9);
        LODWORD(v5->hint.displayRadius) = v9->current.integer;
      }
      if ( v5->hint.displayFOV <= 0.0 )
      {
        v10 = DVARFLT_player_buttonHintFOV;
        if ( !DVARFLT_player_buttonHintFOV && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "player_buttonHintFOV") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v10);
        LODWORD(v5->hint.displayFOV) = v10->current.integer;
      }
    }
    v11 = 1;
    while ( 2 )
    {
      v12 = 0x7FFFFFFFi64;
      v13 = hintStrings[v11];
      if ( !v8 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
        __debugbreak();
      if ( !v13 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 213, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
        __debugbreak();
      v14 = v8 - v13;
      while ( 1 )
      {
        v15 = (unsigned __int8)v13[v14];
        v16 = v12;
        v17 = *(unsigned __int8 *)v13++;
        --v12;
        if ( !v16 )
        {
LABEL_42:
          if ( (unsigned int)(v11 + 0x8000) > 0xFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "short __cdecl truncate_cast_impl<short,int>(int)", "signed", (__int16)v11, "signed", v11) )
            __debugbreak();
          v5->hint.hintType = v11;
          return;
        }
        if ( v15 != v17 )
        {
          v18 = v15 + 32;
          if ( (unsigned int)(v15 - 65) > 0x19 )
            v18 = v15;
          v15 = v18;
          v19 = v17 + 32;
          if ( (unsigned int)(v17 - 65) > 0x19 )
            v19 = v17;
          if ( v15 != v19 )
            break;
        }
        if ( !v15 )
          goto LABEL_42;
      }
      if ( ++v11 < 6 )
        continue;
      break;
    }
    Com_Printf(23, "List of valid hint type strings\n");
    v20 = &hintStrings[1];
    v21 = 5i64;
    do
    {
      Com_Printf(23, "%s\n", *v20++);
      --v21;
    }
    while ( v21 );
    v22 = j_va("%s is not a valid hint type. See above for list of valid hint types\n", v8);
    Scr_Error(COM_ERR_4199, scrContext, v22);
  }
}

/*
==============
G_ScrMain_FrontEndSceneCameraFade
==============
*/
void G_ScrMain_FrontEndSceneCameraFade(scrContext_t *scrContext)
{
  BOOL v2; 
  int v3; 
  double Float; 

  if ( !Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_4741, scrContext, "FrontEndSceneCameraChange() called with incorrect number of parameters.\n");
  v2 = Scr_GetInt(scrContext, 0) != 0;
  if ( Scr_GetNumParam(scrContext) <= 2 )
  {
    Float = Scr_GetFloat(scrContext, 1u);
    v3 = (int)(float)(*(float *)&Float * 1000.0);
  }
  else
  {
    v3 = 500;
  }
  G_FrontEndScene_SetCameraFade((const BgScriptedCameraFadeState)v2, level.time, level.time + v3);
}

/*
==============
G_ScrMain_FrontEndSceneCameraFOV
==============
*/
void G_ScrMain_FrontEndSceneCameraFOV(scrContext_t *scrContext)
{
  int Int; 
  double Float; 
  int v4; 

  if ( !Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_4742, scrContext, "FrontEndSceneFovChange() called with incorrect number of parameters.\n");
  Int = Scr_GetInt(scrContext, 0);
  if ( Scr_GetNumParam(scrContext) < 2 )
  {
    v4 = 0;
  }
  else
  {
    Float = Scr_GetFloat(scrContext, 1u);
    v4 = (int)(float)(*(float *)&Float * 1000.0);
  }
  G_FrontEndScene_SetCameraFov(Int, level.time, level.time + v4);
}

/*
==============
G_ScrMain_FrontEndSceneCameraCharacters
==============
*/
void G_ScrMain_FrontEndSceneCameraCharacters(scrContext_t *scrContext)
{
  unsigned int time; 
  unsigned int NumParam; 
  unsigned int v4; 
  unsigned int Int; 
  __int64 v6; 
  bool requiredCharacters[8]; 
  __int64 v8; 
  __int64 i; 

  if ( Scr_GetNumParam(scrContext) > 0x18 )
    Scr_Error(COM_ERR_4743, scrContext, "FrontEndSceneCameraRequiredCharacter() called with too many parameters.\n");
  time = level.time;
  NumParam = Scr_GetNumParam(scrContext);
  Com_Printf(24, "FrontEndSceneCameraCharacters: %i characters, time %i.\n", NumParam, time);
  *(_QWORD *)requiredCharacters = 0i64;
  v4 = 0;
  v8 = 0i64;
  for ( i = 0i64; v4 < Scr_GetNumParam(scrContext); ++v4 )
  {
    Int = Scr_GetInt(scrContext, v4);
    v6 = Int;
    if ( Int >= 0x18 )
      Scr_Error(COM_ERR_4744, scrContext, "FrontEndSceneCameraRequiredCharacter() CharacterId must a valid client index.\n");
    requiredCharacters[v6] = 1;
  }
  G_FrontEndScene_SetCameraCharacters(requiredCharacters, level.time);
}

/*
==============
G_ScrMain_FrontEndSceneCameraCinematic
==============
*/
void G_ScrMain_FrontEndSceneCameraCinematic(scrContext_t *scrContext)
{
  const char *String; 
  bool v3; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4745, scrContext, "Expected parameter <bink name>");
  String = Scr_GetString(scrContext, 0);
  if ( Scr_GetNumParam(scrContext) < 2 )
  {
    v3 = 1;
  }
  else
  {
    if ( !*String )
      Scr_ParamError(COM_ERR_4746, scrContext, 1u, "Shouldn't specify a looping parameter when the bink name is blank");
    v3 = Scr_GetInt(scrContext, 1u) != 0;
  }
  G_FrontEndScene_SetCameraCinematicPlayback(String, v3, level.time);
}

/*
==============
G_ScrMain_FrontEndSceneGetActiveSection
==============
*/
void G_ScrMain_FrontEndSceneGetActiveSection(scrContext_t *scrContext)
{
  int ActiveSectionParam; 
  unsigned int CanonicalString; 
  const char *ActiveSectionName; 
  unsigned int v5; 

  Scr_AddStruct(scrContext);
  ActiveSectionParam = G_FrontEndScene_GetActiveSectionParam();
  Scr_AddInt(scrContext, ActiveSectionParam);
  CanonicalString = SL_GetCanonicalString("index");
  Scr_AddStructField(scrContext, CanonicalString);
  ActiveSectionName = G_FrontEndScene_GetActiveSectionName();
  Scr_AddString(scrContext, ActiveSectionName);
  v5 = SL_GetCanonicalString((const char *)&stru_143C9A1A4);
  Scr_AddStructField(scrContext, v5);
}

/*
==============
ScrCmd_IsAgent
==============
*/
void ScrCmd_IsAgent(scrContext_t *scrContext)
{
  const gentity_s *Entity; 

  if ( Scr_GetType(scrContext, 0) == VAR_POINTER && Scr_GetPointerType(scrContext, 0) == VAR_ENTITY && (Entity = GScr_GetEntity(0), SV_IsAgentEntity(Entity)) )
    Scr_AddInt(scrContext, 1);
  else
    Scr_AddInt(scrContext, 0);
}

/*
==============
GScr_SetHintString
==============
*/
void GScr_SetHintString(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  entityType_s eType; 
  const char *v5; 
  ComErrorCode v6; 
  scr_string_t classname; 
  const char *String; 
  const char *v9; 

  Entity = GetEntity(entref);
  eType = Entity->s.eType;
  if ( eType == ET_MISSILE )
  {
    if ( (Entity->hint.flags & 0x10) == 0 )
    {
      v5 = "SetHintString called on missile without EnableMissileHint() activation.";
      v6 = COM_ERR_4200;
LABEL_11:
      Scr_Error(v6, scrContext, v5);
    }
  }
  else
  {
    classname = Entity->classname;
    if ( classname != scr_const.trigger_use && classname != scr_const.trigger_use_touch && eType != ET_TURRET && eType != ET_SCRIPTMOVER && !Entity->actor && !Entity->agent )
    {
      v5 = "The setHintString command only works on trigger_use, trigger_use_touch, turret, actor, and script entities.\n";
      v6 = COM_ERR_4201;
      goto LABEL_11;
    }
  }
  Entity->hint.hintString = 0;
  if ( Scr_GetType(scrContext, 0) != VAR_STRING || (String = Scr_GetString(scrContext, 0), I_stricmp(String, (const char *)&queryFormat.fmt + 3)) )
    Entity->hint.hintString = G_ScrMain_GetHintStringMessage(scrContext, 0, 0);
  Entity->hint.ownerHintString = 0;
  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    if ( Scr_GetType(scrContext, 1u) != VAR_STRING || (v9 = Scr_GetString(scrContext, 1u), I_stricmp(v9, (const char *)&queryFormat.fmt + 3)) )
      Entity->hint.ownerHintString = G_ScrMain_GetHintStringMessage(scrContext, 1, 1);
  }
}

/*
==============
ScrCmd_IsScriptedAgent
==============
*/
void ScrCmd_IsScriptedAgent(scrContext_t *scrContext)
{
  const gentity_s *Entity; 

  if ( Scr_GetType(scrContext, 0) == VAR_POINTER && Scr_GetPointerType(scrContext, 0) == VAR_ENTITY && (Entity = GScr_GetEntity(0), SV_IsAgentEntity(Entity)) && SV_Agent_IsScripted(Entity->s.number) )
    Scr_AddInt(scrContext, 1);
  else
    Scr_AddInt(scrContext, 0);
}

/*
==============
ScrCmd_IsBot
==============
*/
void ScrCmd_IsBot(scrContext_t *scrContext)
{
  const gentity_s *Entity; 

  if ( Scr_GetType(scrContext, 0) == VAR_POINTER && Scr_GetPointerType(scrContext, 0) == VAR_ENTITY && (Entity = GScr_GetEntity(0), SV_BotIsBotEntClient(Entity)) )
    Scr_AddInt(scrContext, 1);
  else
    Scr_AddInt(scrContext, 0);
}

/*
==============
ScrCmd_GetWeaponClipModel
==============
*/
void ScrCmd_GetWeaponClipModel(scrContext_t *scrContext)
{
  const WeaponAttachment *WeaponPrimaryAttachment; 
  const WeaponAttachment *v3; 
  unsigned int numModelVariations; 
  __int64 v5; 
  const char *name; 
  int v7; 
  unsigned int v8; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( outWeapon.weaponIdx )
  {
    WeaponPrimaryAttachment = BG_GetWeaponPrimaryAttachment(&outWeapon, ATT_SLOT_MAGAZINE);
    v3 = WeaponPrimaryAttachment;
    if ( WeaponPrimaryAttachment )
    {
      numModelVariations = WeaponPrimaryAttachment->numModelVariations;
      if ( numModelVariations )
      {
        v5 = outWeapon.attachmentVariationIndices[3];
        if ( outWeapon.attachmentVariationIndices[3] >= numModelVariations )
        {
          v8 = WeaponPrimaryAttachment->numModelVariations;
          v7 = outWeapon.attachmentVariationIndices[3];
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 27778, ASSERT_TYPE_ASSERT, "(unsigned)( varIndex ) < (unsigned)( magazineAttachment->numModelVariations )", "varIndex doesn't index magazineAttachment->numModelVariations\n\t%i not in [0, %i)", v7, v8) )
            __debugbreak();
        }
        name = v3->worldModelVariations[v5]->name;
        if ( name )
        {
          if ( *name )
            Scr_AddString(scrContext, name);
        }
      }
    }
  }
}

/*
==============
GScr_SetHintIcon
==============
*/
void GScr_SetHintIcon(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t classname; 
  entityType_s eType; 
  const char *String; 
  const char *v7; 
  unsigned int outIndex; 

  Entity = GetEntity(entref);
  classname = Entity->classname;
  if ( classname != scr_const.trigger_use && classname != scr_const.trigger_use_touch )
  {
    eType = Entity->s.eType;
    if ( eType != ET_TURRET && eType != ET_SCRIPTMOVER && !Entity->actor && !Entity->agent )
      Scr_Error(COM_ERR_4202, scrContext, "The SetHintStringParams command only works on trigger_use, trigger_use_touch, turret, actor, and script entities.\n");
  }
  String = Scr_GetString(scrContext, 0);
  if ( !NetConstStrings_GetIndexFromName(NETCONSTSTRINGTYPE_IMAGE, String, &outIndex) )
  {
    v7 = j_va("'%s' is not a valid image. Please make sure it is included as precache_image in zone_source.", String);
    Scr_Error(COM_ERR_4203, scrContext, v7);
  }
  Entity->hint.paramsTypes[0] = HINT_PARAM_TYPE_IMAGE;
  Entity->hint.paramValues[0].intVal = outIndex;
}

/*
==============
GScr_SetHintStringParams
==============
*/
void GScr_SetHintStringParams(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t classname; 
  entityType_s eType; 
  unsigned int NumParam; 
  unsigned int v7; 
  HintParamValue *paramValues; 
  __int64 v9; 
  VariableType Type; 
  const char *v11; 
  double Float; 
  unsigned int HintStringMessage; 

  Entity = GetEntity(entref);
  classname = Entity->classname;
  if ( classname != scr_const.trigger_use && classname != scr_const.trigger_use_touch )
  {
    eType = Entity->s.eType;
    if ( eType != ET_TURRET && eType != ET_SCRIPTMOVER && !Entity->actor && !Entity->agent )
      Scr_Error(COM_ERR_4204, scrContext, "The SetHintStringParams command only works on trigger_use, trigger_use_touch, turret, actor, and script entities.\n");
  }
  NumParam = Scr_GetNumParam(scrContext);
  v7 = 0;
  if ( NumParam )
  {
    paramValues = Entity->hint.paramValues;
    v9 = 0i64;
    do
    {
      Type = Scr_GetType(scrContext, v7);
      if ( Type )
      {
        switch ( Type )
        {
          case VAR_ISTRING:
            HintStringMessage = G_ScrMain_GetHintStringMessage(scrContext, v7, v7);
            if ( !HintStringMessage )
              Com_PrintError(15, "SetHintStringParams could not find or allocate hint string index for param %u", v7);
            Entity->hint.paramsTypes[v9] = HINT_PARAM_TYPE_STRING;
            paramValues->intVal = HintStringMessage;
            break;
          case VAR_FLOAT:
            Entity->hint.paramsTypes[v9] = HINT_PARAM_TYPE_FLOAT;
            Float = Scr_GetFloat(scrContext, v7);
            paramValues->floatVal = *(float *)&Float;
            break;
          case VAR_INTEGER:
            Entity->hint.paramsTypes[v9] = HINT_PARAM_TYPE_INT;
            paramValues->intVal = Scr_GetInt(scrContext, v7);
            break;
          default:
            v11 = j_va("The SetHintStringParams passed an unhandled type for parameter %u\n", v7);
            Scr_Error(COM_ERR_4205, scrContext, v11);
            break;
        }
      }
      else
      {
        Entity->hint.paramsTypes[v9] = HINT_PARAM_TYPE_NONE;
        paramValues->intVal = 0;
      }
      ++v7;
      ++v9;
      ++paramValues;
    }
    while ( v7 < NumParam );
  }
}

/*
==============
ScrCmd_GetUnarchivedDebugDvar
==============
*/
void ScrCmd_GetUnarchivedDebugDvar(scrContext_t *scrContext)
{
  const char *String; 
  unsigned int NumParam; 
  const char *v4; 
  const char *VariantStringWithDefault; 

  String = (char *)&queryFormat.fmt + 3;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam != 1 )
  {
    if ( NumParam != 2 )
    {
      Scr_Error(COM_ERR_4747, scrContext, "GetUnarchivedDebugDvar( <dvar>, <default> ) takes either one or two parameters");
      return;
    }
    String = Scr_GetString(scrContext, 1u);
  }
  v4 = Scr_GetString(scrContext, 0);
  VariantStringWithDefault = Dvar_GetVariantStringWithDefault(v4, String);
  Scr_AddString(scrContext, VariantStringWithDefault);
}

/*
==============
ScrCmd_SetClothType
==============
*/
void ScrCmd_SetClothType(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *String; 
  int EquipmentSoundClothIndex; 
  const char *v6; 
  AICommonInterface *m_pAI; 
  void (__fastcall *SetClothType)(AICommonInterface *, unsigned __int8); 
  AICommonWrapper v9; 

  Entity = GetEntity(entref);
  String = Scr_GetString(scrContext, 0);
  EquipmentSoundClothIndex = BG_FindEquipmentSoundClothIndex(String);
  if ( EquipmentSoundClothIndex == -1 )
  {
    v6 = j_va("unable to find cloth type '%s'", String);
    Scr_Error(COM_ERR_4748, scrContext, v6);
  }
  if ( Entity->client )
  {
    Entity->client->ps.clothType = truncate_cast<signed char,int>(EquipmentSoundClothIndex);
  }
  else
  {
    AIActorInterface::AIActorInterface(&v9.m_actorInterface);
    AIAgentInterface::AIAgentInterface(&v9.m_newAgentInterface);
    v9.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
    AICommonInterface::AICommonInterface(&v9.m_botInterface);
    v9.m_botInterface.__vftable = (AIBotInterface_vtbl *)&AIBotInterface::`vftable';
    AICommonInterface::AICommonInterface(&v9.m_botAgentInterface);
    v9.m_pAI = NULL;
    v9.m_botAgentInterface.__vftable = (AIBotAgentInterface_vtbl *)&AIBotAgentInterface::`vftable';
    AICommonWrapper::Setup(&v9, Entity);
    m_pAI = v9.m_pAI;
    if ( v9.m_pAI )
    {
      SetClothType = v9.m_pAI->SetClothType;
      if ( (EquipmentSoundClothIndex < 0 || (unsigned int)EquipmentSoundClothIndex > 0xFF) && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned char __cdecl truncate_cast_impl<unsigned char,int>(int)", "unsigned", (unsigned __int8)EquipmentSoundClothIndex, "signed", EquipmentSoundClothIndex) )
        __debugbreak();
      SetClothType(m_pAI, EquipmentSoundClothIndex);
    }
  }
}

/*
==============
GScr_SetHintDisplayRange
==============
*/
void GScr_SetHintDisplayRange(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm { vmaxss  xmm0, xmm0, xmm1 }
  Entity->hint.displayRadius = *(float *)&_XMM0;
}

/*
==============
GScr_SetHintDisplayFOV
==============
*/
void GScr_SetHintDisplayFOV(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm { vmaxss  xmm0, xmm0, xmm1 }
  Entity->hint.displayFOV = *(float *)&_XMM0;
}

/*
==============
GScr_SetHintTag
==============
*/
void GScr_SetHintTag(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t ConstLowercaseString; 
  int BoneIndex; 

  Entity = GetEntity(entref);
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  if ( SV_Game_DObjExists(Entity) )
  {
    BoneIndex = SV_Game_DObjGetBoneIndex(Entity, ConstLowercaseString);
    if ( BoneIndex < 0 )
      BoneIndex = 255;
    Entity->hint.tag = BoneIndex;
  }
  else
  {
    Entity->hint.tag = 255;
  }
}

/*
==============
GScr_SetUseRange
==============
*/
void GScr_SetUseRange(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  unsigned int number; 
  const char *v7; 

  Entity = GetEntity(entref);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  number = Entity->s.number;
  __asm { vmaxss  xmm3, xmm0, xmm1; useRadius }
  Entity->hint.useRadius = *(float *)&_XMM3;
  if ( !G_PlayerUse_SetUseRadius(number, USE_CLASS_GENTITY, 0, *(const float *)&_XMM3) )
  {
    v7 = j_va("Failed to set the use radius for entity %d\n", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_4206, scrContext, v7);
  }
}

/*
==============
ScrCmd_GetShootAtPosition
==============
*/
void ScrCmd_GetShootAtPosition(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const gentity_s *v4; 
  const sentient_s *sentient; 
  gclient_s *client; 
  scr_string_t tag_eye; 
  vec3_t outCentroid; 

  Entity = GetEntity(entref);
  v4 = Entity;
  sentient = Entity->sentient;
  if ( sentient )
  {
    client = Entity->client;
    if ( client && client->sess.sessionState )
    {
      Com_PrintWarning(23, "GetShootAtPos() called while not in SESS_STATE_PLAYING");
      G_Utils_EntityCentroid(v4, &outCentroid);
    }
    else
    {
      Sentient_GetEyePosition(sentient, &outCentroid);
    }
  }
  else
  {
    tag_eye = scr_const.tag_eye;
    if ( Entity->s.number != level.cachedEntTargetTagMat.entnum || level.time != level.cachedEntTargetTagMat.time || scr_const.tag_eye != level.cachedEntTargetTagMat.name )
    {
      if ( !SV_Game_DObjExists(Entity) || !G_Utils_DObjGetWorldTagMatrix(v4, tag_eye, &level.cachedEntTargetTagMat.tagMat) )
      {
        G_Utils_EntityCentroid(v4, &outCentroid);
        goto LABEL_14;
      }
      level.cachedEntTargetTagMat.entnum = v4->s.number;
      level.cachedEntTargetTagMat.time = level.time;
      Scr_SetString(&level.cachedEntTargetTagMat.name, tag_eye);
    }
    outCentroid = level.cachedEntTargetTagMat.tagMat.m[3];
  }
LABEL_14:
  Scr_AddVector(scrContext, outCentroid.v);
}

/*
==============
GScr_SetUseHoldDuration
==============
*/
void GScr_SetUseHoldDuration(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t ConstString; 
  const char *String; 
  const char *v6; 

  Entity = GetEntity(entref);
  ConstString = Scr_GetConstString(scrContext, 0);
  if ( ConstString == scr_const.duration_none )
  {
    Entity->hint.useHoldDuration = HINT_HOLD_DURATION_NONE;
  }
  else if ( ConstString == scr_const.duration_short )
  {
    Entity->hint.useHoldDuration = HINT_HOLD_DURATION_SHORT;
  }
  else if ( ConstString == scr_const.duration_medium )
  {
    Entity->hint.useHoldDuration = HINT_HOLD_DURATION_MEDIUM;
  }
  else if ( ConstString == scr_const.duration_long )
  {
    Entity->hint.useHoldDuration = HINT_HOLD_DURATION_LONG;
  }
  else
  {
    String = Scr_GetString(scrContext, 0);
    v6 = j_va("Illegal duration string \"%s\". Valid strings are \"duration_none\", \"duration_short\", \"duration_medium\", \"duration_long\"\n", String);
    Scr_Error(COM_ERR_4207, scrContext, v6);
  }
}

/*
==============
ScrCmd_GetMuzzlePos
==============
*/
void ScrCmd_GetMuzzlePos(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  AIWrapper v6; 
  vec3_t outOrigin; 
  vec3_t outForward; 

  AIActorInterface::AIActorInterface(&v6.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v6.m_newAgentInterface);
  v6.m_pAI = NULL;
  v6.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v6, Entity);
  m_pAI = v6.m_pAI;
  if ( !v6.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 27927, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  if ( !AIScriptedInterface::GetMuzzleInfo(m_pAI, &outOrigin, &outForward) )
    m_pAI->GetEyePosition(m_pAI, &outOrigin);
  Scr_AddVector(scrContext, outOrigin.v);
}

/*
==============
ScrCmd_NearNode
==============
*/
void ScrCmd_NearNode(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AICommonInterface *m_pAI; 
  const pathnode_t *Pathnode; 
  __int64 v7; 
  bool v8; 
  AICommonWrapper v9; 

  AIActorInterface::AIActorInterface(&v9.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v9.m_newAgentInterface);
  v9.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AICommonInterface::AICommonInterface(&v9.m_botInterface);
  v9.m_botInterface.__vftable = (AIBotInterface_vtbl *)&AIBotInterface::`vftable';
  AICommonInterface::AICommonInterface(&v9.m_botAgentInterface);
  v9.m_pAI = NULL;
  v9.m_botAgentInterface.__vftable = (AIBotAgentInterface_vtbl *)&AIBotAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AICommonWrapper::Setup(&v9, Entity);
  m_pAI = v9.m_pAI;
  if ( !v9.m_pAI || !v9.m_pAI->GetSentient(v9.m_pAI) )
    Scr_Error(COM_ERR_4749, scrContext, "NearNode must be called on an AI");
  Pathnode = Scr_GetPathnode(scrContext, 0);
  v7 = (__int64)m_pAI->GetEntity(m_pAI);
  v8 = AICommonInterface::PointNearNode(m_pAI, (const vec3_t *)(v7 + 304), Pathnode);
  Scr_AddBool(scrContext, v8);
}

/*
==============
GScr_SetUseHideProgressBar
==============
*/
void GScr_SetUseHideProgressBar(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  unsigned __int8 flags; 

  Entity = GetEntity(entref);
  Int = Scr_GetInt(scrContext, 0);
  flags = Entity->hint.flags;
  if ( Int )
    Entity->hint.flags = flags | 0x20;
  else
    Entity->hint.flags = flags & 0xDF;
}

/*
==============
GScr_SetUseWhenHandsOccupied
==============
*/
void GScr_SetUseWhenHandsOccupied(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  unsigned __int8 flags; 

  Entity = GetEntity(entref);
  Int = Scr_GetInt(scrContext, 0);
  flags = Entity->hint.flags;
  if ( Int )
    Entity->hint.flags = flags | 0x40;
  else
    Entity->hint.flags = flags & 0xBF;
}

/*
==============
ScrCmd_GetMuzzleDir
==============
*/
void ScrCmd_GetMuzzleDir(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  AIWrapper v6; 
  vec3_t outForward; 
  vec3_t outOrigin; 

  AIActorInterface::AIActorInterface(&v6.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v6.m_newAgentInterface);
  v6.m_pAI = NULL;
  v6.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v6, Entity);
  m_pAI = v6.m_pAI;
  if ( !v6.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 27981, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  if ( !AIScriptedInterface::GetMuzzleInfo(m_pAI, &outOrigin, &outForward) )
    AICommonInterface::GetEyeDirection(m_pAI, &outForward);
  Scr_AddVector(scrContext, outForward.v);
}

/*
==============
GScr_SetUseCommand
==============
*/
void GScr_SetUseCommand(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *String; 
  LocalClientNum_t OnlyLocalClientNum; 
  int CommandAssignment; 
  bool v7; 
  LocalClientNum_t v8; 
  int v9; 
  LocalClientNum_t v10; 
  int BindingForCommand; 
  int v12; 
  const char *v13; 
  int twokeys; 

  Entity = GetEntity(entref);
  String = Scr_GetString(scrContext, 0);
  if ( !String )
    Scr_Error(COM_ERR_4208, scrContext, "SetUseCommand: NULL useCommand provided.");
  if ( !Com_GameMode_SupportsFeature(WEAPON_LEAP_LOOP) )
    goto LABEL_8;
  OnlyLocalClientNum = CL_GetOnlyLocalClientNum();
  CommandAssignment = CL_Keys_GetCommandAssignment(OnlyLocalClientNum, String, &twokeys);
  v7 = CommandAssignment <= 0;
  if ( !CommandAssignment )
  {
    v8 = CL_GetOnlyLocalClientNum();
    v7 = CL_Keys_GetAlternateCommandAssignment(v8, String, &twokeys) <= 0;
  }
  if ( v7 )
  {
LABEL_8:
    BindingForCommand = Com_Keys_GetBindingForCommand(String);
    v12 = BindingForCommand;
    if ( (BindingForCommand & 1) == 0 || (unsigned int)(BindingForCommand - 117) <= 0x83 || BindingForCommand >= 255 || !BindingForCommand )
    {
      v13 = j_va("SetUseCommand: (%s) is not a valid use command.", String);
      Scr_Error(COM_ERR_4209, scrContext, v13);
    }
    Entity->hint.useBinding = v12;
  }
  else
  {
    v9 = twokeys;
    v10 = CL_GetOnlyLocalClientNum();
    Entity->hint.useBinding = CL_Keys_GetActiveBinding(v10, v9);
  }
}

/*
==============
ScrCmd_GetMuzzleAngle
==============
*/
void ScrCmd_GetMuzzleAngle(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  AIWrapper v6; 
  vec3_t outForward; 
  vec3_t angles; 
  vec3_t outOrigin; 

  AIActorInterface::AIActorInterface(&v6.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v6.m_newAgentInterface);
  v6.m_pAI = NULL;
  v6.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v6, Entity);
  m_pAI = v6.m_pAI;
  if ( !v6.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 28008, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  if ( !AIScriptedInterface::GetMuzzleInfo(m_pAI, &outOrigin, &outForward) )
    AICommonInterface::GetEyeDirection(m_pAI, &outForward);
  vectoangles(&outForward, &angles);
  Scr_AddVector(scrContext, angles.v);
}

/*
==============
GScr_SetUseFOV
==============
*/
void GScr_SetUseFOV(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm { vmaxss  xmm0, xmm0, xmm1 }
  Entity->hint.useFOV = *(float *)&_XMM0;
}

/*
==============
GScr_SetHintOnObstruction
==============
*/
void GScr_SetHintOnObstruction(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *String; 

  Entity = GetEntity(entref);
  String = Scr_GetString(scrContext, 0);
  if ( I_stricmp(String, "hide") )
  {
    if ( I_stricmp(String, "show") )
      Scr_Error(COM_ERR_4210, scrContext, "Acceptable values for SetHintOnObstruction are \"hide\" and \"show\".\n");
    else
      Entity->hint.onObstruction = SHOW;
  }
  else
  {
    Entity->hint.onObstruction = HIDE;
  }
}

/*
==============
ScrCmd_GetMuzzleSideOffsetPos
==============
*/
void ScrCmd_GetMuzzleSideOffsetPos(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  int MuzzleInfo; 
  AIScriptedInterface_vtbl *v7; 
  __int64 v8; 
  float v9; 
  AIWrapper v10; 
  vec3_t outOrigin; 
  vec3_t right; 
  vec3_t outForward; 

  AIActorInterface::AIActorInterface(&v10.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v10.m_newAgentInterface);
  v10.m_pAI = NULL;
  v10.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v10, Entity);
  m_pAI = v10.m_pAI;
  if ( !v10.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 28032, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  MuzzleInfo = AIScriptedInterface::GetMuzzleInfo(m_pAI, &outOrigin, &outForward);
  v7 = m_pAI->__vftable;
  if ( MuzzleInfo )
  {
    v8 = (__int64)v7->GetEntity(m_pAI);
    AngleVectors((const vec3_t *)(v8 + 316), NULL, &right, NULL);
    v9 = (float)((float)(outOrigin.v[1] - *(float *)(v8 + 308)) * right.v[1]) + (float)((float)(outOrigin.v[0] - *(float *)(v8 + 304)) * right.v[0]);
    outOrigin.v[0] = (float)(v9 * right.v[0]) + *(float *)(v8 + 304);
    outOrigin.v[1] = (float)(v9 * right.v[1]) + *(float *)(v8 + 308);
  }
  else
  {
    v7->GetEyePosition(m_pAI, &outOrigin);
  }
  Scr_AddVector(scrContext, outOrigin.v);
}

/*
==============
GScr_SetHintRequiresMashing
==============
*/
void GScr_SetHintRequiresMashing(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  unsigned __int8 flags; 

  Entity = GetEntity(entref);
  Int = Scr_GetInt(scrContext, 0);
  flags = Entity->hint.flags;
  if ( Int )
    Entity->hint.flags = flags | 2;
  else
    Entity->hint.flags = flags & 0xFD;
}

/*
==============
ScrCmd_UpdatePlayerSightAccuracy
==============
*/
void ScrCmd_UpdatePlayerSightAccuracy(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  AIWrapper v5; 

  AIActorInterface::AIActorInterface(&v5.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v5.m_newAgentInterface);
  v5.m_pAI = NULL;
  v5.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v5, Entity);
  m_pAI = v5.m_pAI;
  if ( !v5.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 28066, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  AIScriptedInterface::UpdatePlayerSightAccuracy(m_pAI);
}

/*
==============
GScr_SetHintLockPlayerMovement
==============
*/
void GScr_SetHintLockPlayerMovement(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  unsigned __int8 flags; 

  Entity = GetEntity(entref);
  Int = Scr_GetInt(scrContext, 0);
  flags = Entity->hint.flags;
  if ( Int )
    Entity->hint.flags = flags | 8;
  else
    Entity->hint.flags = flags & 0xF7;
}

/*
==============
GScr_ClearPlayerHintLock
==============
*/
void GScr_ClearPlayerHintLock(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  char *client; 
  const char *v6; 
  ComErrorCode v7; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 10057, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = (char *)v4->client;
  if ( !client )
  {
    client = (char *)v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v7, scrContext, v6);
      client = NULL;
    }
  }
  *((_WORD *)client + 366) &= ~0x10u;
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal((GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *)(client + 28), GameModeFlagValues::ms_spValue, 0x2Eu);
}

/*
==============
ScrCmd_AddAIEventListener
==============
*/
void ScrCmd_AddAIEventListener(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *v4; 
  scr_string_t ConstString; 

  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 28087, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !Entity->sentient )
  {
    v4 = j_va("entity %d must be a sentient!", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_4750, scrContext, v4);
  }
  ConstString = Scr_GetConstString(scrContext, 0);
  Actor_EventListener_Add(Entity->s.number, ConstString);
}

/*
==============
ScrCmd_RemoveAIEventListener
==============
*/
void ScrCmd_RemoveAIEventListener(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t ConstString; 

  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 28112, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( Scr_GetNumParam(scrContext) )
  {
    ConstString = Scr_GetConstString(scrContext, 0);
    Actor_EventListener_Remove(Entity->s.number, ConstString);
  }
  else
  {
    Actor_EventListener_RemoveEntity(Entity->s.number);
  }
}

/*
==============
GScr_SetHintRequiresHolding
==============
*/
void GScr_SetHintRequiresHolding(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  unsigned __int8 flags; 

  Entity = GetEntity(entref);
  Int = Scr_GetInt(scrContext, 0);
  flags = Entity->hint.flags;
  if ( Int )
    Entity->hint.flags = flags | 4;
  else
    Entity->hint.flags = flags & 0xFB;
}

/*
==============
GScr_SetHintInoperable
==============
*/
void GScr_SetHintInoperable(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  unsigned __int8 flags; 

  Entity = GetEntity(entref);
  Int = Scr_GetInt(scrContext, 0);
  flags = Entity->hint.flags;
  if ( Int )
    Entity->hint.flags = flags | 1;
  else
    Entity->hint.flags = flags & 0xFE;
}

/*
==============
ScrCmd_AIEventListenerEvent
==============
*/
void ScrCmd_AIEventListenerEvent(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  scr_string_t ConstString; 
  vec3_t vectorValue; 

  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 28142, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  vectorValue.v[0] = 0.0;
  vectorValue.v[1] = 0.0;
  vectorValue.v[2] = 0.0;
  v4 = NULL;
  ConstString = Scr_GetConstString(scrContext, 0);
  if ( Scr_GetNumParam(scrContext) > 1 && Scr_GetType(scrContext, 1u) )
    v4 = GScr_GetEntity(1u);
  if ( Scr_GetNumParam(scrContext) > 2 && Scr_GetType(scrContext, 2u) )
    Scr_GetVector(scrContext, 2u, &vectorValue);
  Actor_EventListener_EventAdd(Entity->s.number, v4, ConstString, &vectorValue);
}

/*
==============
GScr_SetUsePriority
==============
*/
void GScr_SetUsePriority(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  unsigned int Int; 
  int v5; 
  int number; 

  Entity = GetEntity(entref);
  Int = Scr_GetInt(scrContext, 0);
  Entity->hint.priority = Int;
  if ( Int + 10 > 0xB )
  {
    number = Entity->s.number;
    v5 = 1;
    Com_PrintWarning(16, "SetUsePriority script function is passed in a priority value of %d which is not in in the range of [%d, %d] for entity %d\n", Int, 4294967286i64, v5, number);
  }
  if ( Scr_GetNumParam(scrContext) > 1 && Scr_GetInt(scrContext, 1u) )
    Entity->hint.flags |= 0x80u;
  else
    Entity->hint.flags &= ~0x80u;
}

/*
==============
ScrCmd_SetSurfaceType
==============
*/
void ScrCmd_SetSurfaceType(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *String; 
  int v6; 
  const char *v7; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4751, scrContext, "USAGE: self SetSurfaceType( <surface type name> )\n");
  Entity = GetEntity(entref);
  String = Scr_GetString(scrContext, 0);
  v6 = Com_SurfaceTypeFromName(String);
  if ( !BG_IsCharacterEntity(&Entity->s) && !BG_IsCorpseEntity(&Entity->s) && !G_Utils_IsClientOrActorOrAgent(Entity) )
    Scr_Error(COM_ERR_4752, scrContext, "SetSurfaceType is only valid on players, agents, or actors.");
  if ( v6 < 0 )
  {
    v7 = j_va("unable to find surface type '%s'", String);
    Scr_Error(COM_ERR_4753, scrContext, v7);
  }
  Entity->s.surfType = v6;
}

/*
==============
GScr_SetUsePriorityMax
==============
*/
void GScr_SetUsePriorityMax(scrContext_t *scrContext, scr_entref_t entref)
{
  GetEntity(entref)->hint.priority = 0x80000000;
}

/*
==============
ScrCmd_ForceUseHintOn
==============
*/
void ScrCmd_ForceUseHintOn(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  unsigned int NumParam; 
  unsigned int HintStringMessage; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 10185, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  NumParam = Scr_GetNumParam(scrContext);
  HintStringMessage = G_ScrMain_GetHintStringMessage(scrContext, 0, NumParam - 1);
  if ( HintStringMessage )
  {
    v4->client->hintForcedType = HINT_NOICON;
    v4->client->hintForcedString = HintStringMessage;
  }
}

/*
==============
ScrCmd_DontInterpolate
==============
*/
void ScrCmd_DontInterpolate(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gclient_s *client; 

  Entity = GetEntity(entref);
  client = Entity->client;
  if ( client )
    client->ps.eFlags.m_flags[0] ^= 4u;
  else
    Entity->s.lerp.eFlags.m_flags[0] ^= 4u;
}

/*
==============
ScrCmd_SetScriptableDamageOwner
==============
*/
void ScrCmd_SetScriptableDamageOwner(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  const gentity_s *v4; 
  unsigned int scriptableIndex; 

  Entity = GetEntity(entref);
  if ( ScriptableSv_TryGetIndexForEntity(Entity, &scriptableIndex) )
  {
    v4 = GScr_GetEntity(0);
    ScriptableSv_SetDamageOwner(scriptableIndex, v4);
  }
  else
  {
    Scr_Error(COM_ERR_4754, scrContext, "SetScriptableDamageOwner() must be called on a Scriptable");
  }
}

/*
==============
GScr_SetHUDTutorialMessage
==============
*/
void GScr_SetHUDTutorialMessage(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  playerState_s *EntityPlayerState; 
  const char *String; 
  const char *v11; 
  unsigned int IndexByName; 
  OmnvarData *Data; 

  entnum = entref.entnum;
  Entity = GetEntity(entref);
  if ( !G_Utils_IsClientOrAgent(Entity) )
  {
    targetname = Entity->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(Entity->classname);
    v8 = j_va("only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, Entity->r.currentOrigin.v[0], Entity->r.currentOrigin.v[1], Entity->r.currentOrigin.v[2], v7, v6);
    Scr_Error(COM_ERR_4211, scrContext, v8);
  }
  EntityPlayerState = G_GetEntityPlayerState(Entity);
  if ( Scr_GetType(scrContext, 0) == VAR_STRING )
    String = Scr_GetString(scrContext, 0);
  else
    String = Scr_GetIString(scrContext, 0);
  v11 = String;
  if ( !GConfigStrings::ms_gConfigStrings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_configstrings.h", 71, ASSERT_TYPE_ASSERT, "( ms_gConfigStrings )", (const char *)&queryFormat, "ms_gConfigStrings") )
    __debugbreak();
  GConfigStrings::ms_gConfigStrings->SetLocalizedString(GConfigStrings::ms_gConfigStrings, v11, &EntityPlayerState->tutorialString);
  IndexByName = BG_Omnvar_GetIndexByName("ui_tutorial_message_show");
  if ( IndexByName == -1 )
    Scr_Error(COM_ERR_4212, scrContext, "SetHUDTutorialMessage can't find omnvar ui_tutorial_message_show - check omnvars.csv");
  Data = G_Omnvar_GetData(IndexByName, Entity->s.clientNum, NULL);
  Data->current.enabled = 1;
  G_Omnvar_MarkChanged(Data);
}

/*
==============
ScrCmd_ClearScriptableDamageOwner
==============
*/
void ScrCmd_ClearScriptableDamageOwner(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  unsigned int scriptableIndex; 

  Entity = GetEntity(entref);
  if ( ScriptableSv_TryGetIndexForEntity(Entity, &scriptableIndex) )
    ScriptableSv_SetDamageOwner(scriptableIndex, NULL);
  else
    Scr_Error(COM_ERR_4755, scrContext, "SetScriptableDamageOwner() must be called on a Scriptable");
}

/*
==============
ScrCmd_GetLinkedScriptableInstance
==============
*/
void ScrCmd_GetLinkedScriptableInstance(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  unsigned int scriptableIndex; 

  Entity = GetEntity(entref);
  if ( !ScriptableSv_TryGetIndexForEntity(Entity, &scriptableIndex) )
    Scr_Error(COM_ERR_5924, scrContext, "GetScriptableInstance() must be called on an entity linked to a scriptable");
  Scr_AddEntityNum(scrContext, scriptableIndex, ENTITY_CLASS_SCRIPTABLE);
}

/*
==============
GScr_ClearHUDTutorialMessage
==============
*/
void GScr_ClearHUDTutorialMessage(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  playerState_s *EntityPlayerState; 
  unsigned int IndexByName; 
  OmnvarData *Data; 

  entnum = entref.entnum;
  Entity = GetEntity(entref);
  if ( !G_Utils_IsClientOrAgent(Entity) )
  {
    targetname = Entity->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(Entity->classname);
    v8 = j_va("only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, Entity->r.currentOrigin.v[0], Entity->r.currentOrigin.v[1], Entity->r.currentOrigin.v[2], v7, v6);
    Scr_Error(COM_ERR_4213, scrContext, v8);
  }
  if ( Scr_GetNumParam(scrContext) && Scr_GetInt(scrContext, 0) )
  {
    EntityPlayerState = G_GetEntityPlayerState(Entity);
    if ( !GConfigStrings::ms_gConfigStrings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_configstrings.h", 71, ASSERT_TYPE_ASSERT, "( ms_gConfigStrings )", (const char *)&queryFormat, "ms_gConfigStrings") )
      __debugbreak();
    GConfigStrings::ms_gConfigStrings->ClearLocalizedString(GConfigStrings::ms_gConfigStrings, &EntityPlayerState->tutorialString);
  }
  else
  {
    IndexByName = BG_Omnvar_GetIndexByName("ui_tutorial_message_show");
    if ( IndexByName == -1 )
      Scr_Error(COM_ERR_4214, scrContext, "ClearHUDTutorialMessage can't find omnvar ui_tutorial_message_show - check omnvars.csv");
    Data = G_Omnvar_GetData(IndexByName, Entity->s.clientNum, NULL);
    Data->current.enabled = 0;
    G_Omnvar_MarkChanged(Data);
  }
}

/*
==============
ScrCmd_GetScriptableLinkedEntity
==============
*/
void ScrCmd_GetScriptableLinkedEntity(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  unsigned int v4; 
  const gentity_s *Entity; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  v4 = ScriptableIndex_Internal;
  if ( ScriptableIndex_Internal != -1 )
  {
    if ( ScriptableSv_GetInstanceCommonContext(ScriptableIndex_Internal)->linkedObjectType != SCRIPTABLE_LINK_ENTITY )
      Scr_Error(COM_ERR_5925, scrContext, "Scriptable is not linked to an entity");
    Entity = ScriptableSv_GetEntity(v4);
    GScr_AddEntity(Entity);
  }
}

/*
==============
GScr_AddHUDWarningMessage
==============
*/
void GScr_AddHUDWarningMessage(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  const char *String; 
  const char *v10; 
  const char *v11; 
  int v12; 

  entnum = entref.entnum;
  Entity = GetEntity(entref);
  if ( !G_Utils_IsClientOrAgent(Entity) )
  {
    targetname = Entity->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(Entity->classname);
    v8 = j_va("only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, Entity->r.currentOrigin.v[0], Entity->r.currentOrigin.v[1], Entity->r.currentOrigin.v[2], v7, v6);
    Scr_Error(COM_ERR_4216, scrContext, v8);
  }
  String = Scr_GetString(scrContext, 0);
  v10 = BGScr_TableLookupInternal(scrContext, "hudwarnings.csv", 1, String, 0);
  v11 = v10;
  if ( !v10 || !*v10 )
    Scr_Error(COM_ERR_4217, scrContext, "GScr_AddHUDWarningMessage unable to find given warning key. Please check hudwarnings.csv");
  v12 = atoi(v11);
  SetHUDWarningOmnvars(scrContext, v12, 1);
}

/*
==============
ScrCmd_GetScriptableHasPart
==============
*/
void ScrCmd_GetScriptableHasPart(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  scr_string_t ConstLowercaseString; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal != -1 )
  {
    ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
    if ( ConstLowercaseString )
    {
      if ( ScriptableSv_GetPartScriptedDefFromName(ScriptableIndex_Internal, ConstLowercaseString, 0) )
        Scr_AddBool(scrContext, 1);
      else
        Scr_AddBool(scrContext, 0);
    }
    else
    {
      Scr_Error(COM_ERR_4758, scrContext, "GetScriptableHasPart() missing partName");
    }
  }
}

/*
==============
GScr_ClearHUDWarningMessage
==============
*/
void GScr_ClearHUDWarningMessage(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v8; 

  entnum = entref.entnum;
  Entity = GetEntity(entref);
  if ( !G_Utils_IsClientOrAgent(Entity) )
  {
    targetname = Entity->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(Entity->classname);
    v8 = j_va("only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, Entity->r.currentOrigin.v[0], Entity->r.currentOrigin.v[1], Entity->r.currentOrigin.v[2], v7, v6);
    Scr_Error(COM_ERR_4218, scrContext, v8);
  }
  SetHUDWarningOmnvars(scrContext, 0, 0);
}

/*
==============
ScrCmd_GetScriptablePartHasState
==============
*/
void ScrCmd_GetScriptablePartHasState(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  scr_string_t ConstLowercaseString; 
  scr_string_t v5; 
  ScriptablePartDef *PartScriptedDefFromName; 
  int v7; 
  unsigned int out_stateIndex; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal != -1 )
  {
    ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
    if ( ConstLowercaseString )
    {
      v5 = Scr_GetConstLowercaseString(scrContext, 1u);
      if ( v5 )
      {
        PartScriptedDefFromName = ScriptableSv_GetPartScriptedDefFromName(ScriptableIndex_Internal, ConstLowercaseString, 0);
        v7 = PartScriptedDefFromName && ScriptableSv_GetPartScriptedStateFromName(ScriptableIndex_Internal, PartScriptedDefFromName, v5, 0, &out_stateIndex);
        Scr_AddBool(scrContext, v7);
      }
      else
      {
        Scr_Error(COM_ERR_4760, scrContext, "GetScriptablePartHasState() missing stateName");
      }
    }
    else
    {
      Scr_Error(COM_ERR_4759, scrContext, "GetScriptablePartHasState() missing partName");
    }
  }
}

/*
==============
ScrCmd_ForceUseHintOff
==============
*/
void ScrCmd_ForceUseHintOff(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    *(_BYTE *)(MEMORY[0x150] + 24493i64) = 0;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 10379, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
    v4->client->hintForcedType = HINT_NONE;
  }
}

/*
==============
ScrCmd_LaserOn
==============
*/
void ScrCmd_LaserOn(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gclient_s *client; 
  LerpEntityState *p_lerp; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *p_eFlags; 

  Entity = GetEntity(entref);
  client = Entity->client;
  p_lerp = &Entity->s.lerp;
  p_eFlags = &client->ps.eFlags;
  if ( !client )
    p_eFlags = &p_lerp->eFlags;
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(p_eFlags, ACTIVE, 9u);
}

/*
==============
ScrCmd_GetScriptablePartStateHasEvent
==============
*/
void ScrCmd_GetScriptablePartStateHasEvent(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  scr_string_t ConstLowercaseString; 
  scr_string_t v5; 
  scr_string_t v6; 
  scr_string_t v7; 
  Scriptable_EventType ScriptableEventType_Internal; 
  const char *v9; 
  const char *v10; 
  ScriptablePartDef *PartScriptedDefFromName; 
  const char *v12; 
  const char *v13; 
  const ScriptableStateDef *PartScriptedStateFromName; 
  const char *v15; 
  const char *v16; 
  const char *v17; 
  ScriptableEventDef *PartScriptedStateFirstEventOfType; 
  unsigned int out_stateIndex; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal != -1 )
  {
    ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
    if ( ConstLowercaseString )
    {
      v5 = Scr_GetConstLowercaseString(scrContext, 1u);
      if ( v5 )
      {
        v6 = Scr_GetConstLowercaseString(scrContext, 2u);
        ScriptableEventType_Internal = ScrCmd_GetScriptableEventType_Internal(v6);
        if ( ScriptableEventType_Internal == Scriptable_EventType_Count )
        {
          v9 = SL_ConvertToString(v7);
          v10 = j_va("GetScriptablePartStateHasEvent() unsupported event '%s'", v9);
          Scr_Error(COM_ERR_4764, scrContext, v10);
        }
        else
        {
          PartScriptedDefFromName = ScriptableSv_GetPartScriptedDefFromName(ScriptableIndex_Internal, ConstLowercaseString, 0);
          if ( PartScriptedDefFromName )
          {
            PartScriptedStateFromName = ScriptableSv_GetPartScriptedStateFromName(ScriptableIndex_Internal, PartScriptedDefFromName, v5, 0, &out_stateIndex);
            if ( PartScriptedStateFromName )
            {
              PartScriptedStateFirstEventOfType = ScriptableSv_GetPartScriptedStateFirstEventOfType(ScriptableIndex_Internal, PartScriptedStateFromName, ScriptableEventType_Internal);
              Scr_AddBool(scrContext, PartScriptedStateFirstEventOfType != NULL);
            }
            else
            {
              v15 = SL_ConvertToString(ConstLowercaseString);
              v16 = SL_ConvertToString(v5);
              v17 = j_va("GetScriptablePartStateHasEvent() could not find state '%s' in part '%s'", v16, v15);
              Scr_Error(COM_ERR_4766, scrContext, v17);
            }
          }
          else
          {
            v12 = SL_ConvertToString(ConstLowercaseString);
            v13 = j_va("GetScriptablePartStateHasEvent() could not find part '%s'", v12);
            Scr_Error(COM_ERR_4765, scrContext, v13);
          }
        }
      }
      else
      {
        Scr_Error(COM_ERR_4762, scrContext, "GetScriptablePartStateHasEvent() missing stateName");
      }
    }
    else
    {
      Scr_Error(COM_ERR_4761, scrContext, "GetScriptablePartStateHasEvent() missing partName");
    }
  }
}

/*
==============
ScrCmd_LaserOff
==============
*/
void ScrCmd_LaserOff(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gclient_s *client; 
  LerpEntityState *p_lerp; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *p_eFlags; 

  Entity = GetEntity(entref);
  client = Entity->client;
  p_lerp = &Entity->s.lerp;
  p_eFlags = &client->ps.eFlags;
  if ( !client )
    p_eFlags = &p_lerp->eFlags;
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(p_eFlags, ACTIVE, 9u);
}

/*
==============
ScrCmd_LaserAltViewOn
==============
*/
void ScrCmd_LaserAltViewOn(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  char *client; 
  const char *v6; 
  ComErrorCode v7; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 10435, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = (char *)v4->client;
  if ( !client )
  {
    client = (char *)v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v7, scrContext, v6);
      client = NULL;
    }
  }
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal((GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *)(client + 28), ACTIVE, 2u);
}

/*
==============
ScrCmd_LaserAltViewOff
==============
*/
void ScrCmd_LaserAltViewOff(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  char *client; 
  const char *v6; 
  ComErrorCode v7; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 10452, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = (char *)v4->client;
  if ( !client )
  {
    client = (char *)v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v7, scrContext, v6);
      client = NULL;
    }
  }
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal((GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *)(client + 28), ACTIVE, 2u);
}

/*
==============
ScrCmd_GetScriptablePartStateField
==============
*/
void ScrCmd_GetScriptablePartStateField(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  scr_string_t ConstLowercaseString; 
  scr_string_t v5; 
  scr_string_t v6; 
  const char *v7; 
  ComErrorCode v8; 
  ScriptablePartDef *PartScriptedDefFromName; 
  const char *v10; 
  char *v11; 
  ScriptableStateDef *PartScriptedStateFromName; 
  const char *v13; 
  const char *v14; 
  Scriptable_StateType type; 
  const char *v16; 
  const char *v17; 
  const char *v18; 
  unsigned int out_stateIndex; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal != -1 )
  {
    ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
    if ( !ConstLowercaseString )
    {
      Scr_Error(COM_ERR_4767, scrContext, "GetScriptablePartStateField() missing partName");
      return;
    }
    v5 = Scr_GetConstLowercaseString(scrContext, 1u);
    if ( !v5 )
    {
      Scr_Error(COM_ERR_4768, scrContext, "GetScriptablePartStateField() missing stateName");
      return;
    }
    v6 = Scr_GetConstLowercaseString(scrContext, 2u);
    if ( !v6 )
    {
      v7 = "GetScriptablePartStateField() missing fieldName";
      v8 = COM_ERR_4769;
LABEL_29:
      Scr_Error(v8, scrContext, v7);
      return;
    }
    PartScriptedDefFromName = ScriptableSv_GetPartScriptedDefFromName(ScriptableIndex_Internal, ConstLowercaseString, 1);
    if ( !PartScriptedDefFromName )
    {
      v10 = SL_ConvertToString(ConstLowercaseString);
      v11 = j_va("GetScriptablePartStateField() could not find part '%s'", v10);
      v8 = COM_ERR_4770;
LABEL_28:
      v7 = v11;
      goto LABEL_29;
    }
    PartScriptedStateFromName = ScriptableSv_GetPartScriptedStateFromName(ScriptableIndex_Internal, PartScriptedDefFromName, v5, 1, &out_stateIndex);
    if ( !PartScriptedStateFromName )
    {
      v13 = SL_ConvertToString(ConstLowercaseString);
      v14 = SL_ConvertToString(v5);
      v11 = j_va("GetScriptablePartStateField() could not find state '%s' in part '%s'", v14, v13);
      v8 = COM_ERR_4771;
      goto LABEL_28;
    }
    if ( v6 == scr_const.type )
    {
      type = PartScriptedStateFromName->type;
      if ( type == Scriptable_StateType_Health )
      {
        Scr_AddConstString(scrContext, scr_const.health);
      }
      else if ( type == Scriptable_StateType_Usable )
      {
        Scr_AddConstString(scrContext, scr_const.useable);
      }
      else
      {
        if ( type != Scriptable_StateType_Scripted && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 28627, ASSERT_TYPE_ASSERT, "( stateDef->type == Scriptable_StateType::Scriptable_StateType_Scripted )", (const char *)&queryFormat, "stateDef->type == Scriptable_StateType::Scriptable_StateType_Scripted") )
          __debugbreak();
        Scr_AddConstString(scrContext, scr_const.scriptable);
      }
    }
    else if ( v6 == scr_const.maxhealth )
    {
      if ( PartScriptedStateFromName->type == Scriptable_StateType_Health )
        Scr_AddInt(scrContext, PartScriptedStateFromName->data.health.health);
    }
    else
    {
      if ( v6 != scr_const.radius )
      {
        v16 = SL_ConvertToString(ConstLowercaseString);
        v17 = SL_ConvertToString(v5);
        v18 = SL_ConvertToString(v6);
        v11 = j_va("GetScriptablePartStateField() unsupported field '%s' for state '%s' in part '%s'", v18, v17, v16);
        v8 = COM_ERR_4772;
        goto LABEL_28;
      }
      if ( PartScriptedStateFromName->type == Scriptable_StateType_Usable )
        Scr_AddFloat(scrContext, PartScriptedStateFromName->data.usable.useRadius);
    }
  }
}

/*
==============
GScr_SetImpactFx
==============
*/
void GScr_SetImpactFx(scrContext_t *scrContext, scr_entref_t entref)
{
  const char *String; 
  gentity_s *Entity; 
  const char *v6; 
  unsigned int clientNum; 
  const char *v8; 
  SvClient *CommonClient; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4219, scrContext, "Invalid parameters. Usage: player SetImpactFx( <tableName> ) \n");
  String = Scr_GetString(scrContext, 0);
  Entity = GetEntity(entref);
  if ( !Entity->client )
    Scr_Error(COM_ERR_4220, scrContext, "Invalid ent, ent needs to be a player.\n");
  v6 = j_va("%c %s", 66i64, String);
  clientNum = Entity->s.clientNum;
  v8 = v6;
  if ( clientNum == -1 )
  {
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v6);
  }
  else
  {
    CommonClient = SvClient::GetCommonClient(clientNum);
    CommonClient->SendServerCommand(CommonClient, SV_CMD_RELIABLE, v8);
  }
}

/*
==============
GScr_IsNightVisionOn
==============
*/
void GScr_IsNightVisionOn(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const playerState_s *p_ps; 
  const char *v6; 
  ComErrorCode v7; 
  bool IsUsingNightVision; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 10499, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  p_ps = &v4->client->ps;
  if ( !p_ps )
  {
    p_ps = &v4->agent->playerState;
    if ( !p_ps )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v7, scrContext, v6);
      p_ps = NULL;
    }
  }
  IsUsingNightVision = BG_IsUsingNightVision(p_ps);
  Scr_AddBool(scrContext, IsUsingNightVision);
}

/*
==============
ScrCmd_GetScriptablePartStateEventField
==============
*/
void ScrCmd_GetScriptablePartStateEventField(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  scr_string_t ConstLowercaseString; 
  scr_string_t v5; 
  scr_string_t v6; 
  scr_string_t v7; 
  ScriptablePartDef *PartScriptedDefFromName; 
  const char *v9; 
  const char *v10; 
  const char *v11; 
  const char *v12; 
  const char *v13; 
  Scriptable_EventType ScriptableEventType_Internal; 
  const ScriptableStateDef *v15; 
  scr_string_t v16; 
  Scriptable_EventType v17; 
  const char *v18; 
  const char *v19; 
  ScriptableEventDef *PartScriptedStateFirstEventOfType; 
  const char *v21; 
  const char *v22; 
  const char *v23; 
  const char *v24; 
  const char *v25; 
  const char *v26; 
  const char *v27; 
  const char *v28; 
  const char *v29; 
  unsigned int out_stateIndex; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal != -1 )
  {
    ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
    if ( ConstLowercaseString )
    {
      v5 = Scr_GetConstLowercaseString(scrContext, 1u);
      if ( v5 )
      {
        v6 = Scr_GetConstLowercaseString(scrContext, 2u);
        if ( v6 )
        {
          v7 = Scr_GetConstLowercaseString(scrContext, 3u);
          if ( v7 )
          {
            PartScriptedDefFromName = ScriptableSv_GetPartScriptedDefFromName(ScriptableIndex_Internal, ConstLowercaseString, 1);
            if ( PartScriptedDefFromName )
            {
              if ( ScriptableSv_GetPartScriptedStateFromName(ScriptableIndex_Internal, PartScriptedDefFromName, v5, 1, &out_stateIndex) )
              {
                ScriptableEventType_Internal = ScrCmd_GetScriptableEventType_Internal(v6);
                v17 = ScriptableEventType_Internal;
                if ( ScriptableEventType_Internal == Scriptable_EventType_Count )
                {
                  v18 = SL_ConvertToString(v16);
                  v19 = j_va("GetScriptablePartStateEventField() unsupported event '%s'", v18);
                  Scr_Error(COM_ERR_4779, scrContext, v19);
                }
                else
                {
                  PartScriptedStateFirstEventOfType = ScriptableSv_GetPartScriptedStateFirstEventOfType(ScriptableIndex_Internal, v15, ScriptableEventType_Internal);
                  if ( PartScriptedStateFirstEventOfType )
                  {
                    switch ( v17 )
                    {
                      case Scriptable_EventType_Wait:
                        if ( v7 != scr_const.duration )
                          goto $LN45_11;
                        Scr_AddInt(scrContext, (int)(float)(PartScriptedStateFirstEventOfType->data.wait.delayMax * 1000.0));
                        return;
                      case Scriptable_EventType_Script:
                      case Scriptable_EventType_ScriptDamage:
                        if ( v7 != scr_const.notifyname )
                          goto $LN45_11;
                        Scr_AddConstString(scrContext, PartScriptedStateFirstEventOfType->data.script.scrNotification);
                        return;
                      case Scriptable_EventType_Model:
                        if ( v7 != scr_const.radius )
                          goto $LN45_11;
                        if ( PartScriptedStateFirstEventOfType->data.anonymous.buffer[0] != 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 28766, ASSERT_TYPE_ASSERT, "( eventDef->data.model.dataType == SCRIPTABLE_DATA_TYPE_XMODEL )", (const char *)&queryFormat, "eventDef->data.model.dataType == SCRIPTABLE_DATA_TYPE_XMODEL") )
                          __debugbreak();
                        if ( !PartScriptedStateFirstEventOfType->data.disablePhysicsSubShape.mutableShapeHash && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 28767, ASSERT_TYPE_ASSERT, "( eventDef->data.model.data.model )", (const char *)&queryFormat, "eventDef->data.model.data.model") )
                          __debugbreak();
                        Scr_AddFloat(scrContext, *(float *)(PartScriptedStateFirstEventOfType->data.disablePhysicsSubShape.mutableShapeHash + 40));
                        return;
                      case Scriptable_EventType_Collision:
                        goto $LN45_11;
                      case Scriptable_EventType_Animation:
                        if ( v7 != scr_const.duration )
                          goto $LN45_11;
                        if ( !PartScriptedStateFirstEventOfType->data.script.notification && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 28782, ASSERT_TYPE_ASSERT, "( eventDef->data.animation.animation )", (const char *)&queryFormat, "eventDef->data.animation.animation") )
                          __debugbreak();
                        Scr_AddInt(scrContext, (int)(float)((float)((float)*((unsigned __int16 *)PartScriptedStateFirstEventOfType->data.script.notification + 59) * *((float *)PartScriptedStateFirstEventOfType->data.script.notification + 25)) * 1000.0));
                        break;
                      case Scriptable_EventType_Move:
                        if ( v7 == scr_const.duration )
                        {
                          Scr_AddInt(scrContext, (int)(float)(PartScriptedStateFirstEventOfType->data.animation.playbackRateMin * 1000.0));
                        }
                        else if ( v7 == scr_const.angles_offset )
                        {
                          Scr_AddVector(scrContext, &PartScriptedStateFirstEventOfType->data.animation.startTimeMin);
                        }
                        else if ( v7 == scr_const.origin_offset )
                        {
                          Scr_AddVector(scrContext, &PartScriptedStateFirstEventOfType->data.wait.delayMin);
                        }
                        else
                        {
$LN45_11:
                          v25 = SL_ConvertToString(ConstLowercaseString);
                          v26 = SL_ConvertToString(v5);
                          v27 = SL_ConvertToString(v6);
                          v28 = SL_ConvertToString(v7);
                          v29 = j_va("GetScriptablePartStateEventField() unsupported field '%s' for event '%s' in state '%s' in part '%s'", v28, v27, v26, v25);
                          Scr_Error(COM_ERR_4781, scrContext, v29);
                        }
                        break;
                      default:
                        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 28818, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "GetScriptablePartStateEventField() eventType unhandled in switch statement") )
                          __debugbreak();
                        return;
                    }
                  }
                  else
                  {
                    v21 = SL_ConvertToString(ConstLowercaseString);
                    v22 = SL_ConvertToString(v5);
                    v23 = SL_ConvertToString(v6);
                    v24 = j_va("GetScriptablePartStateEventField() could not find event '%s' in state '%s' in part '%s'", v23, v22, v21);
                    Scr_Error(COM_ERR_4780, scrContext, v24);
                  }
                }
              }
              else
              {
                v11 = SL_ConvertToString(ConstLowercaseString);
                v12 = SL_ConvertToString(v5);
                v13 = j_va("GetScriptablePartStateEventField() could not find state '%s' in part '%s'", v12, v11);
                Scr_Error(COM_ERR_4778, scrContext, v13);
              }
            }
            else
            {
              v9 = SL_ConvertToString(ConstLowercaseString);
              v10 = j_va("GetScriptablePartStateEventField() could not find part '%s'", v9);
              Scr_Error(COM_ERR_4777, scrContext, v10);
            }
          }
          else
          {
            Scr_Error(COM_ERR_4776, scrContext, "GetScriptablePartStateEventField() missing fieldName");
          }
        }
        else
        {
          Scr_Error(COM_ERR_4775, scrContext, "GetScriptablePartStateEventField() missing eventName");
        }
      }
      else
      {
        Scr_Error(COM_ERR_4774, scrContext, "GetScriptablePartStateEventField() missing stateName");
      }
    }
    else
    {
      Scr_Error(COM_ERR_4773, scrContext, "GetScriptablePartStateEventField() missing partName");
    }
  }
}

/*
==============
ScrCmd_NightVisionViewOff
==============
*/
void ScrCmd_NightVisionViewOff(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const playerState_s *p_ps; 
  const char *v6; 
  ComErrorCode v7; 
  unsigned int clientNum; 
  const char *v9; 
  const char *v10; 
  SvClient *CommonClient; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 10526, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  p_ps = &v4->client->ps;
  if ( !p_ps )
  {
    p_ps = &v4->agent->playerState;
    if ( !p_ps )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v7, scrContext, v6);
      p_ps = NULL;
    }
  }
  if ( Scr_GetNumParam(scrContext) == 1 && Scr_GetInt(scrContext, 0) && BG_IsUsingNightVision(p_ps) )
  {
    if ( p_ps->weapCommon.fWeaponPosFrac > 0.0 )
      Com_PrintWarning(16, "Forcing NIGHT VISION TRANSITIONS while the player is in ADS will cause view model weapon pops!!!");
    GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::ClearFlagInternal(&p_ps->weapCommon.weapFlags, ACTIVE, 7u);
  }
  else
  {
    clientNum = p_ps->clientNum;
    v9 = j_va("%c %d", 69i64, 0i64);
    v10 = v9;
    if ( clientNum == -1 )
    {
      SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v9);
    }
    else
    {
      CommonClient = SvClient::GetCommonClient(clientNum);
      CommonClient->SendServerCommand(CommonClient, SV_CMD_RELIABLE, v10);
    }
  }
}

/*
==============
ScrCmd_NightVisionViewOn
==============
*/
void ScrCmd_NightVisionViewOn(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const playerState_s *p_ps; 
  const char *v6; 
  ComErrorCode v7; 
  unsigned int clientNum; 
  const char *v9; 
  const char *v10; 
  SvClient *CommonClient; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 10566, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  p_ps = &v4->client->ps;
  if ( !p_ps )
  {
    p_ps = &v4->agent->playerState;
    if ( !p_ps )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v7, scrContext, v6);
      p_ps = NULL;
    }
  }
  if ( Scr_GetNumParam(scrContext) == 1 && Scr_GetInt(scrContext, 0) && !BG_IsUsingNightVision(p_ps) )
  {
    if ( p_ps->weapCommon.fWeaponPosFrac > 0.0 )
      Com_PrintWarning(16, "Forcing NIGHT VISION TRANSITIONS while the player is in ADS will cause view model weapon pops!!!");
    GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::SetFlagInternal(&p_ps->weapCommon.weapFlags, ACTIVE, 7u);
  }
  else
  {
    clientNum = p_ps->clientNum;
    v9 = j_va("%c %d", 69i64, 1i64);
    v10 = v9;
    if ( clientNum == -1 )
    {
      SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v9);
    }
    else
    {
      CommonClient = SvClient::GetCommonClient(clientNum);
      CommonClient->SendServerCommand(CommonClient, SV_CMD_RELIABLE, v10);
    }
  }
}

/*
==============
ScrCmd_ActivateNightVisionBlind
==============
*/
void ScrCmd_ActivateNightVisionBlind(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const playerState_s *p_ps; 
  const char *v6; 
  unsigned int clientNum; 
  const char *v8; 
  SvClient *CommonClient; 
  const char *v10; 
  ComErrorCode v11; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v10 = "not an entity";
    v11 = COM_ERR_3682;
    goto LABEL_13;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 10605, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  p_ps = &v4->client->ps;
  if ( !p_ps )
  {
    p_ps = &v4->agent->playerState;
    if ( !p_ps )
    {
      v10 = j_va("entity %i is not a player or agent", entnum);
      v11 = COM_ERR_3679;
LABEL_13:
      Scr_ObjectError(v11, scrContext, v10);
      Scr_Error(COM_ERR_6123, scrContext, "ActivateNightVisionBlind: This method must be called on players.\n");
      return;
    }
  }
  if ( !BG_IsAgent(p_ps) )
  {
    v6 = j_va("%c", 33i64);
    clientNum = p_ps->clientNum;
    v8 = v6;
    if ( clientNum == -1 )
    {
      SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v6);
    }
    else
    {
      CommonClient = SvClient::GetCommonClient(clientNum);
      CommonClient->SendServerCommand(CommonClient, SV_CMD_RELIABLE, v8);
    }
  }
}

/*
==============
ScrCmd_SetNightVisionBlindWeight
==============
*/
void ScrCmd_SetNightVisionBlindWeight(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const playerState_s *p_ps; 
  ComErrorCode v6; 
  const char *v7; 
  double Float; 
  const char *v9; 
  unsigned int clientNum; 
  const char *v11; 
  SvClient *CommonClient; 
  const char *v13; 
  ComErrorCode v14; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v13 = "not an entity";
    v14 = COM_ERR_3682;
    goto LABEL_16;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 10636, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  p_ps = &v4->client->ps;
  if ( !p_ps )
  {
    p_ps = &v4->agent->playerState;
    if ( !p_ps )
    {
      v13 = j_va("entity %i is not a player or agent", entnum);
      v14 = COM_ERR_3679;
LABEL_16:
      Scr_ObjectError(v14, scrContext, v13);
      v6 = COM_ERR_6148;
      goto LABEL_17;
    }
  }
  if ( BG_IsAgent(p_ps) )
  {
    v6 = COM_ERR_6291;
LABEL_17:
    v7 = "SetNightVisionBlindWeight: This method must be called on players.\n";
    goto LABEL_18;
  }
  if ( Scr_GetNumParam(scrContext) != 1 )
  {
    v7 = "usage: level.player SetNightVisionBlindWeight( <weight> )\n";
    v6 = COM_ERR_6149;
LABEL_18:
    Scr_Error(v6, scrContext, v7);
    return;
  }
  Float = Scr_GetFloat(scrContext, 0);
  v9 = j_va("%c %f", 36i64, *(float *)&Float);
  clientNum = p_ps->clientNum;
  v11 = v9;
  if ( clientNum == -1 )
  {
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v9);
  }
  else
  {
    CommonClient = SvClient::GetCommonClient(clientNum);
    CommonClient->SendServerCommand(CommonClient, SV_CMD_RELIABLE, v11);
  }
}

/*
==============
ScrCmd_SetScriptablePartState
==============
*/
void ScrCmd_SetScriptablePartState(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  scr_string_t ConstLowercaseString; 
  scr_string_t v5; 
  scr_string_t v6; 
  const char *v7; 
  ComErrorCode v8; 
  const char *v9; 
  const char *v10; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal != -1 )
  {
    ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
    if ( !ConstLowercaseString )
    {
      Scr_Error(COM_ERR_4782, scrContext, "SetScriptablePartState() missing partName");
      return;
    }
    v5 = Scr_GetConstLowercaseString(scrContext, 1u);
    v6 = v5;
    if ( !v5 )
    {
      v7 = "SetScriptablePartState() missing stateName";
      v8 = COM_ERR_4783;
LABEL_10:
      Scr_Error(v8, scrContext, v7);
      return;
    }
    if ( !ScriptableSv_SetPartScriptedState(ScriptableIndex_Internal, ConstLowercaseString, v5) && (Scr_GetNumParam(scrContext) < 3 || Scr_GetInt(scrContext, 2u)) )
    {
      v9 = SL_ConvertToString(v6);
      v10 = SL_ConvertToString(ConstLowercaseString);
      v7 = j_va("SetScriptablePartState() could not set part '%s' to state '%s'", v10, v9);
      v8 = COM_ERR_4784;
      goto LABEL_10;
    }
  }
}

/*
==============
ScrCmd_ThermalVisionOn
==============
*/
void ScrCmd_ThermalVisionOn(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  char *client; 
  const char *v6; 
  ComErrorCode v7; 
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *v8; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 10677, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = (char *)v4->client;
  if ( !client )
  {
    client = (char *)v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v7, scrContext, v6);
      client = NULL;
    }
  }
  v8 = (GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *)(client + 28);
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal((GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *)(client + 28), ACTIVE, 3u);
  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    if ( Scr_GetInt(scrContext, 0) )
      GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal(v8, GameModeFlagValues::ms_mpValue, 0x28u);
  }
}

/*
==============
ScrCmd_SetScriptablePartZeroState_Hack
==============
*/
void ScrCmd_SetScriptablePartZeroState_Hack(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  scr_string_t ConstLowercaseString; 
  const ScriptableDef *def; 
  const char *v6; 
  ComErrorCode v7; 
  ScriptablePartDef *parts; 
  const char *v9; 
  ScriptableEventParams outParams; 
  unsigned int newState; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal != -1 )
  {
    ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
    if ( !ConstLowercaseString )
    {
      Scr_Error(COM_ERR_4785, scrContext, "SetScriptablePartZeroState_Hack() missing stateName");
      return;
    }
    def = ScriptableSv_GetInstanceCommonContext(ScriptableIndex_Internal)->def;
    if ( def )
    {
      parts = def->parts;
      if ( parts )
      {
        if ( ScriptableSv_GetPartScriptedStateFromName(ScriptableIndex_Internal, parts, ConstLowercaseString, 1, &newState) )
        {
          ScriptableSv_InitEventParams(&outParams, ScriptableIndex_Internal, parts);
          ScriptableBg_ChangePartState(&outParams, newState, 1);
          if ( ScriptableSv_SetPartScriptedState(ScriptableIndex_Internal, (const scr_string_t)parts->scrName, ConstLowercaseString) )
            return;
          v9 = SL_ConvertToString(ConstLowercaseString);
          v6 = j_va("SetScriptablePartZeroState_Hack() could not set part 0 to state '%s' for scriptable instance %d", v9, ScriptableIndex_Internal);
          v7 = COM_ERR_4790;
        }
        else
        {
          v6 = j_va("SetScriptablePartZeroState_Hack() could not get state def for part 0 of scriptable instance %d", ScriptableIndex_Internal);
          v7 = COM_ERR_4789;
        }
      }
      else
      {
        v6 = j_va("SetScriptablePartZeroState_Hack() could not get part def 0 for scriptable instance %d", ScriptableIndex_Internal);
        v7 = COM_ERR_4788;
      }
    }
    else
    {
      v6 = j_va("SetScriptablePartZeroState_Hack() could not get def for scriptable instance %d", ScriptableIndex_Internal);
      v7 = COM_ERR_4787;
    }
    Scr_Error(v7, scrContext, v6);
  }
}

/*
==============
ScrCmd_ThermalVisionOnShadowOff
==============
*/
void ScrCmd_ThermalVisionOnShadowOff(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  char *client; 
  const char *v6; 
  ComErrorCode v7; 
  gentity_s *v8; 
  char *agent; 
  const char *v10; 
  ComErrorCode v11; 
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *v12; 
  EntityClass entclass; 

  entclass = entref.entclass;
  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 10697, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = (char *)v4->client;
  if ( !client )
  {
    client = (char *)v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v7, scrContext, v6);
      client = NULL;
    }
  }
  if ( entclass )
  {
    v10 = "not an entity";
    v11 = COM_ERR_3682;
    goto LABEL_18;
  }
  if ( entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 10677, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v8 = &g_entities[entnum];
  agent = (char *)v8->client;
  if ( !agent )
  {
    agent = (char *)v8->agent;
    if ( !agent )
    {
      v10 = j_va("entity %i is not a player or agent", entnum);
      v11 = COM_ERR_3679;
LABEL_18:
      Scr_ObjectError(v11, scrContext, v10);
      agent = NULL;
    }
  }
  v12 = (GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *)(agent + 28);
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal((GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *)(agent + 28), ACTIVE, 3u);
  if ( Scr_GetNumParam(scrContext) == 1 && Scr_GetInt(scrContext, 0) )
    GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal(v12, GameModeFlagValues::ms_mpValue, 0x28u);
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal((GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *)(client + 28), ACTIVE, 0xCu);
}

/*
==============
ScrCmd_GetScriptablePartState
==============
*/
void ScrCmd_GetScriptablePartState(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  scr_string_t ConstLowercaseString; 
  bool v5; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  const char *v9; 
  scr_string_t out_stateName; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal != -1 )
  {
    ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
    if ( ConstLowercaseString )
    {
      v5 = 0;
      if ( Scr_GetNumParam(scrContext) >= 2 )
        v5 = Scr_GetInt(scrContext, 1u) != 0;
      if ( ScriptableSv_GetPartScriptedState(ScriptableIndex_Internal, ConstLowercaseString, &out_stateName) )
      {
        if ( out_stateName )
        {
          Scr_AddConstString(scrContext, out_stateName);
        }
        else if ( !v5 )
        {
          v8 = SL_ConvertToString(ConstLowercaseString);
          v9 = j_va("GetScriptablePartState() got part %s, but it had no Script Id set - check the scriptable", v8);
          Scr_Error(COM_ERR_4793, scrContext, v9);
        }
      }
      else if ( !v5 )
      {
        v6 = SL_ConvertToString(ConstLowercaseString);
        v7 = j_va("GetScriptablePartState() could not get the state name for part %s", v6);
        Scr_Error(COM_ERR_4792, scrContext, v7);
      }
    }
    else
    {
      Scr_Error(COM_ERR_4791, scrContext, "GetScriptablePartState() missing partName");
    }
  }
}

/*
==============
ScrCmd_ThermalVisionOff
==============
*/
void ScrCmd_ThermalVisionOff(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  char *client; 
  const char *v6; 
  ComErrorCode v7; 
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *v8; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 10715, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = (char *)v4->client;
  if ( !client )
  {
    client = (char *)v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v7, scrContext, v6);
      client = NULL;
    }
  }
  v8 = (GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *)(client + 28);
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal((GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *)(client + 28), ACTIVE, 3u);
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal(v8, GameModeFlagValues::ms_mpValue, 0x28u);
}

/*
==============
ScrCmd_ThermalDrawEnable
==============
*/
void ScrCmd_ThermalDrawEnable(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(&Entity->s.lerp.eFlags, ACTIVE, 0xEu);
}

/*
==============
ScrCmd_GetScriptablePartCount
==============
*/
void ScrCmd_GetScriptablePartCount(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  ScriptableInstanceContext *InstanceCommonContext; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal != -1 )
  {
    InstanceCommonContext = ScriptableSv_GetInstanceCommonContext(ScriptableIndex_Internal);
    if ( InstanceCommonContext->def )
      Scr_AddInt(scrContext, InstanceCommonContext->def->partCount);
  }
}

/*
==============
ScrCmd_ThermalDrawDisable
==============
*/
void ScrCmd_ThermalDrawDisable(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(&Entity->s.lerp.eFlags, ACTIVE, 0xEu);
}

/*
==============
ScrCmd_GetScriptablePartNameAtIndex
==============
*/
void ScrCmd_GetScriptablePartNameAtIndex(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  __int64 Int; 
  const ScriptableDef *def; 
  scr_string_t scrName; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal != -1 )
  {
    Int = (unsigned int)Scr_GetInt(scrContext, 0);
    def = ScriptableSv_GetInstanceCommonContext(ScriptableIndex_Internal)->def;
    if ( def )
    {
      if ( (unsigned int)Int < def->partCount )
      {
        scrName = def->parts[Int].scrName;
        if ( scrName )
          Scr_AddConstString(scrContext, scrName);
      }
    }
  }
}

/*
==============
ScrCmd_ScriptMoverPlane
==============
*/
void ScrCmd_ScriptMoverPlane(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( Entity->s.eType == ET_SCRIPTMOVER )
    Entity->s.lerp.u.anonymous.data[2] |= 0x20u;
  else
    Scr_Error(COM_ERR_4221, scrContext, "ScriptMoverOutline Must be called on a script mover");
}

/*
==============
ScrCmd_ScriptMoverOutline
==============
*/
void ScrCmd_ScriptMoverOutline(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( Entity->s.eType == ET_SCRIPTMOVER )
    Entity->s.lerp.u.anonymous.data[2] |= 8u;
  else
    Scr_Error(COM_ERR_4222, scrContext, "ScriptMoverOutline Must be called on a script mover");
}

/*
==============
ScrCmd_ScriptMoverClearOutline
==============
*/
void ScrCmd_ScriptMoverClearOutline(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( Entity->s.eType == ET_SCRIPTMOVER )
    Entity->s.lerp.u.anonymous.data[2] &= ~8u;
  else
    Scr_Error(COM_ERR_4223, scrContext, "ScriptMoverClearOutline Must be called on a script mover");
}

/*
==============
ScrCmd_ScriptMoverDistanceFade
==============
*/
void ScrCmd_ScriptMoverDistanceFade(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( Entity->s.eType == ET_SCRIPTMOVER )
  {
    if ( GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&Entity->s.lerp.eFlags, ACTIVE, 1u) )
      Scr_Error(COM_ERR_5919, scrContext, "ScriptMoverDistanceFade() cannot be called on scriptmovers that are brushmodels");
    else
      v4->s.lerp.u.anonymous.data[2] |= 0x80u;
  }
  else
  {
    Scr_Error(COM_ERR_5918, scrContext, "ScriptMoverDistanceFade() must be called on a script mover");
  }
}

/*
==============
ScrCmd_EnableScriptablePartPlayerUse
==============
*/
void ScrCmd_EnableScriptablePartPlayerUse(scrContext_t *scrContext, scr_entref_t entref)
{
  GScr_SetScriptablePartUsability(scrContext, entref, 1);
}

/*
==============
ScrCmd_ScriptMoverClearDistanceFade
==============
*/
void ScrCmd_ScriptMoverClearDistanceFade(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( Entity->s.eType == ET_SCRIPTMOVER )
    Entity->s.lerp.u.anonymous.data[2] &= ~0x80u;
  else
    Scr_Error(COM_ERR_5749, scrContext, "ScriptMoverClearDistanceFade() must be called on a script mover");
}

/*
==============
ScrCmd_DisableScriptablePartPlayerUse
==============
*/
void ScrCmd_DisableScriptablePartPlayerUse(scrContext_t *scrContext, scr_entref_t entref)
{
  GScr_SetScriptablePartUsability(scrContext, entref, 0);
}

/*
==============
ScrCmd_ScriptMoverThermal
==============
*/
void ScrCmd_ScriptMoverThermal(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( Entity->s.eType == ET_SCRIPTMOVER )
    Entity->s.lerp.u.anonymous.data[2] |= 0x10u;
  else
    Scr_Error(COM_ERR_4224, scrContext, "ScriptMoverThermal Must be called on a script mover");
}

/*
==============
ScrCmd_ScriptMoverClearThermal
==============
*/
void ScrCmd_ScriptMoverClearThermal(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( Entity->s.eType == ET_SCRIPTMOVER )
    Entity->s.lerp.u.anonymous.data[2] &= ~0x10u;
  else
    Scr_Error(COM_ERR_4225, scrContext, "ScriptMoverClearThermal Must be called on a script mover");
}

/*
==============
ScrCmd_MissileThermal
==============
*/
void ScrCmd_MissileThermal(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( Entity->s.eType == ET_MISSILE )
    Entity->s.lerp.u.anonymous.data[4] |= 0x40u;
  else
    Scr_Error(COM_ERR_4226, scrContext, "MissileThermal Must be called on a missile");
}

/*
==============
ScrCmd_MissileHideTrail
==============
*/
void ScrCmd_MissileHideTrail(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( Entity->s.eType == ET_MISSILE )
    Entity->s.lerp.u.anonymous.data[4] |= 0x200u;
  else
    Scr_Error(COM_ERR_4227, scrContext, "MissileHideTrail Must be called on a missile");
}

/*
==============
ScrCmd_MissileOutline
==============
*/
void ScrCmd_MissileOutline(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( Entity->s.eType == ET_MISSILE )
    Entity->s.lerp.u.anonymous.data[4] |= 0x20u;
  else
    Scr_Error(COM_ERR_4228, scrContext, "MissileOutline Must be called on a missile");
}

/*
==============
ScrCmd_EnableScriptablePlayerUse
==============
*/
void ScrCmd_EnableScriptablePlayerUse(scrContext_t *scrContext, scr_entref_t entref)
{
  GScr_SetScriptableUsability(scrContext, entref, 1);
}

/*
==============
ScrCmd_DisableScriptablePlayerUse
==============
*/
void ScrCmd_DisableScriptablePlayerUse(scrContext_t *scrContext, scr_entref_t entref)
{
  GScr_SetScriptableUsability(scrContext, entref, 0);
}

/*
==============
ScrCmd_HudOutlineEnableForClient
==============
*/
void ScrCmd_HudOutlineEnableForClient(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v5; 
  gentity_s *v6; 
  scr_string_t ConstString; 
  const char *v8; 
  const char *v9; 
  scrContext_t *v10; 
  ComErrorCode v11; 
  unsigned int number; 
  int v13; 
  unsigned int outIndex[3]; 
  ClientBits v15; 
  ClientBits v16; 

  v13 = 0;
  if ( Scr_GetNumParam(scrContext) > 2 )
  {
    Scr_Error(COM_ERR_4229, scrContext, "usage: HudOutlineEnableForClient( <client>, <hudOutline> );");
    return;
  }
  Entity = GetEntity(entref);
  v5 = GScr_GetEntity(0);
  v6 = v5;
  if ( !v5 || !v5->client )
  {
    Scr_ParamError(COM_ERR_4230, scrContext, 0, "Invalid client entity.");
    return;
  }
  if ( (unsigned int)v5->s.number >= level.maxclients && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 11059, ASSERT_TYPE_ASSERT, "(unsigned)( clientEnt->s.number ) < (unsigned)( level.maxclients )", "clientEnt->s.number doesn't index level.maxclients\n\t%i not in [0, %i)", v5->s.number, level.maxclients) )
    __debugbreak();
  ConstString = Scr_GetConstString(scrContext, 1u);
  if ( !ConstString && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 11063, ASSERT_TYPE_ASSERT, "(hudOutlineScrStr != ( static_cast< scr_string_t >( 0 ) ))", (const char *)&queryFormat, "hudOutlineScrStr != NULL_SCR_STRING") )
    __debugbreak();
  v8 = SL_ConvertToString(ConstString);
  if ( !v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 11066, ASSERT_TYPE_ASSERT, "(hudOutlineName)", (const char *)&queryFormat, "hudOutlineName") )
    __debugbreak();
  outIndex[0] = 0;
  if ( !BG_HudOutline_GetDefIndex(v8, outIndex) )
  {
    v9 = j_va("Hud Outline name not found (%s)! Make sure you add your Hud Outline asset to your level csv file!\n", v8);
    v10 = scrContext;
    v11 = COM_ERR_5931;
LABEL_16:
    Scr_Error(v11, v10, v9);
    return;
  }
  memset(&v16, 0, sizeof(v16));
  v13 ^= ((unsigned __int8)v13 ^ LOBYTE(outIndex[0])) & 0x3F;
  number = v6->s.number;
  if ( number >= 0xE0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 263, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", number, 224) )
    __debugbreak();
  v16.array[(unsigned __int64)number >> 5] |= 0x80000000 >> (number & 0x1F);
  v15 = v16;
  if ( !G_HudOutline_EnableForClientMask(Entity, &v15, (const outline_client_data_t *)&v13) )
  {
    v9 = "HudOutlineEnableForClient() could not be applied because there are currently too many hud outline settings. Can we reduce color and depth test variations?";
    v10 = scrContext;
    v11 = COM_ERR_156;
    goto LABEL_16;
  }
}

/*
==============
ScrCmd_SetScriptableUseLargerBounds
==============
*/
void ScrCmd_SetScriptableUseLargerBounds(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  __int64 v4; 
  ScriptableInstanceServerContext *v5; 
  __int64 v6; 
  int v7; 
  __int64 v8; 
  unsigned int serverInstanceCount; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  v4 = ScriptableIndex_Internal;
  if ( ScriptableIndex_Internal != -1 )
  {
    ScriptableCommon_AssertCountsInitialized();
    if ( (unsigned int)v4 >= g_scriptableWorldCounts.serverInstanceCount )
    {
      ScriptableCommon_AssertCountsInitialized();
      serverInstanceCount = g_scriptableWorldCounts.serverInstanceCount;
      v7 = v4;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 29213, ASSERT_TYPE_ASSERT, "(unsigned)( scriptableIndex ) < (unsigned)( ScriptableCommon_GetServerInstanceCount() )", "scriptableIndex doesn't index ScriptableCommon_GetServerInstanceCount()\n\t%i not in [0, %i)", v7, serverInstanceCount) )
        __debugbreak();
    }
    if ( ScriptableSv_HasCollisionSupport(v4) )
    {
      if ( !g_scriptableSv_instanceContexts && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\scriptable\\scriptable_server_utility.h", 90, ASSERT_TYPE_ASSERT, "( g_scriptableSv_instanceContexts )", (const char *)&queryFormat, "g_scriptableSv_instanceContexts") )
        __debugbreak();
      ScriptableCommon_AssertCountsInitialized();
      if ( (unsigned int)v4 >= g_scriptableWorldCounts.serverInstanceCount )
      {
        ScriptableCommon_AssertCountsInitialized();
        LODWORD(v8) = g_scriptableWorldCounts.serverInstanceCount;
        LODWORD(v6) = v4;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\scriptable\\scriptable_server_utility.h", 91, ASSERT_TYPE_ASSERT, "(unsigned)( scriptableIndex ) < (unsigned)( ScriptableCommon_GetServerInstanceCount() )", "scriptableIndex doesn't index ScriptableCommon_GetServerInstanceCount()\n\t%i not in [0, %i)", v6, v8) )
          __debugbreak();
      }
      v5 = &g_scriptableSv_instanceContexts[v4];
      v5->collisionContext.useLargerBounds = Scr_GetInt(scrContext, 0) != 0;
    }
  }
}

/*
==============
ScrCmd_GetScriptableIsLoot
==============
*/
void ScrCmd_GetScriptableIsLoot(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  ScriptableInstanceContext *InstanceCommonContext; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal == -1 || (InstanceCommonContext = ScriptableSv_GetInstanceCommonContext(ScriptableIndex_Internal), !InstanceCommonContext->def) )
    Scr_AddBool(scrContext, 0);
  else
    Scr_AddBool(scrContext, ((unsigned int)InstanceCommonContext->def->flags >> 17) & 1);
}

/*
==============
ScrCmd_ScriptableCanBePinged
==============
*/
void ScrCmd_ScriptableCanBePinged(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  unsigned int v4; 
  ScriptableInstanceContext *InstanceCommonContext; 
  int flags; 
  bool v7; 
  char v8; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  v4 = ScriptableIndex_Internal;
  if ( ScriptableIndex_Internal != -1 && (InstanceCommonContext = ScriptableSv_GetInstanceCommonContext(ScriptableIndex_Internal), InstanceCommonContext->def) && ((flags = InstanceCommonContext->def->flags, v7 = (flags & 0x20000) != 0, (flags & 0x180000) == 0) || G_Door_IsClosed(v4) ? (v8 = 0) : (v8 = 1), v7 || v8) )
    Scr_AddBool(scrContext, 1);
  else
    Scr_AddBool(scrContext, 0);
}

/*
==============
ScrCmd_GetScriptableIsReserved
==============
*/
void ScrCmd_GetScriptableIsReserved(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  ScriptableCommon_AssertCountsInitialized();
  Scr_AddBool(scrContext, ScriptableIndex_Internal < g_scriptableWorldCounts.runtimeInstanceCount);
}

/*
==============
ScrCmd_HudOutlineDisableForClient
==============
*/
void ScrCmd_HudOutlineDisableForClient(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v5; 
  gentity_s *v6; 
  unsigned int number; 
  ClientBits v8; 
  ClientBits v9; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    Entity = GetEntity(entref);
    v5 = GScr_GetEntity(0);
    v6 = v5;
    if ( v5 && v5->client )
    {
      if ( (unsigned int)v5->s.number >= level.maxclients && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 11121, ASSERT_TYPE_ASSERT, "(unsigned)( clientEnt->s.number ) < (unsigned)( level.maxclients )", "clientEnt->s.number doesn't index level.maxclients\n\t%i not in [0, %i)", v5->s.number, level.maxclients) )
        __debugbreak();
      number = v6->s.number;
      memset(&v9, 0, sizeof(v9));
      if ( number >= 0xE0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 263, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", number, 224) )
        __debugbreak();
      v9.array[(unsigned __int64)number >> 5] |= 0x80000000 >> (number & 0x1F);
      v8 = v9;
      if ( !G_HudOutline_DisableForClientMask(Entity, &v8) )
        Scr_Error(COM_ERR_6292, scrContext, "HudOutlineDisableForClient() could not be applied because there are currently too many hud outline settings. Can we reduce color and depth test variations?");
    }
    else
    {
      Scr_ParamError(COM_ERR_4233, scrContext, 0, "Invalid client entity.");
    }
  }
  else
  {
    Scr_Error(COM_ERR_4232, scrContext, "usage: HudOutlineDisableForClient( <client> );");
  }
}

/*
==============
ScrCmd_GetScriptableIsLinked
==============
*/
void ScrCmd_GetScriptableIsLinked(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  ScriptableInstanceContext *InstanceCommonContext; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal == -1 )
  {
    Scr_AddBool(scrContext, 0);
  }
  else
  {
    InstanceCommonContext = ScriptableSv_GetInstanceCommonContext(ScriptableIndex_Internal);
    Scr_AddBool(scrContext, InstanceCommonContext->linkedObjectType != SCRIPTABLE_LINK_NONE);
  }
}

/*
==============
ScrCmd_GetScriptableIsUsableOnAnyPart
==============
*/
void ScrCmd_GetScriptableIsUsableOnAnyPart(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  int v4; 
  const ScriptableDef *def; 
  int v6; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal == -1 )
  {
    v4 = 0;
  }
  else
  {
    v4 = 0;
    def = ScriptableSv_GetInstanceCommonContext(ScriptableIndex_Internal)->def;
    if ( def )
    {
      v6 = 0;
      if ( def->numParts )
      {
        while ( !ScriptableCommon_GetPartHasUsableState(&def->parts[v6]) )
        {
          if ( ++v6 >= def->numParts )
            goto LABEL_9;
        }
        v4 = 1;
      }
    }
  }
LABEL_9:
  Scr_AddBool(scrContext, v4);
}

/*
==============
GScr_GetScriptableReservedReamining
==============
*/
void GScr_GetScriptableReservedReamining(scrContext_t *scrContext)
{
  int FreeReservedScriptableCount; 

  FreeReservedScriptableCount = ScriptableSv_GetFreeReservedScriptableCount();
  Scr_AddInt(scrContext, FreeReservedScriptableCount);
}

/*
==============
GScr_CalcScriptablePayloadGravityArc
==============
*/
void GScr_CalcScriptablePayloadGravityArc(scrContext_t *scrContext)
{
  unsigned __int16 v2; 
  vec3_t end; 
  vec3_t vectorValue; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &end);
  v2 = ScriptableBg_GravityArcEncodePayload(&vectorValue, &end);
  Scr_AddInt(scrContext, v2);
}

/*
==============
GScr_StopSliding
==============
*/
void GScr_StopSliding(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  playerState_s *EntityPlayerState; 
  int time; 
  GHandler *Handler; 
  GWeaponMap *Instance; 

  entnum = entref.entnum;
  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 29427, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClientOrAgent(Entity) )
  {
    targetname = Entity->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(Entity->classname);
    v8 = j_va("StopSliding is only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, Entity->r.currentOrigin.v[0], Entity->r.currentOrigin.v[1], Entity->r.currentOrigin.v[2], v7, v6);
    Scr_Error(COM_ERR_4797, scrContext, v8);
  }
  EntityPlayerState = G_GetEntityPlayerState(Entity);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 29433, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_4798, scrContext, "USAGE: <player> StopSliding()\n");
  time = level.time;
  Handler = GHandler::getHandler();
  Instance = GWeaponMap::GetInstance();
  Slide_Interrupt(EntityPlayerState, Instance, Handler, time);
}

/*
==============
ScrCmd_SetEntitySoundContext
==============
*/
void ScrCmd_SetEntitySoundContext(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  unsigned int NumParam; 
  const char *String; 
  const char *v6; 
  unsigned int v7; 
  unsigned int v8; 
  double Float; 
  const char *v10; 

  entnum = entref.entnum;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam - 2 > 1 )
  {
    Scr_Error(COM_ERR_4799, scrContext, "SetEntitySoundContext: Incorrect number of parameters\n");
  }
  else
  {
    String = Scr_GetString(scrContext, 0);
    v6 = Scr_GetString(scrContext, 1u);
    v7 = SND_HashName(String);
    SND_DevhostString(String);
    if ( *v6 )
    {
      v8 = SND_HashName(v6);
      SND_DevhostString(v6);
    }
    else
    {
      v8 = 0;
    }
    if ( NumParam == 3 )
    {
      Float = Scr_GetFloat(scrContext, 2u);
      v10 = j_va("%c %c %d %x %x %g", 105i64, 97i64, entnum, v7, v8, *(float *)&Float);
    }
    else
    {
      v10 = j_va("%c %c %d %x %x", 105i64, 97i64, entnum, v7, v8);
    }
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v10);
  }
}

/*
==============
ScrCmd_HudOutlineEnableForClients
==============
*/
void ScrCmd_HudOutlineEnableForClients(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t ConstString; 
  const char *v6; 
  const char *v7; 
  ComErrorCode v8; 
  int v9; 
  unsigned int outIndex[3]; 
  ClientBits v11; 
  ClientBits outClientMask; 

  v9 = 0;
  if ( Scr_GetNumParam(scrContext) > 2 )
  {
    Scr_Error(COM_ERR_4239, scrContext, "usage: HudOutlineEnableForClients( <client array>, <hudOutline> );");
    return;
  }
  Entity = GetEntity(entref);
  ScrCmd_BuildHudOutlineClientMaskFromEntArray(scrContext, 0, &outClientMask);
  ConstString = Scr_GetConstString(scrContext, 1u);
  if ( !ConstString && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 11220, ASSERT_TYPE_ASSERT, "(hudOutlineScrStr != ( static_cast< scr_string_t >( 0 ) ))", (const char *)&queryFormat, "hudOutlineScrStr != NULL_SCR_STRING") )
    __debugbreak();
  v6 = SL_ConvertToString(ConstString);
  if ( !v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 11223, ASSERT_TYPE_ASSERT, "(hudOutlineName)", (const char *)&queryFormat, "hudOutlineName") )
    __debugbreak();
  outIndex[0] = 0;
  if ( BG_HudOutline_GetDefIndex(v6, outIndex) )
  {
    v9 ^= ((unsigned __int8)v9 ^ LOBYTE(outIndex[0])) & 0x3F;
    v11 = outClientMask;
    if ( G_HudOutline_EnableForClientMask(Entity, &v11, (const outline_client_data_t *)&v9) )
      return;
    v7 = "HudOutlineEnableForClients() could not be applied because there are currently too many hud outline settings. Can we reduce color and depth test variations?";
    v8 = COM_ERR_6293;
  }
  else
  {
    v7 = j_va("Hud Outline name not found (%s)! Make sure you add your Hud Outline asset to your level csv file!\n", v6);
    v8 = COM_ERR_6087;
  }
  Scr_Error(v8, scrContext, v7);
}

/*
==============
PlayerCmd_SetClientTriggerAudioZone
==============
*/
void PlayerCmd_SetClientTriggerAudioZone(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  int number; 
  const char *v7; 
  const char *v8; 
  ComErrorCode v9; 
  unsigned int NumParam; 
  const char *String; 
  const char *v12; 
  const char *v13; 
  double Float; 
  int outControllingClientNum; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3678, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 29521, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client && !v4->agent )
    {
      v5 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3677, scrContext, v5);
    }
  }
  number = v4->s.number;
  outControllingClientNum = number;
  if ( SV_IsAgent(number) && !SV_GetAgentControlledByPlayerNum(outControllingClientNum, &outControllingClientNum) )
  {
    v7 = j_va("entity %i is not a player or player-controlled agent", entnum);
    Scr_ObjectError(COM_ERR_4800, scrContext, v7);
    return;
  }
  if ( outControllingClientNum < level.maxclients )
  {
    NumParam = Scr_GetNumParam(scrContext);
    if ( NumParam - 1 <= 1 )
    {
      if ( NumParam == 1 )
      {
        String = Scr_GetString(scrContext, 0);
        v12 = j_va("%c %c %s 0", 109i64, 98i64, String);
      }
      else
      {
        if ( NumParam != 2 )
          return;
        v13 = Scr_GetString(scrContext, 0);
        Float = Scr_GetFloat(scrContext, 1u);
        v12 = j_va("%c %c %s 0 %g", 109i64, 98i64, v13, *(float *)&Float);
      }
      SV_Game_SendServerCommand(outControllingClientNum, SV_CMD_RELIABLE, v12);
      return;
    }
    v8 = "Incorrect number of parameters\n";
    v9 = COM_ERR_4801;
  }
  else
  {
    v8 = j_va("Invalid entity index %d before SV_Game_SendServerCommand\n", (unsigned int)outControllingClientNum);
    v9 = COM_ERR_6411;
  }
  Scr_Error(v9, scrContext, v8);
}

/*
==============
ScrCmd_HudOutlineDisableForClients
==============
*/
void ScrCmd_HudOutlineDisableForClients(scrContext_t *scrContext, scr_entref_t entref)
{
  const char *v4; 
  ComErrorCode v5; 
  gentity_s *Entity; 
  ClientBits v7; 
  ClientBits outClientMask; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    Entity = GetEntity(entref);
    ScrCmd_BuildHudOutlineClientMaskFromEntArray(scrContext, 0, &outClientMask);
    v7 = outClientMask;
    if ( G_HudOutline_DisableForClientMask(Entity, &v7) )
      return;
    v4 = "HudOutlineDisableForClients() could not be applied because there are currently too many hud outline settings. Can we reduce color and depth test variations?";
    v5 = COM_ERR_6294;
  }
  else
  {
    v4 = "usage: HudOutlineDisableForClients( <client array> );";
    v5 = COM_ERR_4241;
  }
  Scr_Error(v5, scrContext, v4);
}

/*
==============
ScrCmd_HudOutlineEnable
==============
*/
void ScrCmd_HudOutlineEnable(scrContext_t *scrContext, scr_entref_t entref)
{
  scr_string_t ConstString; 
  const char *v5; 
  const char *v6; 
  ComErrorCode v7; 
  gentity_s *Entity; 
  int v9; 
  unsigned int outIndex[3]; 
  ClientBits v11; 
  __int128 v12; 
  __int64 v13; 

  v9 = 0;
  if ( Scr_GetNumParam(scrContext) > 1 )
  {
    Scr_Error(COM_ERR_4242, scrContext, "Usage: HudOutlineEnable( <hudOutline>");
    return;
  }
  ConstString = Scr_GetConstString(scrContext, 0);
  if ( !ConstString && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 11305, ASSERT_TYPE_ASSERT, "(hudOutlineScrStr != ( static_cast< scr_string_t >( 0 ) ))", (const char *)&queryFormat, "hudOutlineScrStr != NULL_SCR_STRING") )
    __debugbreak();
  v5 = SL_ConvertToString(ConstString);
  if ( !v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 11308, ASSERT_TYPE_ASSERT, "(hudOutlineName)", (const char *)&queryFormat, "hudOutlineName") )
    __debugbreak();
  outIndex[0] = 0;
  if ( BG_HudOutline_GetDefIndex(v5, outIndex) )
  {
    v9 ^= ((unsigned __int8)v9 ^ LOBYTE(outIndex[0])) & 0x3F;
    Entity = GetEntity(entref);
    *(_QWORD *)&v12 = -1i64;
    *((_QWORD *)&v12 + 1) = -1i64;
    v13 = -1i64;
    *(_OWORD *)v11.array = v12;
    *(double *)&v11.array[4] = NAN;
    v11.array[6] = -1;
    if ( G_HudOutline_EnableForClientMask(Entity, &v11, (const outline_client_data_t *)&v9) )
      return;
    v6 = "HudOutlineEnable() could not be applied because there are currently too many hud outline settings. Can we reduce color and depth test variations?";
    v7 = COM_ERR_6295;
  }
  else
  {
    v6 = j_va("Hud Outline name not found (%s)! Make sure you add your Hud Outline asset to your level csv file!\n", v5);
    v7 = COM_ERR_6088;
  }
  Scr_Error(v7, scrContext, v6);
}

/*
==============
PlayerCmd_SetPriorityClientTriggerAudioZone
==============
*/
void PlayerCmd_SetPriorityClientTriggerAudioZone(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  int number; 
  const char *v7; 
  const char *v8; 
  unsigned int NumParam; 
  const char *String; 
  int AudioTriggerPriorityIndex; 
  const char *v12; 
  const char *v13; 
  double Float; 
  const char *v15; 
  char *fmt; 
  int outControllingClientNum; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3678, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 29577, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client && !v4->agent )
    {
      v5 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3677, scrContext, v5);
    }
  }
  number = v4->s.number;
  outControllingClientNum = number;
  if ( !SV_IsAgent(number) || SV_GetAgentControlledByPlayerNum(outControllingClientNum, &outControllingClientNum) )
  {
    if ( outControllingClientNum < level.maxclients )
    {
      NumParam = Scr_GetNumParam(scrContext);
      if ( NumParam - 2 > 1 )
      {
        Scr_Error(COM_ERR_4803, scrContext, "Incorrect number of parameters\n");
      }
      else
      {
        String = Scr_GetString(scrContext, 1u);
        AudioTriggerPriorityIndex = GScr_Main_GetAudioTriggerPriorityIndex(String);
        if ( AudioTriggerPriorityIndex == -1 )
        {
          v12 = j_va("Invalid client trigger override priority level: %s", String);
          Scr_Error(COM_ERR_4804, scrContext, v12);
        }
        else if ( NumParam == 2 )
        {
          v13 = Scr_GetString(scrContext, 0);
          Float = Scr_GetFloat(scrContext, 2u);
          LODWORD(fmt) = AudioTriggerPriorityIndex;
          v15 = j_va("%c %c %s %d %g", 109i64, 98i64, v13, fmt, *(float *)&Float);
          SV_Game_SendServerCommand(outControllingClientNum, SV_CMD_RELIABLE, v15);
        }
      }
    }
    else
    {
      v8 = j_va("Invalid entity index %d before SV_Game_SendServerCommand\n", (unsigned int)outControllingClientNum);
      Scr_Error(COM_ERR_6412, scrContext, v8);
    }
  }
  else
  {
    v7 = j_va("entity %i is not a player or player-controlled agent", entnum);
    Scr_ObjectError(COM_ERR_4802, scrContext, v7);
  }
}

/*
==============
ScrCmd_HudOutlineDisable
==============
*/
void ScrCmd_HudOutlineDisable(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  ClientBits v4; 
  __int128 v5; 
  __int64 v6; 

  *(_QWORD *)&v5 = -1i64;
  *((_QWORD *)&v5 + 1) = -1i64;
  v6 = -1i64;
  Entity = GetEntity(entref);
  v4.array[6] = -1;
  *(_OWORD *)v4.array = v5;
  *(double *)&v4.array[4] = NAN;
  if ( !G_HudOutline_DisableForClientMask(Entity, &v4) )
    Scr_Error(COM_ERR_6296, scrContext, "HudOutlineDisable() could not be applied because there are currently too many hud outline settings. Can we reduce color and depth test variations?");
}

/*
==============
PlayerCmd_SetClientTriggerAudioZoneLerp
==============
*/
void PlayerCmd_SetClientTriggerAudioZoneLerp(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  int number; 
  const char *v7; 
  const char *v8; 
  ComErrorCode v9; 
  const char *String; 
  const char *v11; 
  double Float; 
  const char *v13; 
  int outControllingClientNum; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3678, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 29643, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client && !v4->agent )
    {
      v5 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3677, scrContext, v5);
    }
  }
  number = v4->s.number;
  outControllingClientNum = number;
  if ( SV_IsAgent(number) && !SV_GetAgentControlledByPlayerNum(outControllingClientNum, &outControllingClientNum) )
  {
    v7 = j_va("entity %i is not a player or player-controlled agent", entnum);
    Scr_ObjectError(COM_ERR_4805, scrContext, v7);
    return;
  }
  if ( outControllingClientNum < level.maxclients )
  {
    if ( Scr_GetNumParam(scrContext) == 3 )
    {
      String = Scr_GetString(scrContext, 0);
      v11 = Scr_GetString(scrContext, 1u);
      Float = Scr_GetFloat(scrContext, 2u);
      v13 = j_va("%c %c %s %s %g", 109i64, 99i64, String, v11, *(float *)&Float);
      SV_Game_SendServerCommand(outControllingClientNum, SV_CMD_RELIABLE, v13);
      return;
    }
    v8 = "Incorrect number of parameters\n";
    v9 = COM_ERR_4806;
  }
  else
  {
    v8 = j_va("Invalid entity index %d before SV_Game_SendServerCommand\n", (unsigned int)outControllingClientNum);
    v9 = COM_ERR_6413;
  }
  Scr_Error(v9, scrContext, v8);
}

/*
==============
ScrCmd_MotionBlurHQEnable
==============
*/
void ScrCmd_MotionBlurHQEnable(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *client; 

  Entity = GetEntity(entref);
  client = (GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *)Entity->client;
  if ( client )
    GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(client + 94, ACTIVE, 0xDu);
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(&Entity->s.lerp.eFlags, ACTIVE, 0xDu);
}

/*
==============
ScrCmd_MotionBlurHQDisable
==============
*/
void ScrCmd_MotionBlurHQDisable(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *client; 

  Entity = GetEntity(entref);
  client = (GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *)Entity->client;
  if ( client )
    GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(client + 94, ACTIVE, 0xDu);
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(&Entity->s.lerp.eFlags, ACTIVE, 0xDu);
}

/*
==============
ScrCmd_ThermalVisionFOFOverlayOn
==============
*/
void ScrCmd_ThermalVisionFOFOverlayOn(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  char *client; 
  const char *v6; 
  ComErrorCode v7; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 11417, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = (char *)v4->client;
  if ( !client )
  {
    client = (char *)v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v7, scrContext, v6);
      client = NULL;
    }
  }
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal((GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *)(client + 28), ACTIVE, 4u);
}

/*
==============
ScrCmd_ThermalVisionFOFOverlayOff
==============
*/
void ScrCmd_ThermalVisionFOFOverlayOff(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  char *client; 
  const char *v6; 
  ComErrorCode v7; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 11434, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = (char *)v4->client;
  if ( !client )
  {
    client = (char *)v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v7, scrContext, v6);
      client = NULL;
    }
  }
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal((GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *)(client + 28), ACTIVE, 4u);
}

/*
==============
ScrCmd_GetStance
==============
*/
void ScrCmd_GetStance(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  playerState_s *EntityPlayerState; 
  bool v10; 
  scr_string_t crouch; 

  entnum = entref.entnum;
  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 11455, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClientOrAgent(Entity) )
  {
    targetname = Entity->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(Entity->classname);
    v8 = j_va("only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, Entity->r.currentOrigin.v[0], Entity->r.currentOrigin.v[1], Entity->r.currentOrigin.v[2], v7, v6);
    Scr_Error(COM_ERR_4244, scrContext, v8);
  }
  EntityPlayerState = G_GetEntityPlayerState(Entity);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 11461, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&EntityPlayerState->pm_flags, ACTIVE, 0) )
  {
    Scr_AddConstString(scrContext, scr_const.prone);
  }
  else
  {
    v10 = GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&EntityPlayerState->pm_flags, ACTIVE, 1u);
    crouch = scr_const.crouch;
    if ( !v10 )
      crouch = scr_const.stand;
    Scr_AddConstString(scrContext, crouch);
  }
}

/*
==============
PlayerCmd_SetClientTriggerAudioZonePartial
==============
*/
void PlayerCmd_SetClientTriggerAudioZonePartial(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *v4; 
  const char *v5; 
  ComErrorCode v6; 
  const char *String; 

  if ( entref.entclass )
  {
    v5 = "not an entity";
    v6 = COM_ERR_3678;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 29778, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entref.entnum];
  if ( !v4->client && !v4->agent )
  {
    v5 = j_va("entity %i is not a player or agent", entref.entnum);
    v6 = COM_ERR_3677;
LABEL_9:
    Scr_ObjectError(v6, scrContext, v5);
  }
  Scr_GetNumParam(scrContext);
  String = Scr_GetString(scrContext, 0);
  SetClientTriggerAudioZonePartial(scrContext, entref, String, 0, 0.0, 1);
}

/*
==============
ScrCmd_SetStance
==============
*/
void ScrCmd_SetStance(scrContext_t *scrContext, scr_entref_t entref)
{
  bool v3; 
  gentity_s *Entity; 
  scr_string_t ConstString; 
  int v6; 
  gclient_s *client; 
  int passEntityNum; 
  const Bounds *v9; 
  const char *v10; 
  int clientNum; 
  const Bounds *Bounds; 
  const char *v13; 
  const SuitDef *SuitDef; 
  bool v15; 
  bool v16; 
  int viewheight_stand; 
  unsigned int v18; 
  trace_t results; 

  v3 = 0;
  Entity = GetEntity(entref);
  ConstString = Scr_GetConstString(scrContext, 0);
  v6 = 1;
  if ( Scr_GetNumParam(scrContext) > 1 && Scr_GetType(scrContext, 1u) )
    v3 = Scr_GetInt(scrContext, 1u) != 0;
  client = Entity->client;
  if ( !client )
  {
    Scr_Error(COM_ERR_4245, scrContext, "SetStance is only defined for players.");
    return;
  }
  if ( v3 )
    goto LABEL_19;
  if ( !GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&client->ps.pm_flags, ACTIVE, 0) || ConstString != scr_const.crouch && ConstString != scr_const.stand || (passEntityNum = client->ps.clientNum, v9 = BG_Suit_GetBounds(client->ps.suitIndex, PM_EFF_STANCE_DUCKED), G_Main_TraceCapsule(&results, &client->ps.origin, &client->ps.origin, v9, passEntityNum, 65553), !results.allsolid) )
  {
    if ( (GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&client->ps.pm_flags, ACTIVE, 0) || GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&client->ps.pm_flags, ACTIVE, 1u)) && ConstString == scr_const.stand )
    {
      clientNum = client->ps.clientNum;
      Bounds = BG_Suit_GetBounds(client->ps.suitIndex, PM_EFF_STANCE_DUCKED);
      G_Main_TraceCapsule(&results, &client->ps.origin, &client->ps.origin, Bounds, clientNum, 65553);
      if ( results.allsolid )
      {
        v13 = SL_ConvertToString(ConstString);
        Com_PrintWarning(23, "Warning: SetStance( \"%s\" ) could not be applied because there isn't enough room", v13);
        if ( !GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&client->ps.pm_flags, ACTIVE, 0) )
          goto LABEL_11;
        ConstString = scr_const.crouch;
      }
    }
LABEL_19:
    SuitDef = BG_GetSuitDef(client->ps.suitIndex);
    if ( !SuitDef && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 11540, ASSERT_TYPE_ASSERT, "(suitDef)", (const char *)&queryFormat, "suitDef") )
      __debugbreak();
    v15 = Scr_GetNumParam(scrContext) > 2 && Scr_GetType(scrContext, 2u) && Scr_GetInt(scrContext, 2u);
    v16 = Scr_GetNumParam(scrContext) > 3 && Scr_GetType(scrContext, 3u) && Scr_GetInt(scrContext, 3u);
    if ( ConstString == scr_const.stand )
    {
      if ( v15 )
        GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::SetFlagInternal(&client->ps.pm_flags, ACTIVE, 4u);
      GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(&client->ps.pm_flags, ACTIVE, 2u);
      GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(&client->ps.pm_flags, ACTIVE, 3u);
      GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(&client->ps.pm_flags, ACTIVE, 0);
      GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(&client->ps.pm_flags, ACTIVE, 0x36u);
      GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(&client->ps.pm_flags, ACTIVE, 1u);
      viewheight_stand = SuitDef->viewheight_stand;
      v18 = 10;
    }
    else if ( ConstString == scr_const.crouch )
    {
      if ( v15 )
        GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::SetFlagInternal(&client->ps.pm_flags, ACTIVE, 3u);
      GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(&client->ps.pm_flags, ACTIVE, 2u);
      GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(&client->ps.pm_flags, ACTIVE, 4u);
      GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(&client->ps.pm_flags, ACTIVE, 0);
      GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(&client->ps.pm_flags, ACTIVE, 0x36u);
      GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::SetFlagInternal(&client->ps.pm_flags, ACTIVE, 1u);
      viewheight_stand = SuitDef->viewheight_crouch;
      v18 = 11;
    }
    else
    {
      if ( ConstString != scr_const.prone )
      {
        v6 = 0;
LABEL_52:
        Scr_AddBool(scrContext, v6);
        return;
      }
      if ( !GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&client->ps.pm_flags, ACTIVE, 0) )
      {
        if ( (LODWORD(client->ps.viewangles.v[1]) & 0x7F800000) == 2139095040 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 11593, ASSERT_TYPE_ASSERT, "(!IS_NAN( ps->viewangles[YAW] ))", (const char *)&queryFormat, "!IS_NAN( ps->viewangles[YAW] )") )
          __debugbreak();
        client->ps.proneDirection = client->ps.viewangles.v[1];
      }
      if ( v15 )
        GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::SetFlagInternal(&client->ps.pm_flags, ACTIVE, 2u);
      GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(&client->ps.pm_flags, ACTIVE, 3u);
      GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(&client->ps.pm_flags, ACTIVE, 4u);
      GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(&client->ps.pm_flags, ACTIVE, 1u);
      GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::SetFlagInternal(&client->ps.pm_flags, ACTIVE, 0);
      viewheight_stand = BG_Suit_GetProneViewHeight(SuitDef);
      v18 = 12;
    }
    client->ps.viewHeightTarget = viewheight_stand;
    G_Utils_AddEvent(Entity, v18, 0);
    if ( v16 )
      client->ps.viewHeightCurrent = (float)client->ps.viewHeightTarget;
    goto LABEL_52;
  }
  v10 = SL_ConvertToString(ConstString);
  Com_PrintWarning(23, "Warning: SetStance( \"%s\" ) could not be applied because there isn't enough room", v10);
LABEL_11:
  Scr_AddBool(scrContext, 0);
}

/*
==============
PlayerCmd_SetPriorityClientTriggerAudioZonePartial
==============
*/
void PlayerCmd_SetPriorityClientTriggerAudioZonePartial(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *v4; 
  const char *v5; 
  ComErrorCode v6; 
  const char *String; 
  const char *v8; 
  int AudioTriggerPriorityIndex; 
  const char *v10; 

  if ( entref.entclass )
  {
    v5 = "not an entity";
    v6 = COM_ERR_3678;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 29817, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entref.entnum];
  if ( !v4->client && !v4->agent )
  {
    v5 = j_va("entity %i is not a player or agent", entref.entnum);
    v6 = COM_ERR_3677;
LABEL_9:
    Scr_ObjectError(v6, scrContext, v5);
  }
  Scr_GetNumParam(scrContext);
  String = Scr_GetString(scrContext, 0);
  v8 = Scr_GetString(scrContext, 1u);
  AudioTriggerPriorityIndex = GScr_Main_GetAudioTriggerPriorityIndex(v8);
  if ( AudioTriggerPriorityIndex == -1 )
  {
    v10 = j_va("Invalid client trigger override priority level: %s", v8);
    Scr_Error(COM_ERR_4809, scrContext, v10);
  }
  else
  {
    SetClientTriggerAudioZonePartial(scrContext, entref, String, AudioTriggerPriorityIndex, 0.0, 2);
  }
}

/*
==============
PlayerCmd_SetClientTriggerAudioZonePartialWithFade
==============
*/
void PlayerCmd_SetClientTriggerAudioZonePartialWithFade(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *v4; 
  const char *v5; 
  ComErrorCode v6; 
  const char *String; 
  double Float; 

  if ( entref.entclass )
  {
    v5 = "not an entity";
    v6 = COM_ERR_3678;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 29863, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entref.entnum];
  if ( !v4->client && !v4->agent )
  {
    v5 = j_va("entity %i is not a player or agent", entref.entnum);
    v6 = COM_ERR_3677;
LABEL_9:
    Scr_ObjectError(v6, scrContext, v5);
  }
  Scr_GetNumParam(scrContext);
  String = Scr_GetString(scrContext, 0);
  Float = Scr_GetFloat(scrContext, 1u);
  SetClientTriggerAudioZonePartial(scrContext, entref, String, 0, *(const float *)&Float, 2);
}

/*
==============
PlayerCmd_SetPriorityClientTriggerAudioZonePartialWithFade
==============
*/
void PlayerCmd_SetPriorityClientTriggerAudioZonePartialWithFade(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *v4; 
  const char *v5; 
  ComErrorCode v6; 
  const char *String; 
  double Float; 
  const char *v9; 
  int AudioTriggerPriorityIndex; 
  const char *v11; 

  if ( entref.entclass )
  {
    v5 = "not an entity";
    v6 = COM_ERR_3678;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 29905, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entref.entnum];
  if ( !v4->client && !v4->agent )
  {
    v5 = j_va("entity %i is not a player or agent", entref.entnum);
    v6 = COM_ERR_3677;
LABEL_9:
    Scr_ObjectError(v6, scrContext, v5);
  }
  Scr_GetNumParam(scrContext);
  String = Scr_GetString(scrContext, 0);
  Scr_GetString(scrContext, 1u);
  Float = Scr_GetFloat(scrContext, 2u);
  v9 = Scr_GetString(scrContext, 0);
  AudioTriggerPriorityIndex = GScr_Main_GetAudioTriggerPriorityIndex(v9);
  if ( AudioTriggerPriorityIndex == -1 )
  {
    v11 = j_va("Invalid client trigger override priority level: %s", v9);
    Scr_Error(COM_ERR_4810, scrContext, v11);
  }
  else
  {
    SetClientTriggerAudioZonePartial(scrContext, entref, String, AudioTriggerPriorityIndex, *(const float *)&Float, 2);
  }
}

/*
==============
PlayerCmd_ClearClientTriggerAudioZone
==============
*/
void PlayerCmd_ClearClientTriggerAudioZone(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  int NumParam; 
  int number; 
  const char *v8; 
  const char *v9; 
  const char *v10; 
  double Float; 
  int outControllingClientNum; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3678, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 29942, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client && !v4->agent )
    {
      v5 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3677, scrContext, v5);
    }
  }
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam > 1 )
  {
    Scr_Error(COM_ERR_4811, scrContext, "Incorrect number of parameters\n");
    return;
  }
  number = v4->s.number;
  outControllingClientNum = number;
  if ( SV_IsAgent(number) && !SV_GetAgentControlledByPlayerNum(outControllingClientNum, &outControllingClientNum) )
  {
    v8 = j_va("entity %i is not a player or player-controlled agent", entnum);
    Scr_ObjectError(COM_ERR_4812, scrContext, v8);
    return;
  }
  if ( outControllingClientNum >= level.maxclients )
  {
    v9 = j_va("Invalid entity index %d before SV_Game_SendServerCommand\n", (unsigned int)outControllingClientNum);
    Scr_Error(COM_ERR_6415, scrContext, v9);
    return;
  }
  if ( NumParam )
  {
    if ( NumParam != 1 )
      return;
    Float = Scr_GetFloat(scrContext, 0);
    v10 = j_va("%c %c 0 %g", 109i64, 101i64, *(float *)&Float);
  }
  else
  {
    v10 = j_va("%c %c 0", 109i64, 101i64);
  }
  SV_Game_SendServerCommand(outControllingClientNum, SV_CMD_RELIABLE, v10);
}

/*
==============
ScrCmd_GetEye
==============
*/
void ScrCmd_GetEye(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const gentity_s *v4; 
  const char *v5; 
  const char *v6; 
  gclient_s *client; 
  vec3_t outCentroid; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( !Entity->sentient )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("getEye must be called on a sentient entity. Use self MakeEntitySentient() with '%s'", v5);
    Scr_Error(COM_ERR_4251, scrContext, v6);
  }
  client = v4->client;
  if ( client && client->sess.sessionState )
  {
    Com_Printf(23, "GetEye() called while not in SESS_STATE_PLAYING\n");
    G_Utils_EntityCentroid(v4, &outCentroid);
  }
  else
  {
    Sentient_GetEyePosition(v4->sentient, &outCentroid);
  }
  Scr_AddVector(scrContext, outCentroid.v);
}

/*
==============
ScrCmd_GetViewOrigin
==============
*/
void ScrCmd_GetViewOrigin(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const playerState_s *p_ps; 
  const char *v6; 
  ComErrorCode v7; 
  vec3_t outOrigin; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 11726, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  p_ps = &v4->client->ps;
  if ( !p_ps )
  {
    p_ps = &v4->agent->playerState;
    if ( !p_ps )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v7, scrContext, v6);
      p_ps = NULL;
    }
  }
  G_Client_GetViewOrigin(p_ps, &outOrigin);
  Scr_AddVector(scrContext, outOrigin.v);
}

/*
==============
PlayerCmd_ClearPriorityClientTriggerAudioZone
==============
*/
void PlayerCmd_ClearPriorityClientTriggerAudioZone(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  int NumParam; 
  int number; 
  const char *v8; 
  const char *String; 
  unsigned int AudioTriggerPriorityIndex; 
  unsigned int v11; 
  const char *v12; 
  const char *v13; 
  const char *v14; 
  double Float; 
  int outControllingClientNum; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3678, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 29994, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client && !v4->agent )
    {
      v5 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3677, scrContext, v5);
    }
  }
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam > 2 )
  {
    Scr_Error(COM_ERR_4813, scrContext, "Incorrect number of parameters\n");
    return;
  }
  number = v4->s.number;
  outControllingClientNum = number;
  if ( SV_IsAgent(number) && !SV_GetAgentControlledByPlayerNum(outControllingClientNum, &outControllingClientNum) )
  {
    v8 = j_va("entity %i is not a player or player-controlled agent", entnum);
    Scr_ObjectError(COM_ERR_4814, scrContext, v8);
    return;
  }
  String = Scr_GetString(scrContext, 0);
  AudioTriggerPriorityIndex = GScr_Main_GetAudioTriggerPriorityIndex(String);
  v11 = AudioTriggerPriorityIndex;
  if ( AudioTriggerPriorityIndex == -1 )
  {
    v12 = j_va("Invalid client trigger override priority level: %s", String);
    Scr_Error(COM_ERR_4815, scrContext, v12);
    return;
  }
  if ( outControllingClientNum >= level.maxclients )
  {
    v13 = j_va("Invalid entity index %d before SV_Game_SendServerCommand\n", (unsigned int)outControllingClientNum);
    Scr_Error(COM_ERR_6416, scrContext, v13);
    return;
  }
  if ( NumParam == 1 )
  {
    v14 = j_va("%c %c %d", 109i64, 101i64, AudioTriggerPriorityIndex);
  }
  else
  {
    if ( NumParam != 2 )
      return;
    Float = Scr_GetFloat(scrContext, 0);
    v14 = j_va("%c %c %d %g", 109i64, 101i64, v11, *(float *)&Float);
  }
  SV_Game_SendServerCommand(outControllingClientNum, SV_CMD_RELIABLE, v14);
}

/*
==============
Scr_BulletSpread
==============
*/
void Scr_BulletSpread(scrContext_t *scrContext)
{
  __int128 v1; 
  __int128 v2; 
  double Float; 
  float v5; 
  const WeaponDef *v6; 
  __int128 v7; 
  const dvar_t *v11; 
  float value; 
  unsigned int pHoldrand[4]; 
  BgWeaponParms src; 
  vec3_t end; 
  vec3_t vectorValue; 
  vec3_t dir; 
  _OWORD v18[2]; 

  v18[1] = v1;
  v18[0] = v2;
  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &end);
  Float = Scr_GetFloat(scrContext, 2u);
  memset(&src.weapon, 0, 48);
  *(_DWORD *)&src.weapon.weaponCamo = *(_DWORD *)&NULL_WEAPON.weaponCamo;
  *(double *)&src.weapon.attachmentVariationIndices[21] = *(double *)&NULL_WEAPON.attachmentVariationIndices[21];
  v5 = *(float *)&Float;
  v6 = BG_WeaponDef(&NULL_WEAPON, 0);
  src.muzzleTrace = vectorValue;
  v7 = LODWORD(end.v[1]);
  *(float *)&v7 = fsqrt((float)((float)((float)(end.v[1] - vectorValue.v[1]) * (float)(end.v[1] - vectorValue.v[1])) + (float)((float)(end.v[0] - vectorValue.v[0]) * (float)(end.v[0] - vectorValue.v[0]))) + (float)((float)(end.v[2] - vectorValue.v[2]) * (float)(end.v[2] - vectorValue.v[2])));
  _XMM4 = v7;
  __asm
  {
    vcmpless xmm0, xmm4, cs:__real@80000000
    vblendvps xmm0, xmm4, xmm1, xmm0
  }
  src.weapDef = v6;
  src.forward.v[0] = (float)(end.v[0] - vectorValue.v[0]) * (float)(1.0 / *(float *)&_XMM0);
  src.forward.v[1] = (float)(end.v[1] - vectorValue.v[1]) * (float)(1.0 / *(float *)&_XMM0);
  src.forward.v[2] = (float)(end.v[2] - vectorValue.v[2]) * (float)(1.0 / *(float *)&_XMM0);
  src.gunForward = src.forward;
  PerpendicularVector(&src.forward, &src.up);
  src.right.v[0] = (float)(src.forward.v[1] * src.up.v[2]) - (float)(src.forward.v[2] * src.up.v[1]);
  src.right.v[1] = (float)(src.forward.v[2] * src.up.v[0]) - (float)(src.up.v[2] * src.forward.v[0]);
  src.right.v[2] = (float)(src.up.v[1] * src.forward.v[0]) - (float)(src.forward.v[1] * src.up.v[0]);
  pHoldrand[0] = level.time;
  BG_srand(pHoldrand);
  if ( Com_GameMode_SupportsFeature(WEAPON_DROPPING|0x80) )
  {
    v11 = DCONST_DVARFLT_bg_bulletLongHitScanDistance;
    if ( !DCONST_DVARFLT_bg_bulletLongHitScanDistance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_bulletLongHitScanDistance") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v11);
    value = v11->current.value;
  }
  else
  {
    value = FLOAT_8192_0;
  }
  G_Bullet_Endpos(pHoldrand, 0.0, v5, &end, &dir, 0.0, 360.0, &src, value);
  Scr_AddVector(scrContext, end.v);
}

/*
==============
Scr_SightTracePassed
==============
*/
void Scr_SightTracePassed(scrContext_t *scrContext)
{
  int number; 
  int v2; 
  int contentmask; 
  int NumParam; 
  bool v6; 
  double ClientVisibility; 
  float v8; 
  double FxVisibility; 
  vec3_t vectorValue; 
  vec3_t start; 

  number = 2047;
  v2 = 2047;
  contentmask = 41965571;
  Scr_GetVector(scrContext, 0, &start);
  Scr_GetVector(scrContext, 1u, &vectorValue);
  if ( !Scr_GetInt(scrContext, 2u) )
    contentmask = 8394755;
  if ( Scr_GetType(scrContext, 3u) == VAR_POINTER && Scr_GetPointerType(scrContext, 3u) == VAR_ENTITY )
    number = GScr_GetEntity(3u)->s.number;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam > 4 && Scr_GetType(scrContext, 4u) == VAR_POINTER && Scr_GetPointerType(scrContext, 4u) == VAR_ENTITY )
    v2 = GScr_GetEntity(4u)->s.number;
  if ( NumParam > 5 && Scr_GetType(scrContext, 5u) == VAR_INTEGER && Scr_GetInt(scrContext, 5u) )
    contentmask &= ~2u;
  v6 = G_Main_SightTrace(&start, &vectorValue, number, v2, contentmask);
  if ( v6 && (unsigned __int8)Com_GameMode_GetActiveGameMode() == HALF )
  {
    if ( SV_IsDemoPlaying() )
    {
      FxVisibility = SV_DemoSP_GetFxVisibility();
      v8 = *(float *)&FxVisibility;
    }
    else
    {
      if ( !Com_GameMode_SupportsFeature(WEAPON_FIRING) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\effectscore\\fx_system_api_inline.h", 118, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::CLIENT_SERVER_SHARED_MEMORY ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::CLIENT_SERVER_SHARED_MEMORY )") )
        __debugbreak();
      ClientVisibility = FX_GetClientVisibility(fx_serverVisClient, &start, &vectorValue);
      v8 = *(float *)&ClientVisibility;
      SV_DemoSP_RecordFxVisibility(*(float *)&ClientVisibility);
    }
    if ( v8 < 0.2 )
      v6 = 0;
  }
  Scr_AddBool(scrContext, v6);
}

/*
==============
PlayerCmd_SetSoundSubmix
==============
*/

void __fastcall PlayerCmd_SetSoundSubmix(scrContext_t *scrContext, scr_entref_t entref, double _XMM2_8)
{
  unsigned int entnum; 
  unsigned int NumParam; 
  const char *String; 
  const char *v7; 
  unsigned int v8; 
  const char *v9; 
  const char *v10; 
  const char *v11; 
  double Float; 
  float v13; 
  const char *v14; 
  const char *v15; 
  double v16; 
  double v17; 
  const char *v19; 
  int outControllingClientNum; 

  entnum = entref.entnum;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam - 1 > 2 )
  {
    Scr_Error(COM_ERR_4818, scrContext, "SetSoundSubmix: Incorrect number of parameters - expect: duckname [,fadeTime [,scale]]\n");
  }
  else
  {
    String = Scr_GetString(scrContext, 0);
    v7 = String;
    if ( (!String || !*String) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 30171, ASSERT_TYPE_ASSERT, "(duckName && duckName[0])", (const char *)&queryFormat, "duckName && duckName[0]") )
      __debugbreak();
    v8 = SND_HashName(v7);
    if ( !v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 30173, ASSERT_TYPE_ASSERT, "(duckHash != static_cast< SndStringHash >( 0 ))", (const char *)&queryFormat, "duckHash != SND_INVALID_HASH") )
      __debugbreak();
    if ( SND_GetDuckById(v8) )
    {
      if ( SV_GetAgentControlledByPlayerNum(entnum, &outControllingClientNum) )
        entnum = outControllingClientNum;
      if ( (int)entnum < level.maxclients )
      {
        if ( NumParam == 1 )
        {
          v11 = j_va("%c %c %x", 90i64, 48i64, v8);
          SV_Game_SendServerCommand(entnum, SV_CMD_RELIABLE, v11);
        }
        else
        {
          Float = Scr_GetFloat(scrContext, 1u);
          v13 = *(float *)&Float;
          if ( *(float *)&Float >= 0.0 || *(float *)&Float == -1.0 )
          {
            if ( NumParam == 2 )
            {
              v15 = j_va("%c %c %x %f", 90i64, 49i64, v8, *(float *)&Float);
            }
            else
            {
              v16 = Scr_GetFloat(scrContext, 2u);
              if ( *(float *)&v16 < 0.0 || *(float *)&v16 > 1.0 )
              {
                v17 = *(float *)&v16;
                __asm { vxorpd  xmm2, xmm2, xmm2 }
                v19 = j_va("SetSoundSubmix: Incorrect scale parameters %.2f- expect [%.2f,%.2f])\n", *(float *)&v16, (_QWORD)_XMM2, DOUBLE_1_0);
                Scr_Error(COM_ERR_5929, scrContext, v19);
              }
              else
              {
                v17 = *(float *)&v16;
              }
              v15 = j_va("%c %c %x %f %f", 90i64, 50i64, v8, v13, v17);
            }
            SV_Game_SendServerCommand(entnum, SV_CMD_RELIABLE, v15);
          }
          else
          {
            v14 = j_va("SetSoundSubmix: Incorrect fadeTime parameters %.2f- expect >= 0 (or %.2f for asset default)\n", *(float *)&Float, DOUBLE_N1_0);
            Scr_Error(COM_ERR_5928, scrContext, v14);
          }
        }
      }
      else
      {
        v10 = j_va("Invalid entity index %d before SV_Game_SendServerCommand\n", entnum);
        Scr_Error(COM_ERR_6419, scrContext, v10);
      }
    }
    else
    {
      v9 = j_va("SetSoundSubmix: bad duck name: '%s'", v7);
      Scr_ParamError(COM_ERR_4819, scrContext, 0, v9);
    }
  }
}

/*
==============
Scr_PhysicsTrace
==============
*/
void Scr_PhysicsTrace(scrContext_t *scrContext)
{
  vec3_t vectorValue; 
  vec3_t end; 
  float value[4]; 
  trace_t results; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &end);
  G_Main_TraceCapsule(&results, &vectorValue, &end, &bounds_origin, 2047, 131089);
  value[0] = (float)((float)(end.v[0] - vectorValue.v[0]) * results.fraction) + vectorValue.v[0];
  value[1] = (float)((float)(end.v[1] - vectorValue.v[1]) * results.fraction) + vectorValue.v[1];
  value[2] = (float)((float)(end.v[2] - vectorValue.v[2]) * results.fraction) + vectorValue.v[2];
  Scr_AddVector(scrContext, value);
}

/*
==============
Scr_PlayerPhysicsTrace
==============
*/
void Scr_PlayerPhysicsTrace(scrContext_t *scrContext)
{
  const Bounds *bounds; 
  gentity_s *Entity; 
  gclient_s *client; 
  gagent_s *agent; 
  int skipEntities; 
  vec3_t vectorValue; 
  vec3_t end; 
  float value[4]; 
  vec3_t overrideAngles; 
  trace_t results; 

  skipEntities = 2047;
  bounds = &playerBox;
  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &end);
  if ( Scr_GetNumParam(scrContext) > 2 && Scr_GetType(scrContext, 2u) )
  {
    Entity = GScr_GetEntity(2u);
    client = Entity->client;
    if ( client )
    {
      bounds = BG_Suit_GetBounds(client->ps.suitIndex, PM_EFF_STANCE_DEFAULT);
    }
    else
    {
      agent = Entity->agent;
      if ( agent )
        bounds = BG_Suit_GetBounds(agent->playerState.suitIndex, PM_EFF_STANCE_DEFAULT);
      else
        Scr_ParamError(COM_ERR_4252, scrContext, 1u, "Entity is not a client or agent.");
    }
  }
  if ( Scr_GetNumParam(scrContext) > 3 && Scr_GetType(scrContext, 3u) )
  {
    Scr_GetVector(scrContext, 3u, &overrideAngles);
    PhysicsQuery_LegacyCapsuleTraceAngles(PHYSICS_WORLD_ID_FIRST, &results, &vectorValue, &end, bounds, &skipEntities, 1, 65553, NULL, 0, &overrideAngles);
  }
  else
  {
    PhysicsQuery_LegacyCapsuleTrace(PHYSICS_WORLD_ID_FIRST, &results, &vectorValue, &end, bounds, &skipEntities, 1, 65553, NULL, 0, NULL, NULL);
  }
  value[0] = (float)((float)(end.v[0] - vectorValue.v[0]) * results.fraction) + vectorValue.v[0];
  value[1] = (float)((float)(end.v[1] - vectorValue.v[1]) * results.fraction) + vectorValue.v[1];
  value[2] = (float)((float)(end.v[2] - vectorValue.v[2]) * results.fraction) + vectorValue.v[2];
  Scr_AddVector(scrContext, value);
}

/*
==============
Scr_AIPhysicsTrace
==============
*/
void Scr_AIPhysicsTrace(scrContext_t *scrContext, scr_entref_t entref)
{
  int passEntityNum; 
  const gentity_s *Entity; 
  int NumParam; 
  double Float; 
  int v7; 
  double v8; 
  Bounds *p_box; 
  bool v10; 
  bool v11; 
  int v12; 
  AIScriptedInterface *m_pAI; 
  int contentmask; 
  unsigned __int16 EntityHitId; 
  const char *v16; 
  scr_string_t surfacetype; 
  __int128 v18; 
  AIWrapper v22; 
  vec3_t end; 
  vec3_t vectorValue; 
  Bounds *bounds; 
  float v26; 
  float value[4]; 
  int v28[8]; 
  trace_t results; 

  passEntityNum = entref.entnum;
  Entity = GetEntity(entref);
  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &end);
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam > 3 && (Scr_GetType(scrContext, 2u) == VAR_FLOAT || Scr_GetType(scrContext, 2u) == VAR_INTEGER) && (Scr_GetType(scrContext, 3u) == VAR_FLOAT || Scr_GetType(scrContext, 3u) == VAR_INTEGER) )
  {
    Float = Scr_GetFloat(scrContext, 2u);
    v7 = SLODWORD(Float);
    v8 = Scr_GetFloat(scrContext, 3u);
    *(float *)&v28[2] = (float)(*(float *)&v8 * 0.5) + 0.0;
    v28[0] = SLODWORD(vec3_origin.v[0]);
    v28[1] = SLODWORD(vec3_origin.v[1]);
    v28[3] = v7;
    v28[4] = v7;
    *(float *)&v28[5] = *(float *)&v8 * 0.5;
    p_box = (Bounds *)v28;
  }
  else
  {
    p_box = &Entity->r.box;
  }
  bounds = p_box;
  v10 = NumParam <= 4 || Scr_GetInt(scrContext, 4u) != 0;
  v11 = NumParam > 5 && Scr_GetInt(scrContext, 5u) != 0;
  v12 = 33685521;
  if ( NumParam > 6 && BG_ActorOrAgentSystemEnabled() && Scr_GetInt(scrContext, 6u) )
  {
    AIActorInterface::AIActorInterface(&v22.m_actorInterface);
    AIAgentInterface::AIAgentInterface(&v22.m_newAgentInterface);
    v22.m_pAI = NULL;
    v22.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
    AIWrapper::Setup(&v22, Entity);
    m_pAI = v22.m_pAI;
    if ( !v22.m_pAI )
      Scr_Error(COM_ERR_4253, scrContext, "AIPhysicsTrace: arg 6 (bUseActorPhysicsMask) can only be used with a valid actor or agent!");
    v12 = *(_DWORD *)(m_pAI->GetAI(m_pAI) + 2268);
  }
  contentmask = v12 & 0xFDFFBFFF;
  if ( !v10 )
    contentmask = v12;
  G_Main_TraceCapsule(&results, &vectorValue, &end, bounds, passEntityNum, contentmask);
  value[0] = (float)((float)(end.v[0] - vectorValue.v[0]) * results.fraction) + vectorValue.v[0];
  value[1] = (float)((float)(end.v[1] - vectorValue.v[1]) * results.fraction) + vectorValue.v[1];
  value[2] = (float)((float)(end.v[2] - vectorValue.v[2]) * results.fraction) + vectorValue.v[2];
  if ( !v11 )
  {
    Scr_AddVector(scrContext, value);
    return;
  }
  Scr_MakeArray(scrContext);
  Scr_AddFloat(scrContext, results.fraction);
  Scr_AddArrayStringIndexed(scrContext, scr_const.fraction);
  Scr_AddVector(scrContext, value);
  Scr_AddArrayStringIndexed(scrContext, scr_const.position);
  EntityHitId = Trace_GetEntityHitId(&results);
  if ( (unsigned __int16)(EntityHitId - 2046) <= 1u )
    Scr_AddUndefined(scrContext);
  else
    GScr_AddEntity(&g_entities[EntityHitId]);
  Scr_AddArrayStringIndexed(scrContext, scr_const.entity);
  if ( results.fraction >= 1.0 )
  {
    v18 = LODWORD(end.v[1]);
    *(float *)&v18 = fsqrt((float)((float)((float)(end.v[1] - vectorValue.v[1]) * (float)(end.v[1] - vectorValue.v[1])) + (float)((float)(end.v[0] - vectorValue.v[0]) * (float)(end.v[0] - vectorValue.v[0]))) + (float)((float)(end.v[2] - vectorValue.v[2]) * (float)(end.v[2] - vectorValue.v[2])));
    _XMM1 = v18;
    __asm
    {
      vcmpless xmm0, xmm1, cs:__real@80000000
      vblendvps xmm0, xmm1, xmm7, xmm0
    }
    *(float *)&bounds = (float)(1.0 / *(float *)&_XMM0) * (float)(end.v[0] - vectorValue.v[0]);
    v26 = (float)(1.0 / *(float *)&_XMM0) * (float)(end.v[2] - vectorValue.v[2]);
    *((float *)&bounds + 1) = (float)(1.0 / *(float *)&_XMM0) * (float)(end.v[1] - vectorValue.v[1]);
    Scr_AddVector(scrContext, (const float *)&bounds);
    Scr_AddArrayStringIndexed(scrContext, scr_const.normal);
    Scr_AddConstString(scrContext, scr_const.none);
    surfacetype = scr_const.surfacetype;
  }
  else
  {
    Scr_AddVector(scrContext, results.normal.v);
    Scr_AddArrayStringIndexed(scrContext, scr_const.normal);
    v16 = Com_SurfaceTypeToName((results.surfaceFlags >> 19) & 0x3F);
    Scr_AddString(scrContext, v16);
    Scr_AddArrayStringIndexed(scrContext, scr_const.surfacetype);
    if ( (results.surfaceFlags & 0x200) == 0 )
      return;
    Scr_AddBool(scrContext, (results.surfaceFlags & 0x200) != 0);
    surfacetype = scr_const.stairs;
  }
  Scr_AddArrayStringIndexed(scrContext, surfacetype);
}

/*
==============
PlayerCmd_ScaleSoundSubmix
==============
*/

void __fastcall PlayerCmd_ScaleSoundSubmix(scrContext_t *scrContext, scr_entref_t entref, double _XMM2_8)
{
  int entnum; 
  const char *String; 
  const char *v6; 
  unsigned int v7; 
  const char *v8; 
  const char *v9; 
  scrContext_t *v10; 
  ComErrorCode v11; 
  double Float; 
  const char *v13; 
  int outControllingClientNum; 

  entnum = entref.entnum;
  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    String = Scr_GetString(scrContext, 0);
    v6 = String;
    if ( (!String || !*String) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 30255, ASSERT_TYPE_ASSERT, "(submixName && submixName[0])", (const char *)&queryFormat, "submixName && submixName[0]") )
      __debugbreak();
    v7 = SND_HashName(v6);
    if ( !v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 30257, ASSERT_TYPE_ASSERT, "(submixHash != static_cast< SndStringHash >( 0 ))", (const char *)&queryFormat, "submixHash != SND_INVALID_HASH") )
      __debugbreak();
    if ( !SND_GetDuckById(v7) )
    {
      v8 = j_va("ScaleSoundSubmix: bad submix name: '%s'", v6);
      Scr_ParamError(COM_ERR_4821, scrContext, 0, v8);
      return;
    }
    if ( SV_GetAgentControlledByPlayerNum(entnum, &outControllingClientNum) )
      entnum = outControllingClientNum;
    if ( entnum >= level.maxclients )
    {
      v9 = j_va("Invalid entity index %d before SV_Game_SendServerCommand\n", (unsigned int)entnum);
      v10 = scrContext;
      v11 = COM_ERR_6420;
LABEL_15:
      Scr_Error(v11, v10, v9);
      return;
    }
    Float = Scr_GetFloat(scrContext, 2u);
    if ( *(float *)&Float < 0.0 || *(float *)&Float > 1.0 )
    {
      __asm { vxorpd  xmm2, xmm2, xmm2 }
      v9 = j_va("ScaleSoundSubmix: Incorrect scale parameters %.2f- expect [%.2f,%.2f])\n", *(float *)&Float, (_QWORD)_XMM2, DOUBLE_1_0);
      v10 = scrContext;
      v11 = COM_ERR_5930;
      goto LABEL_15;
    }
    v13 = j_va("%c %c %x %f", 90i64, 51i64, v7, *(float *)&Float);
    SV_Game_SendServerCommand(entnum, SV_CMD_RELIABLE, v13);
  }
  else
  {
    Scr_Error(COM_ERR_4820, scrContext, "ScaleSoundSubmix: Incorrect number of parameters - expect: submixname, scale\n");
  }
}

/*
==============
PlayerCmd_ClearSoundSubmix
==============
*/
void PlayerCmd_ClearSoundSubmix(scrContext_t *scrContext, scr_entref_t entref)
{
  int entnum; 
  unsigned int NumParam; 
  const char *String; 
  unsigned int v6; 
  const char *v7; 
  const char *v8; 
  const char *v9; 
  double Float; 
  const char *v11; 
  int outControllingClientNum; 

  entnum = entref.entnum;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam - 1 > 1 )
  {
    Scr_Error(COM_ERR_4822, scrContext, "ClearSoundSubmix: Incorrect number of parameters - expect: duckname [, fadeTime]\n");
  }
  else
  {
    String = Scr_GetString(scrContext, 0);
    v6 = SND_HashName(String);
    if ( !SND_GetDuckById(v6) )
    {
      v7 = j_va("ClearSoundSubmix: bad duck name: '%s'", String);
      Scr_ParamError(COM_ERR_4823, scrContext, 0, v7);
      return;
    }
    if ( SV_GetAgentControlledByPlayerNum(entnum, &outControllingClientNum) )
      entnum = outControllingClientNum;
    if ( entnum >= level.maxclients )
    {
      v8 = j_va("Invalid entity index %d before SV_Game_SendServerCommand\n", (unsigned int)entnum);
      Scr_Error(COM_ERR_6421, scrContext, v8);
      return;
    }
    if ( NumParam == 1 )
    {
      v9 = j_va("%c %c %x", 90i64, 52i64, v6);
    }
    else
    {
      Float = Scr_GetFloat(scrContext, 1u);
      if ( *(float *)&Float < 0.0 && *(float *)&Float != -1.0 )
      {
        v11 = j_va("ClearSoundSubmix: Incorrect fadeTime parameters %.2f- expect >= 0 (or %.2f for asset default)\n", *(float *)&Float, DOUBLE_N1_0);
        Scr_Error(COM_ERR_5666, scrContext, v11);
        return;
      }
      v9 = j_va("%c %c %x %f", 90i64, 55i64, v6, *(float *)&Float);
    }
    SV_Game_SendServerCommand(entnum, SV_CMD_RELIABLE, v9);
  }
}

/*
==============
Scr_AIPhysicsTracePassed
==============
*/
void Scr_AIPhysicsTracePassed(scrContext_t *scrContext, scr_entref_t entref)
{
  int passEntityNum; 
  double Float; 
  float v5; 
  double v6; 
  int v7; 
  int v8; 
  Bounds bounds; 
  vec3_t end; 
  vec3_t vectorValue; 
  trace_t results; 

  passEntityNum = entref.entnum;
  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &end);
  Float = Scr_GetFloat(scrContext, 2u);
  v5 = *(float *)&Float;
  v6 = Scr_GetFloat(scrContext, 3u);
  v7 = 0;
  v8 = Scr_GetNumParam(scrContext) > 4 && Scr_GetInt(scrContext, 4u) == 0;
  bounds.midPoint.v[0] = vec3_origin.v[0];
  bounds.midPoint.v[1] = vec3_origin.v[1];
  bounds.midPoint.v[2] = (float)(*(float *)&v6 * 0.5) + 0.0;
  bounds.halfSize.v[0] = v5;
  bounds.halfSize.v[1] = v5;
  bounds.halfSize.v[2] = *(float *)&v6 * 0.5;
  G_Main_TraceCapsule(&results, &vectorValue, &end, &bounds, passEntityNum, (v8 << 25) + 131089);
  LOBYTE(v7) = results.fraction >= 1.0;
  Scr_AddBool(scrContext, v7);
}

/*
==============
Scr_GetGroundPosition
==============
*/
void Scr_GetGroundPosition(scrContext_t *scrContext)
{
  __m128 v1; 
  double Float; 
  float v5; 
  double v6; 
  vec3_t *p_vectorValue; 
  vec3_t vectorValue; 
  vec3_t start; 
  vec3_t end; 
  float value[4]; 
  Bounds bounds; 
  trace_t results; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  *(double *)v1.m128_u64 = Scr_GetFloat(scrContext, 1u);
  _XMM6 = _mm_shuffle_ps(v1, v1, 0);
  if ( Scr_GetNumParam(scrContext) <= 2 )
  {
    v5 = FLOAT_720_0;
  }
  else
  {
    Float = Scr_GetFloat(scrContext, 2u);
    v5 = *(float *)&Float;
  }
  if ( Scr_GetNumParam(scrContext) <= 3 )
  {
    __asm { vmaxss  xmm4, xmm6, cs:__real@42800000 }
  }
  else
  {
    v6 = Scr_GetFloat(scrContext, 3u);
    LODWORD(_XMM4) = LODWORD(v6);
  }
  end.v[2] = vectorValue.v[2] - v5;
  bounds.midPoint.v[0] = 0.0;
  bounds.midPoint.v[1] = 0.0;
  end.v[0] = vectorValue.v[0];
  end.v[1] = vectorValue.v[1];
  start.v[0] = vectorValue.v[0];
  start.v[1] = vectorValue.v[1];
  start.v[2] = vectorValue.v[2] + *(float *)&_XMM4;
  *(__m128 *)&bounds.midPoint.z = _XMM6;
  G_Main_TraceCapsule(&results, &start, &end, &bounds, 2047, 131089);
  if ( results.startsolid )
  {
    Com_PrintWarning(23, "GetGroundPosition started in solid at (%g %g %g)\n", vectorValue.v[0], vectorValue.v[1], vectorValue.v[2]);
    p_vectorValue = &vectorValue;
  }
  else
  {
    value[0] = (float)((float)(end.v[0] - start.v[0]) * results.fraction) + start.v[0];
    value[1] = (float)((float)(end.v[1] - start.v[1]) * results.fraction) + start.v[1];
    value[2] = (float)((float)(end.v[2] - start.v[2]) * results.fraction) + start.v[2];
    p_vectorValue = (vec3_t *)value;
  }
  Scr_AddVector(scrContext, p_vectorValue->v);
}

/*
==============
PlayerCmd_ClearAllSoundSubmixes
==============
*/
void PlayerCmd_ClearAllSoundSubmixes(scrContext_t *scrContext, scr_entref_t entref)
{
  int entnum; 
  int NumParam; 
  const char *v5; 
  const char *v6; 
  const char *v7; 
  SvClient *CommonClient; 
  double Float; 
  const char *v10; 
  const char *v11; 
  int outControllingClientNum; 

  entnum = entref.entnum;
  if ( SV_GetAgentControlledByPlayerNum(entref.entnum, &outControllingClientNum) )
    entnum = outControllingClientNum;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam <= 2 )
  {
    if ( entnum < level.maxclients )
    {
      if ( NumParam )
      {
        Float = Scr_GetFloat(scrContext, 0);
        if ( *(float *)&Float >= 0.0 || *(float *)&Float == -1.0 )
        {
          v11 = j_va("%c %c %f", 90i64, 54i64, *(float *)&Float);
          SV_Game_SendServerCommand(entnum, SV_CMD_RELIABLE, v11);
        }
        else
        {
          v10 = j_va("ClearAllSoundSubmixes: Incorrect fadeTime parameters %.2f- expect >= 0 (or %.2f for asset default)\n", *(float *)&Float, DOUBLE_N1_0);
          Scr_Error(COM_ERR_5667, scrContext, v10);
        }
      }
      else
      {
        v6 = j_va("%c %c", 90i64, 53i64);
        v7 = v6;
        if ( entnum == -1 )
        {
          SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v6);
        }
        else
        {
          CommonClient = SvClient::GetCommonClient(entnum);
          CommonClient->SendServerCommand(CommonClient, SV_CMD_RELIABLE, v7);
        }
      }
    }
    else
    {
      v5 = j_va("Invalid entity index %d before SV_Game_SendServerCommand\n", (unsigned int)entnum);
      Scr_Error(COM_ERR_6422, scrContext, v5);
    }
  }
  else
  {
    Scr_Error(COM_ERR_4824, scrContext, "ClearAllSoundSubmixes: Incorrect number of parameters - expect: none or optional [fadeTime]\n");
  }
}

/*
==============
GScr_PhysicsSetGravity
==============
*/
void GScr_PhysicsSetGravity(scrContext_t *scrContext)
{
  unsigned int IndexByName; 
  unsigned int v3; 
  unsigned int v4; 
  unsigned int v5; 
  OmnvarData *Data; 
  OmnvarData *v7; 
  OmnvarData *v8; 
  OmnvarData *v9; 
  vec3_t vectorValue; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4254, scrContext, "Physics_SetGravity takes 1 vector parameter");
  Scr_GetVector(scrContext, 0, &vectorValue);
  IndexByName = BG_Omnvar_GetIndexByName("physics_gravity_x");
  v3 = BG_Omnvar_GetIndexByName("physics_gravity_y");
  v4 = BG_Omnvar_GetIndexByName("physics_gravity_z");
  v5 = v4;
  if ( IndexByName == -1 || v3 == -1 || v4 == -1 )
    Scr_Error(COM_ERR_4255, scrContext, "Physics_SetGravity can't find omnvars - check omnvar.csv");
  Data = G_Omnvar_GetData(IndexByName, -1, NULL);
  v7 = G_Omnvar_GetData(v3, -1, NULL);
  v8 = G_Omnvar_GetData(v5, -1, NULL);
  v9 = v8;
  if ( !Data || !v7 || !v8 )
    Scr_Error(COM_ERR_4256, scrContext, "Physics_SetGravity has invalid omnvar data - check omnvar.csv");
  Data->current.value = vectorValue.v[0];
  v7->current.value = vectorValue.v[1];
  v9->current.value = vectorValue.v[2];
  G_Omnvar_MarkChanged(Data);
  G_Omnvar_MarkChanged(v7);
  G_Omnvar_MarkChanged(v9);
}

/*
==============
PlayerCmd_GetSprintMeterFraction
==============
*/
void PlayerCmd_GetSprintMeterFraction(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  const playerState_s *p_ps; 
  const char *v7; 
  GWeaponMap *Instance; 
  int SprintLeftRaw; 
  int MaxSprintTime; 
  float v11; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3678, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 30432, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client && !v4->agent )
    {
      v5 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3677, scrContext, v5);
    }
  }
  p_ps = &v4->client->ps;
  if ( !p_ps )
  {
    p_ps = &v4->agent->playerState;
    if ( !p_ps )
    {
      v7 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3679, scrContext, v7);
    }
  }
  Instance = GWeaponMap::GetInstance();
  SprintLeftRaw = PM_GetSprintLeftRaw(Instance, p_ps, p_ps->serverTime);
  MaxSprintTime = BG_GetMaxSprintTime(Instance, p_ps);
  v11 = 0.0;
  if ( MaxSprintTime > 0 )
    LODWORD(v11) = COERCE_UNSIGNED_INT64(I_fclamp((float)SprintLeftRaw / (float)MaxSprintTime, 0.0, 1.0));
  Scr_AddFloat(scrContext, v11);
}

/*
==============
GScr_PhysicsSetGravityRagdollScalar
==============
*/
void GScr_PhysicsSetGravityRagdollScalar(scrContext_t *scrContext)
{
  double Float; 
  unsigned int IndexByName; 
  OmnvarData *Data; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4257, scrContext, "Physics_SetGravityRagdollScalar takes 1 vector parameter");
  Float = Scr_GetFloat(scrContext, 0);
  if ( COERCE_FLOAT(LODWORD(Float) & _xmm) < 0.0099999998 )
    Scr_Error(COM_ERR_4258, scrContext, "Physics_SetGravityRagdollScalar doesn't support tiny values between -0.01 and 0.01");
  IndexByName = BG_Omnvar_GetIndexByName("physics_gravity_ragdoll");
  if ( IndexByName == -1 )
    Scr_Error(COM_ERR_4259, scrContext, "Physics_SetGravityRagdollScalar can't find omnvars - check omnvar.csv");
  Data = G_Omnvar_GetData(IndexByName, -1, NULL);
  if ( !Data )
    Scr_Error(COM_ERR_4260, scrContext, "Physics_SetGravityRagdollScalar has invalid omnvar data - check omnvar.csv");
  Data->current.value = *(float *)&Float;
  G_Omnvar_MarkChanged(Data);
}

/*
==============
Scr_InitDamageParts
==============
*/

void __fastcall Scr_InitDamageParts(scrContext_t *scrContext, scr_entref_t entref)
{
  InitDamageParts(scrContext, entref);
}

/*
==============
Scr_AddDamagePart
==============
*/

void __fastcall Scr_AddDamagePart(scrContext_t *scrContext, scr_entref_t entref)
{
  AddDamagePart(scrContext, entref);
}

/*
==============
ScrCmd_GetCentroid
==============
*/
void ScrCmd_GetCentroid(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  vec3_t outCentroid; 

  Entity = GetEntity(entref);
  G_Utils_EntityCentroid(Entity, &outCentroid);
  Scr_AddVector(scrContext, outCentroid.v);
}

/*
==============
GScr_PhysicsSetGravityDynentScalar
==============
*/
void GScr_PhysicsSetGravityDynentScalar(scrContext_t *scrContext)
{
  double Float; 
  unsigned int IndexByName; 
  OmnvarData *Data; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4261, scrContext, "Physics_SetGravityDynentScalar takes 1 vector parameter");
  Float = Scr_GetFloat(scrContext, 0);
  if ( COERCE_FLOAT(LODWORD(Float) & _xmm) < 0.0099999998 )
    Scr_Error(COM_ERR_4262, scrContext, "Physics_SetGravityDynentScalar doesn't support tiny values between -0.01 and 0.01");
  IndexByName = BG_Omnvar_GetIndexByName("physics_gravity_dynent");
  if ( IndexByName == -1 )
    Scr_Error(COM_ERR_4263, scrContext, "Physics_SetGravityDynentScalar can't find omnvars - check omnvar.csv");
  Data = G_Omnvar_GetData(IndexByName, -1, NULL);
  if ( !Data )
    Scr_Error(COM_ERR_4264, scrContext, "Physics_SetGravityDynentScalar has invalid omnvar data - check omnvar.csv");
  Data->current.value = *(float *)&Float;
  G_Omnvar_MarkChanged(Data);
}

/*
==============
GScr_SetChargeMeleeHudVisible
==============
*/
void GScr_SetChargeMeleeHudVisible(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  playerState_s *EntityPlayerState; 
  int Int; 
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *p_otherFlags; 

  Entity = GetEntity(entref);
  if ( !Entity )
    Scr_ObjectError(COM_ERR_4825, scrContext, "SetChargeMeleeHudVisible() must be called on a valid entity");
  EntityPlayerState = G_GetEntityPlayerState(Entity);
  if ( !EntityPlayerState )
  {
    Scr_ObjectError(COM_ERR_4826, scrContext, "SetChargeMeleeHudVisible() must be called on a player or agent");
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 30538, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
  }
  Int = Scr_GetInt(scrContext, 0);
  p_otherFlags = &EntityPlayerState->otherFlags;
  if ( Int )
    GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal(p_otherFlags, ACTIVE, 0x13u);
  else
    GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal(p_otherFlags, ACTIVE, 0x13u);
}

/*
==============
GScr_PhysicsSetGravityParticleScalar
==============
*/
void GScr_PhysicsSetGravityParticleScalar(scrContext_t *scrContext)
{
  double Float; 
  unsigned int IndexByName; 
  OmnvarData *Data; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4265, scrContext, "Physics_SetGravityParticleScalar takes 1 vector parameter");
  Float = Scr_GetFloat(scrContext, 0);
  if ( COERCE_FLOAT(LODWORD(Float) & _xmm) < 0.0099999998 )
    Scr_Error(COM_ERR_4266, scrContext, "Physics_SetGravityParticleScalar doesn't support tiny values between -0.01 and 0.01");
  IndexByName = BG_Omnvar_GetIndexByName("physics_gravity_particle");
  if ( IndexByName == -1 )
    Scr_Error(COM_ERR_4267, scrContext, "Physics_SetGravityParticleScalar can't find omnvars - check omnvar.csv");
  Data = G_Omnvar_GetData(IndexByName, -1, NULL);
  if ( !Data )
    Scr_Error(COM_ERR_4268, scrContext, "Physics_SetGravityParticleScalar has invalid omnvar data - check omnvar.csv");
  Data->current.value = *(float *)&Float;
  G_Omnvar_MarkChanged(Data);
}

/*
==============
GScr_Main_RagdollBlendInit
==============
*/
void GScr_Main_RagdollBlendInit(scrContext_t *scrContext, scr_entref_t entref)
{
  ;
}

/*
==============
ScrCmd_GetDebugEye
==============
*/
void ScrCmd_GetDebugEye(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  const sentient_s *sentient; 
  const char *v6; 
  const char *v7; 
  vec3_t vEyePosOut; 

  Entity = GetEntity(entref);
  v4 = Entity;
  sentient = Entity->sentient;
  if ( !sentient )
  {
    v6 = SL_ConvertToString(Entity->classname);
    v7 = j_va("getDebugEye must be called on an AI or player, not on a '%s'", v6);
    Scr_Error(COM_ERR_4827, scrContext, v7);
    sentient = v4->sentient;
  }
  Sentient_GetDebugEyePosition(sentient, &vEyePosOut);
  Scr_AddVector(scrContext, vEyePosOut.v);
}

/*
==============
GScr_PhysicsSetGravityItemScalar
==============
*/
void GScr_PhysicsSetGravityItemScalar(scrContext_t *scrContext)
{
  double Float; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4269, scrContext, "Physics_SetGravityItemScalar takes 1 vector parameter");
  Float = Scr_GetFloat(scrContext, 0);
  if ( COERCE_FLOAT(LODWORD(Float) & _xmm) < 0.0099999998 )
    Scr_Error(COM_ERR_4270, scrContext, "Physics_SetGravityItemScalar doesn't support tiny values between -0.01 and 0.01");
  HavokPhysics_UpdateGravityScalar(PHYSICS_WORLD_ID_FIRST, Physics_GravityType_Item, *(float *)&Float);
}

/*
==============
ScrCmd_GetPlayerLightLevel
==============
*/
void ScrCmd_GetPlayerLightLevel(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  __int16 number; 
  const char *v5; 
  double Normalized; 

  Entity = GetEntity(entref);
  if ( !Entity->client )
    Scr_Error(COM_ERR_4828, scrContext, "GetPlayerLightLevel not called on player character.");
  if ( SV_BotIsBot(Entity->s.number) )
    Scr_Error(COM_ERR_4829, scrContext, "GetPlayerLightLevel cannot be called on a player bot.");
  number = Entity->s.number;
  if ( Entity->s.number >= 24 )
  {
    v5 = j_va("GetPlayerLightLevel only supports %i players (requested for %i)", 24i64, (unsigned int)number);
    Scr_Error(COM_ERR_4830, scrContext, v5);
    number = Entity->s.number;
  }
  Normalized = G_LightSampler_GetNormalized(number);
  Scr_AddFloat(scrContext, *(float *)&Normalized);
}

/*
==============
ScrCmd_DoEntitiesShareHierarchy
==============
*/
void ScrCmd_DoEntitiesShareHierarchy(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  const gentity_s *v3; 
  bool v4; 

  Entity = GScr_GetEntity(0);
  v3 = GScr_GetEntity(1u);
  v4 = GUtils::AreEntsInSameLinkTree(Entity, v3);
  Scr_AddBool(scrContext, v4);
}

/*
==============
Scr_RandomInt
==============
*/
void Scr_RandomInt(scrContext_t *scrContext)
{
  int Int; 
  int v3; 

  Int = Scr_GetInt(scrContext, 0);
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4271, scrContext, "RandomInt takes 1 parameter");
  if ( Int > 0 )
  {
    v3 = G_irand(0, Int);
    Scr_AddInt(scrContext, v3);
  }
  else
  {
    Com_Printf(23, "RandomInt parm: %d  ", (unsigned int)Int);
    Scr_Error(COM_ERR_4272, scrContext, "RandomInt parm must be positive integer.\n");
  }
}

/*
==============
ScrCmd_MotionWarp
==============
*/
void ScrCmd_MotionWarp(scrContext_t *scrContext, scr_entref_t entref)
{
  int entnum; 
  int Int; 
  const char *v5; 
  vec3_t targetAngles; 
  vec3_t vectorValue; 

  entnum = entref.entnum;
  if ( Scr_GetNumParam(scrContext) != 3 )
    Scr_Error(COM_ERR_4831, scrContext, "Incorrect number of parameters.");
  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &targetAngles);
  Int = Scr_GetInt(scrContext, 2u);
  if ( !level.frameDuration && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_level_locals.h", 349, ASSERT_TYPE_ASSERT, "(level.frameDuration)", "%s\n\tAccessing frame duration before it's been set", "level.frameDuration") )
    __debugbreak();
  if ( Int < level.frameDuration )
  {
    v5 = j_va("Motion warp duration (%i ms) must be at least one frame (%i ms).", (unsigned int)Int, (unsigned int)level.frameDuration);
    Scr_Error(COM_ERR_4832, scrContext, v5);
  }
  if ( G_MotionWarp_TrackerIsFull() )
    Scr_Error(COM_ERR_4833, scrContext, "Max tracked entities exceeded.");
  else
    G_MotionWarp_Start(entnum, &vectorValue, &targetAngles, Int);
}

/*
==============
Scr_RandomFloat
==============
*/
void Scr_RandomFloat(scrContext_t *scrContext)
{
  double Float; 
  double v3; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4273, scrContext, "RandomFloat takes 1 parameter");
  Float = Scr_GetFloat(scrContext, 0);
  v3 = G_flrand(0.0, *(float *)&Float);
  Scr_AddFloat(scrContext, *(float *)&v3);
}

/*
==============
Scr_RandomIntRange
==============
*/
void Scr_RandomIntRange(scrContext_t *scrContext)
{
  int Int; 
  int v3; 
  int v4; 
  int v5; 

  Int = Scr_GetInt(scrContext, 0);
  v3 = Scr_GetInt(scrContext, 1u);
  v4 = v3;
  if ( v3 <= Int )
  {
    Com_Printf(23, "RandomIntRange parms: %d %d ", (unsigned int)Int, (unsigned int)v3);
    Scr_Error(COM_ERR_4274, scrContext, "RandomIntRange's second parameter must be greater than the first.\n");
  }
  v5 = G_irand(Int, v4);
  Scr_AddInt(scrContext, v5);
}

/*
==============
ScrCmd_MotionWarpWithAnim
==============
*/
void ScrCmd_MotionWarpWithAnim(scrContext_t *scrContext, scr_entref_t entref)
{
  int entnum; 
  int duration; 
  const char *v5; 
  vec3_t targetAngles; 
  vec3_t targetPos; 
  vec3_t animStartAngles; 
  vec3_t vectorValue; 

  entnum = entref.entnum;
  if ( Scr_GetNumParam(scrContext) != 5 )
    Scr_Error(COM_ERR_4834, scrContext, "Incorrect number of parameters.");
  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &animStartAngles);
  Scr_GetVector(scrContext, 2u, &targetPos);
  Scr_GetVector(scrContext, 3u, &targetAngles);
  duration = Scr_GetInt(scrContext, 4u);
  if ( !level.frameDuration && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_level_locals.h", 349, ASSERT_TYPE_ASSERT, "(level.frameDuration)", "%s\n\tAccessing frame duration before it's been set", "level.frameDuration") )
    __debugbreak();
  if ( duration < level.frameDuration )
  {
    v5 = j_va("Motion warp duration (%i ms) must be at least one frame (%i ms).", (unsigned int)duration, (unsigned int)level.frameDuration);
    Scr_Error(COM_ERR_4835, scrContext, v5);
  }
  if ( G_MotionWarp_TrackerIsFull() )
    Scr_Error(COM_ERR_4836, scrContext, "Max tracked entities exceeded.");
  else
    G_MotionWarp_StartWithAnim(entnum, &vectorValue, &animStartAngles, &targetPos, &targetAngles, duration);
}

/*
==============
Scr_RandomFloatRange
==============
*/
void Scr_RandomFloatRange(scrContext_t *scrContext)
{
  double Float; 
  float v3; 
  double v4; 

  Float = Scr_GetFloat(scrContext, 0);
  v3 = *(float *)&Float;
  v4 = Scr_GetFloat(scrContext, 1u);
  if ( *(float *)&v4 <= v3 )
  {
    Com_Printf(23, "Scr_RandomFloatRange parms: %f %f ", v3, *(float *)&v4);
    Scr_Error(COM_ERR_4275, scrContext, "Scr_RandomFloatRange's second parameter must be greater than the first.\n");
  }
  G_flrand(v3, *(float *)&v4);
  Scr_AddFloat(scrContext, v3);
}

/*
==============
GScr_IsPointInVolume
==============
*/
void GScr_IsPointInVolume(scrContext_t *scrContext)
{
  const gentity_s *Entity; 
  unsigned int Instance; 
  int v4; 
  vec3_t vectorValue; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  Entity = GScr_GetEntity(1u);
  Instance = G_PhysicsObject_GetInstance(PHYSICS_WORLD_ID_FIRST, Entity);
  v4 = PhysicsQuery_LegacyEntityContactPoint(PHYSICS_WORLD_ID_FIRST, &vectorValue, Instance, Entity);
  Scr_AddInt(scrContext, v4);
}

/*
==============
ScrCmd_MotionWarpCancel
==============
*/
void ScrCmd_MotionWarpCancel(scrContext_t *scrContext, scr_entref_t entref)
{
  G_MotionWarp_Cancel(entref.entnum);
}

/*
==============
ScrCmd_IsNearAnyPlayer
==============
*/
void ScrCmd_IsNearAnyPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  double Float; 
  int v5; 
  int v6; 
  __int64 v7; 
  __int64 v8; 
  float v9; 
  float v10; 
  float v11; 
  __int64 v12; 
  __int64 v13; 

  Entity = GetEntity(entref);
  Float = Scr_GetFloat(scrContext, 0);
  v5 = 0;
  v6 = 0;
  if ( level.maxclients > 0 )
  {
    v7 = 0i64;
    v8 = 0i64;
    while ( 1 )
    {
      if ( (unsigned int)v6 >= 0x800 )
      {
        LODWORD(v13) = 2048;
        LODWORD(v12) = v6;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v12, v13) )
          __debugbreak();
      }
      if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
        __debugbreak();
      if ( g_entities[v7].r.isInUse != g_entityIsInUse[v8] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
        __debugbreak();
      if ( g_entityIsInUse[v8] )
      {
        v9 = g_entities[v7].r.currentOrigin.v[0] - Entity->r.currentOrigin.v[0];
        v10 = g_entities[v7].r.currentOrigin.v[1] - Entity->r.currentOrigin.v[1];
        v11 = g_entities[v7].r.currentOrigin.v[2] - Entity->r.currentOrigin.v[2];
        if ( (float)((float)((float)(v10 * v10) + (float)(v9 * v9)) + (float)(v11 * v11)) < (float)(*(float *)&Float * *(float *)&Float) )
          break;
      }
      ++v6;
      ++v8;
      ++v7;
      if ( v6 >= level.maxclients )
        goto LABEL_17;
    }
    v5 = 1;
  }
LABEL_17:
  Scr_AddBool(scrContext, v5);
}

/*
==============
GScr_UseTriggerRequireLookAt
==============
*/
void GScr_UseTriggerRequireLookAt(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t classname; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    Entity = GetEntity(entref);
    if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 12563, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
      __debugbreak();
    classname = Entity->classname;
    if ( classname != scr_const.trigger_use && classname != scr_const.trigger_use_touch )
      Scr_Error(COM_ERR_4277, scrContext, "The UseTriggerRequireLookAt command only works on trigger_use and trigger_use_touch entities.\n");
    Entity->c.trigger.requireLookAt = Scr_GetInt(scrContext, 0) != 0;
  }
  else
  {
    Scr_Error(COM_ERR_4276, scrContext, "USAGE: <trigger_use|trigger_use_touch> UseTriggerRequireLookAt( <bool> )\n");
  }
}

/*
==============
GScr_Turret_SetDismountOrg
==============
*/
void GScr_Turret_SetDismountOrg(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v6; 
  const char *v7; 
  GTurret *Turret; 
  vec3_t vectorValue; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v6 = SL_ConvertToString(Entity->classname);
    v7 = j_va("entity type '%s' is not a turret", v6);
    Scr_Error(COM_ERR_4837, scrContext, v7);
  }
  Turret = GTurret::GetTurret(p_turretHandle);
  Turret->m_data.userOrigin = vectorValue;
}

/*
==============
GScr_GetGroundEntity
==============
*/
void GScr_GetGroundEntity(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  playerState_s *EntityPlayerState; 
  signed __int16 GroundEntNum; 
  AIWrapper v6; 

  Entity = GetEntity(entref);
  EntityPlayerState = G_GetEntityPlayerState(Entity);
  AIActorInterface::AIActorInterface(&v6.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v6.m_newAgentInterface);
  v6.m_pAI = NULL;
  v6.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AIWrapper::Setup(&v6, Entity);
  if ( v6.m_pAI )
  {
    GroundEntNum = AIScriptedInterface::GetGroundEntNum(v6.m_pAI);
  }
  else
  {
    if ( !EntityPlayerState )
    {
LABEL_11:
      Scr_AddUndefined(scrContext);
      return;
    }
    GroundEntNum = EntityPlayerState->groundEntityNum;
  }
  if ( GroundEntNum == 2047 || !G_IsEntityInUse(GroundEntNum) )
    goto LABEL_11;
  if ( (unsigned __int16)GroundEntNum >= 0x800u && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 30954, ASSERT_TYPE_ASSERT, "(unsigned)( groundEntityNum ) < (unsigned)( ( 2048 ) )", "groundEntityNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", GroundEntNum, 2048) )
    __debugbreak();
  GScr_AddEntity(&g_entities[GroundEntNum]);
}

/*
==============
Scr_PrecacheModel
==============
*/
void Scr_PrecacheModel(scrContext_t *scrContext)
{
  const char *String; 
  int CompositeModelIndex; 
  const XCompositeModelDef *CompositeModel; 

  if ( NetConstStrings_IsPrecacheAllowed() )
  {
    if ( !level.initializing )
      Scr_Error(COM_ERR_4279, scrContext, "precacheModel must be called before any wait statements in the gametype or level script\n");
    String = Scr_GetString(scrContext, 0);
    if ( !*String )
      Scr_ParamError(COM_ERR_4280, scrContext, 0, "Model name string is empty");
    if ( !GUtils::ms_gUtils && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_utils.h", 112, ASSERT_TYPE_ASSERT, "( ms_gUtils )", (const char *)&queryFormat, "ms_gUtils") )
      __debugbreak();
    if ( GUtils::ms_gUtils->IsTransientCustomizationModel(GUtils::ms_gUtils, String) )
      Scr_Error(COM_ERR_4281, scrContext, "Can't precache transient models");
    if ( G_Utils_IsNameCompositeModel(String) )
    {
      CompositeModelIndex = G_CString_GetCompositeModelIndex(String);
      CompositeModel = G_Utils_GetCompositeModel(CompositeModelIndex);
      if ( CompositeModel )
        G_XCompositeModel_PrecacheModels(CompositeModel);
    }
    else
    {
      Scr_ErrorOnDefaultAsset(scrContext, ASSET_TYPE_XMODEL, String);
      if ( !GConfigStrings::ms_gConfigStrings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_configstrings.h", 71, ASSERT_TYPE_ASSERT, "( ms_gConfigStrings )", (const char *)&queryFormat, "ms_gConfigStrings") )
        __debugbreak();
      GConfigStrings::GetModelIndex(GConfigStrings::ms_gConfigStrings, String);
    }
  }
}

/*
==============
Scr_PrecacheCompositeModel
==============
*/
void Scr_PrecacheCompositeModel(scrContext_t *scrContext)
{
  const char *String; 
  int CompositeModelIndex; 
  const XCompositeModelDef *CompositeModel; 

  if ( NetConstStrings_IsPrecacheAllowed() )
  {
    if ( !level.initializing )
      Scr_Error(COM_ERR_4282, scrContext, "precacheCompositeModel must be called before any wait statements in the gametype or level script\n");
    String = Scr_GetString(scrContext, 0);
    if ( !*String )
      Scr_ParamError(COM_ERR_4283, scrContext, 0, "Model name string is empty");
    CompositeModelIndex = G_CString_GetCompositeModelIndex(String);
    CompositeModel = G_Utils_GetCompositeModel(CompositeModelIndex);
    if ( CompositeModel )
      G_XCompositeModel_PrecacheModels(CompositeModel);
  }
}

/*
==============
GScr_IsEntityWithinCone
==============
*/
void GScr_IsEntityWithinCone(scrContext_t *scrContext, scr_entref_t entref)
{
  int NumParam; 
  gentity_s *Entity; 
  double Float; 
  float v7; 
  char *p_box; 
  float v9; 
  float v10; 
  float v11; 
  double v12; 
  int v13; 
  vec3_t coneDir; 
  Bounds bounds; 
  vec3_t vectorValue; 
  tmat33_t<vec3_t> axis; 
  char v18; 

  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam < 3 )
    Scr_Error(COM_ERR_4838, scrContext, "Incorrect number of parameters.");
  Entity = GetEntity(entref);
  if ( Entity )
  {
    Float = Scr_GetFloat(scrContext, 2u);
    v7 = *(float *)&Float * 0.017453292;
    cosf_0(*(float *)&Float * 0.017453292);
    Scr_GetVector(scrContext, 0, &vectorValue);
    Scr_GetVector(scrContext, 1u, &coneDir);
    AnglesToAxis(&Entity->r.currentAngles, &axis);
    p_box = (char *)&Entity->r.box;
    if ( &bounds == &Entity->r.box && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\bounds_inline.h", 218, ASSERT_TYPE_ASSERT, "( rotatedBounds != baseBounds )", (const char *)&queryFormat, "rotatedBounds != baseBounds") )
      __debugbreak();
    if ( p_box == &v18 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_math.h", 470, ASSERT_TYPE_SANITY, "( &in1 != &out )", (const char *)&queryFormat, "&in1 != &out") )
      __debugbreak();
    v9 = Entity->r.box.midPoint.v[1];
    v10 = *(float *)p_box;
    v11 = Entity->r.box.midPoint.v[2];
    bounds.midPoint.v[0] = (float)((float)((float)(*(float *)p_box * axis.m[0].v[0]) + (float)(v9 * axis.m[1].v[0])) + (float)(v11 * axis.m[2].v[0])) + Entity->r.currentOrigin.v[0];
    bounds.midPoint.v[1] = (float)((float)((float)(v10 * axis.m[0].v[1]) + (float)(v9 * axis.m[1].v[1])) + (float)(v11 * axis.m[2].v[1])) + Entity->r.currentOrigin.v[1];
    bounds.midPoint.v[2] = (float)((float)((float)(v10 * axis.m[0].v[2]) + (float)(v9 * axis.m[1].v[2])) + (float)(v11 * axis.m[2].v[2])) + Entity->r.currentOrigin.v[2];
    bounds.halfSize.v[0] = (float)((float)(COERCE_FLOAT(LODWORD(axis.m[0].v[0]) & _xmm) * Entity->r.box.halfSize.v[0]) + (float)(COERCE_FLOAT(LODWORD(axis.m[1].v[0]) & _xmm) * Entity->r.box.halfSize.v[1])) + (float)(COERCE_FLOAT(LODWORD(axis.m[2].v[0]) & _xmm) * Entity->r.box.halfSize.v[2]);
    bounds.halfSize.v[1] = (float)((float)(COERCE_FLOAT(LODWORD(axis.m[0].v[1]) & _xmm) * Entity->r.box.halfSize.v[0]) + (float)(COERCE_FLOAT(LODWORD(axis.m[1].v[1]) & _xmm) * Entity->r.box.halfSize.v[1])) + (float)(COERCE_FLOAT(LODWORD(axis.m[2].v[1]) & _xmm) * Entity->r.box.halfSize.v[2]);
    bounds.halfSize.v[2] = (float)((float)(COERCE_FLOAT(LODWORD(axis.m[0].v[2]) & _xmm) * Entity->r.box.halfSize.v[0]) + (float)(COERCE_FLOAT(LODWORD(axis.m[1].v[2]) & _xmm) * Entity->r.box.halfSize.v[1])) + (float)(COERCE_FLOAT(LODWORD(axis.m[2].v[2]) & _xmm) * Entity->r.box.halfSize.v[2]);
    if ( NumParam >= 4 && Scr_GetType(scrContext, 3u) && (v12 = Scr_GetFloat(scrContext, 3u), *(float *)&v12 > 0.0) && (float)(fsqrt((float)((float)((float)(vectorValue.v[1] - bounds.midPoint.v[1]) * (float)(vectorValue.v[1] - bounds.midPoint.v[1])) + (float)((float)(vectorValue.v[0] - bounds.midPoint.v[0]) * (float)(vectorValue.v[0] - bounds.midPoint.v[0]))) + (float)((float)(vectorValue.v[2] - bounds.midPoint.v[2]) * (float)(vectorValue.v[2] - bounds.midPoint.v[2]))) - fsqrt((float)((float)(bounds.halfSize.v[0] * bounds.halfSize.v[0]) + (float)(bounds.halfSize.v[1] * bounds.halfSize.v[1])) + (float)(bounds.halfSize.v[2] * bounds.halfSize.v[2]))) > *(float *)&v12 )
    {
      v13 = 0;
    }
    else
    {
      LODWORD(coneDir.v[0]) ^= _xmm;
      LODWORD(coneDir.v[2]) ^= _xmm;
      LODWORD(coneDir.v[1]) ^= _xmm;
      v13 = !CullBoxFromCone(&vectorValue, &coneDir, v7, &bounds);
    }
    Scr_AddBool(scrContext, v13);
  }
}

/*
==============
GScr_PrecacheSuit
==============
*/
void GScr_PrecacheSuit(scrContext_t *scrContext)
{
  const char *String; 

  String = Scr_GetString(scrContext, 0);
  Com_Printf(15, "PreCacheSuit() is deprecated, suits automatically register. Please delete this script call (%s)\n", String);
}

/*
==============
ScrCmd_StopLoopSound
==============
*/
void ScrCmd_StopLoopSound(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  Entity->r.svFlags &= ~1u;
  Entity->s.loopSound = 0;
}

/*
==============
GScr_CameraDefault
==============
*/
void GScr_CameraDefault(scrContext_t *scrContext, scr_entref_t entref)
{
  gclient_s *client; 
  int cameraTypeIndex; 
  const CameraDef *Def; 

  client = GScr_Main_GetPlayerEntity(scrContext, entref)->client;
  cameraTypeIndex = client->ps.cameraTypeIndex;
  if ( cameraTypeIndex && cameraTypeIndex < 256 && (unsigned int)(cameraTypeIndex - 1) < 0xFA )
  {
    Def = BG_Camera_GetDef(cameraTypeIndex);
    if ( !Def && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31070, ASSERT_TYPE_ASSERT, "(camDef)", (const char *)&queryFormat, "camDef") )
      __debugbreak();
    if ( Def->behaveAsRemoteCont )
      GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(&client->ps.pm_flags, ACTIVE, 0x1Cu);
  }
  client->ps.cameraTypeIndex = 0;
}

/*
==============
ScrCmd_PlayRumbleOnEntity
==============
*/
void ScrCmd_PlayRumbleOnEntity(scrContext_t *scrContext, scr_entref_t entref)
{
  ScrCmd_PlayRumbleOnEntity_Internal(scrContext, entref, 148);
}

/*
==============
ScrCmd_PlayRumbleLoopOnEntity
==============
*/
void ScrCmd_PlayRumbleLoopOnEntity(scrContext_t *scrContext, scr_entref_t entref)
{
  ScrCmd_PlayRumbleOnEntity_Internal(scrContext, entref, 150);
}

/*
==============
GScr_CameraSet
==============
*/
void GScr_CameraSet(scrContext_t *scrContext, scr_entref_t entref)
{
  gclient_s *client; 
  scr_string_t ConstString; 
  const char *v5; 
  const char *v6; 
  unsigned int v7; 
  const CameraDef *Def; 
  __int64 v9; 
  unsigned int outIndex; 

  client = GScr_Main_GetPlayerEntity(scrContext, entref)->client;
  ConstString = Scr_GetConstString(scrContext, 0);
  if ( !ConstString && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31101, ASSERT_TYPE_ASSERT, "(camera != ( static_cast< scr_string_t >( 0 ) ))", (const char *)&queryFormat, "camera != NULL_SCR_STRING") )
    __debugbreak();
  v5 = SL_ConvertToString(ConstString);
  if ( !v5 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31104, ASSERT_TYPE_ASSERT, "(cameraName)", (const char *)&queryFormat, "cameraName") )
    __debugbreak();
  outIndex = 0;
  if ( BG_Camera_GetDefIndex(v5, &outIndex) )
  {
    v7 = outIndex;
    if ( !CameraType_Is_Def(outIndex) )
    {
      LODWORD(v9) = v7;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31112, ASSERT_TYPE_ASSERT, "( CameraType_Is_Def( cameraDefIndex ) )", "Camera index (%d) does not reference an asset def or there are more than %d camera assets", v9, 250) )
        __debugbreak();
      v7 = outIndex;
    }
    client->ps.cameraTypeIndex = v7;
    Def = BG_Camera_GetDef(outIndex);
    if ( !Def && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31117, ASSERT_TYPE_ASSERT, "(camDef)", (const char *)&queryFormat, "camDef") )
      __debugbreak();
    if ( Def->behaveAsRemoteCont )
      GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::SetFlagInternal(&client->ps.pm_flags, ACTIVE, 0x1Cu);
  }
  else
  {
    v6 = j_va("Camera name not found (%s). Call CameraDefault() if you want to disable a camera.\n", v5);
    Scr_Error(COM_ERR_6091, scrContext, v6);
  }
}

/*
==============
Scr_PlayRumbleOnPosition
==============
*/
void Scr_PlayRumbleOnPosition(scrContext_t *scrContext)
{
  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_ParamError(COM_ERR_4287, scrContext, 0, "PlayRumbleOnPosition [rumble name] [pos]");
  Scr_PlayRumbleOnPosition_Internal(scrContext, 149);
}

/*
==============
Scr_PlayRumbleLoopOnPosition
==============
*/
void Scr_PlayRumbleLoopOnPosition(scrContext_t *scrContext)
{
  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_ParamError(COM_ERR_4288, scrContext, 0, "PlayRumbleLoopOnPosition [rumble name] [pos]");
  Scr_PlayRumbleOnPosition_Internal(scrContext, 151);
}

/*
==============
Scr_PlayRumbleOnPositionForClient
==============
*/
void Scr_PlayRumbleOnPositionForClient(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  gentity_s *v6; 
  unsigned int number; 
  unsigned int *v8; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 12888, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_ParamError(COM_ERR_4289, scrContext, 0, "PlayRumbleOnPositionForClient [rumble name] [pos]");
  v6 = Scr_PlayRumbleOnPosition_Internal(scrContext, 149);
  *(_QWORD *)v6->clientMask.array = -1i64;
  *(_QWORD *)&v6->clientMask.array[2] = -1i64;
  *(_QWORD *)&v6->clientMask.array[4] = -1i64;
  v6->clientMask.array[6] = -1;
  number = v4->s.number;
  if ( number >= 0xE0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 290, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", number, 224) )
    __debugbreak();
  v8 = &v6->clientMask.array[(unsigned __int64)number >> 5];
  *v8 &= ~(0x80000000 >> (number & 0x1F));
}

/*
==============
Scr_PlayRumbleLoopOnPositionForClient
==============
*/
void Scr_PlayRumbleLoopOnPositionForClient(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  gentity_s *v6; 
  unsigned int number; 
  unsigned int *v8; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 12920, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_ParamError(COM_ERR_4290, scrContext, 0, "PlayRumbleLoopOnPositionForClient [rumble name] [pos]");
  v6 = Scr_PlayRumbleOnPosition_Internal(scrContext, 151);
  *(_QWORD *)v6->clientMask.array = -1i64;
  *(_QWORD *)&v6->clientMask.array[2] = -1i64;
  *(_QWORD *)&v6->clientMask.array[4] = -1i64;
  v6->clientMask.array[6] = -1;
  number = v4->s.number;
  if ( number >= 0xE0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 290, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", number, 224) )
    __debugbreak();
  v8 = &v6->clientMask.array[(unsigned __int64)number >> 5];
  *v8 &= ~(0x80000000 >> (number & 0x1F));
}

/*
==============
ScrCmd_GetBoundsHalfSize
==============
*/
void ScrCmd_GetBoundsHalfSize(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31138, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  Scr_AddVector(scrContext, Entity->r.box.halfSize.v);
}

/*
==============
Scr_StopAllRumbles
==============
*/
void Scr_StopAllRumbles(scrContext_t *scrContext)
{
  gentity_s *v1; 
  vec3_t origin; 

  origin.v[0] = 0.0;
  origin.v[1] = 0.0;
  origin.v[2] = 0.0;
  v1 = G_Utils_SpawnEventEntity(&origin, 153);
  v1->s.eventParm2 = 0;
  v1->s.eventParm = 0;
}

/*
==============
ScrCmd_StopRumble
==============
*/
void ScrCmd_StopRumble(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *String; 
  const char *v5; 
  gclient_s *client; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *p_eFlags; 
  unsigned int outIndex; 

  Entity = GetEntity(entref);
  String = Scr_GetString(scrContext, 0);
  if ( !NetConstStrings_GetIndexFromName(NETCONSTSTRINGTYPE_RUMBLE, String, &outIndex) )
  {
    v5 = j_va("unknown rumble name '%s'", String);
    Scr_ParamError(COM_ERR_4291, scrContext, 0, v5);
  }
  Entity->r.svFlags &= ~1u;
  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    client = Entity->client;
    if ( client )
      p_eFlags = &client->ps.eFlags;
    else
      p_eFlags = &Entity->s.lerp.eFlags;
    GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(p_eFlags, GameModeFlagValues::ms_mpValue, 0x17u);
    G_Utils_AddEvent(Entity, 0x98u, outIndex);
  }
  else
  {
    Scr_Error(COM_ERR_4292, scrContext, "USAGE: StopRumble( <rumblename> )  The rumble name is required.\n");
  }
}

/*
==============
ScrCmd_GetBoundsMidPoint
==============
*/
void ScrCmd_GetBoundsMidPoint(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31156, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  Scr_AddVector(scrContext, Entity->r.box.midPoint.v);
}

/*
==============
GScr_TriggerEnable
==============
*/
void GScr_TriggerEnable(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *v4; 
  scr_string_t classname; 

  Entity = GetEntity(entref);
  v4 = (GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *)Entity;
  if ( Entity )
  {
    classname = Entity->classname;
    if ( classname == scr_const.trigger || classname == scr_const.trigger_progress || classname == scr_const.trigger_use || classname == scr_const.trigger_use_touch || classname == scr_const.trigger_damage || classname == scr_const.trigger_multiple || classname == scr_const.trigger_disk || classname == scr_const.trigger_hurt || classname == scr_const.trigger_once || classname == scr_const.trigger_radius || classname == scr_const.trigger_rotatable_radius )
      GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(v4 + 3, ACTIVE, 0);
    else
      Scr_Error(COM_ERR_4845, scrContext, "EnableTriggerForPlayer was not called on an entity of trigger type.");
  }
  else
  {
    Scr_Error(COM_ERR_4844, scrContext, "TriggerEnable was not called on an entity.");
  }
}

/*
==============
GScr_WeaponClipSize
==============
*/
void GScr_WeaponClipSize(scrContext_t *scrContext)
{
  int ClipSize; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  ClipSize = BG_GetClipSize(NULL, &outWeapon, outIsAlternate);
  Scr_AddInt(scrContext, ClipSize);
}

/*
==============
GScr_WeaponGetDamageMax
==============
*/
void GScr_WeaponGetDamageMax(scrContext_t *scrContext)
{
  int Damage; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  Damage = BG_GetDamage(WEAP_DMG_CALC_TYPE_DEFAULT, &outWeapon, outIsAlternate);
  Scr_AddInt(scrContext, Damage);
}

/*
==============
GScr_TriggerDisable
==============
*/
void GScr_TriggerDisable(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *v4; 
  scr_string_t classname; 

  Entity = GetEntity(entref);
  v4 = (GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *)Entity;
  if ( Entity )
  {
    classname = Entity->classname;
    if ( classname == scr_const.trigger || classname == scr_const.trigger_progress || classname == scr_const.trigger_use || classname == scr_const.trigger_use_touch || classname == scr_const.trigger_damage || classname == scr_const.trigger_multiple || classname == scr_const.trigger_disk || classname == scr_const.trigger_hurt || classname == scr_const.trigger_once || classname == scr_const.trigger_radius || classname == scr_const.trigger_rotatable_radius )
      GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(v4 + 3, ACTIVE, 0);
    else
      Scr_Error(COM_ERR_4847, scrContext, "TriggerDisable was not called on an entity of trigger type.");
  }
  else
  {
    Scr_Error(COM_ERR_4846, scrContext, "TriggerDisable was not called on an entity.");
  }
}

/*
==============
GScr_GetGrenadeFuseTime
==============
*/
void GScr_GetGrenadeFuseTime(scrContext_t *scrContext)
{
  int v2; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( !BG_IsOffhandWeaponType(&outWeapon, outIsAlternate) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 13069, ASSERT_TYPE_ASSERT, "(BG_IsOffhandWeaponType( weapon, isAlternate ))", "%s\n\tWeapon param for GetGrenadeFuseTime( <weapon name> ) must be of type offhand", "BG_IsOffhandWeaponType( weapon, isAlternate )") )
    __debugbreak();
  v2 = BG_WeaponFuseTime(&outWeapon, outIsAlternate);
  Scr_AddInt(scrContext, v2);
}

/*
==============
GScr_IsTriggerEnabled
==============
*/
void GScr_IsTriggerEnabled(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *v4; 
  scr_string_t classname; 
  bool v6; 

  Entity = GetEntity(entref);
  v4 = (GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *)Entity;
  if ( Entity )
  {
    classname = Entity->classname;
    if ( classname == scr_const.trigger || classname == scr_const.trigger_progress || classname == scr_const.trigger_use || classname == scr_const.trigger_use_touch || classname == scr_const.trigger_damage || classname == scr_const.trigger_multiple || classname == scr_const.trigger_disk || classname == scr_const.trigger_hurt || classname == scr_const.trigger_once || classname == scr_const.trigger_radius || classname == scr_const.trigger_rotatable_radius )
    {
      v6 = GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(v4 + 3, ACTIVE, 0);
      Scr_AddInt(scrContext, !v6);
    }
    else
    {
      Scr_Error(COM_ERR_4849, scrContext, "IsTriggerEnabled was not called on an entity of trigger type.");
    }
  }
  else
  {
    Scr_Error(COM_ERR_4848, scrContext, "IsTriggerEnabled was not called on an entity.");
  }
}

/*
==============
GScr_GetGrenadeFuseTimeAI
==============
*/
void GScr_GetGrenadeFuseTimeAI(scrContext_t *scrContext)
{
  int v2; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( !BG_IsOffhandWeaponType(&outWeapon, outIsAlternate) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 13091, ASSERT_TYPE_ASSERT, "(BG_IsOffhandWeaponType( weapon, isAlternate ))", "%s\n\tWeapon param for GetGrenadeFuseTimeAI( <weapon name> ) must be of type offhand", "BG_IsOffhandWeaponType( weapon, isAlternate )") )
    __debugbreak();
  v2 = BG_WeaponAIFuseTime(&outWeapon, outIsAlternate);
  Scr_AddInt(scrContext, v2);
}

/*
==============
GScr_Skydive_BeginFreefall
==============
*/
void GScr_Skydive_BeginFreefall(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  playerState_s *EntityPlayerState; 

  entnum = entref.entnum;
  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31297, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( G_Utils_IsClient(Entity) )
  {
    EntityPlayerState = G_GetEntityPlayerState(Entity);
    if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31306, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
      __debugbreak();
    GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::SetFlagInternal(&EntityPlayerState->pm_flags, ACTIVE, 0x2Fu);
  }
  else
  {
    targetname = Entity->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(Entity->classname);
    v8 = j_va("Skydive_BeginFreefall(). Only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, Entity->r.currentOrigin.v[0], Entity->r.currentOrigin.v[1], Entity->r.currentOrigin.v[2], v7, v6);
    Scr_Error(COM_ERR_4850, scrContext, v8);
  }
}

/*
==============
GScr_GetGrenadeDamageRadius
==============
*/
void GScr_GetGrenadeDamageRadius(scrContext_t *scrContext)
{
  int v2; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( !BG_IsOffhandWeaponType(&outWeapon, outIsAlternate) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 13113, ASSERT_TYPE_ASSERT, "(BG_IsOffhandWeaponType( weapon, isAlternate ))", "%s\n\tWeapon param for GetGrenadeDamageRadius( <weapon name> ) must be of type offhand", "BG_IsOffhandWeaponType( weapon, isAlternate )") )
    __debugbreak();
  v2 = BG_ExplosionRadius(&outWeapon, outIsAlternate);
  Scr_AddInt(scrContext, v2);
}

/*
==============
GScr_WeaponGetDamageMin
==============
*/
void GScr_WeaponGetDamageMin(scrContext_t *scrContext)
{
  int MinDamage; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  MinDamage = BG_GetMinDamage(WEAP_DMG_CALC_TYPE_DEFAULT, &outWeapon, outIsAlternate);
  Scr_AddInt(scrContext, MinDamage);
}

/*
==============
GScr_Skydive_DeployParachute
==============
*/
void GScr_Skydive_DeployParachute(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  playerState_s *EntityPlayerState; 

  entnum = entref.entnum;
  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31325, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( G_Utils_IsClient(Entity) )
  {
    EntityPlayerState = G_GetEntityPlayerState(Entity);
    if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31334, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
      __debugbreak();
    GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::SetFlagInternal(&EntityPlayerState->pm_flags, ACTIVE, 0x30u);
  }
  else
  {
    targetname = Entity->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(Entity->classname);
    v8 = j_va("Skydive_DeployParachute(). Only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, Entity->r.currentOrigin.v[0], Entity->r.currentOrigin.v[1], Entity->r.currentOrigin.v[2], v7, v6);
    Scr_Error(COM_ERR_4851, scrContext, v8);
  }
}

/*
==============
ScrCmd_ItemWeaponSetAmmo
==============
*/
void ScrCmd_ItemWeaponSetAmmo(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  int v5; 
  int v6; 
  int v7; 
  const char *v8; 
  char *v9; 
  bool v10; 
  int ClipSize; 
  int v12; 

  Entity = GetEntity(entref);
  if ( Entity->s.eType != ET_ITEM )
    Scr_Error(COM_ERR_4293, scrContext, "Entity is not an item.");
  Int = Scr_GetInt(scrContext, 0);
  if ( Int < 0 )
    Scr_ParamError(COM_ERR_4294, scrContext, 0, "Ammo count must not be negative");
  v5 = Scr_GetInt(scrContext, 1u);
  if ( v5 < 0 )
    Scr_ParamError(COM_ERR_4295, scrContext, 1u, "Ammo count must not be negative");
  v6 = Int;
  if ( Scr_GetNumParam(scrContext) > 2 )
  {
    v6 = Scr_GetInt(scrContext, 2u);
    if ( v6 < 0 )
      Scr_ParamError(COM_ERR_4296, scrContext, 2u, "Ammo count must not be negative");
  }
  v7 = 0;
  if ( Scr_GetNumParam(scrContext) > 3 )
  {
    v7 = Scr_GetInt(scrContext, 3u);
    if ( (unsigned int)v7 > 1 )
    {
      v8 = j_va("Value out of range.  Allowed values: 0 to %i", 2i64);
      Scr_ParamError(COM_ERR_4297, scrContext, 3u, v8);
    }
  }
  v9 = (char *)Entity + 80 * v7;
  if ( *((_WORD *)v9 + 230) )
  {
    v10 = v7 != 0;
    if ( BG_GetClipSize(NULL, (const Weapon *)(v9 + 460), v10) < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 13210, ASSERT_TYPE_ASSERT, "(BG_GetClipSize( 0, r_weapon, altEntityIndex != 0 ) >= 0)", (const char *)&queryFormat, "BG_GetClipSize( NULL, r_weapon, altEntityIndex != 0 ) >= 0") )
      __debugbreak();
    ClipSize = BG_GetClipSize(NULL, (const Weapon *)(v9 + 460), v10);
    *((_DWORD *)v9 + 112) = v5;
    if ( Int < ClipSize )
      ClipSize = Int;
    *((_DWORD *)v9 + 113) = ClipSize;
    if ( v9[520] )
    {
      v12 = BG_GetClipSize(NULL, (const Weapon *)(v9 + 460), v10);
      if ( v6 < v12 )
        v12 = v6;
      *((_DWORD *)v9 + 114) = v12;
    }
  }
}

/*
==============
GScr_Skydive_SetDeploymentStatus
==============
*/
void GScr_Skydive_SetDeploymentStatus(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  playerState_s *EntityPlayerState; 
  int Int; 
  GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64> *p_pm_flags; 

  entnum = entref.entnum;
  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31354, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( G_Utils_IsClient(Entity) )
  {
    if ( Scr_GetNumParam(scrContext) )
    {
      EntityPlayerState = G_GetEntityPlayerState(Entity);
      if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31369, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
        __debugbreak();
      Int = Scr_GetInt(scrContext, 0);
      p_pm_flags = &EntityPlayerState->pm_flags;
      if ( Int )
      {
        GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::SetFlagInternal(p_pm_flags, ACTIVE, 0x32u);
        EntityPlayerState->skydivePlayerState.flagsExtra[0] &= ~0x20u;
      }
      else
      {
        GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(p_pm_flags, ACTIVE, 0x32u);
        EntityPlayerState->skydivePlayerState.flagsExtra[0] |= 0x20u;
      }
    }
    else
    {
      Scr_Error(COM_ERR_4853, scrContext, "Missing parameter: player Skydive_SetDeploymentStatus( <enabled> );");
    }
  }
  else
  {
    targetname = Entity->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(Entity->classname);
    v8 = j_va("Skydive_SetDeploymentStatus(). Only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, Entity->r.currentOrigin.v[0], Entity->r.currentOrigin.v[1], Entity->r.currentOrigin.v[2], v7, v6);
    Scr_Error(COM_ERR_4852, scrContext, v8);
  }
}

/*
==============
GScr_GetAmmoCount
==============
*/
void GScr_GetAmmoCount(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const playerState_s *p_ps; 
  const char *v6; 
  ComErrorCode v7; 
  GWeaponMap *Instance; 
  int v9; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 13240, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  p_ps = &v4->client->ps;
  if ( !p_ps )
  {
    p_ps = &v4->agent->playerState;
    if ( !p_ps )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v7, scrContext, v6);
      p_ps = NULL;
    }
  }
  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  Instance = GWeaponMap::GetInstance();
  v9 = BG_WeaponAmmo(Instance, p_ps, &outWeapon, outIsAlternate);
  Scr_AddInt(scrContext, v9);
}

/*
==============
GScr_Skydive_SetBaseJumpingStatus
==============
*/
void GScr_Skydive_SetBaseJumpingStatus(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  playerState_s *EntityPlayerState; 
  int Int; 
  GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64> *p_pm_flags; 

  entnum = entref.entnum;
  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31398, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( G_Utils_IsClient(Entity) )
  {
    if ( Scr_GetNumParam(scrContext) )
    {
      EntityPlayerState = G_GetEntityPlayerState(Entity);
      if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31413, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
        __debugbreak();
      Int = Scr_GetInt(scrContext, 0);
      p_pm_flags = &EntityPlayerState->pm_flags;
      if ( Int )
        GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::SetFlagInternal(p_pm_flags, ACTIVE, 0x34u);
      else
        GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(p_pm_flags, ACTIVE, 0x34u);
    }
    else
    {
      Scr_Error(COM_ERR_5933, scrContext, "Missing parameter: player GScr_Skydive_SetBaseJumpingStatus( <enabled> );");
    }
  }
  else
  {
    targetname = Entity->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(Entity->classname);
    v8 = j_va("GScr_Skydive_SetBaseJumpingStatus(). Only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, Entity->r.currentOrigin.v[0], Entity->r.currentOrigin.v[1], Entity->r.currentOrigin.v[2], v7, v6);
    Scr_Error(COM_ERR_5932, scrContext, v8);
  }
}

/*
==============
GScr_GetAmmoType
==============
*/
void GScr_GetAmmoType(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  ComErrorCode v6; 
  __m256i *v7; 
  scr_string_t primary; 
  bool outIsAlternate; 
  AmmoStore result; 
  Weapon outWeapon; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v5 = "not an entity";
    v6 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 13264, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  if ( !v4->client && !v4->agent )
  {
    v5 = j_va("entity %i is not a player or agent", entnum);
    v6 = COM_ERR_3679;
LABEL_9:
    Scr_ObjectError(v6, scrContext, v5);
  }
  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  v7 = (__m256i *)BG_AmmoStoreForWeapon(&result, &outWeapon, outIsAlternate);
  primary = scr_const.primary;
  _YMM1 = v7[1];
  __asm
  {
    vextractf128 xmm0, ymm1, 1
    vpextrd rax, xmm0, 3
  }
  if ( (_DWORD)_RAX )
    primary = scr_const.alternate;
  Scr_AddConstString(scrContext, primary);
}

/*
==============
GScr_Skydive_Interrupt
==============
*/
void GScr_Skydive_Interrupt(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  playerState_s *EntityPlayerState; 
  GWeaponMap *Instance; 

  entnum = entref.entnum;
  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31439, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( G_Utils_IsClient(Entity) )
  {
    EntityPlayerState = G_GetEntityPlayerState(Entity);
    if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31448, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
      __debugbreak();
    if ( EntityPlayerState->skydivePlayerState.state[0] )
    {
      EntityPlayerState->skydivePlayerState.state[0] = 0;
      EntityPlayerState->skydivePlayerState.animState = 0;
      EntityPlayerState->skydivePlayerState.flagsExtra[0] = 0;
    }
    if ( (unsigned int)(EntityPlayerState->weapState[0].weaponState - 63) <= 0xC )
    {
      EntityPlayerState->weapState[0].weaponTime = 0;
      Instance = GWeaponMap::GetInstance();
      BG_SetWeaponDelay(Instance, EntityPlayerState, WEAPON_HAND_DEFAULT, 0, NULL);
      EntityPlayerState->weapState[0].weaponState = 0;
      PM_StartWeaponAnim(EntityPlayerState, WEAP_IDLE, WEAPON_HAND_DEFAULT);
    }
    if ( EntityPlayerState->cameraTypeIndex == 251 )
      EntityPlayerState->cameraTypeIndex = 0;
    if ( EntityPlayerState->cameraTypeIndex == BG_Camera_GetSkydiveOrbitDefIndex() )
      EntityPlayerState->cameraTypeIndex = 0;
  }
  else
  {
    targetname = Entity->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(Entity->classname);
    v8 = j_va("Skydive_Interrupt(). Only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, Entity->r.currentOrigin.v[0], Entity->r.currentOrigin.v[1], Entity->r.currentOrigin.v[2], v7, v6);
    Scr_Error(COM_ERR_5934, scrContext, v8);
  }
}

/*
==============
GScr_WeaponIsImpaling
==============
*/
void GScr_WeaponIsImpaling(scrContext_t *scrContext)
{
  bool IsImpalingBullet; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  IsImpalingBullet = BG_IsImpalingBullet(&outWeapon, outIsAlternate);
  Scr_AddBool(scrContext, IsImpalingBullet);
}

/*
==============
GScr_WeaponIsAuto
==============
*/
void GScr_WeaponIsAuto(scrContext_t *scrContext)
{
  int v2; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  v2 = BG_GetWeaponFireType(&outWeapon, outIsAlternate) == WEAPON_FIRETYPE_FULLAUTO && BG_GetWeaponType(&outWeapon, outIsAlternate) == WEAPTYPE_BULLET;
  Scr_AddInt(scrContext, v2);
}

/*
==============
GScr_WeaponIsBeam
==============
*/
void GScr_WeaponIsBeam(scrContext_t *scrContext)
{
  weapFireType_t WeaponFireType; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  WeaponFireType = BG_GetWeaponFireType(&outWeapon, outIsAlternate);
  Scr_AddInt(scrContext, WeaponFireType == WEAPON_FIRETYPE_BEAM);
}

/*
==============
GScr_WeaponIsSemiAuto
==============
*/
void GScr_WeaponIsSemiAuto(scrContext_t *scrContext)
{
  weapFireType_t WeaponFireType; 
  int v3; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  WeaponFireType = BG_GetWeaponFireType(&outWeapon, outIsAlternate);
  v3 = ((WeaponFireType - 1) & 0xFFFFFFFC) == 0 && WeaponFireType != WEAPON_FIRETYPE_BURST && BG_GetWeaponType(&outWeapon, outIsAlternate) == WEAPTYPE_BULLET;
  Scr_AddInt(scrContext, v3);
}

/*
==============
PlayerCmd_IsSkydiving
==============
*/
void PlayerCmd_IsSkydiving(scrContext_t *scrContext, scr_entref_t entref)
{
  int v2; 
  unsigned int entnum; 
  gentity_s *v5; 
  _BYTE *client; 
  const char *v7; 
  ComErrorCode v8; 

  v2 = 0;
  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v7 = "not an entity";
    v8 = COM_ERR_3682;
LABEL_9:
    Scr_ObjectError(v8, scrContext, v7);
    client = NULL;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31491, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    goto LABEL_11;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31490, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v5 = &g_entities[entnum];
  client = v5->client;
  if ( !client )
  {
    client = v5->agent;
    if ( !client )
    {
      v7 = j_va("entity %i is not a player or agent", entnum);
      v8 = COM_ERR_3679;
      goto LABEL_9;
    }
  }
LABEL_11:
  LOBYTE(v2) = (unsigned __int8)(client[12112] - 1) <= 5u;
  Scr_AddBool(scrContext, v2);
}

/*
==============
GScr_WeaponBurstCount
==============
*/
void GScr_WeaponBurstCount(scrContext_t *scrContext)
{
  int WeaponBurstCount; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( BG_GetWeaponFireType(&outWeapon, outIsAlternate) == WEAPON_FIRETYPE_BURST )
    WeaponBurstCount = BG_GetWeaponBurstCount(&outWeapon, outIsAlternate);
  else
    WeaponBurstCount = 0;
  Scr_AddInt(scrContext, WeaponBurstCount);
}

/*
==============
GScr_WeaponIsBoltAction
==============
*/
void GScr_WeaponIsBoltAction(scrContext_t *scrContext)
{
  bool IsBoltAction; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  IsBoltAction = BG_IsBoltAction(&outWeapon, outIsAlternate);
  Scr_AddInt(scrContext, IsBoltAction);
}

/*
==============
GScr_WeaponInheritsPerks
==============
*/
void GScr_WeaponInheritsPerks(scrContext_t *scrContext)
{
  int v2; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( outWeapon.weaponIdx )
    v2 = BG_InheritsPerks(&outWeapon, outIsAlternate);
  else
    v2 = 1;
  Scr_AddInt(scrContext, v2);
}

/*
==============
GScr_WeaponType
==============
*/
void GScr_WeaponType(scrContext_t *scrContext)
{
  weapType_t WeaponType; 
  const char *WeaponTypeName; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  WeaponType = BG_GetWeaponType(&outWeapon, outIsAlternate);
  WeaponTypeName = BG_GetWeaponTypeName(WeaponType);
  Scr_AddString(scrContext, WeaponTypeName);
}

/*
==============
PlayerCmd_IsBaseJumpAvailable
==============
*/
void PlayerCmd_IsBaseJumpAvailable(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  unsigned __int8 *client; 
  const char *v6; 
  ComErrorCode v7; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
LABEL_9:
    Scr_ObjectError(v7, scrContext, v6);
    client = NULL;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31510, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    goto LABEL_11;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31509, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = (unsigned __int8 *)v4->client;
  if ( !client )
  {
    client = (unsigned __int8 *)v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
      goto LABEL_9;
    }
  }
LABEL_11:
  Scr_AddBool(scrContext, client[12140] >> 7);
}

/*
==============
GScr_WeaponClass
==============
*/
void GScr_WeaponClass(scrContext_t *scrContext)
{
  const char *WeaponClassName; 
  weapClass_t WeaponClass; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( outWeapon.weaponIdx )
  {
    WeaponClass = BG_GetWeaponClass(&outWeapon, outIsAlternate);
    WeaponClassName = BG_GetWeaponClassName(WeaponClass);
  }
  else
  {
    WeaponClassName = "none";
  }
  Scr_AddString(scrContext, WeaponClassName);
}

/*
==============
GScr_WeaponOffhandClass
==============
*/
void GScr_WeaponOffhandClass(scrContext_t *scrContext)
{
  const char *WeaponOffhandClassName; 
  OffhandClass WeaponOffhandClass; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( outWeapon.weaponIdx )
  {
    WeaponOffhandClass = BG_GetWeaponOffhandClass(&outWeapon);
    WeaponOffhandClassName = BG_GetWeaponOffhandClassName(WeaponOffhandClass);
  }
  else
  {
    WeaponOffhandClassName = "none";
  }
  Scr_AddString(scrContext, WeaponOffhandClassName);
}

/*
==============
GScr_WeaponInventoryType
==============
*/
void GScr_WeaponInventoryType(scrContext_t *scrContext)
{
  weapInventoryType_t inventoryType; 
  unsigned __int16 weaponIdx; 
  bool v4; 
  WeaponDef **v5; 
  const char *WeaponInventoryTypeName; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( outIsAlternate )
  {
    inventoryType = WEAPINVENTORY_ALTMODE;
  }
  else
  {
    weaponIdx = outWeapon.weaponIdx;
    if ( outWeapon.weaponIdx > bg_lastParsedWeaponIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1203, ASSERT_TYPE_ASSERT, "( weaponIdx ) <= ( bg_lastParsedWeaponIndex )", "weaponIdx not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", outWeapon.weaponIdx, bg_lastParsedWeaponIndex) )
      __debugbreak();
    v4 = bg_weaponDefs[weaponIdx] == NULL;
    v5 = &bg_weaponDefs[weaponIdx];
    if ( v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1204, ASSERT_TYPE_ASSERT, "(bg_weaponDefs[weaponIdx])", (const char *)&queryFormat, "bg_weaponDefs[weaponIdx]") )
      __debugbreak();
    inventoryType = (*v5)->inventoryType;
  }
  WeaponInventoryTypeName = BG_GetWeaponInventoryTypeName(inventoryType);
  Scr_AddString(scrContext, WeaponInventoryTypeName);
}

/*
==============
GScr_Skydive_CutParachuteOn
==============
*/
void GScr_Skydive_CutParachuteOn(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  _BYTE *client; 
  const char *v6; 
  ComErrorCode v7; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
LABEL_9:
    Scr_ObjectError(v7, scrContext, v6);
    client = NULL;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31529, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    goto LABEL_11;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31528, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = v4->client;
  if ( !client )
  {
    client = v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
      goto LABEL_9;
    }
  }
LABEL_11:
  client[12140] &= ~0x10u;
}

/*
==============
GScr_WeaponStartAmmo
==============
*/
void GScr_WeaponStartAmmo(scrContext_t *scrContext)
{
  bool v2; 
  int started; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  v2 = Scr_GetNumParam(scrContext) > 1 && Scr_GetType(scrContext, 1u) && Scr_GetInt(scrContext, 1u) != 0;
  started = BG_StartAmmo(&outWeapon, outIsAlternate, v2);
  Scr_AddInt(scrContext, started);
}

/*
==============
GScr_WeaponMaxAmmo
==============
*/
void GScr_WeaponMaxAmmo(scrContext_t *scrContext)
{
  bool v2; 
  int v3; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  v2 = Scr_GetNumParam(scrContext) > 1 && Scr_GetType(scrContext, 1u) && Scr_GetInt(scrContext, 1u) != 0;
  v3 = BG_MaxAmmo(&outWeapon, outIsAlternate, v2);
  Scr_AddInt(scrContext, v3);
}

/*
==============
GScr_WeaponAltWeaponName
==============
*/
void GScr_WeaponAltWeaponName(scrContext_t *scrContext)
{
  bool outIsAlternate; 
  Weapon outWeapon; 
  char output[1024]; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( !outIsAlternate && (unsigned __int16)*(_DWORD *)&BG_GetAltWeapon(&outWeapon)->weaponIdx )
  {
    BG_GetWeaponNameComplete(&outWeapon, 1, output, 0x400u);
    Scr_AddString(scrContext, output);
  }
  else
  {
    Scr_AddConstString(scrContext, scr_const.none);
  }
}

/*
==============
GScr_Skydive_CutParachuteOff
==============
*/
void GScr_Skydive_CutParachuteOff(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  _BYTE *client; 
  const char *v6; 
  ComErrorCode v7; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
LABEL_9:
    Scr_ObjectError(v7, scrContext, v6);
    client = NULL;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31547, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    goto LABEL_11;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31546, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = v4->client;
  if ( !client )
  {
    client = v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
      goto LABEL_9;
    }
  }
LABEL_11:
  client[12140] |= 0x10u;
  client[12141] |= 2u;
}

/*
==============
GScr_WeaponFireTime
==============
*/
void GScr_WeaponFireTime(scrContext_t *scrContext)
{
  bool isDualWielding; 
  bool outIsAlternate; 
  int fireTime; 
  int fireDelay; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  isDualWielding = BG_WeaponIsDualWield(&outWeapon);
  BG_GetFireTime(NULL, NULL, &outWeapon, outIsAlternate, isDualWielding, 0, &fireTime, &fireDelay);
  Scr_AddFloat(scrContext, (float)fireTime * 0.001);
}

/*
==============
GScr_IsWeaponClipOnly
==============
*/
void GScr_IsWeaponClipOnly(scrContext_t *scrContext)
{
  int IsClipOnly; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( outWeapon.weaponIdx )
    IsClipOnly = BG_WeaponIsClipOnly(&outWeapon, outIsAlternate);
  else
    IsClipOnly = 0;
  Scr_AddBool(scrContext, IsClipOnly);
}

/*
==============
GScr_IsWeaponDetonationTimed
==============
*/
void GScr_IsWeaponDetonationTimed(scrContext_t *scrContext)
{
  int v2; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( outWeapon.weaponIdx )
    v2 = BG_TimedDetonation(&outWeapon, outIsAlternate);
  else
    v2 = 0;
  Scr_AddBool(scrContext, v2);
}

/*
==============
GScr_Skydive_CutAutoDeployOn
==============
*/
void GScr_Skydive_CutAutoDeployOn(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  _BYTE *client; 
  const char *v6; 
  ComErrorCode v7; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
LABEL_9:
    Scr_ObjectError(v7, scrContext, v6);
    client = NULL;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31568, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    goto LABEL_11;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31567, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = v4->client;
  if ( !client )
  {
    client = v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
      goto LABEL_9;
    }
  }
LABEL_11:
  client[12141] &= ~2u;
}

/*
==============
GScr_WeaponHasThermalScope
==============
*/
void GScr_WeaponHasThermalScope(scrContext_t *scrContext)
{
  bool HasThermalScope; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  HasThermalScope = BG_HasThermalScope(NULL, &outWeapon, outIsAlternate);
  Scr_AddInt(scrContext, HasThermalScope);
}

/*
==============
GScr_WeaponCanDrop
==============
*/
void GScr_WeaponCanDrop(scrContext_t *scrContext)
{
  bool IsDisabled; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  IsDisabled = BG_WeaponDropIsDisabled(&outWeapon, 0);
  Scr_AddBool(scrContext, !IsDisabled);
}

/*
==============
GScr_WeaponIsPreferredDrop
==============
*/
void GScr_WeaponIsPreferredDrop(scrContext_t *scrContext)
{
  bool IsPrefferedDrop; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  IsPrefferedDrop = BG_WeaponIsPrefferedDrop(&outWeapon, 0);
  Scr_AddBool(scrContext, IsPrefferedDrop);
}

/*
==============
Scr_PrecacheItem
==============
*/
void Scr_PrecacheItem(scrContext_t *scrContext)
{
  const char *String; 

  String = Scr_GetString(scrContext, 0);
  Com_Printf(15, "PrecacheItem() is deprecated, weapons automatically register. Please delete this instruction (Weapon %s)\n", String);
}

/*
==============
GScr_Skydive_CutAutoDeployOff
==============
*/
void GScr_Skydive_CutAutoDeployOff(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  _BYTE *client; 
  const char *v6; 
  ComErrorCode v7; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
LABEL_9:
    Scr_ObjectError(v7, scrContext, v6);
    client = NULL;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31586, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    goto LABEL_11;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31585, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = v4->client;
  if ( !client )
  {
    client = v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
      goto LABEL_9;
    }
  }
LABEL_11:
  client[12141] |= 2u;
}

/*
==============
Scr_PrecacheMaterial
==============
*/
void Scr_PrecacheMaterial(scrContext_t *scrContext)
{
  const char *String; 

  if ( NetConstStrings_IsPrecacheAllowed() )
  {
    if ( !level.initializing )
      Scr_Error(COM_ERR_4298, scrContext, "precacheShader must be called before any wait statements in the gametype or level script\n");
    String = Scr_GetString(scrContext, 0);
    if ( !*String )
      Scr_ParamError(COM_ERR_4299, scrContext, 0, "Shader name string is empty");
    Scr_ErrorOnDefaultAsset(scrContext, ASSET_TYPE_MATERIAL, String);
    if ( !GConfigStrings::ms_gConfigStrings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_configstrings.h", 71, ASSERT_TYPE_ASSERT, "( ms_gConfigStrings )", (const char *)&queryFormat, "ms_gConfigStrings") )
      __debugbreak();
    GConfigStrings::ms_gConfigStrings->GetMaterialIndex(GConfigStrings::ms_gConfigStrings, String);
  }
}

/*
==============
Scr_PrecacheLeaderboards
==============
*/
void Scr_PrecacheLeaderboards(scrContext_t *scrContext)
{
  const char *String; 

  if ( !level.initializing )
    Scr_Error(COM_ERR_4300, scrContext, "preacheLeaderboards must be called before any wait statements in the gametype or level script\n");
  String = Scr_GetString(scrContext, 0);
  SV_SetConfigstring(0xDu, String);
}

/*
==============
Scr_PrecacheString
==============
*/
void Scr_PrecacheString(scrContext_t *scrContext)
{
  GConfigStrings *ConfigStringSystem; 
  char v3[1024]; 

  if ( NetConstStrings_IsPrecacheAllowed() )
  {
    if ( !level.initializing )
      Scr_Error(COM_ERR_4301, scrContext, "precacheString must be called before any wait statements in the gametype or level script\n");
    if ( !GScript::ms_gScriptSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.h", 183, ASSERT_TYPE_ASSERT, "( ms_gScriptSystem )", (const char *)&queryFormat, "ms_gScriptSystem") )
      __debugbreak();
    GScript::ms_gScriptSystem->ConstructMessageString(GScript::ms_gScriptSystem, scrContext, 0, 0, "Precache String", v3, 1024u);
    if ( v3[0] )
    {
      ConfigStringSystem = GConfigStrings::GetConfigStringSystem();
      ConfigStringSystem->SetLocalizedString(ConfigStringSystem, v3, NULL);
    }
  }
}

/*
==============
PlayerCmd_IsInFreefall
==============
*/
void PlayerCmd_IsInFreefall(scrContext_t *scrContext, scr_entref_t entref)
{
  int v2; 
  unsigned int entnum; 
  gentity_s *v5; 
  _BYTE *client; 
  const char *v7; 
  ComErrorCode v8; 

  v2 = 0;
  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v7 = "not an entity";
    v8 = COM_ERR_3682;
LABEL_9:
    Scr_ObjectError(v8, scrContext, v7);
    client = NULL;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31604, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    goto LABEL_11;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31603, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v5 = &g_entities[entnum];
  client = v5->client;
  if ( !client )
  {
    client = v5->agent;
    if ( !client )
    {
      v7 = j_va("entity %i is not a player or agent", entnum);
      v8 = COM_ERR_3679;
      goto LABEL_9;
    }
  }
LABEL_11:
  if ( client[12112] == 7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31605, ASSERT_TYPE_ASSERT, "( ps->skydivePlayerState.state ) != ( SkydiveState::Count )", "%s != %s\n\t%i, %i", "ps->skydivePlayerState.state", "SkydiveState::Count", 7, 7) )
    __debugbreak();
  LOBYTE(v2) = ((client[12112] - 1) & 0xFB) == 0;
  Scr_AddBool(scrContext, v2);
}

/*
==============
Scr_PrecacheRumble
==============
*/
void Scr_PrecacheRumble(scrContext_t *scrContext)
{
  const char *String; 

  String = Scr_GetString(scrContext, 0);
  Com_Printf(15, "PrecacheItem() is deprecated, rumbles automatically register. Please delete this instruction (Rumble %s)\n", String);
}

/*
==============
PlayerCmd_IsParachuting
==============
*/
void PlayerCmd_IsParachuting(scrContext_t *scrContext, scr_entref_t entref)
{
  int v2; 
  unsigned int entnum; 
  gentity_s *v5; 
  _BYTE *client; 
  const char *v7; 
  ComErrorCode v8; 

  v2 = 0;
  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v7 = "not an entity";
    v8 = COM_ERR_3682;
LABEL_9:
    Scr_ObjectError(v8, scrContext, v7);
    client = NULL;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31624, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    goto LABEL_11;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31623, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v5 = &g_entities[entnum];
  client = v5->client;
  if ( !client )
  {
    client = v5->agent;
    if ( !client )
    {
      v7 = j_va("entity %i is not a player or agent", entnum);
      v8 = COM_ERR_3679;
      goto LABEL_9;
    }
  }
LABEL_11:
  if ( client[12112] == 7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31625, ASSERT_TYPE_ASSERT, "( ps->skydivePlayerState.state ) != ( SkydiveState::Count )", "%s != %s\n\t%i, %i", "ps->skydivePlayerState.state", "SkydiveState::Count", 7, 7) )
    __debugbreak();
  LOBYTE(v2) = (unsigned __int8)(client[12112] - 2) <= 1u;
  Scr_AddBool(scrContext, v2);
}

/*
==============
PlayerCmd_ShouldDisableSkydiveVfx
==============
*/
void PlayerCmd_ShouldDisableSkydiveVfx(scrContext_t *scrContext, scr_entref_t entref)
{
  int v2; 
  unsigned int entnum; 
  gentity_s *v5; 
  _BYTE *client; 
  const char *v7; 
  ComErrorCode v8; 

  v2 = 0;
  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v7 = "not an entity";
    v8 = COM_ERR_3682;
LABEL_9:
    Scr_ObjectError(v8, scrContext, v7);
    client = NULL;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31644, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    goto LABEL_11;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31643, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v5 = &g_entities[entnum];
  client = v5->client;
  if ( !client )
  {
    client = v5->agent;
    if ( !client )
    {
      v7 = j_va("entity %i is not a player or agent", entnum);
      v8 = COM_ERR_3679;
      goto LABEL_9;
    }
  }
LABEL_11:
  if ( (client[12141] & 4) != 0 || !client[12112] )
    v2 = 1;
  Scr_AddBool(scrContext, v2);
}

/*
==============
PlayerCmd_SetIsInfilSkydive
==============
*/
void PlayerCmd_SetIsInfilSkydive(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  _BYTE *client; 
  const char *v6; 
  ComErrorCode v7; 
  bool v8; 
  char v9; 
  char v10; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
LABEL_9:
    Scr_ObjectError(v7, scrContext, v6);
    client = NULL;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31665, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
    goto LABEL_11;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31664, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = v4->client;
  if ( !client )
  {
    client = v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
      goto LABEL_9;
    }
  }
LABEL_11:
  v8 = Scr_GetInt(scrContext, 0) != 0;
  if ( client[12112] )
  {
    v9 = client[12141];
    if ( ((v9 & 8) != 0) != v8 )
    {
      if ( (v9 & 8) != 0 )
        v10 = v9 & 0xF7;
      else
        v10 = v9 | 8;
      client[12141] = v10;
    }
  }
}

/*
==============
GScr_Skydive_SetForceThirdPersonStatus
==============
*/
void GScr_Skydive_SetForceThirdPersonStatus(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  playerState_s *EntityPlayerState; 
  int Int; 
  GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64> *p_pm_flags; 

  entnum = entref.entnum;
  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31709, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( G_Utils_IsClient(Entity) )
  {
    if ( Scr_GetNumParam(scrContext) )
    {
      EntityPlayerState = G_GetEntityPlayerState(Entity);
      if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31724, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
        __debugbreak();
      Int = Scr_GetInt(scrContext, 0);
      p_pm_flags = &EntityPlayerState->pm_flags;
      if ( Int )
        GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::SetFlagInternal(p_pm_flags, ACTIVE, 0x31u);
      else
        GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(p_pm_flags, ACTIVE, 0x31u);
    }
    else
    {
      Scr_Error(COM_ERR_5731, scrContext, "Missing parameter: player Skydive_SetForceThirdPersonStatus( <enabled> );");
    }
  }
  else
  {
    targetname = Entity->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(Entity->classname);
    v8 = j_va("Skydive_SetForceThirdPersonStatus(). Only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, Entity->r.currentOrigin.v[0], Entity->r.currentOrigin.v[1], Entity->r.currentOrigin.v[2], v7, v6);
    Scr_Error(COM_ERR_5935, scrContext, v8);
  }
}

/*
==============
GScr_EnablePlayerMarks
==============
*/
void GScr_EnablePlayerMarks(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t ConstString; 
  const char *v5; 
  const char *v6; 
  EntityMarkType outMarkType; 

  Entity = GetEntity(entref);
  ConstString = Scr_GetConstString(scrContext, 0);
  if ( G_EntityMarks_GetMarkType(ConstString, &outMarkType) )
  {
    Entity->markFlags |= 1 << outMarkType;
    *(_QWORD *)Entity->markFilterOut = 0i64;
    *(_QWORD *)&Entity->markFilterOut[2] = 0i64;
    *(_QWORD *)&Entity->markFilterOut[4] = 0i64;
    Entity->markFilterOut[6] = 0;
  }
  else
  {
    G_EntityMarks_PrintMarkTypes();
    v5 = SL_ConvertToString(ConstString);
    v6 = j_va("Invalid mark type specified: %s. See console log for details.\n", v5);
    Scr_ParamError(COM_ERR_6044, scrContext, 0, v6);
  }
}

/*
==============
GScr_DisablePlayerMarks
==============
*/
void GScr_DisablePlayerMarks(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t ConstString; 
  const char *v5; 
  const char *v6; 
  EntityMarkType outMarkType; 

  Entity = GetEntity(entref);
  ConstString = Scr_GetConstString(scrContext, 0);
  if ( G_EntityMarks_GetMarkType(ConstString, &outMarkType) )
  {
    Entity->markFlags &= ~(1 << outMarkType);
    *(_QWORD *)Entity->markFilterOut = 0i64;
    *(_QWORD *)&Entity->markFilterOut[2] = 0i64;
    *(_QWORD *)&Entity->markFilterOut[4] = 0i64;
    Entity->markFilterOut[6] = 0;
  }
  else
  {
    G_EntityMarks_PrintMarkTypes();
    v5 = SL_ConvertToString(ConstString);
    v6 = j_va("Invalid mark type specified: %s. See console log for details.\n", v5);
    Scr_ParamError(COM_ERR_6092, scrContext, 0, v6);
  }
}

/*
==============
GScr_IsExplosiveDamageMOD
==============
*/
void GScr_IsExplosiveDamageMOD(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  scr_string_t **v3; 
  int v4; 

  ConstString = Scr_GetConstString(scrContext, 0);
  v3 = g_combat_modNames;
  v4 = 0;
  while ( **v3 != ConstString )
  {
    ++v4;
    if ( (__int64)++v3 >= (__int64)&MAX_TRANSIENT_WORLD_FASTFILES_454 )
    {
      Scr_AddBool(scrContext, 0);
      return;
    }
  }
  Scr_AddBool(scrContext, modExplosiveFlags[v4]);
}

/*
==============
ScrCmd_DoDamage
==============
*/
void ScrCmd_DoDamage(scrContext_t *scrContext, scr_entref_t entref)
{
  __int128 v2; 
  int v3; 
  gentity_s *v6; 
  gentity_s *EntityAllowNull; 
  scr_string_t ConstString; 
  gentity_s *Entity; 
  double Float; 
  float v11; 
  const char *v12; 
  float *p_commandTime; 
  gclient_s *client; 
  float v15; 
  __int128 v16; 
  __int128 v17; 
  __int128 v18; 
  float v19; 
  __int128 v20; 
  __int128 v21; 
  float v22; 
  __int128 v23; 
  float *v27; 
  damageReturnCode_t (__fastcall *Damage)(GCombat *, gentity_s *, const gentity_s *, gentity_s *, const vec3_t *, const vec3_t *, int, int, int, const Weapon *, bool, hitLocation_t, unsigned int, scr_string_t, int, const vec3_t *, const GExtraDamageParams *); 
  bool outIsAlternate[4]; 
  hitLocation_t HitLocationIndexFromString; 
  meansOfDeath_t v31; 
  float v32; 
  float v33; 
  float v34; 
  vec3_t vectorValue; 
  Weapon outWeapon; 
  __int128 v37; 

  v3 = 0;
  memset(&outWeapon, 0, 48);
  *(double *)&outWeapon.attachmentVariationIndices[21] = *(double *)&NULL_WEAPON.attachmentVariationIndices[21];
  *(_DWORD *)&outWeapon.weaponCamo = *(_DWORD *)&NULL_WEAPON.weaponCamo;
  outIsAlternate[0] = 0;
  v6 = NULL;
  v31 = MOD_UNKNOWN;
  EntityAllowNull = NULL;
  HitLocationIndexFromString = HITLOC_HEAD;
  switch ( Scr_GetNumParam(scrContext) )
  {
    case 2u:
      goto $LN22_42;
    case 3u:
      goto $LN20_39;
    case 4u:
      goto $LN18_41;
    case 5u:
      goto $LN16_45;
    case 6u:
      goto $LN14_55;
    case 7u:
      if ( Scr_GetType(scrContext, 6u) )
      {
        ConstString = Scr_GetConstString(scrContext, 6u);
        HitLocationIndexFromString = G_Combat_GetHitLocationIndexFromString(ConstString);
      }
$LN14_55:
      if ( Scr_GetType(scrContext, 5u) )
        GScr_Main_GetWeaponParam(scrContext, 5u, &outWeapon, outIsAlternate);
$LN16_45:
      if ( Scr_GetType(scrContext, 4u) )
        v31 = G_Combat_MeansOfDeathFromScriptParam(scrContext, 4);
$LN18_41:
      if ( Scr_GetType(scrContext, 3u) )
        EntityAllowNull = GScr_GetEntityAllowNull(3u);
$LN20_39:
      if ( Scr_GetType(scrContext, 2u) )
        v6 = GScr_GetEntityAllowNull(2u);
$LN22_42:
      v37 = v2;
      Entity = GetEntity(entref);
      Float = Scr_GetFloat(scrContext, 0);
      v11 = *(float *)&Float;
      Scr_GetVector(scrContext, 1u, &vectorValue);
      *(float *)outIsAlternate = vectorValue.v[0];
      if ( (LODWORD(vectorValue.v[0]) & 0x7F800000) == 2139095040 || (*(float *)outIsAlternate = vectorValue.v[1], (LODWORD(vectorValue.v[1]) & 0x7F800000) == 2139095040) || (*(float *)outIsAlternate = vectorValue.v[2], (LODWORD(vectorValue.v[2]) & 0x7F800000) == 2139095040) )
      {
        v12 = j_va("Source Damage vector is invalid : %f %f %f", vectorValue.v[0], vectorValue.v[1], vectorValue.v[2]);
        Scr_Error(COM_ERR_4305, scrContext, v12);
      }
      p_commandTime = (float *)&Entity->client->ps.commandTime;
      if ( p_commandTime )
      {
        *(float *)outIsAlternate = p_commandTime[12];
        if ( (*(_DWORD *)outIsAlternate & 0x7F800000) == 2139095040 || (*(float *)outIsAlternate = p_commandTime[13], (*(_DWORD *)outIsAlternate & 0x7F800000) == 2139095040) || (*(float *)outIsAlternate = p_commandTime[14], (*(_DWORD *)outIsAlternate & 0x7F800000) == 2139095040) )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 14301, ASSERT_TYPE_SANITY, "( !IS_NAN( ( ent->client->ps.origin )[0] ) && !IS_NAN( ( ent->client->ps.origin )[1] ) && !IS_NAN( ( ent->client->ps.origin )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( ent->client->ps.origin )[0] ) && !IS_NAN( ( ent->client->ps.origin )[1] ) && !IS_NAN( ( ent->client->ps.origin )[2] )") )
            __debugbreak();
        }
        client = Entity->client;
        v15 = client->ps.origin.v[0] - vectorValue.v[0];
        v32 = v15;
        v16 = LODWORD(client->ps.origin.v[1]);
        v18 = v16;
        *(float *)&v18 = *(float *)&v16 - vectorValue.v[1];
        v17 = v18;
        v33 = *(float *)&v16 - vectorValue.v[1];
        v19 = client->ps.origin.v[2];
      }
      else
      {
        *(float *)outIsAlternate = Entity->r.currentOrigin.v[0];
        if ( (*(_DWORD *)outIsAlternate & 0x7F800000) == 2139095040 || (*(float *)outIsAlternate = Entity->r.currentOrigin.v[1], (*(_DWORD *)outIsAlternate & 0x7F800000) == 2139095040) || (*(float *)outIsAlternate = Entity->r.currentOrigin.v[2], (*(_DWORD *)outIsAlternate & 0x7F800000) == 2139095040) )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 14306, ASSERT_TYPE_SANITY, "( !IS_NAN( ( ent->r.currentOrigin )[0] ) && !IS_NAN( ( ent->r.currentOrigin )[1] ) && !IS_NAN( ( ent->r.currentOrigin )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( ent->r.currentOrigin )[0] ) && !IS_NAN( ( ent->r.currentOrigin )[1] ) && !IS_NAN( ( ent->r.currentOrigin )[2] )") )
            __debugbreak();
        }
        v15 = Entity->r.currentOrigin.v[0] - vectorValue.v[0];
        v32 = v15;
        v20 = LODWORD(Entity->r.currentOrigin.v[1]);
        v21 = v20;
        *(float *)&v21 = *(float *)&v20 - vectorValue.v[1];
        v17 = v21;
        v33 = *(float *)&v20 - vectorValue.v[1];
        v19 = Entity->r.currentOrigin.v[2];
      }
      v22 = v19 - vectorValue.v[2];
      *(float *)outIsAlternate = v15;
      v34 = v19 - vectorValue.v[2];
      if ( (LODWORD(v15) & 0x7F800000) == 2139095040 || (*(float *)outIsAlternate = *(float *)&v17, (v17 & 0x7F800000) == 2139095040) || (*(float *)outIsAlternate = v19 - vectorValue.v[2], (COERCE_UNSIGNED_INT(v19 - vectorValue.v[2]) & 0x7F800000) == 2139095040) )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 14310, ASSERT_TYPE_SANITY, "( !IS_NAN( ( from )[0] ) && !IS_NAN( ( from )[1] ) && !IS_NAN( ( from )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( from )[0] ) && !IS_NAN( ( from )[1] ) && !IS_NAN( ( from )[2] )") )
          __debugbreak();
        v15 = v32;
        v17 = LODWORD(v33);
        v22 = v34;
      }
      v23 = v17;
      *(float *)&v23 = fsqrt((float)((float)(*(float *)&v17 * *(float *)&v17) + (float)(v15 * v15)) + (float)(v22 * v22));
      _XMM3 = v23;
      __asm
      {
        vcmpless xmm0, xmm3, cs:__real@80000000
        vblendvps xmm0, xmm3, xmm1, xmm0
      }
      v33 = *(float *)&v17 * (float)(1.0 / *(float *)&_XMM0);
      v32 = v15 * (float)(1.0 / *(float *)&_XMM0);
      v27 = NULL;
      v34 = v22 * (float)(1.0 / *(float *)&_XMM0);
      if ( *(float *)&v23 != 0.0 )
        v27 = &v32;
      if ( !GCombat::ms_gCombatSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_combat.h", 177, ASSERT_TYPE_ASSERT, "( ms_gCombatSystem )", (const char *)&queryFormat, "ms_gCombatSystem") )
        __debugbreak();
      Damage = GCombat::ms_gCombatSystem->Damage;
      *(_WORD *)outIsAlternate = 0;
      LOBYTE(v3) = Damage(GCombat::ms_gCombatSystem, Entity, EntityAllowNull, v6, (const vec3_t *)v27, &vectorValue, (int)v11, 0, v31, &outWeapon, 0, HitLocationIndexFromString, 0, (scr_string_t)0, 0, NULL, (const GExtraDamageParams *)outIsAlternate) == DAMAGE_RETURNCODE_SUCCESS;
      Scr_AddBool(scrContext, v3);
      break;
    default:
      Scr_Error(COM_ERR_4306, scrContext, "Usage: doDamage( <health>, <source position>, <attacker>, <inflictor> )\n");
      break;
  }
}

/*
==============
GScr_RadiusDamage
==============
*/
void GScr_RadiusDamage(scrContext_t *scrContext)
{
  GScr_RadiusDamageInternal(scrContext, NULL);
}

/*
==============
GScr_EntityRadiusDamage
==============
*/
void GScr_EntityRadiusDamage(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  GScr_RadiusDamageInternal(scrContext, Entity);
}

/*
==============
GScr_RadiusDamageStepped
==============
*/
void GScr_RadiusDamageStepped(scrContext_t *scrContext)
{
  GScr_RadiusDamageSteppedInternal(scrContext, NULL);
}

/*
==============
GScr_EntityRadiusDamageStepped
==============
*/
void GScr_EntityRadiusDamageStepped(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  GScr_RadiusDamageSteppedInternal(scrContext, Entity);
}

/*
==============
GScr_GlassRadiusDamage
==============
*/
void GScr_GlassRadiusDamage(scrContext_t *scrContext)
{
  double Float; 
  float v3; 
  double v4; 
  float v5; 
  double v6; 
  vec3_t vectorValue; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  Float = Scr_GetFloat(scrContext, 1u);
  v3 = *(float *)&Float;
  if ( *(float *)&Float < 0.0 )
    Scr_Error(COM_ERR_4307, scrContext, "Invalid <range> value specified for radius damage ( parameter 2 ).\n");
  v4 = Scr_GetFloat(scrContext, 2u);
  v5 = *(float *)&v4;
  if ( *(float *)&v4 < 0.0 || *(float *)&v4 >= 2147483600.0 )
    Scr_Error(COM_ERR_4308, scrContext, "Invalid <max_damage> value specified for radius damage ( parameter 3 ).\n");
  v6 = Scr_GetFloat(scrContext, 3u);
  if ( *(float *)&v6 < 0.0 || *(float *)&v6 >= 2147483600.0 )
    Scr_Error(COM_ERR_4309, scrContext, "Invalid <min_damage> value specified for radius damage ( parameter 4 ).\n");
  G_Glass_RadiusDamage(&vectorValue, v3, 0.0, NULL, v5, *(float *)&v6);
}

/*
==============
GScr_Detonate
==============
*/
void GScr_Detonate(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  GWeaponMap *Instance; 
  const Weapon *WeaponForEntity; 
  const WeaponDef *v6; 
  bool v7; 
  const gentity_s *v8; 
  gentity_s *v9; 

  Entity = GetEntity(entref);
  Instance = GWeaponMap::GetInstance();
  WeaponForEntity = BG_GetWeaponForEntity(Instance, &Entity->s);
  v6 = BG_WeaponDef(WeaponForEntity, 0);
  v7 = BG_GetWeaponType(WeaponForEntity, 0) == WEAPTYPE_GRENADE || BG_GetWeaponType(WeaponForEntity, 0) == WEAPTYPE_PROJECTILE;
  if ( Entity->s.eType != ET_MISSILE || !v6 || !v7 )
    Scr_ObjectError(COM_ERR_4310, scrContext, "entity is not a grenade or projectile or it already exploded");
  if ( Scr_GetNumParam(scrContext) )
  {
    if ( Scr_GetType(scrContext, 0) )
    {
      v9 = GScr_GetEntity(0);
      v8 = v9;
      if ( !v9->client && !v9->agent )
        Scr_ParamError(COM_ERR_4311, scrContext, 0, "Entity is not a player or agent");
    }
    else
    {
      v8 = g_entities + 2046;
    }
    EntHandle::setEnt(&Entity->parent, v8);
  }
  G_Missile_Explode(Entity);
}

/*
==============
GScr_FilterOutPlayerMarks
==============
*/
void GScr_FilterOutPlayerMarks(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  GScr_FilterPlayerMarks_Internal(scrContext, (unsigned int (*)[7])Entity->markFilterOut);
}

/*
==============
GScr_FilterInPlayerMarks
==============
*/
void GScr_FilterInPlayerMarks(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  GScr_FilterPlayerMarks_Internal(scrContext, (unsigned int (*)[7])Entity->markFilterIn);
}

/*
==============
GScr_GetPlayerMarks
==============
*/
void GScr_GetPlayerMarks(scrContext_t *scrContext, scr_entref_t entref)
{
  scr_string_t MarkName; 

  _RBX = GetEntity(entref);
  Scr_MakeArray(scrContext);
  for ( LOBYTE(_RBX) = _RBX->markFlags; (_BYTE)_RBX; LODWORD(_RBX) = (unsigned __int8)_RBX ^ (1 << _EDI) )
  {
    LODWORD(_RBX) = (unsigned __int8)_RBX;
    __asm { tzcnt   edi, ebx }
    MarkName = G_EntityMarks_GetMarkName((const EntityMarkType)_EDI);
    Scr_AddConstString(scrContext, MarkName);
    Scr_AddArray(scrContext);
  }
}

/*
==============
GScr_SetPlayerIgnoreRadiusDamage
==============
*/
void GScr_SetPlayerIgnoreRadiusDamage(scrContext_t *scrContext)
{
  level.bPlayerIgnoreRadiusDamageLatched = Scr_GetInt(scrContext, 0);
}

/*
==============
GScr_GetPlayerRateOfGameRevenue
==============
*/
void GScr_GetPlayerRateOfGameRevenue(scrContext_t *scrContext)
{
  float v2; 
  gclient_s *client; 

  v2 = FLOAT_1_0;
  if ( g_wegame_platform->current.enabled && Scr_GetType(scrContext, 0) == VAR_POINTER && Scr_GetPointerType(scrContext, 0) == VAR_ENTITY )
  {
    client = GScr_GetEntity(0)->client;
    if ( client )
      v2 = client->sess.extraGameRevenueRate + 1.0;
  }
  Scr_AddFloat(scrContext, v2);
}

/*
==============
GScr_DamageConeTrace
==============
*/
void GScr_DamageConeTrace(scrContext_t *scrContext, scr_entref_t entref)
{
  GScr_DamageConeTraceInternal(scrContext, entref, 9441297);
}

/*
==============
GScr_GetBnetIGRPlayerXPMultiplier
==============
*/
void GScr_GetBnetIGRPlayerXPMultiplier(scrContext_t *scrContext)
{
  Scr_AddFloat(scrContext, 1.0);
}

/*
==============
GScr_SightConeTrace
==============
*/
void GScr_SightConeTrace(scrContext_t *scrContext, scr_entref_t entref)
{
  GScr_DamageConeTraceInternal(scrContext, entref, 2049);
}

/*
==============
GScr_GetBnetIGRWeaponXPMultiplier
==============
*/
void GScr_GetBnetIGRWeaponXPMultiplier(scrContext_t *scrContext)
{
  Scr_AddFloat(scrContext, 1.0);
}

/*
==============
GScr_ShellShock
==============
*/
void GScr_ShellShock(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  playerState_s *EntityPlayerState; 
  const char *String; 
  const char *v11; 
  int v12; 
  int v15; 
  const char *v16; 
  int v17; 
  __int64 v18; 
  unsigned int Animset; 
  unsigned int Anim; 
  bool IsThrowAnim; 
  SuitAnimType SuitAnimIndexFromPlayerState; 
  unsigned __int64 weaponState; 
  __int64 v24; 
  unsigned int *holdrand; 
  GHandler *Handler; 
  unsigned int outIndex; 

  entnum = entref.entnum;
  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 14595, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClientOrAgent(Entity) )
  {
    targetname = Entity->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(Entity->classname);
    v8 = j_va("only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, Entity->r.currentOrigin.v[0], Entity->r.currentOrigin.v[1], Entity->r.currentOrigin.v[2], v7, v6);
    Scr_Error(COM_ERR_4312, scrContext, v8);
  }
  EntityPlayerState = G_GetEntityPlayerState(Entity);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 14601, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( Scr_GetNumParam(scrContext) < 2 )
    Scr_Error(COM_ERR_4313, scrContext, "USAGE: <player> shellshock(<shellshockname>, <duration>)\n");
  String = Scr_GetString(scrContext, 0);
  if ( !NetConstStrings_GetIndexPlusOneFromName(NETCONSTSTRINGTYPE_SHOCK, String, &outIndex) )
  {
    v11 = j_va("Shellshock '%s' does not exist", String);
    Scr_Error(COM_ERR_4314, scrContext, v11);
  }
  if ( !outIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 14613, ASSERT_TYPE_ASSERT, "(shockIndex != 0)", "%s\n\tWe use 0 as a sentinel value for the shellshock index to mean no shock, so start at index 1.", "shockIndex != 0") )
    __debugbreak();
  v12 = 1;
  Scr_GetFloat(scrContext, 1u);
  _XMM0 = 0i64;
  __asm { vroundss xmm1, xmm0, xmm4, 1 }
  v15 = (int)*(float *)&_XMM1;
  if ( (int)*(float *)&_XMM1 < 0 )
  {
    v16 = j_va("duration %g should be >= 0", (float)((float)v15 * 0.001));
    Scr_ParamError(COM_ERR_4315, scrContext, 1u, v16);
  }
  v17 = 0xFFFF;
  EntityPlayerState->shellshockIndex = outIndex;
  if ( v15 < 0xFFFF )
    v17 = (int)*(float *)&_XMM1;
  EntityPlayerState->shellshockTime = level.time;
  EntityPlayerState->shellshockDuration = truncate_cast<unsigned short,int>(v17);
  if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_STILL_LAND|0x80) )
  {
    GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::SetFlagInternal(&EntityPlayerState->pm_flags, ACTIVE, 0x15u);
  }
  else if ( Entity->health > 0 )
  {
    GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::SetFlagInternal(&EntityPlayerState->pm_flags, ACTIVE, 0x15u);
    if ( Scr_GetNumParam(scrContext) < 3 || Scr_GetInt(scrContext, 2u) )
    {
      v18 = *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 272i64);
      if ( !v18 )
        goto LABEL_45;
      if ( !*(_QWORD *)&GStatic::ms_gameStatics && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_static.h", 64, ASSERT_TYPE_ASSERT, "( ms_gameStatics )", (const char *)&queryFormat, "ms_gameStatics") )
        __debugbreak();
      if ( v18 != *(_QWORD *)&GStatic::ms_gameStatics )
      {
LABEL_45:
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 14641, ASSERT_TYPE_ASSERT, "(BgStatic::HasActiveStatics() && (BgStatic::GetActiveStatics() == GStatic::GetGameStatics()))", "%s\n\tEntering server game character processing without a valid client game state", "BgStatic::HasActiveStatics() && (BgStatic::GetActiveStatics() == GStatic::GetGameStatics())") )
          __debugbreak();
      }
      if ( PlayerASM_IsEnabled() )
      {
        Animset = BG_PlayerASM_GetAnimset(EntityPlayerState);
        Anim = BG_PlayerASM_GetAnim(EntityPlayerState, DODGE);
        IsThrowAnim = BG_PlayerASM_IsThrowAlias(Anim, Animset) != 0;
      }
      else
      {
        SuitAnimIndexFromPlayerState = BG_GetSuitAnimIndexFromPlayerState(EntityPlayerState);
        IsThrowAnim = BG_IsThrowAnim(EntityPlayerState->torsoAnim, SuitAnimIndexFromPlayerState);
      }
      weaponState = EntityPlayerState->weapState[0].weaponState;
      if ( (unsigned int)weaponState <= 0x32 && (v24 = 0x4000000001FBEi64, _bittest64(&v24, weaponState)) || IsThrowAnim )
        v12 = 0;
      holdrand = G_GetRandomSeed();
      Handler = GHandler::getHandler();
      BG_AnimScriptEvent(Handler, EntityPlayerState, ANIM_ET_SHELLSHOCK, 0, v12, holdrand);
    }
  }
}

/*
==============
GScr_GetBnetIGRBattlePassXPMultiplier
==============
*/
void GScr_GetBnetIGRBattlePassXPMultiplier(scrContext_t *scrContext)
{
  Scr_AddFloat(scrContext, 1.0);
}

/*
==============
GScr_GetBuildVersion
==============
*/
void GScr_GetBuildVersion(scrContext_t *scrContext)
{
  Scr_AddString(scrContext, "IW8_DEV");
}

/*
==============
GScr_GetBuildNumber
==============
*/
void GScr_GetBuildNumber(scrContext_t *scrContext)
{
  int BuildNumberAsInt; 

  BuildNumberAsInt = j_getBuildNumberAsInt();
  Scr_AddInt(scrContext, BuildNumberAsInt);
}

/*
==============
GScr_SpawnBrCircle
==============
*/
void GScr_SpawnBrCircle(scrContext_t *scrContext)
{
  scr_string_t script_model; 
  double Float; 
  float v4; 
  double v5; 
  float v6; 
  double v7; 
  gentity_s *v8; 

  script_model = scr_const.script_model;
  Float = Scr_GetFloat(scrContext, 0);
  v4 = *(float *)&Float;
  v5 = Scr_GetFloat(scrContext, 1u);
  v6 = *(float *)&v5;
  v7 = Scr_GetFloat(scrContext, 2u);
  v8 = G_Utils_SpawnEntity();
  Scr_SetString(&v8->script_classname, script_model);
  v8->spawnflags = 0;
  v8->r.currentOrigin.v[0] = v4;
  v8->r.currentOrigin.v[1] = v6;
  v8->r.currentOrigin.v[2] = *(float *)&v7;
  if ( G_Spawn_CallForEntity(v8) )
  {
    v8->s.un.scriptMoverType = 9;
    GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(&v8->s.lerp.eFlags, ACTIVE, 0);
    GScr_AddEntity(v8);
  }
  else
  {
    G_FreeEntity(v8);
    Scr_Error(COM_ERR_5936, scrContext, "unable to spawn br circle");
  }
}

/*
==============
GScr_SpawnMapCircle
==============
*/
void GScr_SpawnMapCircle(scrContext_t *scrContext)
{
  scr_string_t script_model; 
  unsigned int NumParam; 
  gentity_s *v4; 
  gentity_s *Entity; 
  const char *v6; 
  double Float; 
  float v8; 
  double v9; 
  float v10; 
  double v11; 
  gentity_s *v12; 

  script_model = scr_const.script_model;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam - 3 > 1 )
  {
    Scr_Error(COM_ERR_6076, scrContext, "Usage: SpawnMapCircle( <x>, <y>, <initial_radius>, [owner] )");
  }
  else
  {
    v4 = NULL;
    if ( NumParam == 4 && Scr_GetType(scrContext, 3u) == VAR_POINTER && Scr_GetPointerType(scrContext, 3u) == VAR_ENTITY )
    {
      Entity = GScr_GetEntity(3u);
      v4 = Entity;
      if ( !Entity->client )
      {
        v6 = j_va("Owner entity %i is not a player", (unsigned int)Entity->s.number);
        Scr_ObjectError(COM_ERR_6569, scrContext, v6);
      }
    }
    Float = Scr_GetFloat(scrContext, 0);
    v8 = *(float *)&Float;
    v9 = Scr_GetFloat(scrContext, 1u);
    v10 = *(float *)&v9;
    v11 = Scr_GetFloat(scrContext, 2u);
    v12 = G_Utils_SpawnEntity();
    Scr_SetString(&v12->script_classname, script_model);
    v12->spawnflags = 0;
    v12->r.currentOrigin.v[0] = v8;
    v12->r.currentOrigin.v[1] = v10;
    v12->r.currentOrigin.v[2] = *(float *)&v11;
    if ( G_Spawn_CallForEntity(v12) )
    {
      v12->s.un.scriptMoverType = 10;
      GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(&v12->s.lerp.eFlags, ACTIVE, 0);
      v12->s.staticState.player.stowedWeaponHandle.m_mapEntryId &= 0xFFFC0000;
      if ( v4 )
        v12->s.otherEntityNum = v4->s.number;
      GScr_AddEntity(v12);
    }
    else
    {
      G_FreeEntity(v12);
      Scr_Error(COM_ERR_6074, scrContext, "unable to spawn map circle");
    }
  }
}

/*
==============
GScr_SetMapCircleColorIndex
==============
*/
void GScr_SetMapCircleColorIndex(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  char Int; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( Entity->s.eType == ET_SCRIPTMOVER && Entity->s.un.scriptMoverType == 10 )
  {
    if ( Scr_GetNumParam(scrContext) == 1 )
    {
      Int = Scr_GetInt(scrContext, 0);
      v4->s.staticState.player.stowedWeaponHandle.m_mapEntryId &= 0xFFFFFFC0;
      v4->s.staticState.player.stowedWeaponHandle.m_mapEntryId |= Int & 0x3F;
    }
    else
    {
      Scr_Error(COM_ERR_6571, scrContext, "Usage: SetMapCircleColorIndex( <idx> )");
    }
  }
  else
  {
    Scr_Error(COM_ERR_6570, scrContext, " SetMapCircleColorIndex() called on an entity that is not a map circle.\n");
  }
}

/*
==============
GScr_SetMapCircleStyleIndex
==============
*/
void GScr_SetMapCircleStyleIndex(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  char Int; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( Entity->s.eType == ET_SCRIPTMOVER && Entity->s.un.scriptMoverType == 10 )
  {
    if ( Scr_GetNumParam(scrContext) == 1 )
    {
      Int = Scr_GetInt(scrContext, 0);
      v4->s.staticState.player.stowedWeaponHandle.m_mapEntryId &= 0xFFFFF03F;
      v4->s.staticState.player.stowedWeaponHandle.m_mapEntryId |= (Int & 0x3F) << 6;
    }
    else
    {
      Scr_Error(COM_ERR_6154, scrContext, "Usage: SetMapCircleStyleIndex( <idx> )");
    }
  }
  else
  {
    Scr_Error(COM_ERR_6153, scrContext, " SetMapCircleStyleIndex() called on an entity that is not a map circle.\n");
  }
}

/*
==============
GScr_StunPlayer
==============
*/
void GScr_StunPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  playerState_s *EntityPlayerState; 
  int v12; 
  const char *v13; 

  entnum = entref.entnum;
  Entity = GetEntity(entref);
  if ( !G_Utils_IsClientOrAgent(Entity) )
  {
    targetname = Entity->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(Entity->classname);
    v8 = j_va("only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, Entity->r.currentOrigin.v[0], Entity->r.currentOrigin.v[1], Entity->r.currentOrigin.v[2], v7, v6);
    Scr_Error(COM_ERR_4316, scrContext, v8);
  }
  EntityPlayerState = G_GetEntityPlayerState(Entity);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 14682, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
    __debugbreak();
  Scr_GetFloat(scrContext, 0);
  _XMM0 = 0i64;
  __asm { vroundss xmm1, xmm0, xmm4, 1 }
  v12 = (int)*(float *)&_XMM1;
  if ( (int)*(float *)&_XMM1 < 0 )
  {
    v13 = j_va("duration %g should be >= 0", (float)((float)v12 * 0.001));
    Scr_ParamError(COM_ERR_4317, scrContext, 0, v13);
  }
  EntityPlayerState->stunTime = v12 + level.time;
}

/*
==============
GScr_SetMapCircleIconIndex
==============
*/
void GScr_SetMapCircleIconIndex(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  char Int; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( Entity->s.eType == ET_SCRIPTMOVER && Entity->s.un.scriptMoverType == 10 )
  {
    if ( Scr_GetNumParam(scrContext) == 1 )
    {
      Int = Scr_GetInt(scrContext, 0);
      v4->s.staticState.player.stowedWeaponHandle.m_mapEntryId &= 0xFFFC0FFF;
      v4->s.staticState.player.stowedWeaponHandle.m_mapEntryId |= (Int & 0x3F) << 12;
    }
    else
    {
      Scr_Error(COM_ERR_6156, scrContext, "Usage: SetMapCircleIconIndex( <idx> )");
    }
  }
  else
  {
    Scr_Error(COM_ERR_6155, scrContext, " SetMapCircleIconIndex() called on an entity that is not a map circle.\n");
  }
}

/*
==============
GScr_GetMoveDelta
==============
*/
void GScr_GetMoveDelta(scrContext_t *scrContext)
{
  float v1; 
  float v3; 
  unsigned int v4; 
  double Float; 
  double v6; 
  int linkPointer; 
  unsigned int v8; 
  const XAnim_s *Anims; 
  vec3_t trans; 
  vec4_t rot; 

  v1 = FLOAT_1_0;
  v3 = 0.0;
  v4 = Scr_GetNumParam(scrContext) - 1;
  if ( v4 )
  {
    if ( v4 != 1 )
    {
      Float = Scr_GetFloat(scrContext, 2u);
      v1 = *(float *)&Float;
      if ( *(float *)&Float < 0.0 || *(float *)&Float > 1.0 )
        Scr_ParamError(COM_ERR_4318, scrContext, 2u, "end time must be between 0 and 1");
    }
    v6 = Scr_GetFloat(scrContext, 1u);
    v3 = *(float *)&v6;
    if ( *(float *)&v6 < 0.0 || *(float *)&v6 > 1.0 )
      Scr_ParamError(COM_ERR_4319, scrContext, 1u, "start time must be between 0 and 1");
  }
  linkPointer = Scr_GetAnim(scrContext, 0, NULL).linkPointer;
  v8 = (unsigned __int16)linkPointer;
  Anims = Scr_GetAnims(scrContext, HIWORD(linkPointer));
  XAnimGetRelDelta3D(Anims, v8, &rot, &trans, v3, v1);
  Scr_AddVector(scrContext, trans.v);
}

/*
==============
GScr_NvidiaHighlightsRequestPermissions
==============
*/
void GScr_NvidiaHighlightsRequestPermissions(scrContext_t *scrContext)
{
  ;
}

/*
==============
GScr_NvidiaHighlightsIsEnabled
==============
*/
void GScr_NvidiaHighlightsIsEnabled(scrContext_t *scrContext)
{
  Scr_AddBool(scrContext, 0);
}

/*
==============
GScr_NvidiaHighlightsBeginGroup
==============
*/
void GScr_NvidiaHighlightsBeginGroup(scrContext_t *scrContext)
{
  ;
}

/*
==============
GScr_NvidiaHighlightsEndGroup
==============
*/
void GScr_NvidiaHighlightsEndGroup(scrContext_t *scrContext)
{
  ;
}

/*
==============
GScr_NvidiaHighlightsScreenshot
==============
*/
void GScr_NvidiaHighlightsScreenshot(scrContext_t *scrContext)
{
  ;
}

/*
==============
GScr_NvidiaHighlightsVideo
==============
*/
void GScr_NvidiaHighlightsVideo(scrContext_t *scrContext)
{
  ;
}

/*
==============
GScr_NvidiaHighlightsGetCount
==============
*/
void GScr_NvidiaHighlightsGetCount(scrContext_t *scrContext)
{
  ;
}

/*
==============
GScr_NvidiaHighlightsSummary
==============
*/
void GScr_NvidiaHighlightsSummary(scrContext_t *scrContext)
{
  ;
}

/*
==============
GScr_NvidiaHighlightsCleanup
==============
*/
void GScr_NvidiaHighlightsCleanup(scrContext_t *scrContext)
{
  ;
}

/*
==============
GScr_NvidiaAnselIsEnabled
==============
*/
void GScr_NvidiaAnselIsEnabled(scrContext_t *scrContext)
{
  Scr_AddBool(scrContext, 0);
}

/*
==============
GScr_GetAngleDelta
==============
*/
void GScr_GetAngleDelta(scrContext_t *scrContext)
{
  float v1; 
  float v3; 
  unsigned int v4; 
  double Float; 
  double v6; 
  int linkPointer; 
  unsigned __int16 v8; 
  const XAnim_s *Anims; 
  double v10; 
  vec2_t rot; 
  vec3_t trans; 

  v1 = FLOAT_1_0;
  v3 = 0.0;
  v4 = Scr_GetNumParam(scrContext) - 1;
  if ( v4 )
  {
    if ( v4 != 1 )
    {
      Float = Scr_GetFloat(scrContext, 2u);
      v1 = *(float *)&Float;
      if ( *(float *)&Float < 0.0 || *(float *)&Float > 1.0 )
        Scr_ParamError(COM_ERR_4320, scrContext, 2u, "end time must be between 0 and 1");
    }
    v6 = Scr_GetFloat(scrContext, 1u);
    v3 = *(float *)&v6;
    if ( *(float *)&v6 < 0.0 || *(float *)&v6 > 1.0 )
      Scr_ParamError(COM_ERR_4321, scrContext, 1u, "start time must be between 0 and 1");
  }
  linkPointer = Scr_GetAnim(scrContext, 0, NULL).linkPointer;
  v8 = linkPointer;
  Anims = Scr_GetAnims(scrContext, HIWORD(linkPointer));
  XAnimGetRelDelta(Anims, v8, &rot, &trans, v3, v1);
  v10 = RotationToYaw(&rot);
  Scr_AddFloat(scrContext, *(float *)&v10);
}

/*
==============
Scr_StreamSetMaterialTouchUntilLoaded
==============
*/
void Scr_StreamSetMaterialTouchUntilLoaded(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *String; 
  const char *v5; 
  unsigned int v6; 
  const char *v7; 
  const char *v8; 
  unsigned int number; 
  const char *v10; 
  SvClient *CommonClient; 

  Entity = GetEntity(entref);
  if ( !Entity->client )
    Scr_ObjectError(COM_ERR_6300, scrContext, "StreamSetMaterialTouchUntilLoaded can only be called on players");
  String = Scr_GetString(scrContext, 0);
  v5 = String;
  if ( !String || !*String )
    Scr_ParamError(COM_ERR_6063, scrContext, 0, "Material name string is empty");
  if ( !GConfigStrings::ms_gConfigStrings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_configstrings.h", 71, ASSERT_TYPE_ASSERT, "( ms_gConfigStrings )", (const char *)&queryFormat, "ms_gConfigStrings") )
    __debugbreak();
  v6 = GConfigStrings::ms_gConfigStrings->GetMaterialIndex(GConfigStrings::ms_gConfigStrings, v5);
  if ( !v6 )
  {
    v7 = j_va("Material '%s' is not precached.", v5);
    Scr_ParamError(COM_ERR_6064, scrContext, 0, v7);
  }
  v8 = j_va("%c %i", 98i64, v6);
  number = Entity->s.number;
  v10 = v8;
  if ( number == -1 )
  {
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v8);
  }
  else
  {
    CommonClient = SvClient::GetCommonClient(number);
    CommonClient->SendServerCommand(CommonClient, SV_CMD_RELIABLE, v10);
  }
}

/*
==============
GScr_GetAngleDelta3D
==============
*/
void GScr_GetAngleDelta3D(scrContext_t *scrContext)
{
  float v1; 
  float v3; 
  unsigned int v4; 
  double Float; 
  double v6; 
  int linkPointer; 
  unsigned int v8; 
  const XAnim_s *Anims; 
  vec3_t angles; 
  vec4_t rot; 
  vec3_t trans; 
  tmat33_t<vec3_t> axis; 

  v1 = FLOAT_1_0;
  v3 = 0.0;
  v4 = Scr_GetNumParam(scrContext) - 1;
  if ( v4 )
  {
    if ( v4 != 1 )
    {
      Float = Scr_GetFloat(scrContext, 2u);
      v1 = *(float *)&Float;
      if ( *(float *)&Float < 0.0 || *(float *)&Float > 1.0 )
        Scr_ParamError(COM_ERR_4322, scrContext, 2u, "end time must be between 0 and 1");
    }
    v6 = Scr_GetFloat(scrContext, 1u);
    v3 = *(float *)&v6;
    if ( *(float *)&v6 < 0.0 || *(float *)&v6 > 1.0 )
      Scr_ParamError(COM_ERR_4323, scrContext, 1u, "start time must be between 0 and 1");
  }
  linkPointer = Scr_GetAnim(scrContext, 0, NULL).linkPointer;
  v8 = (unsigned __int16)linkPointer;
  Anims = Scr_GetAnims(scrContext, HIWORD(linkPointer));
  XAnimGetRelDelta3D(Anims, v8, &rot, &trans, v3, v1);
  QuatToAxis(&rot, &axis);
  AxisToAngles(&axis, &angles);
  Scr_AddVector(scrContext, angles.v);
}

/*
==============
GScr_ScriptableIsLootCache
==============
*/
void GScr_ScriptableIsLootCache(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  unsigned int v4; 
  const ScriptableDef *def; 
  const BG_SpawnGroup_Loot_ItemDef *LootItemDef; 
  unsigned __int8 itemTypeIndexCache; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  v4 = ScriptableIndex_Internal;
  if ( ScriptableIndex_Internal == -1 )
  {
    Scr_Error(COM_ERR_6425, scrContext, "Invalid scriptable index");
  }
  else
  {
    def = ScriptableSv_GetInstanceCommonContext(ScriptableIndex_Internal)->def;
    if ( def && (def->flags & 0x20000) != 0 && (LootItemDef = ScriptableSv_GetLootItemDef(v4)) != NULL && (itemTypeIndexCache = ScriptableSv_GetLootTable()->itemTypeIndexCache, itemTypeIndexCache != 0xFF) )
      Scr_AddBool(scrContext, itemTypeIndexCache == LootItemDef->type);
    else
      Scr_AddBool(scrContext, 0);
  }
}

/*
==============
GScr_GetNorthYaw
==============
*/
void GScr_GetNorthYaw(scrContext_t *scrContext)
{
  char buffer[32]; 

  SV_GetConfigstring(9u, buffer, 32);
  *(double *)&_XMM0 = atof(buffer);
  __asm { vcvtsd2ss xmm1, xmm0, xmm0; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
GScr_ScriptableGetMidPoint
==============
*/
void GScr_ScriptableGetMidPoint(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  ScriptableInstanceContext *InstanceCommonContext; 
  const XModel *ScriptableModel; 
  float value; 
  float v7; 
  float v8; 
  vec3_t out; 
  tmat33_t<vec3_t> axis; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal == -1 )
  {
    Scr_Error(COM_ERR_6426, scrContext, "Invalid scriptable index");
  }
  else
  {
    InstanceCommonContext = ScriptableSv_GetInstanceCommonContext(ScriptableIndex_Internal);
    ScriptableModel = BG_XCompositeModel_GetScriptableModel(InstanceCommonContext);
    if ( ScriptableModel )
    {
      AnglesToAxis(&InstanceCommonContext->angles, &axis);
      MatrixTransformVector(&ScriptableModel->bounds.midPoint, &axis, &out);
      value = out.v[0] + InstanceCommonContext->origin.v[0];
      v7 = out.v[1] + InstanceCommonContext->origin.v[1];
      v8 = out.v[2] + InstanceCommonContext->origin.v[2];
    }
    else
    {
      value = InstanceCommonContext->origin.v[0];
      v7 = InstanceCommonContext->origin.v[1];
      v8 = InstanceCommonContext->origin.v[2];
    }
    Scr_AddVector(scrContext, &value);
  }
}

/*
==============
Scr_IsVFXFile
==============
*/
void Scr_IsVFXFile(scrContext_t *scrContext)
{
  unsigned int Int; 
  const char *v3; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4324, scrContext, "Incorrect number of parameters");
  Int = Scr_GetInt(scrContext, 0);
  if ( !FX_IsValidFxId(Int) )
  {
    v3 = j_va("IsVFXFile: invalid effect id %d", Int);
    Scr_Error(COM_ERR_4325, scrContext, v3);
  }
  Scr_AddBool(scrContext, 1);
}

/*
==============
GScr_ScriptableDoorFreeze
==============
*/
void GScr_ScriptableDoorFreeze(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  bool v4; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal == -1 )
  {
    Scr_Error(COM_ERR_6182, scrContext, "Invalid scriptable index");
  }
  else
  {
    v4 = 1;
    if ( Scr_GetNumParam(scrContext) )
      v4 = Scr_GetInt(scrContext, 0) != 0;
    G_Door_Freeze(v4, ScriptableIndex_Internal);
  }
}

/*
==============
GScr_ScriptableDoorIsClosed
==============
*/
void GScr_ScriptableDoorIsClosed(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  bool IsClosed; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal == -1 )
  {
    Scr_Error(COM_ERR_6183, scrContext, "Invalid scriptable index");
  }
  else
  {
    IsClosed = G_Door_IsClosed(ScriptableIndex_Internal);
    Scr_AddBool(scrContext, IsClosed);
  }
}

/*
==============
GScr_ScriptableDoorIsOwned
==============
*/
void GScr_ScriptableDoorIsOwned(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  int Owner; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal == -1 )
  {
    Scr_Error(COM_ERR_6184, scrContext, "Invalid scriptable index");
  }
  else
  {
    Owner = G_Door_GetOwner(ScriptableIndex_Internal);
    Scr_AddBool(scrContext, Owner != -1);
  }
}

/*
==============
GScr_ScriptableIsDoor
==============
*/
void GScr_ScriptableIsDoor(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  const ScriptableDef *def; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal == -1 )
  {
    Scr_Error(COM_ERR_6185, scrContext, "Invalid scriptable index");
  }
  else
  {
    def = ScriptableSv_GetInstanceCommonContext(ScriptableIndex_Internal)->def;
    if ( def )
      Scr_AddBool(scrContext, (def->flags & 0x180000) != 0);
    else
      Scr_AddBool(scrContext, 0);
  }
}

/*
==============
Scr_LoadFX
==============
*/
void Scr_LoadFX(scrContext_t *scrContext)
{
  const char *v2; 
  char *String; 
  __int64 v4; 
  char v5; 
  __int64 v6; 
  char v7; 
  const char *v8; 
  __int64 v9; 
  char v10; 
  __int64 v11; 
  char v12; 
  char *v13; 
  int v14; 
  char dest[128]; 

  v2 = "fx/";
  String = (char *)Scr_GetString(scrContext, 0);
  v4 = 3i64;
  if ( !String && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 181, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
    __debugbreak();
  do
  {
    v5 = v2[String - "fx/"];
    v6 = v4;
    v7 = *v2++;
    --v4;
    if ( !v6 )
      break;
    if ( v5 != v7 )
    {
      v8 = "vfx/";
      v9 = 4i64;
      if ( !String && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 181, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
        __debugbreak();
      while ( 1 )
      {
        v10 = v8[String - "vfx/"];
        v11 = v9;
        v12 = *v8++;
        --v9;
        if ( !v11 )
          goto LABEL_16;
        if ( v10 != v12 )
        {
          Scr_ParamError(COM_ERR_4327, scrContext, 0, "effect name must start with 'fx/' or 'vfx/'");
          goto LABEL_16;
        }
        if ( !v10 )
          goto LABEL_16;
      }
    }
  }
  while ( v5 );
LABEL_16:
  v13 = strrchr_0(String, 46);
  if ( v13 )
  {
    Core_strncpy_truncate(dest, 0x80ui64, String, v13 - String);
    String = dest;
  }
  if ( !GConfigStrings::ms_gConfigStrings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_configstrings.h", 71, ASSERT_TYPE_ASSERT, "( ms_gConfigStrings )", (const char *)&queryFormat, "ms_gConfigStrings") )
    __debugbreak();
  v14 = GConfigStrings::ms_gConfigStrings->GetEffectIndex(GConfigStrings::ms_gConfigStrings, String);
  if ( !v14 )
  {
    if ( level.initializing )
      Com_PrintError(23, "Could not allocate/find effect ID for '%s'\n", String);
    else
      Scr_Error(COM_ERR_4328, scrContext, "loadFx must be called before any wait statements in the level script, or on an already loaded effect\n");
  }
  Scr_AddInt(scrContext, v14);
}

/*
==============
GScr_ScriptableDoorIsDouble
==============
*/
void GScr_ScriptableDoorIsDouble(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  ScriptableInstanceContext *InstanceCommonContext; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal == -1 )
  {
    Scr_Error(COM_ERR_6186, scrContext, "Invalid scriptable index");
  }
  else
  {
    InstanceCommonContext = ScriptableSv_GetInstanceCommonContext(ScriptableIndex_Internal);
    if ( InstanceCommonContext->def )
      Scr_AddBool(scrContext, ((unsigned int)InstanceCommonContext->def->flags >> 20) & 1);
    else
      Scr_AddBool(scrContext, 0);
  }
}

/*
==============
GScr_ScriptableDoorAngle
==============
*/
void GScr_ScriptableDoorAngle(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  double DeltaAngle; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal == -1 )
  {
    Scr_Error(COM_ERR_6187, scrContext, "Invalid scriptable index");
  }
  else
  {
    DeltaAngle = G_Door_GetDeltaAngle(ScriptableIndex_Internal);
    Scr_AddFloat(scrContext, *(float *)&DeltaAngle);
  }
}

/*
==============
GScr_ScriptableDoorOpen
==============
*/
void GScr_ScriptableDoorOpen(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 
  scr_string_t ConstString; 
  DoorMoveType v5; 
  vec3_t v6; 
  vec3_t vectorValue; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal == -1 )
  {
    Scr_Error(COM_ERR_6188, scrContext, "Invalid scriptable index");
    return;
  }
  if ( !Scr_GetNumParam(scrContext) || (ConstString = Scr_GetConstString(scrContext, 0), ConstString == scr_const.left) )
  {
    v5 = DOOR_MOVE_OPEN_LEFT_RELIABLE;
    goto LABEL_14;
  }
  if ( ConstString == scr_const.right )
  {
    v5 = DOOR_MOVE_OPEN_RIGHT_RELIABLE;
LABEL_14:
    G_Door_MoveReliably(ScriptableIndex_Internal, v5);
    return;
  }
  if ( ConstString == scr_const.away )
  {
    if ( Scr_GetNumParam(scrContext) == 2 && Scr_GetType(scrContext, 1u) == VAR_VECTOR )
    {
      Scr_GetVector(scrContext, 1u, &vectorValue);
      v6 = vectorValue;
      G_Door_OpenReliablyFromPosition(ScriptableIndex_Internal, &v6);
    }
    else
    {
      Scr_Error(COM_ERR_6189, scrContext, "ScriptableDoorOpen - Bad openAwayFromPosition input");
    }
  }
  else
  {
    Scr_Error(COM_ERR_6190, scrContext, "ScriptableDoorOpen - Bad openDir input");
  }
}

/*
==============
GScr_ScriptableDoorClose
==============
*/
void GScr_ScriptableDoorClose(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ScriptableIndex_Internal; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal == -1 )
    Scr_Error(COM_ERR_6191, scrContext, "Invalid scriptable index");
  else
    G_Door_MoveReliably(ScriptableIndex_Internal, DOOR_MOVE_CLOSE_RELIABLE);
}

/*
==============
ScrCmd_HasTacVis
==============
*/
void ScrCmd_HasTacVis(scrContext_t *scrContext)
{
  int v1; 
  const tacpoint_t *PointForPathnodeVis; 
  const tacpoint_t *ClosestPoint; 
  VariableType Type; 
  const tacpoint_t *PointForPathnode; 
  sentient_s *sentient; 
  const pathnode_t *Pathnode; 
  bool HasVis; 
  scr_entref_t EntityRef; 
  vec3_t vectorValue; 

  v1 = 0;
  PointForPathnodeVis = NULL;
  Scr_GetVector(scrContext, 0, &vectorValue);
  ClosestPoint = TacGraph_FindClosestPoint(&vectorValue);
  if ( ClosestPoint )
  {
    Type = Scr_GetType(scrContext, 1u);
    if ( Type == VAR_VECTOR )
    {
      Scr_GetVector(scrContext, 1u, &vectorValue);
      PointForPathnode = TacGraph_FindClosestPoint(&vectorValue);
    }
    else
    {
      if ( Type != VAR_POINTER || Scr_GetPointerType(scrContext, 1u) != VAR_ENTITY )
        goto LABEL_18;
      EntityRef = Scr_GetEntityRef(scrContext, 1u);
      if ( EntityRef.entclass )
      {
        if ( EntityRef.entclass != ENTITY_CLASS_PATHNODE )
          goto LABEL_18;
        Pathnode = Scr_GetPathnode(scrContext, 1u);
        PointForPathnode = TacGraph_GetPointForPathnode(Pathnode);
        if ( Scr_GetNumParam(scrContext) > 2 && Scr_GetInt(scrContext, 2u) )
          PointForPathnodeVis = TacGraph_GetPointForPathnodeVis(Pathnode);
      }
      else
      {
        sentient = GScr_GetEntity(1u)->sentient;
        if ( !sentient )
          goto LABEL_18;
        PointForPathnode = Sentient_NearestTacPoint(sentient);
      }
    }
    if ( PointForPathnode )
    {
      HasVis = TacVisGraph_HasVis(ClosestPoint, PointForPathnode);
      if ( HasVis && PointForPathnodeVis )
        HasVis = TacVisGraph_HasVis(ClosestPoint, PointForPathnodeVis);
      v1 = HasVis;
    }
  }
LABEL_18:
  Scr_AddBool(scrContext, v1);
}

/*
==============
Scr_PlayFX
==============
*/
void Scr_PlayFX(scrContext_t *scrContext)
{
  int NumParam; 
  vec3_t *v3; 
  __int16 *p_number; 
  gentity_s *Entity; 
  const char *v6; 
  int Int; 
  vec3_t *v8; 
  gentity_s *v9; 
  const gentity_s *v10; 
  unsigned int v11; 
  vec3_t v12; 
  vec3_t v13; 
  vec3_t vectorValue; 

  NumParam = Scr_GetNumParam(scrContext);
  if ( (unsigned int)(NumParam - 2) > 3 )
    Scr_Error(COM_ERR_4331, scrContext, "Incorrect number of parameters");
  v3 = NULL;
  p_number = NULL;
  if ( NumParam >= 5 )
  {
    Entity = GScr_GetEntity(4u);
    p_number = &Entity->s.number;
    if ( !Entity->client )
    {
      v6 = j_va("Entity number %i is not a client", (unsigned int)Entity->s.number);
      Scr_ParamError(COM_ERR_4332, scrContext, 5u, v6);
    }
    if ( (unsigned int)*p_number >= level.maxclients && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 15069, ASSERT_TYPE_ASSERT, "(unsigned)( player->s.number ) < (unsigned)( level.maxclients )", "player->s.number doesn't index level.maxclients\n\t%i not in [0, %i)", *p_number, level.maxclients) )
      __debugbreak();
  }
  Int = Scr_GetInt(scrContext, 0);
  Scr_GetVector(scrContext, 1u, &vectorValue);
  v8 = NULL;
  if ( NumParam > 2 )
  {
    if ( Scr_GetType(scrContext, 2u) )
    {
      Scr_GetVector(scrContext, 2u, &v12);
      v3 = &v12;
    }
    if ( NumParam > 3 && Scr_GetType(scrContext, 3u) )
    {
      Scr_GetVector(scrContext, 3u, &v13);
      v8 = &v13;
    }
  }
  v9 = Scr_PlayFXInternal(scrContext, Int, &vectorValue, v3, v8);
  v10 = v9;
  if ( p_number )
  {
    *(_QWORD *)v9->clientMask.array = -1i64;
    *(_QWORD *)&v9->clientMask.array[2] = -1i64;
    *(_QWORD *)&v9->clientMask.array[4] = -1i64;
    v9->clientMask.array[6] = -1;
    v11 = *p_number;
    if ( v11 >= 0xE0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 290, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v11, 224) )
      __debugbreak();
    v10->clientMask.array[(unsigned __int64)v11 >> 5] &= ~(0x80000000 >> (v11 & 0x1F));
  }
  else
  {
    GScr_Main_ClientmaskSetAllVisible(v9);
  }
  GScr_AddEntity(v10);
}

/*
==============
Scr_PlayFXOnTag
==============
*/
void Scr_PlayFXOnTag(scrContext_t *scrContext)
{
  unsigned int Int; 
  gentity_s *Entity; 
  scr_string_t ConstLowercaseString; 

  if ( Scr_GetNumParam(scrContext) != 3 )
    Scr_Error(COM_ERR_4336, scrContext, "Incorrect number of parameters");
  Int = Scr_GetInt(scrContext, 0);
  Entity = GScr_GetEntity(1u);
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 2u);
  Scr_PlayFxOnTagInternal(scrContext, Entity, Int, ConstLowercaseString, -1);
}

/*
==============
Scr_PlayFXOnTagForClients
==============
*/
void Scr_PlayFXOnTagForClients(scrContext_t *scrContext)
{
  unsigned int Int; 
  gentity_s *Entity; 
  scr_string_t ConstLowercaseString; 
  gentity_s *v5; 
  gentity_s *v6; 
  const char *v7; 
  int number; 
  int maxclients; 

  if ( Scr_GetNumParam(scrContext) < 4 )
    Scr_Error(COM_ERR_4337, scrContext, "Incorrect number of parameters");
  Int = Scr_GetInt(scrContext, 0);
  Entity = GScr_GetEntity(1u);
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 2u);
  if ( Scr_GetType(scrContext, 3u) == VAR_ARRAY )
    Scr_ParamError(COM_ERR_4338, scrContext, 3u, "No longer support arrays of player, please specify a player entity");
  v5 = GScr_GetEntity(3u);
  v6 = v5;
  if ( !v5->client )
  {
    v7 = j_va("Entity number %i is not a client", (unsigned int)v5->s.number);
    Scr_ParamError(COM_ERR_4339, scrContext, 3u, v7);
  }
  if ( (unsigned int)v6->s.number >= level.maxclients )
  {
    maxclients = level.maxclients;
    number = v6->s.number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 15221, ASSERT_TYPE_ASSERT, "(unsigned)( player->s.number ) < (unsigned)( level.maxclients )", "player->s.number doesn't index level.maxclients\n\t%i not in [0, %i)", number, maxclients) )
      __debugbreak();
  }
  Scr_PlayFxOnTagInternal(scrContext, Entity, Int, ConstLowercaseString, v6->s.number);
}

/*
==============
Scr_StopFXOnTag
==============
*/
void Scr_StopFXOnTag(scrContext_t *scrContext)
{
  unsigned int Int; 
  gentity_s *Entity; 
  scr_string_t ConstLowercaseString; 

  if ( Scr_GetNumParam(scrContext) != 3 )
    Scr_Error(COM_ERR_4343, scrContext, "Incorrect number of parameters");
  Int = Scr_GetInt(scrContext, 0);
  Entity = GScr_GetEntity(1u);
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 2u);
  Scr_StopFxOnTagInternal(scrContext, Entity, Int, ConstLowercaseString, -1);
}

/*
==============
Scr_StopFXOnTagForClients
==============
*/
void Scr_StopFXOnTagForClients(scrContext_t *scrContext)
{
  unsigned int Int; 
  gentity_s *Entity; 
  scr_string_t ConstLowercaseString; 
  gentity_s *v5; 
  gentity_s *v6; 
  const char *v7; 
  int number; 
  int maxclients; 

  if ( Scr_GetNumParam(scrContext) < 4 )
    Scr_Error(COM_ERR_4344, scrContext, "Incorrect number of parameters");
  Int = Scr_GetInt(scrContext, 0);
  Entity = GScr_GetEntity(1u);
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 2u);
  if ( Scr_GetType(scrContext, 3u) == VAR_ARRAY )
    Scr_ParamError(COM_ERR_4345, scrContext, 3u, "No longer support arrays of player, please specify a player entity");
  v5 = GScr_GetEntity(3u);
  v6 = v5;
  if ( !v5->client )
  {
    v7 = j_va("Entity number %i is not a client", (unsigned int)v5->s.number);
    Scr_ParamError(COM_ERR_4346, scrContext, 3u, v7);
  }
  if ( (unsigned int)v6->s.number >= level.maxclients )
  {
    maxclients = level.maxclients;
    number = v6->s.number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 15317, ASSERT_TYPE_ASSERT, "(unsigned)( player->s.number ) < (unsigned)( level.maxclients )", "player->s.number doesn't index level.maxclients\n\t%i not in [0, %i)", number, maxclients) )
      __debugbreak();
  }
  Scr_StopFxOnTagInternal(scrContext, Entity, Int, ConstLowercaseString, v6->s.number);
}

/*
==============
Scr_KillFXOnTag
==============
*/
void Scr_KillFXOnTag(scrContext_t *scrContext)
{
  unsigned int Int; 
  const char *v3; 
  gentity_s *Entity; 
  scr_string_t ConstLowercaseString; 
  const char *v6; 
  int BoneIndex; 
  const char *ModelName; 
  const char *v9; 
  const char *v10; 
  unsigned int FxEventParam; 

  if ( Scr_GetNumParam(scrContext) != 3 )
    Scr_Error(COM_ERR_4347, scrContext, "Incorrect number of parameters");
  Int = Scr_GetInt(scrContext, 0);
  if ( !FX_IsValidFxId(Int) )
  {
    v3 = j_va("effect id %i is invalid\n", Int);
    Scr_ParamError(COM_ERR_4348, scrContext, 0, v3);
  }
  Entity = GScr_GetEntity(1u);
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 2u);
  v6 = SL_ConvertToString(ConstLowercaseString);
  if ( strchr_0(v6, 34) )
    Scr_ParamError(COM_ERR_4349, scrContext, 2u, "cannot use \" characters in tag names\n");
  BoneIndex = SV_Game_DObjGetBoneIndex(Entity, ConstLowercaseString);
  if ( BoneIndex < 0 )
  {
    SV_Game_DObjDumpInfo(Entity);
    ModelName = G_CString_GetModelName(Entity->model);
    v9 = SL_ConvertToString(ConstLowercaseString);
    v10 = j_va("tag '%s' does not exist on entity with model '%s'", v9, ModelName);
    Scr_ParamError(COM_ERR_4350, scrContext, 2u, v10);
  }
  FxEventParam = Scr_GetFxEventParam(Int, BoneIndex, -1);
  G_Utils_AddEvent(Entity, 0x7Eu, FxEventParam);
}

/*
==============
Scr_PlayFxOnTagsBetweenClients
==============
*/
void Scr_PlayFxOnTagsBetweenClients(scrContext_t *scrContext)
{
  unsigned int Int; 
  gentity_s *Entity; 
  scr_string_t ConstLowercaseString; 
  const gentity_s *v5; 
  scr_string_t v6; 
  char v7; 
  __int16 *p_number; 
  gentity_s *v9; 
  const char *v10; 
  const char *v11; 
  const char *v12; 
  const char *v13; 
  const char *v14; 
  const char *v15; 
  gentity_s *v16; 
  unsigned int v17; 
  unsigned int clientTagIndex; 

  if ( Scr_GetNumParam(scrContext) > 6 )
    Scr_Error(COM_ERR_4351, scrContext, "Incorrect number of parameters");
  Int = Scr_GetInt(scrContext, 0);
  Entity = GScr_GetEntity(1u);
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 2u);
  v5 = GScr_GetEntity(3u);
  v6 = Scr_GetConstLowercaseString(scrContext, 4u);
  v7 = 0;
  p_number = NULL;
  if ( Scr_GetNumParam(scrContext) == 6 )
  {
    v9 = GScr_GetEntity(5u);
    p_number = &v9->s.number;
    if ( !v9->client )
    {
      v10 = j_va("Entity number %i is not a client", (unsigned int)v9->s.number);
      Scr_ParamError(COM_ERR_4352, scrContext, 5u, v10);
    }
    if ( (unsigned int)*p_number >= level.maxclients && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 15411, ASSERT_TYPE_ASSERT, "(unsigned)( player->s.number ) < (unsigned)( level.maxclients )", "player->s.number doesn't index level.maxclients\n\t%i not in [0, %i)", *p_number, level.maxclients) )
      __debugbreak();
    v7 = 1;
  }
  if ( !FX_IsValidFxId(Int) )
  {
    v11 = j_va("effect id %i is invalid\n", Int);
    Scr_ParamError(COM_ERR_4353, scrContext, 0, v11);
  }
  v12 = SL_ConvertToString(ConstLowercaseString);
  if ( strchr_0(v12, 34) )
    Scr_ParamError(COM_ERR_4354, scrContext, 2u, "cannot use \" characters in tag names\n");
  v13 = SL_ConvertToString(v6);
  if ( strchr_0(v13, 34) )
    Scr_ParamError(COM_ERR_4355, scrContext, 4u, "cannot use \" characters in tag names\n");
  clientTagIndex = 0;
  v14 = SL_ConvertToString(ConstLowercaseString);
  if ( !NetConstStrings_GetClientTagIndex(v14, &clientTagIndex) )
    Scr_ParamError(COM_ERR_4356, scrContext, 2u, "tag must be a client tag that is in ncsclienttags.txt");
  v15 = SL_ConvertToString(v6);
  if ( !NetConstStrings_GetClientTagIndex(v15, &clientTagIndex) )
    Scr_ParamError(COM_ERR_4357, scrContext, 4u, "tag must be a client tag that is in ncsclienttags.txt");
  v16 = G_BeamEntity_ScriptSpawn(Entity, ConstLowercaseString, Int);
  G_BeamEntity_ClearTargets(v16);
  G_BeamEntity_AddTargetEnt(v16, v5, v6, NULL);
  if ( v7 )
  {
    if ( !p_number && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 15444, ASSERT_TYPE_ASSERT, "(player)", (const char *)&queryFormat, rowName) )
      __debugbreak();
    *(_QWORD *)v16->clientMask.array = -1i64;
    *(_QWORD *)&v16->clientMask.array[2] = -1i64;
    *(_QWORD *)&v16->clientMask.array[4] = -1i64;
    v16->clientMask.array[6] = -1;
    v17 = *p_number;
    if ( v17 >= 0xE0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 290, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v17, 224) )
      __debugbreak();
    v16->clientMask.array[(unsigned __int64)v17 >> 5] &= ~(0x80000000 >> (v17 & 0x1F));
  }
  GScr_AddEntity(v16);
}

/*
==============
Scr_PlayFxBetweenPoints
==============
*/
void Scr_PlayFxBetweenPoints(scrContext_t *scrContext)
{
  unsigned int Int; 
  char v3; 
  __int16 *p_number; 
  gentity_s *Entity; 
  const char *v6; 
  const char *v7; 
  gentity_s *v8; 
  unsigned int v9; 
  vec3_t v10; 
  vec3_t v11; 
  vec3_t vectorValue; 

  if ( Scr_GetNumParam(scrContext) > 5 )
    Scr_Error(COM_ERR_4358, scrContext, "Incorrect number of parameters");
  Int = Scr_GetInt(scrContext, 0);
  Scr_GetVector(scrContext, 1u, &vectorValue);
  Scr_GetVector(scrContext, 2u, &v11);
  Scr_GetVector(scrContext, 3u, &v10);
  v3 = 0;
  p_number = NULL;
  if ( Scr_GetNumParam(scrContext) == 5 )
  {
    Entity = GScr_GetEntity(4u);
    p_number = &Entity->s.number;
    if ( !Entity->client )
    {
      v6 = j_va("Entity number %i is not a client", (unsigned int)Entity->s.number);
      Scr_ParamError(COM_ERR_4359, scrContext, 4u, v6);
    }
    if ( (unsigned int)*p_number >= level.maxclients && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 15490, ASSERT_TYPE_ASSERT, "(unsigned)( player->s.number ) < (unsigned)( level.maxclients )", "player->s.number doesn't index level.maxclients\n\t%i not in [0, %i)", *p_number, level.maxclients) )
      __debugbreak();
    v3 = 1;
  }
  if ( !FX_IsValidFxId(Int) )
  {
    v7 = j_va("effect id %i is invalid\n", Int);
    Scr_ParamError(COM_ERR_4360, scrContext, 0, v7);
  }
  v8 = G_Utils_SpawnEventEntity(&vectorValue, 123);
  v8->s.lerp.u.turret.gunAngles = v10;
  v8->s.lerp.apos.trBase = v11;
  v8->s.eventParm = Int;
  if ( v3 )
  {
    if ( !p_number && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 15505, ASSERT_TYPE_ASSERT, "(player)", (const char *)&queryFormat, rowName) )
      __debugbreak();
    *(_QWORD *)v8->clientMask.array = -1i64;
    *(_QWORD *)&v8->clientMask.array[2] = -1i64;
    *(_QWORD *)&v8->clientMask.array[4] = -1i64;
    v8->clientMask.array[6] = -1;
    v9 = *p_number;
    if ( v9 >= 0xE0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 290, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v9, 224) )
      __debugbreak();
    v8->clientMask.array[(unsigned __int64)v9 >> 5] &= ~(0x80000000 >> (v9 & 0x1F));
  }
}

/*
==============
Scr_PhysicsExplosionSphere
==============
*/
void Scr_PhysicsExplosionSphere(scrContext_t *scrContext)
{
  gentity_s *v2; 
  double Float; 
  double v4; 
  bool v5; 
  float v6; 
  double v7; 
  float v8; 
  vec3_t vectorValue; 

  if ( Scr_GetNumParam(scrContext) != 4 )
    Scr_Error(COM_ERR_4361, scrContext, "Incorrect number of parameters");
  Scr_GetVector(scrContext, 0, &vectorValue);
  v2 = G_Utils_SpawnEventEntity(&vectorValue, 130);
  v2->s.eventParm2 = 0;
  Float = Scr_GetFloat(scrContext, 1u);
  v2->s.lerp.u.turret.gunAngles.v[1] = *(float *)&Float;
  v4 = Scr_GetFloat(scrContext, 2u);
  v5 = v2->s.lerp.u.turret.gunAngles.v[1] >= 0.0;
  v2->s.lerp.u.turret.gunAngles.v[0] = *(float *)&v4;
  if ( !v5 )
    Scr_ParamError(COM_ERR_4362, scrContext, 1u, "Radius is negative");
  v6 = v2->s.lerp.u.turret.gunAngles.v[0];
  if ( v6 < 0.0 )
  {
    Scr_ParamError(COM_ERR_4363, scrContext, 2u, "Radius is negative");
    v6 = v2->s.lerp.u.turret.gunAngles.v[0];
  }
  if ( v6 > v2->s.lerp.u.turret.gunAngles.v[1] )
    Scr_Error(COM_ERR_4364, scrContext, "Inner radius is outside the outer radius");
  v7 = Scr_GetFloat(scrContext, 3u);
  v8 = v2->s.lerp.u.turret.gunAngles.v[1];
  v2->s.lerp.u.turret.gunAngles.v[2] = *(float *)&v7;
  Physics_ApplyRadiusForce(PHYSICS_WORLD_ID_FIRST, &vectorValue, v8, 0.0, 0.0, *(const float *)&v7, &vec3_origin, level.time, 1.0);
  G_Vehicle_ExplosionEvent(&vectorValue, v2->s.lerp.u.turret.gunAngles.v[0], v2->s.lerp.u.turret.gunAngles.v[1], 0, v2->s.lerp.u.turret.gunAngles.v[2], NULL);
}

/*
==============
Scr_PhysicsRadiusJolt
==============
*/
void Scr_PhysicsRadiusJolt(scrContext_t *scrContext)
{
  gentity_s *v2; 
  bool v3; 
  double Float; 
  float v5; 
  vec3_t vectorValue; 

  if ( Scr_GetNumParam(scrContext) != 4 )
    Scr_Error(COM_ERR_4365, scrContext, "Incorrect number of parameters");
  Scr_GetVector(scrContext, 0, &vectorValue);
  v2 = G_Utils_SpawnEventEntity(&vectorValue, 131);
  v2->s.eventParm2 = 0;
  v3 = Com_GameMode_SupportsFeature(WEAPON_LEAP_OUT);
  Float = Scr_GetFloat(scrContext, 1u);
  v5 = *(float *)&Float;
  if ( v3 )
  {
    _XMM7 = 0i64;
    __asm { vroundss xmm2, xmm7, xmm1, 1 }
    LODWORD(v5) = _mm_cvtepi32_ps((__m128i)(unsigned int)(int)*(float *)&_XMM2).m128_u32[0];
    Scr_GetFloat(scrContext, 2u);
    __asm { vroundss xmm0, xmm7, xmm2, 1 }
    LODWORD(_XMM0) = _mm_cvtepi32_ps((__m128i)(unsigned int)(int)*(float *)&_XMM0).m128_u32[0];
  }
  else
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
  }
  v2->s.lerp.u.turret.gunAngles.v[1] = v5;
  v2->s.lerp.u.turret.gunAngles.v[0] = *(float *)&_XMM0;
  if ( v5 < 0.0 )
  {
    Scr_ParamError(COM_ERR_4366, scrContext, 1u, "Radius is negative");
    LODWORD(_XMM0) = v2->s.lerp.u.anonymous.data[0];
  }
  if ( *(float *)&_XMM0 < 0.0 )
  {
    Scr_ParamError(COM_ERR_4367, scrContext, 2u, "Radius is negative");
    LODWORD(_XMM0) = v2->s.lerp.u.anonymous.data[0];
  }
  if ( *(float *)&_XMM0 > v2->s.lerp.u.turret.gunAngles.v[1] )
    Scr_Error(COM_ERR_4368, scrContext, "Inner radius is outside the outer radius");
  Scr_GetVector(scrContext, 3u, &v2->s.lerp.u.event.explosionJolt.impulse);
  if ( 0.0 == v2->s.lerp.u.turret.gunAngles.v[2] && 0.0 == v2->s.lerp.u.actor.impactVector.v[0] && 0.0 == v2->s.lerp.u.actor.impactVector.v[1] )
    v2->s.lerp.u.anonymous.data[2] = 0x800000;
  Physics_ApplyRadiusForce(PHYSICS_WORLD_ID_FIRST, &vectorValue, v5, 0.0, 0.0, 0.0, &v2->s.lerp.u.event.explosionJolt.impulse, level.time, 1.0);
  G_Vehicle_ExplosionEvent(&vectorValue, v2->s.lerp.u.turret.gunAngles.v[0], v2->s.lerp.u.turret.gunAngles.v[1], 0, 1.0, &v2->s.lerp.u.event.explosionJolt.impulse);
}

/*
==============
ScrCmd_TableSort
==============
*/
void ScrCmd_TableSort(scrContext_t *scrContext)
{
  std::pair<unsigned int,VariableUnion const *> *v2; 
  __int64 v3; 
  unsigned int ArrayObject; 
  unsigned int ArraySize; 
  const char *v6; 
  scr_string_t down; 
  scr_string_t ConstString; 
  const char *v9; 
  const char *v10; 
  const char *v11; 
  const char *v12; 
  int TableEntries; 
  __int64 v14; 
  __int64 v15; 
  std::pair<unsigned int,VariableUnion const *> *v16; 
  int v17; 
  __int64 v18; 
  std::pair<unsigned int,VariableUnion const *> *v19; 
  VariableType outType[8]; 
  VariableValue out; 
  std::pair<unsigned int,VariableUnion const *> outEntries[1024]; 

  v2 = outEntries;
  v3 = 1024i64;
  do
  {
    std::pair<unsigned int,VariableUnion const *>::pair<unsigned int,VariableUnion const *>(v2++);
    --v3;
  }
  while ( v3 );
  ArrayObject = BGScr_Main_GetArrayObject(scrContext, 0);
  ArraySize = GetArraySize(scrContext, ArrayObject);
  if ( ArraySize > 0x400 )
  {
    v6 = j_va("Key array exceeds maximum sort size: %d > %d", ArraySize, 1024i64);
    Scr_ParamError(COM_ERR_6575, scrContext, 0, v6);
  }
  down = scr_const.down;
  if ( Scr_GetNumParam(scrContext) > 1 )
  {
    ConstString = Scr_GetConstString(scrContext, 1u);
    down = ConstString;
    if ( ConstString != scr_const.up && ConstString != scr_const.down )
    {
      v9 = SL_ConvertToString(scr_const.down);
      v10 = SL_ConvertToString(scr_const.up);
      v11 = SL_ConvertToString(down);
      v12 = j_va("Invalid sort direction specified: %s is not \"%s\" or \"%s\"", v11, v10, v9);
      Scr_ParamError(COM_ERR_6576, scrContext, 0, v12);
    }
  }
  TableEntries = ScrCmd_GetTableEntries(scrContext, ArrayObject, outEntries, outType);
  v14 = TableEntries;
  if ( outType[0] )
  {
    switch ( outType[0] )
    {
      case VAR_STRING:
        std::_Sort_unchecked<std::pair<unsigned int,VariableUnion const *> *,ScrCmd_CompareTableEntriesString>(outEntries, &outEntries[TableEntries], TableEntries, (ScrCmd_CompareTableEntriesString)outType[0]);
        break;
      case VAR_FLOAT:
        std::_Sort_unchecked<std::pair<unsigned int,VariableUnion const *> *,ScrCmd_CompareTableEntriesFloat>(outEntries, &outEntries[TableEntries], TableEntries, (ScrCmd_CompareTableEntriesFloat)outType[0]);
        break;
      case VAR_INTEGER:
        std::_Sort_unchecked<std::pair<unsigned int,VariableUnion const *> *,ScrCmd_CompareTableEntriesInteger>(outEntries, &outEntries[TableEntries], TableEntries, (ScrCmd_CompareTableEntriesInteger)outType[0]);
        break;
      default:
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 33110, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Invalid array entries in TableSort") )
          __debugbreak();
        break;
    }
  }
  Scr_MakeArray(scrContext);
  if ( down == scr_const.up )
  {
    v15 = v14;
    if ( (int)v14 > 0 )
    {
      v16 = outEntries;
      do
      {
        Scr_GetArrayIndexValue_Out(v16->first, &out);
        Scr_AddValue(scrContext, &out);
        Scr_AddArray(scrContext);
        ++v16;
        --v15;
      }
      while ( v15 );
    }
  }
  else
  {
    v17 = v14 - 1;
    v18 = (int)v14 - 1;
    if ( v17 >= 0 )
    {
      v19 = &outEntries[v17];
      do
      {
        Scr_GetArrayIndexValue_Out(v19->first, &out);
        Scr_AddValue(scrContext, &out);
        Scr_AddArray(scrContext);
        --v18;
        --v19;
      }
      while ( v18 >= 0 );
    }
  }
}

/*
==============
Scr_PhysicsRadiusJitter
==============
*/
void Scr_PhysicsRadiusJitter(scrContext_t *scrContext)
{
  __int128 v1; 
  __int128 v2; 
  __int128 v3; 
  gentity_s *v5; 
  bool v6; 
  double Float; 
  float v8; 
  const char *v12; 
  double v13; 
  double v14; 
  bool v15; 
  vec3_t vectorValue; 
  __int128 v17; 
  __int128 v18; 
  __int128 v19; 

  v19 = v1;
  v17 = v3;
  if ( Scr_GetNumParam(scrContext) < 5 || Scr_GetNumParam(scrContext) > 6 )
    Scr_Error(COM_ERR_4369, scrContext, "Incorrect number of parameters");
  Scr_GetVector(scrContext, 0, &vectorValue);
  v5 = G_Utils_SpawnEventEntity(&vectorValue, 133);
  v5->s.eventParm2 = 0;
  v6 = Com_GameMode_SupportsFeature(WEAPON_LEAP_OUT);
  Float = Scr_GetFloat(scrContext, 1u);
  v8 = *(float *)&Float;
  if ( v6 )
  {
    v18 = v2;
    _XMM7 = 0i64;
    __asm { vroundss xmm2, xmm7, xmm1, 1 }
    LODWORD(v8) = _mm_cvtepi32_ps((__m128i)(unsigned int)(int)*(float *)&_XMM2).m128_u32[0];
    Scr_GetFloat(scrContext, 2u);
    __asm { vroundss xmm0, xmm7, xmm2, 1 }
    LODWORD(_XMM0) = _mm_cvtepi32_ps((__m128i)(unsigned int)(int)*(float *)&_XMM0).m128_u32[0];
  }
  else
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
  }
  v5->s.lerp.u.turret.gunAngles.v[1] = v8;
  v5->s.lerp.u.turret.gunAngles.v[0] = *(float *)&_XMM0;
  if ( v8 < 0.0 )
  {
    Scr_ParamError(COM_ERR_4370, scrContext, 1u, "Radius is negative");
    LODWORD(_XMM0) = v5->s.lerp.u.anonymous.data[0];
  }
  if ( *(float *)&_XMM0 < 0.0 )
  {
    Scr_ParamError(COM_ERR_4371, scrContext, 2u, "Radius is negative");
    LODWORD(_XMM0) = v5->s.lerp.u.anonymous.data[0];
  }
  if ( *(float *)&_XMM0 > v5->s.lerp.u.turret.gunAngles.v[1] )
    Scr_Error(COM_ERR_4372, scrContext, "Inner radius is outside the outer radius");
  if ( v8 > 1024.0 )
  {
    v12 = j_va("Jitter is too big - max radius is %.2f", DOUBLE_1024_0);
    Scr_Error(COM_ERR_4373, scrContext, v12);
  }
  v13 = Scr_GetFloat(scrContext, 3u);
  v5->s.lerp.u.turret.gunAngles.v[2] = *(float *)&v13;
  v14 = Scr_GetFloat(scrContext, 4u);
  v15 = *(float *)&v14 < v5->s.lerp.u.turret.gunAngles.v[2];
  v5->s.lerp.u.actor.impactVector.v[0] = *(float *)&v14;
  if ( v15 )
    Scr_Error(COM_ERR_4374, scrContext, "Maximum jitter is less than minimum jitter");
}

/*
==============
Scr_VisionSetNaked
==============
*/
void Scr_VisionSetNaked(scrContext_t *scrContext)
{
  VisionSetSendToClient(scrContext, VISIONSET_SCRIPT);
}

/*
==============
Scr_VisionSetNight
==============
*/
void Scr_VisionSetNight(scrContext_t *scrContext)
{
  VisionSetSendToClient(scrContext, VISIONSET_NIGHT);
}

/*
==============
Scr_VisionSetMissilecam
==============
*/
void Scr_VisionSetMissilecam(scrContext_t *scrContext)
{
  VisionSetSendToClient(scrContext, VISIONSET_MISSILECAM);
}

/*
==============
Scr_VisionSetThermal
==============
*/
void Scr_VisionSetThermal(scrContext_t *scrContext)
{
  VisionSetSendToClient(scrContext, VISIONSET_THERMAL);
}

/*
==============
Scr_VisionSetPain
==============
*/
void Scr_VisionSetPain(scrContext_t *scrContext)
{
  VisionSetSendToClient(scrContext, VISIONSET_PAIN);
}

/*
==============
Scr_VisionSetFadeToBlack
==============
*/
void Scr_VisionSetFadeToBlack(scrContext_t *scrContext)
{
  VisionSetSendToClient(scrContext, VISIONSET_FADE_TO_BLACK);
}

/*
==============
Scr_VisionSetKillcamThirdpersonNight
==============
*/
void Scr_VisionSetKillcamThirdpersonNight(scrContext_t *scrContext)
{
  VisionSetSendToClient(scrContext, VISIONSET_KILLCAM);
}

/*
==============
ScrCmd_PainVisionOn
==============
*/
void ScrCmd_PainVisionOn(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 15874, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal(&v4->client->ps.otherFlags, ACTIVE, 0x19u);
}

/*
==============
ScrCmd_PainVisionOff
==============
*/
void ScrCmd_PainVisionOff(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 15891, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal(&v4->client->ps.otherFlags, ACTIVE, 0x19u);
}

/*
==============
ScrCmd_MarkKeyframedMover
==============
*/
void ScrCmd_MarkKeyframedMover(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const dvar_t *v4; 

  Entity = GetEntity(entref);
  if ( Entity->s.eType == ET_SCRIPTMOVER )
  {
    v4 = DVARBOOL_movingPlatformUseKeyframeVelocities;
    if ( !DVARBOOL_movingPlatformUseKeyframeVelocities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "movingPlatformUseKeyframeVelocities") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v4);
    if ( v4->current.enabled )
      GMovingPlatforms::MarkEntityKeyframedMover(Entity);
  }
  else
  {
    Scr_Error(COM_ERR_4221, scrContext, "MarkKeyframedMover must be called on a script mover");
  }
}

/*
==============
ScrCmd_GetNodeNumber
==============
*/
void ScrCmd_GetNodeNumber(scrContext_t *scrContext, scr_entref_t entref)
{
  if ( entref.entclass == ENTITY_CLASS_PATHNODE )
    Scr_AddInt(scrContext, entref.entnum);
  else
    Scr_Error(COM_ERR_4377, scrContext, "GetNodeNumber not called on pathnode");
}

/*
==============
ScrCmd_UnmarkKeyframedMover
==============
*/
void ScrCmd_UnmarkKeyframedMover(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( Entity->s.eType == ET_SCRIPTMOVER )
    GMovingPlatforms::UnmarkEntityKeyframedMover(Entity);
  else
    Scr_Error(COM_ERR_4221, scrContext, "UnmarkKeyframedMover must be called on a script mover");
}

/*
==============
Scr_SetVisionParams
==============
*/
void Scr_SetVisionParams(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  int number; 
  const char *v7; 
  const char *String; 
  const char *v11; 
  const char *v12; 
  SvClient *CommonClient; 
  int outControllingClientNum; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3678, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 15932, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client && !v4->agent )
    {
      v5 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3677, scrContext, v5);
    }
  }
  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_Error(COM_ERR_4378, scrContext, "Incorrect usage for SetVisionParams()");
  number = v4->s.number;
  outControllingClientNum = number;
  if ( !SV_IsAgent(number) || SV_GetAgentControlledByPlayerNum(outControllingClientNum, &outControllingClientNum) )
  {
    String = Scr_GetString(scrContext, 1u);
    Scr_GetFloat(scrContext, 0);
    _XMM0 = 0i64;
    __asm { vroundss xmm1, xmm0, xmm4, 1 }
    v11 = j_va("%c %i \"%s\"", 54i64, (unsigned int)(int)*(float *)&_XMM1, String);
    v12 = v11;
    if ( outControllingClientNum == -1 )
    {
      SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v11);
    }
    else
    {
      CommonClient = SvClient::GetCommonClient(outControllingClientNum);
      CommonClient->SendServerCommand(CommonClient, SV_CMD_RELIABLE, v12);
    }
  }
  else
  {
    v7 = j_va("entity %i is not a player or player-controlled agent", entnum);
    Scr_ObjectError(COM_ERR_4379, scrContext, v7);
  }
}

/*
==============
Scr_VisionSetAlternate
==============
*/
void Scr_VisionSetAlternate(scrContext_t *scrContext)
{
  unsigned int v2; 
  unsigned int Int; 
  scr_string_t ConstLowercaseString; 
  const char *v7; 
  const char *v8; 
  ComErrorCode v9; 
  int v10; 
  unsigned int v11; 
  unsigned int outVisionSetIndex[4]; 
  char dest[64]; 

  v2 = -1;
  Int = Scr_GetInt(scrContext, 0);
  Scr_GetFloat(scrContext, 1u);
  _XMM0 = 0i64;
  __asm { vroundss xmm1, xmm0, xmm4, 1 }
  if ( Scr_GetNumParam(scrContext) != 3 )
  {
    if ( Scr_GetNumParam(scrContext) == 2 )
      goto LABEL_9;
    v8 = "USAGE: VisionSetAlternate( <stage>, <duration>, <optional override> )\n";
    v9 = COM_ERR_4381;
LABEL_8:
    Scr_Error(v9, scrContext, v8);
    goto LABEL_9;
  }
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 2u);
  v7 = SL_ConvertToString(ConstLowercaseString);
  if ( !*v7 || !NetConstStrings_GetVisionSetIndex(v7, outVisionSetIndex) )
  {
    v8 = "Invalid vision set override for VisionSetAlternate.";
    v9 = COM_ERR_4380;
    goto LABEL_8;
  }
  v2 = outVisionSetIndex[0];
LABEL_9:
  v11 = v2;
  v10 = (int)*(float *)&_XMM1;
  Com_sprintf(dest, 0x40ui64, "%i %i %i", Int, v10, v11);
  SV_SetConfigstring(8u, dest);
}

/*
==============
GScr_GetNumParts
==============
*/
void GScr_GetNumParts(scrContext_t *scrContext)
{
  const char *String; 
  XModel *XModel; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4382, scrContext, "Incorrect use of getnumparts()");
  String = Scr_GetString(scrContext, 0);
  if ( !*String )
    Scr_Error(COM_ERR_4383, scrContext, "GetNumParts() used with an empty model name!");
  XModel = SV_Game_GetXModel(String);
  if ( !XModel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\xanim\\xmodel_utils.h", 136, ASSERT_TYPE_ASSERT, "(model)", (const char *)&queryFormat, "model") )
    __debugbreak();
  Scr_AddInt(scrContext, XModel->numBones);
}

/*
==============
GScr_GetPartName
==============
*/
void GScr_GetPartName(scrContext_t *scrContext)
{
  const char *String; 
  XModel *XModel; 
  __int64 Int; 
  unsigned int numBones; 
  const char *v6; 
  scr_string_t v7; 

  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_Error(COM_ERR_4384, scrContext, "Incorrect usage for getpartname()");
  String = Scr_GetString(scrContext, 0);
  XModel = SV_Game_GetXModel(String);
  Int = (unsigned int)Scr_GetInt(scrContext, 1u);
  if ( !XModel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\xanim\\xmodel_utils.h", 136, ASSERT_TYPE_ASSERT, "(model)", (const char *)&queryFormat, "model") )
    __debugbreak();
  numBones = XModel->numBones;
  if ( (unsigned int)Int >= numBones )
  {
    v6 = j_va("index out of range (0 - %d)", numBones - 1);
    Scr_ParamError(COM_ERR_4385, scrContext, 1u, v6);
  }
  v7 = XModelBoneNames(XModel)[Int];
  if ( !v7 )
    Scr_ParamError(COM_ERR_4386, scrContext, 0, "bad model");
  Scr_AddConstString(scrContext, v7);
}

/*
==============
GScr_GetAnimName
==============
*/
void GScr_GetAnimName(scrContext_t *scrContext)
{
  int linkPointer; 
  unsigned int v3; 
  XAnim_s *Anims; 
  const char *AnimName; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    linkPointer = Scr_GetAnim(scrContext, 0, NULL).linkPointer;
    v3 = (unsigned __int16)linkPointer;
    Anims = Scr_GetAnims(scrContext, HIWORD(linkPointer));
    if ( XAnimIsPrimitive(Anims, v3) && XAnimGetParts(Anims, v3) )
    {
      AnimName = XAnimGetAnimName(Anims, v3);
      Scr_AddString(scrContext, AnimName);
    }
    else
    {
      Scr_Error(COM_ERR_4388, scrContext, "GetAnimName() expects a primitive animation as its parameter");
    }
  }
  else
  {
    Scr_Error(COM_ERR_4387, scrContext, "GetAnimName() expects exactly one parameter");
  }
}

/*
==============
Scr_LookupSoundLength
==============
*/
void Scr_LookupSoundLength(scrContext_t *scrContext)
{
  int NumParam; 
  int v3; 
  bool v4; 
  bool v5; 
  const char *String; 
  bool v7; 
  const char *v8; 
  int v9; 

  NumParam = Scr_GetNumParam(scrContext);
  v3 = NumParam;
  if ( NumParam && NumParam <= 2 )
  {
    v4 = Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_STILL_LAND|0x80);
    v5 = !v4;
    if ( !v4 && !Com_GameMode_SupportsFeature(WEAPON_INSPECT|0x80) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16110, ASSERT_TYPE_ASSERT, "(!useApproximation || Com_GameMode_SupportsFeature( Com_GameMode_Feature::SOUND_MULTIPLAYER ))", (const char *)&queryFormat, "!useApproximation || Com_GameMode_SupportsFeature( Com_GameMode_Feature::SOUND_MULTIPLAYER )") )
      __debugbreak();
    String = Scr_GetString(scrContext, 0);
    v7 = 0;
    v8 = String;
    if ( v3 > 1 )
      v7 = Scr_GetInt(scrContext, 1u) != 0;
    v9 = SND_SV_LookupSoundLength(v8, v5, v7);
    Scr_AddInt(scrContext, v9);
  }
  else
  {
    Scr_Error(COM_ERR_4389, scrContext, "usage: timeMS = LookupSoundLength( <alias>, <findLongestVariant> );\n");
  }
}

/*
==============
Scr_SoundSetTimeScaleFactor
==============
*/
void Scr_SoundSetTimeScaleFactor(scrContext_t *scrContext)
{
  const char *String; 
  unsigned int EntChannelFromName; 
  const char *v4; 
  double Float; 
  double v6; 
  const char *v7; 
  char dest[64]; 

  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    String = Scr_GetString(scrContext, 0);
    EntChannelFromName = SND_GetEntChannelFromName(String);
    if ( EntChannelFromName == -1 )
    {
      v4 = j_va("uknown channel: %s\n", String);
      Scr_ParamError(COM_ERR_4394, scrContext, 0, v4);
    }
    Float = Scr_GetFloat(scrContext, 1u);
    if ( *(float *)&Float < 0.0 || *(float *)&Float > 1.0 )
    {
      v6 = *(float *)&Float;
      v7 = j_va("time scale factor must be between 0 and 1 - %f\n", *(float *)&Float);
      Scr_ParamError(COM_ERR_4395, scrContext, 1u, v7);
    }
    else
    {
      v6 = *(float *)&Float;
    }
    Com_sprintf(dest, 0x40ui64, "%c %i %.3f\n", 115i64, EntChannelFromName, v6);
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, dest);
  }
  else
  {
    Scr_Error(COM_ERR_4393, scrContext, "usage: SoundSetTimeScaleFactor( <channelname>, <lerp> )\n");
  }
}

/*
==============
Scr_SoundSetTimeScaleFactorFromTable
==============
*/
void Scr_SoundSetTimeScaleFactorFromTable(scrContext_t *scrContext)
{
  const char *String; 
  const char *v3; 
  __int64 v4; 
  char dest[64]; 

  String = Scr_GetString(scrContext, 0);
  v3 = String;
  v4 = -1i64;
  do
    ++v4;
  while ( String[v4] );
  if ( (unsigned int)v4 > 0x20 )
    Scr_ParamError(COM_ERR_6440, scrContext, 1u, "Preset name is too long to fit in the buffer");
  Com_sprintf(dest, 0x40ui64, "%c %s\n", 116i64, v3);
  SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, dest);
}

/*
==============
ScrCmd_HudOutlineViewModelEnable
==============
*/
void ScrCmd_HudOutlineViewModelEnable(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  scr_string_t ConstString; 
  const char *v7; 
  const char *v8; 
  unsigned int outIndex; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16268, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  if ( v4->s.eType != ET_PLAYER )
    Scr_Error(COM_ERR_4396, scrContext, "ViewModelOutlineEnable called on an ent that's not a player.");
  ConstString = Scr_GetConstString(scrContext, 0);
  if ( !ConstString && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16276, ASSERT_TYPE_ASSERT, "(hudOutlineScrStr != ( static_cast< scr_string_t >( 0 ) ))", (const char *)&queryFormat, "hudOutlineScrStr != NULL_SCR_STRING") )
    __debugbreak();
  v7 = SL_ConvertToString(ConstString);
  if ( !v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16279, ASSERT_TYPE_ASSERT, "(hudOutlineName)", (const char *)&queryFormat, "hudOutlineName") )
    __debugbreak();
  outIndex = 0;
  if ( BG_HudOutline_GetDefIndex(v7, &outIndex) )
  {
    *(_DWORD *)&v4->client->ps.outlineData.viewmodel ^= ((unsigned __int8)outIndex ^ (unsigned __int8)*(_DWORD *)&v4->client->ps.outlineData.viewmodel) & 0x3F;
  }
  else
  {
    v8 = j_va("Hud Outline name not found (%s)! Make sure you add your Hud Outline asset to your level csv file!\n", v7);
    Scr_Error(COM_ERR_6089, scrContext, v8);
  }
}

/*
==============
ScrCmd_HudOutlineViewModelDisable
==============
*/
void ScrCmd_HudOutlineViewModelDisable(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16305, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  if ( v4->s.eType != ET_PLAYER )
    Scr_Error(COM_ERR_4398, scrContext, "ViewModelOutlineDisable called on an ent that's not a player.");
  *(_DWORD *)&v4->client->ps.outlineData.viewmodel &= 0xFFFFFFC0;
}

/*
==============
GScr_GetTagOrigin
==============
*/
void GScr_GetTagOrigin(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int shouldUseCache; 
  int showScriptError; 
  scr_string_t ConstLowercaseString; 
  playerState_s *EntityPlayerState; 
  GHandler *Handler; 
  float v9; 
  vec3_t value; 
  vec3_t vec; 
  WorldUpReferenceFrame v12; 

  Entity = GetEntity(entref);
  shouldUseCache = 1;
  showScriptError = 1;
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  if ( Scr_GetNumParam(scrContext) > 1 && Scr_GetInt(scrContext, 1u) )
    showScriptError = 0;
  if ( Scr_GetNumParam(scrContext) > 3 && !Scr_GetInt(scrContext, 3u) )
    shouldUseCache = 0;
  if ( GScr_UpdateTagInternal(scrContext, Entity, ConstLowercaseString, &level.cachedTagMat, shouldUseCache, showScriptError) )
  {
    value = level.cachedTagMat.tagMat.m[3];
    if ( Scr_GetNumParam(scrContext) > 2 && Scr_GetInt(scrContext, 2u) == 1 )
    {
      EntityPlayerState = G_GetEntityPlayerState(Entity);
      if ( EntityPlayerState )
      {
        Handler = GHandler::getHandler();
        WorldUpReferenceFrame::WorldUpReferenceFrame(&v12, EntityPlayerState, Handler);
        v9 = value.v[1] - EntityPlayerState->origin.v[1];
        vec.v[0] = value.v[0] - EntityPlayerState->origin.v[0];
        vec.v[2] = value.v[2] - EntityPlayerState->origin.v[2];
        vec.v[1] = v9;
        WorldUpReferenceFrame::ApplyReferenceFrameToVector(&v12, &vec);
        value.v[0] = vec.v[0] + EntityPlayerState->origin.v[0];
        value.v[1] = vec.v[1] + EntityPlayerState->origin.v[1];
        value.v[2] = vec.v[2] + EntityPlayerState->origin.v[2];
      }
    }
    Scr_AddVector(scrContext, value.v);
  }
}

/*
==============
GScr_GetTagAngles
==============
*/
void GScr_GetTagAngles(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int shouldUseCache; 
  int showScriptError; 
  scr_string_t ConstLowercaseString; 
  const playerState_s *EntityPlayerState; 
  GHandler *Handler; 
  vec3_t angles; 
  WorldUpReferenceFrame v10; 

  Entity = GetEntity(entref);
  shouldUseCache = 1;
  showScriptError = 1;
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  if ( Scr_GetNumParam(scrContext) > 1 && Scr_GetInt(scrContext, 1u) )
    showScriptError = 0;
  if ( Scr_GetNumParam(scrContext) > 3 && !Scr_GetInt(scrContext, 3u) )
    shouldUseCache = 0;
  GScr_UpdateTagInternal(scrContext, Entity, ConstLowercaseString, &level.cachedTagMat, shouldUseCache, showScriptError);
  AxisToAngles((const tmat33_t<vec3_t> *)&level.cachedTagMat.tagMat, &angles);
  if ( Scr_GetNumParam(scrContext) > 2 && Scr_GetInt(scrContext, 2u) == 1 )
  {
    EntityPlayerState = G_GetEntityPlayerState(Entity);
    if ( EntityPlayerState )
    {
      Handler = GHandler::getHandler();
      WorldUpReferenceFrame::WorldUpReferenceFrame(&v10, EntityPlayerState, Handler);
      WorldUpReferenceFrame::ApplyReferenceFrameToAngles(&v10, &angles);
    }
  }
  Scr_AddVector(scrContext, angles.v);
}

/*
==============
GScr_TagExists
==============
*/
void GScr_TagExists(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t ConstLowercaseString; 
  int BoneIndex; 
  const XModel *Model; 
  int v7; 
  unsigned __int8 index; 

  Entity = GetEntity(entref);
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  if ( SV_Game_DObjExists(Entity) )
  {
    BoneIndex = SV_Game_DObjGetBoneIndex(Entity, ConstLowercaseString);
  }
  else
  {
    if ( !Entity->model )
      goto LABEL_9;
    Model = G_Utils_GetModel(Entity->model);
    if ( !XModelGetBoneIndex(Model, ConstLowercaseString, 0, &index) )
      goto LABEL_9;
    BoneIndex = index;
  }
  if ( (unsigned int)(BoneIndex - 254) <= 1 || BoneIndex == -1 )
  {
LABEL_9:
    v7 = 0;
    goto LABEL_10;
  }
  v7 = 1;
LABEL_10:
  Scr_AddInt(scrContext, v7);
}

/*
==============
GScr_SetDepthOfField
==============
*/
void GScr_SetDepthOfField(scrContext_t *scrContext, scr_entref_t entref)
{
  Com_PrintWarning(24, "GScr_SetDepthOfField: Legacy DoF controls deprecated. Please update script to physical DoF controls!\n");
}

/*
==============
GScr_VignetteSetParams
==============
*/
void GScr_VignetteSetParams(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *PlayerEntity; 
  playerState_s *EntityPlayerState; 
  int NumParam; 
  double Float; 
  float v7; 
  const char *v8; 
  int Int; 
  double v10; 
  float v11; 
  double v12; 
  float v13; 
  double v14; 
  float v15; 
  double v16; 
  float v17; 
  double v18; 
  float v19; 
  double v20; 
  float v21; 
  double v22; 
  float v23; 
  double v24; 
  float v25; 
  int v28; 

  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  EntityPlayerState = G_GetEntityPlayerState(PlayerEntity);
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam >= 10 )
  {
    Float = Scr_GetFloat(scrContext, 0);
    v7 = *(float *)&Float;
    if ( *(float *)&Float < 0.0 || *(float *)&Float > 1.0 )
    {
      v8 = j_va("intensity must be between -1 and 1 - %f\n", *(float *)&Float);
      Scr_ParamError(COM_ERR_5922, scrContext, 1u, v8);
    }
    Int = Scr_GetInt(scrContext, 1u);
    v10 = Scr_GetFloat(scrContext, 2u);
    v11 = *(float *)&v10;
    v12 = Scr_GetFloat(scrContext, 3u);
    v13 = *(float *)&v12;
    v14 = Scr_GetFloat(scrContext, 4u);
    v15 = *(float *)&v14;
    v16 = Scr_GetFloat(scrContext, 5u);
    v17 = *(float *)&v16;
    v18 = Scr_GetFloat(scrContext, 6u);
    v19 = *(float *)&v18;
    v20 = Scr_GetFloat(scrContext, 7u);
    v21 = *(float *)&v20;
    v22 = Scr_GetFloat(scrContext, 8u);
    v23 = *(float *)&v22;
    v24 = Scr_GetFloat(scrContext, 9u);
    v25 = *(float *)&v24;
    if ( NumParam <= 10 )
    {
      v28 = 0;
    }
    else
    {
      Scr_GetFloat(scrContext, 0xAu);
      _XMM1 = 0i64;
      __asm { vroundss xmm5, xmm1, xmm4, 1 }
      v28 = (int)*(float *)&_XMM5;
    }
    EntityPlayerState->vignetteIntensity = v7;
    EntityPlayerState->vignetteSquareAspectRatio = (float)Int;
    EntityPlayerState->vignetteScale.v[0] = v11;
    EntityPlayerState->vignetteScale.v[1] = v13;
    EntityPlayerState->vignetteFalloff = v15;
    EntityPlayerState->vignetteFalloffStart = v17;
    EntityPlayerState->vignetteBoxSize.v[0] = v19;
    EntityPlayerState->vignetteBoxSize.v[1] = v21;
    EntityPlayerState->vignetteOffset.v[0] = v23;
    EntityPlayerState->vignetteOffset.v[1] = v25;
    EntityPlayerState->vignetteLerpDuration = (float)v28;
  }
  else
  {
    Scr_Error(COM_ERR_5921, scrContext, "usage: VignetteSetParams( <intensity>, <squareAspectRatio>, <scaleX>, <scaleY>, <falloff>, <falloffStart>, <boxSizeX>, <boxSizeY>, <offsetX>, <offsetY>, <optional:lerpDuration> )\n");
  }
}

/*
==============
GScr_VignetteGetParams
==============
*/
void GScr_VignetteGetParams(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *PlayerEntity; 
  playerState_s *EntityPlayerState; 
  unsigned int CanonicalString; 
  unsigned int v8; 
  unsigned int v9; 
  unsigned int v10; 
  unsigned int v11; 
  unsigned int v12; 
  unsigned int v13; 
  unsigned int v14; 
  unsigned int v15; 
  unsigned int v16; 
  unsigned int v17; 

  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  EntityPlayerState = G_GetEntityPlayerState(PlayerEntity);
  Scr_MakeStruct(scrContext);
  _XMM0 = LODWORD(EntityPlayerState->vignetteIntensity);
  __asm { vmaxss  xmm1, xmm0, xmm6; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
  CanonicalString = SL_GetCanonicalString("intensity");
  Scr_AddStructField(scrContext, CanonicalString);
  Scr_AddBool(scrContext, EntityPlayerState->vignetteSquareAspectRatio != 0.0);
  v8 = SL_GetCanonicalString("squareaspectratio");
  Scr_AddStructField(scrContext, v8);
  Scr_AddFloat(scrContext, EntityPlayerState->vignetteScale.v[0]);
  v9 = SL_GetCanonicalString("scalex");
  Scr_AddStructField(scrContext, v9);
  Scr_AddFloat(scrContext, EntityPlayerState->vignetteScale.v[1]);
  v10 = SL_GetCanonicalString("scaley");
  Scr_AddStructField(scrContext, v10);
  Scr_AddFloat(scrContext, EntityPlayerState->vignetteFalloff);
  v11 = SL_GetCanonicalString("falloff");
  Scr_AddStructField(scrContext, v11);
  Scr_AddFloat(scrContext, EntityPlayerState->vignetteFalloffStart);
  v12 = SL_GetCanonicalString("falloffstart");
  Scr_AddStructField(scrContext, v12);
  Scr_AddFloat(scrContext, EntityPlayerState->vignetteBoxSize.v[0]);
  v13 = SL_GetCanonicalString("boxsizex");
  Scr_AddStructField(scrContext, v13);
  Scr_AddFloat(scrContext, EntityPlayerState->vignetteBoxSize.v[1]);
  v14 = SL_GetCanonicalString("boxsizey");
  Scr_AddStructField(scrContext, v14);
  Scr_AddFloat(scrContext, EntityPlayerState->vignetteOffset.v[0]);
  v15 = SL_GetCanonicalString("offsetx");
  Scr_AddStructField(scrContext, v15);
  Scr_AddFloat(scrContext, EntityPlayerState->vignetteOffset.v[1]);
  v16 = SL_GetCanonicalString("offsety");
  Scr_AddStructField(scrContext, v16);
  Scr_AddFloat(scrContext, EntityPlayerState->vignetteLerpDuration * 0.001);
  v17 = SL_GetCanonicalString("lerpduration");
  Scr_AddStructField(scrContext, v17);
}

/*
==============
GScr_VignetteScriptDisable
==============
*/
void GScr_VignetteScriptDisable(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *PlayerEntity; 
  playerState_s *EntityPlayerState; 

  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  EntityPlayerState = G_GetEntityPlayerState(PlayerEntity);
  EntityPlayerState->vignetteIntensity = -1.0;
  EntityPlayerState->vignetteSquareAspectRatio = 0.0;
  EntityPlayerState->vignetteScale.v[0] = 1.0;
  EntityPlayerState->vignetteScale.v[1] = 1.0;
  *(_QWORD *)&EntityPlayerState->vignetteFalloff = 1065353216i64;
  EntityPlayerState->vignetteBoxSize = 0i64;
  EntityPlayerState->vignetteOffset = 0i64;
  EntityPlayerState->vignetteLerpDuration = 0.0;
}

/*
==============
GScr_SetNVGAreaLightEffect
==============
*/
void GScr_SetNVGAreaLightEffect(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  playerState_s *EntityPlayerState; 
  int Int; 
  GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64> *p_weapFlags; 

  entnum = entref.entnum;
  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16702, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClientOrAgent(Entity) )
  {
    targetname = Entity->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(Entity->classname);
    v8 = j_va("SetNVGAreaLightEffect(). Only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, Entity->r.currentOrigin.v[0], Entity->r.currentOrigin.v[1], Entity->r.currentOrigin.v[2], v7, v6);
    Scr_Error(COM_ERR_4408, scrContext, v8);
  }
  EntityPlayerState = G_GetEntityPlayerState(Entity);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16710, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4409, scrContext, "SetNVGAreaLightEffect(). USAGE: <player> SetNVGAreaLightEffect( <use alternate> )\n");
  Int = Scr_GetInt(scrContext, 0);
  p_weapFlags = &EntityPlayerState->weapCommon.weapFlags;
  if ( Int )
    GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::SetFlagInternal(p_weapFlags, ACTIVE, 8u);
  else
    GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::ClearFlagInternal(p_weapFlags, ACTIVE, 8u);
}

/*
==============
GScr_AnimScriptSetInputParamReplicationStatus
==============
*/
void GScr_AnimScriptSetInputParamReplicationStatus(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  gclient_s *client; 
  int Int; 
  unsigned int v11; 

  entnum = entref.entnum;
  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16745, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClient(Entity) )
  {
    targetname = Entity->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(Entity->classname);
    v8 = j_va("AnimScriptSetInputParamReplicationStatus(). Only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, Entity->r.currentOrigin.v[0], Entity->r.currentOrigin.v[1], Entity->r.currentOrigin.v[2], v7, v6);
    Scr_Error(COM_ERR_4410, scrContext, v8);
  }
  client = Entity->client;
  if ( !client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16753, ASSERT_TYPE_ASSERT, "( client )", (const char *)&queryFormat, "client") )
    __debugbreak();
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4411, scrContext, "AnimScriptSetInputParamReplicationStatus(). USAGE: <player> AnimScriptSetInputParamReplicationStatus( <replicate> )\n");
  Int = Scr_GetInt(scrContext, 0);
  v11 = client->flags & 0xFFFFF7FF;
  if ( Int )
    v11 = client->flags | 0x800;
  client->flags = v11;
}

/*
==============
GScr_AnimScriptSetParachuteState
==============
*/
void GScr_AnimScriptSetParachuteState(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  playerState_s *EntityPlayerState; 
  scr_string_t ConstString; 
  int ParachuteState; 
  unsigned __int8 v12; 

  entnum = entref.entnum;
  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16788, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClient(Entity) )
  {
    targetname = Entity->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(Entity->classname);
    v8 = j_va("AnimScriptSetParachuteState(). Only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, Entity->r.currentOrigin.v[0], Entity->r.currentOrigin.v[1], Entity->r.currentOrigin.v[2], v7, v6);
    Scr_Error(COM_ERR_4412, scrContext, v8);
  }
  EntityPlayerState = G_GetEntityPlayerState(Entity);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16796, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4413, scrContext, "AnimScriptSetInputParamReplicationStatus(). USAGE: <player> AnimScriptSetInputParamReplicationStatus( <replicate> )\n");
  ConstString = Scr_GetConstString(scrContext, 0);
  ParachuteState = BG_AnimScriptGetParachuteState(ConstString);
  v12 = ParachuteState;
  if ( !ParachuteState || ParachuteState >= 12 )
    Scr_ParamError(COM_ERR_4414, scrContext, 0, "Invalid parachute state supplied to AnimScriptSetParachuteState");
  GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::SetFlagInternal(&EntityPlayerState->pm_flags, ACTIVE, 0x2Eu);
  EntityPlayerState->skydivePlayerState.animState = v12;
}

/*
==============
GScr_AnimScriptExitParachuteState
==============
*/
void GScr_AnimScriptExitParachuteState(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  playerState_s *EntityPlayerState; 

  entnum = entref.entnum;
  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16832, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClientOrAgent(Entity) )
  {
    targetname = Entity->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(Entity->classname);
    v8 = j_va("AnimScriptExitParachuteState(). Only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, Entity->r.currentOrigin.v[0], Entity->r.currentOrigin.v[1], Entity->r.currentOrigin.v[2], v7, v6);
    Scr_Error(COM_ERR_4415, scrContext, v8);
  }
  EntityPlayerState = G_GetEntityPlayerState(Entity);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16840, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( (int)Scr_GetNumParam(scrContext) > 0 )
    Scr_Error(COM_ERR_4416, scrContext, "AnimScriptExitParachuteState(). Too many parameters. USAGE: <player> AnimScriptExitParachuteState()\n");
  GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(&EntityPlayerState->pm_flags, ACTIVE, 0x2Eu);
  EntityPlayerState->skydivePlayerState.animState = 0;
}

/*
==============
GScr_AnimScriptSelfRevivingDoneEvent
==============
*/
void GScr_AnimScriptSelfRevivingDoneEvent(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  playerState_s *EntityPlayerState; 
  unsigned int *holdrand; 
  GHandler *Handler; 

  entnum = entref.entnum;
  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16870, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClientOrAgent(Entity) )
  {
    targetname = Entity->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(Entity->classname);
    v8 = j_va("AnimScriptSelfRevivingDoneEvent(): only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, Entity->r.currentOrigin.v[0], Entity->r.currentOrigin.v[1], Entity->r.currentOrigin.v[2], v7, v6);
    Scr_Error(COM_ERR_6427, scrContext, v8);
  }
  EntityPlayerState = G_GetEntityPlayerState(Entity);
  holdrand = G_GetRandomSeed();
  Handler = GHandler::getHandler();
  BG_AnimScriptEvent(Handler, EntityPlayerState, ANIM_ET_SELF_REVIVING_DONE, 0, 1, holdrand);
}

/*
==============
GScr_AnimScriptBuddyRevivingDoneEvent
==============
*/
void GScr_AnimScriptBuddyRevivingDoneEvent(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  playerState_s *EntityPlayerState; 
  unsigned int *holdrand; 
  GHandler *Handler; 

  entnum = entref.entnum;
  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16899, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClientOrAgent(Entity) )
  {
    targetname = Entity->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(Entity->classname);
    v8 = j_va("AnimScriptBuddyRevivingDoneEvent(): only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, Entity->r.currentOrigin.v[0], Entity->r.currentOrigin.v[1], Entity->r.currentOrigin.v[2], v7, v6);
    Scr_Error(COM_ERR_6428, scrContext, v8);
  }
  EntityPlayerState = G_GetEntityPlayerState(Entity);
  holdrand = G_GetRandomSeed();
  Handler = GHandler::getHandler();
  BG_AnimScriptEvent(Handler, EntityPlayerState, ANIM_ET_BUDDY_REVIVING_DONE, 0, 1, holdrand);
}

/*
==============
GScr_AnimScriptEnterVehicle
==============
*/
void GScr_AnimScriptEnterVehicle(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  playerState_s *EntityPlayerState; 

  entnum = entref.entnum;
  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16925, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClientOrAgent(Entity) )
  {
    targetname = Entity->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(Entity->classname);
    v8 = j_va("AnimScriptEnterVehicle(). Only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, Entity->r.currentOrigin.v[0], Entity->r.currentOrigin.v[1], Entity->r.currentOrigin.v[2], v7, v6);
    Scr_Error(COM_ERR_4417, scrContext, v8);
  }
  EntityPlayerState = G_GetEntityPlayerState(Entity);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16933, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( (int)Scr_GetNumParam(scrContext) > 0 )
    Scr_Error(COM_ERR_4418, scrContext, "AnimScriptEnterVehicle(). USAGE: <player> AnimScriptEnterVehicle()\n");
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal(&EntityPlayerState->otherFlags, ACTIVE, 0x1Bu);
}

/*
==============
GScr_AnimScriptExitVehicle
==============
*/
void GScr_AnimScriptExitVehicle(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  playerState_s *EntityPlayerState; 

  entnum = entref.entnum;
  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16959, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClientOrAgent(Entity) )
  {
    targetname = Entity->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(Entity->classname);
    v8 = j_va("AnimScriptExitVehicle(). Only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, Entity->r.currentOrigin.v[0], Entity->r.currentOrigin.v[1], Entity->r.currentOrigin.v[2], v7, v6);
    Scr_Error(COM_ERR_4419, scrContext, v8);
  }
  EntityPlayerState = G_GetEntityPlayerState(Entity);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16967, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( (int)Scr_GetNumParam(scrContext) > 0 )
    Scr_Error(COM_ERR_4420, scrContext, "AnimScriptExitVehicle(). USAGE: <player> AnimScriptEnterVehicle()\n");
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal(&EntityPlayerState->otherFlags, ACTIVE, 0x1Bu);
}

/*
==============
GScr_Vehicle_SetHeldWeaponVisibility
==============
*/
void GScr_Vehicle_SetHeldWeaponVisibility(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  scr_string_t v5; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  playerState_s *EntityPlayerState; 
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *p_otherFlags; 
  scr_string_t targetname; 
  const char *v12; 
  const char *v13; 
  const char *v14; 

  entnum = entref.entnum;
  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16994, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( G_Utils_IsClientOrAgent(Entity) )
  {
    EntityPlayerState = G_GetEntityPlayerState(Entity);
    if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17003, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
      __debugbreak();
    p_otherFlags = &EntityPlayerState->otherFlags;
    if ( GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(p_otherFlags, ACTIVE, 0x1Bu) )
    {
      if ( Scr_GetNumParam(scrContext) != 1 )
        Scr_Error(COM_ERR_6140, scrContext, "Vehicle_SetHeldWeaponVisibility(). USAGE: <player> Vehicle_SetHeldWeaponVisibility( isVisible )\n");
      if ( Scr_GetInt(scrContext, 0) )
        GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal(p_otherFlags, ACTIVE, 0x1Cu);
      else
        GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal(p_otherFlags, ACTIVE, 0x1Cu);
    }
    else
    {
      targetname = Entity->targetname;
      if ( targetname )
        v12 = SL_ConvertToString(targetname);
      else
        v12 = "<undefined>";
      v13 = SL_ConvertToString(Entity->classname);
      v14 = j_va("Vehicle_SetHeldWeaponVisibility(). Only valid on players or agents which are playing vehicle animations via the AnimScriptEnterVehicle call; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, Entity->r.currentOrigin.v[0], Entity->r.currentOrigin.v[1], Entity->r.currentOrigin.v[2], v13, v12);
      Scr_Error(COM_ERR_6139, scrContext, v14);
    }
  }
  else
  {
    v5 = Entity->targetname;
    if ( v5 )
      v6 = SL_ConvertToString(v5);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(Entity->classname);
    v8 = j_va("Vehicle_SetHeldWeaponVisibility(). Only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, Entity->r.currentOrigin.v[0], Entity->r.currentOrigin.v[1], Entity->r.currentOrigin.v[2], v7, v6);
    Scr_Error(COM_ERR_6138, scrContext, v8);
  }
}

/*
==============
GScr_Vehicle_SetStowedWeaponVisibility
==============
*/
void GScr_Vehicle_SetStowedWeaponVisibility(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  scr_string_t v5; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  playerState_s *EntityPlayerState; 
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *p_otherFlags; 
  scr_string_t targetname; 
  const char *v12; 
  const char *v13; 
  const char *v14; 

  entnum = entref.entnum;
  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17045, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( G_Utils_IsClientOrAgent(Entity) )
  {
    EntityPlayerState = G_GetEntityPlayerState(Entity);
    if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17054, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
      __debugbreak();
    p_otherFlags = &EntityPlayerState->otherFlags;
    if ( GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(p_otherFlags, ACTIVE, 0x1Bu) )
    {
      if ( Scr_GetNumParam(scrContext) != 1 )
        Scr_Error(COM_ERR_6143, scrContext, "Vehicle_SetStowedWeaponVisibility(). USAGE: <player> Vehicle_SetStowedWeaponVisibility( isVisible )\n");
      if ( Scr_GetInt(scrContext, 0) )
        GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal(p_otherFlags, ACTIVE, 0x1Du);
      else
        GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal(p_otherFlags, ACTIVE, 0x1Du);
    }
    else
    {
      targetname = Entity->targetname;
      if ( targetname )
        v12 = SL_ConvertToString(targetname);
      else
        v12 = "<undefined>";
      v13 = SL_ConvertToString(Entity->classname);
      v14 = j_va("Vehicle_SetStowedWeaponVisibility(). Only valid on players or agents which are playing vehicle animations via the AnimScriptEnterVehicle call; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, Entity->r.currentOrigin.v[0], Entity->r.currentOrigin.v[1], Entity->r.currentOrigin.v[2], v13, v12);
      Scr_Error(COM_ERR_6142, scrContext, v14);
    }
  }
  else
  {
    v5 = Entity->targetname;
    if ( v5 )
      v6 = SL_ConvertToString(v5);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(Entity->classname);
    v8 = j_va("Vehicle_SetStowedWeaponVisibility(). Only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, Entity->r.currentOrigin.v[0], Entity->r.currentOrigin.v[1], Entity->r.currentOrigin.v[2], v7, v6);
    Scr_Error(COM_ERR_6141, scrContext, v8);
  }
}

/*
==============
GScr_GetLeftStickX
==============
*/
void GScr_GetLeftStickX(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  playerState_s *EntityPlayerState; 
  float v10; 

  entnum = entref.entnum;
  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17095, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClient(Entity) )
  {
    targetname = Entity->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(Entity->classname);
    v8 = j_va("GetLeftStickX(). Only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, Entity->r.currentOrigin.v[0], Entity->r.currentOrigin.v[1], Entity->r.currentOrigin.v[2], v7, v6);
    Scr_Error(COM_ERR_4421, scrContext, v8);
  }
  if ( (int)Scr_GetNumParam(scrContext) > 0 )
    Scr_Error(COM_ERR_4422, scrContext, "GetLeftStickX(). USAGE: x = <player> GetLeftStickX()\n");
  EntityPlayerState = G_GetEntityPlayerState(Entity);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17110, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
    __debugbreak();
  LODWORD(v10) = *(_QWORD *)&BG_GetStickCartesianCoords(EntityPlayerState->lastInput.rightmove, EntityPlayerState->lastInput.forwardmove);
  Scr_AddFloat(scrContext, v10);
}

/*
==============
GScr_GetLeftStickY
==============
*/
void GScr_GetLeftStickY(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  playerState_s *EntityPlayerState; 
  vec2_t StickCartesianCoords; 

  entnum = entref.entnum;
  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17133, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClient(Entity) )
  {
    targetname = Entity->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(Entity->classname);
    v8 = j_va("GetLeftStickY(). Only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, Entity->r.currentOrigin.v[0], Entity->r.currentOrigin.v[1], Entity->r.currentOrigin.v[2], v7, v6);
    Scr_Error(COM_ERR_4423, scrContext, v8);
  }
  if ( (int)Scr_GetNumParam(scrContext) > 0 )
    Scr_Error(COM_ERR_4424, scrContext, "GetLeftStickY(). USAGE: y = <player> GetLeftStickY()\n");
  EntityPlayerState = G_GetEntityPlayerState(Entity);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17148, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
    __debugbreak();
  StickCartesianCoords = BG_GetStickCartesianCoords(EntityPlayerState->lastInput.rightmove, EntityPlayerState->lastInput.forwardmove);
  Scr_AddFloat(scrContext, StickCartesianCoords.v[1]);
}

/*
==============
GScr_GetRightStickX
==============
*/
void GScr_GetRightStickX(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  playerState_s *EntityPlayerState; 
  float v10; 

  entnum = entref.entnum;
  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17171, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClient(Entity) )
  {
    targetname = Entity->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(Entity->classname);
    v8 = j_va("GetRightStickX(). Only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, Entity->r.currentOrigin.v[0], Entity->r.currentOrigin.v[1], Entity->r.currentOrigin.v[2], v7, v6);
    Scr_Error(COM_ERR_4425, scrContext, v8);
  }
  if ( (int)Scr_GetNumParam(scrContext) > 0 )
    Scr_Error(COM_ERR_4426, scrContext, "GetRightStickX(). USAGE: x = <player> GetRightStickX()\n");
  EntityPlayerState = G_GetEntityPlayerState(Entity);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17186, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
    __debugbreak();
  LODWORD(v10) = *(_QWORD *)&BG_GetStickCartesianCoords(EntityPlayerState->lastInput.yawmove, EntityPlayerState->lastInput.pitchmove);
  Scr_AddFloat(scrContext, v10);
}

/*
==============
GScr_GetRightStickY
==============
*/
void GScr_GetRightStickY(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  playerState_s *EntityPlayerState; 
  vec2_t StickCartesianCoords; 

  entnum = entref.entnum;
  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17209, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClient(Entity) )
  {
    targetname = Entity->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(Entity->classname);
    v8 = j_va("GetRightStickY(). Only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, Entity->r.currentOrigin.v[0], Entity->r.currentOrigin.v[1], Entity->r.currentOrigin.v[2], v7, v6);
    Scr_Error(COM_ERR_4427, scrContext, v8);
  }
  if ( (int)Scr_GetNumParam(scrContext) > 0 )
    Scr_Error(COM_ERR_4428, scrContext, "GetRightStickY(). USAGE: y = <player> GetRightStickY()\n");
  EntityPlayerState = G_GetEntityPlayerState(Entity);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17224, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
    __debugbreak();
  StickCartesianCoords = BG_GetStickCartesianCoords(EntityPlayerState->lastInput.yawmove, EntityPlayerState->lastInput.pitchmove);
  Scr_AddFloat(scrContext, StickCartesianCoords.v[1]);
}

/*
==============
GScr_PlayAnimScriptSceneEvent
==============
*/
void GScr_PlayAnimScriptSceneEvent(scrContext_t *scrContext, scr_entref_t entref)
{
  const characterInfo_t *v2; 
  int NumParam; 
  gentity_s *Entity; 
  scr_string_t targetname; 
  const char *v8; 
  const char *v9; 
  const char *v10; 
  playerState_s *EntityPlayerState; 
  const char *String; 
  const char *v13; 
  const char *v14; 
  const clientState_t *p_cs; 
  int time; 
  const char *v17; 
  gclient_s *client; 
  gagent_s *agent; 
  unsigned int ScriptedSceneAnimTypeIndex; 
  int v21; 
  const char *v22; 
  unsigned int *holdrand; 
  GHandler *Handler; 
  int v25; 
  int v26; 
  const char *v27; 
  PlayerAnimScriptEventType event; 
  char *value; 

  v2 = NULL;
  value = NULL;
  NumParam = Scr_GetNumParam(scrContext);
  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17255, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClientOrAgent(Entity) )
  {
    targetname = Entity->targetname;
    if ( targetname )
      v8 = SL_ConvertToString(targetname);
    else
      v8 = "<undefined>";
    v9 = SL_ConvertToString(Entity->classname);
    v10 = j_va("PlayAnimScriptEvent(). Only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entref.entnum, Entity->r.currentOrigin.v[0], Entity->r.currentOrigin.v[1], Entity->r.currentOrigin.v[2], v9, v8);
    Scr_Error(COM_ERR_4429, scrContext, v10);
  }
  EntityPlayerState = G_GetEntityPlayerState(Entity);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17263, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( NumParam < 1 )
    Scr_Error(COM_ERR_4430, scrContext, "PlayAnimScriptEvent(). USAGE: <player> PlayAnimScriptEvent(<eventname>, <optional scene_scriptedanimtype>)\n");
  String = Scr_GetString(scrContext, 0);
  if ( NumParam >= 2 )
    value = (char *)Scr_GetString(scrContext, 1u);
  event = BG_GetExposedAnimEvent(String);
  if ( event < ANIM_ET_DEATH )
  {
    v13 = j_va("PlayAnimScriptSceneEvent(). Invalid event name '%s'\n", String);
    Scr_Error(COM_ERR_4431, scrContext, v13);
  }
  if ( event != ANIM_ET_SCRIPTED_SCENE )
  {
    v14 = j_va("PlayAnimScriptSceneEvent(). Attempting to play anim event '%s', but it is not a scene anim, use PlayAnimScriptEvent for this\n", String);
    Scr_Error(COM_ERR_4432, scrContext, v14);
  }
  p_cs = NULL;
  if ( Entity->client )
  {
    if ( !*(_QWORD *)&GStatic::ms_gameStatics && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_static.h", 64, ASSERT_TYPE_ASSERT, "( ms_gameStatics )", (const char *)&queryFormat, "ms_gameStatics") )
      __debugbreak();
    if ( *(_QWORD *)&GStatic::ms_gameStatics )
      v2 = (const characterInfo_t *)(*(__int64 (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)&GStatic::ms_gameStatics + 216i64))(*(_QWORD *)&GStatic::ms_gameStatics, (unsigned int)Entity->s.number);
    p_cs = &Entity->client->sess.cs;
  }
  time = level.time;
  v17 = j_va("g_scr_main starting scripted anim %s", String);
  BG_ScriptedAsmDebugPrint(v17, time, v2, p_cs);
  if ( PlayerASM_IsEnabled() )
  {
    client = Entity->client;
    if ( client )
    {
      client->sess.cs.playerASM_scripted_anim_start_time = level.time;
      BG_ScriptedAsmDebugPrint("g_scr_main client anim", level.time, v2, p_cs);
    }
    else
    {
      agent = Entity->agent;
      if ( agent )
      {
        agent->agentState.playerASM_scripted_anim_start_time = level.time;
        BG_ScriptedAsmDebugPrint("g_scr_main agent anim", level.time, v2, p_cs);
      }
    }
  }
  else
  {
    GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::SetFlagInternal(&EntityPlayerState->pm_flags, GameModeFlagValues::ms_mpValue, 0x3Du);
  }
  if ( NumParam >= 2 && value )
  {
    ScriptedSceneAnimTypeIndex = BG_GetScriptedSceneAnimTypeIndex(value);
    BG_AnimScriptSetConditionValue(EntityPlayerState, 37, ScriptedSceneAnimTypeIndex);
    v21 = level.time;
    v22 = j_va("Set type %d", ScriptedSceneAnimTypeIndex);
    BG_ScriptedAsmDebugPrint(v22, v21, v2, p_cs);
  }
  holdrand = G_GetRandomSeed();
  Handler = GHandler::getHandler();
  v25 = BG_AnimScriptEvent(Handler, EntityPlayerState, event, 0, 1, holdrand);
  LODWORD(holdrand) = level.time;
  v26 = v25;
  v27 = j_va("Set event %d", (unsigned int)event);
  BG_ScriptedAsmDebugPrint(v27, (int)holdrand, v2, p_cs);
  Scr_AddInt(scrContext, v26);
}

/*
==============
GScr_StopAnimScriptSceneEvent
==============
*/
void GScr_StopAnimScriptSceneEvent(scrContext_t *scrContext, scr_entref_t entref)
{
  int NumParam; 
  gentity_s *Entity; 
  scr_string_t targetname; 
  const char *v7; 
  const char *v8; 
  const char *v9; 
  playerState_s *EntityPlayerState; 
  __int64 v11; 
  const characterInfo_t *v12; 
  const clientState_t *p_cs; 
  GHandler *Handler; 
  unsigned int *holdrand; 
  GHandler *v16; 

  NumParam = Scr_GetNumParam(scrContext);
  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17367, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClientOrAgent(Entity) )
  {
    targetname = Entity->targetname;
    if ( targetname )
      v7 = SL_ConvertToString(targetname);
    else
      v7 = "<undefined>";
    v8 = SL_ConvertToString(Entity->classname);
    v9 = j_va("StopAnimScriptEvent(). Only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entref.entnum, Entity->r.currentOrigin.v[0], Entity->r.currentOrigin.v[1], Entity->r.currentOrigin.v[2], v8, v7);
    Scr_Error(COM_ERR_4433, scrContext, v9);
  }
  EntityPlayerState = G_GetEntityPlayerState(Entity);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17375, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( NumParam > 0 )
    Scr_Error(COM_ERR_4434, scrContext, "StopAnimScriptEvent() takes no arguments\n");
  if ( !PlayerASM_IsEnabled() )
    GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(&EntityPlayerState->pm_flags, GameModeFlagValues::ms_mpValue, 0x3Du);
  v12 = NULL;
  p_cs = NULL;
  if ( Entity->client )
  {
    if ( !*(_QWORD *)&GStatic::ms_gameStatics && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_static.h", 64, ASSERT_TYPE_ASSERT, "( ms_gameStatics )", (const char *)&queryFormat, "ms_gameStatics") )
      __debugbreak();
    if ( *(_QWORD *)&GStatic::ms_gameStatics )
      v12 = (const characterInfo_t *)(*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64, const clientState_t *))(**(_QWORD **)&GStatic::ms_gameStatics + 216i64))(*(_QWORD *)&GStatic::ms_gameStatics, (unsigned int)Entity->s.number, v11, p_cs);
    p_cs = &Entity->client->sess.cs;
  }
  BG_ScriptedAsmDebugPrint("g_scr_main stop anim scripted", level.time, v12, p_cs);
  BG_AnimScriptSetConditionValue(EntityPlayerState, 37, 0);
  Handler = GHandler::getHandler();
  BG_ClearSceneAnim(Handler, EntityPlayerState);
  holdrand = G_GetRandomSeed();
  v16 = GHandler::getHandler();
  BG_AnimScriptEvent(v16, EntityPlayerState, ANIM_ET_SCRIPTED_SCENE_DONE, 0, 1, holdrand);
}

/*
==============
GScr_PlayAnimScriptEvent
==============
*/
void GScr_PlayAnimScriptEvent(scrContext_t *scrContext, scr_entref_t entref)
{
  const char *v4; 
  int NumParam; 
  gentity_s *Entity; 
  scr_string_t targetname; 
  const char *v8; 
  const char *v9; 
  const char *v10; 
  playerState_s *EntityPlayerState; 
  const char *String; 
  int ExposedAnimEvent; 
  const char *v14; 
  const char *v15; 
  int ScriptedAnimTypeIndex; 
  unsigned int *holdrand; 
  GHandler *Handler; 
  int v19; 

  v4 = NULL;
  NumParam = Scr_GetNumParam(scrContext);
  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17428, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClientOrAgent(Entity) )
  {
    targetname = Entity->targetname;
    if ( targetname )
      v8 = SL_ConvertToString(targetname);
    else
      v8 = "<undefined>";
    v9 = SL_ConvertToString(Entity->classname);
    v10 = j_va("PlayAnimScriptEvent(). Only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entref.entnum, Entity->r.currentOrigin.v[0], Entity->r.currentOrigin.v[1], Entity->r.currentOrigin.v[2], v9, v8);
    Scr_Error(COM_ERR_4435, scrContext, v10);
  }
  EntityPlayerState = G_GetEntityPlayerState(Entity);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17436, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( NumParam < 1 )
    Scr_Error(COM_ERR_4436, scrContext, "PlayAnimScriptEvent(). USAGE: <player> PlayAnimScriptEvent(<eventname>, <optional scriptedanimtype>)\n");
  String = Scr_GetString(scrContext, 0);
  if ( NumParam >= 2 )
    v4 = Scr_GetString(scrContext, 1u);
  ExposedAnimEvent = BG_GetExposedAnimEvent(String);
  if ( ExposedAnimEvent < 0 )
  {
    v14 = j_va("PlayAnimScriptEvent(). Invalid event name '%s'\n", String);
    Scr_Error(COM_ERR_4437, scrContext, v14);
  }
  if ( ExposedAnimEvent == 34 )
  {
    v15 = j_va("PlayAnimScriptEvent(). Attempting to play a scene anim event '%s', use PlayAnimScriptSceneEvent for this\n", String);
    Scr_Error(COM_ERR_4438, scrContext, v15);
  }
  if ( NumParam >= 2 && v4 )
  {
    ScriptedAnimTypeIndex = BG_GetScriptedAnimTypeIndex(v4);
    BG_AnimScriptSetConditionBit(EntityPlayerState, 23, ScriptedAnimTypeIndex);
  }
  holdrand = G_GetRandomSeed();
  Handler = GHandler::getHandler();
  v19 = BG_AnimScriptEvent(Handler, EntityPlayerState, (PlayerAnimScriptEventType)ExposedAnimEvent, 0, 1, holdrand);
  Scr_AddInt(scrContext, v19);
}

/*
==============
PlayerCmd_PlayViewModelAnim
==============
*/
void PlayerCmd_PlayViewModelAnim(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *String; 
  const char *v5; 
  gclient_s *client; 
  playerState_s *p_ps; 
  GWeaponMap *Instance; 
  XAnimParts *Data; 
  float v10; 
  int v11; 
  int time; 
  unsigned int v13; 
  GWeaponMap *v14; 
  const char *v15; 
  unsigned int outIndex[4]; 
  char dest[1024]; 

  Entity = GetEntity(entref);
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4439, scrContext, "PlayViewModelAnim(). Invalid number of parameters");
  String = Scr_GetString(scrContext, 0);
  v5 = String;
  if ( String && *String )
  {
    client = Entity->client;
    if ( !client )
    {
      Scr_Error(COM_ERR_4441, scrContext, "PlayGestureViewmodel(). Self must be a player");
      client = Entity->client;
    }
    if ( !client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17512, ASSERT_TYPE_ASSERT, "(player->client)", (const char *)&queryFormat, "player->client") )
      __debugbreak();
    p_ps = &Entity->client->ps;
    Instance = GWeaponMap::GetInstance();
    if ( BG_HighPriorityWeapon_Get(Instance, p_ps)->weaponIdx )
    {
      Scr_Error(COM_ERR_4442, scrContext, "You cannot play a scripted viewmodel animation when a high priority weapon is set. Player is most likely in the process of switching, or trying to switch, to a high priority weapon.");
    }
    else
    {
      Core_strcpy(dest, 0x400ui64, v5);
      I_strlwr(dest);
      Com_Printf(16, "Playing anim %s on the viewmodel\n", dest);
      if ( NetConstStrings_GetIndexPlusOneFromName(NETCONSTSTRINGTYPE_ANIM, dest, outIndex) )
      {
        Data = XAnimFindData(dest);
        v10 = (float)((float)Data->numframes / Data->framerate) * 1000.0;
        v11 = (int)v10;
        if ( !outIndex[0] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17537, ASSERT_TYPE_ASSERT, "( animIndex != 0 )", (const char *)&queryFormat, "animIndex != 0") )
          __debugbreak();
        time = level.time;
        v13 = outIndex[0];
        v14 = GWeaponMap::GetInstance();
        BG_Weapon_ViewModelScriptedBegin(v14, p_ps, v13, time, (int)v10, WEAPON_HAND_DEFAULT);
      }
      else
      {
        v11 = 0;
        v15 = j_va("MP Anim [%s] needs to be pre-cached in order to work with PlayViewModelAnim()\n", dest);
        Scr_Error(COM_ERR_4443, scrContext, v15);
      }
      Scr_AddInt(scrContext, v11);
    }
  }
  else
  {
    Scr_Error(COM_ERR_4440, scrContext, "PlayViewModelAnim() missing xanim name");
  }
}

/*
==============
PlayerCmd_StopViewModelAnim
==============
*/
void PlayerCmd_StopViewModelAnim(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  playerState_s *p_ps; 
  GHandler *Handler; 
  GWeaponMap *Instance; 

  Entity = GetEntity(entref);
  if ( Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_4444, scrContext, "PlayViewModelAnim(). Takes No parameters");
  if ( !Entity->client )
  {
    Scr_Error(COM_ERR_4445, scrContext, "PlayGestureViewmodel(). Self must be a player");
    if ( !Entity->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17577, ASSERT_TYPE_ASSERT, "(player->client)", (const char *)&queryFormat, "player->client") )
      __debugbreak();
  }
  p_ps = &Entity->client->ps;
  if ( BG_Weapon_IsScriptedViewModelAnimPlaying(p_ps) )
  {
    GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::ClearFlagInternal(&p_ps->weapCommon.weapFlags, ACTIVE, 0x2Au);
    Handler = GHandler::getHandler();
    Instance = GWeaponMap::GetInstance();
    PM_ResetWeaponState(Instance, p_ps, Handler);
  }
}

/*
==============
PlayerCmd_IsViewModelAnimPlaying
==============
*/
void PlayerCmd_IsViewModelAnimPlaying(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  bool IsScriptedViewModelAnimPlaying; 

  Entity = GetEntity(entref);
  if ( Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_4446, scrContext, "IsViewModelAnimPlaying() takes no parameters");
  if ( !Entity->client )
  {
    Scr_Error(COM_ERR_4447, scrContext, "IsViewModelAnimPlaying() self must be a player");
    if ( !Entity->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17613, ASSERT_TYPE_ASSERT, "(player->client)", (const char *)&queryFormat, "player->client") )
      __debugbreak();
  }
  IsScriptedViewModelAnimPlaying = BG_Weapon_IsScriptedViewModelAnimPlaying(&Entity->client->ps);
  Scr_AddInt(scrContext, IsScriptedViewModelAnimPlaying);
}

/*
==============
GScr_SetDemeanorViewmodel
==============
*/
void GScr_SetDemeanorViewmodel(scrContext_t *scrContext, scr_entref_t entref)
{
  const char *String; 
  gentity_s *Entity; 
  unsigned int v5; 
  scr_string_t ConstString; 
  scr_string_t v7; 
  playerState_s *p_ps; 
  scr_string_t DefaultGesture; 
  unsigned int IndexFromName; 
  bool v11; 

  String = NULL;
  Entity = GetEntity(entref);
  v5 = Scr_GetNumParam(scrContext) - 1;
  if ( v5 )
  {
    if ( v5 != 1 )
      Scr_Error(COM_ERR_4448, scrContext, "too many parameters");
    String = Scr_GetString(scrContext, 1u);
  }
  ConstString = Scr_GetConstString(scrContext, 0);
  v7 = ConstString;
  if ( ConstString )
  {
    if ( BG_Demeanor_GetStateType(ConstString) == DEMEANOR_STATE_NUM )
    {
      Scr_Error(COM_ERR_4450, scrContext, "SetDemeanorViewmodel() invalid state name. Valid states are: 'normal', 'safe', 'relaxed'.");
    }
    else
    {
      if ( !Entity->client )
      {
        Scr_Error(COM_ERR_4451, scrContext, "self must be a player");
        if ( !Entity->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17679, ASSERT_TYPE_ASSERT, "(player->client)", (const char *)&queryFormat, "player->client") )
          __debugbreak();
      }
      p_ps = &Entity->client->ps;
      if ( !String || !*String )
      {
        DefaultGesture = BG_Demeanor_GetDefaultGesture(v7);
        if ( DefaultGesture )
          String = SL_ConvertToString(DefaultGesture);
        else
          String = "void";
      }
      IndexFromName = BG_Gesture_GetIndexFromName(String);
      if ( IndexFromName == 256 && BG_Demeanor_GetStateType(v7) )
        Scr_Error(COM_ERR_4452, scrContext, "SetDemeanorViewmodel() invalid gesture asset name.\n");
      v11 = 0;
      if ( (unsigned int)(p_ps->weapState[0].weaponState - 34) > 2 )
        v11 = BG_Demeanor_SetState(p_ps, v7, IndexFromName, level.time);
      Scr_AddBool(scrContext, v11);
    }
  }
  else
  {
    Scr_Error(COM_ERR_4449, scrContext, "SetDemeanorViewmodel() missing demeanor state name");
  }
}

/*
==============
GScr_GetDemeanorViewmodel
==============
*/
void GScr_GetDemeanorViewmodel(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  DemeanorStateType TargetState; 
  scr_string_t StateName; 
  const char *v6; 

  Entity = GetEntity(entref);
  if ( Scr_GetNumParam(scrContext) )
  {
    Scr_Error(COM_ERR_4453, scrContext, "too many parameters");
  }
  else
  {
    if ( !Entity->client )
    {
      Scr_Error(COM_ERR_4454, scrContext, "self must be a player");
      if ( !Entity->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17751, ASSERT_TYPE_ASSERT, "(player->client)", (const char *)&queryFormat, "player->client") )
        __debugbreak();
    }
    TargetState = BG_Demeanor_GetTargetState(&Entity->client->ps);
    StateName = BG_Demeanor_GetStateName(TargetState);
    v6 = SL_ConvertToString(StateName);
    Scr_AddString(scrContext, v6);
  }
}

/*
==============
GScr_PlayGestureViewmodel
==============
*/
void GScr_PlayGestureViewmodel(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *v2; 
  bool v4; 
  gentity_s *Entity; 
  int NumParam; 
  double Float; 
  double v8; 
  const char *String; 
  const char *v10; 
  playerState_s *p_ps; 
  unsigned int IndexFromName; 
  bool v13; 
  int gameTime; 
  GHandler *Handler; 
  GWeaponMap *Instance; 
  GesturePlayRequest *v17; 
  double v18; 
  bool v19; 
  const char *ErrorDescription; 
  const char *v21; 
  int v22; 
  int v23; 
  int number; 
  GestureError outErrorCode; 
  GesturePlayRequest request; 
  GesturePlayRequest result; 
  bool v28; 
  bool v29; 

  v2 = NULL;
  number = 2047;
  v23 = 0;
  v22 = 0;
  v29 = 0;
  v4 = 0;
  v28 = 0;
  Entity = GetEntity(entref);
  NumParam = Scr_GetNumParam(scrContext);
  if ( (unsigned int)(NumParam - 1) > 5 )
    Scr_Error(COM_ERR_4455, scrContext, "PlayGestureViewmodel(). Invalid number of parameters");
  if ( NumParam >= 2 && Scr_GetType(scrContext, 1u) )
    v2 = GScr_GetEntity(1u);
  if ( NumParam >= 3 && Scr_GetType(scrContext, 2u) )
    v28 = Scr_GetInt(scrContext, 2u) > 0;
  if ( NumParam >= 4 )
  {
    if ( Scr_GetType(scrContext, 3u) )
    {
      v4 = 1;
      Float = Scr_GetFloat(scrContext, 3u);
      v23 = (int)(float)(*(float *)&Float * 1000.0);
      if ( v23 < 0 )
        Scr_Error(COM_ERR_4456, scrContext, "PlayGestureViewmodel(). Invalid blend time");
    }
  }
  if ( NumParam >= 5 )
  {
    if ( Scr_GetType(scrContext, 4u) )
    {
      v8 = Scr_GetFloat(scrContext, 4u);
      v22 = (int)(float)(*(float *)&v8 * 1000.0);
      if ( v22 < 0 )
        Scr_Error(COM_ERR_4457, scrContext, "PlayGestureViewmodel(). Invalid start time");
    }
  }
  if ( NumParam >= 6 && Scr_GetType(scrContext, 5u) )
    v29 = Scr_GetInt(scrContext, 5u) > 0;
  String = Scr_GetString(scrContext, 0);
  v10 = String;
  if ( String && *String )
  {
    if ( v2 && G_IsEntityInUse(v2->s.number) )
      number = v2->s.number;
    if ( !Entity->client )
    {
      Scr_Error(COM_ERR_4459, scrContext, "PlayGestureViewmodel(). Self must be a player");
      if ( !Entity->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 17862, ASSERT_TYPE_ASSERT, "(player->client)", (const char *)&queryFormat, "player->client") )
        __debugbreak();
    }
    p_ps = &Entity->client->ps;
    IndexFromName = BG_Gesture_GetIndexFromName(v10);
    if ( IndexFromName == 256 )
      Scr_Error(COM_ERR_4460, scrContext, "PlayGestureViewmodel() invalid gesture asset name.\n");
    v13 = v4 && BG_Demeanor_ShouldEnableBlendToLoop(p_ps, IndexFromName);
    gameTime = level.time;
    Handler = GHandler::getHandler();
    Instance = GWeaponMap::GetInstance();
    v17 = BG_GesturePriority_SetupRequest(&result, Instance, p_ps, Handler, IndexFromName, gameTime);
    *(__m256i *)&request.weaponMap = *(__m256i *)&v17->weaponMap;
    *(_OWORD *)&request.startTime = *(_OWORD *)&v17->startTime;
    v18 = *(double *)&v17->cancelTransitions;
    request.startTime = v22;
    request.ignoreGamePlayState = v28;
    request.slotBlendDuration = v23;
    *(double *)&request.cancelTransitions = v18;
    request.targetEntNumber = number;
    request.stopAllGestures = 0;
    request.slotBlend = v4;
    request.cancelTransitions = v29 || v13;
    v19 = BG_GesturePriority_TryPlay(&request, NULL, &outErrorCode);
    if ( !v19 )
    {
      if ( outErrorCode )
      {
        ErrorDescription = BG_Gesture_GetErrorDescription(outErrorCode);
        v21 = j_va("Gesture '%s' %s.", v10, ErrorDescription);
        Scr_Error(COM_ERR_4461, scrContext, v21);
      }
    }
    Scr_AddBool(scrContext, v19);
  }
  else
  {
    Scr_Error(COM_ERR_4458, scrContext, "PlayGestureViewmodel() missing gesture asset name");
  }
}

/*
==============
GScr_ForcePlayGestureViewmodel
==============
*/
void GScr_ForcePlayGestureViewmodel(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *v2; 
  bool v4; 
  bool v5; 
  gentity_s *Entity; 
  int NumParam; 
  double Float; 
  double v9; 
  const char *String; 
  const char *v11; 
  playerState_s *p_ps; 
  unsigned int IndexFromName; 
  bool v14; 
  int gameTime; 
  GHandler *Handler; 
  GWeaponMap *Instance; 
  GesturePlayRequest *v18; 
  double v19; 
  bool v20; 
  const char *ErrorDescription; 
  const char *v22; 
  int v23; 
  int v24; 
  int number; 
  GestureError outErrorCode; 
  GesturePlayRequest request; 
  GesturePlayRequest result; 
  bool v29; 
  bool v30; 

  v2 = NULL;
  number = 2047;
  v24 = 0;
  v4 = 1;
  v23 = 0;
  v29 = 1;
  v30 = 0;
  v5 = 0;
  Entity = GetEntity(entref);
  NumParam = Scr_GetNumParam(scrContext);
  if ( (unsigned int)(NumParam - 1) > 5 )
    Scr_Error(COM_ERR_4462, scrContext, "PlayGestureViewmodel(). Invalid number of parameters");
  if ( NumParam >= 3 )
  {
    if ( Scr_GetType(scrContext, 2u) )
    {
      v5 = 1;
      Float = Scr_GetFloat(scrContext, 2u);
      v24 = (int)(float)(*(float *)&Float * 1000.0);
      if ( v24 < 0 )
        Scr_Error(COM_ERR_4463, scrContext, "PlayGestureViewmodel(). Invalid blend time");
    }
  }
  if ( NumParam >= 2 && Scr_GetType(scrContext, 1u) )
    v2 = GScr_GetEntity(1u);
  if ( NumParam >= 4 )
  {
    if ( Scr_GetType(scrContext, 3u) )
    {
      v9 = Scr_GetFloat(scrContext, 3u);
      v23 = (int)(float)(*(float *)&v9 * 1000.0);
      if ( v23 < 0 )
        Scr_Error(COM_ERR_4464, scrContext, "PlayGestureViewmodel(). Invalid start time");
    }
  }
  if ( NumParam >= 5 && Scr_GetType(scrContext, 4u) )
  {
    v4 = Scr_GetInt(scrContext, 4u) > 0;
    v29 = v4;
  }
  if ( NumParam == 6 )
  {
    if ( Scr_GetType(scrContext, 5u) )
    {
      v30 = Scr_GetInt(scrContext, 5u) > 0;
      if ( !v4 || !v5 )
        Scr_Error(COM_ERR_4465, scrContext, "ForcePlayGestureViewmodel(). Cancel transitions is available only when stopAllGestures is true and a valid blendtime is provided.");
    }
  }
  String = Scr_GetString(scrContext, 0);
  v11 = String;
  if ( String && *String )
  {
    if ( v2 && G_IsEntityInUse(v2->s.number) )
      number = v2->s.number;
    if ( !Entity->client )
    {
      Scr_Error(COM_ERR_4467, scrContext, "PlayGestureViewmodel(). Self must be a player");
      if ( !Entity->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 18000, ASSERT_TYPE_ASSERT, "(player->client)", (const char *)&queryFormat, "player->client") )
        __debugbreak();
    }
    p_ps = &Entity->client->ps;
    IndexFromName = BG_Gesture_GetIndexFromName(v11);
    if ( IndexFromName == 256 )
      Scr_Error(COM_ERR_4468, scrContext, "PlayGestureViewmodel() invalid gesture asset name.\n");
    v14 = v4 && v5 && BG_Demeanor_ShouldEnableBlendToLoop(p_ps, IndexFromName);
    gameTime = level.time;
    Handler = GHandler::getHandler();
    Instance = GWeaponMap::GetInstance();
    v18 = BG_GesturePriority_SetupRequest(&result, Instance, p_ps, Handler, IndexFromName, gameTime);
    *(__m256i *)&request.weaponMap = *(__m256i *)&v18->weaponMap;
    *(_OWORD *)&request.startTime = *(_OWORD *)&v18->startTime;
    v19 = *(double *)&v18->cancelTransitions;
    request.startTime = v23;
    request.stopAllGestures = v29;
    request.slotBlendDuration = v24;
    *(double *)&request.cancelTransitions = v19;
    request.targetEntNumber = number;
    request.ignoreGamePlayState = 1;
    request.slotBlend = v5;
    request.cancelTransitions = v30 || v14;
    v20 = BG_GesturePriority_TryPlay(&request, NULL, &outErrorCode);
    if ( !v20 )
    {
      if ( outErrorCode )
      {
        ErrorDescription = BG_Gesture_GetErrorDescription(outErrorCode);
        v22 = j_va("Gesture '%s' %s.", v11, ErrorDescription);
        Scr_Error(COM_ERR_4469, scrContext, v22);
      }
    }
    Scr_AddBool(scrContext, v20);
  }
  else
  {
    Scr_Error(COM_ERR_4466, scrContext, "PlayGestureViewmodel() missing gesture asset name");
  }
}

/*
==============
GScr_StopGestureViewmodel
==============
*/
void GScr_StopGestureViewmodel(scrContext_t *scrContext, scr_entref_t entref)
{
  const char *v3; 
  int v4; 
  char v5; 
  bool v6; 
  bool cancelTransitions; 
  gentity_s *Entity; 
  int NumParam; 
  const char *String; 
  double Float; 
  const char *v12; 
  ComErrorCode v13; 
  playerState_s *p_ps; 
  unsigned int IndexFromName; 

  v3 = NULL;
  v4 = 0;
  v5 = 1;
  v6 = 0;
  cancelTransitions = 0;
  Entity = GetEntity(entref);
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam > 3 )
  {
    Scr_Error(COM_ERR_4470, scrContext, "StopGestureViewmodel() too many parameters");
    return;
  }
  if ( NumParam >= 1 )
  {
    String = Scr_GetString(scrContext, 0);
    v3 = String;
    if ( !String || !*String )
    {
      Scr_Error(COM_ERR_4471, scrContext, "StopGestureViewmodel() missing gesture asset name.");
      return;
    }
    v5 = 0;
  }
  if ( NumParam >= 2 )
  {
    if ( Scr_GetType(scrContext, 1u) )
    {
      v6 = 1;
      Float = Scr_GetFloat(scrContext, 1u);
      v4 = (int)(float)(*(float *)&Float * 1000.0);
      if ( v4 >= 0 )
        goto LABEL_15;
      v12 = "StopGestureViewmodel(). Invalid 'out' time";
      v13 = COM_ERR_4472;
    }
    else
    {
      if ( Scr_GetType(scrContext, 1u) )
        goto LABEL_15;
      v12 = "StopGestureViewmodel(). Invalid 'out' time use 0 as the default.";
      v13 = COM_ERR_4473;
    }
    Scr_Error(v13, scrContext, v12);
  }
LABEL_15:
  if ( NumParam == 3 && Scr_GetType(scrContext, 2u) )
    cancelTransitions = Scr_GetInt(scrContext, 2u) > 0;
  if ( !Entity->client )
  {
    Scr_Error(COM_ERR_4474, scrContext, "self must be a player");
    if ( !Entity->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 18106, ASSERT_TYPE_ASSERT, "(player->client)", (const char *)&queryFormat, "player->client") )
      __debugbreak();
  }
  p_ps = &Entity->client->ps;
  if ( v5 )
  {
    BG_Gesture_StopAll(p_ps, level.time, v6, v4, cancelTransitions);
  }
  else
  {
    IndexFromName = BG_Gesture_GetIndexFromName(v3);
    if ( IndexFromName == 256 )
      Scr_Error(COM_ERR_4475, scrContext, "StopGestureViewmodel() invalid gesture asset name.\n");
    BG_Gesture_StopByIndex(p_ps, IndexFromName, level.time, v6, v4, cancelTransitions);
  }
}

/*
==============
GScr_GetGestureAnimLength
==============
*/
void GScr_GetGestureAnimLength(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *String; 
  const char *v5; 
  gclient_s *client; 
  unsigned int IndexFromName; 
  const Gesture *AssetFromIndex; 
  double AnimLengthInSeconds; 

  Entity = GetEntity(entref);
  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    String = Scr_GetString(scrContext, 0);
    v5 = String;
    if ( String && *String )
    {
      client = Entity->client;
      if ( !client )
      {
        Scr_Error(COM_ERR_4478, scrContext, "self must be a player");
        client = Entity->client;
      }
      if ( !client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 18164, ASSERT_TYPE_ASSERT, "(player->client)", (const char *)&queryFormat, "player->client") )
        __debugbreak();
      IndexFromName = BG_Gesture_GetIndexFromName(v5);
      if ( IndexFromName == 256 )
        Scr_Error(COM_ERR_4479, scrContext, "GetGestureAnimLength() invalid gesture asset name.\n");
      AssetFromIndex = BG_Gesture_GetAssetFromIndex(IndexFromName);
      if ( !AssetFromIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 18174, ASSERT_TYPE_ASSERT, "(gesture)", (const char *)&queryFormat, "gesture") )
        __debugbreak();
      AnimLengthInSeconds = BG_Gesture_GetAnimLengthInSeconds(AssetFromIndex);
      Scr_AddFloat(scrContext, *(float *)&AnimLengthInSeconds);
    }
    else
    {
      Scr_Error(COM_ERR_4477, scrContext, "GetGestureAnimLength() missing gesture asset name");
    }
  }
  else
  {
    Scr_Error(COM_ERR_4476, scrContext, "too many parameters");
  }
}

/*
==============
GScr_GetGestureStartTime
==============
*/
void GScr_GetGestureStartTime(scrContext_t *scrContext, scr_entref_t entref)
{
  GestureSectionType v3; 
  gentity_s *Entity; 
  const char *String; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  const char *v9; 
  scrContext_t *v10; 
  ComErrorCode v11; 
  unsigned int IndexFromName; 
  float SectionStartTime; 

  v3 = GESTURE_SECTION_NUM;
  Entity = GetEntity(entref);
  if ( Scr_GetNumParam(scrContext) != 2 )
  {
    Scr_Error(COM_ERR_4480, scrContext, "GScr_GetGestureStartTime(): invalid parameters.");
    return;
  }
  String = Scr_GetString(scrContext, 0);
  v6 = String;
  if ( !String || !*String )
  {
    Scr_Error(COM_ERR_4481, scrContext, "GScr_GetGestureStartTime() missing gesture asset name");
    return;
  }
  v7 = Scr_GetString(scrContext, 1u);
  v8 = v7;
  if ( !v7 || !*v7 )
  {
    v9 = "GScr_GetGestureStartTime() invalid gesture section.";
    v10 = scrContext;
    v11 = COM_ERR_4482;
    goto LABEL_9;
  }
  if ( !Entity->client )
  {
    v9 = "self must be a player";
    v10 = scrContext;
    v11 = COM_ERR_4483;
LABEL_9:
    Scr_Error(v11, v10, v9);
    return;
  }
  IndexFromName = BG_Gesture_GetIndexFromName(v6);
  if ( IndexFromName == 256 )
  {
    v9 = "GScr_GetGestureStartTime() invalid gesture asset name.\n";
    v10 = scrContext;
    v11 = COM_ERR_4484;
    goto LABEL_9;
  }
  if ( I_stricmp(v8, "in") )
  {
    if ( I_stricmp(v8, "loop") )
    {
      if ( I_stricmp(v8, "out") )
        Scr_Error(COM_ERR_4485, scrContext, "GScr_GetGestureStartTime() invalid gesture section. Valid values are: 'in', 'loop', and 'out'.");
      else
        v3 = GESTURE_SECTION_OUT;
    }
    else
    {
      v3 = GESTURE_SECTION_LOOP;
    }
  }
  else
  {
    v3 = GESTURE_SECTION_IN;
  }
  SectionStartTime = (float)BG_Gesture_GetSectionStartTime(IndexFromName, v3);
  Scr_AddFloat(scrContext, SectionStartTime * 0.001);
}

/*
==============
GScr_IsGestureLooped
==============
*/
void GScr_IsGestureLooped(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *String; 
  const char *v5; 
  gclient_s *client; 
  unsigned int IndexFromName; 
  const Gesture *AssetFromIndex; 

  Entity = GetEntity(entref);
  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    String = Scr_GetString(scrContext, 0);
    v5 = String;
    if ( String && *String )
    {
      client = Entity->client;
      if ( !client )
      {
        Scr_Error(COM_ERR_4488, scrContext, "IsGestureLooped() self must be a player.");
        client = Entity->client;
      }
      if ( !client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 18299, ASSERT_TYPE_ASSERT, "(player->client)", (const char *)&queryFormat, "player->client") )
        __debugbreak();
      IndexFromName = BG_Gesture_GetIndexFromName(v5);
      if ( IndexFromName == 256 )
        Scr_Error(COM_ERR_4489, scrContext, "IsGestureLooped() invalid gesture asset name.\n");
      AssetFromIndex = BG_Gesture_GetAssetFromIndex(IndexFromName);
      if ( !AssetFromIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 18309, ASSERT_TYPE_ASSERT, "(gesture)", (const char *)&queryFormat, "gesture") )
        __debugbreak();
      Scr_AddBool(scrContext, AssetFromIndex->looping);
    }
    else
    {
      Scr_Error(COM_ERR_4487, scrContext, "IsGestureLooped() missing gesture asset name.");
    }
  }
  else
  {
    Scr_Error(COM_ERR_4486, scrContext, "IsGestureLooped() too many parameters");
  }
}

/*
==============
GScr_IsGesturePlaying
==============
*/
void GScr_IsGesturePlaying(scrContext_t *scrContext, scr_entref_t entref)
{
  const char *v3; 
  char v4; 
  gentity_s *Entity; 
  const char *String; 
  const playerState_s *p_ps; 
  bool IsPlaying; 
  unsigned int IndexFromName; 

  v3 = NULL;
  v4 = 1;
  Entity = GetEntity(entref);
  if ( Scr_GetNumParam(scrContext) > 1 )
  {
    Scr_Error(COM_ERR_4490, scrContext, "IsGesturePlaying() too many parameters");
    return;
  }
  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    String = Scr_GetString(scrContext, 0);
    v3 = String;
    if ( !String || !*String )
    {
      Scr_Error(COM_ERR_4491, scrContext, "IsGesturePlaying() missing gesture asset name.");
      return;
    }
    v4 = 0;
  }
  if ( !Entity->client )
  {
    Scr_Error(COM_ERR_4492, scrContext, "IsGesturePlaying() self must be a player.");
    if ( !Entity->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 18361, ASSERT_TYPE_ASSERT, "(player->client)", (const char *)&queryFormat, "player->client") )
      __debugbreak();
  }
  p_ps = &Entity->client->ps;
  if ( v4 )
  {
    IsPlaying = BG_Gesture_IsPlaying(p_ps, level.time, 0);
  }
  else
  {
    IndexFromName = BG_Gesture_GetIndexFromName(v3);
    if ( IndexFromName == 256 )
      Scr_Error(COM_ERR_4493, scrContext, "IsGesturePlaying() invalid gesture asset name.\n");
    IsPlaying = BG_Gesture_IsPlayingByIndex(p_ps, IndexFromName, NULL);
  }
  Scr_AddBool(scrContext, IsPlaying);
}

/*
==============
GScr_GetGestureViewmodel
==============
*/
void GScr_GetGestureViewmodel(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const playerState_s *p_ps; 
  unsigned int i; 
  const Gesture *CurrentAsset; 

  Entity = GetEntity(entref);
  if ( !Entity->client )
  {
    Scr_Error(COM_ERR_4494, scrContext, "self must be a player");
    if ( !Entity->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 18407, ASSERT_TYPE_ASSERT, "(player->client)", (const char *)&queryFormat, "player->client") )
      __debugbreak();
  }
  p_ps = &Entity->client->ps;
  Scr_MakeArray(scrContext);
  for ( i = 0; i < 2; ++i )
  {
    CurrentAsset = BG_Gesture_GetCurrentAsset(p_ps, i);
    if ( CurrentAsset )
    {
      if ( BG_Gesture_IsPlayingBySlot(p_ps, i, NULL) )
      {
        Scr_AddString(scrContext, CurrentAsset->name);
        Scr_AddArray(scrContext);
      }
    }
  }
}

/*
==============
GScr_GetGestureNotetrackTimes
==============
*/
void GScr_GetGestureNotetrackTimes(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *String; 
  const char *v5; 
  scr_string_t ConstString; 
  unsigned int IndexFromName; 
  const Gesture *AssetFromIndex; 
  int v9; 
  float *v10; 
  int outNumNotetracks; 
  float outTimes[10]; 

  Entity = GetEntity(entref);
  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    String = Scr_GetString(scrContext, 0);
    v5 = String;
    if ( String && *String )
    {
      ConstString = Scr_GetConstString(scrContext, 1u);
      if ( !ConstString && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 18465, ASSERT_TYPE_ASSERT, "(notetrack != ( static_cast< scr_string_t >( 0 ) ))", (const char *)&queryFormat, "notetrack != NULL_SCR_STRING") )
        __debugbreak();
      if ( !Entity->client )
      {
        Scr_Error(COM_ERR_4497, scrContext, "GScr_GetGestureNotetrackTimes() self must be a player");
        if ( !Entity->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 18474, ASSERT_TYPE_ASSERT, "(player->client)", (const char *)&queryFormat, "player->client") )
          __debugbreak();
      }
      IndexFromName = BG_Gesture_GetIndexFromName(v5);
      if ( IndexFromName == 256 )
        Scr_Error(COM_ERR_4498, scrContext, "GScr_GetGestureNotetrackTimes() invalid gesture asset name.\n");
      AssetFromIndex = BG_Gesture_GetAssetFromIndex(IndexFromName);
      if ( !AssetFromIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 18484, ASSERT_TYPE_ASSERT, "(gesture)", (const char *)&queryFormat, "gesture") )
        __debugbreak();
      BG_Gesture_GetNotetrackTimes(AssetFromIndex, ConstString, 10, outTimes, &outNumNotetracks);
      Scr_MakeArray(scrContext);
      v9 = 0;
      if ( outNumNotetracks > 0 )
      {
        v10 = outTimes;
        do
        {
          Scr_AddFloat(scrContext, *v10);
          Scr_AddArray(scrContext);
          ++v9;
          ++v10;
        }
        while ( v9 < outNumNotetracks );
      }
    }
    else
    {
      Scr_Error(COM_ERR_4496, scrContext, "GScr_GetGestureNotetrackTimes() missing gesture asset name");
    }
  }
  else
  {
    Scr_Error(COM_ERR_4495, scrContext, "GScr_GetGestureNotetrackTimes() wrong number of parameters");
  }
}

/*
==============
GScr_SetViewModelDepthOfField
==============
*/
void GScr_SetViewModelDepthOfField(scrContext_t *scrContext, scr_entref_t entref)
{
  Com_PrintWarning(24, "GScr_SetViewModelDepthOfField: Legacy DoF controls deprecated. Please update script to physical DoF controls!\n");
}

/*
==============
GScr_EnablePhysicalDepthOfFieldScripting
==============
*/
void GScr_EnablePhysicalDepthOfFieldScripting(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *PlayerEntity; 
  unsigned int NumParam; 
  unsigned int Int; 
  bool v6; 
  __int64 v7; 

  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam > 1 )
  {
    Scr_Error(COM_ERR_4502, scrContext, "Incorrect number of parameters\n");
    return;
  }
  if ( NumParam )
  {
    Int = Scr_GetInt(scrContext, 0);
    if ( Int != Scr_GetInt(scrContext, 0) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 18549, ASSERT_TYPE_ASSERT, "((int)dofPhysicalScriptingState == Scr_GetInt( scrContext, 0 ))", (const char *)&queryFormat, "(int)dofPhysicalScriptingState == Scr_GetInt( scrContext, 0 )") )
      __debugbreak();
    if ( !Int )
    {
      v6 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 18550, ASSERT_TYPE_ASSERT, "(dofPhysicalScriptingState != DOF_PHYSICAL_SCRIPTING_DISABLED)", (const char *)&queryFormat, "dofPhysicalScriptingState != DOF_PHYSICAL_SCRIPTING_DISABLED");
      goto LABEL_11;
    }
    if ( Int >= 4 )
    {
      LODWORD(v7) = Int;
      v6 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 18551, ASSERT_TYPE_ASSERT, "(unsigned)( dofPhysicalScriptingState ) < (unsigned)( DOF_PHYSICAL_SCRIPTING_COUNT )", "dofPhysicalScriptingState doesn't index DOF_PHYSICAL_SCRIPTING_COUNT\n\t%i not in [0, %i)", v7, 4);
LABEL_11:
      if ( v6 )
        __debugbreak();
    }
  }
  else
  {
    Int = 1;
  }
  PlayerEntity->client->ps.dofPhysicalScriptingState = Int;
}

/*
==============
GScr_DisablePhysicalDepthOfFieldScripting
==============
*/
void GScr_DisablePhysicalDepthOfFieldScripting(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *PlayerEntity; 
  gclient_s *client; 

  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  if ( Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_4503, scrContext, "Incorrect number of parameters\n");
  PlayerEntity->client->ps.dofPhysicalScriptingState = DOF_PHYSICAL_SCRIPTING_DISABLED;
  PlayerEntity->client->ps.dofPhysicalFstop = 22.0;
  PlayerEntity->client->ps.dofPhysicalFocusDistance = 29.301001;
  PlayerEntity->client->ps.dofPhysicalFocusSpeed = 1.0;
  PlayerEntity->client->ps.dofPhysicalApertureSpeed = 2.0;
  PlayerEntity->client->ps.dofPhysicalViewModelFstop = 22.0;
  PlayerEntity->client->ps.dofPhysicalViewModelFocusDistance = 29.301001;
  PlayerEntity->client->ps.dofPhysicalAdsStart = 29.301001;
  PlayerEntity->client->ps.dofPhysicalAdsEnd = 29.301001;
  client = PlayerEntity->client;
  *(_QWORD *)client->ps.dofPhysicalFocalPoint.v = 0i64;
  client->ps.dofPhysicalFocalPoint.v[2] = 0.0;
}

/*
==============
GScr_SetPhysicalDepthOfField
==============
*/
void GScr_SetPhysicalDepthOfField(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *PlayerEntity; 
  double Float; 
  float v5; 
  double v6; 
  float v7; 
  double v8; 
  float v9; 
  double v10; 
  float v11; 
  gclient_s *client; 
  vec3_t vectorValue; 

  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  if ( Scr_GetNumParam(scrContext) < 2 )
    Scr_Error(COM_ERR_4504, scrContext, "Incorrect number of parameters\n");
  Float = Scr_GetFloat(scrContext, 0);
  v5 = *(float *)&Float;
  v6 = Scr_GetFloat(scrContext, 1u);
  v7 = *(float *)&v6;
  if ( Scr_GetNumParam(scrContext) < 3 )
  {
    v9 = FLOAT_1_0;
  }
  else
  {
    v8 = Scr_GetFloat(scrContext, 2u);
    v9 = *(float *)&v8;
  }
  if ( Scr_GetNumParam(scrContext) < 4 )
  {
    v11 = FLOAT_2_0;
  }
  else
  {
    v10 = Scr_GetFloat(scrContext, 3u);
    v11 = *(float *)&v10;
  }
  if ( Scr_GetNumParam(scrContext) < 5 )
  {
    vectorValue.v[0] = 0.0;
    vectorValue.v[1] = 0.0;
    vectorValue.v[2] = 0.0;
  }
  else
  {
    Scr_GetVector(scrContext, 4u, &vectorValue);
  }
  if ( v5 < 0.125 || v5 > 30.0 )
    Scr_ParamError(COM_ERR_4505, scrContext, 0, "Invalid f-stop value");
  if ( v7 < 0.0 )
    Scr_ParamError(COM_ERR_4506, scrContext, 0, "Focus distance must be >= 0");
  if ( v9 < 0.0 )
    Scr_ParamError(COM_ERR_4507, scrContext, 0, "Focus speed must be >= 0");
  if ( v11 < 0.0 )
    Scr_ParamError(COM_ERR_4508, scrContext, 0, "Aperture speed must be >= 0");
  client = PlayerEntity->client;
  client->ps.dofPhysicalFocalPoint = vectorValue;
  client->ps.dofPhysicalFstop = v5;
  PlayerEntity->client->ps.dofPhysicalFocusDistance = v7;
  PlayerEntity->client->ps.dofPhysicalFocusSpeed = v9;
  PlayerEntity->client->ps.dofPhysicalApertureSpeed = v11;
}

/*
==============
GScr_SetPhysicalViewModelDepthOfField
==============
*/
void GScr_SetPhysicalViewModelDepthOfField(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *PlayerEntity; 
  double Float; 
  float v5; 
  double v6; 

  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_Error(COM_ERR_4509, scrContext, "Incorrect number of parameters\n");
  Float = Scr_GetFloat(scrContext, 0);
  v5 = *(float *)&Float;
  v6 = Scr_GetFloat(scrContext, 1u);
  if ( v5 < 0.125 || v5 > 30.0 )
    Scr_ParamError(COM_ERR_4510, scrContext, 0, "Invalid f-stop value");
  if ( *(float *)&v6 < 0.0 )
    Scr_ParamError(COM_ERR_4511, scrContext, 0, "Focus distance must be >= 0");
  PlayerEntity->client->ps.dofPhysicalViewModelFstop = v5;
  PlayerEntity->client->ps.dofPhysicalViewModelFocusDistance = *(float *)&v6;
}

/*
==============
GScr_SetAdsPhysicalDepthOfField
==============
*/
void GScr_SetAdsPhysicalDepthOfField(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *PlayerEntity; 
  double Float; 
  double v5; 

  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_Error(COM_ERR_4512, scrContext, "Incorrect number of parameters\n");
  Float = Scr_GetFloat(scrContext, 0);
  PlayerEntity->client->ps.dofPhysicalAdsStart = *(float *)&Float;
  v5 = Scr_GetFloat(scrContext, 1u);
  PlayerEntity->client->ps.dofPhysicalAdsEnd = *(float *)&v5;
}

/*
==============
GScr_SetLensProfileDistort
==============
*/
void GScr_SetLensProfileDistort(scrContext_t *scrContext, scr_entref_t entref)
{
  int v3; 
  gentity_s *PlayerEntity; 
  const char *String; 
  __int64 v6; 
  char v7; 
  __int64 v8; 
  char v9; 
  float v10; 
  double Float; 
  float v12; 
  double v13; 
  float v14; 
  double v15; 
  float v16; 
  double v17; 

  v3 = 0;
  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  if ( !Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_4513, scrContext, "Incorrect number of parameters\n");
  String = Scr_GetString(scrContext, 0);
  v6 = 0i64;
  while ( 1 )
  {
    v7 = String[v6++];
    if ( v7 != val[v6 - 1] )
      break;
    if ( v6 == 5 )
      goto LABEL_24;
  }
  if ( !strcmp_0(String, "compact portable") )
  {
    v3 = 1;
  }
  else if ( !strcmp_0(String, "smartphone") )
  {
    v3 = 2;
  }
  else if ( !strcmp_0(String, "cinematic prime") )
  {
    v3 = 3;
  }
  else if ( !strcmp_0(String, "action cam 1") )
  {
    v3 = 4;
  }
  else if ( !strcmp_0(String, "action cam 2") )
  {
    v3 = 5;
  }
  else
  {
    v8 = 0i64;
    while ( 1 )
    {
      v9 = String[v8++];
      if ( v9 != aDrone[v8 - 1] )
        break;
      if ( v8 == 6 )
      {
        v3 = 6;
        goto LABEL_24;
      }
    }
    if ( !strcmp_0(String, "telescopic") )
      v3 = 7;
    else
      Scr_Error(COM_ERR_4514, scrContext, "Unknown lens profile mode.\n");
  }
LABEL_24:
  v10 = 0.0;
  if ( Scr_GetNumParam(scrContext) < 2 )
  {
    v12 = 0.0;
  }
  else
  {
    Float = Scr_GetFloat(scrContext, 1u);
    v12 = *(float *)&Float;
  }
  if ( Scr_GetNumParam(scrContext) >= 3 )
  {
    v13 = Scr_GetFloat(scrContext, 2u);
    v10 = *(float *)&v13;
  }
  v14 = FLOAT_1_0;
  if ( Scr_GetNumParam(scrContext) < 4 )
  {
    v16 = FLOAT_1_0;
  }
  else
  {
    v15 = Scr_GetFloat(scrContext, 3u);
    v16 = *(float *)&v15;
  }
  if ( Scr_GetNumParam(scrContext) >= 5 )
  {
    v17 = Scr_GetFloat(scrContext, 4u);
    v14 = *(float *)&v17;
  }
  PlayerEntity->client->ps.lensProfileMode = v3;
  PlayerEntity->client->ps.lensProfileDistortFocalLength = v12;
  PlayerEntity->client->ps.lensProfileDistortAperture = v10;
  PlayerEntity->client->ps.lensProfileScale = v16;
  PlayerEntity->client->ps.lensProfileUVScale = v14;
}

/*
==============
GScr_ViewKick
==============
*/
void GScr_ViewKick(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *PlayerEntity; 
  int v4; 
  double Float; 
  const char *v6; 
  float *p_commandTime; 
  bool v8; 
  gclient_s *client; 
  vec3_t vectorValue; 

  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  if ( Scr_GetNumParam(scrContext) > 3 )
    Scr_Error(COM_ERR_4515, scrContext, "USAGE: <player> viewkick <force 0-127> <source position> [optional]<bool displayIndicator>\n");
  v4 = (PlayerEntity->maxHealth * Scr_GetInt(scrContext, 0) + 50) / 100;
  if ( v4 < 0 )
  {
    Float = Scr_GetFloat(scrContext, 0);
    v6 = j_va("viewkick: damage %g < 0\n", *(float *)&Float);
    Scr_Error(COM_ERR_4516, scrContext, v6);
  }
  Scr_GetVector(scrContext, 1u, &vectorValue);
  p_commandTime = (float *)&PlayerEntity->client->ps.commandTime;
  v8 = 1;
  p_commandTime[6050] = p_commandTime[12] - vectorValue.v[0];
  p_commandTime[6051] = p_commandTime[13] - vectorValue.v[1];
  p_commandTime[6052] = p_commandTime[14] - vectorValue.v[2];
  if ( Scr_GetNumParam(scrContext) > 2 )
    v8 = Scr_GetInt(scrContext, 2u) != 0;
  client = PlayerEntity->client;
  if ( v8 )
    client->damage_blood += v4;
  else
    client->damage_kick += v4;
}

/*
==============
GScr_OpenFile
==============
*/
void GScr_OpenFile(scrContext_t *scrContext)
{
  const char *String; 
  const char *v3; 
  fileHandle_t *openScriptIOFileHandles; 
  __int64 v5; 
  const char *v6; 
  int v7; 
  __int64 v8; 
  char v9; 
  const char *v10; 
  __int64 v11; 
  unsigned __int64 v12; 
  char *v13; 
  __int64 handle; 
  int v15; 
  __int64 v16; 
  char v17; 
  fileHandle_t *v18; 
  const char *v19; 
  fileHandle_t *v20; 
  char v21; 
  const char *v22; 
  fileHandle_t f; 

  if ( Scr_GetNumParam(scrContext) > 1 )
  {
    String = Scr_GetString(scrContext, 0);
    v3 = Scr_GetString(scrContext, 1u);
    openScriptIOFileHandles = level.openScriptIOFileHandles;
    v5 = 0i64;
    v6 = v3;
    v7 = 0;
    while ( openScriptIOFileHandles->handle.handle != -1 )
    {
      ++v7;
      if ( (__int64)++openScriptIOFileHandles >= (__int64)level.openScriptIOFileBuffers )
        goto LABEL_7;
    }
    if ( (level_locals_t *)((char *)&level + 8 * v7) == (level_locals_t *)-74864i64 )
    {
LABEL_7:
      Com_Printf(23, "OpenFile failed.  %i files already open\n", 1i64);
LABEL_25:
      v15 = -1;
      goto LABEL_26;
    }
    v8 = 0i64;
    do
    {
      v9 = v6[v8++];
      if ( v9 != aRead_1[v8 - 1] )
      {
        v16 = 0i64;
        while ( 1 )
        {
          v17 = v6[v16++];
          if ( v17 != aWrite_0[v16 - 1] )
            break;
          if ( v16 == 6 )
          {
            v18 = (fileHandle_t *)j_va("%s/%s", "scriptdata", String);
            v20 = FS_FOpenTextFileWrite(v18, v19);
            level.openScriptIOFileHandles[v7].handle.handle = (__int64)v20;
            if ( v20 == (fileHandle_t *)-1i64 )
              v7 = -1;
            v15 = v7;
            goto LABEL_26;
          }
        }
        do
        {
          v21 = v6[v5++];
          if ( v21 != aAppend[v5 - 1] )
          {
            Com_Printf(23, "Valid openfile modes are 'write', 'read', and 'append'\n", "write");
            goto LABEL_25;
          }
        }
        while ( v5 != 7 );
        v22 = j_va("%s/%s", "scriptdata", String);
        if ( FS_FOpenFileByMode(v22, &level.openScriptIOFileHandles[v7], FS_APPEND) < 0 )
          v7 = -1;
        v15 = v7;
        goto LABEL_26;
      }
    }
    while ( v8 != 5 );
    v10 = j_va("%s/%s", "scriptdata", String);
    v11 = FS_FOpenFileByMode(v10, &f, FS_READ);
    v12 = v11;
    if ( v11 < 0 )
      goto LABEL_25;
    v13 = (char *)Mem_Virtual_Alloc(v11 + 1, "GScr_OpenFile", TRACK_MISC);
    handle = f.handle.handle;
    level.openScriptIOFileBuffers[v7] = v13;
    FS_Read(v13, v12, (fileHandle_t)handle);
    FS_FCloseFile(f);
    level.openScriptIOFileBuffers[v7][v12] = 0;
    Com_BeginParseSession(String);
    Com_SetCSV(1);
    v15 = v7;
    level.currentScriptIOLineMark[v7].lines = 0;
LABEL_26:
    Scr_AddInt(scrContext, v15);
  }
}

/*
==============
GScr_CloseFile
==============
*/
void GScr_CloseFile(scrContext_t *scrContext)
{
  unsigned int Int; 
  fileHandle_t *v3; 
  void **v4; 
  void *v5; 
  int v6; 

  if ( Scr_GetNumParam(scrContext) )
  {
    Int = Scr_GetInt(scrContext, 0);
    if ( Int > 1 )
    {
      Com_Printf(23, "CloseFile failed, invalid file number %i\n", Int);
      Scr_AddInt(scrContext, -1);
      return;
    }
    v3 = &level.openScriptIOFileHandles[Int];
    v4 = (void **)&level.openScriptIOFileBuffers[Int];
    v5 = *v4;
    if ( v3->handle.handle == -1 )
    {
      if ( !v5 )
      {
        Com_Printf(23, "CloseFile failed, file number %i was not open\n", Int);
        v6 = -1;
        goto LABEL_11;
      }
      Com_EndParseSession();
      Mem_Virtual_Free(*v4);
      *v4 = NULL;
    }
    else
    {
      if ( v5 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 18995, ASSERT_TYPE_ASSERT, "(level.openScriptIOFileBuffers[filenum] == nullptr)", (const char *)&queryFormat, "level.openScriptIOFileBuffers[filenum] == nullptr") )
          __debugbreak();
      }
      FS_FCloseFile((fileHandle_t)v3->handle.handle);
      v3->handle.handle = -1i64;
    }
    v6 = 1;
LABEL_11:
    Scr_AddInt(scrContext, v6);
  }
}

/*
==============
GScr_FPrintln
==============
*/
void GScr_FPrintln(scrContext_t *scrContext)
{
  Scr_FPrint_internal(scrContext, 0);
}

/*
==============
GScr_FPrintFields
==============
*/
void GScr_FPrintFields(scrContext_t *scrContext)
{
  Scr_FPrint_internal(scrContext, 1);
}

/*
==============
GScr_FReadLn
==============
*/
void GScr_FReadLn(scrContext_t *scrContext)
{
  unsigned int Int; 
  com_parse_mark_t *v3; 
  int ArgCountOnLine; 
  char v5; 
  char *text; 

  if ( !Scr_GetNumParam(scrContext) )
  {
    Com_Printf(23, "freadln requires a parameter - the file to read from\n");
LABEL_11:
    ArgCountOnLine = -1;
    goto LABEL_12;
  }
  Int = Scr_GetInt(scrContext, 0);
  if ( Int > 1 )
  {
    Com_Printf(23, "freadln failed, invalid file number %i\n", Int);
    goto LABEL_11;
  }
  if ( !level.openScriptIOFileBuffers[Int] )
  {
    Com_Printf(23, "freadln failed, file number %i was not open for reading\n", Int);
    goto LABEL_11;
  }
  text = level.openScriptIOFileBuffers[Int];
  v3 = &level.currentScriptIOLineMark[Int];
  if ( v3->lines )
  {
    Com_ParseReturnToMark((const char **)&text, v3);
    Com_SkipRestOfLine((const char **)&text);
    Com_ParseSetMark((const char **)&text, v3);
    v5 = *Com_Parse((const char **)&text);
    Com_ParseReturnToMark((const char **)&text, v3);
    if ( !v5 )
      goto LABEL_11;
    ArgCountOnLine = Com_GetArgCountOnLine((const char **)&text);
  }
  else
  {
    Com_ParseSetMark((const char **)&text, v3);
    ArgCountOnLine = Com_GetArgCountOnLine((const char **)&text);
  }
LABEL_12:
  Scr_AddInt(scrContext, ArgCountOnLine);
}

/*
==============
GScr_FGetArg
==============
*/
void GScr_FGetArg(scrContext_t *scrContext)
{
  const char *v2; 
  __int64 Int; 
  int v4; 
  int v5; 
  const char *v6; 
  com_parse_mark_t *v7; 
  unsigned int v8; 
  char *text; 

  if ( Scr_GetNumParam(scrContext) > 1 )
  {
    Int = Scr_GetInt(scrContext, 0);
    v4 = Scr_GetInt(scrContext, 1u);
    v5 = v4;
    if ( (unsigned int)Int > 1 )
    {
      v6 = "freadline failed, invalid file number %i\n";
    }
    else
    {
      if ( v4 < 0 )
      {
        Com_Printf(23, "freadline failed, invalid argument number %i\n", (unsigned int)v4);
        goto LABEL_15;
      }
      if ( level.openScriptIOFileBuffers[Int] )
      {
        text = level.openScriptIOFileBuffers[Int];
        v7 = &level.currentScriptIOLineMark[Int];
        v2 = NULL;
        Com_ParseReturnToMark((const char **)&text, v7);
        v8 = 0;
        if ( v5 < 0 )
          goto LABEL_16;
        while ( 1 )
        {
          v2 = Com_ParseOnLine((const char **)&text);
          if ( !*v2 )
            break;
          if ( (int)++v8 > v5 )
            goto LABEL_16;
        }
        Com_Printf(23, "freadline failed, there aren't %i arguments on this line, there are only %i arguments\n", (unsigned int)(v5 + 1), v8);
LABEL_15:
        v2 = (char *)&queryFormat.fmt + 3;
        goto LABEL_16;
      }
      v6 = "freadline failed, file number %i was not open for reading\n";
    }
    Com_Printf(23, v6, (unsigned int)Int);
    goto LABEL_15;
  }
  Com_Printf(23, "freadline requires at least 2 parameters (file, string)\n");
  v2 = (char *)&queryFormat.fmt + 3;
LABEL_16:
  Scr_AddString(scrContext, v2);
}

/*
==============
GScr_SetMiniMap
==============
*/
void GScr_SetMiniMap(scrContext_t *scrContext)
{
  const char *v3; 
  unsigned int NumParam; 
  const char *String; 
  double Float; 
  float v7; 
  double v8; 
  float v9; 
  double v10; 
  float v11; 
  double v12; 
  float v13; 
  int Int; 
  float v15; 
  float v16; 
  float v17; 
  float v18; 
  float v19; 
  double v21; 
  double v22; 
  double v23; 
  double v24; 
  const char *v25; 
  float c; 
  float s; 
  char buffer[32]; 

  v3 = NULL;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam < 6 )
    Scr_Error(COM_ERR_4517, scrContext, "Expecting 6 arguments");
  String = Scr_GetString(scrContext, 0);
  Float = Scr_GetFloat(scrContext, 1u);
  v7 = *(float *)&Float;
  v8 = Scr_GetFloat(scrContext, 2u);
  v9 = *(float *)&v8;
  v10 = Scr_GetFloat(scrContext, 3u);
  v11 = *(float *)&v10;
  v12 = Scr_GetFloat(scrContext, 4u);
  v13 = *(float *)&v12;
  Int = Scr_GetInt(scrContext, 5u);
  if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_FREEFALL_RAISE|WEAPON_FIRING) )
  {
    if ( NumParam < 7 )
      v3 = String;
    else
      v3 = Scr_GetString(scrContext, 6u);
  }
  if ( Int < 1 )
    Scr_Error(COM_ERR_6130, scrContext, "numTiles should be >= 1");
  v15 = v11 - v7;
  v16 = *(float *)&v12 - v9;
  if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_STILL_LAND|0x80) )
  {
    v17 = (float)(v15 * level.compassNorth.v[1]) - (float)(v16 * level.compassNorth.v[0]);
    v18 = v15 * level.compassNorth.v[0];
    v19 = v16 * level.compassNorth.v[1];
  }
  else
  {
    SV_GetConfigstring(9u, buffer, 32);
    *(double *)&_XMM0 = atof(buffer);
    __asm { vcvtsd2ss xmm1, xmm0, xmm0 }
    FastSinCos(*(float *)&_XMM1 * 0.017453292, &s, &c);
    v17 = (float)(v15 * s) - (float)(v16 * c);
    v18 = v15 * c;
    v19 = v16 * s;
  }
  level.compassMapWorldSize.v[1] = COERCE_FLOAT(LODWORD(v18) ^ _xmm) - v19;
  level.compassMapWorldSize.v[0] = v17;
  if ( v17 < 0.0 || (float)(COERCE_FLOAT(LODWORD(v18) ^ _xmm) - v19) < 0.0 )
    Scr_Error(COM_ERR_4518, scrContext, "lower-right X and Y coordinates must be both south and east of upper-left X and Y coordinates in terms of the northyaw");
  level.compassMapUpperLeft.v[0] = v7;
  level.compassMapUpperLeft.v[1] = v9;
  v21 = v13;
  v22 = v11;
  v23 = v9;
  v24 = v7;
  if ( v3 )
    v25 = j_va("\"%s\" \"%s\" %f %f %f %f %d", String, v3, v24, v23, v22, v21, Int);
  else
    v25 = j_va("\"%s\" %f %f %f %f %d", String, v24, v23, v22, v21, Int);
  SV_SetConfigstring(0xAu, v25);
}

/*
==============
GScr_SetMiniMapCPRaidMaze
==============
*/
void GScr_SetMiniMapCPRaidMaze(scrContext_t *scrContext)
{
  const char *String; 
  double Float; 
  float v4; 
  double v5; 
  float v6; 
  double v7; 
  float v8; 
  double v9; 
  const char *v10; 

  if ( Scr_GetNumParam(scrContext) < 5 )
    Scr_Error(COM_ERR_6561, scrContext, "Expecting 5 arguments");
  String = Scr_GetString(scrContext, 0);
  Float = Scr_GetFloat(scrContext, 1u);
  v4 = *(float *)&Float;
  v5 = Scr_GetFloat(scrContext, 2u);
  v6 = *(float *)&v5;
  v7 = Scr_GetFloat(scrContext, 3u);
  v8 = *(float *)&v7;
  v9 = Scr_GetFloat(scrContext, 4u);
  v10 = j_va("\"%s\" %f %f %f %f", String, v4, v6, v8, *(float *)&v9);
  SV_SetConfigstring(0xFu, v10);
}

/*
==============
GScr_SetThermalBodyMaterial
==============
*/
void GScr_SetThermalBodyMaterial(scrContext_t *scrContext)
{
  const char *String; 

  String = Scr_GetString(scrContext, 0);
  SV_SetConfigstring(0xBu, String);
}

/*
==============
GScr_SetGlareGrimeMaterial
==============
*/
void GScr_SetGlareGrimeMaterial(scrContext_t *scrContext)
{
  Scr_Error(COM_ERR_4519, scrContext, "SetGlareGrimeMaterial is gen4 only (use is_gen4()).");
}

/*
==============
GScr_SortByDistance
==============
*/
void GScr_SortByDistance(scrContext_t *scrContext)
{
  unsigned int *m_ptr; 
  EntityOrigin *v3; 
  unsigned int ArrayObject; 
  unsigned int ArraySize; 
  __int64 v6; 
  const char *v7; 
  const char *NameForType; 
  const char *v9; 
  unsigned int v10; 
  unsigned int *p_obj; 
  vec3_t *p_origin; 
  const char *v13; 
  __int64 v14; 
  unsigned int *v15; 
  Mem_LargeLocal v16; 
  Mem_LargeLocal v17; 
  VariableType failureType; 
  unsigned int failureIndex; 

  Mem_LargeLocal::Mem_LargeLocal(&v17, 0x2000ui64, "scr_objectIdArray_t objects");
  m_ptr = (unsigned int *)v17.m_ptr;
  Mem_LargeLocal::Mem_LargeLocal(&v16, 0x8000ui64, "entityOriginArray_t entityOriginArray");
  v3 = (EntityOrigin *)v16.m_ptr;
  ArrayObject = BGScr_Main_GetArrayObject(scrContext, 0);
  ArraySize = GetArraySize(scrContext, ArrayObject);
  v6 = ArraySize;
  if ( ArraySize > 0x800 )
  {
    v7 = j_va("array is too large (%d > %d), need to increase sortable array size", ArraySize, 2048i64);
    Scr_ParamError(COM_ERR_4520, scrContext, 0, v7);
  }
  if ( !Scr_GetObjectArray(scrContext, ArrayObject, 0x800u, m_ptr, &failureIndex, &failureType) )
  {
    NameForType = Scr_GetNameForType(failureType);
    v9 = j_va("element %i of array: type %s is not an object", failureIndex, NameForType);
    Scr_ParamError(COM_ERR_4521, scrContext, 0, v9);
  }
  Scr_GetVector(scrContext, 1u, &g_entitySortOrigin);
  AddRefToObject(scrContext, ArrayObject);
  Scr_ClearOutParams(scrContext);
  v10 = 0;
  if ( (_DWORD)v6 )
  {
    p_obj = &v3->obj;
    p_origin = &v3->origin;
    do
    {
      if ( !Scr_GetObjectOrigin(scrContext, *m_ptr, p_origin) )
      {
        RemoveRefToObject(scrContext, ArrayObject);
        v13 = j_va("element %i of array: object's origin property is not a vector", v10);
        Scr_ParamError(COM_ERR_4522, scrContext, 0, v13);
      }
      *p_obj = *m_ptr;
      ++v10;
      p_origin = (vec3_t *)((char *)p_origin + 16);
      ++m_ptr;
      p_obj += 4;
    }
    while ( v10 < (unsigned int)v6 );
  }
  v14 = v6;
  std::_Sort_unchecked<EntityOrigin *,bool (*)(EntityOrigin const &,EntityOrigin const &)>(v3, &v3[v6], v6, CompareScriptObjectDistanceIncreasing);
  Scr_MakeArray(scrContext);
  if ( (_DWORD)v6 )
  {
    v15 = &v3->obj;
    do
    {
      Scr_AddObject(scrContext, *v15);
      Scr_AddArray(scrContext);
      v15 += 4;
      --v14;
    }
    while ( v14 );
  }
  RemoveRefToObject(scrContext, ArrayObject);
  Mem_LargeLocal::~Mem_LargeLocal(&v16);
  Mem_LargeLocal::~Mem_LargeLocal(&v17);
}

/*
==============
GScr_SortByDistanceCullByRadius
==============
*/
void GScr_SortByDistanceCullByRadius(scrContext_t *scrContext)
{
  unsigned int *m_ptr; 
  EntityOrigin *v3; 
  unsigned int ArrayObject; 
  unsigned int ArraySize; 
  unsigned int v6; 
  const char *v7; 
  const char *NameForType; 
  const char *v9; 
  double Float; 
  unsigned int v11; 
  unsigned int i; 
  EntityOrigin *v13; 
  const char *v14; 
  __int64 v15; 
  unsigned int *p_obj; 
  VariableType failureType[4]; 
  unsigned int failureIndex; 
  __int64 v19; 
  Mem_LargeLocal v20; 
  Mem_LargeLocal buffer; 

  v19 = -2i64;
  Mem_LargeLocal::Mem_LargeLocal(&buffer, 0x2000ui64, "scr_objectIdArray_t objects");
  m_ptr = (unsigned int *)buffer.m_ptr;
  Mem_LargeLocal::Mem_LargeLocal(&v20, 0x8000ui64, "entityOriginArray_t entityOriginArray");
  v3 = (EntityOrigin *)v20.m_ptr;
  ArrayObject = BGScr_Main_GetArrayObject(scrContext, 0);
  ArraySize = GetArraySize(scrContext, ArrayObject);
  v6 = ArraySize;
  if ( ArraySize > 0x800 )
  {
    v7 = j_va("array is too large (%d > %d), need to increase sortable array size", ArraySize, 2048i64);
    Scr_ParamError(COM_ERR_6306, scrContext, 0, v7);
  }
  if ( !Scr_GetObjectArray(scrContext, ArrayObject, 0x800u, m_ptr, &failureIndex, failureType) )
  {
    NameForType = Scr_GetNameForType(failureType[0]);
    v9 = j_va("element %i of array: type %s is not an object", failureIndex, NameForType);
    Scr_ParamError(COM_ERR_6307, scrContext, 0, v9);
  }
  Scr_GetVector(scrContext, 1u, &g_entitySortOrigin);
  Float = Scr_GetFloat(scrContext, 2u);
  AddRefToObject(scrContext, ArrayObject);
  Scr_ClearOutParams(scrContext);
  v11 = 0;
  for ( i = 0; i < v6; ++m_ptr )
  {
    v13 = &v3[v11];
    if ( !Scr_GetObjectOrigin(scrContext, *m_ptr, &v13->origin) )
    {
      RemoveRefToObject(scrContext, ArrayObject);
      v14 = j_va("element %i of array: object's origin property is not a vector", i);
      Scr_ParamError(COM_ERR_6308, scrContext, 0, v14);
    }
    if ( (float)((float)((float)((float)(g_entitySortOrigin.v[1] - v13->origin.v[1]) * (float)(g_entitySortOrigin.v[1] - v13->origin.v[1])) + (float)((float)(g_entitySortOrigin.v[0] - v13->origin.v[0]) * (float)(g_entitySortOrigin.v[0] - v13->origin.v[0]))) + (float)((float)(g_entitySortOrigin.v[2] - v13->origin.v[2]) * (float)(g_entitySortOrigin.v[2] - v13->origin.v[2]))) <= (float)(*(float *)&Float * *(float *)&Float) )
    {
      v13->obj = *m_ptr;
      ++v11;
    }
    ++i;
  }
  v15 = v11;
  std::_Sort_unchecked<EntityOrigin *,bool (*)(EntityOrigin const &,EntityOrigin const &)>(v3, &v3[v11], v11, CompareScriptObjectDistanceIncreasing);
  Scr_MakeArray(scrContext);
  if ( v11 )
  {
    p_obj = &v3->obj;
    do
    {
      Scr_AddObject(scrContext, *p_obj);
      Scr_AddArray(scrContext);
      p_obj += 4;
      --v15;
    }
    while ( v15 );
  }
  RemoveRefToObject(scrContext, ArrayObject);
  Mem_LargeLocal::~Mem_LargeLocal(&v20);
  Mem_LargeLocal::~Mem_LargeLocal(&buffer);
}

/*
==============
GScr_GetLightIntensity
==============
*/
void GScr_GetLightIntensity(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *v3; 

  v3 = GScr_SetupLightEntity(scrContext, entref);
  Scr_AddFloat(scrContext, v3->s.lerp.u.turret.gunAngles.v[2] * 0.0020268299);
}

/*
==============
GScr_SetLightIntensity
==============
*/
void GScr_SetLightIntensity(scrContext_t *scrContext, scr_entref_t entref)
{
  __int128 v2; 
  gentity_s *v4; 
  __int128 v6; 

  v4 = GScr_SetupLightEntity(scrContext, entref);
  *(double *)&v2 = Scr_GetFloat(scrContext, 0);
  if ( *(float *)&v2 < -0.001 )
    Scr_ParamError(COM_ERR_4524, scrContext, 0, "intensity must be >= 0");
  v6 = v2;
  *(float *)&v6 = *(float *)&v2 * 493.38132;
  _XMM1 = v6;
  __asm { vmaxss  xmm1, xmm1, xmm0 }
  v4->s.lerp.u.turret.gunAngles.v[2] = *(float *)&_XMM1;
}

/*
==============
GScr_GetLightUVIntensity
==============
*/
void GScr_GetLightUVIntensity(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *v3; 

  v3 = GScr_SetupLightEntity(scrContext, entref);
  Scr_AddFloat(scrContext, v3->s.lerp.u.actor.impactVector.v[0] * 0.0020268299);
}

/*
==============
GScr_SetLightUVIntensity
==============
*/
void GScr_SetLightUVIntensity(scrContext_t *scrContext, scr_entref_t entref)
{
  __int128 v2; 
  gentity_s *v4; 
  __int128 v6; 

  v4 = GScr_SetupLightEntity(scrContext, entref);
  *(double *)&v2 = Scr_GetFloat(scrContext, 0);
  if ( *(float *)&v2 < -0.001 )
    Scr_ParamError(COM_ERR_4525, scrContext, 0, "intensity must be >= 0");
  v6 = v2;
  *(float *)&v6 = *(float *)&v2 * 493.38132;
  _XMM1 = v6;
  __asm { vmaxss  xmm1, xmm1, xmm0 }
  v4->s.lerp.u.actor.impactVector.v[0] = *(float *)&_XMM1;
}

/*
==============
GScr_GetLightColor
==============
*/
void GScr_GetLightColor(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *v3; 
  float v4; 
  float v5; 
  float v6; 
  float value[4]; 
  LerpEntityStatePrimaryLightUnpacked out; 

  v3 = GScr_SetupLightEntity(scrContext, entref);
  LerpEntityStatePrimaryLightUnpack((const LerpEntityStatePrimaryLightPacked *)&v3->s.lerp.u, &out);
  if ( out.colorLinearSrgb.v[0] > 0.0031308001 )
    v4 = (float)(powf_0(out.colorLinearSrgb.v[0], 0.41666666) * 1.0549999) - 0.055;
  else
    v4 = out.colorLinearSrgb.v[0] * 12.92;
  value[0] = v4;
  if ( out.colorLinearSrgb.v[1] > 0.0031308001 )
    v5 = (float)(powf_0(out.colorLinearSrgb.v[1], 0.41666666) * 1.0549999) - 0.055;
  else
    v5 = out.colorLinearSrgb.v[1] * 12.92;
  value[1] = v5;
  if ( out.colorLinearSrgb.v[2] > 0.0031308001 )
    v6 = (float)(powf_0(out.colorLinearSrgb.v[2], 0.41666666) * 1.0549999) - 0.055;
  else
    v6 = out.colorLinearSrgb.v[2] * 12.92;
  value[2] = v6;
  Scr_AddVector(scrContext, value);
}

/*
==============
GScr_SetLightColor
==============
*/
void GScr_SetLightColor(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *v3; 
  float v4; 
  float v5; 
  float v6; 
  float v7; 
  vec3_t vectorValue; 
  LerpEntityStatePrimaryLightUnpacked out; 

  v3 = GScr_SetupLightEntity(scrContext, entref);
  Scr_GetVector(scrContext, 0, &vectorValue);
  if ( vectorValue.v[0] > 0.039280001 )
    v4 = powf_0((float)(vectorValue.v[0] * 0.94786733) + 0.052132703, 2.4000001);
  else
    v4 = vectorValue.v[0] * 0.077399381;
  vectorValue.v[0] = v4;
  if ( vectorValue.v[1] > 0.039280001 )
    v5 = powf_0((float)(vectorValue.v[1] * 0.94786733) + 0.052132703, 2.4000001);
  else
    v5 = vectorValue.v[1] * 0.077399381;
  vectorValue.v[1] = v5;
  if ( vectorValue.v[2] > 0.039280001 )
    v6 = powf_0((float)(vectorValue.v[2] * 0.94786733) + 0.052132703, 2.4000001);
  else
    v6 = vectorValue.v[2] * 0.077399381;
  v7 = (float)((float)(v4 * 0.21259999) + (float)(v5 * 0.71520001)) + (float)(v6 * 0.0722);
  vectorValue.v[2] = v6;
  if ( v7 > 0.0 )
  {
    vectorValue.v[0] = (float)(1.0 / v7) * v4;
    vectorValue.v[2] = (float)(1.0 / v7) * v6;
    vectorValue.v[1] = (float)(1.0 / v7) * v5;
  }
  LerpEntityStatePrimaryLightUnpack((const LerpEntityStatePrimaryLightPacked *)&v3->s.lerp.u, &out);
  out.colorLinearSrgb = vectorValue;
  LerpEntityStatePrimaryLightPack(&out, (LerpEntityStatePrimaryLightPacked *)&v3->s.lerp.u);
}

/*
==============
GScr_GetLightRadius
==============
*/
void GScr_GetLightRadius(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *v3; 

  v3 = GScr_SetupLightEntity(scrContext, entref);
  Scr_AddFloat(scrContext, v3->s.lerp.u.actor.impactVector.v[1]);
}

/*
==============
GScr_SetLightRadius
==============
*/
void GScr_SetLightRadius(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *v3; 
  signed int v4; 
  const ComPrimaryLight *PrimaryLight; 
  double Float; 
  double v7; 

  v3 = GScr_SetupLightEntity(scrContext, entref);
  v4 = comWorld.firstScriptablePrimaryLight + v3->s.staticState.general.xmodel;
  if ( (v4 < (int)comWorld.firstScriptablePrimaryLight || v4 >= (int)comWorld.primaryLightCount) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_bsp_api.h", 106, ASSERT_TYPE_ASSERT, "(primaryLightIndex >= static_cast<int>( comWorld.firstScriptablePrimaryLight ) && primaryLightIndex < static_cast<int>( comWorld.primaryLightCount ))", (const char *)&queryFormat, "primaryLightIndex >= static_cast<int>( comWorld.firstScriptablePrimaryLight ) && primaryLightIndex < static_cast<int>( comWorld.primaryLightCount )") )
    __debugbreak();
  PrimaryLight = Com_GetPrimaryLight(v4);
  if ( !PrimaryLight && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 19752, ASSERT_TYPE_ASSERT, "(refLight)", (const char *)&queryFormat, "refLight") )
    __debugbreak();
  if ( PrimaryLight->translationLimit == 0.0 && 1.0 == PrimaryLight->rotationLimit )
  {
    Scr_Error(COM_ERR_2199, scrContext, "SetLightRadius only works for lights with maxmove or maxturn KVP specified in Radiant\n");
  }
  else
  {
    Float = Scr_GetFloat(scrContext, 0);
    v7 = I_fclamp(*(float *)&Float, 1.01, PrimaryLight->radius);
    v3->s.lerp.u.actor.impactVector.v[1] = *(float *)&v7;
  }
}

/*
==============
GScr_GetLightFovInner
==============
*/
void GScr_GetLightFovInner(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *v3; 
  float v4; 
  LerpEntityStatePrimaryLightUnpacked out; 

  v3 = GScr_SetupLightEntity(scrContext, entref);
  LerpEntityStatePrimaryLightUnpack((const LerpEntityStatePrimaryLightPacked *)&v3->s.lerp.u, &out);
  v4 = acosf_0(out.cosHalfFovInner);
  Scr_AddFloat(scrContext, (float)(v4 * 57.295776) * 2.0);
}

/*
==============
GScr_GetLightFovOuter
==============
*/
void GScr_GetLightFovOuter(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *v3; 
  float v4; 
  LerpEntityStatePrimaryLightUnpacked out; 

  v3 = GScr_SetupLightEntity(scrContext, entref);
  LerpEntityStatePrimaryLightUnpack((const LerpEntityStatePrimaryLightPacked *)&v3->s.lerp.u, &out);
  v4 = acosf_0(out.cosHalfFovOuter);
  Scr_AddFloat(scrContext, (float)(v4 * 57.295776) * 2.0);
}

/*
==============
GScr_SetLightFovRange
==============
*/
void GScr_SetLightFovRange(scrContext_t *scrContext, scr_entref_t entref)
{
  __int128 v2; 
  __int128 v3; 
  __int128 v4; 
  gentity_s *v6; 
  signed int v7; 
  const ComPrimaryLight *PrimaryLight; 
  float v9; 
  __int128 v10; 
  __int128 v11; 
  float cosHalfFovOuter; 
  __int128 v13; 
  double Float; 
  float v15; 
  double v16; 
  __int128 v19; 
  LerpEntityStatePrimaryLightUnpacked out; 
  __int128 v21; 
  __int128 v22; 

  v6 = GScr_SetupLightEntity(scrContext, entref);
  v7 = comWorld.firstScriptablePrimaryLight + v6->s.staticState.general.xmodel;
  if ( (v7 < (int)comWorld.firstScriptablePrimaryLight || v7 >= (int)comWorld.primaryLightCount) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_bsp_api.h", 106, ASSERT_TYPE_ASSERT, "(primaryLightIndex >= static_cast<int>( comWorld.firstScriptablePrimaryLight ) && primaryLightIndex < static_cast<int>( comWorld.primaryLightCount ))", (const char *)&queryFormat, "primaryLightIndex >= static_cast<int>( comWorld.firstScriptablePrimaryLight ) && primaryLightIndex < static_cast<int>( comWorld.primaryLightCount )") )
    __debugbreak();
  PrimaryLight = Com_GetPrimaryLight(v7);
  if ( !PrimaryLight && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 19837, ASSERT_TYPE_ASSERT, "(refLight)", (const char *)&queryFormat, "refLight") )
    __debugbreak();
  if ( PrimaryLight->translationLimit == 0.0 && 1.0 == PrimaryLight->rotationLimit )
  {
    Scr_Error(COM_ERR_2201, scrContext, "SetLightFovRange only works for lights with maxmove or maxturn KVP specified in Radiant\n");
  }
  else
  {
    v22 = v3;
    *(double *)&v2 = Scr_GetFloat(scrContext, 0);
    v9 = *(float *)&v2;
    if ( *(float *)&v2 < 0.99900001 || *(float *)&v2 >= 120.001 )
      Scr_ParamError(COM_ERR_2202, scrContext, 0, "outer fov must be in the range of 1 to 120");
    v10 = v2;
    *(float *)&v10 = *(float *)&v2 * 0.0087266462;
    v11 = v10;
    *(float *)&v11 = cosf_0(v9 * 0.0087266462);
    cosHalfFovOuter = PrimaryLight->cosHalfFovOuter;
    v13 = v11;
    if ( *(float *)&v11 < (float)(cosHalfFovOuter - 0.001) )
    {
      Scr_ParamError(COM_ERR_2203, scrContext, 0, "outer fov cannot be larger than the fov when the map was compiled");
      cosHalfFovOuter = PrimaryLight->cosHalfFovOuter;
    }
    I_fclamp(*(float *)&v11, cosHalfFovOuter, 1.0);
    if ( Scr_GetNumParam(scrContext) == 2 )
    {
      v21 = v4;
      Float = Scr_GetFloat(scrContext, 1u);
      if ( *(float *)&Float < -0.001 || *(float *)&Float >= (float)(v9 + 0.001) )
        Scr_ParamError(COM_ERR_2204, scrContext, 1u, "inner fov must be in the range of 0 to outer fov");
      v15 = cosf_0(*(float *)&Float * 0.0087266462);
      v16 = I_fclamp(v15, *(float *)&v13 + 0.001, 1.0);
      LODWORD(_XMM6) = LODWORD(v16);
    }
    else
    {
      v19 = v13;
      *(float *)&v19 = *(float *)&v13 + 0.001;
      _XMM0 = v19;
      __asm { vminss  xmm6, xmm0, dword ptr [rbx+70h] }
    }
    LerpEntityStatePrimaryLightUnpack((const LerpEntityStatePrimaryLightPacked *)&v6->s.lerp.u, &out);
    if ( (*(float *)&v13 <= 0.0 || *(float *)&v13 >= *(float *)&_XMM6 || *(float *)&_XMM6 > 1.0) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 19869, ASSERT_TYPE_ASSERT, "(0.0f < cosHalfFovOuter && cosHalfFovOuter < cosHalfFovInner && cosHalfFovInner <= 1.0f)", "%s\n\t%g, %g", "0.0f < cosHalfFovOuter && cosHalfFovOuter < cosHalfFovInner && cosHalfFovInner <= 1.0f", *(float *)&v13, *(float *)&_XMM6) )
      __debugbreak();
    out.cosHalfFovInner = *(float *)&_XMM6;
    out.cosHalfFovOuter = *(float *)&v13;
    LerpEntityStatePrimaryLightPack(&out, (LerpEntityStatePrimaryLightPacked *)&v6->s.lerp.u);
  }
}

/*
==============
GScr_IsScriptable
==============
*/
void GScr_IsScriptable(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  unsigned int ScriptableIndexForEntity; 

  Entity = GetEntity(entref);
  ScriptableIndexForEntity = ScriptableSv_GetScriptableIndexForEntity(Entity);
  Scr_AddInt(scrContext, ScriptableIndexForEntity != -1);
}

/*
==============
GScr_IsRagdoll
==============
*/
void GScr_IsRagdoll(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  trajectory_t_secure *p_pos; 

  Entity = GetEntity(entref);
  p_pos = &Entity->s.lerp.pos;
  if ( Entity == (gentity_s *)-16i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\q_shared.h", 2263, ASSERT_TYPE_ASSERT, "(trajectory)", (const char *)&queryFormat, "trajectory") )
    __debugbreak();
  Scr_AddInt(scrContext, (unsigned int)(p_pos->trType - 23) <= 5);
}

/*
==============
Scr_GetWeaponArray
==============
*/
void Scr_GetWeaponArray(scrContext_t *scrContext)
{
  EntHandle *droppedWeaponCue; 
  __int64 v3; 
  unsigned __int16 number; 
  __int64 v5; 
  unsigned int v6; 
  __int64 v7; 
  unsigned __int16 v8; 
  __int64 v9; 
  __int64 v10; 
  EntHandle *droppedEquipmentCue; 
  __int64 v12; 
  unsigned __int16 v13; 
  __int64 v14; 
  unsigned int v15; 
  __int64 v16; 
  unsigned __int16 v17; 
  __int64 v18; 
  __int64 v19; 
  __int64 v20; 
  __int64 v21; 

  Scr_MakeArray(scrContext);
  droppedWeaponCue = level.droppedWeaponCue;
  v3 = 32i64;
  do
  {
    number = droppedWeaponCue->number;
    if ( droppedWeaponCue->number )
    {
      v5 = number;
      v6 = number - 1;
      if ( v6 >= 0x800 )
      {
        LODWORD(v21) = 2048;
        LODWORD(v20) = v6;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v20, v21) )
          __debugbreak();
      }
      if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
        __debugbreak();
      v7 = v5 - 1;
      if ( g_entities[v7].r.isInUse != g_entityIsInUse[v7] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
        __debugbreak();
      if ( !g_entityIsInUse[v7] )
      {
        LODWORD(v21) = droppedWeaponCue->number - 1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 216, ASSERT_TYPE_ASSERT, "( ( !number || G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( !number || G_IsEntityInUse( number - 1 ) )", v21) )
          __debugbreak();
      }
      v8 = droppedWeaponCue->number;
      if ( droppedWeaponCue->number )
      {
        if ( (unsigned int)v8 - 1 >= 0x7FF )
        {
          LODWORD(v21) = 2047;
          LODWORD(v20) = v8 - 1;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 223, ASSERT_TYPE_ASSERT, "(unsigned)( number - 1 ) < (unsigned)( ENTITYNUM_NONE )", "number - 1 doesn't index ENTITYNUM_NONE\n\t%i not in [0, %i)", v20, v21) )
            __debugbreak();
        }
        v9 = droppedWeaponCue->number;
        if ( (unsigned int)(v9 - 1) >= 0x800 )
        {
          LODWORD(v21) = 2048;
          LODWORD(v20) = v9 - 1;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v20, v21) )
            __debugbreak();
        }
        if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
          __debugbreak();
        v10 = v9 - 1;
        if ( g_entities[v10].r.isInUse != g_entityIsInUse[v10] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
          __debugbreak();
        if ( !g_entityIsInUse[v10] )
        {
          LODWORD(v21) = droppedWeaponCue->number - 1;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 224, ASSERT_TYPE_ASSERT, "( ( G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( G_IsEntityInUse( number - 1 ) )", v21) )
            __debugbreak();
        }
        GScr_AddEntity(&g_entities[droppedWeaponCue->number - 1]);
        Scr_AddArray(scrContext);
      }
    }
    ++droppedWeaponCue;
    --v3;
  }
  while ( v3 );
  droppedEquipmentCue = level.droppedEquipmentCue;
  v12 = 8i64;
  do
  {
    v13 = droppedEquipmentCue->number;
    if ( droppedEquipmentCue->number )
    {
      v14 = v13;
      v15 = v13 - 1;
      if ( v15 >= 0x800 )
      {
        LODWORD(v21) = 2048;
        LODWORD(v20) = v15;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v20, v21) )
          __debugbreak();
      }
      if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
        __debugbreak();
      v16 = v14 - 1;
      if ( g_entities[v16].r.isInUse != g_entityIsInUse[v16] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
        __debugbreak();
      if ( !g_entityIsInUse[v16] )
      {
        LODWORD(v21) = droppedEquipmentCue->number - 1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 216, ASSERT_TYPE_ASSERT, "( ( !number || G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( !number || G_IsEntityInUse( number - 1 ) )", v21) )
          __debugbreak();
      }
      v17 = droppedEquipmentCue->number;
      if ( droppedEquipmentCue->number )
      {
        if ( (unsigned int)v17 - 1 >= 0x7FF )
        {
          LODWORD(v21) = 2047;
          LODWORD(v20) = v17 - 1;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 223, ASSERT_TYPE_ASSERT, "(unsigned)( number - 1 ) < (unsigned)( ENTITYNUM_NONE )", "number - 1 doesn't index ENTITYNUM_NONE\n\t%i not in [0, %i)", v20, v21) )
            __debugbreak();
        }
        v18 = droppedEquipmentCue->number;
        if ( (unsigned int)(v18 - 1) >= 0x800 )
        {
          LODWORD(v21) = 2048;
          LODWORD(v20) = v18 - 1;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v20, v21) )
            __debugbreak();
        }
        if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
          __debugbreak();
        v19 = v18 - 1;
        if ( g_entities[v19].r.isInUse != g_entityIsInUse[v19] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
          __debugbreak();
        if ( !g_entityIsInUse[v19] )
        {
          LODWORD(v21) = droppedEquipmentCue->number - 1;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 224, ASSERT_TYPE_ASSERT, "( ( G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( G_IsEntityInUse( number - 1 ) )", v21) )
            __debugbreak();
        }
        GScr_AddEntity(&g_entities[droppedEquipmentCue->number - 1]);
        Scr_AddArray(scrContext);
      }
    }
    ++droppedEquipmentCue;
    --v12;
  }
  while ( v12 );
}

/*
==============
Scr_GetWeaponArrayInRadius
==============
*/
void Scr_GetWeaponArrayInRadius(scrContext_t *scrContext)
{
  double Float; 
  float v3; 
  EntHandle *droppedWeaponCue; 
  __int64 v5; 
  unsigned __int16 number; 
  __int64 v7; 
  unsigned int v8; 
  __int64 v9; 
  unsigned __int16 v10; 
  __int64 v11; 
  __int64 v12; 
  __int64 v13; 
  float v14; 
  float v15; 
  float v16; 
  __int64 v17; 
  __int64 v18; 
  EntHandle *droppedEquipmentCue; 
  __int64 v20; 
  unsigned __int16 v21; 
  __int64 v22; 
  unsigned int v23; 
  __int64 v24; 
  unsigned __int16 v25; 
  __int64 v26; 
  __int64 v27; 
  __int64 v28; 
  float v29; 
  float v30; 
  float v31; 
  __int64 v32; 
  __int64 v33; 
  __int64 v34; 
  __int64 v35; 
  vec3_t vectorValue; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  Float = Scr_GetFloat(scrContext, 1u);
  v3 = *(float *)&Float * *(float *)&Float;
  Scr_MakeArray(scrContext);
  droppedWeaponCue = level.droppedWeaponCue;
  v5 = 32i64;
  do
  {
    number = droppedWeaponCue->number;
    if ( droppedWeaponCue->number )
    {
      v7 = number;
      v8 = number - 1;
      if ( v8 >= 0x800 )
      {
        LODWORD(v35) = 2048;
        LODWORD(v34) = v8;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v34, v35) )
          __debugbreak();
      }
      if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
        __debugbreak();
      v9 = v7 - 1;
      if ( g_entities[v9].r.isInUse != g_entityIsInUse[v9] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
        __debugbreak();
      if ( !g_entityIsInUse[v9] )
      {
        LODWORD(v35) = droppedWeaponCue->number - 1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 216, ASSERT_TYPE_ASSERT, "( ( !number || G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( !number || G_IsEntityInUse( number - 1 ) )", v35) )
          __debugbreak();
      }
      v10 = droppedWeaponCue->number;
      if ( droppedWeaponCue->number )
      {
        if ( (unsigned int)v10 - 1 >= 0x7FF )
        {
          LODWORD(v35) = 2047;
          LODWORD(v34) = v10 - 1;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 223, ASSERT_TYPE_ASSERT, "(unsigned)( number - 1 ) < (unsigned)( ENTITYNUM_NONE )", "number - 1 doesn't index ENTITYNUM_NONE\n\t%i not in [0, %i)", v34, v35) )
            __debugbreak();
        }
        v11 = droppedWeaponCue->number;
        if ( (unsigned int)(v11 - 1) >= 0x800 )
        {
          LODWORD(v35) = 2048;
          LODWORD(v34) = v11 - 1;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v34, v35) )
            __debugbreak();
        }
        if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
          __debugbreak();
        v12 = v11 - 1;
        if ( g_entities[v12].r.isInUse != g_entityIsInUse[v12] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
          __debugbreak();
        if ( !g_entityIsInUse[v12] )
        {
          LODWORD(v35) = droppedWeaponCue->number - 1;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 224, ASSERT_TYPE_ASSERT, "( ( G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( G_IsEntityInUse( number - 1 ) )", v35) )
            __debugbreak();
        }
        v13 = droppedWeaponCue->number;
        v14 = vectorValue.v[0] - g_entities[v13 - 1].r.currentOrigin.v[0];
        v15 = vectorValue.v[1] - g_entities[v13 - 1].r.currentOrigin.v[1];
        v16 = vectorValue.v[2] - g_entities[v13 - 1].r.currentOrigin.v[2];
        if ( (float)((float)((float)(v15 * v15) + (float)(v14 * v14)) + (float)(v16 * v16)) <= v3 )
        {
          if ( (unsigned int)(v13 - 1) >= 0x7FF )
          {
            LODWORD(v35) = 2047;
            LODWORD(v34) = v13 - 1;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 223, ASSERT_TYPE_ASSERT, "(unsigned)( number - 1 ) < (unsigned)( ENTITYNUM_NONE )", "number - 1 doesn't index ENTITYNUM_NONE\n\t%i not in [0, %i)", v34, v35) )
              __debugbreak();
          }
          v17 = droppedWeaponCue->number;
          if ( (unsigned int)(v17 - 1) >= 0x800 )
          {
            LODWORD(v35) = 2048;
            LODWORD(v34) = v17 - 1;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v34, v35) )
              __debugbreak();
          }
          if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
            __debugbreak();
          v18 = v17 - 1;
          if ( g_entities[v18].r.isInUse != g_entityIsInUse[v18] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
            __debugbreak();
          if ( !g_entityIsInUse[v18] )
          {
            LODWORD(v35) = droppedWeaponCue->number - 1;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 224, ASSERT_TYPE_ASSERT, "( ( G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( G_IsEntityInUse( number - 1 ) )", v35) )
              __debugbreak();
          }
          GScr_AddEntity(&g_entities[droppedWeaponCue->number - 1]);
          Scr_AddArray(scrContext);
        }
      }
    }
    ++droppedWeaponCue;
    --v5;
  }
  while ( v5 );
  droppedEquipmentCue = level.droppedEquipmentCue;
  v20 = 8i64;
  do
  {
    v21 = droppedEquipmentCue->number;
    if ( droppedEquipmentCue->number )
    {
      v22 = v21;
      v23 = v21 - 1;
      if ( v23 >= 0x800 )
      {
        LODWORD(v35) = 2048;
        LODWORD(v34) = v23;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v34, v35) )
          __debugbreak();
      }
      if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
        __debugbreak();
      v24 = v22 - 1;
      if ( g_entities[v24].r.isInUse != g_entityIsInUse[v24] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
        __debugbreak();
      if ( !g_entityIsInUse[v24] )
      {
        LODWORD(v35) = droppedEquipmentCue->number - 1;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 216, ASSERT_TYPE_ASSERT, "( ( !number || G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( !number || G_IsEntityInUse( number - 1 ) )", v35) )
          __debugbreak();
      }
      v25 = droppedEquipmentCue->number;
      if ( droppedEquipmentCue->number )
      {
        if ( (unsigned int)v25 - 1 >= 0x7FF )
        {
          LODWORD(v35) = 2047;
          LODWORD(v34) = v25 - 1;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 223, ASSERT_TYPE_ASSERT, "(unsigned)( number - 1 ) < (unsigned)( ENTITYNUM_NONE )", "number - 1 doesn't index ENTITYNUM_NONE\n\t%i not in [0, %i)", v34, v35) )
            __debugbreak();
        }
        v26 = droppedEquipmentCue->number;
        if ( (unsigned int)(v26 - 1) >= 0x800 )
        {
          LODWORD(v35) = 2048;
          LODWORD(v34) = v26 - 1;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v34, v35) )
            __debugbreak();
        }
        if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
          __debugbreak();
        v27 = v26 - 1;
        if ( g_entities[v27].r.isInUse != g_entityIsInUse[v27] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
          __debugbreak();
        if ( !g_entityIsInUse[v27] )
        {
          LODWORD(v35) = droppedEquipmentCue->number - 1;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 224, ASSERT_TYPE_ASSERT, "( ( G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( G_IsEntityInUse( number - 1 ) )", v35) )
            __debugbreak();
        }
        v28 = droppedEquipmentCue->number;
        v29 = vectorValue.v[0] - g_entities[v28 - 1].r.currentOrigin.v[0];
        v30 = vectorValue.v[1] - g_entities[v28 - 1].r.currentOrigin.v[1];
        v31 = vectorValue.v[2] - g_entities[v28 - 1].r.currentOrigin.v[2];
        if ( (float)((float)((float)(v30 * v30) + (float)(v29 * v29)) + (float)(v31 * v31)) <= v3 )
        {
          if ( (unsigned int)(v28 - 1) >= 0x7FF )
          {
            LODWORD(v35) = 2047;
            LODWORD(v34) = v28 - 1;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 223, ASSERT_TYPE_ASSERT, "(unsigned)( number - 1 ) < (unsigned)( ENTITYNUM_NONE )", "number - 1 doesn't index ENTITYNUM_NONE\n\t%i not in [0, %i)", v34, v35) )
              __debugbreak();
          }
          v32 = droppedEquipmentCue->number;
          if ( (unsigned int)(v32 - 1) >= 0x800 )
          {
            LODWORD(v35) = 2048;
            LODWORD(v34) = v32 - 1;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v34, v35) )
              __debugbreak();
          }
          if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
            __debugbreak();
          v33 = v32 - 1;
          if ( g_entities[v33].r.isInUse != g_entityIsInUse[v33] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
            __debugbreak();
          if ( !g_entityIsInUse[v33] )
          {
            LODWORD(v35) = droppedEquipmentCue->number - 1;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 224, ASSERT_TYPE_ASSERT, "( ( G_IsEntityInUse( number - 1 ) ) )", "%s\n\t( number - 1 ) = %i", "( G_IsEntityInUse( number - 1 ) )", v35) )
              __debugbreak();
          }
          GScr_AddEntity(&g_entities[droppedEquipmentCue->number - 1]);
          Scr_AddArray(scrContext);
        }
      }
    }
    ++droppedEquipmentCue;
    --v20;
  }
  while ( v20 );
}

/*
==============
GScr_CameraLinkTo
==============
*/
void GScr_CameraLinkTo(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *PlayerEntity; 
  gentity_s *Entity; 
  playerState_s *p_ps; 
  __int16 *p_number; 
  const char *String; 
  unsigned int v8; 
  const char *v9; 
  bool v10; 
  bool v11; 

  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  Entity = GScr_GetEntity(0);
  p_ps = &PlayerEntity->client->ps;
  p_number = &Entity->s.number;
  String = Scr_GetString(scrContext, 1u);
  if ( !GConfigStrings::ms_gConfigStrings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_configstrings.h", 71, ASSERT_TYPE_ASSERT, "( ms_gConfigStrings )", (const char *)&queryFormat, "ms_gConfigStrings") )
    __debugbreak();
  v8 = GConfigStrings::ms_gConfigStrings->GetClientTagIndex(GConfigStrings::ms_gConfigStrings, String);
  if ( !v8 )
  {
    v9 = j_va("Can't find/allocate ID for tag '%s'", String);
    Scr_ParamError(COM_ERR_4531, scrContext, 1u, v9);
  }
  v10 = 0;
  if ( Scr_GetNumParam(scrContext) > 2 )
    v10 = Scr_GetInt(scrContext, 2u) != 0;
  v11 = 0;
  if ( Scr_GetNumParam(scrContext) > 3 )
    v11 = Scr_GetInt(scrContext, 3u) != 0;
  GScr_RemoteEyesSet_Internal(p_ps, *p_number, v10, v11);
  p_ps->remoteEyesTagname = v8;
}

/*
==============
GScr_CameraUnlink
==============
*/
void GScr_CameraUnlink(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *PlayerEntity; 

  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  GScr_RemoteEyesClear_Internal(&PlayerEntity->client->ps);
}

/*
==============
GScrCmd_SetWaterSheeting
==============
*/
void GScrCmd_SetWaterSheeting(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  int number; 
  const char *v6; 
  const char *v7; 
  unsigned int Int; 
  double Float; 
  __int64 v10; 
  const char *v11; 
  const char *v12; 
  SvClient *CommonClient; 
  int outControllingClientNum; 

  entnum = entref.entnum;
  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 20186, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( ((Entity->s.eType - 1) & 0xFFEF) != 0 )
    Scr_Error(COM_ERR_4532, scrContext, "SetWaterSheeting called on an ent that's not a player or agent.");
  number = Entity->s.number;
  outControllingClientNum = number;
  if ( !SV_IsAgent(number) || SV_GetAgentControlledByPlayerNum(outControllingClientNum, &outControllingClientNum) )
  {
    if ( outControllingClientNum < level.maxclients )
    {
      Int = Scr_GetInt(scrContext, 0);
      if ( Scr_GetNumParam(scrContext) == 2 )
      {
        Float = Scr_GetFloat(scrContext, 1u);
        v10 = (unsigned int)(int)(float)(*(float *)&Float * 1000.0);
      }
      else
      {
        v10 = 0i64;
      }
      v11 = j_va("%c %i %i", 80i64, Int, v10);
      v12 = v11;
      if ( outControllingClientNum == -1 )
      {
        SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v11);
      }
      else
      {
        CommonClient = SvClient::GetCommonClient(outControllingClientNum);
        CommonClient->SendServerCommand(CommonClient, SV_CMD_RELIABLE, v12);
      }
    }
    else
    {
      v7 = j_va("Invalid entity index %d before SV_Game_SendServerCommand\n", (unsigned int)outControllingClientNum);
      Scr_Error(COM_ERR_6407, scrContext, v7);
    }
  }
  else
  {
    v6 = j_va("entity %i is not a player or player-controlled agent", entnum);
    Scr_ObjectError(COM_ERR_4533, scrContext, v6);
  }
}

/*
==============
GScr_ControlsLinkTo
==============
*/
void GScr_ControlsLinkTo(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *PlayerEntity; 
  gclient_s *client; 
  gentity_s *Entity; 
  gentity_s *v6; 
  Vehicle *vehicle; 
  bool v8; 
  entityType_s eType; 

  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  client = PlayerEntity->client;
  Entity = GScr_GetEntity(0);
  v6 = Entity;
  v8 = 0;
  if ( Entity->s.eType == ET_VEHICLE )
  {
    vehicle = Entity->vehicle;
    if ( vehicle )
    {
      if ( vehicle->drivingState == VEH_DRIVE_NONE )
        v8 = 1;
    }
  }
  if ( GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&client->ps.pm_flags, ACTIVE, 0x1Cu) && !v8 )
    Scr_Error(COM_ERR_4534, scrContext, "Player's controls are already linked.");
  GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::SetFlagInternal(&client->ps.pm_flags, ACTIVE, 0x1Cu);
  client->ps.remoteControlEnt = v6->s.number;
  EntHandle::setEnt(&v6->remoteControlledOwner, PlayerEntity);
  eType = v6->s.eType;
  if ( eType == ET_MISSILE )
  {
    v6->c.missile.flags |= 0x80u;
  }
  else if ( ((eType - 12) & 0xFFFD) == 0 && Com_GameMode_SupportsFeature(WEAPON_ANIM_SCRIPTED) )
  {
    G_Vehicle_PlayerRemoteControl(v6, PlayerEntity);
  }
}

/*
==============
GScr_RemoteControlTurret
==============
*/
void GScr_RemoteControlTurret(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  gentity_s *Entity; 
  gentity_s *v7; 
  const char *v8; 
  const char *v9; 
  bool v10; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 20284, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  if ( !Com_GameMode_SupportsFeature(WEAPON_DROPPING_LADDER_CLIMB) )
    Scr_Error(COM_ERR_4535, scrContext, "Remote turret control is not supported in this game mode");
  Entity = GScr_GetEntity(0);
  v7 = Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v8 = SL_ConvertToString(Entity->classname);
    v9 = j_va("entity type '%s' is not a turret", v8);
    Scr_Error(COM_ERR_4536, scrContext, v9);
  }
  v10 = G_Turret_ScrRemoteUse(scrContext, v7, v4);
  Scr_AddBool(scrContext, v10);
}

/*
==============
GScr_RemoteControlTurretOff
==============
*/
void GScr_RemoteControlTurretOff(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  gentity_s *Entity; 
  gentity_s *v7; 
  const char *v8; 
  const char *v9; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 20313, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  if ( !Com_GameMode_SupportsFeature(WEAPON_DROPPING_LADDER_CLIMB) )
    Scr_Error(COM_ERR_4537, scrContext, "Remote turret control is not supported in this game mode");
  Entity = GScr_GetEntity(0);
  v7 = Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v8 = SL_ConvertToString(Entity->classname);
    v9 = j_va("entity type '%s' is not a turret", v8);
    Scr_Error(COM_ERR_4538, scrContext, v9);
  }
  G_Turret_ScrStopRemoteUse(v7, v4);
}

/*
==============
ScrCmd_SetEntityOwner
==============
*/
void ScrCmd_SetEntityOwner(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 

  Entity = GetEntity(entref);
  if ( Entity->client )
  {
    Scr_Error(COM_ERR_4539, scrContext, "SetEntityOwner() cannot be called on a client");
  }
  else if ( Scr_GetType(scrContext, 0) )
  {
    v4 = GScr_GetEntity(0);
    EntHandle::setEnt(&Entity->r.ownerNum, v4);
    if ( BG_IsVehicleEntity(&Entity->s) && v4->s.eType == ET_PLAYER )
      G_Vehicle_HandleOwnerChange(Entity, v4);
  }
  else
  {
    if ( BG_IsVehicleEntity(&Entity->s) )
      G_Vehicle_HandleOwnerChange(Entity, NULL);
    EntHandle::setEnt(&Entity->r.ownerNum, NULL);
  }
}

/*
==============
GScr_ControlsUnlink
==============
*/
void GScr_ControlsUnlink(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *PlayerEntity; 
  gclient_s *client; 
  bool v5; 
  __int64 remoteControlEnt; 
  gentity_s *v7; 
  entityType_s eType; 

  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  client = PlayerEntity->client;
  if ( client->sess.sessionState == SESS_STATE_SPECTATOR )
  {
    Com_PrintWarning(23, "WARNING: ControlsUnlink() called on a player who is currently spectating (spectator mode or in killcam).\n");
  }
  else if ( GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&client->ps.pm_flags, ACTIVE, 0x1Cu) )
  {
    v5 = 1;
    if ( Scr_GetNumParam(scrContext) )
      v5 = Scr_GetInt(scrContext, 0) != 0;
    if ( client->ps.remoteControlEnt >= 0x800u && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 20410, ASSERT_TYPE_ASSERT, "((unsigned)ps->remoteControlEnt < ( 2048 ))", (const char *)&queryFormat, "(unsigned)ps->remoteControlEnt < MAX_GENTITIES") )
      __debugbreak();
    remoteControlEnt = client->ps.remoteControlEnt;
    v7 = &g_entities[remoteControlEnt];
    if ( G_IsEntityInUse(remoteControlEnt) )
    {
      EntHandle::setEnt(&v7->remoteControlledOwner, NULL);
      eType = v7->s.eType;
      if ( eType == ET_MISSILE )
      {
        v7->c.missile.flags &= ~0x80u;
      }
      else if ( ((eType - 12) & 0xFFFD) == 0 && Com_GameMode_SupportsFeature(WEAPON_ANIM_SCRIPTED) )
      {
        G_Vehicle_PlayerRemoteControlOff(v7, PlayerEntity);
      }
    }
    if ( v5 )
    {
      GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(&client->ps.pm_flags, ACTIVE, 0x1Cu);
      client->ps.remoteControlEnt = 2047;
    }
  }
  else
  {
    Com_PrintWarning(23, "WARNING: ControlsUnlink() called on a player who's controls were not linked.\n");
  }
}

/*
==============
GScr_MakeVehicleSolidCapsule
==============
*/
void GScr_MakeVehicleSolidCapsule(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  double Float; 
  float v5; 
  double v6; 
  float v7; 
  double v8; 

  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 20490, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !Entity->vehicle )
    Scr_Error(COM_ERR_4540, scrContext, "MakeVehicleSolidCapsule must be called on a vehicle entity.\n");
  if ( Scr_GetNumParam(scrContext) < 3 )
    Scr_Error(COM_ERR_4541, scrContext, "Usage: MakeVehicleSolidCapsule( <radius>, <midz>, <height> ).");
  Float = Scr_GetFloat(scrContext, 0);
  v5 = *(float *)&Float;
  v6 = Scr_GetFloat(scrContext, 1u);
  v7 = *(float *)&v6;
  v8 = Scr_GetFloat(scrContext, 2u);
  SetupVehicleCollision(Entity, v5);
  Entity->r.box.midPoint.v[2] = v7;
  *(_QWORD *)Entity->r.box.midPoint.v = 0i64;
  Entity->r.box.halfSize.v[0] = v5;
  Entity->r.box.halfSize.v[1] = v5;
  Entity->r.box.halfSize.v[2] = *(float *)&v8;
  SV_LinkEntity(Entity);
}

/*
==============
GScr_MakeVehicleSolidSphere
==============
*/
void GScr_MakeVehicleSolidSphere(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  double Float; 
  float v5; 
  float v6; 
  double v7; 

  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 20528, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !Entity->vehicle )
    Scr_Error(COM_ERR_4542, scrContext, "MakeVehicleSolidSphere must be called on a vehicle entity.\n");
  if ( !Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_4543, scrContext, "Usage: MakeVehicleSolidSphere( <radius> ).");
  Float = Scr_GetFloat(scrContext, 0);
  v5 = *(float *)&Float;
  v6 = 0.0;
  if ( Scr_GetNumParam(scrContext) > 1 )
  {
    v7 = Scr_GetFloat(scrContext, 1u);
    v6 = *(float *)&v7;
  }
  SetupVehicleCollision(Entity, v5);
  Entity->r.box.midPoint.v[2] = v6;
  *(_QWORD *)Entity->r.box.midPoint.v = 0i64;
  Entity->r.box.halfSize.v[0] = v5;
  Entity->r.box.halfSize.v[1] = v5;
  Entity->r.box.halfSize.v[2] = v5;
  SV_LinkEntity(Entity);
}

/*
==============
ScrCmd_GetCollision
==============
*/
void ScrCmd_GetCollision(scrContext_t *scrContext, scr_entref_t entref)
{
  EffectiveStance v2; 
  unsigned int entnum; 
  gentity_s *v5; 
  void *client; 
  const char *v7; 
  ComErrorCode v8; 
  const char *v9; 
  ComErrorCode v10; 
  scr_string_t ConstString; 
  unsigned int CanonicalString; 
  unsigned int v13; 
  unsigned int v14; 
  Bounds bounds; 

  v2 = PM_EFF_STANCE_DEFAULT;
  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v7 = "not an entity";
    v8 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 21247, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v5 = &g_entities[entnum];
  client = v5->client;
  if ( !client )
  {
    client = v5->agent;
    if ( !client )
    {
      v7 = j_va("entity %i is not a player or agent", entnum);
      v8 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v8, scrContext, v7);
      client = NULL;
    }
  }
  if ( Scr_GetNumParam(scrContext) != 1 )
  {
    v9 = "GetCollision() requires exactly one argument.";
    v10 = COM_ERR_4576;
LABEL_21:
    Scr_Error(v10, scrContext, v9);
    return;
  }
  ConstString = Scr_GetConstString(scrContext, 0);
  if ( ConstString != scr_const.stand )
  {
    if ( ConstString == scr_const.crouch )
    {
      v2 = PM_EFF_STANCE_DUCKED;
    }
    else
    {
      if ( ConstString != scr_const.prone )
      {
        v9 = "GetCollision() unknown stance argument provided.";
        v10 = COM_ERR_4577;
        goto LABEL_21;
      }
      v2 = PM_EFF_STANCE_PRONE;
    }
  }
  bounds = *BG_Suit_GetBounds(*((_DWORD *)client + 221), v2);
  if ( BG_UsingNewPlayerCollision() )
    BG_PlayerCollision_AdjustCapsuleBoundsForStickSystem(&bounds);
  Scr_MakeStruct(scrContext);
  Scr_AddFloat(scrContext, bounds.halfSize.v[0]);
  CanonicalString = SL_GetCanonicalString("capsule_radius");
  Scr_AddStructField(scrContext, CanonicalString);
  Scr_AddFloat(scrContext, bounds.halfSize.v[2]);
  v13 = SL_GetCanonicalString("capsule_halfheight");
  Scr_AddStructField(scrContext, v13);
  Scr_AddFloat(scrContext, bounds.midPoint.v[2]);
  v14 = SL_GetCanonicalString("capsule_midpoint_height");
  Scr_AddStructField(scrContext, v14);
}

/*
==============
ScrCmd_ControlAgent
==============
*/
void ScrCmd_ControlAgent(scrContext_t *scrContext, scr_entref_t playerRef)
{
  Scr_Error(COM_ERR_4582, scrContext, "ControlAgent() functionality is disbled");
}

/*
==============
ScrCmd_RestoreControlAgent
==============
*/
void ScrCmd_RestoreControlAgent(scrContext_t *scrContext, scr_entref_t playerRef)
{
  Scr_Error(COM_ERR_4586, scrContext, "RestoreControlAgent() functionality is disbled");
}

/*
==============
ScrCmd_SetSolid
==============
*/
void ScrCmd_SetSolid(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *client; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *v6; 
  const char *v7; 
  ComErrorCode v8; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v7 = "not an entity";
    v8 = COM_ERR_3682;
    goto LABEL_20;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 21396, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = (GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *)v4->client;
  if ( !client )
  {
    client = (GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *)v4->agent;
    if ( !client )
    {
      v7 = j_va("entity %i is not a player or agent", entnum);
      v8 = COM_ERR_3679;
LABEL_20:
      Scr_ObjectError(v8, scrContext, v7);
      Scr_Error(COM_ERR_4587, scrContext, "SetSolid() called on entity without a playerState.\n");
      return;
    }
  }
  v6 = client + 94;
  if ( Scr_GetInt(scrContext, 0) )
  {
    if ( GameModeFlagValues::ms_mpValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 212, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a MP-only context", "IsFlagActive( index )") )
      __debugbreak();
    GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(v6, ACTIVE, 0x1Cu);
  }
  else
  {
    if ( GameModeFlagValues::ms_mpValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 201, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a MP-only context", "IsFlagActive( index )") )
      __debugbreak();
    GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(v6, ACTIVE, 0x1Cu);
  }
  if ( v4->agent )
    SV_LinkEntity(v4);
}

/*
==============
ScrCmd_NotifyOnPlayerUpdate
==============
*/
void ScrCmd_NotifyOnPlayerUpdate(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  gclient_s *client; 
  int flags; 

  Entity = GetEntity(entref);
  if ( Entity->client )
  {
    Int = Scr_GetInt(scrContext, 0);
    client = Entity->client;
    flags = client->flags;
    if ( Int )
      client->flags = flags | 0x80;
    else
      client->flags = flags & 0xFFFFFF7F;
  }
  else
  {
    Scr_Error(COM_ERR_4588, scrContext, "NotifyOnPlayerUpdate can only be set on clients.\n");
  }
}

/*
==============
ScrCmd_SetWorldUpTrigger
==============
*/
void ScrCmd_SetWorldUpTrigger(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *p_eFlags; 

  Entity = GetEntity(entref);
  Int = Scr_GetInt(scrContext, 0);
  p_eFlags = &Entity->s.lerp.eFlags;
  if ( Int )
  {
    GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(p_eFlags, ACTIVE, 0xFu);
    Entity->r.svFlags &= ~1u;
  }
  else
  {
    GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(p_eFlags, ACTIVE, 0xFu);
  }
}

/*
==============
GScr_RemoteControlVehicle
==============
*/
void GScr_RemoteControlVehicle(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *PlayerEntity; 
  gentity_s *Entity; 
  Vehicle *vehicle; 
  gclient_s *client; 
  __int64 v7; 
  DObj *ServerDObjForEnt; 
  int v9; 

  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  Entity = GScr_GetEntity(0);
  vehicle = Entity->vehicle;
  if ( !vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 21531, ASSERT_TYPE_ASSERT, "( vehicle )", (const char *)&queryFormat, "vehicle") )
    __debugbreak();
  if ( BGVehicles::PhysicsIsValid(vehicle->physicsVehicle) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 21532, ASSERT_TYPE_ASSERT, "( !BGVehicles::PhysicsIsValid( vehicle->physicsVehicle ) )", "RemoteControlVehicle() should be called only for non-physics vehicles") )
    __debugbreak();
  if ( ((Entity->s.eType - 12) & 0xFFFD) != 0 )
    Scr_ParamError(COM_ERR_4589, scrContext, 0, "Cannot control an entity that isn't a vehicle or helicopter");
  client = PlayerEntity->client;
  v7 = client->ps.vehicleState.entity;
  if ( (_DWORD)v7 != 2047 )
    EntHandle::setEnt(&g_entities[v7].r.ownerNum, NULL);
  memset_0(&client->ps.vehicleState, 0, sizeof(client->ps.vehicleState));
  client->ps.vehicleState.entity = Entity->s.number;
  EntHandle::setEnt(&Entity->r.ownerNum, PlayerEntity);
  client->ps.vehicleState.targetEntity = 2047;
  client->ps.vehicleState.origin.v[0] = vehicle->phys.origin.v[0];
  client->ps.vehicleState.origin.v[1] = vehicle->phys.origin.v[1];
  client->ps.vehicleState.origin.v[2] = vehicle->phys.origin.v[2];
  client->ps.vehicleState.angles.v[0] = vehicle->phys.angles.v[0];
  client->ps.vehicleState.angles.v[1] = vehicle->phys.angles.v[1];
  client->ps.vehicleState.angles.v[2] = vehicle->phys.angles.v[2];
  client->ps.vehicleState.velocity.v[0] = vehicle->phys.vel.v[0];
  client->ps.vehicleState.velocity.v[1] = vehicle->phys.vel.v[1];
  client->ps.vehicleState.velocity.v[2] = vehicle->phys.vel.v[2];
  client->ps.vehicleState.angVelocity.v[0] = vehicle->phys.rotVel.v[0];
  client->ps.vehicleState.angVelocity.v[1] = vehicle->phys.rotVel.v[1];
  client->ps.vehicleState.angVelocity.v[2] = vehicle->phys.rotVel.v[2];
  client->ps.vehicleState.tilt.v[0] = vehicle->phys.worldTilt.v[0];
  client->ps.vehicleState.tilt.v[1] = vehicle->phys.worldTilt.v[1];
  client->ps.vehicleState.tiltVelocity.v[0] = vehicle->phys.worldTiltVel.v[0];
  client->ps.vehicleState.tiltVelocity.v[1] = vehicle->phys.worldTiltVel.v[1];
  if ( G_Vehicle_IsRemoteDrive(Entity) )
  {
    GScr_RemoteEyesSet_Internal(&client->ps, Entity->s.number, 0, 0);
    if ( Com_GameMode_SupportsFeature(WEAPON_DROPPING_LADDER_CLIMB) )
    {
      if ( G_Vehicle_HasTurret(Entity) )
      {
        if ( !Com_GameMode_SupportsFeature(WEAPON_DROPPING_LADDER_CLIMB) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2417, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::TURRET_REMOTE_CONTROL ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::TURRET_REMOTE_CONTROL )") )
          __debugbreak();
        GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal(&client->ps.otherFlags, ACTIVE, 0x18u);
        client->ps.remoteTurretEnt = Entity->s.number;
      }
    }
  }
  ServerDObjForEnt = Com_GetServerDObjForEnt(Entity);
  v9 = XAnimIKGetCacheKey(ServerDObjForEnt);
  XAnimIKPreCacheDObj(ServerDObjForEnt, ServerDObjForEnt->entnum, v9);
}

/*
==============
GScr_CreatePrintChannel
==============
*/
void GScr_CreatePrintChannel(scrContext_t *scrContext)
{
  const char *String; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_3946, scrContext, "illegal call to createprintchannel()");
  String = Scr_GetString(scrContext, 0);
  if ( !Con_OpenChannel(String, 1) )
    Scr_Error(COM_ERR_3947, scrContext, "Unable to create new channel.  Maximum number of channels exeeded.");
}

/*
==============
GScr_printChannelSet
==============
*/
void GScr_printChannelSet(scrContext_t *scrContext)
{
  int scriptPrintChannel; 
  VariableType Type; 
  const char *String; 
  int channel_result; 

  channel_result = 24;
  if ( Scr_GetNumParam(scrContext) != 1 )
  {
    Scr_Error(COM_ERR_3948, scrContext, "illegal call to setprintchannel()");
    return;
  }
  scriptPrintChannel = level.scriptPrintChannel;
  Type = Scr_GetType(scrContext, 0);
  if ( Type == VAR_STRING )
  {
    String = Scr_GetString(scrContext, 0);
    if ( !Con_GetChannel(String, &channel_result) )
    {
      Scr_ParamError(COM_ERR_3949, scrContext, 0, "Invalid Print Channel");
      return;
    }
  }
  else
  {
    if ( Type != VAR_INTEGER )
    {
      Scr_ParamError(COM_ERR_3951, scrContext, 0, "Invalid Print Channel");
      return;
    }
    channel_result = Scr_GetInt(scrContext, 0);
    if ( !Con_IsChannelOpen(channel_result) )
    {
      Scr_ParamError(COM_ERR_3950, scrContext, 0, "Invalid Print Channel");
      return;
    }
  }
  if ( Con_ScriptHasPermission(channel_result) )
  {
    level.scriptPrintChannel = channel_result;
    Scr_AddInt(scrContext, scriptPrintChannel);
  }
  else
  {
    Scr_ParamError(COM_ERR_3952, scrContext, 0, "Script does not have permission to print to this channel");
  }
}

/*
==============
Scr_Print
==============
*/
void Scr_Print(scrContext_t *scrContext)
{
  signed int v2; 
  int NumParam; 
  const char *DebugString; 

  v2 = 0;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam > 0 )
  {
    do
    {
      DebugString = Scr_GetDebugString(scrContext, v2);
      Com_Printf(level.scriptPrintChannel, (const char *)&queryFormat, DebugString);
      ++v2;
    }
    while ( v2 < NumParam );
  }
}

/*
==============
GScr_RemoteControlVehicleOff
==============
*/
void GScr_RemoteControlVehicleOff(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *PlayerEntity; 
  gclient_s *client; 
  __int64 entity; 
  gentity_s *v5; 
  Vehicle *vehicle; 
  int time; 
  GUtils *v8; 

  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  client = PlayerEntity->client;
  entity = client->ps.vehicleState.entity;
  if ( (_DWORD)entity != 2047 )
  {
    v5 = &g_entities[entity];
    EntHandle::setEnt(&v5->r.ownerNum, NULL);
    vehicle = v5->vehicle;
    if ( !vehicle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 21617, ASSERT_TYPE_ASSERT, "( vehicle )", (const char *)&queryFormat, "vehicle") )
      __debugbreak();
    if ( BGVehicles::PhysicsIsValid(vehicle->physicsVehicle) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 21619, ASSERT_TYPE_ASSERT, "( !BGVehicles::PhysicsIsValid( vehicle->physicsVehicle ) )", "RemoteControlVehicleOff() should be called only for non-physics vehicles") )
      __debugbreak();
    vehicle->phys.origin.v[0] = client->ps.vehicleState.origin.v[0];
    vehicle->phys.origin.v[1] = client->ps.vehicleState.origin.v[1];
    vehicle->phys.origin.v[2] = client->ps.vehicleState.origin.v[2];
    vehicle->phys.angles.v[0] = client->ps.vehicleState.angles.v[0];
    vehicle->phys.angles.v[1] = client->ps.vehicleState.angles.v[1];
    vehicle->phys.angles.v[2] = client->ps.vehicleState.angles.v[2];
    vehicle->phys.vel.v[0] = client->ps.vehicleState.velocity.v[0];
    vehicle->phys.vel.v[1] = client->ps.vehicleState.velocity.v[1];
    vehicle->phys.vel.v[2] = client->ps.vehicleState.velocity.v[2];
    vehicle->phys.rotVel.v[0] = client->ps.vehicleState.angVelocity.v[0];
    vehicle->phys.rotVel.v[1] = client->ps.vehicleState.angVelocity.v[1];
    vehicle->phys.rotVel.v[2] = client->ps.vehicleState.angVelocity.v[2];
    vehicle->phys.worldTilt.v[0] = client->ps.vehicleState.tilt.v[0];
    vehicle->phys.worldTilt.v[1] = client->ps.vehicleState.tilt.v[1];
    vehicle->phys.worldTiltVel.v[0] = client->ps.vehicleState.tiltVelocity.v[0];
    vehicle->phys.worldTiltVel.v[1] = client->ps.vehicleState.tiltVelocity.v[1];
    time = level.time;
    v5->s.lerp.u.anonymous.data[1] &= ~0x40u;
    v5->nextthink = time;
  }
  if ( GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&client->ps.otherFlags, ACTIVE, 1u) && client->ps.remoteEyesEnt == client->ps.vehicleState.entity )
    GScr_RemoteEyesClear_Internal(&client->ps);
  if ( !GUtils::ms_gUtils && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_utils.h", 112, ASSERT_TYPE_ASSERT, "( ms_gUtils )", (const char *)&queryFormat, "ms_gUtils") )
    __debugbreak();
  v8 = GUtils::ms_gUtils;
  client->ps.viewangles.v[2] = 0.0;
  v8->SetPlayerViewAngles(v8, PlayerEntity, &client->ps.viewangles);
  if ( GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&client->ps.otherFlags, ACTIVE, 0x18u) )
  {
    if ( !Com_GameMode_SupportsFeature(WEAPON_DROPPING_LADDER_CLIMB) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2396, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::TURRET_REMOTE_CONTROL ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::TURRET_REMOTE_CONTROL )") )
      __debugbreak();
    if ( !Com_GameMode_SupportsFeature(WEAPON_DROPPING_LADDER_CLIMB) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 21647, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::TURRET_REMOTE_CONTROL ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::TURRET_REMOTE_CONTROL )") )
      __debugbreak();
    if ( client->ps.remoteTurretEnt == client->ps.vehicleState.entity )
    {
      if ( !Com_GameMode_SupportsFeature(WEAPON_DROPPING_LADDER_CLIMB) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2409, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::TURRET_REMOTE_CONTROL ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::TURRET_REMOTE_CONTROL )") )
        __debugbreak();
      GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal(&client->ps.otherFlags, ACTIVE, 0x18u);
    }
  }
  BG_InitPlayerstateVehicle(&client->ps);
  client->ps.vehicleState.flags &= ~0x40u;
}

/*
==============
Scr_PrintLn
==============
*/
void Scr_PrintLn(scrContext_t *scrContext)
{
  signed int v2; 
  int NumParam; 
  const char *DebugString; 

  v2 = 0;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam > 0 )
  {
    do
    {
      DebugString = Scr_GetDebugString(scrContext, v2);
      Com_Printf(level.scriptPrintChannel, (const char *)&queryFormat, DebugString);
      ++v2;
    }
    while ( v2 < NumParam );
  }
  Com_Printf(level.scriptPrintChannel, "\n");
}

/*
==============
GScr_IsPlayer
==============
*/
void GScr_IsPlayer(scrContext_t *scrContext)
{
  if ( Scr_GetType(scrContext, 0) == VAR_POINTER && Scr_GetPointerType(scrContext, 0) == VAR_ENTITY && GScr_GetEntity(0)->client )
    Scr_AddInt(scrContext, 1);
  else
    Scr_AddInt(scrContext, 0);
}

/*
==============
GScr_GetMaxClients
==============
*/
void GScr_GetMaxClients(scrContext_t *scrContext)
{
  Scr_AddInt(scrContext, SvClient::ms_clientCount);
}

/*
==============
GScr_Turret_IsFiringTurret
==============
*/
void GScr_Turret_IsFiringTurret(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int v4; 

  Entity = GetEntity(entref);
  if ( !Entity->turretHandle.m_objIndex )
    Scr_Error(COM_ERR_4592, scrContext, "IsVehicleTurretFiring must be called on a turret entity\n");
  v4 = GTurret::GetTurret(&Entity->turretHandle)->m_data.triggerDown && G_Turret_CanShoot(Entity);
  Scr_AddBool(scrContext, v4);
}

/*
==============
ScrCmd_MakeCollideWithItemClip
==============
*/
void ScrCmd_MakeCollideWithItemClip(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  BOOL v4; 
  unsigned int v5; 

  Entity = GetEntity(entref);
  if ( !Entity )
    Scr_Error(COM_ERR_4593, scrContext, "MakeCollideWithItemClip must be called on an entity.\n");
  if ( Entity->s.eType != ET_MISSILE )
    Scr_Error(COM_ERR_4594, scrContext, "MakeCollideWithItemClip is currently limited to missile entities.\n");
  if ( Scr_GetNumParam(scrContext) > 1 )
    Scr_Error(COM_ERR_4595, scrContext, "Usage: MakeCollideWithItemClip () or MakeCollideWithItemClip (enable).");
  v4 = 1;
  if ( Scr_GetNumParam(scrContext) == 1 )
    v4 = Scr_GetInt(scrContext, 0) != 0;
  v5 = Entity->clipmask | 0x400;
  if ( !v4 )
    v5 = Entity->clipmask & 0xFFFFFBFF;
  Entity->clipmask = v5;
}

/*
==============
GScr_PrintToScreen2D
==============
*/
void GScr_PrintToScreen2D(scrContext_t *scrContext)
{
  float v1; 
  unsigned int v3; 
  unsigned int v4; 
  double Float; 
  double v6; 
  float v7; 
  double v8; 
  const char *text; 
  vec4_t color; 

  v1 = FLOAT_1_0;
  color = (vec4_t)_xmm;
  v3 = Scr_GetNumParam(scrContext) - 3;
  if ( v3 )
  {
    v4 = v3 - 1;
    if ( v4 )
    {
      if ( v4 != 1 )
      {
        Scr_Error(COM_ERR_3959, scrContext, "invalid args to printtoscreen3d");
        return;
      }
      Float = Scr_GetFloat(scrContext, 4u);
      v1 = *(float *)&Float;
    }
    Scr_GetVector(scrContext, 3u, (vec3_t *)&color);
  }
  v6 = Scr_GetFloat(scrContext, 0);
  v7 = *(float *)&v6;
  v8 = Scr_GetFloat(scrContext, 1u);
  text = Scr_GetString(scrContext, 2u);
  G_Main_AddDebugString2D(v7, *(float *)&v8, &color, v1, text);
}

/*
==============
GScr_SpawnRagdollConstraint
==============
*/
void GScr_SpawnRagdollConstraint(scrContext_t *scrContext)
{
  gentity_s *Entity; 
  gentity_s *v3; 
  scr_string_t ConstString; 
  hitLocation_t HitLocationIndexFromString; 
  scr_string_t ConstLowercaseString; 
  bool v7; 
  const gentity_s *v8; 
  vec3_t vectorValue; 

  Entity = GScr_GetEntity(0);
  v3 = Entity;
  if ( !Entity || !BG_IsCorpseEntity(&Entity->s) )
    Scr_Error(COM_ERR_4596, scrContext, "ERROR: SpawnRagdollConstraint(), specified entity is not a corpse.");
  if ( v3 == (gentity_s *)-16i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\q_shared.h", 2263, ASSERT_TYPE_ASSERT, "(trajectory)", (const char *)&queryFormat, "trajectory") )
    __debugbreak();
  if ( (unsigned int)(v3->s.lerp.pos.trType - 23) > 5 )
    Scr_Error(COM_ERR_4597, scrContext, "ERROR: SpawnRagdollConstraint(), specified corpse entity is not in ragdoll.");
  ConstString = Scr_GetConstString(scrContext, 1u);
  HitLocationIndexFromString = G_Combat_GetHitLocationIndexFromString(ConstString);
  if ( HitLocationIndexFromString == HITLOC_NUM )
    Scr_Error(COM_ERR_4598, scrContext, "ERROR: SpawnRagdollConstraint(), invalid hitLocation provided.");
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 2u);
  if ( !ConstLowercaseString )
    Scr_Error(COM_ERR_4599, scrContext, "ERROR: SpawnRagdollConstraint(), invalid partName provided.");
  Scr_GetVector(scrContext, 3u, &vectorValue);
  v7 = 1;
  if ( Scr_GetNumParam(scrContext) > 4 )
    v7 = Scr_GetInt(scrContext, 4u) != 0;
  v8 = G_RagdollConstraintEntity_Spawn(v3, HitLocationIndexFromString, ConstLowercaseString, &vectorValue, v7);
  if ( v8 )
    GScr_AddEntity(v8);
  else
    Scr_AddUndefined(scrContext);
}

/*
==============
GScr_print3d
==============
*/
void GScr_print3d(scrContext_t *scrContext)
{
  float v1; 
  bool v3; 
  int duration; 
  double Float; 
  double v6; 
  const char *String; 
  vec4_t color; 
  vec3_t vectorValue; 
  vec3_t xyz; 

  v1 = FLOAT_1_0;
  color = (vec4_t)_xmm;
  v3 = 0;
  duration = 1;
  switch ( Scr_GetNumParam(scrContext) )
  {
    case 2u:
      goto $LN9_64;
    case 3u:
      goto $LN8_50;
    case 4u:
      goto $LN7_87;
    case 5u:
      goto $LN6_42;
    case 6u:
      goto $LN5_39;
    case 7u:
      v3 = Scr_GetInt(scrContext, 6u) != 0;
$LN5_39:
      duration = Scr_GetInt(scrContext, 5u);
$LN6_42:
      Float = Scr_GetFloat(scrContext, 4u);
      v1 = *(float *)&Float;
$LN7_87:
      v6 = Scr_GetFloat(scrContext, 3u);
      color.v[3] = *(float *)&v6;
$LN8_50:
      Scr_GetVector(scrContext, 2u, &vectorValue);
      color.xyz = vectorValue;
$LN9_64:
      String = Scr_GetString(scrContext, 1u);
      Scr_GetVector(scrContext, 0, &xyz);
      if ( v3 )
        G_Main_AddDebugStringWithDurationCentered(&xyz, &color, v1, String, duration);
      else
        G_Main_AddDebugStringWithDuration(&xyz, &color, v1, String, duration);
      break;
    default:
      Scr_Error(COM_ERR_3960, scrContext, "illegal call to print3d()");
      break;
  }
}

/*
==============
Scr_MagicBullet
==============
*/

void __fastcall Scr_MagicBullet(scrContext_t *scrContext, __int64 a2, double a3)
{
  __int128 v3; 
  __int128 v4; 
  __int128 v5; 
  int NumParam; 
  unsigned int v8; 
  gentity_s *Entity; 
  gentity_s *v10; 
  ComErrorCode v11; 
  const char *String; 
  const char *v13; 
  double Float; 
  const char *v15; 
  float v16; 
  __int128 v17; 
  float v18; 
  const WeaponDef *v19; 
  __int128 v20; 
  weapType_t WeaponType; 
  int time; 
  int WeaponClass; 
  const char *v27; 
  ComErrorCode v28; 
  gentity_s *v29; 
  const gentity_s *v30; 
  gentity_s *v31; 
  EntHandle *v32; 
  weapType_t v33; 
  const char *WeaponTypeName; 
  gentity_s *v35; 
  GWeaponMap *Instance; 
  int v37; 
  const DObj *ServerDObjForEnt; 
  float *hipSpreadDuckedMax; 
  float *hipSpreadProneMin; 
  bool outIsAlternate[4]; 
  float hipSpreadStandMin; 
  scr_string_t outTagName; 
  TagPair hipSpreadStandMax; 
  float hipSpreadInAirMin; 
  float hipSpreadSprintMax; 
  float hipSpreadSprintMin; 
  float hipSpreadProneMax; 
  float v49; 
  float v50; 
  float hipSpreadDuckedMin[4]; 
  BgWeaponParms forward; 
  vec3_t vectorValue; 
  vec3_t origin; 
  Weapon outWeapon; 
  tmat33_t<vec3_t> outAxis; 
  tmat33_t<vec3_t> out; 
  __int128 v58; 
  __int128 v59; 
  __int128 v60; 

  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam < 3 )
    Scr_Error(COM_ERR_4600, scrContext, "MagicBullet invalid parameters\n");
  v8 = 0;
  Entity = NULL;
  if ( NumParam >= 4 )
  {
    if ( Scr_GetType(scrContext, 3u) )
    {
      Entity = GScr_GetEntity(3u);
      if ( !G_Utils_IsClientOrActorOrAgent(Entity) )
        Scr_Error(COM_ERR_4601, scrContext, "Owner must be a player, actor, or agent.\n");
    }
  }
  v10 = NULL;
  if ( NumParam >= 5 && Scr_GetType(scrContext, 4u) )
    v10 = GScr_GetEntity(4u);
  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, outIsAlternate);
  if ( !outWeapon.weaponIdx )
  {
    if ( Scr_GetType(scrContext, 0) == VAR_STRING )
    {
      v11 = COM_ERR_4602;
      String = Scr_GetString(scrContext, 0);
      v13 = j_va("MagicBullet called with unknown weapon name %s\n", String);
    }
    else
    {
      v11 = COM_ERR_4603;
      v13 = "MagicBullet called with unknown weapon\n";
    }
    Scr_ParamError(v11, scrContext, 0, v13);
    return;
  }
  hipSpreadStandMin = 0.0;
  if ( BG_GetWeaponClass(&outWeapon, 0) == WEAPCLASS_SPREAD )
    BG_GetHipSpread(&outWeapon, 0, &hipSpreadStandMin, (float *)&hipSpreadStandMax, hipSpreadDuckedMin, &v50, &v49, &hipSpreadProneMax, &hipSpreadSprintMin, &hipSpreadSprintMax, &hipSpreadInAirMin, (float *)&outTagName);
  if ( NumParam >= 6 )
  {
    if ( Scr_GetType(scrContext, 5u) )
    {
      Float = Scr_GetFloat(scrContext, 5u);
      hipSpreadStandMin = *(float *)&Float;
      if ( *(float *)&Float < 0.0 )
      {
        v15 = j_va("MagicBullet called with an invalid spread value %f\n", *(float *)&Float);
        Scr_ParamError(COM_ERR_6491, scrContext, 0, v15);
        return;
      }
    }
  }
  v60 = v3;
  v59 = v4;
  v58 = v5;
  Scr_GetVector(scrContext, 1u, &vectorValue);
  origin = vectorValue;
  Scr_GetVector(scrContext, 2u, &vectorValue);
  v16 = vectorValue.v[0];
  v17 = LODWORD(vectorValue.v[1]);
  v18 = vectorValue.v[2];
  forward.weapon = outWeapon;
  forward.isAlternate = 0;
  if ( LOWORD(a3) > bg_lastParsedWeaponIndex )
  {
    LODWORD(hipSpreadProneMin) = bg_lastParsedWeaponIndex;
    LODWORD(hipSpreadDuckedMax) = LOWORD(a3);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1203, ASSERT_TYPE_ASSERT, "( weaponIdx ) <= ( bg_lastParsedWeaponIndex )", "weaponIdx not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", hipSpreadDuckedMax, hipSpreadProneMin) )
      __debugbreak();
  }
  if ( !bg_weaponDefs[LOWORD(a3)] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1204, ASSERT_TYPE_ASSERT, "(bg_weaponDefs[weaponIdx])", (const char *)&queryFormat, "bg_weaponDefs[weaponIdx]") )
    __debugbreak();
  v19 = bg_weaponDefs[LOWORD(a3)];
  v20 = v17;
  forward.muzzleTrace = origin;
  *(float *)&v20 = fsqrt((float)((float)((float)(*(float *)&v17 - origin.v[1]) * (float)(*(float *)&v17 - origin.v[1])) + (float)((float)(v16 - origin.v[0]) * (float)(v16 - origin.v[0]))) + (float)((float)(v18 - origin.v[2]) * (float)(v18 - origin.v[2])));
  _XMM3 = v20;
  __asm
  {
    vcmpless xmm0, xmm3, cs:__real@80000000
    vblendvps xmm0, xmm3, xmm1, xmm0
  }
  forward.forward.v[2] = (float)(v18 - origin.v[2]) * (float)(1.0 / *(float *)&_XMM0);
  forward.forward.v[0] = (float)(v16 - origin.v[0]) * (float)(1.0 / *(float *)&_XMM0);
  forward.forward.v[1] = (float)(*(float *)&v17 - origin.v[1]) * (float)(1.0 / *(float *)&_XMM0);
  forward.weapDef = v19;
  if ( hipSpreadStandMin <= 0.0 )
  {
    *(_OWORD *)&forward.right.y = 0i64;
    forward.right.v[0] = 0.0;
    forward.up.v[2] = 0.0;
  }
  else
  {
    MatrixIdentity33(&out);
    GenerateAxisFromForwardVector(&forward.forward, &out, &outAxis);
    *(_OWORD *)forward.right.v = *(_OWORD *)outAxis.row1.v;
    forward.up.v[1] = outAxis.m[2].v[1];
    forward.up.v[2] = outAxis.m[2].v[2];
  }
  G_Weapon_ClearSimulateTracerFlag(Entity);
  WeaponType = BG_GetWeaponType(&forward.weapon, forward.isAlternate);
  time = level.time;
  switch ( WeaponType )
  {
    case WEAPTYPE_BULLET:
      if ( !Entity )
        Entity = g_entities + 2046;
      if ( Entity->client )
        Scr_Error(COM_ERR_4613, scrContext, "MagicBullet() invoked with a client entity as the bullet weapon 'owner'.  This is not supported.  Specify a different owner entity.\n");
      G_Bullet_Fire(Entity, hipSpreadStandMin, &forward, Entity, WEAPON_HAND_DEFAULT, time);
      goto LABEL_61;
    case WEAPTYPE_GRENADE:
      Scr_Error(COM_ERR_4604, scrContext, "MagicBullet() does not work with grenade-type weapons.\n");
      return;
    case WEAPTYPE_PROJECTILE:
      WeaponClass = BG_GetWeaponClass(&forward.weapon, forward.isAlternate);
      if ( WeaponClass < 0 )
        goto LABEL_47;
      if ( WeaponClass <= 5 )
        goto LABEL_52;
      if ( WeaponClass == 6 )
      {
        if ( Entity )
          v29 = Entity;
        else
          v29 = g_entities + 2046;
        v30 = G_Weapon_GrenadeLauncher_Fire(v29, &outWeapon, WEAPON_HAND_DEFAULT, time, &forward);
      }
      else
      {
        if ( WeaponClass != 7 && WeaponClass != 12 )
        {
LABEL_47:
          v27 = "MagicBullet(): Unhandled projectile weapClass.\n";
          v28 = COM_ERR_4614;
LABEL_60:
          Scr_Error(v28, scrContext, v27);
          goto LABEL_61;
        }
LABEL_52:
        if ( Entity )
          v31 = Entity;
        else
          v31 = g_entities + 2046;
        v30 = G_Weapon_RocketLauncher_Fire(v31, &outWeapon, forward.isAlternate, WEAPON_HAND_DEFAULT, 0.0, &forward, &vec3_origin, time, NULL, 1);
      }
      v32 = (EntHandle *)v30;
      if ( !v30 )
      {
LABEL_61:
        Scr_AddUndefined(scrContext);
        goto LABEL_62;
      }
      GScr_AddEntity(v30);
      if ( Entity )
      {
        EntHandle::setEnt(v32 + 82, Entity);
        EntHandle::setEnt(v32 + 108, Entity);
      }
LABEL_62:
      if ( v10 )
      {
        if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_STILL_LAND|0x80) )
        {
          BG_GetWeaponFlashTagname(&hipSpreadStandMax, &outWeapon, 0, 0);
          outIsAlternate[0] = -2;
          v37 = -1;
          outTagName = 0;
          ServerDObjForEnt = Com_GetServerDObjForEnt(v10);
          if ( TagPair::GetTagNameAndBoneIndex(&hipSpreadStandMax, ServerDObjForEnt, &outTagName, (unsigned __int8 *)outIsAlternate) )
            v37 = outIsAlternate[0];
          v8 = BG_CreateWeaponFireParam(v37, &outWeapon);
        }
        G_Utils_AddEvent(v10, 0x28u, v8);
      }
      else
      {
        v35 = G_Utils_SpawnEventEntity(&origin, 40);
        v35->s.eventParm2 = 0;
        Instance = GWeaponMap::GetInstance();
        if ( !Instance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 447, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
          __debugbreak();
        Instance->SetWeapon(Instance, &v35->s.weaponHandle, &outWeapon);
        v35->s.eventParm = 0;
      }
      return;
    case WEAPTYPE_SCRIPT:
      Scr_Error(COM_ERR_4605, scrContext, "MagicBullet() does not work with script-type weapons.\n");
      return;
    case WEAPTYPE_SHIELD:
      Scr_Error(COM_ERR_4609, scrContext, "MagicBullet() does not work with shield-type weapons.\n");
      return;
    case WEAPTYPE_CHARGE_SHIELD:
      Scr_Error(COM_ERR_4610, scrContext, "MagicBullet() does not work with charge shield-type weapons.\n");
      return;
    case WEAPTYPE_LOCATION_SELECT:
      Scr_Error(COM_ERR_4611, scrContext, "MagicBullet() does not work with location select-type weapons.\n");
      return;
    case WEAPTYPE_EQUIP_DEPLOY:
      Scr_Error(COM_ERR_4612, scrContext, "MagicBullet() does not work with equipment deploy-type weapons.\n");
      return;
    default:
      v33 = BG_GetWeaponType(&forward.weapon, forward.isAlternate);
      WeaponTypeName = BG_GetWeaponTypeName(v33);
      v27 = j_va("MagicBullet(): Unhandled weapType \"%s\".\n", WeaponTypeName);
      v28 = COM_ERR_4615;
      goto LABEL_60;
  }
}

/*
==============
GScr_line
==============
*/
void GScr_line(scrContext_t *scrContext)
{
  int duration; 
  int Int; 
  unsigned int v4; 
  unsigned int v5; 
  unsigned int v6; 
  unsigned int v7; 
  double Float; 
  vec4_t color; 
  vec3_t vectorValue; 
  vec3_t start; 

  duration = 0;
  Int = 0;
  color = (vec4_t)_xmm;
  v4 = Scr_GetNumParam(scrContext) - 2;
  if ( !v4 )
    goto LABEL_11;
  v5 = v4 - 1;
  if ( !v5 )
  {
LABEL_10:
    Scr_GetVector(scrContext, 2u, (vec3_t *)&color);
LABEL_11:
    Scr_GetVector(scrContext, 1u, &vectorValue);
    Scr_GetVector(scrContext, 0, &start);
    goto LABEL_12;
  }
  v6 = v5 - 1;
  if ( !v6 )
  {
LABEL_9:
    Float = Scr_GetFloat(scrContext, 3u);
    color.v[3] = *(float *)&Float;
    goto LABEL_10;
  }
  v7 = v6 - 1;
  if ( !v7 )
  {
LABEL_8:
    Int = Scr_GetInt(scrContext, 4u);
    goto LABEL_9;
  }
  if ( v7 == 1 )
  {
    duration = Scr_GetInt(scrContext, 5u);
    goto LABEL_8;
  }
  Scr_Error(COM_ERR_3961, scrContext, "illegal call to line()");
LABEL_12:
  CL_AddDebugLine(&start, &vectorValue, &color, Int, duration, 1);
}

/*
==============
GScr_Box
==============
*/
void GScr_Box(scrContext_t *scrContext)
{
  int duration; 
  float v3; 
  int depthTest; 
  unsigned int v5; 
  unsigned int v6; 
  unsigned int v7; 
  unsigned int v8; 
  double Float; 
  vec4_t color; 
  vec3_t vectorValue; 
  Bounds box; 

  color = (vec4_t)_xmm;
  duration = 1;
  v3 = 0.0;
  depthTest = 0;
  v5 = Scr_GetNumParam(scrContext) - 1;
  if ( v5 )
  {
    v6 = v5 - 1;
    if ( v6 )
    {
      v7 = v6 - 1;
      if ( v7 )
      {
        v8 = v7 - 1;
        if ( v8 )
        {
          if ( v8 != 1 )
          {
            Scr_Error(COM_ERR_3962, scrContext, "illegal call to box()");
            return;
          }
          duration = Scr_GetInt(scrContext, 4u);
        }
        depthTest = Scr_GetInt(scrContext, 3u);
      }
      Scr_GetVector(scrContext, 2u, (vec3_t *)&color);
    }
    Float = Scr_GetFloat(scrContext, 1u);
    v3 = *(float *)&Float;
  }
  Scr_GetVector(scrContext, 0, &vectorValue);
  *(_OWORD *)box.midPoint.v = _xmm;
  box.halfSize.v[1] = FLOAT_16_0;
  box.halfSize.v[2] = FLOAT_8_0;
  G_DebugBox(&vectorValue, &box, v3, &color, depthTest, duration);
}

/*
==============
GScr_DrawEntityBounds
==============
*/
void GScr_DrawEntityBounds(scrContext_t *scrContext)
{
  int duration; 
  int depthTest; 
  unsigned int v4; 
  unsigned int v5; 
  unsigned int v6; 
  gentity_s *Entity; 
  vec4_t color; 

  color = (vec4_t)_xmm;
  duration = 1;
  depthTest = 0;
  v4 = Scr_GetNumParam(scrContext) - 1;
  if ( v4 )
  {
    v5 = v4 - 1;
    if ( v5 )
    {
      v6 = v5 - 1;
      if ( v6 )
      {
        if ( v6 != 1 )
        {
          Scr_Error(COM_ERR_3963, scrContext, "illegal call to DrawEntityBounds()");
          return;
        }
        duration = Scr_GetInt(scrContext, 3u);
      }
      depthTest = Scr_GetInt(scrContext, 2u);
    }
    Scr_GetVector(scrContext, 1u, (vec3_t *)&color);
  }
  Entity = GScr_GetEntity(0);
  if ( Entity )
    G_DebugBox(&Entity->r.currentOrigin, &Entity->r.box, Entity->r.currentAngles.v[1], &color, depthTest, duration);
}

/*
==============
GScr_DebugStar
==============
*/
void GScr_DebugStar(scrContext_t *scrContext)
{
  float v1; 
  const char *String; 
  int duration; 
  unsigned int v5; 
  unsigned int v6; 
  unsigned int v7; 
  unsigned int v8; 
  double Float; 
  vec4_t color; 
  vec3_t vectorValue; 

  v1 = FLOAT_1_0;
  String = NULL;
  color = colorWhite;
  duration = 10;
  v5 = Scr_GetNumParam(scrContext) - 1;
  if ( v5 )
  {
    v6 = v5 - 1;
    if ( v6 )
    {
      v7 = v6 - 1;
      if ( v7 )
      {
        v8 = v7 - 1;
        if ( v8 )
        {
          if ( v8 != 1 )
          {
            Scr_Error(COM_ERR_5913, scrContext, "Bad call to GetVector().  Pass in a mandatory origin parameter.");
            return;
          }
          if ( Scr_GetType(scrContext, 4u) )
          {
            Float = Scr_GetFloat(scrContext, 4u);
            v1 = *(float *)&Float;
          }
        }
        if ( Scr_GetType(scrContext, 3u) )
          String = Scr_GetString(scrContext, 3u);
      }
      if ( Scr_GetType(scrContext, 2u) )
        duration = Scr_GetInt(scrContext, 2u);
    }
    if ( Scr_GetType(scrContext, 1u) )
      Scr_GetVector(scrContext, 1u, (vec3_t *)&color);
  }
  Scr_GetVector(scrContext, 0, &vectorValue);
  if ( String )
    G_DebugStarWithTextDuration(&vectorValue, &color, &color, String, v1, duration);
  else
    G_DebugStarWithDuration(&vectorValue, &color, duration);
}

/*
==============
GScr_OrientedBox
==============
*/
void GScr_OrientedBox(scrContext_t *scrContext)
{
  int duration; 
  int depthTest; 
  vec3_t v4; 
  Bounds box; 
  vec4_t color; 
  vec3_t vectorValue; 
  vec3_t origin; 
  tmat33_t<vec3_t> axis; 

  color = (vec4_t)_xmm;
  duration = 1;
  depthTest = 0;
  switch ( Scr_GetNumParam(scrContext) )
  {
    case 1u:
      goto $LN9_65;
    case 2u:
      goto $LN8_51;
    case 3u:
      goto $LN7_88;
    case 4u:
      goto $LN6_43;
    case 5u:
      goto $LN5_40;
    case 6u:
      duration = Scr_GetInt(scrContext, 5u);
$LN5_40:
      depthTest = Scr_GetInt(scrContext, 4u);
$LN6_43:
      Scr_GetVector(scrContext, 3u, (vec3_t *)&color);
$LN7_88:
      Scr_GetVector(scrContext, 2u, &vectorValue);
$LN8_51:
      Scr_GetVector(scrContext, 1u, &v4);
$LN9_65:
      Scr_GetVector(scrContext, 0, &origin);
      box.halfSize.v[1] = 0.5 * v4.v[1];
      box.midPoint.v[0] = 0.0;
      box.midPoint.v[1] = 0.0;
      box.midPoint.v[2] = 0.0;
      box.halfSize.v[0] = 0.5 * v4.v[0];
      box.halfSize.v[2] = 0.5 * v4.v[2];
      AnglesToAxis(&vectorValue, &axis);
      G_DebugBoxOriented(&origin, &box, &axis, &color, depthTest, duration);
      break;
    default:
      Scr_Error(COM_ERR_3964, scrContext, "illegal call to OrientedBox()");
      break;
  }
}

/*
==============
Scr_GetWeaponFlashTagname
==============
*/
void Scr_GetWeaponFlashTagname(scrContext_t *scrContext)
{
  ComErrorCode v2; 
  const char *String; 
  const char *v4; 
  scr_string_t PrimaryTagName; 
  bool outIsAlternate; 
  TagPair result; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( outWeapon.weaponIdx )
  {
    BG_GetWeaponFlashTagname(&result, &outWeapon, 0, 0);
    PrimaryTagName = TagPair::GetPrimaryTagName(&result);
    Scr_AddConstString(scrContext, PrimaryTagName);
  }
  else
  {
    if ( Scr_GetType(scrContext, 0) == VAR_STRING )
    {
      v2 = COM_ERR_4616;
      String = Scr_GetString(scrContext, 0);
      v4 = j_va("Unknown weapon name \"%s\"\n", String);
    }
    else
    {
      v2 = COM_ERR_4617;
      v4 = "Unknown weapon specified for GetWeaponFlashTagname\n";
    }
    Scr_Error(v2, scrContext, v4);
  }
}

/*
==============
GScr_RemoteCameraSoundscapeOn
==============
*/
void GScr_RemoteCameraSoundscapeOn(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gclient_s *client; 

  Entity = GetEntity(entref);
  client = Entity->client;
  if ( !client )
  {
    Scr_ObjectError(COM_ERR_4618, scrContext, "not a player entity");
    client = Entity->client;
  }
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal(&client->ps.otherFlags, ACTIVE, 5u);
}

/*
==============
GScr_DebugAxis
==============
*/
void GScr_DebugAxis(scrContext_t *scrContext)
{
  float v1; 
  float v2; 
  int duration; 
  int depthTest; 
  double Float; 
  double v7; 
  vec3_t vectorValue; 
  vec3_t pos; 
  tmat33_t<vec3_t> axis; 

  v1 = FLOAT_16_0;
  v2 = FLOAT_1_0;
  duration = 1;
  depthTest = 0;
  switch ( Scr_GetNumParam(scrContext) )
  {
    case 1u:
      goto $LN13_46;
    case 2u:
      goto $LN11_53;
    case 3u:
      goto $LN7_89;
    case 4u:
      goto $LN6_44;
    case 5u:
      goto $LN5_41;
    case 6u:
      duration = Scr_GetInt(scrContext, 5u);
$LN5_41:
      depthTest = Scr_GetInt(scrContext, 4u);
$LN6_44:
      if ( Scr_GetType(scrContext, 3u) )
      {
        Float = Scr_GetFloat(scrContext, 3u);
        v2 = *(float *)&Float;
        if ( *(float *)&Float < 0.0 || *(float *)&Float > 2.0 )
          Scr_Error(COM_ERR_5914, scrContext, "Bad call to DebugAxis().  ColorScale must be a multiplier float between 0.0 and 2.0");
        I_fclamp(*(float *)&Float, 0.0, 2.0);
      }
$LN7_89:
      if ( Scr_GetType(scrContext, 2u) )
      {
        v7 = Scr_GetFloat(scrContext, 2u);
        v1 = *(float *)&v7;
      }
$LN11_53:
      Scr_GetVector(scrContext, 1u, &vectorValue);
$LN13_46:
      Scr_GetVector(scrContext, 0, &pos);
      AnglesToAxis(&vectorValue, &axis);
      G_DebugAxisWithColor(&axis, &pos, v1, v2, depthTest, duration);
      break;
    default:
      Scr_Error(COM_ERR_5915, scrContext, "Bad call to DebugAxis().  Mandatory parameters are the origin and angles.");
      break;
  }
}

/*
==============
GScr_RemoteCameraSoundscapeOff
==============
*/
void GScr_RemoteCameraSoundscapeOff(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gclient_s *client; 

  Entity = GetEntity(entref);
  client = Entity->client;
  if ( !client )
  {
    Scr_ObjectError(COM_ERR_4619, scrContext, "not a player entity");
    client = Entity->client;
  }
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal(&client->ps.otherFlags, ACTIVE, 5u);
}

/*
==============
GScr_Sphere
==============
*/
void GScr_Sphere(scrContext_t *scrContext)
{
  int duration; 
  float v3; 
  int Int; 
  unsigned int v5; 
  unsigned int v6; 
  unsigned int v7; 
  unsigned int v8; 
  double Float; 
  vec4_t color; 
  vec3_t vectorValue; 

  color = (vec4_t)_xmm;
  duration = 1;
  v3 = 0.0;
  Int = 0;
  v5 = Scr_GetNumParam(scrContext) - 1;
  if ( v5 )
  {
    v6 = v5 - 1;
    if ( v6 )
    {
      v7 = v6 - 1;
      if ( v7 )
      {
        v8 = v7 - 1;
        if ( v8 )
        {
          if ( v8 != 1 )
          {
            Scr_Error(COM_ERR_3965, scrContext, "illegal call to Sphere()");
            return;
          }
          duration = Scr_GetInt(scrContext, 4u);
        }
        Int = Scr_GetInt(scrContext, 3u);
      }
      Scr_GetVector(scrContext, 2u, (vec3_t *)&color);
    }
    Float = Scr_GetFloat(scrContext, 1u);
    v3 = *(float *)&Float;
  }
  Scr_GetVector(scrContext, 0, &vectorValue);
  G_DebugSphere(&vectorValue, v3, &color, Int, duration);
}

/*
==============
GScr_Cylinder
==============
*/
void GScr_Cylinder(scrContext_t *scrContext)
{
  int duration; 
  float v3; 
  int depthTest; 
  double Float; 
  vec4_t color; 
  vec3_t vectorValue; 
  vec3_t start; 

  color = (vec4_t)_xmm;
  duration = 1;
  v3 = 0.0;
  depthTest = 0;
  switch ( Scr_GetNumParam(scrContext) )
  {
    case 1u:
      goto $LN9_66;
    case 2u:
      goto $LN8_52;
    case 3u:
      goto $LN7_90;
    case 4u:
      goto $LN6_45;
    case 5u:
      goto $LN5_42;
    case 6u:
      duration = Scr_GetInt(scrContext, 5u);
$LN5_42:
      depthTest = Scr_GetInt(scrContext, 4u);
$LN6_45:
      Scr_GetVector(scrContext, 3u, (vec3_t *)&color);
$LN7_90:
      Float = Scr_GetFloat(scrContext, 2u);
      v3 = *(float *)&Float;
$LN8_52:
      Scr_GetVector(scrContext, 1u, &vectorValue);
$LN9_66:
      Scr_GetVector(scrContext, 0, &start);
      G_DebugCylinder(&start, &vectorValue, v3, &color, depthTest, duration);
      break;
    default:
      Scr_Error(COM_ERR_3966, scrContext, "illegal call to Cylinder()");
      break;
  }
}

/*
==============
GScrCmd_SetWeaponHudIconOverride
==============
*/
void GScrCmd_SetWeaponHudIconOverride(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int v2; 
  unsigned int entnum; 
  gentity_s *v5; 
  const char *v6; 
  scr_string_t ConstString; 
  scr_string_t v8; 
  __int64 v9; 
  const char *v10; 
  bool v11; 
  gclient_s *client; 
  unsigned int outWeaponTypeIndex; 

  v2 = 0;
  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v5 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 22313, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v5 = &g_entities[entnum];
    if ( !v5->client )
    {
      v6 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v6);
    }
  }
  ConstString = Scr_GetConstString(scrContext, 0);
  v8 = Scr_GetConstString(scrContext, 1u);
  GetWeaponHudIconOverrideIndex(scrContext, ConstString, &outWeaponTypeIndex);
  v9 = (int)outWeaponTypeIndex;
  if ( v8 != scr_const.none )
  {
    v10 = SL_ConvertToString(v8);
    if ( !GConfigStrings::ms_gConfigStrings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_configstrings.h", 71, ASSERT_TYPE_ASSERT, "( ms_gConfigStrings )", (const char *)&queryFormat, "ms_gConfigStrings") )
      __debugbreak();
    v2 = GConfigStrings::ms_gConfigStrings->GetMaterialIndex(GConfigStrings::ms_gConfigStrings, v10);
  }
  v11 = Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_STILL_LAND|0x80);
  client = v5->client;
  if ( v11 )
  {
    client->ps.weaponHudIconOverrides[v9] = v2;
    BG_SetWeaponHudIconOverrideAmmo(&v5->client->ps, v9, -1);
  }
  else
  {
    client->sess.weaponHudIconOverrides[v9] = v2;
  }
}

/*
==============
GScr_AddDebugCommand
==============
*/
void GScr_AddDebugCommand(scrContext_t *scrContext)
{
  const char *String; 
  int v2; 
  int v3; 
  scrContext_t *v4; 

  String = Scr_GetString(scrContext, 0);
  Sys_EnterCriticalSection(CRITSECT_CBUF);
  v2 = strlen_noncrt(String);
  v3 = v2;
  if ( s_cmd_textArray[0].cmdsize + v2 < s_cmd_textArray[0].maxsize )
  {
    memcpy_noncrt(&s_cmd_textArray[0].data[s_cmd_textArray[0].cmdsize], String, v2 + 1);
    s_cmd_textArray[0].cmdsize += v3;
    v4 = ScriptContext_Server();
    Scr_MonitorCommand(v4, String);
  }
  else
  {
    Com_Printf(16, "Cbuf_AddText: overflow (adding '%s')\n", String);
  }
  Sys_LeaveCriticalSection(CRITSECT_CBUF);
}

/*
==============
GScr_IsValidMissile
==============
*/
void GScr_IsValidMissile(scrContext_t *scrContext)
{
  if ( Scr_GetType(scrContext, 0) == VAR_POINTER && Scr_GetPointerType(scrContext, 0) == VAR_ENTITY && GScr_GetEntity(0)->s.eType == ET_MISSILE )
    Scr_AddInt(scrContext, 1);
  else
    Scr_AddInt(scrContext, 0);
}

/*
==============
GScr_IsSentient
==============
*/
void GScr_IsSentient(scrContext_t *scrContext)
{
  if ( Scr_GetType(scrContext, 0) == VAR_POINTER && Scr_GetPointerType(scrContext, 0) == VAR_ENTITY && GScr_GetEntity(0)->sentient )
    Scr_AddInt(scrContext, 1);
  else
    Scr_AddInt(scrContext, 0);
}

/*
==============
GScr_GetIndexForLuiNCString
==============
*/
void GScr_GetIndexForLuiNCString(scrContext_t *scrContext)
{
  const char *String; 
  unsigned int luiStringIndex; 

  String = Scr_GetString(scrContext, 0);
  if ( NetConstStrings_GetLuiStringIndex(String, &luiStringIndex) || (Com_PrintError(24, "%s not found in the Lui NetConstStrings. Did you add it to ncsLuiStrings.txt? Returning index for 'unknown' instead.", String), NetConstStrings_GetLuiStringIndex("unknown", &luiStringIndex)) )
    Scr_AddInt(scrContext, luiStringIndex);
  else
    Com_ScriptError("Couldn't find 'unknown' in the Lui NetConstStrings.");
}

/*
==============
GScrCmd_GetWeaponHudIconOverride
==============
*/
void GScrCmd_GetWeaponHudIconOverride(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  scr_string_t ConstString; 
  bool v7; 
  gclient_s *client; 
  unsigned int v9; 
  unsigned int outWeaponTypeIndex[4]; 
  char value[64]; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 22363, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  ConstString = Scr_GetConstString(scrContext, 0);
  GetWeaponHudIconOverrideIndex(scrContext, ConstString, outWeaponTypeIndex);
  v7 = Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_STILL_LAND|0x80);
  client = v4->client;
  if ( v7 )
    v9 = client->ps.weaponHudIconOverrides[outWeaponTypeIndex[0]];
  else
    v9 = client->sess.weaponHudIconOverrides[outWeaponTypeIndex[0]];
  if ( v9 )
  {
    if ( !GConfigStrings::ms_gConfigStrings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_configstrings.h", 71, ASSERT_TYPE_ASSERT, "( ms_gConfigStrings )", (const char *)&queryFormat, "ms_gConfigStrings") )
      __debugbreak();
    GConfigStrings::ms_gConfigStrings->GetMaterialName(GConfigStrings::ms_gConfigStrings, v9, value, 64);
    Scr_AddString(scrContext, value);
  }
  else
  {
    Scr_AddConstString(scrContext, scr_const.none);
  }
}

/*
==============
GScrCmd_SetWeaponHudIconOverrideAmmo
==============
*/
void GScrCmd_SetWeaponHudIconOverrideAmmo(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  scr_string_t ConstString; 
  int Int; 
  unsigned int outWeaponTypeIndex; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 22414, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  ConstString = Scr_GetConstString(scrContext, 0);
  Int = Scr_GetInt(scrContext, 1u);
  GetWeaponHudIconOverrideIndex(scrContext, ConstString, &outWeaponTypeIndex);
  if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_STILL_LAND|0x80) )
    BG_SetWeaponHudIconOverrideAmmo(&v4->client->ps, outWeaponTypeIndex, Int);
}

/*
==============
GScrCmd_GetWeaponHudIconOverrideAmmo
==============
*/
void GScrCmd_GetWeaponHudIconOverrideAmmo(scrContext_t *scrContext, scr_entref_t entref)
{
  int WeaponHudIconOverrideAmmo; 
  unsigned int entnum; 
  gentity_s *v5; 
  const char *v6; 
  scr_string_t ConstString; 
  unsigned int outWeaponTypeIndex; 

  WeaponHudIconOverrideAmmo = 0;
  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v5 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 22451, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v5 = &g_entities[entnum];
    if ( !v5->client )
    {
      v6 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v6);
    }
  }
  ConstString = Scr_GetConstString(scrContext, 0);
  GetWeaponHudIconOverrideIndex(scrContext, ConstString, &outWeaponTypeIndex);
  if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_STILL_LAND|0x80) )
    WeaponHudIconOverrideAmmo = BG_GetWeaponHudIconOverrideAmmo(&v5->client->ps, outWeaponTypeIndex);
  Scr_AddInt(scrContext, WeaponHudIconOverrideAmmo);
}

/*
==============
GScr_SetOmnvar
==============
*/
void GScr_SetOmnvar(scrContext_t *scrContext)
{
  const char *String; 
  unsigned int IndexByName; 
  const char *v4; 
  const OmnvarDef *Def; 
  const char *v6; 
  OmnvarData *Data; 

  String = Scr_GetString(scrContext, 0);
  IndexByName = BG_Omnvar_GetIndexByName(String);
  if ( IndexByName == -1 )
  {
    v4 = j_va("SetOmnvar - '%s' not found", String);
    Scr_Error(COM_ERR_3975, scrContext, v4);
  }
  Def = BG_Omnvar_GetDef(IndexByName);
  if ( (Def->flags & 2) != 0 )
  {
    v6 = j_va("SetOmnvar '%s' must be done on a game-scope Omnvar", String);
    Scr_Error(COM_ERR_3976, scrContext, v6);
  }
  Data = G_Omnvar_GetData(IndexByName, -1, NULL);
  GScr_SetOmnvarInternal(scrContext, Def, Data, 1);
}

/*
==============
GScr_SetOmnvarBit
==============
*/
void GScr_SetOmnvarBit(scrContext_t *scrContext)
{
  const char *String; 
  unsigned int IndexByName; 
  const char *v4; 
  const OmnvarDef *Def; 
  const char *v6; 
  OmnvarData *Data; 
  OmnvarValue current; 
  unsigned int NumParam; 
  const char *v10; 
  const char *v11; 
  char Int; 
  int v13; 
  const char *v14; 

  String = Scr_GetString(scrContext, 0);
  IndexByName = BG_Omnvar_GetIndexByName(String);
  if ( IndexByName == -1 )
  {
    v4 = j_va("SetOmnvarBit - '%s' not found", String);
    Scr_Error(COM_ERR_3977, scrContext, v4);
  }
  Def = BG_Omnvar_GetDef(IndexByName);
  if ( (Def->flags & 2) != 0 )
  {
    v6 = j_va("SetOmnvar '%s' must be done on a game-scope Omnvar", String);
    Scr_Error(COM_ERR_3978, scrContext, v6);
  }
  Data = G_Omnvar_GetData(IndexByName, -1, NULL);
  current = Data->current;
  NumParam = Scr_GetNumParam(scrContext);
  if ( Def->type != OMNVAR_TYPE_UINT || Def->userType != OMNVAR_USER_TYPE_BIT_FIELD )
  {
    v10 = j_va("SetOmnvarBit - '%s' expects a bit field omnvar", String);
    Scr_Error(COM_ERR_3979, scrContext, v10);
  }
  if ( NumParam != 3 )
  {
    v11 = j_va("SetOmnvarBit - '%s' expects three paramaters: <bit field omnvar>, <index>, and <value>", String);
    Scr_Error(COM_ERR_3980, scrContext, v11);
  }
  Int = Scr_GetInt(scrContext, 1u);
  v13 = Scr_GetInt(scrContext, 2u);
  if ( v13 == 1 )
  {
    current.integer |= 1 << Int;
  }
  else if ( v13 )
  {
    v14 = j_va("SetOmnvarBit - '%s' third parameter should be a boolean.", String);
    Scr_Error(COM_ERR_3981, scrContext, v14);
  }
  else
  {
    current.integer &= ~(1 << Int);
  }
  Data->current = current;
  G_Omnvar_MarkChanged(Data);
}

/*
==============
GScr_SetEMPJammed
==============
*/
void GScr_SetEMPJammed(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *p_otherFlags; 

  Entity = GetEntity(entref);
  if ( !Entity->client )
    Scr_Error(COM_ERR_4621, scrContext, "SetEMPJammed: Entity must be a player entity");
  Int = Scr_GetInt(scrContext, 0);
  p_otherFlags = &Entity->client->ps.otherFlags;
  if ( Int )
    GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal(p_otherFlags, ACTIVE, 0xAu);
  else
    GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal(p_otherFlags, ACTIVE, 0xAu);
}

/*
==============
ScrCmd_WorldPointToScreenPos
==============
*/
void ScrCmd_WorldPointToScreenPos(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  double Float; 
  const char *VariantString; 
  vec2_t outScreenPos; 
  vec2_t value; 
  float v12; 
  vec3_t vectorValue; 
  vec3_t outOrigin; 
  tmat33_t<vec3_t> outForward; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 22526, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  Scr_GetVector(scrContext, 0, &vectorValue);
  Float = Scr_GetFloat(scrContext, 1u);
  G_Client_GetViewOrigin(&v4->client->ps, &outOrigin);
  G_Client_GetViewDirectionLinked(v4, outForward.m, &outForward.m[1], &outForward.m[2]);
  if ( (float)G_Main_WorldPointToScreenPos(&outOrigin, &outForward, *(float *)&Float, &vectorValue, &outScreenPos) == 0.0 )
    goto LABEL_12;
  VariantString = Dvar_GetVariantString("TQQKORSSM");
  atoi(VariantString);
  _XMM0 = 0i64;
  __asm { vcvtsi2sd xmm0, xmm0, ecx }
  if ( COERCE_FLOAT(LODWORD(outScreenPos.v[0]) & _xmm) > *(double *)&_XMM0 * 0.5 || COERCE_FLOAT(LODWORD(outScreenPos.v[1]) & _xmm) > 240.0 )
  {
LABEL_12:
    Scr_AddUndefined(scrContext);
  }
  else
  {
    value = outScreenPos;
    v12 = 0.0;
    Scr_AddVector(scrContext, (const float *)&value);
  }
}

/*
==============
GScr_GetOmnvar
==============
*/
void GScr_GetOmnvar(scrContext_t *scrContext)
{
  const char *String; 
  unsigned int IndexByName; 
  const char *v4; 
  const OmnvarDef *Def; 
  const char *v6; 
  OmnvarData *Data; 
  unsigned int v8; 
  OmnvarValue current; 
  char Int; 
  __int64 v11; 
  char *outStringValue; 

  String = Scr_GetString(scrContext, 0);
  IndexByName = BG_Omnvar_GetIndexByName(String);
  if ( IndexByName == -1 )
  {
    v4 = j_va("GetOmnvar - '%s' not found", String);
    Scr_Error(COM_ERR_3982, scrContext, v4);
  }
  Def = BG_Omnvar_GetDef(IndexByName);
  if ( (Def->flags & 2) != 0 )
  {
    v6 = j_va("GetOmnvar '%s' must be done on a a game-scope Omnvar", String);
    Scr_Error(COM_ERR_3983, scrContext, v6);
  }
  Data = G_Omnvar_GetData(IndexByName, -1, NULL);
  switch ( Def->type )
  {
    case OMNVAR_TYPE_BOOL:
      Scr_AddBool(scrContext, Data->current.enabled);
      break;
    case OMNVAR_TYPE_FLOAT:
      Scr_AddFloat(scrContext, Data->current.value);
      break;
    case OMNVAR_TYPE_INT:
      if ( !Data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_omnvar.h", 207, ASSERT_TYPE_ASSERT, "(data)", (const char *)&queryFormat, "data") )
        __debugbreak();
      if ( Def->type != OMNVAR_TYPE_INT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_omnvar.h", 208, ASSERT_TYPE_ASSERT, "(def->type == OMNVAR_TYPE_INT)", (const char *)&queryFormat, "def->type == OMNVAR_TYPE_INT") )
        __debugbreak();
      v8 = Def->minvalue + Data->current.integer;
      if ( Def->userType != OMNVAR_USER_TYPE_ENTITY )
        goto LABEL_23;
      if ( v8 != 2047 )
      {
        if ( v8 >= 0x7FE )
        {
          LODWORD(v11) = v8;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 2299, ASSERT_TYPE_ASSERT, "(unsigned)( omnvarValue ) < (unsigned)( ENTITYNUM_ORDINARY_END )", "omnvarValue doesn't index ENTITYNUM_ORDINARY_END\n\t%i not in [0, %i)", v11, 2046) )
            __debugbreak();
        }
        GScr_AddEntity(&g_entities[v8]);
      }
      break;
    case OMNVAR_TYPE_UINT:
      current = Data->current;
      if ( Def->userType != OMNVAR_USER_TYPE_BIT_FIELD || Scr_GetNumParam(scrContext) != 2 )
        goto $LN13_47;
      Int = Scr_GetInt(scrContext, 1u);
      v8 = (current.integer & (unsigned int)(1 << Int)) >> Int;
LABEL_23:
      Scr_AddInt(scrContext, v8);
      break;
    case OMNVAR_TYPE_TIME:
$LN13_47:
      Scr_AddInt(scrContext, Data->current.integer);
      break;
    case OMNVAR_TYPE_NCS_LUI:
      outStringValue = NULL;
      BG_Omnvar_GetNCString(Def, Data, (const char **)&outStringValue);
      if ( !outStringValue && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 2338, ASSERT_TYPE_ASSERT, "(stringValue)", (const char *)&queryFormat, "stringValue") )
        __debugbreak();
      Scr_AddString(scrContext, outStringValue);
      break;
    default:
      Scr_Error(COM_ERR_3984, scrContext, "SetOmnvar - Type for paramater 1 not recognized");
      break;
  }
}

/*
==============
GScr_SetDvar
==============
*/
void GScr_SetDvar(scrContext_t *scrContext)
{
  const char *String; 
  const char *UnobfuscatedName; 
  const char *v4; 
  GScript *v5; 
  void (__fastcall *ConstructMessageString)(GScript *, scrContext_t *, int, int, const char *, char *, unsigned int); 
  unsigned int NumParam; 
  char *v8; 
  bool v9; 
  unsigned int v10; 
  char inString[1024]; 
  char outString[1024]; 

  String = Scr_GetString(scrContext, 0);
  if ( !Dvar_IsValidName(String) )
  {
    UnobfuscatedName = Dvar_DevGetUnobfuscatedName(String);
    v4 = j_va("Dvar %s has an invalid dvar name", UnobfuscatedName);
    Scr_Error(COM_ERR_3986, scrContext, v4);
  }
  if ( Scr_GetType(scrContext, 1u) == VAR_ISTRING )
  {
    if ( !GScript::ms_gScriptSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.h", 183, ASSERT_TYPE_ASSERT, "( ms_gScriptSystem )", (const char *)&queryFormat, "ms_gScriptSystem") )
      __debugbreak();
    v5 = GScript::ms_gScriptSystem;
    ConstructMessageString = GScript::ms_gScriptSystem->ConstructMessageString;
    NumParam = Scr_GetNumParam(scrContext);
    ConstructMessageString(v5, scrContext, 1, NumParam - 1, "Dvar Value", inString, 1024u);
    v8 = inString;
  }
  else
  {
    v8 = (char *)Scr_GetString(scrContext, 1u);
  }
  Com_CleanStringForNetwork(v8, outString, 1024);
  v9 = Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_SLOW_SOFT_LAND|0x80);
  v10 = 525448;
  if ( v9 )
    v10 = -1;
  GScr_SetDvar_Internal(scrContext, String, outString, v10);
}

/*
==============
GScr_SetDynamicDvar
==============
*/
void GScr_SetDynamicDvar(scrContext_t *scrContext)
{
  const char *String; 
  const char *UnobfuscatedName; 
  const char *v4; 
  GScript *v5; 
  void (__fastcall *ConstructMessageString)(GScript *, scrContext_t *, int, int, const char *, char *, unsigned int); 
  unsigned int NumParam; 
  char *v8; 
  char inString[1024]; 
  char outString[1024]; 

  if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_SLOW_SOFT_LAND|0x80) )
    Scr_Error(COM_ERR_3987, scrContext, "SetDynamicDvar is only necessary in Multiplayer. Use SetDvar instead.");
  String = Scr_GetString(scrContext, 0);
  if ( !Dvar_IsValidName(String) )
  {
    UnobfuscatedName = Dvar_DevGetUnobfuscatedName(String);
    v4 = j_va("Dvar %s has an invalid dvar name", UnobfuscatedName);
    Scr_Error(COM_ERR_3988, scrContext, v4);
  }
  if ( Scr_GetType(scrContext, 1u) == VAR_ISTRING )
  {
    if ( !GScript::ms_gScriptSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.h", 183, ASSERT_TYPE_ASSERT, "( ms_gScriptSystem )", (const char *)&queryFormat, "ms_gScriptSystem") )
      __debugbreak();
    v5 = GScript::ms_gScriptSystem;
    ConstructMessageString = GScript::ms_gScriptSystem->ConstructMessageString;
    NumParam = Scr_GetNumParam(scrContext);
    ConstructMessageString(v5, scrContext, 1, NumParam - 1, "Dvar Value", inString, 1024u);
    v8 = inString;
  }
  else
  {
    v8 = (char *)Scr_GetString(scrContext, 1u);
  }
  Com_CleanStringForNetwork(v8, outString, 1024);
  Dvar_SetFromStringByNameFromScript(SCRIPTINSTANCE_SERVER, String, outString);
}

/*
==============
GScr_SetDevDvar
==============
*/
void GScr_SetDevDvar(scrContext_t *scrContext)
{
  const char *String; 
  const char *UnobfuscatedName; 
  const char *v4; 
  GScript *v5; 
  void (__fastcall *ConstructMessageString)(GScript *, scrContext_t *, int, int, const char *, char *, unsigned int); 
  unsigned int NumParam; 
  char *v8; 
  bool v9; 
  const dvar_t *VarByName; 
  const char *v11; 
  const char *v12; 
  char inString[1024]; 
  char outString[1024]; 

  String = Scr_GetString(scrContext, 0);
  if ( !Dvar_IsValidName(String) )
  {
    UnobfuscatedName = Dvar_DevGetUnobfuscatedName(String);
    v4 = j_va("Dvar %s has an invalid dvar name", UnobfuscatedName);
    Scr_Error(COM_ERR_3989, scrContext, v4);
  }
  if ( Scr_GetType(scrContext, 1u) == VAR_ISTRING )
  {
    if ( !GScript::ms_gScriptSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.h", 183, ASSERT_TYPE_ASSERT, "( ms_gScriptSystem )", (const char *)&queryFormat, "ms_gScriptSystem") )
      __debugbreak();
    v5 = GScript::ms_gScriptSystem;
    ConstructMessageString = GScript::ms_gScriptSystem->ConstructMessageString;
    NumParam = Scr_GetNumParam(scrContext);
    ConstructMessageString(v5, scrContext, 1, NumParam - 1, "Dvar Value", inString, 1024u);
    v8 = inString;
  }
  else
  {
    v8 = (char *)Scr_GetString(scrContext, 1u);
  }
  Com_CleanStringForNetwork(v8, outString, 1024);
  v9 = Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_SLOW_SOFT_LAND|0x80);
  Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_SLOW_SOFT_LAND|0x80);
  VarByName = Dvar_FindVarByName(String);
  if ( v9 && VarByName && (VarByName->flags & 0x100) == 0 )
  {
    v11 = Dvar_DevGetUnobfuscatedName(String);
    v12 = j_va("Invalid Dvar set: %s - Internal Dvars cannot be changed by script. Use 'setsaveddvar' to alter SAVED internal dvars\n", v11);
    Scr_Error(COM_ERR_3985, scrContext, v12);
  }
  Dvar_SetFromStringByNameFromScript(SCRIPTINSTANCE_SERVER, String, outString);
}

/*
==============
GScr_SetDvarIfUninitialized
==============
*/
void GScr_SetDvarIfUninitialized(scrContext_t *scrContext)
{
  const char *String; 
  const char *Demo_VariantString; 
  const dvar_t *VarByName; 
  const char *v5; 
  bool v6; 
  unsigned int v7; 
  DvarValue current; 

  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_Error(COM_ERR_3990, scrContext, "GScr_SetDvarIfUninitialized( dvarName, initialValue ) requires two parameters");
  String = Scr_GetString(scrContext, 0);
  g_lastDvarName = String;
  if ( g_archiveGetDvar )
  {
    Demo_VariantString = SV_Game_GetDemo_VariantString(String, (const char *)&queryFormat.fmt + 3);
    goto LABEL_7;
  }
  VarByName = Dvar_FindVarByName(String);
  if ( VarByName )
  {
    current = VarByName->current;
    Demo_VariantString = Dvar_ValueToString(VarByName, &current);
LABEL_7:
    if ( *Demo_VariantString )
      return;
  }
  v5 = Scr_GetString(scrContext, 1u);
  v6 = Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_SLOW_SOFT_LAND|0x80);
  v7 = 525448;
  if ( v6 )
    v7 = -1;
  GScr_SetDvar_Internal(scrContext, String, v5, v7);
}

/*
==============
GScr_SetDevDvarIfUninitialized
==============
*/
void GScr_SetDevDvarIfUninitialized(scrContext_t *scrContext)
{
  const char *String; 
  const char *Demo_VariantString; 
  const dvar_t *VarByName; 
  const char *v5; 
  bool v6; 
  const dvar_t *v7; 
  const char *UnobfuscatedName; 
  const char *v9; 
  DvarValue current; 

  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_Error(COM_ERR_3991, scrContext, "GScr_SetDevDvarIfUninitialized( dvarName, initialValue ) requires two parameters");
  String = Scr_GetString(scrContext, 0);
  g_lastDvarName = String;
  if ( g_archiveGetDvar )
  {
    Demo_VariantString = SV_Game_GetDemo_VariantString(String, (const char *)&queryFormat.fmt + 3);
    goto LABEL_7;
  }
  VarByName = Dvar_FindVarByName(String);
  if ( VarByName )
  {
    current = VarByName->current;
    Demo_VariantString = Dvar_ValueToString(VarByName, &current);
LABEL_7:
    if ( *Demo_VariantString )
      return;
  }
  v5 = Scr_GetString(scrContext, 1u);
  v6 = Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_SLOW_SOFT_LAND|0x80);
  Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_SLOW_SOFT_LAND|0x80);
  v7 = Dvar_FindVarByName(String);
  if ( v6 && v7 && (v7->flags & 0x100) == 0 )
  {
    UnobfuscatedName = Dvar_DevGetUnobfuscatedName(String);
    v9 = j_va("Invalid Dvar set: %s - Internal Dvars cannot be changed by script. Use 'setsaveddvar' to alter SAVED internal dvars\n", UnobfuscatedName);
    Scr_Error(COM_ERR_3985, scrContext, v9);
  }
  Dvar_SetFromStringByNameFromScript(SCRIPTINSTANCE_SERVER, String, v5);
}

/*
==============
GScr_GetDvar
==============
*/
void GScr_GetDvar(scrContext_t *scrContext)
{
  const char *String; 
  unsigned int NumParam; 
  const char *v4; 
  const char *Demo_VariantString; 

  String = (char *)&queryFormat.fmt + 3;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam != 1 )
  {
    if ( NumParam != 2 )
    {
      Scr_Error(COM_ERR_3992, scrContext, "GetDvar( <dvar>, <default> ) takes either one or two parameters");
      return;
    }
    String = Scr_GetString(scrContext, 1u);
  }
  v4 = Scr_GetString(scrContext, 0);
  g_lastDvarName = v4;
  if ( g_archiveGetDvar )
    Demo_VariantString = SV_Game_GetDemo_VariantString(v4, String);
  else
    Demo_VariantString = Dvar_GetVariantStringWithDefault(v4, String);
  Scr_AddString(scrContext, Demo_VariantString);
}

/*
==============
GScr_GetDvarInt
==============
*/
void GScr_GetDvarInt(scrContext_t *scrContext)
{
  const char *String; 
  unsigned int NumParam; 
  const char *v4; 
  const char *Demo_VariantString; 
  int v6; 

  String = (char *)&queryFormat.fmt + 3;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam != 1 )
  {
    if ( NumParam != 2 )
    {
      Scr_Error(COM_ERR_3993, scrContext, "GetDvarInt( <dvar>, <default> ) takes either one or two parameters");
      return;
    }
    String = Scr_GetString(scrContext, 1u);
  }
  v4 = Scr_GetString(scrContext, 0);
  g_lastDvarName = v4;
  if ( g_archiveGetDvar )
    Demo_VariantString = SV_Game_GetDemo_VariantString(v4, String);
  else
    Demo_VariantString = Dvar_GetVariantStringWithDefault(v4, String);
  v6 = atoi(Demo_VariantString);
  Scr_AddInt(scrContext, v6);
}

/*
==============
GScr_GetGameBattleMatchReportState
==============
*/
void GScr_GetGameBattleMatchReportState(scrContext_t *scrContext)
{
  int MatchReportState; 

  MatchReportState = GameBattles_GetMatchReportState();
  Scr_AddInt(scrContext, MatchReportState);
}

/*
==============
GScr_SetGameBattlePlayerStats
==============
*/
void GScr_SetGameBattlePlayerStats(scrContext_t *scrContext)
{
  const char *String; 
  const char *v3; 
  int Int; 
  XUID result; 

  if ( Scr_GetNumParam(scrContext) == 3 )
  {
    String = Scr_GetString(scrContext, 0);
    XUID::FromHexString(&result, String);
    v3 = Scr_GetString(scrContext, 1u);
    Int = Scr_GetInt(scrContext, 2u);
    GameBattles_SetPlayerStats(&result, v3, Int);
  }
  else
  {
    Scr_Error(COM_ERR_6397, scrContext, "GScr_SetGameBattlePlayerStats( xuid, team, score ) requires 3 parameters");
  }
}

/*
==============
GScr_SetGameBattleMatchStats
==============
*/
void GScr_SetGameBattleMatchStats(scrContext_t *scrContext)
{
  const char *String; 
  const char *v3; 
  const char *v4; 
  int Int; 
  int axisScore; 
  int matchStart; 
  int matchEnd; 

  if ( Scr_GetNumParam(scrContext) == 7 )
  {
    String = Scr_GetString(scrContext, 0);
    v3 = Scr_GetString(scrContext, 1u);
    v4 = Scr_GetString(scrContext, 2u);
    Int = Scr_GetInt(scrContext, 3u);
    axisScore = Scr_GetInt(scrContext, 4u);
    matchStart = Scr_GetInt(scrContext, 5u);
    matchEnd = Scr_GetInt(scrContext, 6u);
    GameBattles_SetMatchStats(String, v3, v4, Int, axisScore, matchStart, matchEnd);
  }
  else
  {
    Scr_Error(COM_ERR_6398, scrContext, "GScr_SetGameBattleMatchStats( mapname, gametype, victor, alliesScore, axisScore, matchStart, matchEnd ) requires 7 parameters");
  }
}

/*
==============
GScr_GetDvarFloat
==============
*/
void GScr_GetDvarFloat(scrContext_t *scrContext)
{
  const char *String; 
  unsigned int NumParam; 
  const char *v5; 
  const char *Demo_VariantString; 

  String = (char *)&queryFormat.fmt + 3;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam != 1 )
  {
    if ( NumParam != 2 )
    {
      Scr_Error(COM_ERR_3994, scrContext, "GetDvarFloat( <dvar>, <default> ) takes either one or two parameters");
      return;
    }
    String = Scr_GetString(scrContext, 1u);
  }
  v5 = Scr_GetString(scrContext, 0);
  g_lastDvarName = v5;
  if ( g_archiveGetDvar )
    Demo_VariantString = SV_Game_GetDemo_VariantString(v5, String);
  else
    Demo_VariantString = Dvar_GetVariantStringWithDefault(v5, String);
  *(double *)&_XMM0 = atof(Demo_VariantString);
  __asm { vcvtsd2ss xmm1, xmm0, xmm0; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
GScr_GetDvarVector
==============
*/
void GScr_GetDvarVector(scrContext_t *scrContext)
{
  const char *String; 
  unsigned int NumParam; 
  const char *v4; 
  const char *Demo_VariantString; 
  const char *v6; 
  const char *UnobfuscatedName; 
  const char *v8; 
  vec3_t vec3Value; 

  String = "0.0 0.0 0.0";
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam != 1 )
  {
    if ( NumParam != 2 )
    {
      Scr_Error(COM_ERR_3995, scrContext, "GetDvarVector( <dvar>, <default> ) takes either one or two parameters");
      return;
    }
    String = Scr_GetString(scrContext, 1u);
  }
  v4 = Scr_GetString(scrContext, 0);
  g_lastDvarName = v4;
  if ( g_archiveGetDvar )
    Demo_VariantString = SV_Game_GetDemo_VariantString(v4, String);
  else
    Demo_VariantString = Dvar_GetVariantStringWithDefault(v4, String);
  v6 = Demo_VariantString;
  if ( !Dvar_ConvertStringToVec3(Demo_VariantString, &vec3Value) )
  {
    UnobfuscatedName = Dvar_DevGetUnobfuscatedName(v4);
    v8 = j_va("GetDvarVector: Dvar %s '%s' isn't parsable as a vector\n", UnobfuscatedName, v6);
    Scr_Error(COM_ERR_3996, scrContext, v8);
  }
  Scr_AddVector(scrContext, vec3Value.v);
}

/*
==============
GScr_GetTime
==============
*/
void GScr_GetTime(scrContext_t *scrContext)
{
  Scr_AddInt(scrContext, level.time);
}

/*
==============
Scr_GetEntByNum
==============
*/
void Scr_GetEntByNum(scrContext_t *scrContext)
{
  unsigned int Int; 
  const gentity_s *v2; 

  Int = Scr_GetInt(scrContext, 0);
  if ( Int < 0x800 )
  {
    v2 = &g_entities[Int];
    if ( G_IsEntityInUse(Int) )
      GScr_AddEntity(v2);
  }
}

/*
==============
Scr_GetWeaponModel
==============
*/
void Scr_GetWeaponModel(scrContext_t *scrContext)
{
  unsigned __int16 weaponIdx; 
  bool v3; 
  WeaponDef **v4; 
  const XModel *worldModel; 
  const char *Name; 
  const char *WeaponBaseName; 
  int v8; 
  unsigned int v9; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  weaponIdx = outWeapon.weaponIdx;
  if ( !outWeapon.weaponIdx )
    goto LABEL_11;
  if ( outWeapon.weaponIdx > bg_lastParsedWeaponIndex )
  {
    v9 = bg_lastParsedWeaponIndex;
    v8 = outWeapon.weaponIdx;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1203, ASSERT_TYPE_ASSERT, "( weaponIdx ) <= ( bg_lastParsedWeaponIndex )", "weaponIdx not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", v8, v9) )
      __debugbreak();
  }
  v3 = bg_weaponDefs[weaponIdx] == NULL;
  v4 = &bg_weaponDefs[weaponIdx];
  if ( v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1204, ASSERT_TYPE_ASSERT, "(bg_weaponDefs[weaponIdx])", (const char *)&queryFormat, "bg_weaponDefs[weaponIdx]") )
    __debugbreak();
  worldModel = (*v4)->worldModel;
  if ( !worldModel )
  {
    WeaponBaseName = BG_GetWeaponBaseName(&outWeapon, outIsAlternate);
    Com_Printf(17, "getWeaponModel: weapon '%s' does not have a world model\n", WeaponBaseName);
LABEL_11:
    Name = (char *)&queryFormat.fmt + 3;
    goto LABEL_12;
  }
  Name = XModelGetName(worldModel);
LABEL_12:
  Scr_AddString(scrContext, Name);
}

/*
==============
Scr_GetWeaponViewmodel
==============
*/
void Scr_GetWeaponViewmodel(scrContext_t *scrContext)
{
  unsigned __int16 weaponIdx; 
  const char *Name; 
  bool v4; 
  WeaponDef **v5; 
  const XModel *gunXModel; 
  const char *WeaponBaseName; 
  int v8; 
  unsigned int v9; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  weaponIdx = outWeapon.weaponIdx;
  Name = (char *)&queryFormat.fmt + 3;
  if ( outWeapon.weaponIdx )
  {
    if ( outWeapon.weaponIdx > bg_lastParsedWeaponIndex )
    {
      v9 = bg_lastParsedWeaponIndex;
      v8 = outWeapon.weaponIdx;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1203, ASSERT_TYPE_ASSERT, "( weaponIdx ) <= ( bg_lastParsedWeaponIndex )", "weaponIdx not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", v8, v9) )
        __debugbreak();
    }
    v4 = bg_weaponDefs[weaponIdx] == NULL;
    v5 = &bg_weaponDefs[weaponIdx];
    if ( v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1204, ASSERT_TYPE_ASSERT, "(bg_weaponDefs[weaponIdx])", (const char *)&queryFormat, "bg_weaponDefs[weaponIdx]") )
      __debugbreak();
    gunXModel = (*v5)->gunXModel;
    if ( !gunXModel || (Name = XModelGetName(gunXModel), !*Name) )
    {
      WeaponBaseName = BG_GetWeaponBaseName(&outWeapon, outIsAlternate);
      Com_Printf(17, "getWeaponViewmodel: weapon '%s' does not have a viewmodel\n", WeaponBaseName);
    }
  }
  Scr_AddString(scrContext, Name);
}

/*
==============
Scr_GetWeaponBaseName
==============
*/
void Scr_GetWeaponBaseName(scrContext_t *scrContext)
{
  const char *WeaponBaseName; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( outWeapon.weaponIdx )
  {
    WeaponBaseName = BG_GetWeaponBaseName(&outWeapon, outIsAlternate);
    Scr_AddString(scrContext, WeaponBaseName);
  }
  else
  {
    Scr_AddConstString(scrContext, scr_const.none);
  }
}

/*
==============
Scr_GetWeaponAttachments
==============
*/
void Scr_GetWeaponAttachments(scrContext_t *scrContext)
{
  __int64 AllWeaponAttachments; 
  WeaponAttachment **v3; 
  bool outIsAlternate; 
  Weapon outWeapon; 
  WeaponAttachment *attachments[30]; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( outWeapon.weaponIdx )
  {
    AllWeaponAttachments = BG_GetAllWeaponAttachments(&outWeapon, (const WeaponAttachment **)attachments);
    Scr_MakeArray(scrContext);
    if ( (_DWORD)AllWeaponAttachments )
    {
      v3 = attachments;
      do
      {
        if ( !*v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 3085, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
          __debugbreak();
        Scr_AddConstString(scrContext, (*v3)->internalName);
        Scr_AddArray(scrContext);
        ++v3;
        --AllWeaponAttachments;
      }
      while ( AllWeaponAttachments );
    }
  }
  else
  {
    Scr_AddUndefined(scrContext);
  }
}

/*
==============
Scr_GetWeaponAttachmentWorldModels
==============
*/
void Scr_GetWeaponAttachmentWorldModels(scrContext_t *scrContext)
{
  signed int v2; 
  __int64 i; 
  const XModel *AttachmentModel; 
  bool outIsAlternate; 
  Weapon outWeapon; 
  WeaponAttachment *attachments[30]; 
  unsigned __int8 attachmentIds[32]; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( outWeapon.weaponIdx )
  {
    Scr_MakeArray(scrContext);
    v2 = BG_GetAllWeaponAttachmentsWithIds(&outWeapon, (const WeaponAttachment **)attachments, attachmentIds) - 1;
    for ( i = v2; i >= 0; --i )
    {
      if ( !attachments[i] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 3123, ASSERT_TYPE_ASSERT, "(attachments[attachmentIndex])", (const char *)&queryFormat, "attachments[attachmentIndex]") )
        __debugbreak();
      AttachmentModel = BG_GetAttachmentModel(attachments[i], outWeapon.attachmentVariationIndices[attachmentIds[i]], 0);
      if ( AttachmentModel )
      {
        Scr_AddString(scrContext, AttachmentModel->name);
        Scr_AddArray(scrContext);
      }
    }
  }
  else
  {
    Scr_AddUndefined(scrContext);
  }
}

/*
==============
Scr_GetWeaponCamoName
==============
*/
void Scr_GetWeaponCamoName(scrContext_t *scrContext)
{
  const Camo *Camo; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( outWeapon.weaponIdx )
  {
    Camo = BG_Camo_GetCamo(outWeapon.weaponCamo);
    if ( !Camo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 3157, ASSERT_TYPE_ASSERT, "(camo)", (const char *)&queryFormat, "camo") )
      __debugbreak();
    Scr_AddConstString(scrContext, Camo->internalName);
  }
}

/*
==============
Scr_GetWeaponReticleName
==============
*/
void Scr_GetWeaponReticleName(scrContext_t *scrContext)
{
  bool outIsAlternate; 
  Weapon outWeapon; 
  char dest[8]; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( outWeapon.weaponIdx )
  {
    Com_sprintf(dest, 8ui64, "scope%d", outWeapon.scopeVariation);
    Scr_AddString(scrContext, dest);
  }
}

/*
==============
ScrCmd_WorldPointInReticle_Circle
==============
*/
void ScrCmd_WorldPointInReticle_Circle(scrContext_t *scrContext, scr_entref_t entref)
{
  int v2; 
  unsigned int entnum; 
  gentity_s *v5; 
  const char *v6; 
  double Float; 
  float v8; 
  double v9; 
  vec2_t outScreenPos; 
  vec3_t vectorValue; 
  vec3_t outOrigin; 
  tmat33_t<vec3_t> outForward; 

  v2 = 0;
  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v5 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 22579, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v5 = &g_entities[entnum];
    if ( !v5->client )
    {
      v6 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v6);
    }
  }
  Scr_GetVector(scrContext, 0, &vectorValue);
  Float = Scr_GetFloat(scrContext, 1u);
  v8 = *(float *)&Float;
  v9 = Scr_GetFloat(scrContext, 2u);
  G_Client_GetViewOrigin(&v5->client->ps, &outOrigin);
  G_Client_GetViewDirectionLinked(v5, outForward.m, &outForward.m[1], &outForward.m[2]);
  if ( (float)G_Main_WorldPointToScreenPos(&outOrigin, &outForward, v8, &vectorValue, &outScreenPos) != 0.0 )
    LOBYTE(v2) = (float)(*(float *)&v9 * *(float *)&v9) > (float)((float)(outScreenPos.v[0] * outScreenPos.v[0]) + (float)(outScreenPos.v[1] * outScreenPos.v[1]));
  Scr_AddBool(scrContext, v2);
}

/*
==============
Scr_GetWeaponHideTags
==============
*/
void Scr_GetWeaponHideTags(scrContext_t *scrContext)
{
  unsigned __int64 v2; 
  bool outIsAlternate; 
  unsigned __int64 outHideTagCount; 
  Weapon outWeapon; 
  scr_string_t value[324]; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( outWeapon.weaponIdx )
  {
    v2 = 0i64;
    outHideTagCount = 0i64;
    BG_GetWeaponExplicitHideTags(&outWeapon, outIsAlternate, 0, 0x142ui64, value, &outHideTagCount);
    Scr_MakeArray(scrContext);
    if ( outHideTagCount )
    {
      do
      {
        Scr_AddConstString(scrContext, value[v2]);
        Scr_AddArray(scrContext);
        ++v2;
      }
      while ( v2 < outHideTagCount );
    }
  }
}

/*
==============
ScrCmd_WorldPointInReticle_Rect
==============
*/
void ScrCmd_WorldPointInReticle_Rect(scrContext_t *scrContext, scr_entref_t entref)
{
  int v2; 
  unsigned int entnum; 
  gentity_s *v5; 
  const char *v6; 
  double Float; 
  float v8; 
  double v9; 
  float v10; 
  double v11; 
  vec2_t outScreenPos; 
  vec3_t vectorValue; 
  vec3_t outOrigin; 
  tmat33_t<vec3_t> outForward; 

  v2 = 0;
  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v5 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 22625, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v5 = &g_entities[entnum];
    if ( !v5->client )
    {
      v6 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v6);
    }
  }
  Scr_GetVector(scrContext, 0, &vectorValue);
  Float = Scr_GetFloat(scrContext, 1u);
  v8 = *(float *)&Float;
  v9 = Scr_GetFloat(scrContext, 2u);
  v10 = *(float *)&v9 * 0.5;
  v11 = Scr_GetFloat(scrContext, 3u);
  G_Client_GetViewOrigin(&v5->client->ps, &outOrigin);
  G_Client_GetViewDirectionLinked(v5, outForward.m, &outForward.m[1], &outForward.m[2]);
  if ( (float)G_Main_WorldPointToScreenPos(&outOrigin, &outForward, v8, &vectorValue, &outScreenPos) != 0.0 && COERCE_FLOAT(LODWORD(outScreenPos.v[0]) & _xmm) < COERCE_FLOAT(LODWORD(v10) & _xmm) && COERCE_FLOAT(LODWORD(outScreenPos.v[1]) & _xmm) < COERCE_FLOAT(COERCE_UNSIGNED_INT(*(float *)&v11 * 0.5) & _xmm) )
    v2 = 1;
  Scr_AddBool(scrContext, v2);
}

/*
==============
Scr_GetWeaponLootTable
==============
*/
void Scr_GetWeaponLootTable(scrContext_t *scrContext)
{
  __int64 weaponIdx; 
  bool v3; 
  WeaponCompleteDef **v4; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( outWeapon.weaponIdx )
  {
    weaponIdx = outWeapon.weaponIdx;
    if ( outWeapon.weaponIdx > bg_lastParsedWeaponIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1218, ASSERT_TYPE_ASSERT, "( weaponIndex ) <= ( bg_lastParsedWeaponIndex )", "weaponIndex not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", outWeapon.weaponIdx, bg_lastParsedWeaponIndex) )
      __debugbreak();
    v3 = bg_weaponCompleteDefs[weaponIdx] == NULL;
    v4 = &bg_weaponCompleteDefs[weaponIdx];
    if ( v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1219, ASSERT_TYPE_ASSERT, "(bg_weaponCompleteDefs[weaponIndex])", (const char *)&queryFormat, "bg_weaponCompleteDefs[weaponIndex]") )
      __debugbreak();
    Scr_AddString(scrContext, (*v4)->szLootTable);
  }
  else
  {
    Scr_AddUndefined(scrContext);
  }
}

/*
==============
Scr_GetWeaponVariantIndex
==============
*/
void Scr_GetWeaponVariantIndex(scrContext_t *scrContext)
{
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( outWeapon.weaponIdx && outWeapon.weaponLootId )
    Scr_AddInt(scrContext, outWeapon.weaponLootId - 1);
  else
    Scr_AddUndefined(scrContext);
}

/*
==============
ScrCmd_GetPointInBounds
==============
*/
void ScrCmd_GetPointInBounds(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  double Float; 
  float v5; 
  double v6; 
  float v7; 
  double v8; 
  vec3_t outPoint; 

  Entity = GetEntity(entref);
  Float = Scr_GetFloat(scrContext, 0);
  v5 = *(float *)&Float;
  v6 = Scr_GetFloat(scrContext, 1u);
  v7 = *(float *)&v6;
  v8 = Scr_GetFloat(scrContext, 2u);
  G_Utils_GetEntityBoundsPoint(Entity, v5, v7, *(float *)&v8, &outPoint);
  Scr_AddVector(scrContext, outPoint.v);
}

/*
==============
Scr_GetWeaponAmmoPoolName
==============
*/
void Scr_GetWeaponAmmoPoolName(scrContext_t *scrContext)
{
  GHandler *Handler; 
  const char *WeaponBaseName; 
  const char *v4; 
  bool outIsAlternate; 
  Weapon outWeapon; 
  char outAmmoName[1024]; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  Handler = GHandler::getHandler();
  if ( BG_GetWeaponAmmoPoolName(&outWeapon, outIsAlternate, Handler, outAmmoName, 0x400ui64) )
  {
    Scr_AddString(scrContext, outAmmoName);
  }
  else
  {
    WeaponBaseName = BG_GetWeaponBaseName(&outWeapon, outIsAlternate);
    v4 = j_va("unknown ammo name pool for weapon '%s' \n", WeaponBaseName);
    Scr_ParamError(COM_ERR_3997, scrContext, 0, v4);
    Scr_AddUndefined(scrContext);
  }
}

/*
==============
ScrCmd_TransferMarksToNewScriptModel
==============
*/
void ScrCmd_TransferMarksToNewScriptModel(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  __int16 scriptMoverType; 

  Entity = GetEntity(entref);
  v4 = GScr_GetEntity(0);
  if ( v4->s.eType != ET_SCRIPTMOVER )
    Scr_Error(COM_ERR_4622, scrContext, "Only script model/movers are allowed to be passed to this function.");
  scriptMoverType = v4->s.un.scriptMoverType;
  if ( scriptMoverType == 3 )
  {
    Scr_Error(COM_ERR_4623, scrContext, "Reflection probe entities are not allowed to be passed to this function.");
    scriptMoverType = v4->s.un.scriptMoverType;
  }
  if ( scriptMoverType == 4 )
  {
    Scr_Error(COM_ERR_6297, scrContext, "Server arms entities are not allowed to be passed to this function.");
    scriptMoverType = v4->s.un.scriptMoverType;
  }
  if ( scriptMoverType == 5 )
  {
    Scr_Error(COM_ERR_4624, scrContext, "Client weapon entities are not allowed to be passed to this function.");
    scriptMoverType = v4->s.un.scriptMoverType;
  }
  if ( scriptMoverType == 6 )
  {
    Scr_Error(COM_ERR_4625, scrContext, "Server weapon entities are not allowed to be passed to this function.");
    scriptMoverType = v4->s.un.scriptMoverType;
  }
  if ( scriptMoverType == 8 )
  {
    Scr_Error(COM_ERR_4626, scrContext, "Avatar entities are not allowed to be passed to this function.");
    scriptMoverType = v4->s.un.scriptMoverType;
  }
  if ( scriptMoverType == 9 )
  {
    Scr_Error(COM_ERR_5713, scrContext, "Battle Royale Circle entities are not allowed to be passed to this function.");
    scriptMoverType = v4->s.un.scriptMoverType;
  }
  if ( scriptMoverType == 10 )
    Scr_Error(COM_ERR_6075, scrContext, "Map Circle entities are not allowed to be passed to this function.");
  if ( v4->s.staticState.player.stowedWeaponHandle.m_mapEntryId )
    Scr_Error(COM_ERR_4627, scrContext, "Only non-scriptable entities are allowed to be passed to this function.");
  v4->s.lerp.u.anonymous.data[0] = Entity->s.number;
}

/*
==============
GScr_GetAnimLength
==============
*/
void GScr_GetAnimLength(scrContext_t *scrContext)
{
  int linkPointer; 
  unsigned int v3; 
  XAnim_s *Anims; 
  const char *AnimDebugName; 
  const char *v6; 
  double Length; 

  linkPointer = Scr_GetAnim(scrContext, 0, NULL).linkPointer;
  v3 = (unsigned __int16)linkPointer;
  Anims = Scr_GetAnims(scrContext, HIWORD(linkPointer));
  if ( !XAnimIsPrimitive(Anims, v3) )
  {
    AnimDebugName = XAnimGetAnimDebugName(Anims, v3);
    v6 = j_va("non-primitive animation '%s' has no concept of length", AnimDebugName);
    Scr_ParamError(COM_ERR_3998, scrContext, 0, v6);
  }
  Length = XAnimGetLength(Anims, v3);
  Scr_AddFloat(scrContext, *(float *)&Length);
}

/*
==============
GScr_AnimHasNotetrack
==============
*/
void GScr_AnimHasNotetrack(scrContext_t *scrContext)
{
  bool v2; 
  scr_string_t ConstString; 
  const XAnim_s *Anims; 
  int linkPointer; 

  v2 = 0;
  linkPointer = Scr_GetAnim(scrContext, 0, NULL).linkPointer;
  ConstString = Scr_GetConstString(scrContext, 1u);
  Anims = Scr_GetAnims(scrContext, HIWORD(linkPointer));
  if ( XAnimIsLeafNode(Anims, (unsigned __int16)linkPointer) )
    v2 = XAnimNotetrackExists(Anims, (unsigned __int16)linkPointer, ConstString);
  Scr_AddBool(scrContext, v2);
}

/*
==============
GScr_GetNotetrackTimes
==============
*/
void GScr_GetNotetrackTimes(scrContext_t *scrContext)
{
  int linkPointer; 
  unsigned __int16 v3; 
  scr_string_t ConstString; 
  const XAnim_s *Anims; 
  unsigned __int16 v6; 

  linkPointer = Scr_GetAnim(scrContext, 0, NULL).linkPointer;
  v6 = HIWORD(linkPointer);
  v3 = linkPointer;
  ConstString = Scr_GetConstString(scrContext, 1u);
  Scr_MakeArray(scrContext);
  Anims = Scr_GetAnims(scrContext, v6);
  XAnimAddNotetrackTimesToScriptArray(scrContext, Anims, v3, ConstString);
}

/*
==============
GScr_GetGlass
==============
*/
void GScr_GetGlass(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const unsigned __int16 *IndicesFromName; 
  const char *v4; 
  const char *v5; 
  unsigned int count; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4628, scrContext, "Wrong number of parameters to GetGlass( targetname )");
  ConstString = Scr_GetConstString(scrContext, 0);
  IndicesFromName = G_Glass_GetIndicesFromName(ConstString, &count);
  if ( count )
  {
    if ( count > 1 )
    {
      v4 = SL_ConvertToString(ConstString);
      v5 = j_va("GetGlass used with more than one piece of glass (\"targetname\" = \"%s\")", v4);
      Scr_Error(COM_ERR_4629, scrContext, v5);
    }
    Scr_AddInt(scrContext, *IndicesFromName);
  }
}

/*
==============
GScr_AnimIsLeaf
==============
*/
void GScr_AnimIsLeaf(scrContext_t *scrContext)
{
  int linkPointer; 
  unsigned int v3; 
  const XAnim_s *Anims; 
  int IsLeafNode; 

  linkPointer = Scr_GetAnim(scrContext, 0, NULL).linkPointer;
  v3 = (unsigned __int16)linkPointer;
  Anims = Scr_GetAnims(scrContext, HIWORD(linkPointer));
  IsLeafNode = XAnimIsLeafNode(Anims, v3);
  Scr_AddBool(scrContext, IsLeafNode != 0);
}

/*
==============
GScr_GetGlassArray
==============
*/
void GScr_GetGlassArray(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const unsigned __int16 *IndicesFromName; 
  __int64 i; 
  unsigned int count; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4630, scrContext, "Wrong number of parameters to GetGlassArray( targetname )");
  ConstString = Scr_GetConstString(scrContext, 0);
  IndicesFromName = G_Glass_GetIndicesFromName(ConstString, &count);
  Scr_MakeArray(scrContext);
  for ( i = 0i64; (unsigned int)i < count; i = (unsigned int)(i + 1) )
  {
    Scr_AddInt(scrContext, IndicesFromName[i]);
    Scr_AddArray(scrContext);
  }
}

/*
==============
GScr_GetGlassOrigin
==============
*/
void GScr_GetGlassOrigin(scrContext_t *scrContext)
{
  unsigned int Int; 
  const char *v3; 
  vec3_t outOrigin; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4631, scrContext, "Wrong number of parameters to GetGlassOrigin( glassID )");
  Int = Scr_GetInt(scrContext, 0);
  if ( !G_Glass_IsIndexValid(Int) )
  {
    v3 = j_va("Invalid glass ID %i", Int);
    Scr_ParamError(COM_ERR_4632, scrContext, 0, v3);
  }
  G_Glass_GetPieceOrigin(Int, &outOrigin);
  Scr_AddVector(scrContext, outOrigin.v);
}

/*
==============
GScr_IsGlassDestroyed
==============
*/
void GScr_IsGlassDestroyed(scrContext_t *scrContext)
{
  unsigned int Int; 
  const char *v3; 
  GlassPieceState PieceState; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4633, scrContext, "Wrong number of parameters to IsGlassDestroyed( glassID )");
  Int = Scr_GetInt(scrContext, 0);
  if ( !G_Glass_IsIndexValid(Int) )
  {
    v3 = j_va("Invalid glass ID %i", Int);
    Scr_ParamError(COM_ERR_4634, scrContext, 0, v3);
  }
  PieceState = G_Glass_GetPieceState(Int);
  Scr_AddBool(scrContext, PieceState >= GLASS_DESTROYED);
}

/*
==============
GScr_DestroyGlass
==============
*/
void GScr_DestroyGlass(scrContext_t *scrContext)
{
  unsigned int Int; 
  const char *v3; 
  vec3_t vectorValue; 
  vec3_t outOrigin; 

  if ( !Scr_GetNumParam(scrContext) && Scr_GetNumParam(scrContext) > 2 )
    Scr_Error(COM_ERR_4635, scrContext, "Wrong number of parameters to DestroyGlass( glassID, direction )");
  Int = Scr_GetInt(scrContext, 0);
  if ( !G_Glass_IsIndexValid(Int) )
  {
    v3 = j_va("Invalid glass ID %i", Int);
    Scr_ParamError(COM_ERR_4636, scrContext, 0, v3);
  }
  if ( Scr_GetNumParam(scrContext) < 2 )
  {
    vectorValue.v[0] = 0.0;
    vectorValue.v[1] = 0.0;
    vectorValue.v[2] = 0.0;
  }
  else
  {
    Scr_GetVector(scrContext, 1u, &vectorValue);
  }
  G_Glass_GetPieceOrigin(Int, &outOrigin);
  G_Glass_DestroyPiece(Int, &outOrigin, &vectorValue);
}

/*
==============
GScr_DeleteGlass
==============
*/
void GScr_DeleteGlass(scrContext_t *scrContext)
{
  unsigned int Int; 
  const char *v3; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4637, scrContext, "Wrong number of parameters to DeleteGlass( glassID )");
  Int = Scr_GetInt(scrContext, 0);
  if ( !G_Glass_IsIndexValid(Int) )
  {
    v3 = j_va("Invalid glass ID %i", Int);
    Scr_ParamError(COM_ERR_4638, scrContext, 0, v3);
  }
  G_Glass_DeletePiece(Int);
}

/*
==============
ScrCmd_IsTouching
==============
*/
void ScrCmd_IsTouching(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  const gentity_s *v4; 
  int IsTouchingInternal; 

  Entity = GetEntity(entref);
  v4 = GScr_GetEntity(0);
  IsTouchingInternal = Scr_IsTouchingInternal(scrContext, Entity, v4);
  Scr_AddInt(scrContext, IsTouchingInternal);
}

/*
==============
GScr_ResetGlass
==============
*/
void GScr_ResetGlass(scrContext_t *scrContext)
{
  const char *v1; 

  G_ResetGlass();
  v1 = j_va("%c", 60i64);
  SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v1);
}

/*
==============
ScrCmd_GetIsTouchingEntities
==============
*/
void ScrCmd_GetIsTouchingEntities(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int ArrayObject; 
  unsigned int ArraySize; 
  const char *v6; 
  const char *NameForType; 
  const char *v8; 
  const gentity_s *Entity; 
  __int64 i; 
  scr_entref_t EntityIdRef; 
  const gentity_s *v12; 
  VariableType failureType[4]; 
  unsigned int count; 
  unsigned int failureIndex; 
  unsigned int buffer[128]; 

  Sys_ProfBeginNamedEvent(0xFFFFFFFF, "GetIsTouchingEntities");
  ArrayObject = BGScr_Main_GetArrayObject(scrContext, 0);
  ArraySize = GetArraySize(scrContext, ArrayObject);
  count = ArraySize;
  if ( ArraySize > 0x80 )
  {
    v6 = j_va("array is too large (%d > %d)", ArraySize, 128i64);
    Scr_ParamError(COM_ERR_4000, scrContext, 0, v6);
  }
  if ( !Scr_GetEntityArray(scrContext, ArrayObject, 0x80u, buffer, &count, &failureIndex, failureType) )
  {
    NameForType = Scr_GetNameForType(failureType[0]);
    v8 = j_va("element %i of array: type %s is not an entity", failureIndex, NameForType);
    Scr_ParamError(COM_ERR_4001, scrContext, 0, v8);
  }
  Entity = GetEntity(entref);
  Scr_MakeArray(scrContext);
  for ( i = 0i64; (unsigned int)i < count; i = (unsigned int)(i + 1) )
  {
    EntityIdRef = Scr_GetEntityIdRef(scrContext, buffer[i]);
    v12 = GetEntity(EntityIdRef);
    if ( Scr_IsTouchingInternal(scrContext, Entity, v12) )
    {
      GScr_AddEntity(v12);
      Scr_AddArray(scrContext);
    }
  }
  Sys_ProfEndNamedEvent();
}

/*
==============
ScrCmd_SetSlowMotion
==============
*/
void ScrCmd_SetSlowMotion(scrContext_t *scrContext)
{
  float v2; 
  unsigned int v3; 
  double Float; 
  float v5; 
  double v6; 
  double v7; 
  float v8; 
  float v9; 
  double TimeScale; 
  double v11; 
  const char *v12; 

  if ( !Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_4639, scrContext, "SetSlowMotion requires at least 1 parameter.");
  v2 = FLOAT_1_0;
  v3 = 1000;
  Float = Scr_GetFloat(scrContext, 0);
  v5 = *(float *)&Float;
  if ( Scr_GetNumParam(scrContext) >= 2 )
  {
    v6 = Scr_GetFloat(scrContext, 1u);
    v2 = *(float *)&v6;
  }
  if ( Scr_GetNumParam(scrContext) >= 3 )
  {
    v7 = Scr_GetFloat(scrContext, 2u);
    v3 = (int)(float)(*(float *)&v7 * 1000.0);
  }
  if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_STILL_LAND|0x80) )
  {
    v8 = _mm_cvtepi32_ps((__m128i)v3).m128_f32[0];
    g_slowmoCommon.startTimescale = v5;
    g_slowmoCommon.endTimescale = v2;
    g_slowmoCommon.type = 0;
    v9 = 1.0 / (float)(v2 - v5);
    TimeScale = Com_GetTimeScale();
    g_slowmoCommon.startMsec = com_frameTime + (int)(float)((float)((float)(v5 - *(float *)&TimeScale) * v8) * v9);
    v11 = Com_GetTimeScale();
    g_slowmoCommon.endMsec = com_frameTime + (int)(float)((float)((float)(v2 - *(float *)&v11) * v8) * v9);
    g_slowmoCommon.enable = 1;
  }
  else
  {
    v12 = j_va("%i %i %g %g", (unsigned int)level.time, v3, v5, v2);
    SV_SetConfigstring(0x217u, v12);
  }
}

/*
==============
ScrCmd_LerpFOVByPreset
==============
*/
void ScrCmd_LerpFOVByPreset(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  _DWORD *p_commandTime; 
  const char *v6; 
  ComErrorCode v7; 
  const char *String; 
  int PresetIndex; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
LABEL_9:
    Scr_ObjectError(v7, scrContext, v6);
    p_commandTime = NULL;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 23007, ASSERT_TYPE_ASSERT, "(ps)", "%s\n\tLerpFOVByPreset can only be called on a player or agent.", "ps") )
      __debugbreak();
    goto LABEL_11;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 23005, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  p_commandTime = &v4->client->ps.commandTime;
  if ( !p_commandTime )
  {
    p_commandTime = &v4->agent->playerState.commandTime;
    if ( !p_commandTime )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
      goto LABEL_9;
    }
  }
LABEL_11:
  if ( !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_PARACHUTE_IDLE|WEAPON_OFFHAND_END) )
    Scr_Error(COM_ERR_4640, scrContext, "LerpFOVByPreset is not supported in this gamemode");
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4641, scrContext, "LerpFOVByPreset must have only one parameter.\n");
  String = Scr_GetString(scrContext, 0);
  PresetIndex = BG_FovLerp_GetPresetIndex(String);
  if ( !PresetIndex )
    Scr_Error(COM_ERR_4642, scrContext, "Invalid preset name is passed into LerpFOVByPreset.\n");
  p_commandTime[327] = PresetIndex;
}

/*
==============
ScrCmd_SoundExists
==============
*/
void ScrCmd_SoundExists(scrContext_t *scrContext)
{
  const char *String; 
  SndAliasList *Alias; 

  String = Scr_GetString(scrContext, 0);
  Alias = SND_TryFindAlias(String);
  Scr_AddBool(scrContext, Alias != NULL);
}

/*
==============
Scr_SoundIsLooping
==============
*/
void Scr_SoundIsLooping(scrContext_t *scrContext)
{
  const char *String; 
  SndAliasList *Alias; 
  SndAlias *head; 

  String = Scr_GetString(scrContext, 0);
  Alias = SND_FindAlias(String);
  if ( Alias && (head = Alias->head) != NULL )
    Scr_AddBool(scrContext, (head->flags & 3) != 0);
  else
    Scr_AddUndefined(scrContext);
}

/*
==============
ScrCmd_StopSounds
==============
*/
void ScrCmd_StopSounds(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *v4; 

  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 3607, ASSERT_TYPE_SANITY, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( Entity->s.eType >= ET_EVENTS )
  {
    v4 = j_va("StopSounds() does not support entities of type 'ET_EVENTS' [Ent #%i].", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_4002, scrContext, v4);
  }
  Entity->r.svFlags &= ~1u;
  G_Utils_AddEvent(Entity, 9u, 0);
}

/*
==============
ScrCmd_MagicGrenadeManual
==============
*/
void ScrCmd_MagicGrenadeManual(scrContext_t *scrContext)
{
  ComErrorCode v2; 
  const char *String; 
  const char *v4; 
  double Float; 
  int fuseTime; 
  gentity_s *Entity; 
  const gentity_s *v8; 
  bool outIsAlternate; 
  vec3_t dir; 
  vec3_t vectorValue; 
  Weapon outWeapon; 

  if ( Scr_GetNumParam(scrContext) < 3 || Scr_GetNumParam(scrContext) > 5 )
    Scr_Error(COM_ERR_4003, scrContext, "MagicGrenadeManual <grenade type> <origin> <velocity> [time To Blow (seconds)].\n");
  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  if ( outWeapon.weaponIdx )
  {
    Scr_GetVector(scrContext, 1u, &vectorValue);
    Scr_GetVector(scrContext, 2u, &dir);
    if ( Scr_GetNumParam(scrContext) <= 3 )
    {
      fuseTime = 5000;
    }
    else
    {
      Float = Scr_GetFloat(scrContext, 3u);
      fuseTime = (int)(float)(*(float *)&Float * 1000.0);
    }
    if ( Scr_GetNumParam(scrContext) <= 4 )
      Entity = NULL;
    else
      Entity = GScr_GetEntity(4u);
    v8 = G_Missile_FireGrenade(Entity, &vectorValue, &dir, &outWeapon, 0, WEAPON_HAND_DEFAULT, 1, fuseTime, 1, level.time);
    GScr_AddEntity(v8);
  }
  else
  {
    if ( Scr_GetType(scrContext, 0) == VAR_STRING )
    {
      v2 = COM_ERR_4004;
      String = Scr_GetString(scrContext, 0);
      v4 = j_va("\"%s\" grenade weapon is not precached", String);
    }
    else
    {
      v2 = COM_ERR_4005;
      v4 = "Invalid grenade weapon specified for MagicGrenadeManual";
    }
    Scr_ParamError(v2, scrContext, 0, v4);
  }
}

/*
==============
ScrCmd_LerpFOVScaleFactor
==============
*/
void ScrCmd_LerpFOVScaleFactor(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  const char *v8; 
  const char *v9; 
  unsigned int clientIndex; 
  SvClient *CommonClient; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 23048, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  if ( (int)Scr_GetNumParam(scrContext) < 2 )
    Scr_Error(COM_ERR_5923, scrContext, "Not enough parameters.\n");
  Scr_GetFloat(scrContext, 1u);
  _XMM0 = 0i64;
  __asm { vroundss xmm6, xmm0, xmm4, 1 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  v8 = j_va("%c %f %d", 62i64, *(float *)&_XMM0, (unsigned int)(int)*(float *)&_XMM6);
  v9 = v8;
  clientIndex = v4->client->sess.cs.clientIndex;
  if ( clientIndex == -1 )
  {
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v8);
  }
  else
  {
    CommonClient = SvClient::GetCommonClient(clientIndex);
    CommonClient->SendServerCommand(CommonClient, SV_CMD_RELIABLE, v9);
  }
}

/*
==============
GScr_GetEntChannelsCount
==============
*/
void GScr_GetEntChannelsCount(scrContext_t *scrContext)
{
  int EntChannelCount; 

  EntChannelCount = SND_GetEntChannelCount();
  Scr_AddInt(scrContext, EntChannelCount);
}

/*
==============
GScr_GetEntChannelName
==============
*/
void GScr_GetEntChannelName(scrContext_t *scrContext)
{
  unsigned int Int; 
  const char *v3; 
  const char *EntChannelName; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4643, scrContext, "Wrong number of parameters to GetEntChannelName( <index> )");
  Int = Scr_GetInt(scrContext, 0);
  if ( Int >= SND_GetEntChannelCount() )
  {
    v3 = j_va("Invalid channel index %i", Int);
    Scr_ParamError(COM_ERR_4644, scrContext, 0, v3);
  }
  EntChannelName = SND_GetEntChannelName(Int);
  Scr_AddString(scrContext, EntChannelName);
}

/*
==============
GScr_StartFiring
==============
*/
void GScr_StartFiring(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4006, scrContext, v6);
  }
  Turret = GTurret::GetTurret(p_turretHandle);
  Turret->m_data.flags |= 0x10u;
}

/*
==============
GScr_StopFiring
==============
*/
void GScr_StopFiring(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4007, scrContext, v6);
  }
  Turret = GTurret::GetTurret(p_turretHandle);
  Turret->m_data.flags &= ~0x10u;
}

/*
==============
GScr_IsFiringTurret
==============
*/
void GScr_IsFiringTurret(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  const char *v5; 
  const char *v6; 
  bool IsFiring; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4008, scrContext, v6);
  }
  IsFiring = G_Turret_IsFiring(v4);
  Scr_AddBool(scrContext, IsFiring);
}

/*
==============
GScr_DisconnectPaths
==============
*/
void GScr_DisconnectPaths(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Sys_ProfBeginNamedEvent(0xFFFFFFFF, "GScr_DisconnectPaths");
  Entity = GetEntity(entref);
  if ( GScr_Main_ValidateDisconnectPathsEnt(scrContext, Entity) )
    Path_DisconnectPathsForEntity(Entity, 0);
  Sys_ProfEndNamedEvent();
}

/*
==============
GScr_StartBarrelSpin
==============
*/
void GScr_StartBarrelSpin(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  const char *v5; 
  const char *v6; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4009, scrContext, v6);
  }
  G_Turret_SetManualSpinning(v4, 1);
}

/*
==============
GScr_ConnectPaths
==============
*/
void GScr_ConnectPaths(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Sys_ProfBeginNamedEvent(0xFFFFFFFF, "GScr_ConnectPaths");
  Entity = GetEntity(entref);
  if ( GScr_Main_ValidateDisconnectPathsEnt(scrContext, Entity) )
    Path_ConnectPathsForEntity(Entity);
  Sys_ProfEndNamedEvent();
}

/*
==============
GScr_StopBarrelSpin
==============
*/
void GScr_StopBarrelSpin(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  const char *v5; 
  const char *v6; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4010, scrContext, v6);
  }
  G_Turret_SetManualSpinning(v4, 0);
}

/*
==============
GScr_GetBarrelSpinRate
==============
*/
void GScr_GetBarrelSpinRate(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  const char *v5; 
  const char *v6; 
  double BarrelSpinRate; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4011, scrContext, v6);
  }
  BarrelSpinRate = G_Turret_GetBarrelSpinRate(v4);
  Scr_AddFloat(scrContext, *(float *)&BarrelSpinRate);
}

/*
==============
GScr_DisconnectNode
==============
*/
void GScr_DisconnectNode(scrContext_t *scrContext, scr_entref_t entref)
{
  Path_GetNodeFromEntref(scrContext, entref)->dynamic.bInactive = 1;
}

/*
==============
GScr_ConnectNode
==============
*/
void GScr_ConnectNode(scrContext_t *scrContext, scr_entref_t entref)
{
  Path_GetNodeFromEntref(scrContext, entref)->dynamic.bInactive = 0;
}

/*
==============
Scr_NodeIsDisconnected
==============
*/
void Scr_NodeIsDisconnected(scrContext_t *scrContext, scr_entref_t entref)
{
  const pathnode_t *NodeFromEntref; 
  unsigned __int16 v4; 
  bool IsNodeDisconnected; 

  NodeFromEntref = Path_GetNodeFromEntref(scrContext, entref);
  v4 = Path_ConvertNodeToIndex(NodeFromEntref);
  IsNodeDisconnected = Path_IsNodeDisconnected(v4);
  Scr_AddBool(scrContext, IsNodeDisconnected);
}

/*
==============
GScr_SetWorldUpReference
==============
*/
void GScr_SetWorldUpReference(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  const char *v5; 
  const char *v6; 
  playerState_s *EntityPlayerState; 
  const char *v8; 
  GHandler *Handler; 
  GHandler *v10; 
  gentity_s *v11; 
  const char *v12; 
  __int16 number; 
  GHandler *v14; 
  WorldUpReferenceFrame v15; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( !Entity->client )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a client, can only set world up ref on client.", v5);
    Scr_Error(COM_ERR_4013, scrContext, v6);
    return;
  }
  EntityPlayerState = G_GetEntityPlayerState(Entity);
  if ( !EntityPlayerState )
  {
    v8 = j_va("Could not get playerstate.");
    Scr_Error(COM_ERR_4014, scrContext, v8);
    return;
  }
  Handler = GHandler::getHandler();
  WorldUpReferenceFrame::WorldUpReferenceFrame(&v15, EntityPlayerState, Handler);
  if ( Scr_GetType(scrContext, 0) )
  {
    v11 = GScr_GetEntity(0);
    if ( EntityPlayerState->worldUpRefEnt == v11->s.number )
      return;
    if ( BG_IsPlayerLinked(EntityPlayerState) )
    {
      if ( !v4->tagInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 3927, ASSERT_TYPE_ASSERT, "(playerEnt->tagInfo)", (const char *)&queryFormat, "playerEnt->tagInfo") )
        __debugbreak();
      if ( !v4->tagInfo->parent->s.number && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 3928, ASSERT_TYPE_ASSERT, "(playerEnt->tagInfo->parent->s.number)", (const char *)&queryFormat, "playerEnt->tagInfo->parent->s.number") )
        __debugbreak();
      if ( !GUtils::AreEntsInSameLinkTree(v11, v4) )
      {
        v12 = j_va("Setting the world up while linked is only allowed if the world up ent is in the same hierarchy as the linked parent. entNum = %d", (unsigned int)v11->s.number);
        Scr_Error(COM_ERR_4015, scrContext, v12);
      }
      WorldUpReferenceFrame::SetEntity(&v15, EntityPlayerState, v11->s.number);
      v4->c.item[0].weapon.attachmentVariationIndices[19] = 1;
    }
    else
    {
      number = v11->s.number;
      v14 = GHandler::getHandler();
      WorldUpReferenceFrame::SetEntityAndNormalizeViewAngles(&v15, EntityPlayerState, v14, number);
    }
    v11->r.svFlags &= ~1u;
    v11->s.lerp.eFlags.m_flags[0] ^= 4u;
  }
  else
  {
    if ( !WorldUpReferenceFrame::HasValidWorldUpEnt(EntityPlayerState) )
      return;
    if ( BG_IsPlayerLinked(EntityPlayerState) )
    {
      WorldUpReferenceFrame::SetEntity(&v15, EntityPlayerState, 0);
    }
    else
    {
      v10 = GHandler::getHandler();
      WorldUpReferenceFrame::SetEntityAndNormalizeViewAngles(&v15, EntityPlayerState, v10, 0);
    }
  }
  G_ValidateWorldUpIsSafe(scrContext, v4);
}

/*
==============
Scr_NodeIsActivated
==============
*/
void Scr_NodeIsActivated(scrContext_t *scrContext, scr_entref_t entref)
{
  pathnode_t *NodeFromEntref; 

  NodeFromEntref = Path_GetNodeFromEntref(scrContext, entref);
  Scr_AddBool(scrContext, NodeFromEntref->dynamic.bInactive == 0);
}

/*
==============
GScr_DisconnectNodePair
==============
*/
void GScr_DisconnectNodePair(scrContext_t *scrContext)
{
  Scr_Error(COM_ERR_4647, scrContext, "DisconnectNodePair() functionality not currently supported.  Similar functionality will be provided for links in the near future.");
}

/*
==============
GScr_ConnectNodePair
==============
*/
void GScr_ConnectNodePair(scrContext_t *scrContext)
{
  Scr_Error(COM_ERR_4648, scrContext, "ConnectNodePair() functionality not currently supported.  Similar functionality will be provided for links in the near future.");
}

/*
==============
Scr_BadPlace_Delete
==============
*/
void Scr_BadPlace_Delete(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  scr_string_t v3; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    if ( *Scr_GetString(scrContext, 0) )
    {
      ConstString = Scr_GetConstString(scrContext, 0);
      Path_RemoveBadPlace(ConstString);
    }
    else
    {
      Scr_Error(COM_ERR_4650, scrContext, "badplace_delete called with name \"\"");
    }
    v3 = Scr_GetConstString(scrContext, 0);
    Nav_DestroyRepulsorByName(v3);
  }
  else
  {
    Scr_Error(COM_ERR_4649, scrContext, "Incorrect number of parameters\n");
  }
}

/*
==============
GScr_TeleportWorldUpReferenceAngles
==============
*/
void GScr_TeleportWorldUpReferenceAngles(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *v4; 
  const char *v5; 
  gentity_s *v6; 
  playerState_s *EntityPlayerState; 
  const char *v8; 
  GHandler *Handler; 
  GUtils *Utils; 
  vec3_t inOutViewAngles; 
  vec3_t vectorValue; 
  vec3_t angles; 
  tmat33_t<vec3_t> axis; 
  tmat33_t<vec3_t> in; 
  tmat33_t<vec3_t> out; 
  tmat33_t<vec3_t> v17; 
  WorldUpReferenceFrame v18; 

  Entity = GetEntity(entref);
  Sys_ProfBeginNamedEvent(0xFFFF0000, "GScr_TeleportWorldUpReferenceAngles");
  if ( Entity->client )
  {
    v6 = GScr_GetEntity(0);
    Scr_GetVector(scrContext, 1u, &vectorValue);
    EntityPlayerState = G_GetEntityPlayerState(Entity);
    if ( EntityPlayerState )
    {
      Handler = GHandler::getHandler();
      WorldUpReferenceFrame::WorldUpReferenceFrame(&v18, EntityPlayerState, Handler);
      G_SetAngle(v6, &vectorValue, 1, 1);
      v6->r.svFlags &= ~1u;
      v6->s.lerp.eFlags.m_flags[0] ^= 4u;
      inOutViewAngles = EntityPlayerState->viewangles;
      BG_CalcLinkedViewValues(EntityPlayerState, &inOutViewAngles);
      AnglesToAxis(&inOutViewAngles, &axis);
      WorldUpReferenceFrame::ApplyReferenceFrameToAxis(&v18, &axis);
      AnglesToAxis(&v6->r.currentAngles, &in);
      MatrixTranspose(&in, &out);
      MatrixMultiply(&axis, &out, &v17);
      AxisToAngles(&v17, &angles);
      Utils = GUtils::GetUtils();
      Utils->SetPlayerViewAngles(Utils, Entity, &angles);
      Sys_ProfEndNamedEvent();
      G_ValidateWorldUpIsSafe(scrContext, Entity);
    }
    else
    {
      v8 = j_va("Could not get playerstate.");
      Scr_Error(COM_ERR_4017, scrContext, v8);
      Sys_ProfEndNamedEvent();
    }
  }
  else
  {
    v4 = SL_ConvertToString(Entity->classname);
    v5 = j_va("entity type '%s' is not a client, can only teleport world up ref on client.", v4);
    Scr_Error(COM_ERR_4016, scrContext, v5);
    Sys_ProfEndNamedEvent();
  }
}

/*
==============
GScr_SetWorldUpReferenceAngles
==============
*/
void GScr_SetWorldUpReferenceAngles(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  playerState_s *p_ps; 
  const char *v6; 
  const char *v7; 
  GHandler *Handler; 
  int Int; 
  bool v10; 
  GHandler *v11; 
  GHandler *v12; 
  GWeaponMap *Instance; 
  vec3_t vectorValue; 
  WorldUpReferenceFrame refFrame; 

  Entity = GetEntity(entref);
  v4 = Entity;
  p_ps = &Entity->client->ps;
  if ( !p_ps )
  {
    v6 = SL_ConvertToString(Entity->classname);
    v7 = j_va("SetWorldUpReferenceAngles for %s can only be called on a client.", v6);
    Scr_Error(COM_ERR_4018, scrContext, v7);
    return;
  }
  Handler = GHandler::getHandler();
  WorldUpReferenceFrame::WorldUpReferenceFrame(&refFrame, p_ps, Handler);
  Scr_GetVector(scrContext, 0, &vectorValue);
  if ( Scr_GetNumParam(scrContext) < 2 )
  {
    v10 = 1;
  }
  else
  {
    Int = Scr_GetInt(scrContext, 1u);
    v10 = Int != 0;
    if ( !Int )
    {
LABEL_5:
      v11 = GHandler::getHandler();
      WorldUpReferenceFrame::SetAngles(&refFrame, p_ps, v11, &vectorValue);
      goto LABEL_6;
    }
  }
  if ( !BG_IsPlayerZeroG(p_ps) )
    goto LABEL_5;
  v12 = GHandler::getHandler();
  Instance = GWeaponMap::GetInstance();
  PM_ZeroGravity_SetWorldUpAngles(p_ps, Instance, &refFrame, v12, &vectorValue);
LABEL_6:
  if ( v10 )
    G_ValidateWorldUpIsSafe(scrContext, v4);
}

/*
==============
Scr_BadPlace_Cylinder
==============
*/
void Scr_BadPlace_Cylinder(scrContext_t *scrContext)
{
  unsigned int v2; 
  scr_string_t name; 
  int v6; 
  double Float; 
  bitarray<224> *p_result; 
  bitarray<224> *AllCombatTeamFlags; 
  int usageFlags; 
  nav_space_s *MostLikelySpace; 
  const char *v12; 
  vec3_t vectorValue; 
  bitarray<224> result; 

  v2 = 0;
  if ( Scr_GetType(scrContext, 0) && *Scr_GetString(scrContext, 0) )
    name = Scr_GetConstString(scrContext, 0);
  else
    name = 0;
  Scr_GetFloat(scrContext, 1u);
  _XMM0 = 0i64;
  __asm { vroundss xmm4, xmm0, xmm3, 2 }
  v6 = (int)*(float *)&_XMM4;
  Scr_GetVector(scrContext, 2u, &vectorValue);
  Float = Scr_GetFloat(scrContext, 3u);
  Scr_GetTeamFlags(&result, scrContext, 5u);
  p_result = &result;
  while ( !p_result->array[0] )
  {
    ++v2;
    p_result = (bitarray<224> *)((char *)p_result + 4);
    if ( v2 >= 7 )
    {
      if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_WEAPON_DROP|0x80) )
        AllCombatTeamFlags = (bitarray<224> *)Com_TeamsSP_GetAllCombatTeamFlags();
      else
        AllCombatTeamFlags = (bitarray<224> *)Com_TeamsMP_GetAllTeamFlags();
      result = *AllCombatTeamFlags;
      break;
    }
  }
  usageFlags = Nav_TranslateTeamFlagsToRepulsorUsageFlags(&result);
  MostLikelySpace = Nav_FindMostLikelySpace(&vectorValue, NAV_LAYER_HUMAN, NULL);
  if ( MostLikelySpace )
  {
    if ( !Nav_CreateRepulsor(MostLikelySpace, &vectorValue, &vec3_origin, v6, *(float *)&Float, 2047, usageFlags, name, 1) )
    {
      v12 = j_va("BadPlace: Unable to allocate repulsor.  Exceeded max (%d)?", 256i64);
      Scr_Error(COM_ERR_4651, scrContext, v12);
    }
  }
}

/*
==============
GScr_GetWorldUpReferenceAngles
==============
*/
void GScr_GetWorldUpReferenceAngles(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const playerState_s *p_ps; 
  const char *v5; 
  const char *v6; 
  GHandler *Handler; 
  vec3_t outAngles; 
  WorldUpReferenceFrame v9; 

  Entity = GetEntity(entref);
  p_ps = &Entity->client->ps;
  if ( p_ps )
  {
    Handler = GHandler::getHandler();
    WorldUpReferenceFrame::WorldUpReferenceFrame(&v9, p_ps, Handler);
    WorldUpReferenceFrame::GetAngles(&v9, &outAngles);
    Scr_AddVector(scrContext, outAngles.v);
  }
  else
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("GetWorldUpReferenceAngles for %s can only be called on a client.", v5);
    Scr_Error(COM_ERR_4019, scrContext, v6);
  }
}

/*
==============
GScr_NormalizeWorldUpReferenceAngles
==============
*/
void GScr_NormalizeWorldUpReferenceAngles(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  const char *v5; 
  const char *v6; 
  GHandler *Handler; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( Entity->client )
  {
    Handler = GHandler::getHandler();
    BG_NormalizeWorldUpReferenceAngles(&v4->client->ps, Handler);
  }
  else
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("GetWorldUpReferenceAngles for %s can only be called on a client.", v5);
    Scr_Error(COM_ERR_4020, scrContext, v6);
  }
}

/*
==============
GScr_Turret_Shoot
==============
*/
void GScr_Turret_Shoot(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  gentity_s *v5; 
  const char *v6; 
  const char *v7; 
  scr_string_t ConstString; 

  Entity = GetEntity(entref);
  Int = 0;
  v5 = Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v6 = SL_ConvertToString(Entity->classname);
    v7 = j_va("entity type '%s' is not a turret", v6);
    Scr_Error(COM_ERR_4021, scrContext, v7);
  }
  if ( Scr_GetNumParam(scrContext) && Scr_GetType(scrContext, 0) )
    ConstString = Scr_GetConstString(scrContext, 0);
  else
    ConstString = scr_const.tag_aim;
  if ( Scr_GetNumParam(scrContext) > 1 )
    Int = Scr_GetInt(scrContext, 1u);
  G_Turret_ScrShoot(v5, ConstString, Int);
}

/*
==============
Scr_BadPlace_Global
==============
*/
void Scr_BadPlace_Global(scrContext_t *scrContext)
{
  unsigned int v2; 
  int v3; 
  scr_string_t ConstString; 
  int v7; 
  unsigned int v8; 
  bitarray<224> *p_result; 
  const bitarray<224> *AllCombatTeamFlags; 
  __int128 v11; 
  double v12; 
  unsigned int v13; 
  unsigned int v14; 
  bitarray<224> result; 

  v2 = 2;
  if ( !Com_GameMode_SupportsFeature(WEAPON_RAISING_ALTSWITCH) )
    Scr_Error(COM_ERR_4652, scrContext, "Global bad place system must be active to use this function");
  if ( Scr_GetNumParam(scrContext) < 2 )
    Scr_Error(COM_ERR_4653, scrContext, "Incorrect BadPlace_Global() call.");
  v3 = 0;
  if ( *Scr_GetString(scrContext, 0) )
    ConstString = Scr_GetConstString(scrContext, 0);
  else
    ConstString = 0;
  Scr_GetFloat(scrContext, 1u);
  _XMM0 = 0i64;
  __asm { vroundss xmm4, xmm0, xmm3, 2 }
  v7 = (int)*(float *)&_XMM4;
  Scr_GetTeamFlags(&result, scrContext, 2u);
  v8 = 0;
  p_result = &result;
  do
  {
    if ( p_result->array[0] )
    {
      v13 = result.array[6];
      v12 = *(double *)&result.array[4];
      v11 = *(_OWORD *)result.array;
      goto LABEL_16;
    }
    ++v8;
    p_result = (bitarray<224> *)((char *)p_result + 4);
  }
  while ( v8 < 7 );
  if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_WEAPON_DROP|0x80) )
    AllCombatTeamFlags = Com_TeamsSP_GetAllCombatTeamFlags();
  else
    AllCombatTeamFlags = Com_TeamsMP_GetAllTeamFlags();
  v11 = *(_OWORD *)AllCombatTeamFlags->array;
  v12 = *(double *)&AllCombatTeamFlags->array[4];
  v13 = AllCombatTeamFlags->array[6];
  *(_OWORD *)result.array = *(_OWORD *)AllCombatTeamFlags->array;
LABEL_16:
  if ( !Com_GameMode_SupportsFeature(WEAPON_RAISING_ALTSWITCH) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 23450, ASSERT_TYPE_ASSERT, "( G_Bot_UseBadPlaceRestrictions() )", (const char *)&queryFormat, "G_Bot_UseBadPlaceRestrictions()") )
    __debugbreak();
  if ( !Com_GameMode_SupportsFeature(WEAPON_RAISING_ALTSWITCH) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 23340, ASSERT_TYPE_ASSERT, "( G_Bot_UseBadPlaceRestrictions() )", (const char *)&queryFormat, "G_Bot_UseBadPlaceRestrictions()") )
    __debugbreak();
  if ( !Path_UsePathExtraData() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 23341, ASSERT_TYPE_ASSERT, "( Path_UsePathExtraData() )", (const char *)&queryFormat, "Path_UsePathExtraData()") )
    __debugbreak();
  v14 = v11;
  result.array[0] = v11;
  if ( (int)v11 < 0 && Scr_GetNumParam(scrContext) > 2 )
  {
    do
    {
      if ( Scr_GetConstString(scrContext, v2) == scr_const.only_sky )
      {
        v3 |= 1u;
        v14 &= ~0x80000000;
      }
      ++v2;
    }
    while ( v2 < Scr_GetNumParam(scrContext) );
    result.array[0] = v14;
    v11 = *(_OWORD *)result.array;
  }
  result.array[6] = v13;
  *(_OWORD *)result.array = v11;
  *(double *)&result.array[4] = v12;
  if ( !Path_MakeGlobalBadPlace(ConstString, v7, &result, v3) )
    Scr_Error(COM_ERR_4654, scrContext, "Error creating BadPlace, see log for details");
}

/*
==============
GScr_GetOwnedVehicle
==============
*/
void GScr_GetOwnedVehicle(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  int *p_commandTime; 
  const char *v7; 
  __int64 v8; 
  EntHandle *p_ownerNum; 
  const gentity_s *v10; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3678, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 4188, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client && !v4->agent )
    {
      v5 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3677, scrContext, v5);
    }
  }
  p_commandTime = &v4->client->ps.commandTime;
  if ( !p_commandTime )
  {
    p_commandTime = &v4->agent->playerState.commandTime;
    if ( !p_commandTime )
    {
      v7 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3679, scrContext, v7);
    }
  }
  if ( GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal((GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *)p_commandTime + 94, ACTIVE, 0xBu) )
  {
    v8 = p_commandTime[72];
    if ( (_DWORD)v8 != 2047 )
      goto LABEL_20;
  }
  p_ownerNum = &v4->r.ownerNum;
  if ( EntHandle::isDefined(p_ownerNum) && EntHandle::ent(p_ownerNum)->vehicle )
  {
    v10 = EntHandle::ent(p_ownerNum);
    GScr_AddEntity(v10);
    return;
  }
  if ( GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal((GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64> *)(p_commandTime + 5), ACTIVE, 0x1Cu) )
  {
    LOWORD(v8) = *((_WORD *)p_commandTime + 78);
    if ( (_WORD)v8 != 2047 )
    {
      v8 = (__int16)v8;
LABEL_20:
      GScr_AddEntity(&g_entities[v8]);
      return;
    }
  }
  Scr_AddUndefined(scrContext);
}

/*
==============
GScr_Turret_GetOwner
==============
*/
void GScr_Turret_GetOwner(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  const char *v5; 
  const char *v6; 
  const gentity_s *v7; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4022, scrContext, v6);
  }
  if ( v4->active )
  {
    if ( EntHandle::isDefined(&v4->r.ownerNum) )
    {
      v7 = EntHandle::ent(&v4->r.ownerNum);
      GScr_AddEntity(v7);
    }
    else
    {
      GScr_AddEntity(g_entities + 2047);
    }
  }
}

/*
==============
GScr_Turret_SetSentryOwner
==============
*/
void GScr_Turret_SetSentryOwner(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  const char *v5; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  const gentity_s *v9; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4023, scrContext, v6);
  }
  if ( (GTurret::GetTurret(&v4->turretHandle)->m_data.flags & 0xC) == 0 )
  {
    v7 = j_va("turret number '%i' is not auto or sentry", (unsigned int)v4->s.number);
    Scr_Error(COM_ERR_4024, scrContext, v7);
  }
  if ( Scr_GetType(scrContext, 0) )
  {
    v9 = GScr_GetEntity(0);
    if ( !G_Utils_IsClientOrActor(v9) )
      Scr_ParamError(COM_ERR_4026, scrContext, 0, "turrets can only be owned by clients or actors");
  }
  else
  {
    if ( v4->s.staticState.player.stowedWeaponHandle.m_mapEntryId != 2047 )
    {
      v8 = j_va("turret number '%i' is being carried and cannot have its owner cleared.", (unsigned int)v4->s.number);
      Scr_Error(COM_ERR_4025, scrContext, v8);
    }
    v9 = NULL;
  }
  G_Turret_SetSentryOwner(v4, v9);
}

/*
==============
Scr_HaveMapEntsEffects
==============
*/
void Scr_HaveMapEntsEffects(scrContext_t *scrContext)
{
  Scr_AddBool(scrContext, cm.mapEnts->createFxEffectTotal != 0);
}

/*
==============
GScr_Turret_SetTurretOwner
==============
*/
void GScr_Turret_SetTurretOwner(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  const char *v5; 
  const char *v6; 
  const char *v7; 
  const gentity_s *v8; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4027, scrContext, v6);
  }
  if ( Scr_GetType(scrContext, 0) )
  {
    v8 = GScr_GetEntity(0);
    if ( !G_Utils_IsClientOrActor(v8) )
      Scr_ParamError(COM_ERR_4029, scrContext, 0, "turrets can only be owned by clients or actors");
  }
  else
  {
    if ( v4->s.staticState.player.stowedWeaponHandle.m_mapEntryId != 2047 )
    {
      v7 = j_va("turret number '%i' is being carried and cannot have its owner cleared.", (unsigned int)v4->s.number);
      Scr_Error(COM_ERR_4028, scrContext, v7);
    }
    v8 = NULL;
  }
  G_Turret_SetSentryOwner(v4, v8);
}

/*
==============
GScr_Turret_SetSentryCarrier
==============
*/
void GScr_Turret_SetSentryCarrier(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  const char *v5; 
  const char *v6; 
  const char *v7; 
  const gentity_s *v8; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4030, scrContext, v6);
  }
  if ( (GTurret::GetTurret(&v4->turretHandle)->m_data.flags & 8) == 0 )
  {
    v7 = j_va("turret number '%i' is not a sentry", (unsigned int)v4->s.number);
    Scr_Error(COM_ERR_4031, scrContext, v7);
  }
  if ( Scr_GetType(scrContext, 0) )
  {
    v8 = GScr_GetEntity(0);
    if ( !G_Utils_IsClientOrActor(v8) )
      Scr_ParamError(COM_ERR_4032, scrContext, 0, "turrets can only be carried by clients or actors");
  }
  else
  {
    v8 = NULL;
  }
  G_Turret_ScrSetSentryCarrier(v4, v8);
}

/*
==============
GScr_Turret_SetMinimapVisible
==============
*/
void GScr_Turret_SetMinimapVisible(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *v4; 
  const char *v5; 
  const char *v6; 
  unsigned int Int; 
  const char *String; 
  GTurret *Turret; 

  Entity = GetEntity(entref);
  v4 = (const BgObjectHandle<GTurret> *)Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4033, scrContext, v6);
  }
  Int = Scr_GetInt(scrContext, 0);
  if ( Scr_GetNumParam(scrContext) < 2 )
    String = NULL;
  else
    String = Scr_GetString(scrContext, 1u);
  Turret = GTurret::GetTurret(v4 + 94);
  Turret->SetMinimapVisible(Turret, (gentity_s *)v4, Int, String);
}

/*
==============
GScr_Turret_SetTargetEntity
==============
*/
void GScr_Turret_SetTargetEntity(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 
  const gentity_s *v8; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4034, scrContext, v6);
  }
  Turret = GTurret::GetTurret(p_turretHandle);
  v8 = GScr_GetEntity(0);
  EntHandle::setEnt(&Turret->m_data.manualTarget, v8);
  if ( Scr_GetNumParam(scrContext) <= 1 )
  {
    *(_QWORD *)Turret->m_data.manualTargetOffset.v = 0i64;
    Turret->m_data.manualTargetOffset.v[2] = 0.0;
  }
  else
  {
    Scr_GetVector(scrContext, 1u, &Turret->m_data.manualTargetOffset);
  }
}

/*
==============
Scr_ActivateClientExploder
==============
*/
void Scr_ActivateClientExploder(scrContext_t *scrContext)
{
  gentity_s *v2; 
  __int64 v3; 
  unsigned int ArrayObject; 
  unsigned int ArraySize; 
  int maxclients; 
  const char *NameForType; 
  const char *v8; 
  scr_entref_t EntityIdRef; 
  gentity_s *Entity; 
  gentity_s *v11; 
  const char *v12; 
  int time; 
  unsigned int *failureIndex; 
  VariableType failureType[4]; 
  unsigned int count; 
  unsigned int v19; 
  unsigned int outExploderID; 
  unsigned int buffer[200]; 

  if ( !Com_GameMode_SupportsFeature(WEAPON_RECHAMBERING) )
    Scr_Error(COM_ERR_4657, scrContext, "ActivateClientExploder is not supported in this game mode");
  if ( !Scr_GetNumParam(scrContext) || Scr_GetNumParam(scrContext) > 3 )
    Scr_Error(COM_ERR_6562, scrContext, "Incorrect number of parameters: ActivateClientExploder( exploder_num, <optional_player>, <optional_startTime> )\n");
  if ( Scr_GetExploderID(scrContext, &outExploderID) )
  {
    v2 = G_Utils_SpawnEventEntity(&vec3_origin, 195);
    if ( !v2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 23600, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
      __debugbreak();
    if ( v2->s.lerp.apos.trType && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 23601, ASSERT_TYPE_SANITY, "( ent->s.lerp.apos.trType == TR_STATIONARY )", (const char *)&queryFormat, "ent->s.lerp.apos.trType == TR_STATIONARY") )
      __debugbreak();
    if ( Scr_GetNumParam(scrContext) >= 2 && Scr_GetType(scrContext, 1u) )
    {
      v3 = 0i64;
      count = 0;
      GScr_Main_ClientmaskSetAllHidden(v2);
      if ( Scr_GetType(scrContext, 1u) == VAR_POINTER && Scr_GetPointerType(scrContext, 1u) == VAR_ARRAY )
      {
        ArrayObject = BGScr_Main_GetArrayObject(scrContext, 1u);
        ArraySize = GetArraySize(scrContext, ArrayObject);
        maxclients = level.maxclients;
        count = ArraySize;
        if ( level.maxclients < 1 || (unsigned __int64)level.maxclients > 0xC8 )
        {
          LODWORD(failureIndex) = level.maxclients;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 23613, ASSERT_TYPE_ASSERT, "( 1 ) <= ( level.maxclients ) && ( level.maxclients ) <= ( ( sizeof( *array_counter( entities ) ) + 0 ) )", "level.maxclients not in [1, ARRAY_COUNT( entities )]\n\t%i not in [%i, %i]", failureIndex, 1, 200) )
            __debugbreak();
          maxclients = level.maxclients;
        }
        if ( !Scr_GetEntityArray(scrContext, ArrayObject, maxclients, buffer, &count, &v19, failureType) )
        {
          NameForType = Scr_GetNameForType(failureType[0]);
          v8 = j_va("element %i of array: type %s is not an entity", v19, NameForType);
          Scr_ParamError(COM_ERR_6563, scrContext, 0, v8);
        }
      }
      else if ( Scr_GetType(scrContext, 1u) == VAR_POINTER && Scr_GetPointerType(scrContext, 1u) == VAR_ENTITY )
      {
        count = 1;
        buffer[0] = Scr_GetObject(scrContext, 1u);
      }
      if ( count )
      {
        do
        {
          EntityIdRef = Scr_GetEntityIdRef(scrContext, buffer[v3]);
          Entity = GetEntity(EntityIdRef);
          v11 = Entity;
          if ( !Entity->client )
          {
            v12 = j_va("entity %i is not a player", (unsigned int)Entity->s.number);
            Scr_ObjectError(COM_ERR_6564, scrContext, v12);
          }
          GScr_Main_ClientmaskSetFlagVisible(v2, v11->s.number);
          v3 = (unsigned int)(v3 + 1);
        }
        while ( (unsigned int)v3 < count );
      }
    }
    v2->s.eventParm = outExploderID;
    if ( Scr_GetNumParam(scrContext) == 3 && Scr_GetType(scrContext, 2u) )
    {
      Scr_GetFloat(scrContext, 2u);
      _XMM0 = 0i64;
      __asm { vroundss xmm1, xmm0, xmm4, 1 }
      time = (int)*(float *)&_XMM1;
    }
    else
    {
      time = level.time;
    }
    v2->s.time2 = time;
  }
}

/*
==============
GScr_Turret_GetTargetEntity
==============
*/
void GScr_Turret_GetTargetEntity(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 
  const gentity_s *v8; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4035, scrContext, v6);
  }
  Turret = GTurret::GetTurret(p_turretHandle);
  if ( !Scr_GetNumParam(scrContext) || !Scr_GetInt(scrContext, 0) || (Turret->m_data.flags & 0x20) != 0 )
  {
    if ( EntHandle::isDefined(&Turret->m_data.manualTarget) )
    {
      v8 = EntHandle::ent(&Turret->m_data.manualTarget);
      GScr_AddEntity(v8);
    }
  }
}

/*
==============
GScr_Turret_SnapToTargetEntity
==============
*/
void GScr_Turret_SnapToTargetEntity(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 
  const gentity_s *v8; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4036, scrContext, v6);
  }
  Turret = GTurret::GetTurret(&v4->turretHandle);
  v8 = GScr_GetEntity(0);
  EntHandle::setEnt(&Turret->m_data.manualTarget, v8);
  if ( Scr_GetNumParam(scrContext) <= 1 )
  {
    *(_QWORD *)Turret->m_data.manualTargetOffset.v = 0i64;
    Turret->m_data.manualTargetOffset.v[2] = 0.0;
  }
  else
  {
    Scr_GetVector(scrContext, 1u, &Turret->m_data.manualTargetOffset);
    if ( (LODWORD(Turret->m_data.manualTargetOffset.v[0]) & 0x7F800000) == 2139095040 || (LODWORD(Turret->m_data.manualTargetOffset.v[1]) & 0x7F800000) == 2139095040 || (LODWORD(Turret->m_data.manualTargetOffset.v[2]) & 0x7F800000) == 2139095040 )
      Scr_ParamError(COM_ERR_4037, scrContext, 1u, "Vector target offset has NAN");
  }
  G_Turret_ScrSnapToTarget(scrContext, v4);
}

/*
==============
GScr_Turret_ClearTarget
==============
*/
void GScr_Turret_ClearTarget(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4038, scrContext, v6);
  }
  Turret = GTurret::GetTurret(p_turretHandle);
  EntHandle::setEnt(&Turret->m_data.manualTarget, NULL);
}

/*
==============
GScr_Turret_GetTarget
==============
*/
void GScr_Turret_GetTarget(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 
  const gentity_s *v8; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4039, scrContext, v6);
  }
  Turret = GTurret::GetTurret(p_turretHandle);
  if ( !Scr_GetInt(scrContext, 0) || (Turret->m_data.flags & 0x20) != 0 )
  {
    if ( EntHandle::isDefined(&Turret->m_data.target) )
    {
      v8 = EntHandle::ent(&Turret->m_data.target);
      GScr_AddEntity(v8);
    }
  }
}

/*
==============
GScr_Turret_GetTurretWeaponInfo
==============
*/
void GScr_Turret_GetTurretWeaponInfo(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const entityState_t *p_s; 
  const Weapon *WeaponForEntity; 
  GWeaponMap *Instance; 

  Entity = GetEntity(entref);
  p_s = &Entity->s;
  if ( Entity->turretHandle.m_objIndex || Entity->vehicle )
  {
    Instance = GWeaponMap::GetInstance();
    WeaponForEntity = BG_GetWeaponForEntity(Instance, p_s);
  }
  else
  {
    WeaponForEntity = &NULL_WEAPON;
  }
  GScr_Weapon_AddParam(scrContext, WeaponForEntity, 0);
}

/*
==============
GScr_Turret_SetPlayerSpread
==============
*/
void GScr_Turret_SetPlayerSpread(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 
  double Float; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4040, scrContext, v6);
  }
  Turret = GTurret::GetTurret(p_turretHandle);
  Float = Scr_GetFloat(scrContext, 0);
  Turret->m_data.playerSpread = *(float *)&Float;
}

/*
==============
Scr_StopClientExploder
==============
*/
void Scr_StopClientExploder(scrContext_t *scrContext)
{
  int Int; 
  int v3; 
  gentity_s *v4; 
  int maxclients; 
  __int64 v6; 
  unsigned int ArrayObject; 
  const char *NameForType; 
  const char *v9; 
  scr_entref_t EntityIdRef; 
  gentity_s *Entity; 
  gentity_s *v12; 
  const char *v13; 
  VariableType failureType[4]; 
  unsigned int count; 
  unsigned int failureIndex; 
  unsigned int outExploderID; 
  unsigned int buffer[200]; 

  if ( !Com_GameMode_SupportsFeature(WEAPON_RECHAMBERING) )
    Scr_Error(COM_ERR_4661, scrContext, "StopClientExploder is not supported in this game mode");
  if ( !Scr_GetNumParam(scrContext) || Scr_GetNumParam(scrContext) > 3 )
    Scr_Error(COM_ERR_4662, scrContext, "Incorrect number of parameters: StopClientExploder( exploder_num, <optional_player>, <optional_kill> )\n");
  if ( Scr_GetExploderID(scrContext, &outExploderID) )
  {
    if ( Scr_GetNumParam(scrContext) < 3 || Scr_GetType(scrContext, 2u) == VAR_UNDEFINED || (Int = Scr_GetInt(scrContext, 2u), v3 = 197, !Int) )
      v3 = 196;
    v4 = G_Utils_SpawnEventEntity(&vec3_origin, v3);
    if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 23690, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
      __debugbreak();
    if ( v4->s.lerp.apos.trType && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 23691, ASSERT_TYPE_SANITY, "( ent->s.lerp.apos.trType == TR_STATIONARY )", (const char *)&queryFormat, "ent->s.lerp.apos.trType == TR_STATIONARY") )
      __debugbreak();
    if ( Scr_GetNumParam(scrContext) >= 2 && Scr_GetType(scrContext, 1u) )
    {
      GScr_Main_ClientmaskSetAllHidden(v4);
      if ( level.maxclients > 200 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 23700, ASSERT_TYPE_ASSERT, "( level.maxclients <= ((1 >= 200) ? 1 : 200) )", (const char *)&queryFormat, "level.maxclients <= MAX_CLIENTS_STATIC") )
        __debugbreak();
      maxclients = level.maxclients;
      v6 = 0i64;
      count = 0;
      if ( Scr_GetType(scrContext, 1u) == VAR_POINTER )
      {
        if ( Scr_GetPointerType(scrContext, 1u) == VAR_ARRAY )
        {
          ArrayObject = BGScr_Main_GetArrayObject(scrContext, 1u);
          count = GetArraySize(scrContext, ArrayObject);
          if ( !Scr_GetEntityArray(scrContext, ArrayObject, maxclients, buffer, &count, &failureIndex, failureType) )
          {
            NameForType = Scr_GetNameForType(failureType[0]);
            v9 = j_va("element %u of array: type %s is not an entity", failureIndex, NameForType);
            Scr_ParamError(COM_ERR_4655, scrContext, 1u, v9);
          }
        }
        else if ( Scr_GetPointerType(scrContext, 1u) == VAR_ENTITY )
        {
          count = 1;
          if ( !maxclients && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 23487, ASSERT_TYPE_ASSERT, "( entBufferSize >= 1 )", (const char *)&queryFormat, "entBufferSize >= 1") )
            __debugbreak();
          buffer[0] = Scr_GetObject(scrContext, 1u);
        }
      }
      if ( count )
      {
        do
        {
          EntityIdRef = Scr_GetEntityIdRef(scrContext, buffer[v6]);
          Entity = GetEntity(EntityIdRef);
          v12 = Entity;
          if ( !Entity->client )
          {
            v13 = j_va("entity %i is not a player", (unsigned int)Entity->s.number);
            Scr_ObjectError(COM_ERR_4663, scrContext, v13);
          }
          GScr_Main_ClientmaskSetFlagVisible(v4, v12->s.number);
          v6 = (unsigned int)(v6 + 1);
        }
        while ( (unsigned int)v6 < count );
      }
    }
    v4->s.eventParm = outExploderID;
  }
}

/*
==============
GScr_Turret_SetConvergenceTime
==============
*/
void GScr_Turret_SetConvergenceTime(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 
  __int64 v7; 
  const char *String; 
  __int64 v9; 
  char v10; 
  __int64 v11; 
  char v12; 
  GTurret *Turret; 
  double Float; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4041, scrContext, v6);
  }
  v7 = 1i64;
  if ( (int)Scr_GetNumParam(scrContext) > 1 )
  {
    String = Scr_GetString(scrContext, 1u);
    v9 = 0i64;
    while ( 1 )
    {
      v10 = String[v9++];
      if ( v10 != aYaw[v9 - 1] )
        break;
      if ( v9 == 4 )
        goto LABEL_13;
    }
    v11 = 0i64;
    while ( 1 )
    {
      v12 = String[v11++];
      if ( v12 != aPitch[v11 - 1] )
        break;
      if ( v11 == 6 )
      {
        v7 = 0i64;
        goto LABEL_13;
      }
    }
    Scr_Error(COM_ERR_4042, scrContext, "Convergence type should be either 'pitch' or 'yaw'");
  }
LABEL_13:
  Turret = GTurret::GetTurret(p_turretHandle);
  Float = Scr_GetFloat(scrContext, 0);
  Turret->m_data.convergenceTime[v7] = (int)(float)(*(float *)&Float * 1000.0);
}

/*
==============
GScr_Turret_SetConvergenceHeightPercent
==============
*/
void GScr_Turret_SetConvergenceHeightPercent(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v6; 
  const char *v7; 
  double Float; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v6 = SL_ConvertToString(Entity->classname);
    v7 = j_va("entity type '%s' is not a turret", v6);
    Scr_Error(COM_ERR_4043, scrContext, v7);
  }
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4044, scrContext, "expecting one float argument");
  Float = Scr_GetFloat(scrContext, 0);
  if ( *(float *)&Float < 0.0 || *(float *)&Float > 1.0 )
    Scr_ParamError(COM_ERR_4045, scrContext, 0, "<scaler> must between 0 and 1 inclusive");
  if ( *(float *)&Float < 0.0 || *(float *)&Float > 1.0 )
  {
    __asm { vxorpd  xmm1, xmm1, xmm1 }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 4681, ASSERT_TYPE_ASSERT, "( 0.f ) <= ( percent ) && ( percent ) <= ( 1.f )", "percent not in [0.f, 1.f]\n\t%g not in [%g, %g]", *(float *)&Float, *(double *)&_XMM1, DOUBLE_1_0) )
      __debugbreak();
  }
  GTurret::GetTurret(p_turretHandle)->m_data.convergenceHeightPercent = *(float *)&Float;
}

/*
==============
Scr_TrajectoryCalculateInitialVelocity
==============
*/
void Scr_TrajectoryCalculateInitialVelocity(scrContext_t *scrContext)
{
  double Float; 
  vec3_t returnVector; 
  vec3_t gravityVector; 
  vec3_t endPos; 
  vec3_t vectorValue; 

  returnVector.v[0] = 0.0;
  returnVector.v[1] = 0.0;
  returnVector.v[2] = 0.0;
  if ( Scr_GetNumParam(scrContext) == 4 )
  {
    Scr_GetVector(scrContext, 0, &vectorValue);
    Scr_GetVector(scrContext, 1u, &endPos);
    Scr_GetVector(scrContext, 2u, &gravityVector);
    Float = Scr_GetFloat(scrContext, 3u);
    TrajectoryCalculateInitialVelocity(&vectorValue, &endPos, &gravityVector, *(const float *)&Float, &returnVector);
  }
  else
  {
    Scr_Error(COM_ERR_4664, scrContext, "Wrong number of parameters to TrajectoryCalculateInitialVelocity()!");
  }
  Scr_AddVector(scrContext, returnVector.v);
}

/*
==============
Scr_TrajectoryCalculateMinimumVelocity
==============
*/
void Scr_TrajectoryCalculateMinimumVelocity(scrContext_t *scrContext)
{
  float v2; 
  double Float; 
  double v4; 
  vec3_t endPos; 
  vec3_t vectorValue; 

  v2 = 0.0;
  if ( Scr_GetNumParam(scrContext) == 3 )
  {
    Scr_GetVector(scrContext, 0, &vectorValue);
    Scr_GetVector(scrContext, 1u, &endPos);
    Float = Scr_GetFloat(scrContext, 2u);
    v4 = TrajectoryCalculateMinimumVelocity(&vectorValue, &endPos, *(const float *)&Float);
    v2 = *(float *)&v4;
  }
  else
  {
    Scr_Error(COM_ERR_4665, scrContext, "Wrong number of parameters to TrajectoryCalculateMinimumVelocity()!");
  }
  Scr_AddFloat(scrContext, v2);
}

/*
==============
GScr_Turret_SetTeam
==============
*/
void GScr_Turret_SetTeam(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 
  scr_string_t ConstString; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4046, scrContext, v6);
  }
  Turret = GTurret::GetTurret(p_turretHandle);
  ConstString = Scr_GetConstString(scrContext, 0);
  Turret->ScrSetTeam(Turret, scrContext, ConstString);
}

/*
==============
Scr_TrajectoryCalculateExitAngle
==============
*/
void Scr_TrajectoryCalculateExitAngle(scrContext_t *scrContext)
{
  float v2; 
  double Float; 
  float v4; 
  double v5; 
  float v6; 
  double v7; 
  float v8; 
  double v9; 
  double v10; 

  v2 = 0.0;
  if ( Scr_GetNumParam(scrContext) == 4 )
  {
    Float = Scr_GetFloat(scrContext, 0);
    v4 = *(float *)&Float;
    v5 = Scr_GetFloat(scrContext, 1u);
    v6 = *(float *)&v5;
    v7 = Scr_GetFloat(scrContext, 2u);
    v8 = *(float *)&v7;
    v9 = Scr_GetFloat(scrContext, 3u);
    v10 = TrajectoryCalculateExitAngle(v4, v6, v8, *(const float *)&v9);
    v2 = *(float *)&v10;
  }
  else
  {
    Scr_Error(COM_ERR_4666, scrContext, "Wrong number of parameters to TrajectoryCalculateExitAngle()!");
  }
  Scr_AddFloat(scrContext, v2);
}

/*
==============
GScr_Turret_MakeOperable
==============
*/
void GScr_Turret_MakeOperable(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4047, scrContext, v6);
  }
  Turret = GTurret::GetTurret(p_turretHandle);
  Turret->m_data.flags &= ~0x200u;
}

/*
==============
Scr_TrajectoryEstimateDesiredInAirTime
==============
*/
void Scr_TrajectoryEstimateDesiredInAirTime(scrContext_t *scrContext)
{
  float v2; 
  double Float; 
  float v4; 
  double v5; 
  double v6; 
  vec3_t endPos; 
  vec3_t vectorValue; 

  v2 = 0.0;
  if ( Scr_GetNumParam(scrContext) == 4 )
  {
    Scr_GetVector(scrContext, 0, &vectorValue);
    Scr_GetVector(scrContext, 1u, &endPos);
    Float = Scr_GetFloat(scrContext, 2u);
    v4 = *(float *)&Float;
    v5 = Scr_GetFloat(scrContext, 3u);
    v6 = TrajectoryEstimateDesiredInAirTime(&vectorValue, &endPos, v4, *(const float *)&v5);
    v2 = *(float *)&v6;
  }
  else
  {
    Scr_Error(COM_ERR_4667, scrContext, "Wrong number of parameters to TrajectoryEstimateDesiredInAirTime()!");
  }
  Scr_AddFloat(scrContext, v2);
}

/*
==============
GScr_Turret_MakeInoperable
==============
*/
void GScr_Turret_MakeInoperable(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4048, scrContext, v6);
  }
  Turret = GTurret::GetTurret(p_turretHandle);
  Turret->m_data.flags |= 0x200u;
}

/*
==============
GScr_Turret_IsInoperable
==============
*/
void GScr_Turret_IsInoperable(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_5916, scrContext, v6);
  }
  Turret = GTurret::GetTurret(p_turretHandle);
  Scr_AddBool(scrContext, ((unsigned int)Turret->m_data.flags >> 9) & 1);
}

/*
==============
Scr_TrajectoryComputeDeltaHeightAtTime
==============
*/
void Scr_TrajectoryComputeDeltaHeightAtTime(scrContext_t *scrContext)
{
  float v2; 
  double Float; 
  float v4; 
  double v5; 
  float v6; 
  double v7; 
  double v8; 

  v2 = 0.0;
  if ( Scr_GetNumParam(scrContext) == 3 )
  {
    Float = Scr_GetFloat(scrContext, 0);
    v4 = *(float *)&Float;
    v5 = Scr_GetFloat(scrContext, 1u);
    v6 = *(float *)&v5;
    v7 = Scr_GetFloat(scrContext, 2u);
    v8 = TrajectoryComputeDeltaHeightAtTime(v4, v6, *(const float *)&v7);
    v2 = *(float *)&v8;
  }
  else
  {
    Scr_Error(COM_ERR_4668, scrContext, "Wrong number of parameters to TrajectoryComputeDeltaHeightAtTime()!");
  }
  Scr_AddFloat(scrContext, v2);
}

/*
==============
GScr_Turret_GetRightArc
==============
*/
void GScr_Turret_GetRightArc(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_5917, scrContext, v6);
  }
  Turret = GTurret::GetTurret(p_turretHandle);
  Scr_AddFloat(scrContext, COERCE_FLOAT(LODWORD(Turret->m_data.arcmin.v[1]) ^ _xmm));
}

/*
==============
Scr_TrajectoryCanAttemptAccurateJump
==============
*/
void Scr_TrajectoryCanAttemptAccurateJump(scrContext_t *scrContext)
{
  int v2; 
  double Float; 
  float v4; 
  double v5; 
  vec3_t toNormal; 
  vec3_t toPoint; 
  vec3_t fromNormal; 
  vec3_t vectorValue; 
  PathJumpLinkWorkData workData; 

  v2 = 0;
  if ( Scr_GetNumParam(scrContext) == 6 )
  {
    Scr_GetVector(scrContext, 0, &vectorValue);
    Scr_GetVector(scrContext, 1u, &fromNormal);
    Scr_GetVector(scrContext, 2u, &toPoint);
    Scr_GetVector(scrContext, 3u, &toNormal);
    Float = Scr_GetFloat(scrContext, 4u);
    v4 = *(float *)&Float;
    v5 = Scr_GetFloat(scrContext, 5u);
    if ( Path_TrajectoryCanAttemptAccurateJump(&vectorValue, &fromNormal, &toPoint, &toNormal, v4, *(float *)&v5, &workData) )
      v2 = 1;
  }
  else
  {
    Scr_Error(COM_ERR_4669, scrContext, "Wrong number of parameters to TrajectoryCanAttemptAccurateJump()!");
  }
  Scr_AddBool(scrContext, v2);
}

/*
==============
GScr_Turret_SetRightArc
==============
*/
void GScr_Turret_SetRightArc(scrContext_t *scrContext, scr_entref_t entref)
{
  BgObjectHandle<GTurret> *p_turretHandle; 
  GTurret *Turret; 
  double Float; 

  p_turretHandle = &GetEntity(entref)->turretHandle;
  if ( !p_turretHandle->m_objIndex )
    Scr_Error(COM_ERR_4049, scrContext, "entity is not a turret");
  Turret = GTurret::GetTurret(p_turretHandle);
  Float = Scr_GetFloat(scrContext, 0);
  Turret->m_data.arcmin.v[1] = COERCE_FLOAT(LODWORD(Float) ^ _xmm);
  if ( COERCE_FLOAT(LODWORD(Float) ^ _xmm) > 0.0 )
    Turret->m_data.arcmin.v[1] = 0.0;
}

/*
==============
GScr_Turret_GetLeftArc
==============
*/
void GScr_Turret_GetLeftArc(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_5716, scrContext, v6);
  }
  Turret = GTurret::GetTurret(p_turretHandle);
  Scr_AddFloat(scrContext, Turret->m_data.arcmax.v[1]);
}

/*
==============
GScr_Turret_SetLeftArc
==============
*/
void GScr_Turret_SetLeftArc(scrContext_t *scrContext, scr_entref_t entref)
{
  BgObjectHandle<GTurret> *p_turretHandle; 
  GTurret *Turret; 
  double Float; 

  p_turretHandle = &GetEntity(entref)->turretHandle;
  if ( !p_turretHandle->m_objIndex )
    Scr_Error(COM_ERR_4050, scrContext, "entity is not a turret");
  Turret = GTurret::GetTurret(p_turretHandle);
  Float = Scr_GetFloat(scrContext, 0);
  Turret->m_data.arcmax.v[1] = *(float *)&Float;
  if ( *(float *)&Float < 0.0 )
    Turret->m_data.arcmax.v[1] = 0.0;
}

/*
==============
GScr_drawSoundShape
==============
*/
void GScr_drawSoundShape(scrContext_t *scrContext)
{
  const char *String; 
  double Float; 
  SndAliasList *Alias; 
  SndAliasList *v5; 
  SndAlias *head; 
  const OcclusionShape *OcclusionShapeById; 
  const char *v8; 
  int v9; 
  char v10; 
  char v11; 
  float distMax; 
  double v13; 
  float v14; 
  double v15; 
  vec4_t color; 
  vec3_t v17; 
  vec3_t angles; 
  vec3_t vectorValue; 

  if ( Scr_GetNumParam(scrContext) != 5 )
    Scr_Error(COM_ERR_4670, scrContext, "illegal call to drawSoundShape()");
  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &angles);
  String = Scr_GetString(scrContext, 2u);
  Scr_GetVector(scrContext, 3u, &v17);
  color.xyz = v17;
  Float = Scr_GetFloat(scrContext, 4u);
  color.v[3] = *(float *)&Float;
  if ( String )
  {
    if ( *String )
    {
      Alias = SND_TryFindAlias(String);
      v5 = Alias;
      if ( Alias )
      {
        if ( Alias->count )
        {
          head = Alias->head;
          if ( head )
          {
            OcclusionShapeById = SND_GetOcclusionShapeById(head->occlusionShape);
            if ( OcclusionShapeById )
            {
              v8 = "default";
              v9 = 5381;
              v10 = 100;
              do
              {
                ++v8;
                v11 = v10 | 0x20;
                if ( (unsigned int)(v10 - 65) >= 0x1A )
                  v11 = v10;
                v9 = 65599 * v9 + v11;
                v10 = *v8;
              }
              while ( *v8 );
              if ( !v9 )
                v9 = 1;
              if ( OcclusionShapeById->id != v9 )
              {
                distMax = v5->head->distMax;
                v13 = I_fclamp(OcclusionShapeById->outerAngleVolume, -90.0, 90.0);
                Scr_DrawCone(&vectorValue, &angles, *(float *)&v13, distMax, &color);
                color.v[0] = 0.5 * color.v[0];
                color.v[1] = 0.5 * color.v[1];
                color.v[2] = 0.5 * color.v[2];
                v14 = v5->head->distMax;
                v15 = I_fclamp(OcclusionShapeById->innerAngleVolume, -90.0, 90.0);
                Scr_DrawCone(&vectorValue, &angles, *(float *)&v15, v14, &color);
              }
            }
          }
        }
      }
    }
  }
}

/*
==============
GScr_Turret_GetTopArc
==============
*/
void GScr_Turret_GetTopArc(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_5717, scrContext, v6);
  }
  Turret = GTurret::GetTurret(p_turretHandle);
  Scr_AddFloat(scrContext, COERCE_FLOAT(LODWORD(Turret->m_data.arcmin.v[0]) ^ _xmm));
}

/*
==============
GScr_Turret_SetTopArc
==============
*/
void GScr_Turret_SetTopArc(scrContext_t *scrContext, scr_entref_t entref)
{
  BgObjectHandle<GTurret> *p_turretHandle; 
  GTurret *Turret; 
  double Float; 

  p_turretHandle = &GetEntity(entref)->turretHandle;
  if ( !p_turretHandle->m_objIndex )
    Scr_Error(COM_ERR_4051, scrContext, "entity is not a turret");
  Turret = GTurret::GetTurret(p_turretHandle);
  Float = Scr_GetFloat(scrContext, 0);
  Turret->m_data.arcmin.v[0] = COERCE_FLOAT(LODWORD(Float) ^ _xmm);
  if ( COERCE_FLOAT(LODWORD(Float) ^ _xmm) > 0.0 )
    Turret->m_data.arcmin.v[0] = 0.0;
}

/*
==============
GScr_SendScriptUsageAnalysisData
==============
*/
void GScr_SendScriptUsageAnalysisData(scrContext_t *scrContext)
{
  int Int; 
  ScriptInstanceType v3; 

  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_Error(COM_ERR_4671, scrContext, "sendScriptUsageAnalysisData: Must have two int parameters. First indicates report to log, the second to black box server.");
  if ( script_usage_tracking && script_usage_tracking->current.integer )
  {
    Int = Scr_GetInt(scrContext, 0);
    v3 = g_reportScriptContextUsage;
    if ( Int )
      v3 = SCRIPTINSTANCE_SERVER;
    g_reportScriptContextUsage = v3;
    if ( Scr_GetInt(scrContext, 1u) )
      Scr_ScriptProfilePrintUsageReportToBlackBox(scrContext);
  }
}

/*
==============
GScr_Turret_GetBottomArc
==============
*/
void GScr_Turret_GetBottomArc(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_5718, scrContext, v6);
  }
  Turret = GTurret::GetTurret(p_turretHandle);
  Scr_AddFloat(scrContext, Turret->m_data.arcmax.v[0]);
}

/*
==============
GScr_ResetScriptUsageAnalysisData
==============
*/

void __fastcall GScr_ResetScriptUsageAnalysisData(scrContext_t *scrContext)
{
  Scr_ScriptProfileResetUsageReport(scrContext);
}

/*
==============
GScr_InstantlyLogUsageAnalysisData
==============
*/
void GScr_InstantlyLogUsageAnalysisData(scrContext_t *scrContext)
{
  Scr_CalcScriptProfileTrackServerTime(scrContext);
  Profile_TrackUsageAnalysis(scrContext, 0.0, 1);
  Scr_ScriptProfilePrintUsageReportToLog(scrContext);
}

/*
==============
GScr_Turret_SetBottomArc
==============
*/
void GScr_Turret_SetBottomArc(scrContext_t *scrContext, scr_entref_t entref)
{
  BgObjectHandle<GTurret> *p_turretHandle; 
  GTurret *Turret; 
  double Float; 

  p_turretHandle = &GetEntity(entref)->turretHandle;
  if ( !p_turretHandle->m_objIndex )
    Scr_Error(COM_ERR_4052, scrContext, "entity is not a turret");
  Turret = GTurret::GetTurret(p_turretHandle);
  Float = Scr_GetFloat(scrContext, 0);
  Turret->m_data.arcmax.v[0] = *(float *)&Float;
  if ( *(float *)&Float < 0.0 )
    Turret->m_data.arcmax.v[0] = 0.0;
}

/*
==============
Scr_GetEnt
==============
*/
void Scr_GetEnt(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const char *String; 
  int Offset; 

  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_Error(COM_ERR_4672, scrContext, "GetEnt() requires two arguments (name, key)");
  ConstString = Scr_GetConstString(scrContext, 0);
  String = Scr_GetString(scrContext, 1u);
  Offset = Scr_GetOffset(scrContext, ENTITY_CLASS_GENTITY, String);
  if ( Offset >= 0 )
  {
    if ( (Offset & 0xE000) != 0 )
      Scr_ParamError(COM_ERR_4673, scrContext, 1u, "GetEnt() key must be a generic entity key");
    else
      Scr_GetGenericEnt(scrContext, Offset, String, ConstString, 0, "GetEnt()");
  }
}

/*
==============
GScr_Turret_SetAutoRotationDelay
==============
*/
void GScr_Turret_SetAutoRotationDelay(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  double Float; 

  Entity = GetEntity(entref);
  if ( !Entity->turretHandle.m_objIndex )
    Scr_Error(COM_ERR_4053, scrContext, "entity is not a turret");
  Float = Scr_GetFloat(scrContext, 0);
  if ( *(float *)&Float < 0.0 )
    Scr_Error(COM_ERR_4054, scrContext, "need a positive duration");
  _XMM0 = 0i64;
  __asm { vroundss xmm4, xmm0, xmm3, 1 }
  G_Turret_SetAutoRotationStopDelay(Entity, (int)*(float *)&_XMM4);
}

/*
==============
GScr_Turret_SetDefaultDropPitch
==============
*/
void GScr_Turret_SetDefaultDropPitch(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  double Float; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4055, scrContext, "illegal call to setdefaultdroppitch()");
  Entity = GetEntity(entref);
  if ( !Entity->turretHandle.m_objIndex )
    Scr_Error(COM_ERR_4056, scrContext, "entity is not a turret");
  Float = Scr_GetFloat(scrContext, 0);
  G_Turret_SetDefaultDropPitch(Entity, *(float *)&Float);
}

/*
==============
GScr_Turret_RestoreDefaultDropPitch
==============
*/
void GScr_Turret_RestoreDefaultDropPitch(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  if ( Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_4057, scrContext, "illegal call to restoredefaultdroppitch()");
  Entity = GetEntity(entref);
  if ( Entity->turretHandle.m_objIndex )
    G_Turret_RestoreDefaultDropPitch(Entity);
  else
    Scr_Error(COM_ERR_4058, scrContext, "entity is not a turret");
}

/*
==============
GScr_Turret_GetCurrentYaw
==============
*/
void GScr_Turret_GetCurrentYaw(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  const char *v5; 
  const char *v6; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_5719, scrContext, v6);
  }
  Scr_AddFloat(scrContext, v4->s.lerp.u.turret.gunAngles.v[1]);
}

/*
==============
Scr_GetEntArray
==============
*/
void Scr_GetEntArray(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const char *String; 
  int Offset; 
  const char *v5; 
  ComErrorCode v6; 

  if ( !Scr_GetNumParam(scrContext) )
  {
    Scr_GetGenericEntArray(scrContext, 0);
    return;
  }
  ConstString = Scr_GetConstString(scrContext, 0);
  String = Scr_GetString(scrContext, 1u);
  Offset = Scr_GetOffset(scrContext, ENTITY_CLASS_GENTITY, String);
  if ( Offset >= 0 )
  {
    if ( (Offset & 0xE000) == 0 )
    {
      Scr_GetGenericEntArray(scrContext, Offset, ConstString, 0);
      return;
    }
    v5 = j_va("key '%s' does not internally belong to generic entities", String);
    v6 = COM_ERR_4678;
  }
  else
  {
    v5 = j_va("key '%s' does not internally belong to entities", String);
    v6 = COM_ERR_4677;
  }
  Scr_ParamError(v6, scrContext, 1u, v5);
}

/*
==============
GScr_Turret_GetCurrentPitch
==============
*/
void GScr_Turret_GetCurrentPitch(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  const char *v5; 
  const char *v6; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_5720, scrContext, v6);
  }
  Scr_AddFloat(scrContext, v4->s.lerp.u.turret.gunAngles.v[0]);
}

/*
==============
Scr_GetEntArrayInRadius
==============
*/
void Scr_GetEntArrayInRadius(scrContext_t *scrContext)
{
  Scr_GetEntArrayInRadius_Internal(scrContext, 0);
}

/*
==============
GScr_Turret_OverheatDisable
==============
*/
void GScr_Turret_OverheatDisable(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 
  int Int; 
  unsigned int v9; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_5721, scrContext, v6);
  }
  Turret = GTurret::GetTurret(p_turretHandle);
  Int = Scr_GetInt(scrContext, 0);
  v9 = Turret->m_data.flags & 0xEFFFFFFF;
  if ( Int )
    v9 = Turret->m_data.flags | 0x10000000;
  Turret->m_data.flags = v9;
}

/*
==============
GScr_GetScriptableArray
==============
*/
void GScr_GetScriptableArray(scrContext_t *scrContext)
{
  scr_string_t ConstLowercaseString; 
  const char *String; 
  int Offset; 
  const char *v5; 

  if ( Scr_GetNumParam(scrContext) )
  {
    ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
    String = Scr_GetString(scrContext, 1u);
    Offset = Scr_GetOffset(scrContext, ENTITY_CLASS_GENTITY, String);
    if ( Offset >= 0 )
    {
      if ( (Offset & 0xE000) == 0 )
        Scr_GetGenericEntArray(scrContext, Offset, ConstLowercaseString, 1);
    }
    else
    {
      v5 = j_va("key '%s' does not internally belong to scriptables", String);
      Scr_ParamError(COM_ERR_4679, scrContext, 1u, v5);
    }
  }
  else
  {
    Scr_GetGenericEntArray(scrContext, 1);
  }
}

/*
==============
GScr_Turret_IsOverheatDisabled
==============
*/
void GScr_Turret_IsOverheatDisabled(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_5722, scrContext, v6);
  }
  Turret = GTurret::GetTurret(p_turretHandle);
  Scr_AddBool(scrContext, ((unsigned int)Turret->m_data.flags >> 28) & 1);
}

/*
==============
GScr_GetScriptableArrayInRadius
==============
*/
void GScr_GetScriptableArrayInRadius(scrContext_t *scrContext)
{
  Scr_GetEntArrayInRadius_Internal(scrContext, 1);
}

/*
==============
GScr_Turret_FireDisable
==============
*/
void GScr_Turret_FireDisable(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *v4; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 

  Entity = GetEntity(entref);
  v4 = (const BgObjectHandle<GTurret> *)Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4059, scrContext, v6);
  }
  Turret = GTurret::GetTurret(v4 + 94);
  Turret->m_data.flags |= 2u;
  if ( Com_GameMode_SupportsFeature(WEAPON_DROPPING_LADDER_CLIMB) )
  {
    if ( !Com_GameMode_SupportsFeature(WEAPON_DROPPING_LADDER_CLIMB) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2135, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::TURRET_REMOTE_CONTROL ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::TURRET_REMOTE_CONTROL )") )
      __debugbreak();
    v4[27].m_objIndex |= 0x40u;
  }
}

/*
==============
GScr_Turret_FireEnable
==============
*/
void GScr_Turret_FireEnable(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *v4; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 

  Entity = GetEntity(entref);
  v4 = (const BgObjectHandle<GTurret> *)Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4060, scrContext, v6);
  }
  Turret = GTurret::GetTurret(v4 + 94);
  Turret->m_data.flags &= ~2u;
  if ( Com_GameMode_SupportsFeature(WEAPON_DROPPING_LADDER_CLIMB) )
  {
    if ( !Com_GameMode_SupportsFeature(WEAPON_DROPPING_LADDER_CLIMB) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2144, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::TURRET_REMOTE_CONTROL ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::TURRET_REMOTE_CONTROL )") )
      __debugbreak();
    v4[27].m_objIndex &= ~0x40u;
  }
}

/*
==============
GScr_Turret_SetBarrelSpinEnabled
==============
*/
void GScr_Turret_SetBarrelSpinEnabled(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v6; 
  const char *v7; 
  GTurret *Turret; 
  int Int; 
  unsigned int v10; 

  if ( !Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_4061, scrContext, "Missing parameter: turret TurretSetBarrelSpinEnabled( <enabled> );");
  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v6 = SL_ConvertToString(Entity->classname);
    v7 = j_va("In TurretSetBarrelSpinEnabled: entity type '%s' is not a turret", v6);
    Scr_Error(COM_ERR_4062, scrContext, v7);
  }
  Turret = GTurret::GetTurret(p_turretHandle);
  Int = Scr_GetInt(scrContext, 0);
  v10 = Turret->m_data.flags | 0x2000;
  if ( Int )
    v10 = Turret->m_data.flags & 0xFFFFDFFF;
  Turret->m_data.flags = v10;
}

/*
==============
GScr_Turret_CanTarget
==============
*/
void GScr_Turret_CanTarget(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const gentity_s *v4; 
  const char *v5; 
  const char *v6; 
  bool CanTargetPoint; 
  vec3_t vectorValue; 
  vec2_t out_localAngles; 
  vec3_t out_sourcePosition; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4063, scrContext, v6);
  }
  Scr_GetVector(scrContext, 0, &vectorValue);
  CanTargetPoint = G_Turret_CanTargetPoint(v4, &vectorValue, &out_sourcePosition, &out_localAngles);
  Scr_AddInt(scrContext, CanTargetPoint);
}

/*
==============
GScr_GetEntitylessScriptableArray
==============
*/
void GScr_GetEntitylessScriptableArray(scrContext_t *scrContext)
{
  GetScriptableArray_Internal(scrContext, GScr_Scriptable_GetEntitylessScriptableArray);
}

/*
==============
GScr_GetLootScriptableArray
==============
*/
void GScr_GetLootScriptableArray(scrContext_t *scrContext)
{
  GetScriptableArray_Internal(scrContext, GScr_Scriptable_GetLootScriptableArray);
}

/*
==============
GScr_GetLootScriptableArrayInRadius
==============
*/
void GScr_GetLootScriptableArrayInRadius(scrContext_t *scrContext)
{
  GetScriptableArray_Internal(scrContext, GScr_Scriptable_GetLootScriptableArray);
}

/*
==============
GScr_Scriptable_GetScriptableInstanceFromIndex
==============
*/
void GScr_Scriptable_GetScriptableInstanceFromIndex(scrContext_t *scrContext)
{
  unsigned int Int; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    Int = Scr_GetInt(scrContext, 0);
    if ( ScriptableSv_GetInstanceInUse(Int) )
    {
      ScriptableCommon_AssertCountsInitialized();
      if ( Int <= g_scriptableWorldCounts.serverInstanceCount )
        Scr_AddEntityNum(scrContext, Int, ENTITY_CLASS_SCRIPTABLE);
      else
        Scr_Error(COM_ERR_5960, scrContext, "GetScriptableInstanceFromIndex requires a valid loot scriptable index to be passed in.");
    }
    else
    {
      Scr_AddUndefined(scrContext);
    }
  }
  else
  {
    Scr_Error(COM_ERR_5959, scrContext, "GetScriptableInstanceFromIndex requires an index to be passed in.");
  }
}

/*
==============
GScr_Turret_SetModeChangeWait
==============
*/
void GScr_Turret_SetModeChangeWait(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const BgObjectHandle<GTurret> *p_turretHandle; 
  const char *v5; 
  const char *v6; 
  GTurret *Turret; 
  int Int; 
  unsigned int v9; 

  Entity = GetEntity(entref);
  p_turretHandle = &Entity->turretHandle;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_4064, scrContext, v6);
  }
  Turret = GTurret::GetTurret(p_turretHandle);
  Int = Scr_GetInt(scrContext, 0);
  v9 = Turret->m_data.flags & 0xFFFFBFFF;
  if ( Int )
    v9 = Turret->m_data.flags | 0x4000;
  Turret->m_data.flags = v9;
}

/*
==============
GScr_SpawnScriptable
==============
*/
void GScr_SpawnScriptable(scrContext_t *scrContext)
{
  const char *String; 
  unsigned int Int; 
  const char *v4; 
  ComErrorCode v5; 
  unsigned int outInstanceIndex; 
  vec3_t angles; 
  vec3_t vectorValue; 

  String = Scr_GetString(scrContext, 0);
  Scr_GetVector(scrContext, 1u, &vectorValue);
  if ( Scr_GetNumParam(scrContext) <= 2 )
  {
    angles.v[0] = 0.0;
    angles.v[1] = 0.0;
    angles.v[2] = 0.0;
  }
  else
  {
    Scr_GetVector(scrContext, 2u, &angles);
  }
  if ( Scr_GetNumParam(scrContext) <= 3 )
  {
    LOWORD(Int) = 0;
  }
  else
  {
    Int = Scr_GetInt(scrContext, 3u);
    if ( Int > 0xFFFE )
    {
      v4 = "GScr_SpawnScriptable payload needs to be between 0 and 65535.";
      v5 = COM_ERR_6090;
      goto LABEL_11;
    }
  }
  if ( ScriptableSv_StandaloneSpawnInstance(String, &vectorValue, &angles, Int, 0, &outInstanceIndex) )
  {
    Scr_AddEntityNum(scrContext, outInstanceIndex, ENTITY_CLASS_SCRIPTABLE);
    return;
  }
  v4 = "Failed to spawn standalone instance. See log for details.";
  v5 = COM_ERR_4682;
LABEL_11:
  Scr_Error(v5, scrContext, v4);
}

/*
==============
GScr_GetEntityNumber
==============
*/
void GScr_GetEntityNumber(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  Scr_AddInt(scrContext, Entity->s.number);
}

/*
==============
GScr_TrajectoryUpdateOriginAndAngles
==============
*/
void GScr_TrajectoryUpdateOriginAndAngles(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  char v4; 
  int NumParam; 
  vec3_t vectorValue; 
  vec3_t origin; 

  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 5359, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  v4 = 0;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam > 1 && Scr_GetType(scrContext, 1u) )
  {
    Scr_GetVector(scrContext, 1u, &vectorValue);
    G_Utils_UpdateAnglesTrajectory(Entity, &vectorValue, 0, 0);
    v4 = 1;
  }
  if ( NumParam > 0 && Scr_GetType(scrContext, 0) )
  {
    Scr_GetVector(scrContext, 0, &origin);
    G_Utils_UpdateOriginTrajectory(Entity, &origin, 0, 0);
    G_PhysicsObject_WarpToCurrentTransform(Entity, 1);
  }
  else if ( v4 )
  {
    G_PhysicsObject_WarpToCurrentTransform(Entity, 1);
  }
  else
  {
    Scr_Error(COM_ERR_6340, scrContext, "Not a valid origin or angle.\n");
  }
}

/*
==============
GScr_SpawnCustomWeaponScriptable
==============
*/
void GScr_SpawnCustomWeaponScriptable(scrContext_t *scrContext)
{
  const char *String; 
  unsigned int Int; 
  unsigned __int16 v4; 
  GWeaponMap *Instance; 
  unsigned __int16 extraPayload; 
  BgWeaponHandle handle; 
  bool outIsAlternate; 
  unsigned int outInstanceIndex; 
  vec3_t angles; 
  vec3_t vectorValue; 
  Weapon outWeapon; 

  String = Scr_GetString(scrContext, 0);
  if ( ScriptableSv_IsLootCustomWeapon(String) )
  {
    Scr_GetVector(scrContext, 1u, &vectorValue);
    Scr_GetVector(scrContext, 2u, &angles);
    Int = Scr_GetInt(scrContext, 3u);
    v4 = Int;
    if ( Int > 0xFFFE )
    {
      Scr_Error(COM_ERR_6298, scrContext, "GScr_SpawnScriptable payload needs to be between 0 and 65535.");
    }
    else
    {
      handle.m_mapEntryId = 0;
      Instance = GWeaponMap::GetInstance();
      GScr_Main_GetWeaponParam(scrContext, 4u, &outWeapon, &outIsAlternate);
      GWeaponMap::SetWeapon(Instance, &handle, &outWeapon);
      extraPayload = truncate_cast<unsigned short,unsigned int>(handle.m_mapEntryId);
      if ( ScriptableSv_StandaloneSpawnInstance(String, &vectorValue, &angles, v4, extraPayload, &outInstanceIndex) )
      {
        Scr_AddEntityNum(scrContext, outInstanceIndex, ENTITY_CLASS_SCRIPTABLE);
      }
      else
      {
        if ( handle.m_mapEntryId )
          GWeaponMap::ClearWeapon(Instance, &handle);
        Scr_Error(COM_ERR_6565, scrContext, "Failed to spawn standalone instance. See log for details.");
      }
    }
  }
  else
  {
    Scr_Error(COM_ERR_6299, scrContext, "SpawnCustomWeaponScriptable failed, see log for details.");
  }
}

/*
==============
GScr_GetMissileVelocity
==============
*/
void GScr_GetMissileVelocity(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  trType_t trType; 
  GHandler *Handler; 
  const char *v7; 
  vec3_t outVelocity; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( Entity )
  {
    if ( Entity->s.eType == ET_MISSILE )
      goto LABEL_6;
  }
  else if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 5408, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
  {
    __debugbreak();
  }
  Scr_Error(COM_ERR_6196, scrContext, "GetMissileVelocity() invoked on invalid or non-missile entity.");
LABEL_6:
  trType = v4->s.lerp.pos.trType;
  if ( trType )
  {
    if ( ((trType - 2) & 0xFFFFFFFA) != 0 || trType == TR_LINEAR_STOP )
    {
      outVelocity.v[0] = 0.0;
      outVelocity.v[1] = 0.0;
      outVelocity.v[2] = 0.0;
      v7 = j_va("GetMissileVelocity() unsupported Trajectory Type %i for entity %i", (unsigned int)v4->s.lerp.apos.trType, (unsigned int)v4->s.number);
      Scr_Error(COM_ERR_6197, scrContext, v7);
    }
    else
    {
      Handler = GHandler::getHandler();
      GHandler::GetEntityVelocity(Handler, v4->s.number, &outVelocity);
    }
  }
  else
  {
    outVelocity.v[0] = 0.0;
    outVelocity.v[1] = 0.0;
    outVelocity.v[2] = 0.0;
  }
  Scr_AddVector(scrContext, outVelocity.v);
}

/*
==============
GScr_GetScriptableLootSpawnedCountByName
==============
*/
void GScr_GetScriptableLootSpawnedCountByName(scrContext_t *scrContext)
{
  const char *String; 
  unsigned __int16 LootSpawnedCountForItem; 

  String = Scr_GetString(scrContext, 0);
  LootSpawnedCountForItem = ScriptableSv_GetLootSpawnedCountForItem(String);
  Scr_AddInt(scrContext, LootSpawnedCountForItem);
}

/*
==============
GScr_ValidateCollision
==============
*/
void GScr_ValidateCollision(scrContext_t *scrContext, scr_entref_t entref)
{
  ;
}

/*
==============
GScr_GetScriptableLootSpawnedCountByRarity
==============
*/
void GScr_GetScriptableLootSpawnedCountByRarity(scrContext_t *scrContext)
{
  int Int; 
  unsigned __int16 LootSpawnedCountForRarity; 

  Int = Scr_GetInt(scrContext, 0);
  LootSpawnedCountForRarity = ScriptableSv_GetLootSpawnedCountForRarity(Int);
  Scr_AddInt(scrContext, LootSpawnedCountForRarity);
}

/*
==============
GScr_GetEntityVelocity
==============
*/
void GScr_GetEntityVelocity(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  gclient_s *client; 
  int v6; 
  const char *v7; 
  const float *p_commandTime; 
  const char *v9; 
  const char *v10; 

  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 5548, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( Entity->vehicle )
  {
    if ( EntHandle::isDefined(&Entity->r.ownerNum) && (v4 = EntHandle::ent(&Entity->r.ownerNum)) != NULL && (client = v4->client) != NULL && (v6 = client->ps.vehicleState.entity, v6 != 2047) && v6 == Entity->s.number )
    {
      Scr_AddVector(scrContext, client->ps.vehicleState.velocity.v);
    }
    else
    {
      v7 = j_va("vehicle entity %i is not being controlled by the player. ", (unsigned int)Entity->s.number);
      Scr_Error(COM_ERR_4065, scrContext, v7);
    }
  }
  else
  {
    p_commandTime = (const float *)&Entity->client->ps.commandTime;
    if ( p_commandTime || (p_commandTime = (const float *)&Entity->agent->playerState.commandTime) != NULL )
    {
      Scr_AddVector(scrContext, p_commandTime + 15);
    }
    else
    {
      v9 = SL_ConvertToString(Entity->classname);
      v10 = j_va("entity type '%s' is not a player nor a player controlled vehicle ", v9);
      Scr_Error(COM_ERR_4066, scrContext, v10);
    }
  }
}

/*
==============
GScr_GetScriptableLootSpawnedCountByType
==============
*/
void GScr_GetScriptableLootSpawnedCountByType(scrContext_t *scrContext)
{
  const char *String; 
  unsigned __int16 LootSpawnedCountForType; 

  String = Scr_GetString(scrContext, 0);
  LootSpawnedCountForType = ScriptableSv_GetLootSpawnedCountForType(String);
  Scr_AddInt(scrContext, LootSpawnedCountForType);
}

/*
==============
GScr_GetScriptableLootCacheContents
==============
*/
void GScr_GetScriptableLootCacheContents(scrContext_t *scrContext)
{
  scr_entref_t EntityRef; 
  unsigned int entnum; 
  int v4; 
  int Int; 
  char **v6; 
  int out_itemCount[4]; 
  char *out_itemNames[10]; 

  EntityRef = Scr_GetEntityRef(scrContext, 0);
  entnum = EntityRef.entnum;
  if ( EntityRef.entclass == ENTITY_CLASS_SCRIPTABLE )
  {
    v4 = 0;
    Int = 0;
    if ( Scr_GetNumParam(scrContext) > 1 )
      Int = Scr_GetInt(scrContext, 1u);
    out_itemCount[0] = 10;
    if ( ScriptableSv_GetLootCache(entnum, Int, (const char **)out_itemNames, out_itemCount) )
    {
      Scr_MakeArray(scrContext);
      if ( out_itemCount[0] > 0 )
      {
        v6 = out_itemNames;
        do
        {
          Scr_AddString(scrContext, *v6);
          Scr_AddArray(scrContext);
          ++v4;
          ++v6;
        }
        while ( v4 < out_itemCount[0] );
      }
    }
  }
  else
  {
    Scr_Error(COM_ERR_6566, scrContext, "GetScriptableLootCacheContents must be given a lootInstance.");
  }
}

/*
==============
GScr_GetPlayerRollVelocity
==============
*/
void GScr_GetPlayerRollVelocity(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  playerState_s *EntityPlayerState; 

  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 5597, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  EntityPlayerState = G_GetEntityPlayerState(Entity);
  if ( !EntityPlayerState )
    Scr_Error(COM_ERR_4067, scrContext, "GetPlayerRollVelocity must be called on a player.\n");
  Scr_AddFloat(scrContext, EntityPlayerState->rollVelocity);
}

/*
==============
GScr_GetScriptCacheContents
==============
*/
void GScr_GetScriptCacheContents(scrContext_t *scrContext)
{
  int v2; 
  unsigned __int16 v3; 
  const char *String; 
  int Int; 
  bool ScriptCache; 
  char **v7; 
  int out_itemCount[4]; 
  char *out_itemNames[24]; 

  if ( ScriptableSv_GetLootTable() )
  {
    if ( Scr_GetNumParam(scrContext) )
    {
      v2 = 0;
      v3 = 0;
      String = Scr_GetString(scrContext, 0);
      if ( Scr_GetNumParam(scrContext) <= 1 || (Int = Scr_GetInt(scrContext, 1u), v3 = Int, Int >= 0) )
      {
        out_itemCount[0] = 24;
        ScriptCache = ScriptableSv_GetScriptCache(String, v3, (const char **)out_itemNames, out_itemCount);
        if ( out_itemCount[0] > 24 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 24849, ASSERT_TYPE_ASSERT, "(itemCount <= 24)", (const char *)&queryFormat, "itemCount <= SPAWNGROUP_LOOT_MAX_CACHE_ITEMS") )
          __debugbreak();
        if ( ScriptCache )
        {
          Scr_MakeArray(scrContext);
          if ( out_itemCount[0] > 0 )
          {
            v7 = out_itemNames;
            do
            {
              Scr_AddString(scrContext, *v7);
              Scr_AddArray(scrContext);
              ++v2;
              ++v7;
            }
            while ( v2 < out_itemCount[0] );
          }
        }
      }
      else
      {
        Scr_Error(COM_ERR_6568, scrContext, "GScr_GetScriptCacheContents: invalid cacheIndex value\n");
      }
    }
    else
    {
      Scr_Error(COM_ERR_6567, scrContext, "GScr_GetScriptCacheContents: must be called with a valid <setName>\n");
    }
  }
  else
  {
    Scr_Error(COM_ERR_6624, scrContext, "GScr_GetScriptCacheContents: no loot table currently loaded\n");
  }
}

/*
==============
ScrCmd_CanAttackEnemyNodeFromExposed
==============
*/
void ScrCmd_CanAttackEnemyNodeFromExposed(scrContext_t *scrContext, scr_entref_t entref)
{
  int HasDecentVisFromExposed; 
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  sentient_s *TargetSentient; 
  sentient_s *v8; 
  AIWrapper v9; 

  AIActorInterface::AIActorInterface(&v9.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v9.m_newAgentInterface);
  HasDecentVisFromExposed = 0;
  v9.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  v9.m_pAI = NULL;
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v9, Entity);
  m_pAI = v9.m_pAI;
  if ( !v9.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 5621, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  if ( !m_pAI->GetSentient(m_pAI) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 5623, ASSERT_TYPE_ASSERT, "(pAI->GetSentient())", (const char *)&queryFormat, "pAI->GetSentient()") )
    __debugbreak();
  TargetSentient = AICommonInterface::GetTargetSentient(m_pAI);
  if ( TargetSentient )
  {
    v8 = m_pAI->GetSentient(m_pAI);
    HasDecentVisFromExposed = Sentient_HasDecentVisFromExposed(v8, TargetSentient);
  }
  Scr_AddBool(scrContext, HasDecentVisFromExposed);
}

/*
==============
GScr_PickScriptableLootItem
==============
*/
void GScr_PickScriptableLootItem(scrContext_t *scrContext)
{
  const char *v1; 
  const char *String; 
  int v4; 
  int Int; 
  const char *v6; 

  v1 = (char *)&queryFormat.fmt + 3;
  String = (char *)&queryFormat.fmt + 3;
  if ( Scr_GetNumParam(scrContext) )
    String = Scr_GetString(scrContext, 0);
  v4 = 0;
  Int = 0;
  if ( Scr_GetNumParam(scrContext) > 1 )
    Int = Scr_GetInt(scrContext, 1u);
  if ( Scr_GetNumParam(scrContext) > 2 )
    v4 = Scr_GetInt(scrContext, 2u);
  if ( Scr_GetNumParam(scrContext) > 3 )
    v1 = Scr_GetString(scrContext, 3u);
  v6 = ScriptableSv_PickLootItem(String, Int, v4, v1);
  Scr_AddString(scrContext, v6);
}

/*
==============
ScrCmd_CanAttackEnemyNode
==============
*/
void ScrCmd_CanAttackEnemyNode(scrContext_t *scrContext, scr_entref_t entref)
{
  int HasDecentVis; 
  const gentity_s *Entity; 
  AIScriptedInterface *m_pAI; 
  sentient_s *TargetSentient; 
  sentient_s *v8; 
  AIWrapper v9; 

  AIActorInterface::AIActorInterface(&v9.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v9.m_newAgentInterface);
  HasDecentVis = 0;
  v9.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  v9.m_pAI = NULL;
  Entity = GetEntity(entref);
  AIWrapper::Setup(&v9, Entity);
  m_pAI = v9.m_pAI;
  if ( !v9.m_pAI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 5648, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
    __debugbreak();
  if ( !m_pAI->GetSentient(m_pAI) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 5650, ASSERT_TYPE_ASSERT, "(pAI->GetSentient())", (const char *)&queryFormat, "pAI->GetSentient()") )
    __debugbreak();
  TargetSentient = AICommonInterface::GetTargetSentient(m_pAI);
  if ( TargetSentient )
  {
    v8 = m_pAI->GetSentient(m_pAI);
    HasDecentVis = Sentient_HasDecentVis(v8, TargetSentient);
  }
  Scr_AddBool(scrContext, HasDecentVis);
}

/*
==============
GScr_IsScriptableDefined
==============
*/
void GScr_IsScriptableDefined(scrContext_t *scrContext)
{
  const char *String; 
  const ScriptableDef *NetConstStringDefAtIndex; 
  unsigned int outIndex; 

  String = Scr_GetString(scrContext, 0);
  if ( NetConstStrings_GetIndexFromName(NETCONSTSTRINGTYPE_SCRIPTABLEDEF, String, &outIndex) )
  {
    NetConstStringDefAtIndex = ScriptableBg_GetNetConstStringDefAtIndex(outIndex);
    Scr_AddBool(scrContext, NetConstStringDefAtIndex != NULL);
  }
  else
  {
    Scr_AddBool(scrContext, 0);
  }
}

/*
==============
GScr_EnableGrenadeTouchDamage
==============
*/
void GScr_EnableGrenadeTouchDamage(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( Entity->classname == scr_const.trigger_damage )
  {
    Entity->flags.m_flags[0] |= 0x2000u;
  }
  else
  {
    Scr_Error(COM_ERR_4068, scrContext, "Currently on supported on damage triggers");
    v4->flags.m_flags[0] |= 0x2000u;
  }
}

/*
==============
GScr_DisableGrenadeTouchDamage
==============
*/
void GScr_DisableGrenadeTouchDamage(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( Entity->classname == scr_const.trigger_damage )
  {
    Entity->flags.m_flags[0] &= ~0x2000u;
  }
  else
  {
    Scr_Error(COM_ERR_4069, scrContext, "Currently on supported on damage triggers");
    v4->flags.m_flags[0] &= ~0x2000u;
  }
}

/*
==============
GScr_FreeScriptable
==============
*/
void GScr_FreeScriptable(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 

  entnum = entref.entnum;
  if ( entref.entclass != ENTITY_CLASS_SCRIPTABLE )
    Scr_ObjectError(COM_ERR_4683, scrContext, "Must be called on objects of class 'Scriptable'");
  ScriptableCommon_AssertCountsInitialized();
  if ( entnum >= g_scriptableWorldCounts.runtimeInstanceCount )
    Scr_ObjectError(COM_ERR_4684, scrContext, "Must be called on a standalone dynamic scriptable");
  if ( ScriptableSv_GetInstanceCommonContext(entnum)->linkedObjectType == SCRIPTABLE_LINK_ENTITY )
    Scr_ObjectError(COM_ERR_4685, scrContext, "Must be called on a standalone (non-entity) scriptable");
  if ( !ScriptableSv_StandaloneFreeInstance(entnum) )
    Scr_Error(COM_ERR_4686, scrContext, "Failed to free standalone instance. See log for details.");
}

/*
==============
GScr_ForceHideGrenadeHudWarning
==============
*/
void GScr_ForceHideGrenadeHudWarning(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  int Int; 
  unsigned int v6; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( !Entity || Entity->s.eType != ET_MISSILE )
    Scr_Error(COM_ERR_4070, scrContext, "ForceHideGrenadeHudWarning() invoked on invalid or non-grenade entity.");
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4071, scrContext, "USAGE: <ent> ForceHideGrenadeHudWarning( <bool> )\n");
  Int = Scr_GetInt(scrContext, 0);
  v6 = v4->s.lerp.u.anonymous.data[4] & 0xFFFFFFEF;
  if ( Int )
    v6 = v4->s.lerp.u.anonymous.data[4] | 0x10;
  v4->s.lerp.u.anonymous.data[4] = v6;
}

/*
==============
GScr_SetScriptablePayloadModel
==============
*/
void GScr_SetScriptablePayloadModel(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 

  entnum = entref.entnum;
  if ( entref.entclass != ENTITY_CLASS_SCRIPTABLE )
    Scr_ObjectError(COM_ERR_4683, scrContext, "Must be called on objects of class 'Scriptable'");
  ScriptableCommon_AssertCountsInitialized();
  if ( entnum >= g_scriptableWorldCounts.runtimeInstanceCount )
    Scr_ObjectError(COM_ERR_4684, scrContext, "Must be called on a standalone dynamic scriptable");
  if ( ScriptableSv_GetInstanceCommonContext(entnum)->linkedObjectType == SCRIPTABLE_LINK_ENTITY )
    Scr_ObjectError(COM_ERR_4685, scrContext, "Must be called on a standalone (non-entity) scriptable");
}

/*
==============
GScr_SetScriptablePayloadWeapon
==============
*/
void GScr_SetScriptablePayloadWeapon(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 

  entnum = entref.entnum;
  if ( entref.entclass != ENTITY_CLASS_SCRIPTABLE )
    Scr_ObjectError(COM_ERR_4683, scrContext, "Must be called on objects of class 'Scriptable'");
  ScriptableCommon_AssertCountsInitialized();
  if ( entnum >= g_scriptableWorldCounts.runtimeInstanceCount )
    Scr_ObjectError(COM_ERR_4684, scrContext, "Must be called on a standalone dynamic scriptable");
  if ( ScriptableSv_GetInstanceCommonContext(entnum)->linkedObjectType == SCRIPTABLE_LINK_ENTITY )
    Scr_ObjectError(COM_ERR_4685, scrContext, "Must be called on a standalone (non-entity) scriptable");
}

/*
==============
GScr_MissileSetPhaseState
==============
*/
void GScr_MissileSetPhaseState(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  int Int; 
  unsigned int v6; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( !Entity || Entity->s.eType != ET_MISSILE )
    Scr_Error(COM_ERR_4072, scrContext, "Missile_SetPhaseState() invoked on invalid or non-missile entity.");
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4073, scrContext, "USAGE: <ent> Missile_SetPhaseState( <bool> )\n");
  Int = Scr_GetInt(scrContext, 0);
  v6 = v4->s.lerp.u.anonymous.data[4] & 0xFFFFFEFF;
  if ( Int )
    v6 = v4->s.lerp.u.anonymous.data[4] | 0x100;
  v4->s.lerp.u.anonymous.data[4] = v6;
}

/*
==============
GScr_MissileSetTargetEnt
==============
*/
void GScr_MissileSetTargetEnt(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 

  Entity = GetEntity(entref);
  GScr_CheckRocketEntity(scrContext, Entity);
  v4 = GScr_GetEntity(0);
  Entity->c.missile.flags = Entity->c.missile.flags & 0xFFFFFFE1 | 6;
  EntHandle::setEnt(&Entity->missileTargetEnt, v4);
  Entity->c.item[1].clipAmmoCount[0] = LODWORD(v4->r.currentOrigin.v[0]);
  Entity->c.item[1].clipAmmoCount[1] = LODWORD(v4->r.currentOrigin.v[1]);
  Entity->c.mover.angle.pos3.v[2] = v4->r.currentOrigin.v[2];
  if ( Scr_GetNumParam(scrContext) <= 1 )
  {
    *((_QWORD *)&Entity->c.beam + 9) = 0i64;
    Entity->c.item[1].ammoCount = 0;
  }
  else
  {
    Scr_GetVector(scrContext, 1u, &Entity->c.mover.angle.pos2);
  }
}

/*
==============
GScr_GetCSplineId
==============
*/
void GScr_GetCSplineId(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  int CSplineIdByTargetName; 
  const char *v4; 
  const char *v5; 
  const char *v6; 
  const char *v7; 

  ConstString = Scr_GetConstString(scrContext, 0);
  CSplineIdByTargetName = Com_GetCSplineIdByTargetName(ConstString);
  if ( CSplineIdByTargetName == -1 )
  {
    v4 = SL_ConvertToString(ConstString);
    v5 = j_va("GetCSplineId was unable to find targetname: %s", v4);
    Scr_Error(COM_ERR_4690, scrContext, v5);
    Scr_AddUndefined(scrContext);
  }
  else if ( CSplineIdByTargetName == -3 )
  {
    v6 = SL_ConvertToString(ConstString);
    v7 = j_va("GetCSplineId found multiple splines with the same targetname: %s", v6);
    Scr_Error(COM_ERR_4691, scrContext, v7);
    Scr_AddUndefined(scrContext);
  }
  else
  {
    Scr_AddInt(scrContext, CSplineIdByTargetName);
  }
}

/*
==============
GScr_MissileSetTargetPos
==============
*/
void GScr_MissileSetTargetPos(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  GScr_CheckRocketEntity(scrContext, Entity);
  Entity->c.missile.flags = Entity->c.missile.flags & 0xFFFFFFE1 | 2;
  EntHandle::setEnt(&Entity->missileTargetEnt, NULL);
  *((_QWORD *)&Entity->c.beam + 9) = 0i64;
  Entity->c.item[1].ammoCount = 0;
  Scr_GetVector(scrContext, 0, &Entity->c.mover.angle.pos3);
}

/*
==============
GScr_GetCSplineIdArray
==============
*/
void GScr_GetCSplineIdArray(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  __int64 v3; 
  unsigned __int16 v4; 

  ConstString = Scr_GetConstString(scrContext, 0);
  LOWORD(v3) = Com_GetCSplineCount();
  Scr_MakeArray(scrContext);
  if ( (_WORD)v3 )
  {
    v4 = 1;
    v3 = (unsigned __int16)v3;
    do
    {
      if ( Com_GetCSplineTargetname(v4) == ConstString )
      {
        Scr_AddInt(scrContext, v4);
        Scr_AddArray(scrContext);
      }
      ++v4;
      --v3;
    }
    while ( v3 );
  }
}

/*
==============
GScr_MissileClearTarget
==============
*/
void GScr_MissileClearTarget(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  GScr_CheckRocketEntity(scrContext, Entity);
  Entity->c.missile.flags &= 0xFFFFFFE9;
  EntHandle::setEnt(&Entity->missileTargetEnt, NULL);
  *((_QWORD *)&Entity->c.beam + 9) = 0i64;
  *((_QWORD *)&Entity->c.beam + 10) = 0i64;
  *((_QWORD *)&Entity->c.beam + 11) = 0i64;
}

/*
==============
GScr_GetCSplineCount
==============
*/
void GScr_GetCSplineCount(scrContext_t *scrContext)
{
  unsigned __int16 CSplineCount; 

  CSplineCount = Com_GetCSplineCount();
  Scr_AddInt(scrContext, CSplineCount);
}

/*
==============
GScr_GetCSplinePointCount
==============
*/
void GScr_GetCSplinePointCount(scrContext_t *scrContext)
{
  int Int; 
  unsigned int v3; 
  const char *v4; 
  unsigned __int16 CSplinePointCount; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    Int = Scr_GetInt(scrContext, 0);
    v3 = truncate_cast<unsigned short,int>(Int);
    if ( v3 <= Com_GetCSplineCount() )
    {
      CSplinePointCount = Com_GetCSplinePointCount(v3);
      Scr_AddInt(scrContext, CSplinePointCount);
    }
    else
    {
      v4 = j_va("'%s' - Invalid CSpline Id '%i'\n", "GetCSplinePointCount", v3);
      Scr_Error(COM_ERR_4687, scrContext, v4);
    }
  }
  else
  {
    Scr_Error(COM_ERR_4692, scrContext, "USAGE: GetCSplinePointCount(splineId)\n");
  }
}

/*
==============
GScr_MissileSetFlightmodeDirect
==============
*/
void GScr_MissileSetFlightmodeDirect(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *v4; 

  Entity = GetEntity(entref);
  GScr_CheckRocketEntity(scrContext, Entity);
  if ( (Entity->c.item[0].weapon.attachmentVariationIndices[5] & 2) == 0 )
  {
    v4 = j_va("Entity %i is not locked on to anything.", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_4077, scrContext, v4);
  }
  Entity->s.lerp.u.anonymous.data[3] = 1;
}

/*
==============
GScr_MissileSetFlightmodeTop
==============
*/
void GScr_MissileSetFlightmodeTop(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *v4; 

  Entity = GetEntity(entref);
  GScr_CheckRocketEntity(scrContext, Entity);
  if ( (Entity->c.item[0].weapon.attachmentVariationIndices[5] & 2) == 0 )
  {
    v4 = j_va("Entity %i is not locked on to anything.", (unsigned int)Entity->s.number);
    Scr_Error(COM_ERR_4077, scrContext, v4);
  }
  Entity->s.lerp.u.anonymous.data[3] = 0;
}

/*
==============
GScr_GetCSplineLength
==============
*/
void GScr_GetCSplineLength(scrContext_t *scrContext)
{
  int Int; 
  unsigned int v3; 
  const char *v4; 
  double CSplineLength; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    Int = Scr_GetInt(scrContext, 0);
    v3 = truncate_cast<unsigned short,int>(Int);
    if ( v3 <= Com_GetCSplineCount() )
    {
      CSplineLength = Com_GetCSplineLength(v3);
      Scr_AddFloat(scrContext, *(float *)&CSplineLength);
    }
    else
    {
      v4 = j_va("'%s' - Invalid CSpline Id '%i'\n", "GetCSplineLength", v3);
      Scr_Error(COM_ERR_4687, scrContext, v4);
    }
  }
  else
  {
    Scr_Error(COM_ERR_4693, scrContext, "USAGE: GetCSplineLength(splineId)\n");
  }
}

/*
==============
GScr_GetMissileOwner
==============
*/
void GScr_GetMissileOwner(scrContext_t *scrContext)
{
  gentity_s *Entity; 
  EntHandle *v3; 
  const char *v4; 
  const char *v5; 
  const gentity_s *v6; 

  Entity = GScr_GetEntity(0);
  v3 = (EntHandle *)Entity;
  if ( Entity->s.eType != ET_MISSILE )
  {
    v4 = SL_ConvertToString(Entity->classname);
    v5 = j_va("entity type '%s' is not a missile", v4);
    Scr_Error(COM_ERR_4078, scrContext, v5);
  }
  if ( EntHandle::isDefined(v3 + 82) )
  {
    v6 = EntHandle::ent(v3 + 82);
    GScr_AddEntity(v6);
  }
  else
  {
    Scr_AddUndefined(scrContext);
  }
}

/*
==============
GScr_GetCSplineTargetname
==============
*/
void GScr_GetCSplineTargetname(scrContext_t *scrContext)
{
  int Int; 
  unsigned int v3; 
  const char *v4; 
  scr_string_t CSplineTargetname; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    Int = Scr_GetInt(scrContext, 0);
    v3 = truncate_cast<unsigned short,int>(Int);
    if ( v3 <= Com_GetCSplineCount() )
    {
      CSplineTargetname = Com_GetCSplineTargetname(v3);
      if ( CSplineTargetname )
        Scr_AddConstString(scrContext, CSplineTargetname);
      else
        Scr_AddUndefined(scrContext);
    }
    else
    {
      v4 = j_va("'%s' - Invalid CSpline Id '%i'\n", "GetCSplineTargetname", v3);
      Scr_Error(COM_ERR_4687, scrContext, v4);
    }
  }
  else
  {
    Scr_Error(COM_ERR_4694, scrContext, "USAGE: GetCSplineTargetname(splineId)\n");
  }
}

/*
==============
GScr_IsOnLadder
==============
*/
void GScr_IsOnLadder(scrContext_t *scrContext, scr_entref_t entref)
{
  int v2; 
  unsigned int entnum; 
  gentity_s *v5; 
  char *client; 
  const char *v7; 
  ComErrorCode v8; 

  v2 = 0;
  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v7 = "not an entity";
    v8 = COM_ERR_3682;
LABEL_9:
    Scr_ObjectError(v8, scrContext, v7);
    client = NULL;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 5962, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
      __debugbreak();
    goto LABEL_11;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 5960, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v5 = &g_entities[entnum];
  client = (char *)v5->client;
  if ( !client )
  {
    client = (char *)v5->agent;
    if ( !client )
    {
      v7 = j_va("entity %i is not a player or agent", entnum);
      v8 = COM_ERR_3679;
      goto LABEL_9;
    }
  }
LABEL_11:
  LOBYTE(v2) = GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal((GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64> *)(client + 20), ACTIVE, 6u);
  Scr_AddBool(scrContext, v2);
}

/*
==============
GScr_GetCSplinePointId
==============
*/
void GScr_GetCSplinePointId(scrContext_t *scrContext)
{
  int Int; 
  unsigned int v3; 
  const char *v4; 
  int v5; 
  unsigned __int16 v6; 
  const char *v7; 
  int CSplinePointId; 

  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    Int = Scr_GetInt(scrContext, 0);
    v3 = truncate_cast<unsigned short,int>(Int);
    if ( v3 <= Com_GetCSplineCount() )
    {
      v5 = Scr_GetInt(scrContext, 1u);
      v6 = truncate_cast<unsigned short,int>(v5);
      if ( v6 < Com_GetCSplinePointCount(v3) )
      {
        CSplinePointId = Com_GetCSplinePointId(v3, v6);
        Scr_AddInt(scrContext, CSplinePointId);
      }
      else
      {
        v7 = j_va("'%s' - Invalid CSpline Node Index '%i' for Spline '%i'\n", "GetCSplinePointId", v6, v3);
        Scr_Error(COM_ERR_4688, scrContext, v7);
      }
    }
    else
    {
      v4 = j_va("'%s' - Invalid CSpline Id '%i'\n", "GetCSplinePointId", v3);
      Scr_Error(COM_ERR_4687, scrContext, v4);
    }
  }
  else
  {
    Scr_Error(COM_ERR_4695, scrContext, "USAGE: GetCSplinePointId(splineId, splineNodeIndex)\n");
  }
}

/*
==============
GScr_GetCSplinePointLabel
==============
*/
void GScr_GetCSplinePointLabel(scrContext_t *scrContext)
{
  int Int; 
  unsigned int v3; 
  const char *v4; 
  int v5; 
  unsigned __int16 v6; 
  const char *v7; 
  scr_string_t CSplinePointLabel; 

  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    Int = Scr_GetInt(scrContext, 0);
    v3 = truncate_cast<unsigned short,int>(Int);
    if ( v3 <= Com_GetCSplineCount() )
    {
      v5 = Scr_GetInt(scrContext, 1u);
      v6 = truncate_cast<unsigned short,int>(v5);
      if ( v6 < Com_GetCSplinePointCount(v3) )
      {
        CSplinePointLabel = Com_GetCSplinePointLabel(v3, v6);
        if ( CSplinePointLabel )
          Scr_AddConstString(scrContext, CSplinePointLabel);
        else
          Scr_AddUndefined(scrContext);
      }
      else
      {
        v7 = j_va("'%s' - Invalid CSpline Node Index '%i' for Spline '%i'\n", "GetCSplinePointLabel", v6, v3);
        Scr_Error(COM_ERR_4688, scrContext, v7);
      }
    }
    else
    {
      v4 = j_va("'%s' - Invalid CSpline Id '%i'\n", "GetCSplinePointLabel", v3);
      Scr_Error(COM_ERR_4687, scrContext, v4);
    }
  }
  else
  {
    Scr_Error(COM_ERR_4696, scrContext, "USAGE: GetCSplinePointLabel(splineId, splineNodeIndex)\n");
  }
}

/*
==============
GScr_SetBountyCount
==============
*/
void GScr_SetBountyCount(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *PlayerEntity; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  int Int; 
  const char *v10; 

  entnum = entref.entnum;
  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  if ( !G_Utils_IsClient(PlayerEntity) )
  {
    targetname = PlayerEntity->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(PlayerEntity->classname);
    v8 = j_va("SetBountyCount(). Only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, PlayerEntity->r.currentOrigin.v[0], PlayerEntity->r.currentOrigin.v[1], PlayerEntity->r.currentOrigin.v[2], v7, v6);
    Scr_Error(COM_ERR_4079, scrContext, v8);
  }
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4080, scrContext, "USAGE: <player> SetBountyCount( <int> )\n");
  Int = Scr_GetInt(scrContext, 0);
  if ( Int > 7 )
  {
    v10 = j_va("Bounty count limit exceeded! The maximum supported bounty count is %d\n", 7i64);
    Scr_Error(COM_ERR_4081, scrContext, v10);
  }
  PlayerEntity->client->sess.cs.bountyCount = truncate_cast<signed char,int>(Int);
}

/*
==============
GScr_GetCSplinePointString
==============
*/
void GScr_GetCSplinePointString(scrContext_t *scrContext)
{
  int Int; 
  unsigned int v3; 
  const char *v4; 
  int v5; 
  unsigned __int16 v6; 
  const char *v7; 
  scr_string_t CSplinePointString; 

  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    Int = Scr_GetInt(scrContext, 0);
    v3 = truncate_cast<unsigned short,int>(Int);
    if ( v3 <= Com_GetCSplineCount() )
    {
      v5 = Scr_GetInt(scrContext, 1u);
      v6 = truncate_cast<unsigned short,int>(v5);
      if ( v6 < Com_GetCSplinePointCount(v3) )
      {
        CSplinePointString = Com_GetCSplinePointString(v3, v6);
        if ( CSplinePointString )
          Scr_AddConstString(scrContext, CSplinePointString);
        else
          Scr_AddUndefined(scrContext);
      }
      else
      {
        v7 = j_va("'%s' - Invalid CSpline Node Index '%i' for Spline '%i'\n", "GetCSplinePointString", v6, v3);
        Scr_Error(COM_ERR_4688, scrContext, v7);
      }
    }
    else
    {
      v4 = j_va("'%s' - Invalid CSpline Id '%i'\n", "GetCSplinePointString", v3);
      Scr_Error(COM_ERR_4687, scrContext, v4);
    }
  }
  else
  {
    Scr_Error(COM_ERR_4697, scrContext, "USAGE: GetCSplinePointString(splineId, splineNodeIndex)\n");
  }
}

/*
==============
GScr_SetPerkIcon
==============
*/
void GScr_SetPerkIcon(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *PlayerEntity; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  const char *String; 
  const char *v10; 
  unsigned int outIndex; 

  entnum = entref.entnum;
  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  if ( !G_Utils_IsClient(PlayerEntity) )
  {
    targetname = PlayerEntity->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(PlayerEntity->classname);
    v8 = j_va("SetPerkIcon(). Only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, PlayerEntity->r.currentOrigin.v[0], PlayerEntity->r.currentOrigin.v[1], PlayerEntity->r.currentOrigin.v[2], v7, v6);
    Scr_Error(COM_ERR_4082, scrContext, v8);
  }
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4083, scrContext, "USAGE: <player> SetPerkIcon( <string> )\n");
  String = Scr_GetString(scrContext, 0);
  if ( !NetConstStrings_GetIndexFromName(NETCONSTSTRINGTYPE_IMAGE, String, &outIndex) )
  {
    v10 = j_va("'%s' is not a valid perk icon image. Please make sure it is included as precache_image in zone_source.", String);
    Scr_Error(COM_ERR_4084, scrContext, v10);
  }
  PlayerEntity->client->sess.cs.perkIconName = outIndex;
}

/*
==============
GScr_GetCSplinePointTargetname
==============
*/
void GScr_GetCSplinePointTargetname(scrContext_t *scrContext)
{
  int Int; 
  unsigned int v3; 
  const char *v4; 
  int v5; 
  unsigned __int16 v6; 
  const char *v7; 
  scr_string_t CSplinePointTargetName; 

  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    Int = Scr_GetInt(scrContext, 0);
    v3 = truncate_cast<unsigned short,int>(Int);
    if ( v3 <= Com_GetCSplineCount() )
    {
      v5 = Scr_GetInt(scrContext, 1u);
      v6 = truncate_cast<unsigned short,int>(v5);
      if ( v6 < Com_GetCSplinePointCount(v3) )
      {
        CSplinePointTargetName = Com_GetCSplinePointTargetName(v3, v6);
        if ( CSplinePointTargetName )
          Scr_AddConstString(scrContext, CSplinePointTargetName);
        else
          Scr_AddUndefined(scrContext);
      }
      else
      {
        v7 = j_va("'%s' - Invalid CSpline Node Index '%i' for Spline '%i'\n", "GetCSplinePointTargetname", v6, v3);
        Scr_Error(COM_ERR_4688, scrContext, v7);
      }
    }
    else
    {
      v4 = j_va("'%s' - Invalid CSpline Id '%i'\n", "GetCSplinePointTargetname", v3);
      Scr_Error(COM_ERR_4687, scrContext, v4);
    }
  }
  else
  {
    Scr_Error(COM_ERR_4698, scrContext, "USAGE: GetCSplinePointTargetname(splineId, splineNodeIndex)\n");
  }
}

/*
==============
GScr_GetCSplinePointTarget
==============
*/
void GScr_GetCSplinePointTarget(scrContext_t *scrContext)
{
  int Int; 
  unsigned int v3; 
  const char *v4; 
  int v5; 
  unsigned __int16 v6; 
  const char *v7; 
  scr_string_t CSplinePointTarget; 

  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    Int = Scr_GetInt(scrContext, 0);
    v3 = truncate_cast<unsigned short,int>(Int);
    if ( v3 <= Com_GetCSplineCount() )
    {
      v5 = Scr_GetInt(scrContext, 1u);
      v6 = truncate_cast<unsigned short,int>(v5);
      if ( v6 < Com_GetCSplinePointCount(v3) )
      {
        CSplinePointTarget = Com_GetCSplinePointTarget(v3, v6);
        if ( CSplinePointTarget )
          Scr_AddConstString(scrContext, CSplinePointTarget);
        else
          Scr_AddUndefined(scrContext);
      }
      else
      {
        v7 = j_va("'%s' - Invalid CSpline Node Index '%i' for Spline '%i'\n", "GetCSplinePointTarget", v6, v3);
        Scr_Error(COM_ERR_4688, scrContext, v7);
      }
    }
    else
    {
      v4 = j_va("'%s' - Invalid CSpline Id '%i'\n", "GetCSplinePointTarget", v3);
      Scr_Error(COM_ERR_4687, scrContext, v4);
    }
  }
  else
  {
    Scr_Error(COM_ERR_4699, scrContext, "USAGE: GetCSplinePointTarget(splineId, splineNodeIndex)\n");
  }
}

/*
==============
GScr_SetSquadIndex
==============
*/
void GScr_SetSquadIndex(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *PlayerEntity; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  int Int; 
  const char *v10; 

  entnum = entref.entnum;
  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  if ( !G_Utils_IsClient(PlayerEntity) )
  {
    targetname = PlayerEntity->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(PlayerEntity->classname);
    v8 = j_va("SetSquadIndex(). Only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, PlayerEntity->r.currentOrigin.v[0], PlayerEntity->r.currentOrigin.v[1], PlayerEntity->r.currentOrigin.v[2], v7, v6);
    Scr_Error(COM_ERR_4085, scrContext, v8);
  }
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4086, scrContext, "USAGE: <player> SetSquadIndex( <int> )\n");
  if ( !SV_Game_IsPrivateMatch() )
    Scr_Error(COM_ERR_6125, scrContext, "SetSquadIndex() only valid for private matches, public matches squads are assigned via the matchmaker\n");
  Int = Scr_GetInt(scrContext, 0);
  if ( Int > 255 )
  {
    v10 = j_va("Squad index limit exceeded! The maximum supported squad index is %d\n", 255i64);
    Scr_Error(COM_ERR_4087, scrContext, v10);
  }
  PlayerEntity->client->sess.cs.squadIndex = Int;
}

/*
==============
GScr_GetCSplinePointTension
==============
*/
void GScr_GetCSplinePointTension(scrContext_t *scrContext)
{
  int Int; 
  unsigned int v3; 
  const char *v4; 
  int v5; 
  unsigned __int16 v6; 
  const char *v7; 
  double CSplinePointTension; 

  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    Int = Scr_GetInt(scrContext, 0);
    v3 = truncate_cast<unsigned short,int>(Int);
    if ( v3 <= Com_GetCSplineCount() )
    {
      v5 = Scr_GetInt(scrContext, 1u);
      v6 = truncate_cast<unsigned short,int>(v5);
      if ( v6 < Com_GetCSplinePointCount(v3) )
      {
        CSplinePointTension = Com_GetCSplinePointTension(v3, v6);
        Scr_AddFloat(scrContext, *(float *)&CSplinePointTension);
      }
      else
      {
        v7 = j_va("'%s' - Invalid CSpline Node Index '%i' for Spline '%i'\n", "GetCSplinePointTension", v6, v3);
        Scr_Error(COM_ERR_4688, scrContext, v7);
      }
    }
    else
    {
      v4 = j_va("'%s' - Invalid CSpline Id '%i'\n", "GetCSplinePointTension", v3);
      Scr_Error(COM_ERR_4687, scrContext, v4);
    }
  }
  else
  {
    Scr_Error(COM_ERR_4700, scrContext, "USAGE: GetCSplinePointTension(splineId, splineNodeIndex)\n");
  }
}

/*
==============
GScr_GetSquadIndex
==============
*/
void GScr_GetSquadIndex(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *PlayerEntity; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v8; 

  entnum = entref.entnum;
  PlayerEntity = GScr_Main_GetPlayerEntity(scrContext, entref);
  if ( !G_Utils_IsClient(PlayerEntity) )
  {
    targetname = PlayerEntity->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(PlayerEntity->classname);
    v8 = j_va("GetSquadIndex(). Only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, PlayerEntity->r.currentOrigin.v[0], PlayerEntity->r.currentOrigin.v[1], PlayerEntity->r.currentOrigin.v[2], v7, v6);
    Scr_Error(COM_ERR_6126, scrContext, v8);
  }
  if ( Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_6127, scrContext, "USAGE: <player> GetSquadIndex()\n");
  Scr_AddInt(scrContext, PlayerEntity->client->sess.cs.squadIndex);
}

/*
==============
GScr_GetCSplinePointPosition
==============
*/
void GScr_GetCSplinePointPosition(scrContext_t *scrContext)
{
  int Int; 
  unsigned int v3; 
  const char *v4; 
  int v5; 
  unsigned __int16 v6; 
  const char *v7; 
  vec3_t out_position; 

  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    Int = Scr_GetInt(scrContext, 0);
    v3 = truncate_cast<unsigned short,int>(Int);
    if ( v3 <= Com_GetCSplineCount() )
    {
      v5 = Scr_GetInt(scrContext, 1u);
      v6 = truncate_cast<unsigned short,int>(v5);
      if ( v6 < Com_GetCSplinePointCount(v3) )
      {
        Com_GetCSplinePointPosition(v3, v6, &out_position);
        Scr_AddVector(scrContext, out_position.v);
      }
      else
      {
        v7 = j_va("'%s' - Invalid CSpline Node Index '%i' for Spline '%i'\n", "GetCSplinePointPosition", v6, v3);
        Scr_Error(COM_ERR_4688, scrContext, v7);
      }
    }
    else
    {
      v4 = j_va("'%s' - Invalid CSpline Id '%i'\n", "GetCSplinePointPosition", v3);
      Scr_Error(COM_ERR_4687, scrContext, v4);
    }
  }
  else
  {
    Scr_Error(COM_ERR_4701, scrContext, "USAGE: GetCSplinePointPosition(splineId, splineNodeIndex)\n");
  }
}

/*
==============
ScrCmd_SetNonStick
==============
*/
void ScrCmd_SetNonStick(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  unsigned int v5; 

  Entity = GetEntity(entref);
  if ( !Entity )
    Scr_Error(COM_ERR_4088, scrContext, "SetNonStick() invoked on invalid entity.");
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4089, scrContext, "USAGE: <ent> SetNonStick( <bool> )\n");
  Int = Scr_GetInt(scrContext, 0);
  v5 = Entity->flags.m_flags[0] & 0xFFFFEFFF;
  if ( Int )
    v5 = Entity->flags.m_flags[0] | 0x1000;
  Entity->flags.m_flags[0] = v5;
}

/*
==============
GScr_GetCSplinePointCorridorDims
==============
*/
void GScr_GetCSplinePointCorridorDims(scrContext_t *scrContext)
{
  int Int; 
  unsigned int v3; 
  const char *v4; 
  int v5; 
  unsigned __int16 v6; 
  const char *v7; 
  vec2_t out_dims; 

  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    Int = Scr_GetInt(scrContext, 0);
    v3 = truncate_cast<unsigned short,int>(Int);
    if ( v3 <= Com_GetCSplineCount() )
    {
      v5 = Scr_GetInt(scrContext, 1u);
      v6 = truncate_cast<unsigned short,int>(v5);
      if ( v6 < Com_GetCSplinePointCount(v3) )
      {
        Com_GetCSplinePointCorridorDims(v3, v6, &out_dims);
        Scr_AddVector(scrContext, (const float *)&out_dims);
      }
      else
      {
        v7 = j_va("'%s' - Invalid CSpline Node Index '%i' for Spline '%i'\n", "GetCSplinePointCorridorDims", v6, v3);
        Scr_Error(COM_ERR_4688, scrContext, v7);
      }
    }
    else
    {
      v4 = j_va("'%s' - Invalid CSpline Id '%i'\n", "GetCSplinePointCorridorDims", v3);
      Scr_Error(COM_ERR_4687, scrContext, v4);
    }
  }
  else
  {
    Scr_Error(COM_ERR_4702, scrContext, "USAGE: GetCSplinePointCorridorDims(splineId, splineNodeIndex)\n");
  }
}

/*
==============
GScr_GetCSplinePointTangent
==============
*/
void GScr_GetCSplinePointTangent(scrContext_t *scrContext)
{
  int Int; 
  unsigned int v3; 
  const char *v4; 
  int v5; 
  unsigned __int16 v6; 
  const char *v7; 
  vec3_t out_tangent; 

  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    Int = Scr_GetInt(scrContext, 0);
    v3 = truncate_cast<unsigned short,int>(Int);
    if ( v3 <= Com_GetCSplineCount() )
    {
      v5 = Scr_GetInt(scrContext, 1u);
      v6 = truncate_cast<unsigned short,int>(v5);
      if ( v6 < Com_GetCSplinePointCount(v3) )
      {
        Com_GetCSplinePointTangent(v3, v6, &out_tangent);
        Scr_AddVector(scrContext, out_tangent.v);
      }
      else
      {
        v7 = j_va("'%s' - Invalid CSpline Node Index '%i' for Spline '%i'\n", "GetCSplinePointTangent", v6, v3);
        Scr_Error(COM_ERR_4688, scrContext, v7);
      }
    }
    else
    {
      v4 = j_va("'%s' - Invalid CSpline Id '%i'\n", "GetCSplinePointTangent", v3);
      Scr_Error(COM_ERR_4687, scrContext, v4);
    }
  }
  else
  {
    Scr_Error(COM_ERR_4703, scrContext, "USAGE: GetCSplinePointTangent(splineId, splineNodeIndex)\n");
  }
}

/*
==============
ScrCmd_GetNonStick
==============
*/
void ScrCmd_GetNonStick(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( !Entity )
    Scr_Error(COM_ERR_4090, scrContext, "GetNonStick() invoked on invalid entity.");
  Scr_AddBool(scrContext, (Entity->flags.m_flags[0] >> 12) & 1);
}

/*
==============
ScrCmd_SetScriptableBeamLength
==============
*/
void ScrCmd_SetScriptableBeamLength(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  double Float; 
  const char *v5; 
  const char *v6; 

  Entity = GetEntity(entref);
  if ( !Entity )
    Scr_Error(COM_ERR_4091, scrContext, "SetScriptableBeamLength() invoked on invalid entity.");
  Float = Scr_GetFloat(scrContext, 0);
  if ( *(float *)&Float > 10000.0 )
  {
    v5 = j_va("SetScriptableBeamLength() length is longer than LERP_ENTITY_STATE_MISSILE_EFFECT_MAX_LENGTH %f\n", DOUBLE_10000_0);
    Scr_Error(COM_ERR_4092, scrContext, v5);
  }
  if ( Entity->s.eType != ET_MISSILE )
  {
    v6 = j_va("SetScriptableBeamLength() currently only supports missile ents, but could be changed by code with additional work and bandwidth cost.\n");
    Scr_Error(COM_ERR_4093, scrContext, v6);
  }
  Entity->s.lerp.u.anonymous.data[6] = MSG_PackUnsignedFloat(*(float *)&Float, 10000.0, 0x10u);
}

/*
==============
GScr_GetCSplinePointDistToNextPoint
==============
*/
void GScr_GetCSplinePointDistToNextPoint(scrContext_t *scrContext)
{
  int Int; 
  unsigned int v3; 
  const char *v4; 
  int v5; 
  unsigned __int16 v6; 
  const char *v7; 
  double CSplinePointDistToNextPoint; 

  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    Int = Scr_GetInt(scrContext, 0);
    v3 = truncate_cast<unsigned short,int>(Int);
    if ( v3 <= Com_GetCSplineCount() )
    {
      v5 = Scr_GetInt(scrContext, 1u);
      v6 = truncate_cast<unsigned short,int>(v5);
      if ( v6 < Com_GetCSplinePointCount(v3) )
      {
        CSplinePointDistToNextPoint = Com_GetCSplinePointDistToNextPoint(v3, v6);
        Scr_AddFloat(scrContext, *(float *)&CSplinePointDistToNextPoint);
      }
      else
      {
        v7 = j_va("'%s' - Invalid CSpline Node Index '%i' for Spline '%i'\n", "GetCSplinePointDistToNextPoint", v6, v3);
        Scr_Error(COM_ERR_4688, scrContext, v7);
      }
    }
    else
    {
      v4 = j_va("'%s' - Invalid CSpline Id '%i'\n", "GetCSplinePointDistToNextPoint", v3);
      Scr_Error(COM_ERR_4687, scrContext, v4);
    }
  }
  else
  {
    Scr_Error(COM_ERR_4704, scrContext, "USAGE: GetCSplinePointDistToNextPoint(splineId, splineNodeIndex)\n");
  }
}

/*
==============
GScr_CalcCSplinePosition
==============
*/
void GScr_CalcCSplinePosition(scrContext_t *scrContext)
{
  int Int; 
  unsigned int v3; 
  const char *v4; 
  int v5; 
  unsigned __int16 v6; 
  const char *v7; 
  ComErrorCode v8; 
  double Float; 
  unsigned int v10; 
  vec3_t out_position; 

  if ( Scr_GetNumParam(scrContext) != 3 )
  {
    Scr_Error(COM_ERR_4705, scrContext, "USAGE: CalcCSplinePosition(splineId, splineNodeIndex, lambda)\n");
    return;
  }
  Int = Scr_GetInt(scrContext, 0);
  v3 = truncate_cast<unsigned short,int>(Int);
  if ( v3 > Com_GetCSplineCount() )
  {
    v4 = j_va("'%s' - Invalid CSpline Id '%i'\n", "CalcCSplinePosition", v3);
    Scr_Error(COM_ERR_4687, scrContext, v4);
    return;
  }
  v5 = Scr_GetInt(scrContext, 1u);
  v6 = truncate_cast<unsigned short,int>(v5);
  if ( v6 < Com_GetCSplinePointCount(v3) )
  {
    Float = Scr_GetFloat(scrContext, 2u);
    if ( *(float *)&Float >= 0.0 && *(float *)&Float <= 1.0 )
    {
      Com_CalcCSplinePosition(v3, v6, *(float *)&Float, &out_position);
      Scr_AddVector(scrContext, out_position.v);
      return;
    }
    v10 = v3;
    v7 = j_va("'%s' - Invalid CSpline Lambda '%f' for Index '%i' for Spline '%i'\n", "CalcCSplinePosition", *(float *)&Float, v6, v10);
    v8 = COM_ERR_4689;
  }
  else
  {
    v7 = j_va("'%s' - Invalid CSpline Node Index '%i' for Spline '%i'\n", "CalcCSplinePosition", v6, v3);
    v8 = COM_ERR_4688;
  }
  Scr_Error(v8, scrContext, v7);
}

/*
==============
ScrCmd_SetNoDeploy
==============
*/
void ScrCmd_SetNoDeploy(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  unsigned int v5; 

  Entity = GetEntity(entref);
  if ( !Entity )
    Scr_Error(COM_ERR_4094, scrContext, "SetNoDeploy() invoked on invalid entity.");
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4095, scrContext, "USAGE: <ent> SetNoDeploy( <bool> )\n");
  Int = Scr_GetInt(scrContext, 0);
  v5 = Entity->flags.m_flags[0] & 0xF7FFFFFF;
  if ( Int )
    v5 = Entity->flags.m_flags[0] | 0x8000000;
  Entity->flags.m_flags[0] = v5;
}

/*
==============
GScr_CalcCSplineTangent
==============
*/
void GScr_CalcCSplineTangent(scrContext_t *scrContext)
{
  int Int; 
  unsigned int v3; 
  const char *v4; 
  int v5; 
  unsigned __int16 v6; 
  const char *v7; 
  ComErrorCode v8; 
  double Float; 
  unsigned int v10; 
  vec3_t out_tangent; 

  if ( Scr_GetNumParam(scrContext) != 3 )
  {
    Scr_Error(COM_ERR_4706, scrContext, "USAGE: CalcCSplineTangent(splineId, splineNodeIndex, lambda)\n");
    return;
  }
  Int = Scr_GetInt(scrContext, 0);
  v3 = truncate_cast<unsigned short,int>(Int);
  if ( v3 > Com_GetCSplineCount() )
  {
    v4 = j_va("'%s' - Invalid CSpline Id '%i'\n", "CalcCSplineTangent", v3);
    Scr_Error(COM_ERR_4687, scrContext, v4);
    return;
  }
  v5 = Scr_GetInt(scrContext, 1u);
  v6 = truncate_cast<unsigned short,int>(v5);
  if ( v6 < Com_GetCSplinePointCount(v3) )
  {
    Float = Scr_GetFloat(scrContext, 2u);
    if ( *(float *)&Float >= 0.0 && *(float *)&Float <= 1.0 )
    {
      Com_CalcCSplineTangent(v3, v6, *(float *)&Float, &out_tangent);
      Scr_AddVector(scrContext, out_tangent.v);
      return;
    }
    v10 = v3;
    v7 = j_va("'%s' - Invalid CSpline Lambda '%f' for Index '%i' for Spline '%i'\n", "CalcCSplineTangent", *(float *)&Float, v6, v10);
    v8 = COM_ERR_4689;
  }
  else
  {
    v7 = j_va("'%s' - Invalid CSpline Node Index '%i' for Spline '%i'\n", "CalcCSplineTangent", v6, v3);
    v8 = COM_ERR_4688;
  }
  Scr_Error(v8, scrContext, v7);
}

/*
==============
GScr_CalcCSplineCorridor
==============
*/
void GScr_CalcCSplineCorridor(scrContext_t *scrContext)
{
  int Int; 
  unsigned int v3; 
  const char *v4; 
  int v5; 
  unsigned __int16 v6; 
  const char *v7; 
  ComErrorCode v8; 
  double Float; 
  unsigned int v10; 
  vec2_t out_dims; 

  if ( Scr_GetNumParam(scrContext) != 3 )
  {
    Scr_Error(COM_ERR_4707, scrContext, "USAGE: CalcCSplineCorridor(splineId, splineNodeIndex, lambda)\n");
    return;
  }
  Int = Scr_GetInt(scrContext, 0);
  v3 = truncate_cast<unsigned short,int>(Int);
  if ( v3 > Com_GetCSplineCount() )
  {
    v4 = j_va("'%s' - Invalid CSpline Id '%i'\n", "CalcCSplineCorridor", v3);
    Scr_Error(COM_ERR_4687, scrContext, v4);
    return;
  }
  v5 = Scr_GetInt(scrContext, 1u);
  v6 = truncate_cast<unsigned short,int>(v5);
  if ( v6 < Com_GetCSplinePointCount(v3) )
  {
    Float = Scr_GetFloat(scrContext, 2u);
    if ( *(float *)&Float >= 0.0 && *(float *)&Float <= 1.0 )
    {
      Com_CalcCSplineCorridor(v3, v6, *(float *)&Float, &out_dims);
      Scr_AddVector(scrContext, (const float *)&out_dims);
      return;
    }
    v10 = v3;
    v7 = j_va("'%s' - Invalid CSpline Lambda '%f' for Index '%i' for Spline '%i'\n", "CalcCSplineCorridor", *(float *)&Float, v6, v10);
    v8 = COM_ERR_4689;
  }
  else
  {
    v7 = j_va("'%s' - Invalid CSpline Node Index '%i' for Spline '%i'\n", "CalcCSplineCorridor", v6, v3);
    v8 = COM_ERR_4688;
  }
  Scr_Error(v8, scrContext, v7);
}

/*
==============
GScr_CalcCSplineClosestPoint
==============
*/
void GScr_CalcCSplineClosestPoint(scrContext_t *scrContext)
{
  int Int; 
  unsigned int v3; 
  const char *v4; 
  unsigned __int16 out_splinePointIndex[2]; 
  float out_lambda; 
  vec3_t vectorValue; 
  vec3_t out_position; 

  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    Int = Scr_GetInt(scrContext, 0);
    v3 = truncate_cast<unsigned short,int>(Int);
    if ( v3 <= Com_GetCSplineCount() )
    {
      Scr_GetVector(scrContext, 1u, &vectorValue);
      Com_CalcCSplineClosestPointOnSpline(v3, &vectorValue, out_splinePointIndex, &out_lambda);
      Com_CalcCSplinePosition(v3, out_splinePointIndex[0], out_lambda, &out_position);
      Scr_AddVector(scrContext, out_position.v);
    }
    else
    {
      v4 = j_va("'%s' - Invalid CSpline Id '%i'\n", "CalcCSplineClosestPoint", v3);
      Scr_Error(COM_ERR_4687, scrContext, v4);
    }
  }
  else
  {
    Scr_Error(COM_ERR_4708, scrContext, "USAGE: CalcCSplineClosestPoint(splineId, point)\n");
  }
}

/*
==============
GScr_LocalToWorldCoords
==============
*/
void GScr_LocalToWorldCoords(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  vec3_t vectorValue; 
  float value; 
  float v6; 
  float v7; 
  tmat33_t<vec3_t> axis; 

  Entity = GetEntity(entref);
  Scr_GetVector(scrContext, 0, &vectorValue);
  AnglesToAxis(&Entity->r.currentAngles, &axis);
  value = (float)((float)(axis.m[0].v[0] * vectorValue.v[0]) + (float)(axis.m[1].v[0] * vectorValue.v[1])) + (float)(vectorValue.v[2] * axis.m[2].v[0]);
  v6 = (float)((float)(axis.m[0].v[1] * vectorValue.v[0]) + (float)(axis.m[1].v[1] * vectorValue.v[1])) + (float)(vectorValue.v[2] * axis.m[2].v[1]);
  v7 = (float)((float)(axis.m[0].v[2] * vectorValue.v[0]) + (float)(axis.m[1].v[2] * vectorValue.v[1])) + (float)(vectorValue.v[2] * axis.m[2].v[2]);
  value = value + Entity->r.currentOrigin.v[0];
  v6 = v6 + Entity->r.currentOrigin.v[1];
  v7 = v7 + Entity->r.currentOrigin.v[2];
  Scr_AddVector(scrContext, &value);
}

/*
==============
GScr_GameDVRProhibitRecording
==============
*/
void GScr_GameDVRProhibitRecording(scrContext_t *scrContext)
{
  int Int; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4709, scrContext, "USAGE: ProhibitRecording( prohibit )\n");
  Int = Scr_GetInt(scrContext, 0);
  GameDVR_ProhibitRecording(Int != 0);
}

/*
==============
GScr_GameDVRStartRecording
==============
*/

void __fastcall GScr_GameDVRStartRecording(scrContext_t *scrContext)
{
  GameDVR_StartRecording();
}

/*
==============
GScr_GameDVRStopRecording
==============
*/
void GScr_GameDVRStopRecording(scrContext_t *scrContext)
{
  int Int; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4710, scrContext, "USAGE: StopRecording( discard )\n");
  Int = Scr_GetInt(scrContext, 0);
  GameDVR_StopRecording(Int != 0);
}

/*
==============
GScr_GameDVRSetVideoMetadata
==============
*/
void GScr_GameDVRSetVideoMetadata(scrContext_t *scrContext)
{
  const char *String; 
  const char *v3; 
  const char *v4; 
  const char *v5; 

  if ( Scr_GetNumParam(scrContext) != 4 )
    Scr_Error(COM_ERR_4711, scrContext, "USAGE: SetVideoMetadata( title, description, comment, copyright )\n");
  String = Scr_GetString(scrContext, 3u);
  v3 = Scr_GetString(scrContext, 2u);
  v4 = Scr_GetString(scrContext, 1u);
  v5 = Scr_GetString(scrContext, 0);
  GameDVR_SetVideoMetadata(v5, v4, v3, String);
}

/*
==============
GScr_Earthquake
==============
*/
void GScr_Earthquake(scrContext_t *scrContext)
{
  GScr_Earthquake_Internal(scrContext, -1);
}

/*
==============
GScr_GameDVRProhibitScreenshots
==============
*/
void GScr_GameDVRProhibitScreenshots(scrContext_t *scrContext)
{
  int Int; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_4712, scrContext, "USAGE: ProhibitScreenshots( prohibit )\n");
  Int = Scr_GetInt(scrContext, 0);
  GameDVR_ProhibitScreenshots(Int != 0);
}

/*
==============
GScr_EarthquakeForPlayer
==============
*/
void GScr_EarthquakeForPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  scr_string_t targetname; 
  const char *v7; 
  const char *v8; 
  const char *v9; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
LABEL_8:
    if ( !v4->client )
    {
      targetname = v4->targetname;
      if ( targetname )
        v7 = SL_ConvertToString(targetname);
      else
        v7 = "<undefined>";
      v8 = SL_ConvertToString(v4->classname);
      v9 = j_va("only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, v4->r.currentOrigin.v[0], v4->r.currentOrigin.v[1], v4->r.currentOrigin.v[2], v8, v7);
      Scr_Error(COM_ERR_4099, scrContext, v9);
    }
    goto LABEL_13;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 6374, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  if ( !v4->client )
  {
    v5 = j_va("entity %i is not a player", entnum);
    Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    goto LABEL_8;
  }
LABEL_13:
  GScr_Earthquake_Internal(scrContext, v4->s.number);
}

/*
==============
GScr_GameDVRSetScreenshotMetadata
==============
*/
void GScr_GameDVRSetScreenshotMetadata(scrContext_t *scrContext)
{
  const char *String; 
  const char *v3; 
  const char *v4; 

  if ( Scr_GetNumParam(scrContext) != 3 )
    Scr_Error(COM_ERR_4713, scrContext, "USAGE: SetScreenshotMetadata( game, title, comment )\n");
  String = Scr_GetString(scrContext, 2u);
  v3 = Scr_GetString(scrContext, 1u);
  v4 = Scr_GetString(scrContext, 0);
  GameDVR_SetScreenshotMetadata(v4, v3, String);
}

/*
==============
GScr_LiveStreamingEnable
==============
*/
void GScr_LiveStreamingEnable(scrContext_t *scrContext)
{
  ;
}

/*
==============
GScr_LiveStreamingSetBitrate
==============
*/
void GScr_LiveStreamingSetBitrate(scrContext_t *scrContext)
{
  ;
}

/*
==============
GScr_StopShellShock
==============
*/
void GScr_StopShellShock(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  playerState_s *EntityPlayerState; 

  entnum = entref.entnum;
  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 6399, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClientOrAgent(Entity) )
  {
    targetname = Entity->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(Entity->classname);
    v8 = j_va("only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, Entity->r.currentOrigin.v[0], Entity->r.currentOrigin.v[1], Entity->r.currentOrigin.v[2], v7, v6);
    Scr_Error(COM_ERR_4100, scrContext, v8);
  }
  EntityPlayerState = G_GetEntityPlayerState(Entity);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 6405, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_4101, scrContext, "USAGE: <player> stopshellshock()\n");
  *(_QWORD *)&EntityPlayerState->shellshockIndex = 0i64;
  EntityPlayerState->shellshockDuration = 0;
  GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(&EntityPlayerState->pm_flags, ACTIVE, 0x15u);
}

/*
==============
GScr_FadeOutShellShock
==============
*/
void GScr_FadeOutShellShock(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  playerState_s *EntityPlayerState; 
  shellshock_parms_t *ShellshockParms; 
  int fadeTime; 
  int shellshockDuration; 
  int time; 
  gclient_s *client; 
  __int64 v15; 
  const char *v16; 
  unsigned int v17; 
  unsigned __int16 v18; 
  unsigned int v19; 

  entnum = entref.entnum;
  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 6437, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClientOrAgent(Entity) )
  {
    targetname = Entity->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(Entity->classname);
    v8 = j_va("only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, Entity->r.currentOrigin.v[0], Entity->r.currentOrigin.v[1], Entity->r.currentOrigin.v[2], v7, v6);
    Scr_Error(COM_ERR_4102, scrContext, v8);
  }
  EntityPlayerState = G_GetEntityPlayerState(Entity);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 6443, ASSERT_TYPE_ASSERT, "( ps )", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_4103, scrContext, "USAGE: <player> FadeOutShellShock()\n");
  if ( GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&EntityPlayerState->pm_flags, ACTIVE, 0x15u) && EntityPlayerState->shellshockDuration )
  {
    ShellshockParms = BG_GetShellshockParms(EntityPlayerState->shellshockIndex);
    if ( !ShellshockParms && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 6454, ASSERT_TYPE_ASSERT, "(shockParms)", (const char *)&queryFormat, "shockParms") )
      __debugbreak();
    fadeTime = ShellshockParms->view.fadeTime;
    shellshockDuration = EntityPlayerState->shellshockDuration;
    time = level.time;
    if ( shellshockDuration + EntityPlayerState->shellshockTime - fadeTime > level.time )
    {
      client = Entity->client;
      v15 = (unsigned int)(level.time + fadeTime - client->ps.shellshockTime);
      if ( (int)v15 > 0xFFFF )
      {
        v16 = j_va("Invalid shellshockDuration %d. It must be < %d\n", v15, 0xFFFFi64);
        Scr_Error(COM_ERR_4104, scrContext, v16);
        LOWORD(shellshockDuration) = EntityPlayerState->shellshockDuration;
        client = Entity->client;
        fadeTime = ShellshockParms->view.fadeTime;
        time = level.time;
      }
      v17 = shellshockDuration & 0x7F;
      v18 = truncate_cast<unsigned short,int>(time + fadeTime - client->ps.shellshockTime);
      EntityPlayerState->shellshockDuration = v18;
      v19 = v18 & 0x7F;
      if ( v17 > v19 )
        EntityPlayerState->shellshockDuration += truncate_cast<unsigned short,int>(v17 - v19);
    }
  }
}

/*
==============
ScrCmd_SetModel
==============
*/
void ScrCmd_SetModel(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *String; 
  bool IsNameCompositeModel; 
  const char *v6; 
  unsigned __int16 model; 
  const DObj *ServerDObjForEnt; 
  DObj *v9; 
  const char *v10; 

  Entity = GetEntity(entref);
  String = Scr_GetString(scrContext, 0);
  IsNameCompositeModel = G_Utils_IsNameCompositeModel(String);
  if ( !GUtils::ms_gUtils && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_utils.h", 112, ASSERT_TYPE_ASSERT, "( ms_gUtils )", (const char *)&queryFormat, "ms_gUtils") )
    __debugbreak();
  if ( GUtils::ms_gUtils->IsTransientCustomizationModel(GUtils::ms_gUtils, String) )
  {
    v6 = j_va("Can't set the model '%s' to a transient model from the server", String);
    Scr_Error(COM_ERR_4105, scrContext, v6);
  }
  G_XCompositeModel_Clear(Entity->s.eType, Entity);
  if ( IsNameCompositeModel )
    G_Utils_SetCompositeModel(Entity, Entity->s.eType, String);
  else
    G_Utils_SetModel(Entity, String);
  model = Entity->model;
  if ( model && G_Utils_IsModelBad(model) && G_Utils_IsActor(Entity) )
  {
    Com_PrintWarning(23, "WARNING: actor model '%s' couldn't be found! switching to default actor model.\n", String);
    G_Utils_OverrideModel(Entity->model, "defaultactor");
  }
  if ( Com_GameMode_SupportsFeature(WEAPON_DROPPING_ALT) )
  {
    ServerDObjForEnt = Com_GetServerDObjForEnt(Entity);
    if ( ServerDObjForEnt )
    {
      if ( DObjGetTree(ServerDObjForEnt) && !Entity->model )
        Scr_Error(COM_ERR_4106, scrContext, "Cannot remove an entity's model while it is playing an animation. Call scriptmodelclearanim first.\n");
    }
  }
  if ( !GUtils::ms_gUtils && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_utils.h", 112, ASSERT_TYPE_ASSERT, "( ms_gUtils )", (const char *)&queryFormat, "ms_gUtils") )
    __debugbreak();
  GUtils::ms_gUtils->DObjUpdate(GUtils::ms_gUtils, Entity, 1);
  if ( Entity->s.eType == ET_TURRET )
    G_Turret_SetDObjTransferFlag(Entity);
  v9 = Com_GetServerDObjForEnt(Entity);
  if ( v9 )
  {
    if ( (v9->flags & 0x10) != 0 )
    {
      v10 = j_va("Trying to set model for entity in a way where the existing child models will no longer have the correct attach bones, this will cause child models to appear in front of the camera. %s\n", String);
      Scr_Error(COM_ERR_4107, scrContext, v10);
    }
  }
}

/*
==============
ScrCmd_SetAsGametypeObjective
==============
*/
void ScrCmd_SetAsGametypeObjective(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  HudData *HudData; 

  if ( MLG_IsCoDCasterEnabled() )
  {
    Entity = GetEntity(entref);
    HudData = G_HudOutline_GetHudData(Entity);
    if ( !HudData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 6581, ASSERT_TYPE_ASSERT, "( hudData ) != ( nullptr )", "%s != %s\n\t%p, %p", "hudData", "nullptr", NULL, NULL) )
      __debugbreak();
    HudData->data |= 0x40u;
  }
}

/*
==============
GScr_ScriptBundleContextScoped::~GScr_ScriptBundleContextScoped
==============
*/
void GScr_ScriptBundleContextScoped::~GScr_ScriptBundleContextScoped(GScr_ScriptBundleContextScoped *this)
{
  *this->scoped = this->saved;
}

/*
==============
AddLinkedChildren
==============
*/
void AddLinkedChildren(scrContext_t *scrContext, const gentity_s *parent, int fullTree)
{
  gentity_s *i; 
  __int64 v6; 
  __int64 v7; 
  __int64 number; 
  scrContext_t *v9; 
  __int64 v10; 
  __int64 v11; 
  __int64 v12; 
  __int64 v13; 

  for ( i = parent->tagChildren; i; i = i->tagInfo->next )
  {
    if ( fullTree )
      AddLinkedChildren(scrContext, i, fullTree);
    if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 196, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
      __debugbreak();
    v6 = i - g_entities;
    if ( (unsigned int)v6 >= 0x800 )
    {
      LODWORD(v11) = 2048;
      LODWORD(v10) = ((int)i - (int)g_entities) / 1456;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 199, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( ( 2048 ) )", "index doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v10, v11) )
        __debugbreak();
    }
    if ( i->s.number != (_WORD)v6 )
    {
      if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 196, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
        __debugbreak();
      v7 = i - g_entities;
      if ( (unsigned int)v7 >= 0x800 )
      {
        LODWORD(v11) = 2048;
        LODWORD(v10) = ((int)i - (int)g_entities) / 1456;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 199, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( ( 2048 ) )", "index doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v10, v11) )
          __debugbreak();
      }
      LODWORD(v13) = (__int16)v7;
      LODWORD(v12) = i->s.number;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 948, ASSERT_TYPE_ASSERT, "( ent->s.number ) == ( G_GetEntityIndex( ent ) )", "%s == %s\n\t%i, %i", "ent->s.number", "G_GetEntityIndex( ent )", v12, v13) )
        __debugbreak();
    }
    number = i->s.number;
    if ( (unsigned int)number >= 0x800 )
    {
      LODWORD(v11) = 2048;
      LODWORD(v10) = i->s.number;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v10, v11) )
        __debugbreak();
    }
    if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
      __debugbreak();
    if ( g_entities[number].r.isInUse != g_entityIsInUse[number] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
      __debugbreak();
    if ( !g_entityIsInUse[number] )
    {
      LODWORD(v10) = i->s.number;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 949, ASSERT_TYPE_ASSERT, "( ( G_IsEntityInUse( ent->s.number ) ) )", "( ent->s.number ) = %i", v10) )
        __debugbreak();
    }
    v9 = ScriptContext_Server();
    Scr_AddEntityNum(v9, i->s.number, ENTITY_CLASS_GENTITY);
    Scr_AddArray(scrContext);
  }
}

/*
==============
AttachCmd
==============
*/
char AttachCmd(scrContext_t *scrContext, gentity_s *ent, scr_string_t *tagNameResult)
{
  const char *String; 
  scr_string_t ConstLowercaseString; 
  bool v8; 
  GUtils *v9; 
  const dvar_t *v10; 
  bool enabled; 
  const char *v12; 
  const char *v13; 
  const dvar_t *v14; 
  bool v15; 
  const char *v16; 
  const char *v17; 
  BOOL fmt; 
  BOOL v20; 
  bool v21; 

  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 6966, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  String = Scr_GetString(scrContext, 0);
  if ( Scr_GetNumParam(scrContext) < 2 )
    ConstLowercaseString = scr_const._;
  else
    ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 1u);
  v21 = Scr_GetNumParam(scrContext) >= 3 && Scr_GetInt(scrContext, 2u) != 0;
  v8 = Scr_GetNumParam(scrContext) >= 4 && Scr_GetInt(scrContext, 3u) != 0;
  if ( !GUtils::ms_gUtils && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_utils.h", 112, ASSERT_TYPE_ASSERT, "( ms_gUtils )", (const char *)&queryFormat, "ms_gUtils") )
    __debugbreak();
  v9 = GUtils::ms_gUtils;
  if ( GUtils::ms_gUtils->IsTransientCustomizationModel(GUtils::ms_gUtils, String) )
    Scr_Error(COM_ERR_4116, scrContext, "Should not be using transient models on the server");
  if ( v9->EntDetach(v9, ent, String, ConstLowercaseString) )
  {
    v10 = DVARBOOL_g_assertOnModelAttachFailure;
    if ( !DVARBOOL_g_assertOnModelAttachFailure && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "g_assertOnModelAttachFailure") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v10);
    enabled = v10->current.enabled;
    v12 = SL_ConvertToString(ConstLowercaseString);
    if ( enabled )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 6986, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "model '%s' already attached to tag '%s'", String, v12) )
        __debugbreak();
    }
    else
    {
      v13 = j_va("model '%s' already attached to tag '%s'", String, v12);
      Scr_Error(COM_ERR_4117, scrContext, v13);
    }
  }
  LOBYTE(v20) = v8;
  LOBYTE(fmt) = v21;
  if ( !v9->EntAttach(v9, ent, String, ConstLowercaseString, fmt, v20) )
  {
    v14 = DVARBOOL_g_assertOnModelAttachFailure;
    if ( !DVARBOOL_g_assertOnModelAttachFailure && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "g_assertOnModelAttachFailure") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v14);
    v15 = v14->current.enabled;
    v16 = SL_ConvertToString(ConstLowercaseString);
    if ( v15 )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 7000, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "failed to attach model '%s' to tag '%s'", String, v16) )
        __debugbreak();
    }
    else
    {
      v17 = j_va("failed to attach model '%s' to tag '%s'", String, v16);
      Scr_Error(COM_ERR_4118, scrContext, v17);
    }
  }
  *tagNameResult = ConstLowercaseString;
  return 1;
}

/*
==============
CheckTimes
==============
*/
void CheckTimes(scrContext_t *scrContext, float *totalTime, float accelTime, float decelTime)
{
  float v6; 

  if ( *totalTime < 0.0 )
    Scr_Error(COM_ERR_4185, scrContext, "total time must be non negative");
  if ( accelTime < 0.0 )
    Scr_Error(COM_ERR_4186, scrContext, "acceleration time must be non negative");
  if ( decelTime < 0.0 )
    Scr_Error(COM_ERR_4187, scrContext, "deceleration time must be non negative");
  v6 = *totalTime;
  if ( (float)(accelTime + decelTime) > *totalTime )
  {
    if ( (float)(accelTime + decelTime) <= (float)(v6 + 1.0000005) )
      *totalTime = v6 + 1.0000005;
    else
      Scr_Error(COM_ERR_4188, scrContext, "accel time plus decel time is greater than total time");
  }
}

/*
==============
CompareScriptObjectDistanceIncreasing
==============
*/
bool CompareScriptObjectDistanceIncreasing(const EntityOrigin *obj1, const EntityOrigin *obj2)
{
  return (float)((float)((float)((float)(g_entitySortOrigin.v[1] - obj2->origin.v[1]) * (float)(g_entitySortOrigin.v[1] - obj2->origin.v[1])) + (float)((float)(g_entitySortOrigin.v[0] - obj2->origin.v[0]) * (float)(g_entitySortOrigin.v[0] - obj2->origin.v[0]))) + (float)((float)(g_entitySortOrigin.v[2] - obj2->origin.v[2]) * (float)(g_entitySortOrigin.v[2] - obj2->origin.v[2]))) > (float)((float)((float)((float)(g_entitySortOrigin.v[1] - obj1->origin.v[1]) * (float)(g_entitySortOrigin.v[1] - obj1->origin.v[1])) + (float)((float)(g_entitySortOrigin.v[0] - obj1->origin.v[0]) * (float)(g_entitySortOrigin.v[0] - obj1->origin.v[0]))) + (float)((float)(g_entitySortOrigin.v[2] - obj1->origin.v[2]) * (float)(g_entitySortOrigin.v[2] - obj1->origin.v[2])));
}

/*
==============
DetachCmd
==============
*/
void DetachCmd(scrContext_t *scrContext, gentity_s *ent)
{
  const char *String; 
  scr_string_t ConstLowercaseString; 
  unsigned __int16 *attachModelNames; 
  __int64 v7; 
  scr_string_t *attachTagNames; 
  const char *v9; 
  const char *ModelName; 
  const char *v11; 
  const char *v12; 

  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 7608, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  String = Scr_GetString(scrContext, 0);
  if ( Scr_GetNumParam(scrContext) < 2 )
    ConstLowercaseString = scr_const._;
  else
    ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 1u);
  if ( !GUtils::ms_gUtils && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_utils.h", 112, ASSERT_TYPE_ASSERT, "( ms_gUtils )", (const char *)&queryFormat, "ms_gUtils") )
    __debugbreak();
  if ( !GUtils::ms_gUtils->EntDetach(GUtils::ms_gUtils, ent, String, ConstLowercaseString) )
  {
    Com_Printf(23, "Current attachments:\n");
    attachModelNames = ent->attachModelNames;
    v7 = 28i64;
    attachTagNames = ent->attachTagNames;
    do
    {
      if ( *attachModelNames )
      {
        if ( *attachTagNames )
        {
          v9 = SL_ConvertToString(*attachTagNames);
          ModelName = G_CString_GetModelName(*attachModelNames);
          Com_Printf(23, "model: '%s', tag: '%s'\n", ModelName, v9);
        }
      }
      ++attachTagNames;
      ++attachModelNames;
      --v7;
    }
    while ( v7 );
    v11 = SL_ConvertToString(ConstLowercaseString);
    v12 = j_va("failed to detach model '%s' from tag '%s'", String, v11);
    Scr_Error(COM_ERR_4139, scrContext, v12);
  }
}

/*
==============
GSCr_FilterPlayerMarks_AddEntRefInternal
==============
*/
void GSCr_FilterPlayerMarks_AddEntRefInternal(scrContext_t *scrContext, const scr_entref_t filterEntRef, unsigned int (*entFilterBits)[7])
{
  unsigned int entnum; 
  int v6; 
  int v7; 
  int v8; 

  entnum = filterEntRef.entnum;
  if ( filterEntRef.entclass )
    Scr_ParamError(COM_ERR_6354, scrContext, 0, "Invalid mark filter specified. Not a player entity.");
  v6 = truncate_cast<short,unsigned int>(entnum);
  if ( v6 > level.maxclients || (v6 & 0x8000u) != 0 )
    Scr_ParamError(COM_ERR_6355, scrContext, 0, "Invalid mark filter specified. Not a player entity.");
  if ( (unsigned __int16)((__int16)v6 >> 5) >= 7u )
  {
    v8 = 7;
    v7 = v6 >> 5;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31810, ASSERT_TYPE_ASSERT, "(unsigned)( entNum >> 5 ) < (unsigned)( ( sizeof( *array_counter( entFilterBits ) ) + 0 ) )", "entNum >> 5 doesn't index ARRAY_COUNT( entFilterBits )\n\t%i not in [0, %i)", v7, v8) )
      __debugbreak();
  }
  (*entFilterBits)[(__int64)(__int16)v6 >> 5] |= 0x80000000 >> (v6 & 0x1F);
}

/*
==============
GScr_AddEntity
==============
*/
void GScr_AddEntity(const gentity_s *ent)
{
  signed __int64 v2; 
  signed __int64 v3; 
  __int64 number; 
  scrContext_t *v5; 
  __int64 v6; 
  __int64 v7; 

  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 947, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 196, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
    __debugbreak();
  v2 = ent - g_entities;
  if ( (unsigned int)v2 >= 0x800 )
  {
    LODWORD(v6) = ent - g_entities;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 199, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( ( 2048 ) )", "index doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v6, 2048) )
      __debugbreak();
  }
  if ( ent->s.number != (_WORD)v2 )
  {
    if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 196, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
      __debugbreak();
    v3 = ent - g_entities;
    if ( (unsigned int)v3 >= 0x800 )
    {
      LODWORD(v7) = 2048;
      LODWORD(v6) = ((int)ent - (int)g_entities) / 1456;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 199, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( ( 2048 ) )", "index doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v6, v7) )
        __debugbreak();
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 948, ASSERT_TYPE_ASSERT, "( ent->s.number ) == ( G_GetEntityIndex( ent ) )", "%s == %s\n\t%i, %i", "ent->s.number", "G_GetEntityIndex( ent )", ent->s.number, (__int16)v3) )
      __debugbreak();
  }
  number = ent->s.number;
  if ( (unsigned int)number >= 0x800 )
  {
    LODWORD(v7) = 2048;
    LODWORD(v6) = ent->s.number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v6, v7) )
      __debugbreak();
  }
  if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
    __debugbreak();
  if ( g_entities[number].r.isInUse != g_entityIsInUse[number] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
    __debugbreak();
  if ( !g_entityIsInUse[number] )
  {
    LODWORD(v6) = ent->s.number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 949, ASSERT_TYPE_ASSERT, "( ( G_IsEntityInUse( ent->s.number ) ) )", "( ent->s.number ) = %i", v6) )
      __debugbreak();
  }
  v5 = ScriptContext_Server();
  Scr_AddEntityNum(v5, ent->s.number, ENTITY_CLASS_GENTITY);
}

/*
==============
GScr_AllocString
==============
*/
scr_string_t GScr_AllocString(const char *s)
{
  return Scr_AllocGameString(s, 1);
}

/*
==============
GScr_CheckRocketEntity
==============
*/
void GScr_CheckRocketEntity(scrContext_t *scrContext, gentity_s *missile)
{
  entityType_s eType; 
  const char *v5; 
  scr_string_t classname; 
  const char *v7; 
  const char *v8; 
  const char *v9; 

  if ( !missile && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 5779, ASSERT_TYPE_ASSERT, "(missile)", (const char *)&queryFormat, "missile") )
    __debugbreak();
  eType = missile->s.eType;
  if ( eType != ET_MISSILE )
  {
    v5 = j_va("Entity %i is not a rocket - eType '%i'\n", (unsigned int)missile->s.number, (unsigned int)eType);
    Scr_Error(COM_ERR_4074, scrContext, v5);
  }
  classname = missile->classname;
  if ( classname != scr_const.rocket )
  {
    v7 = SL_ConvertToString(classname);
    v8 = j_va("Entity %i is not a rocket - classname '%s'\n", (unsigned int)missile->s.number, v7);
    Scr_Error(COM_ERR_4075, scrContext, v8);
  }
  if ( G_Missile_IsGrenade(missile) )
  {
    v9 = j_va("Entity %i is not a rocket - it is a grenade\n", (unsigned int)missile->s.number);
    Scr_Error(COM_ERR_4076, scrContext, v9);
  }
}

/*
==============
GScr_DamageConeTraceInternal
==============
*/
void GScr_DamageConeTraceInternal(scrContext_t *scrContext, scr_entref_t entref, int contentMask)
{
  gentity_s *Entity; 
  gentity_s *v6; 
  double v7; 
  int v8; 
  vec3_t vectorValue; 

  Entity = GetEntity(entref);
  if ( Scr_GetNumParam(scrContext) <= 1 )
    v6 = NULL;
  else
    v6 = GScr_GetEntity(1u);
  Scr_GetVector(scrContext, 0, &vectorValue);
  if ( !GCombat::ms_gCombatSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_combat.h", 177, ASSERT_TYPE_ASSERT, "( ms_gCombatSystem )", (const char *)&queryFormat, "ms_gCombatSystem") )
    __debugbreak();
  LOBYTE(v8) = 0;
  v7 = ((double (__fastcall *)(GCombat *, gentity_s *, gentity_s *, vec3_t *, int, int, _QWORD))GCombat::ms_gCombatSystem->GetRadiusDamageFromPos)(GCombat::ms_gCombatSystem, Entity, v6, &vectorValue, contentMask, v8, 0i64);
  Scr_AddFloat(scrContext, *(float *)&v7);
}

/*
==============
GScr_Earthquake_Internal
==============
*/
void GScr_Earthquake_Internal(scrContext_t *scrContext, int clientNum)
{
  unsigned __int64 v2; 
  double Float; 
  float v5; 
  int v8; 
  double v9; 
  const dvar_t *v10; 
  gentity_s *v11; 
  int v12; 
  int v13; 
  vec3_t vectorValue; 

  v2 = (unsigned int)clientNum;
  Float = Scr_GetFloat(scrContext, 0);
  v5 = *(float *)&Float;
  Scr_GetFloat(scrContext, 1u);
  _XMM1 = 0i64;
  __asm { vroundss xmm5, xmm1, xmm4, 1 }
  v8 = (int)*(float *)&_XMM5;
  Scr_GetVector(scrContext, 2u, &vectorValue);
  v9 = Scr_GetFloat(scrContext, 3u);
  if ( v5 <= 0.0 )
    Scr_ParamError(COM_ERR_4096, scrContext, 0, "Scale must be greater than 0");
  if ( v8 <= 0 )
    Scr_ParamError(COM_ERR_4097, scrContext, 1u, "duration must be greater than 0");
  if ( *(float *)&v9 < 0.0 )
    Scr_ParamError(COM_ERR_4098, scrContext, 3u, "Radius must be greater than 0");
  v10 = DVARBOOL_g_earthquakeEnable;
  if ( !DVARBOOL_g_earthquakeEnable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "g_earthquakeEnable") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v10);
  if ( v10->current.enabled )
  {
    v11 = G_Utils_SpawnEventEntity(&vectorValue, 134);
    v11->s.eventParm = 0;
    v11->s.eventParm2 = 0;
    v11->s.lerp.u.anonymous.data[2] = v8;
    v11->s.lerp.u.turret.gunAngles.v[0] = v5;
    v11->s.lerp.u.turret.gunAngles.v[1] = *(float *)&v9;
    if ( (v2 & 0x80000000) != 0i64 )
    {
      *(_QWORD *)v11->clientMask.array = 0i64;
      *(_QWORD *)&v11->clientMask.array[2] = 0i64;
      *(_QWORD *)&v11->clientMask.array[4] = 0i64;
      v11->clientMask.array[6] = 0;
    }
    else
    {
      *(_QWORD *)v11->clientMask.array = -1i64;
      *(_QWORD *)&v11->clientMask.array[2] = -1i64;
      *(_QWORD *)&v11->clientMask.array[4] = -1i64;
      v11->clientMask.array[6] = -1;
      if ( (unsigned int)v2 >= 0xE0 )
      {
        v13 = 224;
        v12 = v2;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 290, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v12, v13) )
          __debugbreak();
      }
      v11->clientMask.array[v2 >> 5] &= ~(0x80000000 >> (v2 & 0x1F));
    }
  }
}

/*
==============
GScr_EntityGetAIScriptedData
==============
*/
actor_s *GScr_EntityGetAIScriptedData(scrContext_t *scrContext, gentity_s *ent)
{
  actor_s *result; 
  ai_scripted_t *AIScriptedData; 

  result = ent->actor;
  if ( !result )
  {
    AIScriptedData = Agent_GetAIScriptedData(ent);
    if ( !AIScriptedData )
      Scr_Error(COM_ERR_3941, scrContext, "Entity is not an actor or a Scripted Agent");
    return (actor_s *)AIScriptedData;
  }
  return result;
}

/*
==============
GScr_EntityGetShootAtPos
==============
*/
void GScr_EntityGetShootAtPos(scrContext_t *scrContext, gentity_s *ent, vec3_t *outShootAtPos)
{
  sentient_s *sentient; 
  gclient_s *client; 
  scr_string_t tag_eye; 

  sentient = ent->sentient;
  if ( !sentient )
  {
    tag_eye = scr_const.tag_eye;
    if ( ent->s.number != level.cachedEntTargetTagMat.entnum || level.time != level.cachedEntTargetTagMat.time || scr_const.tag_eye != level.cachedEntTargetTagMat.name )
    {
      if ( !SV_Game_DObjExists(ent) || !G_Utils_DObjGetWorldTagMatrix(ent, tag_eye, &level.cachedEntTargetTagMat.tagMat) )
      {
        G_Utils_EntityCentroid(ent, outShootAtPos);
        return;
      }
      level.cachedEntTargetTagMat.entnum = ent->s.number;
      level.cachedEntTargetTagMat.time = level.time;
      Scr_SetString(&level.cachedEntTargetTagMat.name, tag_eye);
    }
    *outShootAtPos = level.cachedEntTargetTagMat.tagMat.m[3];
    return;
  }
  client = ent->client;
  if ( client && client->sess.sessionState )
  {
    Com_PrintWarning(23, "GetShootAtPos() called while not in SESS_STATE_PLAYING");
    G_Utils_EntityCentroid(ent, outShootAtPos);
  }
  else
  {
    Sentient_GetEyePosition(sentient, outShootAtPos);
  }
}

/*
==============
GScr_ExecEntThread
==============
*/
unsigned int GScr_ExecEntThread(const gentity_s *ent, int handle, unsigned int paramcount)
{
  return GScr_ExecEntThreadWithReturnValue(ent, handle, paramcount, NULL, NULL, NULL);
}

/*
==============
GScr_ExecEntThreadWithReturnValue
==============
*/
unsigned int GScr_ExecEntThreadWithReturnValue(const gentity_s *ent, int handle, unsigned int paramcount, void (*callback)(scrContext_t *, const void *, void *), const void *cbUserData, void *outReturnValue)
{
  signed __int64 v10; 
  signed __int64 v11; 
  __int64 number; 
  scrContext_t *v13; 
  __int64 paramcounta; 
  void (__fastcall *callbacka)(scrContext_t *, const void *, void *); 

  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 875, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 196, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
    __debugbreak();
  v10 = ent - g_entities;
  if ( (unsigned int)v10 >= 0x800 )
  {
    LODWORD(paramcounta) = ent - g_entities;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 199, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( ( 2048 ) )", "index doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", paramcounta, 2048) )
      __debugbreak();
  }
  if ( ent->s.number != (_WORD)v10 )
  {
    if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 196, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
      __debugbreak();
    v11 = ent - g_entities;
    if ( (unsigned int)v11 >= 0x800 )
    {
      LODWORD(callbacka) = 2048;
      LODWORD(paramcounta) = ent - g_entities;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 199, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( ( 2048 ) )", "index doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", paramcounta, callbacka) )
        __debugbreak();
    }
    LODWORD(callbacka) = (__int16)v11;
    LODWORD(paramcounta) = ent->s.number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 876, ASSERT_TYPE_ASSERT, "( ent->s.number ) == ( G_GetEntityIndex( ent ) )", "ent->s.number == G_GetEntityIndex( ent )\n\t%i, %i", paramcounta, callbacka) )
      __debugbreak();
  }
  number = ent->s.number;
  if ( (unsigned int)number >= 0x800 )
  {
    LODWORD(callbacka) = 2048;
    LODWORD(paramcounta) = ent->s.number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", paramcounta, callbacka) )
      __debugbreak();
  }
  if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
    __debugbreak();
  if ( g_entities[number].r.isInUse != g_entityIsInUse[number] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
    __debugbreak();
  if ( !g_entityIsInUse[number] )
  {
    LODWORD(callbacka) = ent->s.number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 877, ASSERT_TYPE_ASSERT, "( ( G_IsEntityInUse( ent->s.number ) ) )", "%s\n\t( ent->s.number ) = %i", "( G_IsEntityInUse( ent->s.number ) )", callbacka) )
      __debugbreak();
  }
  if ( Sys_IsServerUserMoveWorker() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 878, ASSERT_TYPE_ASSERT, "(!Sys_IsServerUserMoveWorker())", "%s\n\tShouldn't process script from server worker threads", "!Sys_IsServerUserMoveWorker()") )
    __debugbreak();
  v13 = ScriptContext_Server();
  return Scr_ExecEntThreadNumWithReturnValue(v13, LOCAL_CLIENT_0, ent->s.number, ENTITY_CLASS_GENTITY, handle, paramcount, callback, cbUserData, outReturnValue);
}

/*
==============
GScr_ExecSpawnerThread
==============
*/
unsigned int GScr_ExecSpawnerThread(const spawner_t *spawner, int handle, unsigned int paramcount)
{
  scrContext_t *v6; 

  if ( !spawner && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 893, ASSERT_TYPE_ASSERT, "(spawner)", (const char *)&queryFormat, "spawner") )
    __debugbreak();
  v6 = ScriptContext_Server();
  return Scr_ExecEntThreadNumWithReturnValue(v6, LOCAL_CLIENT_0, spawner->number, ENTITY_CLASS_SPAWNER, handle, paramcount, NULL, NULL, NULL);
}

/*
==============
GScr_FilterPlayerMarks_Internal
==============
*/
void GScr_FilterPlayerMarks_Internal(scrContext_t *scrContext, unsigned int (*entFilterBits)[7])
{
  VariableType Type; 
  EntityMarkFilterType ActiveFilterType; 
  scr_string_t ConstString; 
  const char *String; 
  const char *v8; 
  __int64 v9; 
  __int64 v10; 
  __int64 v11; 
  team_t outTeam; 

  *(_QWORD *)entFilterBits = 0i64;
  *(_QWORD *)&(*entFilterBits)[2] = 0i64;
  *(_QWORD *)&(*entFilterBits)[4] = 0i64;
  (*entFilterBits)[6] = 0;
  if ( !Scr_GetNumParam(scrContext) )
    return;
  Type = Scr_GetType(scrContext, 0);
  if ( Type == VAR_UNDEFINED )
    return;
  if ( Type == VAR_POINTER )
  {
    GScr_FilterPlayerMarks_InternalHandlePointer(scrContext, entFilterBits);
    return;
  }
  if ( Type != VAR_STRING )
  {
    Scr_ParamError(COM_ERR_6100, scrContext, 0, "Invalid mark filter specified. Value is not a team/player or array of teams/players.");
    return;
  }
  ActiveFilterType = G_EntityMarks_GetActiveFilterType();
  if ( ActiveFilterType == Player )
  {
    Scr_ParamError(COM_ERR_6093, scrContext, 0, "Invalid mark player specified. Not a player entity");
    goto LABEL_9;
  }
  if ( ActiveFilterType )
  {
LABEL_9:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31826, ASSERT_TYPE_ASSERT, "( filterType ) == ( EntityMarkFilterType::Team )", "filterType == EntityMarkFilterType::Team\n\t%i, %i", (unsigned __int8)ActiveFilterType, 0i64) )
      __debugbreak();
  }
  ConstString = Scr_GetConstString(scrContext, 0);
  if ( !Com_Teams_TeamFromString(ConstString, &outTeam) )
  {
    String = Scr_GetString(scrContext, 0);
    v8 = j_va("Invalid mark team specified: %s.", String);
    Scr_ParamError(COM_ERR_6094, scrContext, 0, v8);
  }
  v9 = outTeam;
  if ( (unsigned int)(outTeam >> 5) >= TEAM_SEVEN )
  {
    LODWORD(v11) = 7;
    LODWORD(v10) = outTeam >> 5;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31834, ASSERT_TYPE_ASSERT, "(unsigned)( filterTeam >> 5 ) < (unsigned)( ( sizeof( *array_counter( entFilterBits ) ) + 0 ) )", "filterTeam >> 5 doesn't index ARRAY_COUNT( entFilterBits )\n\t%i not in [0, %i)", v10, v11) )
      __debugbreak();
  }
  (*entFilterBits)[v9 >> 5] |= 0x80000000 >> (v9 & 0x1F);
}

/*
==============
GScr_FilterPlayerMarks_InternalHandlePointer
==============
*/
void GScr_FilterPlayerMarks_InternalHandlePointer(scrContext_t *scrContext, unsigned int (*entFilterBits)[7])
{
  EntityMarkFilterType ActiveFilterType; 
  EntityMarkFilterType v5; 
  VariableType PointerType; 
  unsigned int ArrayObject; 
  unsigned int i; 
  VariableUnion *VariableValueAddress; 
  scr_entref_t EntityIdRef; 
  scr_string_t *v11; 
  const char *String; 
  const char *v13; 
  scr_entref_t EntityRef; 
  team_t outTeam; 

  ActiveFilterType = G_EntityMarks_GetActiveFilterType();
  v5 = ActiveFilterType;
  if ( (unsigned __int8)ActiveFilterType >= 2u && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 31842, ASSERT_TYPE_ASSERT, "( ( filterType == EntityMarkFilterType::Player || filterType == EntityMarkFilterType::Team ) )", "%s\n\t( static_cast<int>( filterType ) ) = %i", "( filterType == EntityMarkFilterType::Player || filterType == EntityMarkFilterType::Team )", (unsigned __int8)ActiveFilterType) )
    __debugbreak();
  PointerType = Scr_GetPointerType(scrContext, 0);
  if ( PointerType == VAR_ENTITY )
  {
    if ( v5 == Player )
    {
      EntityRef = Scr_GetEntityRef(scrContext, 0);
      GSCr_FilterPlayerMarks_AddEntRefInternal(scrContext, EntityRef, entFilterBits);
    }
    else
    {
      Scr_ParamError(COM_ERR_6098, scrContext, 0, "Invalid mark filter specified. Can't provide player entities when in team-filtering mode");
    }
  }
  else if ( PointerType == VAR_ARRAY )
  {
    ArrayObject = BGScr_Main_GetArrayObject(scrContext, 0);
    for ( i = FindFirstSibling(scrContext, ArrayObject); i; i = FindNextSibling(scrContext, i) )
    {
      if ( v5 == Player )
      {
        VariableValueAddress = GetVariableValueAddress(scrContext, i);
        if ( GetObjectType(scrContext, VariableValueAddress->intValue) != VAR_ENTITY )
          Scr_ParamError(COM_ERR_6095, scrContext, 0, "Invalid mark player specified. Array entry is not player entity.");
        EntityIdRef = Scr_GetEntityIdRef(scrContext, VariableValueAddress->intValue);
        GSCr_FilterPlayerMarks_AddEntRefInternal(scrContext, EntityIdRef, entFilterBits);
      }
      else
      {
        if ( GetValueType(scrContext, i) != VAR_STRING )
          Scr_ParamError(COM_ERR_6096, scrContext, 0, "Invalid mark team specified. Array entry is not a string.");
        v11 = (scr_string_t *)GetVariableValueAddress(scrContext, i);
        if ( !Com_Teams_TeamFromString(*v11, &outTeam) )
        {
          String = Scr_GetString(scrContext, 0);
          v13 = j_va("Invalid mark team specified: %s.", String);
          Scr_ParamError(COM_ERR_6097, scrContext, 0, v13);
        }
        (*entFilterBits)[(__int64)(int)outTeam >> 5] |= 0x80000000 >> (outTeam & 0x1F);
      }
    }
  }
  else
  {
    Scr_ParamError(COM_ERR_6099, scrContext, 0, "Invalid parameter array type for filtering");
  }
}

/*
==============
GScr_FreeEntity
==============
*/
void GScr_FreeEntity(gentity_s *ent)
{
  signed __int64 v2; 
  signed __int64 v3; 
  __int64 number; 
  GSave *v5; 
  scrContext_t *v6; 
  __int64 v7; 
  __int64 v8; 

  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 919, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 196, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
    __debugbreak();
  v2 = ent - g_entities;
  if ( (unsigned int)v2 >= 0x800 )
  {
    LODWORD(v7) = ent - g_entities;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 199, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( ( 2048 ) )", "index doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v7, 2048) )
      __debugbreak();
  }
  if ( ent->s.number != (_WORD)v2 )
  {
    if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 196, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
      __debugbreak();
    v3 = ent - g_entities;
    if ( (unsigned int)v3 >= 0x800 )
    {
      LODWORD(v8) = 2048;
      LODWORD(v7) = ((int)ent - (int)g_entities) / 1456;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 199, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( ( 2048 ) )", "index doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v7, v8) )
        __debugbreak();
    }
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 920, ASSERT_TYPE_ASSERT, "( ent->s.number ) == ( G_GetEntityIndex( ent ) )", "%s == %s\n\t%i, %i", "ent->s.number", "G_GetEntityIndex( ent )", ent->s.number, (__int16)v3) )
      __debugbreak();
  }
  number = ent->s.number;
  if ( (unsigned int)number >= 0x800 )
  {
    LODWORD(v8) = 2048;
    LODWORD(v7) = ent->s.number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v7, v8) )
      __debugbreak();
  }
  if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
    __debugbreak();
  if ( g_entities[number].r.isInUse != g_entityIsInUse[number] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
    __debugbreak();
  if ( !g_entityIsInUse[number] )
  {
    LODWORD(v7) = ent->s.number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 921, ASSERT_TYPE_ASSERT, "( ( G_IsEntityInUse( ent->s.number ) ) )", "( ent->s.number ) = %i", v7) )
      __debugbreak();
  }
  if ( !GSave::ms_gSave && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_save.h", 71, ASSERT_TYPE_ASSERT, "( ms_gSave )", (const char *)&queryFormat, "ms_gSave") )
    __debugbreak();
  v5 = GSave::ms_gSave;
  if ( ent->client )
    ((void (__fastcall *)(GSave *))GSave::ms_gSave->ScrFreeClientFields)(GSave::ms_gSave);
  v5->ScrFreeEntityFields(v5, ent);
  v6 = ScriptContext_Server();
  Scr_FreeEntityNum(v6, ent->s.number, ENTITY_CLASS_GENTITY);
}

/*
==============
GScr_FreeScripts
==============
*/
void GScr_FreeScripts(void)
{
  scrContext_t *v0; 
  int i; 

  v0 = ScriptContext_Server();
  for ( i = 0; i < 11; ++i )
    Scr_RemoveClassMap(v0, (EntityClass)i);
}

/*
==============
GScr_GetEntity
==============
*/
gentity_s *GScr_GetEntity(unsigned int index)
{
  scrContext_t *v2; 
  scr_entref_t EntityRef; 

  v2 = ScriptContext_Server();
  EntityRef = Scr_GetEntityRef(v2, index);
  if ( EntityRef.entclass )
  {
    Scr_ParamError(COM_ERR_3942, v2, index, "not an entity");
    return 0i64;
  }
  else
  {
    if ( EntityRef.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 964, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    return &g_entities[EntityRef.entnum];
  }
}

/*
==============
GScr_GetEntityAllowNull
==============
*/
gentity_s *GScr_GetEntityAllowNull(unsigned int index)
{
  scrContext_t *v2; 
  scr_entref_t EntityRef; 

  v2 = ScriptContext_Server();
  if ( Scr_GetType(v2, index) == VAR_UNDEFINED )
    return 0i64;
  EntityRef = Scr_GetEntityRef(v2, index);
  if ( EntityRef.entclass )
    return 0i64;
  if ( EntityRef.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 985, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  return &g_entities[EntityRef.entnum];
}

/*
==============
GScr_GetFunction
==============
*/
__int64 GScr_GetFunction(const char **pName, BuiltinType *type)
{
  if ( !GScript::ms_gScriptSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.h", 183, ASSERT_TYPE_ASSERT, "( ms_gScriptSystem )", (const char *)&queryFormat, "ms_gScriptSystem") )
    __debugbreak();
  return ((__int64 (__fastcall *)(GScript *, const char **, BuiltinType *))GScript::ms_gScriptSystem->GetFunction)(GScript::ms_gScriptSystem, pName, type);
}

/*
==============
GScr_GetMethod
==============
*/
__int64 GScr_GetMethod(const char **pName, BuiltinType *type)
{
  if ( !GScript::ms_gScriptSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.h", 183, ASSERT_TYPE_ASSERT, "( ms_gScriptSystem )", (const char *)&queryFormat, "ms_gScriptSystem") )
    __debugbreak();
  return ((__int64 (__fastcall *)(GScript *, const char **, BuiltinType *))GScript::ms_gScriptSystem->GetMethod)(GScript::ms_gScriptSystem, pName, type);
}

/*
==============
GScr_GetStandaloneScriptableIndex
==============
*/
__int64 GScr_GetStandaloneScriptableIndex(scrContext_t *scrContext, const scr_entref_t *entref)
{
  unsigned int entnum; 

  if ( entref->entclass != ENTITY_CLASS_SCRIPTABLE )
    Scr_ObjectError(COM_ERR_4683, scrContext, "Must be called on objects of class 'Scriptable'");
  ScriptableCommon_AssertCountsInitialized();
  entnum = entref->entnum;
  if ( entref->entnum >= g_scriptableWorldCounts.runtimeInstanceCount )
  {
    Scr_ObjectError(COM_ERR_4684, scrContext, "Must be called on a standalone dynamic scriptable");
    entnum = entref->entnum;
  }
  if ( ScriptableSv_GetInstanceCommonContext(entnum)->linkedObjectType == SCRIPTABLE_LINK_ENTITY )
    Scr_ObjectError(COM_ERR_4685, scrContext, "Must be called on a standalone (non-entity) scriptable");
  return entnum;
}

/*
==============
GScr_LoadLevel
==============
*/
void GScr_LoadLevel(void)
{
  GameScriptData *v0; 
  scrContext_t *v1; 
  unsigned int v2; 

  if ( !GameScriptData::ms_gScriptData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_data.h", 78, ASSERT_TYPE_ASSERT, "(ms_gScriptData)", "%s\n\tAttempting to access game data outside of an active game context", "ms_gScriptData") )
    __debugbreak();
  if ( !(_BYTE)GameScriptData::ms_allocatedType && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_data.h", 79, ASSERT_TYPE_ASSERT, "(ms_allocatedType != GameModeType::NONE)", "%s\n\tAttempting to access game data outside of an active game context", "ms_allocatedType != GameModeType::NONE") )
    __debugbreak();
  v0 = GameScriptData::ms_gScriptData;
  if ( GameScriptData::ms_gScriptData->levelscript )
  {
    v1 = ScriptContext_Server();
    v2 = Scr_ExecThread(v1, v0->levelscript, 0);
    Scr_FreeThread(v1, v2);
  }
}

/*
==============
GScr_Main_ClientmaskSetAllHidden
==============
*/
void GScr_Main_ClientmaskSetAllHidden(gentity_s *ent)
{
  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 8636, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  *(_QWORD *)ent->clientMask.array = -1i64;
  *(_QWORD *)&ent->clientMask.array[2] = -1i64;
  *(_QWORD *)&ent->clientMask.array[4] = -1i64;
  ent->clientMask.array[6] = -1;
}

/*
==============
GScr_Main_ClientmaskSetAllVisible
==============
*/
void GScr_Main_ClientmaskSetAllVisible(gentity_s *ent)
{
  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 8628, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  *(_QWORD *)ent->clientMask.array = 0i64;
  *(_QWORD *)&ent->clientMask.array[2] = 0i64;
  *(_QWORD *)&ent->clientMask.array[4] = 0i64;
  ent->clientMask.array[6] = 0;
}

/*
==============
GScr_Main_ClientmaskSetFlagVisible
==============
*/
void GScr_Main_ClientmaskSetFlagVisible(gentity_s *ent, unsigned int clientNum)
{
  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 8644, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( clientNum >= level.maxclients && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 8645, ASSERT_TYPE_ASSERT, "( clientNum < static_cast<uint>(level.maxclients) )", (const char *)&queryFormat, "clientNum < static_cast<uint>(level.maxclients)") )
    __debugbreak();
  bitarray_base<bitarray<224>>::resetBit(&ent->clientMask, clientNum);
}

/*
==============
GScr_Main_DeleteCommon
==============
*/
void GScr_Main_DeleteCommon(scrContext_t *scrContext, gentity_s *ent)
{
  __int64 number; 
  const char *v5; 
  unsigned int ScriptableIndexForEntity; 

  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 11640, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( ent->client )
    Scr_Error(COM_ERR_4246, scrContext, "Cannot delete a client entity");
  if ( ent->agent )
    Scr_Error(COM_ERR_4247, scrContext, "Cannot delete an agent entity");
  number = (unsigned int)ent->s.number;
  if ( level.currentEntityThink == (_DWORD)number )
  {
    v5 = j_va("Cannot delete entity '%i' during its think", number);
    Scr_Error(COM_ERR_4248, scrContext, v5);
  }
  if ( GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&ent->s.lerp.eFlags, GameModeFlagValues::ms_mpValue, 0x1Eu) )
    Scr_Error(COM_ERR_4249, scrContext, "Cannot delete a 'willNeverChange' entity");
  ScriptableIndexForEntity = ScriptableSv_GetScriptableIndexForEntity(ent);
  if ( ScriptableIndexForEntity != -1 )
  {
    ScriptableCommon_AssertCountsInitialized();
    if ( ScriptableIndexForEntity >= g_scriptableWorldCounts.runtimeInstanceCount )
    {
      ScriptableSv_VerifyScriptableMoverEntity(ent);
      Scr_Error(COM_ERR_4250, scrContext, "Cannot delete a radiant placed scriptable");
    }
  }
  GScr_Notify(ent, scr_const.death, 0);
  GScr_Notify(ent, scr_const.death_or_disconnect, 0);
  G_FreeEntity(ent);
}

/*
==============
GScr_Main_DisableAimAssistCommon
==============
*/
void GScr_Main_DisableAimAssistCommon(gentity_s *ent)
{
  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 6255, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(&ent->s.lerp.eFlags, ACTIVE, 8u);
}

/*
==============
GScr_Main_EnableAimAssistCommon
==============
*/
void GScr_Main_EnableAimAssistCommon(gentity_s *ent)
{
  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 6238, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(&ent->s.lerp.eFlags, ACTIVE, 8u);
}

/*
==============
GScr_Main_FillWeaponArray
==============
*/
__int64 GScr_Main_FillWeaponArray(scrContext_t *scrContext, Weapon *outWeapons, const unsigned int weaponIndexCount)
{
  Weapon *v4; 
  unsigned int ArrayObject; 
  unsigned int ArraySize; 
  unsigned int v8; 
  const char *v9; 
  unsigned int i; 
  unsigned int ArrayVariable; 
  VariableType ValueType; 
  scr_string_t *VariableValueAddress; 
  const char *v14; 
  bool IsAlternate; 
  VariableUnion *v16; 
  scr_entref_t EntityIdRef; 
  signed int entnum; 
  __int128 v19; 
  int v20; 
  double v21; 
  Weapon result; 
  Weapon r_weapon; 

  v4 = outWeapons;
  if ( !outWeapons && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 403, ASSERT_TYPE_ASSERT, "( outWeapons )", (const char *)&queryFormat, "outWeapons") )
    __debugbreak();
  ArrayObject = BGScr_Main_GetArrayObject(scrContext, 0);
  ArraySize = GetArraySize(scrContext, ArrayObject);
  v8 = ArraySize;
  if ( ArraySize > weaponIndexCount )
  {
    v9 = j_va("Too many weapons requested. Requested %d weapons but only %d are supported for this call.", ArraySize, weaponIndexCount);
    Scr_Error(COM_ERR_3932, scrContext, v9);
  }
  for ( i = 0; i < v8; ++v4 )
  {
    ArrayVariable = GetArrayVariable(scrContext, ArrayObject, i);
    ValueType = GetValueType(scrContext, ArrayVariable);
    if ( ValueType == VAR_STRING )
    {
      VariableValueAddress = (scr_string_t *)GetVariableValueAddress(scrContext, ArrayVariable);
      v14 = SL_ConvertToString(*VariableValueAddress);
      if ( !v14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 366, ASSERT_TYPE_ASSERT, "(weaponName)", (const char *)&queryFormat, "weaponName") )
        __debugbreak();
      r_weapon = *GScr_Main_GetWeaponForName(&result, scrContext, v14);
      IsAlternate = BG_IsAlternate(v14);
      Scr_VerifyWeapon(scrContext, &r_weapon, IsAlternate, v14);
    }
    else if ( ValueType == VAR_POINTER && (v16 = GetVariableValueAddress(scrContext, ArrayVariable), GetObjectType(scrContext, v16->intValue) == VAR_ENTITY) && (EntityIdRef = Scr_GetEntityIdRef(scrContext, v16->intValue), entnum = EntityIdRef.entnum, EntityIdRef.entclass == ENTITY_CLASS_SAVED_COUNT) )
    {
      r_weapon = *GScr_Weapon_GetWeapon(scrContext, (const scr_weapon_t)EntityIdRef.entnum);
      GScr_Weapon_IsAlternate(scrContext, (const scr_weapon_t)entnum);
    }
    else
    {
      memset(&r_weapon, 0, 48);
      *(_DWORD *)&r_weapon.weaponCamo = *(_DWORD *)&NULL_WEAPON.weaponCamo;
      *(double *)&r_weapon.attachmentVariationIndices[21] = *(double *)&NULL_WEAPON.attachmentVariationIndices[21];
      Scr_ParamError(COM_ERR_3933, scrContext, i, "All weapons in the array need to be weapon strings or weapon objects.");
    }
    v19 = *(_OWORD *)&r_weapon.attachmentVariationIndices[5];
    v20 = *(_DWORD *)&r_weapon.weaponCamo;
    ++i;
    *(__m256i *)&v4->weaponIdx = *(__m256i *)&r_weapon.weaponIdx;
    v21 = *(double *)&r_weapon.attachmentVariationIndices[21];
    *(_OWORD *)&v4->attachmentVariationIndices[5] = v19;
    *(double *)&v4->attachmentVariationIndices[21] = v21;
    *(_DWORD *)&v4->weaponCamo = v20;
  }
  return v8;
}

/*
==============
GScr_Main_GetAudioTriggerPriorityIndex
==============
*/
__int64 GScr_Main_GetAudioTriggerPriorityIndex(const char *name)
{
  const char **v2; 
  unsigned int i; 
  const char *v4; 
  __int64 v5; 
  const char *v6; 
  signed __int64 v7; 
  int v8; 
  __int64 v9; 
  int v10; 
  int v11; 
  int v12; 

  v2 = s_audioTriggerOverrideTypeNames;
  for ( i = 0; i < 7; ++i )
  {
    v4 = *v2;
    v5 = 0x7FFFFFFFi64;
    v6 = name;
    if ( !*v2 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
      __debugbreak();
    if ( !name && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 213, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
      __debugbreak();
    v7 = v4 - name;
    while ( 1 )
    {
      v8 = (unsigned __int8)v6[v7];
      v9 = v5;
      v10 = *(unsigned __int8 *)v6++;
      --v5;
      if ( !v9 )
        return i;
      if ( v8 != v10 )
      {
        v11 = v8 + 32;
        if ( (unsigned int)(v8 - 65) > 0x19 )
          v11 = v8;
        v8 = v11;
        v12 = v10 + 32;
        if ( (unsigned int)(v10 - 65) > 0x19 )
          v12 = v10;
        if ( v8 != v12 )
          break;
      }
      if ( !v8 )
        return i;
    }
    ++v2;
  }
  return 0xFFFFFFFFi64;
}

/*
==============
GScr_Main_GetDDL
==============
*/
void GScr_Main_GetDDL(scrContext_t *scrContext, DDLState *state, const DDLDef *def, const DDLContext *context, const char *callingFunction, int firstArgIndex)
{
  unsigned int NumParam; 
  int Int; 
  int v11; 
  double Float; 
  int v13; 
  int v14; 
  int v15; 
  const char *EnumString; 
  const char *String; 
  int BitSize; 
  int Type; 
  const char *stringPtr; 
  bool Bool; 
  int v22; 
  double v23; 
  unsigned __int16 Short; 
  unsigned __int8 Byte; 
  const char *Enum; 
  int v27; 
  __int64 v28; 
  __int64 v29; 
  int finalArgumentIndex[2]; 

  finalArgumentIndex[0] = -1;
  GScr_Main_NavigateDDL(scrContext, def, callingFunction, state, firstArgIndex, finalArgumentIndex);
  NumParam = Scr_GetNumParam(scrContext);
  if ( finalArgumentIndex[0] == NumParam )
  {
    if ( state->member )
    {
      if ( Com_GameMode_SupportsFeature(WEAPON_RELOAD_END|0x80) && g_archiveGetDvar && SV_IsDemoPlaying() )
      {
        Int = SV_Demo_GetInt();
        v11 = SV_Demo_GetInt();
        if ( SV_IsDemoPlaying() )
        {
          switch ( Int )
          {
            case 0:
            case 1:
            case 3:
              goto LABEL_14;
            case 2:
              if ( v11 == 1 )
              {
                v13 = SV_Demo_GetInt();
                Scr_AddBool(scrContext, v13 != 0);
              }
              else
              {
LABEL_14:
                v14 = SV_Demo_GetInt();
                Scr_AddInt(scrContext, v14);
              }
              break;
            case 6:
              Float = SV_Demo_GetFloat();
              Scr_AddFloat(scrContext, *(float *)&Float);
              break;
            case 10:
              v15 = SV_Demo_GetInt();
              EnumString = DDL::DDL_Lookup_GetEnumString(state, v15);
              Scr_AddString(scrContext, EnumString);
              break;
            default:
              if ( Int != 8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 693, ASSERT_TYPE_ASSERT, "( resultType ) == ( DDL_STRING_TYPE )", "%s == %s\n\t%i, %i", "resultType", "DDL_STRING_TYPE", Int, 8) )
                __debugbreak();
              String = SV_Demo_GetString();
              Scr_AddString(scrContext, String);
              break;
          }
        }
        else
        {
          Scr_AddInt(scrContext, 0);
        }
      }
      else
      {
        BitSize = DDL_StateGetBitSize(state);
        Type = DDL_GetType(state);
        stringPtr = DDL_GetValue(state, context).stringPtr;
        switch ( Type )
        {
          case 0:
            Byte = DDL_GetByte(state, context);
            Scr_AddInt(scrContext, Byte);
            break;
          case 1:
            Short = DDL_GetShort(state, context);
            Scr_AddInt(scrContext, Short);
            break;
          case 2:
            if ( BitSize != 1 )
              goto $LN11_54;
            Bool = DDL_GetBool(state, context);
            Scr_AddBool(scrContext, Bool);
            break;
          case 3:
$LN11_54:
            v22 = DDL_GetInt(state, context);
            Scr_AddInt(scrContext, v22);
            break;
          case 6:
            v23 = DDL_GetFloat(state, context);
            Scr_AddFloat(scrContext, *(float *)&v23);
            break;
          case 10:
            Enum = DDL_GetEnum(state, context);
            goto LABEL_32;
          default:
            if ( Type != 8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 816, ASSERT_TYPE_ASSERT, "( resultType ) == ( DDL_STRING_TYPE )", "%s == %s\n\t%i, %i", "resultType", "DDL_STRING_TYPE", Type, 8) )
              __debugbreak();
            Enum = DDL_GetString(state, context);
LABEL_32:
            Scr_AddString(scrContext, Enum);
            break;
        }
        *(_QWORD *)finalArgumentIndex = stringPtr;
        if ( Com_GameMode_SupportsFeature(WEAPON_RELOAD_END|0x80) && g_archiveGetDvar && !SV_IsDemoPlaying() )
        {
          SV_Record_GetInt(Type);
          SV_Record_GetInt(BitSize);
          switch ( Type )
          {
            case 0:
            case 1:
            case 3:
              goto LABEL_39;
            case 2:
              if ( BitSize == 1 )
                goto LABEL_40;
LABEL_39:
              SV_Record_GetInt((int)stringPtr);
              break;
            case 6:
              SV_Record_GetFloat(*(float *)finalArgumentIndex);
              return;
            case 10:
LABEL_40:
              v27 = truncate_cast<int,unsigned int>((unsigned int)stringPtr);
              SV_Record_GetInt(v27);
              break;
            default:
              if ( Type != 8 )
              {
                LODWORD(v29) = 8;
                LODWORD(v28) = Type;
                if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 744, ASSERT_TYPE_ASSERT, "( resultType ) == ( DDL_STRING_TYPE )", "%s == %s\n\t%i, %i", "resultType", "DDL_STRING_TYPE", v28, v29) )
                  __debugbreak();
              }
              SV_Record_GetString(stringPtr);
              break;
          }
        }
      }
    }
    else
    {
      GScr_Main_StructuredDataPrintArgs(scrContext, callingFunction);
      Scr_Error(COM_ERR_3940, scrContext, "DDL navigation failed at root.");
    }
  }
  else
  {
    GScr_Main_StructuredDataPrintArgs(scrContext, callingFunction);
    Scr_Error(COM_ERR_3939, scrContext, "Too many arguments. See log.");
  }
}

/*
==============
GScr_Main_GetPlayerEntity
==============
*/
gentity_s *GScr_Main_GetPlayerEntity(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v8; 

  entnum = entref.entnum;
  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 1061, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !Entity->client )
  {
    targetname = Entity->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(Entity->classname);
    v8 = j_va("Only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, Entity->r.currentOrigin.v[0], Entity->r.currentOrigin.v[1], Entity->r.currentOrigin.v[2], v7, v6);
    Scr_Error(COM_ERR_3944, scrContext, v8);
  }
  return Entity;
}

/*
==============
GScr_Main_GetWeaponForName
==============
*/
Weapon *GScr_Main_GetWeaponForName(Weapon *result, scrContext_t *scrContext, const char *weaponName)
{
  const dvar_t *v6; 
  const char *v7; 

  if ( !BG_Weapons_GetFullWeaponForName(weaponName, result, BG_FindBaseWeaponForName) )
  {
    v6 = DCONST_DVARBOOL_g_weaponEnforceNames;
    if ( !DCONST_DVARBOOL_g_weaponEnforceNames && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "g_weaponEnforceNames") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v6);
    if ( v6->current.enabled )
    {
      v7 = j_va("Invalid weapon name (%s) specified. See console log for details.", weaponName);
      Scr_Error(COM_ERR_3928, scrContext, v7);
    }
  }
  return result;
}

/*
==============
GScr_Main_GetWeaponParam
==============
*/
void GScr_Main_GetWeaponParam(scrContext_t *scrContext, const unsigned int index, Weapon *outWeapon, bool *outIsAlternate)
{
  const char *String; 
  const char *v9; 
  scr_entref_t EntityRef; 
  bool IsAlternate; 
  const char *v12; 
  gentity_s *Entity; 
  scr_entref_t v14; 
  char v15[512]; 
  char output[1024]; 
  char dest[1024]; 

  if ( Scr_GetType(scrContext, index) == VAR_STRING )
  {
    String = Scr_GetString(scrContext, index);
    *outIsAlternate = BG_IsAlternate(String);
    if ( !BG_Weapons_GetFullWeaponForName(String, outWeapon, BG_FindBaseWeaponForName) )
    {
      v9 = j_va("Invalid weapon name (%s) specified. See console log for details.", String);
      Scr_ParamError(COM_ERR_3929, scrContext, index, v9);
    }
    Scr_VerifyWeapon(scrContext, outWeapon, *outIsAlternate, String);
    return;
  }
  if ( Scr_GetType(scrContext, index) != VAR_POINTER || Scr_GetPointerType(scrContext, index) != VAR_ENTITY )
  {
LABEL_14:
    Scr_ParamError(COM_ERR_3930, scrContext, index, "Invalid weapon parameter specified. Weapon must be a weapon string, weapon object or weapon item entity. ");
    return;
  }
  EntityRef = Scr_GetEntityRef(scrContext, index);
  v14 = EntityRef;
  if ( EntityRef.entclass != ENTITY_CLASS_SAVED_COUNT )
  {
    if ( EntityRef.entclass == ENTITY_CLASS_GENTITY )
    {
      Entity = GetEntity(EntityRef);
      if ( Entity->s.eType == ET_ITEM )
      {
        *(__m256i *)&outWeapon->weaponIdx = *(__m256i *)(&Entity->c.beam + 3);
        *(_OWORD *)&outWeapon->attachmentVariationIndices[5] = *(_OWORD *)(&Entity->c.beam + 11);
        *(double *)&outWeapon->attachmentVariationIndices[21] = *(double *)(&Entity->c.beam + 15);
        *(float *)&outWeapon->weaponCamo = Entity->c.mover.angle.pos1.v[2];
        *outIsAlternate = 0;
        return;
      }
    }
    goto LABEL_14;
  }
  *outWeapon = *GScr_Weapon_GetWeapon(scrContext, (const scr_weapon_t)EntityRef.entnum);
  IsAlternate = GScr_Weapon_IsAlternate(scrContext, (const scr_weapon_t)EntityRef.entnum);
  *outIsAlternate = IsAlternate;
  if ( IsAlternate && !BG_ActiveUnderbarrel(outWeapon) )
  {
    BG_GetWeaponNameComplete(outWeapon, *outIsAlternate, output, 0x400u);
    v12 = j_va("Weapon must have an 'active underbarrel' attachment if it's in alt mode: %s", output);
    BG_GetWeaponName(outWeapon, v15, 0x200u);
    Com_sprintf(dest, 0x400ui64, v12, v15, v14);
    Scr_ParamError(COM_ERR_6290, scrContext, 0, dest);
    *outIsAlternate = 0;
  }
}

/*
==============
GScr_Main_NavigateDDL
==============
*/
void GScr_Main_NavigateDDL(scrContext_t *scrContext, const DDLDef *def, const char *functionName, DDLState *state, int firstArgIndex, int *finalArgumentIndex)
{
  signed int v9; 
  char v10; 
  int Int; 
  unsigned int v12; 
  const char *v13; 
  ComErrorCode v14; 
  scr_string_t ConstString; 
  unsigned int RawHash; 
  const char *String; 

  if ( !def && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 493, ASSERT_TYPE_ASSERT, "(def)", (const char *)&queryFormat, "def") )
    __debugbreak();
  if ( !state && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 494, ASSERT_TYPE_ASSERT, "(state)", (const char *)&queryFormat, "state") )
    __debugbreak();
  if ( !finalArgumentIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 495, ASSERT_TYPE_ASSERT, "(finalArgumentIndex)", (const char *)&queryFormat, "finalArgumentIndex") )
    __debugbreak();
  v9 = firstArgIndex - 1;
  v10 = 1;
  if ( DDL_StateIsLeaf(state) )
    goto LABEL_25;
  while ( 1 )
  {
    ++v9;
    if ( !DDL_StateIsArrayRoot(state) )
      break;
    Int = Scr_GetInt(scrContext, v9);
    v10 &= DDL_MoveToIndex(state, state, Int);
    if ( !v10 )
    {
      if ( v9 < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 515, ASSERT_TYPE_ASSERT, "(argumentIndex >= 0)", (const char *)&queryFormat, "argumentIndex >= 0") )
        __debugbreak();
      GScr_Main_StructuredDataPrintArgs(scrContext, functionName);
      v12 = Scr_GetInt(scrContext, v9);
      v13 = j_va("Failed to navigate into DDL array index %d", v12);
      v14 = COM_ERR_3934;
      goto LABEL_24;
    }
LABEL_18:
    if ( DDL_StateIsLeaf(state) )
      goto LABEL_25;
  }
  ConstString = Scr_GetConstString(scrContext, v9);
  RawHash = j_SL_GetRawHash(ConstString);
  v10 &= DDL_MoveToNameByHash(state, state, RawHash, NULL);
  if ( v10 )
    goto LABEL_18;
  if ( v9 < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 530, ASSERT_TYPE_ASSERT, "(argumentIndex >= 0)", (const char *)&queryFormat, "argumentIndex >= 0") )
    __debugbreak();
  GScr_Main_StructuredDataPrintArgs(scrContext, functionName);
  String = Scr_GetString(scrContext, v9);
  v13 = j_va("Failed to navigate into DDL field %s", String);
  v14 = COM_ERR_3935;
LABEL_24:
  Scr_ParamError(v14, scrContext, v9, v13);
LABEL_25:
  *finalArgumentIndex = v9 + 1;
}

/*
==============
GScr_Main_PlayerLinkTo_Internal
==============
*/
void GScr_Main_PlayerLinkTo_Internal(scrContext_t *scrContext, scr_entref_t entref, PlayerLinkToType linkType)
{
  gentity_s *Entity; 
  gclient_s *client; 
  gentity_s *v7; 
  int NumParam; 
  scr_string_t ConstLowercaseString; 
  GHandler *Handler; 
  bool v11; 
  bool v12; 
  bool v13; 
  bool v14; 
  bool v15; 
  double Float; 
  double v17; 
  double v18; 
  double v19; 
  double v20; 
  double v21; 
  double v22; 
  double v23; 
  double v24; 
  const dvar_t *v25; 
  int time; 
  GWeaponMap *Instance; 
  GHandler *v28; 
  const char *v29; 
  char outErrorMessage[256]; 

  Entity = GetEntity(entref);
  if ( Scr_GetType(scrContext, 0) != VAR_POINTER || Scr_GetPointerType(scrContext, 0) != VAR_ENTITY )
    Scr_ParamError(COM_ERR_4169, scrContext, 0, "not an entity");
  if ( !Entity->client )
    Scr_ObjectError(COM_ERR_4170, scrContext, "not a player entity");
  if ( (Entity->flags.m_flags[0] & 0x200) == 0 )
    Scr_ObjectError(COM_ERR_4171, scrContext, "player does not support linking");
  client = Entity->client;
  v7 = GScr_GetEntity(0);
  NumParam = Scr_GetNumParam(scrContext);
  ConstLowercaseString = 0;
  if ( NumParam > 1 )
  {
    if ( Scr_GetType(scrContext, 1u) )
    {
      ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 1u);
      if ( ConstLowercaseString == scr_const._ )
        ConstLowercaseString = 0;
    }
  }
  if ( !client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2605, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( BG_IsPlayerZeroG(&client->ps) && !BG_IsPlayerZeroGWalking(&client->ps) )
  {
    Handler = GHandler::getHandler();
    BG_NormalizeWorldUpReferenceAngles(&client->ps, Handler);
  }
  GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::ClearFlagInternal(&client->ps.linkFlags, ACTIVE, 6u);
  GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::ClearFlagInternal(&client->ps.linkFlags, GameModeFlagValues::ms_mpValue, 7u);
  if ( linkType == PLAYERLINKTO_DELTA )
  {
    GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::ClearFlagInternal(&client->ps.linkFlags, ACTIVE, 2u);
    v11 = NumParam <= 8 || Scr_GetInt(scrContext, 8u) != 0;
    client->link_rotationMovesEyePos = v11;
    v12 = NumParam > 7 && Scr_GetInt(scrContext, 7u) != 0;
    client->link_useTagAnglesForViewAngles = v12;
    v13 = NumParam <= 9 || Scr_GetInt(scrContext, 9u) != 0;
    client->link_useTagScriptedCamera = v13;
    if ( v13 )
      GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::SetFlagInternal(&client->ps.linkFlags, ACTIVE, 6u);
    client->link_doCollision = 0;
  }
  else if ( linkType == PLAYERLINKTO_DELTA_WEAPONVIEWONLY )
  {
    if ( ConstLowercaseString != scr_const.tag_player )
      Scr_Error(COM_ERR_4172, scrContext, "This function only supports linking to tags named 'tag_player'.");
    client->ps.linkWeaponAngles.v[0] = client->ps.viewangles.v[0];
    client->ps.linkWeaponAngles.v[1] = client->ps.viewangles.v[1];
    client->ps.linkWeaponAngles.v[2] = client->ps.viewangles.v[2];
    GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::SetFlagInternal(&client->ps.linkFlags, ACTIVE, 2u);
    GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::SetFlagInternal(&client->ps.linkFlags, ACTIVE, 3u);
    client->link_rotationMovesEyePos = 0;
    v14 = NumParam > 7 && Scr_GetInt(scrContext, 7u) != 0;
    client->link_useTagAnglesForViewAngles = v14;
    client->link_useTagScriptedCamera = 0;
    client->link_doCollision = 0;
    if ( !SV_Game_IsSplitscreen() || SV_Game_IsOnlineGame() )
      GScr_Main_ClientmaskSetFlagVisible(v7, client->ps.clientNum);
    else
      GScr_Main_ClientmaskSetAllVisible(v7);
  }
  else
  {
    if ( linkType && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 8737, ASSERT_TYPE_ASSERT, "(linkType == PLAYERLINKTO_NORMAL)", (const char *)&queryFormat, "linkType == PLAYERLINKTO_NORMAL") )
      __debugbreak();
    GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::ClearFlagInternal(&client->ps.linkFlags, ACTIVE, 2u);
    client->link_rotationMovesEyePos = 0;
    client->link_useTagAnglesForViewAngles = 1;
    client->link_useTagScriptedCamera = 0;
    v15 = NumParam > 7 && Scr_GetInt(scrContext, 7u) != 0;
    client->link_doCollision = v15;
  }
  client->link_useBaseAnglesForViewClamp = 0;
  if ( NumParam <= 2 )
    LODWORD(Float) = 0;
  else
    Float = Scr_GetFloat(scrContext, 2u);
  client->flags &= ~4u;
  client->linkAnglesFrac = *(float *)&Float;
  if ( NumParam <= 3 )
    *(float *)&v17 = FLOAT_180_0;
  else
    v17 = Scr_GetFloat(scrContext, 3u);
  v18 = I_fclamp(*(float *)&v17, 0.0, 180.0);
  client->link_viewClamp.min.goal.v[1] = COERCE_FLOAT(LODWORD(v18) ^ _xmm);
  if ( NumParam <= 4 )
    *(float *)&v19 = FLOAT_180_0;
  else
    v19 = Scr_GetFloat(scrContext, 4u);
  v20 = I_fclamp(*(float *)&v19, 0.0, 180.0);
  client->link_viewClamp.max.goal.v[1] = *(float *)&v20;
  if ( NumParam <= 5 )
    *(float *)&v21 = FLOAT_180_0;
  else
    v21 = Scr_GetFloat(scrContext, 5u);
  v22 = I_fclamp(*(float *)&v21, 0.0, 180.0);
  client->link_viewClamp.min.goal.v[0] = COERCE_FLOAT(LODWORD(v22) ^ _xmm);
  if ( NumParam <= 6 )
    *(float *)&v23 = FLOAT_180_0;
  else
    v23 = Scr_GetFloat(scrContext, 6u);
  v24 = I_fclamp(*(float *)&v23, 0.0, 180.0);
  client->link_viewClamp.max.goal.v[0] = *(float *)&v24;
  if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_FREEFALL_IDLE|WEAPON_OFFHAND_END) )
  {
    client->link_viewClamp.resistMin.goal = 0i64;
    client->link_viewClamp.resistMax.goal = 0i64;
  }
  G_SnapToViewAngleClampGoal(&client->link_viewClamp);
  GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::ClearFlagInternal(&client->ps.linkFlags, ACTIVE, 0);
  GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::ClearFlagInternal(&client->ps.linkFlags, GameModeFlagValues::ms_spValue, 7u);
  GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::ClearFlagInternal(&client->ps.linkFlags, GameModeFlagValues::ms_spValue, 8u);
  client->prevLinkAnglesSet = 0;
  if ( (v7->flags.m_flags[0] & 0x80000) != 0 )
    GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::ClearFlagInternal(&client->ps.pm_flags, ACTIVE, 5u);
  if ( G_EntLinkTo(Entity, v7, ConstLowercaseString, 256, outErrorMessage) )
  {
    v25 = DVARBOOL_killswitch_prevent_mantle_while_linked_enabled;
    if ( !DVARBOOL_killswitch_prevent_mantle_while_linked_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "killswitch_prevent_mantle_while_linked_enabled") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v25);
    if ( v25->current.enabled )
    {
      time = level.time;
      Instance = GWeaponMap::GetInstance();
      v28 = GHandler::getHandler();
      Mantle_CancelMantle(v28, Instance, &client->ps, time);
    }
    if ( linkType == PLAYERLINKTO_DELTA_WEAPONVIEWONLY )
    {
      GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::SetFlagInternal(&client->ps.linkFlags, ACTIVE, 2u);
      GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::SetFlagInternal(&client->ps.linkFlags, ACTIVE, 3u);
    }
    G_InitPlayerLinkAngles(Entity);
  }
  else
  {
    v29 = j_va("failed to link entity %i to entity %i: %s", (unsigned int)Entity->s.number, (unsigned int)v7->s.number, outErrorMessage);
    Scr_Error(COM_ERR_4173, scrContext, v29);
  }
}

/*
==============
GScr_Main_PostLoadScriptsCommon
==============
*/
void GScr_Main_PostLoadScriptsCommon(void)
{
  scrContext_t *v0; 

  v0 = ScriptContext_Server();
  GScr_AddFieldsForEntity(v0);
  G_HudElem_ScrAddFieldsForHudElems(v0);
  GScr_AddFieldsForPathnode(v0);
  GScr_Weapon_AddFields(v0);
  G_VehiclePathScr_AddFieldsForNode(v0);
  Scr_AddFieldsForRadiant(v0);
  if ( script_usage_tracking )
  {
    if ( script_usage_tracking->current.integer )
      Scr_InitSourceFuncInfo(v0);
  }
}

/*
==============
GScr_Main_SetDDL
==============
*/
void GScr_Main_SetDDL(scrContext_t *scrContext, DDLState *state, const DDLDef *def, DDLContext *context, const char *callingFunction, int firstArgIndex)
{
  unsigned int v9; 
  unsigned int v10; 
  DDLType Type; 
  int v12; 
  bool v13; 
  unsigned int v14; 
  int v15; 
  double Float; 
  unsigned __int16 v17; 
  unsigned __int8 Int; 
  const char *String; 
  const char *v20; 
  const char *v21; 
  const char *v22; 
  unsigned int index[10]; 

  index[0] = -1;
  GScr_Main_NavigateDDL(scrContext, def, callingFunction, state, firstArgIndex, (int *)index);
  v9 = index[0];
  v10 = index[0] + 1;
  if ( v10 <= Scr_GetNumParam(scrContext) )
  {
    if ( v10 >= Scr_GetNumParam(scrContext) )
    {
      Type = DDL_GetType(state);
      switch ( Type )
      {
        case DDL_BYTE_TYPE:
          Int = Scr_GetInt(scrContext, v9);
          v13 = DDL_SetByte(state, context, Int);
          break;
        case DDL_SHORT_TYPE:
          v17 = Scr_GetInt(scrContext, v9);
          v13 = DDL_SetShort(state, context, v17);
          break;
        case DDL_UINT_TYPE:
          if ( DDL_StateGetBitSize(state) == 1 )
          {
            v12 = Scr_GetInt(scrContext, v9);
            v13 = DDL_SetBool(state, context, v12 != 0);
          }
          else
          {
            v14 = Scr_GetInt(scrContext, v9);
            v13 = DDL_SetUInt(state, context, v14);
          }
          break;
        case DDL_INT_TYPE:
          v15 = Scr_GetInt(scrContext, v9);
          v13 = DDL_SetInt(state, context, v15);
          break;
        case DDL_FLOAT_TYPE:
          Float = Scr_GetFloat(scrContext, v9);
          v13 = DDL_SetFloat(state, context, *(float *)&Float);
          break;
        case DDL_STRING_TYPE:
          goto $LN14_57;
        case DDL_ENUM_TYPE:
          String = Scr_GetString(scrContext, v9);
          v13 = DDL_SetEnum(state, context, String);
          break;
        default:
          Com_PrintWarning(28, "attempting to write to ddl type %d as a string?\n", (unsigned int)Type);
$LN14_57:
          v20 = Scr_GetString(scrContext, v9);
          v13 = DDL_SetString(state, context, v20);
          break;
      }
      if ( !v13 )
      {
        GScr_Main_StructuredDataPrintArgs(scrContext, callingFunction);
        v21 = Scr_GetString(scrContext, v9);
        v22 = j_va("%s: \"%s\" %s", callingFunction, v21, "DDL error");
        Scr_ParamError(COM_ERR_3938, scrContext, v9, v22);
      }
    }
    else
    {
      GScr_Main_StructuredDataPrintArgs(scrContext, callingFunction);
      Scr_Error(COM_ERR_3937, scrContext, "Too many arguments. See log.");
    }
  }
  else
  {
    GScr_Main_StructuredDataPrintArgs(scrContext, callingFunction);
    Scr_Error(COM_ERR_3936, scrContext, "Not enough arguments. See log.");
  }
}

/*
==============
GScr_Main_StructuredDataPrintArgs
==============
*/
void GScr_Main_StructuredDataPrintArgs(scrContext_t *scrContext, const char *functionName)
{
  int v3; 
  unsigned int v4; 
  int v5; 
  VariableType Type; 
  const char *TypeName; 
  int v8; 
  unsigned int Int; 
  double Float; 
  const char *String; 
  char dest[1024]; 

  v3 = Com_sprintf_truncate(dest, 0x400ui64, "In call to %s( ", functionName);
  if ( v3 >= 0 )
  {
    v4 = 0;
    if ( Scr_GetNumParam(scrContext) )
    {
      while ( 1 )
      {
        if ( v4 )
        {
          v5 = Com_sprintf_truncate(&dest[v3], 1024 - v3, ", ");
          if ( v5 < 0 )
            break;
          v3 += v5;
        }
        Type = Scr_GetType(scrContext, v4);
        switch ( Type )
        {
          case VAR_STRING:
            String = Scr_GetString(scrContext, v4);
            v8 = Com_sprintf_truncate(&dest[v3], 1024 - v3, "\"%s\"", String);
            break;
          case VAR_FLOAT:
            Float = Scr_GetFloat(scrContext, v4);
            v8 = Com_sprintf_truncate(&dest[v3], 1024 - v3, "\"%f\"", *(float *)&Float);
            break;
          case VAR_INTEGER:
            Int = Scr_GetInt(scrContext, v4);
            v8 = Com_sprintf_truncate(&dest[v3], 1024 - v3, "\"%i\"", Int);
            break;
          default:
            TypeName = Scr_GetTypeName(scrContext, v4);
            v8 = Com_sprintf_truncate(&dest[v3], 1024 - v3, "[unhandled type %s]", TypeName);
            break;
        }
        if ( v8 < 0 )
          break;
        v3 += v8;
        if ( ++v4 >= Scr_GetNumParam(scrContext) )
          goto LABEL_15;
      }
    }
    else
    {
LABEL_15:
      Com_sprintf(&dest[v3], 1024 - v3, " )\n");
    }
  }
  Com_PrintError(23, (const char *)&queryFormat, dest);
}

/*
==============
GScr_Main_UpdateClassMap
==============
*/
void GScr_Main_UpdateClassMap(void)
{
  scrContext_t *v0; 
  int i; 

  v0 = ScriptContext_Server();
  for ( i = 0; i < 11; ++i )
    Scr_SetClassMap(v0, (EntityClass)i);
}

/*
==============
GScr_Main_ValidateDisconnectPathsEnt
==============
*/
__int64 GScr_Main_ValidateDisconnectPathsEnt(scrContext_t *scrContext, gentity_s *ent)
{
  const char *v5; 
  const char *v6; 

  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 23108, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !Path_IsDynamicBlockingEntity(ent) )
  {
    if ( ent->classname == scr_const.script_brushmodel )
    {
      Scr_Error(COM_ERR_4645, scrContext, "script_brushmodel must have DYNAMICPATH set to disconnect/connect paths");
      return 0i64;
    }
    if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_STILL_LAND|0x80) )
    {
      v5 = SL_ConvertToString(ent->classname);
      v6 = j_va("entity of type '%s' cannot disconnect/connect paths.\n \n ", v5);
      Scr_Error(COM_ERR_4646, scrContext, v6);
      return 0i64;
    }
    ent->flags.m_flags[0] |= 0x40u;
  }
  return 1i64;
}

/*
==============
GScr_Main_WeaponParamError
==============
*/
void GScr_Main_WeaponParamError(ComErrorCode uniqueErrorCode, scrContext_t *scrContext, const unsigned int index, const Weapon *r_weapon, const char *weaponFormatString)
{
  char output[512]; 
  char dest[1024]; 

  BG_GetWeaponName(r_weapon, output, 0x200u);
  Com_sprintf(dest, 0x400ui64, weaponFormatString, output);
  Scr_ParamError(uniqueErrorCode, scrContext, index, dest);
}

/*
==============
GScr_MakeGameMessage
==============
*/
void GScr_MakeGameMessage(scrContext_t *scrContext, __int64 clientNum, const char cmd)
{
  unsigned int v4; 
  const char *v6; 
  GScript *v7; 
  void (__fastcall *ConstructMessageString)(GScript *, scrContext_t *, int, int, const char *, char *, unsigned int); 
  unsigned int NumParam; 
  const char *v10; 
  const char *v11; 
  SvClient *CommonClient; 
  char v13[1024]; 

  v4 = clientNum;
  if ( (int)clientNum < level.maxclients )
  {
    if ( !GScript::ms_gScriptSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.h", 183, ASSERT_TYPE_ASSERT, "( ms_gScriptSystem )", (const char *)&queryFormat, "ms_gScriptSystem") )
      __debugbreak();
    v7 = GScript::ms_gScriptSystem;
    ConstructMessageString = GScript::ms_gScriptSystem->ConstructMessageString;
    NumParam = Scr_GetNumParam(scrContext);
    ConstructMessageString(v7, scrContext, 0, NumParam - 1, "Game Message", v13, 1024u);
    v10 = j_va("%c \"%s\"", (unsigned int)cmd, v13);
    v11 = v10;
    if ( v4 == -1 )
    {
      SV_Game_BroadcastServerCommand(SV_CMD_CAN_IGNORE, v10);
    }
    else
    {
      CommonClient = SvClient::GetCommonClient(v4);
      CommonClient->SendServerCommand(CommonClient, SV_CMD_CAN_IGNORE, v11);
    }
  }
  else
  {
    v6 = j_va("Invalid entity index %d before SV_Game_SendServerCommand\n", clientNum);
    Scr_Error(COM_ERR_6408, scrContext, v6);
  }
}

/*
==============
GScr_Notify
==============
*/
void GScr_Notify(const gentity_s *ent, scr_string_t stringValue, unsigned int paramcount)
{
  signed __int64 v6; 
  const char *v7; 
  signed __int64 v8; 
  __int64 number; 
  const char *v10; 
  scrContext_t *v11; 
  __int64 localClientNum; 
  __int64 v13; 

  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 908, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 196, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
    __debugbreak();
  v6 = ent - g_entities;
  if ( (unsigned int)v6 >= 0x800 )
  {
    LODWORD(localClientNum) = ent - g_entities;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 199, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( ( 2048 ) )", "index doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", localClientNum, 2048) )
      __debugbreak();
  }
  if ( ent->s.number != (_WORD)v6 )
  {
    v7 = SL_ConvertToString(stringValue);
    if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 196, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
      __debugbreak();
    v8 = ent - g_entities;
    if ( (unsigned int)v8 >= 0x800 )
    {
      LODWORD(v13) = 2048;
      LODWORD(localClientNum) = ent - g_entities;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 199, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( ( 2048 ) )", "index doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", localClientNum, v13) )
        __debugbreak();
    }
    LODWORD(v13) = ent->s.number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 909, ASSERT_TYPE_ASSERT, "(ent->s.number == G_GetEntityIndex( ent ))", "%s\n\ts.number = %i, index = %i, stringValue = %s", "ent->s.number == G_GetEntityIndex( ent )", v13, (__int16)v8, v7) )
      __debugbreak();
  }
  number = ent->s.number;
  if ( (unsigned int)number >= 0x800 )
  {
    LODWORD(v13) = 2048;
    LODWORD(localClientNum) = ent->s.number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", localClientNum, v13) )
      __debugbreak();
  }
  if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
    __debugbreak();
  if ( g_entities[number].r.isInUse != g_entityIsInUse[number] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
    __debugbreak();
  if ( !g_entityIsInUse[number] )
  {
    v10 = SL_ConvertToString(stringValue);
    LODWORD(v13) = ent->s.number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 910, ASSERT_TYPE_ASSERT, "(G_IsEntityInUse( ent->s.number ))", "%s\n\tent->s.number = %i, stringValue = %s", "G_IsEntityInUse( ent->s.number )", v13, v10) )
      __debugbreak();
  }
  v11 = ScriptContext_Server();
  Scr_NotifyNum(v11, ent->s.number, ENTITY_CLASS_GENTITY, stringValue, paramcount, LOCAL_CLIENT_0);
}

/*
==============
GScr_RadiusDamageInternal
==============
*/
void GScr_RadiusDamageInternal(scrContext_t *scrContext, gentity_s *inflictor)
{
  bool runOcclusionTraces; 
  float v5; 
  double Float; 
  float reactiveEmitterDelay; 
  float v8; 
  double v9; 
  float v10; 
  gentity_s *Entity; 
  meansOfDeath_t mod; 
  float v13; 
  double v14; 
  bool environmentOnly; 
  bool outIsAlternate; 
  vec3_t vectorValue; 
  Weapon outWeapon; 
  BgExplosionDamageRangeInfo outDamageRangeInfo; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  runOcclusionTraces = 1;
  v5 = GScr_ValidateRadiusDamageRange(scrContext, 1u);
  Float = Scr_GetFloat(scrContext, 2u);
  reactiveEmitterDelay = 0.0;
  v8 = *(float *)&Float;
  if ( *(float *)&Float < 0.0 || *(float *)&Float >= 2147483600.0 )
  {
    Scr_ParamError(COM_ERR_4303, scrContext, 2u, "Invalid damage value specified for radius damage.\n");
    v8 = 0.0;
  }
  v9 = Scr_GetFloat(scrContext, 3u);
  v10 = *(float *)&v9;
  if ( *(float *)&v9 < 0.0 || *(float *)&v9 >= 2147483600.0 )
  {
    Scr_ParamError(COM_ERR_4303, scrContext, 3u, "Invalid damage value specified for radius damage.\n");
    v10 = 0.0;
  }
  Entity = g_entities + 2046;
  if ( Scr_GetNumParam(scrContext) > 4 && Scr_GetType(scrContext, 4u) )
    Entity = GScr_GetEntity(4u);
  mod = MOD_EXPLOSIVE;
  if ( Scr_GetNumParam(scrContext) > 5 && Scr_GetType(scrContext, 5u) )
    mod = G_Combat_MeansOfDeathFromScriptParam(scrContext, 5);
  v13 = FLOAT_1_0;
  memset(&outWeapon, 0, 48);
  *(_DWORD *)&outWeapon.weaponCamo = *(_DWORD *)&NULL_WEAPON.weaponCamo;
  *(double *)&outWeapon.attachmentVariationIndices[21] = *(double *)&NULL_WEAPON.attachmentVariationIndices[21];
  if ( Scr_GetNumParam(scrContext) > 6 && Scr_GetType(scrContext, 6u) )
  {
    GScr_Main_GetWeaponParam(scrContext, 6u, &outWeapon, &outIsAlternate);
    reactiveEmitterDelay = BG_WeaponDef(&outWeapon, 0)->reactiveEmitterDelay;
    v14 = BG_ExplosionForceScalar(&outWeapon, outIsAlternate);
    v13 = *(float *)&v14;
  }
  environmentOnly = 0;
  if ( Scr_GetNumParam(scrContext) > 7 && Scr_GetType(scrContext, 7u) )
    environmentOnly = Scr_GetInt(scrContext, 7u) > 0;
  if ( Scr_GetNumParam(scrContext) > 8 && Scr_GetType(scrContext, 8u) )
    runOcclusionTraces = Scr_GetInt(scrContext, 8u) > 0;
  BG_BuildExplosionDamageRangeInfo_Interpolated(v8, v10, v5, &outDamageRangeInfo);
  GScr_RadiusDamageProcessInternal(&vectorValue, inflictor, Entity, &outDamageRangeInfo, mod, &outWeapon, v13, reactiveEmitterDelay, environmentOnly, runOcclusionTraces);
}

/*
==============
GScr_RadiusDamageProcessInternal
==============
*/
void GScr_RadiusDamageProcessInternal(const vec3_t *damageOrigin, gentity_s *const inflictor, gentity_s *const attacker, const BgExplosionDamageRangeInfo *damageRangeInfo, const meansOfDeath_t mod, const Weapon *weapon, const float forceScalar, const float reactiveEmitterDelay, const bool environmentOnly, const bool runOcclusionTraces)
{
  GCombat *v14; 
  __int64 v15; 
  gentity_s *v16; 
  float outerRadius; 
  float v18; 
  float v19; 
  __int64 v20; 

  level.bPlayerIgnoreRadiusDamage = level.bPlayerIgnoreRadiusDamageLatched;
  if ( !GCombat::ms_gCombatSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_combat.h", 177, ASSERT_TYPE_ASSERT, "( ms_gCombatSystem )", (const char *)&queryFormat, "ms_gCombatSystem") )
    __debugbreak();
  v14 = GCombat::ms_gCombatSystem;
  ((void (__fastcall *)(GCombat *, const vec3_t *, gentity_s *const, gentity_s *const, const BgExplosionDamageRangeInfo *, _DWORD, _QWORD, gentity_s *const, const meansOfDeath_t, const Weapon *, _BYTE, const bool, const bool))GCombat::ms_gCombatSystem->RadiusDamage)(GCombat::ms_gCombatSystem, damageOrigin, inflictor, attacker, damageRangeInfo, LODWORD(FLOAT_1_0), 0i64, inflictor, mod, weapon, 0, environmentOnly, runOcclusionTraces);
  level.bPlayerIgnoreRadiusDamage = 0;
  if ( mod == MOD_EXPLOSIVE )
  {
    LOBYTE(v20) = 0;
    ((void (__fastcall *)(GCombat *, const vec3_t *, __int64, gentity_s *const, const Weapon *, _DWORD))v14->NotifyRadiusDamage)(v14, damageOrigin, v15, attacker, weapon, v20);
  }
  v16 = G_Utils_SpawnEventEntity(damageOrigin, 132);
  if ( (mod < MOD_UNKNOWN || (unsigned int)mod > (MOD_NUM|MOD_PROJECTILE|0xE0)) && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned char __cdecl truncate_cast_impl<unsigned char,meansOfDeath_t>(meansOfDeath_t)", "unsigned", (unsigned __int8)mod, "signed", mod) )
    __debugbreak();
  v16->s.eventParm2 = (unsigned __int8)mod;
  if ( (unsigned __int8)mod != mod && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 13982, ASSERT_TYPE_ASSERT, "(static_cast<meansOfDeath_t>( eventEnt->s.eventParm2 ) == mod)", (const char *)&queryFormat, "static_cast<meansOfDeath_t>( eventEnt->s.eventParm2 ) == mod") )
    __debugbreak();
  v16->s.lerp.u.anonymous.data[3] = (int)damageRangeInfo->innerDamage;
  v16->s.lerp.u.anonymous.data[2] = (int)damageRangeInfo->outerDamage;
  outerRadius = damageRangeInfo->outerRadius;
  v16->s.lerp.u.anonymous.data[5] = runOcclusionTraces;
  v16->s.lerp.u.turret.gunAngles.v[0] = outerRadius;
  v16->s.lerp.u.turret.gunAngles.v[1] = reactiveEmitterDelay;
  v16->s.lerp.u.actor.impactVector.v[1] = forceScalar;
  if ( outerRadius < 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 13995, ASSERT_TYPE_SANITY, "( ( ( eventEnt->s.lerp.u.event.radiusDamage.range >= 0.0f ) ) )", "( eventEnt->s.lerp.u.event.radiusDamage.range ) = %g", outerRadius) )
    __debugbreak();
  v18 = v16->s.lerp.u.turret.gunAngles.v[1];
  if ( v18 < 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 13996, ASSERT_TYPE_SANITY, "( ( ( eventEnt->s.lerp.u.event.radiusDamage.delay >= 0.0f ) ) )", "( eventEnt->s.lerp.u.event.radiusDamage.delay ) = %g", v18) )
    __debugbreak();
  v19 = v16->s.lerp.u.actor.impactVector.v[1];
  if ( (v19 < 0.0 || v19 > 2.0) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 13997, ASSERT_TYPE_SANITY, "( ( ( ( eventEnt->s.lerp.u.event.radiusDamage.forceScalar >= 0.0f ) && ( eventEnt->s.lerp.u.event.radiusDamage.forceScalar <= PHYSICS_MAX_RADIUSFORCE_SCALAR ) ) ) )", "( eventEnt->s.lerp.u.event.radiusDamage.forceScalar ) = %g", v19) )
    __debugbreak();
  if ( v16->s.lerp.u.anonymous.data[3] < 0 )
  {
    LODWORD(v20) = v16->s.lerp.u.anonymous.data[3];
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 13998, ASSERT_TYPE_SANITY, "( ( ( eventEnt->s.lerp.u.event.radiusDamage.damageMax >= 0 ) ) )", "( eventEnt->s.lerp.u.event.radiusDamage.damageMax ) = %i", v20) )
      __debugbreak();
  }
  if ( v16->s.lerp.u.anonymous.data[2] < 0 )
  {
    LODWORD(v20) = v16->s.lerp.u.anonymous.data[2];
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 13999, ASSERT_TYPE_SANITY, "( ( ( eventEnt->s.lerp.u.event.radiusDamage.damageMin >= 0 ) ) )", "( eventEnt->s.lerp.u.event.radiusDamage.damageMin ) = %i", v20) )
      __debugbreak();
  }
}

/*
==============
GScr_RadiusDamageSteppedInternal
==============
*/
void GScr_RadiusDamageSteppedInternal(scrContext_t *scrContext, gentity_s *inflictor)
{
  bool runOcclusionTraces; 
  float v5; 
  double Float; 
  float reactiveEmitterDelay; 
  float v8; 
  float v9; 
  double v10; 
  float v11; 
  float v12; 
  double v13; 
  float v14; 
  gentity_s *Entity; 
  meansOfDeath_t mod; 
  float v17; 
  double v18; 
  bool environmentOnly; 
  bool outIsAlternate; 
  vec3_t vectorValue; 
  Weapon outWeapon; 
  BgExplosionDamageRangeInfo damageRangeInfo; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  runOcclusionTraces = 1;
  v5 = GScr_ValidateRadiusDamageRange(scrContext, 1u);
  Float = Scr_GetFloat(scrContext, 2u);
  reactiveEmitterDelay = 0.0;
  v8 = *(float *)&Float;
  if ( *(float *)&Float < 0.0 || *(float *)&Float >= 2147483600.0 )
  {
    Scr_ParamError(COM_ERR_4303, scrContext, 2u, "Invalid damage value specified for radius damage.\n");
    v8 = 0.0;
  }
  v9 = GScr_ValidateRadiusDamageRange(scrContext, 3u);
  v10 = Scr_GetFloat(scrContext, 4u);
  v11 = *(float *)&v10;
  if ( *(float *)&v10 < 0.0 || *(float *)&v10 >= 2147483600.0 )
  {
    Scr_ParamError(COM_ERR_4303, scrContext, 4u, "Invalid damage value specified for radius damage.\n");
    v11 = 0.0;
  }
  v12 = GScr_ValidateRadiusDamageRange(scrContext, 5u);
  v13 = Scr_GetFloat(scrContext, 6u);
  v14 = *(float *)&v13;
  if ( *(float *)&v13 < 0.0 || *(float *)&v13 >= 2147483600.0 )
  {
    Scr_ParamError(COM_ERR_4303, scrContext, 6u, "Invalid damage value specified for radius damage.\n");
    v14 = 0.0;
  }
  Entity = g_entities + 2046;
  if ( Scr_GetNumParam(scrContext) > 7 && Scr_GetType(scrContext, 7u) )
    Entity = GScr_GetEntity(7u);
  mod = MOD_EXPLOSIVE;
  if ( Scr_GetNumParam(scrContext) > 8 && Scr_GetType(scrContext, 8u) )
    mod = G_Combat_MeansOfDeathFromScriptParam(scrContext, 8);
  v17 = FLOAT_1_0;
  memset(&outWeapon, 0, 48);
  *(_DWORD *)&outWeapon.weaponCamo = *(_DWORD *)&NULL_WEAPON.weaponCamo;
  *(double *)&outWeapon.attachmentVariationIndices[21] = *(double *)&NULL_WEAPON.attachmentVariationIndices[21];
  if ( Scr_GetNumParam(scrContext) > 9 && Scr_GetType(scrContext, 9u) )
  {
    GScr_Main_GetWeaponParam(scrContext, 9u, &outWeapon, &outIsAlternate);
    reactiveEmitterDelay = BG_WeaponDef(&outWeapon, 0)->reactiveEmitterDelay;
    v18 = BG_ExplosionForceScalar(&outWeapon, outIsAlternate);
    v17 = *(float *)&v18;
  }
  environmentOnly = 0;
  if ( Scr_GetNumParam(scrContext) > 0xA && Scr_GetType(scrContext, 0xAu) )
    environmentOnly = Scr_GetInt(scrContext, 0xAu) > 0;
  if ( Scr_GetNumParam(scrContext) > 0xB && Scr_GetType(scrContext, 0xBu) )
    runOcclusionTraces = Scr_GetInt(scrContext, 0xBu) > 0;
  BG_BuildExplosionDamageRangeInfo_Stepped(v5, v8, v9, v11, v12, v14, &damageRangeInfo);
  GScr_RadiusDamageProcessInternal(&vectorValue, inflictor, Entity, &damageRangeInfo, mod, &outWeapon, v17, reactiveEmitterDelay, environmentOnly, runOcclusionTraces);
}

/*
==============
GScr_RemoteEyesClear_Internal
==============
*/
void GScr_RemoteEyesClear_Internal(playerState_s *const ps)
{
  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 20089, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal(&ps->otherFlags, ACTIVE, 1u);
  ps->remoteEyesEnt = 2047;
  GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::ClearFlagInternal(&ps->linkFlags, ACTIVE, 4u);
  GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::ClearFlagInternal(&ps->linkFlags, ACTIVE, 5u);
}

/*
==============
GScr_RemoteEyesSet_Internal
==============
*/
void GScr_RemoteEyesSet_Internal(playerState_s *const ps, __int16 remoteEyesEnt, bool setZNearClose, bool useTagAngles)
{
  __int64 v8; 

  if ( !ps && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 20070, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( (unsigned __int16)remoteEyesEnt >= 0x800u )
  {
    LODWORD(v8) = remoteEyesEnt;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 20071, ASSERT_TYPE_ASSERT, "(unsigned)( remoteEyesEnt ) < (unsigned)( ( 2048 ) )", "remoteEyesEnt doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v8, 2048) )
      __debugbreak();
  }
  ps->linkWeaponAngles.v[0] = ps->viewangles.v[0];
  ps->linkWeaponAngles.v[1] = ps->viewangles.v[1];
  ps->linkWeaponAngles.v[2] = ps->viewangles.v[2];
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal(&ps->otherFlags, ACTIVE, 1u);
  ps->remoteEyesEnt = remoteEyesEnt;
  if ( setZNearClose )
    GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::SetFlagInternal(&ps->linkFlags, ACTIVE, 4u);
  if ( useTagAngles )
    GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::SetFlagInternal(&ps->linkFlags, ACTIVE, 5u);
}

/*
==============
GScr_SBAddArray
==============
*/
int *GScr_SBAddArray(GScr_ScriptBundleContext *ctxt, ScriptBundleValue *arr)
{
  int *v2; 
  int v5; 
  ScriptBundleValue *v6; 
  bool v7; 

  v2 = (int *)&arr[1];
  if ( arr->type != SCR_SB_ARRAY && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 26032, ASSERT_TYPE_ASSERT, "(arr->type == ScriptBundleValue::ValueType::SCR_SB_ARRAY)", (const char *)&queryFormat, "arr->type == ScriptBundleValue::ValueType::SCR_SB_ARRAY") )
    __debugbreak();
  if ( !ctxt->pScrContext && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 26033, ASSERT_TYPE_ASSERT, "( ctxt.pScrContext )", (const char *)&queryFormat, "ctxt.pScrContext") )
    __debugbreak();
  Scr_MakeArray(ctxt->pScrContext);
  v5 = 0;
  if ( arr->string > 0 )
  {
    while ( 2 )
    {
      v6 = (ScriptBundleValue *)v2;
      v2 += 2;
      switch ( v6->type )
      {
        case SCR_B_NONE:
          Scr_AddUndefined(ctxt->pScrContext);
          goto LABEL_21;
        case SCR_SB_BOOL:
          Scr_AddBool(ctxt->pScrContext, v6->string);
          goto LABEL_21;
        case SCR_SB_INT:
          Scr_AddInt(ctxt->pScrContext, v6->string);
          goto LABEL_21;
        case SCR_SB_FLOAT:
          Scr_AddFloat(ctxt->pScrContext, v6->float_number);
          goto LABEL_21;
        case SCR_SB_STRING:
        case SCR_SB_ANIMTREE:
          Scr_AddString(ctxt->pScrContext, &ctxt->strPool[v6->string]);
          goto LABEL_21;
        case SCR_SB_OBJECT:
          v2 = GScr_SBAddObject(ctxt, v6);
          goto LABEL_21;
        case SCR_SB_ARRAY:
          v2 = GScr_SBAddArray(ctxt, v6);
          goto LABEL_21;
        case SCR_SB_ANIMATION:
          v7 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 26066, ASSERT_TYPE_ASSERT, "(!\"Script Bundle schema error - SCR_SB_ANIMATION in array???\")", (const char *)&queryFormat, "!\"Script Bundle schema error - SCR_SB_ANIMATION in array???\"");
          goto LABEL_19;
        case SCR_SB_ANIMTREEID:
          v7 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 26069, ASSERT_TYPE_ASSERT, "(!\"Script Bundle schema error - SCR_SB_ANIMTREEID should have been preprocessed to an SCR_SB_INT\")", (const char *)&queryFormat, "!\"Script Bundle schema error - SCR_SB_ANIMTREEID should have been preprocessed to an SCR_SB_INT\"");
          goto LABEL_19;
        default:
          v7 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 26072, ASSERT_TYPE_ASSERT, "(!\"Script Bundle parse error\")", (const char *)&queryFormat, "!\"Script Bundle parse error\"");
LABEL_19:
          if ( v7 )
            __debugbreak();
LABEL_21:
          Scr_AddArray(ctxt->pScrContext);
          if ( ++v5 >= arr->string )
            return v2;
          continue;
      }
    }
  }
  return v2;
}

/*
==============
GScr_SBAddObject
==============
*/
int *GScr_SBAddObject(GScr_ScriptBundleContext *ctxt, ScriptBundleValue *obj)
{
  int *v2; 
  int v5; 
  float *v6; 
  int *v7; 
  int v8; 
  ScriptBundleValue *v9; 
  __int64 v10; 
  unsigned int CanonicalString; 
  bool v12; 
  unsigned int v13; 

  v2 = (int *)&obj[1];
  if ( obj->type != SCR_SB_OBJECT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 25963, ASSERT_TYPE_ASSERT, "(obj->type == ScriptBundleValue::ValueType::SCR_SB_OBJECT)", (const char *)&queryFormat, "obj->type == ScriptBundleValue::ValueType::SCR_SB_OBJECT") )
    __debugbreak();
  if ( !ctxt->pScrContext && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 25964, ASSERT_TYPE_ASSERT, "( ctxt.pScrContext )", (const char *)&queryFormat, "ctxt.pScrContext") )
    __debugbreak();
  Scr_MakeStruct(ctxt->pScrContext);
  v5 = 0;
  if ( obj->string > 0 )
  {
    while ( 2 )
    {
      v6 = (float *)v2;
      v7 = v2;
      v8 = *((unsigned __int8 *)v2 + 4);
      v9 = (ScriptBundleValue *)(v2 + 1);
      v2 += 3;
      switch ( v8 )
      {
        case 0:
          Scr_AddUndefined(ctxt->pScrContext);
          goto LABEL_23;
        case 1:
          Scr_AddBool(ctxt->pScrContext, *((_DWORD *)v6 + 2));
          goto LABEL_23;
        case 2:
          Scr_AddInt(ctxt->pScrContext, *((_DWORD *)v6 + 2));
          goto LABEL_23;
        case 3:
          Scr_AddFloat(ctxt->pScrContext, v6[2]);
          goto LABEL_23;
        case 4:
        case 8:
          goto $LN27_33;
        case 5:
          v2 = GScr_SBAddObject(ctxt, v9);
          goto LABEL_23;
        case 6:
          v2 = GScr_SBAddArray(ctxt, v9);
          goto LABEL_23;
        case 7:
          v10 = 4i64;
          if ( ((unsigned __int8)v2 & 4) == 0 )
            v10 = 3i64;
          Scr_AddAnim(ctxt->pScrContext, *(scr_anim_t *)&v7[v10]);
          v2 = v7 + 6;
          CanonicalString = SL_GetCanonicalString("animationid");
          Scr_AppendToArchiveCanonicalString(ctxt->pScrContext, CanonicalString);
          Scr_AddStructField(ctxt->pScrContext, CanonicalString);
$LN27_33:
          Scr_AddString(ctxt->pScrContext, &ctxt->strPool[*((int *)v6 + 2)]);
          goto LABEL_23;
        case 9:
          v12 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 26012, ASSERT_TYPE_ASSERT, "(!\"Script Bundle schema error - SCR_SB_ANIMTREEID should have been preprocessed to an SCR_SB_INT\")", (const char *)&queryFormat, "!\"Script Bundle schema error - SCR_SB_ANIMTREEID should have been preprocessed to an SCR_SB_INT\"");
          goto LABEL_21;
        default:
          v12 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 26015, ASSERT_TYPE_ASSERT, "(!\"Script Bundle parse error\")", (const char *)&queryFormat, "!\"Script Bundle parse error\"");
LABEL_21:
          if ( v12 )
            __debugbreak();
LABEL_23:
          v13 = SL_GetCanonicalString(&ctxt->strPool[*(int *)v6]);
          Scr_AppendToArchiveCanonicalString(ctxt->pScrContext, v13);
          Scr_AddStructField(ctxt->pScrContext, v13);
          if ( ++v5 >= obj->string )
            return v2;
          continue;
      }
    }
  }
  return v2;
}

/*
==============
GScr_SetDvar_Internal
==============
*/
void GScr_SetDvar_Internal(scrContext_t *scrContext, const char *dvarName, const char *newValue, const unsigned int allowedModifyFlags)
{
  bool v8; 
  bool v9; 
  const dvar_t *VarByName; 
  const char *UnobfuscatedName; 
  const char *v12; 
  const dvar_t *v13; 
  unsigned int flags; 
  const char *v15; 

  v8 = Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_SLOW_SOFT_LAND|0x80);
  v9 = !Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_SLOW_SOFT_LAND|0x80);
  VarByName = Dvar_FindVarByName(dvarName);
  if ( v8 && VarByName && (VarByName->flags & 0x100) == 0 )
  {
    UnobfuscatedName = Dvar_DevGetUnobfuscatedName(dvarName);
    v12 = j_va("Invalid Dvar set: %s - Internal Dvars cannot be changed by script. Use 'setsaveddvar' to alter SAVED internal dvars\n", UnobfuscatedName);
    Scr_Error(COM_ERR_3985, scrContext, v12);
  }
  v13 = Dvar_SetFromStringByNameFromScript(SCRIPTINSTANCE_SERVER, dvarName, newValue);
  if ( v9 && allowedModifyFlags != -1 )
  {
    flags = v13->flags;
    if ( (flags & allowedModifyFlags) == 0 )
    {
      v15 = Dvar_DevGetUnobfuscatedName(dvarName);
      Com_PrintError(15, "SetDvar: dvar '%s' not allowed to be modified.  flags are '%d'.  New value supposed to be %s.\n", v15, flags, newValue);
    }
  }
}

/*
==============
GScr_SetOmnvarInternal
==============
*/
void GScr_SetOmnvarInternal(scrContext_t *scrContext, const OmnvarDef *def, OmnvarData *data, int valueArgumentIndex)
{
  int time; 
  const char *v9; 
  VariableType Type; 
  OmnvarUserType userType; 
  const char *v12; 
  int entnum; 
  const char *v14; 
  const char *v15; 
  const char *v16; 
  double Float; 
  const char *String; 
  const char *v19; 
  const char *v20; 

  switch ( def->type )
  {
    case OMNVAR_TYPE_BOOL:
      data->current.enabled = Scr_GetInt(scrContext, valueArgumentIndex) != 0;
      G_Omnvar_MarkChanged(data);
      break;
    case OMNVAR_TYPE_FLOAT:
      Float = Scr_GetFloat(scrContext, valueArgumentIndex);
      data->current.value = *(float *)&Float;
      G_Omnvar_MarkChanged(data);
      break;
    case OMNVAR_TYPE_INT:
      Type = Scr_GetType(scrContext, valueArgumentIndex);
      userType = def->userType;
      if ( Type == VAR_POINTER )
      {
        if ( userType != OMNVAR_USER_TYPE_ENTITY )
        {
          v12 = j_va("SetOmnvarInternal - '%s' cannot be set to a value of type entity", def->name);
          Scr_Error(COM_ERR_3968, scrContext, v12);
        }
        entnum = Scr_GetEntityRef(scrContext, valueArgumentIndex).entnum;
      }
      else if ( Type )
      {
        if ( userType == OMNVAR_USER_TYPE_ENTITY )
        {
          v15 = j_va("SetOmnvarInternal - '%s' can only be set to an entity or undefined", def->name);
          Scr_Error(COM_ERR_3970, scrContext, v15);
        }
        entnum = Scr_GetInt(scrContext, valueArgumentIndex);
      }
      else
      {
        if ( userType != OMNVAR_USER_TYPE_ENTITY )
        {
          v14 = j_va("SetOmnvarInternal - '%s' cannot be set to a value of undefined", def->name);
          Scr_Error(COM_ERR_3969, scrContext, v14);
        }
        entnum = 2047;
      }
      if ( entnum > def->maxvalue || entnum < def->minvalue )
      {
        v16 = j_va("SetOmnvarInternal - '%s' setting to %d would exceed this omnvar's specified range [%d,%d]", def->name, (unsigned int)entnum, (unsigned int)def->minvalue, def->maxvalue);
        Scr_Error(COM_ERR_3971, scrContext, v16);
      }
      if ( !data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_omnvar.h", 21, ASSERT_TYPE_ASSERT, "(data)", (const char *)&queryFormat, "data") )
        __debugbreak();
      if ( def->type != OMNVAR_TYPE_INT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_omnvar.h", 22, ASSERT_TYPE_ASSERT, "(def->type == OMNVAR_TYPE_INT)", (const char *)&queryFormat, "def->type == OMNVAR_TYPE_INT") )
        __debugbreak();
      data->current.integer = entnum - def->minvalue;
      G_Omnvar_MarkChanged(data);
      break;
    case OMNVAR_TYPE_UINT:
      data->current.integer = Scr_GetInt(scrContext, valueArgumentIndex);
      G_Omnvar_MarkChanged(data);
      break;
    case OMNVAR_TYPE_TIME:
      if ( def->userType == OMNVAR_USER_TYPE_NOTIFY )
        time = level.time;
      else
        time = Scr_GetInt(scrContext, valueArgumentIndex);
      if ( time < 0 )
      {
        v9 = j_va("SetOmnvarInternal - '%s' is a unsigned type, and can not be set to negative values", def->name);
        Scr_Error(COM_ERR_3967, scrContext, v9);
      }
      data->current.integer = time;
      G_Omnvar_MarkChanged(data);
      break;
    case OMNVAR_TYPE_NCS_LUI:
      String = Scr_GetString(scrContext, valueArgumentIndex);
      if ( !G_Omnvar_SetNCString(def, data, String) )
      {
        v19 = j_va("SetOmnvarInternal - '%s' is a LUI NetConstString, and cannot be set to '%s'. Did you add this string to ncsLuiStrings.txt?", def->name, String);
        Scr_Error(COM_ERR_3973, scrContext, v19);
      }
      G_Omnvar_MarkChanged(data);
      break;
    default:
      v20 = j_va("SetOmnvarInternal - Type for paramater %d not recognized", (unsigned int)valueArgumentIndex);
      Scr_Error(COM_ERR_3974, scrContext, v20);
      break;
  }
}

/*
==============
GScr_SetScriptablePartUsability
==============
*/
void GScr_SetScriptablePartUsability(scrContext_t *scrContext, scr_entref_t entref, const bool usable)
{
  unsigned int ScriptableIndex_Internal; 
  scr_string_t ConstString; 
  ScriptablePartDef *PartScriptedDefFromName; 
  const char *v8; 
  const char *v9; 
  gentity_s *Entity; 
  unsigned __int8 v11; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  if ( ScriptableIndex_Internal != -1 )
  {
    ConstString = Scr_GetConstString(scrContext, 0);
    if ( !ConstString )
      Scr_ParamError(COM_ERR_4795, scrContext, 0, "Part name cannot be empty");
    PartScriptedDefFromName = ScriptableSv_GetPartScriptedDefFromName(ScriptableIndex_Internal, ConstString, 1);
    if ( !PartScriptedDefFromName )
    {
      v8 = SL_ConvertToString(ConstString);
      v9 = j_va("Failed to get part def for name '%s'", v8);
      Scr_ParamError(COM_ERR_4796, scrContext, 0, v9);
    }
    Entity = GScr_GetEntity(1u);
    if ( !Entity->client )
      Scr_ParamError(COM_ERR_5926, scrContext, 1u, "Entity must be a player");
    v11 = truncate_cast<unsigned char,unsigned int>(PartScriptedDefFromName->serverInstanceFlatId);
    G_PlayerUse_SetObjectUsableForClient(ScriptableIndex_Internal, USE_CLASS_SCRIPTABLE, v11, usable, Entity->s.number);
  }
}

/*
==============
GScr_SetScriptableUsability
==============
*/
void GScr_SetScriptableUsability(scrContext_t *scrContext, scr_entref_t entref, const bool usable)
{
  unsigned int ScriptableIndex_Internal; 
  unsigned int v6; 
  const ScriptableDef *def; 
  gentity_s *Entity; 
  unsigned int i; 
  const ScriptablePartDef *v10; 
  __int64 serverInstanceFlatId; 

  ScriptableIndex_Internal = ScrCmd_GetScriptableIndex_Internal(scrContext, entref);
  v6 = ScriptableIndex_Internal;
  if ( ScriptableIndex_Internal != -1 )
  {
    if ( ScriptableIndex_Internal >= 0xFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 29133, ASSERT_TYPE_ASSERT, "( scriptableIndex < 0xffff )", (const char *)&queryFormat, "scriptableIndex < USHRT_MAX") )
      __debugbreak();
    def = ScriptableSv_GetInstanceCommonContext(v6)->def;
    if ( !def && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 29136, ASSERT_TYPE_ASSERT, "( scriptableDef )", (const char *)&queryFormat, "scriptableDef") )
      __debugbreak();
    Entity = GScr_GetEntity(0);
    if ( !Entity->client )
      Scr_ParamError(COM_ERR_5927, scrContext, 0, "Entity must be a player");
    for ( i = 0; i < def->numParts; ++i )
    {
      v10 = &def->parts[i];
      if ( ScriptableCommon_GetPartHasUsableState(v10) )
      {
        serverInstanceFlatId = v10->serverInstanceFlatId;
        if ( (unsigned int)serverInstanceFlatId > 0xFF && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned char __cdecl truncate_cast_impl<unsigned char,unsigned int>(unsigned int)", "unsigned", (unsigned __int8)serverInstanceFlatId, "unsigned", serverInstanceFlatId) )
          __debugbreak();
        G_PlayerUse_SetObjectUsableForClient(v6, USE_CLASS_SCRIPTABLE, serverInstanceFlatId, usable, Entity->s.number);
      }
    }
  }
}

/*
==============
GScr_SetupLightEntity
==============
*/
gentity_s *GScr_SetupLightEntity(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *v4; 
  const char *v5; 

  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 19563, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( Entity->s.eType != ET_PRIMARY_LIGHT )
  {
    v4 = SL_ConvertToString(Entity->classname);
    v5 = j_va("Function can only be called on a 'light' entity; actual classname is '%s'\n", v4);
    Scr_Error(COM_ERR_4523, scrContext, v5);
  }
  return Entity;
}

/*
==============
GScr_Shutdown
==============
*/
void GScr_Shutdown(void)
{
  if ( level.cachedTagMat.name )
    Scr_SetString(&level.cachedTagMat.name, (scr_string_t)0);
}

/*
==============
GScr_UpdateTagInternal
==============
*/
__int64 GScr_UpdateTagInternal(scrContext_t *scrContext, gentity_s *ent, scr_string_t tagName, cached_tag_mat_t *cachedTag, int shouldUseCache, int showScriptError)
{
  const char *v10; 
  const char *v11; 
  const char *ModelName; 
  actor_s *actor; 
  const char *v15; 
  const Weapon *Weapon; 
  bool IsAlternate; 
  const char *v18; 
  const char *v19; 
  const char *v20; 
  char output[512]; 

  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 16125, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !shouldUseCache || ent->s.number != cachedTag->entnum || level.time != cachedTag->time || tagName != cachedTag->name )
  {
    if ( !SV_Game_DObjExists(ent) )
    {
      if ( showScriptError )
      {
        v10 = SL_ConvertToString(ent->classname);
        v11 = j_va("entity has no model defined (classname '%s')", v10);
        Scr_ObjectError(COM_ERR_4390, scrContext, v11);
        return 0i64;
      }
      return 0i64;
    }
    if ( !G_Utils_DObjGetWorldTagMatrix(ent, tagName, &cachedTag->tagMat) )
    {
      if ( showScriptError )
      {
        SV_Game_DObjDumpInfo(ent);
        ModelName = G_CString_GetModelName(ent->model);
        actor = ent->actor;
        v15 = ModelName;
        if ( actor )
        {
          Weapon = GScr_Weapon_GetWeapon(scrContext, (const scr_weapon_t)actor->currentWeapon);
          IsAlternate = GScr_Weapon_IsAlternate(scrContext, (const scr_weapon_t)ent->actor->currentWeapon);
          BG_GetWeaponNameComplete(Weapon, IsAlternate, output, 0x200u);
          v18 = j_va(" - '%s' ", output);
        }
        else
        {
          v18 = (char *)&queryFormat.fmt + 3;
        }
        v19 = SL_ConvertToString(tagName);
        v20 = j_va("tag '%s' does not exist in model '%s'%s(or any attached submodels)", v19, v15, v18);
        Scr_ParamError(COM_ERR_4391, scrContext, 0, v20);
      }
      return 0i64;
    }
    cachedTag->entnum = ent->s.number;
    cachedTag->time = level.time;
    Scr_SetString(&cachedTag->name, tagName);
  }
  return 1i64;
}

/*
==============
GScr_ValidateRadiusDamageRange
==============
*/
float GScr_ValidateRadiusDamageRange(scrContext_t *scrContext, unsigned int index)
{
  double Float; 

  Float = Scr_GetFloat(scrContext, index);
  if ( *(float *)&Float >= 0.0 )
  {
    if ( *(float *)&Float > 512.0 )
    {
      Com_PrintWarning(24, "RadiusDamage called with extreme range %.2f - max is %.2f\n", *(float *)&Float, DOUBLE_512_0);
      *(float *)&Float = FLOAT_512_0;
    }
  }
  else
  {
    Scr_ParamError(COM_ERR_4302, scrContext, index, "Invalid <range> value specified for radius damage.\n");
    LODWORD(Float) = 0;
  }
  return *(float *)&Float;
}

/*
==============
G_GetAngleDelta
==============
*/
float G_GetAngleDelta(scrContext_t *scrContext, const scr_anim_t anim, const float startTime, float endTime)
{
  unsigned __int16 index; 
  const XAnim_s *Anims; 
  double v6; 
  vec2_t rot; 
  vec3_t trans; 

  index = anim.index;
  Anims = Scr_GetAnims(scrContext, anim.tree);
  XAnimGetRelDelta(Anims, index, &rot, &trans, startTime, endTime);
  v6 = RotationToYaw(&rot);
  return *(float *)&v6;
}

/*
==============
G_GetMoveDelta
==============
*/
void G_GetMoveDelta(scrContext_t *scrContext, const scr_anim_t anim, const float startTime, const float endTime, vec3_t *outMoveDelta)
{
  unsigned int index; 
  const XAnim_s *Anims; 
  vec4_t rot; 

  index = anim.index;
  Anims = Scr_GetAnims(scrContext, anim.tree);
  XAnimGetRelDelta3D(Anims, index, &rot, outMoveDelta, startTime, endTime);
}

/*
==============
G_LocalToWorldCoords
==============
*/
void G_LocalToWorldCoords(const gentity_s *pSelf, const vec3_t *local, vec3_t *outWorld)
{
  tmat33_t<vec3_t> axis; 

  AnglesToAxis(&pSelf->r.currentAngles, &axis);
  MatrixTransformVector(local, &axis, outWorld);
  outWorld->v[0] = pSelf->r.currentOrigin.v[0] + outWorld->v[0];
  outWorld->v[1] = pSelf->r.currentOrigin.v[1] + outWorld->v[1];
  outWorld->v[2] = pSelf->r.currentOrigin.v[2] + outWorld->v[2];
}

/*
==============
G_ScrMain_GetHintStringMessage
==============
*/
__int64 G_ScrMain_GetHintStringMessage(scrContext_t *scrContext, int firstParmIndex, int lastParmIndex)
{
  __int64 result; 
  char v7[1024]; 

  if ( !GScript::ms_gScriptSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.h", 183, ASSERT_TYPE_ASSERT, "( ms_gScriptSystem )", (const char *)&queryFormat, "ms_gScriptSystem") )
    __debugbreak();
  GScript::ms_gScriptSystem->ConstructMessageString(GScript::ms_gScriptSystem, scrContext, firstParmIndex, lastParmIndex, "Hint String", v7, 1024u);
  if ( !GConfigStrings::ms_gConfigStrings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_configstrings.h", 71, ASSERT_TYPE_ASSERT, "( ms_gConfigStrings )", (const char *)&queryFormat, "ms_gConfigStrings") )
    __debugbreak();
  result = ((__int64 (__fastcall *)(GConfigStrings *, char *))GConfigStrings::ms_gConfigStrings->GetHintStringIndex)(GConfigStrings::ms_gConfigStrings, v7);
  if ( !(_DWORD)result )
  {
    Com_PrintError(15, "Could not find or allocate hint string id for message '%s'. See console log for details.\n", v7);
    return 0i64;
  }
  return result;
}

/*
==============
G_SetEntityFlag
==============
*/
void G_SetEntityFlag(gentity_s *ent, EntityStateFlagsCommon flag)
{
  gclient_s *client; 
  LerpEntityState *p_lerp; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *p_eFlags; 

  client = ent->client;
  p_lerp = &ent->s.lerp;
  p_eFlags = &client->ps.eFlags;
  if ( !client )
    p_eFlags = &p_lerp->eFlags;
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(p_eFlags, ACTIVE, flag);
}

/*
==============
G_ValidateWorldUpIsSafe
==============
*/
void G_ValidateWorldUpIsSafe(scrContext_t *scrContext, gentity_s *clientEnt)
{
  gclient_s *ps; 
  GPlayerTraceInfo *PlayerTraceInfo; 
  BgTrace v6; 
  trace_t results; 

  ps = clientEnt->client;
  if ( ps && !BG_IsPlayerLinked(&clientEnt->client->ps) )
  {
    PlayerTraceInfo = GPlayerTraceInfo::GetPlayerTraceInfo(clientEnt->s.number);
    BgTrace::BgTrace(&v6, PlayerTraceInfo);
    BgTrace::LegacyTraceHandler(&v6, PHYSICS_WORLD_ID_FIRST, &results, &ps->ps.origin, &ps->ps.origin, &clientEnt->r.box, ps->ps.clientNum, clientEnt->clipmask & 0xFDFFBFFF, &ps->ps);
    if ( results.allsolid )
      Scr_Error(COM_ERR_4012, scrContext, "Unsafely setting the player's world up in collision, talk to Ben K. with questions.");
  }
}

/*
==============
GetScriptableArray_Internal
==============
*/
void GetScriptableArray_Internal(scrContext_t *scrContext, void (*gScrGetScriptableArrayImpl)(scrContext_t *, const int *, const scr_string_t, const vec3_t *, const float, const scr_string_t))
{
  int NumParam; 
  int *p_Offset; 
  vec3_t *p_vectorValue; 
  scr_string_t v8; 
  scr_string_t ConstLowercaseString; 
  const char *String; 
  const char *v12; 
  const char *v13; 
  int Offset; 
  vec3_t vectorValue; 

  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam == 3 )
  {
    Scr_Error(COM_ERR_4680, scrContext, "Requires both an origin and a radius if one or the other is provided");
    return;
  }
  p_Offset = NULL;
  p_vectorValue = NULL;
  v8 = 0;
  ConstLowercaseString = 0;
  LODWORD(_XMM6) = 0;
  if ( NumParam >= 1 && Scr_GetType(scrContext, 0) )
    ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  if ( NumParam >= 2 )
  {
    if ( Scr_GetType(scrContext, 1u) )
    {
      String = Scr_GetString(scrContext, 1u);
      v12 = String;
      if ( String )
      {
        if ( *String )
        {
          Offset = Scr_GetOffset(scrContext, ENTITY_CLASS_SCRIPTABLE, String);
          if ( Offset < 0 )
          {
            v13 = j_va("key '%s' does not internally belong to scriptables", v12);
            Scr_ParamError(COM_ERR_4681, scrContext, 1u, v13);
            return;
          }
          p_Offset = &Offset;
        }
      }
      else if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 24445, ASSERT_TYPE_ASSERT, "( key )", (const char *)&queryFormat, "key") )
      {
        __debugbreak();
      }
    }
    if ( NumParam >= 4 )
    {
      if ( Scr_GetType(scrContext, 2u) )
      {
        Scr_GetVector(scrContext, 2u, &vectorValue);
        p_vectorValue = &vectorValue;
        *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
        __asm { vmaxss  xmm6, xmm0, xmm6 }
      }
      if ( NumParam >= 5 )
        v8 = Scr_GetConstLowercaseString(scrContext, 4u);
    }
  }
  ((void (__fastcall *)(scrContext_t *, int *, _QWORD, vec3_t *, _DWORD, scr_string_t, int))gScrGetScriptableArrayImpl)(scrContext, p_Offset, (unsigned int)ConstLowercaseString, p_vectorValue, _XMM6, v8, Offset);
}

/*
==============
GetWeaponHudIconOverrideIndex
==============
*/
void GetWeaponHudIconOverrideIndex(scrContext_t *scrContext, scr_string_t weaponTypeName, unsigned int *outWeaponTypeIndex)
{
  bool v6; 
  const scr_string_t **v7; 
  unsigned int v8; 
  unsigned int i; 
  bool v10; 
  const char *v11; 
  const char *v12; 
  unsigned int v13; 
  unsigned int v14; 

  Com_GameMode_SupportsFeature(WEAPON_DROPPING_QUICK);
  v6 = Com_GameMode_SupportsFeature(WEAPON_DROPPING_QUICK);
  v7 = S_WEAPON_HUD_ICON_TYPE_NAMES;
  v8 = 7;
  if ( v6 )
    v8 = 10;
  for ( i = 0; i < v8; ++i )
  {
    if ( weaponTypeName == **v7 )
      break;
    ++v7;
  }
  Com_Printf_NoFilter("icontypeindex: %d", i);
  v10 = i < v8;
  if ( i == v8 )
  {
    v11 = SL_ConvertToString(weaponTypeName);
    v12 = j_va("\"%s\" is not a valid weapon hud icon type to override", v11);
    Scr_ParamError(COM_ERR_4620, scrContext, 0, v12);
    v10 = i < v8;
  }
  if ( !v10 )
  {
    v14 = v8;
    v13 = i;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 22286, ASSERT_TYPE_ASSERT, "(unsigned)( weaponTypeIndex ) < (unsigned)( iconTypeCount )", "weaponTypeIndex doesn't index iconTypeCount\n\t%i not in [0, %i)", v13, v14) )
      __debugbreak();
  }
  *outWeaponTypeIndex = i;
}

/*
==============
ScrCmd_BuildHudOutlineClientMaskFromEntArray
==============
*/
void ScrCmd_BuildHudOutlineClientMaskFromEntArray(scrContext_t *scrContext, unsigned int paramIndex, ClientBits *outClientMask)
{
  unsigned int ArrayObject; 
  unsigned int ArraySize; 
  unsigned int v8; 
  unsigned int ArrayVariable; 
  int intValue; 
  scr_entref_t EntityIdRef; 
  __int64 v12; 
  __int64 v13; 

  if ( !outClientMask && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 11146, ASSERT_TYPE_ASSERT, "(outClientMask)", (const char *)&queryFormat, "outClientMask") )
    __debugbreak();
  ArrayObject = BGScr_Main_GetArrayObject(scrContext, paramIndex);
  ArraySize = GetArraySize(scrContext, ArrayObject);
  if ( !ArraySize )
    Scr_ParamError(COM_ERR_4234, scrContext, paramIndex, "An empty array is not valid.");
  v8 = 0;
  *(_QWORD *)outClientMask->array = 0i64;
  *(_QWORD *)&outClientMask->array[2] = 0i64;
  *(_QWORD *)&outClientMask->array[4] = 0i64;
  for ( outClientMask->array[6] = 0; v8 < ArraySize; ++v8 )
  {
    ArrayVariable = GetArrayVariable(scrContext, ArrayObject, v8);
    if ( GetValueType(scrContext, ArrayVariable) != VAR_POINTER )
      Scr_ParamError(COM_ERR_4235, scrContext, paramIndex, "All array elements need to be client entities.");
    intValue = GetVariableValueAddress(scrContext, ArrayVariable)->intValue;
    if ( GetObjectType(scrContext, intValue) != VAR_ENTITY )
      Scr_ParamError(COM_ERR_4236, scrContext, paramIndex, "All array elements need to be client entities.");
    EntityIdRef = Scr_GetEntityIdRef(scrContext, intValue);
    if ( EntityIdRef.entclass )
      Scr_ParamError(COM_ERR_4237, scrContext, paramIndex, "All array elements need to be client entities.");
    if ( (EntityIdRef.entnum > 0x7FFFFFFF || EntityIdRef.entnum + 0x8000 > 0xFFFF) && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "short __cdecl truncate_cast_impl<short,unsigned int>(unsigned int)", "signed", SLOWORD(EntityIdRef.entnum), "unsigned", EntityIdRef.entnum) )
      __debugbreak();
    if ( !ComCharacterLimits::ms_isGameDataValid && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_character_limits.h", 123, ASSERT_TYPE_ASSERT, "(ms_isGameDataValid)", (const char *)&queryFormat, "ms_isGameDataValid") )
      __debugbreak();
    if ( SLOWORD(EntityIdRef.entnum) >= (int)ComCharacterLimits::ms_gameData.m_characterCount )
      Scr_ParamError(COM_ERR_4238, scrContext, paramIndex, "All array elements need to be character entities.");
    if ( SLOWORD(EntityIdRef.entnum) < level.maxclients )
    {
      if ( (unsigned int)SLOWORD(EntityIdRef.entnum) >= 0xE0 )
      {
        LODWORD(v13) = 224;
        LODWORD(v12) = SLOWORD(EntityIdRef.entnum);
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 263, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v12, v13) )
          __debugbreak();
      }
      outClientMask->array[(unsigned __int64)(unsigned int)SLOWORD(EntityIdRef.entnum) >> 5] |= 0x80000000 >> (EntityIdRef.entnum & 0x1F);
    }
  }
}

/*
==============
ScrCmd_EnableDisableAudioTrigger
==============
*/
void ScrCmd_EnableDisableAudioTrigger(scrContext_t *scrContext, bool enabled)
{
  const char *String; 
  unsigned int v5; 
  const char *v6; 
  const char *v7; 
  int v8; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    String = Scr_GetString(scrContext, 0);
    v5 = SND_HashName(String);
    if ( !CG_CheckAudioStateId(String) )
    {
      v6 = j_va("Enable/DisableAudioTrigger: Bad state id name: %s\n", String);
      Scr_Error(COM_ERR_4725, scrContext, v6);
    }
    v8 = enabled + 48;
    v7 = j_va("%c %c %x %c", 109i64, 102i64, v5, v8);
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v7);
  }
  else
  {
    Scr_Error(COM_ERR_4724, scrContext, "DisableAudioTrigger: Incorrect number of parameters\n");
  }
}

/*
==============
ScrCmd_EnableDisablePASpeaker
==============
*/
void ScrCmd_EnableDisablePASpeaker(scrContext_t *scrContext, const char *name, bool enable)
{
  unsigned int v3; 
  const char *v5; 
  char v6; 
  unsigned int v7; 
  char v8; 
  unsigned int audioPASpeakerCount; 
  unsigned int *p_nameHash; 
  const char *v11; 
  const char *v12; 

  v3 = 0;
  v5 = name;
  if ( name && (v6 = *name) != 0 )
  {
    v7 = 5381;
    do
    {
      ++v5;
      v8 = v6 | 0x20;
      if ( (unsigned int)(v6 - 65) >= 0x1A )
        v8 = v6;
      v7 = 65599 * v7 + v8;
      v6 = *v5;
    }
    while ( *v5 );
    if ( !v7 )
      v7 = 1;
  }
  else
  {
    v7 = 0;
  }
  if ( cm.mapEnts )
  {
    audioPASpeakerCount = cm.mapEnts->audioPASpeakerCount;
    if ( !audioPASpeakerCount )
    {
LABEL_16:
      v11 = j_va("Enable/DisablePASpeaker: Speaker %s not found", name);
      Scr_Error(COM_ERR_4727, scrContext, v11);
      return;
    }
    p_nameHash = &cm.mapEnts->audioPASpeakers->nameHash;
    while ( *p_nameHash != v7 )
    {
      ++v3;
      p_nameHash += 5;
      if ( v3 >= audioPASpeakerCount )
        goto LABEL_16;
    }
  }
  v12 = j_va("%c %x %c", 120i64, v7, (unsigned int)enable + 48);
  SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v12);
}

/*
==============
ScrCmd_GetScriptableEventType_Internal
==============
*/
__int64 ScrCmd_GetScriptableEventType_Internal(scr_string_t name)
{
  if ( name == scr_const.scriptable_event_wait )
    return 1i64;
  if ( name == scr_const.scriptable_event_script )
    return 3i64;
  if ( name == scr_const.scriptable_event_model )
    return 4i64;
  if ( name == scr_const.scriptable_event_collision )
    return 5i64;
  if ( name == scr_const.scriptable_event_animation )
    return 6i64;
  if ( name == scr_const.scriptable_event_move )
    return 34i64;
  return (unsigned int)(name != scr_const.scriptable_event_script_damage) + 43;
}

/*
==============
ScrCmd_GetScriptableIndex_Internal
==============
*/
__int64 ScrCmd_GetScriptableIndex_Internal(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  unsigned int scriptableIndex; 

  scriptableIndex = 0;
  entnum = entref.entnum;
  if ( entref.entclass )
  {
    if ( entref.entclass == ENTITY_CLASS_SCRIPTABLE )
    {
      return entref.entnum;
    }
    else
    {
      Scr_ObjectError(COM_ERR_4757, scrContext, "self not an ENTITY_CLASS_GENTITY or ENTITY_CLASS_SCRIPTABLE");
      return 0xFFFFFFFFi64;
    }
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 188, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", entref.entnum, 2048) )
      __debugbreak();
    if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 189, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
      __debugbreak();
    if ( ScriptableSv_TryGetIndexForEntity(&g_entities[entnum], &scriptableIndex) )
    {
      return scriptableIndex;
    }
    else
    {
      Scr_Error(COM_ERR_4756, scrContext, "self entity must have an attached scriptable");
      return 0xFFFFFFFFi64;
    }
  }
}

/*
==============
ScrCmd_GetTableEntries
==============
*/
__int64 ScrCmd_GetTableEntries(scrContext_t *scrContext, const unsigned int arrayId, std::pair<unsigned int,VariableUnion const *> *outEntries, VariableType *outType)
{
  std::pair<unsigned int,VariableUnion const *> *v5; 
  unsigned int v8; 
  unsigned int FirstSibling; 
  unsigned int VariableName; 
  int ValueType; 
  const VariableUnion *VariableValueAddressConst; 
  const char *v13; 
  const char *v14; 
  const char *v15; 
  const char *v16; 
  const char *v17; 
  ComErrorCode v18; 
  const char *v19; 
  const char *v20; 
  const char *NameForType; 
  const char *v22; 

  v5 = outEntries;
  if ( !outEntries && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 33010, ASSERT_TYPE_ASSERT, "( outEntries != nullptr )", (const char *)&queryFormat, "outEntries != nullptr") )
    __debugbreak();
  if ( !outType && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 33011, ASSERT_TYPE_ASSERT, "( outType != nullptr )", (const char *)&queryFormat, "outType != nullptr") )
    __debugbreak();
  *outType = VAR_UNDEFINED;
  v8 = 0;
  FirstSibling = FindFirstSibling(scrContext, arrayId);
  if ( FirstSibling )
  {
    while ( 1 )
    {
      VariableName = GetVariableName(scrContext, FirstSibling);
      ValueType = (unsigned __int8)GetValueType(scrContext, FirstSibling);
      VariableValueAddressConst = GetVariableValueAddressConst(scrContext, FirstSibling);
      if ( ValueType == 2 )
      {
        if ( *outType == VAR_UNDEFINED )
        {
          *outType = VAR_STRING;
          goto LABEL_25;
        }
        if ( *outType == VAR_STRING )
          goto LABEL_25;
        NameForType = Scr_GetNameForType(VAR_STRING);
        v22 = Scr_GetNameForType(*outType);
        v17 = j_va("Array contains mismatching types: %s != %s", v22, NameForType);
        v18 = COM_ERR_6573;
        goto LABEL_24;
      }
      if ( ValueType == 5 )
        break;
      if ( ValueType == 6 )
      {
        if ( *outType == VAR_UNDEFINED )
        {
          *outType = VAR_INTEGER;
LABEL_25:
          v5->first = VariableName;
          ++v8;
          v5->second = VariableValueAddressConst;
          ++v5;
          goto LABEL_26;
        }
        if ( *outType == VAR_INTEGER )
          goto LABEL_25;
        v15 = Scr_GetNameForType((VariableType)ValueType);
        v16 = Scr_GetNameForType(*outType);
        v17 = j_va("Array contains mismatching types: %s != %s", v16, v15);
        v18 = COM_ERR_6437;
LABEL_24:
        Scr_ParamError(v18, scrContext, 0, v17);
        goto LABEL_25;
      }
      v13 = Scr_GetNameForType((VariableType)ValueType);
      v14 = j_va("Array contains value that is not a comparable: %s", v13);
      Scr_ParamError(COM_ERR_6574, scrContext, 0, v14);
LABEL_26:
      FirstSibling = FindNextSibling(scrContext, FirstSibling);
      if ( !FirstSibling )
        return v8;
    }
    if ( *outType == VAR_UNDEFINED )
    {
      *outType = VAR_FLOAT;
      goto LABEL_25;
    }
    if ( *outType == VAR_FLOAT )
      goto LABEL_25;
    v19 = Scr_GetNameForType((VariableType)ValueType);
    v20 = Scr_GetNameForType(*outType);
    v17 = j_va("Array contains mismatching types: %s != %s", v20, v19);
    v18 = COM_ERR_6572;
    goto LABEL_24;
  }
  return v8;
}

/*
==============
ScrCmd_PlayRumbleOnEntity_Internal
==============
*/
void ScrCmd_PlayRumbleOnEntity_Internal(scrContext_t *scrContext, scr_entref_t entref, int event)
{
  gentity_s *Entity; 
  const char *String; 
  const char *v7; 
  gclient_s *client; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *p_eFlags; 
  unsigned int outIndex; 

  Entity = GetEntity(entref);
  if ( !Entity->agent )
  {
    String = Scr_GetString(scrContext, 0);
    if ( !NetConstStrings_GetIndexFromName(NETCONSTSTRINGTYPE_RUMBLE, String, &outIndex) )
    {
      v7 = j_va("unknown rumble name '%s'", String);
      Scr_ParamError(COM_ERR_4284, scrContext, 0, v7);
    }
    Entity->r.svFlags &= ~1u;
    if ( Scr_GetNumParam(scrContext) == 1 )
    {
      if ( event == 150 )
      {
        client = Entity->client;
        if ( client )
          p_eFlags = &client->ps.eFlags;
        else
          p_eFlags = &Entity->s.lerp.eFlags;
        GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(p_eFlags, GameModeFlagValues::ms_mpValue, 0x17u);
      }
      G_Utils_AddEvent(Entity, event, outIndex);
    }
    else
    {
      Scr_Error(COM_ERR_4285, scrContext, "Incorrect number of parameters.\n");
    }
  }
}

/*
==============
ScrCmd_Unlink_Internal
==============
*/
void ScrCmd_Unlink_Internal(gentity_s *ent, int allowUnlinkIncollision)
{
  gclient_s *client; 
  gclient_s *v5; 
  GMovingPlatforms *v6; 
  unsigned int v7; 
  ai_scripted_t *m_pAI; 
  __int64 v9; 
  AIWrapper v10; 

  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 8348, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  G_AllowEntUnlinkInCollision(allowUnlinkIncollision != 0);
  G_EntUnlink(ent);
  G_AllowEntUnlinkInCollision(0);
  client = ent->client;
  if ( client )
  {
    client->linkAnglesFrac = 0.0;
    ent->client->flags &= ~4u;
    GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::ClearFlagInternal(&ent->client->ps.linkFlags, ACTIVE, 0);
    GameModeFlagContainer<enum PLinkFlagsCommon,enum PLinkFlagsSP,enum PLinkFlagsMP,32>::ClearFlagInternal(&ent->client->ps.linkFlags, GameModeFlagValues::ms_spValue, 7u);
    v5 = ent->client;
    if ( !GMovingPlatforms::ms_instance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\movingplatforms\\g_moving_platforms.h", 207, ASSERT_TYPE_ASSERT, "(ms_instance)", (const char *)&queryFormat, "ms_instance") )
      __debugbreak();
    v6 = GMovingPlatforms::ms_instance;
    if ( !v5->movingPlatformHandle.m_objIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_object_handle.h", 36, ASSERT_TYPE_ASSERT, "(IsDefined())", "%s\n\tCan't get the index of an undefined handle", "IsDefined()") )
      __debugbreak();
    v7 = v5->movingPlatformHandle.m_objIndex - 1;
    if ( !(_BYTE)GMovingPlatforms::ms_allocatedType && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\movingplatforms\\g_moving_platforms.h", 198, ASSERT_TYPE_ASSERT, "( ms_allocatedType != GameModeType::NONE )", (const char *)&queryFormat, "ms_allocatedType != GameModeType::NONE") )
      __debugbreak();
    if ( v7 >= 0xF8 )
    {
      LODWORD(v9) = v7;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\movingplatforms\\g_moving_platforms.h", 199, ASSERT_TYPE_ASSERT, "(unsigned)( clientIndex ) < (unsigned)( ( sizeof( *array_counter( m_moverClientArray ) ) + 0 ) )", "clientIndex doesn't index ARRAY_COUNT( m_moverClientArray )\n\t%i not in [0, %i)", v9, 248) )
        __debugbreak();
    }
    GMovingPlatformClient::UpdatePlatformTrace(&v6->m_moverClientArray[v7], ent, 1);
  }
  AIActorInterface::AIActorInterface(&v10.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v10.m_newAgentInterface);
  v10.m_pAI = NULL;
  v10.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AIWrapper::Setup(&v10, ent);
  if ( v10.m_pAI )
  {
    m_pAI = v10.m_pAI->m_pAI;
    if ( m_pAI->eScriptSetAnimMode == AI_ANIM_POINT_RELATIVE )
      m_pAI->eScriptSetAnimMode = AI_ANIM_UNKNOWN;
  }
}

/*
==============
ScrLinkTo_Internal
==============
*/
void ScrLinkTo_Internal(scrContext_t *scrContext, scr_entref_t entref, bool blendToTag, bool movementChangesOffset)
{
  gentity_s *Entity; 
  unsigned int ScriptableIndexForEntity; 
  char v9; 
  const char *EntityTypeName; 
  const char *ModelName; 
  const char *v12; 
  ComErrorCode v13; 
  const char *v14; 
  gentity_s *v15; 
  int NumParam; 
  scr_string_t ConstLowercaseString; 
  const char *v18; 
  AIWrapper v19; 
  vec3_t anglesOffset; 
  vec3_t vectorValue; 
  char outErrorMessage[256]; 

  Entity = GetEntity(entref);
  if ( Scr_GetType(scrContext, 0) != VAR_POINTER || Scr_GetPointerType(scrContext, 0) != VAR_ENTITY )
    Scr_ParamError(COM_ERR_4156, scrContext, 0, "not an entity");
  if ( Entity->client )
    Scr_ParamError(COM_ERR_4157, scrContext, 0, "This function doesn't support player entities.");
  if ( (Entity->flags.m_flags[0] & 0x200) == 0 )
  {
    ScriptableIndexForEntity = ScriptableSv_GetScriptableIndexForEntity(Entity);
    if ( ScriptableIndexForEntity == -1 || (ScriptableCommon_AssertCountsInitialized(), ScriptableIndexForEntity < g_scriptableWorldCounts.runtimeInstanceCount) )
    {
      v9 = 0;
    }
    else
    {
      v9 = 1;
      ScriptableSv_VerifyScriptableMoverEntity(Entity);
    }
    EntityTypeName = G_GetEntityTypeName(Entity);
    if ( v9 )
    {
      ModelName = G_CString_GetModelName(Entity->model);
      v12 = j_va("scriptable (model: '%s', type: '%s') link failed.  Call EnableLinkTo() on the scriptable first before calling LinkTo()", ModelName, EntityTypeName);
      v13 = COM_ERR_4158;
    }
    else
    {
      v14 = SL_ConvertToString(Entity->classname);
      v12 = j_va("entity (classname: '%s', type: '%s') does not currently support linkTo", v14, EntityTypeName);
      v13 = COM_ERR_4160;
    }
    Scr_ObjectError(v13, scrContext, v12);
  }
  v15 = GScr_GetEntity(0);
  NumParam = Scr_GetNumParam(scrContext);
  ConstLowercaseString = 0;
  if ( NumParam >= 2 )
  {
    ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 1u);
    if ( ConstLowercaseString == scr_const._ )
      ConstLowercaseString = 0;
  }
  if ( NumParam > 2 && !blendToTag )
  {
    Scr_GetVector(scrContext, 2u, &vectorValue);
    Scr_GetVector(scrContext, 3u, &anglesOffset);
    if ( G_EntLinkToWithOffset(Entity, v15, ConstLowercaseString, &vectorValue, &anglesOffset, 256, outErrorMessage) )
    {
      Entity->tagInfo->movementChangesOffset = movementChangesOffset;
      return;
    }
    goto LABEL_37;
  }
  if ( !G_EntLinkTo(Entity, v15, ConstLowercaseString, 256, outErrorMessage) )
  {
LABEL_37:
    v18 = j_va("failed to link entity %i to entity %i: %s", (unsigned int)Entity->s.number, (unsigned int)v15->s.number, outErrorMessage);
    Scr_Error(COM_ERR_4162, scrContext, v18);
    return;
  }
  Entity->tagInfo->blendToParent = blendToTag;
  Entity->tagInfo->movementChangesOffset = movementChangesOffset;
  Entity->tagInfo->blendOnlyYaw = Com_GameMode_SupportsFeature(WEAPON_MELEE_END) && (!blendToTag || NumParam <= 2 || Scr_GetInt(scrContext, 2u) != 0);
  Entity->tagInfo->collisionPhysics = Com_GameMode_SupportsFeature(WEAPON_EXECUTION) && blendToTag && NumParam > 3 && Scr_GetInt(scrContext, 3u) != 0;
  AIActorInterface::AIActorInterface(&v19.m_actorInterface);
  AIAgentInterface::AIAgentInterface(&v19.m_newAgentInterface);
  v19.m_pAI = NULL;
  v19.m_newAgentInterface.__vftable = (AINewAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
  AIWrapper::Setup(&v19, Entity);
  if ( blendToTag )
  {
    if ( v19.m_pAI )
      *(_DWORD *)((__int64)v19.m_pAI->GetAI(v19.m_pAI) + 2424) = 10;
  }
}

/*
==============
Scr_DrawCone
==============
*/
void Scr_DrawCone(const vec3_t *start, const vec3_t *angles, float coneAngle, float range, const vec4_t *color)
{
  float v7; 
  __int64 v8; 
  __int64 v9; 
  __int64 v10; 
  __int64 v11; 
  float v12; 
  __int128 v13; 
  double v14; 
  float v15; 
  float v16; 
  float v17; 
  __int128 v18; 
  vec3_t end; 
  tmat33_t<vec3_t> axis; 
  vec3_t starta; 

  v7 = sinf_0(coneAngle * 0.017453292) * range;
  AnglesToAxis(angles, &axis);
  LODWORD(v12) = LODWORD(range) ^ _xmm;
  v13 = 0i64;
  do
  {
    v14 = j___libm_sse2_sincosf_(v9, v8, v10, v11);
    v15 = _mm_shuffle_ps((__m128)*(unsigned __int64 *)&v14, (__m128)*(unsigned __int64 *)&v14, 1).m128_f32[0];
    v16 = (float)((float)((float)(v15 * v7) * axis.m[0].v[1]) + start->v[1]) + (float)((float)(*(float *)&v14 * v7) * axis.m[2].v[1]);
    end.v[0] = (float)((float)((float)((float)(v15 * v7) * axis.m[0].v[0]) + start->v[0]) + (float)((float)(*(float *)&v14 * v7) * axis.m[2].v[0])) + (float)(v12 * axis.m[1].v[0]);
    v17 = (float)((float)(v15 * v7) * axis.m[0].v[2]) + start->v[2];
    end.v[1] = v16 + (float)(v12 * axis.m[1].v[1]);
    end.v[2] = (float)(v17 + (float)((float)(*(float *)&v14 * v7) * axis.m[2].v[2])) + (float)(v12 * axis.m[1].v[2]);
    CL_AddDebugLine(start, &end, color, 0, 0, 1);
    if ( *(float *)&v13 > 9.0 )
      CL_AddDebugLine(&starta, &end, color, 0, 0, 1);
    v18 = v13;
    *(float *)&v18 = *(float *)&v13 + 18.0;
    v13 = v18;
    starta = end;
  }
  while ( *(float *)&v18 <= 360.0 );
}

/*
==============
Scr_EmitScriptBundleAnimations
==============
*/
void Scr_EmitScriptBundleAnimations(XAssetHeader bundle, void *data)
{
  scrContext_t *v4; 
  ScriptBundleValue *v5; 
  GScr_ScriptBundleContext ctxt; 

  if ( !data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 26195, ASSERT_TYPE_ASSERT, "(data != nullptr)", (const char *)&queryFormat, "data != nullptr") )
    __debugbreak();
  if ( bundle.physicsLibrary )
  {
    if ( SLODWORD(bundle.physicsLibrary[1].name) <= 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 26199, ASSERT_TYPE_ASSERT, "(bundle.scriptBundle->rootSize > 0)", (const char *)&queryFormat, "bundle.scriptBundle->rootSize > 0") )
      __debugbreak();
    v4 = *(scrContext_t **)data;
    ctxt.strPool = bundle.physicsLibrary->havokData;
    ctxt.currentAnimTree = s_defaultScriptbundleAnimtree;
    ctxt.pScrContext = v4;
    ScriptContext_GetInstance(v4);
    v5 = *(ScriptBundleValue **)&bundle.physicsLibrary[1].isMaterialList;
    ctxt.anim_user = 1;
    Scr_SBPreScanObject(&ctxt, v5);
  }
}

/*
==============
Scr_EmitScriptBundlesAnimations
==============
*/
void Scr_EmitScriptBundlesAnimations(scrContext_t *scrContext)
{
  scrContext_t *inData; 

  inData = scrContext;
  DB_EnumXAssets(ASSET_TYPE_SCRIPTBUNDLE, Scr_EmitScriptBundleAnimations, &inData, 0);
}

/*
==============
Scr_ErrorOnDefaultAsset
==============
*/
void Scr_ErrorOnDefaultAsset(scrContext_t *scrContext, XAssetType type, const char *assetName)
{
  const char *XAssetTypeName; 
  const char *v7; 

  DB_FindXAssetHeader(type, assetName, 1);
  if ( DB_IsXAssetDefault(type, assetName) )
  {
    if ( !DB_CheckIfMissingAssetIsTransient(type, assetName) )
    {
      XAssetTypeName = DB_GetXAssetTypeName(type);
      v7 = j_va("precache %s '%s' failed", XAssetTypeName, assetName);
      Scr_NeverTerminalError(COM_ERR_4278, scrContext, v7);
    }
  }
}

/*
==============
Scr_FPrint_internal
==============
*/
void Scr_FPrint_internal(scrContext_t *scrContext, bool commaBetweenFields)
{
  unsigned int Int; 
  fileHandle_t *v5; 
  unsigned int i; 
  const char *String; 
  unsigned __int64 v8; 
  int v9; 

  if ( Scr_GetNumParam(scrContext) <= 1 )
  {
    Com_Printf(23, "fprintln requires at least 2 parameters (file, output)\n");
LABEL_14:
    v9 = -1;
    goto LABEL_15;
  }
  Int = Scr_GetInt(scrContext, 0);
  if ( Int > 1 )
  {
    Com_Printf(23, "FPrintln failed, invalid file number %i\n", Int);
    goto LABEL_14;
  }
  v5 = (fileHandle_t *)&level.openScriptIOFileBuffers[(int)Int - 1];
  if ( v5->handle.handle == -1 )
  {
    Com_Printf(23, "FPrintln failed, file number %i was not open for writing\n", Int);
    goto LABEL_14;
  }
  for ( i = 1; i < Scr_GetNumParam(scrContext); ++i )
  {
    String = Scr_GetString(scrContext, i);
    v8 = -1i64;
    do
      ++v8;
    while ( String[v8] );
    FS_Write(String, v8, (fileHandle_t)v5->handle.handle);
    if ( commaBetweenFields )
      FS_Write(",", 1ui64, (fileHandle_t)v5->handle.handle);
  }
  FS_Write("\n", 1ui64, (fileHandle_t)v5->handle.handle);
  v9 = Scr_GetNumParam(scrContext) - 1;
LABEL_15:
  Scr_AddInt(scrContext, v9);
}

/*
==============
Scr_FxParamError
==============
*/
void Scr_FxParamError(ComErrorCode uniqueErrorCode, scrContext_t *scrContext, int paramIndex, const char *errorString, int fxId)
{
  const char *v9; 
  char dest[1024]; 

  if ( !errorString && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 14973, ASSERT_TYPE_ASSERT, "(errorString)", (const char *)&queryFormat, "errorString") )
    __debugbreak();
  if ( fxId )
  {
    if ( !GConfigStrings::ms_gConfigStrings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_configstrings.h", 71, ASSERT_TYPE_ASSERT, "( ms_gConfigStrings )", (const char *)&queryFormat, "ms_gConfigStrings") )
      __debugbreak();
    GConfigStrings::ms_gConfigStrings->GetEffectName(GConfigStrings::ms_gConfigStrings, fxId, dest, 1024);
  }
  else
  {
    Core_strcpy(dest, 0x400ui64, "not successfully loaded");
  }
  v9 = j_va("%s (effect = %s)\n", errorString, dest);
  Scr_ParamError(uniqueErrorCode, scrContext, paramIndex, v9);
}

/*
==============
Scr_GetEntArrayInRadius_Internal
==============
*/
void Scr_GetEntArrayInRadius_Internal(scrContext_t *scrContext, int qbOnlyScriptables)
{
  float v4; 
  double Float; 
  scr_string_t ConstString; 
  const char *String; 
  int Offset; 
  const char *v9; 
  scrContext_t *v10; 
  ComErrorCode v11; 
  vec3_t vectorValue; 

  v4 = 0.0;
  if ( Scr_GetNumParam(scrContext) == 3 )
  {
    Scr_Error(COM_ERR_4674, scrContext, "Requires both an origin and a radius if one or the other is provided");
    Scr_MakeArray(scrContext);
    return;
  }
  if ( Scr_GetNumParam(scrContext) >= 4 )
  {
    Scr_GetVector(scrContext, 2u, &vectorValue);
    Float = Scr_GetFloat(scrContext, 3u);
    v4 = *(float *)&Float;
  }
  if ( !Scr_GetNumParam(scrContext) )
  {
LABEL_20:
    Scr_GetGenericEntArray(scrContext, qbOnlyScriptables);
    return;
  }
  if ( Scr_GetNumParam(scrContext) < 2 || Scr_GetType(scrContext, 0) == VAR_UNDEFINED || Scr_GetType(scrContext, 1u) == VAR_UNDEFINED )
  {
    if ( v4 > 0.0 )
    {
      Scr_GetGenericEntArray(scrContext, qbOnlyScriptables, &vectorValue, v4);
      return;
    }
    goto LABEL_20;
  }
  ConstString = Scr_GetConstString(scrContext, 0);
  String = Scr_GetString(scrContext, 1u);
  Offset = Scr_GetOffset(scrContext, ENTITY_CLASS_GENTITY, String);
  if ( Offset < 0 )
  {
    v9 = j_va("key '%s' does not internally belong to entities", String);
    v10 = scrContext;
    v11 = COM_ERR_4675;
LABEL_11:
    Scr_ParamError(v11, v10, 1u, v9);
    return;
  }
  if ( (Offset & 0xE000) != 0 )
  {
    v9 = j_va("key '%s' does not internally belong to generic entities", String);
    v10 = scrContext;
    v11 = COM_ERR_4676;
    goto LABEL_11;
  }
  if ( v4 <= 0.0 )
    Scr_GetGenericEntArray(scrContext, Offset, ConstString, qbOnlyScriptables);
  else
    Scr_GetGenericEntArray(scrContext, Offset, ConstString, qbOnlyScriptables, &vectorValue, v4);
}

/*
==============
Scr_GetExploderID
==============
*/
char Scr_GetExploderID(scrContext_t *scrContext, unsigned int *outExploderID)
{
  const char *String; 
  unsigned int v6; 
  const char *v7; 
  const dvar_t *v8; 
  __int64 v9; 
  unsigned int exploderNameTotal; 
  scr_string_t *exploderNames; 

  if ( Scr_GetType(scrContext, 0) == VAR_INTEGER )
  {
    *outExploderID = Scr_GetInt(scrContext, 0);
    return 1;
  }
  if ( Scr_GetType(scrContext, 0) != VAR_STRING && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 23518, ASSERT_TYPE_ASSERT, "(Scr_GetType( scrContext, 0 ) == VAR_STRING)", (const char *)&queryFormat, "Scr_GetType( scrContext, 0 ) == VAR_STRING") )
    __debugbreak();
  if ( !cm.mapEnts->createFxEffectTotal && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 23519, ASSERT_TYPE_ASSERT, "(cm.mapEnts->createFxEffectTotal > 0)", (const char *)&queryFormat, "cm.mapEnts->createFxEffectTotal > 0") )
    __debugbreak();
  String = Scr_GetString(scrContext, 0);
  v6 = SL_FindString(String);
  if ( !v6 )
  {
    v7 = j_va("Failed to find script string for exploder name '%s'", String);
    Scr_Error(COM_ERR_4656, scrContext, v7);
  }
  if ( CG_CreateFx_HasBeenEnabled() )
    goto LABEL_26;
  v8 = DCONST_DVARBOOL_developer_createfx;
  if ( !DCONST_DVARBOOL_developer_createfx && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "developer_createfx") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v8);
  if ( v8->current.enabled )
  {
LABEL_26:
    *outExploderID = v6;
  }
  else
  {
    v9 = 0i64;
    exploderNameTotal = cm.mapEnts->exploderNameTotal;
    if ( !exploderNameTotal )
      goto LABEL_20;
    exploderNames = cm.mapEnts->exploderNames;
    while ( *exploderNames != v6 )
    {
      v9 = (unsigned int)(v9 + 1);
      ++exploderNames;
      if ( (unsigned int)v9 >= exploderNameTotal )
        goto LABEL_20;
    }
    if ( (_DWORD)v9 == exploderNameTotal )
    {
LABEL_20:
      Com_PrintWarning(24, "Warning: exploder name '%s' not found in mapents exploder data\n", String);
      return 0;
    }
    if ( cm.mapEnts->exploderNames[v9] != v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 23550, ASSERT_TYPE_ASSERT, "(cm.mapEnts->exploderNames[foundIndex] == exploderScriptName)", (const char *)&queryFormat, "cm.mapEnts->exploderNames[foundIndex] == exploderScriptName") )
      __debugbreak();
    *outExploderID = v9;
  }
  return 1;
}

/*
==============
Scr_GetNoTarget
==============
*/
void Scr_GetNoTarget(scrContext_t *scrContext, gentity_s *ent, int offset)
{
  Scr_AddInt(scrContext, (ent->flags.m_flags[0] >> 2) & 1);
}

/*
==============
Scr_GetTeamFlag
==============
*/
bitarray<224> *Scr_GetTeamFlag(bitarray<224> *result, scrContext_t *scrContext, scr_string_t teamName)
{
  const bitarray<224> *AllTeamFlags; 
  unsigned int v7; 
  bitarray<224> *v8; 
  const bitarray<224> *BadGuyTeamFlags; 
  const char *v10; 
  const char *v11; 
  team_t outTeam[10]; 

  if ( teamName == scr_const.all )
  {
    if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_WEAPON_DROP|0x80) )
      AllTeamFlags = Com_TeamsSP_GetAllTeamFlags();
    else
      AllTeamFlags = Com_TeamsMP_GetAllTeamFlags();
    *(_OWORD *)result->array = *(_OWORD *)AllTeamFlags->array;
    *(double *)&result->array[4] = *(double *)&AllTeamFlags->array[4];
    v7 = AllTeamFlags->array[6];
    v8 = result;
    result->array[6] = v7;
  }
  else if ( teamName == scr_const.bad_guys )
  {
    if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_WEAPON_DROP|0x80) )
      BadGuyTeamFlags = Com_TeamsSP_GetBadGuyTeamFlags();
    else
      BadGuyTeamFlags = Com_TeamsMP_GetBadGuyTeamFlags();
    *(_OWORD *)result->array = *(_OWORD *)BadGuyTeamFlags->array;
    *(double *)&result->array[4] = *(double *)&BadGuyTeamFlags->array[4];
    result->array[6] = BadGuyTeamFlags->array[6];
    return result;
  }
  else
  {
    if ( Com_Teams_TeamFromString(teamName, outTeam) )
    {
      Com_Teams_GetTeamFlag(result, outTeam[0]);
    }
    else
    {
      v10 = SL_ConvertToString(teamName);
      v11 = j_va("unknown team '%s'", v10);
      Scr_Error(COM_ERR_3945, scrContext, v11);
      result->array[0] = 0x80000000;
      *(_QWORD *)&result->array[1] = 0i64;
      *(_QWORD *)&result->array[3] = 0i64;
      *(_QWORD *)&result->array[5] = 0i64;
    }
    return result;
  }
  return v8;
}

/*
==============
Scr_GetTeamFlags
==============
*/
bitarray<224> *Scr_GetTeamFlags(bitarray<224> *result, scrContext_t *scrContext, unsigned int i)
{
  unsigned int v4; 
  scr_string_t ConstString; 
  scr_string_t v7; 
  const bitarray<224> *BadGuyTeamFlags; 
  const char *v9; 
  const char *v10; 
  int v11; 
  int v12; 
  int v13; 
  int v14; 
  int v15; 
  int v16; 
  unsigned int v17; 
  unsigned __int64 v18; 
  const bitarray<224> *AllTeamFlags; 
  __int64 v21; 
  __int64 v22; 
  team_t outTeam; 
  __int64 v24; 
  __int64 v25; 
  __int64 v26; 
  int v27; 

  *(_QWORD *)result->array = 0i64;
  v4 = i;
  *(_QWORD *)&result->array[2] = 0i64;
  *(_QWORD *)&result->array[4] = 0i64;
  result->array[6] = 0;
  if ( i < Scr_GetNumParam(scrContext) )
  {
    while ( 1 )
    {
      ConstString = Scr_GetConstString(scrContext, v4);
      v7 = ConstString;
      if ( ConstString == scr_const.all )
        break;
      if ( ConstString == scr_const.bad_guys )
      {
        if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_WEAPON_DROP|0x80) )
          BadGuyTeamFlags = Com_TeamsSP_GetBadGuyTeamFlags();
        else
          BadGuyTeamFlags = Com_TeamsMP_GetBadGuyTeamFlags();
        result->array[0] |= BadGuyTeamFlags->array[0];
        result->array[1] |= BadGuyTeamFlags->array[1];
        result->array[2] |= BadGuyTeamFlags->array[2];
        result->array[3] |= BadGuyTeamFlags->array[3];
        result->array[4] |= BadGuyTeamFlags->array[4];
        result->array[5] |= BadGuyTeamFlags->array[5];
        result->array[6] |= BadGuyTeamFlags->array[6];
      }
      else
      {
        if ( Com_Teams_TeamFromString(ConstString, &outTeam) )
        {
          v18 = (unsigned int)outTeam;
          v24 = 0i64;
          v25 = 0i64;
          v26 = 0i64;
          v27 = 0;
          if ( (unsigned int)outTeam >= (TEAM_HUNDRED_NINETY_TWO|TEAM_THIRTY_TWO) )
          {
            LODWORD(v22) = 224;
            LODWORD(v21) = outTeam;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 263, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v21, v22) )
              __debugbreak();
          }
          *((_DWORD *)&v24 + (v18 >> 5)) |= 0x80000000 >> (v18 & 0x1F);
          v16 = v27;
          v15 = HIDWORD(v26);
          v14 = v26;
          v13 = HIDWORD(v25);
          v12 = v25;
          v11 = HIDWORD(v24);
          v17 = v24;
        }
        else
        {
          v9 = SL_ConvertToString(v7);
          v10 = j_va("unknown team '%s'", v9);
          Scr_Error(COM_ERR_3945, scrContext, v10);
          v11 = 0;
          v12 = 0;
          v13 = 0;
          v14 = 0;
          v15 = 0;
          v16 = 0;
          v17 = 0x80000000;
        }
        result->array[0] |= v17;
        result->array[1] |= v11;
        result->array[2] |= v12;
        result->array[3] |= v13;
        result->array[4] |= v14;
        result->array[5] |= v15;
        result->array[6] |= v16;
      }
      if ( ++v4 >= Scr_GetNumParam(scrContext) )
        return result;
    }
    if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_WEAPON_DROP|0x80) )
      AllTeamFlags = Com_TeamsSP_GetAllTeamFlags();
    else
      AllTeamFlags = Com_TeamsMP_GetAllTeamFlags();
    result->array[0] |= AllTeamFlags->array[0];
    result->array[1] |= AllTeamFlags->array[1];
    result->array[2] |= AllTeamFlags->array[2];
    result->array[3] |= AllTeamFlags->array[3];
    result->array[4] |= AllTeamFlags->array[4];
    result->array[5] |= AllTeamFlags->array[5];
    result->array[6] |= AllTeamFlags->array[6];
  }
  return result;
}

/*
==============
Scr_IsTouchingInternal
==============
*/
int Scr_IsTouchingInternal(scrContext_t *scrContext, const gentity_s *ent1, const gentity_s *ent2)
{
  __int128 v3; 
  const gentity_s *v5; 
  bool v7; 
  const gentity_s *v8; 
  const char *v9; 
  const char *v10; 
  const char *v11; 
  float v12; 
  float v13; 
  float v14; 
  float v15; 
  float v16; 
  unsigned int Instance; 
  __int64 v22; 
  bool result; 
  Bounds bounds; 
  __int128 v25; 

  v5 = ent1;
  if ( G_Vehicle_IsTouching(scrContext, ent1, ent2, &result) )
    return result;
  v7 = v5->r.modelType == 0;
  v25 = v3;
  if ( v7 || v5->vehicle )
  {
    v8 = v5;
    v5 = ent2;
  }
  else
  {
    v8 = ent2;
  }
  if ( !v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 3449, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( v8->r.box.halfSize.v[0] < 0.0 )
  {
    v9 = SL_ConvertToString(v8->classname);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 3450, ASSERT_TYPE_ASSERT, "(ent->r.box.halfSize[0] >= 0.0f)", "%s\n\tentnum: %d, origin: %g %g %g, classname: %s", "ent->r.box.halfSize[0] >= 0.0f", v8->s.number, v8->r.currentOrigin.v[0], v8->r.currentOrigin.v[1], v8->r.currentOrigin.v[2], v9) )
      __debugbreak();
  }
  if ( v8->r.box.halfSize.v[1] < 0.0 )
  {
    v10 = SL_ConvertToString(v8->classname);
    LODWORD(v22) = v8->s.number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 3451, ASSERT_TYPE_ASSERT, "(ent->r.box.halfSize[1] >= 0.0f)", "%s\n\tentnum: %d, origin: %g %g %g, classname: %s", "ent->r.box.halfSize[1] >= 0.0f", v22, v8->r.currentOrigin.v[0], v8->r.currentOrigin.v[1], v8->r.currentOrigin.v[2], v10) )
      __debugbreak();
  }
  if ( v8->r.box.halfSize.v[2] < 0.0 )
  {
    v11 = SL_ConvertToString(v8->classname);
    LODWORD(v22) = v8->s.number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 3452, ASSERT_TYPE_ASSERT, "(ent->r.box.halfSize[2] >= 0.0f)", "%s\n\tentnum: %d, origin: %g %g %g, classname: %s", "ent->r.box.halfSize[2] >= 0.0f", v22, v8->r.currentOrigin.v[0], v8->r.currentOrigin.v[1], v8->r.currentOrigin.v[2], v11) )
      __debugbreak();
  }
  v12 = v8->r.box.midPoint.v[1] + v8->r.currentOrigin.v[1];
  v13 = v8->r.box.halfSize.v[0];
  bounds.midPoint.v[0] = v8->r.box.midPoint.v[0] + v8->r.currentOrigin.v[0];
  v14 = v8->r.box.midPoint.v[2] + v8->r.currentOrigin.v[2];
  v15 = v8->r.box.halfSize.v[2];
  bounds.midPoint.v[1] = v12;
  v16 = v8->r.box.halfSize.v[1];
  bounds.halfSize.v[2] = v15;
  bounds.midPoint.v[2] = v14;
  bounds.halfSize.v[0] = v13;
  bounds.halfSize.v[1] = v16;
  if ( v13 < 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\bounds_inline.h", 824, ASSERT_TYPE_ASSERT, "(bounds->halfSize[0] >= 0.0f)", (const char *)&queryFormat, "bounds->halfSize[0] >= 0.0f") )
    __debugbreak();
  if ( bounds.halfSize.v[1] < 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\bounds_inline.h", 825, ASSERT_TYPE_ASSERT, "(bounds->halfSize[1] >= 0.0f)", (const char *)&queryFormat, "bounds->halfSize[1] >= 0.0f") )
    __debugbreak();
  if ( bounds.halfSize.v[2] < 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\bounds_inline.h", 826, ASSERT_TYPE_ASSERT, "(bounds->halfSize[2] >= 0.0f)", (const char *)&queryFormat, "bounds->halfSize[2] >= 0.0f") )
    __debugbreak();
  _XMM0 = LODWORD(bounds.halfSize.v[1]);
  __asm { vmaxss  xmm1, xmm0, dword ptr [rsp+0B8h+bounds.halfSize] }
  _XMM0 = LODWORD(bounds.halfSize.v[2]);
  bounds.halfSize.v[0] = *(float *)&_XMM1;
  bounds.halfSize.v[1] = *(float *)&_XMM1;
  __asm { vmaxss  xmm1, xmm0, xmm1 }
  bounds.halfSize.v[2] = *(float *)&_XMM1;
  Instance = G_PhysicsObject_GetInstance(PHYSICS_WORLD_ID_FIRST, v5);
  return PhysicsQuery_LegacyEntityContactCapsule(PHYSICS_WORLD_ID_FIRST, &bounds, Instance, v5);
}

/*
==============
Scr_LocalizationError
==============
*/
void Scr_LocalizationError(scrContext_t *scrContext, int iParm, const char *pszErrorMessage)
{
  Scr_ParamError(COM_ERR_3953, scrContext, iParm, pszErrorMessage);
}

/*
==============
Scr_PlayFXInternal
==============
*/
gentity_s *Scr_PlayFXInternal(scrContext_t *scrContext, int fxId, const vec3_t *pos, vec3_t *forward, vec3_t *up)
{
  const char *v9; 
  gentity_s *v10; 
  float v11; 
  float v12; 
  __int128 v13; 
  __int128 v17; 
  __int128 v18; 
  float v19; 
  tmat33_t<vec3_t> vec; 

  if ( !FX_IsValidFxId(fxId) )
  {
    v9 = j_va("Scr_PlayFX: invalid effect id %d", (unsigned int)fxId);
    Scr_Error(COM_ERR_4330, scrContext, v9);
  }
  G_Debug_LogFxInfo(pos, fxId, (const scr_string_t)0);
  v10 = G_Utils_SpawnEventEntity(pos, 122);
  if ( v10->s.lerp.apos.trType && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 15002, ASSERT_TYPE_SANITY, "( ent->s.lerp.apos.trType == TR_STATIONARY )", (const char *)&queryFormat, "ent->s.lerp.apos.trType == TR_STATIONARY") )
    __debugbreak();
  v10->s.eventParm2 = 0;
  v10->s.eventParm = fxId;
  if ( forward )
  {
    v11 = forward->v[0];
    v12 = forward->v[2];
    vec.m[0].v[1] = forward->v[1];
    v13 = LODWORD(vec.m[0].v[1]);
    *(float *)&v13 = fsqrt((float)(vec.m[0].v[1] + (float)(v11 * v11)) + (float)(v12 * v12));
    _XMM4 = v13;
    __asm
    {
      vcmpless xmm0, xmm4, cs:__real@80000000
      vblendvps xmm0, xmm4, xmm7, xmm0
    }
    forward->v[0] = v11 * (float)(1.0 / *(float *)&_XMM0);
    forward->v[1] = (float)(1.0 / *(float *)&_XMM0) * forward->v[1];
    forward->v[2] = (float)(1.0 / *(float *)&_XMM0) * forward->v[2];
    vec.m[0].v[0] = v11;
    vec.m[0].v[2] = v12;
    if ( *(float *)&v13 == 0.0 )
      Scr_FxParamError(COM_ERR_5348, scrContext, 2, "playFx called with (0 0 0) forward direction", fxId);
    if ( up )
    {
      v17 = LODWORD(up->v[1]);
      v18 = v17;
      v19 = up->v[2];
      *(float *)&v18 = fsqrt((float)((float)(*(float *)&v17 * *(float *)&v17) + (float)(up->v[0] * up->v[0])) + (float)(v19 * v19));
      _XMM3 = v18;
      __asm
      {
        vcmpless xmm0, xmm3, cs:__real@80000000
        vblendvps xmm0, xmm3, xmm7, xmm0
      }
      vec.m[2].v[0] = (float)(1.0 / *(float *)&_XMM0) * up->v[0];
      vec.m[2].v[2] = (float)(1.0 / *(float *)&_XMM0) * v19;
      vec.m[2].v[1] = (float)(1.0 / *(float *)&_XMM0) * *(float *)&v17;
      if ( *(float *)&v18 == 0.0 )
        Scr_FxParamError(COM_ERR_5349, scrContext, 3, "playFx called with (0 0 0) up direction", fxId);
      Scr_SetFxAngles(scrContext, 2, &vec, &v10->s.lerp.apos.trBase, fxId);
    }
    else
    {
      vectoangles(vec.m, &v10->s.lerp.apos.trBase);
    }
  }
  return v10;
}

/*
==============
Scr_PlayFxOnTagInternal
==============
*/
void Scr_PlayFxOnTagInternal(scrContext_t *scrContext, gentity_s *ent, const unsigned int fxId, scr_string_t tag, int onlyClientIndex)
{
  const char *v9; 
  const char *v10; 
  int BoneIndex; 
  const char *ModelName; 
  const char *v13; 
  const char *v14; 
  unsigned int FxEventParam; 
  unsigned int v16; 
  vec3_t trBase; 

  if ( !FX_IsValidFxId(fxId) )
  {
    v9 = j_va("effect id %i is invalid\n", fxId);
    Scr_ParamError(COM_ERR_4333, scrContext, 0, v9);
  }
  v10 = SL_ConvertToString(tag);
  if ( strchr_0(v10, 34) )
    Scr_ParamError(COM_ERR_4334, scrContext, 2u, "cannot use \" characters in tag names\n");
  BoneIndex = SV_Game_DObjGetBoneIndex(ent, tag);
  if ( BoneIndex < 0 )
  {
    SV_Game_DObjDumpInfo(ent);
    ModelName = G_CString_GetModelName(ent->model);
    v13 = SL_ConvertToString(tag);
    v14 = j_va("tag '%s' does not exist on entity with model '%s'", v13, ModelName);
    Scr_ParamError(COM_ERR_4335, scrContext, 2u, v14);
  }
  FxEventParam = Scr_GetFxEventParam(fxId, BoneIndex, onlyClientIndex);
  v16 = 127;
  if ( onlyClientIndex == -1 )
    v16 = 124;
  G_Utils_AddEvent(ent, v16, FxEventParam);
  Trajectory_GetTrBase(&ent->s.lerp.pos, &trBase);
  G_Debug_LogFxInfo(&trBase, fxId, tag);
  memset(&trBase, 0, sizeof(trBase));
}

/*
==============
Scr_PlayRumbleOnPosition_Internal
==============
*/
gentity_s *Scr_PlayRumbleOnPosition_Internal(scrContext_t *scrContext, int event)
{
  const char *String; 
  const char *v5; 
  gentity_s *result; 
  unsigned int outIndex; 
  vec3_t vectorValue; 

  String = Scr_GetString(scrContext, 0);
  if ( !NetConstStrings_GetIndexFromName(NETCONSTSTRINGTYPE_RUMBLE, String, &outIndex) )
  {
    v5 = j_va("unknown rumble name '%s'", String);
    Scr_ParamError(COM_ERR_4286, scrContext, 0, v5);
  }
  Scr_GetVector(scrContext, 1u, &vectorValue);
  result = G_Utils_SpawnEventEntity(&vectorValue, event);
  result->s.eventParm2 = 0;
  result->s.eventParm = outIndex;
  return result;
}

/*
==============
Scr_SBPreScanArray
==============
*/
int *Scr_SBPreScanArray(GScr_ScriptBundleContext *ctxt, ScriptBundleValue *arr)
{
  int *v2; 
  int i; 
  ScriptBundleValue *v6; 
  bool v7; 

  v2 = (int *)&arr[1];
  if ( arr->type != SCR_SB_ARRAY && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 26142, ASSERT_TYPE_ASSERT, "(arr->type == ScriptBundleValue::ValueType::SCR_SB_ARRAY)", (const char *)&queryFormat, "arr->type == ScriptBundleValue::ValueType::SCR_SB_ARRAY") )
    __debugbreak();
  for ( i = 0; i < arr->string; ++i )
  {
    v6 = (ScriptBundleValue *)v2;
    v2 += 2;
    switch ( v6->type )
    {
      case SCR_B_NONE:
      case SCR_SB_BOOL:
      case SCR_SB_INT:
      case SCR_SB_FLOAT:
      case SCR_SB_STRING:
      case SCR_SB_ANIMTREE:
        continue;
      case SCR_SB_OBJECT:
        v2 = Scr_SBPreScanObject(ctxt, v6);
        break;
      case SCR_SB_ARRAY:
        v2 = Scr_SBPreScanArray(ctxt, v6);
        break;
      case SCR_SB_ANIMATION:
        v7 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 26177, ASSERT_TYPE_ASSERT, "(!\"Script Bundle schema error - SCR_SB_ANIMATION in array???\")", (const char *)&queryFormat, "!\"Script Bundle schema error - SCR_SB_ANIMATION in array???\"");
        goto LABEL_11;
      case SCR_SB_ANIMTREEID:
        v6->string = Scr_FindAnimTreeID(&ctxt->strPool[v6->string], ctxt->anim_user);
        v6->type = SCR_SB_INT;
        break;
      default:
        v7 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 26180, ASSERT_TYPE_ASSERT, "(!\"Script Bundle parse error\")", (const char *)&queryFormat, "!\"Script Bundle parse error\"");
LABEL_11:
        if ( v7 )
          __debugbreak();
        break;
    }
  }
  return v2;
}

/*
==============
Scr_SBPreScanObject
==============
*/
int *Scr_SBPreScanObject(GScr_ScriptBundleContext *ctxt, ScriptBundleValue *obj)
{
  int *v4; 
  __m256i v5; 
  int v6; 
  int *v7; 
  scr_anim_t *v8; 
  __m256i v10; 

  v4 = (int *)&obj[1];
  if ( obj->type != SCR_SB_OBJECT && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 26085, ASSERT_TYPE_ASSERT, "(obj->type == ScriptBundleValue::ValueType::SCR_SB_OBJECT)", (const char *)&queryFormat, "obj->type == ScriptBundleValue::ValueType::SCR_SB_OBJECT", -2i64) )
    __debugbreak();
  v5 = *(__m256i *)ctxt;
  v10 = *(__m256i *)ctxt;
  v6 = 0;
  if ( obj->string > 0 )
  {
    do
    {
      v7 = v4;
      v4 += 3;
      switch ( *((_BYTE *)v7 + 4) )
      {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
          break;
        case 5:
          v4 = Scr_SBPreScanObject(ctxt, (ScriptBundleValue *)(v7 + 1));
          break;
        case 6:
          v4 = Scr_SBPreScanArray(ctxt, (ScriptBundleValue *)(v7 + 1));
          break;
        case 7:
          v8 = (scr_anim_t *)(v4 + 1);
          if ( ((unsigned __int8)v4 & 4) == 0 )
            v8 = (scr_anim_t *)v4;
          Scr_FindAnim(ctxt->currentAnimTree, &ctxt->strPool[v7[2]], v8, ctxt->anim_user);
          v4 += 3;
          break;
        case 8:
          ctxt->currentAnimTree = &ctxt->strPool[v7[2]];
          break;
        case 9:
          v7[2] = Scr_FindAnimTreeID(&ctxt->strPool[v7[2]], ctxt->anim_user);
          *((_BYTE *)v7 + 4) = 2;
          break;
        default:
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 26129, ASSERT_TYPE_ASSERT, "(!\"Script Bundle prescan error\")", (const char *)&queryFormat, "!\"Script Bundle prescan error\"") )
            __debugbreak();
          break;
      }
      ++v6;
    }
    while ( v6 < obj->string );
    v5 = v10;
  }
  *(__m256i *)ctxt = v5;
  return v4;
}

/*
==============
Scr_SetAngles
==============
*/
void Scr_SetAngles(scrContext_t *scrContext, gentity_s *ent, int offset)
{
  vec3_t vectorValue; 

  if ( ent->actor )
    Scr_Error(COM_ERR_4529, scrContext, "cannot directly set the angles on AI.  Use the teleport command instead.\n");
  if ( ent->s.lerp.apos.trType == TR_ANIMATED_MOVER )
  {
    if ( !Com_GameMode_SupportsFeature(WEAPON_DROPPING_ALT) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_trajectory.h", 90, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::ANIMATED_TRAJECTORIES ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::ANIMATED_TRAJECTORIES )") )
      __debugbreak();
    Scr_Error(COM_ERR_4530, scrContext, "Cannot set an entity's angles while it is playing a delta animation. Call scriptmodelclearanim first.\n");
    Sys_ProfEndNamedEvent();
  }
  else
  {
    Scr_GetVector(scrContext, 0, &vectorValue);
    if ( G_SetAngle(ent, &vectorValue, 1, 0) )
    {
      Physics_SetBroadphaseNeedsRefresh(PHYSICS_WORLD_ID_FIRST, 1);
      Physics_SetBroadphaseNeedsRefresh(PHYSICS_WORLD_ID_SERVER_DETAIL, 1);
    }
    if ( ent->r.isLinked )
      SV_LinkEntity(ent);
  }
}

/*
==============
Scr_SetFxAngles
==============
*/
void Scr_SetFxAngles(scrContext_t *scrContext, int givenAxisCount, tmat33_t<vec3_t> *inOutAxis, vec3_t *outAngles)
{
  int v8; 
  __int128 v9; 
  __int128 v10; 
  __int128 v11; 
  __int128 v12; 
  float v13; 
  float v14; 
  const char *v18; 

  if ( (unsigned int)givenAxisCount > 2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 14895, ASSERT_TYPE_ASSERT, "( 0 ) <= ( givenAxisCount ) && ( givenAxisCount ) <= ( 2 )", "givenAxisCount not in [0, 2]\n\t%i not in [%i, %i]", givenAxisCount, 0i64, 2) )
    __debugbreak();
  v8 = givenAxisCount - 1;
  if ( v8 )
  {
    if ( v8 == 1 )
    {
      v9 = LODWORD(inOutAxis->m[2].v[0]);
      v10 = v9;
      *(float *)&v10 = (float)((float)(*(float *)&v9 * inOutAxis->m[0].v[0]) + (float)(inOutAxis->m[0].v[1] * inOutAxis->m[2].v[1])) + (float)(inOutAxis->m[2].v[2] * inOutAxis->m[0].v[2]);
      v11 = v10 ^ _xmm;
      v12 = v11;
      *(float *)&v12 = (float)(*(float *)&v11 * inOutAxis->m[0].v[0]) + *(float *)&v9;
      inOutAxis->m[2].v[0] = *(float *)&v12;
      v13 = (float)(*(float *)&v11 * inOutAxis->m[0].v[1]) + inOutAxis->m[2].v[1];
      inOutAxis->m[2].v[1] = v13;
      v14 = (float)(*(float *)&v11 * inOutAxis->m[0].v[2]) + inOutAxis->m[2].v[2];
      inOutAxis->m[2].v[2] = v14;
      *(float *)&v12 = fsqrt((float)((float)(*(float *)&v12 * inOutAxis->m[2].v[0]) + (float)(v13 * v13)) + (float)(v14 * v14));
      _XMM5 = v12;
      __asm
      {
        vcmpless xmm0, xmm5, cs:__real@80000000
        vblendvps xmm0, xmm5, xmm1, xmm0
      }
      inOutAxis->m[2].v[0] = (float)(1.0 / *(float *)&_XMM0) * inOutAxis->m[2].v[0];
      inOutAxis->m[2].v[1] = (float)(1.0 / *(float *)&_XMM0) * inOutAxis->m[2].v[1];
      inOutAxis->m[2].v[2] = (float)(1.0 / *(float *)&_XMM0) * inOutAxis->m[2].v[2];
      if ( *(float *)&v12 == 0.0 )
      {
        v18 = j_va("forward and up vectors are the same direction or exact opposite directions");
        Scr_Error(COM_ERR_4326, scrContext, v18);
      }
      Vec3Cross(&inOutAxis->m[2], inOutAxis->m, &inOutAxis->m[1]);
      AxisToAngles(inOutAxis, outAngles);
    }
  }
  else
  {
    vectoangles(inOutAxis->m, outAngles);
  }
}

/*
==============
Scr_SetOrigin
==============
*/
void Scr_SetOrigin(scrContext_t *scrContext, gentity_s *ent, int offset)
{
  sentient_s *sentient; 
  float v6; 
  vec3_t vectorValue; 

  if ( ent->actor )
    Scr_Error(COM_ERR_4526, scrContext, "cannot directly set the origin on AI.  Use the teleport command instead.\n");
  Scr_GetVector(scrContext, 0, &vectorValue);
  v6 = vectorValue.v[0];
  if ( (LODWORD(vectorValue.v[0]) & 0x7F800000) == 2139095040 || (v6 = vectorValue.v[1], (LODWORD(vectorValue.v[1]) & 0x7F800000) == 2139095040) || (v6 = vectorValue.v[2], (LODWORD(vectorValue.v[2]) & 0x7F800000) == 2139095040) )
    Scr_Error(COM_ERR_4527, scrContext, "origin being set to NAN.");
  if ( ent->s.lerp.pos.trType == TR_ANIMATED_MOVER )
  {
    if ( !Com_GameMode_SupportsFeature(WEAPON_DROPPING_ALT) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_trajectory.h", 90, ASSERT_TYPE_ASSERT, "(Com_GameMode_SupportsFeature( Com_GameMode_Feature::ANIMATED_TRAJECTORIES ))", (const char *)&queryFormat, "Com_GameMode_SupportsFeature( Com_GameMode_Feature::ANIMATED_TRAJECTORIES )", v6) )
      __debugbreak();
    Scr_Error(COM_ERR_4528, scrContext, "Cannot set an entity's origin while it is playing a delta animation. Call scriptmodelclearanim first.\n");
    Sys_ProfEndNamedEvent();
  }
  else
  {
    if ( G_SetOrigin(ent, &vectorValue, 1, 0) )
    {
      Physics_SetBroadphaseNeedsRefresh(PHYSICS_WORLD_ID_FIRST, 1);
      Physics_SetBroadphaseNeedsRefresh(PHYSICS_WORLD_ID_SERVER_DETAIL, 1);
    }
    sentient = ent->sentient;
    if ( sentient )
    {
      Sentient_InvalidateNearestNode(sentient);
      Sentient_InvalidateNearestTacPoint(ent->sentient);
    }
    if ( ent->r.isLinked )
      SV_LinkEntity(ent);
  }
}

/*
==============
Scr_StopFxOnTagInternal
==============
*/
void Scr_StopFxOnTagInternal(scrContext_t *scrContext, gentity_s *ent, const unsigned int fxId, scr_string_t tag, int onlyClientIndex)
{
  const char *v9; 
  const char *v10; 
  int BoneIndex; 
  const char *ModelName; 
  const char *v13; 
  const char *v14; 
  unsigned int FxEventParam; 
  unsigned int v16; 
  vec3_t trBase; 

  if ( !FX_IsValidFxId(fxId) )
  {
    v9 = j_va("effect id %i is invalid\n", fxId);
    Scr_ParamError(COM_ERR_4340, scrContext, 0, v9);
  }
  v10 = SL_ConvertToString(tag);
  if ( strchr_0(v10, 34) )
    Scr_ParamError(COM_ERR_4341, scrContext, 2u, "cannot use \" characters in tag names\n");
  BoneIndex = SV_Game_DObjGetBoneIndex(ent, tag);
  if ( BoneIndex < 0 )
  {
    SV_Game_DObjDumpInfo(ent);
    ModelName = G_CString_GetModelName(ent->model);
    v13 = SL_ConvertToString(tag);
    v14 = j_va("tag '%s' does not exist on entity with model '%s'", v13, ModelName);
    Scr_ParamError(COM_ERR_4342, scrContext, 2u, v14);
  }
  FxEventParam = Scr_GetFxEventParam(fxId, BoneIndex, onlyClientIndex);
  v16 = 128;
  if ( onlyClientIndex == -1 )
    v16 = 125;
  G_Utils_AddEvent(ent, v16, FxEventParam);
  Trajectory_GetTrBase(&ent->s.lerp.pos, &trBase);
  G_Debug_LogFxInfo(&trBase, fxId, tag);
  memset(&trBase, 0, sizeof(trBase));
}

/*
==============
Scr_ValidateLocalizedStringRef
==============
*/
void Scr_ValidateLocalizedStringRef(scrContext_t *scrContext, int parmIndex, const char *token, int tokenLen)
{
  __int64 v4; 
  __int64 v8; 
  const char *v9; 
  const char *v10; 

  v4 = tokenLen;
  if ( !token && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 1273, ASSERT_TYPE_ASSERT, "(token)", (const char *)&queryFormat, "token") )
    __debugbreak();
  if ( (int)v4 < 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 1274, ASSERT_TYPE_ASSERT, "(tokenLen >= 0)", (const char *)&queryFormat, "tokenLen >= 0") )
    __debugbreak();
  v8 = v4;
  if ( v4 >= 2 )
  {
    v9 = token;
    do
    {
      if ( !isalnum(*v9) && *v9 != 95 && *v9 != 47 )
      {
        v10 = j_va("Illegal localized string reference: %s must contain only alpha-numeric characters and underscore or '/'", token);
        Scr_ParamError(COM_ERR_3954, scrContext, parmIndex, v10);
      }
      ++v9;
      --v8;
    }
    while ( v8 );
  }
}

/*
==============
Scr_VerifyWeapon
==============
*/
void Scr_VerifyWeapon(scrContext_t *scrContext, const Weapon *r_weapon, bool isAlternate, const char *weaponName)
{
  const char *v8; 
  ComErrorCode v9; 
  const char *v10; 
  char output[1024]; 

  if ( !weaponName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 1294, ASSERT_TYPE_ASSERT, "(weaponName)", (const char *)&queryFormat, "weaponName") )
    __debugbreak();
  if ( r_weapon->weaponIdx )
  {
    if ( !BG_IsValidWeapon(r_weapon, isAlternate) )
    {
      v10 = j_va("Weapon '%s' is does not define a valid weapon\n", weaponName);
      Scr_Error(COM_ERR_3957, scrContext, v10);
    }
    BG_GetWeaponNameComplete(r_weapon, isAlternate, output, 0x400u);
    if ( !BG_AreWeaponNamesEquivalent(output, weaponName) )
    {
      v8 = j_va("Asked for weapon \"%s\", but got weapon \"%s\" - check for missing or misspelled attachments, and make sure they are sorted alphabetically ", weaponName, output);
      v9 = COM_ERR_3958;
      goto LABEL_13;
    }
  }
  else if ( *weaponName && I_stricmp("none", weaponName) && I_stricmp("alt_none", weaponName) )
  {
    v8 = j_va("Unknown weapon name \"%s\": weapon may need to be added to the fast file. Or add attachments to the base weapon description.\n", weaponName);
    v9 = COM_ERR_3956;
LABEL_13:
    Scr_Error(v9, scrContext, v8);
  }
}

/*
==============
SetClientTriggerAudioZonePartial
==============
*/
void SetClientTriggerAudioZonePartial(scrContext_t *scrContext, scr_entref_t entref, const char *zoneName, int priorityIndex, const float fadetime, const int startParamIndex)
{
  int v6; 
  const char *v7; 
  unsigned int v8; 
  signed int v10; 
  int v11; 
  int NumParam; 
  const char *v13; 
  const char *String; 
  __int64 v15; 
  int v16; 
  __int64 v17; 
  int v18; 
  int v19; 
  int v20; 
  const char *v21; 
  const char *v22; 
  __int64 v23; 
  int v24; 
  __int64 v25; 
  int v26; 
  int v27; 
  int v28; 
  const char *v29; 
  __int64 v30; 
  int v31; 
  __int64 v32; 
  int v33; 
  int v34; 
  int v35; 
  const char *v36; 
  const char *v37; 
  const char *v38; 
  const char *v39; 
  SvClient *CommonClient; 
  char *fmt; 
  __int64 v42; 
  int outControllingClientNum[4]; 
  unsigned int entnum; 

  entnum = entref.entnum;
  v6 = priorityIndex;
  v7 = zoneName;
  v8 = entref.entnum;
  v10 = startParamIndex;
  v11 = 0;
  NumParam = Scr_GetNumParam(scrContext);
  if ( startParamIndex < NumParam )
  {
    v13 = "reverb";
    do
    {
      String = Scr_GetString(scrContext, v10);
      v15 = 0x7FFFFFFFi64;
      if ( !String && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
        __debugbreak();
      while ( 1 )
      {
        v16 = (unsigned __int8)v13[String - "reverb"];
        v17 = v15;
        v18 = *(unsigned __int8 *)v13++;
        --v15;
        if ( !v17 )
        {
LABEL_14:
          v11 |= 1u;
          goto LABEL_15;
        }
        if ( v16 != v18 )
        {
          v19 = v16 + 32;
          if ( (unsigned int)(v16 - 65) > 0x19 )
            v19 = v16;
          v16 = v19;
          v20 = v18 + 32;
          if ( (unsigned int)(v18 - 65) > 0x19 )
            v20 = v18;
          if ( v16 != v20 )
            break;
        }
        if ( !v16 )
          goto LABEL_14;
      }
      v22 = "mix";
      v23 = 0x7FFFFFFFi64;
      if ( !String && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
        __debugbreak();
      while ( 1 )
      {
        v24 = (unsigned __int8)v22[String - "mix"];
        v25 = v23;
        v26 = *(unsigned __int8 *)v22++;
        --v23;
        if ( !v25 )
        {
LABEL_31:
          v11 |= 2u;
          goto LABEL_15;
        }
        if ( v24 != v26 )
        {
          v27 = v24 + 32;
          if ( (unsigned int)(v24 - 65) > 0x19 )
            v27 = v24;
          v24 = v27;
          v28 = v26 + 32;
          if ( (unsigned int)(v26 - 65) > 0x19 )
            v28 = v26;
          if ( v24 != v28 )
            break;
        }
        if ( !v24 )
          goto LABEL_31;
      }
      v29 = "filter";
      v30 = 0x7FFFFFFFi64;
      if ( !String && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
        __debugbreak();
      while ( 1 )
      {
        v31 = (unsigned __int8)v29[String - "filter"];
        v32 = v30;
        v33 = *(unsigned __int8 *)v29++;
        --v30;
        if ( !v32 )
        {
LABEL_43:
          v11 |= 4u;
          goto LABEL_15;
        }
        if ( v31 != v33 )
        {
          v34 = v31 + 32;
          if ( (unsigned int)(v31 - 65) > 0x19 )
            v34 = v31;
          v31 = v34;
          v35 = v33 + 32;
          if ( (unsigned int)(v33 - 65) > 0x19 )
            v35 = v33;
          if ( v31 != v35 )
            break;
        }
        if ( !v31 )
          goto LABEL_43;
      }
      if ( I_stricmp(String, "occlusion") )
      {
        if ( I_stricmp(String, "ambient") )
        {
          if ( I_stricmp(String, "ambient_events") )
          {
            if ( I_stricmp(String, "player_adsr") )
            {
              if ( I_stricmp(String, "weapon_reflection") )
              {
                if ( I_stricmp(String, "contexts") )
                {
                  if ( I_stricmp(String, "full_occlusion") )
                  {
                    v36 = j_va("SetClientTriggerAudioZonePartial: bad parameter: '%s'", String);
                    Scr_ParamError(COM_ERR_4807, scrContext, v10, v36);
                  }
                  else
                  {
                    v11 |= 0x200u;
                  }
                }
                else
                {
                  v11 |= 0x100u;
                }
              }
              else
              {
                v11 |= 0x80u;
              }
            }
            else
            {
              v11 |= 0x40u;
            }
          }
          else
          {
            v11 |= 0x20u;
          }
        }
        else
        {
          v11 |= 0x10u;
        }
      }
      else
      {
        v11 |= 8u;
      }
LABEL_15:
      ++v10;
      v13 = "reverb";
    }
    while ( v10 < NumParam );
    v8 = entnum;
    v6 = priorityIndex;
    v7 = zoneName;
  }
  outControllingClientNum[0] = v8;
  if ( !SV_IsAgent(v8) || SV_GetAgentControlledByPlayerNum(outControllingClientNum[0], outControllingClientNum) )
  {
    if ( outControllingClientNum[0] < level.maxclients )
    {
      LODWORD(v42) = v11;
      LODWORD(fmt) = v6;
      v38 = j_va("%c %c %s %d %d %f", 109i64, 100i64, v7, fmt, v42, fadetime);
      v39 = v38;
      if ( outControllingClientNum[0] == -1 )
      {
        SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v38);
      }
      else
      {
        CommonClient = SvClient::GetCommonClient(outControllingClientNum[0]);
        CommonClient->SendServerCommand(CommonClient, SV_CMD_RELIABLE, v39);
      }
    }
    else
    {
      v37 = j_va("Invalid entity index %d before SV_Game_SendServerCommand\n", (unsigned int)outControllingClientNum[0]);
      Scr_Error(COM_ERR_6414, scrContext, v37);
    }
  }
  else
  {
    v21 = j_va("entity %i is not a player or player-controlled agent", v8);
    Scr_ObjectError(COM_ERR_4808, scrContext, v21);
  }
}

/*
==============
SetHUDWarningOmnvars
==============
*/
void SetHUDWarningOmnvars(scrContext_t *scrContext, const int warningIndex, const bool showWarning)
{
  unsigned int IndexByName; 
  unsigned int v7; 
  unsigned int v8; 
  OmnvarData *Data; 
  OmnvarData *v10; 
  OmnvarData *v11; 

  IndexByName = BG_Omnvar_GetIndexByName("ui_hud_warning");
  v7 = BG_Omnvar_GetIndexByName("ui_hud_warning_notify");
  v8 = v7;
  if ( IndexByName == -1 || v7 == -1 )
    Scr_Error(COM_ERR_4215, scrContext, "SetHUDWarningOmnvars can't find omnvars - check omnvars.csv");
  Data = G_Omnvar_GetData(IndexByName, -1, NULL);
  v10 = G_Omnvar_GetData(v8, -1, NULL);
  Data->current.integer = warningIndex;
  v11 = v10;
  v10->current.enabled = showWarning;
  G_Omnvar_MarkChanged(Data);
  G_Omnvar_MarkChanged(v11);
}

/*
==============
SetupVehicleCollision
==============
*/
void SetupVehicleCollision(gentity_s *ent, float vehRadius)
{
  __int16 otherEntityNum; 
  float v4; 
  __int64 v5; 
  float v6; 
  float v7; 
  float v8; 
  float v9; 
  vec3_t forward; 
  vec3_t origin; 

  Sys_ProfBeginNamedEvent(0xFFFF0000, "SetupVehicleCollision");
  otherEntityNum = ent->s.otherEntityNum;
  ent->r.svFlags |= 4u;
  ent->clipmask = 8389137;
  if ( otherEntityNum )
  {
    v4 = vehRadius + 15.125;
    v5 = otherEntityNum;
    v6 = g_entities[v5].r.currentOrigin.v[1] - ent->r.currentOrigin.v[1];
    v7 = g_entities[v5].r.currentOrigin.v[0] - ent->r.currentOrigin.v[0];
    v8 = (float)(v6 * v6) + (float)(v7 * v7);
    if ( v8 < (float)(v4 * v4) )
    {
      AngleVectors(&ent->r.currentAngles, &forward, NULL, NULL);
      v9 = v4 - fsqrt(v8);
      origin.v[0] = (float)(v9 * forward.v[0]) + ent->r.currentOrigin.v[0];
      origin.v[1] = (float)(v9 * forward.v[1]) + ent->r.currentOrigin.v[1];
      origin.v[2] = (float)(v9 * forward.v[2]) + ent->r.currentOrigin.v[2];
      G_SetOrigin(ent, &origin, 1, 1);
    }
  }
  Sys_ProfEndNamedEvent();
}

/*
==============
VisionSetSendToClient
==============
*/
void VisionSetSendToClient(scrContext_t *scrContext, visionSetMode_t visionMode)
{
  __int64 v2; 
  int v4; 
  unsigned int v5; 
  scr_string_t ConstLowercaseString; 
  const char *v9; 
  const char *v10; 
  __int64 v11; 
  const char *v12; 
  char *fmt; 
  unsigned int outVisionSetIndex[4]; 
  char dest[64]; 

  v2 = visionMode;
  v4 = 1000;
  v5 = Scr_GetNumParam(scrContext) - 1;
  if ( v5 )
  {
    if ( v5 != 1 )
    {
      Scr_Error(COM_ERR_4376, scrContext, "Invalid parameters.");
      return;
    }
    Scr_GetFloat(scrContext, 1u);
    _XMM0 = 0i64;
    __asm { vroundss xmm1, xmm0, xmm4, 1 }
    v4 = (int)*(float *)&_XMM1;
  }
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  v9 = SL_ConvertToString(ConstLowercaseString);
  v10 = v9;
  if ( *v9 )
  {
    if ( !NetConstStrings_GetVisionSetIndex(v9, outVisionSetIndex) )
    {
      v12 = j_va("visionset %s has not been precached, include with precache_vision", v10);
      Scr_Error(COM_ERR_4375, scrContext, v12);
    }
    v11 = outVisionSetIndex[0];
    if ( !outVisionSetIndex[0] )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 15723, ASSERT_TYPE_ASSERT, "( visionSetIndex != 0 )", (const char *)&queryFormat, "visionSetIndex != 0") )
        __debugbreak();
      v11 = outVisionSetIndex[0];
    }
  }
  else
  {
    v11 = 0i64;
    outVisionSetIndex[0] = 0;
  }
  if ( !(_DWORD)v2 || (_DWORD)v2 == 5 )
  {
    LODWORD(fmt) = v4;
    Com_sprintf(dest, 0x40ui64, "%d %i", v11, fmt);
  }
  else
  {
    Com_sprintf(dest, 0x40ui64, "%d", v11);
  }
  SV_SetConfigstring(dword_143FD1A68[v2], dest);
}

