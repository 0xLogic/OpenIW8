/*
==============
RB_Draw2D_BeforePostFX
==============
*/

void __fastcall RB_Draw2D_BeforePostFX(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RB_Draw2D_BeforePostFX@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, viewInfo, data);
}

/*
==============
RB_Draw2D_Hud
==============
*/

void __fastcall RB_Draw2D_Hud(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RB_Draw2D_Hud@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, viewInfo, data);
}

/*
==============
R_Draw2D_BackupScopeReticle
==============
*/

void __fastcall R_Draw2D_BackupScopeReticle(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, const GfxImage *sceneSrc, const GfxImage *scopeBuffer)
{
  ?R_Draw2D_BackupScopeReticle@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@PEBUGfxImage@@3@Z(gfxContext, viewInfo, data, sceneSrc, scopeBuffer);
}

/*
==============
RB_DrawUmbraOverlays
==============
*/

void __fastcall RB_DrawUmbraOverlays(GfxCmdBufContext *gfxContext)
{
  ?RB_DrawUmbraOverlays@@YAXUGfxCmdBufContext@@@Z(gfxContext);
}

/*
==============
R_WaitSkippedDrawWorkerCmds
==============
*/

void __fastcall R_WaitSkippedDrawWorkerCmds(const GfxBackEndData *data)
{
  ?R_WaitSkippedDrawWorkerCmds@@YAXPEBUGfxBackEndData@@@Z(data);
}

/*
==============
RB_DecommitSpotShadowRTs
==============
*/

void __fastcall RB_DecommitSpotShadowRTs(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo)
{
  ?RB_DecommitSpotShadowRTs@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@@Z(gfxContext, viewInfo);
}

/*
==============
R_WaitDrawWorkerCmdsOfType
==============
*/

void __fastcall R_WaitDrawWorkerCmdsOfType(const GfxBackEndData *data, const GfxDrawListType drawListType)
{
  ?R_WaitDrawWorkerCmdsOfType@@YAXPEBUGfxBackEndData@@W4GfxDrawListType@@@Z(data, drawListType);
}

/*
==============
R_Draw2D_BeforePostFX_IsValid
==============
*/

bool __fastcall R_Draw2D_BeforePostFX_IsValid(const GfxViewInfo *viewInfo)
{
  return ?R_Draw2D_BeforePostFX_IsValid@@YA_NPEBUGfxViewInfo@@@Z(viewInfo);
}

/*
==============
R_SetPersistentTables
==============
*/

void __fastcall R_SetPersistentTables(GfxCmdBufContext *ctx, const GfxBackEndData *data, GfxPersistentDescriptorTables table)
{
  ?R_SetPersistentTables@@YAXAEAUGfxCmdBufContext@@PEBUGfxBackEndData@@W4GfxPersistentDescriptorTables@@@Z(ctx, data, table);
}

/*
==============
R_Draw2D_ReceivePostFXLite_IsValid
==============
*/

bool __fastcall R_Draw2D_ReceivePostFXLite_IsValid(const GfxViewInfo *viewInfo)
{
  return ?R_Draw2D_ReceivePostFXLite_IsValid@@YA_NPEBUGfxViewInfo@@@Z(viewInfo);
}

/*
==============
RB_UploadPackedLightData
==============
*/

void __fastcall RB_UploadPackedLightData(const GfxBackEndData *data, const GfxViewInfo *viewInfo)
{
  ?RB_UploadPackedLightData@@YAXPEBUGfxBackEndData@@PEBUGfxViewInfo@@@Z(data, viewInfo);
}

/*
==============
R_Draw2D_ReceivePostFXComposite_IsValid
==============
*/

bool __fastcall R_Draw2D_ReceivePostFXComposite_IsValid(const GfxViewInfo *viewInfo)
{
  return ?R_Draw2D_ReceivePostFXComposite_IsValid@@YA_NPEBUGfxViewInfo@@@Z(viewInfo);
}

/*
==============
R_UpdatePackedSceneLightConstants
==============
*/

void __fastcall R_UpdatePackedSceneLightConstants(GfxBackEndData *data, const GfxViewInfo *viewInfo)
{
  ?R_UpdatePackedSceneLightConstants@@YAXPEAUGfxBackEndData@@PEBUGfxViewInfo@@@Z(data, viewInfo);
}

/*
==============
RB_InitClient2DContext_ReceivePostFXLite
==============
*/

void __fastcall RB_InitClient2DContext_ReceivePostFXLite(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, R_RT_ColorHandle *sceneRt, const GfxImage *packedStencil, const GfxImage *scopeBuffer)
{
  ?RB_InitClient2DContext_ReceivePostFXLite@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@VR_RT_ColorHandle@@PEBUGfxImage@@4@Z(gfxContext, viewInfo, data, sceneRt, packedStencil, scopeBuffer);
}

/*
==============
RB_PreOpaque_MapMeshes
==============
*/

void __fastcall RB_PreOpaque_MapMeshes(const GfxBackEndData *data)
{
  ?RB_PreOpaque_MapMeshes@@YAXPEBUGfxBackEndData@@@Z(data);
}

/*
==============
R_UpdatePackedLightData
==============
*/

void __fastcall R_UpdatePackedLightData(GfxBackEndData *data, const GfxViewInfo *viewInfo)
{
  ?R_UpdatePackedLightData@@YAXPEAUGfxBackEndData@@PEBUGfxViewInfo@@@Z(data, viewInfo);
}

/*
==============
R_InitDrawCallOutput
==============
*/

void __fastcall R_InitDrawCallOutput(const GfxBackEndData *data, GfxDrawCallOutput *drawOutput)
{
  ?R_InitDrawCallOutput@@YAXPEBUGfxBackEndData@@PEAUGfxDrawCallOutput@@@Z(data, drawOutput);
}

/*
==============
R_PostLitResolve0_Active
==============
*/

bool __fastcall R_PostLitResolve0_Active(const GfxViewInfo *viewInfo)
{
  return ?R_PostLitResolve0_Active@@YA_NPEBUGfxViewInfo@@@Z(viewInfo);
}

/*
==============
R_ShowTris_Draw
==============
*/

void __fastcall R_ShowTris_Draw(const GfxViewInfo *viewInfo, const GfxBackEndData *data, const R_RT_Group *rtGroup, R_SHOW_TRIS showTris)
{
  ?R_ShowTris_Draw@@YAXPEBUGfxViewInfo@@PEBUGfxBackEndData@@PEBUR_RT_Group@@W4R_SHOW_TRIS@@@Z(viewInfo, data, rtGroup, showTris);
}

/*
==============
R_BlitDebugOverlay
==============
*/

void __fastcall R_BlitDebugOverlay(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, R_RT_ColorHandle *outputRt, R_RT_ColorHandle *debugOverlayRt)
{
  ?R_BlitDebugOverlay@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@VR_RT_ColorHandle@@2@Z(gfxContext, viewInfo, outputRt, debugOverlayRt);
}

/*
==============
RB_FinishComputeCmds
==============
*/

void __fastcall RB_FinishComputeCmds(GfxCmdBufContext *gfxContext, const GfxBackEndData *data)
{
  ?RB_FinishComputeCmds@@YAXUGfxCmdBufContext@@PEBUGfxBackEndData@@@Z(gfxContext, data);
}

/*
==============
R_DrawDebug3D_Enabled
==============
*/

bool __fastcall R_DrawDebug3D_Enabled(const GfxViewInfo *viewInfo)
{
  return ?R_DrawDebug3D_Enabled@@YA_NPEBUGfxViewInfo@@@Z(viewInfo);
}

/*
==============
R_ProfBeginDrawListImmediate
==============
*/

void __fastcall R_ProfBeginDrawListImmediate(const GfxDrawListType drawListType)
{
  ?R_ProfBeginDrawListImmediate@@YAXW4GfxDrawListType@@@Z(drawListType);
}

/*
==============
R_Draw2D_RestoreScopeReticle
==============
*/

void __fastcall R_Draw2D_RestoreScopeReticle(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, const GfxImage *sceneBackup, const GfxImage *scopeBuffer)
{
  ?R_Draw2D_RestoreScopeReticle@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@PEBUGfxImage@@3@Z(gfxContext, viewInfo, data, sceneBackup, scopeBuffer);
}

/*
==============
RB_StartDraw3DScene
==============
*/

void __fastcall RB_StartDraw3DScene(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RB_StartDraw3DScene@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, viewInfo, data);
}

/*
==============
RB_InitClient2DContext
==============
*/

void __fastcall RB_InitClient2DContext(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, R_RT_ColorHandle *colorRt, R_RT_Handle *packedStencil, const GfxImage *universalClut, const GfxImage *resolvedScene, const GfxWrappedBuffer *exposureBuffer)
{
  ?RB_InitClient2DContext@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@VR_RT_ColorHandle@@VR_RT_Handle@@PEBUGfxImage@@5PEBUGfxWrappedBuffer@@@Z(gfxContext, viewInfo, data, colorRt, packedStencil, universalClut, resolvedScene, exposureBuffer);
}

/*
==============
R_Draw2D_Hud
==============
*/

void __fastcall R_Draw2D_Hud(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, R_RT_ColorHandle *colorRt, R_RT_Handle *packedStencil, const GfxImage *universalClut, const GfxImage *resolvedScene, const GfxWrappedBuffer *exposureBuffer)
{
  ?R_Draw2D_Hud@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@VR_RT_ColorHandle@@VR_RT_Handle@@PEBUGfxImage@@5PEBUGfxWrappedBuffer@@@Z(gfxContext, viewInfo, data, colorRt, packedStencil, universalClut, resolvedScene, exposureBuffer);
}

/*
==============
R_DebugPrimitivesValid
==============
*/

bool __fastcall R_DebugPrimitivesValid()
{
  return ?R_DebugPrimitivesValid@@YA_NXZ();
}

/*
==============
RB_DisableMSEmissive
==============
*/

void __fastcall RB_DisableMSEmissive(GfxCmdBufContext *context, const GfxViewInfo *viewInfo)
{
  ?RB_DisableMSEmissive@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@@Z(context, viewInfo);
}

/*
==============
R_DrawDebugPrimitives
==============
*/

void __fastcall R_DrawDebugPrimitives(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo)
{
  ?R_DrawDebugPrimitives@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@@Z(gfxContext, viewInfo);
}

/*
==============
R_FontCache_DebugDisplay
==============
*/

void R_FontCache_DebugDisplay(void)
{
  ?R_FontCache_DebugDisplay@@YAXXZ();
}

/*
==============
R_HalfRes_Upsample
==============
*/

void __fastcall R_HalfRes_Upsample(GfxCmdBufContext *context, R_RT_Handle *halfResColor, R_RT_Handle *halfResAlpha, R_RT_Handle *halfResDepth, R_RT_Handle *fullResDepth, const GfxViewport *viewport)
{
  ?R_HalfRes_Upsample@@YAXUGfxCmdBufContext@@VR_RT_Handle@@111PEBUGfxViewport@@@Z(context, halfResColor, halfResAlpha, halfResDepth, fullResDepth, viewport);
}

/*
==============
RB_Draw3DScene
==============
*/

void __fastcall RB_Draw3DScene(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RB_Draw3DScene@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, viewInfo, data);
}

/*
==============
R_RunDrawListCommandBuffer
==============
*/

bool __fastcall R_RunDrawListCommandBuffer(const GfxBackEndData *data, const GfxDrawListType drawListType)
{
  return ?R_RunDrawListCommandBuffer@@YA_NPEBUGfxBackEndData@@W4GfxDrawListType@@@Z(data, drawListType);
}

/*
==============
R_UpdatePackedSpotShadowConstants
==============
*/

void __fastcall R_UpdatePackedSpotShadowConstants(GfxBackEndData *data, const GfxViewInfo *viewInfo)
{
  ?R_UpdatePackedSpotShadowConstants@@YAXPEAUGfxBackEndData@@PEBUGfxViewInfo@@@Z(data, viewInfo);
}

/*
==============
R_PostLitResolve1_Active
==============
*/

bool __fastcall R_PostLitResolve1_Active(const GfxViewInfo *viewInfo)
{
  return ?R_PostLitResolve1_Active@@YA_NPEBUGfxViewInfo@@@Z(viewInfo);
}

/*
==============
RB_DrawFogSplineOverlap_GetImage
==============
*/

const GfxImage *__fastcall RB_DrawFogSplineOverlap_GetImage(const GfxViewInfo *viewInfo, int fogSplineBlendIndex)
{
  return ?RB_DrawFogSplineOverlap_GetImage@@YAPEBUGfxImage@@PEBUGfxViewInfo@@H@Z(viewInfo, fogSplineBlendIndex);
}

/*
==============
R_Draw2D_ReceivePostFXLite
==============
*/

void __fastcall R_Draw2D_ReceivePostFXLite(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, R_RT_ColorHandle *sceneRt, const GfxImage *packedStencil, const GfxImage *scopeBuffer)
{
  ?R_Draw2D_ReceivePostFXLite@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@VR_RT_ColorHandle@@PEBUGfxImage@@4@Z(gfxContext, viewInfo, data, sceneRt, packedStencil, scopeBuffer);
}

/*
==============
RB_RunDrawList
==============
*/

void __fastcall RB_RunDrawList(const GfxViewInfo *viewInfo, const GfxBackEndData *data, const R_RT_Group *rtGroup, GfxDrawListType drawListID)
{
  ?RB_RunDrawList@@YAXPEBUGfxViewInfo@@PEBUGfxBackEndData@@PEBUR_RT_Group@@W4GfxDrawListType@@@Z(viewInfo, data, rtGroup, drawListID);
}

/*
==============
RB_ClearDepthForScopeStencil
==============
*/

void __fastcall RB_ClearDepthForScopeStencil(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RB_ClearDepthForScopeStencil@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, viewInfo, data);
}

/*
==============
RB_Draw3DScene_FreeRts
==============
*/

void RB_Draw3DScene_FreeRts(void)
{
  ?RB_Draw3DScene_FreeRts@@YAXXZ();
}

/*
==============
RB_DrawEmissive_MapMeshes
==============
*/

void __fastcall RB_DrawEmissive_MapMeshes(const GfxBackEndData *data)
{
  ?RB_DrawEmissive_MapMeshes@@YAXPEBUGfxBackEndData@@@Z(data);
}

/*
==============
R_ShowTris_GetShowTris
==============
*/

R_SHOW_TRIS __fastcall R_ShowTris_GetShowTris()
{
  return ?R_ShowTris_GetShowTris@@YA?AW4R_SHOW_TRIS@@XZ();
}

/*
==============
RB_Draw3DOverlays
==============
*/

void __fastcall RB_Draw3DOverlays(GfxCmdBufContext *gfxContext, const GfxBackEndData *data)
{
  ?RB_Draw3DOverlays@@YAXUGfxCmdBufContext@@PEBUGfxBackEndData@@@Z(gfxContext, data);
}

/*
==============
R_HalfRes_DownsampleDepth
==============
*/

void __fastcall R_HalfRes_DownsampleDepth(GfxCmdBufContext *context, R_RT_Handle *fullResDepth, const GfxViewport *viewport)
{
  ?R_HalfRes_DownsampleDepth@@YAXUGfxCmdBufContext@@VR_RT_Handle@@PEBUGfxViewport@@@Z(context, fullResDepth, viewport);
}

/*
==============
RB_AddComputeCmdsTransitions
==============
*/

void __fastcall RB_AddComputeCmdsTransitions(GfxCmdBufState *gfxState, const GfxBackEndData *data, bool begin)
{
  ?RB_AddComputeCmdsTransitions@@YAXPEAUGfxCmdBufState@@PEBUGfxBackEndData@@_N@Z(gfxState, data, begin);
}

/*
==============
RB_InitClient2D_RTT
==============
*/

void __fastcall RB_InitClient2D_RTT(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RB_InitClient2D_RTT@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, viewInfo, data);
}

/*
==============
R_Draw2D_BeforePostFX
==============
*/

void __fastcall R_Draw2D_BeforePostFX(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, R_RT_ColorHandle *sceneRt, R_RT_DepthHandle *depthRt, const GfxImage *universalClut)
{
  ?R_Draw2D_BeforePostFX@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@VR_RT_ColorHandle@@VR_RT_DepthHandle@@PEBUGfxImage@@@Z(gfxContext, viewInfo, data, sceneRt, depthRt, universalClut);
}

/*
==============
RB_DrawScreenshot2DHud
==============
*/

void __fastcall RB_DrawScreenshot2DHud(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, R_RT_Handle *packedStencil, const GfxImage *universalClut, const GfxImage *resolvedScene, const GfxWrappedBuffer *exposureBuffer)
{
  ?RB_DrawScreenshot2DHud@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@VR_RT_Handle@@PEBUGfxImage@@4PEBUGfxWrappedBuffer@@@Z(gfxContext, viewInfo, data, packedStencil, universalClut, resolvedScene, exposureBuffer);
}

/*
==============
R_Umbra_ShowOcclusion
==============
*/

void __fastcall R_Umbra_ShowOcclusion(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, const GfxImage *umbraFloatZ)
{
  ?R_Umbra_ShowOcclusion@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@PEBUGfxImage@@@Z(gfxContext, viewInfo, data, umbraFloatZ);
}

/*
==============
RB_PreOpaque_UnmapMeshes
==============
*/

void __fastcall RB_PreOpaque_UnmapMeshes(const GfxBackEndData *data)
{
  ?RB_PreOpaque_UnmapMeshes@@YAXPEBUGfxBackEndData@@@Z(data);
}

/*
==============
RB_InitClient2DContext_CopyScopeReticle
==============
*/

void __fastcall RB_InitClient2DContext_CopyScopeReticle(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RB_InitClient2DContext_CopyScopeReticle@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, viewInfo, data);
}

/*
==============
RB_InitClient2DReceivePPFXContext
==============
*/

void __fastcall RB_InitClient2DReceivePPFXContext(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, R_RT_ColorHandle *sceneRt, R_RT_DepthHandle *depthRt, const GfxImage *universalClut)
{
  ?RB_InitClient2DReceivePPFXContext@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@VR_RT_ColorHandle@@VR_RT_DepthHandle@@PEBUGfxImage@@@Z(gfxContext, viewInfo, data, sceneRt, depthRt, universalClut);
}

/*
==============
R_Draw2D_RTT
==============
*/

void __fastcall R_Draw2D_RTT(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?R_Draw2D_RTT@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, viewInfo, data);
}

/*
==============
R_Draw2D_RTT_Overlay
==============
*/

void __fastcall R_Draw2D_RTT_Overlay(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?R_Draw2D_RTT_Overlay@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, viewInfo, data);
}

/*
==============
RB_PerformVolumeLightScatter
==============
*/

void __fastcall RB_PerformVolumeLightScatter(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RB_PerformVolumeLightScatter@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, viewInfo, data);
}

/*
==============
R_Draw2D_ReceivePostFXComposite
==============
*/

void __fastcall R_Draw2D_ReceivePostFXComposite(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, R_RT_ColorHandle *sceneRt, const GfxImage *packedStencil, const GfxImage *scopeBuffer)
{
  ?R_Draw2D_ReceivePostFXComposite@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@VR_RT_ColorHandle@@PEBUGfxImage@@4@Z(gfxContext, viewInfo, data, sceneRt, packedStencil, scopeBuffer);
}

/*
==============
RB_UpdatePersistentTables
==============
*/

void __fastcall RB_UpdatePersistentTables(const GfxViewInfo *viewInfo, const GfxBackEndData *data, GfxPersistentDescriptorTables table)
{
  ?RB_UpdatePersistentTables@@YAXPEBUGfxViewInfo@@PEBUGfxBackEndData@@W4GfxPersistentDescriptorTables@@@Z(viewInfo, data, table);
}

/*
==============
R_WaveWaterFloatZ_Active
==============
*/

bool __fastcall R_WaveWaterFloatZ_Active(const GfxViewInfo *viewInfo)
{
  return ?R_WaveWaterFloatZ_Active@@YA_NPEBUGfxViewInfo@@@Z(viewInfo);
}

/*
==============
RB_DrawFogSplineOverlap
==============
*/

void __fastcall RB_DrawFogSplineOverlap(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, int drawFogSpline)
{
  ?RB_DrawFogSplineOverlap@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@H@Z(gfxContext, viewInfo, drawFogSpline);
}

/*
==============
RB_DrawEmissive_UnmapMeshes
==============
*/

void __fastcall RB_DrawEmissive_UnmapMeshes(const GfxBackEndData *data)
{
  ?RB_DrawEmissive_UnmapMeshes@@YAXPEBUGfxBackEndData@@@Z(data);
}

/*
==============
R_Shadow_DrawOverlay
==============
*/

void __fastcall R_Shadow_DrawOverlay(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, int overlayStyle, const R_RT_Handle *shadowCascades, unsigned int cascadeCount, const R_RT_Handle *viewmodelShadowCascade, const R_RT_ColorHandle *spotshadowsStaleCacheRt, const R_RT_DepthHandle *sunshadowCacheRt, R_RT_BufferHandle *compressedSunCascades, R_RT_BufferHandle *csmPrepass, const R_RT_ColorHandle *sunshadowTranslucentMask)
{
  ?R_Shadow_DrawOverlay@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@HPEBVR_RT_Handle@@IV3@VR_RT_ColorHandle@@VR_RT_DepthHandle@@PEAVR_RT_BufferHandle@@V6@4@Z(gfxContext, viewInfo, overlayStyle, shadowCascades, cascadeCount, viewmodelShadowCascade, spotshadowsStaleCacheRt, sunshadowCacheRt, compressedSunCascades, csmPrepass, sunshadowTranslucentMask);
}

/*
==============
R_ProfEndDrawListImmediate
==============
*/

void R_ProfEndDrawListImmediate(void)
{
  ?R_ProfEndDrawListImmediate@@YAXXZ();
}

/*
==============
RB_EnableMSEmissive
==============
*/

void __fastcall RB_EnableMSEmissive(GfxCmdBufContext *context, const GfxViewInfo *viewInfo)
{
  ?RB_EnableMSEmissive@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@@Z(context, viewInfo);
}

/*
==============
RB_AddComputeCmdsTransitions
==============
*/
void RB_AddComputeCmdsTransitions(GfxCmdBufState *gfxState, const GfxBackEndData *data, bool begin)
{
  D3D12_RESOURCE_STATES v6; 
  const GfxWrappedRWBuffer *ClusterBuffer; 
  _BOOL8 v8; 
  _BOOL8 v9; 
  D3D12_RESOURCE_STATES v10; 
  D3D12_RESOURCE_STATES after; 
  const GfxWrappedBuffer *ReactiveMotionPivotsBuffer; 
  D3D12_RESOURCE_STATES before; 
  D3D12_RESOURCE_STATES v14[4]; 
  int v15; 
  D3D12_RESOURCE_STATES v16[4]; 
  D3D12_RESOURCE_STATES v17[2]; 

  if ( data->frameCount || (v6 = D3D12_RESOURCE_STATE_GENERIC_READ, !begin) )
    v6 = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
  *(_OWORD *)v14 = _xmm;
  before = v6;
  v15 = 1;
  v16[0] = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
  v16[1] = D3D12_RESOURCE_STATE_PREDICATION|D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_INDEX_BUFFER;
  v16[2] = v6;
  v16[3] = D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER;
  v17[0] = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
  v17[1] = D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER;
  ClusterBuffer = R_ReflectionProbe_GetClusterBuffer();
  v8 = begin;
  v9 = !begin;
  R_HW_AddResourceTransition(gfxState, ClusterBuffer, 0xFFFFFFFF, v14[v9 - 1], v14[v8 - 1], D3D12_RESOURCE_BARRIER_FLAG_NONE);
  v10 = v14[v9 + 1];
  after = v14[v8 + 1];
  R_HW_AddResourceTransition(gfxState, &data->skinnedCacheVb->buffer, 0xFFFFFFFF, v10, after, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  R_HW_AddResourceTransition(gfxState, &data->subdivCacheVb->buffer, 0xFFFFFFFF, v10, after, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  R_HW_AddResourceTransition(gfxState, &data->subdivCacheVbPrevFrame->buffer, 0xFFFFFFFF, v10, after, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  R_HW_AddResourceTransition(gfxState, &data->skinnedCacheVbPrevFrame->buffer, 0xFFFFFFFF, v10, after, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  ReactiveMotionPivotsBuffer = R_GetReactiveMotionPivotsBuffer(data->reactiveMotionIndex);
  R_HW_AddResourceTransition(gfxState, ReactiveMotionPivotsBuffer, 0xFFFFFFFF, v10, after, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  R_HW_AddResourceTransition(gfxState, &data->tessFactorsBuffer->wrappedBuffer, 0xFFFFFFFF, v16[v9], v16[v8], D3D12_RESOURCE_BARRIER_FLAG_NONE);
  R_HW_AddResourceTransition(gfxState, &data->mayhemChannelsVb->buffer, 0xFFFFFFFF, v17[v9], v17[v8], D3D12_RESOURCE_BARRIER_FLAG_NONE);
}

/*
==============
RB_Async2D_ExecCmdBuf
==============
*/
bool RB_Async2D_ExecCmdBuf(GfxCmdBuf *cmdBuf, const bool renderFailed)
{
  bool result; 
  GfxDevice *device; 

  if ( cmdBuf->device )
  {
    if ( !renderFailed )
    {
      R_FlushImmediateContext();
      device = cmdBuf->device;
      ((void (__fastcall *)(ID3D12CommandQueue *, __int64, GfxDevice **))g_dx.immediateCommandQueue.commandQueue->m_pFunction[3].AddRef)(g_dx.immediateCommandQueue.commandQueue, 1i64, &device);
      result = 1;
      cmdBuf->device = NULL;
      return result;
    }
    cmdBuf->device = NULL;
  }
  return 0;
}

/*
==============
RB_Async2D_Finished
==============
*/
char RB_Async2D_Finished(void *userData)
{
  __int64 v1; 

  v1 = *(_QWORD *)userData;
  if ( !*(_QWORD *)userData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 2093, ASSERT_TYPE_ASSERT, "(data)", (const char *)&queryFormat, "data") )
    __debugbreak();
  if ( !*(_BYTE *)(v1 + 904193) )
    return 1;
  RB_CheckSkipRemoteScreenUpdate();
  return 0;
}

/*
==============
RB_Async2D_ReceivePPFXFinished
==============
*/
char RB_Async2D_ReceivePPFXFinished(void *userData)
{
  __int64 v1; 

  v1 = *(_QWORD *)userData;
  if ( !*(_QWORD *)userData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 2077, ASSERT_TYPE_ASSERT, "(data)", (const char *)&queryFormat, "data") )
    __debugbreak();
  if ( !*(_BYTE *)(v1 + 904194) )
    return 1;
  RB_CheckSkipRemoteScreenUpdate();
  return 0;
}

/*
==============
RB_BlitDebugOverlay
==============
*/
void RB_BlitDebugOverlay(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo)
{
  R_RT_ColorHandle *p_debugOverlay; 
  R_RT_Handle v6; 
  bool v8; 
  GfxCmdBufSourceState *source; 
  GfxCmdBufState *state; 
  unsigned int height; 
  const R_RT_Surface *Surface; 
  GfxCmdBufContext v13; 
  GfxCmdBufSourceState *v14; 
  GfxCmdBufSourceState *v15; 
  R_RT_Image *p_m_image; 
  GfxCmdBufInput *p_input; 
  float v18; 
  float width; 
  R_RT_Handle v20; 
  R_RT_Handle v21; 
  R_RT_Handle result; 
  R_RT_Group v23; 
  GfxViewport viewport[2]; 
  R_RT_Group v25; 

  p_debugOverlay = &viewInfo->debugOverlay;
  if ( R_RT_Handle::IsValid(&viewInfo->debugOverlay) )
  {
    v21 = p_debugOverlay->R_RT_Handle;
    v6 = *R_RT_GetGlobal(&result, R_RENDERTARGET_DISPLAY_BUFFER);
    *(R_RT_Handle *)&viewport[0].x = v6;
    v20 = v6;
    if ( (_WORD)_XMM0 )
    {
      R_RT_Handle::GetSurface(&v20);
      if ( (R_RT_Handle::GetSurface(&v20)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        v6 = v20;
        __debugbreak();
      }
      else
      {
        v6 = v20;
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v8 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        v6 = *(R_RT_Handle *)&viewport[0].x;
        if ( v8 )
          __debugbreak();
      }
    }
    v20 = v6;
    R_RT_Group::AssignColor(&v23, (R_RT_ColorHandle *)&v20);
    source = gfxContext->source;
    v25 = v23;
    R_InitCmdBufSourceState(source, &viewInfo->input);
    state = gfxContext->state;
    R_InitLocalCmdBufState(state, &source->input);
    R_ProfBeginNamedEvent(state, "Debug Overlay");
    v20 = *R_RT_Group::GetValidRt(&v25, &result);
    height = R_RT_Handle::GetSurface(&v20)->m_image.m_base.height;
    Surface = R_RT_Handle::GetSurface(&v20);
    R_SetRenderTargetSize(source, Surface->m_image.m_base.width, height, GFX_USE_VIEWPORT_FOR_VIEW);
    R_BeginViewInternal(source, &viewInfo->sceneDef, (const GfxViewParms *)viewInfo, &viewInfo->viewParmsSet.frames[1].viewParms);
    viewport[0] = *(GfxViewport *)gfxContext;
    R_SetRenderTargetsInternal((GfxCmdBufContext *)viewport, &v25, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1052)");
    v13 = *gfxContext;
    v14 = gfxContext->source;
    v15 = gfxContext->source;
    viewport[0] = viewInfo->displayViewport;
    R_SetViewportStruct(v15, viewport);
    R_Set2D(v14);
    v14->input.consts[59] = colorWhite;
    ++v14->constVersions[59];
    v14->input.consts[60] = colorBlackBlank;
    ++v14->constVersions[60];
    *(_QWORD *)&v14->input.consts[61].xyz.y = 2139095039i64;
    v14->input.consts[61].v[0] = 0.0;
    v14->input.consts[61].v[3] = 0.0;
    ++v14->constVersions[61];
    p_m_image = &R_RT_Handle::GetSurface(&v21)->m_image;
    p_input = &v14->input;
    if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
      __debugbreak();
    v18 = (float)viewport[0].height;
    width = (float)viewport[0].width;
    p_input->codeImages[4] = &p_m_image->m_base;
    *(GfxCmdBufContext *)&v20.m_surfaceID = v13;
    RB_ViewportFilterDirectInternal((GfxCmdBufContext *)&v20, rgp.feedbackBlendBackbufferMaterial, 0xFFFFFFFF, viewport, 0.0, 0.0, width, v18, 0.0, 0.0, 1.0, 1.0, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1032)");
    R_ProfEndNamedEvent(state);
    R_ShutdownLocalCmdBufState(state, &source->input);
    v21 = p_debugOverlay->R_RT_Handle;
    *(GfxCmdBufContext *)&v20.m_surfaceID = v13;
    R_RT_Destroy((GfxCmdBufContext *)&v20, (R_RT_ColorHandle *)&v21);
    p_debugOverlay->m_surfaceID = 0;
    p_debugOverlay->m_tracking.m_allocCounter = 0;
    p_debugOverlay->m_tracking.m_name = NULL;
    p_debugOverlay->m_tracking.m_location = NULL;
  }
}

/*
==============
RB_ClearDepthForScopeStencil
==============
*/
void RB_ClearDepthForScopeStencil(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufSourceState *source; 
  GfxCmdBufState *state; 
  GfxViewport *p_sceneViewport; 
  __m256i m_mainSceneEntityIDVelocityRt; 
  unsigned int height; 
  const R_RT_Surface *Surface; 
  float v11; 
  float width; 
  R_RT_Handle m_mainSceneColorRt; 
  R_RT_DepthHandle m_mainSceneDepthRt; 
  __m256i v15; 

  if ( data->scope.scopeUseDualFov && (!data->scope.adsSmoothFade || data->scope.scopeFadeInfo[0].fadeInFrac != 0.0) )
  {
    source = gfxContext->source;
    R_InitCmdBufSourceState(gfxContext->source, &viewInfo->input);
    state = gfxContext->state;
    R_InitLocalCmdBufState(state, &source->input);
    R_ProfBeginNamedEvent(state, "Scope Depth Clear");
    R_BeginViewInternal(source, &viewInfo->sceneDef, (const GfxViewParms *)viewInfo, &viewInfo->viewParmsSet.frames[1].viewParms);
    p_sceneViewport = &viewInfo->sceneViewport;
    R_SetViewportStruct(source, &viewInfo->sceneViewport);
    m_mainSceneEntityIDVelocityRt = (__m256i)viewInfo->sceneRtInput.m_mainSceneEntityIDVelocityRt;
    m_mainSceneDepthRt = viewInfo->sceneRtInput.m_mainSceneDepthRt;
    *(GfxCmdBufContext *)&m_mainSceneColorRt.m_surfaceID = *gfxContext;
    v15 = m_mainSceneEntityIDVelocityRt;
    R_SetRenderTargetsInternal_ColorDepth((GfxCmdBufContext *)&m_mainSceneColorRt, (R_RT_ColorHandle *)&v15, &m_mainSceneDepthRt, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(5500)");
    m_mainSceneColorRt = (R_RT_Handle)viewInfo->sceneRtInput.m_mainSceneColorRt;
    height = R_RT_Handle::GetSurface(&m_mainSceneColorRt)->m_image.m_base.height;
    Surface = R_RT_Handle::GetSurface(&m_mainSceneColorRt);
    R_SetRenderTargetSize(source, Surface->m_image.m_base.width, height, GFX_USE_VIEWPORT_FOR_VIEW);
    v11 = (float)p_sceneViewport->height;
    width = (float)p_sceneViewport->width;
    *(GfxCmdBufContext *)&m_mainSceneColorRt.m_surfaceID = *gfxContext;
    RB_ViewportFilterDirectInternal((GfxCmdBufContext *)&m_mainSceneColorRt, rgp.scopeUIDepthClear, 0xFFFFFFFF, p_sceneViewport, 0.0, 0.0, width, v11, 0.0, 0.0, 1.0, 1.0, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(5504)");
    R_ProfEndNamedEvent(state);
    R_ShutdownLocalCmdBufState(state, &source->input);
  }
}

/*
==============
RB_DecommitEmissiveRTs
==============
*/
void RB_DecommitEmissiveRTs(GfxCmdBufContext *gfxContext, const GfxBackEndData *data, const GfxViewInfo *viewInfo)
{
  GfxCmdBufContext v5; 
  GfxCmdBufContext v6; 
  GfxCmdBufContext v7; 
  GfxCmdBufContext v8; 
  GfxCmdBufContext v9; 
  GfxCmdBufContext v10; 
  GfxCmdBufContext v11; 
  GfxCmdBufContext v12; 
  GfxCmdBufContext v13; 
  R_RT_ColorHandle m_msaaSceneColorRt; 

  R_LockGfxImmediateContext();
  if ( rg.vrsEmissiveOnly )
  {
    v5 = *gfxContext;
    m_msaaSceneColorRt = viewInfo->sceneRtInput.m_msaaSceneColorRt;
    v13 = v5;
    R_RT_Destroy(&v13, &m_msaaSceneColorRt);
    v6 = *gfxContext;
    viewInfo->sceneRtInput.m_msaaSceneColorRt.m_surfaceID = 0;
    viewInfo->sceneRtInput.m_msaaSceneColorRt.m_tracking.m_allocCounter = 0;
    viewInfo->sceneRtInput.m_msaaSceneColorRt.m_tracking.m_name = NULL;
    viewInfo->sceneRtInput.m_msaaSceneColorRt.m_tracking.m_location = NULL;
    m_msaaSceneColorRt = viewInfo->sceneRtInput.m_msaaSceneAlphaRt;
    v13 = v6;
    R_RT_Destroy(&v13, &m_msaaSceneColorRt);
    v7 = *gfxContext;
    viewInfo->sceneRtInput.m_msaaSceneAlphaRt.m_surfaceID = 0;
    viewInfo->sceneRtInput.m_msaaSceneAlphaRt.m_tracking.m_allocCounter = 0;
    viewInfo->sceneRtInput.m_msaaSceneAlphaRt.m_tracking.m_name = NULL;
    viewInfo->sceneRtInput.m_msaaSceneAlphaRt.m_tracking.m_location = NULL;
    m_msaaSceneColorRt = (R_RT_ColorHandle)viewInfo->sceneRtInput.m_msaaSceneDepthRt;
    v13 = v7;
    R_RT_Destroy(&v13, (R_RT_DepthHandle *)&m_msaaSceneColorRt);
    viewInfo->sceneRtInput.m_msaaSceneDepthRt.m_surfaceID = 0;
    viewInfo->sceneRtInput.m_msaaSceneDepthRt.m_tracking.m_allocCounter = 0;
    viewInfo->sceneRtInput.m_msaaSceneDepthRt.m_tracking.m_name = NULL;
    viewInfo->sceneRtInput.m_msaaSceneDepthRt.m_tracking.m_location = NULL;
  }
  if ( rg.halfResEmissive )
  {
    v8 = *gfxContext;
    m_msaaSceneColorRt = viewInfo->sceneRtInput.m_halfSceneColorRt;
    v13 = v8;
    R_RT_Destroy(&v13, &m_msaaSceneColorRt);
    v9 = *gfxContext;
    viewInfo->sceneRtInput.m_halfSceneColorRt.m_surfaceID = 0;
    viewInfo->sceneRtInput.m_halfSceneColorRt.m_tracking.m_allocCounter = 0;
    viewInfo->sceneRtInput.m_halfSceneColorRt.m_tracking.m_name = NULL;
    viewInfo->sceneRtInput.m_halfSceneColorRt.m_tracking.m_location = NULL;
    m_msaaSceneColorRt = viewInfo->sceneRtInput.m_halfSceneAlphaRt;
    v13 = v9;
    R_RT_Destroy(&v13, &m_msaaSceneColorRt);
    v10 = *gfxContext;
    viewInfo->sceneRtInput.m_halfSceneAlphaRt.m_surfaceID = 0;
    viewInfo->sceneRtInput.m_halfSceneAlphaRt.m_tracking.m_allocCounter = 0;
    viewInfo->sceneRtInput.m_halfSceneAlphaRt.m_tracking.m_name = NULL;
    viewInfo->sceneRtInput.m_halfSceneAlphaRt.m_tracking.m_location = NULL;
    m_msaaSceneColorRt = (R_RT_ColorHandle)viewInfo->sceneRtInput.m_halfSceneDepthRt;
    v13 = v10;
    R_RT_Destroy(&v13, (R_RT_DepthHandle *)&m_msaaSceneColorRt);
    viewInfo->sceneRtInput.m_halfSceneDepthRt.m_surfaceID = 0;
    viewInfo->sceneRtInput.m_halfSceneDepthRt.m_tracking.m_allocCounter = 0;
    viewInfo->sceneRtInput.m_halfSceneDepthRt.m_tracking.m_name = NULL;
    viewInfo->sceneRtInput.m_halfSceneDepthRt.m_tracking.m_location = NULL;
  }
  if ( rg.debugTextureOverlay != 11 )
  {
    v11 = *gfxContext;
    m_msaaSceneColorRt = viewInfo->sceneRtInput.m_ssrRt;
    v13 = v11;
    R_RT_Destroy(&v13, &m_msaaSceneColorRt);
    viewInfo->sceneRtInput.m_ssrRt.m_surfaceID = 0;
    viewInfo->sceneRtInput.m_ssrRt.m_tracking.m_allocCounter = 0;
    viewInfo->sceneRtInput.m_ssrRt.m_tracking.m_name = NULL;
    viewInfo->sceneRtInput.m_ssrRt.m_tracking.m_location = NULL;
  }
  v12 = *gfxContext;
  m_msaaSceneColorRt = viewInfo->sceneRtInput.m_ssrMaskRt;
  v13 = v12;
  R_RT_Destroy(&v13, &m_msaaSceneColorRt);
  viewInfo->sceneRtInput.m_ssrMaskRt.m_surfaceID = 0;
  viewInfo->sceneRtInput.m_ssrMaskRt.m_tracking.m_allocCounter = 0;
  viewInfo->sceneRtInput.m_ssrMaskRt.m_tracking.m_name = NULL;
  viewInfo->sceneRtInput.m_ssrMaskRt.m_tracking.m_location = NULL;
  R_FlushImmediateContext();
  R_UnlockGfxImmediateContext();
}

/*
==============
RB_DecommitSceneRTs
==============
*/
void RB_DecommitSceneRTs(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo)
{
  GfxCmdBufContext v4; 
  GfxCmdBufContext v5; 
  GfxCmdBufContext v6; 
  GfxCmdBufContext v7; 
  GfxCmdBufContext v8; 
  GfxCmdBufContext v9; 
  GfxCmdBufContext v10; 
  GfxCmdBufContext v11; 
  unsigned int debugTextureOverlay; 
  GfxCmdBufContext v13; 
  GfxCmdBufContext v14; 
  GfxCmdBufContext v15; 
  R_RT_ColorHandle m_waterFloatZRt; 

  R_LockGfxImmediateContext();
  v15 = *gfxContext;
  RB_ReProjFloatZ_RotateRTs(&v15, viewInfo);
  v4 = *gfxContext;
  m_waterFloatZRt = viewInfo->sceneRtInput.m_waterFloatZRt;
  v15 = v4;
  R_RT_Destroy(&v15, &m_waterFloatZRt);
  v5 = *gfxContext;
  viewInfo->sceneRtInput.m_waterFloatZRt.m_surfaceID = 0;
  viewInfo->sceneRtInput.m_waterFloatZRt.m_tracking.m_allocCounter = 0;
  viewInfo->sceneRtInput.m_waterFloatZRt.m_tracking.m_name = NULL;
  viewInfo->sceneRtInput.m_waterFloatZRt.m_tracking.m_location = NULL;
  m_waterFloatZRt = viewInfo->sceneRtInput.m_mainSceneEntityIDVelocityRt;
  v15 = v5;
  R_RT_Destroy(&v15, &m_waterFloatZRt);
  v6 = *gfxContext;
  viewInfo->sceneRtInput.m_mainSceneEntityIDVelocityRt.m_surfaceID = 0;
  viewInfo->sceneRtInput.m_mainSceneEntityIDVelocityRt.m_tracking.m_allocCounter = 0;
  viewInfo->sceneRtInput.m_mainSceneEntityIDVelocityRt.m_tracking.m_name = NULL;
  viewInfo->sceneRtInput.m_mainSceneEntityIDVelocityRt.m_tracking.m_location = NULL;
  m_waterFloatZRt = viewInfo->sceneRtInput.m_mainSceneTangentFrameRt;
  v15 = v6;
  R_RT_Destroy(&v15, &m_waterFloatZRt);
  v7 = *gfxContext;
  viewInfo->sceneRtInput.m_mainSceneTangentFrameRt.m_surfaceID = 0;
  viewInfo->sceneRtInput.m_mainSceneTangentFrameRt.m_tracking.m_allocCounter = 0;
  viewInfo->sceneRtInput.m_mainSceneTangentFrameRt.m_tracking.m_name = NULL;
  viewInfo->sceneRtInput.m_mainSceneTangentFrameRt.m_tracking.m_location = NULL;
  m_waterFloatZRt = viewInfo->sceneRtInput.m_mainSceneColorRt;
  v15 = v7;
  R_RT_Destroy(&v15, &m_waterFloatZRt);
  v8 = *gfxContext;
  viewInfo->sceneRtInput.m_mainSceneColorRt.m_surfaceID = 0;
  viewInfo->sceneRtInput.m_mainSceneColorRt.m_tracking.m_allocCounter = 0;
  viewInfo->sceneRtInput.m_mainSceneColorRt.m_tracking.m_name = NULL;
  viewInfo->sceneRtInput.m_mainSceneColorRt.m_tracking.m_location = NULL;
  m_waterFloatZRt = viewInfo->sceneRtInput.m_mainSceneAlphaRt;
  v15 = v8;
  R_RT_Destroy(&v15, &m_waterFloatZRt);
  v9 = *gfxContext;
  viewInfo->sceneRtInput.m_mainSceneAlphaRt.m_surfaceID = 0;
  viewInfo->sceneRtInput.m_mainSceneAlphaRt.m_tracking.m_allocCounter = 0;
  viewInfo->sceneRtInput.m_mainSceneAlphaRt.m_tracking.m_name = NULL;
  viewInfo->sceneRtInput.m_mainSceneAlphaRt.m_tracking.m_location = NULL;
  m_waterFloatZRt = viewInfo->sceneRtInput.m_mainSceneOverdrawRt;
  v15 = v9;
  R_RT_Destroy(&v15, &m_waterFloatZRt);
  v10 = *gfxContext;
  viewInfo->sceneRtInput.m_mainSceneOverdrawRt.m_surfaceID = 0;
  viewInfo->sceneRtInput.m_mainSceneOverdrawRt.m_tracking.m_allocCounter = 0;
  viewInfo->sceneRtInput.m_mainSceneOverdrawRt.m_tracking.m_name = NULL;
  viewInfo->sceneRtInput.m_mainSceneOverdrawRt.m_tracking.m_location = NULL;
  m_waterFloatZRt = viewInfo->sceneRtInput.m_halfVelocityMBlurRt;
  v15 = v10;
  R_RT_Destroy(&v15, &m_waterFloatZRt);
  v11 = *gfxContext;
  viewInfo->sceneRtInput.m_halfVelocityMBlurRt.m_surfaceID = 0;
  viewInfo->sceneRtInput.m_halfVelocityMBlurRt.m_tracking.m_allocCounter = 0;
  viewInfo->sceneRtInput.m_halfVelocityMBlurRt.m_tracking.m_name = NULL;
  viewInfo->sceneRtInput.m_halfVelocityMBlurRt.m_tracking.m_location = NULL;
  m_waterFloatZRt = viewInfo->sceneRtInput.m_dofTile0Handle;
  v15 = v11;
  R_RT_Destroy(&v15, &m_waterFloatZRt);
  viewInfo->sceneRtInput.m_dofTile0Handle.m_surfaceID = 0;
  viewInfo->sceneRtInput.m_dofTile0Handle.m_tracking.m_allocCounter = 0;
  viewInfo->sceneRtInput.m_dofTile0Handle.m_tracking.m_name = NULL;
  viewInfo->sceneRtInput.m_dofTile0Handle.m_tracking.m_location = NULL;
  debugTextureOverlay = rg.debugTextureOverlay;
  if ( rg.debugTextureOverlay == 10 )
  {
    v15 = *gfxContext;
    RB_SSAO_DecommitRTs(&v15, viewInfo);
    debugTextureOverlay = rg.debugTextureOverlay;
  }
  if ( debugTextureOverlay == 11 )
  {
    v13 = *gfxContext;
    m_waterFloatZRt = viewInfo->sceneRtInput.m_ssrRt;
    v15 = v13;
    R_RT_Destroy(&v15, &m_waterFloatZRt);
    viewInfo->sceneRtInput.m_ssrRt.m_surfaceID = 0;
    viewInfo->sceneRtInput.m_ssrRt.m_tracking.m_allocCounter = 0;
    viewInfo->sceneRtInput.m_ssrRt.m_tracking.m_name = NULL;
    viewInfo->sceneRtInput.m_ssrRt.m_tracking.m_location = NULL;
    debugTextureOverlay = rg.debugTextureOverlay;
  }
  if ( debugTextureOverlay == 14 )
  {
    v14 = *gfxContext;
    m_waterFloatZRt = viewInfo->sceneRtInput.m_transMask;
    v15 = v14;
    R_RT_Destroy(&v15, &m_waterFloatZRt);
    viewInfo->sceneRtInput.m_transMask.m_surfaceID = 0;
    viewInfo->sceneRtInput.m_transMask.m_tracking.m_allocCounter = 0;
    viewInfo->sceneRtInput.m_transMask.m_tracking.m_name = NULL;
    viewInfo->sceneRtInput.m_transMask.m_tracking.m_location = NULL;
  }
  R_FlushImmediateContext();
  R_UnlockGfxImmediateContext();
}

/*
==============
RB_DecommitSpotShadowRTs
==============
*/
void RB_DecommitSpotShadowRTs(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo)
{
  R_RT_Tracking_HandleInfo *p_m_tracking; 
  __int64 v5; 
  unsigned __int16 v6; 
  __int128 v7; 
  double v8; 
  R_RT_Handle v9; 
  bool v10; 
  R_RT_Handle v11; 
  R_RT_Handle v12; 
  R_RT_Handle v13; 

  R_LockGfxImmediateContext();
  p_m_tracking = &viewInfo->sceneRtInput.m_spotShadowRts[0].m_tracking;
  v5 = 8i64;
  do
  {
    v6 = (__int64)p_m_tracking[-1].m_location & 0x7FFF;
    if ( !v6 )
      v6 = 0;
    v12.m_surfaceID = v6;
    v7 = *(_OWORD *)&p_m_tracking->m_allocCounter;
    v8 = *(double *)&p_m_tracking->m_location;
    *(_OWORD *)&v12.m_tracking.m_allocCounter = *(_OWORD *)&p_m_tracking->m_allocCounter;
    *(double *)&v12.m_tracking.m_location = v8;
    v9 = v12;
    v11 = v12;
    v13 = v12;
    if ( v6 )
    {
      R_RT_Handle::GetSurface(&v13);
      if ( (R_RT_Handle::GetSurface(&v13)->m_rtFlagsInternal & 0x10) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 277, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsDepth())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsDepth()") )
      {
        v9 = v13;
        v11 = v13;
      }
      else
      {
        v9 = v13;
        v11 = v13;
        __debugbreak();
      }
    }
    else if ( v12.m_tracking.m_allocCounter )
    {
      v10 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      v9 = v11;
      if ( v10 )
        __debugbreak();
    }
    LOWORD(p_m_tracking[-1].m_location) = 0;
    p_m_tracking->m_allocCounter = 0;
    p_m_tracking->m_name = NULL;
    p_m_tracking->m_location = NULL;
    v12 = v9;
    if ( (_WORD)v7 )
    {
      R_RT_Handle::GetSurface(&v12);
    }
    else
    {
      if ( !v13.m_tracking.m_allocCounter )
        goto LABEL_18;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    v9 = v11;
LABEL_18:
    if ( (_WORD)v7 )
    {
      v13 = v9;
      *(GfxCmdBufContext *)&v11.m_surfaceID = *gfxContext;
      R_RT_Destroy((GfxCmdBufContext *)&v11, (R_RT_DepthHandle *)&v13);
    }
    p_m_tracking = (R_RT_Tracking_HandleInfo *)((char *)p_m_tracking + 32);
    --v5;
  }
  while ( v5 );
  R_FlushImmediateContext();
  R_UnlockGfxImmediateContext();
}

/*
==============
RB_DecommitSunShadowRTs
==============
*/
void RB_DecommitSunShadowRTs(GfxCmdBufContext *gfxContext, const GfxBackEndData *data, const GfxViewInfo *viewInfo)
{
  unsigned int v6; 
  GfxCmdBufState *state; 
  ComputeCmdBufState *GfxComputeCmdBufState; 
  unsigned int i; 
  R_RT_ColorHandle *v10; 
  GfxCmdBufContext v11; 
  GfxCmdBufContext v12; 
  GfxCmdBufContext v13; 
  R_RT_ColorHandle m_sunShadowCascade0ForViewmodel; 
  R_RT_DepthHandle v15; 
  R_RT_DepthHandle result; 

  R_LockGfxImmediateContext();
  R_SunShadowMapDebug_CreateRTDraw3D();
  if ( (unsigned int)(sm_showOverlay->current.integer - 1) <= 3 && (*((_BYTE *)&viewInfo->viewportFeatures + 44) & 4) != 0 )
  {
    v6 = 0;
    if ( data->sunShadow.opaqueCascadeCount )
    {
      state = gfxContext->state;
      do
      {
        v15 = viewInfo->sceneRtInput.m_sunShadowCascades[v6];
        R_SunShadowMapDebug_GetRTDraw3D(&result, v6);
        m_sunShadowCascade0ForViewmodel = (R_RT_ColorHandle)result;
        GfxComputeCmdBufState = R_GetGfxComputeCmdBufState(state);
        R_CopyDepthStencilRT(GfxComputeCmdBufState, (R_RT_DepthHandle *)&m_sunShadowCascade0ForViewmodel, &v15);
        ++v6;
      }
      while ( v6 < data->sunShadow.opaqueCascadeCount );
    }
  }
  for ( i = 0; i < data->sunShadow.opaqueCascadeCount; v10->m_tracking.m_location = NULL )
  {
    v10 = (R_RT_ColorHandle *)&viewInfo->sceneRtInput.m_sunShadowCascades[i];
    *(GfxCmdBufContext *)&result.m_surfaceID = *gfxContext;
    m_sunShadowCascade0ForViewmodel = *v10;
    R_RT_Destroy((GfxCmdBufContext *)&result, (R_RT_DepthHandle *)&m_sunShadowCascade0ForViewmodel);
    v10->m_surfaceID = 0;
    ++i;
    v10->m_tracking.m_allocCounter = 0;
    v10->m_tracking.m_name = NULL;
  }
  v11 = *gfxContext;
  m_sunShadowCascade0ForViewmodel = (R_RT_ColorHandle)viewInfo->sceneRtInput.m_sunShadowCascade0ForViewmodel;
  *(GfxCmdBufContext *)&result.m_surfaceID = v11;
  R_RT_Destroy((GfxCmdBufContext *)&result, (R_RT_DepthHandle *)&m_sunShadowCascade0ForViewmodel);
  v12 = *gfxContext;
  viewInfo->sceneRtInput.m_sunShadowCascade0ForViewmodel.m_surfaceID = 0;
  viewInfo->sceneRtInput.m_sunShadowCascade0ForViewmodel.m_tracking.m_allocCounter = 0;
  viewInfo->sceneRtInput.m_sunShadowCascade0ForViewmodel.m_tracking.m_name = NULL;
  viewInfo->sceneRtInput.m_sunShadowCascade0ForViewmodel.m_tracking.m_location = NULL;
  m_sunShadowCascade0ForViewmodel = viewInfo->sceneRtInput.m_sunVisibilityRt;
  *(GfxCmdBufContext *)&result.m_surfaceID = v12;
  R_RT_Destroy((GfxCmdBufContext *)&result, &m_sunShadowCascade0ForViewmodel);
  v13 = *gfxContext;
  viewInfo->sceneRtInput.m_sunVisibilityRt.m_surfaceID = 0;
  viewInfo->sceneRtInput.m_sunVisibilityRt.m_tracking.m_allocCounter = 0;
  viewInfo->sceneRtInput.m_sunVisibilityRt.m_tracking.m_name = NULL;
  viewInfo->sceneRtInput.m_sunVisibilityRt.m_tracking.m_location = NULL;
  m_sunShadowCascade0ForViewmodel = viewInfo->sceneRtInput.m_translucentShadowRt;
  *(GfxCmdBufContext *)&result.m_surfaceID = v13;
  R_RT_Destroy((GfxCmdBufContext *)&result, &m_sunShadowCascade0ForViewmodel);
  viewInfo->sceneRtInput.m_translucentShadowRt.m_surfaceID = 0;
  viewInfo->sceneRtInput.m_translucentShadowRt.m_tracking.m_allocCounter = 0;
  viewInfo->sceneRtInput.m_translucentShadowRt.m_tracking.m_name = NULL;
  viewInfo->sceneRtInput.m_translucentShadowRt.m_tracking.m_location = NULL;
  R_FlushImmediateContext();
  R_UnlockGfxImmediateContext();
}

/*
==============
RB_DisableMSEmissive
==============
*/
void RB_DisableMSEmissive(GfxCmdBufContext *context, const GfxViewInfo *viewInfo)
{
  char v4[128]; 

  _XMM0 = *context;
  __asm { vpextrq rbx, xmm0, 1 }
  if ( !R_IsLockedIfGfxImmediateContext(*(const GfxDevice **)(_RBX + 1360)) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_immediate_context_lock.h", 29, ASSERT_TYPE_ASSERT, "(R_IsLockedIfGfxImmediateContext( device ))", (const char *)&queryFormat, "R_IsLockedIfGfxImmediateContext( device )") )
    __debugbreak();
  memset_0(v4, 0, sizeof(v4));
  (*(void (__fastcall **)(_QWORD, char *, void *, void *))(**(_QWORD **)(_RBX + 1360) + 640i64))(*(_QWORD *)(_RBX + 1360), v4, &`R_HW_DisableMultiSample'::`2'::s_samplePriorities1xMS, &`R_HW_DisableMultiSample'::`2'::s_eqaa1xMS);
  (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(_RBX + 1360) + 512i64))(*(_QWORD *)(_RBX + 1360), 0i64);
}

/*
==============
RB_Draw2D_BeforePostFX
==============
*/
void RB_Draw2D_BeforePostFX(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufSourceState *source; 
  GfxCmdBufState *state; 
  GfxCmdBufInput *p_input; 
  const GfxImage *Image; 
  const GfxBackEndData *v9; 
  __m256i m_mainSceneColorRt; 
  const void *v11; 
  GfxCmdBufContext v12; 
  GfxCmdBufContext v13; 
  R_RT_DepthHandle m_mainSceneDepthRt; 
  __m256i v15; 
  const GfxBackEndData *v16; 
  const GfxBackEndData *timeoutUserData; 
  GfxDevice *device; 

  timeoutUserData = data;
  if ( viewInfo->displayCmds[0] )
  {
    Sys_ProfBeginNamedEvent(0xFFFFA500, "wait hud2D ready");
    Sys_ProcessWorkerCmdsWithTimeout(RB_IsHud2DReady, &timeoutUserData);
    Sys_ProfEndNamedEvent();
    if ( !timeoutUserData->abortReady )
    {
      if ( viewInfo->displayCmds[3] )
      {
        Sys_ProfBeginNamedEvent(0xFFFFD700, "exec cmds before postFX");
        source = gfxContext->source;
        R_InitCmdBufSourceState(gfxContext->source, &viewInfo->input);
        state = gfxContext->state;
        p_input = &source->input;
        R_InitLocalCmdBufState(state, &source->input);
        R_ProfBeginNamedEvent(state, "2D (before postFX)");
        R_GPU_BeginTimer(GPU_TIMER_2D);
        Image = R_UniversalClut_GetImage(viewInfo->clientIndex, MOVEMENT);
        v9 = timeoutUserData;
        m_mainSceneColorRt = (__m256i)viewInfo->sceneRtInput.m_mainSceneColorRt;
        m_mainSceneDepthRt = viewInfo->sceneRtInput.m_mainSceneDepthRt;
        v12 = *gfxContext;
        v15 = m_mainSceneColorRt;
        RB_InitClient2DReceivePPFXContext(&v12, viewInfo, timeoutUserData, (R_RT_ColorHandle *)&v15, &m_mainSceneDepthRt, Image);
        if ( v9->async2D.renderReceivePPFXPending )
        {
          v16 = v9;
          Sys_ProfBeginNamedEvent(0xFF008008, "wait LUI render");
          R_UnlockGfxImmediateContext();
          Sys_ProcessWorkerCmdsWithTimeout((bool (__fastcall *)(void *))RB_Async2D_ReceivePPFXFinished, &v16);
          R_LockGfxImmediateContext();
          Sys_ProfEndNamedEvent();
        }
        if ( v9->async2D.receivePPFXCmdBuf.device )
        {
          if ( !v9->async2D.renderFailed )
          {
            R_FlushImmediateContext();
            device = v9->async2D.receivePPFXCmdBuf.device;
            ((void (__fastcall *)(ID3D12CommandQueue *, __int64, GfxDevice **))g_dx.immediateCommandQueue.commandQueue->m_pFunction[3].AddRef)(g_dx.immediateCommandQueue.commandQueue, 1i64, &device);
            v9->async2D.receivePPFXCmdBuf.device = NULL;
LABEL_11:
            R_GPU_EndTimer();
            R_ProfEndNamedEvent(state);
            R_ShutdownLocalCmdBufState(state, p_input);
            Sys_ProfEndNamedEvent();
            return;
          }
          v9->async2D.receivePPFXCmdBuf.device = NULL;
        }
        v11 = viewInfo->displayCmds[3];
        v13 = *gfxContext;
        RB_ExecuteRenderCommandsLoop(&v13, v11, NULL);
        goto LABEL_11;
      }
    }
  }
}

/*
==============
RB_Draw2D_Hud
==============
*/
void RB_Draw2D_Hud(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufSourceState *source; 
  const GfxImage *Image; 
  R_RT_Image *p_m_image; 
  const GfxWrappedBuffer *ConstantBuffer; 
  GfxCmdBufContext v12; 
  R_RT_Handle m_resolvedSceneRt; 
  R_RT_Handle v14; 
  R_RT_Handle result; 

  if ( viewInfo->displayCmds[0] )
  {
    Sys_ProfBeginNamedEvent(0xFFFFD700, "exec cmds display");
    source = gfxContext->source;
    R_InitCmdBufSourceState(gfxContext->source, &viewInfo->input);
    R_InitLocalCmdBufState(gfxContext->state, &source->input);
    R_ProfBeginNamedEvent(gfxContext->state, "2D (View)");
    R_GPU_BeginTimer(GPU_TIMER_2D);
    v14 = *R_RT_GetGlobal(&result, R_RENDERTARGET_DISPLAY_BUFFER);
    m_resolvedSceneRt = v14;
    if ( (_WORD)_XMM0 )
    {
      R_RT_Handle::GetSurface(&m_resolvedSceneRt);
      if ( (R_RT_Handle::GetSurface(&m_resolvedSceneRt)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        v14 = m_resolvedSceneRt;
        __debugbreak();
      }
      else
      {
        v14 = m_resolvedSceneRt;
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    Image = R_UniversalClut_GetImage(viewInfo->clientIndex, MOVEMENT);
    m_resolvedSceneRt = (R_RT_Handle)viewInfo->sceneRtInput.m_resolvedSceneRt;
    if ( (_WORD)_XMM0 )
    {
      R_RT_Handle::GetSurface(&m_resolvedSceneRt);
      p_m_image = &R_RT_Handle::GetSurface(&m_resolvedSceneRt)->m_image;
    }
    else
    {
      if ( m_resolvedSceneRt.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
      p_m_image = (R_RT_Image *)rgp.blackImage;
    }
    ConstantBuffer = R_Tonemap_GetConstantBuffer(viewInfo);
    result = (R_RT_Handle)viewInfo->sceneRtInput.m_packedStencilRt;
    *(GfxCmdBufContext *)&m_resolvedSceneRt.m_surfaceID = *gfxContext;
    R_Draw2D_Hud((GfxCmdBufContext *)&m_resolvedSceneRt, viewInfo, data, (R_RT_ColorHandle *)&v14, &result, Image, &p_m_image->m_base, ConstantBuffer);
    R_GPU_EndTimer();
    R_ProfEndNamedEvent(gfxContext->state);
    R_ShutdownLocalCmdBufState(gfxContext->state, &gfxContext->source->input);
    Sys_ProfEndNamedEvent();
  }
  v12 = *gfxContext;
  result = (R_RT_Handle)viewInfo->sceneRtInput.m_packedStencilRt;
  *(GfxCmdBufContext *)&m_resolvedSceneRt.m_surfaceID = v12;
  R_RT_Destroy((GfxCmdBufContext *)&m_resolvedSceneRt, (R_RT_ColorHandle *)&result);
}

/*
==============
RB_Draw3DOverlays
==============
*/
void RB_Draw3DOverlays(GfxCmdBufContext *gfxContext, const GfxBackEndData *data)
{
  int integer; 
  char v6; 
  unsigned int v7; 
  R_RT_Handle *v8; 
  __m256i *RTDraw3D; 
  bool v10; 
  int v11; 
  int IsOverlayEnabled; 
  int v13; 
  GfxViewInfo *v14; 
  GfxCmdBufState *state; 
  GfxCmdBufSourceState *source; 
  GfxCmdBufSourceState *v17; 
  R_RT_Handle v19; 
  unsigned int height; 
  const R_RT_Surface *Surface; 
  GfxCmdBufSourceState *v23; 
  const R_RT_ColorHandle *ColorArrayRtDraw3D; 
  R_RT_Handle v27; 
  GfxCmdBufContext v28; 
  R_RT_Handle v29; 
  GfxCmdBufContext v30; 
  GfxImage *umbraOcclusionScene; 
  GfxCmdBufSourceState *v32; 
  GfxCmdBufInput *p_input; 
  float value; 
  float v35; 
  float v36; 
  unsigned int reflectionProbeFrameIndex; 
  GfxViewInfo *viewInfo; 
  GfxCmdBufSourceState *v39; 
  R_RT_Handle v40; 
  bool v42; 
  unsigned int v43; 
  const R_RT_Surface *v44; 
  GfxCmdBufSourceState *v45; 
  const R_RT_ColorHandle *v48; 
  R_RT_Handle v49; 
  GfxCmdBufContext v50; 
  R_RT_Handle v51; 
  __int64 v52; 
  bool enabled; 
  __m256i v54; 
  R_RT_Handle v55; 
  int v56; 
  int v57; 
  R_RT_Handle v58; 
  signed int v59; 
  int v60; 
  int v61; 
  __m256i v62; 
  R_RT_Group v63; 
  R_RT_DepthHandle result; 
  R_RT_ColorHandle v65; 
  R_RT_DepthHandle v66; 
  R_RT_Group v67; 
  R_RT_Group rtGroup; 
  R_RT_Handle v69[3]; 

  integer = sm_showOverlay->current.integer;
  v6 = integer != 0;
  if ( data->viewInfoCount )
    v6 &= ~BYTE1(*((_DWORD *)&data->viewInfo[data->viewInfoIndex].viewportFeatures + 11));
  if ( v6 )
  {
    v7 = 0;
    v8 = v69;
    do
    {
      RTDraw3D = (__m256i *)R_SunShadowMapDebug_GetRTDraw3D(&result, v7++);
      ++v8;
      v8[-1] = *(R_RT_Handle *)RTDraw3D;
    }
    while ( v7 < 3 );
  }
  enabled = r_umbraShowOverlay->current.enabled;
  v10 = Physics_RenderDebugEnabled();
  v11 = r_decalVolumesShowAtlas->current.integer;
  v60 = v11;
  v56 = r_showHeightmap->current.integer;
  v57 = r_showFogSpline->current.integer;
  IsOverlayEnabled = RB_ReflectionProbe_IsOverlayEnabled();
  v61 = IsOverlayEnabled;
  v13 = r_showLightmap->current.integer;
  v59 = v13;
  if ( data->viewInfoCount )
  {
    v14 = &data->viewInfo[data->viewInfoIndex];
    if ( v6 || enabled || v10 || r_showPIPTexture->current.enabled || v13 >= 0 || v56 || v11 > 0 || v57 >= 0 || IsOverlayEnabled >= 0 )
    {
      state = gfxContext->state;
      source = gfxContext->source;
      v17 = gfxContext->source;
      rtGroup = state->rtGroup;
      _XMM0 = *(_OWORD *)&rtGroup.m_depthRt.m_tracking.m_location;
      R_InitCmdBufSourceState(v17, &v14->input);
      R_InitLocalCmdBufState(state, &source->input);
      v19 = *R_RT_GetGlobal(&result, R_RENDERTARGET_DISPLAY_BUFFER);
      v54 = (__m256i)v19;
      v55 = v19;
      if ( (_WORD)_XMM0 )
      {
        R_RT_Handle::GetSurface(&v55);
        if ( (R_RT_Handle::GetSurface(&v55)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
        {
          v19 = v55;
          v54 = (__m256i)v55;
          __debugbreak();
        }
        else
        {
          v19 = v55;
          v54 = (__m256i)v55;
        }
      }
      else
      {
        __asm { vpextrd rax, xmm0, 2 }
        if ( (_DWORD)_RAX )
        {
          v19 = (R_RT_Handle)v54;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
            __debugbreak();
        }
      }
      v55 = v19;
      height = R_RT_Handle::GetSurface(&v55)->m_image.m_base.height;
      Surface = R_RT_Handle::GetSurface(&v55);
      v23 = gfxContext->source;
      R_SetRenderTargetSize(gfxContext->source, Surface->m_image.m_base.width, height, GFX_USE_VIEWPORT_FOR_VIEW);
      v58 = (R_RT_Handle)v54;
      R_RT_Group::AssignColor(&v63, (R_RT_ColorHandle *)&v58);
      *(__m256i *)&v67.m_colorRtCount = *(__m256i *)&v63.m_colorRtCount;
      *(__m256i *)&v67.m_colorRts[0].m_tracking.m_location = *(__m256i *)&v63.m_colorRts[0].m_tracking.m_location;
      *(__m256i *)&v67.m_colorRts[1].m_tracking.m_location = *(__m256i *)&v63.m_colorRts[1].m_tracking.m_location;
      *(__m256i *)&v67.m_colorRts[2].m_tracking.m_location = *(__m256i *)&v63.m_colorRts[2].m_tracking.m_location;
      *(__m256i *)&v67.m_colorRts[3].m_tracking.m_location = *(__m256i *)&v63.m_colorRts[3].m_tracking.m_location;
      *(__m256i *)&v67.m_depthRt.m_tracking.m_location = *(__m256i *)&v63.m_depthRt.m_tracking.m_location;
      _XMM0 = *gfxContext;
      v67.m_vrsRt.m_tracking.m_location = v63.m_vrsRt.m_tracking.m_location;
      *(GfxCmdBufContext *)v54.m256i_i8 = _XMM0;
      R_SetRenderTargetsInternal((GfxCmdBufContext *)&v54, &v67, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(5353)");
      R_BeginViewInternal(v23, &v14->sceneDef, (const GfxViewParms *)v14, &v14->viewParmsSet.frames[1].viewParms);
      R_SetViewportStruct(v23, &v14->displayViewport);
      R_Set2D(v23);
      if ( v6 )
      {
        __asm { vpxor   xmm0, xmm0, xmm0 }
        v55.m_surfaceID = 0;
        v55.m_tracking.m_allocCounter = 0;
        *(_OWORD *)&v55.m_tracking.m_name = _XMM0;
        v54.m256i_i16[0] = 0;
        v54.m256i_i32[2] = 0;
        *(_OWORD *)&v54.m256i_u64[2] = _XMM0;
        result = *R_SunShadowCache_GetDepthArrayRtDraw3D(&v66);
        ColorArrayRtDraw3D = R_SpotShadow_StaleCacheEntry::GetColorArrayRtDraw3D(&v65);
        v27 = v69[0];
        v28 = *gfxContext;
        v58 = v69[0];
        v29 = ColorArrayRtDraw3D->R_RT_Handle;
        v62 = *(__m256i *)ColorArrayRtDraw3D;
        if ( (unsigned int)(integer - 1) > 6 )
        {
          LODWORD(v52) = integer;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 4818, ASSERT_TYPE_ASSERT, "( ( overlayStyle >= GFX_SM_OVERLAY_SUN && overlayStyle < GFX_SM_OVERLAY_COUNT ) )", "( overlayStyle ) = %i", v52) )
            __debugbreak();
          v27 = v58;
          v29 = (R_RT_Handle)v62;
        }
        if ( integer > 4 )
        {
          result = v14->spotshadowActiveCache;
          v58 = v29;
          *(GfxCmdBufContext *)v54.m256i_i8 = v28;
          R_SpotShadow_DrawOverlay((GfxCmdBufContext *)&v54, integer, (const R_RT_ColorHandle *)&v58, &result);
        }
        else
        {
          v58 = v55;
          v62 = v54;
          v55 = v27;
          *(GfxCmdBufContext *)v54.m256i_i8 = v28;
          R_Sunshadow_DrawOverlay((GfxCmdBufContext *)&v54, v14, integer, v69, 3u, &v55, &result, NULL, (R_RT_BufferHandle *)&v62, &v58);
        }
      }
      if ( enabled )
      {
        v30 = *gfxContext;
        umbraOcclusionScene = rgp.umbraOcclusionScene;
        v32 = gfxContext->source;
        if ( !gfxContext->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
          __debugbreak();
        p_input = &v32->input;
        if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
          __debugbreak();
        p_input->codeImages[4] = umbraOcclusionScene;
        value = r_umbraShowOverlayDisplaySizeScale->current.value;
        v35 = (float)umbraOcclusionScene->height * value;
        v36 = (float)umbraOcclusionScene->width * value;
        *(GfxCmdBufContext *)v54.m256i_i8 = v30;
        RB_DrawStretchPic((GfxCmdBufContext *)&v54, rgp.feedbackReplaceBackbufferMaterial, 64.0, 64.0, v36, v35, 0.0, 1.0, 1.0, 0.0, 0xFFFFFFFF, GFX_PRIM_STATS_HUD);
        *(GfxCmdBufContext *)v54.m256i_i8 = v30;
        RB_EndTessSurfaceInternal((GfxCmdBufContext *)&v54, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(4771)");
      }
      *(GfxCmdBufContext *)v54.m256i_i8 = *gfxContext;
      Physics_RenderDebugOverlays((GfxCmdBufContext *)&v54);
      if ( v59 >= 0 )
      {
        *(GfxCmdBufContext *)v54.m256i_i8 = *gfxContext;
        RB_DrawLightmapOverlap((GfxCmdBufContext *)&v54, data, v59);
      }
      if ( v56 )
      {
        *(GfxCmdBufContext *)v54.m256i_i8 = *gfxContext;
        RB_DrawHeightmapOverlay((GfxCmdBufContext *)&v54);
      }
      if ( v60 )
      {
        *(GfxCmdBufContext *)v54.m256i_i8 = *gfxContext;
        RB_DecalVolumes_ShowAtlas((GfxCmdBufContext *)&v54, v60);
      }
      if ( v57 >= 0 )
      {
        *(GfxCmdBufContext *)v54.m256i_i8 = *gfxContext;
        RB_DrawFogSplineOverlap((GfxCmdBufContext *)&v54, v14, v57);
      }
      if ( v61 >= 0 )
      {
        reflectionProbeFrameIndex = data->reflectionProbeFrameIndex;
        *(GfxCmdBufContext *)v54.m256i_i8 = *gfxContext;
        RB_ReflectionProbe_Overlay((GfxCmdBufContext *)&v54, reflectionProbeFrameIndex, v61);
      }
      _XMM0 = *gfxContext;
      *(GfxCmdBufContext *)v54.m256i_i8 = *gfxContext;
      R_SetRenderTargetsInternal((GfxCmdBufContext *)&v54, &rtGroup, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(5417)");
      R_ShutdownLocalCmdBufState(gfxContext->state, &gfxContext->source->input);
    }
  }
  if ( data->pipInfoCount )
  {
    viewInfo = data->viewInfo;
    v39 = gfxContext->source;
    R_InitCmdBufSourceState(gfxContext->source, &viewInfo[5].input);
    R_InitLocalCmdBufState(gfxContext->state, &v39->input);
    v40 = *R_RT_GetGlobal(&v65, R_RENDERTARGET_DISPLAY_BUFFER);
    v54 = (__m256i)v40;
    v55 = v40;
    if ( LOWORD(_XMM0.source) )
    {
      R_RT_Handle::GetSurface(&v55);
      if ( (R_RT_Handle::GetSurface(&v55)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        v40 = v55;
        v54 = (__m256i)v55;
        __debugbreak();
      }
      else
      {
        v40 = v55;
        v54 = (__m256i)v55;
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v42 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        v40 = (R_RT_Handle)v54;
        if ( v42 )
          __debugbreak();
      }
    }
    v58 = v40;
    v43 = R_RT_Handle::GetSurface(&v58)->m_image.m_base.height;
    v44 = R_RT_Handle::GetSurface(&v58);
    v45 = gfxContext->source;
    R_SetRenderTargetSize(gfxContext->source, v44->m_image.m_base.width, v43, GFX_USE_VIEWPORT_FOR_VIEW);
    result = (R_RT_DepthHandle)v54;
    R_RT_Group::AssignColor(&rtGroup, (R_RT_ColorHandle *)&result);
    *(__m256i *)&v67.m_colorRtCount = *(__m256i *)&rtGroup.m_colorRtCount;
    *(__m256i *)&v67.m_colorRts[0].m_tracking.m_location = *(__m256i *)&rtGroup.m_colorRts[0].m_tracking.m_location;
    *(__m256i *)&v67.m_colorRts[1].m_tracking.m_location = *(__m256i *)&rtGroup.m_colorRts[1].m_tracking.m_location;
    *(__m256i *)&v67.m_colorRts[2].m_tracking.m_location = *(__m256i *)&rtGroup.m_colorRts[2].m_tracking.m_location;
    *(__m256i *)&v67.m_colorRts[3].m_tracking.m_location = *(__m256i *)&rtGroup.m_colorRts[3].m_tracking.m_location;
    *(__m256i *)&v67.m_depthRt.m_tracking.m_location = *(__m256i *)&rtGroup.m_depthRt.m_tracking.m_location;
    _XMM0 = *gfxContext;
    v67.m_vrsRt.m_tracking.m_location = rtGroup.m_vrsRt.m_tracking.m_location;
    *(GfxCmdBufContext *)v54.m256i_i8 = _XMM0;
    R_SetRenderTargetsInternal((GfxCmdBufContext *)&v54, &v67, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(5432)");
    R_BeginViewInternal(v45, &viewInfo[5].sceneDef, (const GfxViewParms *)&viewInfo[5], &viewInfo[5].viewParmsSet.frames[1].viewParms);
    R_SetViewportStruct(v45, &viewInfo[5].displayViewport);
    R_Set2D(v45);
    if ( v6 )
    {
      __asm { vpxor   xmm0, xmm0, xmm0 }
      v55.m_surfaceID = 0;
      *(_OWORD *)&v55.m_tracking.m_name = _XMM0;
      *(_OWORD *)&v54.m256i_u64[2] = _XMM0;
      v55.m_tracking.m_allocCounter = 0;
      v54.m256i_i16[0] = 0;
      v54.m256i_i32[2] = 0;
      result = *R_SunShadowCache_GetDepthArrayRtDraw3D((R_RT_DepthHandle *)&v65);
      v48 = R_SpotShadow_StaleCacheEntry::GetColorArrayRtDraw3D((const R_RT_ColorHandle *)&v66);
      v49 = v69[0];
      v50 = *gfxContext;
      v62 = (__m256i)v69[0];
      v51 = v48->R_RT_Handle;
      v58 = v48->R_RT_Handle;
      if ( integer < 1 || integer >= 8 )
      {
        LODWORD(v52) = integer;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 4818, ASSERT_TYPE_ASSERT, "( ( overlayStyle >= GFX_SM_OVERLAY_SUN && overlayStyle < GFX_SM_OVERLAY_COUNT ) )", "( overlayStyle ) = %i", v52) )
          __debugbreak();
        v49 = (R_RT_Handle)v62;
        v51 = v58;
      }
      if ( integer > 4 )
      {
        result = viewInfo[5].spotshadowActiveCache;
        v58 = v51;
        *(GfxCmdBufContext *)v54.m256i_i8 = v50;
        R_SpotShadow_DrawOverlay((GfxCmdBufContext *)&v54, integer, (const R_RT_ColorHandle *)&v58, &result);
      }
      else
      {
        v58 = v55;
        v62 = v54;
        v55 = v49;
        *(GfxCmdBufContext *)v54.m256i_i8 = v50;
        R_Sunshadow_DrawOverlay((GfxCmdBufContext *)&v54, viewInfo + 5, integer, v69, 3u, &v55, &result, NULL, (R_RT_BufferHandle *)&v62, &v58);
      }
    }
    R_ShutdownLocalCmdBufState(gfxContext->state, &v45->input);
  }
}

/*
==============
RB_Draw3DScene
==============
*/
void RB_Draw3DScene(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  signed __int64 v3; 
  void *v5; 
  GfxCmdBufContext v8; 
  const GfxBackEndData *v9; 
  GfxCmdBufState *v10; 
  int v11; 
  R_RT_BufferHandle *v12; 
  GfxBackEndData *v13; 
  GfxCmdBufState *v14; 
  GfxCmdBufContext v15; 
  GfxCmdBufContext v16; 
  __int64 v17; 
  GfxCmdBufContext v18; 
  GfxCmdBufContext v19; 
  GfxCmdBufContext v20; 
  GfxCmdBufContext v21; 
  GfxCmdBufContext v22; 
  GfxCmdBufContext v23; 
  GfxCmdBufContext v24; 
  GfxCmdBufContext v25; 
  GfxCmdBufContext v26; 
  GfxBackEndData *v27; 
  char v30; 
  GfxCmdBufContext v31; 
  const dvar_t *v32; 
  R_RT_Flags v33; 
  unsigned int height; 
  const R_RT_Surface *Surface; 
  R_RT_Handle v36; 
  bool v38; 
  ComputeCmdBufState *GfxComputeCmdBufState; 
  GfxCmdBufSourceState *v41; 
  GfxCmdBufContext v42; 
  GfxCmdBufContext v43; 
  GfxCmdBufState *v44; 
  __m256i v45; 
  bool v47; 
  __m256i m_floatZFullRt; 
  __m256i v50; 
  __m256i v51; 
  __m256i v53; 
  GfxCmdBufContext v54; 
  GfxCmdBufContext v55; 
  GfxCmdBufContext v56; 
  __m256i v59; 
  R_RT_Handle v63; 
  GfxCmdBufContext v65; 
  GfxCmdBufContext v66; 
  GfxCmdBufSourceState *v67; 
  GfxCmdBufState *v68; 
  const GfxImage *Image; 
  GfxBackEndData *v70; 
  __m256i v71; 
  const void *v72; 
  GfxCmdBufState *v73; 
  GfxCmdBufContext v74; 
  GfxCmdBufContext v75; 
  GfxCmdBufContext v76; 
  GfxCmdBufContext v77; 
  const GfxViewInfo *v78; 
  GfxViewParms *p_viewParms; 
  __m256i v80; 
  vec4_t v81; 
  GfxBackEndData *v82; 
  volatile int *p_inCmdCount; 
  int *cmdBufValid; 
  __int64 rtFlagsInternal; 
  GfxBackEndData *dataa; 
  bool v87; 
  GfxBackEndData *timeoutUserData; 
  GfxBackEndData *v89; 
  GfxCmdBufInput *input; 
  GfxImage *extinction; 
  GfxImage *scattering; 
  R_RT_ColorHandle v93; 
  ID3D12Resource *buffers; 
  GfxBackEndData *v95; 
  ID3D12Resource *buffer; 
  ID3D12Resource *v97; 
  ID3D12Resource *v98; 
  ID3D12Resource *v99; 
  ID3D12Resource *v100; 
  GfxBackEndData *v101; 
  GfxDevice *device; 
  GfxCmdBufSourceState *source[2]; 
  __m256i v104; 
  R_RT_Handle v105; 
  R_RT_Handle v106; 
  R_RT_Handle v107; 
  __m256i v108; 
  GfxImage *visibility; 
  GfxCmdBufContext v110; 
  GfxCmdBufContext v111; 
  GfxCmdBufContext v112; 
  GfxCmdBufContext v113; 
  GfxCmdBufContext v114; 
  GfxCmdBufContext v115; 
  GfxCmdBufContext v116; 
  GfxCmdBufContext v117; 
  GfxCmdBufContext v118; 
  GfxCmdBufContext v119; 
  GfxCmdBufContext v120; 
  GfxCmdBufContext v121; 
  GfxCmdBufContext v122; 
  GfxCmdBufContext v123; 
  GfxCmdBufContext v124; 
  GfxCmdBufContext v125; 
  GfxCmdBufContext v126; 
  GfxCmdBufContext v127; 
  GfxCmdBufContext v128; 
  GfxCmdBufContext v129; 
  GfxCmdBufContext v130; 
  GfxCmdBufContext v131; 
  GfxCmdBufContext v132; 
  GfxCmdBufContext v133; 
  GfxCmdBufContext v134; 
  GfxCmdBufContext v135; 
  GfxCmdBufContext v136; 
  GfxCmdBufContext v137; 
  GfxCmdBufContext v138; 
  GfxCmdBufContext v139; 
  GfxCmdBufContext v140; 
  GfxCmdBufContext v141; 
  GfxCmdBufContext v142; 
  GfxCmdBufContext v143; 
  GfxCmdBufContext v144; 
  GfxCmdBufContext v145; 
  GfxCmdBufContext v146; 
  GfxCmdBufContext v147; 
  GfxCmdBufContext v148; 
  GfxCmdBufContext v149; 
  GfxCmdBufContext v150; 
  GfxCmdBufContext v151; 
  GfxCmdBufContext v152; 
  GfxCmdBufContext v153; 
  GfxCmdBufContext v154; 
  GfxCmdBufContext v155; 
  GfxCmdBufContext v156; 
  GfxCmdBufContext v157; 
  GfxCmdBufContext v158; 
  GfxCmdBufContext v159; 
  GfxCmdBufContext v160; 
  GfxCmdBufContext v161; 
  GfxCmdBufContext v162; 
  GfxCmdBufContext v163; 
  GfxCmdBufContext v164; 
  GfxCmdBufContext v165; 
  GfxCmdBufContext v166; 
  GfxCmdBufContext v167; 
  GfxCmdBufContext v168; 
  GfxCmdBufContext v169; 
  GfxCmdBufContext v170; 
  GfxCmdBufContext v171; 
  R_RT_ColorHandle v172; 
  R_RT_ColorHandle v173; 
  R_RT_Handle v174; 
  R_RT_ColorHandle m_ssaoRt; 
  R_RT_BufferHandle m_gpIndexBuffer; 
  R_RT_BufferHandle m_gpIndirectArgsBuffer; 
  R_RT_ColorHandle m_mainSceneColorRt; 
  R_RT_ColorHandle m_mainSceneAlphaRt; 
  R_RT_ColorHandle m_mainSceneEntityIDVelocityRt; 
  R_RT_ColorHandle m_mainSceneTangentFrameRt; 
  R_RT_DepthHandle m_mainSceneDepthRt; 
  R_RT_BufferHandle m_gpSubMeshCountBuffer; 
  R_RT_ColorHandle m_mdaoRt; 
  R_RT_ColorHandle v185; 
  R_RT_ColorHandle v186; 
  R_RT_DepthHandle v187; 
  R_RT_ColorHandle v188; 
  R_RT_DepthHandle v189; 
  R_RT_BufferHandle m_gpBatchSubMeshOffsetsBuffer; 
  R_RT_BufferHandle m_gpSubMeshWorkgroupArgsBuffer; 
  R_RT_BufferHandle m_gpPerSurfDataBuffer; 
  R_RT_BufferHandle m_gpClusterPassIndirectArgsBuffer; 
  R_RT_BufferHandle m_gpClusterPPSumIndirectArgsBuffer; 
  R_RT_BufferHandle m_gpPrevCulledSubMeshBuffer; 
  R_RT_BufferHandle m_gpPrevSubMeshClusterOffsetsBuffer; 
  R_RT_BufferHandle m_gpPrevCulledTriClusterBuffer; 
  R_RT_ColorHandle v198; 
  R_RT_Handle v199; 
  R_RT_ColorHandle m_mainSceneSSSAlbedoRt; 
  R_RT_ColorHandle m_mainSceneSSSDiffuseRt; 
  R_RT_ColorHandle v202; 
  R_RT_ColorHandle v203; 
  R_RT_ColorHandle v204; 
  R_RT_ColorHandle v205; 
  R_RT_ColorHandle v206; 
  R_RT_ColorHandle v207; 
  __m256i v208; 
  R_RT_ColorHandle v209; 
  __m256i v210; 
  __m256i v211; 
  __m256i v212; 
  R_RT_ColorHandle v213; 
  __m256i v214; 
  R_RT_ColorHandle v215; 
  R_RT_ColorHandle v216; 
  R_RT_DepthHandle v217; 
  R_RT_DepthHandle v218; 
  __m256i v219; 
  R_RT_Handle v220; 
  R_RT_Handle v221; 
  R_RT_ColorHandle m_lightGridVolumeData3D; 
  R_RT_ColorHandle m_lightGridVolumeHighBandsData3D; 
  R_RT_DepthHandle v224; 
  __m256i v225; 
  R_RT_DepthHandle v226; 
  R_RT_ColorHandle v227; 
  R_RT_ColorHandle v228; 
  R_RT_DepthHandle v229; 
  R_RT_Handle v230; 
  R_RT_Handle v231; 
  GfxGPConfig v232; 
  GfxGPConfig v233; 
  GfxGPConfig v234; 
  R_RT_BufferHandle result; 
  R_RT_BufferHandle v236; 
  R_RT_BufferHandle v237; 
  R_RT_BufferHandle v238; 
  R_RT_BufferHandle v239; 
  R_RT_BufferHandle v240; 
  R_RT_BufferHandle v241; 
  R_RT_BufferHandle v242; 
  R_RT_Group rtGroup; 
  ComputeCmdBufState state; 
  ComputeCmdBufState v245; 
  ComputeCmdBufState computeState; 
  ComputeCmdBufState v247; 
  ComputeCmdBufState v248; 
  ComputeCmdBufState v249; 

  v5 = alloca(v3);
  dataa = (GfxBackEndData *)data;
  R_RT_BackendPassBegin(viewInfo->sceneRtInput.m_pass);
  v8 = *gfxContext;
  timeoutUserData = dataa;
  Profile2_UpdateEntry(48);
  if ( ((unsigned __int8)&dword_14FDE8090 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE8090) )
    __debugbreak();
  _InterlockedIncrement(&dword_14FDE8090);
  v9 = timeoutUserData;
  if ( !timeoutUserData->compute.smpEnabled )
  {
    Sys_ProfBeginNamedEvent(0xFFFFA500, "wait compute ready");
    Sys_ProcessWorkerCmdsWithTimeout(RB_IsComputeReady, &timeoutUserData);
    Sys_WaitWorkerCmdsOfType(WRKCMD_UGB_MAKE_XSURFS_RESIDENT_DISPATCH);
    Sys_WaitWorkerCmdsOfType(WRKCMD_INIT_UGB_BACKEND);
    Sys_ProfEndNamedEvent();
    v9 = timeoutUserData;
  }
  v110 = v8;
  R_FinishComputeCmdList(&v110, v9);
  Profile2_UpdateEntry(48);
  if ( ((unsigned __int64)&dword_14FDE8090 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 44, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE8090) )
    __debugbreak();
  _InterlockedDecrement(&dword_14FDE8090);
  Profile_BeginCSV(23);
  v111 = *gfxContext;
  RB_StartDraw3DScene(&v111, viewInfo, dataa);
  v112 = *gfxContext;
  R_ClearGlobalRTsAsRequired(&v112, viewInfo);
  v10 = gfxContext->state;
  RB_AddComputeCmdsTransitions(v10, dataa, 1);
  m_mainSceneColorRt = viewInfo->sceneRtInput.m_mainSceneColorRt;
  R_AddRenderTargetTransition(v10, &m_mainSceneColorRt, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  m_mainSceneAlphaRt = viewInfo->sceneRtInput.m_mainSceneAlphaRt;
  R_AddRenderTargetTransition(v10, &m_mainSceneAlphaRt, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  m_mainSceneEntityIDVelocityRt = viewInfo->sceneRtInput.m_mainSceneEntityIDVelocityRt;
  R_AddRenderTargetTransition(v10, &m_mainSceneEntityIDVelocityRt, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  m_mainSceneTangentFrameRt = viewInfo->sceneRtInput.m_mainSceneTangentFrameRt;
  R_AddRenderTargetTransition(v10, &m_mainSceneTangentFrameRt, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  m_mainSceneDepthRt = viewInfo->sceneRtInput.m_mainSceneDepthRt;
  R_AddDepthStencilTransition(v10, &m_mainSceneDepthRt, DEPTHSTENCIL_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  R_FlushResourceTransitions(v10);
  v11 = 0;
  viewInfo->sceneRtInput.m_gpBatchSubMeshOffsetsBuffer = *R_RT_CreateBufferInternal(&result, 4u, 0x4001u, GFX_DATA_FORMAT_R32_UINT, R_RT_Flag_BufferRaw|R_RT_Flag_RWView, R_RT_FlagInternal_None, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, "Batch SubMesh Offsets Buffer", 0, NULL, NULL, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(3993)");
  viewInfo->sceneRtInput.m_gpSubMeshWorkgroupArgsBuffer = *R_RT_CreateBufferInternal(&v236, 4u, 0x10000u, GFX_DATA_FORMAT_R32_UINT, R_RT_Flag_BufferRaw|R_RT_Flag_RWView, R_RT_FlagInternal_None, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, "SubMesh Workgroup Args Buffer", 0, NULL, NULL, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(3994)");
  viewInfo->sceneRtInput.m_gpSubMeshCountBuffer = *R_RT_CreateBufferInternal(&v237, 4u, 1u, GFX_DATA_FORMAT_R32_UINT, R_RT_Flag_BufferRaw|R_RT_Flag_RWView, R_RT_FlagInternal_None, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, "SubMesh Count Buffer", 0, NULL, NULL, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(3995)");
  viewInfo->sceneRtInput.m_gpClusterPassIndirectArgsBuffer = *R_RT_CreateBufferInternal(&v238, 0xCu, 1u, GFX_DATA_FORMAT_R32_UINT, R_RT_Flag_BufferIndirectArgs|R_RT_Flag_BufferRaw|R_RT_Flag_RWView, R_RT_FlagInternal_None, D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT, "Cluster Pass Indirect Args Buffer", 0, NULL, NULL, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(3996)");
  viewInfo->sceneRtInput.m_gpClusterPPSumIndirectArgsBuffer = *R_RT_CreateBufferInternal(&v239, 0xCu, 1u, GFX_DATA_FORMAT_R32_UINT, R_RT_Flag_BufferIndirectArgs|R_RT_Flag_BufferRaw|R_RT_Flag_RWView, R_RT_FlagInternal_None, D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT, "Cluster Pass PPSum Indirect Args Buffer", 0, NULL, NULL, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(3997)");
  viewInfo->sceneRtInput.m_gpPrevCulledSubMeshBuffer = *R_RT_CreateBufferInternal(&v240, 8u, 0x10000u, GFX_DATA_FORMAT_R32_UINT, R_RT_Flag_BufferStructured|R_RT_Flag_RWView, R_RT_FlagInternal_None, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, "Prev Culled SubMesh Buffer", 0, NULL, NULL, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(3998)");
  viewInfo->sceneRtInput.m_gpPrevSubMeshClusterOffsetsBuffer = *R_RT_CreateBufferInternal(&v241, 4u, 0x10001u, GFX_DATA_FORMAT_R32_UINT, R_RT_Flag_BufferRaw|R_RT_Flag_RWView, R_RT_FlagInternal_None, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, "Prev SubMesh Cluster Offsets Buffer", 0, NULL, NULL, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(3999)");
  v12 = R_RT_CreateBufferInternal(&v242, 8u, 0x40000u, GFX_DATA_FORMAT_R32_UINT, R_RT_Flag_BufferStructured|R_RT_Flag_RWView, R_RT_FlagInternal_None, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, "Prev Culled Tri Cluster Buffer", 0, NULL, NULL, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(4000)");
  v13 = dataa;
  v234.passIndex = GFX_GP_PASS_SHADOWS;
  *(_WORD *)&v234.occlusionPass = 0;
  viewInfo->sceneRtInput.m_gpPrevCulledTriClusterBuffer = *v12;
  v113 = *gfxContext;
  v234.reusePrepassVisData = 0;
  RB_GP_ProcessSurfs(&v113, viewInfo, v13, &v234);
  R_InitComputeCmdBufState(&state, dataa, COMPUTE_CONTEXT_TYPE_ASYNC_BACKEND);
  buffers = dataa->globalSceneConstantBuffer->buffer;
  R_SetComputeConstantBuffers(&state, 7, 1, &buffers);
  R_ComputeWaitForGraphics(&state, v10);
  RB_VOL_EvaluateLightgrid(&state, viewInfo, dataa);
  RB_ReflectionProbe_ProcessView(&state, viewInfo, dataa);
  if ( rg.useLightGridVolumes )
    RB_LGV_SampleLighting(&state, dataa, viewInfo);
  R_LockGfxImmediateContext();
  R_ComputeWaitForCompute(&state, PIPE_FLUSH_PARTIAL);
  RB_ReProjFloatZ_Resources(&state, viewInfo);
  RB_VOL_Cluster(&state, viewInfo, dataa);
  RB_UniversalClut_Generate(&state, viewInfo, dataa);
  R_UnlockGfxImmediateContext();
  R_ShutdownComputeCmdBufState(&state);
  v114 = *gfxContext;
  RB_StandardDrawCommands_Shadows(&v114, viewInfo, dataa);
  R_InitCmdBufSourceState(gfxContext->source, &viewInfo->input);
  v115 = *gfxContext;
  R_SetAndClearSceneTarget(&v115, viewInfo);
  v95 = dataa;
  Profile2_UpdateEntry(51);
  if ( ((unsigned __int8)&dword_14FDE809C & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE809C) )
    __debugbreak();
  _InterlockedIncrement(&dword_14FDE809C);
  Sys_ProfBeginNamedEvent(0xFFFFA500, "wait opaque ready");
  Sys_ProcessWorkerCmdsWithTimeout(RB_IsOpaqueReady, &v95);
  Sys_ProfEndNamedEvent();
  Profile2_UpdateEntry(51);
  if ( ((unsigned __int64)&dword_14FDE809C & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 44, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE809C) )
    __debugbreak();
  _InterlockedDecrement(&dword_14FDE809C);
  v116 = *gfxContext;
  RB_SetupFrustumLights(&v116, viewInfo, dataa);
  v117 = *gfxContext;
  RB_RenderFrustumLightsCluster(&v117, viewInfo, dataa);
  v14 = gfxContext->state;
  R_WaitAsyncCompute(v14, dataa, COMPUTE_CONTEXT_TYPE_ASYNC_BACKEND, 0);
  v15 = *gfxContext;
  v233.passIndex = GFX_GP_PASS_CAMERA;
  *(_WORD *)&v233.occlusionPass = 0;
  v118 = v15;
  v233.reusePrepassVisData = 0;
  RB_GP_ProcessSurfs(&v118, viewInfo, dataa, &v233);
  R_InitComputeCmdBufState(&computeState, dataa, COMPUTE_CONTEXT_TYPE_ASYNC_BACKEND);
  buffer = dataa->globalSceneConstantBuffer->buffer;
  R_SetComputeConstantBuffers(&computeState, 7, 1, &buffer);
  R_LockGfxImmediateContext();
  R_ComputeWaitForCompute(&computeState, PIPE_FLUSH_PARTIAL);
  R_ComputeWaitForGraphics(&computeState, v14);
  if ( R_GetSSAOMode(viewInfo) )
  {
    m_ssaoRt = viewInfo->sceneRtInput.m_ssaoRt;
    R_ClearColorTargetAsync(&computeState, &m_ssaoRt);
  }
  if ( (R_GetSSAOMode(viewInfo) & 2) != 0 )
  {
    m_mdaoRt = viewInfo->sceneRtInput.m_mdaoRt;
    R_ClearColorTargetAsync(&computeState, &m_mdaoRt);
  }
  RB_LightSensor_Process(&computeState, viewInfo, dataa);
  R_UnlockGfxImmediateContext();
  R_ShutdownComputeCmdBufState(&computeState);
  Sys_ProfBeginNamedEvent(0xFFFFD700, "exec cmds opaque");
  Profile2_UpdateEntry(52);
  input = (GfxCmdBufInput *)((unsigned __int64)&dword_14FDE80A0 & 3);
  if ( ((unsigned __int8)&dword_14FDE80A0 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE80A0) )
  {
    __debugbreak();
    v14 = gfxContext->state;
  }
  _InterlockedIncrement(&dword_14FDE80A0);
  v119 = *gfxContext;
  RB_DrawPrepass(&v119, viewInfo, dataa);
  R_LockGfxImmediateContext();
  v120 = *gfxContext;
  RB_ResolveFloatZFull(&v120, viewInfo);
  v185 = viewInfo->sceneRtInput.m_mainSceneTangentFrameRt;
  R_AddRenderTargetTransition(v14, &v185, RENDERTARGET_TRANSITION_MODE_READ, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  v186 = viewInfo->sceneRtInput.m_mainSceneEntityIDVelocityRt;
  R_AddRenderTargetTransition(v14, &v186, RENDERTARGET_TRANSITION_MODE_READ, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  v187 = viewInfo->sceneRtInput.m_mainSceneDepthRt;
  R_AddDepthStencilTransition(v14, &v187, DEPTHSTENCIL_TRANSITION_MODE_READ_PRESERVE_DEPTH_COMPRESSION, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  R_FlushResourceTransitions(v14);
  R_UnlockGfxImmediateContext();
  if ( (R_GetSSAOMode(viewInfo) & 2) != 0 )
  {
    v16 = *gfxContext;
    v188 = viewInfo->sceneRtInput.m_mdaoRt;
    v121 = v16;
    RB_MDAO_DrawVolumeOccluders(&v121, viewInfo, dataa, &v188);
  }
  R_InitComputeCmdBufState(&v245, dataa, COMPUTE_CONTEXT_TYPE_ASYNC_BACKEND);
  v97 = dataa->globalSceneConstantBuffer->buffer;
  R_SetComputeConstantBuffers(&v245, 7, 1, &v97);
  R_LockGfxImmediateContext();
  R_ComputeWaitForGraphics(&v245, v14);
  RB_VOL_EvaluateVolumetricsScattering(&v245, viewInfo, dataa);
  RB_CompositeStaticVelocity(&v245, viewInfo);
  if ( (R_GetSSAOMode(viewInfo) & 2) != 0 )
    RB_MDAO_Generate(&v245, viewInfo, dataa);
  if ( (R_GetSSAOMode(viewInfo) & 1) != 0 )
    RB_SSAO_Generate(&v245, viewInfo, dataa, viewInfo->ssao.splitZones ? SSAO_ZONE_SCENE : SSAO_ZONE_ALL);
  if ( !viewInfo->ssao.splitZones )
  {
    v122 = *gfxContext;
    RB_SSAO_RotateRTs(&v122, viewInfo);
  }
  RB_MayhemSelfVis_UpdateAnimBuffer(&v245, dataa);
  if ( (unsigned __int8)R_GetSSRMode(viewInfo) >= GFX_SSR_DEFERRED_LQ )
    RB_SSR_DeferredTrace(&v245, viewInfo, dataa);
  R_UnlockGfxImmediateContext();
  R_ShutdownComputeCmdBufState(&v245);
  v17 = 3i64;
  v189 = viewInfo->sceneRtInput.m_mainSceneDepthRt;
  R_AddDepthStencilTransition(v14, &v189, DEPTHSTENCIL_TRANSITION_MODE_WRITE_PRESERVE_DEPTH_COMPRESSION, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  R_FlushResourceTransitions(v14);
  if ( rg.gpuCullOcclusion )
  {
    v18 = *gfxContext;
    v232.reusePrepassVisData = rg.gpuCullReusePrepassVisData;
    v123 = v18;
    v232.passIndex = GFX_GP_PASS_CAMERA;
    *(_WORD *)&v232.occlusionPass = 257;
    RB_GP_ProcessSurfs(&v123, viewInfo, dataa, &v232);
  }
  v19 = *gfxContext;
  m_gpBatchSubMeshOffsetsBuffer = viewInfo->sceneRtInput.m_gpBatchSubMeshOffsetsBuffer;
  v124 = v19;
  R_RT_Destroy(&v124, &m_gpBatchSubMeshOffsetsBuffer);
  v20 = *gfxContext;
  m_gpSubMeshWorkgroupArgsBuffer = viewInfo->sceneRtInput.m_gpSubMeshWorkgroupArgsBuffer;
  v125 = v20;
  R_RT_Destroy(&v125, &m_gpSubMeshWorkgroupArgsBuffer);
  v21 = *gfxContext;
  m_gpSubMeshCountBuffer = viewInfo->sceneRtInput.m_gpSubMeshCountBuffer;
  v126 = v21;
  R_RT_Destroy(&v126, &m_gpSubMeshCountBuffer);
  v22 = *gfxContext;
  m_gpClusterPassIndirectArgsBuffer = viewInfo->sceneRtInput.m_gpClusterPassIndirectArgsBuffer;
  v127 = v22;
  R_RT_Destroy(&v127, &m_gpClusterPassIndirectArgsBuffer);
  v23 = *gfxContext;
  m_gpClusterPPSumIndirectArgsBuffer = viewInfo->sceneRtInput.m_gpClusterPPSumIndirectArgsBuffer;
  v128 = v23;
  R_RT_Destroy(&v128, &m_gpClusterPPSumIndirectArgsBuffer);
  v24 = *gfxContext;
  m_gpPrevCulledSubMeshBuffer = viewInfo->sceneRtInput.m_gpPrevCulledSubMeshBuffer;
  v129 = v24;
  R_RT_Destroy(&v129, &m_gpPrevCulledSubMeshBuffer);
  v25 = *gfxContext;
  m_gpPrevSubMeshClusterOffsetsBuffer = viewInfo->sceneRtInput.m_gpPrevSubMeshClusterOffsetsBuffer;
  v130 = v25;
  R_RT_Destroy(&v130, &m_gpPrevSubMeshClusterOffsetsBuffer);
  v26 = *gfxContext;
  m_gpPrevCulledTriClusterBuffer = viewInfo->sceneRtInput.m_gpPrevCulledTriClusterBuffer;
  v131 = v26;
  R_RT_Destroy(&v131, &m_gpPrevCulledTriClusterBuffer);
  v27 = dataa;
  if ( dataa->activePrimarySunLight && (*((_BYTE *)&viewInfo->viewportFeatures + 44) & 4) != 0 )
  {
    v132 = *gfxContext;
    RB_SunShadow_GenerateFullScreenVisibility(&v132, viewInfo, dataa);
    v27 = dataa;
  }
  v133 = *gfxContext;
  RB_FillFrustumGrid(&v133, viewInfo, v27);
  v134 = *gfxContext;
  RB_DecalVolumes_UpdateAtlas(&v134, dataa);
  _XMM0 = *gfxContext;
  v135 = *gfxContext;
  RB_RenderFrustumLightsTile(&v135, viewInfo, dataa);
  R_WaitAsyncCompute(v14, dataa, COMPUTE_CONTEXT_TYPE_ASYNC_BACKEND, 0);
  __asm { vpxor   xmm0, xmm0, xmm0 }
  v87 = R_SSS_Enabled(viewInfo);
  *(GfxCmdBufContext *)&v93.m_tracking.m_name = _XMM0;
  v30 = v87;
  v93.m_surfaceID = 0;
  v93.m_tracking.m_allocCounter = 0;
  R_InitComputeCmdBufState(&v247, dataa, COMPUTE_CONTEXT_TYPE_ASYNC_BACKEND);
  v98 = dataa->globalSceneConstantBuffer->buffer;
  R_SetComputeConstantBuffers(&v247, 7, 1, &v98);
  R_LockGfxImmediateContext();
  R_ComputeWaitForGraphics(&v247, v14);
  R_SetComputeLimitsAbsolute(&v247, COMPUTECMD_SIMD_WALK_DEFAULT, 0, 5u, 0);
  if ( viewInfo->ssao.splitZones )
  {
    if ( (R_GetSSAOMode(viewInfo) & 1) != 0 )
      RB_SSAO_Generate(&v247, viewInfo, dataa, SSAO_ZONE_VIEW_MODEL);
    _XMM0 = *gfxContext;
    v136 = *gfxContext;
    RB_SSAO_RotateRTs(&v136, viewInfo);
  }
  if ( (R_GetSSAOMode(viewInfo) & 2) != 0 )
  {
    v31 = *gfxContext;
    v198 = viewInfo->sceneRtInput.m_mdaoRt;
    v137 = v31;
    R_RT_Destroy(&v137, &v198);
  }
  if ( v87 )
  {
    if ( Dvar_GetBool_Internal(r_deviceDebug) )
      goto LABEL_51;
    v32 = DCONST_DVARBOOL_r_esramPostFX;
    if ( !DCONST_DVARBOOL_r_esramPostFX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "r_esramPostFX") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v32);
    v33 = R_RT_Flag_RWView|R_RT_Flag_RTView|R_RT_Flag_PreferESRAM;
    if ( !v32->current.enabled )
LABEL_51:
      v33 = R_RT_Flag_RWView|R_RT_Flag_RTView;
    height = R_RT_Handle::GetSurface(&viewInfo->sceneRtInput.m_mainSceneColorRt)->m_image.m_base.height;
    Surface = R_RT_Handle::GetSurface(&viewInfo->sceneRtInput.m_mainSceneColorRt);
    v36 = *R_RT_CreateInternal(&v230, Surface->m_image.m_base.width, height, Surface->m_image.m_base.width, height, 1u, 1u, 1u, g_R_RT_renderTargetFmts[3], v33, R_RT_FlagInternal_None, &colorBlack, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, "ssss ping pong", 0, NULL, NULL, NULL, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(4346)");
    v93 = (R_RT_ColorHandle)v36;
    v106 = v36;
    if ( LOWORD(_XMM0.source) )
    {
      R_RT_Handle::GetSurface(&v106);
      if ( (R_RT_Handle::GetSurface(&v106)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        v36 = v106;
        __debugbreak();
      }
      else
      {
        v36 = v106;
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v38 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        v36 = (R_RT_Handle)v93;
        if ( v38 )
          __debugbreak();
      }
    }
    v93 = (R_RT_ColorHandle)v36;
    v199 = v36;
    R_ClearColorTargetAsync(&v247, (R_RT_ColorHandle *)&v199);
    v14 = gfxContext->state;
    v30 = v87;
  }
  R_UnlockGfxImmediateContext();
  R_ShutdownComputeCmdBufState(&v247);
  if ( v30 )
  {
    m_mainSceneSSSAlbedoRt = viewInfo->sceneRtInput.m_mainSceneSSSAlbedoRt;
    R_AddRenderTargetTransition(v14, &m_mainSceneSSSAlbedoRt, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    m_mainSceneSSSDiffuseRt = viewInfo->sceneRtInput.m_mainSceneSSSDiffuseRt;
    R_AddRenderTargetTransition(v14, &m_mainSceneSSSDiffuseRt, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    R_FlushResourceTransitions(v14);
  }
  v138 = *gfxContext;
  RB_DrawForward_Opaque(&v138, viewInfo, dataa);
  _XMM0 = *gfxContext;
  v139 = *gfxContext;
  R_DecalVolumes_Show3DDebug2(&v139, viewInfo, dataa);
  R_LockGfxImmediateContext();
  if ( rg.debugTextureOverlay != 10 )
  {
    _XMM0 = *gfxContext;
    v140 = *gfxContext;
    RB_SSAO_DecommitRTs(&v140, viewInfo);
  }
  R_FlushImmediateContext();
  R_UnlockGfxImmediateContext();
  GfxComputeCmdBufState = R_GetGfxComputeCmdBufState(v14);
  RB_ReflectionProbeRelighting_Update(GfxComputeCmdBufState, viewInfo, dataa);
  v41 = gfxContext->source;
  R_InitCmdBufSourceState(gfxContext->source, &viewInfo->input);
  R_InitLocalCmdBufState(v14, &v41->input);
  v42 = *gfxContext;
  v202 = viewInfo->sceneRtInput.m_mainSceneColorRt;
  v141 = v42;
  R_Resolve_EliminateFastClear(&v141, &v202, 0);
  v43 = *gfxContext;
  v203 = viewInfo->sceneRtInput.m_mainSceneAlphaRt;
  v142 = v43;
  R_Resolve_EliminateFastClear(&v142, &v203, 1);
  R_ShutdownLocalCmdBufState(v14, &v41->input);
  Profile2_UpdateEntry(52);
  if ( input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 44, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE80A0) )
    __debugbreak();
  _InterlockedDecrement(&dword_14FDE80A0);
  Sys_ProfEndNamedEvent();
  Profile2_UpdateEntry(57);
  if ( ((unsigned int)&dword_14FDE80B4 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE80B4) )
    __debugbreak();
  _InterlockedIncrement(&dword_14FDE80B4);
  R_InitCmdBufSourceState(gfxContext->source, &viewInfo->input);
  if ( v87 )
  {
    v44 = gfxContext->state;
    v204 = viewInfo->sceneRtInput.m_mainSceneSSSAlbedoRt;
    R_AddRenderTargetTransition(v44, &v204, RENDERTARGET_TRANSITION_MODE_READ, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    v205 = viewInfo->sceneRtInput.m_mainSceneSSSDiffuseRt;
    R_AddRenderTargetTransition(v44, &v205, RENDERTARGET_TRANSITION_MODE_READ, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    R_FlushResourceTransitions(v44);
    R_WaitAsyncCompute(v44, dataa, COMPUTE_CONTEXT_TYPE_ASYNC_BACKEND, 0);
    v206 = v93;
    v143 = *gfxContext;
    RB_SSS_Apply(&v143, dataa, viewInfo, &v206);
    v207 = v93;
    _XMM0 = *gfxContext;
    v144 = *gfxContext;
    R_RT_Destroy(&v144, &v207);
  }
  R_InitComputeCmdBufState(&v248, dataa, COMPUTE_CONTEXT_TYPE_ASYNC_BACKEND);
  v99 = dataa->globalSceneConstantBuffer->buffer;
  R_SetComputeConstantBuffers(&v248, 7, 1, &v99);
  R_LockGfxImmediateContext();
  R_ComputeWaitForGraphics(&v248, gfxContext->state);
  R_VOL_GetAccumImages(viewInfo, (const GfxImage **)&scattering, (const GfxImage **)&extinction, (const GfxImage **)&visibility);
  if ( R_PostAAHasTemporalSupersampling(viewInfo->postAA.mode) && viewInfo->postAA.smaaTransMask )
  {
    v45 = *(__m256i *)R_RT_CreateInternal(&v231, viewInfo->sceneRtInput.sceneRtWidth >> 2, viewInfo->sceneRtInput.sceneRtHeight >> 2, viewInfo->sceneRtInput.maxSceneRtWidth >> 2, viewInfo->sceneRtInput.maxSceneRtHeight >> 2, 1u, 1u, 1u, g_R_RT_renderTargetFmts[58], R_RT_Flag_RWView|R_RT_Flag_RTView, R_RT_FlagInternal_None, &colorBlack, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, "Post Opaque Luma", 0, NULL, NULL, NULL, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(4464)");
    v104 = v45;
    v105 = (R_RT_Handle)v45;
    if ( (_WORD)_XMM2 )
    {
      R_RT_Handle::GetSurface(&v105);
      if ( (R_RT_Handle::GetSurface(&v105)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        v45 = (__m256i)v105;
        __debugbreak();
      }
      else
      {
        v45 = (__m256i)v105;
      }
    }
    else
    {
      __asm { vpextrd rax, xmm2, 2 }
      if ( (_DWORD)_RAX )
      {
        v47 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        v45 = v104;
        if ( v47 )
          __debugbreak();
      }
    }
    m_floatZFullRt = (__m256i)viewInfo->sceneRtInput.m_floatZFullRt;
    __asm { vpxor   xmm0, xmm0, xmm0 }
    viewInfo->sceneRtInput.m_postOpaqueLuma = (R_RT_ColorHandle)v45;
    *(_OWORD *)&v172.m_tracking.m_name = _XMM0;
    v208 = m_floatZFullRt;
    v50 = (__m256i)viewInfo->sceneRtInput.m_mainSceneColorRt;
    v172.m_surfaceID = 0;
    v172.m_tracking.m_allocCounter = 0;
    v209 = v172;
    v210 = v50;
    v211 = v45;
    R_RunPostOpaqueProcessesLuma(&v248, viewInfo, (R_RT_ColorHandle *)&v211, (R_RT_ColorHandle *)&v210, &v209, (R_RT_ColorHandle *)&v208, scattering, extinction, rgp.blackImage);
  }
  else
  {
    v51 = (__m256i)viewInfo->sceneRtInput.m_floatZFullRt;
    __asm { vpxor   xmm0, xmm0, xmm0 }
    *(_OWORD *)&v173.m_tracking.m_name = _XMM0;
    v212 = v51;
    v53 = (__m256i)viewInfo->sceneRtInput.m_mainSceneColorRt;
    v173.m_surfaceID = 0;
    v173.m_tracking.m_allocCounter = 0;
    v213 = v173;
    v214 = v53;
    R_RunPostOpaqueProcesses(&v248, viewInfo, (R_RT_ColorHandle *)&v214, &v213, (R_RT_ColorHandle *)&v212, scattering, extinction, rgp.blackImage);
  }
  R_UnlockGfxImmediateContext();
  R_ShutdownComputeCmdBufState(&v248);
  R_LockGfxImmediateContext();
  v54 = *gfxContext;
  v215 = viewInfo->sceneRtInput.m_mainSceneSSSAlbedoRt;
  v145 = v54;
  R_RT_Destroy(&v145, &v215);
  v55 = *gfxContext;
  viewInfo->sceneRtInput.m_mainSceneSSSAlbedoRt.m_surfaceID = 0;
  viewInfo->sceneRtInput.m_mainSceneSSSAlbedoRt.m_tracking.m_allocCounter = 0;
  viewInfo->sceneRtInput.m_mainSceneSSSAlbedoRt.m_tracking.m_name = NULL;
  viewInfo->sceneRtInput.m_mainSceneSSSAlbedoRt.m_tracking.m_location = NULL;
  v216 = viewInfo->sceneRtInput.m_mainSceneSSSDiffuseRt;
  v146 = v55;
  R_RT_Destroy(&v146, &v216);
  viewInfo->sceneRtInput.m_mainSceneSSSDiffuseRt.m_surfaceID = 0;
  viewInfo->sceneRtInput.m_mainSceneSSSDiffuseRt.m_tracking.m_allocCounter = 0;
  viewInfo->sceneRtInput.m_mainSceneSSSDiffuseRt.m_tracking.m_name = NULL;
  viewInfo->sceneRtInput.m_mainSceneSSSDiffuseRt.m_tracking.m_location = NULL;
  R_FlushImmediateContext();
  R_UnlockGfxImmediateContext();
  v147 = *gfxContext;
  RB_DrawForward_Trans(&v147, viewInfo, dataa);
  if ( viewInfo->ssrWaterTrace )
  {
    R_InitComputeCmdBufState(&v249, dataa, COMPUTE_CONTEXT_TYPE_ASYNC_BACKEND);
    v100 = dataa->globalSceneConstantBuffer->buffer;
    R_SetComputeConstantBuffers(&v249, 7, 1, &v100);
    R_LockGfxImmediateContext();
    R_ComputeWaitForGraphics(&v249, gfxContext->state);
    if ( (unsigned __int8)R_GetSSRMode(viewInfo) >= GFX_SSR_DEFERRED_LQ )
      RB_SSR_DeferredWaterTrace(&v249, viewInfo, dataa);
    R_UnlockGfxImmediateContext();
    R_ShutdownComputeCmdBufState(&v249);
  }
  *(GfxCmdBufContext *)v104.m256i_i8 = *gfxContext;
  R_SSR_RotateRTs((GfxCmdBufContext *)&v104, viewInfo);
  if ( RB_HaveAnyOcclusionQueries(viewInfo->clientIndex) && (*((_DWORD *)&viewInfo->viewportFeatures + 10) & 0x10000) != 0 )
  {
    R_GPU_BeginTimer(GPU_TIMER_OCCLUSION_QUERIES);
    v148 = *gfxContext;
    RB_StandardDrawCommands_PreDrawOcclusionQueriesAndSun(&v148, viewInfo, "OccQueries");
    v56 = *gfxContext;
    v217 = viewInfo->sceneRtInput.m_mainSceneDepthRt;
    v149 = v56;
    R_SetRenderTargetsInternal_DepthOnly(&v149, &v217, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(2322)");
    v150 = *gfxContext;
    RB_DrawOcclusionQueries(&v150, viewInfo);
    _XMM6 = *gfxContext;
    __asm { vpextrq rbx, xmm6, 1 }
    R_ProfEndNamedEvent(_RBX);
    R_ShutdownLocalCmdBufState(_RBX, &_XMM6.source->input);
    R_GPU_EndTimer();
  }
  if ( RB_IsSunEnabled() )
  {
    R_GPU_BeginTimer(GPU_TIMER_SUN_QUERY);
    v151 = *gfxContext;
    RB_StandardDrawCommands_PreDrawOcclusionQueriesAndSun(&v151, viewInfo, "Sun");
    v59 = (__m256i)viewInfo->sceneRtInput.m_mainSceneColorRt;
    v218 = viewInfo->sceneRtInput.m_mainSceneDepthRt;
    v152 = *gfxContext;
    v219 = v59;
    R_SetRenderTargetsInternal_ColorDepth(&v152, (R_RT_ColorHandle *)&v219, &v218, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(2332)");
    v153 = *gfxContext;
    RB_DrawSun(&v153, viewInfo);
    _XMM6 = *gfxContext;
    __asm { vpextrq rbx, xmm6, 1 }
    R_ProfEndNamedEvent(_RBX);
    R_ShutdownLocalCmdBufState(_RBX, &_XMM6.source->input);
    R_GPU_EndTimer();
  }
  Profile2_UpdateEntry(57);
  if ( ((unsigned __int64)&dword_14FDE80B4 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 44, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE80B4) )
    __debugbreak();
  _InterlockedDecrement(&dword_14FDE80B4);
  v154 = *gfxContext;
  RB_DrawEmissive(&v154, viewInfo, dataa);
  v155 = *gfxContext;
  _XMM0 = v155;
  RB_DecommitEmissiveRTs(&v155, dataa, viewInfo);
  v63 = (R_RT_Handle)viewInfo->sceneRtInput.m_mainSceneColorRt;
  v108 = (__m256i)viewInfo->sceneRtInput.m_mainSceneDepthRt;
  v174 = (R_RT_Handle)v108;
  v107 = v63;
  v220 = v63;
  if ( LOWORD(_XMM0.source) )
  {
    R_RT_Handle::GetSurface(&v174);
    v108 = (__m256i)v174;
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 463, ASSERT_TYPE_ASSERT, "(depthRt)", (const char *)&queryFormat, "depthRt") )
      __debugbreak();
  }
  rtGroup.m_colorRtCount = 1;
  v221 = v107;
  if ( LOWORD(_XMM0.source) )
  {
    R_RT_Handle::GetSurface(&v221);
  }
  else
  {
    if ( v220.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 442, ASSERT_TYPE_ASSERT, "(colorRt)", (const char *)&queryFormat, "colorRt") )
      __debugbreak();
  }
  rtGroup.m_colorRts[0] = (R_RT_ColorHandle)v107;
  rtGroup.m_depthRt = (R_RT_DepthHandle)v108;
  RB_RunDrawList(viewInfo, dataa, &rtGroup, DRAWLIST_DEPTH_HACK_TRANS);
  R_LockGfxImmediateContext();
  v156 = *gfxContext;
  RB_StandardDrawCommands_DrawFlaresPostEmissive(&v156, viewInfo, dataa);
  R_UnlockGfxImmediateContext();
  v157 = *gfxContext;
  RB_DecommitSunShadowRTs(&v157, dataa, viewInfo);
  v158 = *gfxContext;
  RB_LGV_DrawProbes(&v158, viewInfo);
  v159 = *gfxContext;
  RB_ReflectionProbe_DrawSH(&v159, viewInfo);
  v160 = *gfxContext;
  RB_GpuLightGrid_DebugDrawVolumes(&v160, viewInfo);
  R_LockGfxImmediateContext();
  v65 = *gfxContext;
  m_lightGridVolumeData3D = viewInfo->sceneRtInput.m_lightGridVolumeData3D;
  *(GfxCmdBufContext *)v108.m256i_i8 = v65;
  R_RT_Destroy((GfxCmdBufContext *)&v108, &m_lightGridVolumeData3D);
  v66 = *gfxContext;
  viewInfo->sceneRtInput.m_lightGridVolumeData3D.m_surfaceID = 0;
  viewInfo->sceneRtInput.m_lightGridVolumeData3D.m_tracking.m_allocCounter = 0;
  viewInfo->sceneRtInput.m_lightGridVolumeData3D.m_tracking.m_name = NULL;
  viewInfo->sceneRtInput.m_lightGridVolumeData3D.m_tracking.m_location = NULL;
  m_lightGridVolumeHighBandsData3D = viewInfo->sceneRtInput.m_lightGridVolumeHighBandsData3D;
  *(GfxCmdBufContext *)&v107.m_surfaceID = v66;
  R_RT_Destroy((GfxCmdBufContext *)&v107, &m_lightGridVolumeHighBandsData3D);
  viewInfo->sceneRtInput.m_lightGridVolumeHighBandsData3D.m_surfaceID = 0;
  viewInfo->sceneRtInput.m_lightGridVolumeHighBandsData3D.m_tracking.m_allocCounter = 0;
  viewInfo->sceneRtInput.m_lightGridVolumeHighBandsData3D.m_tracking.m_name = NULL;
  viewInfo->sceneRtInput.m_lightGridVolumeHighBandsData3D.m_tracking.m_location = NULL;
  R_FlushImmediateContext();
  R_UnlockGfxImmediateContext();
  if ( viewInfo->volumeLightScatter.enabled )
  {
    v161 = *gfxContext;
    RB_PerformVolumeLightScatter(&v161, viewInfo, dataa);
  }
  R_LockGfxImmediateContext();
  dataa->endFence = R_FlushImmediateContext();
  R_UnlockGfxImmediateContext();
  Profile2_UpdateEntry(61);
  if ( ((unsigned int)&dword_14FDE80C4 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE80C4) )
    __debugbreak();
  _InterlockedIncrement(&dword_14FDE80C4);
  Sys_ProfBeginNamedEvent(0xFFFFA500, "wait finish ready");
  Sys_ProcessWorkerCmdsWithTimeout(RB_IsFinishReady, &dataa);
  Sys_ProfEndNamedEvent();
  Profile2_UpdateEntry(61);
  if ( ((unsigned int)&dword_14FDE80C4 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 44, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE80C4) )
    __debugbreak();
  _InterlockedDecrement(&dword_14FDE80C4);
  if ( dataa->finishReady )
  {
    *(GfxCmdBufContext *)source = *gfxContext;
    v89 = dataa;
    if ( !viewInfo->displayCmds[0] )
      goto LABEL_131;
    Sys_ProfBeginNamedEvent(0xFFFFA500, "wait hud2D ready");
    Sys_ProcessWorkerCmdsWithTimeout(RB_IsHud2DReady, &v89);
    Sys_ProfEndNamedEvent();
    if ( v89->abortReady || !viewInfo->displayCmds[3] )
      goto LABEL_131;
    Sys_ProfBeginNamedEvent(0xFFFFD700, "exec cmds before postFX");
    v67 = source[0];
    R_InitCmdBufSourceState(source[0], &viewInfo->input);
    v68 = (GfxCmdBufState *)source[1];
    input = &v67->input;
    R_InitLocalCmdBufState((GfxCmdBufState *)source[1], &v67->input);
    R_ProfBeginNamedEvent(v68, "2D (before postFX)");
    R_GPU_BeginTimer(GPU_TIMER_2D);
    Image = R_UniversalClut_GetImage(viewInfo->clientIndex, MOVEMENT);
    v70 = v89;
    v71 = (__m256i)viewInfo->sceneRtInput.m_mainSceneColorRt;
    v224 = viewInfo->sceneRtInput.m_mainSceneDepthRt;
    v162 = *gfxContext;
    v225 = v71;
    RB_InitClient2DReceivePPFXContext(&v162, viewInfo, v89, (R_RT_ColorHandle *)&v225, &v224, Image);
    if ( v70->async2D.renderReceivePPFXPending )
    {
      v101 = v70;
      Sys_ProfBeginNamedEvent(0xFF008008, "wait LUI render");
      R_UnlockGfxImmediateContext();
      Sys_ProcessWorkerCmdsWithTimeout((bool (__fastcall *)(void *))RB_Async2D_ReceivePPFXFinished, &v101);
      R_LockGfxImmediateContext();
      Sys_ProfEndNamedEvent();
    }
    if ( v70->async2D.receivePPFXCmdBuf.device )
    {
      if ( !v70->async2D.renderFailed )
      {
        R_FlushImmediateContext();
        device = v70->async2D.receivePPFXCmdBuf.device;
        ((void (__fastcall *)(ID3D12CommandQueue *, __int64, GfxDevice **))g_dx.immediateCommandQueue.commandQueue->m_pFunction[3].AddRef)(g_dx.immediateCommandQueue.commandQueue, 1i64, &device);
        v70->async2D.receivePPFXCmdBuf.device = NULL;
LABEL_130:
        R_GPU_EndTimer();
        R_ProfEndNamedEvent(v68);
        R_ShutdownLocalCmdBufState(v68, input);
        Sys_ProfEndNamedEvent();
LABEL_131:
        Sys_ProfBeginNamedEvent(0xFFFFD700, "exec post3d");
        Profile2_UpdateEntry(62);
        if ( ((unsigned int)&dword_14FDE80C8 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE80C8) )
          __debugbreak();
        _InterlockedIncrement(&dword_14FDE80C8);
        v164 = *gfxContext;
        RB_DrawDebugPrimitives(&v164, viewInfo);
        v73 = gfxContext->state;
        v226 = viewInfo->sceneRtInput.m_mainSceneDepthRt;
        R_AddDepthStencilTransition(v73, &v226, DEPTHSTENCIL_TRANSITION_MODE_READ_PRESERVE_DEPTH_COMPRESSION, D3D12_RESOURCE_BARRIER_FLAG_NONE);
        v227 = viewInfo->sceneRtInput.m_mainSceneColorRt;
        R_AddRenderTargetTransition(v73, &v227, RENDERTARGET_TRANSITION_MODE_READ, D3D12_RESOURCE_BARRIER_FLAG_NONE);
        v228 = viewInfo->sceneRtInput.m_mainSceneAlphaRt;
        R_AddRenderTargetTransition(v73, &v228, RENDERTARGET_TRANSITION_MODE_READ, D3D12_RESOURCE_BARRIER_FLAG_NONE);
        R_FlushResourceTransitions(v73);
        R_LockGfxImmediateContext();
        v74 = *gfxContext;
        v229 = viewInfo->sceneRtInput.m_mainSceneDepthRt;
        v165 = v74;
        R_RT_Destroy(&v165, &v229);
        v75 = *gfxContext;
        viewInfo->sceneRtInput.m_mainSceneDepthRt.m_surfaceID = 0;
        viewInfo->sceneRtInput.m_mainSceneDepthRt.m_tracking.m_allocCounter = 0;
        viewInfo->sceneRtInput.m_mainSceneDepthRt.m_tracking.m_name = NULL;
        viewInfo->sceneRtInput.m_mainSceneDepthRt.m_tracking.m_location = NULL;
        m_gpIndexBuffer = viewInfo->sceneRtInput.m_gpIndexBuffer;
        v166 = v75;
        R_RT_Destroy(&v166, &m_gpIndexBuffer);
        v76 = *gfxContext;
        viewInfo->sceneRtInput.m_gpIndexBuffer.m_surfaceID = 0;
        viewInfo->sceneRtInput.m_gpIndexBuffer.m_tracking.m_allocCounter = 0;
        viewInfo->sceneRtInput.m_gpIndexBuffer.m_tracking.m_name = NULL;
        viewInfo->sceneRtInput.m_gpIndexBuffer.m_tracking.m_location = NULL;
        m_gpIndirectArgsBuffer = viewInfo->sceneRtInput.m_gpIndirectArgsBuffer;
        v167 = v76;
        R_RT_Destroy(&v167, &m_gpIndirectArgsBuffer);
        v77 = *gfxContext;
        viewInfo->sceneRtInput.m_gpIndirectArgsBuffer.m_surfaceID = 0;
        viewInfo->sceneRtInput.m_gpIndirectArgsBuffer.m_tracking.m_allocCounter = 0;
        viewInfo->sceneRtInput.m_gpIndirectArgsBuffer.m_tracking.m_name = NULL;
        viewInfo->sceneRtInput.m_gpIndirectArgsBuffer.m_tracking.m_location = NULL;
        m_gpPerSurfDataBuffer = viewInfo->sceneRtInput.m_gpPerSurfDataBuffer;
        v168 = v77;
        R_RT_Destroy(&v168, &m_gpPerSurfDataBuffer);
        viewInfo->sceneRtInput.m_gpPerSurfDataBuffer.m_surfaceID = 0;
        viewInfo->sceneRtInput.m_gpPerSurfDataBuffer.m_tracking.m_allocCounter = 0;
        viewInfo->sceneRtInput.m_gpPerSurfDataBuffer.m_tracking.m_name = NULL;
        viewInfo->sceneRtInput.m_gpPerSurfDataBuffer.m_tracking.m_location = NULL;
        R_FlushImmediateContext();
        R_UnlockGfxImmediateContext();
        R_WaitAsyncCompute(v73, dataa, COMPUTE_CONTEXT_TYPE_ASYNC_BACKEND, 0);
        if ( viewInfo->viewParmsSet.frames[0].viewParms.subpixelOffset.v[0] != 0.0 || viewInfo->viewParmsSet.frames[0].viewParms.subpixelOffset.v[1] != 0.0 )
        {
          v78 = viewInfo;
          p_viewParms = &viewInfo->viewParmsSet.frames[2].viewParms;
          do
          {
            v78 = (const GfxViewInfo *)((char *)v78 + 128);
            v80 = *(__m256i *)p_viewParms->viewMatrix.m.m[0].v;
            v81 = p_viewParms->projectionMatrix.m.m[3];
            p_viewParms = (GfxViewParms *)((char *)p_viewParms + 128);
            *(__m256i *)&v78[-1].drawList[64].superTerrainSurfList.surfs = v80;
            *(__m256i *)&v78[-1].spotshadowActiveCache.m_tracking.m_name = *(__m256i *)&p_viewParms[-1].camera.axis.row1.z;
            v78[-1].sunshadowCacheRt = *(R_RT_DepthHandle *)p_viewParms[-1].camera.zPlanes;
            *(_OWORD *)&v78[-1].sunShadowCacheBeforeState = *(_OWORD *)&p_viewParms[-1].camera.visibilityQueryDistance;
            *(vec4_t *)&v78[-1].shellShock.enabled = v81;
            --v17;
          }
          while ( v17 );
        }
        v169 = *gfxContext;
        RB_ApplyPostEffects(&v169, viewInfo, dataa);
        v170 = *gfxContext;
        RB_BlitDebugOverlay(&v170, viewInfo);
        v171 = *gfxContext;
        RB_DecommitSceneRTs(&v171, viewInfo);
        RB_AddComputeCmdsTransitions(v73, dataa, 0);
        R_FlushResourceTransitions(v73);
        v82 = dataa;
        Sys_ProfBeginNamedEvent(0xFFFFA500, "wait skipped draw workers");
        p_inCmdCount = &v82->drawOutput[0].inCmdCount;
        cmdBufValid = v82->cmdBufValid;
        do
        {
          if ( *cmdBufValid && *((_DWORD *)p_inCmdCount - 1) )
          {
            if ( *p_inCmdCount )
            {
              LODWORD(rtFlagsInternal) = v11;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 1283, ASSERT_TYPE_ASSERT, "( ( !data->drawOutput[drawListType].inCmdCount ) )", "( drawListType ) = %i", rtFlagsInternal) )
                __debugbreak();
            }
            R_WaitDrawWorkerCmdsOfType(v82, (const GfxDrawListType)v11);
          }
          ++v11;
          ++cmdBufValid;
          p_inCmdCount += 2284;
        }
        while ( v11 < 89 );
        Sys_ProfEndNamedEvent();
        Profile2_UpdateEntry(62);
        if ( ((unsigned __int64)&dword_14FDE80C8 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 44, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE80C8) )
          __debugbreak();
        _InterlockedDecrement(&dword_14FDE80C8);
        Sys_ProfEndNamedEvent();
        goto LABEL_150;
      }
      v70->async2D.receivePPFXCmdBuf.device = NULL;
    }
    v72 = viewInfo->displayCmds[3];
    v163 = *gfxContext;
    RB_ExecuteRenderCommandsLoop(&v163, v72, NULL);
    goto LABEL_130;
  }
LABEL_150:
  Profile_EndCSV(23);
}

/*
==============
RB_Draw3DScene_FreeRts
==============
*/
void RB_Draw3DScene_FreeRts(void)
{
  RB_PostEffects_FreeTemporalRts();
  R_Velocity_FreeTemporalRts();
  R_SSAO_FreeTemporalRts();
  R_VRS_FreeRts();
  R_LGV_FreeSamplingBuffers();
  R_EffectLighting_FreeRts();
  R_VOL_FreeRts();
  R_FrustumLights_FreeRts();
  R_UniversalClut_FreeRts();
  R_SSR_FreeTemporalRts();
  R_SunShadowCache_FreeRts();
  R_SunShadowMapDebug_DestroyRTDraw3D();
  R_SpotShadow_FreeRts();
  R_ReProjFloatZ_FreeTemporalRTs();
}

/*
==============
RB_DrawDebugPrimitives
==============
*/

void __fastcall RB_DrawDebugPrimitives(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, __int64 a3, double a4)
{
  __int16 v5; 
  const dvar_t *v6; 
  GfxCmdBufSourceState *source; 
  GfxCmdBufState *state; 
  R_RT_Handle m_mainSceneColorRt; 
  R_RT_Handle v13; 
  bool v14; 
  unsigned int height; 
  const R_RT_Surface *Surface; 
  R_RT_Handle v17; 
  bool v19; 
  R_RT_Handle v20; 
  GfxCmdBufState *v21; 
  unsigned int v22; 
  const R_RT_Surface *v23; 
  GfxCmdBufSourceState *v24; 
  R_RT_Handle m_mainSceneDepthRt; 
  R_RT_Handle v26; 
  R_RT_Handle v27; 
  R_RT_Handle result; 
  R_RT_Handle v29; 
  R_RT_Group v30; 
  __m256i v31; 
  __m256i v32; 
  __m256i v33; 
  __m256i v34; 
  _BYTE v35[64]; 
  const char *m_location; 
  R_RT_Group v37; 

  v6 = DCONST_DVARINT_developer;
  if ( !DCONST_DVARINT_developer && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "developer") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v6);
  if ( v6->current.integer && (Physics_RenderDebugEnabled() || CG_Edge_DrawDebugEnabled() || RB_Stream_TreeDebugDrawEnabled() || RB_Stream_XModelTreeDebugDrawEnabled() || RB_NeedDrawDebug()) )
  {
    source = gfxContext->source;
    R_InitCmdBufSourceState(gfxContext->source, &viewInfo->input);
    state = gfxContext->state;
    R_InitLocalCmdBufState(state, &source->input);
    R_ProfBeginNamedEvent(state, "Debug");
    m_mainSceneColorRt = (R_RT_Handle)viewInfo->sceneRtInput.m_mainSceneColorRt;
    m_mainSceneDepthRt = (R_RT_Handle)viewInfo->sceneRtInput.m_mainSceneDepthRt;
    v26 = m_mainSceneDepthRt;
    v27 = m_mainSceneColorRt;
    v29 = m_mainSceneColorRt;
    if ( (_WORD)_XMM0 )
    {
      R_RT_Handle::GetSurface(&v26);
      v13 = v26;
      m_mainSceneDepthRt = v26;
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 463, ASSERT_TYPE_ASSERT, "(depthRt)", (const char *)&queryFormat, "depthRt") )
        __debugbreak();
      v13 = m_mainSceneDepthRt;
    }
    result = v13;
    v30.m_colorRtCount = 1;
    v26 = v27;
    if ( (_WORD)_XMM0 )
    {
      R_RT_Handle::GetSurface(&v26);
    }
    else
    {
      if ( v29.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 442, ASSERT_TYPE_ASSERT, "(colorRt)", (const char *)&queryFormat, "colorRt") )
        __debugbreak();
    }
    v30.m_colorRts[0] = (R_RT_ColorHandle)v27;
    v30.m_depthRt = (R_RT_DepthHandle)m_mainSceneDepthRt;
    v31 = *(__m256i *)&v30.m_colorRtCount;
    v32 = *(__m256i *)&v30.m_colorRts[0].m_tracking.m_location;
    v33 = *(__m256i *)&v30.m_colorRts[1].m_tracking.m_location;
    v34 = *(__m256i *)&v30.m_colorRts[2].m_tracking.m_location;
    *(__m256i *)v35 = *(__m256i *)&v30.m_colorRts[3].m_tracking.m_location;
    *(__m256i *)&v35[32] = *(__m256i *)&v30.m_depthRt.m_tracking.m_location;
    m_location = v30.m_vrsRt.m_tracking.m_location;
    m_mainSceneDepthRt = v27;
    if ( LOWORD(a4) )
    {
      R_RT_Handle::GetSurface(&m_mainSceneDepthRt);
      if ( (R_RT_Handle::GetSurface(&m_mainSceneDepthRt)->m_rtFlagsInternal & 0x18) != 0 )
      {
        v14 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 396, ASSERT_TYPE_ASSERT, "(!colorRt.IsValid() || colorRt.IsColor())", (const char *)&queryFormat, "!colorRt.IsValid() || colorRt.IsColor()");
LABEL_30:
        if ( v14 )
          __debugbreak();
      }
    }
    else if ( v30.m_colorRts[0].m_tracking.m_allocCounter )
    {
      v14 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", LOWORD(a4) + 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      goto LABEL_30;
    }
    v29 = m_mainSceneDepthRt;
    v27 = m_mainSceneDepthRt;
    height = R_RT_Handle::GetSurface(&v27)->m_image.m_base.height;
    Surface = R_RT_Handle::GetSurface(&v27);
    v17 = *R_RT_CreateInternal(&result, Surface->m_image.m_base.width, height, Surface->m_image.m_base.width, height, 1u, 1u, 1u, g_R_RT_renderTargetFmts[1], R_RT_Flag_RTView, R_RT_FlagInternal_None, &colorBlackBlank, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, "Debug Overlay", 0, NULL, NULL, NULL, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(975)");
    m_mainSceneDepthRt = v17;
    v26 = v17;
    if ( (_WORD)_XMM0 )
    {
      R_RT_Handle::GetSurface(&v26);
      if ( (R_RT_Handle::GetSurface(&v26)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        v17 = v26;
        m_mainSceneDepthRt = v26;
        __debugbreak();
      }
      else
      {
        v17 = v26;
        m_mainSceneDepthRt = v26;
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v19 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        v17 = m_mainSceneDepthRt;
        if ( v19 )
          __debugbreak();
      }
    }
    v26 = *(R_RT_Handle *)&v35[8];
    v27 = *(R_RT_Handle *)&v35[8];
    result = v17;
    if ( v5 )
    {
      R_RT_Handle::GetSurface(&v27);
      v26 = v27;
    }
    else
    {
      if ( *(_DWORD *)&v35[16] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 463, ASSERT_TYPE_ASSERT, "(depthRt)", (const char *)&queryFormat, "depthRt") )
        __debugbreak();
    }
    v30.m_colorRtCount = 1;
    v29 = m_mainSceneDepthRt;
    if ( (_WORD)_XMM0 )
    {
      R_RT_Handle::GetSurface(&v29);
    }
    else
    {
      if ( result.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 442, ASSERT_TYPE_ASSERT, "(colorRt)", (const char *)&queryFormat, "colorRt") )
        __debugbreak();
    }
    v30.m_colorRts[0] = (R_RT_ColorHandle)m_mainSceneDepthRt;
    v30.m_depthRt = (R_RT_DepthHandle)v26;
    v37 = v30;
    if ( R_RT_Handle::IsValid(&viewInfo->debugOverlay) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 978, ASSERT_TYPE_ASSERT, "(!viewInfo->debugOverlay)", (const char *)&queryFormat, "!viewInfo->debugOverlay") )
      __debugbreak();
    v20 = m_mainSceneDepthRt;
    v21 = gfxContext->state;
    viewInfo->debugOverlay = (R_RT_ColorHandle)m_mainSceneDepthRt;
    result = v20;
    R_AddRenderTargetTransition(v21, (R_RT_ColorHandle *)&result, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    R_FlushResourceTransitions(v21);
    v27 = *R_RT_Group::GetValidRt(&v37, &result);
    v22 = R_RT_Handle::GetSurface(&v27)->m_image.m_base.height;
    v23 = R_RT_Handle::GetSurface(&v27);
    v24 = gfxContext->source;
    R_SetRenderTargetSize(gfxContext->source, v23->m_image.m_base.width, v22, GFX_USE_VIEWPORT_FOR_VIEW);
    *(GfxCmdBufContext *)&v26.m_surfaceID = *gfxContext;
    R_SetRenderTargetsInternal((GfxCmdBufContext *)&v26, &v37, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(985)");
    R_ClearScreen(v21, 0xFu, 0);
    *(GfxCmdBufContext *)&v26.m_surfaceID = *gfxContext;
    RB_UniversalClut_SetParameters((const GfxCmdBufContext *)&v26, viewInfo);
    R_BeginViewInternal(v24, &viewInfo->sceneDef, &viewInfo->viewParmsSet.frames[2].viewParms, NULL);
    R_SetViewportStruct(v24, &viewInfo->sceneViewport);
    R_Set3D(v24);
    *(GfxCmdBufContext *)&v26.m_surfaceID = *gfxContext;
    RB_DrawDebug((GfxCmdBufContext *)&v26, &v24->viewParms, viewInfo);
    result = m_mainSceneDepthRt;
    R_AddRenderTargetTransition(v21, (R_RT_ColorHandle *)&result, RENDERTARGET_TRANSITION_MODE_READ, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    R_FlushResourceTransitions(v21);
    R_ProfEndNamedEvent(v21);
    R_ShutdownLocalCmdBufState(v21, &v24->input);
  }
}

/*
==============
RB_DrawEmissive
==============
*/
void RB_DrawEmissive(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  __int128 v3; 
  GfxCmdBufState *v6; 
  ComputeContextType v7; 
  const GfxBackEndData *v10; 
  __m256i m_mainSceneDepthRt; 
  int integer; 
  __m256i m_mainSceneAlphaRt; 
  __m256i v17; 
  __m256i v18; 
  const GfxBackEndData *v20; 
  R_RT_Handle v21; 
  GfxBackEndData *timeoutUserData; 
  ID3D12Resource *buffers; 
  GfxCmdBufInput *input[2]; 
  GfxCmdBufContext v26; 
  GfxCmdBufContext v27; 
  GfxCmdBufContext v28; 
  GfxCmdBufContext v29; 
  GfxCmdBufContext v30; 
  GfxCmdBufContext v31; 
  GfxCmdBufContext v32; 
  R_RT_Handle v33; 
  R_RT_Handle v34; 
  __m256i v35; 
  R_RT_ColorHandle m_msaaSceneColorRt; 
  R_RT_ColorHandle m_msaaSceneAlphaRt; 
  R_RT_DepthHandle m_msaaSceneDepthRt; 
  R_RT_DepthHandle v39; 
  __m256i v40; 
  R_RT_DepthHandle v41; 
  R_RT_DepthHandle v42; 
  __m256i v43; 
  R_RT_ColorHandle m_mainSceneColorRt; 
  __m256i v45; 
  __m256i v46; 
  R_RT_ColorHandle v47; 
  R_RT_ColorHandle v48; 
  R_RT_Handle v49; 
  R_RT_Handle v50; 
  R_RT_Group v51; 
  char v52[128]; 
  R_RT_Group rtGroup; 
  R_RT_Group v54; 
  ComputeCmdBufState state; 
  __int128 v56; 

  timeoutUserData = (GfxBackEndData *)data;
  Profile2_UpdateEntry(58);
  if ( ((unsigned __int8)&dword_14FDE80B8 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE80B8) )
    __debugbreak();
  _InterlockedIncrement(&dword_14FDE80B8);
  Sys_ProfBeginNamedEvent(0xFFFFA500, "wait emissive ready");
  Sys_ProcessWorkerCmdsWithTimeout(RB_IsEmissiveReady, &timeoutUserData);
  Sys_ProfEndNamedEvent();
  Profile2_UpdateEntry(58);
  if ( ((unsigned __int64)&dword_14FDE80B8 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 44, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE80B8) )
    __debugbreak();
  _InterlockedDecrement(&dword_14FDE80B8);
  v6 = gfxContext->state;
  R_LockIfGfxImmediateContext(v6->device);
  v26 = *gfxContext;
  RB_StandardDrawCommands_DrawSunPost(&v26, viewInfo, timeoutUserData);
  Sys_ProfBeginNamedEvent(0xFFFFD700, "exec cmds emissive");
  Profile2_UpdateEntry(60);
  if ( ((unsigned __int8)&dword_14FDE80C0 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE80C0) )
    __debugbreak();
  _InterlockedIncrement(&dword_14FDE80C0);
  v7 = COMPUTE_CONTEXT_TYPE_GFX;
  if ( r_effectLightingAsync->current.enabled )
    v7 = COMPUTE_CONTEXT_TYPE_ASYNC_BACKEND;
  R_InitComputeCmdBufState(&state, v6, timeoutUserData, v7);
  buffers = timeoutUserData->globalSceneConstantBuffer->buffer;
  R_SetComputeConstantBuffers(&state, 7, 1, &buffers);
  RB_EffectLighting(&state, viewInfo);
  R_ShutdownComputeCmdBufState(&state);
  if ( r_effectLightingAsync->current.enabled )
    R_WaitAsyncCompute(v6, timeoutUserData, COMPUTE_CONTEXT_TYPE_ASYNC_BACKEND, 0);
  v56 = v3;
  if ( rg.vrsEmissiveOnly )
  {
    _XMM6 = *gfxContext;
    R_GPU_BeginTimer(GPU_TIMER_EMISSIVE_COPY);
    R_InitCmdBufSourceState(_XMM6.source, &viewInfo->input);
    __asm { vpextrq rbx, xmm6, 1 }
    R_InitLocalCmdBufState(_RBX, &_XMM6.source->input);
    v10 = viewInfo->input.data;
    v27 = _XMM6;
    R_HW_EnableMultiSample(&v27, v10->frameCount);
    m_msaaSceneColorRt = viewInfo->sceneRtInput.m_msaaSceneColorRt;
    R_AddRenderTargetTransition(_RBX, &m_msaaSceneColorRt, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    m_msaaSceneAlphaRt = viewInfo->sceneRtInput.m_msaaSceneAlphaRt;
    R_AddRenderTargetTransition(_RBX, &m_msaaSceneAlphaRt, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    m_msaaSceneDepthRt = viewInfo->sceneRtInput.m_msaaSceneDepthRt;
    R_AddDepthStencilTransition(_RBX, &m_msaaSceneDepthRt, DEPTHSTENCIL_TRANSITION_MODE_WRITE_PRESERVE_COMPRESSION, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    R_FlushResourceTransitions(_RBX);
    if ( r_halfResEmissivePSCopy->current.enabled )
    {
      R_ProfBeginNamedEvent(_RBX, "R_Resolve_CopyDepthTo4xMS");
      m_mainSceneDepthRt = (__m256i)viewInfo->sceneRtInput.m_mainSceneDepthRt;
      v39 = viewInfo->sceneRtInput.m_msaaSceneDepthRt;
      v40 = m_mainSceneDepthRt;
      v28 = _XMM6;
      R_Resolve_CopyDepthTo4xMS(&v28, (R_RT_DepthHandle *)&v40, &v39);
      R_ProfEndNamedEvent(_RBX);
    }
    R_ShutdownLocalCmdBufState(_RBX, &_XMM6.source->input);
    R_GPU_EndTimer();
  }
  else if ( rg.halfResEmissive )
  {
    v29 = *gfxContext;
    RB_HalfResEmissive_DownsampleDepth(&v29, viewInfo);
  }
  R_UnlockIfGfxImmediateContext(v6->device);
  if ( !rg.debugShaderEnabled )
  {
    R_Draw_GetRtGroup(viewInfo, DRAWLIST_PREPASS_COUNT, &rtGroup);
    RB_RunDrawList(viewInfo, timeoutUserData, &rtGroup, DRAWLIST_PREPASS_COUNT);
    RB_RunDrawList(viewInfo, timeoutUserData, &rtGroup, DRAWLIST_DEPTH_HACK_EMISSIVE);
  }
  R_LockIfGfxImmediateContext(v6->device);
  integer = 5;
  if ( rg.vrsEmissiveOnly )
  {
    _XMM6 = *gfxContext;
    __asm { vpextrq r12, xmm6, 1 }
    R_GPU_BeginTimer(GPU_TIMER_EMISSIVE_COPY);
    R_InitCmdBufSourceState(_XMM6.source, &viewInfo->input);
    input[0] = &_XMM6.source->input;
    R_InitLocalCmdBufState(_R12, &_XMM6.source->input);
    v41 = viewInfo->sceneRtInput.m_msaaSceneDepthRt;
    R_AddDepthStencilTransition(_R12, &v41, DEPTHSTENCIL_TRANSITION_MODE_READ_PRESERVE_COMPRESSION, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    __asm { vpextrq rbx, xmm6, 1 }
    if ( !R_IsLockedIfGfxImmediateContext(*(const GfxDevice **)(_RBX + 1360)) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_immediate_context_lock.h", 29, ASSERT_TYPE_ASSERT, "(R_IsLockedIfGfxImmediateContext( device ))", (const char *)&queryFormat, "R_IsLockedIfGfxImmediateContext( device )") )
    {
      __debugbreak();
      v6 = gfxContext->state;
    }
    memset_0(v52, 0, sizeof(v52));
    (*(void (__fastcall **)(_QWORD, char *, void *, void *))(**(_QWORD **)(_RBX + 1360) + 640i64))(*(_QWORD *)(_RBX + 1360), v52, &`R_HW_DisableMultiSample'::`2'::s_samplePriorities1xMS, &`R_HW_DisableMultiSample'::`2'::s_eqaa1xMS);
    (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(_RBX + 1360) + 512i64))(*(_QWORD *)(_RBX + 1360), 0i64);
    R_ProfBeginNamedEvent(_R12, "R_Resolve_CopyFrom4xMS");
    m_mainSceneAlphaRt = (__m256i)viewInfo->sceneRtInput.m_mainSceneAlphaRt;
    v42 = viewInfo->sceneRtInput.m_mainSceneDepthRt;
    m_mainSceneColorRt = viewInfo->sceneRtInput.m_mainSceneColorRt;
    v17 = (__m256i)viewInfo->sceneRtInput.m_msaaSceneColorRt;
    v43 = m_mainSceneAlphaRt;
    v18 = (__m256i)viewInfo->sceneRtInput.m_msaaSceneAlphaRt;
    v46 = v17;
    v45 = v18;
    v30 = _XMM6;
    RB_Resolve_CopyFrom4xMS(&v30, (R_RT_ColorHandle *)&v46, (R_RT_ColorHandle *)&v45, &m_mainSceneColorRt, (R_RT_ColorHandle *)&v43, &v42);
    R_ProfEndNamedEvent(_R12);
    R_ShutdownLocalCmdBufState(_R12, input[0]);
    R_GPU_EndTimer();
  }
  else if ( rg.halfResEmissive )
  {
    v31 = *gfxContext;
    RB_HalfRes_Upsample(&v31, viewInfo);
  }
  if ( (viewInfo->matRenderFeatures & 2) != 0 )
  {
    R_GPU_BeginTimer(GPU_TIMER_RESOLVE_DISTORTION_1);
    v47 = viewInfo->sceneRtInput.m_mainSceneColorRt;
    R_AddRenderTargetTransition(v6, &v47, RENDERTARGET_TRANSITION_MODE_READ, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    R_FlushResourceTransitions(v6);
    v32 = *gfxContext;
    RB_ResolveDistortion(&v32, viewInfo);
    v48 = viewInfo->sceneRtInput.m_mainSceneColorRt;
    R_AddRenderTargetTransition(v6, &v48, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    R_FlushResourceTransitions(v6);
    R_GPU_EndTimer();
  }
  R_UnlockIfGfxImmediateContext(v6->device);
  if ( !rg.debugShaderEnabled )
  {
    R_Draw_GetRtGroup(viewInfo, DRAWLIST_DISTORT_EMISSIVE, &v54);
    RB_RunDrawList(viewInfo, timeoutUserData, &v54, DRAWLIST_DISTORT_EMISSIVE);
  }
  R_LockIfGfxImmediateContext(v6->device);
  _XMM0 = *gfxContext;
  *(GfxCmdBufContext *)input = *gfxContext;
  RB_FL_RenderDebugProxies((GfxCmdBufContext *)input, viewInfo);
  v20 = timeoutUserData;
  if ( particle_show_tris->current.enabled || (integer = r_showTris->current.integer) != 0 )
  {
    v21 = (R_RT_Handle)viewInfo->sceneRtInput.m_mainSceneColorRt;
    v35 = (__m256i)viewInfo->sceneRtInput.m_mainSceneDepthRt;
    v33 = (R_RT_Handle)v35;
    v34 = v21;
    v49 = v21;
    if ( LOWORD(_XMM0.source) )
    {
      R_RT_Handle::GetSurface(&v33);
      v35 = (__m256i)v33;
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 463, ASSERT_TYPE_ASSERT, "(depthRt)", (const char *)&queryFormat, "depthRt") )
        __debugbreak();
    }
    v51.m_colorRtCount = 1;
    v50 = v34;
    if ( LOWORD(_XMM0.source) )
    {
      R_RT_Handle::GetSurface(&v50);
    }
    else
    {
      if ( v49.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 442, ASSERT_TYPE_ASSERT, "(colorRt)", (const char *)&queryFormat, "colorRt") )
        __debugbreak();
    }
    v51.m_colorRts[0] = (R_RT_ColorHandle)v34;
    v51.m_depthRt = (R_RT_DepthHandle)v35;
    R_ShowTris_Draw(viewInfo, v20, &v51, (R_SHOW_TRIS)integer);
  }
  R_UnlockIfGfxImmediateContext(gfxContext->state->device);
  Profile2_UpdateEntry(60);
  if ( ((unsigned __int64)&dword_14FDE80C0 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 44, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE80C0) )
    __debugbreak();
  _InterlockedDecrement(&dword_14FDE80C0);
  Sys_ProfEndNamedEvent();
}

/*
==============
RB_DrawEmissive_MapMeshes
==============
*/
void RB_DrawEmissive_MapMeshes(const GfxBackEndData *data)
{
  ;
}

/*
==============
RB_DrawEmissive_UnmapMeshes
==============
*/
void RB_DrawEmissive_UnmapMeshes(const GfxBackEndData *data)
{
  ;
}

/*
==============
RB_DrawFogSplineOverlap
==============
*/
void RB_DrawFogSplineOverlap(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, int drawFogSpline)
{
  int v5; 
  int v6; 
  GfxFogSplineBlendEntry *v8; 
  __int64 v9; 
  GfxImage *zero1DImage; 
  int v11; 
  GfxCmdBufSourceState *source; 
  float v13; 
  float v14; 
  GfxCmdBufInput *p_input; 
  GfxCmdBufContext v16; 
  GfxFont *debugFont; 
  const char *v18; 
  __int128 v21; 
  GfxCmdBufContext v22; 

  v5 = -1;
  if ( drawFogSpline >= 2 )
    v5 = drawFogSpline - 2;
  v6 = 8;
  if ( drawFogSpline != 1 )
    v6 = v5 + 1;
  _XMM11 = 0i64;
  if ( v5 < (__int64)v6 )
  {
    v8 = &viewInfo->fog.fogSplineBlendEntry[v5];
    v9 = v6 - (__int64)v5;
    while ( v5 >= 0 && (unsigned int)v5 < 8 )
    {
      if ( v5 < viewInfo->fog.fogSplineBlendCount )
      {
        zero1DImage = rgp.zero1DImage;
        if ( v8->image )
          zero1DImage = (GfxImage *)v8->image;
        goto LABEL_14;
      }
LABEL_25:
      ++v5;
      ++v8;
      if ( !--v9 )
        return;
    }
    zero1DImage = (GfxImage *)RB_FogSpline_GetImage(&viewInfo->fog, viewInfo->clientIndex);
LABEL_14:
    if ( zero1DImage )
    {
      LOWORD(v11) = zero1DImage->width;
      if ( (_WORD)v11 == 1 )
        v11 = 128;
      else
        v11 = (unsigned __int16)v11;
      source = gfxContext->source;
      v13 = (float)zero1DImage->height * 24.0;
      v14 = (float)v11 * 12.0;
      if ( !gfxContext->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
        __debugbreak();
      p_input = &source->input;
      if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
        __debugbreak();
      v16 = *gfxContext;
      p_input->codeImages[4] = zero1DImage;
      v22 = v16;
      RB_DrawStretchPic(&v22, rgp.feedbackReplaceBackbufferMaterial, 8.0, *(float *)&_XMM11 + 8.0, v14, v13, 0.0, 0.0, 1.0, 1.0, 0xFFFFFFFF, GFX_PRIM_STATS_HUD);
      v22 = *gfxContext;
      RB_EndTessSurfaceInternal(&v22, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(5255)");
      debugFont = backEnd.debugFont;
      v18 = j_va((const char *)&queryFormat, zero1DImage->name);
      v22 = *gfxContext;
      RB_DrawText(&v22, v18, debugFont, v14 + 16.0, (float)((float)(v13 * 0.75) + *(float *)&_XMM11) + 8.0, (const GfxColor)-1);
      v22 = *gfxContext;
      RB_EndTessSurfaceInternal(&v22, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(5258)");
      __asm
      {
        vcmpeqss xmm0, xmm11, xmm10
        vblendvps xmm2, xmm11, xmm1, xmm0
      }
      v21 = _XMM2;
      *(float *)&v21 = *(float *)&_XMM2 + (float)(v13 + 3.0);
      _XMM11 = v21;
    }
    goto LABEL_25;
  }
}

/*
==============
RB_DrawFogSplineOverlap_GetImage
==============
*/
GfxImage *RB_DrawFogSplineOverlap_GetImage(const GfxViewInfo *viewInfo, int fogSplineBlendIndex)
{
  const GfxImage *image; 
  GfxImage *result; 

  if ( fogSplineBlendIndex < 0 || (unsigned int)fogSplineBlendIndex >= 8 )
    return (GfxImage *)RB_FogSpline_GetImage(&viewInfo->fog, viewInfo->clientIndex);
  if ( fogSplineBlendIndex >= viewInfo->fog.fogSplineBlendCount )
    return 0i64;
  image = viewInfo->fog.fogSplineBlendEntry[fogSplineBlendIndex].image;
  result = rgp.zero1DImage;
  if ( image )
    return (GfxImage *)image;
  return result;
}

/*
==============
RB_DrawForward_Opaque
==============
*/
void RB_DrawForward_Opaque(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxDrawListType v6; 
  R_RT_Group rtGroup; 
  R_RT_Group v8; 

  Profile2_UpdateEntry(56);
  if ( ((unsigned __int8)&dword_14FDE80B0 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE80B0) )
    __debugbreak();
  _InterlockedIncrement(&dword_14FDE80B0);
  v6 = DRAWLIST_LIT_OPAQUE;
  R_Draw_GetRtGroup(viewInfo, DRAWLIST_LIT_OPAQUE, &rtGroup);
  R_Draw_GetRtGroup(viewInfo, DRAWLIST_LIT_OPAQUE_END, &v8);
  RB_RunDrawList(viewInfo, data, &rtGroup, DRAWLIST_PRE_OPAQUE);
  RB_RunDrawList(viewInfo, data, &v8, DRAWLIST_PRE_SSS);
  if ( (*((_BYTE *)&viewInfo->input + 7920) & 2) != 0 )
  {
    do
      RB_RunDrawList(viewInfo, data, &rtGroup, v6++);
    while ( v6 != DRAWLIST_LIT_OPAQUE_END );
  }
  else
  {
    RB_RunDrawList(viewInfo, data, &rtGroup, DRAWLIST_LIT_OPAQUE);
  }
  RB_RunDrawList(viewInfo, data, &v8, DRAWLIST_LIT_OPAQUE_END);
  if ( viewInfo->ssao.splitZones )
    R_WaitAsyncCompute(gfxContext->state, data, COMPUTE_CONTEXT_TYPE_ASYNC_BACKEND, 0);
  RB_RunDrawList(viewInfo, data, &rtGroup, DRAWLIST_FIRST);
  RB_RunDrawList(viewInfo, data, &v8, DRAWLIST_DEPTH_HACK_SSS);
  RB_RunDrawList(viewInfo, data, &rtGroup, DRAWLIST_LIT_OPAQUE_GLASS);
  RB_RunDrawList(viewInfo, data, &rtGroup, DRAWLIST_LIT_DECAL);
  Profile2_UpdateEntry(56);
  if ( ((unsigned __int64)&dword_14FDE80B0 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 44, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE80B0) )
    __debugbreak();
  _InterlockedDecrement(&dword_14FDE80B0);
}

/*
==============
RB_DrawForward_Trans
==============
*/
void RB_DrawForward_Trans(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufState *state; 
  const R_RT_Surface *Surface; 
  const GfxTexture *Resident; 
  GfxCmdBufContext v9; 
  D3D12_RESOURCE_STATES v10; 
  const R_RT_Surface *v11; 
  const GfxTexture *v12; 
  GfxCmdBufContext v13; 
  R_RT_Handle m_waterFloatZRt; 
  R_RT_Handle v15; 
  R_RT_ColorHandle m_mainSceneColorRt; 
  R_RT_ColorHandle m_mainSceneAlphaRt; 
  R_RT_Handle v18; 
  R_RT_Handle v19; 
  R_RT_ColorHandle v20; 
  R_RT_ColorHandle v21; 
  R_RT_Group v22; 
  R_RT_Group rtGroup; 
  R_RT_Group v24; 

  if ( &data->viewInfo[data->viewInfoIndex] != viewInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 5640, ASSERT_TYPE_ASSERT, "(&data->viewInfo[data->viewInfoIndex] == viewInfo)", (const char *)&queryFormat, "&data->viewInfo[data->viewInfoIndex] == viewInfo") )
    __debugbreak();
  state = gfxContext->state;
  m_mainSceneColorRt = viewInfo->sceneRtInput.m_mainSceneColorRt;
  R_AddRenderTargetTransition(state, &m_mainSceneColorRt, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  m_mainSceneAlphaRt = viewInfo->sceneRtInput.m_mainSceneAlphaRt;
  R_AddRenderTargetTransition(state, &m_mainSceneAlphaRt, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  R_FlushResourceTransitions(state);
  R_Draw_GetRtGroup(viewInfo, DRAWLIST_LIT_TRANS, &rtGroup);
  m_waterFloatZRt = (R_RT_Handle)viewInfo->sceneRtInput.m_waterFloatZRt;
  v15 = m_waterFloatZRt;
  Surface = R_RT_Handle::GetSurface(&v15);
  Resident = R_Texture_GetResident(Surface->m_image.m_base.textureId);
  R_HW_AddResourceTransition(state, Resident, 0xFFFFFFFF, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  R_FlushResourceTransitions(state);
  v18 = m_waterFloatZRt;
  R_RT_Group::AssignColor(&v22, (R_RT_ColorHandle *)&v18);
  *(__m256i *)&v24.m_colorRtCount = *(__m256i *)&v22.m_colorRtCount;
  *(__m256i *)&v24.m_colorRts[0].m_tracking.m_location = *(__m256i *)&v22.m_colorRts[0].m_tracking.m_location;
  *(__m256i *)&v24.m_colorRts[1].m_tracking.m_location = *(__m256i *)&v22.m_colorRts[1].m_tracking.m_location;
  *(__m256i *)&v24.m_colorRts[2].m_tracking.m_location = *(__m256i *)&v22.m_colorRts[2].m_tracking.m_location;
  v9 = *gfxContext;
  *(__m256i *)&v24.m_colorRts[3].m_tracking.m_location = *(__m256i *)&v22.m_colorRts[3].m_tracking.m_location;
  *(__m256i *)&v24.m_depthRt.m_tracking.m_location = *(__m256i *)&v22.m_depthRt.m_tracking.m_location;
  v24.m_vrsRt.m_tracking.m_location = v22.m_vrsRt.m_tracking.m_location;
  v13 = v9;
  R_ClearRenderTarget(&v13, &v24, 0xFu, 0);
  v10 = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
  if ( (viewInfo->matRenderFeatures & 4) != 0 )
  {
    v19 = v15;
    R_HW_AddResourceTransition(state, &v19, 0xFFFFFFFF, D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    R_FlushResourceTransitions(state);
  }
  RB_RunDrawList(viewInfo, data, &rtGroup, DRAWLIST_LIT_TRANS);
  if ( (viewInfo->matRenderFeatures & 4) == 0 )
    v10 = D3D12_RESOURCE_STATE_RENDER_TARGET;
  v11 = R_RT_Handle::GetSurface(&v15);
  v12 = R_Texture_GetResident(v11->m_image.m_base.textureId);
  R_HW_AddResourceTransition(state, v12, 0xFFFFFFFF, v10, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  R_FlushResourceTransitions(state);
  if ( (viewInfo->matRenderFeatures & 1) != 0 )
  {
    R_GPU_BeginTimer(GPU_TIMER_RESOLVE_DISTORTION_0);
    v20 = viewInfo->sceneRtInput.m_mainSceneColorRt;
    R_AddRenderTargetTransition(state, &v20, RENDERTARGET_TRANSITION_MODE_READ, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    R_FlushResourceTransitions(state);
    *(GfxCmdBufContext *)&m_waterFloatZRt.m_surfaceID = *gfxContext;
    RB_ResolveDistortion((GfxCmdBufContext *)&m_waterFloatZRt, viewInfo);
    v21 = viewInfo->sceneRtInput.m_mainSceneColorRt;
    R_AddRenderTargetTransition(state, &v21, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    R_FlushResourceTransitions(state);
    R_GPU_EndTimer();
  }
  RB_RunDrawList(viewInfo, data, &rtGroup, DRAWLIST_LIT_TRANS1);
}

/*
==============
RB_DrawHeightmapOverlay
==============
*/
void RB_DrawHeightmapOverlay(GfxCmdBufContext *gfxContext)
{
  __int128 v1; 
  __int128 v2; 
  __int128 v3; 
  __int128 v4; 
  __int128 v5; 
  __int128 v6; 
  __int64 viewInfoIndex; 
  GfxViewInfo *viewInfo; 
  __int64 voxelTreeZoneIndex; 
  GfxHeightfield *v11; 
  GfxCmdBufSourceState *source; 
  float v13; 
  float v14; 
  float v15; 
  __int64 renderTargetWidth; 
  float v17; 
  float v18; 
  float v19; 
  float v20; 
  __int128 v21; 
  float v24; 
  float v25; 
  float v26; 
  float v27; 
  float renderTargetHeight; 
  float v29; 
  GfxFont *v30; 
  const char *v31; 
  const char *v32; 
  GfxFont *debugFont; 
  const char *v34; 
  GfxCmdBufContext v35; 
  float v36; 
  float v37; 
  vec4_t out; 
  __int128 v39; 
  __int128 v40; 
  __int128 v41; 
  __int128 v42; 
  __int128 v43; 
  __int128 v44; 

  viewInfoIndex = backEndData->viewInfoIndex;
  viewInfo = backEndData->viewInfo;
  voxelTreeZoneIndex = (int)viewInfo[viewInfoIndex].input.voxelTreeZoneIndex;
  if ( (int)voxelTreeZoneIndex >= 0 && (int)voxelTreeZoneIndex < rgp.world->heightfieldCount )
  {
    v44 = v1;
    v43 = v2;
    v42 = v3;
    v41 = v4;
    v40 = v5;
    v11 = &rgp.world->heightfields[voxelTreeZoneIndex];
    v39 = v6;
    MatrixTransformPos44(&viewInfo[viewInfoIndex].viewParmsSet.frames[0].viewParms.camera.origin, &v11->lookupMatrix, &out);
    source = gfxContext->source;
    v13 = out.v[2];
    v14 = out.v[1];
    source->input.consts[38].v[0] = out.v[0];
    source->input.consts[38].v[1] = v14;
    source->input.consts[38].v[2] = v13;
    source->input.consts[38].v[3] = 0.0;
    ++source->constVersions[38];
    v15 = 1.0 / r_showHeightmapScale->current.value;
    renderTargetWidth = source->renderTargetWidth;
    v17 = (float)(1.0 - v15) * out.v[1];
    v18 = (float)(1.0 - v15) * out.v[0];
    v37 = v18 + v15;
    v19 = v11->bounds.halfSize.v[1] / v11->bounds.halfSize.v[0];
    v36 = v17 + v15;
    v21 = 0i64;
    v20 = (float)renderTargetWidth;
    *(float *)&v21 = v20 * 0.125;
    _XMM0 = v21;
    __asm { vmaxss  xmm10, xmm0, cs:__real@43800000 }
    *(float *)&_XMM0 = sinf_0((float)((float)(source->sceneDef.floatTime * 3.1415927) * 2.0) * 2.0);
    v24 = (float)((float)((float)((float)(1.0 - (float)((float)(*(float *)&_XMM0 + 1.0) * 0.5)) * 0.5) + (float)((float)(*(float *)&_XMM0 + 1.0) * 0.5)) * (float)(8.0 / *(float *)&_XMM10)) * v15;
    v25 = *(float *)&_XMM10;
    v26 = *(float *)&_XMM10;
    v27 = *(float *)&_XMM10 * v19;
    if ( v19 <= 1.0 )
    {
      v26 = *(float *)&_XMM10 * v19;
      if ( v27 > (float)(v20 * 0.75) )
      {
        v26 = v20 * 0.75;
        v25 = (float)((float)(v20 * 0.75) / v27) * *(float *)&_XMM10;
      }
      source->input.consts[39].v[0] = v19;
      source->input.consts[39].v[1] = 1.0;
    }
    else
    {
      renderTargetHeight = (float)source->renderTargetHeight;
      v29 = renderTargetHeight * 0.75;
      v25 = *(float *)&_XMM10 * v19;
      if ( v27 > v29 )
      {
        v26 = (float)(v29 / v27) * *(float *)&_XMM10;
        v25 = v29;
      }
      source->input.consts[39].v[1] = v19;
      source->input.consts[39].v[0] = 1.0;
    }
    source->input.consts[39].v[2] = v24;
    source->input.consts[39].v[3] = 0.0;
    ++source->constVersions[39];
    R_SetCodeImageTextureInternal(source, 4u, v11->image, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(5079)");
    v35 = *gfxContext;
    RB_DrawStretchPic(&v35, rgp.showHeightmap, 8.0, 8.0, v26, v25, v18, v17, v37, v36, 0xFFFFFFFF, GFX_PRIM_STATS_HUD);
    v35 = *gfxContext;
    RB_EndTessSurfaceInternal(&v35, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(5081)");
    if ( out.v[0] < 0.0 || out.v[0] > 1.0 || out.v[1] < 0.0 || out.v[1] > 1.0 || out.v[2] < 0.0 || out.v[2] > 1.0 )
    {
      debugFont = backEnd.debugFont;
      v34 = j_va("camera is outside zone%d heightmap coverage", (unsigned int)voxelTreeZoneIndex);
      v35 = *gfxContext;
      RB_DrawText(&v35, v34, debugFont, 8.0, v25 + 28.0, (const GfxColor)-16776961);
      v32 = "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(5103)";
    }
    else
    {
      v30 = backEnd.debugFont;
      v31 = j_va("zone%d image=%dx%d bound=%3.0fx%3.0fx%3.0f zoom=%4.1f", (unsigned int)voxelTreeZoneIndex, v11->image->width, v11->image->height, (float)(v11->bounds.halfSize.v[0] * 2.0), (float)(v11->bounds.halfSize.v[1] * 2.0), (float)(v11->bounds.halfSize.v[2] * 2.0), r_showHeightmapScale->current.value);
      v35 = *gfxContext;
      RB_DrawText(&v35, v31, v30, 8.0, v25 + 28.0, (const GfxColor)-1);
      v32 = "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(5095)";
    }
    v35 = *gfxContext;
    RB_EndTessSurfaceInternal(&v35, v32);
  }
}

/*
==============
RB_DrawLightmapOverlap
==============
*/
void RB_DrawLightmapOverlap(GfxCmdBufContext *gfxContext, const GfxBackEndData *data, unsigned int drawLightmap)
{
  signed __int64 v3; 
  __int128 v4; 
  __int128 v5; 
  __int128 v6; 
  __int128 v7; 
  __int128 v8; 
  __int128 v9; 
  __int128 v10; 
  void *v11; 
  GfxCmdBufContext *v13; 
  GfxLightmapType lightmapType; 
  unsigned int v15; 
  unsigned int v16; 
  float v17; 
  __int128 v19; 
  float displayHeight; 
  __int128 v22; 
  float v23; 
  GfxCmdBufContext v24; 
  unsigned int v25; 
  GfxCmdBufSourceState *source; 
  __int128 v27; 
  float v28; 
  const GfxImage *LightmapAtlasTexture; 
  __int128 v30; 
  __int128 v31; 
  __int64 *v32; 
  unsigned int v33; 
  signed int v34; 
  __int128 v35; 
  float v36; 
  const GfxImage *v37; 
  GfxFont *debugFont; 
  const char *v39; 
  GfxFont *v40; 
  float v41; 
  const char *v42; 
  __int128 v43; 
  unsigned int LightmapAtlasLightmapsCount; 
  XZoneHandleUnique *worldIndex; 
  GfxCmdBufContext *v46; 
  unsigned int v47; 
  unsigned __int16 *p_m_zoneIndex; 
  __int64 v49; 
  const char *ZoneNameFromIndex; 
  GfxFont *v51; 
  const char *v52; 
  GfxFont *v53; 
  __int128 v54; 
  unsigned int v55; 
  const char *v56; 
  const char *v57; 
  GfxCmdBufContext v58; 
  RB_DrawLightmapOverlap::__l2::<lambda_4b68385f17aa2fbc2ee34f13383fa2c0> v59; 
  unsigned int v60; 
  unsigned int NumLightmapAtlasSlices; 
  GfxCmdBufContext *v62; 
  __int64 v63; 
  RB_DrawLightmapOverlap::__l2::DebugLightmapDesc _Last[1024]; 
  __int128 v65; 
  __int128 v66; 
  __int128 v67; 
  __int128 v68; 
  __int128 v69; 
  __int128 v70; 
  __int128 v71; 

  v11 = alloca(v3);
  v13 = gfxContext;
  lightmapType = g_worldDraw->lightmapType;
  v71 = v4;
  v70 = v5;
  v62 = gfxContext;
  v68 = v7;
  v65 = v10;
  v15 = 0;
  NumLightmapAtlasSlices = RB_GetNumLightmapAtlasSlices(data, lightmapType);
  v16 = 0;
  v60 = 0;
  v17 = (float)NumLightmapAtlasSlices;
  v19 = LODWORD(FLOAT_1_0);
  *(float *)&v19 = 1.0 / v17;
  _XMM0 = v19;
  __asm { vminss  xmm2, xmm0, cs:__real@3e4ccccd }
  displayHeight = (float)vidConfig.displayHeight;
  v22 = LODWORD(FLOAT_8_0);
  if ( NumLightmapAtlasSlices )
  {
    v69 = v6;
    v67 = v8;
    v66 = v9;
    v23 = (float)(*(float *)&_XMM2 * displayHeight) + 1.0;
    do
    {
      v24 = *v13;
      v25 = 0;
      v58 = *v13;
      source = v58.source;
      v27 = LODWORD(FLOAT_8_0);
      do
      {
        LightmapAtlasTexture = R_GetLightmapAtlasTexture(data, g_worldDraw->lightmapType, v25);
        if ( !source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
          __debugbreak();
        if ( source == (GfxCmdBufSourceState *)-1792i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
          __debugbreak();
        v28 = (float)v16;
        source->input.consts[149].v[0] = v28;
        source->input.codeImages[4] = LightmapAtlasTexture;
        *(_QWORD *)&source->input.consts[149].xyz.y = 0i64;
        source->input.consts[149].v[3] = 0.0;
        ++source->constVersions[149];
        v58 = v24;
        RB_DrawStretchPic(&v58, rgp.lightmapAtlasDebugMaterial, *(float *)&v22, *(float *)&v27, *(float *)&_XMM2 * displayHeight, *(float *)&_XMM2 * displayHeight, 0.0, 0.0, 1.0, 1.0, 0xFFFFFFFF, GFX_PRIM_STATS_HUD);
        v58 = v24;
        RB_EndTessSurfaceInternal(&v58, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(4883)");
        ++v25;
        v30 = v27;
        *(float *)&v30 = *(float *)&v27 + v23;
        v27 = v30;
      }
      while ( v25 < 3 );
      v13 = v62;
      v16 = v60 + 1;
      v31 = v22;
      *(float *)&v31 = *(float *)&v22 + v23;
      v22 = v31;
      v60 = v16;
    }
    while ( v16 < NumLightmapAtlasSlices );
  }
  v32 = &v63;
  v33 = 0;
  v34 = 0;
  v35 = 0i64;
  *(float *)&v35 = (float)backEnd.debugFont->pixelHeight + 8.0;
  v36 = *(float *)&v22 + 1.0;
  do
  {
    v37 = R_GetLightmapAtlasTexture(data, g_worldDraw->lightmapType, v34++);
    *v32++ = (__int64)v37;
    v33 += v37->totalSize;
  }
  while ( v34 < 3 );
  v58 = *v13;
  RB_DrawText(&v58, "Lightmap atlas stats", backEnd.debugFont, *(float *)&v22 + 1.0, *(float *)&v35, (const GfxColor)-1);
  *(float *)&v35 = *(float *)&v35 + (float)((float)backEnd.debugFont->pixelHeight + 3.0);
  v58 = *v13;
  RB_DrawText(&v58, "--------------------", backEnd.debugFont, v36, *(float *)&v35, (const GfxColor)-1);
  debugFont = backEnd.debugFont;
  *(float *)&v35 = *(float *)&v35 + (float)((float)backEnd.debugFont->pixelHeight + 3.0);
  v39 = j_va("Size: %dx%d, num slices %d", *(unsigned __int16 *)(v63 + 36), *(unsigned __int16 *)(v63 + 38), NumLightmapAtlasSlices);
  v58 = *v13;
  RB_DrawText(&v58, v39, debugFont, v36, *(float *)&v35, (const GfxColor)-1);
  v40 = backEnd.debugFont;
  v41 = (float)v33;
  *(float *)&v35 = *(float *)&v35 + (float)((float)backEnd.debugFont->pixelHeight + 3.0);
  v42 = j_va("Setup type: %s, atlas memory %.2f MB", lightmapTypeNames[g_worldDraw->lightmapType], (float)(v41 * 0.00000095367432));
  v58 = *v13;
  RB_DrawText(&v58, v42, v40, v36, *(float *)&v35, (const GfxColor)-1);
  *(float *)&v35 = *(float *)&v35 + (float)((float)backEnd.debugFont->pixelHeight + 3.0);
  v43 = v35;
  LightmapAtlasLightmapsCount = RB_Debug_GetLightmapAtlasLightmapsCount(data, g_worldDraw->lightmapType);
  if ( LightmapAtlasLightmapsCount > 0x400 )
    LightmapAtlasLightmapsCount = 1024;
  if ( LightmapAtlasLightmapsCount )
  {
    worldIndex = (XZoneHandleUnique *)&_Last[0].worldIndex;
    do
    {
      RB_Debug_GetLightmapAtlasLightmapDesc(data, g_worldDraw->lightmapType, v15++, &worldIndex[-2].m_packed, &worldIndex[-1].m_packed, &worldIndex->m_packed, worldIndex + 1);
      worldIndex += 4;
    }
    while ( v15 < LightmapAtlasLightmapsCount );
  }
  std::_Sort_unchecked__RB_DrawLightmapOverlap_::_2_::DebugLightmapDesc____lambda_4b68385f17aa2fbc2ee34f13383fa2c0___(_Last, &_Last[LightmapAtlasLightmapsCount], LightmapAtlasLightmapsCount, v59);
  v46 = v62;
  v47 = 20;
  if ( LightmapAtlasLightmapsCount < 0x14 )
    v47 = LightmapAtlasLightmapsCount;
  if ( v47 )
  {
    p_m_zoneIndex = &_Last[0].zone.m_zoneIndex;
    v49 = v47;
    do
    {
      if ( DB_Zones_IsValidZoneIndex(*p_m_zoneIndex) )
        ZoneNameFromIndex = DB_Zones_GetZoneNameFromIndex(*p_m_zoneIndex);
      else
        ZoneNameFromIndex = "<unloading>";
      v51 = backEnd.debugFont;
      v52 = j_va("Lightmap %03d, %dx%d, zone %s", *(unsigned int *)(p_m_zoneIndex - 3), *(unsigned int *)(p_m_zoneIndex - 7), *(unsigned int *)(p_m_zoneIndex - 5), ZoneNameFromIndex);
      v58 = *v46;
      RB_DrawText(&v58, v52, v51, v36, *(float *)&v43, (const GfxColor)-1);
      v53 = backEnd.debugFont;
      p_m_zoneIndex += 8;
      v54 = v43;
      *(float *)&v54 = *(float *)&v43 + (float)((float)backEnd.debugFont->pixelHeight + 3.0);
      v43 = v54;
      --v49;
    }
    while ( v49 );
  }
  else
  {
    v53 = backEnd.debugFont;
  }
  if ( v47 < LightmapAtlasLightmapsCount )
  {
    v55 = LightmapAtlasLightmapsCount - v47;
    v56 = "s";
    if ( v55 == 1 )
      v56 = (char *)&queryFormat.fmt + 3;
    v57 = j_va("...and %d more, smaller one%s", v55, v56);
    v58 = *v46;
    RB_DrawText(&v58, v57, v53, v36, *(float *)&v43, (const GfxColor)-1);
  }
  v58 = *v46;
  RB_EndTessSurfaceInternal(&v58, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(5016)");
}

/*
==============
RB_DrawPrepass
==============
*/
void RB_DrawPrepass(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  __int128 v3; 
  unsigned __int16 m_surfaceID; 
  __m256i m_mainSceneTangentFrameRt; 
  __int16 v8; 
  __int16 v9; 
  GfxCmdBufSourceState *m_location; 
  bool v12; 
  __int64 v13; 
  __int64 v14; 
  GfxCmdBufContext *v16; 
  unsigned __int64 v17; 
  GfxCmdBufContext v18; 
  __m256i m_mainSceneEntityIDVelocityRt; 
  unsigned int height; 
  const R_RT_Surface *Surface; 
  float v22; 
  float width; 
  const R_RT_Surface *v24; 
  const GfxTexture *Resident; 
  CmdBufState *state; 
  GfxCmdBufContext v27; 
  GfxDrawListType i; 
  GfxCmdBufSourceState *source[4]; 
  unsigned __int64 v31; 
  GfxCmdBufContext v32; 
  GfxCmdBufContext v33; 
  GfxCmdBufContext v34; 
  R_RT_Handle v35; 
  R_RT_Handle m_mainSceneColorRt; 
  __m256i m_ssrMaskRt; 
  R_RT_Handle v38; 
  R_RT_DepthHandle m_mainSceneDepthRt; 
  __m256i v40; 
  __m256i v41; 
  __m256i v42; 
  R_RT_Group v43; 
  R_RT_Group rtGroup; 
  R_RT_Group v45; 
  _BYTE v46[64]; 
  __int128 v47; 

  Profile2_UpdateEntry(54);
  v31 = (unsigned __int64)&dword_14FDE80A8 & 3;
  if ( ((unsigned __int8)&dword_14FDE80A8 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE80A8) )
    __debugbreak();
  _InterlockedIncrement(&dword_14FDE80A8);
  m_surfaceID = viewInfo->sceneRtInput.m_mainSceneDepthRt.m_surfaceID;
  m_mainSceneTangentFrameRt = (__m256i)viewInfo->sceneRtInput.m_mainSceneTangentFrameRt;
  *(R_RT_ColorHandle *)v46 = viewInfo->sceneRtInput.m_mainSceneEntityIDVelocityRt;
  *(__m256i *)&v46[32] = m_mainSceneTangentFrameRt;
  v8 = m_surfaceID & 0x7FFF;
  if ( v8 )
    v9 = v8 | 0x8000;
  else
    v9 = 0;
  LOWORD(source[0]) = v9;
  _XMM0 = *(_OWORD *)&viewInfo->sceneRtInput.m_mainSceneDepthRt.m_tracking.m_allocCounter;
  m_location = (GfxCmdBufSourceState *)viewInfo->sceneRtInput.m_mainSceneDepthRt.m_tracking.m_location;
  *(_OWORD *)&source[1] = _XMM0;
  source[3] = m_location;
  v35 = *(R_RT_Handle *)source;
  if ( v9 )
  {
    R_RT_Handle::GetSurface(&v35);
    if ( (R_RT_Handle::GetSurface(&v35)->m_rtFlagsInternal & 0x10) != 0 )
      goto LABEL_14;
    v12 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 277, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsDepth())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsDepth()");
  }
  else
  {
    if ( !LODWORD(source[1]) )
      goto LABEL_14;
    v12 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
  }
  if ( v12 )
    __debugbreak();
LABEL_14:
  v13 = 0i64;
  rtGroup.m_colorRtCount = 2;
  v14 = 2i64;
  do
  {
    v38 = *(R_RT_Handle *)&v46[v13 * 32];
    if ( (_WORD)_XMM0 )
    {
      R_RT_Handle::GetSurface(&v38);
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 442, ASSERT_TYPE_ASSERT, "(colorRt)", (const char *)&queryFormat, "colorRt") )
        __debugbreak();
    }
    rtGroup.m_colorRts[v13] = *(R_RT_ColorHandle *)&v46[v13 * 32];
    ++v13;
    --v14;
  }
  while ( v14 );
  rtGroup.m_depthRt = (R_RT_DepthHandle)v35;
  RB_RunDrawList(viewInfo, data, &rtGroup, DRAWLIST_FRONTEND_COUNT);
  RB_RunDrawList(viewInfo, data, &rtGroup, DRAWLIST_PREPASS_DEPTH_HACK_SSS);
  v16 = gfxContext;
  v17 = v31;
  v18 = *gfxContext;
  *(GfxCmdBufContext *)source = *gfxContext;
  if ( data->scope.scopeUseDualFov )
  {
    v47 = v3;
    if ( !data->scope.adsSmoothFade || data->scope.scopeFadeInfo[0].fadeInFrac != 0.0 )
    {
      R_InitCmdBufSourceState(source[0], &viewInfo->input);
      R_InitLocalCmdBufState((GfxCmdBufState *)source[1], &source[0]->input);
      R_ProfBeginNamedEvent((CmdBufState *)source[1], "Scope Depth Clear");
      R_BeginViewInternal(source[0], &viewInfo->sceneDef, (const GfxViewParms *)viewInfo, &viewInfo->viewParmsSet.frames[1].viewParms);
      R_SetViewportStruct(source[0], &viewInfo->sceneViewport);
      m_mainSceneEntityIDVelocityRt = (__m256i)viewInfo->sceneRtInput.m_mainSceneEntityIDVelocityRt;
      m_mainSceneDepthRt = viewInfo->sceneRtInput.m_mainSceneDepthRt;
      v32 = *gfxContext;
      v40 = m_mainSceneEntityIDVelocityRt;
      R_SetRenderTargetsInternal_ColorDepth(&v32, (R_RT_ColorHandle *)&v40, &m_mainSceneDepthRt, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(5500)");
      m_mainSceneColorRt = (R_RT_Handle)viewInfo->sceneRtInput.m_mainSceneColorRt;
      height = R_RT_Handle::GetSurface(&m_mainSceneColorRt)->m_image.m_base.height;
      Surface = R_RT_Handle::GetSurface(&m_mainSceneColorRt);
      R_SetRenderTargetSize(source[0], Surface->m_image.m_base.width, height, GFX_USE_VIEWPORT_FOR_VIEW);
      v22 = (float)viewInfo->sceneViewport.height;
      width = (float)viewInfo->sceneViewport.width;
      v33 = *gfxContext;
      LOWORD(v18.source) = LOWORD(FLOAT_1_0);
      RB_ViewportFilterDirectInternal(&v33, rgp.scopeUIDepthClear, 0xFFFFFFFF, &viewInfo->sceneViewport, 0.0, 0.0, width, v22, 0.0, 0.0, 1.0, 1.0, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(5504)");
      R_ProfEndNamedEvent((CmdBufState *)source[1]);
      R_ShutdownLocalCmdBufState((GfxCmdBufState *)source[1], &source[0]->input);
      v17 = v31;
      v16 = gfxContext;
    }
  }
  RB_RunDrawList(viewInfo, data, &rtGroup, DRAWLIST_PREPASS_PRE_OPAQUE);
  RB_RunDrawList(viewInfo, data, &rtGroup, DRAWLIST_PREPASS_PRE_SSS);
  m_ssrMaskRt = (__m256i)viewInfo->sceneRtInput.m_ssrMaskRt;
  *(__m256i *)source = m_ssrMaskRt;
  if ( LOWORD(v18.source) )
  {
    R_RT_Handle::GetSurface((R_RT_Handle *)source);
    v24 = R_RT_Handle::GetSurface((R_RT_Handle *)source);
    Resident = R_Texture_GetResident(v24->m_image.m_base.textureId);
    state = v16->state;
    R_HW_AddResourceTransition(state, Resident, 0xFFFFFFFF, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    R_FlushResourceTransitions(state);
    v41 = m_ssrMaskRt;
    R_RT_Group::AssignColor(&v43, (R_RT_ColorHandle *)&v41);
    *(__m256i *)&v45.m_colorRtCount = *(__m256i *)&v43.m_colorRtCount;
    *(__m256i *)&v45.m_colorRts[0].m_tracking.m_location = *(__m256i *)&v43.m_colorRts[0].m_tracking.m_location;
    *(__m256i *)&v45.m_colorRts[1].m_tracking.m_location = *(__m256i *)&v43.m_colorRts[1].m_tracking.m_location;
    *(__m256i *)&v45.m_colorRts[2].m_tracking.m_location = *(__m256i *)&v43.m_colorRts[2].m_tracking.m_location;
    v27 = *v16;
    *(__m256i *)&v45.m_colorRts[3].m_tracking.m_location = *(__m256i *)&v43.m_colorRts[3].m_tracking.m_location;
    *(__m256i *)&v45.m_depthRt.m_tracking.m_location = *(__m256i *)&v43.m_depthRt.m_tracking.m_location;
    v45.m_vrsRt.m_tracking.m_location = v43.m_vrsRt.m_tracking.m_location;
    v34 = v27;
    R_ClearRenderTarget(&v34, &v45, 0xFu, 0);
    v42 = m_ssrMaskRt;
    R_HW_AddResourceTransition(state, (R_RT_Handle *)&v42, 0xFFFFFFFF, D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    R_FlushResourceTransitions(state);
  }
  else if ( LODWORD(source[1]) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
  {
    __debugbreak();
  }
  if ( (*((_BYTE *)&viewInfo->input + 7920) & 2) != 0 )
  {
    for ( i = DRAWLIST_PREPASS_LIT_OPAQUE; i != DRAWLIST_PREPASS_LIT_OPAQUE_END; ++i )
      RB_RunDrawList(viewInfo, data, &rtGroup, i);
  }
  else
  {
    RB_RunDrawList(viewInfo, data, &rtGroup, DRAWLIST_PREPASS_LIT_OPAQUE);
  }
  RB_RunDrawList(viewInfo, data, &rtGroup, DRAWLIST_PREPASS_LIT_OPAQUE_END);
  RB_RunDrawList(viewInfo, data, &rtGroup, DRAWLIST_PREPASS_EID_ONLY);
  RB_RunDrawList(viewInfo, data, &rtGroup, DRAWLIST_PREPASS_LIT_OPAQUE_GLASS);
  RB_RunDrawList(viewInfo, data, &rtGroup, DRAWLIST_PREPASS_LIT_DECAL);
  RB_RunDrawList(viewInfo, data, &rtGroup, DRAWLIST_PREPASS_LIT_TRANS);
  RB_RunDrawList(viewInfo, data, &rtGroup, DRAWLIST_PREPASS_LIT_TRANS1);
  RB_RunDrawList(viewInfo, data, &rtGroup, DRAWLIST_PREPASS_DEPTH_HACK_TRANS);
  Profile2_UpdateEntry(54);
  if ( v17 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 44, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE80A8) )
    __debugbreak();
  _InterlockedDecrement(&dword_14FDE80A8);
}

/*
==============
RB_DrawRttOverlay
==============
*/
void RB_DrawRttOverlay(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, unsigned int drawRttOverlay)
{
  __int64 v3; 
  unsigned int v4; 
  LocalClientNum_t clientIndex; 
  __int128 v6; 
  __int64 v7; 
  unsigned int v8; 
  int v9; 
  __int64 v10; 
  unsigned int v11; 
  __int64 v12; 
  __int64 v13; 
  unsigned int UpdateCount; 
  const GfxImage *v15; 
  const char *v16; 
  unsigned int v17; 
  float v18; 
  int v19; 
  float v20; 
  float v21; 
  float v22; 
  __int128 v23; 
  const GfxImage *Image; 
  GfxImage *blackImage; 
  const char *Name; 
  unsigned int v27; 
  float width; 
  int height; 
  __int128 v31; 
  GfxCmdBufContext v33; 
  int v36; 

  v3 = 0i64;
  v4 = drawRttOverlay;
  if ( backEndData->viewInfoCount )
    clientIndex = backEndData->viewInfo[backEndData->viewInfoIndex].clientIndex;
  else
    clientIndex = LOCAL_CLIENT_0;
  v6 = LODWORD(FLOAT_8_0);
  v7 = clientIndex;
  v36 = Sys_MillisecondsRaw();
  v8 = 1;
  v9 = v36 - s_timeUpdated[clientIndex];
  v10 = 8i64;
  if ( v9 > 1000 )
  {
    v11 = 1;
    v12 = 8i64;
    v13 = 8i64 * (int)clientIndex;
    do
    {
      if ( RB_RTT_GetImage(clientIndex, v11) )
      {
        s_fps[0][v13] = (float)(int)(RB_RTT_GetUpdateCount(clientIndex, v11) - s_updateCount[0][v13]) * (float)(999.99994 / (float)v9);
        UpdateCount = RB_RTT_GetUpdateCount(clientIndex, v11);
      }
      else
      {
        s_fps[0][v13] = 0.0;
        UpdateCount = 0;
      }
      s_updateCount[0][v13] = UpdateCount;
      ++v11;
      ++v13;
      --v12;
    }
    while ( v12 );
    v4 = drawRttOverlay;
    v10 = 8i64;
    v7 = clientIndex;
    s_timeUpdated[clientIndex] = v36;
  }
  if ( v4 )
  {
    if ( v4 <= 8 )
    {
      Image = RB_RTT_GetImage(clientIndex, v4);
      blackImage = rgp.blackImage;
      if ( Image )
        blackImage = (GfxImage *)Image;
      Name = R_RTT_GetName(v4);
      v27 = RB_RTT_GetUpdateCount(clientIndex, v4);
      width = (float)blackImage->width;
      height = blackImage->height;
      v31 = LODWORD(FLOAT_256_0);
      *(float *)&v31 = 256.0 / width;
      _XMM1 = v31;
      __asm { vmaxss  xmm2, xmm1, cs:__real@3f800000 }
      v33 = *gfxContext;
      RB_DrawRttOverlaySingle(&v33, Name, blackImage, v27, s_fps[v7 - 1][v4 + 7], 8.0, 8.0, width * *(float *)&_XMM2, (float)height * *(float *)&_XMM2);
    }
  }
  else
  {
    do
    {
      v15 = RB_RTT_GetImage(clientIndex, v8);
      if ( v15 )
      {
        v16 = s_rttAlias_0[v3];
        v17 = RB_RTT_GetUpdateCount(clientIndex, v8);
        v18 = (float)v15->width;
        v19 = v15->height;
        v20 = 256.0 / v18;
        v21 = v18 * (float)(256.0 / v18);
        v33 = *gfxContext;
        RB_DrawRttOverlaySingle(&v33, v16, v15, v17, s_fps[v7][v3], *(float *)&v6, 8.0, v21, (float)v19 * v20);
        v22 = v21 + 2.0;
        v23 = v6;
        *(float *)&v23 = *(float *)&v6 + v22;
        v6 = v23;
      }
      ++v8;
      ++v3;
      --v10;
    }
    while ( v10 );
  }
}

/*
==============
RB_DrawRttOverlaySingle
==============
*/
void RB_DrawRttOverlaySingle(GfxCmdBufContext *gfxContext, const char *name, const GfxImage *image, const unsigned int updateCount, float fps, float x0, float y0, float w, float h)
{
  GfxCmdBufSourceState *source; 
  GfxCmdBufInput *p_input; 
  GfxFont *debugFont; 
  const char *v16; 
  GfxFont *v17; 
  const char *v18; 
  GfxFont *v19; 
  const char *v20; 
  GfxFont *v21; 
  const char *v22; 
  GfxCmdBufContext v23[5]; 

  v23[0] = *gfxContext;
  RB_SetUIColorimetryParams(v23);
  v23[0] = *gfxContext;
  RB_DrawRect2D(v23, x0, y0, w, h + 80.0, (const GfxColor)-8355712);
  v23[0] = *gfxContext;
  RB_EndTessSurfaceInternal(v23, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(5120)");
  source = gfxContext->source;
  if ( !gfxContext->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  p_input = &source->input;
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  v23[0] = *gfxContext;
  p_input->codeImages[4] = image;
  RB_DrawStretchPic(v23, rgp.iconMaterial, x0, y0, w, h, 0.0, 0.0, 1.0, 1.0, 0xFFFFFFFF, GFX_PRIM_STATS_HUD);
  v23[0] = *gfxContext;
  RB_EndTessSurfaceInternal(v23, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(5125)");
  debugFont = backEnd.debugFont;
  v16 = j_va((const char *)&queryFormat, name);
  v23[0] = *gfxContext;
  RB_DrawText(v23, v16, debugFont, x0, (float)(y0 + h) + 20.0, (const GfxColor)-1);
  v17 = backEnd.debugFont;
  v18 = j_va("%dx%d", image->width, image->height);
  v23[0] = *gfxContext;
  RB_DrawText(v23, v18, v17, x0, (float)(y0 + h) + 40.0, (const GfxColor)-1);
  v19 = backEnd.debugFont;
  v20 = j_va("updated:%d", updateCount);
  v23[0] = *gfxContext;
  RB_DrawText(v23, v20, v19, x0, (float)(y0 + h) + 60.0, (const GfxColor)-1);
  v21 = backEnd.debugFont;
  v22 = j_va("fps:%.2f", fps);
  v23[0] = *gfxContext;
  RB_DrawText(v23, v22, v21, x0, (float)(y0 + h) + 80.0, (const GfxColor)-1);
  v23[0] = *gfxContext;
  RB_EndTessSurfaceInternal(v23, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(5134)");
}

/*
==============
RB_DrawScreenshot2DHud
==============
*/
void RB_DrawScreenshot2DHud(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, R_RT_Handle *packedStencil)
{
  ;
}

/*
==============
RB_DrawUmbraOverlays
==============
*/
void RB_DrawUmbraOverlays(GfxCmdBufContext *gfxContext)
{
  GfxCmdBufSourceState *source; 
  GfxImage *umbraOcclusionScene; 
  GfxCmdBufInput *p_input; 
  GfxCmdBufContext v5; 
  GfxCmdBufContext v6; 

  source = gfxContext->source;
  umbraOcclusionScene = rgp.umbraOcclusionScene;
  if ( !gfxContext->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  p_input = &source->input;
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  v5 = *gfxContext;
  p_input->codeImages[4] = umbraOcclusionScene;
  v6 = v5;
  RB_DrawStretchPic(&v6, rgp.feedbackReplaceBackbufferMaterial, 64.0, 64.0, (float)umbraOcclusionScene->width * r_umbraShowOverlayDisplaySizeScale->current.value, (float)umbraOcclusionScene->height * r_umbraShowOverlayDisplaySizeScale->current.value, 0.0, 1.0, 1.0, 0.0, 0xFFFFFFFF, GFX_PRIM_STATS_HUD);
  v6 = *gfxContext;
  RB_EndTessSurfaceInternal(&v6, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(4771)");
}

/*
==============
RB_EnableMSEmissive
==============
*/
void RB_EnableMSEmissive(GfxCmdBufContext *context, const GfxViewInfo *viewInfo)
{
  const GfxBackEndData *data; 
  GfxCmdBufContext v3; 

  data = viewInfo->input.data;
  v3 = *context;
  R_HW_EnableMultiSample(&v3, data->frameCount);
}

/*
==============
RB_FinishComputeCmds
==============
*/
void RB_FinishComputeCmds(GfxCmdBufContext *gfxContext, const GfxBackEndData *data)
{
  const GfxBackEndData *v3; 
  GfxCmdBufContext v4; 
  const GfxBackEndData *timeoutUserData; 

  timeoutUserData = data;
  Profile2_UpdateEntry(48);
  if ( ((unsigned __int8)&dword_14FDE8090 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE8090) )
    __debugbreak();
  _InterlockedIncrement(&dword_14FDE8090);
  v3 = timeoutUserData;
  if ( !timeoutUserData->compute.smpEnabled )
  {
    Sys_ProfBeginNamedEvent(0xFFFFA500, "wait compute ready");
    Sys_ProcessWorkerCmdsWithTimeout(RB_IsComputeReady, &timeoutUserData);
    Sys_WaitWorkerCmdsOfType(WRKCMD_UGB_MAKE_XSURFS_RESIDENT_DISPATCH);
    Sys_WaitWorkerCmdsOfType(WRKCMD_INIT_UGB_BACKEND);
    Sys_ProfEndNamedEvent();
    v3 = timeoutUserData;
  }
  v4 = *gfxContext;
  R_FinishComputeCmdList(&v4, v3);
  Profile2_UpdateEntry(48);
  if ( ((unsigned __int64)&dword_14FDE8090 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 44, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE8090) )
    __debugbreak();
  _InterlockedDecrement(&dword_14FDE8090);
}

/*
==============
RB_HalfResEmissive_DownsampleDepth
==============
*/
void RB_HalfResEmissive_DownsampleDepth(GfxCmdBufContext *context, const GfxViewInfo *viewInfo)
{
  GfxCmdBufSourceState *source; 
  GfxCmdBufState *state; 
  unsigned int height; 
  const R_RT_Surface *Surface; 
  GfxCmdBufContext v8; 
  GfxCmdBufContext v9; 
  GfxCmdBufContext v10; 
  R_RT_Image *p_m_image; 
  float v12; 
  float width; 
  R_RT_Image *v14; 
  __int64 v15; 
  R_RT_Handle m_halfSceneDepthRt; 
  R_RT_Handle m_mainSceneDepthRt; 

  source = context->source;
  state = context->state;
  R_GPU_BeginTimer(GPU_TIMER_EMISSIVE_COPY);
  R_InitCmdBufSourceState(source, &viewInfo->input);
  R_InitLocalCmdBufState(state, &source->input);
  R_ProfBeginNamedEvent(state, "downsample depth");
  m_halfSceneDepthRt = (R_RT_Handle)viewInfo->sceneRtInput.m_halfSceneDepthRt;
  R_AddDepthStencilTransition(state, (R_RT_DepthHandle *)&m_halfSceneDepthRt, DEPTHSTENCIL_TRANSITION_MODE_WRITE_PRESERVE_COMPRESSION, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  R_FlushResourceTransitions(state);
  m_halfSceneDepthRt = (R_RT_Handle)viewInfo->sceneRtInput.m_halfSceneDepthRt;
  height = R_RT_Handle::GetSurface(&m_halfSceneDepthRt)->m_image.m_base.height;
  Surface = R_RT_Handle::GetSurface(&m_halfSceneDepthRt);
  R_SetRenderTargetSize(source, Surface->m_image.m_base.width, height, GFX_USE_VIEWPORT_FOR_VIEW);
  R_BeginViewInternal(source, &viewInfo->sceneDef, (const GfxViewParms *)viewInfo, &viewInfo->viewParmsSet.frames[1].viewParms);
  R_SetViewportStruct(source, &viewInfo->sceneEmissiveViewport);
  v8 = *context;
  m_mainSceneDepthRt = (R_RT_Handle)viewInfo->sceneRtInput.m_mainSceneDepthRt;
  *(GfxCmdBufContext *)&m_halfSceneDepthRt.m_surfaceID = v8;
  R_SetRenderTargetsInternal_DepthOnly((GfxCmdBufContext *)&m_halfSceneDepthRt, (R_RT_DepthHandle *)&m_mainSceneDepthRt, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(3036)");
  *(GfxCmdBufContext *)&m_halfSceneDepthRt.m_surfaceID = *context;
  R_ResolveDepth((GfxCmdBufContext *)&m_halfSceneDepthRt);
  v9 = *context;
  m_mainSceneDepthRt = (R_RT_Handle)viewInfo->sceneRtInput.m_halfSceneDepthRt;
  *(GfxCmdBufContext *)&m_halfSceneDepthRt.m_surfaceID = v9;
  R_SetRenderTargetsInternal_DepthOnly((GfxCmdBufContext *)&m_halfSceneDepthRt, (R_RT_DepthHandle *)&m_mainSceneDepthRt, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(3039)");
  v10 = *context;
  m_mainSceneDepthRt = (R_RT_Handle)viewInfo->sceneRtInput.m_mainSceneDepthRt;
  p_m_image = &R_RT_Handle::GetSurface(&m_mainSceneDepthRt)->m_image;
  if ( !v10.source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  if ( v10.source == (GfxCmdBufSourceState *)-1792i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  v10.source->input.codeImages[0] = &p_m_image->m_base;
  R_Set2D(v10.source);
  if ( v10.source->viewMode != VIEW_MODE_2D )
  {
    LODWORD(v15) = v10.source->viewMode;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 2990, ASSERT_TYPE_ASSERT, "( ( source->viewMode == VIEW_MODE_2D ) )", "( source->viewMode ) = %i", v15) )
      __debugbreak();
  }
  v12 = (float)viewInfo->sceneEmissiveViewport.height;
  width = (float)viewInfo->sceneEmissiveViewport.width;
  *(GfxCmdBufContext *)&m_halfSceneDepthRt.m_surfaceID = v10;
  RB_ViewportFilterDirectInternal((GfxCmdBufContext *)&m_halfSceneDepthRt, rgp.floatZWriteDepthDownsampleMaterial, 0xFFFFFFFF, &viewInfo->sceneEmissiveViewport, 0.0, 0.0, width, v12, 0.0, 0.0, 1.0, 1.0, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(2992)");
  v14 = &R_RT_Handle::GetSurface(&viewInfo->sceneRtInput.m_floatZFullRt)->m_image;
  if ( !source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  if ( source == (GfxCmdBufSourceState *)-1792i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  source->input.codeImages[0] = &v14->m_base;
  m_mainSceneDepthRt = (R_RT_Handle)viewInfo->sceneRtInput.m_mainSceneDepthRt;
  R_AddDepthStencilTransition(state, (R_RT_DepthHandle *)&m_mainSceneDepthRt, DEPTHSTENCIL_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  m_mainSceneDepthRt = (R_RT_Handle)viewInfo->sceneRtInput.m_halfSceneDepthRt;
  R_AddDepthStencilTransition(state, (R_RT_DepthHandle *)&m_mainSceneDepthRt, DEPTHSTENCIL_TRANSITION_MODE_READ_PRESERVE_COMPRESSION, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  R_FlushResourceTransitions(state);
  R_ProfEndNamedEvent(state);
  R_ShutdownLocalCmdBufState(state, &source->input);
  R_GPU_EndTimer();
}

/*
==============
RB_HalfRes_Upsample
==============
*/
void RB_HalfRes_Upsample(GfxCmdBufContext *context, const GfxViewInfo *viewInfo)
{
  R_RT_Handle v5; 
  unsigned __int16 m_surfaceID; 
  bool v8; 
  __int16 v9; 
  __int16 v10; 
  bool v12; 
  GfxCmdBufSourceState *source; 
  GfxCmdBufSourceState *v14; 
  GfxCmdBufContext v15; 
  GfxCmdBufContext v16; 
  unsigned int height; 
  const R_RT_Surface *Surface; 
  __m256i v19; 
  __m256i m_mainSceneAlphaRt; 
  __int64 v22; 
  __int64 v23; 
  GfxCmdBufSourceState *v25; 
  GfxCmdBufState *state; 
  __int64 v27; 
  R_RT_Handle m_mainSceneColorRt; 
  R_RT_Handle v29; 
  R_RT_Handle m_floatZFullRt; 
  R_RT_Handle v31; 
  R_RT_Handle m_halfSceneAlphaRt; 
  R_RT_Handle m_halfSceneColorRt; 
  R_RT_Handle v34; 
  R_RT_Group v35; 
  _BYTE v36[64]; 

  m_halfSceneColorRt = (R_RT_Handle)viewInfo->sceneRtInput.m_halfSceneColorRt;
  m_halfSceneAlphaRt = (R_RT_Handle)viewInfo->sceneRtInput.m_halfSceneAlphaRt;
  m_floatZFullRt = (R_RT_Handle)viewInfo->sceneRtInput.m_floatZFullRt;
  v5 = *R_RT_GetViewInternal(&v31, &m_floatZFullRt, 0, 1);
  m_surfaceID = _XMM0;
  m_floatZFullRt = v5;
  m_mainSceneColorRt = v5;
  if ( (_WORD)_XMM0 )
  {
    R_RT_Handle::GetSurface(&m_mainSceneColorRt);
    if ( (R_RT_Handle::GetSurface(&m_mainSceneColorRt)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      LODWORD(_RDI) = m_mainSceneColorRt.m_tracking.m_allocCounter;
      m_surfaceID = m_mainSceneColorRt.m_surfaceID;
      v5 = m_mainSceneColorRt;
      __debugbreak();
    }
    else
    {
      LODWORD(_RDI) = m_mainSceneColorRt.m_tracking.m_allocCounter;
      m_surfaceID = m_mainSceneColorRt.m_surfaceID;
      v5 = m_mainSceneColorRt;
    }
  }
  else
  {
    __asm { vpextrd rdi, xmm0, 2 }
    if ( (_DWORD)_RDI )
    {
      v8 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      v5 = m_floatZFullRt;
      if ( v8 )
        __debugbreak();
    }
  }
  v34 = v5;
  v9 = m_surfaceID & 0x7FFF;
  if ( v9 )
  {
    v10 = v9 | 0x8000;
    v29.m_surfaceID = v10;
  }
  else
  {
    v10 = 0;
    v29.m_surfaceID = 0;
  }
  _XMM0 = *(_OWORD *)&m_mainSceneColorRt.m_tracking.m_allocCounter;
  v29.m_tracking = m_mainSceneColorRt.m_tracking;
  m_floatZFullRt = v29;
  if ( v10 )
  {
    R_RT_Handle::GetSurface(&m_floatZFullRt);
    if ( (R_RT_Handle::GetSurface(&m_floatZFullRt)->m_rtFlagsInternal & 0x18) == 0 )
      goto LABEL_19;
    v12 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()");
  }
  else
  {
    if ( !(_DWORD)_RDI )
      goto LABEL_19;
    v12 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
  }
  if ( v12 )
    __debugbreak();
LABEL_19:
  source = context->source;
  v14 = context->source;
  v31 = (R_RT_Handle)viewInfo->sceneRtInput.m_floatZFullRt;
  R_InitCmdBufSourceState(v14, &viewInfo->input);
  R_InitLocalCmdBufState(context->state, &source->input);
  R_GPU_BeginTimer(GPU_TIMER_EMISSIVE_COPY);
  R_ProfBeginNamedEvent(context->state, "upsample half res");
  v15 = *context;
  m_mainSceneColorRt = (R_RT_Handle)viewInfo->sceneRtInput.m_halfSceneColorRt;
  *(GfxCmdBufContext *)&v29.m_surfaceID = v15;
  R_Resolve_EliminateFastClear((GfxCmdBufContext *)&v29, (R_RT_ColorHandle *)&m_mainSceneColorRt, 0);
  v16 = *context;
  m_mainSceneColorRt = (R_RT_Handle)viewInfo->sceneRtInput.m_halfSceneAlphaRt;
  *(GfxCmdBufContext *)&v29.m_surfaceID = v16;
  R_Resolve_EliminateFastClear((GfxCmdBufContext *)&v29, (R_RT_ColorHandle *)&m_mainSceneColorRt, 1);
  m_mainSceneColorRt = (R_RT_Handle)viewInfo->sceneRtInput.m_mainSceneColorRt;
  height = R_RT_Handle::GetSurface(&m_mainSceneColorRt)->m_image.m_base.height;
  Surface = R_RT_Handle::GetSurface(&m_mainSceneColorRt);
  R_SetRenderTargetSize(source, Surface->m_image.m_base.width, height, GFX_USE_VIEWPORT_FOR_VIEW);
  R_BeginViewInternal(source, &viewInfo->sceneDef, (const GfxViewParms *)viewInfo, &viewInfo->viewParmsSet.frames[1].viewParms);
  *(_QWORD *)&v29.m_surfaceID = &viewInfo->sceneViewport;
  R_SetViewportStruct(source, &viewInfo->sceneViewport);
  v19 = (__m256i)viewInfo->sceneRtInput.m_mainSceneColorRt;
  m_mainSceneAlphaRt = (__m256i)viewInfo->sceneRtInput.m_mainSceneAlphaRt;
  v35.m_colorRtCount = 2;
  *(__m256i *)v36 = v19;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  *(_OWORD *)&m_mainSceneColorRt.m_tracking.m_name = _XMM0;
  v22 = 2i64;
  m_mainSceneColorRt.m_surfaceID = 0;
  *(__m256i *)&v36[32] = m_mainSceneAlphaRt;
  m_mainSceneColorRt.m_tracking.m_allocCounter = 0;
  v23 = 0i64;
  do
  {
    v34 = *(R_RT_Handle *)&v36[v23 * 32];
    if ( (_WORD)_XMM0 )
    {
      R_RT_Handle::GetSurface(&v34);
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 442, ASSERT_TYPE_ASSERT, "(colorRt)", (const char *)&queryFormat, "colorRt") )
        __debugbreak();
    }
    v35.m_colorRts[v23] = *(R_RT_ColorHandle *)&v36[v23 * 32];
    ++v23;
    --v22;
  }
  while ( v22 );
  v35.m_depthRt = (R_RT_DepthHandle)m_mainSceneColorRt;
  *(GfxCmdBufContext *)&m_mainSceneColorRt.m_surfaceID = *context;
  R_SetRenderTargetsInternal((GfxCmdBufContext *)&m_mainSceneColorRt, &v35, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(3088)");
  v25 = context->source;
  R_Set2D(context->source);
  state = context->state;
  if ( v25->viewMode != VIEW_MODE_2D )
  {
    LODWORD(v27) = v25->viewMode;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 3092, ASSERT_TYPE_ASSERT, "( ( source->viewMode == VIEW_MODE_2D ) )", "( source->viewMode ) = %i", v27) )
      __debugbreak();
  }
  v34 = m_floatZFullRt;
  *(GfxCmdBufContext *)&m_mainSceneColorRt.m_surfaceID = *context;
  R_HalfRes_Upsample((GfxCmdBufContext *)&m_mainSceneColorRt, &m_halfSceneColorRt, &m_halfSceneAlphaRt, &v34, &v31, *(const GfxViewport **)&v29.m_surfaceID);
  if ( v25 == (GfxCmdBufSourceState *)-1792i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  v25->input.codeImages[22] = NULL;
  if ( v25 == (GfxCmdBufSourceState *)-1792i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  v25->input.codeImages[23] = NULL;
  if ( v25 == (GfxCmdBufSourceState *)-1792i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  v25->input.codeImages[24] = NULL;
  if ( v25 == (GfxCmdBufSourceState *)-1792i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  v25->input.codeImages[25] = NULL;
  R_ProfEndNamedEvent(state);
  R_GPU_EndTimer();
  R_ShutdownLocalCmdBufState(state, &v25->input);
}

/*
==============
RB_InitClient2DContext
==============
*/
void RB_InitClient2DContext(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, R_RT_ColorHandle *colorRt, R_RT_Handle *packedStencil, const GfxImage *universalClut, const GfxImage *resolvedScene, const GfxWrappedBuffer *exposureBuffer)
{
  __m256i v9; 
  unsigned int height; 
  const R_RT_Surface *Surface; 
  GfxCmdBufSourceState *source; 
  GfxCmdBufContext v16; 
  R_RT_Image *p_m_image; 
  unsigned int v18; 
  unsigned __int16 v19; 
  int width; 
  float v21; 
  float v22; 
  GfxCmdBufInput *p_input; 
  GfxImage *blackImage; 
  GfxCmdBufSourceState *v25; 
  GfxCmdBufInput *v26; 
  GfxCmdBufSourceState *v27; 
  GfxImage *v28; 
  GfxCmdBufInput *v29; 
  GfxCmdBufSourceState *v30; 
  GfxCmdBufSourceState *v31; 
  GfxCmdBufInput *v32; 
  GfxWrappedBuffer *p_dummyBuffer; 
  GfxImage *Image; 
  GfxCmdBufInput *v35; 
  GfxCmdBufContext v36; 
  const GfxImage *v37; 
  __m256i v38; 
  const GfxImage *v39; 
  R_RT_Group v40; 
  GfxViewport viewport; 
  R_RT_Group v42; 

  v9 = *(__m256i *)colorRt;
  v39 = universalClut;
  v38 = v9;
  height = R_RT_Handle::GetSurface((R_RT_Handle *)&v38)->m_image.m_base.height;
  Surface = R_RT_Handle::GetSurface((R_RT_Handle *)&v38);
  source = gfxContext->source;
  R_SetRenderTargetSize(gfxContext->source, Surface->m_image.m_base.width, height, GFX_USE_VIEWPORT_FOR_VIEW);
  v38 = *(__m256i *)colorRt;
  R_RT_Group::AssignColor(&v40, (R_RT_ColorHandle *)&v38);
  *(__m256i *)&v42.m_colorRtCount = *(__m256i *)&v40.m_colorRtCount;
  *(__m256i *)&v42.m_colorRts[0].m_tracking.m_location = *(__m256i *)&v40.m_colorRts[0].m_tracking.m_location;
  *(__m256i *)&v42.m_colorRts[1].m_tracking.m_location = *(__m256i *)&v40.m_colorRts[1].m_tracking.m_location;
  *(__m256i *)&v42.m_colorRts[2].m_tracking.m_location = *(__m256i *)&v40.m_colorRts[2].m_tracking.m_location;
  v16 = *gfxContext;
  *(__m256i *)&v42.m_colorRts[3].m_tracking.m_location = *(__m256i *)&v40.m_colorRts[3].m_tracking.m_location;
  *(__m256i *)&v42.m_depthRt.m_tracking.m_location = *(__m256i *)&v40.m_depthRt.m_tracking.m_location;
  v42.m_vrsRt.m_tracking.m_location = v40.m_vrsRt.m_tracking.m_location;
  *(GfxCmdBufContext *)v38.m256i_i8 = v16;
  R_SetRenderTargetsInternal((GfxCmdBufContext *)&v38, &v42, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(2134)");
  v38 = *(__m256i *)packedStencil;
  if ( LOWORD(v16.source) )
  {
    R_RT_Handle::GetSurface((R_RT_Handle *)&v38);
    width = R_RT_Handle::GetSurface((R_RT_Handle *)&v38)->m_image.m_base.width;
    v19 = R_RT_Handle::GetSurface((R_RT_Handle *)&v38)->m_image.m_base.height;
    p_m_image = &R_RT_Handle::GetSurface((R_RT_Handle *)&v38)->m_image;
    v18 = 2 * width;
  }
  else
  {
    if ( v38.m256i_i32[2] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", v38.m256i_i64[0]) )
      __debugbreak();
    p_m_image = (R_RT_Image *)rgp.blackImage;
    v18 = rgp.blackImage->width;
    v19 = rgp.blackImage->height;
  }
  v21 = (float)v18;
  v22 = (float)v19;
  if ( !source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  p_input = &source->input;
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codeImages[79] = &p_m_image->m_base;
  blackImage = rgp.blackImage;
  v25 = gfxContext->source;
  if ( resolvedScene )
    blackImage = (GfxImage *)resolvedScene;
  if ( !v25 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  v26 = &v25->input;
  if ( !v26 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  v26->codeImages[6] = blackImage;
  v27 = gfxContext->source;
  v28 = rgp.blackImage;
  if ( !gfxContext->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  v29 = &v27->input;
  if ( !v29 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  v29->codeImages[80] = v28;
  v30 = gfxContext->source;
  v31 = gfxContext->source;
  v32 = &gfxContext->source->input;
  if ( gfxContext->source == (GfxCmdBufSourceState *)-1792i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1494, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_dummyBuffer = &gfxBuf.dummyBuffer;
  if ( exposureBuffer )
    p_dummyBuffer = (GfxWrappedBuffer *)exposureBuffer;
  v32->codeBuffers[32] = p_dummyBuffer;
  v31->input.consts[5].v[0] = v21;
  v31->input.consts[5].v[1] = v22;
  v31->input.consts[5].v[2] = 1.0 / v21;
  v31->input.consts[5].v[3] = 1.0 / v22;
  ++v31->constVersions[5];
  R_SetRenderTargetAspect(v31, vidConfig.windowAspectRatio);
  Image = FontCache_GetImage();
  v35 = &v31->input;
  if ( !v35 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
  {
    __debugbreak();
    v30 = gfxContext->source;
  }
  v36 = *gfxContext;
  v37 = v39;
  v35->codeImages[32] = Image;
  *(GfxCmdBufContext *)v38.m256i_i8 = v36;
  RB_SetDefaultUIState((GfxCmdBufContext *)&v38, data, v37);
  *(GfxCmdBufContext *)v38.m256i_i8 = *gfxContext;
  RB_SetupUIWhiteBalanceParams((GfxCmdBufContext *)&v38, viewInfo);
  R_SetMovieImages(&v30->input);
  R_BeginViewInternal(v30, &viewInfo->sceneDef, (const GfxViewParms *)viewInfo, &viewInfo->viewParmsSet.frames[1].viewParms);
  viewport = viewInfo->displayViewport;
  R_SetViewportStruct(v30, &viewport);
  R_SetViewportAndScissorSeparate(gfxContext->state, &viewport, &viewport);
}

/*
==============
RB_InitClient2DContext_CopyScopeReticle
==============
*/
void RB_InitClient2DContext_CopyScopeReticle(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufState *state; 
  unsigned int height; 
  const R_RT_Surface *Surface; 
  GfxCmdBufSourceState *source; 
  float width; 
  float v11; 
  GfxImage *Image; 
  GfxCmdBufContext v13; 
  R_RT_Handle v14; 
  R_RT_Handle v15; 
  GfxViewport viewport; 

  state = gfxContext->state;
  if ( state->rtGroup.m_colorRtCount != 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 559, ASSERT_TYPE_ASSERT, "(this->m_colorRtCount == 1)", (const char *)&queryFormat, "this->m_colorRtCount == 1") )
    __debugbreak();
  v15 = (R_RT_Handle)state->rtGroup.m_colorRts[0];
  v14 = v15;
  height = R_RT_Handle::GetSurface(&v14)->m_image.m_base.height;
  Surface = R_RT_Handle::GetSurface(&v14);
  source = gfxContext->source;
  R_SetRenderTargetSize(gfxContext->source, Surface->m_image.m_base.width, height, GFX_USE_VIEWPORT_FOR_VIEW);
  width = (float)R_RT_Handle::GetSurface(&v15)->m_image.m_base.width;
  v11 = (float)R_RT_Handle::GetSurface(&v15)->m_image.m_base.height;
  source->input.consts[5].v[3] = 1.0 / v11;
  source->input.consts[5].v[0] = width;
  source->input.consts[5].v[1] = v11;
  source->input.consts[5].v[2] = 1.0 / width;
  ++source->constVersions[5];
  R_SetRenderTargetAspect(source, vidConfig.windowAspectRatio);
  Image = FontCache_GetImage();
  if ( !source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  if ( source == (GfxCmdBufSourceState *)-1792i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  v13 = *gfxContext;
  source->input.codeImages[32] = Image;
  *(GfxCmdBufContext *)&v14.m_surfaceID = v13;
  RB_SetDefaultUIState((GfxCmdBufContext *)&v14, data, NULL);
  *(GfxCmdBufContext *)&v14.m_surfaceID = *gfxContext;
  RB_SetupUIWhiteBalanceParams((GfxCmdBufContext *)&v14, viewInfo);
  *(_QWORD *)&viewport.x = 0i64;
  viewport.width = R_RT_Handle::GetSurface(&v15)->m_image.m_base.width;
  viewport.height = R_RT_Handle::GetSurface(&v15)->m_image.m_base.height;
  R_SetViewportStruct(source, &viewport);
  R_Set2D(source);
}

/*
==============
RB_InitClient2DContext_ReceivePostFXLite
==============
*/
void RB_InitClient2DContext_ReceivePostFXLite(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, R_RT_ColorHandle *sceneRt, const GfxImage *packedStencil, const GfxImage *scopeBuffer)
{
  unsigned int height; 
  const R_RT_Surface *Surface; 
  GfxCmdBufSourceState *source; 
  GfxImage *Image; 
  GfxCmdBufInput *p_input; 
  GfxCmdBufContext v15; 
  float width; 
  const R_RT_Surface *v17; 
  GfxCmdBufSourceState *v18; 
  int v19; 
  float v20; 
  GfxCmdBufInput *v21; 
  GfxCmdBufSourceState *v22; 
  GfxCmdBufInput *v23; 
  const R_RT_Surface *v24; 
  GfxCmdBufSourceState *v25; 
  R_RT_Handle v26; 
  GfxViewport viewport; 

  v26 = sceneRt->R_RT_Handle;
  height = R_RT_Handle::GetSurface(&v26)->m_image.m_base.height;
  Surface = R_RT_Handle::GetSurface(&v26);
  source = gfxContext->source;
  R_SetRenderTargetSize(gfxContext->source, Surface->m_image.m_base.width, height, GFX_USE_VIEWPORT_FOR_VIEW);
  Image = FontCache_GetImage();
  if ( !source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  p_input = &source->input;
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  v15 = *gfxContext;
  p_input->codeImages[32] = Image;
  *(GfxCmdBufContext *)&v26.m_surfaceID = v15;
  RB_SetDefaultUIState((GfxCmdBufContext *)&v26, data, rgp.blackImage3D);
  *(GfxCmdBufContext *)&v26.m_surfaceID = *gfxContext;
  RB_SetupUIWhiteBalanceParams((GfxCmdBufContext *)&v26, viewInfo);
  width = (float)R_RT_Handle::GetSurface(sceneRt)->m_image.m_base.width;
  v17 = R_RT_Handle::GetSurface(sceneRt);
  v18 = gfxContext->source;
  v19 = v17->m_image.m_base.height;
  v18->input.consts[5].v[0] = width;
  v18->input.consts[5].v[2] = 1.0 / width;
  v20 = (float)v19;
  v18->input.consts[5].v[3] = 1.0 / v20;
  v18->input.consts[5].v[1] = v20;
  ++v18->constVersions[5];
  R_SetRenderTargetAspect(v18, vidConfig.windowAspectRatio);
  if ( !v18 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  v21 = &v18->input;
  if ( !v21 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  v21->codeImages[79] = packedStencil;
  v22 = gfxContext->source;
  if ( !gfxContext->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  v23 = &v22->input;
  if ( !v23 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  v23->codeImages[80] = scopeBuffer;
  *(_QWORD *)&viewport.x = 0i64;
  viewport.width = R_RT_Handle::GetSurface(sceneRt)->m_image.m_base.width;
  v24 = R_RT_Handle::GetSurface(sceneRt);
  v25 = gfxContext->source;
  viewport.height = v24->m_image.m_base.height;
  R_SetViewportStruct(v25, &viewport);
  R_Set2D(v25);
  R_ForceSet2D(v25, &viewInfo->displayViewport);
}

/*
==============
RB_InitClient2DReceivePPFXContext
==============
*/
void RB_InitClient2DReceivePPFXContext(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, R_RT_ColorHandle *sceneRt, R_RT_DepthHandle *depthRt, const GfxImage *universalClut)
{
  R_RT_ColorHandle v6; 
  GfxCmdBufSourceState *source; 
  unsigned int height; 
  const R_RT_Surface *Surface; 
  float width; 
  float v15; 
  GfxImage *blackImage; 
  GfxImage *Image; 
  GfxCmdBufSourceState *v18; 
  GfxImage *v19; 
  GfxCmdBufInput *p_input; 
  GfxCmdBufContext v21; 
  R_RT_Handle v22; 
  R_RT_DepthHandle v23; 
  __m256i v24; 

  v6 = *sceneRt;
  v23 = *depthRt;
  *(GfxCmdBufContext *)&v22.m_surfaceID = *gfxContext;
  v24 = (__m256i)v6;
  R_SetRenderTargetsInternal_ColorDepth((GfxCmdBufContext *)&v22, (R_RT_ColorHandle *)&v24, &v23, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(3572)");
  source = gfxContext->source;
  R_SetViewportStruct(gfxContext->source, &viewInfo->sceneGeoViewport);
  v22 = sceneRt->R_RT_Handle;
  height = R_RT_Handle::GetSurface(&v22)->m_image.m_base.height;
  Surface = R_RT_Handle::GetSurface(&v22);
  R_SetRenderTargetSize(source, Surface->m_image.m_base.width, height, GFX_USE_VIEWPORT_FOR_VIEW);
  R_BeginViewInternal(source, &viewInfo->sceneDef, (const GfxViewParms *)viewInfo, &viewInfo->viewParmsSet.frames[1].viewParms);
  width = (float)R_RT_Handle::GetSurface(sceneRt)->m_image.m_base.width;
  v15 = (float)R_RT_Handle::GetSurface(sceneRt)->m_image.m_base.height;
  source->input.consts[5].v[3] = 1.0 / v15;
  source->input.consts[5].v[0] = width;
  source->input.consts[5].v[1] = v15;
  source->input.consts[5].v[2] = 1.0 / width;
  ++source->constVersions[5];
  R_SetRenderTargetAspect(source, vidConfig.windowAspectRatio);
  blackImage = rgp.blackImage;
  if ( !source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  if ( source == (GfxCmdBufSourceState *)-1792i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  source->input.codeImages[80] = blackImage;
  Image = FontCache_GetImage();
  v18 = gfxContext->source;
  v19 = Image;
  if ( !gfxContext->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  p_input = &v18->input;
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  v21 = *gfxContext;
  p_input->codeImages[32] = v19;
  *(GfxCmdBufContext *)&v22.m_surfaceID = v21;
  RB_SetDefaultUIState((GfxCmdBufContext *)&v22, data, universalClut);
  *(GfxCmdBufContext *)&v22.m_surfaceID = *gfxContext;
  RB_SetupUIWhiteBalanceParams((GfxCmdBufContext *)&v22, viewInfo);
  R_Set2D(gfxContext->source);
  R_ForceSet2D(gfxContext->source, &viewInfo->displayViewport);
}

/*
==============
RB_InitClient2D_RTT
==============
*/
void RB_InitClient2D_RTT(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufSourceState *source; 
  GfxImage *blackImage; 
  GfxCmdBufInput *p_input; 
  GfxImage *Image; 
  GfxCmdBufSourceState *v10; 
  GfxImage *v11; 
  GfxCmdBufInput *v12; 
  GfxCmdBufContext v13; 
  GfxCmdBufSourceState *v14; 
  GfxCmdBufContext v15[3]; 

  source = gfxContext->source;
  blackImage = rgp.blackImage;
  if ( !gfxContext->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  p_input = &source->input;
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codeImages[80] = blackImage;
  Image = FontCache_GetImage();
  v10 = gfxContext->source;
  v11 = Image;
  if ( !gfxContext->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  v12 = &v10->input;
  if ( !v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  v13 = *gfxContext;
  v12->codeImages[32] = v11;
  v15[0] = v13;
  RB_SetDefaultUIState(v15, data, NULL);
  v15[0] = *gfxContext;
  RB_SetupUIWhiteBalanceParams(v15, viewInfo);
  v14 = gfxContext->source;
  R_Set2D(v14);
  R_ForceSet2D(v14, &viewInfo->displayViewport);
}

/*
==============
RB_IsComputeReady
==============
*/
char RB_IsComputeReady(void *userData)
{
  __int64 v1; 

  v1 = *(_QWORD *)userData;
  if ( !*(_QWORD *)userData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 2420, ASSERT_TYPE_ASSERT, "(data)", (const char *)&queryFormat, "data") )
    __debugbreak();
  if ( *(_DWORD *)(v1 + 927428) )
    return 1;
  RB_CheckSkipRemoteScreenUpdate();
  return 0;
}

/*
==============
RB_IsEmissiveReady
==============
*/
char RB_IsEmissiveReady(void *userData)
{
  __int64 v1; 

  v1 = *(_QWORD *)userData;
  if ( !*(_QWORD *)userData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 2469, ASSERT_TYPE_ASSERT, "(data)", (const char *)&queryFormat, "data") )
    __debugbreak();
  if ( *(_DWORD *)(v1 + 927440) )
    return 1;
  RB_CheckSkipRemoteScreenUpdate();
  return 0;
}

/*
==============
RB_IsHud2DReady
==============
*/
char RB_IsHud2DReady(void *userData)
{
  __int64 v1; 

  v1 = *(_QWORD *)userData;
  if ( !*(_QWORD *)userData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 2485, ASSERT_TYPE_ASSERT, "(data)", (const char *)&queryFormat, "data") )
    __debugbreak();
  if ( *(_DWORD *)(v1 + 927444) || *(_DWORD *)(v1 + 927452) )
    return 1;
  RB_CheckSkipRemoteScreenUpdate();
  return 0;
}

/*
==============
RB_IsOpaqueReady
==============
*/
char RB_IsOpaqueReady(void *userData)
{
  __int64 v1; 

  v1 = *(_QWORD *)userData;
  if ( !*(_QWORD *)userData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 2453, ASSERT_TYPE_ASSERT, "(data)", (const char *)&queryFormat, "data") )
    __debugbreak();
  if ( *(_DWORD *)(v1 + 927436) )
    return 1;
  RB_CheckSkipRemoteScreenUpdate();
  return 0;
}

/*
==============
RB_IsShadowReady
==============
*/
char RB_IsShadowReady(void *userData)
{
  __int64 v1; 

  v1 = *(_QWORD *)userData;
  if ( !*(_QWORD *)userData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 2438, ASSERT_TYPE_ASSERT, "(data)", (const char *)&queryFormat, "data") )
    __debugbreak();
  if ( *(_DWORD *)(v1 + 927432) )
    return 1;
  RB_CheckSkipRemoteScreenUpdate();
  return 0;
}

/*
==============
RB_PerformVolumeLightScatter
==============
*/
void RB_PerformVolumeLightScatter(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  float v6; 
  float v7; 
  float v8; 
  float v9; 
  float v10; 
  float v11; 
  __int64 activePrimarySunLight; 
  float v13; 
  __int128 v14; 
  __int128 v19; 
  __int128 v22; 
  __int128 v23; 
  R_RT_Handle m_mainSceneColorRt; 
  __int128 v26; 
  R_RT_Handle m_mainSceneDepthRt; 
  GfxCmdBufSourceState *source; 
  GfxCmdBufState *state; 
  unsigned int v31; 
  unsigned int height; 
  unsigned int v33; 
  int v34; 
  int v35; 
  int rtFlags; 
  R_RT_Handle v37; 
  bool v39; 
  R_RT_Handle v40; 
  bool v42; 
  __int64 x; 
  __int64 y; 
  unsigned int v45; 
  unsigned int v46; 
  float v47; 
  float v48; 
  float v49; 
  float v50; 
  float v51; 
  float v52; 
  float v53; 
  unsigned int v54; 
  float v55; 
  float v56; 
  float v57; 
  float v58; 
  float v59; 
  float v60; 
  float v61; 
  float v62; 
  float v63; 
  unsigned int v64; 
  GfxCmdBufState *v65; 
  float v66; 
  float v67; 
  float v68; 
  float v69; 
  float v70; 
  float v71; 
  float v72; 
  float v73; 
  float v74; 
  float v75; 
  float v76; 
  R_RT_Handle v77; 
  unsigned int v78; 
  const R_RT_Surface *Surface; 
  const R_RT_Surface *v80; 
  const GfxImage *p_m_base; 
  unsigned int v82; 
  const R_RT_Surface *v83; 
  Material *feedbackReplaceScenebufferMaterial; 
  const char *v85; 
  R_RT_Handle v86; 
  unsigned int v87; 
  const R_RT_Surface *v88; 
  const R_RT_Surface *v89; 
  const GfxImage *v90; 
  unsigned int v91; 
  const R_RT_Surface *v92; 
  unsigned int v93; 
  const R_RT_Surface *v94; 
  unsigned int v95; 
  const R_RT_Surface *v96; 
  int integer; 
  float v98; 
  float v99; 
  float v100; 
  float v101; 
  float v104; 
  R_RT_Handle v105; 
  unsigned int v106; 
  R_RT_Handle v107; 
  R_RT_Handle v108; 
  R_RT_Handle result; 
  unsigned int width; 
  float v111; 
  float v112; 
  float v113; 
  float v114; 
  float v115; 
  float v116; 
  GfxCmdBufInput *input; 
  R_RT_Handle v118; 
  R_RT_Handle v119; 
  R_RT_Group v120; 
  R_RT_Group v121; 

  if ( (*((_BYTE *)&viewInfo->viewportFeatures + 40) & 0x40) != 0 )
  {
    v6 = rgp.world->sun.sunFxPosition.v[1];
    v7 = rgp.world->sun.sunFxPosition.v[0];
    v8 = rgp.world->sun.sunFxPosition.v[2];
    if ( (float)((float)((float)(v6 * viewInfo->viewParmsSet.frames[0].viewParms.camera.axis.m[0].v[1]) + (float)(v7 * viewInfo->viewParmsSet.frames[0].viewParms.camera.axis.m[0].v[0])) + (float)(v8 * viewInfo->viewParmsSet.frames[0].viewParms.camera.axis.m[0].v[2])) > 0.0 )
    {
      v9 = 1.0 / (float)((float)((float)(v7 * viewInfo->viewParmsSet.frames[0].viewParms.viewProjectionMatrix.m.m[0].v[3]) + (float)(v6 * viewInfo->viewParmsSet.frames[0].viewParms.viewProjectionMatrix.m.m[1].v[3])) + (float)(v8 * viewInfo->viewParmsSet.frames[0].viewParms.viewProjectionMatrix.m.m[2].v[3]));
      v10 = (float)((float)((float)(v6 * viewInfo->viewParmsSet.frames[0].viewParms.viewProjectionMatrix.m.m[1].v[0]) + (float)(v7 * viewInfo->viewParmsSet.frames[0].viewParms.viewProjectionMatrix.m.m[0].v[0])) + (float)(v8 * viewInfo->viewParmsSet.frames[0].viewParms.viewProjectionMatrix.m.m[2].v[0])) * v9;
      v11 = (float)((float)((float)(v7 * viewInfo->viewParmsSet.frames[0].viewParms.viewProjectionMatrix.m.m[0].v[1]) + (float)(v6 * viewInfo->viewParmsSet.frames[0].viewParms.viewProjectionMatrix.m.m[1].v[1])) + (float)(v8 * viewInfo->viewParmsSet.frames[0].viewParms.viewProjectionMatrix.m.m[2].v[1])) * v9;
      if ( COERCE_FLOAT(LODWORD(v10) & _xmm) <= 1.0 && COERCE_FLOAT(COERCE_UNSIGNED_INT((float)((float)((float)(v7 * viewInfo->viewParmsSet.frames[0].viewParms.viewProjectionMatrix.m.m[0].v[1]) + (float)(v6 * viewInfo->viewParmsSet.frames[0].viewParms.viewProjectionMatrix.m.m[1].v[1])) + (float)(v8 * viewInfo->viewParmsSet.frames[0].viewParms.viewProjectionMatrix.m.m[2].v[1])) * v9) & _xmm) <= 1.0 )
      {
        activePrimarySunLight = data->activePrimarySunLight;
        if ( (_DWORD)activePrimarySunLight )
        {
          Sys_ProfBeginNamedEvent(0xFFFF7F50, "VolumeLightScatter");
          v13 = viewInfo->volumeLightScatter.attenuation.v[2];
          v111 = (float)(v10 * 0.5) + 0.5;
          v14 = LODWORD(FLOAT_0_5);
          _XMM0 = LODWORD(viewInfo->volumeLightScatter.backgroundDistance);
          __asm { vmaxss  xmm1, xmm0, cs:__real@34000000 }
          v113 = 1.0 / *(float *)&_XMM1;
          *(float *)&v14 = (float)(0.5 - (float)(v11 * 0.5)) - 0.5;
          _XMM0 = v14 & (unsigned int)_xmm;
          __asm { vmaxss  xmm0, xmm0, xmm2 }
          v19 = _XMM0;
          *(float *)&v19 = (float)(*(float *)&_XMM0 - v13) / (float)(0.5 - v13);
          _XMM0 = v19;
          __asm { vmaxss  xmm3, xmm0, xmm12 }
          v22 = LODWORD(FLOAT_1_0);
          *(float *)&v22 = (float)((float)(1.0 - (float)((float)(3.0 - (float)(*(float *)&_XMM3 * 2.0)) * (float)(*(float *)&_XMM3 * *(float *)&_XMM3))) * r_volumeLightScatterScriptIntensity->current.value) * data->sceneLights[activePrimarySunLight].intensity;
          v23 = v22;
          *(float *)&_XMM0 = (float)(*(float *)&v22 * viewInfo->volumeLightScatter.lightColor.v[0]) * data->sceneLights[activePrimarySunLight].colorLinearSrgb.v[0];
          *(float *)&v22 = *(float *)&v22 * viewInfo->volumeLightScatter.lightColor.v[1];
          v114 = *(float *)&_XMM0;
          m_mainSceneColorRt = (R_RT_Handle)viewInfo->sceneRtInput.m_mainSceneColorRt;
          v115 = *(float *)&v22 * data->sceneLights[activePrimarySunLight].colorLinearSrgb.v[1];
          v26 = v23;
          *(float *)&v26 = (float)(*(float *)&v23 * viewInfo->volumeLightScatter.lightColor.v[2]) * data->sceneLights[activePrimarySunLight].colorLinearSrgb.v[2];
          _XMM0 = v26;
          v116 = *(float *)&v26;
          m_mainSceneDepthRt = (R_RT_Handle)viewInfo->sceneRtInput.m_mainSceneDepthRt;
          v112 = 0.5 - (float)(v11 * 0.5);
          v105 = m_mainSceneDepthRt;
          v107 = m_mainSceneDepthRt;
          v108 = m_mainSceneColorRt;
          v118 = m_mainSceneColorRt;
          if ( (_WORD)v26 )
          {
            R_RT_Handle::GetSurface(&v107);
            v105 = v107;
          }
          else
          {
            __asm { vpextrd rax, xmm0, 2 }
            if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
              __debugbreak();
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 463, ASSERT_TYPE_ASSERT, "(depthRt)", (const char *)&queryFormat, "depthRt") )
              __debugbreak();
          }
          v120.m_colorRtCount = 1;
          v107 = v108;
          if ( (_WORD)v26 )
          {
            R_RT_Handle::GetSurface(&v107);
          }
          else
          {
            if ( v118.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
              __debugbreak();
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 442, ASSERT_TYPE_ASSERT, "(colorRt)", (const char *)&queryFormat, "colorRt") )
              __debugbreak();
          }
          v120.m_colorRts[0] = (R_RT_ColorHandle)v108;
          v120.m_depthRt = (R_RT_DepthHandle)v105;
          v121 = v120;
          R_GPU_BeginTimer(GPU_TIMER_VOLUME_LIGHT_SCATTER);
          source = gfxContext->source;
          R_InitCmdBufSourceState(gfxContext->source, &viewInfo->input);
          state = gfxContext->state;
          input = &source->input;
          R_InitLocalCmdBufState(state, &source->input);
          if ( v121.m_colorRtCount != 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 559, ASSERT_TYPE_ASSERT, "(this->m_colorRtCount == 1)", (const char *)&queryFormat, "this->m_colorRtCount == 1") )
            __debugbreak();
          v107 = (R_RT_Handle)v121.m_colorRts[0];
          width = R_RT_Handle::GetSurface(&v107)->m_image.m_base.width;
          v31 = width >> 1;
          height = R_RT_Handle::GetSurface(&v107)->m_image.m_base.height;
          if ( !v31 )
            v31 = 1;
          v106 = height;
          v33 = height >> 1;
          if ( !(height >> 1) )
            v33 = 1;
          if ( Dvar_GetBool_Internal(r_deviceDebug) || (v34 = 64, !Dvar_GetBool_Internal_DebugName(DCONST_DVARBOOL_r_esramPostFX, "r_esramPostFX")) )
            v34 = 0;
          v35 = 2048;
          if ( Dvar_GetInt_Internal_DebugName(DCONST_DVARINT_r_dccPostFX, "r_dccPostFX") == 1 )
            v35 = 2056;
          rtFlags = v34 | v35;
          v37 = *R_RT_CreateInternal(&result, v31, v33, v31, v33, 1u, 1u, 1u, g_R_RT_renderTargetFmts[27], (R_RT_Flags)rtFlags, R_RT_FlagInternal_None, &colorBlack, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, "R_RENDERTARGET_DEPTH_BLUR_0", 0, NULL, NULL, NULL, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1139)");
          v108 = v37;
          v107 = v37;
          if ( (_WORD)v26 )
          {
            R_RT_Handle::GetSurface(&v107);
            if ( (R_RT_Handle::GetSurface(&v107)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
            {
              v37 = v107;
              v108 = v107;
              __debugbreak();
            }
            else
            {
              v37 = v107;
              v108 = v107;
            }
          }
          else
          {
            __asm { vpextrd rax, xmm0, 2 }
            if ( (_DWORD)_RAX )
            {
              v39 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
              v37 = v108;
              if ( v39 )
                __debugbreak();
            }
          }
          v119 = v37;
          v40 = *R_RT_CreateInternal(&result, v31, v33, v31, v33, 1u, 1u, 1u, g_R_RT_renderTargetFmts[27], (R_RT_Flags)rtFlags, R_RT_FlagInternal_None, &colorBlack, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, "R_RENDERTARGET_DEPTH_BLUR_1", 0, NULL, NULL, NULL, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1140)");
          v107 = v40;
          v105 = v40;
          if ( (_WORD)v26 )
          {
            R_RT_Handle::GetSurface(&v105);
            if ( (R_RT_Handle::GetSurface(&v105)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
            {
              v40 = v105;
              v107 = v105;
              __debugbreak();
            }
            else
            {
              v40 = v105;
              v107 = v105;
            }
          }
          else
          {
            __asm { vpextrd rax, xmm0, 2 }
            if ( (_DWORD)_RAX )
            {
              v42 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
              v40 = v107;
              if ( v42 )
                __debugbreak();
            }
          }
          x = viewInfo->sceneViewport.x;
          y = viewInfo->sceneViewport.y;
          v45 = viewInfo->sceneViewport.height;
          v46 = x + viewInfo->sceneViewport.width;
          result = v40;
          v47 = (float)v106;
          v48 = 1.0 / v47;
          v49 = (float)x;
          v50 = (float)width;
          v51 = (float)y;
          v52 = (float)(v49 + 0.5) * (float)(1.0 / v50);
          v53 = (float)(v51 + 0.5) * v48;
          v54 = y + v45;
          v55 = (float)v46;
          v56 = (float)(v55 - 0.5) * (float)(1.0 / v50);
          v57 = (float)v54;
          v58 = (float)(v57 - 0.5) * v48;
          v59 = (float)v33;
          v60 = 1.0 / v59;
          v61 = (float)v31;
          v62 = (float)(v31 * (unsigned int)x / width);
          v63 = 1.0 / v61;
          v64 = v31 * v46;
          v65 = gfxContext->state;
          v66 = (float)(v62 + 0.5) * (float)(1.0 / v61);
          v67 = (float)(v33 * (unsigned int)y / v106);
          v68 = (float)(v64 / width);
          v69 = (float)(v67 + 0.5) * v60;
          v70 = v68 - 0.5;
          v71 = (float)(v33 * v54 / v106);
          v72 = v70 * v63;
          v73 = (float)(v71 - 0.5) * v60;
          R_ProfBeginNamedEvent(v65, "VolumeLightScatter");
          v74 = viewInfo->volumeLightScatter.attenuation.v[0];
          v75 = v113;
          source->input.consts[100].v[0] = v111;
          v76 = v112;
          source->input.consts[100].v[3] = v74;
          v77 = v108;
          source->input.consts[100].v[1] = v76;
          source->input.consts[100].v[2] = v75;
          ++source->constVersions[100];
          source->input.consts[101].v[0] = v52;
          source->input.consts[101].v[1] = v53;
          source->input.consts[101].v[2] = v56;
          source->input.consts[101].v[3] = v58;
          ++source->constVersions[101];
          v118 = v77;
          R_AddRenderTargetTransition(v65, (R_RT_ColorHandle *)&v118, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
          R_FlushResourceTransitions(v65);
          R_SetViewportStruct(source, &viewInfo->sceneViewport);
          v105 = v108;
          v78 = R_RT_Handle::GetSurface(&v105)->m_image.m_base.height;
          Surface = R_RT_Handle::GetSurface(&v105);
          R_SetRenderTargetSize(source, Surface->m_image.m_base.width, v78, GFX_USE_VIEWPORT_FULL);
          v118 = v108;
          *(GfxCmdBufContext *)&v105.m_surfaceID = *gfxContext;
          R_SetRenderTargetsInternal_ColorOnly((GfxCmdBufContext *)&v105, (R_RT_ColorHandle *)&v118, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1160)");
          *(GfxCmdBufContext *)&v105.m_surfaceID = *gfxContext;
          RB_FullScreenFilterInternal((GfxCmdBufContext *)&v105, rgp.volumeLightScatterBlur0Material, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1161)");
          v118 = v108;
          R_AddRenderTargetTransition(v65, (R_RT_ColorHandle *)&v118, RENDERTARGET_TRANSITION_MODE_READ, D3D12_RESOURCE_BARRIER_FLAG_NONE);
          R_FlushResourceTransitions(v65);
          v80 = R_RT_Handle::GetSurface(&v119);
          *(GfxCmdBufContext *)&v105.m_surfaceID = *gfxContext;
          p_m_base = &v80->m_image.m_base;
          R_Resolve((GfxCmdBufContext *)&v105, &v80->m_image.m_base);
          if ( r_volumeLightScatterDebug->current.integer == 1 )
          {
            v105 = *R_RT_Group::GetValidRt(&v121, &result);
            v82 = R_RT_Handle::GetSurface(&v105)->m_image.m_base.height;
            v83 = R_RT_Handle::GetSurface(&v105);
            R_SetRenderTargetSize(source, v83->m_image.m_base.width, v82, GFX_USE_VIEWPORT_FOR_VIEW);
            *(GfxCmdBufContext *)&v105.m_surfaceID = *gfxContext;
            R_SetRenderTargetsInternal((GfxCmdBufContext *)&v105, &v121, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1173)");
            R_SetCodeImageTextureInternal(source, 4u, p_m_base, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1174)");
            feedbackReplaceScenebufferMaterial = rgp.feedbackReplaceScenebufferMaterial;
            v85 = "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1175)";
          }
          else
          {
            v119 = v107;
            R_AddRenderTargetTransition(v65, (R_RT_ColorHandle *)&v119, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
            R_FlushResourceTransitions(v65);
            R_SetCodeImageTextureInternal(source, 0x1Bu, p_m_base, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1183)");
            v86 = v107;
            source->input.consts[101].v[0] = v66;
            source->input.consts[101].v[1] = v69;
            source->input.consts[101].v[2] = v72;
            source->input.consts[101].v[3] = v73;
            ++source->constVersions[101];
            v105 = v86;
            v87 = R_RT_Handle::GetSurface(&v105)->m_image.m_base.height;
            v88 = R_RT_Handle::GetSurface(&v105);
            R_SetRenderTargetSize(source, v88->m_image.m_base.width, v87, GFX_USE_VIEWPORT_FULL);
            v119 = v107;
            *(GfxCmdBufContext *)&v105.m_surfaceID = *gfxContext;
            R_SetRenderTargetsInternal_ColorOnly((GfxCmdBufContext *)&v105, (R_RT_ColorHandle *)&v119, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1186)");
            *(GfxCmdBufContext *)&v105.m_surfaceID = *gfxContext;
            RB_FullScreenFilterInternal((GfxCmdBufContext *)&v105, rgp.volumeLightScatterBlur1Material, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1187)");
            v119 = v107;
            R_AddRenderTargetTransition(v65, (R_RT_ColorHandle *)&v119, RENDERTARGET_TRANSITION_MODE_READ, D3D12_RESOURCE_BARRIER_FLAG_NONE);
            R_FlushResourceTransitions(v65);
            v89 = R_RT_Handle::GetSurface(&result);
            *(GfxCmdBufContext *)&v105.m_surfaceID = *gfxContext;
            v90 = &v89->m_image.m_base;
            R_Resolve((GfxCmdBufContext *)&v105, &v89->m_image.m_base);
            if ( r_volumeLightScatterDebug->current.integer == 2 )
            {
              v105 = *R_RT_Group::GetValidRt(&v121, &result);
              v91 = R_RT_Handle::GetSurface(&v105)->m_image.m_base.height;
              v92 = R_RT_Handle::GetSurface(&v105);
              R_SetRenderTargetSize(source, v92->m_image.m_base.width, v91, GFX_USE_VIEWPORT_FOR_VIEW);
              *(GfxCmdBufContext *)&v105.m_surfaceID = *gfxContext;
              R_SetRenderTargetsInternal((GfxCmdBufContext *)&v105, &v121, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1199)");
              R_SetCodeImageTextureInternal(source, 4u, v90, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1200)");
              feedbackReplaceScenebufferMaterial = rgp.feedbackReplaceScenebufferMaterial;
              v85 = "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1201)";
            }
            else
            {
              result = v108;
              R_AddRenderTargetTransition(v65, (R_RT_ColorHandle *)&result, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
              R_FlushResourceTransitions(v65);
              R_SetCodeImageTextureInternal(source, 0x1Cu, v90, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1210)");
              v105 = v108;
              v93 = R_RT_Handle::GetSurface(&v105)->m_image.m_base.height;
              v94 = R_RT_Handle::GetSurface(&v105);
              R_SetRenderTargetSize(source, v94->m_image.m_base.width, v93, GFX_USE_VIEWPORT_FULL);
              result = v108;
              *(GfxCmdBufContext *)&v105.m_surfaceID = *gfxContext;
              R_SetRenderTargetsInternal_ColorOnly((GfxCmdBufContext *)&v105, (R_RT_ColorHandle *)&result, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1212)");
              *(GfxCmdBufContext *)&v105.m_surfaceID = *gfxContext;
              RB_FullScreenFilterInternal((GfxCmdBufContext *)&v105, rgp.volumeLightScatterBlur2Material, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1213)");
              result = v108;
              R_AddRenderTargetTransition(v65, (R_RT_ColorHandle *)&result, RENDERTARGET_TRANSITION_MODE_READ, D3D12_RESOURCE_BARRIER_FLAG_NONE);
              R_FlushResourceTransitions(v65);
              *(GfxCmdBufContext *)&v105.m_surfaceID = *gfxContext;
              R_Resolve((GfxCmdBufContext *)&v105, p_m_base);
              v105 = *R_RT_Group::GetValidRt(&v121, &result);
              v95 = R_RT_Handle::GetSurface(&v105)->m_image.m_base.height;
              v96 = R_RT_Handle::GetSurface(&v105);
              R_SetRenderTargetSize(source, v96->m_image.m_base.width, v95, GFX_USE_VIEWPORT_FOR_VIEW);
              *(GfxCmdBufContext *)&v105.m_surfaceID = *gfxContext;
              R_SetRenderTargetsInternal((GfxCmdBufContext *)&v105, &v121, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1221)");
              integer = r_volumeLightScatterDebug->current.integer;
              if ( integer == 3 )
              {
                R_SetCodeImageTextureInternal(source, 4u, p_m_base, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1225)");
                feedbackReplaceScenebufferMaterial = rgp.feedbackReplaceScenebufferMaterial;
                v85 = "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1226)";
              }
              else
              {
                if ( integer == 4 )
                  R_ClearScreen(v65, 0xFu, 0);
                R_SetCodeImageTextureInternal(source, 0x1Bu, p_m_base, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1236)");
                v98 = viewInfo->volumeLightScatter.attenuation.v[1];
                v99 = v115;
                v100 = v116;
                source->input.consts[101].v[0] = v114;
                source->input.consts[101].v[1] = v99;
                source->input.consts[101].v[2] = v100;
                source->input.consts[101].v[3] = v98;
                ++source->constVersions[101];
                v101 = viewInfo->volumeLightScatter.depthAttenuation.v[0];
                _XMM0 = LODWORD(viewInfo->volumeLightScatter.depthAttenuation.v[1]);
                __asm { vmaxss  xmm1, xmm0, xmm2 }
                if ( *(float *)&_XMM1 <= 0.0 || *(float *)&_XMM0 < v101 )
                {
                  feedbackReplaceScenebufferMaterial = rgp.volumeLightScatterApplyMaterial;
                  v85 = "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1248)";
                }
                else
                {
                  if ( *(float *)&_XMM0 <= v101 )
                    v104 = FLOAT_10000_0;
                  else
                    v104 = 1.0 / (float)(*(float *)&_XMM0 - v101);
                  v85 = "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1244)";
                  *(_QWORD *)&source->input.consts[102].xyz.z = 0i64;
                  source->input.consts[102].v[0] = v101;
                  source->input.consts[102].v[1] = v104;
                  ++source->constVersions[102];
                  feedbackReplaceScenebufferMaterial = rgp.volumeLightScatterApplyWithDepthAttenMaterial;
                }
              }
            }
          }
          *(GfxCmdBufContext *)&v105.m_surfaceID = *gfxContext;
          RB_FullScreenFilterInternal((GfxCmdBufContext *)&v105, feedbackReplaceScenebufferMaterial, v85);
          result = v107;
          *(GfxCmdBufContext *)&v105.m_surfaceID = *gfxContext;
          R_RT_Destroy((GfxCmdBufContext *)&v105, (R_RT_ColorHandle *)&result);
          result = v108;
          *(GfxCmdBufContext *)&v105.m_surfaceID = *gfxContext;
          R_RT_Destroy((GfxCmdBufContext *)&v105, (R_RT_ColorHandle *)&result);
          R_GPU_EndTimer();
          R_ProfEndNamedEvent(v65);
          R_ShutdownLocalCmdBufState(v65, input);
          Sys_ProfEndNamedEvent();
        }
      }
    }
  }
}

/*
==============
RB_PreOpaque_MapMeshes
==============
*/
void RB_PreOpaque_MapMeshes(const GfxBackEndData *data)
{
  ;
}

/*
==============
RB_PreOpaque_UnmapMeshes
==============
*/
void RB_PreOpaque_UnmapMeshes(const GfxBackEndData *data)
{
  ;
}

/*
==============
RB_ResolveDistortion
==============
*/
void RB_ResolveDistortion(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo)
{
  GfxCmdBufSourceState *source; 
  __m256i m_mainSceneColorRt; 
  GfxCmdBufContext v6; 
  R_RT_ColorHandle m_resolvedSceneRt; 
  __m256i v8; 

  source = gfxContext->source;
  Profile2_UpdateEntry(59);
  if ( ((unsigned __int8)&dword_14FDE80BC & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE80BC) )
    __debugbreak();
  _InterlockedIncrement(&dword_14FDE80BC);
  R_InitCmdBufSourceState(source, &viewInfo->input);
  R_InitLocalCmdBufState(gfxContext->state, &source->input);
  Profile_Begin(104);
  R_ProfBeginNamedEvent(gfxContext->state, "Resolve Distortion");
  m_mainSceneColorRt = (__m256i)viewInfo->sceneRtInput.m_mainSceneColorRt;
  m_resolvedSceneRt = viewInfo->sceneRtInput.m_resolvedSceneRt;
  v6 = *gfxContext;
  v8 = m_mainSceneColorRt;
  RB_Perceptual_ScatterBlurScene(&v6, viewInfo, (R_RT_ColorHandle *)&v8, &m_resolvedSceneRt, 1);
  R_ProfEndNamedEvent(gfxContext->state);
  Profile_EndInternal(NULL);
  Profile2_UpdateEntry(59);
  if ( ((unsigned __int64)&dword_14FDE80BC & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 44, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE80BC) )
    __debugbreak();
  _InterlockedDecrement(&dword_14FDE80BC);
  R_ShutdownLocalCmdBufState(gfxContext->state, &source->input);
}

/*
==============
RB_ResolveFloatZFull
==============
*/
void RB_ResolveFloatZFull(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo)
{
  GfxCmdBufState *state; 
  R_RT_Handle v6; 
  unsigned __int16 m_surfaceID; 
  bool v9; 
  __int16 v10; 
  unsigned __int16 v11; 
  bool v13; 
  R_RT_Handle v14; 
  unsigned __int16 v15; 
  bool v17; 
  __int16 v18; 
  unsigned __int16 v19; 
  const char *v21; 
  int v22; 
  const char *v23; 
  R_RT_Handle v24; 
  unsigned __int16 v25; 
  bool v27; 
  __int16 v28; 
  unsigned __int16 v29; 
  const char *v30; 
  int v31; 
  const char *v32; 
  GfxCmdBufSourceState *source; 
  const R_RT_Surface *Surface; 
  const GfxTexture *Resident; 
  const R_RT_Surface *v36; 
  const GfxTexture *v37; 
  ComputeCmdBufState *GfxComputeCmdBufState; 
  unsigned int v39; 
  unsigned int levelCount; 
  const R_RT_Surface *v41; 
  const GfxTexture *v42; 
  const R_RT_Surface *v43; 
  const GfxTexture *v44; 
  R_RT_Handle v45; 
  R_RT_Handle v46; 
  R_RT_Handle v47; 
  R_RT_Handle v48; 
  __m256i v49; 
  __m256i m_mainSceneDepthRt; 
  __m256i v51; 
  R_RT_ColorHandle m_packedStencilRt; 
  R_RT_DepthHandle m_msaaSceneDepthRt; 
  __m256i m_floatZEighthMipMinRt; 
  R_RT_Handle m_floatZFullRt; 
  R_RT_Handle v56; 
  R_RT_Handle v57; 

  state = gfxContext->state;
  m_mainSceneDepthRt = (__m256i)viewInfo->sceneRtInput.m_mainSceneDepthRt;
  m_floatZFullRt = (R_RT_Handle)viewInfo->sceneRtInput.m_floatZFullRt;
  v56 = m_floatZFullRt;
  m_floatZEighthMipMinRt = (__m256i)viewInfo->sceneRtInput.m_floatZEighthMipMinRt;
  v48 = (R_RT_Handle)viewInfo->sceneRtInput.m_floatZFullRt;
  v6 = *R_RT_GetViewInternal((R_RT_Handle *)&v49, &v48, 0, 1);
  m_surfaceID = _XMM0;
  v48 = v6;
  v45 = v6;
  if ( (_WORD)_XMM0 )
  {
    R_RT_Handle::GetSurface(&v45);
    if ( (R_RT_Handle::GetSurface(&v45)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      LODWORD(_RDI) = v45.m_tracking.m_allocCounter;
      m_surfaceID = v45.m_surfaceID;
      v6 = v45;
      __debugbreak();
    }
    else
    {
      LODWORD(_RDI) = v45.m_tracking.m_allocCounter;
      m_surfaceID = v45.m_surfaceID;
      v6 = v45;
    }
  }
  else
  {
    __asm { vpextrd rdi, xmm0, 2 }
    if ( (_DWORD)_RDI )
    {
      v9 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      v6 = v48;
      if ( v9 )
        __debugbreak();
    }
  }
  v57 = v6;
  v10 = m_surfaceID & 0x7FFF;
  if ( v10 )
  {
    v11 = v10 | 0x8000;
    v46.m_surfaceID = v11;
  }
  else
  {
    v11 = 0;
    v46.m_surfaceID = 0;
  }
  _XMM0 = *(_OWORD *)&v45.m_tracking.m_allocCounter;
  v46.m_tracking = v45.m_tracking;
  v48 = v46;
  if ( v11 )
  {
    R_RT_Handle::GetSurface(&v48);
    if ( (R_RT_Handle::GetSurface(&v48)->m_rtFlagsInternal & 0x18) == 0 )
      goto LABEL_19;
    v13 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()");
  }
  else
  {
    if ( !(_DWORD)_RDI )
      goto LABEL_19;
    v13 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
  }
  if ( v13 )
    __debugbreak();
LABEL_19:
  v47 = (R_RT_Handle)viewInfo->sceneRtInput.m_floatZFullRt;
  v14 = *R_RT_GetViewInternal((R_RT_Handle *)&v49, &v47, 0, 2);
  v15 = _XMM0;
  v47 = v14;
  v45 = v14;
  if ( (_WORD)_XMM0 )
  {
    R_RT_Handle::GetSurface(&v45);
    if ( (R_RT_Handle::GetSurface(&v45)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      LODWORD(_RDI) = v45.m_tracking.m_allocCounter;
      v15 = v45.m_surfaceID;
      v14 = v45;
      __debugbreak();
    }
    else
    {
      LODWORD(_RDI) = v45.m_tracking.m_allocCounter;
      v15 = v45.m_surfaceID;
      v14 = v45;
    }
  }
  else
  {
    __asm { vpextrd rdi, xmm0, 2 }
    if ( (_DWORD)_RDI )
    {
      v17 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      v14 = v47;
      if ( v17 )
        __debugbreak();
    }
  }
  v57 = v14;
  v18 = v15 & 0x7FFF;
  if ( v18 )
  {
    v19 = v18 | 0x8000;
    v46.m_surfaceID = v19;
  }
  else
  {
    v19 = 0;
    v46.m_surfaceID = 0;
  }
  _XMM0 = *(_OWORD *)&v45.m_tracking.m_allocCounter;
  v46.m_tracking = v45.m_tracking;
  v47 = v46;
  if ( v19 )
  {
    R_RT_Handle::GetSurface(&v47);
    if ( (R_RT_Handle::GetSurface(&v47)->m_rtFlagsInternal & 0x18) == 0 )
      goto LABEL_37;
    v21 = "!unionHandle.IsValid() || unionHandle.IsColor()";
    v22 = 217;
    v23 = "(!unionHandle.IsValid() || unionHandle.IsColor())";
  }
  else
  {
    if ( !(_DWORD)_RDI )
      goto LABEL_37;
    v21 = "!this->m_tracking.m_allocCounter";
    v22 = 100;
    v23 = "(!this->m_tracking.m_allocCounter)";
  }
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", v22, ASSERT_TYPE_ASSERT, v23, (const char *)&queryFormat, v21) )
    __debugbreak();
LABEL_37:
  v46 = (R_RT_Handle)viewInfo->sceneRtInput.m_floatZFullRt;
  v24 = *R_RT_GetViewInternal((R_RT_Handle *)&v49, &v46, 0, 3);
  v25 = _XMM0;
  v46 = v24;
  v45 = v24;
  if ( (_WORD)_XMM0 )
  {
    R_RT_Handle::GetSurface(&v45);
    if ( (R_RT_Handle::GetSurface(&v45)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      LODWORD(_RDI) = v45.m_tracking.m_allocCounter;
      v25 = v45.m_surfaceID;
      v24 = v45;
      __debugbreak();
    }
    else
    {
      LODWORD(_RDI) = v45.m_tracking.m_allocCounter;
      v25 = v45.m_surfaceID;
      v24 = v45;
    }
  }
  else
  {
    __asm { vpextrd rdi, xmm0, 2 }
    if ( (_DWORD)_RDI )
    {
      v27 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      v24 = v46;
      if ( v27 )
        __debugbreak();
    }
  }
  v57 = v24;
  v28 = v25 & 0x7FFF;
  if ( v28 )
  {
    v29 = v28 | 0x8000;
    v46.m_surfaceID = v29;
  }
  else
  {
    v29 = 0;
    v46.m_surfaceID = 0;
  }
  v46.m_tracking = v45.m_tracking;
  if ( v29 )
  {
    R_RT_Handle::GetSurface(&v46);
    if ( (R_RT_Handle::GetSurface(&v46)->m_rtFlagsInternal & 0x18) == 0 )
      goto LABEL_55;
    v30 = "!unionHandle.IsValid() || unionHandle.IsColor()";
    v31 = 217;
    v32 = "(!unionHandle.IsValid() || unionHandle.IsColor())";
  }
  else
  {
    if ( !(_DWORD)_RDI )
      goto LABEL_55;
    v30 = "!this->m_tracking.m_allocCounter";
    v31 = 100;
    v32 = "(!this->m_tracking.m_allocCounter)";
  }
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", v31, ASSERT_TYPE_ASSERT, v32, (const char *)&queryFormat, v30) )
    __debugbreak();
LABEL_55:
  source = gfxContext->source;
  m_packedStencilRt = viewInfo->sceneRtInput.m_packedStencilRt;
  v45 = (R_RT_Handle)m_packedStencilRt;
  m_msaaSceneDepthRt = viewInfo->sceneRtInput.m_msaaSceneDepthRt;
  R_InitLocalCmdBufState(state, &source->input);
  R_ProfBeginNamedEvent(state, "Resolve FloatZ");
  R_GPU_BeginTimer(GPU_TIMER_RESOLVE_FLOAT_Z_MULTI);
  Surface = R_RT_Handle::GetSurface(&v56);
  Resident = R_Texture_GetResident(Surface->m_image.m_base.textureId);
  R_HW_AddResourceTransition(state, Resident, 0xFFFFFFFF, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  v36 = R_RT_Handle::GetSurface(&v45);
  v37 = R_Texture_GetResident(v36->m_image.m_base.textureId);
  R_HW_AddResourceTransition(state, v37, 0xFFFFFFFF, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  v51 = m_mainSceneDepthRt;
  R_AddDepthStencilTransition(state, (R_RT_DepthHandle *)&v51, DEPTHSTENCIL_TRANSITION_MODE_READ_PRESERVE_COMPRESSION, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  R_HW_FlushResourceTransitions(state);
  GfxComputeCmdBufState = R_GetGfxComputeCmdBufState(state);
  v57 = m_floatZFullRt;
  v49 = m_mainSceneDepthRt;
  v51 = m_floatZEighthMipMinRt;
  R_ResolveFloatZDownsample(GfxComputeCmdBufState, viewInfo, (R_RT_DepthHandle *)&v49, (R_RT_ColorHandle *)&v57, (R_RT_ColorHandle *)&v48, (R_RT_ColorHandle *)&v47, (R_RT_ColorHandle *)&v46, (R_RT_ColorHandle *)&v51, &m_msaaSceneDepthRt, &m_packedStencilRt, NULL);
  R_ComputeWaitForCompute(GfxComputeCmdBufState, PIPE_FLUSH_PARTIAL);
  v39 = 4;
  levelCount = R_RT_Handle::GetSurface(&viewInfo->sceneRtInput.m_floatZFullRt)->m_image.m_base.levelCount;
  if ( levelCount > 4 )
  {
    do
    {
      v49 = m_floatZEighthMipMinRt;
      v57 = m_floatZFullRt;
      R_ResolveFloatZDownsampleCS(GfxComputeCmdBufState, (R_RT_ColorHandle *)&v57, (R_RT_ColorHandle *)&v49, v39 - 1, 0, 0);
      v39 += 4;
    }
    while ( v39 < levelCount );
  }
  v41 = R_RT_Handle::GetSurface(&v56);
  v42 = R_Texture_GetResident(v41->m_image.m_base.textureId);
  R_HW_AddResourceTransition(state, v42, 0xFFFFFFFF, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  v43 = R_RT_Handle::GetSurface(&v45);
  v44 = R_Texture_GetResident(v43->m_image.m_base.textureId);
  R_HW_AddResourceTransition(state, v44, 0xFFFFFFFF, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  v49 = m_mainSceneDepthRt;
  R_AddDepthStencilTransition(state, (R_RT_DepthHandle *)&v49, DEPTHSTENCIL_TRANSITION_MODE_WRITE_PRESERVE_COMPRESSION, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  R_HW_FlushResourceTransitions(state);
  R_HW_FlushResourceTransitions(state);
  R_GPU_EndTimer();
  R_ProfEndNamedEvent(state);
  R_ShutdownLocalCmdBufState(state, &source->input);
}

/*
==============
RB_RunDrawList
==============
*/
void RB_RunDrawList(const GfxViewInfo *viewInfo, const GfxBackEndData *data, const R_RT_Group *rtGroup, GfxDrawListType drawListID)
{
  const char *DrawListTypeName; 
  GfxDrawCallOutput cmdBuf; 

  if ( R_RunDrawListCommandBuffer(data, drawListID) )
  {
    R_LockGfxImmediateContext();
    cmdBuf.empty = 0;
    R_InitContext(data, &cmdBuf.cmdBuf);
    R_GPU_BeginRunDrawListTimer(drawListID);
    DrawListTypeName = R_GetDrawListTypeName(drawListID);
    R_ProfBeginNamedEventImmediateContext(DrawListTypeName);
    R_DrawCamera(viewInfo, data, rtGroup, &cmdBuf, drawListID);
    R_ProfEndNamedEventImmediateContext();
    R_GPU_EndTimer();
    R_UnlockGfxImmediateContext();
  }
}

/*
==============
RB_StandardDrawCommands_DrawFlaresPostEmissive
==============
*/
void RB_StandardDrawCommands_DrawFlaresPostEmissive(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufSourceState *source; 
  unsigned int height; 
  const R_RT_Surface *Surface; 
  __m256i v9; 
  GfxImage *blackImage; 
  GfxCmdBufSourceState *v11; 
  GfxImage *v12; 
  GfxCmdBufInput *p_input; 
  GfxCmdBufSourceState *v14; 
  GfxImage *defaultFogLightmapImage; 
  GfxCmdBufInput *v16; 
  GfxCmdBufContext v17; 
  R_RT_Handle m_mainSceneColorRt; 
  R_RT_DepthHandle m_mainSceneDepthRt; 
  __m256i v20; 

  if ( r_flareDrawOrder->current.integer )
  {
    Sys_ProfBeginNamedEvent(0xFFFFD700, "exec cmds flares post emissive");
    source = gfxContext->source;
    R_InitCmdBufSourceState(gfxContext->source, &viewInfo->input);
    R_InitLocalCmdBufState(gfxContext->state, &source->input);
    m_mainSceneColorRt = (R_RT_Handle)viewInfo->sceneRtInput.m_mainSceneColorRt;
    height = R_RT_Handle::GetSurface(&m_mainSceneColorRt)->m_image.m_base.height;
    Surface = R_RT_Handle::GetSurface(&m_mainSceneColorRt);
    R_SetRenderTargetSize(source, Surface->m_image.m_base.width, height, GFX_USE_VIEWPORT_FOR_VIEW);
    R_BeginViewInternal(source, &viewInfo->sceneDef, (const GfxViewParms *)viewInfo, &viewInfo->viewParmsSet.frames[1].viewParms);
    R_SetViewportStruct(source, &viewInfo->sceneViewport);
    v9 = (__m256i)viewInfo->sceneRtInput.m_mainSceneColorRt;
    m_mainSceneDepthRt = viewInfo->sceneRtInput.m_mainSceneDepthRt;
    *(GfxCmdBufContext *)&m_mainSceneColorRt.m_surfaceID = *gfxContext;
    v20 = v9;
    R_SetRenderTargetsInternal_ColorDepth((GfxCmdBufContext *)&m_mainSceneColorRt, (R_RT_ColorHandle *)&v20, &m_mainSceneDepthRt, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(2390)");
    blackImage = rgp.blackImage;
    if ( !source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
      __debugbreak();
    if ( source == (GfxCmdBufSourceState *)-1792i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
      __debugbreak();
    source->input.codeImages[36] = blackImage;
    v11 = gfxContext->source;
    v12 = rgp.blackImage;
    if ( !gfxContext->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
      __debugbreak();
    p_input = &v11->input;
    if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
      __debugbreak();
    p_input->codeImages[37] = v12;
    v14 = gfxContext->source;
    defaultFogLightmapImage = rgp.defaultFogLightmapImage;
    if ( !gfxContext->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
      __debugbreak();
    v16 = &v14->input;
    if ( !v16 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
      __debugbreak();
    v17 = *gfxContext;
    v16->codeImages[38] = defaultFogLightmapImage;
    *(GfxCmdBufContext *)&m_mainSceneColorRt.m_surfaceID = v17;
    RB_Flare_Draw((GfxCmdBufContext *)&m_mainSceneColorRt, viewInfo, data);
    R_ShutdownLocalCmdBufState(gfxContext->state, &gfxContext->source->input);
    Sys_ProfEndNamedEvent();
  }
}

/*
==============
RB_StandardDrawCommands_DrawSunPost
==============
*/
void RB_StandardDrawCommands_DrawSunPost(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  __m256i m_mainSceneColorRt; 
  GfxCmdBufSourceState *source; 
  GfxImage *blackImage; 
  GfxCmdBufInput *p_input; 
  GfxCmdBufSourceState *v10; 
  GfxImage *v11; 
  GfxCmdBufInput *v12; 
  GfxCmdBufSourceState *v13; 
  GfxImage *defaultFogLightmapImage; 
  GfxCmdBufInput *v15; 
  GfxCmdBufContext v18; 
  R_RT_DepthHandle m_mainSceneDepthRt; 
  __m256i v20; 

  Sys_ProfBeginNamedEvent(0xFFFFD700, "exec cmds sunpost");
  v18 = *gfxContext;
  RB_StandardDrawCommands_PreDrawOcclusionQueriesAndSun(&v18, viewInfo, "SunPost");
  m_mainSceneColorRt = (__m256i)viewInfo->sceneRtInput.m_mainSceneColorRt;
  m_mainSceneDepthRt = viewInfo->sceneRtInput.m_mainSceneDepthRt;
  v18 = *gfxContext;
  v20 = m_mainSceneColorRt;
  R_SetRenderTargetsInternal_ColorDepth(&v18, (R_RT_ColorHandle *)&v20, &m_mainSceneDepthRt, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(2345)");
  source = gfxContext->source;
  blackImage = rgp.blackImage;
  if ( !gfxContext->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  p_input = &source->input;
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codeImages[36] = blackImage;
  v10 = gfxContext->source;
  v11 = rgp.blackImage;
  if ( !gfxContext->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  v12 = &v10->input;
  if ( !v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  v12->codeImages[37] = v11;
  v13 = gfxContext->source;
  defaultFogLightmapImage = rgp.defaultFogLightmapImage;
  if ( !gfxContext->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  v15 = &v13->input;
  if ( !v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  v15->codeImages[38] = defaultFogLightmapImage;
  if ( RB_IsSunEnabled() )
  {
    R_GPU_BeginTimer(GPU_TIMER_SUN_POST);
    v18 = *gfxContext;
    RB_DrawSunPostEffects(&v18, viewInfo);
    R_GPU_EndTimer();
  }
  if ( !r_flareDrawOrder->current.integer )
  {
    v18 = *gfxContext;
    RB_Flare_Draw(&v18, viewInfo, data);
  }
  _XMM0 = *gfxContext;
  __asm { vpextrq rbx, xmm0, 1 }
  R_ProfEndNamedEvent(_RBX);
  R_ShutdownLocalCmdBufState(_RBX, &gfxContext->source->input);
  Sys_ProfEndNamedEvent();
}

/*
==============
RB_StandardDrawCommands_PreDrawOcclusionQueriesAndSun
==============
*/
void RB_StandardDrawCommands_PreDrawOcclusionQueriesAndSun(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const char *pass)
{
  GfxCmdBufSourceState *source; 
  GfxCmdBufState *state; 
  const R_RT_Surface *Surface; 
  R_RT_Handle m_mainSceneColorRt; 

  Sys_ProfBeginNamedEvent(0xFFFFD700, "exec cmds occqueries sun");
  source = gfxContext->source;
  R_InitCmdBufSourceState(gfxContext->source, &viewInfo->input);
  state = gfxContext->state;
  R_InitLocalCmdBufState(state, &source->input);
  R_ProfBeginNamedEvent(state, pass);
  m_mainSceneColorRt = (R_RT_Handle)viewInfo->sceneRtInput.m_mainSceneColorRt;
  LODWORD(state) = R_RT_Handle::GetSurface(&m_mainSceneColorRt)->m_image.m_base.height;
  Surface = R_RT_Handle::GetSurface(&m_mainSceneColorRt);
  R_SetRenderTargetSize(source, Surface->m_image.m_base.width, (unsigned int)state, GFX_USE_VIEWPORT_FOR_VIEW);
  R_BeginViewInternal(source, &viewInfo->sceneDef, (const GfxViewParms *)viewInfo, &viewInfo->viewParmsSet.frames[1].viewParms);
  R_SetViewportStruct(source, &viewInfo->sceneViewport);
  Sys_ProfEndNamedEvent();
}

/*
==============
RB_StandardDrawCommands_Shadows
==============
*/
void RB_StandardDrawCommands_Shadows(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufState *state; 
  GfxCmdBufState *v6; 
  unsigned int i; 
  GfxCmdBufState *v8; 
  unsigned int v9; 
  GfxCmdBufContext v10; 
  R_RT_Tracking_HandleInfo *p_m_tracking; 
  __int64 v12; 
  unsigned __int16 v13; 
  __int128 v14; 
  double v15; 
  R_RT_Handle v16; 
  bool v17; 
  GfxCmdBufState *v18; 
  R_RT_Handle v19; 
  R_RT_Handle v20; 
  R_RT_Handle v21; 
  GfxCmdBufContext v22; 
  GfxCmdBufContext v23; 
  GfxCmdBufContext v24; 
  R_RT_DepthHandle v25; 
  R_RT_DepthHandle m_sunShadowCascade0ForViewmodel; 
  R_RT_ColorHandle m_translucentShadowRt; 
  R_RT_DepthHandle v28; 
  R_RT_ColorHandle v29; 
  const GfxBackEndData *timeoutUserData; 

  timeoutUserData = data;
  Profile2_UpdateEntry(49);
  if ( ((unsigned __int8)&dword_14FDE8094 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE8094) )
    __debugbreak();
  _InterlockedIncrement(&dword_14FDE8094);
  Sys_ProfBeginNamedEvent(0xFFFFA500, "wait shadow ready");
  Sys_ProcessWorkerCmdsWithTimeout((bool (__fastcall *)(void *))RB_IsShadowReady, &timeoutUserData);
  Sys_ProfEndNamedEvent();
  Profile2_UpdateEntry(49);
  if ( ((unsigned __int64)&dword_14FDE8094 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 44, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE8094) )
    __debugbreak();
  _InterlockedDecrement(&dword_14FDE8094);
  Sys_ProfBeginNamedEvent(0xFFFFD700, "exec cmds shadow");
  state = gfxContext->state;
  R_ProfBeginNamedEvent(state, "exec cmds shadow");
  Profile2_UpdateEntry(50);
  v6 = state;
  if ( ((unsigned __int8)&dword_14FDE8098 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE8098) )
    __debugbreak();
  _InterlockedIncrement(&dword_14FDE8098);
  if ( (*((_BYTE *)&viewInfo->viewportFeatures + 44) & 4) != 0 )
  {
    for ( i = 0; i < timeoutUserData->sunShadow.opaqueCascadeCount; ++i )
    {
      v25 = viewInfo->sceneRtInput.m_sunShadowCascades[i];
      R_AddDepthStencilTransition(state, &v25, DEPTHSTENCIL_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    }
    m_sunShadowCascade0ForViewmodel = viewInfo->sceneRtInput.m_sunShadowCascade0ForViewmodel;
    R_AddDepthStencilTransition(state, &m_sunShadowCascade0ForViewmodel, DEPTHSTENCIL_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    v6 = state;
    if ( rg.useTransSunShadow )
    {
      m_translucentShadowRt = viewInfo->sceneRtInput.m_translucentShadowRt;
      R_AddRenderTargetTransition(state, &m_translucentShadowRt, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    }
  }
  v8 = v6;
  if ( timeoutUserData->spotShadowUpdateCount )
  {
    v9 = 0;
    do
    {
      v28 = viewInfo->sceneRtInput.m_spotShadowRts[v9];
      R_AddDepthStencilTransition(v6, &v28, DEPTHSTENCIL_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
      ++v9;
    }
    while ( v9 < timeoutUserData->spotShadowUpdateCount );
    v8 = state;
  }
  R_FlushResourceTransitions(v8);
  if ( (*((_BYTE *)&viewInfo->viewportFeatures + 44) & 4) != 0 )
  {
    v22 = *gfxContext;
    RB_DrawSunshadow(&v22, timeoutUserData, viewInfo);
  }
  if ( timeoutUserData->spotShadowUpdateCount )
  {
    v23 = *gfxContext;
    RB_SpotShadowMaps(&v23, timeoutUserData, viewInfo);
  }
  if ( (*((_BYTE *)&viewInfo->viewportFeatures + 44) & 4) != 0 && rg.useTransSunShadow )
  {
    v29 = viewInfo->sceneRtInput.m_translucentShadowRt;
    R_AddRenderTargetTransition(v8, &v29, RENDERTARGET_TRANSITION_MODE_READ, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    R_FlushResourceTransitions(v8);
  }
  v10 = *gfxContext;
  R_LockGfxImmediateContext();
  p_m_tracking = &viewInfo->sceneRtInput.m_spotShadowRts[0].m_tracking;
  v12 = 8i64;
  do
  {
    v13 = (__int64)p_m_tracking[-1].m_location & 0x7FFF;
    if ( !v13 )
      v13 = 0;
    v20.m_surfaceID = v13;
    v14 = *(_OWORD *)&p_m_tracking->m_allocCounter;
    v15 = *(double *)&p_m_tracking->m_location;
    *(_OWORD *)&v20.m_tracking.m_allocCounter = *(_OWORD *)&p_m_tracking->m_allocCounter;
    *(double *)&v20.m_tracking.m_location = v15;
    v16 = v20;
    v19 = v20;
    v21 = v20;
    if ( v13 )
    {
      R_RT_Handle::GetSurface(&v21);
      if ( (R_RT_Handle::GetSurface(&v21)->m_rtFlagsInternal & 0x10) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 277, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsDepth())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsDepth()") )
      {
        v16 = v21;
        v19 = v21;
      }
      else
      {
        v16 = v21;
        v19 = v21;
        __debugbreak();
      }
    }
    else if ( v20.m_tracking.m_allocCounter )
    {
      v17 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      v16 = v19;
      if ( v17 )
        __debugbreak();
    }
    LOWORD(p_m_tracking[-1].m_location) = 0;
    p_m_tracking->m_allocCounter = 0;
    p_m_tracking->m_name = NULL;
    p_m_tracking->m_location = NULL;
    v20 = v16;
    if ( (_WORD)v14 )
    {
      R_RT_Handle::GetSurface(&v20);
    }
    else
    {
      if ( !v21.m_tracking.m_allocCounter )
        goto LABEL_43;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    v16 = v19;
LABEL_43:
    if ( (_WORD)v14 )
    {
      v19 = v16;
      v24 = v10;
      R_RT_Destroy(&v24, (R_RT_DepthHandle *)&v19);
    }
    p_m_tracking = (R_RT_Tracking_HandleInfo *)((char *)p_m_tracking + 32);
    --v12;
  }
  while ( v12 );
  R_FlushImmediateContext();
  R_UnlockGfxImmediateContext();
  Profile2_UpdateEntry(50);
  if ( ((unsigned __int64)&dword_14FDE8098 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 44, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE8098) )
    __debugbreak();
  v18 = gfxContext->state;
  _InterlockedDecrement(&dword_14FDE8098);
  R_ProfEndNamedEvent(v18);
  Sys_ProfEndNamedEvent();
}

/*
==============
RB_StartDraw3DScene
==============
*/
void RB_StartDraw3DScene(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  unsigned int maxSpotShadowIndex; 
  __int64 voxelTreeZoneIndex; 
  GfxCmdBufState *state; 
  GfxCmdBufContext v9; 

  if ( data != backEndData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 3495, ASSERT_TYPE_ASSERT, "(data == backEndData)", (const char *)&queryFormat, "data == backEndData") )
    __debugbreak();
  v9 = *gfxContext;
  if ( !RB_IsBackendCmdBufContext(&v9) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 3496, ASSERT_TYPE_ASSERT, "(RB_IsBackendCmdBufContext( gfxContext ))", (const char *)&queryFormat, "RB_IsBackendCmdBufContext( gfxContext )") )
    __debugbreak();
  gfxContext->source->input.data = data;
  Physics_SetDebugCameras(viewInfo);
  Profile_Begin(110);
  R_LockGfxImmediateContext();
  maxSpotShadowIndex = data->maxSpotShadowIndex;
  R_UpdateGfxWrappedBuffer(data->globalLightConstantBuffer, data->packedSceneLights, 96 * data->sceneLightCount);
  R_UpdateGfxWrappedBuffer(data->globalShadowConstantBuffer, data->packedShadowLights, 32 * (3 * maxSpotShadowIndex + 3));
  if ( rgp.world && rgp.world->voxelTreeCount )
  {
    voxelTreeZoneIndex = viewInfo->input.voxelTreeZoneIndex;
    R_UpdateGfxWrappedBuffer(&deviceGlobals.voxelInternalNodeDynamicLightList[voxelTreeZoneIndex][data->dynamicLightListBufferIndex], &rgp.world->voxelTree[voxelTreeZoneIndex].voxelInternalNodeDynamicLightListCPU[data->dynamicLightListBufferIndex * rgp.world->voxelTree[voxelTreeZoneIndex].voxelInternalNodeCount], 4 * rgp.world->voxelTree[voxelTreeZoneIndex].voxelInternalNodeCount);
  }
  R_UnlockGfxImmediateContext();
  Profile_EndInternal(NULL);
  RB_CG_Wind_UpdateWindGridBuffers();
  state = gfxContext->state;
  RB_UploadReactiveMotionData(state, data);
  RB_UpdateSceneConstantBuffer(data, viewInfo);
  RB_UpdatePersistentTables(viewInfo, data, PERSISTENT_TABLE_SCENE);
  RB_ModelIndirectionData_Upload(state, data);
  RB_GpuLightGrid_Update(state, viewInfo, data);
  RB_ST_UpdateFrameDataResources(state, data);
  R_LockGfxImmediateContext();
  if ( !data->bspIndirectArgs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 3537, ASSERT_TYPE_ASSERT, "(data->bspIndirectArgs != nullptr)", (const char *)&queryFormat, "data->bspIndirectArgs != nullptr") )
    __debugbreak();
  R_EndWrappedBufferDataWrite(data->bspIndirectArgsBuffer);
  R_UnlockGfxImmediateContext();
  RB_FogSpline_ProcessBlend(state, viewInfo, data);
  RB_UpdateFallbackProbeData(state, data, viewInfo);
  RB_UpdateEntityDataBuffer(viewInfo, data);
  RB_RTT_DeleteSlots(viewInfo->clientIndex, &data->rttContext);
}

/*
==============
RB_UpdatePersistentTables
==============
*/
void RB_UpdatePersistentTables(const GfxViewInfo *viewInfo, const GfxBackEndData *data, GfxPersistentDescriptorTables table)
{
  GfxDescriptorTable *v5; 
  int v6; 
  int v7; 
  __int64 v8; 
  const GfxImage **codePersistentImages; 
  GfxImage *blackImage; 
  const GfxTexture *v11; 
  unsigned int m_usedSize; 
  GfxDescriptorTable *v13; 
  const GfxWrappedBuffer **codePersistentBuffers; 
  __int64 v15; 
  GfxWrappedBuffer *p_dummyBuffer; 
  unsigned int v17; 
  __int64 v18; 
  __int64 v19; 
  __int64 v21; 

  v5 = &data->globalPersistentTextureTable[table];
  v21 = table;
  R_ResetGfxDescriptorTable(v5);
  v6 = 0;
  v7 = 0;
  v8 = 0i64;
  codePersistentImages = viewInfo->input.codePersistentImages;
  do
  {
    blackImage = (GfxImage *)*codePersistentImages;
    if ( !*codePersistentImages )
      blackImage = rgp.blackImage;
    v11 = R_Texture_Get(data, blackImage->textureId);
    if ( v7 >= v5->m_size )
    {
      LODWORD(v19) = v5->m_size;
      LODWORD(v18) = v7;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_setstate_d3d.h", 1212, ASSERT_TYPE_ASSERT, "(unsigned)( startApiSlot + apiSlotCount - 1 ) < (unsigned)( table->m_size )", "startApiSlot + apiSlotCount - 1 doesn't index table->m_size\n\t%i not in [0, %i)", v18, v19) )
        __debugbreak();
    }
    ++v7;
    v5->m_descriptors[v8] = v11->shaderView.view;
    m_usedSize = v7;
    if ( (signed int)v5->m_usedSize > v7 )
      m_usedSize = v5->m_usedSize;
    ++codePersistentImages;
    ++v8;
    v5->m_usedSize = m_usedSize;
  }
  while ( v7 < 42 );
  R_FlushDescriptorTable(v5);
  v13 = &data->globalPersistentBufferTable[v21];
  R_ResetGfxDescriptorTable(v13);
  codePersistentBuffers = viewInfo->input.codePersistentBuffers;
  v15 = 0i64;
  do
  {
    p_dummyBuffer = &gfxBuf.dummyBuffer;
    if ( *codePersistentBuffers )
      p_dummyBuffer = (GfxWrappedBuffer *)*codePersistentBuffers;
    if ( v6 >= v13->m_size )
    {
      LODWORD(v19) = v13->m_size;
      LODWORD(v18) = v6;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_setstate_d3d.h", 1222, ASSERT_TYPE_ASSERT, "(unsigned)( startApiSlot + apiSlotCount - 1 ) < (unsigned)( table->m_size )", "startApiSlot + apiSlotCount - 1 doesn't index table->m_size\n\t%i not in [0, %i)", v18, v19) )
        __debugbreak();
    }
    ++v6;
    v13->m_descriptors[v15] = p_dummyBuffer->view.view;
    v17 = v6;
    if ( (signed int)v13->m_usedSize > v6 )
      v17 = v13->m_usedSize;
    ++codePersistentBuffers;
    ++v15;
    v13->m_usedSize = v17;
  }
  while ( v6 < 41 );
  R_FlushDescriptorTable(v13);
}

/*
==============
RB_UploadPackedLightData
==============
*/
void RB_UploadPackedLightData(const GfxBackEndData *data, const GfxViewInfo *viewInfo)
{
  unsigned int maxSpotShadowIndex; 
  __int64 voxelTreeZoneIndex; 

  Profile_Begin(110);
  R_LockGfxImmediateContext();
  maxSpotShadowIndex = data->maxSpotShadowIndex;
  R_UpdateGfxWrappedBuffer(data->globalLightConstantBuffer, data->packedSceneLights, 96 * data->sceneLightCount);
  R_UpdateGfxWrappedBuffer(data->globalShadowConstantBuffer, data->packedShadowLights, 32 * (3 * maxSpotShadowIndex + 3));
  if ( rgp.world && rgp.world->voxelTreeCount )
  {
    voxelTreeZoneIndex = viewInfo->input.voxelTreeZoneIndex;
    R_UpdateGfxWrappedBuffer(&deviceGlobals.voxelInternalNodeDynamicLightList[voxelTreeZoneIndex][data->dynamicLightListBufferIndex], &rgp.world->voxelTree[voxelTreeZoneIndex].voxelInternalNodeDynamicLightListCPU[data->dynamicLightListBufferIndex * rgp.world->voxelTree[voxelTreeZoneIndex].voxelInternalNodeCount], 4 * rgp.world->voxelTree[voxelTreeZoneIndex].voxelInternalNodeCount);
  }
  R_UnlockGfxImmediateContext();
  Profile_EndInternal(NULL);
}

/*
==============
R_BlitDebugOverlay
==============
*/
void R_BlitDebugOverlay(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, R_RT_ColorHandle *outputRt, R_RT_ColorHandle *debugOverlayRt)
{
  GfxCmdBufSourceState *source; 
  R_RT_Image *p_m_image; 
  GfxCmdBufInput *p_input; 
  GfxCmdBufContext v9; 
  float height; 
  float width; 
  GfxCmdBufContext v12; 
  GfxViewport displayViewport; 

  source = gfxContext->source;
  displayViewport = viewInfo->displayViewport;
  R_SetViewportStruct(source, &displayViewport);
  R_Set2D(source);
  source->input.consts[59] = colorWhite;
  ++source->constVersions[59];
  source->input.consts[60] = colorBlackBlank;
  ++source->constVersions[60];
  source->input.consts[61].v[0] = 0.0;
  *(_QWORD *)&source->input.consts[61].xyz.y = 2139095039i64;
  source->input.consts[61].v[3] = 0.0;
  ++source->constVersions[61];
  p_m_image = &R_RT_Handle::GetSurface(debugOverlayRt)->m_image;
  p_input = &source->input;
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  v9 = *gfxContext;
  p_input->codeImages[4] = &p_m_image->m_base;
  height = (float)displayViewport.height;
  width = (float)displayViewport.width;
  v12 = v9;
  RB_ViewportFilterDirectInternal(&v12, rgp.feedbackBlendBackbufferMaterial, 0xFFFFFFFF, &displayViewport, 0.0, 0.0, width, height, 0.0, 0.0, 1.0, 1.0, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1032)");
}

/*
==============
R_ClearColorTargetAsync
==============
*/
void R_ClearColorTargetAsync(ComputeCmdBufState *state, R_RT_ColorHandle *colorRt)
{
  const R_RT_Surface *Surface; 
  const GfxTexture *Resident; 
  unsigned int height; 
  unsigned int width; 
  const R_RT_Surface *v8; 
  const R_RT_Surface *v9; 
  const GfxTexture *v10; 
  const R_RT_Surface *v11; 
  const GfxTexture *v12; 

  R_ProfBeginNamedEvent(state, "R_ClearColorTargetAsync");
  R_GPU_BeginTimer(GPU_TIMER_CLEAR_SCREEN);
  if ( (R_RT_Handle::GetSurface(colorRt)->m_rtFlags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 1386, ASSERT_TYPE_ASSERT, "(!(colorRt.GetFlags() & R_RT_Flag_FastClear))", "%s\n\teliminate fast clear not implemented for R_ClearColorTargetAsync", "!(colorRt.GetFlags() & R_RT_Flag_FastClear)") )
    __debugbreak();
  if ( (R_RT_Handle::GetSurface(colorRt)->m_rtFlags & 0x1000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 1388, ASSERT_TYPE_ASSERT, "(colorRt.GetFlags() & R_RT_Flag_RWView)", "%s\n\tRWView needed for R_ClearColorTargetAsync", "colorRt.GetFlags() & R_RT_Flag_RWView") )
    __debugbreak();
  Surface = R_RT_Handle::GetSurface(colorRt);
  Resident = R_Texture_GetResident(Surface->m_image.m_base.textureId);
  R_HW_AddResourceTransition(state, Resident, 0xFFFFFFFF, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  R_FlushResourceTransitions(state);
  height = R_RT_Handle::GetSurface(colorRt)->m_image.m_base.height;
  width = R_RT_Handle::GetSurface(colorRt)->m_image.m_base.width;
  v8 = R_RT_Handle::GetSurface(colorRt);
  if ( (v8->m_rtFlagsInternal & 0x10) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 324, ASSERT_TYPE_ASSERT, "(!( surface->m_rtFlagsInternal & R_RT_FlagInternal_Depth ))", (const char *)&queryFormat, "!( surface->m_rtFlagsInternal & R_RT_FlagInternal_Depth )") )
    __debugbreak();
  v9 = R_RT_Handle::GetSurface(colorRt);
  v10 = R_Texture_GetResident(v9->m_image.m_base.textureId);
  R_SetTextureRect(state, v10, &v8->m_color.m_clearColor, 0, 0, width, height);
  v11 = R_RT_Handle::GetSurface(colorRt);
  v12 = R_Texture_GetResident(v11->m_image.m_base.textureId);
  R_HW_AddResourceTransition(state, v12, 0xFFFFFFFF, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  R_FlushResourceTransitions(state);
  R_GPU_EndTimer();
  R_ProfEndNamedEvent(state);
}

/*
==============
R_ClearGlobalRTsAsRequired
==============
*/
void R_ClearGlobalRTsAsRequired(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo)
{
  GfxCmdBufSourceState *source; 
  int i; 
  R_RT_Handle *v7; 
  unsigned __int16 m_surfaceID; 
  const char *LastKnownName; 
  unsigned __int16 v10; 
  GfxCmdBufContext v11; 
  R_RT_Handle *v12; 
  GfxCmdBufState *state; 
  R_RT_Handle v14; 
  bool v16; 
  R_RT_Handle v18; 
  bool v20; 
  __int64 v21; 
  __int64 v22; 
  R_RT_Handle v23; 
  __m256i v24; 
  __m256i *v25; 
  R_RT_Group v26; 
  R_RT_Group v27; 

  v25 = (__m256i *)viewInfo;
  Sys_ProfBeginNamedEvent(0xFF800000, "R_ClearGlobalRTsAsRequired");
  source = gfxContext->source;
  R_InitCmdBufSourceState(gfxContext->source, &viewInfo->input);
  R_InitLocalCmdBufState(gfxContext->state, &source->input);
  R_ProfBeginNamedEvent(gfxContext->state, "R_ClearGlobalRTsAsRequired");
  R_GPU_BeginTimer(GPU_TIMER_CLEAR_SCREEN);
  for ( i = 0; i != 10; ++i )
  {
    if ( (unsigned __int8)i >= 0xAu )
    {
      LODWORD(v22) = 10;
      LODWORD(v21) = (unsigned __int8)i;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_globals.h", 65, ASSERT_TYPE_ASSERT, "(unsigned)( static_cast<uint>( rtId ) ) < (unsigned)( ( sizeof( *array_counter( g_R_RT_globals ) ) + 0 ) )", "static_cast<uint>( rtId ) doesn't index ARRAY_COUNT( g_R_RT_globals )\n\t%i not in [0, %i)", v21, v22) )
        __debugbreak();
    }
    v7 = &g_R_RT_globals[(unsigned __int8)i];
    if ( R_RT_Handle::IsValid(v7) )
    {
      if ( (unsigned __int8)i >= 0xAu )
      {
        LODWORD(v22) = 10;
        LODWORD(v21) = (unsigned __int8)i;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_globals.h", 72, ASSERT_TYPE_ASSERT, "(unsigned)( static_cast<uint>( rtId ) ) < (unsigned)( ( sizeof( *array_counter( g_R_RT_globals ) ) + 0 ) )", "static_cast<uint>( rtId ) doesn't index ARRAY_COUNT( g_R_RT_globals )\n\t%i not in [0, %i)", v21, v22) )
          __debugbreak();
      }
      m_surfaceID = v7->m_surfaceID;
      if ( v7->m_surfaceID )
      {
        R_RT_Handle::GetSurface(v7);
      }
      else if ( v7->m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      {
        __debugbreak();
      }
      if ( !m_surfaceID )
      {
        LastKnownName = R_RT_Handle::DebugGetLastKnownName(v7);
        LODWORD(v22) = (unsigned __int8)i;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_globals.h", 73, ASSERT_TYPE_ASSERT, "(g_R_RT_globals[rtId].IsValid())", "%s\n\trtId=%u(%s), last-known name=%s", "g_R_RT_globals[rtId].IsValid()", v22, g_R_RT_globalSlotNames[(unsigned __int8)i], LastKnownName) )
          __debugbreak();
      }
      v24 = *(__m256i *)v7;
      v10 = _XMM0 & 0x7FFF;
      if ( (_XMM0 & 0x7FFF) == 0 )
        v10 = 0;
      _XMM0 = *(_OWORD *)&v24.m256i_u64[1];
      v23.m_tracking = *(R_RT_Tracking_HandleInfo *)&v24.m256i_u64[1];
      v11 = *gfxContext;
      v23.m_surfaceID = v10;
      v24 = (__m256i)v23;
      *(GfxCmdBufContext *)&v23.m_surfaceID = v11;
      R_SetAndClearIfRequired((GfxCmdBufContext *)&v23, (R_RT_Handle *)&v24);
    }
  }
  v12 = (R_RT_Handle *)v25;
  state = gfxContext->state;
  if ( v25[416].m256i_i32[0] )
  {
    v14 = (R_RT_Handle)v25[415];
    v24 = (__m256i)v14;
    v23 = v14;
    if ( (_WORD)_XMM0 )
    {
      R_RT_Handle::GetSurface(&v23);
      if ( (R_RT_Handle::GetSurface(&v23)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        v14 = v23;
        __debugbreak();
      }
      else
      {
        v14 = v23;
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v16 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        v14 = (R_RT_Handle)v24;
        if ( v16 )
          __debugbreak();
      }
    }
    v24 = (__m256i)v14;
    R_AddRenderTargetTransition(state, (R_RT_ColorHandle *)&v24, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    R_FlushResourceTransitions(state);
    v24 = (__m256i)v12[415];
    R_RT_Group::AssignColor(&v26, (R_RT_ColorHandle *)&v24);
    *(__m256i *)&v27.m_colorRtCount = *(__m256i *)&v26.m_colorRtCount;
    *(__m256i *)&v27.m_colorRts[0].m_tracking.m_location = *(__m256i *)&v26.m_colorRts[0].m_tracking.m_location;
    *(__m256i *)&v27.m_colorRts[1].m_tracking.m_location = *(__m256i *)&v26.m_colorRts[1].m_tracking.m_location;
    *(__m256i *)&v27.m_colorRts[2].m_tracking.m_location = *(__m256i *)&v26.m_colorRts[2].m_tracking.m_location;
    _XMM0 = *gfxContext;
    *(__m256i *)&v27.m_colorRts[3].m_tracking.m_location = *(__m256i *)&v26.m_colorRts[3].m_tracking.m_location;
    *(__m256i *)&v27.m_depthRt.m_tracking.m_location = *(__m256i *)&v26.m_depthRt.m_tracking.m_location;
    v27.m_vrsRt.m_tracking.m_location = v26.m_vrsRt.m_tracking.m_location;
    *(GfxCmdBufContext *)&v23.m_surfaceID = _XMM0;
    R_SetRenderTargetsInternal((GfxCmdBufContext *)&v23, &v27, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(495)");
    R_ClearScreen(state, 0xFu, 0);
    v18 = v12[415];
    v24 = (__m256i)v18;
    v23 = v18;
    if ( LOWORD(_XMM0.source) )
    {
      R_RT_Handle::GetSurface(&v23);
      if ( (R_RT_Handle::GetSurface(&v23)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        v18 = v23;
        __debugbreak();
      }
      else
      {
        v18 = v23;
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v20 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        v18 = (R_RT_Handle)v24;
        if ( v20 )
          __debugbreak();
      }
    }
    v24 = (__m256i)v18;
    R_AddRenderTargetTransition(state, (R_RT_ColorHandle *)&v24, RENDERTARGET_TRANSITION_MODE_READ, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    R_FlushResourceTransitions(state);
    R_FlushImmediateContext();
  }
  R_ResetRenderTargets(state);
  R_FlushImmediateContext();
  R_GPU_EndTimer();
  R_ProfEndNamedEvent(state);
  R_ShutdownLocalCmdBufState(state, &gfxContext->source->input);
  Sys_ProfEndNamedEvent();
}

/*
==============
R_ClearRenderTarget
==============
*/
void R_ClearRenderTarget(GfxCmdBufContext *gfxContext, const R_RT_Group *rtGroup, unsigned __int8 whichToClear, unsigned __int8 stencil)
{
  GfxCmdBufSourceState *source; 
  GfxCmdBufState *state; 
  unsigned int height; 
  const R_RT_Surface *Surface; 
  R_RT_Handle v12; 
  R_RT_Handle result; 

  source = gfxContext->source;
  state = gfxContext->state;
  R_InitLocalCmdBufState(state, &gfxContext->source->input);
  R_ProfBeginNamedEvent(state, "R_ClearRenderTarget");
  v12 = *R_RT_Group::GetValidRt((R_RT_Group *)rtGroup, &result);
  height = R_RT_Handle::GetSurface(&v12)->m_image.m_base.height;
  Surface = R_RT_Handle::GetSurface(&v12);
  R_SetRenderTargetSize(source, Surface->m_image.m_base.width, height, GFX_USE_VIEWPORT_FOR_VIEW);
  *(GfxCmdBufContext *)&v12.m_surfaceID = *gfxContext;
  R_SetRenderTargetsInternal((GfxCmdBufContext *)&v12, rtGroup, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1368)");
  R_GPU_BeginTimer(GPU_TIMER_CLEAR_SCREEN);
  R_ClearScreen(state, whichToClear, stencil);
  R_GPU_EndTimer();
  R_ProfEndNamedEvent(state);
  R_ShutdownLocalCmdBufState(state, &source->input);
}

/*
==============
R_DebugPrimitivesValid
==============
*/
bool R_DebugPrimitivesValid()
{
  const dvar_t *v0; 

  v0 = DCONST_DVARINT_developer;
  if ( !DCONST_DVARINT_developer && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "developer") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v0);
  return v0->current.integer && (Physics_RenderDebugEnabled() || CG_Edge_DrawDebugEnabled() || RB_Stream_TreeDebugDrawEnabled() || RB_Stream_XModelTreeDebugDrawEnabled() || RB_NeedDrawDebug());
}

/*
==============
R_Draw2D_BackupScopeReticle
==============
*/
void R_Draw2D_BackupScopeReticle(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, const GfxImage *sceneSrc, const GfxImage *scopeBuffer)
{
  GfxCmdBufContext v5; 

  v5 = *gfxContext;
  R_Draw2D_CopyScopeReticle(&v5, viewInfo, data, sceneSrc, scopeBuffer);
}

/*
==============
R_Draw2D_BeforePostFX
==============
*/
void R_Draw2D_BeforePostFX(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, R_RT_ColorHandle *sceneRt, R_RT_DepthHandle *depthRt, const GfxImage *universalClut)
{
  const void *v9; 
  GfxCmdBufContext v10; 
  GfxCmdBufContext v11; 
  R_RT_DepthHandle v12; 
  R_RT_ColorHandle v13; 
  GfxDevice *device; 

  v13 = *sceneRt;
  v12 = *depthRt;
  v10 = *gfxContext;
  RB_InitClient2DReceivePPFXContext(&v10, viewInfo, data, &v13, &v12, universalClut);
  if ( data->async2D.renderReceivePPFXPending )
  {
    depthRt = (R_RT_DepthHandle *)data;
    Sys_ProfBeginNamedEvent(0xFF008008, "wait LUI render");
    R_UnlockGfxImmediateContext();
    Sys_ProcessWorkerCmdsWithTimeout((bool (__fastcall *)(void *))RB_Async2D_ReceivePPFXFinished, &depthRt);
    R_LockGfxImmediateContext();
    Sys_ProfEndNamedEvent();
  }
  if ( data->async2D.receivePPFXCmdBuf.device )
  {
    if ( !data->async2D.renderFailed )
    {
      R_FlushImmediateContext();
      device = data->async2D.receivePPFXCmdBuf.device;
      ((void (__fastcall *)(ID3D12CommandQueue *, __int64, GfxDevice **))g_dx.immediateCommandQueue.commandQueue->m_pFunction[3].AddRef)(g_dx.immediateCommandQueue.commandQueue, 1i64, &device);
      data->async2D.receivePPFXCmdBuf.device = NULL;
      return;
    }
    data->async2D.receivePPFXCmdBuf.device = NULL;
  }
  v9 = viewInfo->displayCmds[3];
  v11 = *gfxContext;
  RB_ExecuteRenderCommandsLoop(&v11, v9, NULL);
}

/*
==============
R_Draw2D_BeforePostFX_IsValid
==============
*/
bool R_Draw2D_BeforePostFX_IsValid(const GfxViewInfo *viewInfo)
{
  return viewInfo->displayCmds[3] != NULL;
}

/*
==============
R_Draw2D_CopyScopeReticle
==============
*/
void R_Draw2D_CopyScopeReticle(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, const GfxImage *sceneSrc, const GfxImage *scopeBuffer)
{
  GfxCmdBufSourceState *source; 
  GfxCmdBufInput *p_input; 
  GfxCmdBufSourceState *v10; 
  GfxCmdBufInput *v11; 
  GfxCmdBufSourceState *v12; 
  const void *v13; 
  GfxCmdBufContext v14[2]; 

  if ( viewInfo->displayCmds[4] )
  {
    v14[0] = *gfxContext;
    RB_InitClient2DContext_CopyScopeReticle(v14, viewInfo, data);
    source = gfxContext->source;
    if ( !gfxContext->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
      __debugbreak();
    p_input = &source->input;
    if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
      __debugbreak();
    p_input->codeImages[80] = scopeBuffer;
    v10 = gfxContext->source;
    if ( !gfxContext->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
      __debugbreak();
    v11 = &v10->input;
    if ( !v11 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
      __debugbreak();
    v11->codeImages[24] = sceneSrc;
    v12 = gfxContext->source;
    R_ForceSet2D(gfxContext->source, &viewInfo->displayViewport);
    v13 = viewInfo->displayCmds[4];
    v14[0] = *gfxContext;
    RB_ExecuteRenderCommandsLoop(v14, v13, rgp.reticleCopyScreen);
    if ( !v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
      __debugbreak();
    if ( v12 == (GfxCmdBufSourceState *)-1792i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
      __debugbreak();
    v12->input.codeImages[24] = NULL;
  }
}

/*
==============
R_Draw2D_Hud
==============
*/
void R_Draw2D_Hud(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, R_RT_ColorHandle *colorRt, R_RT_Handle *packedStencil, const GfxImage *universalClut, const GfxImage *resolvedScene, const GfxWrappedBuffer *exposureBuffer)
{
  R_RT_Handle *v12; 
  const void *v13; 
  _WORD *v14; 
  bool v15; 
  const char *LastKnownName; 
  GfxCmdBufSourceState *source; 
  R_RT_ColorHandle v18; 
  GfxCmdBufContext v19; 
  const void *v20; 
  const void *v21; 
  __int64 v22; 
  GfxCmdBufContext v23; 
  GfxCmdBufContext v24; 
  GfxCmdBufContext v25; 
  GfxCmdBufContext v26; 
  GfxCmdBufContext v27; 
  R_RT_Handle v28; 
  R_RT_ColorHandle v29; 
  R_RT_Handle v30; 
  R_RT_ColorHandle v31; 
  const GfxBackEndData *timeoutUserData; 

  if ( viewInfo->displayCmds[0] )
  {
    v12 = packedStencil;
    v29 = *colorRt;
    v28 = *packedStencil;
    v23 = *gfxContext;
    RB_InitClient2DContext(&v23, viewInfo, data, &v29, &v28, universalClut, resolvedScene, exposureBuffer);
    v13 = viewInfo->displayCmds[0];
    v24 = *gfxContext;
    RB_ExecuteRenderCommandsLoop(&v24, v13, NULL);
    v14 = viewInfo->displayCmds[2];
    v15 = v14 && *v14;
    if ( viewInfo->displayCmds[1] )
    {
      if ( g_R_RT_globals[0].m_surfaceID )
      {
        R_RT_Handle::GetSurface(g_R_RT_globals);
      }
      else
      {
        if ( g_R_RT_globals[0].m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
          __debugbreak();
        LastKnownName = R_RT_Handle::DebugGetLastKnownName(g_R_RT_globals);
        LODWORD(v22) = 0;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_globals.h", 73, ASSERT_TYPE_ASSERT, "(g_R_RT_globals[rtId].IsValid())", "%s\n\trtId=%u(%s), last-known name=%s", "g_R_RT_globals[rtId].IsValid()", v22, g_R_RT_globalSlotNames[0], LastKnownName) )
          __debugbreak();
      }
      if ( ((g_R_RT_globals[0].m_surfaceID ^ (unsigned __int16)*(_DWORD *)&data->displayRtDebug.m_surfaceID) & 0xFFFF7FFF) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 2193, ASSERT_TYPE_ASSERT, "(data->displayRtDebug == R_RT_GetGlobal( R_RENDERTARGET_DISPLAY_BUFFER ))", (const char *)&queryFormat, "data->displayRtDebug == R_RT_GetGlobal( R_RENDERTARGET_DISPLAY_BUFFER )") )
        __debugbreak();
      if ( data->async2D.renderPending )
      {
        timeoutUserData = data;
        Sys_ProfBeginNamedEvent(0xFF008008, "wait LUI render");
        R_UnlockGfxImmediateContext();
        Sys_ProcessWorkerCmdsWithTimeout((bool (__fastcall *)(void *))RB_Async2D_Finished, &timeoutUserData);
        R_LockGfxImmediateContext();
        Sys_ProfEndNamedEvent();
      }
      if ( RB_Async2D_ExecCmdBuf(&data->async2D.cmdBuf, data->async2D.renderFailed) )
      {
        if ( !v15 )
          return;
        source = gfxContext->source;
        R_ShutdownLocalCmdBufState(gfxContext->state, &gfxContext->source->input);
        R_InitLocalCmdBufState(gfxContext->state, &source->input);
        v18 = *colorRt;
        v30 = *v12;
        v19 = *gfxContext;
        v31 = v18;
        v25 = v19;
        RB_InitClient2DContext(&v25, viewInfo, data, &v31, &v30, universalClut, resolvedScene, exposureBuffer);
      }
      else
      {
        v20 = viewInfo->displayCmds[1];
        v26 = *gfxContext;
        RB_ExecuteRenderCommandsLoop(&v26, v20, NULL);
      }
    }
    if ( v15 )
    {
      v21 = viewInfo->displayCmds[2];
      v27 = *gfxContext;
      RB_ExecuteRenderCommandsLoop(&v27, v21, NULL);
    }
  }
}

/*
==============
R_Draw2D_RTT
==============
*/
void R_Draw2D_RTT(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  unsigned int v6; 
  const void **v7; 
  __int64 v8; 
  const char *Name; 
  const void *v10; 
  GfxCmdBufContext v11; 
  R_RT_ColorHandle result; 

  if ( !data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 3826, ASSERT_TYPE_ASSERT, "(data)", (const char *)&queryFormat, "data") )
    __debugbreak();
  v11 = *gfxContext;
  RB_InitClient2D_RTT(&v11, viewInfo, data);
  v6 = 1;
  v7 = &viewInfo->displayCmds[8];
  v8 = 8i64;
  do
  {
    if ( *v7 )
    {
      RB_RTT_GetSurface(&result, viewInfo->clientIndex, &data->rttContext, v6);
      if ( (result.m_surfaceID & 0x7FFF) != 0 )
      {
        v10 = *v7;
        v11 = *gfxContext;
        RB_ExecuteRenderCommandsLoop(&v11, v10, NULL);
      }
      else
      {
        Name = R_RTT_GetName(v6);
        Com_Printf(8, "ERROR: RTT %s is not allocated, skipping update\n", Name);
      }
    }
    ++v7;
    ++v6;
    --v8;
  }
  while ( v8 );
}

/*
==============
R_Draw2D_RTT_Overlay
==============
*/
void R_Draw2D_RTT_Overlay(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  unsigned int unsignedInt; 
  GfxCmdBufContext v6; 

  v6 = *gfxContext;
  unsignedInt = r_rtt_showOverlay->current.unsignedInt;
  RB_InitClient2D_RTT(&v6, viewInfo, data);
  if ( unsignedInt <= 8 )
  {
    v6 = *gfxContext;
    RB_DrawRttOverlay(&v6, viewInfo, unsignedInt);
  }
}

/*
==============
R_Draw2D_ReceivePostFXComposite
==============
*/
void R_Draw2D_ReceivePostFXComposite(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, R_RT_ColorHandle *sceneRt, const GfxImage *packedStencil, const GfxImage *scopeBuffer)
{
  GfxCmdBufContext v8; 
  const void *v9; 
  GfxCmdBufContext v10; 
  R_RT_ColorHandle v11; 

  if ( viewInfo->displayCmds[5] )
  {
    v8 = *gfxContext;
    v11 = *sceneRt;
    v10 = v8;
    RB_InitClient2DContext_ReceivePostFXLite(&v10, viewInfo, data, &v11, packedStencil, scopeBuffer);
    v9 = viewInfo->displayCmds[5];
    v10 = *gfxContext;
    RB_ExecuteRenderCommandsLoop(&v10, v9, NULL);
  }
}

/*
==============
R_Draw2D_ReceivePostFXComposite_IsValid
==============
*/
bool R_Draw2D_ReceivePostFXComposite_IsValid(const GfxViewInfo *viewInfo)
{
  return viewInfo->displayCmds[5] != NULL;
}

/*
==============
R_Draw2D_ReceivePostFXLite
==============
*/
void R_Draw2D_ReceivePostFXLite(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, R_RT_ColorHandle *sceneRt, const GfxImage *packedStencil, const GfxImage *scopeBuffer)
{
  GfxCmdBufContext v8; 
  const void *v9; 
  GfxCmdBufContext v10; 
  R_RT_ColorHandle v11; 

  if ( viewInfo->displayCmds[4] )
  {
    v8 = *gfxContext;
    v11 = *sceneRt;
    v10 = v8;
    RB_InitClient2DContext_ReceivePostFXLite(&v10, viewInfo, data, &v11, packedStencil, scopeBuffer);
    v9 = viewInfo->displayCmds[4];
    v10 = *gfxContext;
    RB_ExecuteRenderCommandsLoop(&v10, v9, NULL);
  }
}

/*
==============
R_Draw2D_ReceivePostFXLite_IsValid
==============
*/
bool R_Draw2D_ReceivePostFXLite_IsValid(const GfxViewInfo *viewInfo)
{
  return viewInfo->displayCmds[4] != NULL;
}

/*
==============
R_Draw2D_RestoreScopeReticle
==============
*/
void R_Draw2D_RestoreScopeReticle(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, const GfxImage *sceneBackup, const GfxImage *scopeBuffer)
{
  GfxCmdBufContext v5; 

  v5 = *gfxContext;
  R_Draw2D_CopyScopeReticle(&v5, viewInfo, data, sceneBackup, scopeBuffer);
}

/*
==============
R_DrawDebug3D_Enabled
==============
*/
bool R_DrawDebug3D_Enabled(const GfxViewInfo *viewInfo)
{
  bool result; 

  if ( R_LGV_DrawProbes_Enabled(viewInfo) )
    return 1;
  if ( R_ReflectionProbe_DrawSH_Enabled(viewInfo) )
    return 1;
  if ( R_FL_RenderDebugProxies_Enabled(viewInfo) )
    return 1;
  if ( r_umbraShowOverlayNDC->current.integer >= 1 )
    return 1;
  result = R_GpuLightGrid_DebugDrawEnabled();
  if ( result )
    return 1;
  return result;
}

/*
==============
R_DrawDebugPrimitives
==============
*/
void R_DrawDebugPrimitives(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo)
{
  GfxCmdBufSourceState *source; 
  GfxCmdBufContext v5; 

  source = gfxContext->source;
  R_BeginViewInternal(gfxContext->source, &viewInfo->sceneDef, &viewInfo->viewParmsSet.frames[2].viewParms, NULL);
  R_SetViewportStruct(source, &viewInfo->sceneViewport);
  R_Set3D(source);
  v5 = *gfxContext;
  RB_DrawDebug(&v5, &source->viewParms, viewInfo);
}

/*
==============
R_DrawWorkerCmdsFinished
==============
*/
bool R_DrawWorkerCmdsFinished(void *data)
{
  return *(_DWORD *)data == 0;
}

/*
==============
R_FontCache_DebugDisplay
==============
*/

void R_FontCache_DebugDisplay(void)
{
  FontCache_RenderDebug();
}

/*
==============
R_HalfRes_DownsampleDepth
==============
*/
void R_HalfRes_DownsampleDepth(GfxCmdBufContext *context, R_RT_Handle *fullResDepth, const GfxViewport *viewport)
{
  GfxCmdBufSourceState *source; 
  R_RT_Image *p_m_image; 
  float height; 
  float width; 
  __int64 v9; 
  GfxCmdBufContext v10; 

  source = context->source;
  p_m_image = &R_RT_Handle::GetSurface(fullResDepth)->m_image;
  if ( !source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  if ( source == (GfxCmdBufSourceState *)-1792i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  source->input.codeImages[0] = &p_m_image->m_base;
  R_Set2D(source);
  if ( source->viewMode != VIEW_MODE_2D )
  {
    LODWORD(v9) = source->viewMode;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 2990, ASSERT_TYPE_ASSERT, "( ( source->viewMode == VIEW_MODE_2D ) )", "( source->viewMode ) = %i", v9) )
      __debugbreak();
  }
  height = (float)viewport->height;
  width = (float)viewport->width;
  v10 = *context;
  RB_ViewportFilterDirectInternal(&v10, rgp.floatZWriteDepthDownsampleMaterial, 0xFFFFFFFF, viewport, 0.0, 0.0, width, height, 0.0, 0.0, 1.0, 1.0, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(2992)");
}

/*
==============
R_HalfRes_Upsample
==============
*/
void R_HalfRes_Upsample(GfxCmdBufContext *context, R_RT_Handle *halfResColor, R_RT_Handle *halfResAlpha, R_RT_Handle *halfResDepth, R_RT_Handle *fullResDepth, const GfxViewport *viewport)
{
  GfxCmdBufSourceState *source; 
  R_RT_Image *p_m_image; 
  GfxCmdBufInput *p_input; 
  R_RT_Image *v13; 
  R_RT_Image *v14; 
  R_RT_Image *v15; 
  GfxCmdBufContext v16; 
  float height; 
  float width; 
  GfxCmdBufContext v19; 

  source = context->source;
  R_Set2D(context->source);
  if ( source->viewMode != VIEW_MODE_2D && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 3002, ASSERT_TYPE_ASSERT, "( ( source->viewMode == VIEW_MODE_2D ) )", "( source->viewMode ) = %i", source->viewMode) )
    __debugbreak();
  p_m_image = &R_RT_Handle::GetSurface(halfResColor)->m_image;
  p_input = &source->input;
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codeImages[22] = &p_m_image->m_base;
  v13 = &R_RT_Handle::GetSurface(halfResAlpha)->m_image;
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codeImages[23] = &v13->m_base;
  v14 = &R_RT_Handle::GetSurface(halfResDepth)->m_image;
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codeImages[24] = &v14->m_base;
  v15 = &R_RT_Handle::GetSurface(fullResDepth)->m_image;
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  v16 = *context;
  p_input->codeImages[25] = &v15->m_base;
  height = (float)viewport->height;
  width = (float)viewport->width;
  v19 = v16;
  RB_ViewportFilterDirectInternal(&v19, rgp.bilateralUpsampleMaterial, 0xFFFFFFFF, viewport, 0.0, 0.0, width, height, 0.0, 0.0, 1.0, 1.0, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(3009)");
}

/*
==============
R_InitDrawCallOutput
==============
*/
void R_InitDrawCallOutput(const GfxBackEndData *data, GfxDrawCallOutput *drawOutput)
{
  drawOutput->empty = 0;
  R_InitContext(data, &drawOutput->cmdBuf);
}

/*
==============
R_PostLitResolve0_Active
==============
*/
bool R_PostLitResolve0_Active(const GfxViewInfo *viewInfo)
{
  return viewInfo->matRenderFeatures & 1;
}

/*
==============
R_PostLitResolve1_Active
==============
*/
bool R_PostLitResolve1_Active(const GfxViewInfo *viewInfo)
{
  return (viewInfo->matRenderFeatures & 2) != 0;
}

/*
==============
R_ProfBeginDrawListImmediate
==============
*/
void R_ProfBeginDrawListImmediate(const GfxDrawListType drawListType)
{
  const char *DrawListTypeName; 

  DrawListTypeName = R_GetDrawListTypeName(drawListType);
  R_ProfBeginNamedEventImmediateContext(DrawListTypeName);
}

/*
==============
R_ProfEndDrawListImmediate
==============
*/

void R_ProfEndDrawListImmediate(void)
{
  R_ProfEndNamedEventImmediateContext();
}

/*
==============
R_RunDrawListCommandBuffer
==============
*/
bool R_RunDrawListCommandBuffer(const GfxBackEndData *data, const GfxDrawListType drawListType)
{
  __int64 v4; 
  const char *DrawListTypeName; 
  const char *v6; 
  const dvar_t *v7; 
  char *v8; 
  __int64 v9; 
  unsigned __int64 v10; 
  unsigned __int64 integer; 
  __int64 v12; 
  GfxDrawCallOutput *v14; 
  const char *v15; 
  ID3D12CommandList *cmdLists; 

  v4 = drawListType;
  if ( !data->cmdBufValid[drawListType] )
    return 1;
  DrawListTypeName = R_GetDrawListTypeName(drawListType);
  v6 = j_va("run cmdbuf: %s", DrawListTypeName);
  Sys_ProfBeginNamedEvent(0xFFDAA520, v6);
  v7 = r_cmdbuf_handoff;
  ++backEnd.cmdbufHandoffStats[backEndData->frameCount & 1][0];
  if ( !v7->current.enabled )
  {
    R_WaitDrawWorkerCmdsOfType(data, drawListType);
    goto LABEL_15;
  }
  v8 = (char *)data + 9136 * v4;
  if ( !*((_DWORD *)v8 + 10258) )
    goto LABEL_15;
  v9 = backEndData->frameCount & 1;
  ++backEnd.cmdbufHandoffStats[v9][1];
  if ( Sys_InterlockedCompareExchange((volatile int *)v8 + 10259, 0, 1) )
  {
    Sys_ProfEndNamedEvent();
    return 1;
  }
  R_SetHandoffDrawListIter(&data->drawListIter[v4]);
  Sys_ProfBeginNamedEvent(0xFFFFA500, "wait");
  v10 = Sys_Microseconds();
  if ( *((_DWORD *)v8 + 10258) )
  {
    integer = r_cmdbuf_wait_us->current.integer;
    while ( Sys_Microseconds() - v10 < integer )
    {
      if ( !*((_DWORD *)v8 + 10258) )
        goto LABEL_11;
    }
    v12 = backEndData->frameCount & 1;
    ++backEnd.cmdbufHandoffStats[v12][2];
    Sys_ProfBeginNamedEvent(0xFFFF0000, "slow wait");
    R_WaitDrawWorkerCmdsOfType(data, drawListType);
    Sys_ProfEndNamedEvent();
  }
LABEL_11:
  Sys_ProfEndNamedEvent();
  R_SetHandoffDrawListIter(NULL);
LABEL_15:
  v14 = &data->drawOutput[v4];
  if ( data->drawOutput[v4].empty )
  {
    v14->cmdBuf.device = NULL;
  }
  else if ( v14->cmdBuf.device )
  {
    R_LockGfxImmediateContext();
    cmdLists = v14->cmdBuf.device;
    R_ProfBeginNamedEventImmediateContext(DrawListTypeName);
    R_GPU_BeginRunDrawListTimer(drawListType);
    R_FlushImmediateContext();
    v15 = j_va("ExecuteCommandList %s", "(partial)");
    Sys_ProfBeginNamedEvent(0xFFFFD700, v15);
    R_ExecuteCommandListsOnQueue(&g_dx.immediateCommandQueue, 1u, &cmdLists);
    Sys_ProfEndNamedEvent();
    if ( r_deviceDebug->current.enabled )
      g_dx.immediateCommandQueue.commandQueue->m_pFunction[8].AddRef(g_dx.immediateCommandQueue.commandQueue);
    R_GPU_EndTimer();
    R_ProfEndNamedEventImmediateContext();
    v14->cmdBuf.device = NULL;
    R_UnlockGfxImmediateContext();
  }
  Sys_ProfEndNamedEvent();
  return data->drawListIter[v4].iteratorCount != 0;
}

/*
==============
R_SetAndClearSceneTarget
==============
*/
void R_SetAndClearSceneTarget(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo)
{
  const GfxViewInfo *v3; 
  GfxCmdBufState *state; 
  __int64 v6; 
  __m256i m_msaaSceneAlphaRt; 
  __int64 v8; 
  __int64 v9; 
  unsigned int v11; 
  R_RT_Handle m_depthRt; 
  GfxCmdBufState *v13; 
  GfxCmdBufSourceState *source; 
  unsigned int height; 
  const R_RT_Surface *Surface; 
  unsigned int i; 
  __m256i m_halfSceneAlphaRt; 
  __int64 v21; 
  __int64 v22; 
  unsigned int v24; 
  R_RT_Handle v25; 
  GfxCmdBufState *v26; 
  GfxCmdBufSourceState *v28; 
  unsigned int v30; 
  const R_RT_Surface *v31; 
  unsigned int j; 
  GfxCmdBufSourceState *v34; 
  unsigned int v36; 
  const R_RT_Surface *v37; 
  __m256i m_mainSceneAlphaRt; 
  R_RT_Handle m_mainSceneDepthRt; 
  __m256i m_mainSceneTangentFrameRt; 
  __int64 v41; 
  GfxCmdBufSourceState *v46; 
  unsigned int v48; 
  const R_RT_Surface *v49; 
  R_RT_Handle result; 
  R_RT_Handle m_halfSceneDepthRt; 
  const GfxViewInfo *v53; 
  R_RT_Group v54; 
  __m256i m_msaaSceneColorRt; 
  __m256i v56; 
  __m256i m_mainSceneEntityIDVelocityRt; 
  __m256i v58; 
  vec4_t unpackedRgba; 
  __m256i v60; 
  vec4_t v61; 

  v53 = viewInfo;
  v3 = viewInfo;
  if ( !viewInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 1423, ASSERT_TYPE_ASSERT, "(viewInfo)", (const char *)&queryFormat, "viewInfo") )
    __debugbreak();
  R_LockGfxImmediateContext();
  state = gfxContext->state;
  R_ProfBeginNamedEvent(state, "R_SetAndClearSceneTarget");
  R_ResetRenderTargets(state);
  v6 = 0i64;
  if ( rg.vrsEmissiveOnly )
  {
    m_msaaSceneAlphaRt = (__m256i)v3->sceneRtInput.m_msaaSceneAlphaRt;
    m_msaaSceneColorRt = (__m256i)v3->sceneRtInput.m_msaaSceneColorRt;
    result = (R_RT_Handle)v3->sceneRtInput.m_msaaSceneDepthRt;
    v56 = m_msaaSceneAlphaRt;
    v54.m_colorRtCount = 2;
    v8 = 2i64;
    v9 = 0i64;
    do
    {
      m_halfSceneDepthRt = *(R_RT_Handle *)((char *)&m_msaaSceneColorRt + v9 * 32);
      if ( LOWORD(_XMM0.source) )
      {
        R_RT_Handle::GetSurface(&m_halfSceneDepthRt);
      }
      else
      {
        __asm { vpextrd rax, xmm0, 2 }
        if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
          __debugbreak();
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 442, ASSERT_TYPE_ASSERT, "(colorRt)", (const char *)&queryFormat, "colorRt") )
          __debugbreak();
      }
      v54.m_colorRts[v9] = *(R_RT_ColorHandle *)((char *)&m_msaaSceneColorRt + v9 * 32);
      ++v9;
      --v8;
    }
    while ( v8 );
    v11 = 0;
    m_depthRt = result;
    v54.m_depthRt = (R_RT_DepthHandle)result;
    if ( v54.m_colorRtCount )
    {
      v13 = gfxContext->state;
      do
      {
        result = (R_RT_Handle)v54.m_colorRts[v11];
        R_AddRenderTargetTransition(v13, (R_RT_ColorHandle *)&result, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
        ++v11;
      }
      while ( v11 < v54.m_colorRtCount );
      m_depthRt = (R_RT_Handle)v54.m_depthRt;
    }
    state = gfxContext->state;
    result = m_depthRt;
    R_AddDepthStencilTransition(state, (R_RT_DepthHandle *)&result, DEPTHSTENCIL_TRANSITION_MODE_WRITE_PRESERVE_COMPRESSION, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    R_FlushResourceTransitions(state);
    _XMM0 = *gfxContext;
    source = gfxContext->source;
    __asm { vpextrq rsi, xmm0, 1 }
    R_InitLocalCmdBufState(_RSI, &gfxContext->source->input);
    R_ProfBeginNamedEvent(_RSI, "R_ClearRenderTarget");
    m_halfSceneDepthRt = *R_RT_Group::GetValidRt(&v54, &result);
    height = R_RT_Handle::GetSurface(&m_halfSceneDepthRt)->m_image.m_base.height;
    Surface = R_RT_Handle::GetSurface(&m_halfSceneDepthRt);
    R_SetRenderTargetSize(source, Surface->m_image.m_base.width, height, GFX_USE_VIEWPORT_FOR_VIEW);
    _XMM0 = *gfxContext;
    *(GfxCmdBufContext *)&m_halfSceneDepthRt.m_surfaceID = *gfxContext;
    R_SetRenderTargetsInternal((GfxCmdBufContext *)&m_halfSceneDepthRt, &v54, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1368)");
    R_GPU_BeginTimer(GPU_TIMER_CLEAR_SCREEN);
    R_ClearScreen(_RSI, 0x3Fu, 0);
    R_GPU_EndTimer();
    R_ProfEndNamedEvent(_RSI);
    R_ShutdownLocalCmdBufState(_RSI, &source->input);
    for ( i = 0; i < v54.m_colorRtCount; ++i )
    {
      result = (R_RT_Handle)v54.m_colorRts[i];
      R_AddRenderTargetTransition(state, (R_RT_ColorHandle *)&result, RENDERTARGET_TRANSITION_MODE_READ, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    }
    result = (R_RT_Handle)v54.m_depthRt;
    R_AddDepthStencilTransition(state, (R_RT_DepthHandle *)&result, DEPTHSTENCIL_TRANSITION_MODE_READ_PRESERVE_COMPRESSION, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    R_FlushResourceTransitions(state);
  }
  if ( rg.halfResEmissive )
  {
    m_halfSceneAlphaRt = (__m256i)v3->sceneRtInput.m_halfSceneAlphaRt;
    m_msaaSceneColorRt = (__m256i)v3->sceneRtInput.m_halfSceneColorRt;
    m_halfSceneDepthRt = (R_RT_Handle)v3->sceneRtInput.m_halfSceneDepthRt;
    v56 = m_halfSceneAlphaRt;
    v54.m_colorRtCount = 2;
    v21 = 0i64;
    v22 = 2i64;
    do
    {
      result = *(R_RT_Handle *)((char *)&m_msaaSceneColorRt + v21 * 32);
      if ( LOWORD(_XMM0.source) )
      {
        R_RT_Handle::GetSurface(&result);
      }
      else
      {
        __asm { vpextrd rax, xmm0, 2 }
        if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
          __debugbreak();
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 442, ASSERT_TYPE_ASSERT, "(colorRt)", (const char *)&queryFormat, "colorRt") )
          __debugbreak();
      }
      v54.m_colorRts[v21] = *(R_RT_ColorHandle *)((char *)&m_msaaSceneColorRt + v21 * 32);
      ++v21;
      --v22;
    }
    while ( v22 );
    v24 = 0;
    v3 = v53;
    v25 = m_halfSceneDepthRt;
    v54.m_depthRt = (R_RT_DepthHandle)m_halfSceneDepthRt;
    if ( v54.m_colorRtCount )
    {
      v26 = gfxContext->state;
      do
      {
        result = (R_RT_Handle)v54.m_colorRts[v24];
        R_AddRenderTargetTransition(v26, (R_RT_ColorHandle *)&result, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
        ++v24;
      }
      while ( v24 < v54.m_colorRtCount );
      v25 = (R_RT_Handle)v54.m_depthRt;
    }
    state = gfxContext->state;
    result = v25;
    R_AddDepthStencilTransition(state, (R_RT_DepthHandle *)&result, DEPTHSTENCIL_TRANSITION_MODE_WRITE_PRESERVE_COMPRESSION, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    R_FlushResourceTransitions(state);
    _XMM0 = *gfxContext;
    v28 = gfxContext->source;
    __asm { vpextrq rsi, xmm0, 1 }
    R_InitLocalCmdBufState(_RSI, &gfxContext->source->input);
    R_ProfBeginNamedEvent(_RSI, "R_ClearRenderTarget");
    m_halfSceneDepthRt = *R_RT_Group::GetValidRt(&v54, &result);
    v30 = R_RT_Handle::GetSurface(&m_halfSceneDepthRt)->m_image.m_base.height;
    v31 = R_RT_Handle::GetSurface(&m_halfSceneDepthRt);
    R_SetRenderTargetSize(v28, v31->m_image.m_base.width, v30, GFX_USE_VIEWPORT_FOR_VIEW);
    _XMM0 = *gfxContext;
    *(GfxCmdBufContext *)&m_halfSceneDepthRt.m_surfaceID = *gfxContext;
    R_SetRenderTargetsInternal((GfxCmdBufContext *)&m_halfSceneDepthRt, &v54, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1368)");
    R_GPU_BeginTimer(GPU_TIMER_CLEAR_SCREEN);
    R_ClearScreen(_RSI, 0x3Fu, 0);
    R_GPU_EndTimer();
    R_ProfEndNamedEvent(_RSI);
    R_ShutdownLocalCmdBufState(_RSI, &v28->input);
    for ( j = 0; j < v54.m_colorRtCount; ++j )
    {
      result = (R_RT_Handle)v54.m_colorRts[j];
      R_AddRenderTargetTransition(state, (R_RT_ColorHandle *)&result, RENDERTARGET_TRANSITION_MODE_READ, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    }
    result = (R_RT_Handle)v54.m_depthRt;
    R_AddDepthStencilTransition(state, (R_RT_DepthHandle *)&result, DEPTHSTENCIL_TRANSITION_MODE_READ_PRESERVE_COMPRESSION, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    R_FlushResourceTransitions(state);
  }
  if ( rg.debugOverdrawOverlay )
  {
    result = (R_RT_Handle)v3->sceneRtInput.m_mainSceneOverdrawRt;
    R_AddRenderTargetTransition(state, (R_RT_ColorHandle *)&result, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    R_FlushResourceTransitions(state);
    result = (R_RT_Handle)v3->sceneRtInput.m_mainSceneOverdrawRt;
    R_RT_Group::AssignColor(&v54, (R_RT_ColorHandle *)&result);
    _XMM0 = *gfxContext;
    v34 = gfxContext->source;
    __asm { vpextrq rsi, xmm0, 1 }
    R_InitLocalCmdBufState(_RSI, &gfxContext->source->input);
    R_ProfBeginNamedEvent(_RSI, "R_ClearRenderTarget");
    m_halfSceneDepthRt = *R_RT_Group::GetValidRt(&v54, &result);
    v36 = R_RT_Handle::GetSurface(&m_halfSceneDepthRt)->m_image.m_base.height;
    v37 = R_RT_Handle::GetSurface(&m_halfSceneDepthRt);
    R_SetRenderTargetSize(v34, v37->m_image.m_base.width, v36, GFX_USE_VIEWPORT_FOR_VIEW);
    _XMM0 = *gfxContext;
    *(GfxCmdBufContext *)&m_halfSceneDepthRt.m_surfaceID = *gfxContext;
    R_SetRenderTargetsInternal((GfxCmdBufContext *)&m_halfSceneDepthRt, &v54, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1368)");
    R_GPU_BeginTimer(GPU_TIMER_CLEAR_SCREEN);
    R_ClearScreen(_RSI, 0xFu, 0);
    R_GPU_EndTimer();
    R_ProfEndNamedEvent(_RSI);
    R_ShutdownLocalCmdBufState(_RSI, &v34->input);
  }
  m_mainSceneAlphaRt = (__m256i)v3->sceneRtInput.m_mainSceneAlphaRt;
  m_msaaSceneColorRt = (__m256i)v3->sceneRtInput.m_mainSceneColorRt;
  m_mainSceneEntityIDVelocityRt = (__m256i)v3->sceneRtInput.m_mainSceneEntityIDVelocityRt;
  m_mainSceneDepthRt = (R_RT_Handle)v3->sceneRtInput.m_mainSceneDepthRt;
  v56 = m_mainSceneAlphaRt;
  m_mainSceneTangentFrameRt = (__m256i)v3->sceneRtInput.m_mainSceneTangentFrameRt;
  m_halfSceneDepthRt = m_mainSceneDepthRt;
  v58 = m_mainSceneTangentFrameRt;
  v54.m_colorRtCount = 4;
  v41 = 4i64;
  do
  {
    result = *(R_RT_Handle *)((char *)&m_msaaSceneColorRt + v6 * 32);
    if ( LOWORD(_XMM0.source) )
    {
      R_RT_Handle::GetSurface(&result);
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 442, ASSERT_TYPE_ASSERT, "(colorRt)", (const char *)&queryFormat, "colorRt") )
        __debugbreak();
    }
    v54.m_colorRts[v6] = *(R_RT_ColorHandle *)((char *)&m_msaaSceneColorRt + v6 * 32);
    ++v6;
    --v41;
  }
  while ( v41 );
  v54.m_depthRt = (R_RT_DepthHandle)m_halfSceneDepthRt;
  R_GetClearColor(v3, &unpackedRgba);
  _YMM0 = (__m256i)(unsigned __int128)colorZero;
  __asm { vinsertf128 ymm0, ymm0, xmm0, 1 }
  v60 = _YMM0;
  v61 = colorZero;
  _XMM1 = *gfxContext;
  v46 = gfxContext->source;
  __asm { vpextrq rsi, xmm1, 1 }
  R_InitLocalCmdBufState(_RSI, &gfxContext->source->input);
  R_ProfBeginNamedEvent(_RSI, "R_ClearRenderTargetLegacySlow");
  m_halfSceneDepthRt = *R_RT_Group::GetValidRt(&v54, &result);
  v48 = R_RT_Handle::GetSurface(&m_halfSceneDepthRt)->m_image.m_base.height;
  v49 = R_RT_Handle::GetSurface(&m_halfSceneDepthRt);
  R_SetRenderTargetSize(v46, v49->m_image.m_base.width, v48, GFX_USE_VIEWPORT_FOR_VIEW);
  *(GfxCmdBufContext *)&m_halfSceneDepthRt.m_surfaceID = *gfxContext;
  R_SetRenderTargetsInternal((GfxCmdBufContext *)&m_halfSceneDepthRt, &v54, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1410)");
  R_GPU_BeginTimer(GPU_TIMER_CLEAR_SCREEN);
  R_ClearScreenLegacySlow(_RSI, 0x3Fu, &unpackedRgba, 4u, 0.0, 0);
  R_GPU_EndTimer();
  R_ProfEndNamedEvent(_RSI);
  R_ShutdownLocalCmdBufState(_RSI, &v46->input);
  R_ProfEndNamedEvent(gfxContext->state);
  R_UnlockGfxImmediateContext();
}

/*
==============
R_SetPersistentTables
==============
*/
void R_SetPersistentTables(GfxCmdBufContext *ctx, const GfxBackEndData *data, GfxPersistentDescriptorTables table)
{
  __int64 v5; 

  v5 = table;
  R_SetGfxDescriptorTable(ctx->state, &data->globalPersistentBufferTable[v5], 0xBu);
  R_SetGfxDescriptorTable(ctx->state, &data->globalPersistentTextureTable[v5], 0xCu);
}

/*
==============
R_Shadow_DrawOverlay
==============
*/
void R_Shadow_DrawOverlay(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, int overlayStyle, const R_RT_Handle *shadowCascades, unsigned int cascadeCount, const R_RT_Handle *viewmodelShadowCascade, const R_RT_ColorHandle *spotshadowsStaleCacheRt, const R_RT_DepthHandle *sunshadowCacheRt, R_RT_BufferHandle *compressedSunCascades, R_RT_BufferHandle *csmPrepass, const R_RT_ColorHandle *sunshadowTranslucentMask)
{
  GfxCmdBufContext v15; 
  GfxCmdBufContext v17; 
  R_RT_ColorHandle v18; 
  R_RT_Handle spotshadowActiveCache; 
  R_RT_Handle v20; 
  R_RT_BufferHandle v21; 

  if ( (unsigned int)(overlayStyle - 1) > 6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 4818, ASSERT_TYPE_ASSERT, "( ( overlayStyle >= GFX_SM_OVERLAY_SUN && overlayStyle < GFX_SM_OVERLAY_COUNT ) )", "( overlayStyle ) = %i", overlayStyle) )
    __debugbreak();
  if ( overlayStyle > 4 )
  {
    spotshadowActiveCache = (R_RT_Handle)viewInfo->spotshadowActiveCache;
    v15 = *gfxContext;
    v18 = *spotshadowsStaleCacheRt;
    v17 = v15;
    R_SpotShadow_DrawOverlay(&v17, overlayStyle, &v18, (const R_RT_DepthHandle *)&spotshadowActiveCache);
  }
  else
  {
    v20 = sunshadowTranslucentMask->R_RT_Handle;
    v21 = *csmPrepass;
    v18 = *(R_RT_ColorHandle *)sunshadowCacheRt;
    v17 = *gfxContext;
    spotshadowActiveCache = *viewmodelShadowCascade;
    R_Sunshadow_DrawOverlay(&v17, viewInfo, overlayStyle, shadowCascades, cascadeCount, &spotshadowActiveCache, (const R_RT_DepthHandle *)&v18, compressedSunCascades, &v21, &v20);
  }
}

/*
==============
R_ShouldDrawWireframe
==============
*/
bool R_ShouldDrawWireframe(GfxDrawListType drawlistIndex, R_SHOW_TRIS showTris)
{
  int v2; 
  bool result; 
  bool v4; 
  __int32 v5; 
  __int32 v6; 
  bool v7; 

  switch ( 0x40000000u )
  {
    case 1u:
    case 2u:
    case 7u:
    case 8u:
      if ( (unsigned int)drawlistIndex > DRAWLIST_DISTORT_EMISSIVE )
        goto $LN25_104;
      v2 = 8927236;
      if ( !_bittest(&v2, drawlistIndex) )
        goto $LN25_104;
      goto $LN81_13;
    case 3u:
$LN25_104:
      switch ( drawlistIndex )
      {
        case DRAWLIST_FIRST:
        case DRAWLIST_DEPTH_HACK_SSS:
        case DRAWLIST_LIT_OPAQUE:
        case DRAWLIST_LIT_OPAQUE_END:
        case DRAWLIST_LIT_OPAQUE_GLASS:
        case DRAWLIST_PRE_OPAQUE:
        case DRAWLIST_PRE_SSS:
        case DRAWLIST_EID_ONLY:
          goto $LN81_13;
        default:
          goto $LN2_10;
      }
    case 4u:
      if ( drawlistIndex == DRAWLIST_DEPTH_HACK_TRANS || (unsigned int)(drawlistIndex - 11) <= 2 )
        goto $LN81_13;
      return 0;
    case 5u:
      v4 = ((drawlistIndex - 19) & 0xFFFFFFFB) == 0;
      goto LABEL_9;
    case 6u:
      v5 = drawlistIndex - 1;
      if ( !v5 )
        goto $LN81_13;
      v6 = v5 - 8;
      if ( !v6 )
        goto $LN81_13;
      v4 = v6 == 8;
LABEL_9:
      if ( !v4 )
        goto $LN2_10;
      goto $LN81_13;
    case 9u:
      v7 = (unsigned int)(drawlistIndex - 24) <= 0x14;
      goto LABEL_22;
    case 0xAu:
      v7 = (unsigned int)(drawlistIndex - 24) <= 4;
      goto LABEL_22;
    case 0xBu:
      return ((drawlistIndex - 24) & 0xFFFFFFFB) == 0;
    case 0xCu:
      return drawlistIndex == DRAWLIST_SUNSHADOW_1;
    case 0xDu:
      return drawlistIndex == DRAWLIST_SUNSHADOW_2;
    case 0xEu:
      return drawlistIndex == DRAWLIST_SUNSHADOW_END;
    case 0xFu:
      v7 = (unsigned int)(drawlistIndex - 29) <= 0xF;
      goto LABEL_22;
    case 0x10u:
      v7 = (unsigned int)(drawlistIndex - 37) <= 3;
LABEL_22:
      if ( !v7 )
        goto $LN2_10;
$LN81_13:
      result = 1;
      break;
    case 0x11u:
      return ((drawlistIndex - 29) & 0xFFFFFFF7) == 0;
    case 0x12u:
      return ((drawlistIndex - 30) & 0xFFFFFFF7) == 0;
    case 0x13u:
      return ((drawlistIndex - 31) & 0xFFFFFFF7) == 0;
    case 0x14u:
      return ((drawlistIndex - 32) & 0xFFFFFFF7) == 0;
    case 0x15u:
      return ((drawlistIndex - 33) & 0xFFFFFFF7) == 0;
    case 0x16u:
      return ((drawlistIndex - 34) & 0xFFFFFFF7) == 0;
    case 0x17u:
      return ((drawlistIndex - 35) & 0xFFFFFFF7) == 0;
    case 0x18u:
      return ((drawlistIndex - 36) & 0xFFFFFFF7) == 0;
    default:
$LN2_10:
      result = 0;
      break;
  }
  return result;
}

/*
==============
R_ShowTris_Draw
==============
*/
void R_ShowTris_Draw(const GfxViewInfo *viewInfo, const GfxBackEndData *data, const R_RT_Group *rtGroup, R_SHOW_TRIS showTris)
{
  signed __int64 v4; 
  void *v5; 
  __int128 v10; 
  unsigned int height; 
  const R_RT_Surface *Surface; 
  unsigned int mtlFlagsFilter; 
  GfxDrawListType i; 
  unsigned int v15; 
  R_RT_Handle v16; 
  __int64 v17; 
  R_RT_Handle result; 
  GfxDrawListIter drawListIter; 
  GfxCmdBufStateLocal state; 
  GfxCmdBufSourceStateLocal v21; 
  GfxDrawCallOutput cmdBuf; 

  v5 = alloca(v4);
  v17 = -2i64;
  if ( showTris == R_SHOW_TRIS_NONE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 777, ASSERT_TYPE_ASSERT, "(showTris != R_SHOW_TRIS_NONE)", (const char *)&queryFormat, "showTris != R_SHOW_TRIS_NONE") )
    __debugbreak();
  Sys_ProfBeginNamedEvent(0xFFC0C0C0, "ShowTris");
  cmdBuf.empty = 0;
  R_InitContext(data, &cmdBuf.cmdBuf);
  GfxCmdBufSourceStateLocal::GfxCmdBufSourceStateLocal(&v21);
  GfxCmdBufStateLocal::GfxCmdBufStateLocal(&state);
  if ( R_DrawListStart(&state, &v21, viewInfo, (const GfxViewParms *)viewInfo, &viewInfo->viewParmsSet.frames[1].viewParms, &cmdBuf) )
  {
    *(_QWORD *)&v16.m_surfaceID = &v21;
    *(_QWORD *)&v16.m_tracking.m_allocCounter = &state;
    R_ProfBeginNamedEvent(&state, "ShowTris");
    R_GP_SetScenePassIndex(&v21, viewInfo->input.data, 0);
    v21.viewStatsTarget = GFX_VIEW_STATS_EMISSIVE;
    v21.input.consts[14] = (vec4_t)_xmm;
    ++v21.constVersions[14];
    v10 = *(_OWORD *)&v16.m_surfaceID;
    R_SetRenderTargetsInternal((GfxCmdBufContext *)&v16, rtGroup, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(803)");
    v16 = *R_RT_Group::GetValidRt((R_RT_Group *)rtGroup, &result);
    height = R_RT_Handle::GetSurface(&v16)->m_image.m_base.height;
    Surface = R_RT_Handle::GetSurface(&v16);
    R_SetRenderTargetSize(&v21, Surface->m_image.m_base.width, height, GFX_USE_VIEWPORT_FOR_VIEW);
    R_SetViewportStruct(&v21, &viewInfo->sceneGeoViewport);
    R_Set3D(&v21);
    *(_OWORD *)&v16.m_surfaceID = v10;
    R_HW_EnableScissor((GfxCmdBufContext *)&v16, &viewInfo->scissorGeoViewport);
    if ( showTris == R_SHOW_TRIS_CAMERA_NEEDS_REFRACTION )
    {
      v21.mtlFlagsFilter = 1;
    }
    else
    {
      mtlFlagsFilter = v21.mtlFlagsFilter;
      if ( showTris == R_SHOW_TRIS_CAMERA_NEEDS_SSR_FX_DISTORT )
        mtlFlagsFilter = 2;
      v21.mtlFlagsFilter = mtlFlagsFilter;
    }
    R_SetInputWorldDefaults(&v21.input);
    RB_UpdatePersistentTables(viewInfo, data, PERSISTENT_TABLE_SHOWTRIS);
    R_SetGfxDescriptorTable(&state, (const GfxDescriptorTable *)data->globalPersistentBufferTable + 1, 0xBu);
    R_SetGfxDescriptorTable(&state, (const GfxDescriptorTable *)data->globalPersistentTextureTable + 1, 0xCu);
    if ( showTris != R_SHOW_TRIS_CAMERA_DEPTHTEST && (showTris == R_SHOW_TRIS_CAMERA_ALL || (unsigned int)(showTris - 7) <= 1 || !r_showTrisDepthTest->current.enabled) )
      R_ClearScreen(&state, 0x30u, 0);
    for ( i = DRAWLIST_FIRST; (unsigned int)i < DRAWLIST_FRONTEND_COUNT; ++i )
    {
      if ( R_ShouldDrawWireframe(i, showTris) )
      {
        R_DrawListIter_Init(&viewInfo->drawList[i], &drawListIter);
        switch ( i )
        {
          case DRAWLIST_FIRST:
          case DRAWLIST_DEPTH_HACK_SSS:
          case DRAWLIST_DEPTH_HACK_TRANS:
          case DRAWLIST_HUD_OUTLINE_FIRST:
          case DRAWLIST_PRE_DEPTH_HACK_SSS:
          case DRAWLIST_DEPTH_HACK_EMISSIVE:
          case DRAWLIST_POST_BLUR_DEPTH_HACK_EMISSIVE:
          case DRAWLIST_FRONTEND_COUNT:
          case DRAWLIST_PREPASS_DEPTH_HACK_SSS:
          case DRAWLIST_PREPASS_DEPTH_HACK_TRANS:
          case DRAWLIST_PREPASS_HUD_OUTLINE_FIRST:
          case DRAWLIST_PREPASS_PRE_DEPTH_HACK_SSS:
          case DRAWLIST_PREPASS_HUD_OUTLINE_STENCIL_FIRST:
          case DRAWLIST_PREPASS_PRE_DEPTH_HACK_SSS_STENCIL:
            if ( state.depthRangeType != GFX_DEPTH_RANGE_VIEWMODEL )
              R_ChangeDepthRange(&state, GFX_DEPTH_RANGE_VIEWMODEL);
            v15 = 1;
            break;
          default:
            if ( state.depthRangeType )
              R_ChangeDepthRange(&state, GFX_DEPTH_RANGE_SCENE);
            v15 = 0;
            break;
        }
        R_ChangeDepthHackNearClip(&v21, v15);
        *(_OWORD *)&v16.m_surfaceID = v10;
        R_DrawSurfs_Unsorted((GfxCmdBufContext *)&v16, &drawListIter, TECHNIQUE_WIREFRAME_SOLID, i);
      }
    }
    R_HW_DisableScissor(&state);
    R_ProfEndNamedEvent(&state);
    *(_OWORD *)&v16.m_surfaceID = v10;
    R_DrawListEnd((GfxCmdBufContext *)&v16, &cmdBuf);
  }
  Sys_ProfEndNamedEvent();
  GfxCmdBufStateLocal::~GfxCmdBufStateLocal(&state);
  GfxCmdBufSourceStateLocal::~GfxCmdBufSourceStateLocal(&v21);
}

/*
==============
R_ShowTris_GetShowTris
==============
*/
__int64 R_ShowTris_GetShowTris()
{
  if ( particle_show_tris->current.enabled )
    return 5i64;
  else
    return r_showTris->current.unsignedInt;
}

/*
==============
R_Umbra_ShowOcclusion
==============
*/
void R_Umbra_ShowOcclusion(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, const GfxImage *umbraFloatZ)
{
  GfxCmdBufState *state; 
  float v8; 
  float v9; 
  GfxCmdBufContext v10; 
  GfxCmdBufSourceState *source; 
  float renderTargetWidth; 
  float renderTargetHeight; 
  bool v14; 
  float tanHalfFovY; 
  GfxCmdBufInput *p_input; 
  GfxCmdBufContext v17; 

  if ( r_umbraShowOverlayNDC->current.integer >= 1 && R_Umbra_GetOcclusionImageCameraView(data) )
  {
    state = gfxContext->state;
    R_ProfBeginNamedEvent(state, "Umbra Occlusion");
    v8 = viewInfo->viewParmsSet.frames[0].viewParms.camera.zPlanes[2];
    v9 = viewInfo->viewParmsSet.frames[0].viewParms.camera.zPlanes[3];
    v10 = *gfxContext;
    source = gfxContext->source;
    renderTargetWidth = (float)gfxContext->source->renderTargetWidth;
    renderTargetHeight = (float)gfxContext->source->renderTargetHeight;
    v14 = r_umbraShowOverlayNDC->current.integer == 1;
    *(_QWORD *)&source->input.consts[149].xyz.y = 0i64;
    source->input.consts[149].v[3] = 0.75;
    source->input.consts[149].v[0] = (float)!v14;
    ++source->constVersions[149];
    tanHalfFovY = viewInfo->viewParmsSet.frames[0].viewParms.camera.tanHalfFovY;
    source->input.consts[150].v[2] = viewInfo->viewParmsSet.frames[0].viewParms.camera.tanHalfFovX;
    source->input.consts[150].v[3] = tanHalfFovY;
    source->input.consts[150].v[0] = v8;
    source->input.consts[150].v[1] = v9;
    ++source->constVersions[150];
    p_input = &source->input;
    if ( source == (GfxCmdBufSourceState *)-1792i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
      __debugbreak();
    p_input->codeImages[4] = umbraFloatZ;
    v17 = v10;
    RB_DrawStretchPic(&v17, rgp.umbraOverlay3d, 0.0, 0.0, renderTargetWidth, renderTargetHeight, 0.0, 0.0, 1.0, 1.0, 0xFFFFFFFF, GFX_PRIM_STATS_CODE);
    v17 = v10;
    RB_EndTessSurfaceInternal(&v17, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(4718)");
    R_ProfEndNamedEvent(state);
  }
}

/*
==============
R_UpdatePackedLightData
==============
*/
void R_UpdatePackedLightData(GfxBackEndData *data, const GfxViewInfo *viewInfo)
{
  if ( Sys_ExistsWorkerCmdsOfType(WRKCMD_UMBRA_QUERY_STATIC_CAMERA) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 2774, ASSERT_TYPE_ASSERT, "(!Sys_ExistsWorkerCmdsOfType( WRKCMD_UMBRA_QUERY_STATIC_CAMERA ))", (const char *)&queryFormat, "!Sys_ExistsWorkerCmdsOfType( WRKCMD_UMBRA_QUERY_STATIC_CAMERA )") )
    __debugbreak();
  Profile_Begin(109);
  R_UpdatePackedSceneLightConstants(data, viewInfo);
  R_UpdatePackedSpotShadowConstants(data, viewInfo);
  Profile_EndInternal(NULL);
}

/*
==============
R_UpdatePackedSceneLightConstants
==============
*/
void R_UpdatePackedSceneLightConstants(GfxBackEndData *data, const GfxViewInfo *viewInfo)
{
  double v4; 
  float v5; 
  float v6; 
  float v7; 
  float v8; 
  unsigned int v9; 
  GfxWorld *world; 
  __int64 v11; 
  GfxPackedLightConstants *v12; 
  float v13; 
  float v14; 
  bool v15; 
  int v16; 
  bool IsModifiedLight; 
  float v22; 
  float v23; 
  float v24; 
  float v25; 
  float tonemappingScaleFactor; 
  float v27; 
  float v28; 
  unsigned int flags; 
  float v30; 
  float v31; 
  float heatIntensity; 
  unsigned int type; 
  int v34; 
  unsigned int v35; 
  unsigned int v36; 
  float radius; 
  float v38; 
  GfxLightDef *def; 
  float coordOffset; 
  float coordScale; 
  double v42; 
  int v43; 
  double v44; 
  unsigned __int8 v45; 
  float v46; 
  float v47; 
  float v48; 
  float v49; 
  float cosHalfFovInner; 
  float cosHalfFovOuter; 
  float v52; 

  v4 = I_fclamp(1.0 / viewInfo->tonemap.staticExposureLinear, r_lightIntensityAutoScaleMin->current.value, r_lightIntensityAutoScaleMax->current.value);
  v5 = *(float *)&v4 * r_lightIntensityAutoScale->current.value;
  if ( !data->packedSceneLightsUpdateCount )
    memset_0(data->packedSceneLights, 0, 96i64 * rgp.world->primaryLightCount);
  v6 = viewInfo->viewParmsSet.frames[0].viewParms.camera.origin.v[0];
  v7 = viewInfo->viewParmsSet.frames[0].viewParms.camera.origin.v[1];
  v8 = viewInfo->viewParmsSet.frames[0].viewParms.camera.origin.v[2];
  v9 = 1;
  if ( data->sceneLightCount > 1 )
  {
    world = rgp.world;
    while ( 1 )
    {
      if ( v9 >= world->firstMovingScriptablePrimaryLight && v9 < world->primaryLightCount )
        goto LABEL_47;
      v11 = v9;
      v12 = &data->packedSceneLights[v9];
      if ( v9 >= world->primaryLightCount || R_IsPrimaryLightLoaded(data, v9) )
      {
        v13 = data->sceneLights[v11].origin.v[1];
        v14 = data->sceneLights[v11].origin.v[2];
        v12->pos.v[0] = data->sceneLights[v11].origin.v[0] - v6;
        v12->pos.v[2] = v14 - v8;
        v12->pos.v[1] = v13 - v7;
        LOBYTE(v12->packed) = 0;
        v15 = 1;
        v16 = v12->packed | 0xFF;
        v12->packed = v16;
        if ( v9 < rgp.world->primaryLightCount )
        {
          IsModifiedLight = R_RadiantLive_IsModifiedLight(v9);
          v15 = (v16 & 0x300) == 0 || IsModifiedLight;
        }
        _XMM1 = LODWORD(data->sceneLights[v11].cosHalfFovCollimation);
        __asm { vmaxss  xmm10, xmm1, cs:__real@3ae4c389 }
        _XMM0 = LODWORD(data->sceneLights[v11].bulbRadius);
        __asm { vmaxss  xmm8, xmm0, xmm9 }
        v22 = (float)(data->sceneLights[v11].intensity / (float)((float)(1.0 - *(float *)&_XMM10) * (float)(1.0 - *(float *)&_XMM10))) * rg.diffuseColorScale;
        *(float *)&_XMM1 = v22 * data->sceneLights[v11].colorLinearSrgb.v[0];
        v23 = (float)(1.0 / *(float *)&_XMM8) * (float)(1.0 / *(float *)&_XMM8);
        v24 = (float)(v22 * data->sceneLights[v11].colorLinearSrgb.v[1]) * v23;
        v25 = (float)(v22 * data->sceneLights[v11].colorLinearSrgb.v[2]) * v23;
        tonemappingScaleFactor = data->sceneLights[v11].tonemappingScaleFactor;
        v27 = *(float *)&_XMM1 * v23;
        if ( tonemappingScaleFactor > 0.0 )
        {
          v28 = (float)(tonemappingScaleFactor * v5) + (float)(1.0 - tonemappingScaleFactor);
          v27 = v28 * v27;
          v24 = v28 * v24;
          v25 = v28 * v25;
        }
        flags = data->sceneLights[v11].flags;
        v30 = rg.diffuseColorScale * data->sceneLights[v11].uvIntensity;
        v31 = rg.diffuseColorScale * data->sceneLights[v11].irIntensity;
        heatIntensity = data->sceneLights[v11].heatIntensity;
        if ( (flags & 0x10) != 0 )
        {
          v27 = 0.0;
          v24 = 0.0;
          v25 = 0.0;
          v30 = 0.0;
          v31 = 0.0;
          heatIntensity = 0.0;
        }
        if ( (flags & 0x4000) == 0 )
          v30 = v30 * viewInfo->lightUVIntensityScale;
        v12->diffuse.v[0] = v27;
        v12->diffuse.v[1] = v24;
        v12->diffuse.v[2] = v25;
        v12->intensityUvIrHeat.v[0] = v30;
        v12->intensityUvIrHeat.v[1] = v31;
        v12->intensityUvIrHeat.v[2] = heatIntensity;
        if ( v15 )
          break;
      }
LABEL_46:
      world = rgp.world;
LABEL_47:
      if ( ++v9 >= data->sceneLightCount )
        goto LABEL_48;
    }
    type = data->sceneLights[v11].type;
    if ( type > 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_light.h", 107, ASSERT_TYPE_ASSERT, "(inType <= 3)", (const char *)&queryFormat, "inType <= 3") )
      __debugbreak();
    v34 = 0;
    v35 = (type << 8) | v12->packed & 0xFFFFFCFF;
    v12->packed = v35;
    if ( v9 >= rgp.world->primaryLightCount )
      v34 = 0x20000000;
    v36 = v35 & 0xDFFFFFFF | v34;
    v12->packed = v36;
    v12->packed = v36 & 0xBFFFFFFF | (data->sceneLights[v11].isVolumetric != 0 ? 0x40000000 : 0);
    radius = data->sceneLights[v11].radius;
    if ( radius <= 0.0 )
      v38 = 0.0;
    else
      v38 = 1.0 / radius;
    if ( *(float *)&_XMM8 == 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_light.h", 126, ASSERT_TYPE_ASSERT, "(inBulbRadius != 0.0f)", (const char *)&queryFormat, "inBulbRadius != 0.0f") )
      __debugbreak();
    v12->bulbDir.v[0] = data->sceneLights[v11].bulbLength.v[0];
    v12->bulbDir.v[1] = data->sceneLights[v11].bulbLength.v[1];
    v12->bulbDir.v[2] = data->sceneLights[v11].bulbLength.v[2];
    v12->bulbRadius = *(float *)&_XMM8;
    v12->pos.v[3] = v38;
    v12->dir.v[0] = data->sceneLights[v11].dir.v[0];
    v12->dir.v[1] = data->sceneLights[v11].dir.v[1];
    v12->dir.v[2] = data->sceneLights[v11].dir.v[2];
    v12->collimationOffset = (float)(*(float *)&_XMM10 * *(float *)&_XMM8) / fsqrt(1.0 - (float)(*(float *)&_XMM10 * *(float *)&_XMM10));
    def = data->sceneLights[v11].def;
    coordOffset = 0.0;
    coordScale = 0.0;
    if ( def && def->iesProfile )
    {
      coordOffset = def->coordOffset;
      coordScale = def->coordScale;
    }
    v42 = I_fclamp(coordOffset * 65535.0, 0.0, 65535.0);
    v43 = (int)*(float *)&v42;
    v44 = I_fclamp(coordScale * 65535.0, 0.0, 65535.0);
    v12->iesLookup = (unsigned __int16)v43 | ((unsigned __int16)(int)*(float *)&v44 << 16);
    v45 = data->sceneLights[v11].type;
    if ( v45 == 2 )
      goto LABEL_40;
    if ( v45 != 3 )
    {
      v49 = 0.0;
      v48 = 0.0;
      v47 = 0.0;
      v46 = 0.0;
LABEL_45:
      v12->spotFactors.v[0] = v46;
      v12->spotFactors.v[1] = v47;
      v12->spotFactors.v[2] = v48;
      v12->spotFactors.v[3] = v49;
      goto LABEL_46;
    }
    if ( data->sceneLights[v11].canUseShadowMap )
    {
LABEL_40:
      cosHalfFovInner = data->sceneLights[v11].cosHalfFovInner;
      cosHalfFovOuter = data->sceneLights[v11].cosHalfFovOuter;
      if ( cosHalfFovInner <= cosHalfFovOuter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 2694, ASSERT_TYPE_ASSERT, "( gfxLight->cosHalfFovInner ) > ( gfxLight->cosHalfFovOuter )", "%s > %s\n\t%g, %g", "gfxLight->cosHalfFovInner", "gfxLight->cosHalfFovOuter", cosHalfFovInner, cosHalfFovOuter) )
        __debugbreak();
      v52 = data->sceneLights[v11].cosHalfFovOuter;
      v46 = 1.0 / (float)(data->sceneLights[v11].cosHalfFovInner - v52);
      LODWORD(v47) = COERCE_UNSIGNED_INT(v46 * v52) ^ _xmm;
      v48 = (float)(v52 * data->sceneLights[v11].bulbRadius) / fsqrt(1.0 - (float)(v52 * v52));
    }
    else
    {
      v46 = 0.0;
      v47 = 0.0;
      v48 = 0.0;
    }
    v49 = 1.0 / data->sceneLights[v11].distanceFalloff;
    goto LABEL_45;
  }
LABEL_48:
  ++data->packedSceneLightsUpdateCount;
}

/*
==============
R_UpdatePackedSpotShadowConstants
==============
*/
void R_UpdatePackedSpotShadowConstants(GfxBackEndData *data, const GfxViewInfo *viewInfo)
{
  const dvar_t *v2; 
  float v5; 
  __int64 v8; 
  __m128 *v9; 
  __int64 sceneLightIndex; 
  __int64 cacheIndex; 
  __int64 v12; 
  __int64 v13; 
  unsigned int maxSpotShadowIndex; 
  __m128 v15; 
  __m256i v16; 
  __m128 v17; 
  float radius; 
  float shadowSoftness; 
  float shadowBias; 
  float v21; 
  __int64 v22; 
  float zNear; 
  float v24; 
  __m128 v; 
  int MapSize; 
  signed int arraySliceIndex; 
  __int64 v28; 
  __int64 v29; 
  float4 result; 
  tmat44_t<vec4_t> in; 
  tmat44_t<vec4_t> out; 

  v2 = r_spotLightShadowsPolygonOffset;
  if ( !r_spotLightShadowsPolygonOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 648, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar accessed after deregistration", "dvar") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  v5 = v2->current.value * 0.001;
  _XMM0 = *(_OWORD *)viewInfo->viewParms.camera.origin.v;
  __asm { vinsertps xmm14, xmm0, dword ptr cs:__xmm@3f8000003f8000003f8000003f800000+0Ch, 30h ; '0' }
  v8 = 0i64;
  for ( data->maxSpotShadowIndex = 0; (unsigned int)v8 < data->spotShadowCount; data->packedShadowLights[v22].params0.v[3] = (float)arraySliceIndex + _mm_shuffle_ps(v, v, 170).m128_f32[0] )
  {
    v9 = (__m128 *)&data->spotShadows[v8];
    sceneLightIndex = data->spotShadows[v8].sceneLightIndex;
    if ( (unsigned int)sceneLightIndex >= data->sceneLightCount )
    {
      LODWORD(v29) = data->sceneLightCount;
      LODWORD(v28) = data->spotShadows[v8].sceneLightIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 2732, ASSERT_TYPE_ASSERT, "(unsigned)( sceneLightIndex ) < (unsigned)( data->sceneLightCount )", "sceneLightIndex doesn't index data->sceneLightCount\n\t%i not in [0, %i)", v28, v29) )
        __debugbreak();
    }
    cacheIndex = data->spotShadows[v8].cacheIndex;
    v12 = sceneLightIndex;
    v13 = sceneLightIndex;
    if ( (unsigned int)cacheIndex > 0xFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_light.h", 79, ASSERT_TYPE_ASSERT, "(inIndex <= 0xff)", (const char *)&queryFormat, "inIndex <= 0xff") )
      __debugbreak();
    LOBYTE(data->packedSceneLights[v13].packed) = 0;
    data->packedSceneLights[v13].packed |= cacheIndex;
    maxSpotShadowIndex = cacheIndex;
    v15 = _mm_shuffle_ps(_XMM14, _XMM14, 0);
    if ( data->maxSpotShadowIndex > (unsigned int)cacheIndex )
      maxSpotShadowIndex = data->maxSpotShadowIndex;
    data->maxSpotShadowIndex = maxSpotShadowIndex;
    v16 = *(__m256i *)v9->m128_f32;
    *(__m256i *)in.row2.v = *(__m256i *)data->spotShadows[v8].lookupMatrix.m.row2.v;
    v17 = _mm128_mul_ps(v15, *v9);
    *(__m256i *)in.m[0].v = v16;
    in.m[3] = (vec4_t)_mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(_XMM14, _XMM14, 255), (__m128)data->spotShadows[v8].lookupMatrix.m.m[3]), _mm128_mul_ps(_mm_shuffle_ps(_XMM14, _XMM14, 85), (__m128)data->spotShadows[v8].lookupMatrix.m.m[1])), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(_XMM14, _XMM14, 170), (__m128)data->spotShadows[v8].lookupMatrix.m.m[2]), v17));
    MatrixTranspose44Aligned(&in, &out);
    radius = data->sceneLights[v12].radius;
    shadowSoftness = data->sceneLights[v12].shadowSoftness;
    shadowBias = data->sceneLights[v12].shadowBias;
    if ( radius <= 0.0 )
      v21 = 0.0;
    else
      v21 = v5 / radius;
    R_SpotShadow_GetAtlasUVOffsetAndScale(&result, &data->spotShadows[v8]);
    v22 = cacheIndex;
    data->packedShadowLights[cacheIndex].lookupMatrix = out;
    zNear = data->spotShadows[v8].zNear;
    if ( zNear < 0.00000011920929 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_light.h", 196, ASSERT_TYPE_ASSERT, "( ( zNear >= 1.192092896e-07F ) )", "( zNear ) = %g", zNear) )
      __debugbreak();
    data->packedShadowLights[v22].params1.v[3] = 1.0 / zNear;
    data->packedShadowLights[v22].params1.v[0] = (float)((float)(1.0 - shadowSoftness) * 88.0) + shadowSoftness;
    v24 = 1.0 / (float)(1.0 - shadowBias);
    data->packedShadowLights[v22].params1.v[1] = v24;
    data->packedShadowLights[v22].params1.v[2] = COERCE_FLOAT(COERCE_UNSIGNED_INT(v24 * shadowBias) ^ _xmm);
    data->packedShadowLights[v22].params0.v[0] = v21;
    v = result.v;
    MapSize = R_SpotShadow_GetMapSize();
    arraySliceIndex = data->spotShadows[v8].arraySliceIndex;
    data->packedShadowLights[v22].params0.v[1] = v.m128_f32[0];
    data->packedShadowLights[v22].params0.v[2] = (float)MapSize + _mm_shuffle_ps(v, v, 85).m128_f32[0];
    v8 = (unsigned int)(v8 + 1);
  }
}

/*
==============
R_WaitDrawWorkerCmdsOfType
==============
*/
void R_WaitDrawWorkerCmdsOfType(const GfxBackEndData *data, const GfxDrawListType drawListType)
{
  __int64 v2; 
  const char *DrawListTypeName; 
  const char *v5; 
  bool IsLockedGfxImmediateContext; 

  v2 = drawListType;
  DrawListTypeName = R_GetDrawListTypeName(drawListType);
  v5 = j_va("wait drawlist %s", DrawListTypeName);
  Sys_ProfBeginNamedEvent(0xFFFFA500, v5);
  IsLockedGfxImmediateContext = R_IsLockedGfxImmediateContext();
  if ( R_IsLockedGfxImmediateContext() )
  {
    R_UnlockGfxImmediateContext();
    if ( R_IsLockedGfxImmediateContext() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_immediate_context_lock.h", 23, ASSERT_TYPE_ASSERT, "(!R_IsLockedGfxImmediateContext())", (const char *)&queryFormat, "!R_IsLockedGfxImmediateContext()") )
      __debugbreak();
  }
  Sys_ProcessWorkerCmdsWithTimeout(R_DrawWorkerCmdsFinished, (void *)&data->drawOutput[v2].cmdCount);
  if ( IsLockedGfxImmediateContext )
  {
    if ( R_IsLockedGfxImmediateContext() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_immediate_context_lock.h", 23, ASSERT_TYPE_ASSERT, "(!R_IsLockedGfxImmediateContext())", (const char *)&queryFormat, "!R_IsLockedGfxImmediateContext()") )
      __debugbreak();
    R_LockGfxImmediateContext();
  }
  Sys_ProfEndNamedEvent();
}

/*
==============
R_WaitSkippedDrawWorkerCmds
==============
*/
void R_WaitSkippedDrawWorkerCmds(const GfxBackEndData *data)
{
  int v2; 
  volatile int *p_inCmdCount; 
  int *cmdBufValid; 
  volatile int *p_cmdCount; 
  const char *DrawListTypeName; 
  const char *v7; 
  bool IsLockedGfxImmediateContext; 
  __int64 v9; 

  Sys_ProfBeginNamedEvent(0xFFFFA500, "wait skipped draw workers");
  v2 = 0;
  p_inCmdCount = &data->drawOutput[0].inCmdCount;
  cmdBufValid = data->cmdBufValid;
  p_cmdCount = &data->drawOutput[0].cmdCount;
  do
  {
    if ( *cmdBufValid && *((_DWORD *)p_inCmdCount - 1) )
    {
      if ( *p_inCmdCount )
      {
        LODWORD(v9) = v2;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 1283, ASSERT_TYPE_ASSERT, "( ( !data->drawOutput[drawListType].inCmdCount ) )", "( drawListType ) = %i", v9) )
          __debugbreak();
      }
      DrawListTypeName = R_GetDrawListTypeName((GfxDrawListType)v2);
      v7 = j_va("wait drawlist %s", DrawListTypeName);
      Sys_ProfBeginNamedEvent(0xFFFFA500, v7);
      IsLockedGfxImmediateContext = R_IsLockedGfxImmediateContext();
      if ( R_IsLockedGfxImmediateContext() )
      {
        R_UnlockGfxImmediateContext();
        if ( R_IsLockedGfxImmediateContext() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_immediate_context_lock.h", 23, ASSERT_TYPE_ASSERT, "(!R_IsLockedGfxImmediateContext())", (const char *)&queryFormat, "!R_IsLockedGfxImmediateContext()") )
          __debugbreak();
      }
      Sys_ProcessWorkerCmdsWithTimeout(R_DrawWorkerCmdsFinished, (void *)p_cmdCount);
      if ( IsLockedGfxImmediateContext )
      {
        if ( R_IsLockedGfxImmediateContext() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_immediate_context_lock.h", 23, ASSERT_TYPE_ASSERT, "(!R_IsLockedGfxImmediateContext())", (const char *)&queryFormat, "!R_IsLockedGfxImmediateContext()") )
          __debugbreak();
        R_LockGfxImmediateContext();
      }
      Sys_ProfEndNamedEvent();
    }
    ++v2;
    p_cmdCount += 2284;
    ++cmdBufValid;
    p_inCmdCount += 2284;
  }
  while ( v2 < 89 );
  Sys_ProfEndNamedEvent();
}

/*
==============
R_WaveWaterFloatZ_Active
==============
*/
bool R_WaveWaterFloatZ_Active(const GfxViewInfo *viewInfo)
{
  return (viewInfo->matRenderFeatures & 4) != 0;
}

