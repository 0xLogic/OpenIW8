/*
==============
Scr_AgentMain
==============
*/

void Scr_AgentMain(void)
{
  ?Scr_AgentMain@@YAXXZ();
}

/*
==============
Scr_AgentKilled
==============
*/

void __fastcall Scr_AgentKilled(gentity_s *self, const gentity_s *inflictor, gentity_s *attacker, int damage, int damageFlags, int meansOfDeath, const Weapon *r_weapon, bool isAlternate, const vec3_t *vDir, const hitLocation_t hitLoc, int psTimeOffset, int deathAnimDuration)
{
  ?Scr_AgentKilled@@YAXPEAUgentity_s@@PEBU1@0HHHAEBUWeapon@@_NPEBTvec3_t@@W4hitLocation_t@@HH@Z(self, inflictor, attacker, damage, damageFlags, meansOfDeath, r_weapon, isAlternate, vDir, hitLoc, psTimeOffset, deathAnimDuration);
}

/*
==============
Scr_PlayerDisconnect
==============
*/

void __fastcall Scr_PlayerDisconnect(gentity_s *self, const char *reason)
{
  ?Scr_PlayerDisconnect@@YAXPEAUgentity_s@@PEBD@Z(self, reason);
}

/*
==============
GScr_MainMP_TriggerFX
==============
*/

void __fastcall GScr_MainMP_TriggerFX(scrContext_t *scrContext)
{
  ?GScr_MainMP_TriggerFX@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_GetNearNodeListForSpawnCheck
==============
*/

void __fastcall Scr_GetNearNodeListForSpawnCheck(scrContext_t *scrContext, scr_entref_t entref)
{
  ?Scr_GetNearNodeListForSpawnCheck@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
Scr_PlayerVote
==============
*/

void __fastcall Scr_PlayerVote(gentity_s *self, char *option)
{
  ?Scr_PlayerVote@@YAXPEAUgentity_s@@PEAD@Z(self, option);
}

/*
==============
Scr_BotMain
==============
*/

void Scr_BotMain(void)
{
  ?Scr_BotMain@@YAXXZ();
}

/*
==============
GScr_GetAltBunkerIndexForName
==============
*/

void __fastcall GScr_GetAltBunkerIndexForName(scrContext_t *scrContext)
{
  ?GScr_GetAltBunkerIndexForName@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_GetClanWarsBonusForCurrentPlaylist
==============
*/

void __fastcall GScr_GetClanWarsBonusForCurrentPlaylist(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScr_GetClanWarsBonusForCurrentPlaylist@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_MainMP_SpawnFX
==============
*/

void __fastcall GScr_MainMP_SpawnFX(scrContext_t *scrContext)
{
  ?GScr_MainMP_SpawnFX@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_AnalyticsReset
==============
*/

void __fastcall GScr_AnalyticsReset(scrContext_t *scrContext)
{
  ?GScr_AnalyticsReset@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
ScrCmd_PlayerForceDeathAnim
==============
*/

void __fastcall ScrCmd_PlayerForceDeathAnim(scrContext_t *scrContext, scr_entref_t entref)
{
  ?ScrCmd_PlayerForceDeathAnim@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
Scr_PlayerKilled
==============
*/

void __fastcall Scr_PlayerKilled(gentity_s *self, const gentity_s *inflictor, gentity_s *attacker, int damage, int damageFlags, int meansOfDeath, const Weapon *r_weapon, bool isAlternate, const vec3_t *vDir, const hitLocation_t hitLoc, int psTimeOffset, int deathAnimDuration)
{
  ?Scr_PlayerKilled@@YAXPEAUgentity_s@@PEBU1@0HHHAEBUWeapon@@_NPEBTvec3_t@@W4hitLocation_t@@HH@Z(self, inflictor, attacker, damage, damageFlags, meansOfDeath, r_weapon, isAlternate, vDir, hitLoc, psTimeOffset, deathAnimDuration);
}

/*
==============
GScr_MainMP_LoadScripts
==============
*/

void __fastcall GScr_MainMP_LoadScripts(const SvServerInitSettings *initSettings)
{
  ?GScr_MainMP_LoadScripts@@YAXPEBUSvServerInitSettings@@@Z(initSettings);
}

/*
==============
GScr_StopAC130
==============
*/

void __fastcall GScr_StopAC130(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScr_StopAC130@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
ScrCmd_EnablePlayerUseForAllPlayers
==============
*/

void __fastcall ScrCmd_EnablePlayerUseForAllPlayers(scrContext_t *scrContext, scr_entref_t entref)
{
  ?ScrCmd_EnablePlayerUseForAllPlayers@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_MainMP_SetHealth
==============
*/

void __fastcall GScr_MainMP_SetHealth(scrContext_t *scrContext, gentity_s *ent, int offset)
{
  ?GScr_MainMP_SetHealth@@YAXAEAUscrContext_t@@PEAUgentity_s@@H@Z(scrContext, ent, offset);
}

/*
==============
GScr_DisableForceHelmetWhenSpectating
==============
*/

void __fastcall GScr_DisableForceHelmetWhenSpectating(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScr_DisableForceHelmetWhenSpectating@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_DisableLootSpawnPoint
==============
*/

void __fastcall GScr_DisableLootSpawnPoint(scrContext_t *scrContext)
{
  ?GScr_DisableLootSpawnPoint@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_AgentDamage
==============
*/

void __fastcall Scr_AgentDamage(gentity_s *self, const gentity_s *inflictor, gentity_s *attacker, int damage, int dflags, int meansOfDeath, const Weapon *r_weapon, bool isAlternate, const vec3_t *vPoint, const vec3_t *vDir, const hitLocation_t hitLoc, int timeOffset, int modelIndex, scr_string_t partName)
{
  ?Scr_AgentDamage@@YAXPEAUgentity_s@@PEBU1@0HHHAEBUWeapon@@_NPEBTvec3_t@@4W4hitLocation_t@@HHW4scr_string_t@@@Z(self, inflictor, attacker, damage, dflags, meansOfDeath, r_weapon, isAlternate, vPoint, vDir, hitLoc, timeOffset, modelIndex, partName);
}

/*
==============
GScr_AddEntityAllowUndefined
==============
*/

void __fastcall GScr_AddEntityAllowUndefined(const gentity_s *pEnt)
{
  ?GScr_AddEntityAllowUndefined@@YAXPEBUgentity_s@@@Z(pEnt);
}

/*
==============
Scr_AgentGameTypeMain
==============
*/

void Scr_AgentGameTypeMain(void)
{
  ?Scr_AgentGameTypeMain@@YAXXZ();
}

/*
==============
ScrCmd_DisablePlayerUseForAllPlayers
==============
*/

void __fastcall ScrCmd_DisablePlayerUseForAllPlayers(scrContext_t *scrContext, scr_entref_t entref)
{
  ?ScrCmd_DisablePlayerUseForAllPlayers@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_VerifyBunkerCode
==============
*/

void __fastcall GScr_VerifyBunkerCode(scrContext_t *scrContext)
{
  ?GScr_VerifyBunkerCode@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
ScrCmd_DisablePlayerUse
==============
*/

void __fastcall ScrCmd_DisablePlayerUse(scrContext_t *scrContext, scr_entref_t entref)
{
  ?ScrCmd_DisablePlayerUse@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_GetLootSpawnPoint
==============
*/

void __fastcall GScr_GetLootSpawnPoint(scrContext_t *scrContext)
{
  ?GScr_GetLootSpawnPoint@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_BotGameTypeMain
==============
*/

void Scr_BotGameTypeMain(void)
{
  ?Scr_BotGameTypeMain@@YAXXZ();
}

/*
==============
GScr_GetQuestPoints
==============
*/

void __fastcall GScr_GetQuestPoints(scrContext_t *scrContext)
{
  ?GScr_GetQuestPoints@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_LoadRead
==============
*/

void *__fastcall Scr_LoadRead(int len)
{
  return ?Scr_LoadRead@@YAPEAXH@Z(len);
}

/*
==============
GScr_AnalyticsAddEvent
==============
*/

void __fastcall GScr_AnalyticsAddEvent(scrContext_t *scrContext)
{
  ?GScr_AnalyticsAddEvent@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_GetLootSpawnPointCount
==============
*/

void __fastcall GScr_GetLootSpawnPointCount(scrContext_t *scrContext)
{
  ?GScr_GetLootSpawnPointCount@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScriptMP::ConstructMessageString
==============
*/

void __fastcall GScriptMP::ConstructMessageString(GScriptMP *this, scrContext_t *scrContext, int firstParmIndex, int lastParmIndex, const char *errorContext, char *string, unsigned int stringLimit)
{
  ?ConstructMessageString@GScriptMP@@UEBAXAEAUscrContext_t@@HHPEBDPEADI@Z(this, scrContext, firstParmIndex, lastParmIndex, errorContext, string, stringLimit);
}

/*
==============
GScr_SetIntroCameraActive
==============
*/

void __fastcall GScr_SetIntroCameraActive(scrContext_t *scrContext)
{
  ?GScr_SetIntroCameraActive@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_HostMigration
==============
*/

void Scr_HostMigration(void)
{
  ?Scr_HostMigration@@YAXXZ();
}

/*
==============
GScr_GetUnusedLootCachePoints
==============
*/

void __fastcall GScr_GetUnusedLootCachePoints(scrContext_t *scrContext)
{
  ?GScr_GetUnusedLootCachePoints@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_ForceThirdPersonWhenSpectating
==============
*/

void __fastcall GScr_ForceThirdPersonWhenSpectating(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScr_ForceThirdPersonWhenSpectating@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_MainMP_PrecacheAiTypes
==============
*/

void __fastcall GScr_MainMP_PrecacheAiTypes(scrContext_t *scrContext)
{
  ?GScr_MainMP_PrecacheAiTypes@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_MainMP_PlayLoopedFX
==============
*/

void __fastcall GScr_MainMP_PlayLoopedFX(scrContext_t *scrContext)
{
  ?GScr_MainMP_PlayLoopedFX@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_SetBallPassAllowed
==============
*/

void __fastcall GScr_SetBallPassAllowed(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScr_SetBallPassAllowed@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_AnalyticsWriteCSV
==============
*/

void __fastcall GScr_AnalyticsWriteCSV(scrContext_t *scrContext)
{
  ?GScr_AnalyticsWriteCSV@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_GetDateTime
==============
*/

void __fastcall GScr_GetDateTime(scrContext_t *scrContext)
{
  ?GScr_GetDateTime@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
ScrCmd_EnablePlayerUse
==============
*/

void __fastcall ScrCmd_EnablePlayerUse(scrContext_t *scrContext, scr_entref_t entref)
{
  ?ScrCmd_EnablePlayerUse@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScr_ForceHelmetWhenSpectating
==============
*/

void __fastcall GScr_ForceHelmetWhenSpectating(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScr_ForceHelmetWhenSpectating@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
Scr_LeaderDialog
==============
*/

void __fastcall Scr_LeaderDialog(gentity_s *self, const scr_string_t dialog, const vec3_t *location)
{
  ?Scr_LeaderDialog@@YAXPEAUgentity_s@@W4scr_string_t@@AEBTvec3_t@@@Z(self, dialog, location);
}

/*
==============
Scr_AgentAdded
==============
*/

void __fastcall Scr_AgentAdded(gentity_s *self)
{
  ?Scr_AgentAdded@@YAXPEAUgentity_s@@@Z(self);
}

/*
==============
Scr_PlayerDamage
==============
*/

void __fastcall Scr_PlayerDamage(gentity_s *self, const gentity_s *inflictor, gentity_s *attacker, int damage, int dflags, int meansOfDeath, const Weapon *r_weapon, bool isAlternate, const vec3_t *vPoint, const vec3_t *vDir, const hitLocation_t hitLoc, int timeOffset, int modelIndex, scr_string_t partName, const GExtraDamageParams *extraParams, int unscaledDamage)
{
  ?Scr_PlayerDamage@@YAXPEAUgentity_s@@PEBU1@0HHHAEBUWeapon@@_NPEBTvec3_t@@4W4hitLocation_t@@HHW4scr_string_t@@AEBVGExtraDamageParams@@H@Z(self, inflictor, attacker, damage, dflags, meansOfDeath, r_weapon, isAlternate, vPoint, vDir, hitLoc, timeOffset, modelIndex, partName, extraParams, unscaledDamage);
}

/*
==============
GScr_GetLootSpawnScriptableIndexFirst
==============
*/

void __fastcall GScr_GetLootSpawnScriptableIndexFirst(scrContext_t *scrContext)
{
  ?GScr_GetLootSpawnScriptableIndexFirst@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_StartAC130
==============
*/

void __fastcall GScr_StartAC130(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScr_StartAC130@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
Scr_PlayerLastStand
==============
*/

bool __fastcall Scr_PlayerLastStand(gentity_s *self, gentity_s *inflictor, gentity_s *attacker, int damage, int meansOfDeath, const Weapon *r_weapon, bool isAlternate, const vec3_t *vDir, const hitLocation_t hitLoc, int psTimeOffset)
{
  return ?Scr_PlayerLastStand@@YA_NPEAUgentity_s@@00HHAEBUWeapon@@_NAEBTvec3_t@@W4hitLocation_t@@H@Z(self, inflictor, attacker, damage, meansOfDeath, r_weapon, isAlternate, vDir, hitLoc, psTimeOffset);
}

/*
==============
GScr_DisableForceThirdPersonWhenSpectating
==============
*/

void __fastcall GScr_DisableForceThirdPersonWhenSpectating(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScr_DisableForceThirdPersonWhenSpectating@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
GScriptMP::GetFunction
==============
*/

unsigned int __fastcall GScriptMP::GetFunction(GScriptMP *this, const char **pName, BuiltinType *type)
{
  return ?GetFunction@GScriptMP@@UEBAIPEAPEBDPEAW4BuiltinType@@@Z(this, pName, type);
}

/*
==============
Scr_PlayerActive
==============
*/

void __fastcall Scr_PlayerActive(gentity_s *self)
{
  ?Scr_PlayerActive@@YAXPEAUgentity_s@@@Z(self);
}

/*
==============
GScr_BRMatchStarted
==============
*/

void __fastcall GScr_BRMatchStarted(scrContext_t *scrContext)
{
  ?GScr_BRMatchStarted@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
GScr_RequestGameLobbyRemainIntact
==============
*/

void __fastcall GScr_RequestGameLobbyRemainIntact(scrContext_t *scrContext)
{
  ?GScr_RequestGameLobbyRemainIntact@@YAXAEAUscrContext_t@@@Z(scrContext);
}

/*
==============
Scr_PlayerMigrated
==============
*/

void __fastcall Scr_PlayerMigrated(gentity_s *self)
{
  ?Scr_PlayerMigrated@@YAXPEAUgentity_s@@@Z(self);
}

/*
==============
Scr_LoadGameType
==============
*/

void Scr_LoadGameType(void)
{
  ?Scr_LoadGameType@@YAXXZ();
}

/*
==============
GScriptMP::GetMethod
==============
*/

unsigned int __fastcall GScriptMP::GetMethod(GScriptMP *this, const char **pName, BuiltinType *type)
{
  return ?GetMethod@GScriptMP@@UEBAIPEAPEBDPEAW4BuiltinType@@@Z(this, pName, type);
}

/*
==============
Scr_StartupGameType
==============
*/

void Scr_StartupGameType(void)
{
  ?Scr_StartupGameType@@YAXXZ();
}

/*
==============
GScr_GetCorpseAnim
==============
*/

void __fastcall GScr_GetCorpseAnim(scrContext_t *scrContext, scr_entref_t entref)
{
  ?GScr_GetCorpseAnim@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
Scr_PlayerConnect
==============
*/

void __fastcall Scr_PlayerConnect(gentity_s *self)
{
  ?Scr_PlayerConnect@@YAXPEAUgentity_s@@@Z(self);
}

/*
==============
Scr_VoteCalled
==============
*/

void __fastcall Scr_VoteCalled(gentity_s *self, char *command, char *param1, char *param2)
{
  ?Scr_VoteCalled@@YAXPEAUgentity_s@@PEAD11@Z(self, command, param1, param2);
}

/*
==============
Scr_SetFXKillDefOnDelete
==============
*/

void __fastcall Scr_SetFXKillDefOnDelete(scrContext_t *scrContext, scr_entref_t entref)
{
  ?Scr_SetFXKillDefOnDelete@@YAXAEAUscrContext_t@@Uscr_entref_t@@@Z(scrContext, entref);
}

/*
==============
Scr_GetFxEventParam
==============
*/
__int64 Scr_GetFxEventParam(const int fxId, const int boneIndex, const int onlyClientIndex)
{
  unsigned int v6; 
  __int64 v8; 
  __int64 v9; 
  int v10; 
  int v11; 

  if ( fxId <= 0 )
    goto LABEL_22;
  if ( !BgDynamicLimits::IsValidGameMode() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_dynamic_limits.h", 98, ASSERT_TYPE_ASSERT, "(IsValidGameMode())", "%s\n\tAccessing BgDynamicLimits during invalid game mode", "IsValidGameMode()") )
    __debugbreak();
  if ( fxId >= BgDynamicLimits::ms_data.m_effectNamesCount )
  {
LABEL_22:
    if ( !BgDynamicLimits::IsValidGameMode() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_dynamic_limits.h", 98, ASSERT_TYPE_ASSERT, "(IsValidGameMode())", "%s\n\tAccessing BgDynamicLimits during invalid game mode", "IsValidGameMode()") )
      __debugbreak();
    v11 = BgDynamicLimits::ms_data.m_effectNamesCount - 1;
    v10 = fxId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 15115, ASSERT_TYPE_ASSERT, "(FX_IsValidFxId( fxId ))", "%s\n\tInvalid fxId %d. Max effect ID is %d", "FX_IsValidFxId( fxId )", v10, v11) )
      __debugbreak();
  }
  if ( (unsigned int)boneIndex >= 0x100 )
  {
    LODWORD(v9) = 256;
    LODWORD(v8) = boneIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 15118, ASSERT_TYPE_ASSERT, "(unsigned)( boneIndex ) < (unsigned)( (1<<8) )", "boneIndex doesn't index BONEINDEX_COUNT\n\t%i not in [0, %i)", v8, v9) )
      __debugbreak();
  }
  v6 = fxId | (boneIndex << BgDynamicLimits::GetEffectBits());
  if ( onlyClientIndex != -1 )
  {
    if ( (unsigned int)onlyClientIndex >= level.maxclients )
    {
      LODWORD(v9) = level.maxclients;
      LODWORD(v8) = onlyClientIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.cpp", 15124, ASSERT_TYPE_ASSERT, "(unsigned)( onlyClientIndex ) < (unsigned)( level.maxclients )", "onlyClientIndex doesn't index level.maxclients\n\t%i not in [0, %i)", v8, v9) )
        __debugbreak();
    }
    v6 |= onlyClientIndex << (BgDynamicLimits::GetEffectBits() + 8);
  }
  return v6;
}

/*
==============
GScr_GetUAVStrengthLevelNeutral
==============
*/
void GScr_GetUAVStrengthLevelNeutral(scrContext_t *scrContext)
{
  const dvar_t *v1; 

  v1 = DCONST_DVARINT_bg_UAVStrengthLevelNeutral;
  if ( !DCONST_DVARINT_bg_UAVStrengthLevelNeutral && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_UAVStrengthLevelNeutral") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  Scr_AddInt(scrContext, v1->current.integer);
}

/*
==============
GScr_GetUAVStrengthLevelShowEnemyFastSweep
==============
*/
void GScr_GetUAVStrengthLevelShowEnemyFastSweep(scrContext_t *scrContext)
{
  const dvar_t *v1; 

  v1 = DCONST_DVARINT_bg_UAVStrengthLevelShowEnemyFastSweep;
  if ( !DCONST_DVARINT_bg_UAVStrengthLevelShowEnemyFastSweep && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_UAVStrengthLevelShowEnemyFastSweep") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  Scr_AddInt(scrContext, v1->current.integer);
}

/*
==============
GScr_GetUAVStrengthLevelShowEnemyDirectional
==============
*/
void GScr_GetUAVStrengthLevelShowEnemyDirectional(scrContext_t *scrContext)
{
  const dvar_t *v1; 

  v1 = DCONST_DVARINT_bg_UAVStrengthLevelShowEnemyDirectional;
  if ( !DCONST_DVARINT_bg_UAVStrengthLevelShowEnemyDirectional && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_UAVStrengthLevelShowEnemyDirectional") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  Scr_AddInt(scrContext, v1->current.integer);
}

/*
==============
GScr_BlockTeamRadar
==============
*/
void GScr_BlockTeamRadar(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const char *v3; 
  const char *v4; 
  const char *v5; 
  const char *v6; 
  team_t outTeam; 

  ConstString = Scr_GetConstString(scrContext, 0);
  if ( Com_Teams_TeamFromString(ConstString, &outTeam) )
  {
    if ( outTeam >= TEAM_MP_NUM_TEAMS )
    {
      v5 = SL_ConvertToString(ConstString);
      v6 = j_va("Illegal team string '%s'. Must be axis, allies, team_three, team_four, team_five, team_six or none.", v5);
      Scr_ParamError(COM_ERR_3241, scrContext, 0, v6);
    }
    level.teamRadarBlocked[outTeam] = 1;
  }
  else
  {
    v3 = SL_ConvertToString(ConstString);
    v4 = j_va("unknown team '%s'", v3);
    Scr_Error(COM_ERR_3240, scrContext, v4);
  }
}

/*
==============
GScr_UnblockTeamRadar
==============
*/
void GScr_UnblockTeamRadar(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const char *v3; 
  const char *v4; 
  const char *v5; 
  const char *v6; 
  team_t outTeam; 

  ConstString = Scr_GetConstString(scrContext, 0);
  if ( Com_Teams_TeamFromString(ConstString, &outTeam) )
  {
    if ( outTeam >= TEAM_MP_NUM_TEAMS )
    {
      v5 = SL_ConvertToString(ConstString);
      v6 = j_va("Illegal team string '%s'. Must be axis, allies, team_three, team_four, team_five, team_six or none.", v5);
      Scr_ParamError(COM_ERR_3243, scrContext, 0, v6);
    }
    level.teamRadarBlocked[outTeam] = 0;
  }
  else
  {
    v3 = SL_ConvertToString(ConstString);
    v4 = j_va("unknown team '%s'", v3);
    Scr_Error(COM_ERR_3242, scrContext, v4);
  }
}

/*
==============
GScr_IsTeamRadarBlocked
==============
*/
void GScr_IsTeamRadarBlocked(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const char *v3; 
  const char *v4; 
  const char *v5; 
  const char *v6; 
  team_t outTeam; 

  ConstString = Scr_GetConstString(scrContext, 0);
  if ( Com_Teams_TeamFromString(ConstString, &outTeam) )
  {
    if ( outTeam >= TEAM_MP_NUM_TEAMS )
    {
      v5 = SL_ConvertToString(ConstString);
      v6 = j_va("Illegal team string '%s'. Must be axis, allies, team_three, team_four, team_five, team_six or none.", v5);
      Scr_ParamError(COM_ERR_3245, scrContext, 0, v6);
    }
    Scr_AddInt(scrContext, level.teamRadarBlocked[outTeam]);
  }
  else
  {
    v3 = SL_ConvertToString(ConstString);
    v4 = j_va("unknown team '%s'", v3);
    Scr_Error(COM_ERR_3244, scrContext, v4);
  }
}

/*
==============
GScr_EndLobby
==============
*/
void GScr_EndLobby(scrContext_t *scrContext)
{
  const dvar_t *v1; 

  v1 = DVARBOOL_g_kickHostIfIdle;
  if ( !DVARBOOL_g_kickHostIfIdle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "g_kickHostIfIdle") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  if ( v1->current.enabled )
    Cbuf_AddText(LOCAL_CLIENT_0, "xpartydisbandafterround\n");
}

/*
==============
GScr_MainMP_StartRagdoll
==============
*/
void GScr_MainMP_StartRagdoll(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  bool v4; 
  int Int; 

  Entity = GetEntity(entref);
  v4 = 0;
  if ( Scr_GetNumParam(scrContext) )
  {
    if ( Scr_GetType(scrContext, 0) != VAR_INTEGER )
      Scr_Error(COM_ERR_3246, scrContext, "GScr_MainMP_StartRagdoll - first param must be a boolean - it should be true if the ragdoll is being played instantly on a player\n");
    Int = Scr_GetInt(scrContext, 0);
    v4 = Int != 0;
    if ( Int && Entity->s.eType != ET_PLAYER_CORPSE )
      Scr_Error(COM_ERR_3247, scrContext, "GScr_MainMP_StartRagdoll - flagged as an instant player ragdoll - but the entity isn't a player corpse\n");
  }
  if ( G_PlayerCorpseMP_CheckShouldStartRagdoll(Entity) )
    G_PlayerCorpseMP_StartRagdoll(Entity, v4);
}

/*
==============
GScr_MainMP_StartRagdollFromImpact
==============
*/
void GScr_MainMP_StartRagdollFromImpact(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t ConstString; 
  int HitLocationIndexFromString; 
  vec3_t vectorValue; 

  Entity = GetEntity(entref);
  if ( Entity->s.eType != ET_AGENT_CORPSE )
    Scr_Error(COM_ERR_3248, scrContext, "GScr_MainMP_StartRagdollFromImpact - Must only be called on agent corpse. \n");
  if ( G_PlayerCorpseMP_CheckShouldStartRagdoll(Entity) )
  {
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vmovss  dword ptr [rsp+58h+vectorValue], xmm0
      vmovss  dword ptr [rsp+58h+vectorValue+4], xmm0
      vmovss  dword ptr [rsp+58h+vectorValue+8], xmm0
    }
    ConstString = Scr_GetConstString(scrContext, 0);
    HitLocationIndexFromString = G_Combat_GetHitLocationIndexFromString(ConstString);
    if ( !HitLocationIndexFromString && ConstString != scr_const.none )
      Scr_Error(COM_ERR_3249, scrContext, "HitLoc parameter must be a valid hit location string e.g. 'torso_upper'\n");
    Scr_GetVector(scrContext, 1u, &vectorValue);
    if ( HitLocationIndexFromString )
    {
      LerpEntityStateAgentCorpse::SetHitLoc((LerpEntityStateAgentCorpse *)&Entity->s.lerp.u, HitLocationIndexFromString);
      LerpEntityStateAgentCorpse::SetImpactVector((LerpEntityStateAgentCorpse *)&Entity->s.lerp.u, &vectorValue);
    }
    G_PlayerCorpseMP_StartRagdoll(Entity, 0);
  }
}

/*
==============
GScr_MainMP_StartRagdollFromVehicleHit
==============
*/
void GScr_MainMP_StartRagdollFromVehicleHit(scrContext_t *scrContext, scr_entref_t entref)
{
  const dvar_t *v6; 
  gentity_s *Entity; 
  gentity_s *v10; 
  Vehicle *vehicle; 
  GVehicles *VehicleSystem; 
  BgVehiclePhysicsManager *v13; 
  const dvar_t *v30; 
  GHandler *Handler; 
  int v57[4]; 
  vec3_t outVelLs; 

  v6 = DVARBOOL_bg_vehRagdoll;
  if ( !DVARBOOL_bg_vehRagdoll && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_vehRagdoll") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v6);
  if ( v6->current.enabled )
  {
    Entity = GetEntity(entref);
    if ( Entity->s.eType != ET_PLAYER_CORPSE )
      Scr_Error(COM_ERR_6219, scrContext, "GScr_MainMP_StartRagdollFromVehicleHit - Must only be called on player corpse. \n");
    if ( G_PlayerCorpseMP_CheckShouldStartRagdoll(Entity) )
    {
      __asm
      {
        vmovaps [rsp+0C8h+var_28], xmm6
        vmovaps [rsp+0C8h+var_38], xmm7
        vmovaps [rsp+0C8h+var_48], xmm8
        vmovaps [rsp+0C8h+var_58], xmm9
      }
      v10 = GScr_GetEntity(0);
      if ( !BG_IsVehicleEntity(&v10->s) || (vehicle = v10->vehicle) == NULL || !BGVehicles::PhysicsIsValid(vehicle->physicsVehicle) )
        Scr_Error(COM_ERR_6220, scrContext, "GScr_MainMP_StartRagdollFromVehicleHit - Must be called with a physics vehicle entity. \n");
      VehicleSystem = GVehicles::GetVehicleSystem();
      v13 = VehicleSystem->PhysicsGetVehiclePhysicsManager(VehicleSystem);
      _RSI = BgVehiclePhysicsManager::GetObjectById(v13, v10->vehicle->physicsVehicle);
      if ( !_RSI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 9559, ASSERT_TYPE_ASSERT, "(vehObj)", (const char *)&queryFormat, "vehObj") )
        __debugbreak();
      BgVehiclePhysics::ComputeVelocityLocalSpace(_RSI, &_RSI->m_linearVelocityWs, &outVelLs);
      __asm
      {
        vmovss  xmm0, dword ptr [rsp+0C8h+outVelLs]
        vmovss  xmm1, dword ptr [rsp+0C8h+outVelLs+4]
        vmulss  xmm3, xmm0, xmm0
        vmulss  xmm2, xmm1, xmm1
        vaddss  xmm6, xmm3, xmm2
      }
      *(double *)&_XMM0 = BgVehiclePhysics::GetTopSpeedForward(_RSI);
      __asm
      {
        vmaxss  xmm1, xmm0, cs:__real@41200000
        vmovss  xmm8, cs:__real@3f800000
        vdivss  xmm0, xmm8, xmm1
        vsqrtss xmm2, xmm6, xmm6
        vmulss  xmm0, xmm2, xmm0; val
        vmovaps xmm2, xmm8; max
        vxorps  xmm1, xmm1, xmm1; min
      }
      *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
      __asm
      {
        vmovss  xmm5, dword ptr [rsi+1A4h]
        vmovss  xmm7, dword ptr [rsi+1A8h]
        vmovss  xmm6, dword ptr [rsi+1ACh]
      }
      v30 = DCONST_DVARFLT_bg_vehRagdollSpawnAhead;
      __asm
      {
        vmulss  xmm1, xmm7, xmm7
        vmulss  xmm2, xmm5, xmm5
        vaddss  xmm3, xmm2, xmm1
        vmulss  xmm2, xmm6, xmm6
        vaddss  xmm3, xmm3, xmm2
        vsqrtss xmm4, xmm3, xmm3
        vcmpless xmm1, xmm4, cs:__real@80000000
        vmovaps xmm9, xmm0
        vblendvps xmm0, xmm4, xmm8, xmm1
        vdivss  xmm2, xmm8, xmm0
        vmulss  xmm8, xmm5, xmm2
        vmulss  xmm7, xmm7, xmm2
        vmulss  xmm6, xmm6, xmm2
      }
      if ( !DCONST_DVARFLT_bg_vehRagdollSpawnAhead && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_vehRagdollSpawnAhead") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v30);
      __asm
      {
        vmulss  xmm0, xmm9, xmm9
        vmulss  xmm3, xmm0, dword ptr [rbx+28h]
        vmulss  xmm1, xmm8, xmm3
        vaddss  xmm0, xmm1, dword ptr [rdi+130h]
        vmovss  [rsp+0C8h+var_88], xmm0
        vmulss  xmm2, xmm7, xmm3
        vaddss  xmm1, xmm2, dword ptr [rdi+134h]
        vmulss  xmm0, xmm6, xmm3
        vmovss  [rsp+0C8h+var_84], xmm1
        vaddss  xmm2, xmm0, dword ptr [rdi+138h]
        vmovss  [rsp+0C8h+var_80], xmm2
      }
      Handler = GHandler::getHandler();
      Handler->SetEntityOrigin(Handler, Entity->s.number, (const vec3_t *)v57);
      G_PlayerCorpseMP_StartRagdoll(Entity, 0);
      __asm
      {
        vmovaps xmm9, [rsp+0C8h+var_58]
        vmovaps xmm8, [rsp+0C8h+var_48]
        vmovaps xmm7, [rsp+0C8h+var_38]
        vmovaps xmm6, [rsp+0C8h+var_28]
      }
    }
  }
}

/*
==============
GScr_MainMP_StartRagdollFromVehicleImpact
==============
*/
void GScr_MainMP_StartRagdollFromVehicleImpact(scrContext_t *scrContext, scr_entref_t entref)
{
  const dvar_t *v6; 
  gentity_s *Entity; 
  gentity_s *v10; 
  Vehicle *vehicle; 
  GVehicles *VehicleSystem; 
  BgVehiclePhysicsManager *v13; 
  bool IsDynamic; 
  char v16; 
  bool v17; 
  unsigned int PhysicsBodyId; 
  Physics_WorldId m_worldId; 
  unsigned int v28; 
  hknpWorld *world; 
  __int64 v66; 
  char v67; 
  vec3_t impactVector; 
  float v69; 

  v6 = DVARBOOL_bg_vehRagdoll;
  if ( !DVARBOOL_bg_vehRagdoll && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_vehRagdoll") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v6);
  if ( v6->current.enabled )
  {
    Entity = GetEntity(entref);
    if ( ((Entity->s.eType - 2) & 0xFFEF) != 0 )
      Scr_Error(COM_ERR_6288, scrContext, "GScr_MainMP_StartRagdollFromVehicleHit - Must only be called on player corpse. \n");
    if ( G_PlayerCorpseMP_CheckShouldStartRagdoll(Entity) )
    {
      __asm
      {
        vmovaps [rsp+0C8h+var_28], xmm6
        vmovaps [rsp+0C8h+var_38], xmm7
        vmovaps [rsp+0C8h+var_48], xmm8
        vmovaps [rsp+0C8h+var_58], xmm9
      }
      v10 = GScr_GetEntity(0);
      if ( !BG_IsVehicleEntity(&v10->s) || (vehicle = v10->vehicle) == NULL || !BGVehicles::PhysicsIsValid(vehicle->physicsVehicle) )
        Scr_Error(COM_ERR_6289, scrContext, "GScr_MainMP_StartRagdollFromVehicleHit - Must be called with a physics vehicle entity. \n");
      VehicleSystem = GVehicles::GetVehicleSystem();
      v13 = VehicleSystem->PhysicsGetVehiclePhysicsManager(VehicleSystem);
      _RDI = BgVehiclePhysicsManager::GetObjectById(v13, v10->vehicle->physicsVehicle);
      if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 9613, ASSERT_TYPE_ASSERT, "(vehObj)", (const char *)&queryFormat, "vehObj") )
        __debugbreak();
      IsDynamic = BgVehiclePhysics::IsDynamic(_RDI);
      v16 = 0;
      v17 = !IsDynamic;
      if ( IsDynamic )
      {
        __asm
        {
          vmovss  xmm0, dword ptr [rdi+178h]
          vmovss  xmm1, dword ptr [rdi+174h]
          vmulss  xmm3, xmm0, dword ptr [rdi+1A8h]
          vmulss  xmm2, xmm1, dword ptr [rdi+1A4h]
          vmovss  xmm0, dword ptr [rdi+17Ch]
          vmulss  xmm1, xmm0, dword ptr [rdi+1ACh]
          vaddss  xmm4, xmm3, xmm2
          vaddss  xmm6, xmm4, xmm1
        }
      }
      else
      {
        PhysicsBodyId = BgVehiclePhysics::GetPhysicsBodyId(_RDI);
        m_worldId = _RDI->m_worldId;
        v28 = PhysicsBodyId;
        if ( (unsigned int)m_worldId > PHYSICS_WORLD_ID_CLIENT1_DETAIL )
        {
          LODWORD(v66) = _RDI->m_worldId;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 850, ASSERT_TYPE_ASSERT, "(worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST)", "%s\n\tHavok Physics: Trying to Get Rigid Body Transform with invalid world index %i", "worldId >= PHYSICS_WORLD_ID_FIRST && worldId <= PHYSICS_WORLD_ID_LAST", v66) )
            __debugbreak();
        }
        if ( (v28 & 0xFFFFFF) == 0xFFFFFF )
        {
          LODWORD(v66) = m_worldId;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 851, ASSERT_TYPE_ASSERT, "(bodyId.isValid())", "%s\n\tHavok Physics: Trying to Get Rigid Body Transform with invalid body id for world %i", "bodyId.isValid()", v66) )
            __debugbreak();
        }
        world = HavokPhysics_GetConstWorld(m_worldId)->world;
        if ( !world )
        {
          LODWORD(v66) = m_worldId;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\physics\\private\\havok\\havokphysicsimplementationinterface.inl", 855, ASSERT_TYPE_ASSERT, "(world)", "%s\n\tHavokPhysics Get rigid Body Transform %i: world is NULL", "world", v66) )
            __debugbreak();
        }
        ((void (__fastcall *)(hknpWorldReader *, _QWORD))world->getBodyTransform)(&world->hknpWorldReader, v28);
        __asm
        {
          vmovsd  xmm2, qword ptr [rdi+140h]
          vshufps xmm0, xmm2, xmm2, 55h ; 'U'
          vmulss  xmm1, xmm0, dword ptr [rax+4]
          vmulss  xmm0, xmm2, dword ptr [rax]
          vaddss  xmm3, xmm1, xmm0
        }
        v69 = _RDI->m_history.m_lastLinearVel.v[2];
        __asm
        {
          vmovss  xmm1, [rsp+0C8h+var_68]
          vmulss  xmm2, xmm1, dword ptr [rax+8]
          vaddss  xmm6, xmm3, xmm2
        }
      }
      __asm
      {
        vxorps  xmm7, xmm7, xmm7
        vcomiss xmm6, xmm7
      }
      if ( v16 | v17 )
        *(double *)&_XMM0 = BgVehiclePhysics::GetTopSpeedReverse(_RDI);
      else
        *(double *)&_XMM0 = BgVehiclePhysics::GetTopSpeedForward(_RDI);
      __asm
      {
        vmaxss  xmm0, xmm0, cs:__real@41200000
        vmovss  xmm9, cs:__real@3f800000
        vdivss  xmm0, xmm6, xmm0
        vandps  xmm0, xmm0, cs:__xmm@7fffffff7fffffff7fffffff7fffffff; val
        vmovaps xmm2, xmm9; max
        vxorps  xmm1, xmm1, xmm1; min
      }
      *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
      __asm { vmovaps xmm8, xmm0 }
      _RDI->GetRagdollInitialImpact(_RDI, &Entity->r.currentOrigin, 0, (int *)&v67, &impactVector);
      __asm
      {
        vmovss  xmm5, dword ptr [rsp+0C8h+impactVector]
        vmovss  xmm6, dword ptr [rsp+0C8h+impactVector+4]
        vmovss  xmm7, dword ptr [rsp+0C8h+impactVector+8]
        vmulss  xmm0, xmm7, xmm7
        vmulss  xmm2, xmm5, xmm5
        vmulss  xmm1, xmm6, xmm6
        vaddss  xmm3, xmm2, xmm1
        vaddss  xmm1, xmm3, xmm0
        vmulss  xmm3, xmm8, cs:sScale
        vsqrtss xmm2, xmm1, xmm1
        vcmpless xmm0, xmm2, cs:__real@80000000
        vblendvps xmm0, xmm2, xmm9, xmm0
        vdivss  xmm4, xmm9, xmm0
        vmulss  xmm1, xmm5, xmm4
        vmulss  xmm2, xmm1, xmm3
        vmulss  xmm0, xmm6, xmm4
        vmulss  xmm1, xmm0, xmm3
        vmovss  dword ptr [rsp+0C8h+impactVector], xmm2
        vmulss  xmm2, xmm7, xmm4
        vmulss  xmm0, xmm2, xmm3
        vmovss  dword ptr [rsp+0C8h+impactVector+8], xmm0
        vmovss  dword ptr [rsp+0C8h+impactVector+4], xmm1
      }
      LerpEntityStateAgentCorpse::SetHitLoc((LerpEntityStateAgentCorpse *)&Entity->s.lerp.u, 5);
      LerpEntityStateAgentCorpse::SetImpactVector((LerpEntityStateAgentCorpse *)&Entity->s.lerp.u, &impactVector);
      G_PlayerCorpseMP_StartRagdoll(&g_entities[Entity->s.number], 0);
      __asm
      {
        vmovaps xmm9, [rsp+0C8h+var_58]
        vmovaps xmm8, [rsp+0C8h+var_48]
        vmovaps xmm7, [rsp+0C8h+var_38]
        vmovaps xmm6, [rsp+0C8h+var_28]
      }
    }
  }
}

/*
==============
GScr_MainMP_SetPlayerCorpseDone
==============
*/
void GScr_MainMP_SetPlayerCorpseDone(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  GCorpseInfoMP *CorpseInfo; 

  Entity = GetEntity(entref);
  if ( Entity->s.eType != ET_PLAYER_CORPSE )
    Scr_Error(COM_ERR_5755, scrContext, "GScr_MainMP_SetPlayerCorpseDone only valid for player corpses.\n");
  CorpseInfo = G_PlayerCorpseMP_FindCorpseInfo(Entity);
  if ( !CorpseInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 9658, ASSERT_TYPE_ASSERT, "( corpseInfo )", (const char *)&queryFormat, "corpseInfo") )
    __debugbreak();
  CorpseInfo->canDetachClientCorpse = 1;
  G_PlayerCorpseMP_UpdateClientDetachState(Entity, CorpseInfo);
}

/*
==============
GScr_GetCorpseAnim
==============
*/
void GScr_GetCorpseAnim(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  __int64 v4; 
  gentity_s *v5; 
  __int64 v6; 
  const BgAnimStatic *v7; 
  entityType_s eType; 
  GameScriptDataMP *GameScriptDataMP; 
  const XAnimTree **p_tree; 
  unsigned __int16 AnimIndex; 
  GameScriptDataMP *v12; 
  __int64 AgentCorpseIndex; 
  scr_string_t AnimsetName; 
  SuitAnimType SuitAnimIndex; 
  int LegsAnimation; 
  const XAnim_s *Anims; 
  const char *v18; 
  scr_anim_t value; 

  Entity = GetEntity(entref);
  v4 = tls_index;
  v5 = Entity;
  if ( !*(_QWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 272i64) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_static.h", 169, ASSERT_TYPE_ASSERT, "(ms_activeBgs)", (const char *)&queryFormat, "ms_activeBgs") )
    __debugbreak();
  v6 = *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + v4) + 272i64);
  if ( !v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 9676, ASSERT_TYPE_ASSERT, "( bgameStatic )", (const char *)&queryFormat, "bgameStatic") )
    __debugbreak();
  v7 = (const BgAnimStatic *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v6 + 8i64))(v6);
  if ( !v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 9679, ASSERT_TYPE_ASSERT, "( bgameAnim )", (const char *)&queryFormat, "bgameAnim") )
    __debugbreak();
  eType = v5->s.eType;
  if ( eType == ET_PLAYER_CORPSE )
  {
    GameScriptDataMP = GameScriptDataMP::GetGameScriptDataMP();
    p_tree = (const XAnimTree **)&GameScriptDataMP->playerCorpseInfo[G_PlayerCorpseMP_GetEntCorpseIndex(v5)].tree;
    goto LABEL_12;
  }
  if ( eType == ET_AGENT_CORPSE )
  {
    v12 = GameScriptDataMP::GetGameScriptDataMP();
    AgentCorpseIndex = G_PlayerCorpseMP_GetAgentCorpseIndex(v5);
    p_tree = (const XAnimTree **)&v12->agentCorpseInfo[AgentCorpseIndex].tree;
    if ( v12->agentCorpseInfo[AgentCorpseIndex].ci.usingAnimState )
    {
      AnimsetName = BG_AnimationState_GetAnimsetName(&v5->s);
      if ( !AnimsetName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 9714, ASSERT_TYPE_ASSERT, "( animsetName != ( static_cast< scr_string_t >( 0 ) ) )", (const char *)&queryFormat, "animsetName != NULL_SCR_STRING") )
        __debugbreak();
      AnimIndex = BG_AnimationState_GetAnimIndex(AnimsetName, &v5->s);
      goto LABEL_21;
    }
LABEL_12:
    if ( PlayerASM_IsEnabled() )
    {
      AnimIndex = BG_PlayerASM_GetXAnimIndex(&v5->s, MOVEMENT);
    }
    else
    {
      SuitAnimIndex = BG_AnimationMP_GetSuitAnimIndex(&v5->s);
      LegsAnimation = BG_AnimationMP_GetLegsAnimation(&v5->s);
      AnimIndex = BG_AnimationMP_GetXAnimIndex(v7, SuitAnimIndex, LegsAnimation & 0xFFFFEFFF);
    }
LABEL_21:
    value.index = AnimIndex;
    Anims = XAnimGetAnims(*p_tree);
    value.tree = Scr_GetAnimsIndex(Anims, 1u);
    Scr_AddAnim(scrContext, value);
    return;
  }
  v18 = j_va("Only valid on player corpses");
  Scr_Error(COM_ERR_3250, scrContext, v18);
}

/*
==============
GScr_SetCorpseFalling
==============
*/
void GScr_SetCorpseFalling(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  bool v4; 
  __int64 EntCorpseIndex; 

  Entity = GetEntity(entref);
  v4 = Scr_GetInt(scrContext, 0) != 0;
  if ( Entity && Entity->s.eType == ET_PLAYER_CORPSE )
  {
    EntCorpseIndex = G_PlayerCorpseMP_GetEntCorpseIndex(Entity);
    GameScriptDataMP::GetGameScriptDataMP()->playerCorpseInfo[EntCorpseIndex].falling = v4;
  }
  else
  {
    Scr_Error(COM_ERR_3251, scrContext, "SetCorpseFalling called on a non-corpse entity\n");
  }
}

/*
==============
GScr_GetCorpseEntity
==============
*/
void GScr_GetCorpseEntity(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  const GCorpseInfoMP *CorpseInfoFromEntity; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3678, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 9796, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client && !v4->agent )
    {
      v5 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3677, scrContext, v5);
    }
  }
  CorpseInfoFromEntity = GetCorpseInfoFromEntity(v4);
  if ( CorpseInfoFromEntity )
    GScr_AddEntity(&g_entities[CorpseInfoFromEntity->entnum]);
  else
    Scr_AddUndefined(scrContext);
}

/*
==============
ScrCmd_PlayerForceDeathAnim
==============
*/
void ScrCmd_PlayerForceDeathAnim(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const gentity_s *v4; 
  int v5; 
  hitLocation_t hitLoc; 
  int v7; 
  bool outIsAlternate; 
  vec3_t vectorValue; 
  Weapon outWeapon; 

  Entity = GetEntity(entref);
  if ( !Entity->client )
    Scr_Error(COM_ERR_3252, scrContext, "Must be called on a player.");
  v4 = GScr_GetEntity(0);
  v5 = G_Combat_MeansOfDeathFromScriptParam(scrContext, 1);
  GScr_Main_GetWeaponParam(scrContext, 2u, &outWeapon, &outIsAlternate);
  hitLoc = G_Combat_HitLocFromScriptParam(scrContext, 3);
  Scr_GetVector(scrContext, 4u, &vectorValue);
  v7 = G_CombatMP_DeathAnimForScript(Entity, v4, v5, &outWeapon, hitLoc, &vectorValue);
  Scr_AddInt(scrContext, v7);
}

/*
==============
GScr_ForceThirdPersonWhenSpectating
==============
*/
void GScr_ForceThirdPersonWhenSpectating(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gclient_s *client; 

  Entity = GetEntity(entref);
  client = Entity->client;
  if ( !client )
  {
    Scr_ObjectError(COM_ERR_3253, scrContext, "not a player entity");
    client = Entity->client;
  }
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal(&client->ps.otherFlags, GameModeFlagValues::ms_mpValue, 0x2Bu);
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal(&Entity->client->ps.otherFlags, GameModeFlagValues::ms_mpValue, 0x2Cu);
}

/*
==============
GScr_ForceHelmetWhenSpectating
==============
*/
void GScr_ForceHelmetWhenSpectating(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gclient_s *client; 

  Entity = GetEntity(entref);
  client = Entity->client;
  if ( !client )
  {
    Scr_ObjectError(COM_ERR_6082, scrContext, "not a player entity");
    client = Entity->client;
  }
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal(&client->ps.otherFlags, GameModeFlagValues::ms_mpValue, 0x2Cu);
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal(&Entity->client->ps.otherFlags, GameModeFlagValues::ms_mpValue, 0x2Bu);
}

/*
==============
GScr_DisableForceHelmetWhenSpectating
==============
*/
void GScr_DisableForceHelmetWhenSpectating(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gclient_s *client; 

  Entity = GetEntity(entref);
  client = Entity->client;
  if ( !client )
  {
    Scr_ObjectError(COM_ERR_3255, scrContext, "not a player entity");
    client = Entity->client;
  }
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal(&client->ps.otherFlags, GameModeFlagValues::ms_mpValue, 0x2Cu);
}

/*
==============
GScr_SetBallPassAllowed
==============
*/
void GScr_SetBallPassAllowed(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gclient_s *client; 
  int Int; 
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *p_otherFlags; 

  Entity = GetEntity(entref);
  client = Entity->client;
  if ( !client )
  {
    Scr_ObjectError(COM_ERR_3254, scrContext, "SetBallPassAllowed() must be called on a player");
    client = Entity->client;
    if ( !client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 9945, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
  }
  Int = Scr_GetInt(scrContext, 0);
  p_otherFlags = &client->ps.otherFlags;
  if ( Int )
    GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagStrict(p_otherFlags, (POtherFlagsMP)48);
  else
    GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagStrict(p_otherFlags, (POtherFlagsMP)48);
}

/*
==============
GScr_DisableForceThirdPersonWhenSpectating
==============
*/
void GScr_DisableForceThirdPersonWhenSpectating(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gclient_s *client; 

  Entity = GetEntity(entref);
  client = Entity->client;
  if ( !client )
  {
    Scr_ObjectError(COM_ERR_6083, scrContext, "not a player entity");
    client = Entity->client;
  }
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal(&client->ps.otherFlags, GameModeFlagValues::ms_mpValue, 0x2Bu);
}

/*
==============
GScr_StartAC130
==============
*/
void GScr_StartAC130(scrContext_t *scrContext, scr_entref_t entref)
{
  if ( !GetEntity(entref)->client )
    Scr_ObjectError(COM_ERR_3256, scrContext, "not a player entity");
  Scr_Error(COM_ERR_3257, scrContext, "This functionality has been disabled, code needs to re-enable special ambient support");
}

/*
==============
GScr_StopAC130
==============
*/
void GScr_StopAC130(scrContext_t *scrContext, scr_entref_t entref)
{
  if ( !GetEntity(entref)->client )
    Scr_ObjectError(COM_ERR_3258, scrContext, "not a player entity");
  Scr_Error(COM_ERR_3259, scrContext, "This functionality has been disabled, code needs to re-enable special ambient support");
}

/*
==============
Scr_DevSetMinimapDvarSettings
==============
*/

void __fastcall Scr_DevSetMinimapDvarSettings(scrContext_t *scrContext, double _XMM1_8)
{
  const char *v4; 

  if ( Scr_GetNumParam(scrContext) != 2 )
  {
    v4 = j_va("USAGE: DevSetMinimapDvarSettings(<znear>, <angle>);\n");
    Scr_Error(COM_ERR_3260, scrContext, v4);
  }
  Dvar_SetBoolByName("SROLTPQLK", 0);
  Dvar_SetBoolByName("NNTRRPNLQ", 0);
  Dvar_SetBoolByName("LKQNQLPSNQ", 0);
  Dvar_SetBoolByName("MSMKRKOKQP", 0);
  Dvar_SetBoolByName("LTOKRMRTMM", 0);
  Dvar_SetBoolByName("MQRQQONQSL", 1);
  Dvar_SetBoolByName("RNPPKQOTN", 1);
  Dvar_SetIntByName("OLNTNRTPPL", 0);
  __asm { vxorps  xmm1, xmm1, xmm1; value }
  Dvar_SetFloatByName("QTSTQORQL", *(float *)&_XMM1);
  __asm { vmovss  xmm1, cs:__real@42b40000; value }
  Dvar_SetFloatByName("LOMLPPTKO", *(float *)&_XMM1);
  __asm { vxorps  xmm1, xmm1, xmm1; value }
  Dvar_SetFloatByName("NNSNKNRTPL", *(float *)&_XMM1);
  __asm { vmovss  xmm1, cs:__real@3f800000; value }
  Dvar_SetFloatByName("NQPKSOTP", *(float *)&_XMM1);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm { vmovaps xmm1, xmm0; value }
  Dvar_SetFloatByName("QTSPTNLOL", *(float *)&_XMM1);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm { vmovaps xmm1, xmm0; value }
  Dvar_SetFloatByName("LQSSPMSRQK", *(float *)&_XMM1);
}

/*
==============
Scr_GetPathDist
==============
*/
void Scr_GetPathDist(scrContext_t *scrContext)
{
  vec3_t vEndPos; 
  vec3_t vectorValue; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  Scr_GetVector(scrContext, 1u, &vEndPos);
  if ( Scr_GetNumParam(scrContext) <= 2 )
    __asm { vmovss  xmm0, cs:__real@44800000 }
  else
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
  __asm { vmovaps xmm2, xmm0; maxRadius }
  *(double *)&_XMM0 = Path_GetPathFindDist(&vectorValue, &vEndPos, *(float *)&_XMM2);
  __asm { vmovaps xmm1, xmm0; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
GScr_EmissiveBlend
==============
*/
void GScr_EmissiveBlend(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  char v14; 
  char v15; 
  msg_t buf; 

  Entity = GetEntity(entref);
  if ( (Entity->s.eType & 0x11) != 0 )
  {
    __asm
    {
      vmovaps [rsp+98h+var_18], xmm6
      vmovaps [rsp+98h+var_28], xmm7
      vxorps  xmm7, xmm7, xmm7
    }
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
    __asm
    {
      vmulss  xmm1, xmm0, cs:__real@447a0000
      vaddss  xmm2, xmm1, cs:__real@3f000000
      vxorps  xmm0, xmm0, xmm0
      vmovss  xmm1, xmm0, xmm2
      vroundss xmm3, xmm7, xmm1, 1
      vcvttss2si esi, xmm3
    }
    if ( _ESI < 0 )
      Scr_Error(COM_ERR_3264, scrContext, "duration must be positive.");
    if ( _ESI > 0xFFFF )
      Scr_Error(COM_ERR_3265, scrContext, "duration must be less than 65.535s any longer will require more bandwidth.");
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
    __asm
    {
      vxorps  xmm1, xmm1, xmm1
      vcomiss xmm0, xmm1
      vmovaps xmm6, xmm0
    }
    if ( v14 )
      goto LABEL_8;
    __asm { vcomiss xmm0, cs:__real@3f800000 }
    if ( !(v14 | v15) )
LABEL_8:
      Scr_Error(COM_ERR_3266, scrContext, "Intensity must be between 0 and 1");
    MSG_Init(&buf, msgBuffer, 1020);
    MSG_WriteByte(&buf, 49i64);
    if ( Entity->s.number >= 255 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 10209, ASSERT_TYPE_ASSERT, "(ent->s.number < 0xff)", (const char *)&queryFormat, "ent->s.number < 0xff") )
      __debugbreak();
    MSG_WriteByte(&buf, Entity->s.number);
    __asm
    {
      vmulss  xmm0, xmm6, cs:__real@437f0000
      vaddss  xmm2, xmm0, cs:__real@3f000000
      vxorps  xmm1, xmm1, xmm1
      vmovss  xmm2, xmm1, xmm2
      vroundss xmm0, xmm7, xmm2, 1
      vcvttss2si eax, xmm0
    }
    MSG_WriteByte(&buf, _EAX);
    MSG_WriteShort(&buf, _ESI);
    SV_Game_BroadcastServerCommandMsg(SV_CMD_CAN_IGNORE, &buf);
    __asm
    {
      vmovaps xmm7, [rsp+98h+var_28]
      vmovaps xmm6, [rsp+98h+var_18]
    }
  }
}

/*
==============
GScr_SetAutoBoxCalculationUsingDobj
==============
*/
void GScr_SetAutoBoxCalculationUsingDobj(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  GameModeFlagContainer<enum BgEntityFlagsCommon,enum BgEntityFlagsSP,enum BgEntityFlagsMP,64> *p_flags; 

  Entity = GetEntity(entref);
  if ( Entity->classname == scr_const.script_model )
  {
    p_flags = &Entity->flags;
    if ( Scr_GetInt(scrContext, 0) )
    {
      if ( GameModeFlagValues::ms_mpValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 201, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a MP-only context", "IsFlagActive( index )") )
        __debugbreak();
      p_flags->m_flags[1] |= 0x10u;
    }
    else
    {
      GameModeFlagContainer<enum BgEntityFlagsCommon,enum BgEntityFlagsSP,enum BgEntityFlagsMP,64>::ClearFlagStrict(p_flags, (BgEntityFlagsMP)36);
    }
  }
  else
  {
    Scr_Error(COM_ERR_6490, scrContext, "Currently only supported on script model entities.");
  }
}

/*
==============
GScr_DisableMissileStick
==============
*/
void GScr_DisableMissileStick(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( Entity->classname != scr_const.script_model )
    Scr_Error(COM_ERR_3267, scrContext, "Currently only supported on script model entities");
  if ( GameModeFlagValues::ms_mpValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 201, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a MP-only context", "IsFlagActive( index )") )
    __debugbreak();
  Entity->flags.m_flags[1] |= 2u;
}

/*
==============
GScr_EnableMissileStick
==============
*/
void GScr_EnableMissileStick(scrContext_t *scrContext, scr_entref_t entref)
{
  GameModeFlagContainer<enum BgEntityFlagsCommon,enum BgEntityFlagsSP,enum BgEntityFlagsMP,64> *Entity; 

  Entity = (GameModeFlagContainer<enum BgEntityFlagsCommon,enum BgEntityFlagsSP,enum BgEntityFlagsMP,64> *)GetEntity(entref);
  if ( Entity[47].m_flags[1] != scr_const.script_model )
    Scr_Error(COM_ERR_3268, scrContext, "Currently only supported on script model entities");
  if ( GameModeFlagValues::ms_mpValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 212, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a MP-only context", "IsFlagActive( index )") )
    __debugbreak();
  GameModeFlagContainer<enum BgEntityFlagsCommon,enum BgEntityFlagsSP,enum BgEntityFlagsMP,64>::ClearFlagInternal(Entity + 52, ACTIVE, 0x21u);
}

/*
==============
GScr_RideVehicle
==============
*/
void GScr_RideVehicle(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v7; 
  int NumParam; 
  unsigned int v21; 
  bool v22; 
  scr_string_t **v23; 
  const char *v24; 
  __int64 v27[2]; 
  char outErrorMessage[256]; 
  char v30; 

  __asm { vmovaps [rsp+178h+var_28], xmm6 }
  Entity = GetEntity(entref);
  if ( !Entity->client )
    Scr_ObjectError(COM_ERR_3269, scrContext, "not a player entity");
  v7 = GScr_GetEntity(0);
  if ( !v7->vehicle )
    Scr_ParamError(COM_ERR_3270, scrContext, 0, "not a vehicle entity");
  if ( (v7->flags.m_flags[0] & 0x80000) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 10326, ASSERT_TYPE_ASSERT, "(!vehicleEntity->flags.TestFlag( BgEntityFlagsCommon::MOVER_SLIDE ))", "%s\n\tVehicles cannot be script movers", "!vehicleEntity->flags.TestFlag( BgEntityFlagsCommon::MOVER_SLIDE )") )
    __debugbreak();
  _RDI = Entity->client;
  NumParam = Scr_GetNumParam(scrContext);
  __asm { vmovss  xmm6, cs:__real@43340000 }
  if ( NumParam <= 1 )
    __asm { vmovaps xmm0, xmm6; val }
  else
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm
  {
    vmovaps xmm2, xmm6; max
    vxorps  xmm1, xmm1, xmm1; min
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm
  {
    vxorps  xmm0, xmm0, cs:__xmm@80000000800000008000000080000000
    vmovss  dword ptr [rdi+5ED0h], xmm0
  }
  if ( NumParam <= 2 )
    __asm { vmovaps xmm0, xmm6; val }
  else
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
  __asm
  {
    vmovaps xmm2, xmm6; max
    vxorps  xmm1, xmm1, xmm1; min
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm { vmovss  dword ptr [rdi+5EE8h], xmm0 }
  if ( NumParam <= 3 )
    __asm { vmovaps xmm0, xmm6; val }
  else
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
  __asm
  {
    vmovaps xmm2, xmm6; max
    vxorps  xmm1, xmm1, xmm1; min
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm
  {
    vxorps  xmm1, xmm0, cs:__xmm@80000000800000008000000080000000
    vmovss  dword ptr [rdi+5ECCh], xmm1
  }
  if ( NumParam <= 4 )
    __asm { vmovaps xmm0, xmm6; val }
  else
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 4u);
  __asm
  {
    vmovaps xmm2, xmm6; max
    vxorps  xmm1, xmm1, xmm1; min
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm { vmovss  dword ptr [rdi+5EE4h], xmm0 }
  if ( NumParam <= 5 )
  {
    v21 = 0;
    v22 = 0;
  }
  else
  {
    v21 = 0;
    v22 = Scr_GetInt(scrContext, 5u) != 0;
  }
  _RDI->link_useTagAnglesForViewAngles = v22;
  _RDI->link_useBaseAnglesForViewClamp = 0;
  *(_WORD *)&_RDI->link_rotationMovesEyePos = 1;
  _RDI->linkAnglesFrac = 0.0;
  _RDI->prevLinkAnglesSet = 0;
  _RDI->ps.viewlocked_entNum = v7->s.number;
  _RDI->ps.viewlocked = PLAYERVIEWLOCK_FULL;
  _RDI->ps.linkFlags.m_flags[0] &= 0xFFFFFFFA;
  G_SnapToViewAngleClampGoal(&_RDI->link_viewClamp);
  v27[0] = (__int64)&scr_const.tag_rider;
  v23 = (scr_string_t **)v27;
  v27[1] = (__int64)&scr_const.tag_driver;
  while ( !G_EntLinkTo(Entity, v7, **v23, 256, outErrorMessage) )
  {
    ++v21;
    ++v23;
    if ( v21 >= 2 )
      goto LABEL_28;
  }
  G_InitPlayerLinkAngles(Entity);
LABEL_28:
  if ( v21 == 2 )
  {
    v24 = j_va("failed to link player entity %i to vehicle entity %i: %s", (unsigned int)Entity->s.number, (unsigned int)v7->s.number, outErrorMessage);
    Scr_Error(COM_ERR_3271, scrContext, v24);
  }
  _R11 = &v30;
  __asm { vmovaps xmm6, xmmword ptr [r11-10h] }
}

/*
==============
GScr_StopRidingVehicle
==============
*/
void GScr_StopRidingVehicle(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gclient_s *client; 
  __int16 viewlocked_entNum; 
  GMovingPlatformClient *ClientFromGEntity; 
  int v7; 
  int v8; 

  Entity = GetEntity(entref);
  client = Entity->client;
  if ( !client )
  {
    Scr_ObjectError(COM_ERR_3272, scrContext, "not a player entity");
    client = Entity->client;
  }
  viewlocked_entNum = client->ps.viewlocked_entNum;
  if ( viewlocked_entNum == 2047 )
  {
    Scr_ObjectError(COM_ERR_3273, scrContext, "player not riding a vehicle");
    viewlocked_entNum = client->ps.viewlocked_entNum;
  }
  if ( (unsigned __int16)viewlocked_entNum >= 0x800u )
  {
    v8 = 2048;
    v7 = viewlocked_entNum;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 10401, ASSERT_TYPE_ASSERT, "(unsigned)( ps->viewlocked_entNum ) < (unsigned)( ( 2048 ) )", "ps->viewlocked_entNum doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v7, v8) )
      __debugbreak();
  }
  if ( !g_entities[client->ps.viewlocked_entNum].vehicle )
    Scr_ObjectError(COM_ERR_3274, scrContext, "player not riding a vehicle");
  G_EntUnlink(Entity);
  ClientFromGEntity = GMovingPlatforms::GetClientFromGEntity(Entity);
  if ( ClientFromGEntity )
    GMovingPlatformClient::UpdatePlatformTrace(ClientFromGEntity, Entity, 1);
  else
    Scr_ObjectError(COM_ERR_3275, scrContext, "Cannot get moving platform data from player entity.");
  client->ps.viewlocked_entNum = 2047;
}

/*
==============
GScr_DisableMissileBoosting
==============
*/
void GScr_DisableMissileBoosting(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( Entity->s.eType == ET_MISSILE )
  {
    Entity->c.missile.flags &= ~0x200u;
  }
  else
  {
    Scr_Error(COM_ERR_3276, scrContext, "This should only be used with missiles");
    v4->c.missile.flags &= ~0x200u;
  }
}

/*
==============
GScr_EnableMissileBoosting
==============
*/
void GScr_EnableMissileBoosting(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( Entity->s.eType == ET_MISSILE )
  {
    Entity->c.missile.flags |= 0x200u;
  }
  else
  {
    Scr_Error(COM_ERR_3277, scrContext, "This should only be used with missiles");
    v4->c.missile.flags |= 0x200u;
  }
}

/*
==============
GScr_MainMP_LaunchGrenade
==============
*/
void GScr_MainMP_LaunchGrenade(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  unsigned __int16 weaponIdx; 
  int time; 
  gentity_s *rethrowEnt; 
  gentity_s *v9; 
  scr_string_t grenade; 
  const gentity_s *v11; 
  __int64 hand; 
  bool outIsAlternate; 
  vec3_t dir; 
  vec3_t vectorValue; 
  Weapon outWeapon; 

  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 10492, ASSERT_TYPE_ASSERT, "(entity)", (const char *)&queryFormat, "entity") )
    __debugbreak();
  if ( Scr_GetNumParam(scrContext) < 3 || Scr_GetNumParam(scrContext) > 5 )
    Scr_Error(COM_ERR_3278, scrContext, "LaunchGrenade <grenade type> <origin> <velocity> [time to blow (seconds)] [rethrow grenade entity].\n");
  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  weaponIdx = outWeapon.weaponIdx;
  if ( !outWeapon.weaponIdx )
  {
    Scr_ParamError(COM_ERR_3279, scrContext, 0, "Specified grenade weapon is not valid");
    weaponIdx = outWeapon.weaponIdx;
  }
  if ( weaponIdx > bg_lastParsedWeaponIndex )
  {
    LODWORD(hand) = weaponIdx;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1203, ASSERT_TYPE_ASSERT, "( weaponIdx ) <= ( bg_lastParsedWeaponIndex )", "weaponIdx not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", hand, bg_lastParsedWeaponIndex) )
      __debugbreak();
  }
  if ( !bg_weaponDefs[weaponIdx] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1204, ASSERT_TYPE_ASSERT, "(bg_weaponDefs[weaponIdx])", (const char *)&queryFormat, "bg_weaponDefs[weaponIdx]") )
    __debugbreak();
  Scr_GetVector(scrContext, 1u, &vectorValue);
  Scr_GetVector(scrContext, 2u, &dir);
  if ( Scr_GetNumParam(scrContext) > 3 && Scr_GetType(scrContext, 3u) )
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
    __asm
    {
      vmulss  xmm1, xmm0, cs:__real@447a0000
      vcvttss2si esi, xmm1
    }
  }
  else
  {
    time = BG_WeaponFuseTime(&outWeapon, 0);
  }
  rethrowEnt = NULL;
  if ( Scr_GetNumParam(scrContext) > 4 && Scr_GetType(scrContext, 4u) )
  {
    if ( Scr_GetType(scrContext, 4u) != VAR_ENTITY && Scr_GetType(scrContext, 4u) != VAR_POINTER )
      Scr_Error(COM_ERR_3280, scrContext, "LaunchGrenade(): provided rethrow entity is not an entity.");
    v9 = GScr_GetEntity(4u);
    rethrowEnt = v9;
    if ( v9 )
    {
      if ( v9->s.eType != ET_MISSILE )
        Scr_Error(COM_ERR_3281, scrContext, "LaunchGrenade(): provided rethrow entity type is not ET_MISSILE.");
      grenade = scr_const.grenade;
      if ( rethrowEnt->classname != scr_const.grenade )
      {
        Scr_Error(COM_ERR_3282, scrContext, "LaunchGrenade(): provided rethrow entity classname is not 'grenade'.");
        grenade = scr_const.grenade;
      }
      if ( rethrowEnt->script_classname != grenade )
        Scr_Error(COM_ERR_3283, scrContext, "LaunchGrenade(): provided rethrow entity script_classname is not 'grenade'.");
    }
  }
  v11 = G_Missile_FireGrenadeRethrow(Entity, &vectorValue, &dir, &outWeapon, 0, WEAPON_HAND_DEFAULT, 1, time, 0, level.time, rethrowEnt);
  if ( v11 )
    GScr_AddEntity(v11);
  else
    Scr_AddUndefined(scrContext);
}

/*
==============
ScrCmd_SetGrenadeThrowScale
==============
*/
void ScrCmd_SetGrenadeThrowScale(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v7; 
  const char *v8; 

  __asm { vmovaps [rsp+58h+var_28], xmm7 }
  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3678, scrContext, "not an entity");
    v7 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 10575, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v7 = &g_entities[entnum];
    if ( !v7->client && !v7->agent )
    {
      v8 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3677, scrContext, v8);
    }
  }
  __asm { vmovaps [rsp+58h+var_18], xmm6 }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm { vmovaps xmm7, xmm0 }
  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
    __asm { vmovaps xmm6, xmm0 }
  }
  else
  {
    __asm { vmovss  xmm6, cs:__real@3f800000 }
  }
  if ( v7->agent )
  {
    __asm { vmovss  dword ptr [rax+0D208h], xmm7 }
    _RAX = v7->agent;
    __asm { vmovss  dword ptr [rax+0D20Ch], xmm6 }
  }
  else
  {
    if ( !v7->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 10587, ASSERT_TYPE_ASSERT, "( pSelf->client )", (const char *)&queryFormat, "pSelf->client") )
      __debugbreak();
    _RAX = v7->client;
    __asm { vmovss  dword ptr [rax+5FB4h], xmm7 }
    _RAX = v7->client;
    __asm { vmovss  dword ptr [rax+5FB8h], xmm6 }
  }
  __asm
  {
    vmovaps xmm6, [rsp+58h+var_18]
    vmovaps xmm7, [rsp+58h+var_28]
  }
}

/*
==============
ScrCmd_SetGrenadeCookScale
==============
*/
void ScrCmd_SetGrenadeCookScale(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v6; 
  const char *v7; 
  _DWORD *p_commandTime; 

  __asm { vmovaps [rsp+48h+var_18], xmm6 }
  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3678, scrContext, "not an entity");
    v6 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 10607, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v6 = &g_entities[entnum];
    if ( !v6->client && !v6->agent )
    {
      v7 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3677, scrContext, v7);
    }
  }
  p_commandTime = &v6->agent->playerState.commandTime;
  if ( !p_commandTime )
    p_commandTime = &v6->client->ps.commandTime;
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
  __asm { vmovaps xmm6, xmm0 }
  if ( !p_commandTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_playerstate.h", 1159, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  __asm
  {
    vmovss  xmm1, cs:__real@40a00000; maxAbsValueSize
    vmovaps xmm0, xmm6; value
    vmovaps xmm6, [rsp+48h+var_18]
  }
  p_commandTime[220] = MSG_PackSignedFloat(*(float *)&_XMM0, *(float *)&_XMM1, 0xCu);
}

/*
==============
Scr_GetNearNodeListForSpawnCheck
==============
*/
void Scr_GetNearNodeListForSpawnCheck(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  Scr_GetNearNodeListForSightToPathNodeCheck(scrContext, Entity);
}

/*
==============
GScr_MainMP_SpawnFX
==============
*/
void GScr_MainMP_SpawnFX(scrContext_t *scrContext)
{
  int v6; 
  int fxId; 
  unsigned int v10; 
  char v26; 
  const gentity_s *v42; 
  tmat33_t<vec3_t> v47; 
  vec3_t pos; 
  char v50; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-28h], xmm7
    vmovaps xmmword ptr [rax-38h], xmm9
  }
  if ( Scr_GetNumParam(scrContext) < 2 || Scr_GetNumParam(scrContext) > 4 )
    Scr_Error(COM_ERR_3284, scrContext, "Incorrect number of parameters");
  v6 = 0;
  fxId = Scr_GetInt(scrContext, 0);
  if ( !FX_IsValidFxId(fxId) )
    Scr_FxParamError(COM_ERR_5308, scrContext, 0, "spawnFx called with invalid effect id", fxId);
  __asm
  {
    vmovaps [rsp+0A8h+var_18], xmm6
    vmovss  xmm7, cs:__real@3f800000
    vxorps  xmm9, xmm9, xmm9
  }
  v10 = Scr_GetNumParam(scrContext) - 3;
  if ( v10 )
  {
    if ( v10 != 1 )
      goto LABEL_14;
    Scr_GetVector(scrContext, 3u, &v47.m[2]);
    __asm
    {
      vmovss  xmm5, dword ptr [rsp+0A8h+vectorValue]
      vmovss  xmm6, dword ptr [rsp+0A8h+vectorValue+4]
      vmovss  xmm3, dword ptr [rsp+0A8h+vectorValue+8]
      vmulss  xmm1, xmm5, xmm5
      vmulss  xmm0, xmm6, xmm6
      vaddss  xmm2, xmm1, xmm0
      vmulss  xmm1, xmm3, xmm3
      vaddss  xmm0, xmm2, xmm1
      vsqrtss xmm4, xmm0, xmm0
      vucomiss xmm4, xmm9
      vcmpless xmm0, xmm4, cs:__real@80000000
      vblendvps xmm0, xmm4, xmm7, xmm0
      vdivss  xmm2, xmm7, xmm0
      vmulss  xmm0, xmm5, xmm2
      vmovss  dword ptr [rsp+0A8h+vectorValue], xmm0
      vmulss  xmm0, xmm3, xmm2
      vmulss  xmm1, xmm6, xmm2
      vmovss  dword ptr [rsp+0A8h+vectorValue+8], xmm0
      vmovss  dword ptr [rsp+0A8h+vectorValue+4], xmm1
    }
    if ( v26 )
      Scr_FxParamError(COM_ERR_5309, scrContext, 3, "spawnFx called with (0 0 0) up direction", fxId);
    v6 = 1;
  }
  Scr_GetVector(scrContext, 2u, v47.m);
  __asm
  {
    vmovss  xmm5, dword ptr [rsp+0A8h+var_78]
    vmovss  xmm6, dword ptr [rsp+0A8h+var_78+4]
    vmovss  xmm3, dword ptr [rsp+0A8h+var_78+8]
    vmulss  xmm1, xmm5, xmm5
    vmulss  xmm0, xmm6, xmm6
    vaddss  xmm2, xmm1, xmm0
    vmulss  xmm1, xmm3, xmm3
    vaddss  xmm0, xmm2, xmm1
    vsqrtss xmm4, xmm0, xmm0
    vucomiss xmm4, xmm9
    vcmpless xmm0, xmm4, cs:__real@80000000
    vblendvps xmm0, xmm4, xmm7, xmm0
    vdivss  xmm2, xmm7, xmm0
    vmulss  xmm0, xmm5, xmm2
    vmovss  dword ptr [rsp+0A8h+var_78], xmm0
    vmulss  xmm0, xmm3, xmm2
    vmulss  xmm1, xmm6, xmm2
    vmovss  dword ptr [rsp+0A8h+var_78+8], xmm0
    vmovss  dword ptr [rsp+0A8h+var_78+4], xmm1
  }
  if ( v26 )
    Scr_FxParamError(COM_ERR_5310, scrContext, 2, "spawnFx called with (0 0 0) forward direction", fxId);
  ++v6;
LABEL_14:
  Scr_GetVector(scrContext, 1u, &pos);
  v42 = Scr_SpawnFXInternal(scrContext, fxId, &pos, v6, &v47);
  GScr_AddEntity(v42);
  __asm { vmovaps xmm6, [rsp+0A8h+var_18] }
  _R11 = &v50;
  __asm
  {
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm9, xmmword ptr [r11-30h]
  }
}

/*
==============
GScr_MainMP_SpawnFXForClient
==============
*/
void GScr_MainMP_SpawnFXForClient(scrContext_t *scrContext)
{
  unsigned int NumParam; 
  int v7; 
  int fxId; 
  gentity_s *Entity; 
  unsigned int v12; 
  char v28; 
  gentity_s *v44; 
  unsigned int number; 
  tmat33_t<vec3_t> v49; 
  vec3_t pos; 
  void *retaddr; 

  _R11 = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [r11-38h], xmm7
    vmovaps xmmword ptr [r11-48h], xmm9
  }
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam - 3 > 2 )
    Scr_Error(COM_ERR_3285, scrContext, "Incorrect number of parameters");
  v7 = 0;
  fxId = Scr_GetInt(scrContext, 0);
  if ( !FX_IsValidFxId(fxId) )
    Scr_FxParamError(COM_ERR_5311, scrContext, 0, "spawnFxForClient called with invalid effect id", fxId);
  Entity = GScr_GetEntity(2u);
  if ( Entity->s.number >= level.maxclients )
    Scr_FxParamError(COM_ERR_5312, scrContext, 2, "spawnFx called with invalid client entity", fxId);
  __asm
  {
    vmovaps [rsp+0D8h+var_28], xmm6
    vmovss  xmm7, cs:__real@3f800000
    vxorps  xmm9, xmm9, xmm9
  }
  v12 = NumParam - 4;
  if ( v12 )
  {
    if ( v12 != 1 )
      goto LABEL_15;
    Scr_GetVector(scrContext, 4u, &v49.m[2]);
    __asm
    {
      vmovss  xmm5, dword ptr [rsp+0D8h+vectorValue]
      vmovss  xmm6, dword ptr [rsp+0D8h+vectorValue+4]
      vmovss  xmm3, dword ptr [rsp+0D8h+vectorValue+8]
      vmulss  xmm1, xmm5, xmm5
      vmulss  xmm0, xmm6, xmm6
      vaddss  xmm2, xmm1, xmm0
      vmulss  xmm1, xmm3, xmm3
      vaddss  xmm0, xmm2, xmm1
      vsqrtss xmm4, xmm0, xmm0
      vucomiss xmm4, xmm9
      vcmpless xmm0, xmm4, cs:__real@80000000
      vblendvps xmm0, xmm4, xmm7, xmm0
      vdivss  xmm2, xmm7, xmm0
      vmulss  xmm0, xmm5, xmm2
      vmovss  dword ptr [rsp+0D8h+vectorValue], xmm0
      vmulss  xmm0, xmm3, xmm2
      vmulss  xmm1, xmm6, xmm2
      vmovss  dword ptr [rsp+0D8h+vectorValue+8], xmm0
      vmovss  dword ptr [rsp+0D8h+vectorValue+4], xmm1
    }
    if ( v28 )
      Scr_FxParamError(COM_ERR_5313, scrContext, 4, "spawnFx called with (0 0 0) up direction", fxId);
    v7 = 1;
  }
  Scr_GetVector(scrContext, 3u, v49.m);
  __asm
  {
    vmovss  xmm5, dword ptr [rsp+0D8h+var_88]
    vmovss  xmm6, dword ptr [rsp+0D8h+var_88+4]
    vmovss  xmm3, dword ptr [rsp+0D8h+var_88+8]
    vmulss  xmm1, xmm5, xmm5
    vmulss  xmm0, xmm6, xmm6
    vaddss  xmm2, xmm1, xmm0
    vmulss  xmm1, xmm3, xmm3
    vaddss  xmm0, xmm2, xmm1
    vsqrtss xmm4, xmm0, xmm0
    vucomiss xmm4, xmm9
    vcmpless xmm0, xmm4, cs:__real@80000000
    vblendvps xmm0, xmm4, xmm7, xmm0
    vdivss  xmm2, xmm7, xmm0
    vmulss  xmm0, xmm5, xmm2
    vmovss  dword ptr [rsp+0D8h+var_88], xmm0
    vmulss  xmm0, xmm3, xmm2
    vmulss  xmm1, xmm6, xmm2
    vmovss  dword ptr [rsp+0D8h+var_88+8], xmm0
    vmovss  dword ptr [rsp+0D8h+var_88+4], xmm1
  }
  if ( v28 )
    Scr_FxParamError(COM_ERR_5314, scrContext, 3, "spawnFx called with (0 0 0) forward direction", fxId);
  ++v7;
LABEL_15:
  Scr_GetVector(scrContext, 1u, &pos);
  v44 = Scr_SpawnFXInternal(scrContext, fxId, &pos, v7, &v49);
  __asm
  {
    vmovaps xmm9, [rsp+0D8h+var_48]
    vmovaps xmm7, [rsp+0D8h+var_38]
    vmovaps xmm6, [rsp+0D8h+var_28]
  }
  if ( (unsigned int)Entity->s.number >= level.maxclients && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 10768, ASSERT_TYPE_ASSERT, "(unsigned)( clientEnt->s.number ) < (unsigned)( level.maxclients )", "clientEnt->s.number doesn't index level.maxclients\n\t%i not in [0, %i)", Entity->s.number, level.maxclients) )
    __debugbreak();
  *(_QWORD *)v44->clientMask.array = -1i64;
  *(_QWORD *)&v44->clientMask.array[2] = -1i64;
  *(_QWORD *)&v44->clientMask.array[4] = -1i64;
  v44->clientMask.array[6] = -1;
  number = Entity->s.number;
  if ( number >= 0xE0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 290, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", Entity->s.number, 224) )
    __debugbreak();
  v44->clientMask.array[(unsigned __int64)number >> 5] &= ~(0x80000000 >> (number & 0x1F));
  GScr_AddEntity(v44);
}

/*
==============
Scr_PlayFXOnTagForTeam
==============
*/
void Scr_PlayFXOnTagForTeam(scrContext_t *scrContext)
{
  unsigned int Int; 
  gentity_s *Entity; 
  scr_string_t ConstLowercaseString; 
  scr_string_t v5; 
  team_t v6; 
  const char *v7; 
  const char *v8; 
  const char *v9; 
  const char *v10; 
  int BoneIndex; 
  unsigned int model; 
  const char *v13; 
  const char *v14; 
  const char *v15; 
  unsigned int FxEventParam_0; 

  if ( Scr_GetNumParam(scrContext) < 4 )
    Scr_Error(COM_ERR_3286, scrContext, "Incorrect number of parameters");
  Int = Scr_GetInt(scrContext, 0);
  Entity = GScr_GetEntity(1u);
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 2u);
  v5 = Scr_GetConstLowercaseString(scrContext, 3u);
  v6 = TEAM_ZERO;
  if ( v5 == scr_const.allies )
  {
    v6 = TEAM_TWO;
  }
  else if ( v5 == scr_const.axis )
  {
    v6 = TEAM_ONE;
  }
  else
  {
    v7 = SL_ConvertToString(v5);
    v8 = j_va("effect team %s is invalid\n", v7);
    Scr_ParamError(COM_ERR_3287, scrContext, 0, v8);
  }
  if ( !FX_IsValidFxId(Int) )
  {
    v9 = j_va("effect id %i is invalid\n", Int);
    Scr_ParamError(COM_ERR_3288, scrContext, 0, v9);
  }
  v10 = SL_ConvertToString(ConstLowercaseString);
  if ( strchr_0(v10, 34) )
    Scr_ParamError(COM_ERR_3289, scrContext, 2u, "cannot use \" characters in tag names\n");
  BoneIndex = SV_Game_DObjGetBoneIndex(Entity, ConstLowercaseString);
  if ( BoneIndex < 0 )
  {
    SV_Game_DObjDumpInfo(Entity);
    model = Entity->model;
    if ( !GConfigStrings::ms_gConfigStrings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_configstrings.h", 71, ASSERT_TYPE_ASSERT, "( ms_gConfigStrings )", (const char *)&queryFormat, "ms_gConfigStrings") )
      __debugbreak();
    v13 = GConfigStrings::ms_gConfigStrings->GetModelNameString(GConfigStrings::ms_gConfigStrings, model);
    v14 = SL_ConvertToString(ConstLowercaseString);
    v15 = j_va("tag '%s' does not exist on entity with model '%s'", v14, v13);
    Scr_ParamError(COM_ERR_3290, scrContext, 2u, v15);
  }
  FxEventParam_0 = Scr_GetFxEventParam_0(Int, BoneIndex, -1, v6);
  G_Utils_AddEvent(Entity, 0x81u, FxEventParam_0);
}

/*
==============
GScr_MainMP_TriggerFX
==============
*/

void __fastcall GScr_MainMP_TriggerFX(scrContext_t *scrContext, __int64 a2, double _XMM2_8)
{
  gentity_s *Entity; 

  if ( !Scr_GetNumParam(scrContext) || Scr_GetNumParam(scrContext) > 2 )
    Scr_Error(COM_ERR_3291, scrContext, "Incorrect number of parameters");
  Entity = GScr_GetEntity(0);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 10885, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( Entity->s.eType != ET_FX )
    Scr_ParamError(COM_ERR_3292, scrContext, 0, "entity wasn't created with 'newFx'");
  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
    __asm
    {
      vmulss  xmm1, xmm0, cs:__real@447a0000
      vaddss  xmm3, xmm1, cs:__real@3f000000
      vxorps  xmm2, xmm2, xmm2
      vmovss  xmm4, xmm2, xmm3
      vxorps  xmm0, xmm0, xmm0
      vroundss xmm1, xmm0, xmm4, 1
      vcvttss2si eax, xmm1
    }
    Entity->s.time2 = _EAX;
  }
  else
  {
    Entity->s.time2 = level.time;
  }
}

/*
==============
GScr_MainMP_PlayLoopedFX
==============
*/

void __fastcall GScr_MainMP_PlayLoopedFX(scrContext_t *scrContext, __int64 a2, double _XMM2_8)
{
  int v8; 
  int fxId; 
  unsigned int v11; 
  unsigned int v13; 
  char v29; 
  tmat33_t<vec3_t> v55; 
  vec3_t origin; 
  char v60; 

  __asm { vmovaps [rsp+0B8h+var_38], xmm7 }
  Sys_ProfBeginNamedEvent(0xFFFF0000, "GScr_MainMP_PlayLoopedFX");
  if ( Scr_GetNumParam(scrContext) < 3 || Scr_GetNumParam(scrContext) > 6 )
    Scr_Error(COM_ERR_3293, scrContext, "Incorrect number of parameters");
  v8 = 0;
  __asm { vxorps  xmm7, xmm7, xmm7 }
  fxId = Scr_GetInt(scrContext, 0);
  if ( !FX_IsValidFxId(fxId) )
    Scr_FxParamError(COM_ERR_5315, scrContext, 0, "playLoopedFx called with invalid effect id", fxId);
  __asm
  {
    vmovaps [rsp+0B8h+var_28], xmm6
    vmovaps [rsp+0B8h+var_48], xmm8
  }
  v11 = Scr_GetNumParam(scrContext) - 4;
  if ( v11 )
  {
    __asm { vmovss  xmm8, cs:__real@3f800000 }
    v13 = v11 - 1;
    if ( v13 )
    {
      if ( v13 != 1 )
        goto LABEL_15;
      v8 = 1;
      Scr_GetVector(scrContext, 5u, &v55.m[2]);
      __asm
      {
        vmovss  xmm5, dword ptr [rsp+0B8h+vectorValue]
        vmovss  xmm6, dword ptr [rsp+0B8h+vectorValue+4]
        vmovss  xmm3, dword ptr [rsp+0B8h+vectorValue+8]
        vmulss  xmm1, xmm5, xmm5
        vmulss  xmm0, xmm6, xmm6
        vaddss  xmm2, xmm1, xmm0
        vmulss  xmm1, xmm3, xmm3
        vaddss  xmm0, xmm2, xmm1
        vsqrtss xmm4, xmm0, xmm0
        vucomiss xmm4, xmm7
        vcmpless xmm0, xmm4, cs:__real@80000000
        vblendvps xmm0, xmm4, xmm8, xmm0
        vdivss  xmm2, xmm8, xmm0
        vmulss  xmm0, xmm5, xmm2
        vmovss  dword ptr [rsp+0B8h+vectorValue], xmm0
        vmulss  xmm0, xmm3, xmm2
        vmulss  xmm1, xmm6, xmm2
        vmovss  dword ptr [rsp+0B8h+vectorValue+8], xmm0
        vmovss  dword ptr [rsp+0B8h+vectorValue+4], xmm1
      }
      if ( v29 )
        Scr_FxParamError(COM_ERR_5316, scrContext, 5, "playLoopedFx called with (0 0 0) up direction", fxId);
    }
    Scr_GetVector(scrContext, 4u, v55.m);
    __asm
    {
      vmovss  xmm5, dword ptr [rsp+0B8h+var_88]
      vmovss  xmm6, dword ptr [rsp+0B8h+var_88+4]
      vmovss  xmm3, dword ptr [rsp+0B8h+var_88+8]
      vmulss  xmm1, xmm5, xmm5
      vmulss  xmm0, xmm6, xmm6
      vaddss  xmm2, xmm1, xmm0
      vmulss  xmm1, xmm3, xmm3
      vaddss  xmm0, xmm2, xmm1
      vsqrtss xmm4, xmm0, xmm0
      vucomiss xmm4, xmm7
      vcmpless xmm0, xmm4, cs:__real@80000000
      vblendvps xmm0, xmm4, xmm8, xmm0
      vdivss  xmm2, xmm8, xmm0
      vmulss  xmm0, xmm5, xmm2
      vmovss  dword ptr [rsp+0B8h+var_88], xmm0
      vmulss  xmm0, xmm3, xmm2
      vmulss  xmm1, xmm6, xmm2
      vmovss  dword ptr [rsp+0B8h+var_88+8], xmm0
      vmovss  dword ptr [rsp+0B8h+var_88+4], xmm1
    }
    if ( v29 )
      Scr_FxParamError(COM_ERR_5317, scrContext, 4, "playLoopedFx called with (0 0 0) forward direction", fxId);
    ++v8;
  }
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
  __asm { vmovaps xmm7, xmm0 }
LABEL_15:
  Scr_GetVector(scrContext, 2u, &origin);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm
  {
    vmulss  xmm1, xmm0, cs:__real@447a0000
    vaddss  xmm3, xmm1, cs:__real@3f000000
    vmovaps xmm8, [rsp+0B8h+var_48]
    vmovaps xmm6, [rsp+0B8h+var_28]
    vxorps  xmm2, xmm2, xmm2
    vmovss  xmm4, xmm2, xmm3
    vxorps  xmm0, xmm0, xmm0
    vroundss xmm1, xmm0, xmm4, 1
    vcvttss2si r14d, xmm1
  }
  if ( _ER14 <= 0 )
    Scr_FxParamError(COM_ERR_5318, scrContext, 1, "playLoopedFx called with repeat < 0.001 seconds", fxId);
  _RBX = G_Utils_SpawnEntity();
  _RBX->s.eType = ET_LOOP_FX;
  _RBX->s.staticState.general.xmodel = fxId;
  G_SetOrigin(_RBX, &origin, 1, 1);
  Scr_SetFxAngles(scrContext, v8, &v55, &_RBX->s.lerp.apos.trBase, fxId);
  _RBX->s.lerp.u.anonymous.data[1] = _ER14;
  __asm { vmovss  dword ptr [rbx+58h], xmm7 }
  SV_LinkEntity(_RBX);
  GScr_AddEntity(_RBX);
  Sys_ProfEndNamedEvent();
  _R11 = &v60;
  __asm { vmovaps xmm7, xmmword ptr [r11-20h] }
}

/*
==============
GScr_MainMP_SetNoJIPScore
==============
*/
void GScr_MainMP_SetNoJIPScore(scrContext_t *scrContext)
{
  unsigned int v2; 
  int Int; 
  BOOL v4; 
  int v5; 
  const char *v6; 

  if ( !Scr_GetNumParam(scrContext) || Scr_GetNumParam(scrContext) > 2 )
    Scr_Error(COM_ERR_3294, scrContext, "USAGE: SetNoJIPScore( no_jip )\n");
  v2 = 0;
  Int = Scr_GetInt(scrContext, 0);
  v4 = Int != 0;
  Com_Printf(24, "SetNoJIPScore() Called from script with value(%i)\n", Int != 0);
  if ( Int )
  {
    QosPayload::DisableJoinInProgressForScore(&QosPayload::ms_qosPayload);
    OnlineMatchmakerOmniscient::TurnOffBackfill_JIP(&OnlineMatchmakerOmniscient::ms_instance);
  }
  else
  {
    QosPayload::EnableJoinInProgressForScore(&QosPayload::ms_qosPayload);
    OnlineMatchmakerOmniscient::TurnOnBackfill_JIP(&OnlineMatchmakerOmniscient::ms_instance);
  }
  if ( Scr_GetNumParam(scrContext) > 1 )
  {
    v5 = Scr_GetInt(scrContext, 1u);
    LOBYTE(v2) = v5 != 0;
    Com_Printf(24, "SetNoJIPScore() invite join disabled value (%i)\n", v2);
    if ( v5 )
    {
      v6 = j_va("%c %d", 35i64, v4);
      SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v6);
    }
  }
}

/*
==============
GScr_MainMP_SetNoJIPTime
==============
*/
void GScr_MainMP_SetNoJIPTime(scrContext_t *scrContext)
{
  unsigned int v2; 
  int Int; 
  BOOL v4; 
  int v5; 
  const char *v6; 

  if ( !Scr_GetNumParam(scrContext) || Scr_GetNumParam(scrContext) > 2 )
    Scr_Error(COM_ERR_3295, scrContext, "USAGE: SetNoJIPTime( no_jip )\n");
  v2 = 0;
  Int = Scr_GetInt(scrContext, 0);
  v4 = Int != 0;
  Com_Printf(24, "SetNoJIPTime() Called from script with value(%i)\n", Int != 0);
  if ( Int )
  {
    QosPayload::DisableJoinInProgressForTime(&QosPayload::ms_qosPayload);
    OnlineMatchmakerOmniscient::TurnOffBackfill_JIP(&OnlineMatchmakerOmniscient::ms_instance);
  }
  else
  {
    QosPayload::EnableJoinInProgressForTime(&QosPayload::ms_qosPayload);
    OnlineMatchmakerOmniscient::TurnOnBackfill_JIP(&OnlineMatchmakerOmniscient::ms_instance);
  }
  if ( Scr_GetNumParam(scrContext) > 1 )
  {
    v5 = Scr_GetInt(scrContext, 1u);
    LOBYTE(v2) = v5 != 0;
    Com_Printf(24, "SetNoJIPTime() invite join disabled value (%i)\n", v2);
    if ( v5 )
    {
      v6 = j_va("%c %d", 35i64, v4);
      SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v6);
    }
  }
}

/*
==============
GScr_MainMP_CancelJoins
==============
*/
void GScr_MainMP_CancelJoins(scrContext_t *scrContext)
{
  PartyData *GameParty; 

  if ( Lobby_IsInLobby() || Live_IsInSystemlinkLobby() )
  {
    GameParty = Live_GetGameParty();
    PartyHost_ClearGoAsync(GameParty);
  }
}

/*
==============
GScr_AreWorldWeaponsLoaded
==============
*/
void GScr_AreWorldWeaponsLoaded(scrContext_t *scrContext)
{
  unsigned int v2; 
  int HasWorldWeaponsLoaded; 
  Weapon outWeapons; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_3296, scrContext, "LoadWeaponsForPlayer requires an array of weapon names.");
  v2 = GScr_Main_FillWeaponArray(scrContext, &outWeapons, 0x40u);
  HasWorldWeaponsLoaded = SV_StreamSync_HasWorldWeaponsLoaded(&outWeapons, v2);
  Scr_AddBool(scrContext, HasWorldWeaponsLoaded);
}

/*
==============
GScr_LoadWorldWeapons
==============
*/
void GScr_LoadWorldWeapons(scrContext_t *scrContext)
{
  unsigned int v2; 
  Weapon outWeapons; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_3297, scrContext, "LoadWorldWeapons requires an array of weapon names.");
  v2 = GScr_Main_FillWeaponArray(scrContext, &outWeapons, 0x20u);
  G_WeaponStreaming_SetGameWorldWeapons(&outWeapons, v2);
}

/*
==============
GScr_ClearWorldWeapons
==============
*/
void GScr_ClearWorldWeapons(scrContext_t *scrContext)
{
  if ( Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_3298, scrContext, "ClearWorldWeapons does not accept arguments.");
  G_WeaponStreaming_ClearGameRequests();
}

/*
==============
GScr_MainMp_ComputeWeaponClientLoadout
==============
*/
void GScr_MainMp_ComputeWeaponClientLoadout(scrContext_t *scrContext)
{
  unsigned int Int; 
  unsigned int v3; 
  unsigned int v4; 
  unsigned __int16 v5; 

  Int = Scr_GetInt(scrContext, 0);
  v3 = Scr_GetInt(scrContext, 1u);
  v4 = Scr_GetInt(scrContext, 2u);
  v5 = BG_WarPaint_EncodeClientLoadout(Int, v3, v4);
  Scr_AddInt(scrContext, v5);
}

/*
==============
Scr_IsGameBattleMatch
==============
*/
void Scr_IsGameBattleMatch(scrContext_t *scrContext)
{
  bool IsGameBattleActive; 

  IsGameBattleActive = GameBattles_IsGameBattleActive();
  Scr_AddInt(scrContext, IsGameBattleActive);
}

/*
==============
GScr_SetUAVJammed
==============
*/
void GScr_SetUAVJammed(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  int Int; 
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *p_otherFlags; 

  Entity = GetEntity(entref);
  if ( !Entity->client )
    Scr_Error(COM_ERR_3299, scrContext, "SetUAVJammed: Entity must be a player entity");
  if ( !Com_GameMode_SupportsFeature(WEAPON_MANTLE_OVER_WEAPON_DOWN|0x80) )
    Scr_Error(COM_ERR_3300, scrContext, "SetUAVJammed: Feature not supported by the current game mode");
  Int = Scr_GetInt(scrContext, 0);
  p_otherFlags = &Entity->client->ps.otherFlags;
  if ( Int )
    GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal(p_otherFlags, GameModeFlagValues::ms_mpValue, 0x37u);
  else
    GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal(p_otherFlags, GameModeFlagValues::ms_mpValue, 0x37u);
}

/*
==============
ScrCmd_StopSpectatePlayer
==============
*/
void ScrCmd_StopSpectatePlayer(scrContext_t *scrContext)
{
  unsigned int Int; 
  gentity_s *GEntity; 
  const char *v4; 

  Int = Scr_GetInt(scrContext, 0);
  if ( Scr_GetNumParam(scrContext) > 1 && Scr_GetInt(scrContext, 1u) )
  {
    GEntity = G_GetGEntity(Int);
    G_CmdsMP_StopSpectating(GEntity, 1, 0);
    G_CmdsMP_StopSpectateClientnum_ReplicateFollow_f(GEntity, Int, 1, 0);
  }
  else
  {
    v4 = j_va("stopspectate %i\n", Int);
    Cbuf_AddText(LOCAL_CLIENT_0, v4);
  }
}

/*
==============
ScrCmd_SpectateClientNum
==============
*/
void ScrCmd_SpectateClientNum(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int number; 
  unsigned int Int; 
  gentity_s *GEntity; 
  const char *v6; 

  number = GetEntity(entref)->s.number;
  Int = Scr_GetInt(scrContext, 0);
  if ( Scr_GetNumParam(scrContext) > 1 && Scr_GetInt(scrContext, 1u) )
  {
    GEntity = G_GetGEntity(number);
    G_CmdsMP_SpectateClientnum_f(GEntity, Int);
    G_CmdsMP_SpectateClientnum_ReplicateFollow_f(GEntity, number, Int);
  }
  else
  {
    v6 = j_va("svrspectateclientnum %i %i\n", number, Int);
    Cbuf_AddText(LOCAL_CLIENT_0, v6);
  }
}

/*
==============
ScrCmd_IsSpectatingPlayer
==============
*/
void ScrCmd_IsSpectatingPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gclient_s *client; 
  bool v5; 

  Entity = GetEntity(entref);
  client = Entity->client;
  if ( !client )
  {
    Scr_Error(COM_ERR_3301, scrContext, "IsSpectatingPlayer must be called on a player.");
    client = Entity->client;
    if ( !client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2275, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
      __debugbreak();
  }
  v5 = GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&client->ps.otherFlags, GameModeFlagValues::ms_mpValue, 0x21u);
  Scr_AddInt(scrContext, v5);
}

/*
==============
ScrCmd_GetFollowedPlayer
==============
*/
void ScrCmd_GetFollowedPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gclient_s *client; 

  Entity = GetEntity(entref);
  client = Entity->client;
  if ( !client )
  {
    Scr_Error(COM_ERR_6383, scrContext, "GetFollowedPlayer must be called on a player.");
    client = Entity->client;
  }
  if ( client->sess.cs.team != TEAM_FOLLOWER )
  {
    Scr_Error(COM_ERR_6384, scrContext, "GetFollowedPlayer must be called on a follower.");
    client = Entity->client;
  }
  Scr_AddInt(scrContext, client->sess.cs.indexMLGFollower);
}

/*
==============
Scr_LoadInfilTransient
==============
*/
void Scr_LoadInfilTransient(scrContext_t *scrContext)
{
  unsigned int NumParam; 
  const char *v3; 
  const char *String; 
  const char *v5; 
  const char *v6; 
  const char *v7; 
  const OmnvarDef *Def; 
  OmnvarData *Data; 
  InfilTransientType outType; 
  unsigned int outIndex; 

  if ( !BG_TransientsInfilMP_IsOmnvarsInited() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 11609, ASSERT_TYPE_ASSERT, "(BG_TransientsInfilMP_IsOmnvarsInited())", (const char *)&queryFormat, "BG_TransientsInfilMP_IsOmnvarsInited()") )
    __debugbreak();
  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    String = Scr_GetString(scrContext, 0);
    v5 = String;
    if ( String )
    {
      if ( BG_TransientsInfilMP_GetInfilOmnvarIndexByName(String, &outType, &outIndex) )
      {
        if ( outType )
        {
          Def = BG_Omnvar_GetDef(outIndex);
          Data = G_Omnvar_GetData(outIndex, -1, NULL);
          G_Omnvar_SetBool(Def, Data, 1);
          G_Omnvar_MarkChanged(Data);
        }
        else
        {
          v7 = j_va("LoadInfilTransient cannot load intro infil '%s' during gameplay.", v5);
          Scr_Error(COM_ERR_6061, scrContext, v7);
        }
      }
      else
      {
        v6 = j_va("LoadInfilTransient couldn't find transient '%s' listed in the infil csv files for this map", v5);
        Scr_Error(COM_ERR_6060, scrContext, v6);
      }
    }
    else
    {
      Scr_Error(COM_ERR_3305, scrContext, "LoadInfilTransient takes a string parameter");
    }
  }
  else
  {
    NumParam = Scr_GetNumParam(scrContext);
    v3 = j_va("LoadInfilTransient has %d parameters.  There should be exactly one.", NumParam);
    Scr_Error(COM_ERR_3304, scrContext, v3);
  }
}

/*
==============
Scr_UnloadInfilTransient
==============
*/
void Scr_UnloadInfilTransient(scrContext_t *scrContext)
{
  unsigned int NumParam; 
  const char *v3; 
  const char *String; 
  const char *v5; 
  const char *v6; 
  const OmnvarDef *Def; 
  OmnvarData *Data; 
  InfilTransientType outType; 
  unsigned int outIndex; 

  if ( !BG_TransientsInfilMP_IsOmnvarsInited() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 11657, ASSERT_TYPE_ASSERT, "(BG_TransientsInfilMP_IsOmnvarsInited())", (const char *)&queryFormat, "BG_TransientsInfilMP_IsOmnvarsInited()") )
    __debugbreak();
  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    String = Scr_GetString(scrContext, 0);
    v5 = String;
    if ( String )
    {
      if ( BG_TransientsInfilMP_GetInfilOmnvarIndexByName(String, &outType, &outIndex) )
      {
        Def = BG_Omnvar_GetDef(outIndex);
        Data = G_Omnvar_GetData(outIndex, -1, NULL);
        G_Omnvar_SetBool(Def, Data, 0);
        G_Omnvar_MarkChanged(Data);
      }
      else
      {
        v6 = j_va("UnloadInfilTransient couldn't find transient '%s' listed in the infil csv files for this map", v5);
        Scr_Error(COM_ERR_6062, scrContext, v6);
      }
    }
    else
    {
      Scr_Error(COM_ERR_3307, scrContext, "UnloadInfilTransient takes a string parameter");
    }
  }
  else
  {
    NumParam = Scr_GetNumParam(scrContext);
    v3 = j_va("UnloadInfilTransient has %d parameters.  There should be exactly one.", NumParam);
    Scr_Error(COM_ERR_3306, scrContext, v3);
  }
}

/*
==============
Scr_UnloadAllInfilIntroTransients
==============
*/
void Scr_UnloadAllInfilIntroTransients(scrContext_t *scrContext)
{
  unsigned int NumParam; 
  const char *v3; 
  unsigned int i; 
  unsigned int InfilOmnvarIndexByIndex; 
  const OmnvarDef *Def; 
  OmnvarData *Data; 

  if ( !BG_TransientsInfilMP_IsOmnvarsInited() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 11698, ASSERT_TYPE_ASSERT, "(BG_TransientsInfilMP_IsOmnvarsInited())", (const char *)&queryFormat, "BG_TransientsInfilMP_IsOmnvarsInited()") )
    __debugbreak();
  if ( Scr_GetNumParam(scrContext) )
  {
    NumParam = Scr_GetNumParam(scrContext);
    v3 = j_va("unloadallinfilintrotransients has %d parameters.  There should be exactly zero.", NumParam);
    Scr_Error(COM_ERR_6058, scrContext, v3);
  }
  else
  {
    for ( i = 0; i < BG_TransientsInfilMP_GetInfilCount(); ++i )
    {
      if ( BG_TransientsInfilMP_GetInfilType(i) == INFIL_TRTYPE_INTRO )
      {
        InfilOmnvarIndexByIndex = BG_TransientsInfilMP_GetInfilOmnvarIndexByIndex(i);
        if ( InfilOmnvarIndexByIndex == -1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 11712, ASSERT_TYPE_ASSERT, "(omnvarIndex != ((uint)-1))", (const char *)&queryFormat, "omnvarIndex != OMNVAR_NONE") )
          __debugbreak();
        Def = BG_Omnvar_GetDef(InfilOmnvarIndexByIndex);
        Data = G_Omnvar_GetData(InfilOmnvarIndexByIndex, -1, NULL);
        if ( !Def && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_omnvar.h", 47, ASSERT_TYPE_ASSERT, "(def)", (const char *)&queryFormat, "def") )
          __debugbreak();
        if ( !Data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_omnvar.h", 48, ASSERT_TYPE_ASSERT, "(data)", (const char *)&queryFormat, "data") )
          __debugbreak();
        if ( Def->type )
        {
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_omnvar.h", 49, ASSERT_TYPE_ASSERT, "(def->type == OMNVAR_TYPE_BOOL)", (const char *)&queryFormat, "def->type == OMNVAR_TYPE_BOOL") )
            __debugbreak();
        }
        Data->current.enabled = 0;
        G_Omnvar_MarkChanged(Data);
      }
    }
  }
}

/*
==============
GScr_GetAIArray
==============
*/
void GScr_GetAIArray(scrContext_t *scrContext)
{
  unsigned int v3; 
  __int128 *v6; 
  int v10; 
  AIIterator *AIAgentIterator; 
  const gentity_s *i; 
  unsigned __int64 eTeam; 
  ai_agent_t *ScriptedAgentInfo; 
  __int64 v15; 
  __int64 v16; 
  __int64 v17; 
  __int128 v18; 
  int v20; 
  AIAgentInterface result; 
  AIAgentInterface *p_result; 

  _RAX = Scr_GetTeamFlags((bitarray<224> *)&result, scrContext, 0);
  v3 = 0;
  __asm
  {
    vmovups xmm0, xmmword ptr [rax]
    vmovsd  xmm1, qword ptr [rax+10h]
  }
  v20 = _RAX->array[6];
  v6 = &v18;
  __asm
  {
    vmovups [rsp+0B8h+var_78], xmm0
    vmovsd  [rsp+0B8h+var_68], xmm1
  }
  while ( !*(_DWORD *)v6 )
  {
    ++v3;
    v6 = (__int128 *)((char *)v6 + 4);
    if ( v3 >= 7 )
    {
      if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_WEAPON_DROP|0x80) )
        _RAX = Com_TeamsSP_GetAllTeamFlags();
      else
        _RAX = Com_TeamsMP_GetAllTeamFlags();
      __asm
      {
        vmovups xmm0, xmmword ptr [rax]
        vmovsd  xmm1, qword ptr [rax+10h]
      }
      v10 = _RAX->array[6];
      __asm
      {
        vmovups [rsp+0B8h+var_78], xmm0
        vmovsd  [rsp+0B8h+var_68], xmm1
      }
      v20 = v10;
      break;
    }
  }
  Scr_MakeArray(scrContext);
  AIAgentIterator = AIAgentInterface::GetAIAgentIterator();
  for ( i = (const gentity_s *)AIAgentIterator->GetFirst(AIAgentIterator); i; i = AIAgentIterator->GetNext(AIAgentIterator) )
  {
    eTeam = (unsigned int)i->sentient->eTeam;
    if ( (unsigned int)eTeam >= 0xE0 )
    {
      LODWORD(v17) = 224;
      LODWORD(v16) = i->sentient->eTeam;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v16, v17) )
        __debugbreak();
    }
    if ( ((0x80000000 >> (eTeam & 0x1F)) & *((_DWORD *)&v18 + (eTeam >> 5))) != 0 )
    {
      AIAgentInterface::AIAgentInterface(&result);
      result.__vftable = (AIAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
      p_result = NULL;
      if ( SV_IsAgentScripted(i) )
      {
        ScriptedAgentInfo = AIAgentInterface::GetScriptedAgentInfo(i);
        if ( ScriptedAgentInfo )
        {
          p_result = &result;
          AINewAgentInterface::SetAgent((AINewAgentInterface *)&result, ScriptedAgentInfo);
        }
      }
      v15 = (__int64)p_result;
      if ( !p_result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 11757, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
        __debugbreak();
      if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v15 + 128i64))(v15) )
      {
        if ( !*(_BYTE *)((**(__int64 (__fastcall ***)(__int64))v15)(v15) + 1851) )
        {
          GScr_AddEntity(i);
          Scr_AddArray(scrContext);
        }
      }
    }
  }
}

/*
==============
GScr_GetAIArrayInRadius
==============
*/
void GScr_GetAIArrayInRadius(scrContext_t *scrContext)
{
  unsigned int v6; 
  __int128 *v9; 
  int v13; 
  AIIterator *AIAgentIterator; 
  const gentity_s *i; 
  unsigned __int64 eTeam; 
  ai_agent_t *ScriptedAgentInfo; 
  __int64 v18; 
  __int64 v19; 
  __int64 v32; 
  __int64 v33; 
  vec3_t vectorValue; 
  __int128 v35; 
  int v37; 
  AIAgentInterface result; 
  AIAgentInterface *p_result; 

  __asm { vmovaps [rsp+0D8h+var_38], xmm6 }
  Scr_GetVector(scrContext, 0, &vectorValue);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm { vmulss  xmm6, xmm0, xmm0 }
  _RAX = Scr_GetTeamFlags((bitarray<224> *)&result, scrContext, 2u);
  v6 = 0;
  __asm
  {
    vmovups xmm0, xmmword ptr [rax]
    vmovsd  xmm1, qword ptr [rax+10h]
  }
  v37 = _RAX->array[6];
  v9 = &v35;
  __asm
  {
    vmovups [rsp+0D8h+var_88], xmm0
    vmovsd  [rsp+0D8h+var_78], xmm1
  }
  while ( !*(_DWORD *)v9 )
  {
    ++v6;
    v9 = (__int128 *)((char *)v9 + 4);
    if ( v6 >= 7 )
    {
      if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_WEAPON_DROP|0x80) )
        _RAX = Com_TeamsSP_GetAllTeamFlags();
      else
        _RAX = Com_TeamsMP_GetAllTeamFlags();
      __asm
      {
        vmovups xmm0, xmmword ptr [rax]
        vmovsd  xmm1, qword ptr [rax+10h]
      }
      v13 = _RAX->array[6];
      __asm
      {
        vmovups [rsp+0D8h+var_88], xmm0
        vmovsd  [rsp+0D8h+var_78], xmm1
      }
      v37 = v13;
      break;
    }
  }
  Scr_MakeArray(scrContext);
  AIAgentIterator = AIAgentInterface::GetAIAgentIterator();
  for ( i = (const gentity_s *)AIAgentIterator->GetFirst(AIAgentIterator); i; i = AIAgentIterator->GetNext(AIAgentIterator) )
  {
    eTeam = (unsigned int)i->sentient->eTeam;
    if ( (unsigned int)eTeam >= 0xE0 )
    {
      LODWORD(v33) = 224;
      LODWORD(v32) = i->sentient->eTeam;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 257, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "pos < impl()->getBitCount()\n\t%i, %i", v32, v33) )
        __debugbreak();
    }
    if ( ((0x80000000 >> (eTeam & 0x1F)) & *((_DWORD *)&v35 + (eTeam >> 5))) != 0 )
    {
      AIAgentInterface::AIAgentInterface(&result);
      result.__vftable = (AIAgentInterface_vtbl *)&AINewAgentInterface::`vftable';
      p_result = NULL;
      if ( SV_IsAgentScripted(i) )
      {
        ScriptedAgentInfo = AIAgentInterface::GetScriptedAgentInfo(i);
        if ( ScriptedAgentInfo )
        {
          p_result = &result;
          AINewAgentInterface::SetAgent((AINewAgentInterface *)&result, ScriptedAgentInfo);
        }
      }
      v18 = (__int64)p_result;
      if ( !p_result && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 11816, ASSERT_TYPE_ASSERT, "(pAI)", (const char *)&queryFormat, "pAI") )
        __debugbreak();
      if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v18 + 128i64))(v18) )
      {
        v19 = (**(__int64 (__fastcall ***)(__int64))v18)(v18);
        if ( !*(_BYTE *)(v19 + 1851) )
        {
          __asm
          {
            vmovss  xmm0, dword ptr [rsp+0D8h+vectorValue]
            vsubss  xmm3, xmm0, dword ptr [rbx+130h]
            vmovss  xmm1, dword ptr [rsp+0D8h+vectorValue+4]
            vsubss  xmm2, xmm1, dword ptr [rbx+134h]
            vmovss  xmm0, dword ptr [rsp+0D8h+vectorValue+8]
            vsubss  xmm4, xmm0, dword ptr [rbx+138h]
            vmulss  xmm2, xmm2, xmm2
            vmulss  xmm1, xmm3, xmm3
            vmulss  xmm0, xmm4, xmm4
            vaddss  xmm3, xmm2, xmm1
            vaddss  xmm2, xmm3, xmm0
            vcomiss xmm2, xmm6
          }
          if ( !*(_BYTE *)(v19 + 1851) )
          {
            GScr_AddEntity(i);
            Scr_AddArray(scrContext);
          }
        }
      }
    }
  }
  __asm { vmovaps xmm6, [rsp+0D8h+var_38] }
}

/*
==============
GScr_ReportChallengeUserEvent
==============
*/
void GScr_ReportChallengeUserEvent(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  unsigned int NumParam; 
  scr_string_t ConstString; 
  unsigned int v7; 
  VariableType Type; 
  unsigned int Int; 
  signed int v10; 
  const char *v11; 
  ComErrorCode v12; 
  signed int v15; 
  scr_string_t v16; 
  signed int v17; 
  unsigned int ArrayObject; 
  unsigned int v19; 
  unsigned int ArraySize; 
  unsigned int ArrayVariable; 
  VariableType ValueType; 
  VariableType v23; 
  const char *NameForType; 
  const char *v25; 
  ComErrorCode v26; 
  VariableUnion *v27; 
  int v28; 
  const char *v29; 
  const char *v34; 
  scr_string_t *VariableValueAddress; 
  const char *v36; 
  char dest[1024]; 

  Entity = GetEntity(entref);
  if ( !Entity->client )
    Scr_Error(COM_ERR_3313, scrContext, "ReportChallengeUserEvent: entity must be a player entity");
  NumParam = Scr_GetNumParam(scrContext);
  if ( !NumParam )
    Scr_Error(COM_ERR_3314, scrContext, "ReportChallengeUserEvent: must supply at least an event name");
  ConstString = Scr_GetConstString(scrContext, 0);
  if ( !SV_Challenges_BeginEvent(Entity->client, ConstString) )
  {
    SV_Challenges_DiscardEvent();
    Scr_Error(COM_ERR_5873, scrContext, "ReportChallengeUserEvent: challenge event buffer full");
  }
  v7 = 1;
  if ( NumParam > 1 )
  {
    while ( 1 )
    {
      Type = Scr_GetType(scrContext, v7);
      if ( Type == VAR_UNDEFINED )
        goto LABEL_43;
      if ( Type == VAR_POINTER )
        break;
      if ( Type != VAR_STRING )
      {
        if ( Type == VAR_FLOAT )
        {
          *(double *)&_XMM0 = Scr_GetFloat(scrContext, v7);
          __asm
          {
            vcvtss2sd xmm3, xmm0, xmm0
            vmovq   r9, xmm3
          }
          v15 = Com_sprintf(dest, 0x400ui64, "%f", *(double *)&_XMM3);
          if ( v15 < 0 )
          {
            SV_Challenges_DiscardEvent();
            Scr_Error(COM_ERR_5877, scrContext, "ReportChallengeUserEvent: challenge event buffer full");
          }
          if ( SV_Challenges_AddParamString(dest, v15) )
            goto LABEL_43;
          SV_Challenges_DiscardEvent();
          v11 = "ReportChallengeUserEvent: challenge event buffer full";
          v12 = COM_ERR_5878;
        }
        else if ( Type == VAR_INTEGER )
        {
          Int = Scr_GetInt(scrContext, v7);
          v10 = Com_sprintf(dest, 0x400ui64, "%i", Int);
          if ( v10 < 0 )
          {
            SV_Challenges_DiscardEvent();
            Scr_Error(COM_ERR_5875, scrContext, "ReportChallengeUserEvent: challenge event buffer full");
          }
          if ( SV_Challenges_AddParamString(dest, v10) )
            goto LABEL_43;
          SV_Challenges_DiscardEvent();
          v11 = "ReportChallengeUserEvent: challenge event buffer full";
          v12 = COM_ERR_5876;
        }
        else
        {
LABEL_41:
          SV_Challenges_DiscardEvent();
          v11 = j_va("ReportChallengeUserEvent: invalid parameter %d is not an array, string or number", v7);
          v12 = COM_ERR_5753;
        }
LABEL_42:
        Scr_Error(v12, scrContext, v11);
        goto LABEL_43;
      }
      v16 = Scr_GetConstString(scrContext, v7);
      if ( !SV_Challenges_AddParam(v16) )
      {
        SV_Challenges_DiscardEvent();
        v11 = "ReportChallengeUserEvent: challenge event buffer full";
        v12 = COM_ERR_5874;
        goto LABEL_42;
      }
LABEL_43:
      if ( ++v7 >= NumParam )
        goto LABEL_44;
    }
    if ( Scr_GetPointerType(scrContext, v7) != VAR_ARRAY )
      goto LABEL_41;
    v17 = 0;
    dest[0] = 0;
    ArrayObject = BGScr_Main_GetArrayObject(scrContext, v7);
    v19 = 0;
    ArraySize = GetArraySize(scrContext, ArrayObject);
    if ( !ArraySize )
    {
LABEL_39:
      if ( !SV_Challenges_AddParamString(dest, v17) )
      {
        SV_Challenges_DiscardEvent();
        v11 = "ReportChallengeUserEvent: challenge event buffer full";
        v12 = COM_ERR_5881;
        goto LABEL_42;
      }
      goto LABEL_43;
    }
    while ( 1 )
    {
      ArrayVariable = GetArrayVariable(scrContext, ArrayObject, v19);
      ValueType = GetValueType(scrContext, ArrayVariable);
      if ( ValueType )
      {
        if ( ValueType == VAR_STRING )
        {
          VariableValueAddress = (scr_string_t *)GetVariableValueAddress(scrContext, ArrayVariable);
          v36 = SL_ConvertToString(*VariableValueAddress);
          v17 += Com_sprintf(&dest[v17], 1024i64 - v17, "%s|", v36);
          if ( (unsigned int)(v17 + 1) >= 0x400 )
          {
            SV_Challenges_DiscardEvent();
            v25 = j_va("ReportChallengeUserEvent: array parameter %d is too long", v7);
            v26 = COM_ERR_5880;
            goto LABEL_37;
          }
        }
        else
        {
          if ( ValueType == VAR_FLOAT )
          {
            _RAX = GetVariableValueAddress(scrContext, ArrayVariable);
            __asm
            {
              vmovss  xmm3, dword ptr [rax]
              vcvtss2sd xmm3, xmm3, xmm3
              vmovq   r9, xmm3
            }
            v28 = Com_sprintf(&dest[v17], 1024i64 - v17, "%f|", *(double *)&_XMM3);
            if ( v28 < 0 )
            {
              SV_Challenges_DiscardEvent();
              v34 = j_va("ReportChallengeUserEvent: array parameter %d is too long", v7);
              Scr_Error(COM_ERR_5879, scrContext, v34);
              v17 += v28;
              goto LABEL_38;
            }
          }
          else
          {
            if ( ValueType != VAR_INTEGER )
            {
              SV_Challenges_DiscardEvent();
              v23 = GetValueType(scrContext, ArrayVariable);
              NameForType = Scr_GetNameForType(v23);
              v25 = j_va("ReportChallengeUserEvent: invalid entry %d in parameter %d -- %s is not a string or number", v19, v7, NameForType);
              v26 = COM_ERR_5752;
LABEL_37:
              Scr_Error(v26, scrContext, v25);
              goto LABEL_38;
            }
            v27 = GetVariableValueAddress(scrContext, ArrayVariable);
            v28 = Com_sprintf(&dest[v17], 1024i64 - v17, "%i|", v27->uintValue);
            if ( v28 < 0 )
            {
              SV_Challenges_DiscardEvent();
              v29 = j_va("ReportChallengeUserEvent: array parameter %d is too long", v7);
              Scr_Error(COM_ERR_5751, scrContext, v29);
            }
          }
          v17 += v28;
        }
      }
LABEL_38:
      if ( ++v19 >= ArraySize )
        goto LABEL_39;
    }
  }
LABEL_44:
  SV_Challenges_FinishEvent();
}

/*
==============
GScr_GetLobbySquadIndex
==============
*/
void GScr_GetLobbySquadIndex(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v16; 
  __int64 v17; 

  entnum = entref.entnum;
  _RDI = GScr_Main_GetPlayerEntity(scrContext, entref);
  if ( !G_Utils_IsClient(_RDI) )
  {
    targetname = _RDI->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(_RDI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rdi+134h]
      vmovss  xmm2, dword ptr [rdi+130h]
      vmovss  xmm0, dword ptr [rdi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+48h+var_28], xmm0
    }
    v16 = j_va("GetLobbySquadIndex(). Only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, v17, v7, v6);
    Scr_Error(COM_ERR_5290, scrContext, v16);
  }
  Scr_AddInt(scrContext, _RDI->client->sess.lobbySquadIndex);
}

/*
==============
GScr_SavePOTGData
==============
*/

void __fastcall GScr_SavePOTGData(scrContext_t *scrContext)
{
  SV_SnapWorkersMP_StartSnapshotPOTGArchiveSave();
}

/*
==============
GScr_GetPOTGStartTime
==============
*/
void GScr_GetPOTGStartTime(scrContext_t *scrContext)
{
  int POTGStartTime; 

  POTGStartTime = SV_SnapshotMP_ArchiveGetPOTGStartTime();
  Scr_AddInt(scrContext, POTGStartTime);
}

/*
==============
GScr_GetPOTGDuration
==============
*/
void GScr_GetPOTGDuration(scrContext_t *scrContext)
{
  int POTGDuration; 

  POTGDuration = SV_SnapshotMP_ArchiveGetPOTGDuration();
  Scr_AddInt(scrContext, POTGDuration);
}

/*
==============
GScr_CompleteSceneTransition
==============
*/
void GScr_CompleteSceneTransition(scrContext_t *scrContext)
{
  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
    Cbuf_AddText(LOCAL_CLIENT_0, "completeSceneTransition\n");
}

/*
==============
GScr_CTGS_ReportUserMatchStats
==============
*/
void GScr_CTGS_ReportUserMatchStats(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  BG_SynchronizedPlayerInfo *PlayerInfo; 
  BG_SynchronizedPlayerInfo *v7; 
  const char *String; 
  int Int; 
  int v10; 
  int v11; 
  int v12; 
  int v13; 
  signed int v14; 
  char *v15; 
  unsigned __int64 MatchId; 
  unsigned int UTC; 
  XUID v18; 
  const char *MapName; 
  unsigned __int64 UniversalId; 
  __int64 v21; 
  ScopedCriticalSection v22; 
  int v23; 
  int v24; 
  int v25; 

  v21 = -2i64;
  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 12315, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  PlayerInfo = SvClientMP::GetPlayerInfo(v4->s.clientNum);
  v7 = PlayerInfo;
  if ( PlayerInfo && PlayerInfo->clientPlatform[0] == 2 )
  {
    String = Scr_GetString(scrContext, 0);
    Int = Scr_GetInt(scrContext, 1u);
    v10 = Scr_GetInt(scrContext, 2u);
    v11 = Scr_GetInt(scrContext, 3u);
    v12 = Scr_GetInt(scrContext, 4u);
    v25 = Scr_GetInt(scrContext, 5u);
    v24 = Scr_GetInt(scrContext, 6u);
    v23 = Scr_GetInt(scrContext, 7u);
    v13 = Scr_GetInt(scrContext, 8u);
    MapName = SV_Game_GetMapName();
    v18.m_id = v7->xuid.m_id;
    UniversalId = XUID::GetUniversalId(&v18);
    ScopedCriticalSection::ScopedCriticalSection(&v22, CRITSECT_QQTECH_MATCHDATA, SCOPED_CRITSECT_NORMAL);
    v14 = s_matchdata_queue_size;
    if ( (int)s_matchdata_queue_size < 64 )
      goto LABEL_14;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qqtech\\ac_matchdata.h", 53, ASSERT_TYPE_ASSERT, "(s_matchdata_queue_size < 64)", (const char *)&queryFormat, "s_matchdata_queue_size < AC_MATCHDATA_MAX_QUEUED") )
      __debugbreak();
    v14 = s_matchdata_queue_size;
    if ( (int)s_matchdata_queue_size < 64 )
    {
LABEL_14:
      v15 = s_matchdata_queue[(__int64)v14];
      MatchId = OnlineMatchId::GetMatchId();
      UTC = LiveStorage_GetUTC();
      j_snprintf(v15, 0x200ui64, "{\n\t\"%s\" :\n\t{\n\t\t\"%s\": %llu,\n\t\t\"%s\": %lu,\n\t\t\"%s\": \"%llu\",\n\t\t\"%s\": \"%s\",\n\t\t\"%s\": \"%s\",\n\t\t\"%s\": \"%lu\",\n\t\t\"%s\": \"%lu\",\n\t\t\"%s\": \"%lu\",\n\t\t\"%s\": \"%lu\",\n\t\t\"%s\": \"%lu\",\n\t\t\"%s\": \"%lu\",\n\t\t\"%s\": \"%lu\",\n\t\t\"%s\": \"%lu\"\n\t}\n}\n", "zh5l", "g2p0", UniversalId, "r9ic", UTC, "u3p0", MatchId, "xb9r", MapName, "bjf8", String, "lo0c", Int, "wv8c", v10, "ipo4", v11, "pwb8", v12, "tmr9", v25, "g7c1", v24, "f7fd", v23, "dd6b", v13);
      ++s_matchdata_queue_size;
    }
    ScopedCriticalSection::~ScopedCriticalSection(&v22);
  }
}

/*
==============
GScr_IncrementPersistentStat
==============
*/
void GScr_IncrementPersistentStat(scrContext_t *scrContext)
{
  VariableValue *Variable; 
  unsigned int *v4; 
  scr_entref_t EntityIdRef; 
  gentity_s *v6; 
  gclient_s *client; 
  unsigned int ConstString; 
  unsigned int v9; 
  unsigned int v10; 
  VariableType VariableType; 
  VariableType type; 
  const char *v18; 
  ComErrorCode v19; 
  VariableType v20; 
  VariableValue value; 

  if ( Scr_GetNumParam(scrContext) != 3 )
  {
    Scr_Error(COM_ERR_6310, scrContext, "Usage: IncrementPersistentStat( player, stateName, increment )");
    return;
  }
  Variable = Scr_GetVariable(scrContext, 0);
  v4 = (unsigned int *)Variable;
  if ( Variable->type == VAR_POINTER && GetObjectType(scrContext, Variable->u.intValue) == VAR_ENTITY )
  {
    EntityIdRef = Scr_GetEntityIdRef(scrContext, *v4);
    if ( EntityIdRef.entclass == ENTITY_CLASS_GENTITY )
    {
      if ( EntityIdRef.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 12366, ASSERT_TYPE_ASSERT, "( entref.entnum < ( 2048 ) )", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
        __debugbreak();
      v6 = &g_entities[EntityIdRef.entnum];
      client = v6->client;
      if ( client )
      {
        if ( client->sess.scriptPersId )
        {
          ConstString = Scr_GetConstString(scrContext, 1u);
          v9 = FindVariable(scrContext, v6->client->sess.scriptPersId, ConstString);
          v10 = v9;
          if ( v9 )
          {
            VariableType = GetVariableType(scrContext, v9);
            _RBX = GetVariableValueAddress(scrContext, v10);
            _RAX = Scr_GetVariable(scrContext, 2u);
            if ( VariableType == VAR_INTEGER )
            {
              type = _RAX->type;
              if ( type == VAR_INTEGER )
              {
                _RBX->intValue += _RAX->u.intValue;
                return;
              }
              if ( type == VAR_FLOAT )
              {
                __asm
                {
                  vxorps  xmm0, xmm0, xmm0
                  vcvtsi2ss xmm0, xmm0, dword ptr [rbx]
                  vaddss  xmm1, xmm0, dword ptr [rax]
                }
                value.type = _RAX->type;
                __asm { vmovss  dword ptr [rsp+48h+value.u], xmm1 }
                SetVariableValue(scrContext, v10, &value);
                return;
              }
              v18 = "Persistent stat increment must be int or float";
              v19 = COM_ERR_6311;
            }
            else if ( VariableType == VAR_FLOAT )
            {
              v20 = _RAX->type;
              if ( v20 == VAR_FLOAT )
              {
                __asm
                {
                  vmovss  xmm0, dword ptr [rax]
                  vaddss  xmm1, xmm0, dword ptr [rbx]
                  vmovss  dword ptr [rbx], xmm1
                }
                return;
              }
              if ( v20 == VAR_INTEGER )
              {
                __asm
                {
                  vxorps  xmm0, xmm0, xmm0
                  vcvtsi2ss xmm0, xmm0, dword ptr [rax]
                  vaddss  xmm1, xmm0, dword ptr [rbx]
                  vmovss  dword ptr [rbx], xmm1
                }
                return;
              }
              v18 = "Persistent stat increment must be int or float";
              v19 = COM_ERR_6338;
            }
            else
            {
              v18 = "Persistent stat must be int or float to increment";
              v19 = COM_ERR_6312;
            }
            Scr_Error(v19, scrContext, v18);
          }
        }
      }
    }
  }
}

/*
==============
GScr_MainMP_IsDismembermentEnabled
==============
*/
void GScr_MainMP_IsDismembermentEnabled(scrContext_t *scrContext)
{
  int v1; 
  unsigned int v3; 
  SvClient *CommonClient; 

  v1 = 0;
  v3 = 0;
  if ( (int)SvClient::ms_clientCount <= 0 )
  {
LABEL_8:
    v1 = 1;
  }
  else
  {
    while ( 1 )
    {
      if ( (_BYTE)SvClient::ms_allocatedType != HALF_HALF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_mp\\sv_client_mp.h", 957, ASSERT_TYPE_ASSERT, "( ms_allocatedType == ALLOCATION_TYPE )", (const char *)&queryFormat, "ms_allocatedType == ALLOCATION_TYPE") )
        __debugbreak();
      CommonClient = SvClient::GetCommonClient(v3);
      if ( CommonClient->state >= CS_CONNECTED && !LOBYTE(CommonClient[1116].lastUsercmd.commandTime) )
        break;
      if ( (int)++v3 >= (int)SvClient::ms_clientCount )
        goto LABEL_8;
    }
  }
  Scr_AddBool(scrContext, v1);
}

/*
==============
GScr_MainMP_IsDismembermentEnabledForPlayer
==============
*/
void GScr_MainMP_IsDismembermentEnabledForPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  int v2; 
  unsigned int entnum; 
  gentity_s *v5; 
  const char *v6; 
  unsigned int number; 
  SvClient *CommonClient; 

  v2 = 0;
  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v5 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 12469, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v5 = &g_entities[entnum];
    if ( !v5->client )
    {
      v6 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v6);
    }
  }
  number = v5->s.number;
  if ( (_BYTE)SvClient::ms_allocatedType != HALF_HALF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_mp\\sv_client_mp.h", 957, ASSERT_TYPE_ASSERT, "( ms_allocatedType == ALLOCATION_TYPE )", (const char *)&queryFormat, "ms_allocatedType == ALLOCATION_TYPE") )
    __debugbreak();
  CommonClient = SvClient::GetCommonClient(number);
  if ( CommonClient->state >= CS_CONNECTED )
    LOBYTE(v2) = LOBYTE(CommonClient[1116].lastUsercmd.commandTime) != 0;
  Scr_AddBool(scrContext, v2);
}

/*
==============
GScr_IsPlayerHeadless
==============
*/
void GScr_IsPlayerHeadless(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  BG_SynchronizedPlayerInfo *PlayerInfo; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 12499, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  PlayerInfo = SvClientMP::GetPlayerInfo(v4->s.number);
  if ( !PlayerInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 12501, ASSERT_TYPE_ASSERT, "( storedPlayerInfo )", (const char *)&queryFormat, "storedPlayerInfo") )
    __debugbreak();
  Scr_AddBool(scrContext, PlayerInfo->isHeadless);
}

/*
==============
GScr_Knockback
==============
*/
void GScr_Knockback(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  scr_string_t targetname; 
  const char *v11; 
  const char *v12; 
  const char *v20; 
  gentity_s *v21; 
  const char *v23; 
  ComErrorCode v24; 
  char *fmt; 
  EntityClass entclass; 
  vec3_t vectorValue; 
  char v55; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-28h], xmm6
    vmovaps xmmword ptr [rax-38h], xmm7
    vmovaps xmmword ptr [rax-48h], xmm8
  }
  entclass = entref.entclass;
  entnum = entref.entnum;
  _RDI = GetEntity(entref);
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 538, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClientOrAgent(_RDI) )
  {
    targetname = _RDI->targetname;
    if ( targetname )
      v11 = SL_ConvertToString(targetname);
    else
      v11 = "<undefined>";
    v12 = SL_ConvertToString(_RDI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rdi+134h]
      vmovss  xmm2, dword ptr [rdi+130h]
      vmovss  xmm0, dword ptr [rdi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+0A8h+fmt], xmm0
    }
    v20 = j_va("Knockback(): Only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, fmt, v12, v11);
    Scr_Error(COM_ERR_2977, scrContext, v20);
  }
  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_Error(COM_ERR_2978, scrContext, "Knockback() USAGE: <player> Knockback(<velocity dir>,<velocity magnitud>)\n");
  if ( entclass )
  {
    v23 = "not an entity";
    v24 = COM_ERR_3682;
    goto LABEL_19;
  }
  if ( entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 548, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v21 = &g_entities[entnum];
  _RDI = &v21->client->ps;
  if ( !_RDI )
  {
    _RDI = &v21->agent->playerState;
    if ( !_RDI )
    {
      v23 = j_va("entity %i is not a player or agent", entnum);
      v24 = COM_ERR_3679;
LABEL_19:
      Scr_ObjectError(v24, scrContext, v23);
      _RDI = NULL;
    }
  }
  Scr_GetVector(scrContext, 0, &vectorValue);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm
  {
    vmovss  xmm5, dword ptr [rsp+0A8h+vectorValue]
    vmovss  xmm6, dword ptr [rsp+0A8h+vectorValue+4]
    vmovss  xmm7, dword ptr [rsp+0A8h+vectorValue+8]
    vmovaps xmm8, xmm0
    vmulss  xmm2, xmm5, xmm5
    vmulss  xmm1, xmm6, xmm6
    vaddss  xmm3, xmm2, xmm1
    vmulss  xmm2, xmm7, xmm7
    vaddss  xmm1, xmm3, xmm2
    vmovss  xmm2, cs:__real@3f800000
    vsqrtss xmm4, xmm1, xmm1
    vcmpless xmm1, xmm4, cs:__real@80000000
    vblendvps xmm0, xmm4, xmm2, xmm1
    vdivss  xmm3, xmm2, xmm0
    vmulss  xmm0, xmm5, xmm3
    vmulss  xmm4, xmm0, xmm8
    vmovss  dword ptr [rsp+0A8h+vectorValue], xmm4
    vmulss  xmm1, xmm6, xmm3
    vmulss  xmm0, xmm1, xmm8
    vmovss  dword ptr [rsp+0A8h+vectorValue+4], xmm0
    vmulss  xmm2, xmm7, xmm3
    vmulss  xmm1, xmm2, xmm8
    vmovss  dword ptr [rsp+0A8h+vectorValue+8], xmm1
    vmovss  dword ptr [rdi+3Ch], xmm4
    vmovss  xmm0, dword ptr [rsp+0A8h+vectorValue+4]
    vmovss  dword ptr [rdi+40h], xmm0
    vmovss  xmm1, dword ptr [rsp+0A8h+vectorValue+8]
    vmovss  dword ptr [rdi+44h], xmm1
  }
  BG_SetKnockbackFlag(_RDI);
  _R11 = &v55;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, [rsp+0A8h+var_38]
    vmovaps xmm8, xmmword ptr [r11-30h]
  }
}

/*
==============
GScr_SetOnWallAnimConditional
==============
*/
void GScr_SetOnWallAnimConditional(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v16; 
  gentity_s *v17; 
  playerState_s *p_ps; 
  const char *v19; 
  ComErrorCode v20; 
  bool v21; 
  char *fmt; 
  EntityClass entclass; 

  entclass = entref.entclass;
  entnum = entref.entnum;
  _RDI = GetEntity(entref);
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 578, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClientOrAgent(_RDI) )
  {
    targetname = _RDI->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(_RDI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rdi+134h]
      vmovss  xmm2, dword ptr [rdi+130h]
      vmovss  xmm0, dword ptr [rdi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+58h+fmt], xmm0
    }
    v16 = j_va("SetOnWallAnimConditional(): Only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, fmt, v7, v6);
    Scr_Error(COM_ERR_2979, scrContext, v16);
  }
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_2980, scrContext, "SetOnWallAnimConditional() USAGE: <player> SetOnWallAnimConditional(<enable>)\n");
  if ( entclass )
  {
    v19 = "not an entity";
    v20 = COM_ERR_3682;
    goto LABEL_19;
  }
  if ( entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 588, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v17 = &g_entities[entnum];
  p_ps = &v17->client->ps;
  if ( !p_ps )
  {
    p_ps = &v17->agent->playerState;
    if ( !p_ps )
    {
      v19 = j_va("entity %i is not a player or agent", entnum);
      v20 = COM_ERR_3679;
LABEL_19:
      Scr_ObjectError(v20, scrContext, v19);
      p_ps = NULL;
    }
  }
  v21 = 0;
  if ( Scr_GetType(scrContext, 0) )
    v21 = Scr_GetInt(scrContext, 0) > 0;
  BG_SetOnWallAnimFlag(p_ps, v21);
}

/*
==============
GScr_SetSeatedAnimConditional
==============
*/
void GScr_SetSeatedAnimConditional(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  PMoveFlagsMP v4; 
  scr_string_t targetname; 
  const char *v7; 
  const char *v8; 
  const char *v17; 
  gentity_s *v18; 
  playerState_s *p_ps; 
  const char *v20; 
  ComErrorCode v21; 
  bool v22; 
  scr_string_t ConstString; 
  char *fmt; 
  EntityClass entclass; 

  entclass = entref.entclass;
  entnum = entref.entnum;
  v4 = ANIM_LINKEDTO_NONE;
  _RSI = GetEntity(entref);
  if ( !_RSI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 623, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClientOrAgent(_RSI) )
  {
    targetname = _RSI->targetname;
    if ( targetname )
      v7 = SL_ConvertToString(targetname);
    else
      v7 = "<undefined>";
    v8 = SL_ConvertToString(_RSI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rsi+134h]
      vmovss  xmm2, dword ptr [rsi+130h]
      vmovss  xmm0, dword ptr [rsi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+58h+fmt], xmm0
    }
    v17 = j_va("SetSeatedAnimConditional(): Only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, fmt, v8, v7);
    Scr_Error(COM_ERR_2981, scrContext, v17);
  }
  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_Error(COM_ERR_2982, scrContext, "SetSeatedAnimConditional() USAGE: <player> SetSeatedAnimConditional(<type>,<enable>)\n");
  if ( entclass )
  {
    v20 = "not an entity";
    v21 = COM_ERR_3682;
    goto LABEL_19;
  }
  if ( entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 633, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v18 = &g_entities[entnum];
  p_ps = &v18->client->ps;
  if ( !p_ps )
  {
    p_ps = &v18->agent->playerState;
    if ( !p_ps )
    {
      v20 = j_va("entity %i is not a player or agent", entnum);
      v21 = COM_ERR_3679;
LABEL_19:
      Scr_ObjectError(v21, scrContext, v20);
      p_ps = NULL;
    }
  }
  v22 = 0;
  if ( Scr_GetType(scrContext, 0) == VAR_UNDEFINED )
    Scr_Error(COM_ERR_2983, scrContext, "SetSeatedAnimConditional() USAGE: <player> SetSeatedAnimConditional(<type>,<enable>). Valid types are \"seat\" and \"zipline\".\n");
  if ( Scr_GetType(scrContext, 1u) )
    v22 = Scr_GetInt(scrContext, 1u) > 0;
  ConstString = Scr_GetConstString(scrContext, 0);
  if ( ConstString == scr_const.animLinkedToSeat )
  {
    v4 = 59;
  }
  else if ( ConstString == scr_const.animLinkedToZipline )
  {
    v4 = 60;
  }
  else
  {
    Scr_Error(COM_ERR_2984, scrContext, "SetSeatedAnimConditional() USAGE: <player> SetSeatedAnimConditional(<type>,<enable>). Valid types are \"seat\" and \"zipline\".\n");
  }
  if ( v22 )
    BG_ClearLinkedToAnimFlags(p_ps);
  BG_SetLinkedToAnimFlag(p_ps, v4, v22);
}

/*
==============
GScr_OverrideVehicleSeatAnimConditionals
==============
*/
void GScr_OverrideVehicleSeatAnimConditionals(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  scr_string_t targetname; 
  const char *v6; 
  const char *v7; 
  const char *v16; 
  gentity_s *v17; 
  const char *v18; 
  ComErrorCode v19; 
  unsigned int v20; 
  unsigned int Int; 
  const char *v22; 
  scr_string_t ConstLowercaseString; 
  const char *v24; 
  const char *v25; 
  gclient_s *v26; 
  const char *v27; 
  const VehicleDef *ServerDef; 
  const char *v29; 
  animScriptVehicleType_t v30; 
  animScriptVehicleSeat_t v31; 
  gclient_s *client; 
  char *fmt; 
  scr_entref_t outIndex; 

  outIndex = entref;
  entnum = entref.entnum;
  _RDI = GetEntity(entref);
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 695, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClientOrAgent(_RDI) )
  {
    targetname = _RDI->targetname;
    if ( targetname )
      v6 = SL_ConvertToString(targetname);
    else
      v6 = "<undefined>";
    v7 = SL_ConvertToString(_RDI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rdi+134h]
      vmovss  xmm2, dword ptr [rdi+130h]
      vmovss  xmm0, dword ptr [rdi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+58h+fmt], xmm0
    }
    v16 = j_va("SetVehicleSeatAnimConditionals(): Only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entnum, _R8, _R9, fmt, v7, v6);
    Scr_Error(COM_ERR_6212, scrContext, v16);
  }
  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_Error(COM_ERR_6213, scrContext, "SetVehicleSeatAnimConditionals() USAGE: <player> SetVehicleSeatAnimConditionals( <vehicletype>, <seat> )\n");
  if ( outIndex.entclass )
  {
    v18 = "not an entity";
    v19 = COM_ERR_3682;
    goto LABEL_19;
  }
  if ( entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 707, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v17 = &g_entities[entnum];
  if ( !v17->client && !v17->agent )
  {
    v18 = j_va("entity %i is not a player or agent", entnum);
    v19 = COM_ERR_3679;
LABEL_19:
    Scr_ObjectError(v19, scrContext, v18);
  }
  v20 = 0;
  if ( Scr_GetType(scrContext, 0) == VAR_UNDEFINED )
    Scr_Error(COM_ERR_6214, scrContext, "SetVehicleSeatAnimConditionals() USAGE: <player> SetVehicleSeatAnimConditionals( <vehicletype>, <seat> )\n");
  if ( Scr_GetType(scrContext, 1u) )
  {
    Int = Scr_GetInt(scrContext, 1u);
    v20 = Int;
    if ( Int > 9 )
    {
      v22 = j_va("SetVehicleSeatAnimConditionals(): cannot assign a seat of index %i! Must be a 0-9 index.\n", Int);
      Scr_Error(COM_ERR_6215, scrContext, v22);
    }
  }
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  v24 = SL_ConvertToString(ConstLowercaseString);
  v25 = v24;
  if ( *v24 )
  {
    if ( !G_Vehicle_GetServerDefIndex(v24, (unsigned int *)&outIndex) )
    {
      v27 = j_va("SetVehicleSeatAnimConditionals(): could not find server def index for vehicle with asset name: %s\n", v25);
      Scr_Error(COM_ERR_6216, scrContext, v27);
    }
    ServerDef = G_Vehicle_GetServerDef(outIndex.entnum);
    if ( !ServerDef )
    {
      v29 = j_va("SetVehicleSeatAnimConditionals(): could not find VehicleDef for vehicle of type: %s\n", v25);
      Scr_Error(COM_ERR_6217, scrContext, v29);
    }
    v30 = BG_VehicleOccupancy_MapVehicleProfileToVehicleType((const VehiclePhysicsAnimProfile)ServerDef->vehiclePhysicsDef.physics_animProfile);
    v31 = v20 + 1;
    client = _RDI->client;
    if ( client )
    {
      client->animOverrideVehicleType = v30;
      _RDI->client->animOverrideVehicleSeat = v31;
    }
    else
    {
      _RDI->agent->animOverrideVehicleType = v30;
      _RDI->agent->animOverrideVehicleSeat = v31;
    }
  }
  else
  {
    v26 = _RDI->client;
    if ( v26 )
    {
      v26->animOverrideVehicleType = VEHICLE_TYPE_UNUSED;
      _RDI->client->animOverrideVehicleSeat = VEHICLE_SEAT_UNUSED;
    }
    else
    {
      _RDI->agent->animOverrideVehicleType = VEHICLE_TYPE_UNUSED;
      _RDI->agent->animOverrideVehicleSeat = VEHICLE_SEAT_UNUSED;
    }
  }
}

/*
==============
GScr_SpawnPlane
==============
*/
void GScr_SpawnPlane(scrContext_t *scrContext)
{
  gentity_s *Entity; 
  scr_string_t ConstString; 
  int Int; 
  const char *String; 
  const char *v6; 
  const char *v7; 
  const char *v8; 
  signed __int64 v13; 
  const char *v14; 
  const char *v15; 
  __int64 v16; 
  __int64 v17; 
  unsigned int outIndex; 
  unsigned int v19; 
  vec3_t vectorValue; 

  Entity = GScr_GetEntity(0);
  if ( !Entity->client )
    Scr_ParamError(COM_ERR_2985, scrContext, 0, "Owner entity is not a player");
  ConstString = Scr_GetConstString(scrContext, 1u);
  Scr_GetVector(scrContext, 2u, &vectorValue);
  Int = 0;
  if ( Scr_GetNumParam(scrContext) > 3 && Scr_GetType(scrContext, 3u) )
  {
    String = Scr_GetString(scrContext, 3u);
    if ( !NetConstStrings_GetIndexPlusOneFromName(NETCONSTSTRINGTYPE_MINIMAPICON, String, &outIndex) )
    {
      v6 = j_va("Couldn't find icon index for friendly icon '%s'", String);
      Scr_ParamError(COM_ERR_2986, scrContext, 3u, v6);
    }
    if ( !outIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 814, ASSERT_TYPE_ASSERT, "( friendIconIndex != 0 )", (const char *)&queryFormat, "friendIconIndex != 0") )
      __debugbreak();
  }
  else
  {
    outIndex = 0;
  }
  if ( Scr_GetNumParam(scrContext) > 4 && Scr_GetType(scrContext, 4u) )
  {
    v7 = Scr_GetString(scrContext, 4u);
    if ( !NetConstStrings_GetIndexPlusOneFromName(NETCONSTSTRINGTYPE_MINIMAPICON, v7, &v19) )
    {
      v8 = j_va("Couldn't find icon index for enemy icon '%s'", v7);
      Scr_ParamError(COM_ERR_2987, scrContext, 4u, v8);
    }
    if ( !v19 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 828, ASSERT_TYPE_ASSERT, "( enemyIconIndex != 0 )", (const char *)&queryFormat, "enemyIconIndex != 0") )
      __debugbreak();
  }
  else
  {
    v19 = 0;
  }
  if ( Scr_GetNumParam(scrContext) > 5 )
    Int = Scr_GetInt(scrContext, 5u);
  _RDI = G_Utils_SpawnEntity();
  Scr_SetString(&_RDI->script_classname, ConstString);
  __asm
  {
    vmovss  xmm0, dword ptr [rsp+98h+vectorValue]
    vmovss  dword ptr [rdi+130h], xmm0
    vmovss  xmm1, dword ptr [rsp+98h+vectorValue+4]
    vmovss  dword ptr [rdi+134h], xmm1
    vmovss  xmm0, dword ptr [rsp+98h+vectorValue+8]
    vmovss  dword ptr [rdi+138h], xmm0
  }
  _RDI->spawnflags = Int;
  if ( G_Spawn_CallForEntity(_RDI) )
  {
    _RDI->s.eType = ET_PLANE;
    v13 = Entity->client - level.clients;
    if ( (unsigned __int64)(v13 + 0x80000000i64) > 0xFFFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "int __cdecl truncate_cast_impl<int,__int64>(__int64)", "signed", (int)v13, "signed", Entity->client - level.clients) )
      __debugbreak();
    _RDI->s.lerp.u.anonymous.data[0] = v13;
    if ( (unsigned int)v13 >= level.maxclients )
    {
      LODWORD(v17) = level.maxclients;
      LODWORD(v16) = v13;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 853, ASSERT_TYPE_ASSERT, "(unsigned)( ent->s.lerp.u.plane.ownerNum ) < (unsigned)( level.maxclients )", "ent->s.lerp.u.plane.ownerNum doesn't index level.maxclients\n\t%i not in [0, %i)", v16, v17) )
        __debugbreak();
    }
    _RDI->s.lerp.u.anonymous.data[2] = outIndex;
    _RDI->s.lerp.u.anonymous.data[1] = v19;
    GScr_AddEntity(_RDI);
  }
  else
  {
    if ( !GUtils::ms_gUtils && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_utils.h", 112, ASSERT_TYPE_ASSERT, "( ms_gUtils )", (const char *)&queryFormat, "ms_gUtils") )
      __debugbreak();
    GUtils::ms_gUtils->FreeEntity(GUtils::ms_gUtils, _RDI);
    v14 = SL_ConvertToString(ConstString);
    v15 = j_va("unable to spawn \"%s\" entity", v14);
    Scr_Error(COM_ERR_2988, scrContext, v15);
  }
}

/*
==============
GScr_SpawnHelicopter
==============
*/
void GScr_SpawnHelicopter(scrContext_t *scrContext)
{
  gentity_s *Entity; 
  const char *String; 
  const char *v4; 
  vec3_t vectorValue; 
  vec3_t v13; 

  Entity = GScr_GetEntity(0);
  if ( !Entity->client )
    Scr_ParamError(COM_ERR_2989, scrContext, 0, "Owner entity is not a player");
  Scr_GetVector(scrContext, 1u, &vectorValue);
  Scr_GetVector(scrContext, 2u, &v13);
  String = Scr_GetString(scrContext, 3u);
  v4 = Scr_GetString(scrContext, 4u);
  if ( G_VehicleHeliMP_CanSpawn() )
  {
    _RBX = G_Utils_SpawnEntity();
    Scr_SetString(&_RBX->classname, scr_const.script_vehicle);
    Scr_SetString(&_RBX->script_classname, scr_const.script_vehicle);
    __asm
    {
      vmovss  xmm0, dword ptr [rsp+58h+vectorValue]
      vmovss  dword ptr [rbx+130h], xmm0
      vmovss  xmm1, dword ptr [rsp+58h+vectorValue+4]
      vmovss  dword ptr [rbx+134h], xmm1
      vmovss  xmm0, dword ptr [rsp+58h+vectorValue+8]
      vmovss  dword ptr [rbx+138h], xmm0
      vmovss  xmm1, dword ptr [rsp+58h+var_28]
      vmovss  dword ptr [rbx+13Ch], xmm1
      vmovss  xmm0, dword ptr [rsp+58h+var_28+4]
      vmovss  dword ptr [rbx+140h], xmm0
      vmovss  xmm1, dword ptr [rsp+58h+var_28+8]
      vmovss  dword ptr [rbx+144h], xmm1
    }
    G_VehicleHeliMP_Spawn(_RBX, Entity, String, v4);
    GScr_AddEntity(_RBX);
  }
  else
  {
    Com_PrintError(1, "Can't spawn extra helicopter (%s %s)\n", String, v4);
    Scr_Error(COM_ERR_2990, scrContext, "Can't spawn extra helicopter. In ship this will return 'undefined' instead of a script error.");
    Scr_AddUndefined(scrContext);
  }
}

/*
==============
GScr_SpawnImpulseField
==============
*/
void GScr_SpawnImpulseField(scrContext_t *scrContext)
{
  const dvar_t *v1; 
  const char *v3; 
  VariableType Type; 
  bool v5; 
  const gentity_s *Entity; 
  gentity_s *v9; 
  GWeaponMap *Instance; 
  bool outIsAlternate; 
  vec3_t vectorValue; 
  Weapon outWeapon; 

  v1 = DCONST_DVARBOOL_bg_impulse_field_instrumentation_enabled;
  if ( !DCONST_DVARBOOL_bg_impulse_field_instrumentation_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_impulse_field_instrumentation_enabled") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  if ( v1->current.enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 939, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Script spawned an impulse field.") )
    __debugbreak();
  if ( G_MainMP_GetImpulseFieldEntityCount(LOCAL_CLIENT_INVALID) == 24 )
  {
    v3 = j_va("You cannot create more than %d impulse fields.", 24i64);
    Scr_Error(COM_ERR_2991, scrContext, v3);
    return;
  }
  if ( Scr_GetNumParam(scrContext) != 3 )
  {
    Scr_Error(COM_ERR_2992, scrContext, "Incorrect number of parameters. Correct usage: SpawnImpulseField( <owner>, <weapon>, <origin> )");
    return;
  }
  Type = Scr_GetType(scrContext, 0);
  v5 = Type == VAR_UNDEFINED;
  if ( Type && Scr_GetType(scrContext, 0) == VAR_POINTER && Scr_GetPointerType(scrContext, 0) == VAR_ENTITY )
  {
    Entity = GScr_GetEntity(0);
  }
  else
  {
    if ( !v5 )
    {
      Scr_Error(COM_ERR_2993, scrContext, "First argument must be either the owner entity or undefined.");
      return;
    }
    Entity = NULL;
  }
  GScr_Main_GetWeaponParam(scrContext, 1u, &outWeapon, &outIsAlternate);
  if ( outWeapon.weaponIdx )
  {
    Scr_GetVector(scrContext, 2u, &vectorValue);
    _RAX = G_Utils_SpawnEntity();
    __asm { vmovss  xmm0, dword ptr [rsp+0A8h+vectorValue] }
    v9 = _RAX;
    __asm
    {
      vmovss  dword ptr [rax+130h], xmm0
      vmovss  xmm1, dword ptr [rsp+0A8h+vectorValue+4]
      vmovss  dword ptr [rax+134h], xmm1
      vmovss  xmm0, dword ptr [rsp+0A8h+vectorValue+8]
      vmovss  dword ptr [rax+138h], xmm0
    }
    Scr_SetString(&_RAX->classname, scr_const.script_impulse_field);
    Scr_SetString(&v9->script_classname, scr_const.script_impulse_field);
    G_ScrMover_InitScriptMover(v9);
    if ( Entity )
    {
      EntHandle::setEnt(&v9->r.ownerNum, Entity);
      EntHandle::setEnt(&v9->parent, Entity);
      v9->s.otherEntityNum = Entity->s.number;
    }
    Instance = GWeaponMap::GetInstance();
    if ( !Instance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 447, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    if ( !v9 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 448, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
      __debugbreak();
    Instance->SetWeapon(Instance, &v9->s.weaponHandle, &outWeapon);
    v9->s.lerp.u.anonymous.data[2] |= 4u;
    SV_LinkEntity(v9);
    GScr_AddEntity(v9);
  }
  else
  {
    Scr_ParamError(COM_ERR_2994, scrContext, 0, "Invalid weapon.");
    Scr_AddUndefined(scrContext);
  }
}

/*
==============
GScr_SetPlayerGhost
==============
*/
void GScr_SetPlayerGhost(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *client; 
  const char *v6; 
  ComErrorCode v7; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *v8; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 1028, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = (GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *)v4->client;
  if ( !client )
  {
    client = (GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *)v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v7, scrContext, v6);
      client = NULL;
    }
  }
  v8 = client + 94;
  if ( Scr_GetInt(scrContext, 0) )
    GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(v8, GameModeFlagValues::ms_mpValue, 0x1Au);
  else
    GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(v8, GameModeFlagValues::ms_mpValue, 0x1Au);
}

/*
==============
GScr_SetPlayerAdvancedUAVDot
==============
*/
void GScr_SetPlayerAdvancedUAVDot(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *v4; 
  const char *v5; 
  ComErrorCode v6; 
  scr_string_t targetname; 
  const char *v9; 
  const char *v10; 
  const char *v19; 
  int Int; 
  __int16 playerFlags; 
  __int16 v22; 
  __int16 v23; 
  char *fmt; 

  if ( entref.entclass )
  {
    v5 = "not an entity";
    v6 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 1055, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entref.entnum];
  if ( !v4->client && !v4->agent )
  {
    v5 = j_va("entity %i is not a player or agent", entref.entnum);
    v6 = COM_ERR_3679;
LABEL_9:
    Scr_ObjectError(v6, scrContext, v5);
  }
  _RDI = GetEntity(entref);
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 1060, ASSERT_TYPE_ASSERT, "( ent )", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( !G_Utils_IsClientOrAgent(_RDI) )
  {
    targetname = _RDI->targetname;
    if ( targetname )
      v9 = SL_ConvertToString(targetname);
    else
      v9 = "<undefined>";
    v10 = SL_ConvertToString(_RDI->classname);
    __asm
    {
      vmovss  xmm3, dword ptr [rdi+134h]
      vmovss  xmm2, dword ptr [rdi+130h]
      vmovss  xmm0, dword ptr [rdi+138h]
      vcvtss2sd xmm3, xmm3, xmm3
      vcvtss2sd xmm2, xmm2, xmm2
      vcvtss2sd xmm0, xmm0, xmm0
      vmovq   r9, xmm3
      vmovq   r8, xmm2
      vmovsd  [rsp+48h+fmt], xmm0
    }
    v19 = j_va("SetPlayerAdvancedUAVDot(): Only valid on players or agents; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", entref.entnum, _R8, _R9, fmt, v10, v9);
    Scr_Error(COM_ERR_6168, scrContext, v19);
  }
  Int = Scr_GetInt(scrContext, 0);
  playerFlags = _RDI->s.lerp.u.player.playerFlags;
  v22 = playerFlags | 0x4000;
  v23 = playerFlags & 0xBFFF;
  if ( Int )
    v23 = v22;
  _RDI->s.lerp.u.player.playerFlags = v23;
}

/*
==============
Scr_SysPrint
==============
*/
void Scr_SysPrint(scrContext_t *scrContext)
{
  signed int v2; 
  int NumParam; 
  const char *DebugString; 

  v2 = 0;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam > 0 )
  {
    do
    {
      DebugString = Scr_GetDebugString(scrContext, v2);
      Compass_Print(DebugString);
      Sys_Print("\n");
      ++v2;
    }
    while ( v2 < NumParam );
  }
}

/*
==============
GScr_RemoveAllCorpses
==============
*/
void GScr_RemoveAllCorpses(scrContext_t *scrContext)
{
  G_MainMP_FreeAllPlayerCorpses(1);
  G_MainMP_FreeAllAgentCorpses();
}

/*
==============
GScr_SetOmnvarForAllClients
==============
*/
void GScr_SetOmnvarForAllClients(scrContext_t *scrContext)
{
  const char *String; 
  unsigned int IndexByName; 
  const char *v4; 
  const OmnvarDef *Def; 
  const char *v6; 
  int maxclients; 
  int v8; 
  __int64 v9; 
  OmnvarData *Data; 

  String = Scr_GetString(scrContext, 0);
  IndexByName = BG_Omnvar_GetIndexByName(String);
  if ( IndexByName == -1 )
  {
    v4 = j_va("SetOmnvarForAllClients - '%s' not found", String);
    Scr_Error(COM_ERR_2995, scrContext, v4);
  }
  Def = BG_Omnvar_GetDef(IndexByName);
  if ( (Def->flags & 2) == 0 )
  {
    v6 = j_va("SetOmnvarForAllClients '%s' must be done on a client-scope Omnvar", String);
    Scr_Error(COM_ERR_2996, scrContext, v6);
  }
  maxclients = level.maxclients;
  v8 = 0;
  if ( level.maxclients > 0 )
  {
    v9 = 0i64;
    do
    {
      if ( level.clients[v9].sess.connected == CON_CONNECTED )
      {
        Data = G_Omnvar_GetData(IndexByName, v8, &level.clients[v9].ps);
        GScr_SetOmnvarInternal(scrContext, Def, Data, 1);
        maxclients = level.maxclients;
      }
      ++v8;
      ++v9;
    }
    while ( v8 < maxclients );
  }
}

/*
==============
ScrCmd_SetSoundBlend
==============
*/
void ScrCmd_SetSoundBlend(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *String; 
  unsigned __int16 v9; 
  const char *v10; 
  unsigned __int16 v11; 
  char v12; 
  char v13; 

  __asm { vmovaps [rsp+38h+var_18], xmm6 }
  Entity = GetEntity(entref);
  _RBX = Entity;
  if ( Entity->s.eType != ET_SOUND || Entity->s.lerp.u.anonymous.data[0] )
    Scr_Error(COM_ERR_3011, scrContext, "Entity is not a sound_blend\n");
  String = Scr_GetString(scrContext, 0);
  v9 = G_CStringMP_LoopedSoundAliasIndex(String);
  v10 = Scr_GetString(scrContext, 1u);
  v11 = G_CStringMP_LoopedSoundAliasIndex(v10);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
  __asm
  {
    vxorps  xmm1, xmm1, xmm1
    vcomiss xmm0, xmm1
    vmovaps xmm6, xmm0
  }
  if ( v12 )
    goto LABEL_6;
  __asm { vcomiss xmm0, cs:__real@3f800000 }
  if ( !(v12 | v13) )
LABEL_6:
    Scr_Error(COM_ERR_3012, scrContext, "Lerp must be between 0.0f and 1.0f\n");
  __asm
  {
    vmovss  dword ptr [rbx+60h], xmm6
    vmovaps xmm6, [rsp+38h+var_18]
  }
  _RBX->s.lerp.u.player.torsoPitchPacked = v9;
  _RBX->s.lerp.u.actor.lookAtEntityNum = v11;
  *(_QWORD *)&_RBX->s.lerp.u.scriptMover.animIndex = 0i64;
}

/*
==============
ScrCmd_PlaySoundOnMovingEnt
==============
*/
void ScrCmd_PlaySoundOnMovingEnt(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *String; 
  const char *v6; 
  const char *v7; 
  const SndAliasList *Alias; 
  const char *v9; 
  const char *v10; 
  unsigned __int16 v11; 
  const char *v12; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_3014, scrContext, "Usage: PlaySoundOnMovingEnt( <aliasname> );");
  Entity = GetEntity(entref);
  String = Scr_GetString(scrContext, 0);
  if ( (Entity->r.svFlags & 1) != 0 )
  {
    v6 = SL_ConvertToString(Entity->classname);
    v7 = j_va("PlaySoundOnMovingEnt called on a server only entity of type %s.", v6);
    Scr_Error(COM_ERR_3015, scrContext, v7);
  }
  Alias = SND_FindAlias(String);
  if ( !Alias )
  {
    v9 = j_va("unknown sound alias '%s'", String);
    Scr_ParamError(COM_ERR_3016, scrContext, 0, v9);
  }
  if ( Com_IsSoundAliasLooping(Alias) )
  {
    v10 = j_va("'%s' is a looping alias, use 'playloopsound' instead", String);
    Scr_ParamError(COM_ERR_3017, scrContext, 0, v10);
  }
  v11 = G_CStringMP_SoundAliasIndex(String);
  if ( (unsigned __int16)(v11 - 1) > 0x7FFFu )
  {
    v12 = j_va("'%s' does has not have a valid index (%i)", String, v11);
    Scr_ParamError(COM_ERR_3018, scrContext, 0, v12);
  }
  G_Utils_AddEvent(Entity, 3u, v11);
}

/*
==============
ScrCmd_PlaySoundAtPos
==============
*/
void ScrCmd_PlaySoundAtPos(scrContext_t *scrContext)
{
  unsigned int NumParam; 
  const char *v3; 
  const char *String; 
  vec3_t vectorValue; 

  if ( Scr_GetNumParam(scrContext) != 2 )
  {
    NumParam = Scr_GetNumParam(scrContext);
    v3 = j_va("playsoundatpos needs 2 parameters - you had %i parameters", NumParam);
    Scr_Error(COM_ERR_3019, scrContext, v3);
  }
  Scr_GetVector(scrContext, 0, &vectorValue);
  String = Scr_GetString(scrContext, 1u);
  ScrCmd_PlaySoundAtPosInternal(scrContext, &vectorValue, String);
}

/*
==============
GScr_TurretGetAim
==============
*/
void GScr_TurretGetAim(scrContext_t *scrContext, scr_entref_t entref)
{
  ;
}

/*
==============
ScrCmd_IsThirdPersonCamVehicle
==============
*/
void ScrCmd_IsThirdPersonCamVehicle(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  const playerState_s *EntityPlayerState; 
  GHandler *Handler; 
  bool ShouldHandleThirdPersonVehicleCamera; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 1824, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  EntityPlayerState = G_GetEntityPlayerState(v4);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 1827, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  Handler = GHandler::getHandler();
  ShouldHandleThirdPersonVehicleCamera = BG_ShouldHandleThirdPersonVehicleCamera(EntityPlayerState, Handler);
  Scr_AddBool(scrContext, ShouldHandleThirdPersonVehicleCamera);
}

/*
==============
ScrCmd_SetThirdPersonCamVehicle
==============
*/
void ScrCmd_SetThirdPersonCamVehicle(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  playerState_s *EntityPlayerState; 
  unsigned int NumParam; 
  const char *v8; 
  int Int; 
  unsigned int v10; 
  unsigned int v11; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 1845, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  EntityPlayerState = G_GetEntityPlayerState(v4);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 1848, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  if ( Scr_GetNumParam(scrContext) != 1 )
  {
    NumParam = Scr_GetNumParam(scrContext);
    v8 = j_va("SetThirdPersonCamVehicle needs 1 parameter - you had %i parameters", NumParam);
    Scr_Error(COM_ERR_3023, scrContext, v8);
  }
  Int = Scr_GetInt(scrContext, 0);
  v10 = EntityPlayerState->pm_flags.m_flags[1];
  if ( Int )
    v11 = v10 | 0x1000;
  else
    v11 = v10 & 0xFFFFEFFF;
  EntityPlayerState->pm_flags.m_flags[1] = v11;
}

/*
==============
ScrCmd_PlaySoundToTeam
==============
*/
void ScrCmd_PlaySoundToTeam(scrContext_t *scrContext, scr_entref_t entref)
{
  scr_entref_t v2; 
  gentity_s *Entity; 
  char v5; 
  gentity_s *v6; 
  const char *String; 
  gentity_s *v8; 
  gentity_s *v9; 
  scr_string_t ConstString; 
  const char *v11; 
  const char *v12; 
  unsigned int entnum; 
  const char *v14; 
  const char *v15; 
  signed int v16; 
  gentity_s *v17; 
  gentity_s *v18; 
  const char *v19; 
  bitarray_base<bitarray<224> > *p_clientMask; 
  gentity_s *v21; 
  __int64 v22; 
  __int64 v23; 
  __int64 v24; 
  __int64 v25; 
  scr_entref_t entrefa; 

  v2 = entref;
  entrefa = entref;
  if ( Scr_GetNumParam(scrContext) > 3 && Scr_GetType(scrContext, 3u) )
  {
    Entity = GScr_GetEntity(3u);
    if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 1488, ASSERT_TYPE_ASSERT, "( soundSourceEnt )", (const char *)&queryFormat, "soundSourceEnt") )
      __debugbreak();
    v5 = 1;
    entrefa.entnum = Entity->s.number;
    entrefa.entclass = ENTITY_CLASS_GENTITY;
    v2 = entrefa;
  }
  else
  {
    v5 = 0;
  }
  v6 = GetEntity(v2);
  String = Scr_GetString(scrContext, 0);
  v8 = ScrCmd_PlaySoundAtPosInternal(scrContext, &v6->r.currentOrigin, String);
  v9 = v8;
  if ( v5 )
    v8->s.otherEntityNum = entrefa.entnum;
  ConstString = Scr_GetConstString(scrContext, 1u);
  if ( Com_Teams_TeamFromString(ConstString, (team_t *)&entrefa) )
  {
    entnum = entrefa.entnum;
    if ( !entrefa.entnum || entrefa.entnum - 201 <= 1 )
    {
      v14 = SL_ConvertToString(ConstString);
      v15 = j_va("Illegal team string '%s'. Must be allies, axis, team_three, team_four, team_five, or team_six.", v14);
      Scr_Error(COM_ERR_3025, scrContext, v15);
    }
    v16 = 0;
    if ( Scr_GetNumParam(scrContext) >= 3 && Scr_GetType(scrContext, 2u) )
    {
      v17 = GScr_GetEntity(2u);
      v18 = v17;
      if ( !v17->client )
      {
        v19 = j_va("entity %i is not a player", (unsigned int)v17->s.number);
        Scr_ObjectError(COM_ERR_3026, scrContext, v19);
      }
    }
    else
    {
      v18 = NULL;
    }
    p_clientMask = &v9->clientMask;
    v9->clientMask.array[0] = -1;
    *(_QWORD *)&v9->clientMask.array[1] = -1i64;
    *(_QWORD *)&v9->clientMask.array[3] = -1i64;
    *(_QWORD *)&v9->clientMask.array[5] = -1i64;
    v21 = g_entities;
    if ( (int)SvClient::ms_clientCount > 0 )
    {
      v22 = 0i64;
      v23 = 0i64;
      do
      {
        if ( (unsigned int)v16 >= 0x800 )
        {
          LODWORD(v25) = 2048;
          LODWORD(v24) = v16;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v24, v25) )
            __debugbreak();
        }
        if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
          __debugbreak();
        if ( g_entities[v22].r.isInUse != g_entityIsInUse[v23] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
          __debugbreak();
        if ( g_entityIsInUse[v23] && v21 != v18 )
        {
          if ( !v21->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 1925, ASSERT_TYPE_ASSERT, "(clientEnt->client)", (const char *)&queryFormat, "clientEnt->client") )
            __debugbreak();
          if ( v21->client->sess.cs.team == entnum )
            bitarray_base<bitarray<224>>::resetBit(p_clientMask, v21->s.number);
        }
        ++v16;
        ++v23;
        ++v22;
        ++v21;
      }
      while ( v16 < (int)SvClient::ms_clientCount );
    }
  }
  else
  {
    v11 = SL_ConvertToString(ConstString);
    v12 = j_va("unknown team '%s'", v11);
    Scr_Error(COM_ERR_3024, scrContext, v12);
  }
}

/*
==============
ScrCmd_PlaySoundToPlayer
==============
*/
void ScrCmd_PlaySoundToPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  scr_entref_t v2; 
  gentity_s *Entity; 
  char v5; 
  gentity_s *v6; 
  const char *String; 
  gentity_s *v8; 
  gentity_s *v9; 
  gentity_s *v10; 
  gentity_s *v11; 
  const char *v12; 
  unsigned int number; 
  unsigned int *v14; 
  scr_entref_t entrefa; 

  v2 = entref;
  entrefa = entref;
  if ( Scr_GetNumParam(scrContext) > 2 && Scr_GetType(scrContext, 2u) )
  {
    Entity = GScr_GetEntity(2u);
    if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 1488, ASSERT_TYPE_ASSERT, "( soundSourceEnt )", (const char *)&queryFormat, "soundSourceEnt") )
      __debugbreak();
    v5 = 1;
    entrefa.entnum = Entity->s.number;
    entrefa.entclass = ENTITY_CLASS_GENTITY;
    v2 = entrefa;
  }
  else
  {
    v5 = 0;
  }
  v6 = GetEntity(v2);
  String = Scr_GetString(scrContext, 0);
  v8 = ScrCmd_PlaySoundAtPosInternal(scrContext, &v6->r.currentOrigin, String);
  v9 = v8;
  if ( v5 )
    v8->s.otherEntityNum = entrefa.entnum;
  v10 = GScr_GetEntity(1u);
  v11 = v10;
  if ( !v10->client )
  {
    v12 = j_va("entity %i is not a player", (unsigned int)v10->s.number);
    Scr_ObjectError(COM_ERR_3027, scrContext, v12);
  }
  *(_QWORD *)v9->clientMask.array = -1i64;
  *(_QWORD *)&v9->clientMask.array[2] = -1i64;
  *(_QWORD *)&v9->clientMask.array[4] = -1i64;
  v9->clientMask.array[6] = -1;
  number = v11->s.number;
  if ( number >= 0xE0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 290, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", number, 224) )
    __debugbreak();
  v14 = &v9->clientMask.array[(unsigned __int64)number >> 5];
  *v14 &= ~(0x80000000 >> (number & 0x1F));
}

/*
==============
ScrCmd_QueueDialogForPlayer
==============
*/

void __fastcall ScrCmd_QueueDialogForPlayer(scrContext_t *scrContext, scr_entref_t entref, double _XMM2_8)
{
  int groupOverride; 
  unsigned int entnum; 
  gentity_s *v7; 
  const char *v8; 
  const char *String; 
  scr_string_t ConstString; 
  unsigned int v18; 
  scr_string_t group; 
  vec3_t vectorValue; 

  groupOverride = 0;
  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3678, scrContext, "not an entity");
    v7 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 1995, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v7 = &g_entities[entnum];
    if ( !v7->client && !v7->agent )
    {
      v8 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3677, scrContext, v8);
    }
  }
  if ( !SV_IsAgentEntity(v7) || SV_IsAgentBot(v7->agent->agentState.entityNum) )
  {
    String = Scr_GetString(scrContext, 0);
    ConstString = Scr_GetConstString(scrContext, 1u);
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
    __asm
    {
      vmulss  xmm1, xmm0, cs:__real@447a0000
      vaddss  xmm3, xmm1, cs:__real@3f000000
      vxorps  xmm2, xmm2, xmm2
      vmovss  xmm4, xmm2, xmm3
      vxorps  xmm0, xmm0, xmm0
      vroundss xmm1, xmm0, xmm4, 1
      vcvttss2si r12d, xmm1
    }
    v18 = 0;
    if ( !strstr_0(String, "null") )
    {
      v18 = SND_HashName(String);
      if ( !v18 )
        Scr_ParamError(COM_ERR_3028, scrContext, 0, "Invalid sound name specified");
    }
    if ( Scr_GetNumParam(scrContext) > 3 && Scr_GetType(scrContext, 3u) )
      group = Scr_GetConstString(scrContext, 3u);
    else
      group = 0;
    if ( Scr_GetNumParam(scrContext) > 4 && Scr_GetType(scrContext, 4u) )
      groupOverride = Scr_GetInt(scrContext, 4u);
    if ( Scr_GetNumParam(scrContext) > 5 && Scr_GetType(scrContext, 5u) )
    {
      Scr_GetVector(scrContext, 5u, &vectorValue);
    }
    else
    {
      __asm
      {
        vxorps  xmm0, xmm0, xmm0
        vmovss  dword ptr [rsp+88h+vectorValue], xmm0
        vmovss  dword ptr [rsp+88h+vectorValue+4], xmm0
        vmovss  dword ptr [rsp+88h+vectorValue+8], xmm0
      }
    }
    G_QueueDialogForPlayer(v7, ConstString, v18, &vectorValue, _ER12, group, groupOverride);
  }
}

/*
==============
ScrCmd_QueueDialog
==============
*/

void __fastcall ScrCmd_QueueDialog(scrContext_t *scrContext, __int64 a2, double _XMM2_8)
{
  const char *String; 
  const char *v6; 
  const char *v14; 
  unsigned int v15; 
  team_t v16; 
  scr_string_t ConstString; 
  const char *v18; 
  const char *v19; 
  unsigned int ArrayObject; 
  unsigned int ArraySize; 
  const char *v22; 
  const char *NameForType; 
  const char *v24; 
  unsigned int i; 
  gclient_s *v27; 
  SvClientMP *MpClient; 
  team_t team; 
  __int64 v30; 
  scr_entref_t EntityIdRef; 
  gentity_s *Entity; 
  unsigned int v33; 
  gentity_s *v34; 
  unsigned int j; 
  unsigned int v36; 
  __int64 v37; 
  gentity_s *v38; 
  gagent_s *agent; 
  int entityNum; 
  team_t v41; 
  __int64 v42; 
  scr_entref_t v43; 
  gentity_s *v44; 
  unsigned int v45; 
  unsigned int *failureIndex; 
  VariableType *failureType; 
  unsigned int count; 
  VariableType v49[4]; 
  team_t outTeam; 
  unsigned int v51; 
  scr_string_t group; 
  unsigned int soundHash; 
  int duration; 
  scr_string_t dialogName; 
  unsigned int v56; 
  vec3_t vectorValue; 
  unsigned int buffer[248]; 

  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
    Scr_Error(COM_ERR_3029, scrContext, "Function not supported for front-end server");
  if ( !SV_Game_IsLocalSplitscreenGame() )
  {
    String = Scr_GetString(scrContext, 0);
    v6 = Scr_GetString(scrContext, 1u);
    dialogName = Scr_GetConstString(scrContext, 2u);
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
    __asm
    {
      vmulss  xmm1, xmm0, cs:__real@447a0000
      vaddss  xmm3, xmm1, cs:__real@3f000000
      vxorps  xmm2, xmm2, xmm2
      vmovss  xmm4, xmm2, xmm3
      vxorps  xmm0, xmm0, xmm0
      vroundss xmm1, xmm0, xmm4, 1
      vcvttss2si eax, xmm1
    }
    duration = _EAX;
    v14 = SL_ConvertToString(dialogName);
    if ( I_strncmp(v14, "null", 0x7FFFFFFFui64) )
    {
      v15 = 0;
      v51 = 0;
      soundHash = 0;
      if ( !strstr_0(String, "null") )
      {
        v51 = SND_HashName(String);
        if ( !v51 )
          Scr_ParamError(COM_ERR_3030, scrContext, 0, "Invalid sound allies sound name specified");
      }
      if ( !strstr_0(v6, "null") )
      {
        soundHash = SND_HashName(v6);
        v15 = soundHash;
        if ( !soundHash )
          Scr_ParamError(COM_ERR_3031, scrContext, 1u, "Invalid sound axis sound name specified");
      }
      v16 = TEAM_ZERO;
      outTeam = TEAM_ZERO;
      if ( Scr_GetNumParam(scrContext) > 4 && Scr_GetType(scrContext, 4u) )
      {
        ConstString = Scr_GetConstString(scrContext, 4u);
        if ( !Com_Teams_TeamFromString(ConstString, &outTeam) )
        {
          v18 = SL_ConvertToString(ConstString);
          v19 = j_va("unknown team '%s'", v18);
          Scr_Error(COM_ERR_3032, scrContext, v19);
          return;
        }
        v16 = outTeam;
      }
      if ( Scr_GetNumParam(scrContext) > 5 && Scr_GetType(scrContext, 5u) )
        group = Scr_GetConstString(scrContext, 5u);
      else
        group = 0;
      count = 0;
      if ( Scr_GetNumParam(scrContext) > 6 && Scr_GetType(scrContext, 6u) )
      {
        ArrayObject = BGScr_Main_GetArrayObject(scrContext, 6u);
        ArraySize = GetArraySize(scrContext, ArrayObject);
        count = ArraySize;
        if ( ArraySize > 0xF8 )
        {
          v22 = j_va("array is too large (%d > %d)", ArraySize, 248i64);
          Scr_ParamError(COM_ERR_3033, scrContext, 0, v22);
        }
        if ( !Scr_GetEntityArray(scrContext, ArrayObject, 0xF8u, buffer, &count, &v56, v49) )
        {
          NameForType = Scr_GetNameForType(v49[0]);
          v24 = j_va("element %i of array: type %s is not an entity", v56, NameForType);
          Scr_ParamError(COM_ERR_3034, scrContext, 0, v24);
        }
      }
      if ( Scr_GetNumParam(scrContext) > 7 && Scr_GetType(scrContext, 7u) )
      {
        Scr_GetVector(scrContext, 7u, &vectorValue);
      }
      else
      {
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vmovss  dword ptr [rsp+490h+vectorValue], xmm0
          vmovss  dword ptr [rsp+490h+vectorValue+4], xmm0
          vmovss  dword ptr [rsp+490h+vectorValue+8], xmm0
        }
      }
      for ( i = 0; i < level.maxclients; ++i )
      {
        if ( i >= 0x800 )
        {
          LODWORD(failureType) = 2048;
          LODWORD(failureIndex) = i;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", failureIndex, failureType) )
            __debugbreak();
        }
        if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
          __debugbreak();
        if ( g_entities[i].r.isInUse != g_entityIsInUse[i] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
          __debugbreak();
        if ( g_entityIsInUse[i] )
        {
          v27 = &level.clients[i];
          if ( v27->sess.connected == CON_CONNECTED )
          {
            MpClient = SV_Client_GetMpClient(i);
            if ( !MpClient->bIsSplitscreenClient || NetConnection::GetNetId(&MpClient->clientConnection) == NS_CLIENT1 )
            {
              team = v27->sess.cs.team;
              if ( (unsigned int)(team - 201) > 1 && (v16 == TEAM_ZERO || v16 == team) )
              {
                v30 = 0i64;
                if ( !count )
                  goto LABEL_55;
                while ( 1 )
                {
                  EntityIdRef = Scr_GetEntityIdRef(scrContext, buffer[v30]);
                  Entity = GetEntity(EntityIdRef);
                  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 2182, ASSERT_TYPE_ASSERT, "( excludedEntity )", (const char *)&queryFormat, "excludedEntity") )
                    __debugbreak();
                  if ( Entity->s.number == i )
                    break;
                  v30 = (unsigned int)(v30 + 1);
                  if ( (unsigned int)v30 >= count )
                    goto LABEL_55;
                }
                if ( (unsigned int)v30 >= count )
                {
LABEL_55:
                  v33 = v51;
                  if ( team == TEAM_ONE )
                    v33 = v15;
                  v34 = &g_entities[i];
                  if ( !v34->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 2195, ASSERT_TYPE_ASSERT, "( clientEntity->client )", (const char *)&queryFormat, "clientEntity->client") )
                    __debugbreak();
                  G_QueueDialogForPlayer(v34, dialogName, v33, &vectorValue, duration, group, 0);
                }
              }
            }
          }
        }
        v16 = outTeam;
      }
      for ( j = 0; (int)j < level.maxagents; ++j )
      {
        if ( !ComCharacterLimits::ms_isGameDataValid && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_character_limits.h", 116, ASSERT_TYPE_ASSERT, "(ms_isGameDataValid)", (const char *)&queryFormat, "ms_isGameDataValid") )
          __debugbreak();
        if ( j >= ComCharacterLimits::ms_gameData.m_agentCount )
        {
          if ( !ComCharacterLimits::ms_isGameDataValid && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_character_limits.h", 116, ASSERT_TYPE_ASSERT, "(ms_isGameDataValid)", (const char *)&queryFormat, "ms_isGameDataValid") )
            __debugbreak();
          LODWORD(failureType) = ComCharacterLimits::ms_gameData.m_agentCount;
          LODWORD(failureIndex) = j;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_character_limits.h", 186, ASSERT_TYPE_ASSERT, "(unsigned)( agentIndex ) < (unsigned)( ComCharacterLimits::GetAgentMaxCount() )", "agentIndex doesn't index ComCharacterLimits::GetAgentMaxCount()\n\t%i not in [0, %i)", failureIndex, failureType) )
            __debugbreak();
        }
        if ( !ComCharacterLimits::ms_isGameDataValid && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_character_limits.h", 168, ASSERT_TYPE_ASSERT, "(ms_isGameDataValid)", (const char *)&queryFormat, "ms_isGameDataValid") )
          __debugbreak();
        v36 = j + ComCharacterLimits::ms_gameData.m_clientCount;
        if ( j + ComCharacterLimits::ms_gameData.m_clientCount >= 0x800 )
        {
          LODWORD(failureType) = 2048;
          LODWORD(failureIndex) = j + ComCharacterLimits::ms_gameData.m_clientCount;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", failureIndex, failureType) )
            __debugbreak();
        }
        if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
          __debugbreak();
        v37 = (int)v36;
        if ( g_entities[v37].r.isInUse != g_entityIsInUse[v36] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
          __debugbreak();
        if ( g_entityIsInUse[v36] )
        {
          if ( !ComCharacterLimits::ms_isGameDataValid && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_character_limits.h", 123, ASSERT_TYPE_ASSERT, "(ms_isGameDataValid)", (const char *)&queryFormat, "ms_isGameDataValid") )
            __debugbreak();
          if ( v36 >= ComCharacterLimits::ms_gameData.m_characterCount )
          {
            if ( !ComCharacterLimits::ms_isGameDataValid && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_character_limits.h", 123, ASSERT_TYPE_ASSERT, "(ms_isGameDataValid)", (const char *)&queryFormat, "ms_isGameDataValid") )
              __debugbreak();
            LODWORD(failureType) = ComCharacterLimits::ms_gameData.m_characterCount;
            LODWORD(failureIndex) = v36;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 2207, ASSERT_TYPE_ASSERT, "(unsigned)( characterIndex ) < (unsigned)( ComCharacterLimits::GetCharacterMaxCount() )", "characterIndex doesn't index ComCharacterLimits::GetCharacterMaxCount()\n\t%i not in [0, %i)", failureIndex, failureType) )
              __debugbreak();
          }
          v38 = &g_entities[v37];
          agent = g_entities[v37].agent;
          if ( agent )
          {
            if ( v38->r.isLinked )
            {
              if ( (v38->r.svFlags & 1) == 0 )
              {
                entityNum = agent->agentState.entityNum;
                if ( entityNum == v36 )
                {
                  if ( SV_IsAgentBot(entityNum) )
                  {
                    v41 = v38->agent->agentState.team;
                    if ( (unsigned int)(v41 - 201) > 1 && (outTeam == TEAM_ZERO || outTeam == v41) )
                    {
                      v42 = 0i64;
                      if ( !count )
                        goto LABEL_110;
                      while ( 1 )
                      {
                        v43 = Scr_GetEntityIdRef(scrContext, buffer[v42]);
                        v44 = GetEntity(v43);
                        if ( !v44 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 2237, ASSERT_TYPE_ASSERT, "( excludedEntity )", (const char *)&queryFormat, "excludedEntity") )
                          __debugbreak();
                        if ( v44->s.number == v36 )
                          break;
                        v42 = (unsigned int)(v42 + 1);
                        if ( (unsigned int)v42 >= count )
                          goto LABEL_110;
                      }
                      if ( (unsigned int)v42 >= count )
                      {
LABEL_110:
                        v45 = v51;
                        if ( v41 == TEAM_ONE )
                          v45 = soundHash;
                        G_QueueDialogForPlayer(v38, dialogName, v45, &vectorValue, duration, group, 0);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

/*
==============
Scr_SetFXKillDefOnDelete
==============
*/
void Scr_SetFXKillDefOnDelete(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 2267, ASSERT_TYPE_ASSERT, "(ent)", (const char *)&queryFormat, "ent") )
    __debugbreak();
  if ( Entity->s.eType != ET_FX )
    Scr_Error(COM_ERR_3035, scrContext, "SetFXKillDefOnDelete should only be operated on an entity that is an FX type");
  Entity->s.staticState.player.stowedWeaponHandle.m_mapEntryId = 1;
}

/*
==============
GScr_GetClanWarsBonusForCurrentPlaylist
==============
*/
void GScr_GetClanWarsBonusForCurrentPlaylist(scrContext_t *scrContext, scr_entref_t entref)
{
  __asm { vxorps  xmm1, xmm1, xmm1; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
GScr_MainMP_EntityWillNeverChange
==============
*/
void GScr_MainMP_EntityWillNeverChange(scrContext_t *scrContext, scr_entref_t entref)
{
  LerpEntityState *p_lerp; 

  p_lerp = &GetEntity(entref)->s.lerp;
  if ( GameModeFlagValues::ms_mpValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 201, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a MP-only context", "IsFlagActive( index )") )
    __debugbreak();
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(&p_lerp->eFlags, ACTIVE, 0x1Eu);
}

/*
==============
GScr_MainMP_EntityForceNetfieldHighLoD
==============
*/
void GScr_MainMP_EntityForceNetfieldHighLoD(scrContext_t *scrContext, scr_entref_t entref)
{
  GameModeFlagContainer<enum BgEntityFlagsCommon,enum BgEntityFlagsSP,enum BgEntityFlagsMP,64> *p_flags; 

  p_flags = &GetEntity(entref)->flags;
  if ( Scr_GetInt(scrContext, 0) )
  {
    if ( GameModeFlagValues::ms_mpValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 201, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a MP-only context", "IsFlagActive( index )") )
      __debugbreak();
    p_flags->m_flags[1] |= 0x20u;
  }
  else
  {
    GameModeFlagContainer<enum BgEntityFlagsCommon,enum BgEntityFlagsSP,enum BgEntityFlagsMP,64>::ClearFlagStrict(p_flags, TURRET_ACTIVE_PRONE|0x20);
  }
}

/*
==============
ScrCmd_PlayerHide
==============
*/
void ScrCmd_PlayerHide(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  bool v4; 
  bool v5; 

  Entity = GetEntity(entref);
  if ( !Entity->client )
    Scr_Error(COM_ERR_3040, scrContext, "Must be called on a player.");
  v4 = 0;
  if ( Scr_GetNumParam(scrContext) && Scr_GetType(scrContext, 0) )
    v4 = Scr_GetInt(scrContext, 0) != 0;
  v5 = 0;
  if ( Scr_GetNumParam(scrContext) > 1 && Scr_GetType(scrContext, 1u) )
    v5 = Scr_GetInt(scrContext, 1u) != 0;
  if ( v4 )
  {
    if ( v5 )
      Scr_Error(COM_ERR_6080, scrContext, "Cannot call PlayerHide with both <forceTransmitToAllClients> and <forceTransmitToNoClients> set to true");
    *(_QWORD *)Entity->clientMask.array = 0i64;
    *(_QWORD *)&Entity->clientMask.array[2] = 0i64;
    *(_QWORD *)&Entity->clientMask.array[4] = 0i64;
    Entity->clientMask.array[6] = 0;
  }
  if ( v5 )
  {
    *(_QWORD *)Entity->clientMask.array = -1i64;
    *(_QWORD *)&Entity->clientMask.array[2] = -1i64;
    *(_QWORD *)&Entity->clientMask.array[4] = -1i64;
    Entity->clientMask.array[6] = -1;
  }
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(&Entity->client->ps.eFlags, ACTIVE, 0xCu);
}

/*
==============
ScrCmd_PlayerShow
==============
*/
void ScrCmd_PlayerShow(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  bool v4; 
  bool v5; 

  Entity = GetEntity(entref);
  if ( !Entity->client )
    Scr_Error(COM_ERR_3041, scrContext, "Must be called on a player.");
  v4 = 0;
  if ( Scr_GetNumParam(scrContext) && Scr_GetType(scrContext, 0) )
    v4 = Scr_GetInt(scrContext, 0) != 0;
  v5 = 0;
  if ( Scr_GetNumParam(scrContext) > 1 && Scr_GetType(scrContext, 1u) )
    v5 = Scr_GetInt(scrContext, 1u) != 0;
  if ( v4 )
  {
    if ( v5 )
      Scr_Error(COM_ERR_6081, scrContext, "Cannot call PlayerHide with both <forceTransmitToAllClients> and <forceTransmitToNoClients> set to true");
    *(_QWORD *)Entity->clientMask.array = 0i64;
    *(_QWORD *)&Entity->clientMask.array[2] = 0i64;
    *(_QWORD *)&Entity->clientMask.array[4] = 0i64;
    Entity->clientMask.array[6] = 0;
  }
  if ( v5 )
  {
    *(_QWORD *)Entity->clientMask.array = -1i64;
    *(_QWORD *)&Entity->clientMask.array[2] = -1i64;
    *(_QWORD *)&Entity->clientMask.array[4] = -1i64;
    Entity->clientMask.array[6] = -1;
  }
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(&Entity->client->ps.eFlags, ACTIVE, 0xCu);
}

/*
==============
ScrCmd_ShowOnlyToPlayer
==============
*/
void ScrCmd_ShowOnlyToPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  gclient_s *client; 
  __int64 v6; 

  Entity = GetEntity(entref);
  if ( GameModeFlagValues::ms_mpValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 190, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a MP-only context", "IsFlagActive( index )") )
    __debugbreak();
  if ( GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&Entity->s.lerp.eFlags, ACTIVE, 0x1Eu) )
    Scr_Error(COM_ERR_5868, scrContext, "Cannot change a 'willNeverChange' entity");
  if ( Entity->client )
    Scr_Error(COM_ERR_5963, scrContext, "ShowOnlyToPlayer only works on non-player entities");
  v4 = GScr_GetEntity(0);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 2626, ASSERT_TYPE_ASSERT, "( clientEnt )", (const char *)&queryFormat, "clientEnt") )
    __debugbreak();
  if ( !v4->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 2627, ASSERT_TYPE_ASSERT, "( clientEnt->client )", (const char *)&queryFormat, "clientEnt->client") )
    __debugbreak();
  client = v4->client;
  if ( v4->s.number < level.maxclients )
  {
    if ( Entity->tagInfo || Entity->tagChildren )
    {
      if ( client->ps.linkEnt == Entity->s.number )
      {
        client->ps.linkFlags.m_flags[0] |= GameModeFlagValues::ms_mpValue << 7;
        GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::SetFlagInternal(&Entity->s.lerp.eFlags, ACTIVE, 0xCu);
        *(_QWORD *)Entity->clientMask.array = 0i64;
        *(_QWORD *)&Entity->clientMask.array[2] = 0i64;
        *(_QWORD *)&Entity->clientMask.array[4] = 0i64;
        Entity->clientMask.array[6] = 0;
      }
      else
      {
        LODWORD(v6) = Entity->s.number;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 2646, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "ShowOnlyToPlayer can only be called on a non-linked entity or an entity a player is linked to. Entity number: %d Client: %d", v6, v4->s.number) )
          __debugbreak();
      }
    }
    else
    {
      GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(&Entity->s.lerp.eFlags, ACTIVE, 0xCu);
      Entity->clientMask.array[0] = -1;
      *(_QWORD *)&Entity->clientMask.array[1] = -1i64;
      *(_QWORD *)&Entity->clientMask.array[3] = -1i64;
      *(_QWORD *)&Entity->clientMask.array[5] = -1i64;
      bitarray_base<bitarray<224>>::resetBit(&Entity->clientMask, v4->s.number);
    }
  }
  else
  {
    Scr_Error(COM_ERR_5869, scrContext, "showOnlyToClient error: param must be a client entity\n");
  }
}

/*
==============
ScrCmd_ShowToPlayer
==============
*/
void ScrCmd_ShowToPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *client; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *p_eFlags; 
  unsigned int number; 
  unsigned int *v8; 
  int v9; 
  int v10; 

  Entity = GetEntity(entref);
  if ( GameModeFlagValues::ms_mpValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 190, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a MP-only context", "IsFlagActive( index )") )
    __debugbreak();
  if ( GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&Entity->s.lerp.eFlags, ACTIVE, 0x1Eu) )
    Scr_Error(COM_ERR_3042, scrContext, "Cannot change a 'willNeverChange' entity");
  v4 = GScr_GetEntity(0);
  if ( v4->s.number >= level.maxclients )
  {
    Scr_Error(COM_ERR_3043, scrContext, "showToClient error: param must be a client entity\n");
    return;
  }
  client = (GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *)Entity->client;
  if ( client )
  {
    if ( GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(client + 94, ACTIVE, 0xCu) )
    {
      p_eFlags = &Entity->client->ps.eFlags;
LABEL_13:
      GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(p_eFlags, ACTIVE, 0xCu);
      *(_QWORD *)Entity->clientMask.array = -1i64;
      *(_QWORD *)&Entity->clientMask.array[2] = -1i64;
      *(_QWORD *)&Entity->clientMask.array[4] = -1i64;
      Entity->clientMask.array[6] = -1;
    }
  }
  else if ( GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&Entity->s.lerp.eFlags, ACTIVE, 0xCu) )
  {
    p_eFlags = &Entity->s.lerp.eFlags;
    goto LABEL_13;
  }
  number = v4->s.number;
  if ( number >= 0xE0 )
  {
    v10 = 224;
    v9 = v4->s.number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 290, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v9, v10) )
      __debugbreak();
  }
  v8 = &Entity->clientMask.array[(unsigned __int64)number >> 5];
  *v8 &= ~(0x80000000 >> (number & 0x1F));
}

/*
==============
ScrCmd_HideFromPlayer
==============
*/
void ScrCmd_HideFromPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *client; 
  GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *p_eFlags; 
  unsigned int number; 
  unsigned int *v8; 
  int v9; 
  int v10; 

  Entity = GetEntity(entref);
  if ( GameModeFlagValues::ms_mpValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 190, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a MP-only context", "IsFlagActive( index )") )
    __debugbreak();
  if ( GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&Entity->s.lerp.eFlags, ACTIVE, 0x1Eu) )
    Scr_Error(COM_ERR_3044, scrContext, "Cannot change a 'willNeverChange' entity");
  v4 = GScr_GetEntity(0);
  if ( v4->s.number >= level.maxclients )
  {
    Scr_Error(COM_ERR_3045, scrContext, "showToClient error: param must be a client entity\n");
    return;
  }
  client = (GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32> *)Entity->client;
  if ( client )
  {
    if ( GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(client + 94, ACTIVE, 0xCu) )
    {
      p_eFlags = &Entity->client->ps.eFlags;
LABEL_13:
      GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::ClearFlagInternal(p_eFlags, ACTIVE, 0xCu);
      *(_QWORD *)Entity->clientMask.array = -1i64;
      *(_QWORD *)&Entity->clientMask.array[2] = -1i64;
      *(_QWORD *)&Entity->clientMask.array[4] = -1i64;
      Entity->clientMask.array[6] = -1;
    }
  }
  else if ( GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&Entity->s.lerp.eFlags, ACTIVE, 0xCu) )
  {
    p_eFlags = &Entity->s.lerp.eFlags;
    goto LABEL_13;
  }
  number = v4->s.number;
  if ( number >= 0xE0 )
  {
    v10 = 224;
    v9 = v4->s.number;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 263, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v9, v10) )
      __debugbreak();
  }
  v8 = &Entity->clientMask.array[(unsigned __int64)number >> 5];
  *v8 |= 0x80000000 >> (number & 0x1F);
}

/*
==============
ScrCmd_SetClientOwner
==============
*/
void ScrCmd_SetClientOwner(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 

  Entity = GetEntity(entref);
  if ( Entity->client )
  {
    Scr_ObjectError(COM_ERR_3046, scrContext, "SetClientOwner() cannot be called on a client.");
  }
  else if ( Scr_GetNumParam(scrContext) == 1 )
  {
    if ( GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagStrict(&Entity->s.lerp.eFlags, (EntityStateFlagsMP)30) )
      Scr_Error(COM_ERR_3048, scrContext, "Cannot change a 'willNeverChange' entity");
    v4 = GScr_GetEntity(0);
    if ( !v4->client )
      Scr_ParamError(COM_ERR_3049, scrContext, 0, "entity is not a client");
    Entity->s.clientNum = v4->s.number + 1;
  }
  else
  {
    Scr_Error(COM_ERR_3047, scrContext, "SetClientOwner() needs to have a client passed in. ");
  }
}

/*
==============
Scr_GetWeaponExplosionRadius
==============
*/
void Scr_GetWeaponExplosionRadius(scrContext_t *scrContext)
{
  int v2; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  GScr_Main_GetWeaponParam(scrContext, 0, &outWeapon, &outIsAlternate);
  v2 = BG_ExplosionRadius(&outWeapon, outIsAlternate);
  Scr_AddInt(scrContext, v2);
}

/*
==============
Scr_GetPredictedEntityPosition
==============
*/
void Scr_GetPredictedEntityPosition(scrContext_t *scrContext)
{
  gentity_s *Entity; 
  pathnode_t *v30; 
  pathnode_t *BestNode; 
  ai_search_t search; 
  vec3_t forward; 
  vec3_t pos; 
  char v39; 
  void *retaddr; 

  _R11 = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [r11-18h], xmm6
    vmovaps xmmword ptr [r11-28h], xmm7
  }
  Entity = GScr_GetEntity(0);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm
  {
    vmulss  xmm1, xmm0, cs:__real@447a0000
    vcvttss2si esi, xmm1
  }
  _RAX = G_GetEntityPlayerState(Entity);
  __asm { vmovss  xmm6, cs:__real@3f800000 }
  if ( _RAX )
  {
    __asm
    {
      vmovss  xmm0, dword ptr [rax+40h]
      vmovss  xmm4, dword ptr [rax+3Ch]
      vmovss  xmm3, dword ptr [rax+44h]
      vmulss  xmm0, xmm0, xmm0
      vmulss  xmm1, xmm4, xmm4
      vaddss  xmm2, xmm1, xmm0
      vmulss  xmm1, xmm3, xmm3
      vaddss  xmm2, xmm2, xmm1
      vsqrtss xmm7, xmm2, xmm2
      vcmpless xmm0, xmm7, cs:__real@80000000
      vblendvps xmm0, xmm7, xmm6, xmm0
      vdivss  xmm2, xmm6, xmm0
      vmulss  xmm0, xmm4, xmm2
      vmovss  dword ptr [rsp+3C8h+forward], xmm0
      vmulss  xmm1, xmm2, dword ptr [rax+40h]
      vmovss  dword ptr [rsp+3C8h+forward+4], xmm1
      vmulss  xmm0, xmm2, dword ptr [rax+44h]
      vmovss  dword ptr [rsp+3C8h+forward+8], xmm0
    }
  }
  else
  {
    AngleVectors(&Entity->r.currentAngles, &forward, NULL, NULL);
    __asm { vxorps  xmm7, xmm7, xmm7 }
  }
  _RCX = &Entity->r.currentOrigin;
  __asm
  {
    vmovss  xmm0, dword ptr [rcx]
    vmovss  dword ptr [rsp+3C8h+search.searchOrigin], xmm0
    vmovss  xmm1, dword ptr [rcx+4]
    vmovss  dword ptr [rsp+3C8h+search.searchOrigin+4], xmm1
    vmovss  xmm0, dword ptr [rcx+8]
    vmovss  dword ptr [rsp+3C8h+search.searchOrigin+8], xmm0
  }
  if ( Entity->sentient )
    v30 = Sentient_NearestNode(Entity->sentient);
  else
    v30 = Path_NearestNode(_RCX, Entity->clipmask, NULL);
  search.nodeNearestSearchOrigin = v30;
  if ( v30 )
  {
    __asm
    {
      vmovaps xmm2, xmm7; targetVelocity
      vmovss  [rsp+3C8h+search.highestPriorityDistScalar], xmm6
      vmovss  [rsp+3C8h+search.maxSearchDistScalar], xmm6
    }
    AI_BuildSearchArea(&search, &forward, *(float *)&_XMM2, _ESI, NULL, 0, AI_SEARCH_THOROUGH);
    if ( search.totalNodeCount )
    {
      BestNode = AI_SearchGetBestNode(&search);
      pathnode_t::GetPos(BestNode, &pos);
      Scr_AddVector(scrContext, pos.v);
    }
  }
  _R11 = &v39;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
  }
}

/*
==============
Scr_MakeEntityNoMeleeTarget
==============
*/
void Scr_MakeEntityNoMeleeTarget(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v3; 

  Entity = GetEntity(entref);
  v3 = Entity;
  if ( GameModeFlagValues::ms_mpValue == ACTIVE )
  {
    Entity->flags.m_flags[1] |= 4u;
  }
  else
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 201, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a MP-only context", "IsFlagActive( index )") )
      __debugbreak();
    v3->flags.m_flags[1] |= 4u;
  }
}

/*
==============
ScrCmd_MissileDontTrackKillCam
==============
*/
void ScrCmd_MissileDontTrackKillCam(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( Entity->s.eType == ET_MISSILE )
    Entity->s.lerp.u.anonymous.data[4] |= 0x80u;
  else
    Scr_Error(COM_ERR_3050, scrContext, "MissileDontTrackKillCam must be called on a missile.");
}

/*
==============
ScrCmd_SetScriptMoverKillCam
==============
*/
void ScrCmd_SetScriptMoverKillCam(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  unsigned int v6; 
  const char **v7; 
  const char *String; 
  const char *v9; 
  ComErrorCode v10; 
  unsigned int v11; 
  unsigned int Int; 
  unsigned int v13; 
  __int64 v14[14]; 
  int v15; 
  void *retaddr; 

  _R11 = &retaddr;
  __asm { vmovdqu ymm0, cs:__ymm@0000000800000007000000060000000500000004000000030000000200000001 }
  v15 = 9;
  v14[0] = (__int64)"helicopter";
  v14[1] = (__int64)"airstrike";
  v14[2] = (__int64)"explosive";
  v14[3] = (__int64)"offset explosive";
  v14[4] = (__int64)"fast explosive";
  v14[5] = (__int64)"rocket";
  v14[6] = (__int64)"turret";
  v14[7] = (__int64)"javelin";
  v14[8] = (__int64)"missile";
  __asm { vmovdqu ymmword ptr [r11-58h], ymm0 }
  Entity = GetEntity(entref);
  if ( !Scr_GetNumParam(scrContext) )
  {
    Scr_Error(COM_ERR_3051, scrContext, "First argument missing in SetScriptMoverKillCam() invocation.");
    return;
  }
  if ( Entity->s.eType != ET_SCRIPTMOVER )
  {
    Scr_ParamError(COM_ERR_3053, scrContext, 0, "SetScriptMoverKillCam() can only be invoked on a script mover.");
    return;
  }
  if ( GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagStrict(&Entity->s.lerp.eFlags, (EntityStateFlagsMP)30) )
  {
    Scr_Error(COM_ERR_3054, scrContext, "SetScriptMoverKillCam() was invoked on a 'willNeverChange' entity");
    return;
  }
  v6 = 0;
  v7 = (const char **)v14;
  String = Scr_GetString(scrContext, 0);
  while ( !String || I_strnicmp(String, *v7, 0x7FFFFFFFui64) )
  {
    ++v6;
    ++v7;
    if ( v6 >= 9 )
      goto LABEL_11;
  }
  v11 = *((_DWORD *)&v14[10] + (int)v6);
  if ( !v11 )
  {
LABEL_11:
    v9 = j_va("SetScriptMoverKillCam needs to have a correct killcam type passed in. This can be 'helicopter', 'airstrike', 'explosive', 'fast explosive', 'rocket', 'turret', 'javelin', 'missile'.\nWe had %s.", String);
    v10 = COM_ERR_3052;
LABEL_12:
    Scr_Error(v10, scrContext, v9);
    return;
  }
  Entity->s.eventParm = v11;
  if ( v11 == 4 )
  {
    if ( Scr_GetNumParam(scrContext) < 3 )
    {
      v9 = "SetScriptMoverKillCam(): since type 'offset explosive' was specified, offset 'up' and 'back' arguments are required.";
      v10 = COM_ERR_6533;
      goto LABEL_12;
    }
    Int = Scr_GetInt(scrContext, 1u);
    v13 = Scr_GetInt(scrContext, 2u);
    BG_ScriptMoverKillcam_PackOffset(Int, v13, &Entity->s.eventParm2);
  }
}

/*
==============
ScrCmd_MakeScrambler
==============
*/
void ScrCmd_MakeScrambler(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t ConstLowercaseString; 
  gentity_s *v6; 

  Entity = GetEntity(entref);
  G_SetAffector(Entity, (const EntityStateFlagsMP)20);
  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 1u);
    v6 = GetEntity(entref);
    if ( v6->s.eType != ET_SCRIPTMOVER && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 3008, ASSERT_TYPE_ASSERT, "(ent->s.eType == ET_SCRIPTMOVER)", (const char *)&queryFormat, "ent->s.eType == ET_SCRIPTMOVER") )
      __debugbreak();
    if ( ConstLowercaseString == scr_const.little )
    {
      BG_SetJammingType(&v6->s, JAMMING_TYPE_LITTLE);
    }
    else if ( ConstLowercaseString == scr_const.medium )
    {
      BG_SetJammingType(&v6->s, JAMMING_TYPE_MEDIUM);
    }
    else if ( ConstLowercaseString == scr_const.large )
    {
      BG_SetJammingType(&v6->s, JAMMING_TYPE_LARGE);
    }
    else
    {
      Scr_Error(COM_ERR_3055, scrContext, "SetJammerFlag: Invalid parameter. Must be one of: (little, medium, large)");
    }
  }
}

/*
==============
ScrCmd_ClearScrambler
==============
*/
void ScrCmd_ClearScrambler(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  G_ClearAffector(Entity, (const EntityStateFlagsMP)20);
  if ( Entity->s.eType != ET_SCRIPTMOVER && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 3065, ASSERT_TYPE_ASSERT, "(ent->s.eType == ET_SCRIPTMOVER)", (const char *)&queryFormat, "ent->s.eType == ET_SCRIPTMOVER") )
    __debugbreak();
  BG_ClearJammingType(&Entity->s);
}

/*
==============
ScrCmd_TriggerOneOffRadarSweep
==============
*/
void ScrCmd_TriggerOneOffRadarSweep(scrContext_t *scrContext)
{
  gclient_s *client; 

  if ( (int)Scr_GetNumParam(scrContext) < 1 )
    Scr_Error(COM_ERR_3056, scrContext, "TriggerOneOffRadarSweep(): Invalid parameters. Check documentation.\n");
  client = GScr_GetEntity(0)->client;
  if ( client )
    client->ps.radarOneOffSweepTime = level.time;
  else
    Scr_Error(COM_ERR_3057, scrContext, "TriggerOneOffRadarSweep(): Owner must be a player.\n");
}

/*
==============
ScrCmd_MakePortableRadar
==============
*/
void ScrCmd_MakePortableRadar(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  G_SetAffector(Entity, LEGACY_LADDER_CENTERLINE|LEGACY_MOUNT|0x10);
}

/*
==============
ScrCmd_ClearPortableRadar
==============
*/
void ScrCmd_ClearPortableRadar(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  G_ClearAffector(Entity, LEGACY_LADDER_CENTERLINE|LEGACY_MOUNT|0x10);
}

/*
==============
ScrCmd_PingLocationEnemyTeams
==============
*/
void ScrCmd_PingLocationEnemyTeams(scrContext_t *scrContext)
{
  unsigned int NumParam; 
  __int16 number; 
  int integer; 
  const dvar_t *v5; 
  int Int; 
  const dvar_t *v7; 
  scr_string_t ConstString; 
  const char *v9; 
  const char *v10; 
  gentity_s *v11; 
  signed int v12; 
  bitarray_base<bitarray<224> > *p_clientMask; 
  gentity_s *v14; 
  team_t v15; 
  __int64 v16; 
  __int64 v17; 
  gclient_s *client; 
  __int64 v19; 
  __int64 v20; 
  team_t outTeam; 
  vec3_t vectorValue; 

  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam - 2 > 3 )
    Scr_Error(COM_ERR_3058, scrContext, "PingLocationEnemyTeams(): Invalid parameters. Check documentation.\n");
  Scr_GetVector(scrContext, 0, &vectorValue);
  if ( NumParam < 3 )
    number = 2047;
  else
    number = GScr_GetEntity(2u)->s.number;
  if ( NumParam < 4 )
  {
    v5 = DCONST_DVARINT_bg_compassNumDecoyActors;
    if ( !DCONST_DVARINT_bg_compassNumDecoyActors && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_compassNumDecoyActors") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v5);
    integer = v5->current.integer;
  }
  else
  {
    integer = Scr_GetInt(scrContext, 3u);
    if ( integer <= 0 )
      Scr_Error(COM_ERR_3059, scrContext, "PingLocationEnemyTeams(): Invalid number of decoys.\n");
  }
  if ( NumParam < 5 )
  {
    v7 = DCONST_DVARINT_bg_compassDecoyPingMagnitude;
    if ( !DCONST_DVARINT_bg_compassDecoyPingMagnitude && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_compassDecoyPingMagnitude") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v7);
    Int = v7->current.integer;
  }
  else
  {
    Int = Scr_GetInt(scrContext, 4u);
    if ( Int < 0 )
      Scr_Error(COM_ERR_3060, scrContext, "PingLocationEnemyTeams(): Invalid magnitude.\n");
  }
  ConstString = Scr_GetConstString(scrContext, 1u);
  if ( Com_Teams_TeamFromString(ConstString, &outTeam) )
  {
    v11 = G_Utils_SpawnEventEntity(&vectorValue, 157);
    v12 = 0;
    p_clientMask = &v11->clientMask;
    v11->clientMask.array[0] = -1;
    *(_QWORD *)&v11->clientMask.array[1] = -1i64;
    *(_QWORD *)&v11->clientMask.array[3] = -1i64;
    *(_QWORD *)&v11->clientMask.array[5] = -1i64;
    v11->s.eventParm = integer;
    v11->s.time2 = Int;
    v11->s.otherEntityNum = number;
    v14 = g_entities;
    if ( (int)SvClient::ms_clientCount > 0 )
    {
      v15 = outTeam;
      v16 = 0i64;
      v17 = 0i64;
      do
      {
        if ( (unsigned int)v12 >= 0x800 )
        {
          LODWORD(v20) = 2048;
          LODWORD(v19) = v12;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v19, v20) )
            __debugbreak();
        }
        if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
          __debugbreak();
        if ( g_entities[v17].r.isInUse != g_entityIsInUse[v16] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
          __debugbreak();
        if ( g_entityIsInUse[v16] )
        {
          client = v14->client;
          if ( client )
          {
            if ( client->sess.cs.team != v15 )
              bitarray_base<bitarray<224>>::resetBit(p_clientMask, v14->s.number);
          }
        }
        ++v12;
        ++v16;
        ++v17;
        ++v14;
      }
      while ( v12 < (int)SvClient::ms_clientCount );
    }
  }
  else
  {
    v9 = SL_ConvertToString(ConstString);
    v10 = j_va("unknown team '%s'", v9);
    Scr_Error(COM_ERR_3061, scrContext, v10);
  }
}

/*
==============
ScrCmd_TriggerPortableRadarPing
==============
*/

void __fastcall ScrCmd_TriggerPortableRadarPing(scrContext_t *scrContext, __int64 a2, double _XMM2_8)
{
  unsigned int NumParam; 
  gentity_s *Entity; 
  int integer; 
  const dvar_t *v9; 
  const char *String; 
  unsigned int PerkCodeIndexForName; 
  unsigned int number; 
  gentity_s *v15; 
  vec3_t vectorValue; 

  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam - 2 > 3 )
    Scr_Error(COM_ERR_3062, scrContext, "TriggerPortableRadarPing(): Invalid parameters. Check documentation.\n");
  Scr_GetVector(scrContext, 0, &vectorValue);
  Entity = GScr_GetEntity(1u);
  if ( NumParam < 3 )
  {
    _RBP = DCONST_DVARFLT_bg_compassPortableRadarTriggeredRadius;
    if ( !DCONST_DVARFLT_bg_compassPortableRadarTriggeredRadius && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_compassPortableRadarTriggeredRadius") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(_RBP);
    __asm { vcvttss2si r14d, dword ptr [rbp+28h] }
  }
  else
  {
    _ER14 = Scr_GetInt(scrContext, 2u);
    if ( _ER14 < 0 )
      Scr_Error(COM_ERR_3063, scrContext, "TriggerPortableRadarPing(): Invalid radius.\n");
  }
  if ( NumParam < 4 )
  {
    v9 = DCONST_DVARINT_bg_compassPortableRadarTriggeredSweepTime;
    if ( !DCONST_DVARINT_bg_compassPortableRadarTriggeredSweepTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_compassPortableRadarTriggeredSweepTime") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v9);
    integer = v9->current.integer;
  }
  else
  {
    integer = Scr_GetInt(scrContext, 3u);
    if ( integer < 0 )
      Scr_Error(COM_ERR_3064, scrContext, "TriggerPortableRadarPing(): Invalid sweep time.\n");
  }
  if ( NumParam < 5 )
  {
    PerkCodeIndexForName = 68;
  }
  else
  {
    String = Scr_GetString(scrContext, 4u);
    PerkCodeIndexForName = BG_GetPerkCodeIndexForName(String);
    if ( PerkCodeIndexForName == 68 )
      Scr_Error(COM_ERR_6534, scrContext, "TriggerPortableRadarPing(): Invalid perk name.\n");
  }
  if ( SV_BotIsBotEnt(Entity) )
  {
    __asm
    {
      vxorps  xmm2, xmm2, xmm2
      vcvtsi2ss xmm2, xmm2, r14d; radius
    }
    SV_BotKnownEnemiesRadial(Entity, &vectorValue, *(float *)&_XMM2, 0x1Au);
  }
  if ( Entity->client )
  {
    number = Entity->s.number;
    v15 = G_Utils_SpawnEventEntity(&vectorValue, 198);
    *(_QWORD *)v15->clientMask.array = -1i64;
    *(_QWORD *)&v15->clientMask.array[2] = -1i64;
    *(_QWORD *)&v15->clientMask.array[4] = -1i64;
    v15->clientMask.array[6] = -1;
    if ( number >= 0xE0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 290, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", number, 224) )
      __debugbreak();
    v15->clientMask.array[(unsigned __int64)number >> 5] &= ~(0x80000000 >> (number & 0x1F));
    v15->s.time2 = integer;
    v15->s.eventParm = _ER14;
    v15->s.eventParm2 = PerkCodeIndexForName;
  }
  else if ( !SV_BotIsBotEnt(Entity) )
  {
    Scr_Error(COM_ERR_3065, scrContext, "TriggerPortableRadarPing(): Owner must be a player or agent player.\n");
  }
}

/*
==============
ScrCmd_TriggerPortableRadarPingTeam
==============
*/

void __fastcall ScrCmd_TriggerPortableRadarPingTeam(scrContext_t *scrContext, __int64 a2, double _XMM2_8)
{
  unsigned int NumParam; 
  scr_string_t ConstString; 
  const char *v6; 
  const char *v7; 
  int integer; 
  const dvar_t *v11; 
  gentity_s *v12; 
  bitarray_base<bitarray<224> > *p_clientMask; 
  signed int v14; 
  gentity_s *v15; 
  team_t v16; 
  __int64 v17; 
  __int64 v18; 
  gclient_s *client; 
  __int64 v21; 
  __int64 v22; 
  team_t outTeam; 
  vec3_t vectorValue; 

  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam - 2 > 2 )
    Scr_Error(COM_ERR_3066, scrContext, "TriggerPortableRadarPingTeam(): Invalid parameters. Check documentation.\n");
  Scr_GetVector(scrContext, 0, &vectorValue);
  ConstString = Scr_GetConstString(scrContext, 1u);
  if ( Com_Teams_TeamFromString(ConstString, &outTeam) )
  {
    if ( NumParam < 3 )
    {
      _RDI = DCONST_DVARFLT_bg_compassPortableRadarTriggeredRadius;
      if ( !DCONST_DVARFLT_bg_compassPortableRadarTriggeredRadius && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_compassPortableRadarTriggeredRadius") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(_RDI);
      __asm { vcvttss2si r14d, dword ptr [rdi+28h] }
    }
    else
    {
      _ER14 = Scr_GetInt(scrContext, 2u);
      if ( _ER14 < 0 )
        Scr_Error(COM_ERR_3068, scrContext, "TriggerPortableRadarPingTeam(): Invalid radius.\n");
    }
    if ( NumParam < 4 )
    {
      v11 = DCONST_DVARINT_bg_compassPortableRadarTriggeredSweepTime;
      if ( !DCONST_DVARINT_bg_compassPortableRadarTriggeredSweepTime && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_compassPortableRadarTriggeredSweepTime") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v11);
      integer = v11->current.integer;
    }
    else
    {
      integer = Scr_GetInt(scrContext, 3u);
      if ( integer < 0 )
        Scr_Error(COM_ERR_3069, scrContext, "TriggerPortableRadarPingTeam(): Invalid sweep time.\n");
    }
    v12 = G_Utils_SpawnEventEntity(&vectorValue, 198);
    v12->s.time2 = integer;
    p_clientMask = &v12->clientMask;
    v12->s.eventParm = _ER14;
    v14 = 0;
    v12->clientMask.array[0] = -1;
    *(_QWORD *)&v12->clientMask.array[1] = -1i64;
    *(_QWORD *)&v12->clientMask.array[3] = -1i64;
    *(_QWORD *)&v12->clientMask.array[5] = -1i64;
    v15 = g_entities;
    if ( (int)SvClient::ms_clientCount > 0 )
    {
      v16 = outTeam;
      v17 = 0i64;
      v18 = 0i64;
      do
      {
        if ( (unsigned int)v14 >= 0x800 )
        {
          LODWORD(v22) = 2048;
          LODWORD(v21) = v14;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v21, v22) )
            __debugbreak();
        }
        if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
          __debugbreak();
        if ( g_entities[v18].r.isInUse != g_entityIsInUse[v17] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
          __debugbreak();
        if ( g_entityIsInUse[v17] )
        {
          client = v15->client;
          if ( client )
          {
            if ( client->sess.cs.team == v16 )
            {
              if ( SV_BotIsBotEnt(v15) )
              {
                __asm
                {
                  vxorps  xmm2, xmm2, xmm2
                  vcvtsi2ss xmm2, xmm2, r14d; radius
                }
                SV_BotKnownEnemiesRadial(v15, &vectorValue, *(float *)&_XMM2_8, 0x1Au);
              }
              bitarray_base<bitarray<224>>::resetBit(p_clientMask, v15->s.number);
            }
          }
        }
        ++v14;
        ++v17;
        ++v18;
        ++v15;
      }
      while ( v14 < (int)SvClient::ms_clientCount );
    }
  }
  else
  {
    v6 = SL_ConvertToString(ConstString);
    v7 = j_va("unknown team '%s'", v6);
    Scr_Error(COM_ERR_3067, scrContext, v7);
  }
}

/*
==============
ScrCmd_IsDedicatedServer
==============
*/
void ScrCmd_IsDedicatedServer(scrContext_t *scrContext)
{
  Scr_AddInt(scrContext, 0);
}

/*
==============
ScrCmd_GetDediServerGuid
==============
*/
void ScrCmd_GetDediServerGuid(scrContext_t *scrContext)
{
  Scr_AddString(scrContext, (const char *)&queryFormat.fmt + 3);
}

/*
==============
ScrCmd_GetPlaylistVersion
==============
*/
void ScrCmd_GetPlaylistVersion(scrContext_t *scrContext)
{
  int VersionNumber; 

  VersionNumber = Playlist_GetVersionNumber();
  Scr_AddInt(scrContext, VersionNumber);
}

/*
==============
ScrCmd_GetPlaylistID
==============
*/
void ScrCmd_GetPlaylistID(scrContext_t *scrContext)
{
  const dvar_t *v2; 
  int PlaylistIdForNum; 

  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
    Scr_Error(COM_ERR_3070, scrContext, "Not supported for front-end server");
  v2 = DVARINT_playlist;
  if ( !DVARINT_playlist && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "playlist") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  PlaylistIdForNum = Playlist_GetPlaylistIdForNum(v2->current.integer);
  Scr_AddInt(scrContext, PlaylistIdForNum);
}

/*
==============
ScrCmd_GetPlaylistName
==============
*/
void ScrCmd_GetPlaylistName(scrContext_t *scrContext)
{
  const dvar_t *v2; 
  int PlaylistIdForNum; 
  const char *PlaylistName; 

  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
    Scr_Error(COM_ERR_6535, scrContext, "Not supported for front-end server");
  v2 = DVARINT_playlist;
  if ( !DVARINT_playlist && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "playlist") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  PlaylistIdForNum = Playlist_GetPlaylistIdForNum(v2->current.integer);
  PlaylistName = Playlist_GetPlaylistName(PlaylistIdForNum);
  Scr_AddString(scrContext, PlaylistName);
}

/*
==============
ScrCmd_GetActiveClientCount
==============
*/
void ScrCmd_GetActiveClientCount(scrContext_t *scrContext)
{
  int v2; 
  int Int; 
  signed int i; 
  SvClientConnectionState state; 

  v2 = 0;
  if ( Scr_GetNumParam(scrContext) )
    Int = Scr_GetInt(scrContext, 0);
  else
    Int = 0;
  for ( i = 0; i < (int)SvClient::ms_clientCount; ++i )
  {
    state = SvClient::GetCommonClient(i)->state;
    if ( Int && (unsigned __int8)state >= CS_CONNECTED || state == CS_ACTIVE )
      ++v2;
  }
  Scr_AddInt(scrContext, v2);
}

/*
==============
ScrCmd_EnablePlayerUse
==============
*/
void ScrCmd_EnablePlayerUse(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  unsigned __int16 v5; 
  gagent_s *agent; 
  const char *v7; 
  unsigned __int16 v8; 
  int v9; 

  entnum = entref.entnum;
  Entity = GScr_GetEntity(0);
  if ( SV_IsAgentEntity(Entity) )
  {
    v5 = truncate_cast<unsigned short,unsigned int>(entnum);
    if ( !SV_AgentSetEntUsable(Entity, v5) )
    {
      agent = Entity->agent;
      v9 = agent->useEntsEnabled[1];
      v7 = j_va("Agent entity %i could not enable entity %i for use, probably exceeded max enabled ents (%i, %i)", (unsigned int)Entity->s.number, entnum, agent->useEntsEnabled[0], v9);
      Scr_Error(COM_ERR_3071, scrContext, v7);
    }
  }
  else if ( Entity->client )
  {
    v8 = truncate_cast<unsigned short,unsigned int>(entnum);
    G_Client_SetEntUsable(Entity->client, v8);
  }
  else
  {
    Scr_ParamError(COM_ERR_3072, scrContext, 0, "entity is not a player or agent\n");
  }
}

/*
==============
ScrCmd_DisablePlayerUse
==============
*/
void ScrCmd_DisablePlayerUse(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *Entity; 
  unsigned __int16 v5; 
  unsigned __int16 v6; 

  entnum = entref.entnum;
  Entity = GScr_GetEntity(0);
  if ( SV_IsAgentEntity(Entity) )
  {
    v5 = truncate_cast<unsigned short,unsigned int>(entnum);
    SV_AgentSetEntUnusable(Entity, v5);
  }
  else if ( Entity->client )
  {
    v6 = truncate_cast<unsigned short,unsigned int>(entnum);
    G_Client_SetEntUnusable(Entity->client, v6);
  }
  else
  {
    Scr_ParamError(COM_ERR_3073, scrContext, 0, "entity is not a player or agent\n");
  }
}

/*
==============
ScrCmd_EnablePlayerUseForAllPlayers
==============
*/
void ScrCmd_EnablePlayerUseForAllPlayers(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  int v3; 
  int maxclients; 
  __int64 v5; 
  gentity_s *v6; 
  gclient_s *client; 

  entnum = entref.entnum;
  v3 = 0;
  maxclients = level.maxclients;
  if ( level.maxclients > 0 )
  {
    v5 = 0i64;
    do
    {
      v6 = &g_entities[v5];
      if ( &g_entities[v5] )
      {
        client = v6->client;
        if ( client )
        {
          if ( entnum > 0xFFFF )
          {
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned short __cdecl truncate_cast_impl<unsigned short,unsigned int>(unsigned int)", "unsigned", (unsigned __int16)entnum, "unsigned", entnum) )
              __debugbreak();
            client = v6->client;
          }
          G_Client_SetEntUsable(client, entnum);
          maxclients = level.maxclients;
        }
      }
      ++v3;
      ++v5;
    }
    while ( v3 < maxclients );
  }
}

/*
==============
ScrCmd_DisablePlayerUseForAllPlayers
==============
*/
void ScrCmd_DisablePlayerUseForAllPlayers(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  int v3; 
  int maxclients; 
  __int64 v5; 
  gentity_s *v6; 
  gclient_s *client; 

  entnum = entref.entnum;
  v3 = 0;
  maxclients = level.maxclients;
  if ( level.maxclients > 0 )
  {
    v5 = 0i64;
    do
    {
      v6 = &g_entities[v5];
      if ( &g_entities[v5] )
      {
        client = v6->client;
        if ( client )
        {
          if ( entnum > 0xFFFF )
          {
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned short __cdecl truncate_cast_impl<unsigned short,unsigned int>(unsigned int)", "unsigned", (unsigned __int16)entnum, "unsigned", entnum) )
              __debugbreak();
            client = v6->client;
          }
          G_Client_SetEntUnusable(client, entnum);
          maxclients = level.maxclients;
        }
      }
      ++v3;
      ++v5;
    }
    while ( v3 < maxclients );
  }
}

/*
==============
GScr_TurretMP_SetMode
==============
*/
void GScr_TurretMP_SetMode(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  const char *v5; 
  const char *v6; 
  scr_string_t ConstString; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_3074, scrContext, v6);
  }
  ConstString = Scr_GetConstString(scrContext, 0);
  if ( ConstString == scr_const.manual )
  {
    G_Turret_SetMode(v4, 0);
  }
  else if ( ConstString == scr_const.manual_ai )
  {
    Scr_ParamError(COM_ERR_3075, scrContext, 0, "'manual_ai' is not support in MP");
  }
  else if ( ConstString == scr_const.auto_nonai )
  {
    G_Turret_SetMode(v4, 4);
  }
  else if ( ConstString == scr_const.auto_ai )
  {
    Scr_ParamError(COM_ERR_3076, scrContext, 0, "'auto_ai' is not support in MP");
  }
  else if ( ConstString == scr_const.manual_target )
  {
    G_Turret_SetMode(v4, 2052);
  }
  else if ( ConstString == scr_const.sentry )
  {
    G_Turret_SetMode(v4, 12);
  }
  else if ( ConstString == scr_const.sentry_offline )
  {
    G_Turret_SetMode(v4, 1032);
  }
  else
  {
    Scr_Error(COM_ERR_3077, scrContext, "Error setting the mode of a turret.\n");
  }
}

/*
==============
GScr_TurretMP_GetMode
==============
*/
void GScr_TurretMP_GetMode(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 
  const char *v5; 
  const char *v6; 
  __int64 v7; 
  bool v8; 
  GTurret **v9; 
  int flags; 
  scr_string_t sentry; 
  __int64 v12; 
  int v13; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v5 = SL_ConvertToString(Entity->classname);
    v6 = j_va("entity type '%s' is not a turret", v5);
    Scr_Error(COM_ERR_3078, scrContext, v6);
  }
  if ( !v4->turretHandle.m_objIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_object_handle.h", 36, ASSERT_TYPE_ASSERT, "(IsDefined())", "%s\n\tCan't get the index of an undefined handle", "IsDefined()") )
    __debugbreak();
  v7 = v4->turretHandle.m_objIndex - 1;
  if ( !(_BYTE)GTurret::ms_allocatedType && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_turret.h", 226, ASSERT_TYPE_ASSERT, "( ms_allocatedType != GameModeType::NONE )", (const char *)&queryFormat, "ms_allocatedType != GameModeType::NONE") )
    __debugbreak();
  if ( (unsigned int)v7 >= 0x80 )
  {
    v13 = 128;
    LODWORD(v12) = v7;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_turret.h", 227, ASSERT_TYPE_ASSERT, "(unsigned)( turretIndex ) < (unsigned)( ( sizeof( *array_counter( ms_turretArray ) ) + 0 ) )", "turretIndex doesn't index ARRAY_COUNT( ms_turretArray )\n\t%i not in [0, %i)", v12, v13) )
      __debugbreak();
  }
  v8 = GTurret::ms_turretArray[v7] == NULL;
  v9 = &GTurret::ms_turretArray[v7];
  if ( v8 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_turret.h", 228, ASSERT_TYPE_ASSERT, "( ms_turretArray[turretIndex] )", (const char *)&queryFormat, "ms_turretArray[turretIndex]") )
    __debugbreak();
  flags = (*v9)->m_data.flags;
  if ( (flags & 0xC) != 0 )
  {
    sentry = scr_const.sentry;
  }
  else
  {
    sentry = scr_const.auto_nonai;
    if ( (flags & 4) == 0 )
      sentry = scr_const.manual;
  }
  Scr_AddConstString(scrContext, sentry);
}

/*
==============
GScr_PlayCinematicForPlayer
==============
*/
void GScr_PlayCinematicForPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *String; 
  const char *v5; 
  unsigned int number; 
  const char *v7; 
  SvClient *CommonClient; 

  Entity = GetEntity(entref);
  String = Scr_GetString(scrContext, 0);
  v5 = j_va("%c \"%s\" %d", 51i64, String, 0i64);
  number = Entity->s.number;
  v7 = v5;
  if ( number == -1 )
  {
    SV_Game_BroadcastServerCommand(SV_CMD_CAN_IGNORE, v5);
  }
  else
  {
    CommonClient = SvClient::GetCommonClient(number);
    CommonClient->SendServerCommand(CommonClient, SV_CMD_CAN_IGNORE, v7);
  }
}

/*
==============
GScr_PlayCinematicForPlayerLooping
==============
*/
void GScr_PlayCinematicForPlayerLooping(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *String; 
  const char *v5; 
  unsigned int number; 
  const char *v7; 
  SvClient *CommonClient; 

  Entity = GetEntity(entref);
  String = Scr_GetString(scrContext, 0);
  v5 = j_va("%c \"%s\"", 53i64, String);
  number = Entity->s.number;
  v7 = v5;
  if ( number == -1 )
  {
    SV_Game_BroadcastServerCommand(SV_CMD_CAN_IGNORE, v5);
  }
  else
  {
    CommonClient = SvClient::GetCommonClient(number);
    CommonClient->SendServerCommand(CommonClient, SV_CMD_CAN_IGNORE, v7);
  }
}

/*
==============
GScr_PreloadCinematicForPlayer
==============
*/
void GScr_PreloadCinematicForPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *String; 
  const char *v5; 
  unsigned int number; 
  const char *v7; 
  SvClient *CommonClient; 

  Entity = GetEntity(entref);
  String = Scr_GetString(scrContext, 0);
  v5 = j_va("%c \"%s\" %d", 51i64, String, 1i64);
  number = Entity->s.number;
  v7 = v5;
  if ( number == -1 )
  {
    SV_Game_BroadcastServerCommand(SV_CMD_CAN_IGNORE, v5);
  }
  else
  {
    CommonClient = SvClient::GetCommonClient(number);
    CommonClient->SendServerCommand(CommonClient, SV_CMD_CAN_IGNORE, v7);
  }
}

/*
==============
GScr_StopCinematicForPlayer
==============
*/
void GScr_StopCinematicForPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *v3; 
  unsigned int number; 
  const char *v5; 
  SvClient *CommonClient; 

  Entity = GetEntity(entref);
  v3 = j_va("%c", 52i64);
  number = Entity->s.number;
  v5 = v3;
  if ( number == -1 )
  {
    SV_Game_BroadcastServerCommand(SV_CMD_CAN_IGNORE, v3);
  }
  else
  {
    CommonClient = SvClient::GetCommonClient(number);
    CommonClient->SendServerCommand(CommonClient, SV_CMD_CAN_IGNORE, v5);
  }
}

/*
==============
GScr_PlayCinematicForAll
==============
*/
void GScr_PlayCinematicForAll(scrContext_t *scrContext)
{
  const char *String; 
  const char *v2; 

  String = Scr_GetString(scrContext, 0);
  v2 = j_va("%c \"%s\" %d", 51i64, String, 0i64);
  SV_Game_BroadcastServerCommand(SV_CMD_CAN_IGNORE, v2);
}

/*
==============
GScr_PlayEncryptedCinematicForAll
==============
*/
void GScr_PlayEncryptedCinematicForAll(scrContext_t *scrContext)
{
  const char *String; 
  const char *v2; 
  unsigned __int64 keyByte16; 
  unsigned __int64 keyByte8; 
  unsigned __int64 keyByte0; 

  String = Scr_GetString(scrContext, 0);
  BinkKey_ExtractKeyBytes(String, &keyByte0, &keyByte8, &keyByte16);
  v2 = j_va("%c \"%s\" %d %llu %llu %llu", 61i64, String, 0i64, keyByte0, keyByte8, keyByte16);
  SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v2);
}

/*
==============
GScr_PlayEncryptedCinematicForPlayer
==============
*/
void GScr_PlayEncryptedCinematicForPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *String; 
  const char *v5; 
  unsigned int number; 
  const char *v7; 
  SvClient *CommonClient; 
  unsigned __int64 keyByte0[3]; 
  unsigned __int64 keyByte16; 
  unsigned __int64 keyByte8; 

  Entity = GetEntity(entref);
  String = Scr_GetString(scrContext, 0);
  BinkKey_ExtractKeyBytes(String, keyByte0, &keyByte8, &keyByte16);
  v5 = j_va("%c \"%s\" %d %llu %llu %llu", 61i64, String, 0i64, keyByte0[0], keyByte8, keyByte16);
  number = Entity->s.number;
  v7 = v5;
  if ( number == -1 )
  {
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v5);
  }
  else
  {
    CommonClient = SvClient::GetCommonClient(number);
    CommonClient->SendServerCommand(CommonClient, SV_CMD_RELIABLE, v7);
  }
}

/*
==============
GScr_PlayCinematicForAllLooping
==============
*/
void GScr_PlayCinematicForAllLooping(scrContext_t *scrContext)
{
  const char *String; 
  const char *v2; 

  String = Scr_GetString(scrContext, 0);
  v2 = j_va("%c \"%s\"", 53i64, String);
  SV_Game_BroadcastServerCommand(SV_CMD_CAN_IGNORE, v2);
}

/*
==============
GScr_PreloadCinematicForAll
==============
*/
void GScr_PreloadCinematicForAll(scrContext_t *scrContext)
{
  const char *String; 
  const char *v2; 

  String = Scr_GetString(scrContext, 0);
  v2 = j_va("%c \"%s\" %d", 51i64, String, 1i64);
  SV_Game_BroadcastServerCommand(SV_CMD_CAN_IGNORE, v2);
}

/*
==============
GScr_StopCinematicForAll
==============
*/
void GScr_StopCinematicForAll(scrContext_t *scrContext)
{
  const char *v1; 

  v1 = j_va("%c", 52i64);
  SV_Game_BroadcastServerCommand(SV_CMD_CAN_IGNORE, v1);
}

/*
==============
GScr_LogPrint
==============
*/
void GScr_LogPrint(scrContext_t *scrContext)
{
  int v2; 
  signed int NumParam; 
  signed int i; 
  const char *String; 
  __int64 v6; 
  char dest[1024]; 

  dest[0] = 0;
  v2 = 0;
  NumParam = Scr_GetNumParam(scrContext);
  for ( i = 0; i < NumParam; ++i )
  {
    String = Scr_GetString(scrContext, i);
    v6 = -1i64;
    do
      ++v6;
    while ( String[v6] );
    v2 += v6;
    if ( v2 >= 1024 )
      break;
    I_strcat(dest, 0x400ui64, String);
  }
  G_MainMP_LogPrintf((const char *)&queryFormat, dest);
}

/*
==============
GScr_AnalyticsStreamerLogFileStartStream
==============
*/
void GScr_AnalyticsStreamerLogFileStartStream(scrContext_t *scrContext)
{
  const dvar_t *v1; 
  const char *HostName; 
  unsigned __int64 MatchId; 
  char *fmt; 
  __int64 v5; 
  __int64 v6; 
  int tm_hour; 
  int tm_min; 
  int tm_sec; 
  qtime_s qtime; 
  char dest[256]; 

  v1 = DVARBOOL_online_should_upload_analytics_streamer_log_file;
  if ( !DVARBOOL_online_should_upload_analytics_streamer_log_file && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "online_should_upload_analytics_streamer_log_file") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  if ( v1->current.enabled )
  {
    HostName = SV_GameMP_GetHostName();
    Com_RealTime(0, &qtime);
    tm_sec = qtime.tm_sec;
    tm_min = qtime.tm_min;
    tm_hour = qtime.tm_hour;
    LODWORD(v6) = qtime.tm_mday;
    LODWORD(v5) = qtime.tm_mon + 1;
    LODWORD(fmt) = qtime.tm_year - 100;
    Com_sprintf(dest, 0x100ui64, "games_mp_log_%s_%02d_%02d_%02d_%02d%02d%02d", HostName, fmt, v5, v6, tm_hour, tm_min, tm_sec);
    AnalyticsStreamer_StartStream(ANALYTICS_STREAMER_LOG_FILE, dest);
    MatchId = OnlineMatchId::GetMatchId();
    AnalyticsStreamer_AddTag(ANALYTICS_STREAMER_LOG_FILE, 8ui64, MatchId);
    AnalyticsStreamer_AddTag(ANALYTICS_STREAMER_LOG_FILE, 9ui64, 0i64);
  }
  else if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 3980, ASSERT_TYPE_ASSERT, "(mpLogStreamerEnabled)", (const char *)&queryFormat, "mpLogStreamerEnabled") )
  {
    __debugbreak();
  }
}

/*
==============
GScr_AnalyticsStreamerLogFileEndStream
==============
*/
void GScr_AnalyticsStreamerLogFileEndStream(scrContext_t *scrContext)
{
  const dvar_t *v1; 

  v1 = DVARBOOL_online_should_upload_analytics_streamer_log_file;
  if ( !DVARBOOL_online_should_upload_analytics_streamer_log_file && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "online_should_upload_analytics_streamer_log_file") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  if ( v1->current.enabled )
  {
    AnalyticsStreamer_EndStream(ANALYTICS_STREAMER_LOG_FILE);
  }
  else if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 4021, ASSERT_TYPE_ASSERT, "(mpLogStreamerEnabled)", (const char *)&queryFormat, "mpLogStreamerEnabled") )
  {
    __debugbreak();
  }
}

/*
==============
GScr_AnalyticsStreamerLogFileWriteToBuffer
==============
*/
void GScr_AnalyticsStreamerLogFileWriteToBuffer(scrContext_t *scrContext)
{
  const dvar_t *v1; 
  int v3; 
  __int64 v4; 
  signed int NumParam; 
  signed int i; 
  const char *String; 
  __int64 v8; 
  int v9; 
  char *fmt; 
  __int64 v11; 
  char dest[1024]; 
  char data[1024]; 

  v1 = DVARBOOL_online_should_upload_analytics_streamer_log_file;
  if ( !DVARBOOL_online_should_upload_analytics_streamer_log_file && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "online_should_upload_analytics_streamer_log_file") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  if ( v1->current.enabled )
  {
    v3 = 0;
    dest[0] = 0;
    v4 = -1i64;
    NumParam = Scr_GetNumParam(scrContext);
    for ( i = 0; i < NumParam; ++i )
    {
      String = Scr_GetString(scrContext, i);
      v8 = -1i64;
      do
        ++v8;
      while ( String[v8] );
      v3 += v8;
      if ( v3 >= 1024 )
        break;
      I_strcat(dest, 0x400ui64, String);
    }
    v9 = level.time / 1000 % 60;
    LODWORD(v11) = v9 % 10;
    LODWORD(fmt) = v9 / 10;
    Com_sprintf(data, 0x400ui64, "%3i:%i%i %s", (unsigned int)(level.time / 1000 / 60), fmt, v11, dest);
    do
      ++v4;
    while ( data[v4] );
    AnalyticsStreamer_WriteToBuffer(ANALYTICS_STREAMER_LOG_FILE, data, v4);
  }
  else if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 4052, ASSERT_TYPE_ASSERT, "(mpLogStreamerEnabled)", (const char *)&queryFormat, "mpLogStreamerEnabled") )
  {
    __debugbreak();
  }
}

/*
==============
GScr_AnalyticsStreamerLogFileTagPlayer
==============
*/
void GScr_AnalyticsStreamerLogFileTagPlayer(scrContext_t *scrContext)
{
  const dvar_t *v2; 
  const char *String; 
  const XUID *v4; 
  unsigned __int64 UniversalId; 
  XUID v6; 
  XUID result; 

  XUID::XUID(&v6);
  v2 = DVARBOOL_online_should_upload_analytics_streamer_log_file;
  if ( !DVARBOOL_online_should_upload_analytics_streamer_log_file && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "online_should_upload_analytics_streamer_log_file") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  if ( v2->current.enabled )
  {
    String = Scr_GetString(scrContext, 0);
    v4 = XUID::FromString(&result, String);
    XUID::operator=(&v6, v4);
    UniversalId = XUID::GetUniversalId(&v6);
    AnalyticsStreamer_AddTag(ANALYTICS_STREAMER_LOG_FILE, 4ui64, UniversalId);
  }
  else if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 4103, ASSERT_TYPE_ASSERT, "(mpLogStreamerEnabled)", (const char *)&queryFormat, "mpLogStreamerEnabled") )
  {
    __debugbreak();
  }
}

/*
==============
GScr_AnalyticsStreamerIsLogFileStreamingEnabled
==============
*/
void GScr_AnalyticsStreamerIsLogFileStreamingEnabled(scrContext_t *scrContext)
{
  int v2; 
  const dvar_t *v3; 

  v2 = 0;
  if ( AnalyticsStreamer_IsSystemEnabled() )
  {
    v3 = DVARBOOL_online_should_upload_analytics_streamer_log_file;
    if ( !DVARBOOL_online_should_upload_analytics_streamer_log_file && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "online_should_upload_analytics_streamer_log_file") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v3);
    if ( v3->current.enabled )
      v2 = 1;
  }
  Scr_AddBool(scrContext, v2);
}

/*
==============
GScr_WorldEntNumber
==============
*/
void GScr_WorldEntNumber(scrContext_t *scrContext)
{
  Scr_AddInt(scrContext, 2046);
}

/*
==============
GScr_Obituary
==============
*/
void GScr_Obituary(scrContext_t *scrContext)
{
  signed int v2; 
  bool v3; 
  __int64 v4; 
  gentity_s *Entity; 
  int v6; 
  gentity_s *v7; 
  GWeaponMap *Instance; 
  BOOL v9; 
  __int16 number; 
  ClientBits *p_clientMask; 
  unsigned int ArrayObject; 
  unsigned int ArraySize; 
  int maxclients; 
  const char *NameForType; 
  const char *v16; 
  __int64 weaponIdx; 
  bool v18; 
  WeaponCompleteDef **v19; 
  Material *killIconMat; 
  MaterialTextureDef *textureTable; 
  scr_entref_t EntityIdRef; 
  gentity_s *v23; 
  unsigned int v24; 
  const char *v25; 
  unsigned int *failureIndex; 
  VariableType *failureType; 
  __int64 v28; 
  __int64 v29; 
  VariableType v30[4]; 
  unsigned int count; 
  bool outIsAlternate; 
  unsigned int v33; 
  Weapon outWeapon; 
  unsigned int buffer[200]; 

  if ( !Scr_GetNumParam(scrContext) || Scr_GetNumParam(scrContext) > 5 )
    Scr_Error(COM_ERR_4658, scrContext, "Incorrect number of parameters: GScr_Obituary( victim, attacker, weapon, weapon, <optional_obitPlayers> )\n");
  GScr_Main_GetWeaponParam(scrContext, 2u, &outWeapon, &outIsAlternate);
  v2 = G_Combat_MeansOfDeathFromScriptParam(scrContext, 3);
  v3 = 0;
  v4 = 0i64;
  Entity = GScr_GetEntity(0);
  if ( (unsigned int)v2 > 0x18 )
    goto LABEL_39;
  v6 = 31646464;
  if ( !_bittest(&v6, v2) )
    goto LABEL_39;
  v3 = 1;
  if ( v2 != 17 )
  {
    if ( v2 == 8 )
    {
      v3 = !BG_IsMeleeOnlyWeapon(&outWeapon, 0);
      if ( BG_IsRiotShield(&outWeapon, 0) )
        goto LABEL_8;
      goto LABEL_34;
    }
LABEL_39:
    if ( v2 == 12 )
    {
      weaponIdx = outWeapon.weaponIdx;
      if ( outWeapon.weaponIdx > bg_lastParsedWeaponIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1218, ASSERT_TYPE_ASSERT, "( weaponIndex ) <= ( bg_lastParsedWeaponIndex )", "weaponIndex not in [0, bg_lastParsedWeaponIndex]\n\t%u not in [0, %u]", outWeapon.weaponIdx, bg_lastParsedWeaponIndex) )
        __debugbreak();
      v18 = bg_weaponCompleteDefs[weaponIdx] == NULL;
      v19 = &bg_weaponCompleteDefs[weaponIdx];
      if ( v18 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1219, ASSERT_TYPE_ASSERT, "(bg_weaponCompleteDefs[weaponIndex])", (const char *)&queryFormat, "bg_weaponCompleteDefs[weaponIndex]") )
        __debugbreak();
      killIconMat = (*v19)->killIconMat;
      if ( killIconMat )
      {
        textureTable = killIconMat->textureTable;
        if ( textureTable )
        {
          if ( textureTable->image )
            goto LABEL_8;
        }
      }
      goto LABEL_35;
    }
LABEL_34:
    if ( v3 )
      goto LABEL_35;
LABEL_8:
    v7 = G_Utils_SpawnEventEntity(&vec3_origin, 154);
    Instance = GWeaponMap::GetInstance();
    if ( !Instance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 489, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
      __debugbreak();
    if ( v7 == (gentity_s *)-156i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 490, ASSERT_TYPE_ASSERT, "(eventParm)", (const char *)&queryFormat, "eventParm") )
      __debugbreak();
    if ( outWeapon.weaponIdx >= BG_GetNumWeapons() )
    {
      LODWORD(failureType) = BG_GetNumWeapons();
      LODWORD(failureIndex) = outWeapon.weaponIdx;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 491, ASSERT_TYPE_ASSERT, "(unsigned)( r_weapon.weaponIdx ) < (unsigned)( BG_GetNumWeapons() )", "r_weapon.weaponIdx doesn't index BG_GetNumWeapons()\n\t%i not in [0, %i)", failureIndex, failureType) )
        __debugbreak();
    }
    Instance->SetWeapon(Instance, (BgWeaponHandle *)&v7->s.eventParm, &outWeapon);
    goto LABEL_18;
  }
  if ( BG_GetWeaponClass(&outWeapon, 0) == WEAPCLASS_THROWINGKNIFE )
    goto LABEL_8;
LABEL_35:
  v7 = G_Utils_SpawnEventEntity(&vec3_origin, 155);
  if ( v2 >= 25 )
  {
    LODWORD(failureType) = v2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 4232, ASSERT_TYPE_ASSERT, "(meansOfDeath < MOD_NUM)", "%s\n\tMOD value of %d is not valid.\n", "meansOfDeath < MOD_NUM", failureType) )
      __debugbreak();
  }
  v7->s.eventParm = v2;
LABEL_18:
  v7->s.eventParm2 = 0;
  v7->s.otherEntityNum = Entity->s.number;
  v9 = v2 == 18;
  number = 2046;
  v7->s.eventParm2 = v9;
  if ( Scr_GetType(scrContext, 1u) == VAR_POINTER && Scr_GetPointerType(scrContext, 1u) == VAR_ENTITY )
    number = GScr_GetEntity(1u)->s.number;
  v7->s.attackerEntityNum = number;
  if ( Scr_GetNumParam(scrContext) == 5 && Scr_GetType(scrContext, 4u) )
  {
    p_clientMask = &v7->clientMask;
    count = 0;
    v7->clientMask.array[0] = -1;
    *(_QWORD *)&v7->clientMask.array[1] = -1i64;
    *(_QWORD *)&v7->clientMask.array[3] = -1i64;
    *(_QWORD *)&v7->clientMask.array[5] = -1i64;
    if ( Scr_GetType(scrContext, 4u) == VAR_POINTER && Scr_GetPointerType(scrContext, 4u) == VAR_ARRAY )
    {
      ArrayObject = BGScr_Main_GetArrayObject(scrContext, 4u);
      ArraySize = GetArraySize(scrContext, ArrayObject);
      maxclients = level.maxclients;
      count = ArraySize;
      if ( level.maxclients < 1 || (unsigned __int64)level.maxclients > 0xC8 )
      {
        LODWORD(failureType) = 1;
        LODWORD(failureIndex) = level.maxclients;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 4271, ASSERT_TYPE_ASSERT, "( 1 ) <= ( level.maxclients ) && ( level.maxclients ) <= ( ( sizeof( *array_counter( entities ) ) + 0 ) )", "level.maxclients not in [1, ARRAY_COUNT( entities )]\n\t%i not in [%i, %i]", failureIndex, failureType, 200) )
          __debugbreak();
        maxclients = level.maxclients;
      }
      if ( !Scr_GetEntityArray(scrContext, ArrayObject, maxclients, buffer, &count, &v33, v30) )
      {
        NameForType = Scr_GetNameForType(v30[0]);
        v16 = j_va("element %i of array: type %s is not an entity", v33, NameForType);
        Scr_ParamError(COM_ERR_4659, scrContext, 0, v16);
        return;
      }
    }
    else if ( Scr_GetType(scrContext, 4u) == VAR_POINTER && Scr_GetPointerType(scrContext, 4u) == VAR_ENTITY )
    {
      count = 1;
      buffer[0] = Scr_GetObject(scrContext, 4u);
    }
    if ( count )
    {
      do
      {
        EntityIdRef = Scr_GetEntityIdRef(scrContext, buffer[v4]);
        v23 = GetEntity(EntityIdRef);
        v24 = v23->s.number;
        if ( v23->client )
        {
          if ( v24 >= 0xE0 )
          {
            LODWORD(v29) = 224;
            LODWORD(v28) = v23->s.number;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\bitarray.h", 290, ASSERT_TYPE_ASSERT, "( pos ) < ( impl()->getBitCount() )", "%s < %s\n\t%u, %u", "pos", "impl()->getBitCount()", v28, v29) )
              __debugbreak();
          }
          p_clientMask->array[(unsigned __int64)v24 >> 5] &= ~(0x80000000 >> (v24 & 0x1F));
        }
        else
        {
          v25 = j_va("entity %i is not a player", v24);
          Scr_ObjectError(COM_ERR_4660, scrContext, v25);
        }
        v4 = (unsigned int)(v4 + 1);
      }
      while ( (unsigned int)v4 < count );
    }
  }
}

/*
==============
GScr_PositionWouldTelefrag
==============
*/
void GScr_PositionWouldTelefrag(scrContext_t *scrContext)
{
  gentity_s *Entity; 
  gclient_s *client; 
  gagent_s *agent; 
  GUtils *v15; 
  bool WouldTelefrag; 
  vec3_t vectorValue; 
  Bounds worldBounds; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  _RBX = &playerBox;
  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    Entity = GScr_GetEntity(1u);
    client = Entity->client;
    if ( client )
    {
      _RBX = (Bounds *)BG_Suit_GetBounds(client->ps.suitIndex, PM_EFF_STANCE_DEFAULT);
    }
    else
    {
      agent = Entity->agent;
      if ( agent )
        _RBX = (Bounds *)BG_Suit_GetBounds(agent->playerState.suitIndex, PM_EFF_STANCE_DEFAULT);
      else
        Scr_ParamError(COM_ERR_3079, scrContext, 1u, "Entity is not a client or agent.");
    }
  }
  __asm
  {
    vmovss  xmm0, dword ptr [rsp+68h+vectorValue]
    vaddss  xmm1, xmm0, dword ptr [rbx]
    vmovss  xmm2, dword ptr [rsp+68h+vectorValue+4]
    vmovss  dword ptr [rsp+68h+worldBounds.midPoint], xmm1
    vaddss  xmm0, xmm2, dword ptr [rbx+4]
    vmovss  xmm1, dword ptr [rsp+68h+vectorValue+8]
    vmovss  dword ptr [rsp+68h+worldBounds.midPoint+4], xmm0
    vaddss  xmm2, xmm1, dword ptr [rbx+8]
    vmovss  dword ptr [rsp+68h+worldBounds.midPoint+8], xmm2
    vmovss  xmm0, dword ptr [rbx+0Ch]
    vmovss  dword ptr [rsp+68h+worldBounds.halfSize], xmm0
    vmovss  xmm1, dword ptr [rbx+10h]
    vmovss  dword ptr [rsp+68h+worldBounds.halfSize+4], xmm1
    vmovss  xmm0, dword ptr [rbx+14h]
    vmovss  dword ptr [rsp+68h+worldBounds.halfSize+8], xmm0
  }
  if ( !GUtils::ms_gUtils && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_utils.h", 112, ASSERT_TYPE_ASSERT, "( ms_gUtils )", (const char *)&queryFormat, "ms_gUtils") )
    __debugbreak();
  v15 = GUtils::ms_gUtils;
  if ( !GUtils::ms_gUtils && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 4366, ASSERT_TYPE_ASSERT, "(gUtils)", (const char *)&queryFormat, "gUtils") )
    __debugbreak();
  WouldTelefrag = GUtils::WorldBoundsWouldTelefrag(v15, &worldBounds);
  Scr_AddInt(scrContext, WouldTelefrag);
}

/*
==============
GScr_CanSpawn
==============
*/
void GScr_CanSpawn(scrContext_t *scrContext)
{
  const Bounds *Bounds; 
  gentity_s *Entity; 
  gclient_s *client; 
  gagent_s *agent; 
  vec3_t vectorValue; 
  trace_t results; 

  Scr_GetVector(scrContext, 0, &vectorValue);
  Bounds = &playerBox;
  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    Entity = GScr_GetEntity(1u);
    client = Entity->client;
    if ( client )
    {
      Bounds = BG_Suit_GetBounds(client->ps.suitIndex, PM_EFF_STANCE_DEFAULT);
    }
    else
    {
      agent = Entity->agent;
      if ( agent )
        Bounds = BG_Suit_GetBounds(agent->playerState.suitIndex, PM_EFF_STANCE_DEFAULT);
      else
        Scr_ParamError(COM_ERR_3080, scrContext, 1u, "Entity is not a client or agent.");
    }
  }
  G_Main_TraceCapsule(&results, &vectorValue, &vectorValue, Bounds, 2047, 65553);
  Scr_AddInt(scrContext, !results.allsolid);
}

/*
==============
GScr_CapsuleTracePassed
==============
*/

void __fastcall GScr_CapsuleTracePassed(scrContext_t *scrContext, double _XMM1_8)
{
  char v9; 
  char v10; 
  int passEntityNum; 
  int contentmask; 
  Bounds bounds; 
  vec3_t vectorValue; 
  trace_t results; 
  char v24; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-18h], xmm6
    vmovaps xmmword ptr [rax-28h], xmm7
  }
  Scr_GetVector(scrContext, 0, &vectorValue);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
  __asm
  {
    vxorps  xmm1, xmm1, xmm1
    vcomiss xmm0, xmm1
    vmovaps xmm7, xmm0
  }
  if ( v9 | v10 )
    Scr_Error(COM_ERR_3081, scrContext, "CapsuleTrace capsule radius too small!");
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
  __asm
  {
    vmulss  xmm6, xmm0, cs:__real@3f000000
    vcomiss xmm6, xmm7
  }
  if ( v9 )
    Scr_Error(COM_ERR_3082, scrContext, "CapsuleTrace capsule half height must be greater than the radius!");
  __asm
  {
    vmovss  xmm0, dword ptr cs:?vec3_origin@@3Tvec3_t@@B; vec3_t const vec3_origin
    vmovss  xmm1, dword ptr cs:?vec3_origin@@3Tvec3_t@@B+4; vec3_t const vec3_origin
    vaddss  xmm2, xmm6, dword ptr cs:?vec3_origin@@3Tvec3_t@@B+8; vec3_t const vec3_origin
  }
  passEntityNum = 2047;
  __asm
  {
    vmovss  dword ptr [rsp+0F8h+bounds.midPoint], xmm0
    vmovss  dword ptr [rsp+0F8h+bounds.midPoint+4], xmm1
    vmovss  dword ptr [rsp+0F8h+bounds.midPoint+8], xmm2
    vmovss  dword ptr [rsp+0F8h+bounds.halfSize], xmm7
    vmovss  dword ptr [rsp+0F8h+bounds.halfSize+4], xmm7
    vmovss  dword ptr [rsp+0F8h+bounds.halfSize+8], xmm6
  }
  if ( Scr_GetNumParam(scrContext) > 3 && Scr_GetType(scrContext, 3u) == VAR_POINTER && Scr_GetPointerType(scrContext, 3u) == VAR_ENTITY )
    passEntityNum = GScr_GetEntity(3u)->s.number;
  contentmask = 33636369;
  if ( Scr_GetNumParam(scrContext) > 4 && !Scr_GetInt(scrContext, 4u) )
    contentmask = 65553;
  if ( Scr_GetNumParam(scrContext) > 5 && Scr_GetInt(scrContext, 5u) )
    contentmask |= 0x200u;
  G_Main_TraceCapsule(&results, &vectorValue, &vectorValue, &bounds, passEntityNum, contentmask);
  __asm
  {
    vmovss  xmm0, [rsp+0F8h+results.fraction]
    vcomiss xmm0, cs:__real@3f800000
  }
  Scr_AddBool(scrContext, 1);
  _R11 = &v24;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
  }
}

/*
==============
GScr_getStartTime
==============
*/
void GScr_getStartTime(scrContext_t *scrContext)
{
  Scr_AddInt(scrContext, level.startTime);
}

/*
==============
GScr_MapRestart
==============
*/
void GScr_MapRestart(scrContext_t *scrContext)
{
  const char *v2; 

  if ( level.finished )
  {
    v2 = "exitlevel already called";
    if ( level.finished == 1 )
      v2 = "map_restart already called";
    Scr_Error(COM_ERR_3083, scrContext, v2);
  }
  level.finished = 1;
  level.savepersist = 0;
  if ( Scr_GetNumParam(scrContext) )
    level.savepersist = Scr_GetInt(scrContext, 0);
  Cbuf_AddCall(LOCAL_CLIENT_0, SV_CmdsMP_FastRestart);
}

/*
==============
GScr_SpawnSightTrace
==============
*/
void GScr_SpawnSightTrace(scrContext_t *scrContext)
{
  vec3_t end; 
  vec3_t vectorValue; 

  Scr_GetVector(scrContext, 1u, &vectorValue);
  Scr_GetVector(scrContext, 2u, &end);
  *(double *)&_XMM0 = PhysicsQuery_LegacyBrushModelSightTraceAroundCorners(PHYSICS_WORLD_ID_FIRST, &vectorValue, &end, 6145);
  __asm { vmovaps xmm1, xmm0; value }
  Scr_AddFloat(scrContext, *(float *)&_XMM1);
}

/*
==============
GScr_ExitLevel
==============
*/
void GScr_ExitLevel(scrContext_t *scrContext)
{
  const char *v2; 
  unsigned int Int; 

  if ( level.finished )
  {
    v2 = "exitlevel already called";
    if ( level.finished == 1 )
      v2 = "map_restart already called";
    Scr_Error(COM_ERR_3084, scrContext, v2);
  }
  level.finished = 3;
  level.savepersist = 0;
  if ( Scr_GetNumParam(scrContext) )
  {
    Int = Scr_GetInt(scrContext, 0);
    level.savepersist = Int;
  }
  else
  {
    Int = level.savepersist;
  }
  Com_Printf(24, "ExitLevel() Called from script (%i)\n", Int);
  SV_MainMP_MatchEnd();
  G_MainMP_ExitLevel();
}

/*
==============
GScr_AddTestClient
==============
*/
void GScr_AddTestClient(scrContext_t *scrContext)
{
  const gentity_s *v1; 

  GStatic::ClearActiveStatics();
  v1 = SV_ClientMP_AddTestClient();
  GStatic::SetActiveStatics();
  if ( v1 )
    GScr_AddEntity(v1);
}

/*
==============
GScr_AddBot
==============
*/
void GScr_AddBot(scrContext_t *scrContext)
{
  const char *String; 
  const gentity_s *v3; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_3085, scrContext, "AddBot: Invalid number of args");
  GStatic::ClearActiveStatics();
  String = Scr_GetString(scrContext, 0);
  v3 = SV_ClientMP_AddBot(String, 0, 0, 0);
  GStatic::SetActiveStatics();
  if ( v3 )
    GScr_AddEntity(v3);
}

/*
==============
GScr_IsBotMatchMakingEnabled
==============
*/
void GScr_IsBotMatchMakingEnabled(scrContext_t *scrContext)
{
  bool IsBotMatchMakingAllowedForPlaylist; 

  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
    Scr_Error(COM_ERR_3086, scrContext, "This function cannot be used by the front-end server");
  IsBotMatchMakingAllowedForPlaylist = BG_Bots_IsBotMatchMakingAllowedForPlaylist();
  Scr_AddBool(scrContext, IsBotMatchMakingAllowedForPlaylist);
}

/*
==============
GScr_AddMPBotToTeam
==============
*/
void GScr_AddMPBotToTeam(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const char *v3; 
  const char *v4; 
  const gentity_s *v5; 
  team_t outTeam; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_3087, scrContext, "AddBot: Invalid number of args");
  ConstString = Scr_GetConstString(scrContext, 0);
  if ( Com_Teams_TeamFromString(ConstString, &outTeam) )
  {
    GStatic::ClearActiveStatics();
    v5 = SV_ClientMP_AddMPBotToTeam(outTeam);
    GStatic::SetActiveStatics();
    if ( v5 )
      GScr_AddEntity(v5);
  }
  else
  {
    v3 = SL_ConvertToString(ConstString);
    v4 = j_va("unknown team '%s'", v3);
    Scr_Error(COM_ERR_3088, scrContext, v4);
  }
}

/*
==============
GScr_CanSpawnBotOrTestClient
==============
*/
void GScr_CanSpawnBotOrTestClient(scrContext_t *scrContext, scr_entref_t entref)
{
  const gentity_s *Entity; 
  int CanSpawnBotOrTestClient; 

  Entity = GetEntity(entref);
  CanSpawnBotOrTestClient = SV_ClientMP_CanSpawnBotOrTestClient(Entity);
  Scr_AddBool(scrContext, CanSpawnBotOrTestClient);
}

/*
==============
GScr_SpawnBotOrTestClient
==============
*/
void GScr_SpawnBotOrTestClient(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  GStatic::ClearActiveStatics();
  LODWORD(Entity) = SV_ClientMP_SpawnBotOrTestClient(Entity);
  GStatic::SetActiveStatics();
  if ( !(_DWORD)Entity )
    Scr_Error(COM_ERR_3089, scrContext, "SpawnBotOrTestClient() must be called on a valid bot or test client. See console log for details");
}

/*
==============
GScr_IsTestClient
==============
*/
void GScr_IsTestClient(scrContext_t *scrContext)
{
  gentity_s *Entity; 
  int IsTestClient; 

  Entity = GScr_GetEntity(0);
  if ( Entity->client )
  {
    IsTestClient = SV_ClientMP_IsTestClient(Entity->s.number);
    Scr_AddInt(scrContext, IsTestClient);
  }
  else
  {
    Scr_AddInt(scrContext, 0);
  }
}

/*
==============
GScr_AddAgent
==============
*/
void GScr_AddAgent(scrContext_t *scrContext)
{
  const gentity_s *v1; 

  v1 = SV_AgentMP_AddAgent();
  if ( v1 )
    GScr_AddEntity(v1);
}

/*
==============
GScr_AllClientsPrint
==============
*/
void GScr_AllClientsPrint(scrContext_t *scrContext)
{
  const char *String; 
  const char *v3; 

  if ( Scr_GetNumParam(scrContext) )
  {
    String = Scr_GetString(scrContext, 0);
    v3 = j_va("%c \"%s\"", 101i64, String);
    SV_Game_BroadcastServerCommand(SV_CMD_CAN_IGNORE, v3);
  }
}

/*
==============
GScr_MapExists
==============
*/
void GScr_MapExists(scrContext_t *scrContext)
{
  if ( Scr_GetNumParam(scrContext) )
    Scr_AddInt(scrContext, 1);
}

/*
==============
GScr_KickPlayer
==============
*/
void GScr_KickPlayer(scrContext_t *scrContext)
{
  const char *String; 
  bool v3; 
  unsigned int NumParam; 
  const char *v5; 
  int Int; 
  int v7; 
  const char *v8; 

  String = "EXE/PLAYERKICKED";
  v3 = 0;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam == 1 )
    goto LABEL_8;
  if ( NumParam != 2 )
  {
    if ( NumParam != 3 )
    {
      Scr_Error(COM_ERR_3091, scrContext, "Not enough parameters for Kick() ");
      return;
    }
    v3 = Scr_GetInt(scrContext, 2u) != 0;
  }
  String = Scr_GetString(scrContext, 1u);
  if ( !I_strnicmp("EXE/PLAYERKICKED", String, 0x10ui64) )
  {
LABEL_8:
    Int = Scr_GetInt(scrContext, 0);
    v7 = Int;
    if ( Int < 0 || Int >= (int)SvClient::ms_clientCount )
    {
      v8 = j_va("Invalid client specified (%i) out of %i clients", (unsigned int)Int, SvClient::ms_clientCount);
      Scr_ParamError(COM_ERR_3092, scrContext, 0, v8);
    }
    GStatic::ClearActiveStatics();
    SV_CmdsMP_KickClientNum(v7, String, v3);
    GStatic::SetActiveStatics();
  }
  else
  {
    v5 = j_va("Localized string should start with %s", "EXE/PLAYERKICKED");
    Scr_ParamError(COM_ERR_3090, scrContext, 1u, v5);
  }
}

/*
==============
GScr_ClientPrint
==============
*/
void GScr_ClientPrint(scrContext_t *scrContext)
{
  gentity_s *Entity; 
  const char *String; 
  const char *v4; 
  __int64 v5; 
  SvClient *CommonClient; 
  __int64 v7; 
  int v8; 

  if ( Scr_GetNumParam(scrContext) )
  {
    Entity = GScr_GetEntity(0);
    String = Scr_GetString(scrContext, 1u);
    v4 = j_va("%c \"%s\"", 101i64, String);
    if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 196, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
      __debugbreak();
    v5 = Entity - g_entities;
    if ( (unsigned int)v5 >= 0x800 )
    {
      v8 = 2048;
      LODWORD(v7) = ((int)Entity - (int)g_entities) / 1456;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 199, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( ( 2048 ) )", "index doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v7, v8) )
        __debugbreak();
    }
    if ( (__int16)v5 == -1 )
    {
      SV_Game_BroadcastServerCommand(SV_CMD_CAN_IGNORE, v4);
    }
    else
    {
      CommonClient = SvClient::GetCommonClient((__int16)v5);
      CommonClient->SendServerCommand(CommonClient, SV_CMD_CAN_IGNORE, v4);
    }
  }
}

/*
==============
GScr_PrecacheStatusIcon
==============
*/
void GScr_PrecacheStatusIcon(scrContext_t *scrContext)
{
  const char *String; 

  String = Scr_GetString(scrContext, 0);
  Com_Printf(15, "PreCacheStatusIcon (%s) is deprecated, remove this script call. Precaching is done via precache_statusicon in CSV files\n", String);
}

/*
==============
GScr_PrecacheMiniMapIcon
==============
*/
void GScr_PrecacheMiniMapIcon(scrContext_t *scrContext)
{
  const char *String; 

  String = Scr_GetString(scrContext, 0);
  Com_Printf(15, "PrecacheMiniMapIcon (%s) is deprecated, remove this script call. Precaching is done via precache_minimapicon in CSV files\n", String);
}

/*
==============
GScr_PrecacheMpAnim
==============
*/
void GScr_PrecacheMpAnim(scrContext_t *scrContext)
{
  const char *String; 

  String = Scr_GetString(scrContext, 0);
  Com_Printf(15, "PrecacheMpAnim (%s) is deprecated, remove this script call. Precaching is done via precache_xanim in CSV files\n", String);
}

/*
==============
Scr_VisionSetAlternateForPlayer
==============
*/

void __fastcall Scr_VisionSetAlternateForPlayer(scrContext_t *scrContext, scr_entref_t entref, double _XMM2_8)
{
  unsigned int entnum; 
  gentity_s *v6; 
  const char *v7; 
  int number; 
  const char *v9; 
  unsigned int Int; 
  const char *v18; 
  const char *v19; 
  SvClient *CommonClient; 
  int outControllingClientNum; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3678, scrContext, "not an entity");
    v6 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 4989, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v6 = &g_entities[entnum];
    if ( !v6->client && !v6->agent )
    {
      v7 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3677, scrContext, v7);
    }
  }
  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_Error(COM_ERR_3093, scrContext, "USAGE: <player> VisionSetAlternateForPlayer( <stage>, <duration> )\n");
  number = v6->s.number;
  outControllingClientNum = number;
  if ( !SV_IsAgent(number) || SV_GetAgentControlledByPlayerNum(outControllingClientNum, &outControllingClientNum) )
  {
    Int = Scr_GetInt(scrContext, 0);
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
    __asm
    {
      vmulss  xmm1, xmm0, cs:__real@447a0000
      vaddss  xmm3, xmm1, cs:__real@3f000000
      vxorps  xmm2, xmm2, xmm2
      vmovss  xmm4, xmm2, xmm3
      vxorps  xmm0, xmm0, xmm0
      vroundss xmm1, xmm0, xmm4, 1
      vcvttss2si r9d, xmm1
    }
    v18 = j_va("%c %i %i", 48i64, Int, _R9);
    v19 = v18;
    if ( outControllingClientNum == -1 )
    {
      SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v18);
    }
    else
    {
      CommonClient = SvClient::GetCommonClient(outControllingClientNum);
      CommonClient->SendServerCommand(CommonClient, SV_CMD_RELIABLE, v19);
    }
  }
  else
  {
    v9 = j_va("entity %i is not a player or player-controlled agent", entnum);
    Scr_ObjectError(COM_ERR_3094, scrContext, v9);
  }
}

/*
==============
Scr_VisionSetNakedForPlayer
==============
*/

void __fastcall Scr_VisionSetNakedForPlayer(scrContext_t *scrContext, scr_entref_t entref, double _XMM2_8)
{
  unsigned int entnum; 
  gentity_s *v6; 
  unsigned int *client; 
  const char *v8; 
  ComErrorCode v9; 
  unsigned int v11; 
  scr_string_t ConstLowercaseString; 
  const char *v19; 
  const char *v20; 
  const char *v21; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v8 = "not an entity";
    v9 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5087, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v6 = &g_entities[entnum];
  client = (unsigned int *)v6->client;
  if ( !client )
  {
    client = (unsigned int *)v6->agent;
    if ( !client )
    {
      v8 = j_va("entity %i is not a player or agent", entnum);
      v9 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v9, scrContext, v8);
      client = NULL;
    }
  }
  _ER14 = 1000;
  v11 = Scr_GetNumParam(scrContext) - 1;
  if ( v11 )
  {
    if ( v11 != 1 )
    {
      Scr_Error(COM_ERR_3098, scrContext, "USAGE: <player> VisionSetForPlayer( <visionset name>, <transition time> )\n");
      return;
    }
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
    __asm
    {
      vmulss  xmm1, xmm0, cs:__real@447a0000
      vaddss  xmm3, xmm1, cs:__real@3f000000
      vxorps  xmm2, xmm2, xmm2
      vmovss  xmm4, xmm2, xmm3
      vxorps  xmm0, xmm0, xmm0
      vroundss xmm1, xmm0, xmm4, 1
      vcvttss2si r14d, xmm1
    }
  }
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  v19 = SL_ConvertToString(ConstLowercaseString);
  v20 = v19;
  if ( *v19 )
  {
    if ( !NetConstStrings_GetVisionSetIndex(v19, client + 317) )
    {
      v21 = j_va("visionset %s has not been precached, include with precache_vision", v20);
      Scr_Error(COM_ERR_3099, scrContext, v21);
    }
    if ( !client[317] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5118, ASSERT_TYPE_ASSERT, "( ps->visionSetOverride.visionSetIndex != 0 )", (const char *)&queryFormat, "ps->visionSetOverride.visionSetIndex != 0") )
      __debugbreak();
  }
  else
  {
    client[317] = 0;
  }
  client[318] = level.time;
  client[319] = _ER14;
}

/*
==============
Scr_VisionSetNightForPlayer
==============
*/
void Scr_VisionSetNightForPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  Scr_VisionSetForPlayer_Internal(scrContext, entref, VISIONSET_NIGHT);
}

/*
==============
Scr_VisionSetMissileCamForPlayer
==============
*/
void Scr_VisionSetMissileCamForPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  unsigned int *client; 
  const char *v6; 
  ComErrorCode v7; 
  scr_string_t ConstLowercaseString; 
  const char *v9; 
  const char *v10; 
  const char *v11; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5158, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = (unsigned int *)v4->client;
  if ( !client )
  {
    client = (unsigned int *)v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v7, scrContext, v6);
      client = NULL;
    }
  }
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  v9 = SL_ConvertToString(ConstLowercaseString);
  v10 = v9;
  if ( *v9 )
  {
    if ( !NetConstStrings_GetVisionSetIndex(v9, client + 325) )
    {
      v11 = j_va("visionset %s has not been precached, include with precache_vision", v10);
      Scr_Error(COM_ERR_3100, scrContext, v11);
    }
    if ( !client[325] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5172, ASSERT_TYPE_ASSERT, "( ps->missileOverrideVisionSetIndex != 0 )", (const char *)&queryFormat, "ps->missileOverrideVisionSetIndex != 0") )
      __debugbreak();
  }
  else
  {
    client[325] = 0;
  }
}

/*
==============
Scr_VisionSetThermalForPlayer
==============
*/
void Scr_VisionSetThermalForPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  unsigned int *client; 
  const char *v6; 
  ComErrorCode v7; 
  scr_string_t ConstLowercaseString; 
  const char *v9; 
  const char *v10; 
  const char *v11; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5190, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = (unsigned int *)v4->client;
  if ( !client )
  {
    client = (unsigned int *)v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v7, scrContext, v6);
      client = NULL;
    }
  }
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  v9 = SL_ConvertToString(ConstLowercaseString);
  v10 = v9;
  if ( *v9 )
  {
    if ( !NetConstStrings_GetVisionSetIndex(v9, client + 323) )
    {
      v11 = j_va("visionset %s has not been precached, include with precache_vision", v10);
      Scr_Error(COM_ERR_3101, scrContext, v11);
    }
    if ( !client[323] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5204, ASSERT_TYPE_ASSERT, "( ps->thermalOverrideVisionSetIndex != 0 )", (const char *)&queryFormat, "ps->thermalOverrideVisionSetIndex != 0") )
      __debugbreak();
  }
  else
  {
    client[323] = 0;
  }
}

/*
==============
Scr_VisionSetPainForPlayer
==============
*/
void Scr_VisionSetPainForPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  unsigned int *client; 
  const char *v6; 
  ComErrorCode v7; 
  scr_string_t ConstLowercaseString; 
  const char *v9; 
  const char *v10; 
  const char *v11; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5222, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = (unsigned int *)v4->client;
  if ( !client )
  {
    client = (unsigned int *)v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v7, scrContext, v6);
      client = NULL;
    }
  }
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  v9 = SL_ConvertToString(ConstLowercaseString);
  v10 = v9;
  if ( *v9 )
  {
    if ( !NetConstStrings_GetVisionSetIndex(v9, client + 324) )
    {
      v11 = j_va("visionset %s has not been precached, include with precache_vision", v10);
      Scr_Error(COM_ERR_3102, scrContext, v11);
    }
    if ( !client[324] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5236, ASSERT_TYPE_ASSERT, "( ps->painOverrideVisionSetIndex != 0 )", (const char *)&queryFormat, "ps->painOverrideVisionSetIndex != 0") )
      __debugbreak();
  }
  else
  {
    client[324] = 0;
  }
}

/*
==============
Scr_VisionSetFadeToBlackForPlayer
==============
*/
void Scr_VisionSetFadeToBlackForPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  Scr_VisionSetForPlayer_Internal(scrContext, entref, VISIONSET_FADE_TO_BLACK);
}

/*
==============
Scr_VisionSetKillStreakForPlayer
==============
*/
void Scr_VisionSetKillStreakForPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  unsigned int *client; 
  const char *v6; 
  ComErrorCode v7; 
  scr_string_t ConstLowercaseString; 
  const char *v9; 
  const char *v10; 
  const char *v11; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5273, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = (unsigned int *)v4->client;
  if ( !client )
  {
    client = (unsigned int *)v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v7, scrContext, v6);
      client = NULL;
    }
  }
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  v9 = SL_ConvertToString(ConstLowercaseString);
  v10 = v9;
  if ( *v9 )
  {
    if ( !NetConstStrings_GetVisionSetIndex(v9, client + 326) )
    {
      v11 = j_va("visionset %s has not been precached, include with precache_vision", v10);
      Scr_Error(COM_ERR_3103, scrContext, v11);
    }
    if ( !client[326] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5287, ASSERT_TYPE_ASSERT, "( ps->killstreakOverrideVisionSetIndex != 0 )", (const char *)&queryFormat, "ps->killstreakOverrideVisionSetIndex != 0") )
      __debugbreak();
  }
  else
  {
    client[326] = 0;
  }
}

/*
==============
ScrCmd_AutoSpotOverlayOn
==============
*/
void ScrCmd_AutoSpotOverlayOn(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  gclient_s *client; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5304, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  client = v4->client;
  if ( GameModeFlagValues::ms_mpValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 201, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a MP-only context", "IsFlagActive( index )") )
    __debugbreak();
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagInternal(&client->ps.otherFlags, ACTIVE, 0x27u);
}

/*
==============
ScrCmd_AutoSpotOverlayOff
==============
*/
void ScrCmd_AutoSpotOverlayOff(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  gclient_s *client; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5321, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  client = v4->client;
  if ( GameModeFlagValues::ms_mpValue != ACTIVE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_gamemode_flags.h", 212, ASSERT_TYPE_ASSERT, "(IsFlagActive( index ))", "%s\n\tThis function must be used in a MP-only context", "IsFlagActive( index )") )
    __debugbreak();
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagInternal(&client->ps.otherFlags, ACTIVE, 0x27u);
}

/*
==============
ScrCmd_EnableWorldUp
==============
*/
void ScrCmd_EnableWorldUp(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  playerState_s *EntityPlayerState; 
  int Int; 
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *p_otherFlags; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5338, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  EntityPlayerState = G_GetEntityPlayerState(v4);
  if ( !EntityPlayerState )
    Scr_Error(COM_ERR_3104, scrContext, "EnableWorldUp only works on players.");
  Int = Scr_GetInt(scrContext, 0);
  p_otherFlags = &EntityPlayerState->otherFlags;
  if ( Int )
    GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagStrict(p_otherFlags, DEAD|PRONE|0x20);
  else
    GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagStrict(p_otherFlags, DEAD|PRONE|0x20);
}

/*
==============
ScrCmd_SetEyesOnUplinkEnabled
==============
*/
void ScrCmd_SetEyesOnUplinkEnabled(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  char *client; 
  const char *v6; 
  ComErrorCode v7; 
  int Int; 
  GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *v9; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    v6 = "not an entity";
    v7 = COM_ERR_3682;
    goto LABEL_9;
  }
  if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5370, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
    __debugbreak();
  v4 = &g_entities[entnum];
  client = (char *)v4->client;
  if ( !client )
  {
    client = (char *)v4->agent;
    if ( !client )
    {
      v6 = j_va("entity %i is not a player or agent", entnum);
      v7 = COM_ERR_3679;
LABEL_9:
      Scr_ObjectError(v7, scrContext, v6);
      client = NULL;
    }
  }
  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    Int = Scr_GetInt(scrContext, 0);
    v9 = (GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64> *)(client + 28);
    if ( Int )
      GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::SetFlagStrict(v9, FIRING|0x20);
    else
      GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::ClearFlagStrict(v9, FIRING|0x20);
  }
  else
  {
    Scr_Error(COM_ERR_3105, scrContext, "SetEyesOnUplinkEnabled requires 1 argument");
  }
}

/*
==============
GScr_ControlTurretOn
==============
*/
void GScr_ControlTurretOn(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  gentity_s *Entity; 
  gentity_s *v7; 
  const char *v8; 
  const char *v9; 
  bool v10; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5398, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  Entity = GScr_GetEntity(0);
  v7 = Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v8 = SL_ConvertToString(Entity->classname);
    v9 = j_va("entity type '%s' is not a turret", v8);
    Scr_Error(COM_ERR_3106, scrContext, v9);
  }
  v10 = G_Turret_ScrUse(scrContext, v7, v4, 0);
  Scr_AddBool(scrContext, v10);
}

/*
==============
GScr_ControlTurretOff
==============
*/
void GScr_ControlTurretOff(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  gentity_s *v4; 
  const char *v5; 
  gentity_s *Entity; 
  gentity_s *v7; 
  const char *v8; 
  const char *v9; 

  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v4 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5426, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v4 = &g_entities[entnum];
    if ( !v4->client )
    {
      v5 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v5);
    }
  }
  Entity = GScr_GetEntity(0);
  v7 = Entity;
  if ( !Entity->turretHandle.m_objIndex )
  {
    v8 = SL_ConvertToString(Entity->classname);
    v9 = j_va("entity type '%s' is not a turret", v8);
    Scr_Error(COM_ERR_3107, scrContext, v9);
  }
  G_Turret_ScrStopUse(v7, v4);
}

/*
==============
GScr_RemoteControlVehicleTarget
==============
*/
void GScr_RemoteControlVehicleTarget(scrContext_t *scrContext, scr_entref_t entref)
{
  EntHandle *Entity; 
  gentity_s *v4; 
  playerState_s *EntityPlayerState; 
  gentity_s *v6; 
  int number; 

  Entity = (EntHandle *)GetEntity(entref);
  if ( Entity[2].number != 12 )
    Scr_Error(COM_ERR_3108, scrContext, "Specified entity is not a helicopter. Currently only helicopters are supported for this feature.");
  if ( !EntHandle::isDefined(Entity + 82) )
    Scr_Error(COM_ERR_3109, scrContext, "Specified helicopter is not controlled by a player");
  v4 = EntHandle::ent(Entity + 82);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5462, ASSERT_TYPE_ASSERT, "( playerEntity )", (const char *)&queryFormat, "playerEntity") )
    __debugbreak();
  if ( v4->s.eType != ET_PLAYER )
    Scr_Error(COM_ERR_3110, scrContext, "Specified helicopter is not controlled by a player");
  EntityPlayerState = G_GetEntityPlayerState(v4);
  if ( !EntityPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5468, ASSERT_TYPE_ASSERT, "( playerState )", (const char *)&queryFormat, "playerState") )
    __debugbreak();
  v6 = GScr_GetEntity(0);
  if ( !v6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5471, ASSERT_TYPE_ASSERT, "( targetEntity )", (const char *)&queryFormat, "targetEntity") )
    __debugbreak();
  number = v6->s.number;
  v6->r.svFlags &= ~1u;
  EntityPlayerState->vehicleState.targetEntity = number;
}

/*
==============
GScr_RemoteControlVehicleTargetOff
==============
*/
void GScr_RemoteControlVehicleTargetOff(scrContext_t *scrContext, scr_entref_t entref)
{
  EntHandle *Entity; 
  gentity_s *v4; 
  playerState_s *EntityPlayerState; 

  Entity = (EntHandle *)GetEntity(entref);
  if ( Entity[2].number != 12 )
    Scr_Error(COM_ERR_3111, scrContext, "Specified entity is not a helicopter. Currently only helicopters are supported for this feature.");
  if ( !EntHandle::isDefined(Entity + 82) )
    Scr_Error(COM_ERR_3112, scrContext, "Specified helicopter is not controlled by a player");
  v4 = EntHandle::ent(Entity + 82);
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5502, ASSERT_TYPE_ASSERT, "( playerEntity )", (const char *)&queryFormat, "playerEntity") )
    __debugbreak();
  if ( v4->s.eType != ET_PLAYER )
    Scr_Error(COM_ERR_3113, scrContext, "Specified helicopter is not controlled by a player");
  EntityPlayerState = G_GetEntityPlayerState(v4);
  if ( EntityPlayerState )
  {
    EntityPlayerState->vehicleState.targetEntity = 2047;
  }
  else
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5508, ASSERT_TYPE_ASSERT, "( playerState )", (const char *)&queryFormat, "playerState") )
      __debugbreak();
    MEMORY[0x128] = 2047;
  }
}

/*
==============
GScr_MainMP_EnableAimAssist
==============
*/
void GScr_MainMP_EnableAimAssist(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gentity_s *v4; 

  Entity = GetEntity(entref);
  v4 = Entity;
  if ( Entity->s.eType != ET_SCRIPTMOVER && !BG_IsVehicleEntity(&Entity->s) && v4->r.modelType != 5 )
    Scr_Error(COM_ERR_3114, scrContext, "Currently only supported on script movers, vehicle/helicopters entities, entities with brush models");
  GScr_Main_EnableAimAssistCommon(v4);
}

/*
==============
GScr_MainMP_DisableAimAssist
==============
*/
void GScr_MainMP_DisableAimAssist(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( !Entity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 1914, ASSERT_TYPE_ASSERT, "(es)", (const char *)&queryFormat, "es") )
    __debugbreak();
  if ( ((Entity->s.eType - 12) & 0xFFFD) != 0 && Entity->r.modelType != 5 )
    Scr_Error(COM_ERR_3115, scrContext, "Currently only supported on vehicle/helicopters entities or entities with brush models");
  GScr_Main_DisableAimAssistCommon(Entity);
}

/*
==============
GScr_MainMP_IsItemUnlocked
==============
*/
void GScr_MainMP_IsItemUnlocked(scrContext_t *scrContext, scr_entref_t entref)
{
  Scr_AddInt(scrContext, 0);
}

/*
==============
GScr_SetCodcasterClientMatchData
==============
*/
void GScr_SetCodcasterClientMatchData(scrContext_t *scrContext)
{
  SvGameGlobalsMP *SvGameGlobalsMP; 
  const DDLDef *Asset; 
  DDLState state; 
  DDLContext ddlContext; 

  SvGameGlobalsMP = SvGameGlobalsMP::GetSvGameGlobalsMP();
  if ( !SvGameGlobalsMP->codcasterClientMatchData.def[0] )
    GScr_SetCodcasterClientMatchDataDef(scrContext);
  Asset = Com_DDL_LoadAsset(SvGameGlobalsMP->codcasterClientMatchData.def);
  Com_DDL_CreateContext(SvGameGlobalsMP->codcasterClientMatchData.data, 1614, Asset, &ddlContext, NULL, NULL);
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovdqu xmmword ptr [rsp+88h+state.member], xmm0
  }
  state.isValid = 0;
  state.offset = 0;
  state.arrayIndex = -1;
  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
    Scr_Error(COM_ERR_3121, scrContext, "SetDDL: Can't use this function on the front end server");
  LiveStorage_InitializeDDLStateForStatsGroup(Asset, &state, STATSGROUP_IGNORE);
  GScr_Main_SetDDL(scrContext, &state, Asset, &ddlContext, "GScr_SetCodcasterClientMatchData", 0);
}

/*
==============
GScr_GetCodcasterClientMatchData
==============
*/
void GScr_GetCodcasterClientMatchData(scrContext_t *scrContext)
{
  SvGameGlobalsMP *SvGameGlobalsMP; 
  const DDLDef *Asset; 
  DDLState state; 
  DDLContext ddlContext; 

  SvGameGlobalsMP = SvGameGlobalsMP::GetSvGameGlobalsMP();
  if ( !SvGameGlobalsMP->codcasterClientMatchData.def[0] )
    GScr_SetCodcasterClientMatchDataDef(scrContext);
  Asset = Com_DDL_LoadAsset(SvGameGlobalsMP->codcasterClientMatchData.def);
  Com_DDL_CreateContext(SvGameGlobalsMP->codcasterClientMatchData.data, 1614, Asset, &ddlContext, NULL, NULL);
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovdqu xmmword ptr [rsp+88h+state.member], xmm0
  }
  state.isValid = 0;
  state.offset = 0;
  state.arrayIndex = -1;
  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
    Scr_Error(COM_ERR_3120, scrContext, "GetDDL: Can't use this function on the front end server");
  LiveStorage_InitializeDDLStateForStatsGroup(Asset, &state, STATSGROUP_IGNORE);
  GScr_Main_GetDDL(scrContext, &state, Asset, &ddlContext, "GetCodcasterClientMatchData", 0);
}

/*
==============
GScr_SendCodcasterClientMatchData
==============
*/
void GScr_SendCodcasterClientMatchData(scrContext_t *scrContext)
{
  int maxclients; 
  int v2; 
  __int64 v3; 

  if ( SvGameGlobalsMP::GetSvGameGlobalsMP()->codcasterClientMatchData.def[0] )
  {
    maxclients = level.maxclients;
    v2 = 0;
    if ( level.maxclients > 0 )
    {
      v3 = 0i64;
      do
      {
        if ( level.clients[v3].sess.connected == CON_CONNECTED )
        {
          SV_ClientMP_SendCodcasterClientMatchData(v2);
          maxclients = level.maxclients;
        }
        ++v2;
        ++v3;
      }
      while ( v2 < maxclients );
    }
  }
}

/*
==============
GScr_MainMP_HasPlayerData
==============
*/
void GScr_MainMP_HasPlayerData(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  unsigned int number; 
  const SvClientMP *CommonClient; 
  int HasAllClientStatPackets; 

  Entity = GetEntity(entref);
  if ( !Entity->client )
    Scr_Error(COM_ERR_3131, scrContext, "GetPlayerData: entity must be a player entity");
  number = Entity->s.number;
  if ( (_BYTE)SvClient::ms_allocatedType != HALF_HALF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_mp\\sv_client_mp.h", 957, ASSERT_TYPE_ASSERT, "( ms_allocatedType == ALLOCATION_TYPE )", (const char *)&queryFormat, "ms_allocatedType == ALLOCATION_TYPE") )
    __debugbreak();
  CommonClient = (const SvClientMP *)SvClient::GetCommonClient(number);
  HasAllClientStatPackets = SV_HasAllClientStatPackets(CommonClient);
  Scr_AddBool(scrContext, HasAllClientStatPackets != 0);
}

/*
==============
GScr_MainMP_GetPlayerData
==============
*/
void GScr_MainMP_GetPlayerData(scrContext_t *scrContext, scr_entref_t entref)
{
  scr_string_t ConstString; 
  unsigned int RawHash; 
  StatsGroup StatsGroupByHash; 
  gentity_s *Entity; 
  unsigned int number; 
  const SvClientMP *CommonClient; 
  const DDLDef *DefForStatsGroup; 
  unsigned __int8 *ClientPlayerDataBuffer; 
  int PlayerDataBufferSize; 
  DDLState state; 
  DDLContext ddlContext; 

  ConstString = Scr_GetConstString(scrContext, 0);
  RawHash = j_SL_GetRawHash(ConstString);
  StatsGroupByHash = Com_PlayerData_FindStatsGroupByHash(RawHash);
  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
    Scr_Error(COM_ERR_3122, scrContext, "GetPlayerData not allowed on front end server");
  Entity = GetEntity(entref);
  if ( !Entity->client )
    Scr_Error(COM_ERR_3123, scrContext, "GetPlayerData: entity must be a player entity");
  number = Entity->s.number;
  if ( (_BYTE)SvClient::ms_allocatedType != HALF_HALF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_mp\\sv_client_mp.h", 957, ASSERT_TYPE_ASSERT, "( ms_allocatedType == ALLOCATION_TYPE )", (const char *)&queryFormat, "ms_allocatedType == ALLOCATION_TYPE") )
    __debugbreak();
  CommonClient = (const SvClientMP *)SvClient::GetCommonClient(number);
  if ( !SV_HasAllClientStatPackets(CommonClient) )
    Scr_Error(COM_ERR_3124, scrContext, "GetPlayerData: we don't have that player's stats yet");
  DefForStatsGroup = Com_PlayerData_GetDefForStatsGroup(StatsGroupByHash);
  ClientPlayerDataBuffer = SV_ClientMP_GetClientPlayerDataBuffer(Entity->s.number, StatsGroupByHash);
  PlayerDataBufferSize = LiveStorage_GetPlayerDataBufferSize(StatsGroupByHash);
  Com_DDL_CreateContext(ClientPlayerDataBuffer, PlayerDataBufferSize, DefForStatsGroup, &ddlContext, NULL, NULL);
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovdqu xmmword ptr [rsp+88h+state.member], xmm0
  }
  state.isValid = 0;
  state.offset = 0;
  state.arrayIndex = -1;
  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
    Scr_Error(COM_ERR_3120, scrContext, "GetDDL: Can't use this function on the front end server");
  LiveStorage_InitializeDDLStateForStatsGroup(DefForStatsGroup, &state, StatsGroupByHash);
  GScr_Main_GetDDL(scrContext, &state, DefForStatsGroup, &ddlContext, "GetPlayerData", 1);
}

/*
==============
GScr_MainMP_SetPlayerData
==============
*/
void GScr_MainMP_SetPlayerData(scrContext_t *scrContext, scr_entref_t entref)
{
  scr_string_t ConstString; 
  unsigned int RawHash; 
  StatsGroup StatsGroupByHash; 
  gentity_s *Entity; 
  unsigned int number; 
  const SvClientMP *CommonClient; 
  const DDLDef *DefForStatsGroup; 
  unsigned __int8 *ClientPlayerDataBuffer; 
  int PlayerDataBufferSize; 
  DDLState state; 
  DDLContext ddlContext; 

  ConstString = Scr_GetConstString(scrContext, 0);
  RawHash = j_SL_GetRawHash(ConstString);
  StatsGroupByHash = Com_PlayerData_FindStatsGroupByHash(RawHash);
  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
    Scr_Error(COM_ERR_3128, scrContext, "SetPlayerData not allowed on front end server");
  Entity = GetEntity(entref);
  if ( !Entity->client )
    Scr_Error(COM_ERR_3129, scrContext, "SetPlayerData: entity must be a player entity");
  number = Entity->s.number;
  if ( (_BYTE)SvClient::ms_allocatedType != HALF_HALF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_mp\\sv_client_mp.h", 957, ASSERT_TYPE_ASSERT, "( ms_allocatedType == ALLOCATION_TYPE )", (const char *)&queryFormat, "ms_allocatedType == ALLOCATION_TYPE") )
    __debugbreak();
  CommonClient = (const SvClientMP *)SvClient::GetCommonClient(number);
  if ( !SV_HasAllClientStatPackets(CommonClient) )
    Scr_Error(COM_ERR_3130, scrContext, "GetPlayerData: we don't have that player's stats yet");
  DefForStatsGroup = Com_PlayerData_GetDefForStatsGroup(StatsGroupByHash);
  ClientPlayerDataBuffer = SV_ClientMP_GetClientPlayerDataBuffer(Entity->s.number, StatsGroupByHash);
  s_callbackData.modifiedFlags = SV_ClientMP_GetClientPersistentDataModifiedFlags(Entity->s.number);
  s_callbackData.baseOffset = Com_PlayerData_GetStatsGroupOffset(StatsGroupByHash) + 4;
  PlayerDataBufferSize = LiveStorage_GetPlayerDataBufferSize(StatsGroupByHash);
  Com_DDL_CreateContext(ClientPlayerDataBuffer, PlayerDataBufferSize, DefForStatsGroup, &ddlContext, DDLAccessCB, &s_callbackData);
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovdqu xmmword ptr [rsp+88h+state.member], xmm0
  }
  state.isValid = 0;
  state.offset = 0;
  state.arrayIndex = -1;
  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
    Scr_Error(COM_ERR_3121, scrContext, "SetDDL: Can't use this function on the front end server");
  LiveStorage_InitializeDDLStateForStatsGroup(DefForStatsGroup, &state, StatsGroupByHash);
  GScr_Main_SetDDL(scrContext, &state, DefForStatsGroup, &ddlContext, "SetPlayerData", 1);
  SV_ClientMP_SetClientPersistentDataModified(Entity->s.number);
}

/*
==============
GScr_MainMP_LogStatMatchGUID
==============
*/
void GScr_MainMP_LogStatMatchGUID(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const gentity_s *v7; 
  const SvClientMP *MpClient; 
  const DDLDef *DefForStatsGroup; 
  unsigned __int8 *ClientPlayerDataBuffer; 
  int PlayerDataBufferSize; 
  unsigned __int64 MatchId; 
  DDLState fromState; 
  DDLState toState; 
  DDLContext ddlContext; 
  DDLState result; 
  unsigned int path; 
  unsigned int RawHash; 

  fromState.isValid = 0;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  fromState.offset = 0;
  __asm { vmovdqu xmmword ptr [rsp+0D8h+fromState.member], xmm0 }
  toState.isValid = 0;
  toState.offset = 0;
  __asm { vmovdqu xmmword ptr [rsp+0D8h+toState.member], xmm0 }
  fromState.arrayIndex = -1;
  toState.arrayIndex = -1;
  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
  {
    Scr_Error(COM_ERR_3132, scrContext, "LogStatMatchGUID not allowed on front end server");
  }
  else
  {
    Entity = GetEntity(entref);
    v7 = Entity;
    if ( Entity && Entity->client )
    {
      MpClient = SV_Client_GetMpClient(Entity->s.number);
      if ( SV_HasAllClientStatPackets(MpClient) )
      {
        DefForStatsGroup = Com_PlayerData_GetDefForStatsGroup(STATSGROUP_COMMON);
        ClientPlayerDataBuffer = SV_ClientMP_GetClientPlayerDataBuffer(v7->s.number, STATSGROUP_COMMON);
        PlayerDataBufferSize = LiveStorage_GetPlayerDataBufferSize(STATSGROUP_COMMON);
        if ( DefForStatsGroup && !SV_BotIsBotEntClient(v7) && !Dvar_GetBool_Internal_DebugName(DVARBOOL_xblive_privatematch, "xblive_privatematch") )
        {
          path = j_SL_GetRawHash(scr_const.commonData);
          RawHash = j_SL_GetRawHash(scr_const.lastMatchGUID);
          _RAX = DDL_GetRootState(&result, DefForStatsGroup);
          __asm
          {
            vmovups ymm0, ymmword ptr [rax]
            vmovups ymmword ptr [rsp+0D8h+fromState.isValid], ymm0
          }
          DDL_MoveToPathByHash(&fromState, &toState, 2, &path);
          Com_DDL_CreateContext(ClientPlayerDataBuffer, PlayerDataBufferSize, DefForStatsGroup, &ddlContext, NULL, NULL);
          MatchId = OnlineMatchId::GetMatchId();
          DDL_SetUInt64(&toState, &ddlContext, MatchId);
        }
      }
      else
      {
        Scr_Error(COM_ERR_3134, scrContext, "LogStatMatchGUID: we don't have that player's stats yet");
      }
    }
    else
    {
      Scr_Error(COM_ERR_3133, scrContext, "LogStatMatchGUID: entity must be a player entity");
    }
  }
}

/*
==============
GScr_MainMP_IsEnumValueValid
==============
*/
void GScr_MainMP_IsEnumValueValid(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const char *String; 
  scr_string_t v4; 
  unsigned int RawHash; 
  StatsGroup StatsGroupByHash; 
  const DDLDef *DefForStatsGroup; 
  unsigned int v8; 
  bool IsEnumValueHashValid; 

  ConstString = Scr_GetConstString(scrContext, 0);
  String = Scr_GetString(scrContext, 1u);
  v4 = Scr_GetConstString(scrContext, 2u);
  RawHash = j_SL_GetRawHash(ConstString);
  StatsGroupByHash = Com_PlayerData_FindStatsGroupByHash(RawHash);
  DefForStatsGroup = Com_PlayerData_GetDefForStatsGroup(StatsGroupByHash);
  if ( !DefForStatsGroup && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5964, ASSERT_TYPE_SANITY, "( def )", (const char *)&queryFormat, "def") )
    __debugbreak();
  v8 = j_SL_GetRawHash(v4);
  IsEnumValueHashValid = DDL_IsEnumValueHashValid(DefForStatsGroup, String, v8);
  Scr_AddBool(scrContext, IsEnumValueHashValid);
}

/*
==============
GScr_MainMP_IsSquadsMode
==============
*/
void GScr_MainMP_IsSquadsMode(scrContext_t *scrContext)
{
  Scr_AddInt(scrContext, 0);
}

/*
==============
GScr_MainMP_GetSquadAssaultEnemyPrestige
==============
*/
void GScr_MainMP_GetSquadAssaultEnemyPrestige(scrContext_t *scrContext)
{
  Scr_AddInt(scrContext, 0);
}

/*
==============
GScr_MainMP_GetEnemySquadData
==============
*/
void GScr_MainMP_GetEnemySquadData(scrContext_t *scrContext)
{
  ;
}

/*
==============
GScr_MainMP_GetEnemySquadDogType
==============
*/
void GScr_MainMP_GetEnemySquadDogType(scrContext_t *scrContext)
{
  Scr_AddInt(scrContext, 0);
}

/*
==============
GScr_MainMP_GetSquadAssaultELO
==============
*/
void GScr_MainMP_GetSquadAssaultELO(scrContext_t *scrContext)
{
  Scr_AddInt(scrContext, 0);
}

/*
==============
GScr_MainMP_GetSquadAssaultSquadIndex
==============
*/
void GScr_MainMP_GetSquadAssaultSquadIndex(scrContext_t *scrContext)
{
  Scr_AddInt(scrContext, 0);
}

/*
==============
GScr_MainMP_SpawnLoopingSound
==============
*/
void GScr_MainMP_SpawnLoopingSound(scrContext_t *scrContext)
{
  if ( Com_GameMode_SupportsFeature(WEAPON_SKYDIVE_SLOW_SOFT_LAND) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 6062, ASSERT_TYPE_ASSERT, "( !Com_GameMode_SupportsFeature( Com_GameMode_Feature::SOUND_SERVER_CULL ) )", (const char *)&queryFormat, "!Com_GameMode_SupportsFeature( Com_GameMode_Feature::SOUND_SERVER_CULL )") )
    __debugbreak();
}

/*
==============
GScr_MainMP_Delete
==============
*/
void GScr_MainMP_Delete(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  if ( entref.entclass == ENTITY_CLASS_SOUNDENTITY )
  {
    ScrCmd_SoundEntity_Delete(scrContext, entref);
  }
  else
  {
    Entity = GetEntity(entref);
    GScr_Main_DeleteCommon(scrContext, Entity);
  }
}

/*
==============
GScr_MainMP_GetGameTypeIndex
==============
*/
void GScr_MainMP_GetGameTypeIndex(scrContext_t *scrContext)
{
  const char *String; 
  int index; 

  index = -1;
  String = Scr_GetString(scrContext, 0);
  Com_GameInfo_GetGameTypeIndexForInternalName(String, &index);
  Scr_AddInt(scrContext, index);
}

/*
==============
GScr_MainMP_IsAI
==============
*/
void GScr_MainMP_IsAI(scrContext_t *scrContext)
{
  const gentity_s *Entity; 

  if ( Scr_GetType(scrContext, 0) == VAR_POINTER && Scr_GetPointerType(scrContext, 0) == VAR_ENTITY && !(unsigned __int8)*(_DWORD *)&Scr_GetEntityRef(scrContext, 0).entclass && ((Entity = GScr_GetEntity(0), SV_BotIsBotEnt(Entity)) || SV_IsAgentEntity(Entity)) )
    Scr_AddBool(scrContext, 1);
  else
    Scr_AddBool(scrContext, 0);
}

/*
==============
GScr_IsPlayerNumber
==============
*/
void GScr_IsPlayerNumber(scrContext_t *scrContext)
{
  int Int; 

  Int = Scr_GetInt(scrContext, 0);
  if ( Int < 0 || Int >= level.maxclients )
    Scr_AddInt(scrContext, 0);
  else
    Scr_AddInt(scrContext, 1);
}

/*
==============
GScr_SetWinningTeam
==============
*/
void GScr_SetWinningTeam(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const char *v3; 
  const char *v4; 
  team_t outTeam; 

  ConstString = Scr_GetConstString(scrContext, 0);
  if ( Com_Teams_TeamFromString(ConstString, &outTeam) )
  {
    SV_MainMP_SetWinningTeam(outTeam);
  }
  else
  {
    v3 = SL_ConvertToString(ConstString);
    v4 = j_va("unknown team '%s'", v3);
    Scr_Error(COM_ERR_3136, scrContext, v4);
  }
}

/*
==============
GScr_Announcement
==============
*/
void GScr_Announcement(scrContext_t *scrContext)
{
  GScript *v2; 
  void (__fastcall *ConstructMessageString)(GScript *, scrContext_t *, int, int, const char *, char *, unsigned int); 
  unsigned int NumParam; 
  const char *v5; 
  char v6[1024]; 

  if ( !GScript::ms_gScriptSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.h", 183, ASSERT_TYPE_ASSERT, "( ms_gScriptSystem )", (const char *)&queryFormat, "ms_gScriptSystem") )
    __debugbreak();
  v2 = GScript::ms_gScriptSystem;
  ConstructMessageString = GScript::ms_gScriptSystem->ConstructMessageString;
  NumParam = Scr_GetNumParam(scrContext);
  ConstructMessageString(v2, scrContext, 0, NumParam - 1, "Announcement", v6, 1024u);
  v5 = j_va("%c \"%s\" 2", 99i64, v6);
  SV_Game_BroadcastServerCommand(SV_CMD_CAN_IGNORE, v5);
}

/*
==============
GScr_ClientAnnouncement
==============
*/
void GScr_ClientAnnouncement(scrContext_t *scrContext)
{
  gentity_s *Entity; 
  GScript *v3; 
  void (__fastcall *ConstructMessageString)(GScript *, scrContext_t *, int, int, const char *, char *, unsigned int); 
  unsigned int NumParam; 
  const char *v6; 
  unsigned int number; 
  const char *v8; 
  SvClient *CommonClient; 
  char v10[1024]; 

  Entity = GScr_GetEntity(0);
  if ( !GScript::ms_gScriptSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_scr_main.h", 183, ASSERT_TYPE_ASSERT, "( ms_gScriptSystem )", (const char *)&queryFormat, "ms_gScriptSystem") )
    __debugbreak();
  v3 = GScript::ms_gScriptSystem;
  ConstructMessageString = GScript::ms_gScriptSystem->ConstructMessageString;
  NumParam = Scr_GetNumParam(scrContext);
  ConstructMessageString(v3, scrContext, 1, NumParam - 1, "Announcement", v10, 1024u);
  v6 = j_va("%c \"%s\" 2", 99i64, v10);
  number = Entity->s.number;
  v8 = v6;
  if ( number == -1 )
  {
    SV_Game_BroadcastServerCommand(SV_CMD_CAN_IGNORE, v6);
  }
  else
  {
    CommonClient = SvClient::GetCommonClient(number);
    CommonClient->SendServerCommand(CommonClient, SV_CMD_CAN_IGNORE, v8);
  }
}

/*
==============
GScr_SetTeamMode
==============
*/
void GScr_SetTeamMode(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const char *v3; 
  const char *v4; 

  ConstString = Scr_GetConstString(scrContext, 0);
  if ( ConstString == scr_const.teammode_ffa )
  {
    level.teammode = TEAMMODE_FFA;
  }
  else if ( ConstString == scr_const.teammode_axisallies )
  {
    level.teammode = TEAMMODE_AXIS_ALLIES;
  }
  else
  {
    v3 = SL_ConvertToString(ConstString);
    v4 = j_va("Illegal teammode string '%s'. Must be ffa, or axis_allies.", v3);
    Scr_Error(COM_ERR_3137, scrContext, v4);
  }
}

/*
==============
GScr_GetTeamScore
==============
*/
void GScr_GetTeamScore(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const char *v3; 
  const char *v4; 
  team_t outTeam; 

  ConstString = Scr_GetConstString(scrContext, 0);
  if ( Com_Teams_TeamFromString(ConstString, &outTeam) )
  {
    Scr_AddInt(scrContext, level.teamScores[outTeam]);
  }
  else
  {
    v3 = SL_ConvertToString(ConstString);
    v4 = j_va("unknown team '%s'", v3);
    Scr_Error(COM_ERR_3138, scrContext, v4);
  }
}

/*
==============
GScr_SetTeamScore
==============
*/
void GScr_SetTeamScore(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const char *v3; 
  const char *v4; 
  int Int; 
  team_t v6; 
  int v7; 
  unsigned __int16 v8; 
  unsigned __int16 v9; 
  team_t outTeam; 

  ConstString = Scr_GetConstString(scrContext, 0);
  if ( Com_Teams_TeamFromString(ConstString, &outTeam) )
  {
    Int = Scr_GetInt(scrContext, 1u);
    v6 = outTeam;
    v7 = Int;
    level.teamScores[outTeam] = Int;
    if ( SV_OnlineTournament_IsInTournament() )
    {
      if ( v6 == TEAM_TWO )
      {
        v8 = truncate_cast<unsigned short,int>(v7);
        SV_OnlineTournament_TeamScoreUpdated(TEAM_1, v8);
      }
      else if ( v6 == TEAM_ONE )
      {
        v9 = truncate_cast<unsigned short,int>(v7);
        SV_OnlineTournament_TeamScoreUpdated(TEAM_0, v9);
      }
    }
  }
  else
  {
    v3 = SL_ConvertToString(ConstString);
    v4 = j_va("unknown team '%s'", v3);
    Scr_Error(COM_ERR_3139, scrContext, v4);
  }
}

/*
==============
GScr_SetTeamPlacement
==============
*/
void GScr_SetTeamPlacement(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const char *v3; 
  const char *v4; 
  int Int; 
  team_t outTeam; 

  ConstString = Scr_GetConstString(scrContext, 0);
  if ( Com_Teams_TeamFromString(ConstString, &outTeam) )
  {
    Int = Scr_GetInt(scrContext, 1u);
    level.teamPlacements[outTeam] = Int;
  }
  else
  {
    v3 = SL_ConvertToString(ConstString);
    v4 = j_va("unknown team '%s'", v3);
    Scr_Error(COM_ERR_6536, scrContext, v4);
  }
}

/*
==============
GScr_SetClientNameMode
==============
*/
void GScr_SetClientNameMode(scrContext_t *scrContext)
{
  scr_string_t ConstString; 

  ConstString = Scr_GetConstString(scrContext, 0);
  if ( ConstString == scr_const.auto_change )
  {
    level.manualNameChange = 0;
  }
  else if ( ConstString == scr_const.manual_change )
  {
    level.manualNameChange = 1;
  }
  else
  {
    Scr_Error(COM_ERR_3140, scrContext, "Unknown mode");
  }
}

/*
==============
GScr_UpdateClientNames
==============
*/
void GScr_UpdateClientNames(scrContext_t *scrContext)
{
  int maxclients; 
  int v2; 
  char *name; 
  char *v4; 
  int v5; 
  int v6; 
  char dest[40]; 

  if ( !level.manualNameChange )
    Scr_Error(COM_ERR_3141, scrContext, "Only works in [manual_change] mode");
  maxclients = level.maxclients;
  v2 = 0;
  if ( level.maxclients > 0 )
  {
    name = level.clients->sess.cs.name;
    do
    {
      if ( *((_DWORD *)name - 193) == 2 )
      {
        v4 = name;
        do
        {
          v5 = (unsigned __int8)*(v4 - 192);
          v6 = (unsigned __int8)*v4 - v5;
          if ( v6 )
            break;
          ++v4;
        }
        while ( v5 );
        if ( v6 )
        {
          Core_strcpy(dest, 0x24ui64, name);
          Core_strcpy(name, 0x24ui64, name - 192);
          G_ClientMP_UserinfoChanged(v2);
          maxclients = level.maxclients;
        }
      }
      ++v2;
      name += 64592;
    }
    while ( v2 < maxclients );
  }
}

/*
==============
GScr_GetTeamPlayersAlive
==============
*/
void GScr_GetTeamPlayersAlive(scrContext_t *scrContext)
{
  scrContext_t *v1; 
  scr_string_t ConstString; 
  const char *v3; 
  const char *v4; 
  int v5; 
  signed int v6; 
  __int64 v7; 
  __int64 v8; 
  team_t v9; 
  __int64 v10; 
  __int64 v11; 
  team_t outTeam; 

  v1 = scrContext;
  ConstString = Scr_GetConstString(scrContext, 0);
  if ( Com_Teams_TeamFromString(ConstString, &outTeam) )
  {
    v5 = 0;
    v6 = 0;
    if ( (int)SvClient::ms_clientCount > 0 )
    {
      v7 = 0i64;
      v8 = 0i64;
      v9 = outTeam;
      do
      {
        if ( (unsigned int)v6 >= 0x800 )
        {
          LODWORD(v11) = 2048;
          LODWORD(v10) = v6;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 207, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( 2048 ) )", "entityIndex doesn't index MAX_GENTITIES\n\t%i not in [0, %i)", v10, v11) )
            __debugbreak();
        }
        if ( !g_entities && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 208, ASSERT_TYPE_ASSERT, "( g_entities != nullptr )", (const char *)&queryFormat, "g_entities != nullptr") )
          __debugbreak();
        if ( g_entities[v7].r.isInUse != g_entityIsInUse[v8] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\g_public.h", 209, ASSERT_TYPE_ASSERT, "( g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex] )", (const char *)&queryFormat, "g_entities[entityIndex].r.isInUse == g_entityIsInUse[entityIndex]") )
          __debugbreak();
        if ( g_entityIsInUse[v8] && g_entities[v7].client->sess.cs.team == v9 && g_entities[v7].health > 0 )
          ++v5;
        ++v6;
        ++v8;
        ++v7;
      }
      while ( v6 < (int)SvClient::ms_clientCount );
      v1 = scrContext;
    }
    Scr_AddInt(v1, v5);
  }
  else
  {
    v3 = SL_ConvertToString(ConstString);
    v4 = j_va("unknown team '%s'", v3);
    Scr_Error(COM_ERR_3142, v1, v4);
  }
}

/*
==============
GScr_SetPlayerTeamRank
==============
*/
void GScr_SetPlayerTeamRank(scrContext_t *scrContext)
{
  gentity_s *Entity; 
  int Int; 

  __asm { vmovaps [rsp+38h+var_18], xmm6 }
  if ( Scr_GetNumParam(scrContext) != 3 )
    Scr_ParamError(COM_ERR_3143, scrContext, 0, "setPlayerTeamRank [entity] [team] [rank]");
  Entity = GScr_GetEntity(0);
  Int = Scr_GetInt(scrContext, 1u);
  *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
  __asm { vmovaps xmm6, xmm0 }
  if ( !Entity )
    Scr_ParamError(COM_ERR_3144, scrContext, 0, "setPlayerTeamRank Error: param 1 is not an entity");
  if ( Int < 0 )
    Scr_ParamError(COM_ERR_3145, scrContext, 1u, "setPlayerTeamRank Error: param 2 must be >= 0");
  __asm
  {
    vmovaps xmm1, xmm6; rankValue
    vmovaps xmm6, [rsp+38h+var_18]
  }
  SV_ClientMP_SetClientRankValue(Entity->s.number, *(const float *)&_XMM1);
}

/*
==============
GScr_EndXboxLiveLobby
==============
*/
void GScr_EndXboxLiveLobby(scrContext_t *scrContext)
{
  ;
}

/*
==============
GScr_GetAssignedTeam
==============
*/
void GScr_GetAssignedTeam(scrContext_t *scrContext)
{
  gentity_s *Entity; 
  int AssignedTeam; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_ParamError(COM_ERR_3146, scrContext, 0, "getAssignedTeam [player]");
  Entity = GScr_GetEntity(0);
  if ( !Entity )
    Scr_ParamError(COM_ERR_3147, scrContext, 0, "getAssignedTeam Error: param 1 is not an entity.");
  AssignedTeam = SV_ClientMP_GetAssignedTeam(Entity->s.number);
  Scr_AddInt(scrContext, AssignedTeam);
}

/*
==============
GScr_SendLeaderboards
==============
*/
void GScr_SendLeaderboards(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  const char *v4; 
  unsigned int number; 
  const char *v6; 
  SvClient *CommonClient; 

  Entity = GetEntity(entref);
  if ( !Entity->client )
    Scr_Error(COM_ERR_3148, scrContext, "sendleaderboards: entity must be a player entity");
  v4 = j_va("%c", 73i64);
  number = Entity->s.number;
  v6 = v4;
  if ( number == -1 )
  {
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v4);
  }
  else
  {
    CommonClient = SvClient::GetCommonClient(number);
    CommonClient->SendServerCommand(CommonClient, SV_CMD_RELIABLE, v6);
  }
}

/*
==============
GScr_GetClientMatchData
==============
*/
void GScr_GetClientMatchData(scrContext_t *scrContext)
{
  SvGameGlobalsMP *SvGameGlobalsMP; 
  const DDLDef *Asset; 
  DDLState state; 
  DDLContext ddlContext; 

  SvGameGlobalsMP = SvGameGlobalsMP::GetSvGameGlobalsMP();
  if ( !SvGameGlobalsMP->clientMatchData.def[0] )
    Scr_Error(COM_ERR_3149, scrContext, "No match data def defined");
  Asset = Com_DDL_LoadAsset(SvGameGlobalsMP->clientMatchData.def);
  if ( !Com_DDL_CreateContext(SvGameGlobalsMP->clientMatchData.data, 24000, Asset, &ddlContext, NULL, NULL) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 6620, ASSERT_TYPE_ASSERT, "(Com_DDL_CreateContext( sv->clientMatchData.data, sizeof( sv->clientMatchData.data ), def, &buffer, 0, 0 ))", (const char *)&queryFormat, "Com_DDL_CreateContext( sv->clientMatchData.data, sizeof( sv->clientMatchData.data ), def, &buffer, NULL, NULL )") )
    __debugbreak();
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovdqu xmmword ptr [rsp+88h+state.member], xmm0
  }
  state.isValid = 0;
  state.offset = 0;
  state.arrayIndex = -1;
  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
    Scr_Error(COM_ERR_3120, scrContext, "GetDDL: Can't use this function on the front end server");
  LiveStorage_InitializeDDLStateForStatsGroup(Asset, &state, STATSGROUP_IGNORE);
  GScr_Main_GetDDL(scrContext, &state, Asset, &ddlContext, "GetMatchData", 0);
}

/*
==============
GScr_GetMatchData
==============
*/
void GScr_GetMatchData(scrContext_t *scrContext)
{
  SvGameGlobalsMP *SvGameGlobalsMP; 
  const DDLDef *Asset; 
  DDLState state; 
  DDLContext ddlContext; 

  SvGameGlobalsMP = SvGameGlobalsMP::GetSvGameGlobalsMP();
  if ( !SvGameGlobalsMP->matchDataDef[0] )
    Scr_Error(COM_ERR_3150, scrContext, "No match data def defined");
  Asset = Com_DDL_LoadAsset(SvGameGlobalsMP->matchDataDef);
  Com_DDL_CreateContext(SvGameGlobalsMP->matchData, 2048, Asset, &ddlContext, NULL, NULL);
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovdqu xmmword ptr [rsp+88h+state.member], xmm0
  }
  state.isValid = 0;
  state.offset = 0;
  state.arrayIndex = -1;
  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
    Scr_Error(COM_ERR_3120, scrContext, "GetDDL: Can't use this function on the front end server");
  LiveStorage_InitializeDDLStateForStatsGroup(Asset, &state, STATSGROUP_IGNORE);
  GScr_Main_GetDDL(scrContext, &state, Asset, &ddlContext, "GetMatchData", 0);
}

/*
==============
GScr_OnMatchBegin
==============
*/
void GScr_OnMatchBegin(scrContext_t *scrContext)
{
  const char *MatchIdString; 

  MatchIdString = OnlineMatchId::GetMatchIdString();
  SV_SetConfigstring(0x218u, MatchIdString);
  Com_Printf(16, "GScr_OnMatchBegin\n");
}

/*
==============
GScr_OnMatchEnd
==============
*/
void GScr_OnMatchEnd(scrContext_t *scrContext)
{
  Online_MatchData_RecordBreadcrumbCount();
  Com_Printf(16, "GScr_OnMatchEnd\n");
}

/*
==============
GScr_SendMatchData
==============
*/
void GScr_SendMatchData(scrContext_t *scrContext)
{
  if ( !SvGameGlobalsMP::GetSvGameGlobalsMP()->matchDataDef[0] )
    Scr_Error(COM_ERR_3151, scrContext, "No match data def defined");
  Cbuf_AddCall(LOCAL_CLIENT_0, SV_CmdsMP_SendMatchData);
}

/*
==============
GScr_ClearMatchData
==============
*/
void GScr_ClearMatchData(scrContext_t *scrContext)
{
  SvGameGlobalsMP *SvGameGlobalsMP; 

  SvGameGlobalsMP = SvGameGlobalsMP::GetSvGameGlobalsMP();
  memset_0(SvGameGlobalsMP->matchData, 0, sizeof(SvGameGlobalsMP->matchData));
  SvGameGlobalsMP->matchDataDef[0] = 0;
}

/*
==============
GScr_SetClientMatchData
==============
*/
void GScr_SetClientMatchData(scrContext_t *scrContext)
{
  SvGameGlobalsMP *SvGameGlobalsMP; 
  const DDLDef *Asset; 
  DDLState state; 
  DDLContext ddlContext; 

  SvGameGlobalsMP = SvGameGlobalsMP::GetSvGameGlobalsMP();
  if ( !SvGameGlobalsMP->clientMatchData.def[0] )
    Scr_Error(COM_ERR_3153, scrContext, "No match data def defined");
  Asset = Com_DDL_LoadAsset(SvGameGlobalsMP->clientMatchData.def);
  if ( !Com_DDL_CreateContext(SvGameGlobalsMP->clientMatchData.data, 24000, Asset, &ddlContext, NULL, NULL) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 6771, ASSERT_TYPE_ASSERT, "(Com_DDL_CreateContext( sv->clientMatchData.data, sizeof( sv->clientMatchData.data ), def, &buffer, 0, 0 ))", (const char *)&queryFormat, "Com_DDL_CreateContext( sv->clientMatchData.data, sizeof( sv->clientMatchData.data ), def, &buffer, NULL, NULL )") )
    __debugbreak();
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovdqu xmmword ptr [rsp+88h+state.member], xmm0
  }
  state.isValid = 0;
  state.offset = 0;
  state.arrayIndex = -1;
  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
    Scr_Error(COM_ERR_3121, scrContext, "SetDDL: Can't use this function on the front end server");
  LiveStorage_InitializeDDLStateForStatsGroup(Asset, &state, STATSGROUP_IGNORE);
  GScr_Main_SetDDL(scrContext, &state, Asset, &ddlContext, "GScr_SetClientMatchData", 0);
}

/*
==============
GScr_SetMatchClientIP
==============
*/
void GScr_SetMatchClientIP(scrContext_t *scrContext)
{
  SvGameGlobalsMP *SvGameGlobalsMP; 
  gentity_s *Entity; 
  int Int; 
  __int64 number; 
  const DDLDef *Asset; 
  unsigned int RawHash; 
  unsigned int v12; 
  bool v13; 
  __int64 v14; 
  unsigned __int8 In4AddrByte; 
  unsigned __int8 v16; 
  unsigned __int8 v17; 
  unsigned __int8 v18; 
  unsigned int v19; 
  unsigned int v20; 
  unsigned int v21; 
  unsigned int v22; 
  VoteType *p_vote; 
  int v24; 
  unsigned int newOffset; 
  DDLState state; 
  DDLState fromState; 
  DDLState toState; 
  DDLContext ddlContext; 
  DDLState result; 
  bdAddr v31; 
  XNADDR outAddr; 

  fromState.isValid = 0;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  fromState.offset = 0;
  __asm { vmovdqu xmmword ptr [rbp+140h+fromState.member], xmm0 }
  toState.isValid = 0;
  toState.offset = 0;
  __asm { vmovdqu xmmword ptr [rbp+140h+toState.member], xmm0 }
  state.isValid = 0;
  state.offset = 0;
  __asm { vmovdqu xmmword ptr [rsp+240h+state.member], xmm0 }
  fromState.arrayIndex = -1;
  toState.arrayIndex = -1;
  state.arrayIndex = -1;
  SvGameGlobalsMP = SvGameGlobalsMP::GetSvGameGlobalsMP();
  if ( !SvGameGlobalsMP->matchDataDef[0] )
    Scr_Error(COM_ERR_3154, scrContext, "No match data def defined");
  if ( Scr_GetNumParam(scrContext) == 2 )
  {
    if ( SvPersistentGlobalsMP::IsFrontEndServer() )
      Scr_Error(COM_ERR_3156, scrContext, "SetMatchClientIP cannot be called for front-end server");
    Entity = GScr_GetEntity(0);
    Int = Scr_GetInt(scrContext, 1u);
    if ( !Entity )
      Scr_ParamError(COM_ERR_3157, scrContext, 0, "matchdata set ip Error: param 1 is not an entity");
    if ( !SV_IsDemoPlaying() )
    {
      number = Entity->s.number;
      SV_ClientMP_GetXNAddr(Entity->s.number, &outAddr);
      Asset = Com_DDL_LoadAsset(SvGameGlobalsMP->matchDataDef);
      Com_DDL_CreateContext(SvGameGlobalsMP->matchData, 2048, Asset, &ddlContext, NULL, NULL);
      _RAX = DDL_GetRootState(&result, Asset);
      __asm
      {
        vmovups ymm0, ymmword ptr [rax]
        vmovups ymmword ptr [rsp+240h+fromState.isValid], ymm0
      }
      RawHash = j_SL_GetRawHash(scr_const.players);
      DDL_MoveToNameByHash(&fromState, &fromState, RawHash, NULL);
      if ( DDL_MoveToIndex(&fromState, &fromState, Int) )
      {
        v12 = j_SL_GetRawHash(scr_const.playerIP);
        DDL_MoveToNameByHash(&fromState, &toState, v12, NULL);
        bdAddr::bdAddr(&v31);
        v13 = 1;
        newOffset = 0;
        v14 = 5i64;
        do
        {
          v13 = v13 && bdAddr::deserialize(&v31, &outAddr, 0x54u, newOffset, &newOffset);
          --v14;
        }
        while ( v14 );
        if ( v13 )
          bdAddr::deserialize(&v31, &outAddr, 0x54u, newOffset, &newOffset);
        In4AddrByte = bdSockAddr::getIn4AddrByte(&v31.m_address, 0);
        v16 = bdSockAddr::getIn4AddrByte(&v31.m_address, 1);
        v17 = bdSockAddr::getIn4AddrByte(&v31.m_address, 2);
        v18 = bdSockAddr::getIn4AddrByte(&v31.m_address, 3);
        v19 = j_SL_GetRawHash(scr_const.a);
        DDL_MoveToNameByHash(&toState, &state, v19, NULL);
        DDL_SetByte(&state, &ddlContext, In4AddrByte);
        v20 = j_SL_GetRawHash(scr_const.b);
        DDL_MoveToNameByHash(&toState, &state, v20, NULL);
        DDL_SetByte(&state, &ddlContext, v16);
        v21 = j_SL_GetRawHash(scr_const.c);
        DDL_MoveToNameByHash(&toState, &state, v21, NULL);
        DDL_SetByte(&state, &ddlContext, v17);
        v22 = j_SL_GetRawHash(scr_const.d);
        DDL_MoveToNameByHash(&toState, &state, v22, NULL);
        DDL_SetByte(&state, &ddlContext, v18);
        if ( mapvote_logging->current.integer == 1 )
        {
          p_vote = &Lobby_GetPartyData()->partyMembers[number].info.vote;
          Com_Printf(16, "Client %d voted for %d\n", (unsigned int)number, *(unsigned int *)p_vote);
          DDL_MoveToName(&fromState, &toState, "voteType");
          v24 = *p_vote;
          if ( (v24 < 0 || (unsigned int)v24 > 0xFF) && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned char __cdecl truncate_cast_impl<unsigned char,enum VoteType>(enum VoteType)", "unsigned", (unsigned __int8)v24, "signed", v24) )
            __debugbreak();
          DDL_SetByte(&toState, &ddlContext, v24);
        }
      }
    }
  }
  else
  {
    Scr_Error(COM_ERR_3155, scrContext, "Incorrect number of parameters.\n");
  }
}

/*
==============
GScr_RecordBreadcrumbDataForPlayer
==============
*/
void GScr_RecordBreadcrumbDataForPlayer(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  unsigned int clientNum; 
  BG_SynchronizedPlayerInfo *PlayerInfo; 
  const char *v6; 
  unsigned int Int; 
  int v8; 
  int v9; 

  Entity = GetEntity(entref);
  if ( Entity->client )
  {
    if ( Scr_GetNumParam(scrContext) == 3 )
    {
      clientNum = Entity->s.clientNum;
      PlayerInfo = SvClientMP::GetPlayerInfo(clientNum);
      if ( !PlayerInfo )
      {
        v6 = j_va("Online_MatchData_RecordBreadcrumbData - error accessing playerInfo for clientNum %d", clientNum);
        Scr_Error(COM_ERR_5699, scrContext, v6);
      }
      Int = Scr_GetInt(scrContext, 0);
      v8 = Scr_GetInt(scrContext, 1u);
      v9 = Scr_GetInt(scrContext, 2u);
      Online_MatchData_RecordBreadcrumbData(Entity, PlayerInfo, Int, v8, v9 != 0);
    }
    else
    {
      Scr_Error(COM_ERR_3159, scrContext, "RecordBreadcrumbDataForPlayer takes 3 params!\n");
    }
  }
  else
  {
    Scr_Error(COM_ERR_3158, scrContext, "RecordBreadcrumbDataForPlayer must be called on a player\n");
  }
}

/*
==============
GScr_LogPingHistogram
==============
*/
void GScr_LogPingHistogram(scrContext_t *scrContext, scr_entref_t entref)
{
  Com_Printf(15, "LogPingHistogram is deprecated. client network histograms are logged by sendClientNetworkTelemetry()");
}

/*
==============
GScr_SendClientNetworkTelemetry
==============
*/
void GScr_SendClientNetworkTelemetry(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( Entity->client )
    SV_ClientNetPerf_SendClientNetworkTelemetry(Entity->s.clientNum);
  else
    Scr_Error(COM_ERR_6218, scrContext, "GScr_SendClientNetworkTelemetry must be called on a client");
}

/*
==============
GScr_SendCollectedClientAnticheatData
==============
*/
void GScr_SendCollectedClientAnticheatData(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 

  Entity = GetEntity(entref);
  if ( Entity->client )
    SV_ClientAntiCheatMP_SendCollectedAntiCheatData(Entity->s.clientNum);
  else
    Scr_Error(COM_ERR_6537, scrContext, "GScr_SendCollectedClientAnticheatData must be called on a client");
}

/*
==============
GScr_IsTrialVersion
==============
*/
void GScr_IsTrialVersion(scrContext_t *scrContext, scr_entref_t entref)
{
  Scr_AddInt(scrContext, 0);
}

/*
==============
GScr_LogPlayerEndMatchData
==============
*/
void GScr_LogPlayerEndMatchData(scrContext_t *scrContext, scr_entref_t entref)
{
  Com_PrintWarning(16, "GScr_LogPlayerEndMatchData is deprecated\n");
}

/*
==============
GScr_LogPlayerEndMatchDataShotsHits
==============
*/
void GScr_LogPlayerEndMatchDataShotsHits(scrContext_t *scrContext, scr_entref_t entref)
{
  Com_PrintWarning(16, "GScr_LogPlayerEndMatchDataShotsHits is deprecated\n");
}

/*
==============
GScr_LogPlayerEndMatchDataMisc
==============
*/
void GScr_LogPlayerEndMatchDataMisc(scrContext_t *scrContext, scr_entref_t entref)
{
  Com_PrintWarning(16, "GScr_LogPlayerEndMatchDataMisc is deprecated\n");
}

/*
==============
GScr_LogPlayerEndMatchDataHeadBody
==============
*/
void GScr_LogPlayerEndMatchDataHeadBody(scrContext_t *scrContext, scr_entref_t entref)
{
  Com_PrintWarning(16, "GScr_LogPlayerEndMatchDataHeadBody is deprecated\n");
}

/*
==============
GScr_LogPlayerEndMatchDataGesture
==============
*/
void GScr_LogPlayerEndMatchDataGesture(scrContext_t *scrContext, scr_entref_t entref)
{
  Com_PrintWarning(16, "GScr_LogPlayerEndMatchDataGesture is deprecated\n");
}

/*
==============
GScr_LogPlayerEndMatchDataMatchResult
==============
*/
void GScr_LogPlayerEndMatchDataMatchResult(scrContext_t *scrContext, scr_entref_t entref)
{
  Com_PrintWarning(16, "GScr_LogPlayerEndMatchDataMatchResult is deprecated\n");
}

/*
==============
GScr_LogMatchDataLife
==============
*/
void GScr_LogMatchDataLife(scrContext_t *scrContext, scr_entref_t entref)
{
  SvGameGlobalsMP *SvGameGlobalsMP; 
  gentity_s *Entity; 
  int Int; 
  int v9; 
  const DDLDef *Asset; 
  unsigned int RawHash; 
  int v14; 
  unsigned int v15; 
  unsigned int v16; 
  unsigned int v17; 
  unsigned int v18; 
  unsigned int v19; 
  unsigned int v20; 
  unsigned int v21; 
  team_t team; 
  const char *v23; 
  DDLState toState; 
  int v25; 
  int v26; 
  DDLState v27; 
  DDLContext ddlContext; 
  DDLState fromState; 
  DDLState v30; 
  DDLState result; 
  vec3_t vectorValue; 

  fromState.isValid = 0;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  fromState.offset = 0;
  __asm { vmovdqu xmmword ptr [rbp+50h+fromState.member], xmm0 }
  v30.isValid = 0;
  v30.offset = 0;
  __asm { vmovdqu xmmword ptr [rbp+50h+var_88.member], xmm0 }
  v27.isValid = 0;
  v27.offset = 0;
  __asm { vmovdqu xmmword ptr [rsp+150h+var_F8.member], xmm0 }
  toState.isValid = 0;
  toState.offset = 0;
  __asm { vmovdqu xmmword ptr [rsp+150h+toState.member], xmm0 }
  fromState.arrayIndex = -1;
  v30.arrayIndex = -1;
  v27.arrayIndex = -1;
  toState.arrayIndex = -1;
  SvGameGlobalsMP = SvGameGlobalsMP::GetSvGameGlobalsMP();
  if ( !SvGameGlobalsMP->matchDataDef[0] )
    Scr_Error(COM_ERR_3168, scrContext, "No match data def defined");
  if ( Scr_GetNumParam(scrContext) < 5 )
    Scr_Error(COM_ERR_3169, scrContext, "Missing information for match data life.");
  Entity = GetEntity(entref);
  if ( !Entity->client )
  {
    Scr_Error(COM_ERR_3170, scrContext, "LogMatchDataLife must be called on a client");
    if ( !Entity->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7158, ASSERT_TYPE_ASSERT, "( entity->client )", (const char *)&queryFormat, "entity->client", *(_QWORD *)&toState.isValid, *(_QWORD *)&toState.arrayIndex, toState.member, toState.ddlDef) )
      __debugbreak();
  }
  Int = Scr_GetInt(scrContext, 0);
  Scr_GetVector(scrContext, 1u, &vectorValue);
  v9 = Scr_GetInt(scrContext, 2u);
  v25 = Scr_GetInt(scrContext, 3u);
  v26 = Scr_GetInt(scrContext, 4u);
  Asset = Com_DDL_LoadAsset(SvGameGlobalsMP->matchDataDef);
  Com_DDL_CreateContext(SvGameGlobalsMP->matchData, 2048, Asset, &ddlContext, NULL, NULL);
  _RAX = DDL_GetRootState(&result, Asset);
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovups ymmword ptr [rbp+50h+fromState.isValid], ymm0
  }
  RawHash = j_SL_GetRawHash(scr_const.lifeCount);
  if ( !DDL_MoveToNameByHash(&fromState, &toState, RawHash, NULL) )
    Scr_Error(COM_ERR_3171, scrContext, "Invalid match data definition specified. Must contain a lifeCount field.");
  if ( DDL_GetType(&toState) != DDL_SHORT_TYPE )
    Scr_Error(COM_ERR_3172, scrContext, "Invalid match data definition specified. lifeCount must be a short");
  LOWORD(v14) = DDL_GetShort(&toState, &ddlContext);
  if ( (_WORD)v14 != 0xFFFF )
    DDL_SetShort(&toState, &ddlContext, v14 + 1);
  if ( (unsigned __int16)v14 < 0x1DBu )
  {
    v15 = j_SL_GetRawHash(scr_const.lives);
    if ( !DDL_MoveToNameByHash(&fromState, &v30, v15, NULL) )
      Scr_Error(COM_ERR_3173, scrContext, "Invalid match data definition specified. The lives field must be an indexed array of life structures");
    v14 = (unsigned __int16)v14;
    if ( !DDL_MoveToIndex(&v30, &v27, (unsigned __int16)v14) )
      Scr_Error(COM_ERR_3174, scrContext, "Invalid match data definition specified. The lives field must be an indexed array of life structures");
    v16 = j_SL_GetRawHash(scr_const.player);
    DDL_MoveToNameByHash(&v27, &toState, v16, NULL);
    DDL_SetInt(&toState, &ddlContext, Int);
    v17 = j_SL_GetRawHash(scr_const.spawnPos);
    DDL_MoveToNameByHash(&v27, &toState, v17, NULL);
    Com_DDL_SetShortVec3(&toState, &ddlContext, &vectorValue);
    v18 = j_SL_GetRawHash(scr_const.spawnTime_msFromMatchStart);
    DDL_MoveToNameByHash(&v27, &toState, v18, NULL);
    DDL_SetInt(&toState, &ddlContext, v9);
    v19 = j_SL_GetRawHash(scr_const.wasTacticalInsertion);
    DDL_MoveToNameByHash(&v27, &toState, v19, NULL);
    DDL_SetBool(&toState, &ddlContext, v25 != 0);
    v20 = j_SL_GetRawHash(scr_const.loadoutIndex);
    DDL_MoveToNameByHash(&v27, &toState, v20, NULL);
    DDL_SetByte(&toState, &ddlContext, v26);
    v21 = j_SL_GetRawHash(scr_const.team);
    DDL_MoveToNameByHash(&v27, &toState, v21, NULL);
    team = Entity->client->sess.cs.team;
    if ( team )
    {
      if ( team == TEAM_ONE )
      {
        v23 = "axis";
      }
      else if ( team == TEAM_TWO )
      {
        v23 = "allies";
      }
      else
      {
        if ( (unsigned int)(team - 201) > 1 )
          goto LABEL_30;
        v23 = "spectator";
      }
    }
    else
    {
      v23 = "none";
    }
    DDL_SetEnum(&toState, &ddlContext, v23);
    goto LABEL_30;
  }
  v14 = 474;
LABEL_30:
  Scr_AddInt(scrContext, v14);
}

/*
==============
GScr_LogMatchDataDeath
==============
*/
void GScr_LogMatchDataDeath(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int v5; 
  int Int; 
  gentity_s *Entity; 
  unsigned int v12; 
  unsigned int ArrayObject; 
  unsigned int ArraySize; 
  const char *v15; 
  unsigned int v19; 
  const char *v20; 
  const DDLDef *Asset; 
  unsigned int RawHash; 
  unsigned int v25; 
  unsigned int v26; 
  unsigned int v27; 
  unsigned int v28; 
  unsigned __int8 MotionState; 
  unsigned int v30; 
  unsigned int v46; 
  unsigned int v47; 
  unsigned int v48; 
  unsigned int v52; 
  unsigned int v53; 
  unsigned int v54; 
  unsigned __int8 v55; 
  unsigned int v56; 
  unsigned int v59; 
  unsigned int v60; 
  unsigned int v61; 
  unsigned int v62; 
  unsigned int v63; 
  unsigned int v64; 
  unsigned int v65; 
  unsigned int v66; 
  unsigned int v67; 
  unsigned int attachmentsStringHash; 
  unsigned int weaponAltModeHash; 
  unsigned int v70; 
  int lifeIndex; 
  unsigned int v72; 
  unsigned int v73; 
  unsigned int v74; 
  bool v75; 
  bool outIsAlternate; 
  DDLState state; 
  DDLState lifeState; 
  int index; 
  int val; 
  int v81; 
  int v82; 
  int v83; 
  int v84; 
  int v85; 
  int v86; 
  int v87; 
  unsigned int attachmentsArrayId; 
  unsigned int attachmentsArrayCount; 
  DDLContext ddlContext; 
  char *fileName; 
  SvGameGlobalsMP *SvGameGlobalsMP; 
  char *String; 
  DDLState fromState; 
  DDLState toState; 
  DDLState result; 
  vec2_t forward; 
  Weapon r_weapon; 
  Weapon outWeapon; 

  v5 = 0;
  fromState.isValid = 0;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  Int = -1;
  fromState.offset = 0;
  fromState.arrayIndex = -1;
  __asm { vmovdqu xmmword ptr [rbp+160h+fromState.member], xmm0 }
  toState.isValid = 0;
  toState.offset = 0;
  toState.arrayIndex = -1;
  __asm { vmovdqu xmmword ptr [rbp+160h+toState.member], xmm0 }
  lifeState.isValid = 0;
  lifeState.offset = 0;
  lifeState.arrayIndex = -1;
  __asm { vmovdqu xmmword ptr [rbp+160h+lifeState.member], xmm0 }
  state.isValid = 0;
  state.offset = 0;
  state.arrayIndex = -1;
  __asm { vmovdqu xmmword ptr [rsp+260h+state.member], xmm0 }
  SvGameGlobalsMP = SvGameGlobalsMP::GetSvGameGlobalsMP();
  fileName = SvGameGlobalsMP->matchDataDef;
  if ( !SvGameGlobalsMP->matchDataDef[0] )
    Scr_Error(COM_ERR_3178, scrContext, "No match data def defined");
  _R14 = GetEntity(entref);
  if ( !_R14->client )
  {
    Scr_Error(COM_ERR_3179, scrContext, "LogMatchDataDeath must be called on a client");
    if ( !_R14->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7494, ASSERT_TYPE_ASSERT, "( victim->client )", (const char *)&queryFormat, "victim->client") )
      __debugbreak();
  }
  if ( Scr_GetNumParam(scrContext) != 17 )
  {
    Scr_Error(COM_ERR_3180, scrContext, "GScr_LogMatchDataDeath requires 17 params\n");
    return;
  }
  index = Scr_GetInt(scrContext, 0);
  LODWORD(forward.v[0]) = Scr_GetInt(scrContext, 1u);
  if ( Scr_GetType(scrContext, 2u) )
    Entity = GScr_GetEntity(2u);
  else
    Entity = NULL;
  if ( Scr_GetType(scrContext, 3u) )
    Int = Scr_GetInt(scrContext, 3u);
  GScr_Main_GetWeaponParam(scrContext, 4u, &outWeapon, &outIsAlternate);
  String = (char *)Scr_GetString(scrContext, 5u);
  v83 = Scr_GetInt(scrContext, 6u);
  v81 = Scr_GetInt(scrContext, 7u);
  attachmentsArrayId = BGScr_Main_GetArrayObject(scrContext, 8u);
  v12 = attachmentsArrayId;
  val = Scr_GetInt(scrContext, 9u);
  if ( Scr_GetType(scrContext, 0xAu) )
  {
    GScr_Main_GetWeaponParam(scrContext, 0xAu, &r_weapon, &v75);
    ArrayObject = BGScr_Main_GetArrayObject(scrContext, 0xBu);
    ArraySize = GetArraySize(scrContext, ArrayObject);
    v5 = ArraySize;
    if ( ArraySize > 0x800 )
    {
      v15 = j_va("array is too large (%d > %d), need to increase sortable array size", ArraySize, 2048i64);
      Scr_ParamError(COM_ERR_3181, scrContext, 0xBu, v15);
      return;
    }
  }
  else
  {
    __asm
    {
      vmovups ymm0, ymmword ptr cs:?NULL_WEAPON@@3UWeapon@@B.weaponIdx; Weapon const NULL_WEAPON
      vmovups xmm1, xmmword ptr cs:?NULL_WEAPON@@3UWeapon@@B.attachmentVariationIndices+5; Weapon const NULL_WEAPON
    }
    ArrayObject = 0;
    __asm
    {
      vmovups ymmword ptr [rbp+160h+r_weapon.weaponIdx], ymm0
      vmovsd  xmm0, qword ptr cs:?NULL_WEAPON@@3UWeapon@@B.attachmentVariationIndices+15h; Weapon const NULL_WEAPON
      vmovsd  qword ptr [rbp+160h+r_weapon.attachmentVariationIndices+15h], xmm0
      vmovups xmmword ptr [rbp+160h+r_weapon.attachmentVariationIndices+5], xmm1
    }
    *(_DWORD *)&r_weapon.weaponCamo = *(_DWORD *)&NULL_WEAPON.weaponCamo;
    v75 = 0;
  }
  v84 = Scr_GetInt(scrContext, 0xCu);
  v85 = Scr_GetInt(scrContext, 0xDu);
  v86 = Scr_GetInt(scrContext, 0xEu);
  v87 = Scr_GetInt(scrContext, 0xFu);
  v82 = Scr_GetInt(scrContext, 0x10u);
  v19 = GetArraySize(scrContext, v12);
  attachmentsArrayCount = v19;
  if ( v19 <= 0x800 )
  {
    Asset = Com_DDL_LoadAsset(fileName);
    Com_DDL_CreateContext(SvGameGlobalsMP->matchData, 2048, Asset, &ddlContext, NULL, NULL);
    _RAX = DDL_GetRootState(&result, Asset);
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovups ymmword ptr [rbp+160h+fromState.isValid], ymm0
    }
    RawHash = j_SL_GetRawHash(scr_const.lives);
    if ( !DDL_MoveToNameByHash(&fromState, &toState, RawHash, NULL) )
      Scr_Error(COM_ERR_3183, scrContext, "Invalid match data definition specified. The lives field must be an indexed array of life structures");
    if ( !DDL_MoveToIndex(&toState, &lifeState, index) )
      Scr_Error(COM_ERR_3184, scrContext, "Invalid match data definition specified. The lives field must be an indexed array of life structures");
    v25 = j_SL_GetRawHash(scr_const.deathTime_msFromMatchStart);
    DDL_MoveToNameByHash(&lifeState, &state, v25, NULL);
    DDL_SetInt(&state, &ddlContext, val);
    v26 = j_SL_GetRawHash(scr_const.player);
    DDL_MoveToNameByHash(&lifeState, &state, v26, NULL);
    DDL_SetInt(&state, &ddlContext, SLODWORD(forward.v[0]));
    v27 = j_SL_GetRawHash(scr_const.deathPos);
    DDL_MoveToNameByHash(&lifeState, &state, v27, NULL);
    Com_DDL_SetShortVec3(&state, &ddlContext, &_R14->r.currentOrigin);
    v28 = j_SL_GetRawHash(scr_const.deathAngles);
    DDL_MoveToNameByHash(&lifeState, &state, v28, NULL);
    Com_DDL_SetShortVec3(&state, &ddlContext, &_R14->r.currentAngles);
    MotionState = Online_MatchData_GetMotionState(&_R14->client->ps);
    v30 = j_SL_GetRawHash(scr_const.victimMotionState);
    DDL_MoveToNameByHash(&lifeState, &state, v30, NULL);
    DDL_SetByte(&state, &ddlContext, MotionState);
    if ( Entity && Entity->client )
    {
      __asm
      {
        vmovss  xmm0, dword ptr [r14+140h]; yaw
        vmovaps [rsp+260h+var_40], xmm6
        vmovaps [rsp+260h+var_50], xmm7
      }
      YawVectors2D(*(float *)&_XMM0, &forward, NULL);
      __asm
      {
        vmovss  xmm0, dword ptr [r14+130h]
        vsubss  xmm5, xmm0, dword ptr [r13+130h]
        vmovss  xmm1, dword ptr [r14+134h]
        vsubss  xmm4, xmm1, dword ptr [r13+134h]
        vmulss  xmm0, xmm5, xmm5
        vmulss  xmm2, xmm4, xmm4
        vaddss  xmm1, xmm2, xmm0
        vsqrtss xmm3, xmm1, xmm1
        vmovss  xmm1, cs:__real@3f800000
        vcmpless xmm0, xmm3, cs:__real@80000000
        vblendvps xmm0, xmm3, xmm1, xmm0
        vdivss  xmm1, xmm1, xmm0
        vmulss  xmm6, xmm5, xmm1
        vmulss  xmm7, xmm4, xmm1
      }
      v46 = j_SL_GetRawHash(scr_const.attacker);
      DDL_MoveToNameByHash(&lifeState, &state, v46, NULL);
      DDL_SetInt(&state, &ddlContext, Int);
      v47 = j_SL_GetRawHash(scr_const.attackerPos);
      DDL_MoveToNameByHash(&lifeState, &state, v47, NULL);
      Com_DDL_SetShortVec3(&state, &ddlContext, &Entity->r.currentOrigin);
      v48 = j_SL_GetRawHash(scr_const.dotOfDeath);
      DDL_MoveToNameByHash(&lifeState, &state, v48, NULL);
      __asm
      {
        vmulss  xmm3, xmm6, dword ptr [rbp+160h+forward]
        vmulss  xmm2, xmm7, dword ptr [rbp+160h+forward+4]
        vaddss  xmm2, xmm3, xmm2; val
      }
      DDL_SetFloat(&state, &ddlContext, *(float *)&_XMM2);
      v52 = j_SL_GetRawHash(scr_const.attackerIsJuggernaut);
      DDL_MoveToNameByHash(&lifeState, &state, v52, NULL);
      DDL_SetBool(&state, &ddlContext, v81 != 0);
      v53 = j_SL_GetRawHash(scr_const.attackerCurrentLifeIndex);
      DDL_MoveToNameByHash(&lifeState, &state, v53, NULL);
      DDL_SetShort(&state, &ddlContext, v82);
      v54 = j_SL_GetRawHash(scr_const.attackerAngles);
      DDL_MoveToNameByHash(&lifeState, &state, v54, NULL);
      Com_DDL_SetShortVec3(&state, &ddlContext, &Entity->r.currentAngles);
      v55 = Online_MatchData_GetMotionState(&Entity->client->ps);
      v56 = j_SL_GetRawHash(scr_const.attackerMotionState);
      DDL_MoveToNameByHash(&lifeState, &state, v56, NULL);
      DDL_SetByte(&state, &ddlContext, v55);
      __asm
      {
        vmovaps xmm7, [rsp+260h+var_50]
        vmovaps xmm6, [rsp+260h+var_40]
      }
    }
    else
    {
      v59 = j_SL_GetRawHash(scr_const.attacker);
      DDL_MoveToNameByHash(&lifeState, &state, v59, NULL);
      DDL_SetInt(&state, &ddlContext, 255);
      v60 = j_SL_GetRawHash(scr_const.attackerPos);
      DDL_MoveToNameByHash(&lifeState, &state, v60, NULL);
      Com_DDL_SetShortVec3(&state, &ddlContext, &_R14->r.currentOrigin);
    }
    v61 = j_SL_GetRawHash(scr_const.mod);
    DDL_MoveToNameByHash(&lifeState, &state, v61, NULL);
    DDL_SetEnum(&state, &ddlContext, String);
    v62 = j_SL_GetRawHash(scr_const.modifiers);
    DDL_MoveToNameByHash(&lifeState, &state, v62, NULL);
    v63 = j_SL_GetRawHash(scr_const.killstreak);
    DDL_MoveToNameByHash(&state, &state, v63, NULL);
    DDL_SetBool(&state, &ddlContext, v83 != 0);
    v64 = j_SL_GetRawHash(scr_const.victimWasADS);
    DDL_MoveToNameByHash(&lifeState, &state, v64, NULL);
    DDL_SetBool(&state, &ddlContext, v84 != 0);
    v65 = j_SL_GetRawHash(scr_const.attackerWasADS);
    DDL_MoveToNameByHash(&lifeState, &state, v65, NULL);
    DDL_SetBool(&state, &ddlContext, v85 != 0);
    v66 = j_SL_GetRawHash(scr_const.victimWasInAttackerFOV);
    DDL_MoveToNameByHash(&lifeState, &state, v66, NULL);
    DDL_SetBool(&state, &ddlContext, v86 != 0);
    v67 = j_SL_GetRawHash(scr_const.attackerWasInVictimFOV);
    DDL_MoveToNameByHash(&lifeState, &state, v67, NULL);
    DDL_SetBool(&state, &ddlContext, v87 != 0);
    LogMatchDataDeathWhileReloadingHelper(scrContext, &lifeState, &ddlContext, _R14);
    attachmentsStringHash = j_SL_GetRawHash(scr_const.attacker_weapon_attachments);
    weaponAltModeHash = j_SL_GetRawHash(scr_const.attacker_weapon_alt_mode);
    v70 = j_SL_GetRawHash(scr_const.attacker_weapon);
    lifeIndex = index;
    LogMatchDataDeathWeaponHelper(scrContext, &outWeapon, outIsAlternate, attachmentsArrayCount, attachmentsArrayId, v70, weaponAltModeHash, attachmentsStringHash, &lifeState, &ddlContext, index);
    if ( r_weapon.weaponIdx )
    {
      v72 = j_SL_GetRawHash(scr_const.victim_current_weapon_attachments);
      v73 = j_SL_GetRawHash(scr_const.victim_current_weapon_alt_mode);
      v74 = j_SL_GetRawHash(scr_const.victim_current_weapon);
      LogMatchDataDeathWeaponHelper(scrContext, &r_weapon, v75, v5, ArrayObject, v74, v73, v72, &lifeState, &ddlContext, lifeIndex);
    }
  }
  else
  {
    v20 = j_va("array is too large (%d > %d), need to increase sortable array size", v19, 2048i64);
    Scr_ParamError(COM_ERR_3182, scrContext, 0, v20);
  }
}

/*
==============
GScr_MatchDataPlayerExistingSlot
==============
*/
void GScr_MatchDataPlayerExistingSlot(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  unsigned __int8 ActiveGameMode; 
  int v6; 
  unsigned int v8; 
  SvGameGlobalsMP *SvGameGlobalsMP; 
  gentity_s *v10; 
  const char *v11; 
  const DDLDef *Asset; 
  unsigned int RawHash; 
  unsigned int v16; 
  int Int; 
  unsigned int v18; 
  unsigned int v19; 
  const char *String; 
  bool v21; 
  unsigned int v22; 
  unsigned int v23; 
  unsigned __int64 UInt64; 
  unsigned int v25; 
  unsigned __int64 v26; 
  Online_ErrorReporting *InstancePtr; 
  const char *v28; 
  unsigned __int64 outUnoId; 
  unsigned __int64 outFirstPartyUserId; 
  DDLState state; 
  DLogFirstPartyAccountType outFirstPartyAccountType; 
  unsigned __int64 outUserSessionId; 
  DDLState fromState; 
  DDLState v35; 
  DDLState v36; 
  DDLState toState; 
  DDLState v38; 
  DDLContext ddlContext; 
  DDLState result; 
  EntityClass entclass; 
  char v42; 
  ClientPlatform outClientPlatform; 

  entclass = entref.entclass;
  entnum = entref.entnum;
  ActiveGameMode = Com_GameMode_GetActiveGameMode();
  v6 = -1;
  if ( BG_GameInterface_GameModeIsMP((GameModeType)ActiveGameMode) )
  {
    __asm { vpxor   xmm0, xmm0, xmm0 }
    v8 = 0;
    fromState.offset = 0;
    toState.isValid = 0;
    toState.offset = 0;
    v38.isValid = 0;
    v38.offset = 0;
    v35.isValid = 0;
    v35.offset = 0;
    v36.isValid = 0;
    v36.offset = 0;
    state.isValid = 0;
    state.offset = 0;
    outUnoId = 0i64;
    outFirstPartyUserId = 0i64;
    outUserSessionId = 0i64;
    v42 = 0;
    fromState.isValid = 0;
    fromState.arrayIndex = -1;
    __asm { vmovdqu xmmword ptr [rbp+90h+fromState.member], xmm0 }
    toState.arrayIndex = -1;
    __asm { vmovdqu xmmword ptr [rbp+90h+toState.member], xmm0 }
    v38.arrayIndex = -1;
    __asm { vmovdqu xmmword ptr [rbp+90h+var_A0.member], xmm0 }
    v35.arrayIndex = -1;
    __asm { vmovdqu xmmword ptr [rbp+90h+var_100.member], xmm0 }
    v36.arrayIndex = -1;
    __asm { vmovdqu xmmword ptr [rbp+90h+var_E0.member], xmm0 }
    state.arrayIndex = -1;
    __asm { vmovdqu xmmword ptr [rsp+190h+state.member], xmm0 }
    SvGameGlobalsMP = SvGameGlobalsMP::GetSvGameGlobalsMP();
    if ( !SvGameGlobalsMP->matchDataDef[0] )
      Scr_Error(COM_ERR_3185, scrContext, "No matchdata def defined");
    if ( entclass )
    {
      Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
      v10 = NULL;
    }
    else
    {
      if ( entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7709, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
        __debugbreak();
      v10 = &g_entities[entnum];
      if ( !v10->client )
      {
        v11 = j_va("entity %i is not a player", entnum);
        Scr_ObjectError(COM_ERR_3680, scrContext, v11);
      }
    }
    if ( SV_BotIsBotEntClient(v10) || SV_ClientMP_IsTestClient(v10->s.number) == 1 )
      v42 = 1;
    else
      DLog_Util_GetPlayerHeaderFieldsFromEntity(v10, &outUnoId, &outFirstPartyUserId, &outFirstPartyAccountType, &outUserSessionId, &outClientPlatform);
    Asset = Com_DDL_LoadAsset(SvGameGlobalsMP->matchDataDef);
    if ( !Asset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7721, ASSERT_TYPE_ASSERT, "(def)", (const char *)&queryFormat, "def") )
      __debugbreak();
    Com_DDL_CreateContext(SvGameGlobalsMP->matchData, 2048, Asset, &ddlContext, NULL, NULL);
    _RAX = DDL_GetRootState(&result, Asset);
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovups ymmword ptr [rsp+190h+fromState.isValid], ymm0
    }
    RawHash = j_SL_GetRawHash(scr_const.commonMatchData);
    if ( !DDL_MoveToNameByHash(&fromState, &toState, RawHash, NULL) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7726, ASSERT_TYPE_ASSERT, "(DDL_MoveToNameByHash( &root, &commonMatchData, SL_GetRawHash( scr_const.commonMatchData ) ))", (const char *)&queryFormat, "DDL_MoveToNameByHash( &root, &commonMatchData, SL_GetRawHash( scr_const.commonMatchData ) )") )
      __debugbreak();
    v16 = j_SL_GetRawHash(scr_const.player_count);
    if ( !DDL_MoveToNameByHash(&toState, &state, v16, NULL) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7727, ASSERT_TYPE_ASSERT, "(DDL_MoveToNameByHash( &commonMatchData, &temp, SL_GetRawHash( scr_const.player_count ) ))", (const char *)&queryFormat, "DDL_MoveToNameByHash( &commonMatchData, &temp, SL_GetRawHash( scr_const.player_count ) )") )
      __debugbreak();
    Int = DDL_GetInt(&state, &ddlContext);
    v18 = j_SL_GetRawHash(scr_const.players);
    if ( !DDL_MoveToNameByHash(&fromState, &v38, v18, NULL) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7730, ASSERT_TYPE_ASSERT, "(DDL_MoveToNameByHash( &root, &players, SL_GetRawHash( scr_const.players ) ))", (const char *)&queryFormat, "DDL_MoveToNameByHash( &root, &players, SL_GetRawHash( scr_const.players ) )") )
      __debugbreak();
    if ( Int > 0 )
    {
      while ( DDL_MoveToIndex(&v38, &v35, v8) )
      {
        if ( v42 )
        {
          v19 = j_SL_GetRawHash(scr_const.gamertag);
          if ( !DDL_MoveToNameByHash(&v35, &state, v19, NULL) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7739, ASSERT_TYPE_ASSERT, "(DDL_MoveToNameByHash( &player, &temp, SL_GetRawHash( scr_const.gamertag ) ))", (const char *)&queryFormat, "DDL_MoveToNameByHash( &player, &temp, SL_GetRawHash( scr_const.gamertag ) )") )
            __debugbreak();
          String = DDL_GetString(&state, &ddlContext);
          v21 = I_strncmp(String, v10->client->sess.cs.name, 0x7FFFFFFFui64) == 0;
        }
        else
        {
          v22 = j_SL_GetRawHash(scr_const.player);
          if ( !DDL_MoveToNameByHash(&v35, &v36, v22, NULL) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7751, ASSERT_TYPE_ASSERT, "(DDL_MoveToNameByHash( &player, &playerHeader, SL_GetRawHash( scr_const.player ) ))", (const char *)&queryFormat, "DDL_MoveToNameByHash( &player, &playerHeader, SL_GetRawHash( scr_const.player ) )") )
            __debugbreak();
          v23 = j_SL_GetRawHash(scr_const.uno_id);
          if ( !DDL_MoveToNameByHash(&v36, &state, v23, NULL) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7752, ASSERT_TYPE_ASSERT, "(DDL_MoveToNameByHash( &playerHeader, &temp, SL_GetRawHash( scr_const.uno_id ) ))", (const char *)&queryFormat, "DDL_MoveToNameByHash( &playerHeader, &temp, SL_GetRawHash( scr_const.uno_id ) )") )
            __debugbreak();
          UInt64 = DDL_GetUInt64(&state, &ddlContext);
          if ( UInt64 )
          {
            v21 = outUnoId == UInt64;
          }
          else
          {
            v25 = j_SL_GetRawHash(scr_const.first_party_user_id);
            if ( !DDL_MoveToNameByHash(&v36, &state, v25, NULL) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7767, ASSERT_TYPE_ASSERT, "(DDL_MoveToNameByHash( &playerHeader, &temp, SL_GetRawHash( scr_const.first_party_user_id ) ))", (const char *)&queryFormat, "DDL_MoveToNameByHash( &playerHeader, &temp, SL_GetRawHash( scr_const.first_party_user_id ) )") )
              __debugbreak();
            v26 = DDL_GetUInt64(&state, &ddlContext);
            v21 = v26 == outFirstPartyUserId;
          }
        }
        if ( v21 )
        {
          v6 = v8;
          goto LABEL_51;
        }
        if ( (int)++v8 >= Int )
          goto LABEL_51;
      }
      Com_PrintWarning(16, "Warning - GScr_MatchDataPlayerExistingSlot - warning, unable to access player slot %d in matchdata\n", v8);
      InstancePtr = Online_ErrorReporting::GetInstancePtr();
      v28 = j_va("GScr_MatchDataPlayerExistingSlot playerIndex %d", v8);
      Online_ErrorReporting::ReportError(InstancePtr, (Online_Error_CAT_DEFAULT_t)0x10000, v28);
    }
  }
LABEL_51:
  Scr_AddInt(scrContext, v6);
}

/*
==============
GScr_GetPlayerIP
==============
*/
void GScr_GetPlayerIP(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  EntityClass entclass; 
  unsigned int v5; 
  gentity_s *v6; 
  const char *v7; 
  bool v8; 
  __int64 v9; 
  int *v10; 
  int v11; 
  unsigned int newOffset[3]; 
  bdAddr v13; 
  XNADDR outAddr; 

  entnum = entref.entnum;
  entclass = entref.entclass;
  if ( Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_6192, scrContext, "GScr_GetPlayerIP takes no parameters");
  v5 = 0;
  if ( entclass )
  {
    Scr_ObjectError(COM_ERR_3681, scrContext, "not an entity");
    v6 = NULL;
  }
  else
  {
    if ( entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7817, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v6 = &g_entities[entnum];
    if ( !v6->client )
    {
      v7 = j_va("entity %i is not a player", entnum);
      Scr_ObjectError(COM_ERR_3680, scrContext, v7);
    }
  }
  if ( SV_ClientMP_GetXNAddr(v6->s.number, &outAddr) )
  {
    bdAddr::bdAddr(&v13);
    v8 = 1;
    newOffset[0] = 0;
    v9 = 5i64;
    do
    {
      v8 = v8 && bdAddr::deserialize(&v13, &outAddr, 0x54u, newOffset[0], newOffset);
      --v9;
    }
    while ( v9 );
    if ( v8 )
      bdAddr::deserialize(&v13, &outAddr, 0x54u, newOffset[0], newOffset);
    LOBYTE(v11) = bdSockAddr::getIn4AddrByte(&v13.m_address, 0);
    BYTE1(v11) = bdSockAddr::getIn4AddrByte(&v13.m_address, 1);
    BYTE2(v11) = bdSockAddr::getIn4AddrByte(&v13.m_address, 2);
    HIBYTE(v11) = bdSockAddr::getIn4AddrByte(&v13.m_address, 3);
  }
  else
  {
    v11 = 0;
  }
  Scr_MakeArray(scrContext);
  v10 = &v11;
  do
  {
    Scr_AddInt(scrContext, *(unsigned __int8 *)v10);
    Scr_AddArray(scrContext);
    ++v5;
    v10 = (int *)((char *)v10 + 1);
  }
  while ( v5 < 4 );
}

/*
==============
GScr_GetUnusedLootCachePoints
==============
*/
void GScr_GetUnusedLootCachePoints(scrContext_t *scrContext)
{
  vec3_t *p_vectorValue; 
  bool bDistance2D; 
  int NumParam; 
  float v13; 
  vec3_t vectorValue; 

  __asm
  {
    vmovaps [rsp+88h+var_18], xmm6
    vmovaps [rsp+88h+var_28], xmm7
    vmovss  xmm7, cs:__real@7f7fffff
  }
  p_vectorValue = NULL;
  __asm { vxorps  xmm6, xmm6, xmm6 }
  bDistance2D = 0;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam >= 2 )
  {
    Scr_GetVector(scrContext, 0, &vectorValue);
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
    p_vectorValue = &vectorValue;
    __asm { vmovaps xmm7, xmm0 }
    if ( NumParam >= 3 )
    {
      *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
      __asm { vmovaps xmm6, xmm0 }
      if ( NumParam >= 4 )
        bDistance2D = Scr_GetInt(scrContext, 3u) != 0;
    }
  }
  __asm
  {
    vmovaps xmm3, xmm7; maxRadius
    vmovss  [rsp+88h+var_68], xmm6
  }
  GScr_GetQuestPoints_Internal(scrContext, 0xFFFDu, p_vectorValue, *(const float *)&_XMM3, v13, bDistance2D, NULL);
  __asm
  {
    vmovaps xmm6, [rsp+88h+var_18]
    vmovaps xmm7, [rsp+88h+var_28]
  }
}

/*
==============
GScr_GetLootSpawnPoint
==============
*/
void GScr_GetLootSpawnPoint(scrContext_t *scrContext)
{
  __int64 Int; 
  SpawnGroupPoint *v3; 
  int v4; 
  unsigned __int16 cluster; 
  int v6; 
  unsigned int CanonicalString; 
  unsigned int v8; 
  unsigned int v9; 
  unsigned int v10; 
  unsigned int v11; 
  const char *v12; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    Int = Scr_GetInt(scrContext, 0);
    if ( (int)Int < 0 || (int)Int >= cm.mapEnts->spawnGroupLoot.pointCount )
    {
      v12 = j_va("Requested point index %d is invalid, valid range is [0, %d)", (unsigned int)Int, cm.mapEnts->spawnGroupLoot.pointCount);
      Scr_Error(COM_ERR_6543, scrContext, v12);
    }
    else
    {
      v3 = &cm.mapEnts->spawnGroupLoot.points[Int];
      v4 = 0;
      cluster = v3->cluster;
      if ( cluster == 0xFFFD )
      {
        v6 = 1;
      }
      else
      {
        v6 = 0;
        if ( cluster == 0xFFFB )
          v6 = 2;
      }
      Scr_MakeStruct(scrContext);
      Scr_AddInt(scrContext, Int);
      CanonicalString = SL_GetCanonicalString("index");
      Scr_AddStructField(scrContext, CanonicalString);
      Scr_AddVector(scrContext, v3->origin.v);
      v8 = SL_GetCanonicalString("origin");
      Scr_AddStructField(scrContext, v8);
      Scr_AddVector(scrContext, v3->angles.v);
      v9 = SL_GetCanonicalString("angles");
      Scr_AddStructField(scrContext, v9);
      Scr_AddInt(scrContext, v6);
      v10 = SL_GetCanonicalString("type");
      Scr_AddStructField(scrContext, v10);
      LOBYTE(v4) = ScriptableSv_IsLootPointInUse(Int);
      Scr_AddInt(scrContext, v4);
      v11 = SL_GetCanonicalString("game_extrainfo");
      Scr_AddStructField(scrContext, v11);
    }
  }
  else
  {
    Scr_Error(COM_ERR_6542, scrContext, "Usage: GetLootSpawnPoint( <pointIndex> )");
  }
}

/*
==============
GScr_GetQuestPoints
==============
*/
void GScr_GetQuestPoints(scrContext_t *scrContext)
{
  vec3_t *p_vectorValue; 
  bool bDistance2D; 
  int NumParam; 
  float v13; 
  int type; 
  vec3_t vectorValue; 

  __asm
  {
    vmovaps [rsp+88h+var_18], xmm6
    vmovaps [rsp+88h+var_28], xmm7
    vmovss  xmm7, cs:__real@7f7fffff
  }
  p_vectorValue = NULL;
  __asm { vxorps  xmm6, xmm6, xmm6 }
  bDistance2D = 0;
  NumParam = Scr_GetNumParam(scrContext);
  if ( NumParam >= 1 )
  {
    if ( NumParam == 2 )
    {
      Scr_Error(COM_ERR_6541, scrContext, "GetQuestPoints(): Must specify at least a maximum radius when providing an origin.\n");
    }
    else
    {
      type = Scr_GetInt(scrContext, 0);
      if ( NumParam >= 3 )
      {
        Scr_GetVector(scrContext, 1u, &vectorValue);
        *(double *)&_XMM0 = Scr_GetFloat(scrContext, 2u);
        p_vectorValue = &vectorValue;
        __asm { vmovaps xmm7, xmm0 }
        if ( NumParam >= 4 )
        {
          *(double *)&_XMM0 = Scr_GetFloat(scrContext, 3u);
          __asm { vmovaps xmm6, xmm0 }
          if ( NumParam >= 5 )
            bDistance2D = Scr_GetInt(scrContext, 4u) != 0;
        }
      }
      __asm
      {
        vmovaps xmm3, xmm7; maxRadius
        vmovss  [rsp+88h+var_68], xmm6
      }
      GScr_GetQuestPoints_Internal(scrContext, 0xFFFBu, p_vectorValue, *(const float *)&_XMM3, v13, bDistance2D, &type);
    }
  }
  else
  {
    Scr_Error(COM_ERR_6540, scrContext, "GetQuestPoints(): Must specify a point type.\n");
  }
  __asm
  {
    vmovaps xmm6, [rsp+88h+var_18]
    vmovaps xmm7, [rsp+88h+var_28]
  }
}

/*
==============
GScr_DisableLootSpawnPoint
==============
*/
void GScr_DisableLootSpawnPoint(scrContext_t *scrContext)
{
  __int64 Int; 
  SpawnGroupPoint *v3; 
  unsigned __int16 cluster; 
  const char *v5; 
  const char *v6; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    Int = Scr_GetInt(scrContext, 0);
    if ( (int)Int < 0 || (int)Int >= cm.mapEnts->spawnGroupLoot.pointCount )
    {
      v6 = j_va("DisableLootSpawnPoint - Requested point index %d is invalid, valid range is [0, %d)", Int, cm.mapEnts->spawnGroupLoot.pointCount);
      Scr_Error(COM_ERR_6545, scrContext, v6);
    }
    else
    {
      v3 = &cm.mapEnts->spawnGroupLoot.points[Int];
      cluster = v3->cluster;
      if ( ((cluster + 4) & 0xFFFD) != 0 )
      {
        if ( cluster == 0xFFFD )
        {
          v3->cluster = -4;
          ScriptableSv_DisableQuestPointIndex(Int);
        }
        else if ( cluster == 0xFFFB )
        {
          v3->cluster = -2;
          ScriptableSv_DisableQuestPointIndex(Int);
        }
        else
        {
          v5 = j_va("DisableLootSpawnPoint - Requested point index %d is not a cache or quest point", Int);
          Scr_Error(COM_ERR_6546, scrContext, v5);
        }
      }
    }
  }
  else
  {
    Scr_Error(COM_ERR_6544, scrContext, "Usage: DisableLootSpawnPoint( <pointIndex> )");
  }
}

/*
==============
GScr_GetLootSpawnPointCount
==============
*/
void GScr_GetLootSpawnPointCount(scrContext_t *scrContext)
{
  Scr_AddInt(scrContext, cm.mapEnts->spawnGroupLoot.pointCount);
}

/*
==============
GScr_GetLootSpawnScriptableIndexFirst
==============
*/
void GScr_GetLootSpawnScriptableIndexFirst(scrContext_t *scrContext)
{
  ScriptableCommon_AssertCountsInitialized();
  Scr_AddInt(scrContext, g_scriptableWorldCounts.runtimeInstanceCount);
}

/*
==============
GScr_GetDateTime
==============
*/
void GScr_GetDateTime(scrContext_t *scrContext)
{
  qtime_s qtime; 

  Com_RealTime(0, &qtime);
  Scr_MakeArray(scrContext);
  Scr_AddInt(scrContext, qtime.tm_year - 100);
  Scr_AddArray(scrContext);
  Scr_AddInt(scrContext, qtime.tm_mon + 1);
  Scr_AddArray(scrContext);
  Scr_AddInt(scrContext, qtime.tm_mday);
  Scr_AddArray(scrContext);
  Scr_AddInt(scrContext, qtime.tm_hour);
  Scr_AddArray(scrContext);
  Scr_AddInt(scrContext, qtime.tm_min);
  Scr_AddArray(scrContext);
  Scr_AddInt(scrContext, qtime.tm_sec);
  Scr_AddArray(scrContext);
}

/*
==============
GScr_AnalyticsReset
==============
*/
void GScr_AnalyticsReset(scrContext_t *scrContext)
{
  ;
}

/*
==============
GScr_AnalyticsAddEvent
==============
*/
void GScr_AnalyticsAddEvent(scrContext_t *scrContext)
{
  ;
}

/*
==============
GScr_AnalyticsWriteCSV
==============
*/
void GScr_AnalyticsWriteCSV(scrContext_t *scrContext)
{
  ;
}

/*
==============
GScr_RequestGameLobbyRemainIntact
==============
*/
void GScr_RequestGameLobbyRemainIntact(scrContext_t *scrContext)
{
  OnlineMatchmakerOmniscient::RequestGameLobbyRemainIntact(&OnlineMatchmakerOmniscient::ms_instance);
}

/*
==============
GScr_BRMatchStarted
==============
*/
void GScr_BRMatchStarted(scrContext_t *scrContext)
{
  ;
}

/*
==============
GScr_VerifyBunkerCode
==============
*/
void GScr_VerifyBunkerCode(scrContext_t *scrContext)
{
  unsigned __int64 Int; 
  int v3; 
  int v5; 
  __int128 v6; 
  int v7; 
  int v8; 

  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_Error(COM_ERR_6549, scrContext, "VerifyBunkerCode() USAGE: VerifyBunkerCode( <bunkerIndex>, <bunkerCode> )\n");
  Int = Scr_GetInt(scrContext, 0);
  v3 = Scr_GetInt(scrContext, 1u);
  __asm { vmovdqu xmm0, cs:__xmm@05cc220a04591b3305390c9302f0082b }
  v5 = 0;
  v7 = 27495810;
  v8 = 60274513;
  __asm { vmovdqu [rsp+48h+var_28], xmm0 }
  if ( Int < 6 )
    LOBYTE(v5) = *((_DWORD *)&v6 + Int) == v3;
  Scr_AddBool(scrContext, v5);
}

/*
==============
GScr_GetAltBunkerIndexForName
==============
*/
void GScr_GetAltBunkerIndexForName(scrContext_t *scrContext)
{
  int v2; 
  const char *String; 
  const char *v4; 
  __int64 v5; 
  __int64 v6; 
  int v7; 
  __int64 v8; 
  int v9; 
  int v10; 
  int v11; 
  const char *v12; 
  __int64 v13; 
  int v14; 
  __int64 v15; 
  int v16; 
  int v17; 
  int v18; 
  const char *v19; 
  __int64 v20; 
  int v21; 
  __int64 v22; 
  int v23; 
  int v24; 
  int v25; 
  const char *v26; 
  __int64 v27; 
  int v28; 
  __int64 v29; 
  int v30; 
  int v31; 
  int v32; 
  const char *v33; 
  __int64 v34; 
  int v35; 
  __int64 v36; 
  int v37; 
  int v38; 
  int v39; 
  const char *v40; 
  __int64 v41; 
  int v42; 
  __int64 v43; 
  int v44; 
  int v45; 
  int v46; 
  const char *v47; 
  signed __int64 v48; 
  int v49; 
  __int64 v50; 
  int v51; 
  int v52; 
  int v53; 

  v2 = -1;
  String = Scr_GetString(scrContext, 0);
  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_6550, scrContext, "GetAltBunkerIndexForName() USAGE: GetAltBunkerIndexForName( <bunkerScriptableInstanceName> )\n");
  v4 = "br_bunker_alt_barn";
  v5 = 0x7FFFFFFFi64;
  v6 = 0x7FFFFFFFi64;
  if ( !String && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
    __debugbreak();
  while ( 1 )
  {
    v7 = (unsigned __int8)v4[String - "br_bunker_alt_barn"];
    v8 = v6;
    v9 = *(unsigned __int8 *)v4++;
    --v6;
    if ( !v8 )
    {
LABEL_14:
      v2 = 0;
      goto LABEL_15;
    }
    if ( v7 != v9 )
    {
      v10 = v7 + 32;
      if ( (unsigned int)(v7 - 65) > 0x19 )
        v10 = v7;
      v7 = v10;
      v11 = v9 + 32;
      if ( (unsigned int)(v9 - 65) > 0x19 )
        v11 = v9;
      if ( v7 != v11 )
        break;
    }
    if ( !v7 )
      goto LABEL_14;
  }
  v12 = "bunker_door_3";
  v13 = 0x7FFFFFFFi64;
  if ( !String && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
    __debugbreak();
  while ( 1 )
  {
    v14 = (unsigned __int8)v12[String - "bunker_door_3"];
    v15 = v13;
    v16 = *(unsigned __int8 *)v12++;
    --v13;
    if ( !v15 )
    {
LABEL_27:
      v2 = 1;
      goto LABEL_15;
    }
    if ( v14 != v16 )
    {
      v17 = v14 + 32;
      if ( (unsigned int)(v14 - 65) > 0x19 )
        v17 = v14;
      v14 = v17;
      v18 = v16 + 32;
      if ( (unsigned int)(v16 - 65) > 0x19 )
        v18 = v16;
      if ( v14 != v18 )
        break;
    }
    if ( !v14 )
      goto LABEL_27;
  }
  v19 = "br_bunker_alt_outhouse";
  v20 = 0x7FFFFFFFi64;
  if ( !String && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
    __debugbreak();
  while ( 1 )
  {
    v21 = (unsigned __int8)v19[String - "br_bunker_alt_outhouse"];
    v22 = v20;
    v23 = *(unsigned __int8 *)v19++;
    --v20;
    if ( !v22 )
    {
LABEL_39:
      v2 = 2;
      goto LABEL_15;
    }
    if ( v21 != v23 )
    {
      v24 = v21 + 32;
      if ( (unsigned int)(v21 - 65) > 0x19 )
        v24 = v21;
      v21 = v24;
      v25 = v23 + 32;
      if ( (unsigned int)(v23 - 65) > 0x19 )
        v25 = v23;
      if ( v21 != v25 )
        break;
    }
    if ( !v21 )
      goto LABEL_39;
  }
  v26 = "bunker_door_1";
  v27 = 0x7FFFFFFFi64;
  if ( !String && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
    __debugbreak();
  while ( 1 )
  {
    v28 = (unsigned __int8)v26[String - "bunker_door_1"];
    v29 = v27;
    v30 = *(unsigned __int8 *)v26++;
    --v27;
    if ( !v29 )
    {
LABEL_51:
      v2 = 3;
      goto LABEL_15;
    }
    if ( v28 != v30 )
    {
      v31 = v28 + 32;
      if ( (unsigned int)(v28 - 65) > 0x19 )
        v31 = v28;
      v28 = v31;
      v32 = v30 + 32;
      if ( (unsigned int)(v30 - 65) > 0x19 )
        v32 = v30;
      if ( v28 != v32 )
        break;
    }
    if ( !v28 )
      goto LABEL_51;
  }
  v33 = "br_bunker_alt_shed_01";
  v34 = 0x7FFFFFFFi64;
  if ( !String && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
    __debugbreak();
  do
  {
    v35 = (unsigned __int8)v33[String - "br_bunker_alt_shed_01"];
    v36 = v34;
    v37 = *(unsigned __int8 *)v33++;
    --v34;
    if ( !v36 )
      break;
    if ( v35 != v37 )
    {
      v38 = v35 + 32;
      if ( (unsigned int)(v35 - 65) > 0x19 )
        v38 = v35;
      v35 = v38;
      v39 = v37 + 32;
      if ( (unsigned int)(v37 - 65) > 0x19 )
        v39 = v37;
      if ( v35 != v39 )
      {
        v40 = "br_bunker_alt_shed_02";
        v41 = 0x7FFFFFFFi64;
        if ( !String && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
          __debugbreak();
        while ( 1 )
        {
          v42 = (unsigned __int8)v40[String - "br_bunker_alt_shed_02"];
          v43 = v41;
          v44 = *(unsigned __int8 *)v40++;
          --v41;
          if ( !v43 )
            goto LABEL_63;
          if ( v42 != v44 )
          {
            v45 = v42 + 32;
            if ( (unsigned int)(v42 - 65) > 0x19 )
              v45 = v42;
            v42 = v45;
            v46 = v44 + 32;
            if ( (unsigned int)(v44 - 65) > 0x19 )
              v46 = v44;
            if ( v42 != v46 )
            {
              v47 = "bunker_door_10";
              if ( !String && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
                __debugbreak();
              v48 = String - "bunker_door_10";
              do
              {
                v49 = (unsigned __int8)v47[v48];
                v50 = v5;
                v51 = *(unsigned __int8 *)v47++;
                --v5;
                if ( !v50 )
                  break;
                if ( v49 != v51 )
                {
                  v52 = v49 + 32;
                  if ( (unsigned int)(v49 - 65) > 0x19 )
                    v52 = v49;
                  v49 = v52;
                  v53 = v51 + 32;
                  if ( (unsigned int)(v51 - 65) > 0x19 )
                    v53 = v51;
                  if ( v49 != v53 )
                    goto LABEL_15;
                }
              }
              while ( v49 );
              v2 = 5;
              goto LABEL_15;
            }
          }
          if ( !v42 )
          {
            v2 = 4;
            goto LABEL_15;
          }
        }
      }
    }
  }
  while ( v35 );
LABEL_63:
  v2 = 4;
LABEL_15:
  Scr_AddInt(scrContext, v2);
}

/*
==============
GScr_MatchDataFillPlayerHeader
==============
*/
void GScr_MatchDataFillPlayerHeader(scrContext_t *scrContext, scr_entref_t entref)
{
  unsigned int entnum; 
  unsigned __int8 ActiveGameMode; 
  gentity_s *v6; 
  SvGameGlobalsMP *SvGameGlobalsMP; 
  unsigned int Int; 
  const char *v10; 
  ComErrorCode v11; 
  const DDLDef *Asset; 
  unsigned int RawHash; 
  unsigned int v17; 
  unsigned int v18; 
  unsigned int v19; 
  unsigned int v20; 
  unsigned int v21; 
  unsigned int v22; 
  Online_ErrorReporting *InstancePtr; 
  const char *v24; 
  DDLState state; 
  DDLState v26; 
  unsigned __int64 outUnoId; 
  unsigned __int64 outUserSessionId; 
  unsigned __int64 outFirstPartyUserId; 
  DDLState result; 
  DDLState fromState; 
  DDLState toState; 
  DDLContext ddlContext; 
  EntityClass entclass; 
  ClientPlatform outClientPlatform; 
  DLogFirstPartyAccountType outFirstPartyAccountType; 

  entclass = entref.entclass;
  entnum = entref.entnum;
  ActiveGameMode = Com_GameMode_GetActiveGameMode();
  if ( !BG_GameInterface_GameModeIsMP((GameModeType)ActiveGameMode) )
    return;
  v6 = NULL;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  fromState.isValid = 0;
  fromState.offset = 0;
  fromState.arrayIndex = -1;
  __asm { vmovdqu xmmword ptr [rbp+50h+fromState.member], xmm0 }
  toState.isValid = 0;
  toState.offset = 0;
  toState.arrayIndex = -1;
  __asm { vmovdqu xmmword ptr [rbp+50h+toState.member], xmm0 }
  SvGameGlobalsMP = SvGameGlobalsMP::GetSvGameGlobalsMP();
  if ( !SvGameGlobalsMP->matchDataDef[0] )
    Scr_Error(COM_ERR_5871, scrContext, "No matchdata def defined");
  if ( !Scr_GetNumParam(scrContext) )
    Scr_Error(COM_ERR_5680, scrContext, "Missing information for GScr_MatchDataFillPlayerHeader.");
  Int = Scr_GetInt(scrContext, 0);
  if ( entclass )
  {
    v10 = "not an entity";
    v11 = COM_ERR_3681;
  }
  else
  {
    if ( entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7916, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v6 = &g_entities[entnum];
    if ( v6->client )
      goto LABEL_14;
    v10 = j_va("entity %i is not a player", entnum);
    v11 = COM_ERR_3680;
  }
  Scr_ObjectError(v11, scrContext, v10);
LABEL_14:
  DLog_Util_GetPlayerHeaderFieldsFromEntity(v6, &outUnoId, &outFirstPartyUserId, &outFirstPartyAccountType, &outUserSessionId, &outClientPlatform);
  Asset = Com_DDL_LoadAsset(SvGameGlobalsMP->matchDataDef);
  if ( !Asset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7921, ASSERT_TYPE_ASSERT, "(def)", (const char *)&queryFormat, "def") )
    __debugbreak();
  Com_DDL_CreateContext(SvGameGlobalsMP->matchData, 2048, Asset, &ddlContext, NULL, NULL);
  _RAX = DDL_GetRootState(&result, Asset);
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovups ymmword ptr [rbp+50h+fromState.isValid], ymm0
  }
  RawHash = j_SL_GetRawHash(scr_const.players);
  if ( DDL_MoveToNameByHash(&fromState, &toState, RawHash, NULL) )
  {
    __asm { vpxor   xmm0, xmm0, xmm0 }
    result.isValid = 0;
    result.offset = 0;
    result.arrayIndex = -1;
    __asm
    {
      vmovdqu xmmword ptr [rbp+50h+result.member], xmm0
      vmovdqu xmmword ptr [rsp+150h+var_100.member], xmm0
      vmovdqu xmmword ptr [rsp+150h+state.member], xmm0
    }
    v26.isValid = 0;
    v26.offset = 0;
    v26.arrayIndex = -1;
    state.isValid = 0;
    state.offset = 0;
    state.arrayIndex = -1;
    if ( DDL_MoveToIndex(&toState, &result, Int) )
    {
      v17 = j_SL_GetRawHash(scr_const.player);
      if ( !DDL_MoveToNameByHash(&result, &v26, v17, NULL) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7933, ASSERT_TYPE_ASSERT, "(DDL_MoveToNameByHash( &player, &playerHeader, SL_GetRawHash( scr_const.player ) ))", (const char *)&queryFormat, "DDL_MoveToNameByHash( &player, &playerHeader, SL_GetRawHash( scr_const.player ) )", *(_QWORD *)&state.isValid, *(_QWORD *)&state.arrayIndex, state.member, state.ddlDef, *(_QWORD *)&v26.isValid, *(_QWORD *)&v26.arrayIndex, v26.member, v26.ddlDef) )
        __debugbreak();
      v18 = j_SL_GetRawHash(scr_const.uno_id);
      if ( !DDL_MoveToNameByHash(&v26, &state, v18, NULL) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7934, ASSERT_TYPE_ASSERT, "(DDL_MoveToNameByHash( &playerHeader, &temp, SL_GetRawHash( scr_const.uno_id ) ))", (const char *)&queryFormat, "DDL_MoveToNameByHash( &playerHeader, &temp, SL_GetRawHash( scr_const.uno_id ) )") )
        __debugbreak();
      DDL_SetUInt64(&state, &ddlContext, outUnoId);
      v19 = j_SL_GetRawHash(scr_const.user_session_id);
      if ( !DDL_MoveToNameByHash(&v26, &state, v19, NULL) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7937, ASSERT_TYPE_ASSERT, "(DDL_MoveToNameByHash( &playerHeader, &temp, SL_GetRawHash( scr_const.user_session_id ) ))", (const char *)&queryFormat, "DDL_MoveToNameByHash( &playerHeader, &temp, SL_GetRawHash( scr_const.user_session_id ) )") )
        __debugbreak();
      DDL_SetUInt64(&state, &ddlContext, outUserSessionId);
      v20 = j_SL_GetRawHash(scr_const.first_party_user_id);
      if ( !DDL_MoveToNameByHash(&v26, &state, v20, NULL) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7940, ASSERT_TYPE_ASSERT, "(DDL_MoveToNameByHash( &playerHeader, &temp, SL_GetRawHash( scr_const.first_party_user_id ) ))", (const char *)&queryFormat, "DDL_MoveToNameByHash( &playerHeader, &temp, SL_GetRawHash( scr_const.first_party_user_id ) )") )
        __debugbreak();
      DDL_SetUInt64(&state, &ddlContext, outFirstPartyUserId);
      v21 = j_SL_GetRawHash(scr_const.first_party_account_type);
      if ( !DDL_MoveToNameByHash(&v26, &state, v21, NULL) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7943, ASSERT_TYPE_ASSERT, "(DDL_MoveToNameByHash( &playerHeader, &temp, SL_GetRawHash( scr_const.first_party_account_type ) ))", (const char *)&queryFormat, "DDL_MoveToNameByHash( &playerHeader, &temp, SL_GetRawHash( scr_const.first_party_account_type ) )") )
        __debugbreak();
      DDL_SetUInt(&state, &ddlContext, outFirstPartyAccountType);
      v22 = j_SL_GetRawHash(scr_const.platform);
      if ( !DDL_MoveToNameByHash(&v26, &state, v22, NULL) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7946, ASSERT_TYPE_ASSERT, "(DDL_MoveToNameByHash( &playerHeader, &temp, SL_GetRawHash( scr_const.platform ) ))", (const char *)&queryFormat, "DDL_MoveToNameByHash( &playerHeader, &temp, SL_GetRawHash( scr_const.platform ) )") )
        __debugbreak();
      DDL_SetUInt(&state, &ddlContext, (char)outClientPlatform);
    }
    else
    {
      Com_PrintWarning(16, "Warning - GScr_MatchDataFillPlayerHeader - unable to move to slot %d in player array", Int);
      InstancePtr = Online_ErrorReporting::GetInstancePtr();
      v24 = j_va("GScr_MatchDataFillPlayerHeader playerIndex %d", Int);
      Online_ErrorReporting::ReportError(InstancePtr, (Online_Error_CAT_DEFAULT_t)0x10000, v24);
    }
  }
  else
  {
    Scr_Error(COM_ERR_5684, scrContext, "GScr_MatchDataFillPlayerHeader - unable to move to players array in matchdata");
  }
}

/*
==============
GScr_IsInTournament
==============
*/
void GScr_IsInTournament(scrContext_t *scrContext)
{
  bool v2; 

  v2 = SV_OnlineTournament_IsInTournament();
  Scr_AddBool(scrContext, v2);
}

/*
==============
GScr_UpdateTournamentRoundTime
==============
*/
void GScr_UpdateTournamentRoundTime(scrContext_t *scrContext)
{
  int Int; 
  MatchTimeMode v5; 

  if ( SV_OnlineTournament_IsInTournament() )
  {
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 0);
    __asm { vcvttss2si edi, xmm0 }
    Int = Scr_GetInt(scrContext, 1u);
    v5 = (char)Int;
    if ( (Int < 0 || (unsigned int)Int > 0xFF) && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "enum MatchTimeMode __cdecl truncate_cast_impl<enum MatchTimeMode,int>(int)", "unsigned", (unsigned __int8)Int, "signed", Int) )
      __debugbreak();
    SV_OnlineTournament_RoundTimeUpdated(_EDI, v5);
  }
}

/*
==============
GScr_DoTournamentEndGame
==============
*/
void GScr_DoTournamentEndGame(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const char *v3; 

  if ( SV_OnlineTournament_IsInTournament() )
  {
    ConstString = Scr_GetConstString(scrContext, 0);
    if ( ConstString == scr_const.allies )
    {
      SV_OnlineTournament_MatchComplete(TEAM_1);
    }
    else
    {
      if ( ConstString != scr_const.axis )
      {
        v3 = SL_ConvertToString(ConstString);
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 8032, ASSERT_TYPE_ASSERT, "(winner == scr_const.axis)", "%s\n\tUnexpected winner %s", "winner == scr_const.axis", v3) )
          __debugbreak();
      }
      SV_OnlineTournament_MatchComplete(TEAM_0);
    }
  }
}

/*
==============
GScr_LogTournamentDeath
==============
*/
void GScr_LogTournamentDeath(scrContext_t *scrContext)
{
  const char *String; 
  const char *v3; 
  int Int; 
  bool outIsAlternate; 
  Weapon outWeapon; 

  if ( SV_OnlineTournament_IsInTournament() )
  {
    String = Scr_GetString(scrContext, 0);
    v3 = Scr_GetString(scrContext, 1u);
    GScr_Main_GetWeaponParam(scrContext, 2u, &outWeapon, &outIsAlternate);
    Int = Scr_GetInt(scrContext, 3u);
    SV_OnlineTournament_KillUpdate(String, v3, outWeapon.weaponIdx, Int != 0);
  }
}

/*
==============
GScr_SetMatchData
==============
*/
void GScr_SetMatchData(scrContext_t *scrContext)
{
  SvGameGlobalsMP *SvGameGlobalsMP; 
  const dvar_t *v4; 
  const DDLDef *Asset; 
  DDLState state; 
  DDLContext ddlContext; 

  SvGameGlobalsMP = SvGameGlobalsMP::GetSvGameGlobalsMP();
  if ( SvGameGlobalsMP->matchDataDef[0] )
  {
LABEL_7:
    Asset = Com_DDL_LoadAsset(SvGameGlobalsMP->matchDataDef);
    if ( Com_DDL_CreateContext(SvGameGlobalsMP->matchData, 2048, Asset, &ddlContext, NULL, NULL) )
    {
      __asm
      {
        vpxor   xmm0, xmm0, xmm0
        vmovdqu xmmword ptr [rsp+98h+state.member], xmm0
      }
      state.isValid = 0;
      state.offset = 0;
      state.arrayIndex = -1;
      if ( SvPersistentGlobalsMP::IsFrontEndServer() )
        Scr_Error(COM_ERR_3121, scrContext, "SetDDL: Can't use this function on the front end server");
      LiveStorage_InitializeDDLStateForStatsGroup(Asset, &state, STATSGROUP_IGNORE);
      GScr_Main_SetDDL(scrContext, &state, Asset, &ddlContext, "SetMatchData", 0);
    }
    else
    {
      Scr_Error(COM_ERR_6128, scrContext, "Could not create match data context.  Match data may be too big so we can't load it!");
    }
    return;
  }
  v4 = DVARBOOL_online_matchdata_enabled;
  if ( !DVARBOOL_online_matchdata_enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "online_matchdata_enabled") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v4);
  if ( v4->current.enabled )
  {
    Scr_Error(COM_ERR_3189, scrContext, "No match data def defined");
    goto LABEL_7;
  }
}

/*
==============
GScr_SetMatchDataDef
==============
*/
void GScr_SetMatchDataDef(scrContext_t *scrContext)
{
  SvGameGlobalsMP *SvGameGlobalsMP; 
  const char *String; 
  __int64 v4; 

  if ( Scr_GetNumParam(scrContext) == 1 )
  {
    SvGameGlobalsMP = SvGameGlobalsMP::GetSvGameGlobalsMP();
    String = Scr_GetString(scrContext, 0);
    if ( I_strnicmp(String, SvGameGlobalsMP->matchDataDef, 0x7FFFFFFFui64) )
    {
      if ( SvGameGlobalsMP->matchDataDef[0] )
      {
        Scr_Error(COM_ERR_3191, scrContext, "Already set match data def\n");
      }
      else
      {
        v4 = -1i64;
        do
          ++v4;
        while ( String[v4] );
        if ( (unsigned int)v4 < 0x40 )
        {
          Core_strcpy(SvGameGlobalsMP->matchDataDef, 0x40ui64, String);
          Online_MatchData_Load();
        }
        else
        {
          Scr_ParamError(COM_ERR_3192, scrContext, 0, "def name too long.\n");
        }
      }
    }
    else
    {
      Com_PrintWarning(16, "SetMatchDataDef -- trying to set matchdata defName to the existing value\n");
    }
  }
  else
  {
    Scr_Error(COM_ERR_3190, scrContext, "SetMatchDataDef takes exactly one argument: <def asset name>\n");
  }
}

/*
==============
GScr_SetClientMatchDataDef
==============
*/
void GScr_SetClientMatchDataDef(scrContext_t *scrContext)
{
  SvGameGlobalsMP *SvGameGlobalsMP; 
  const char *String; 
  __int64 v4; 
  const DDLDef *Asset; 
  DDLContext ddlContext; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_3193, scrContext, "SetClientMatchDataDef takes exactly one argument: <def asset name>\n");
  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
    Scr_Error(COM_ERR_3194, scrContext, "Cannot use client match data for front-end server");
  SvGameGlobalsMP = SvGameGlobalsMP::GetSvGameGlobalsMP();
  String = Scr_GetString(scrContext, 0);
  if ( I_strnicmp(String, SvGameGlobalsMP->clientMatchData.def, 0x7FFFFFFFui64) )
  {
    if ( SvGameGlobalsMP->clientMatchData.def[0] )
      Scr_Error(COM_ERR_3195, scrContext, "Already set client match data def\n");
    v4 = -1i64;
    do
      ++v4;
    while ( String[v4] );
    if ( (unsigned int)v4 >= 0x40 )
      Scr_ParamError(COM_ERR_3196, scrContext, 0, "def name too long.\n");
    Core_strcpy(SvGameGlobalsMP->clientMatchData.def, 0x40ui64, String);
    Asset = Com_DDL_LoadAsset(SvGameGlobalsMP->clientMatchData.def);
    if ( !DDL_ResetContext(SvGameGlobalsMP->clientMatchData.data, 24000, Asset, &ddlContext, NULL, NULL) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 8200, ASSERT_TYPE_ASSERT, "(DDL_ResetContext( sv->clientMatchData.data, sizeof( sv->clientMatchData.data ), def, &buffer, 0, 0 ))", (const char *)&queryFormat, "DDL_ResetContext( sv->clientMatchData.data, sizeof( sv->clientMatchData.data ), def, &buffer, NULL, NULL )") )
      __debugbreak();
  }
}

/*
==============
GScr_LogClientMatchDataDeath
==============
*/
void GScr_LogClientMatchDataDeath(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *v3; 
  int Int; 
  SvGameGlobalsMP *SvGameGlobalsMP; 
  gentity_s *Entity; 
  gclient_s *client; 
  const DDLDef *Asset; 
  unsigned int RawHash; 
  int v15; 
  unsigned int v16; 
  unsigned int v17; 
  unsigned int v18; 
  unsigned int v19; 
  const vec3_t *p_currentOrigin; 
  unsigned int v21; 
  unsigned int v22; 
  DDLState toState; 
  int val; 
  DDLState v25; 
  DDLState fromState; 
  DDLState v27; 
  DDLContext ddlContext; 
  DDLState result; 
  vec2_t vec; 

  v3 = NULL;
  fromState.isValid = 0;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  Int = -1;
  fromState.offset = 0;
  fromState.arrayIndex = -1;
  __asm { vmovdqu xmmword ptr [rbp+50h+fromState.member], xmm0 }
  v27.isValid = 0;
  v27.offset = 0;
  v27.arrayIndex = -1;
  __asm { vmovdqu xmmword ptr [rbp+50h+var_B8.member], xmm0 }
  v25.isValid = 0;
  v25.offset = 0;
  v25.arrayIndex = -1;
  __asm { vmovdqu xmmword ptr [rsp+150h+var_F8.member], xmm0 }
  toState.isValid = 0;
  toState.offset = 0;
  toState.arrayIndex = -1;
  __asm { vmovdqu xmmword ptr [rsp+150h+toState.member], xmm0 }
  SvGameGlobalsMP = SvGameGlobalsMP::GetSvGameGlobalsMP();
  if ( !SvGameGlobalsMP->clientMatchData.def[0] )
    Scr_Error(COM_ERR_3198, scrContext, "No client match data def defined");
  Entity = GetEntity(entref);
  client = Entity->client;
  if ( !client )
  {
    Scr_Error(COM_ERR_3199, scrContext, "LogClientMatchDataDeath must be called on a client");
    client = Entity->client;
  }
  if ( !client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 8259, ASSERT_TYPE_ASSERT, "( victim->client )", (const char *)&queryFormat, "victim->client", *(_QWORD *)&toState.isValid, *(_QWORD *)&toState.arrayIndex, toState.member, toState.ddlDef) )
    __debugbreak();
  val = Scr_GetInt(scrContext, 1u);
  if ( Scr_GetType(scrContext, 2u) )
    v3 = GScr_GetEntity(2u);
  if ( Scr_GetType(scrContext, 2u) )
    Int = Scr_GetInt(scrContext, 3u);
  Asset = Com_DDL_LoadAsset(SvGameGlobalsMP->clientMatchData.def);
  if ( !Com_DDL_CreateContext(SvGameGlobalsMP->clientMatchData.data, 24000, Asset, &ddlContext, NULL, NULL) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 8267, ASSERT_TYPE_ASSERT, "(Com_DDL_CreateContext( sv->clientMatchData.data, sizeof( sv->clientMatchData.data ), def, &buffer, 0, 0 ))", (const char *)&queryFormat, "Com_DDL_CreateContext( sv->clientMatchData.data, sizeof( sv->clientMatchData.data ), def, &buffer, NULL, NULL )") )
    __debugbreak();
  _RAX = DDL_GetRootState(&result, Asset);
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovups ymmword ptr [rsp+150h+fromState.isValid], ymm0
  }
  RawHash = j_SL_GetRawHash(scr_const.deathCount);
  if ( !DDL_MoveToNameByHash(&fromState, &toState, RawHash, NULL) )
    Scr_Error(COM_ERR_3200, scrContext, "Invalid client match data definition specified. Must contain a deathCount field.");
  if ( DDL_GetType(&toState) != DDL_SHORT_TYPE )
    Scr_Error(COM_ERR_3201, scrContext, "Invalid client match data definition specified. deathCount must be a short");
  LOWORD(v15) = DDL_GetShort(&toState, &ddlContext);
  if ( (__int16)v15 < 300 )
  {
    DDL_SetShort(&toState, &ddlContext, v15 + 1);
    v16 = j_SL_GetRawHash(scr_const.deaths);
    if ( !DDL_MoveToNameByHash(&fromState, &v27, v16, NULL) )
      Scr_Error(COM_ERR_3202, scrContext, "Invalid client match data definition specified. The deaths field must be an indexed array of life structures");
    v15 = (__int16)v15;
    if ( !DDL_MoveToIndex(&v27, &v25, (__int16)v15) )
      Scr_Error(COM_ERR_3203, scrContext, "Invalid client match data definition specified. The deaths field must be an indexed array of life structures");
    v17 = j_SL_GetRawHash(scr_const.player);
    DDL_MoveToNameByHash(&v25, &toState, v17, NULL);
    DDL_SetInt(&toState, &ddlContext, val);
    NormalizePosition(scrContext, &Entity->r.currentOrigin, &vec);
    v18 = j_SL_GetRawHash(scr_const.deathPos);
    DDL_MoveToNameByHash(&v25, &toState, v18, NULL);
    Com_DDL_SetByteVec2(&toState, &ddlContext, &vec);
    if ( v3 && v3->client )
    {
      v19 = j_SL_GetRawHash(scr_const.attacker);
      DDL_MoveToNameByHash(&v25, &toState, v19, NULL);
      DDL_SetInt(&toState, &ddlContext, Int);
      p_currentOrigin = &v3->r.currentOrigin;
    }
    else
    {
      if ( (unsigned __int8)Com_GameMode_GetActiveGameMode() != LONG )
      {
        v21 = j_SL_GetRawHash(scr_const.attacker);
        DDL_MoveToNameByHash(&v25, &toState, v21, NULL);
        DDL_SetInt(&toState, &ddlContext, 255);
      }
      p_currentOrigin = &Entity->r.currentOrigin;
    }
    NormalizePosition(scrContext, p_currentOrigin, &vec);
    v22 = j_SL_GetRawHash(scr_const.attackerPos);
    DDL_MoveToNameByHash(&v25, &toState, v22, NULL);
    Com_DDL_SetByteVec2(&toState, &ddlContext, &vec);
  }
  else
  {
    v15 = (__int16)v15;
  }
  Scr_AddInt(scrContext, v15);
}

/*
==============
GScr_GetMatchRulesData
==============
*/
void GScr_GetMatchRulesData(scrContext_t *scrContext)
{
  GameStateInfo *v3; 
  const DDLDef *Asset; 
  DDLState state; 
  DDLContext ddlContext; 

  v3 = GameStateInfo_Get();
  if ( !v3->usingRecipe )
    Scr_Error(COM_ERR_3204, scrContext, "GetMatchRulesData called when not using recipe!");
  if ( !v3->matchRules && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 8365, ASSERT_TYPE_ASSERT, "(gInfo->matchRules)", (const char *)&queryFormat, "gInfo->matchRules") )
    __debugbreak();
  Asset = Com_DDL_LoadAsset("ddl/mp/recipes.ddl");
  Com_DDL_CreateContext(v3->matchRules, 4096, Asset, &ddlContext, NULL, NULL);
  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovdqu xmmword ptr [rsp+88h+state.member], xmm0
  }
  state.isValid = 0;
  state.offset = 0;
  state.arrayIndex = -1;
  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
    Scr_Error(COM_ERR_3120, scrContext, "GetDDL: Can't use this function on the front end server");
  LiveStorage_InitializeDDLStateForStatsGroup(Asset, &state, STATSGROUP_IGNORE);
  GScr_Main_GetDDL(scrContext, &state, Asset, &ddlContext, "GetMatchRulesData", 0);
}

/*
==============
GScr_IsUsingMatchRulesData
==============
*/
void GScr_IsUsingMatchRulesData(scrContext_t *scrContext)
{
  GameStateInfo *v2; 

  v2 = GameStateInfo_Get();
  Scr_AddBool(scrContext, v2->usingRecipe);
}

/*
==============
GScr_AttachmentIsRestricted
==============
*/
void GScr_AttachmentIsRestricted(scrContext_t *scrContext)
{
  const char *String; 
  const char *v3; 
  int IsWeaponAttachmentRestricted; 
  char dest[256]; 

  String = Scr_GetString(scrContext, 0);
  v3 = Scr_GetString(scrContext, 1u);
  if ( MatchRules_IsAttachmentRestricted(String) )
  {
    IsWeaponAttachmentRestricted = 1;
  }
  else
  {
    Com_sprintf<256>((char (*)[256])dest, "%s_%s", v3, String);
    IsWeaponAttachmentRestricted = MatchRules_IsWeaponAttachmentRestricted(dest);
  }
  Scr_AddBool(scrContext, IsWeaponAttachmentRestricted);
}

/*
==============
GScr_WeaponIsRestricted
==============
*/
void GScr_WeaponIsRestricted(scrContext_t *scrContext)
{
  const char *String; 
  int IsWeaponRestricted; 

  String = Scr_GetString(scrContext, 0);
  IsWeaponRestricted = MatchRules_IsWeaponRestricted(String);
  Scr_AddBool(scrContext, IsWeaponRestricted);
}

/*
==============
GScr_PerkIsRestricted
==============
*/
void GScr_PerkIsRestricted(scrContext_t *scrContext)
{
  const char *String; 
  int IsPerkRestricted; 

  String = Scr_GetString(scrContext, 0);
  IsPerkRestricted = MatchRules_IsPerkRestricted(String);
  Scr_AddBool(scrContext, IsPerkRestricted);
}

/*
==============
GScr_EquipmentIsRestricted
==============
*/
void GScr_EquipmentIsRestricted(scrContext_t *scrContext)
{
  const char *String; 
  int IsEquipmentRestricted; 

  String = Scr_GetString(scrContext, 0);
  IsEquipmentRestricted = MatchRules_IsEquipmentRestricted(String);
  Scr_AddBool(scrContext, IsEquipmentRestricted);
}

/*
==============
GScr_KillstreakIsRestricted
==============
*/
void GScr_KillstreakIsRestricted(scrContext_t *scrContext)
{
  const char *String; 
  int IsKillstreakRestricted; 

  String = Scr_GetString(scrContext, 0);
  IsKillstreakRestricted = MatchRules_IsKillstreakRestricted(String);
  Scr_AddBool(scrContext, IsKillstreakRestricted);
}

/*
==============
GScr_SuperIsRestricted
==============
*/
void GScr_SuperIsRestricted(scrContext_t *scrContext)
{
  const char *String; 
  int IsSuperRestricted; 

  String = Scr_GetString(scrContext, 0);
  IsSuperRestricted = MatchRules_IsSuperRestricted(String);
  Scr_AddBool(scrContext, IsSuperRestricted);
}

/*
==============
GScr_IsUsingOnlineDataOffline
==============
*/
void GScr_IsUsingOnlineDataOffline(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  bool IsUsingOnlineStatsOffline; 

  Entity = GetEntity(entref);
  if ( !Entity->client )
    Scr_Error(COM_ERR_3205, scrContext, "setstat: entity must be a player entity");
  IsUsingOnlineStatsOffline = SV_ClientMP_IsUsingOnlineStatsOffline(Entity->s.number);
  Scr_AddBool(scrContext, IsUsingOnlineStatsOffline);
}

/*
==============
GScr_GetRestedTime
==============
*/
void GScr_GetRestedTime(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gclient_s *client; 
  __int64 connected; 
  const char *v7; 
  int Int; 

  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
    Scr_Error(COM_ERR_3206, scrContext, "GetRestedTime not allowed on front end server");
  Entity = GetEntity(entref);
  if ( !Entity->client )
  {
    Scr_Error(COM_ERR_3207, scrContext, "setstat: entity must be a player entity");
    if ( !Entity->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5544, ASSERT_TYPE_ASSERT, "( playerEnt->client )", (const char *)&queryFormat, "playerEnt->client") )
      __debugbreak();
  }
  client = Entity->client;
  connected = (unsigned int)client->sess.connected;
  if ( (_DWORD)connected != 2 )
  {
    v7 = j_va("cannot read persistent data: player has not finished connecting, or ExitLevel has been called. (%s, %d)", client->sess.cs.name, connected);
    Scr_ObjectError(COM_ERR_3116, scrContext, v7);
  }
  if ( SV_IsDemoPlaying() )
  {
    GetRestedTime_Internal(Entity);
    Int = SV_Demo_GetInt();
  }
  else
  {
    Int = GetRestedTime_Internal(Entity);
    SV_Record_GetInt(Int);
  }
  Scr_AddInt(scrContext, Int);
}

/*
==============
GScr_SendClientMatchData
==============
*/
void GScr_SendClientMatchData(scrContext_t *scrContext)
{
  int maxclients; 
  int v2; 
  __int64 v3; 

  if ( SvGameGlobalsMP::GetSvGameGlobalsMP()->clientMatchData.def[0] )
  {
    maxclients = level.maxclients;
    v2 = 0;
    if ( level.maxclients > 0 )
    {
      v3 = 0i64;
      do
      {
        if ( level.clients[v3].sess.connected == CON_CONNECTED )
        {
          SV_ClientMP_SendClientMatchData(v2);
          maxclients = level.maxclients;
        }
        ++v2;
        ++v3;
      }
      while ( v2 < maxclients );
    }
  }
}

/*
==============
GScr_SendClientMatchDataForClient
==============
*/
void GScr_SendClientMatchDataForClient(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  gclient_s *client; 

  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
    Scr_Error(COM_ERR_6538, scrContext, "SendClientMatchDataForClient not allowed on front end server");
  Entity = GetEntity(entref);
  if ( !Entity->client )
    Scr_Error(COM_ERR_6539, scrContext, "SendClientMatchDataForClient: entity must be a player entity");
  if ( SvGameGlobalsMP::GetSvGameGlobalsMP()->clientMatchData.def[0] )
  {
    client = Entity->client;
    if ( client->sess.connected == CON_CONNECTED )
      SV_ClientMP_SendClientMatchData(client->ps.clientNum);
  }
}

/*
==============
GScr_GetSystemTime
==============
*/
void GScr_GetSystemTime(scrContext_t *scrContext)
{
  int Int; 

  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
    Scr_Error(COM_ERR_3208, scrContext, "This function is not available for the front end scene");
  if ( SV_IsDemoPlaying() )
  {
    Int = SV_Demo_GetInt();
  }
  else
  {
    if ( LiveStorage_IsTimeSynced() )
      Int = LiveStorage_GetUTC();
    else
      Int = Sys_GetTimeAsSeconds();
    SV_Record_GetInt(Int);
  }
  Scr_AddInt(scrContext, Int);
}

/*
==============
GScr_GetServerHostName
==============
*/
void GScr_GetServerHostName(scrContext_t *scrContext)
{
  const char *HostName; 

  HostName = SV_GameMP_GetHostName();
  Scr_AddString(scrContext, HostName);
}

/*
==============
GScr_SetIntroCameraActive
==============
*/
void GScr_SetIntroCameraActive(scrContext_t *scrContext)
{
  level.introCameraActive = Scr_GetInt(scrContext, 0) != 0;
}

/*
==============
GScr_StartPodium
==============
*/
void GScr_StartPodium(scrContext_t *scrContext)
{
  int Int; 
  unsigned int v3; 
  const char *v4; 
  unsigned int Object; 
  unsigned int ArraySize; 
  unsigned int v7; 
  const char *v8; 
  signed int v9; 
  const char *NameForType; 
  const char *v11; 
  __int64 v12; 
  unsigned int *v13; 
  int cursize; 
  unsigned int CanonicalString; 
  unsigned int v16; 
  unsigned int v17; 
  unsigned int v18; 
  VariableType type; 
  const char *v20; 
  const char *v21; 
  __int64 v22; 
  char v23; 
  __int64 v24; 
  char v25; 
  bool v26; 
  unsigned __int64 v31; 
  scr_entref_t EntityIdRef; 
  unsigned int v37; 
  const char *v38; 
  unsigned int v39; 
  const char *v40; 
  unsigned int v41; 
  const char *v42; 
  const char *v43; 
  const char *v44; 
  const char *v45; 
  const char *v46; 
  const char *v47; 
  const char *v48; 
  const char *v49; 
  const char *v50; 
  SvClient *CommonClient; 
  __int64 v52; 
  VariableType failureType[4]; 
  unsigned int failureIndex; 
  int v55; 
  VariableValue v56; 
  int v57; 
  VariableValue v58; 
  VariableValue v59; 
  VariableValue out; 
  VariableValue v61; 
  VariableValue v62; 
  VariableValue v63; 
  msg_t buf; 
  XUID v65; 
  Weapon result; 
  Weapon r_weapon; 
  unsigned int buffer[2]; 
  __int64 v69; 
  __int64 v70; 
  unsigned __int8 data[1024]; 

  if ( Scr_GetNumParam(scrContext) != 2 )
    Scr_Error(COM_ERR_3209, scrContext, "StartPodium(): invalid number of arguments provided.  StartPodium( <client>, <mvp array> );");
  Int = Scr_GetInt(scrContext, 0);
  v3 = Int;
  v55 = Int;
  if ( Int < -1 || level.maxclients <= Int )
  {
    v4 = j_va("StartPodium(): client index should be an integer between -1 and %i", (unsigned int)level.maxclients);
    Scr_Error(COM_ERR_3210, scrContext, v4);
  }
  if ( Scr_GetType(scrContext, 1u) != VAR_POINTER || Scr_GetPointerType(scrContext, 1u) != VAR_ARRAY )
    Scr_Error(COM_ERR_3211, scrContext, "StartPodium(): expected an array.");
  Object = Scr_GetObject(scrContext, 1u);
  ArraySize = GetArraySize(scrContext, Object);
  v7 = ArraySize;
  if ( ArraySize > 6 )
  {
    v8 = j_va("StartPodium(): too many array entries were provided.  %i provided, %i supported.", ArraySize, 6i64);
    Scr_Error(COM_ERR_3212, scrContext, v8);
  }
  *(_QWORD *)buffer = 0i64;
  v9 = 0;
  v69 = 0i64;
  v70 = 0i64;
  failureType[0] = VAR_UNDEFINED;
  failureIndex = 0;
  if ( !Scr_GetObjectArray(scrContext, Object, 6u, buffer, &failureIndex, failureType) )
  {
    if ( failureIndex >= 6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 8800, ASSERT_TYPE_ASSERT, "(failureIndex < 6)", "%s\n\tStartPodium(): Internal error.", "failureIndex < MAX_PODIUM_CLIENTS") )
      __debugbreak();
    NameForType = Scr_GetNameForType(failureType[0]);
    v11 = j_va("StartPodium(): element %i of provided array -- type %s is not an object", failureIndex, NameForType);
    Scr_Error(COM_ERR_3213, scrContext, v11);
  }
  MSG_Init(&buf, data, 1020);
  MSG_WriteByte(&buf, 65i64);
  if ( (v7 > 0x7FFFFFFF || v7 + 128 > 0xFF) && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "char __cdecl truncate_cast_impl<char,unsigned int>(unsigned int)", "signed", (char)v7, "unsigned", v7) )
    __debugbreak();
  MSG_WriteByte(&buf, (char)v7);
  if ( v7 > 6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 8815, ASSERT_TYPE_ASSERT, "(arraySize <= 6)", (const char *)&queryFormat, "arraySize <= MAX_PODIUM_CLIENTS") )
    __debugbreak();
  if ( (int)(v7 - 1) > 0 )
    v9 = v7 - 1;
  v12 = 4i64 * v9;
  v13 = &buffer[(unsigned __int64)v12 / 4];
  if ( &buffer[(unsigned __int64)v12 / 4] < buffer )
  {
LABEL_85:
    if ( v3 == -1 )
    {
      SV_Game_BroadcastServerCommandMsg(SV_CMD_RELIABLE, &buf);
    }
    else
    {
      CommonClient = SvClient::GetCommonClient(v3);
      SV_Game_SendServerCommandMsg(CommonClient, SV_CMD_RELIABLE, &buf);
    }
    return;
  }
  while ( 1 )
  {
    if ( !*v13 )
    {
LABEL_84:
      v3 = v55;
      goto LABEL_85;
    }
    cursize = buf.cursize;
    v57 = buf.cursize;
    CanonicalString = SL_GetCanonicalString("rigindex");
    Scr_FindVariableField_Out(scrContext, *v13, CanonicalString, &out);
    if ( out.type != VAR_INTEGER )
    {
      RemoveRefToValue(scrContext, (unsigned __int8)out.type, out.u);
      v50 = j_va("StartPodium(): element %zu of provided array -- field 'rigIndex' is missing or is not an integer.", v12 >> 2);
      Scr_Error(COM_ERR_3214, scrContext, v50);
      return;
    }
    if ( out.u.intValue > 511 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 8835, ASSERT_TYPE_ASSERT, "(r_rigValue.u.intValue <= ((1 << 9) - 1))", (const char *)&queryFormat, "r_rigValue.u.intValue <= MAX_PODIUM_CUSTOMIZATION_INDEX") )
      __debugbreak();
    MSG_WriteBits(&buf, out.u.intValue, 9u);
    RemoveRefToValue(scrContext, (unsigned __int8)out.type, out.u);
    v16 = SL_GetCanonicalString("headindex");
    Scr_FindVariableField_Out(scrContext, *v13, v16, &v59);
    if ( v59.type != VAR_INTEGER )
    {
      RemoveRefToValue(scrContext, (unsigned __int8)v59.type, v59.u);
      v49 = j_va("StartPodium(): element %zu of provided array -- field 'headindex' is missing or is not an integer.", v12 >> 2);
      Scr_Error(COM_ERR_3215, scrContext, v49);
      return;
    }
    if ( v59.u.intValue > 511 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 8847, ASSERT_TYPE_ASSERT, "(r_headValue.u.intValue <= ((1 << 9) - 1))", (const char *)&queryFormat, "r_headValue.u.intValue <= MAX_PODIUM_CUSTOMIZATION_INDEX") )
      __debugbreak();
    MSG_WriteBits(&buf, v59.u.intValue, 9u);
    RemoveRefToValue(scrContext, (unsigned __int8)v59.type, v59.u);
    v17 = SL_GetCanonicalString("bodyindex");
    Scr_FindVariableField_Out(scrContext, *v13, v17, &v58);
    if ( v58.type != VAR_INTEGER )
    {
      RemoveRefToValue(scrContext, (unsigned __int8)v58.type, v58.u);
      v48 = j_va("StartPodium(): element %zu of provided array -- field 'bodyIndex' is missing or is not an integer.", v12 >> 2);
      Scr_Error(COM_ERR_3216, scrContext, v48);
      return;
    }
    if ( v58.u.intValue > 511 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 8859, ASSERT_TYPE_ASSERT, "(r_bodyValue.u.intValue <= ((1 << 9) - 1))", (const char *)&queryFormat, "r_bodyValue.u.intValue <= MAX_PODIUM_CUSTOMIZATION_INDEX") )
      __debugbreak();
    MSG_WriteBits(&buf, v58.u.intValue, 9u);
    RemoveRefToValue(scrContext, (unsigned __int8)v58.type, v58.u);
    v18 = SL_GetCanonicalString("weaponname");
    Scr_FindVariableField_Out(scrContext, *v13, v18, &v56);
    type = v56.type;
    if ( v56.type == VAR_STRING )
    {
      v20 = SL_ConvertToString((scr_string_t)v56.u.intValue);
      if ( !v20 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 8868, ASSERT_TYPE_ASSERT, "(weaponName)", (const char *)&queryFormat, "weaponName") )
          __debugbreak();
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons_util.h", 1138, ASSERT_TYPE_ASSERT, "(weaponName)", (const char *)&queryFormat, "weaponName") )
          __debugbreak();
      }
      v21 = "none";
      v22 = 4i64;
      if ( !v20 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 181, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
        __debugbreak();
      while ( 1 )
      {
        v23 = v21[v20 - "none"];
        v24 = v22;
        v25 = *v21;
        --v22;
        ++v21;
        if ( !v24 )
          goto LABEL_51;
        if ( v23 != v25 )
          break;
        if ( !v23 )
          goto LABEL_51;
      }
      v31 = -1i64;
      do
        ++v31;
      while ( v20[v31] );
      if ( v31 <= 4 || *v20 != 97 || v20[1] != 108 || v20[2] != 116 || v20[3] != 95 )
      {
LABEL_51:
        v26 = 0;
        goto LABEL_52;
      }
      v26 = 1;
LABEL_52:
      _RAX = GScr_Main_GetWeaponForName(&result, scrContext, v20);
      __asm
      {
        vmovups ymm0, ymmword ptr [rax]
        vmovups ymmword ptr [rbp+4E0h+r_weapon.weaponIdx], ymm0
        vmovups xmm1, xmmword ptr [rax+20h]
        vmovups xmmword ptr [rbp+4E0h+r_weapon.attachmentVariationIndices+5], xmm1
        vmovsd  xmm0, qword ptr [rax+30h]
        vmovsd  qword ptr [rbp+4E0h+r_weapon.attachmentVariationIndices+15h], xmm0
      }
      *(_DWORD *)&r_weapon.weaponCamo = *(_DWORD *)&_RAX->weaponCamo;
      Scr_VerifyWeapon(scrContext, &r_weapon, v26, v20);
      cursize = v57;
      goto LABEL_65;
    }
    if ( v56.type != VAR_POINTER )
      goto LABEL_92;
    if ( GetObjectType(scrContext, v56.u.uintValue) != VAR_ENTITY )
      break;
    EntityIdRef = Scr_GetEntityIdRef(scrContext, v56.u.uintValue);
    if ( EntityIdRef.entclass != ENTITY_CLASS_SAVED_COUNT )
    {
      RemoveRefToValue(scrContext, (unsigned __int8)v56.type, v56.u);
      v46 = j_va("StartPodium(): element %zu of provided array -- field 'weaponName' is not a valid weapon entity.", v12 >> 2);
      Scr_Error(COM_ERR_3217, scrContext, v46);
      return;
    }
    _RAX = GScr_Weapon_GetWeapon(scrContext, (const scr_weapon_t)EntityIdRef.entnum);
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovups ymmword ptr [rbp+4E0h+r_weapon.weaponIdx], ymm0
      vmovups xmm1, xmmword ptr [rax+20h]
      vmovups xmmword ptr [rbp+4E0h+r_weapon.attachmentVariationIndices+5], xmm1
      vmovsd  xmm0, qword ptr [rax+30h]
      vmovsd  qword ptr [rbp+4E0h+r_weapon.attachmentVariationIndices+15h], xmm0
    }
    *(_DWORD *)&r_weapon.weaponCamo = *(_DWORD *)&_RAX->weaponCamo;
    GScr_Weapon_IsAlternate(scrContext, (const scr_weapon_t)EntityIdRef.entnum);
LABEL_65:
    MSG_WriteWeapon(&buf, &r_weapon);
    RemoveRefToValue(scrContext, (unsigned __int8)v56.type, v56.u);
    v37 = SL_GetCanonicalString("clantag");
    Scr_FindVariableField_Out(scrContext, *v13, v37, &v63);
    if ( v63.type != VAR_STRING )
    {
      RemoveRefToValue(scrContext, (unsigned __int8)v63.type, v63.u);
      v45 = j_va("StartPodium(): element %zu of provided array -- field 'clanTag' is missing or is not a string.", v12 >> 2);
      Scr_Error(COM_ERR_3219, scrContext, v45);
      return;
    }
    v38 = SL_ConvertToString((scr_string_t)v63.u.intValue);
    if ( !v38 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 8908, ASSERT_TYPE_ASSERT, "(clanTag)", (const char *)&queryFormat, "clanTag") )
      __debugbreak();
    MSG_WriteString(&buf, v38);
    RemoveRefToValue(scrContext, (unsigned __int8)v63.type, v63.u);
    v39 = SL_GetCanonicalString((const char *)&stru_143C9A1A4);
    Scr_FindVariableField_Out(scrContext, *v13, v39, &v62);
    if ( v62.type != VAR_STRING )
    {
      RemoveRefToValue(scrContext, (unsigned __int8)v62.type, v62.u);
      v44 = j_va("StartPodium(): element %zu of provided array -- field 'name' is missing or is not a string.", v12 >> 2);
      Scr_Error(COM_ERR_3220, scrContext, v44);
      return;
    }
    v40 = SL_ConvertToString((scr_string_t)v62.u.intValue);
    if ( !v40 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 8921, ASSERT_TYPE_ASSERT, (const char *)&stru_143C9A1A4.m_end, (const char *)&queryFormat, &stru_143C9A1A4) )
      __debugbreak();
    MSG_WriteString(&buf, v40);
    RemoveRefToValue(scrContext, (unsigned __int8)v62.type, v62.u);
    v41 = SL_GetCanonicalString("xuid");
    Scr_FindVariableField_Out(scrContext, *v13, v41, &v61);
    if ( v61.type != VAR_STRING )
    {
      RemoveRefToValue(scrContext, (unsigned __int8)v61.type, v61.u);
      v43 = j_va("StartPodium(): element %zu of provided array -- field 'xuid' is missing or is not a string.", v12 >> 2);
      Scr_Error(COM_ERR_3221, scrContext, v43);
      return;
    }
    v42 = SL_ConvertToString((scr_string_t)v61.u.intValue);
    if ( !v42 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 8934, ASSERT_TYPE_ASSERT, "(xuidStr)", (const char *)&queryFormat, "xuidStr") )
      __debugbreak();
    XUID::FromHexString(&v65, v42);
    XUID::Serialize(&v65, &buf);
    RemoveRefToValue(scrContext, (unsigned __int8)v61.type, v61.u);
    --v13;
    v12 -= 4i64;
    if ( buf.overflowed && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 8943, ASSERT_TYPE_ASSERT, "(!msg.overflowed)", "%s\n\tStartPodium(): internal error.  Server command buffer overflowed while writing message.", "!msg.overflowed") )
      __debugbreak();
    if ( (unsigned int)(buf.cursize - cursize) > 0x3F )
    {
      LODWORD(v52) = buf.cursize - cursize;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 8946, ASSERT_TYPE_ASSERT, "(messageSize <= PER_CLIENT_MAX_MESSAGE_SIZE)", "%s\n\tStartPodium(): internal error.  (%i) bytes were written out of (%zu) maximum expected.  No overflow occurred, but please update PER_CLIENT_MESSAGE_SIZE so that compile-time assertions are valid.", "messageSize <= PER_CLIENT_MAX_MESSAGE_SIZE", v52, 0x3Fui64) )
        __debugbreak();
    }
    if ( v13 < buffer )
      goto LABEL_84;
  }
  type = v56.type;
LABEL_92:
  RemoveRefToValue(scrContext, (unsigned __int8)type, v56.u);
  v47 = j_va("StartPodium(): element %zu of provided array -- field 'weaponName' is missing or is not a weapon type.", v12 >> 2);
  Scr_Error(COM_ERR_3218, scrContext, v47);
}

/*
==============
GScr_SetTeamForTrigger
==============
*/
void GScr_SetTeamForTrigger(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t classname; 
  const char *v5; 
  const char *v6; 
  const char *v7; 
  scr_string_t ConstString; 
  const char *v9; 
  const char *v10; 
  team_t outTeam; 

  Entity = GetEntity(entref);
  classname = Entity->classname;
  if ( classname != scr_const.trigger_use && classname != scr_const.trigger_use_touch )
  {
    v5 = SL_ConvertToString(scr_const.trigger_use_touch);
    v6 = SL_ConvertToString(scr_const.trigger_use);
    v7 = j_va("setteamfortrigger: trigger entity must be of type %s or %s", v6, v5);
    Scr_Error(COM_ERR_3222, scrContext, v7);
  }
  ConstString = Scr_GetConstString(scrContext, 0);
  if ( Com_Teams_TeamFromString(ConstString, &outTeam) )
  {
    Entity->c.trigger.team = outTeam;
  }
  else
  {
    v9 = SL_ConvertToString(ConstString);
    v10 = j_va("unknown team '%s'", v9);
    Scr_Error(COM_ERR_3223, scrContext, v10);
  }
}

/*
==============
GScr_ClientClaimTrigger
==============
*/
void GScr_ClientClaimTrigger(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  playerState_s *EntityPlayerState; 
  gentity_s *v5; 
  scr_string_t classname; 
  const char *v7; 
  const char *v8; 
  const char *v9; 
  unsigned __int16 v10; 

  Entity = GetEntity(entref);
  EntityPlayerState = G_GetEntityPlayerState(Entity);
  if ( !Entity->agent && !Entity->client )
    Scr_Error(COM_ERR_3224, scrContext, "clientclaimtrigger: claimer must be a client or an agent.");
  v5 = GScr_GetEntity(0);
  classname = v5->classname;
  if ( classname != scr_const.trigger_use && classname != scr_const.trigger_use_touch )
  {
    v7 = SL_ConvertToString(scr_const.trigger_use_touch);
    v8 = SL_ConvertToString(scr_const.trigger_use);
    v9 = j_va("clientclaimtrigger: trigger entity must be of type %s or %s", v8, v7);
    Scr_Error(COM_ERR_3225, scrContext, v9);
  }
  v10 = v5->c.item[0].weapon.stickerIndices[1];
  if ( v10 == 2047 || v10 == EntityPlayerState->clientNum )
    v5->c.item[0].weapon.stickerIndices[1] = truncate_cast<unsigned short,int>(EntityPlayerState->clientNum);
}

/*
==============
GScr_ClientReleaseTrigger
==============
*/
void GScr_ClientReleaseTrigger(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  playerState_s *EntityPlayerState; 
  gentity_s *v5; 
  scr_string_t classname; 
  const char *v7; 
  const char *v8; 
  const char *v9; 

  Entity = GetEntity(entref);
  EntityPlayerState = G_GetEntityPlayerState(Entity);
  if ( !Entity->agent && !Entity->client )
    Scr_Error(COM_ERR_3226, scrContext, "clientreleasetrigger: releaser must be a client or an agent.");
  v5 = GScr_GetEntity(0);
  classname = v5->classname;
  if ( classname != scr_const.trigger_use && classname != scr_const.trigger_use_touch )
  {
    v7 = SL_ConvertToString(scr_const.trigger_use_touch);
    v8 = SL_ConvertToString(scr_const.trigger_use);
    v9 = j_va("clientreleasetrigger: trigger entity must be of type %s or %s", v8, v7);
    Scr_Error(COM_ERR_3227, scrContext, v9);
  }
  if ( v5->c.item[0].weapon.stickerIndices[1] == EntityPlayerState->clientNum )
    v5->c.item[0].weapon.stickerIndices[1] = 2047;
}

/*
==============
GScr_ReleaseClaimedTrigger
==============
*/
void GScr_ReleaseClaimedTrigger(scrContext_t *scrContext, scr_entref_t entref)
{
  gentity_s *Entity; 
  scr_string_t classname; 
  const char *v5; 
  const char *v6; 
  const char *v7; 

  Entity = GetEntity(entref);
  classname = Entity->classname;
  if ( classname != scr_const.trigger_use && classname != scr_const.trigger_use_touch )
  {
    v5 = SL_ConvertToString(scr_const.trigger_use_touch);
    v6 = SL_ConvertToString(scr_const.trigger_use);
    v7 = j_va("releaseclaimedtrigger: trigger entity must be of type %s or %s", v6, v5);
    Scr_Error(COM_ERR_3228, scrContext, v7);
  }
  Entity->c.item[0].weapon.stickerIndices[1] = 2047;
}

/*
==============
GScr_SetMapCenter
==============
*/
void GScr_SetMapCenter(scrContext_t *scrContext)
{
  vec3_t vectorValue; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_3229, scrContext, "Expected 1 argument to setMapCenter()");
  Scr_GetVector(scrContext, 0, &vectorValue);
  SV_GameMP_SetMapCenter(&vectorValue);
}

/*
==============
GScr_SetGameEndTime
==============
*/
void GScr_SetGameEndTime(scrContext_t *scrContext)
{
  int Int; 

  if ( Scr_GetNumParam(scrContext) != 1 )
    Scr_Error(COM_ERR_3230, scrContext, "Expected 1 argument to setGameEndTime()");
  Int = Scr_GetInt(scrContext, 0);
  SV_GameMP_SetGameEndTime(Int);
}

/*
==============
GScr_SetTeamRadar
==============
*/
void GScr_SetTeamRadar(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const char *v3; 
  const char *v4; 
  const char *v5; 
  const char *v6; 
  bool v7; 
  team_t outTeam; 

  ConstString = Scr_GetConstString(scrContext, 0);
  if ( Com_Teams_TeamFromString(ConstString, &outTeam) )
  {
    if ( outTeam >= TEAM_MP_NUM_TEAMS )
    {
      v5 = SL_ConvertToString(ConstString);
      v6 = j_va("Illegal team string '%s'. Must be allies, axis, team_three, team_four, team_five, team_six or none.", v5);
      Scr_ParamError(COM_ERR_3232, scrContext, 0, v6);
    }
    v7 = Scr_GetInt(scrContext, 1u) == 0;
    level.teamHasRadar[outTeam] = !v7;
  }
  else
  {
    v3 = SL_ConvertToString(ConstString);
    v4 = j_va("unknown team '%s'", v3);
    Scr_Error(COM_ERR_3231, scrContext, v4);
  }
}

/*
==============
GScr_GetTeamRadar
==============
*/
void GScr_GetTeamRadar(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const char *v3; 
  const char *v4; 
  const char *v5; 
  const char *v6; 
  team_t outTeam; 

  ConstString = Scr_GetConstString(scrContext, 0);
  if ( Com_Teams_TeamFromString(ConstString, &outTeam) )
  {
    if ( outTeam >= TEAM_MP_NUM_TEAMS )
    {
      v5 = SL_ConvertToString(ConstString);
      v6 = j_va("Illegal team string '%s'. Must be allies, axis, team_three, team_four, team_five, team_six or none.", v5);
      Scr_ParamError(COM_ERR_3234, scrContext, 0, v6);
    }
    Scr_AddInt(scrContext, level.teamHasRadar[outTeam]);
  }
  else
  {
    v3 = SL_ConvertToString(ConstString);
    v4 = j_va("unknown team '%s'", v3);
    Scr_Error(COM_ERR_3233, scrContext, v4);
  }
}

/*
==============
GScr_SetTeamRadarStrength
==============
*/
void GScr_SetTeamRadarStrength(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const char *v3; 
  const char *v4; 
  const char *v5; 
  const char *v6; 
  int Int; 
  const dvar_t *v8; 
  int v9; 
  int integer; 
  const dvar_t *v11; 
  __int64 unsignedInt; 
  const char *v13; 
  team_t outTeam; 

  ConstString = Scr_GetConstString(scrContext, 0);
  if ( Com_Teams_TeamFromString(ConstString, &outTeam) )
  {
    if ( outTeam >= TEAM_MP_NUM_TEAMS )
    {
      v5 = SL_ConvertToString(ConstString);
      v6 = j_va("Illegal team string '%s'. Must be a valid team.", v5);
      Scr_ParamError(COM_ERR_3236, scrContext, 0, v6);
    }
    Int = Scr_GetInt(scrContext, 1u);
    v8 = DCONST_DVARINT_bg_UAVStrengthMin;
    v9 = Int;
    if ( !DCONST_DVARINT_bg_UAVStrengthMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_UAVStrengthMin") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v8);
    integer = v8->current.integer;
    v11 = DCONST_DVARINT_bg_UAVStrengthMax;
    if ( !DCONST_DVARINT_bg_UAVStrengthMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_UAVStrengthMax") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v11);
    unsignedInt = v11->current.unsignedInt;
    if ( v9 < integer || v9 > (int)unsignedInt )
    {
      v13 = j_va("Illegal UAV radar strength value'%d'. Must be between %d and %d.", (unsigned int)v9, (unsigned int)integer, unsignedInt);
      Scr_ParamError(COM_ERR_3237, scrContext, 0, v13);
    }
    level.teamRadarStrength[outTeam] = v9;
  }
  else
  {
    v3 = SL_ConvertToString(ConstString);
    v4 = j_va("unknown team '%s'", v3);
    Scr_Error(COM_ERR_3235, scrContext, v4);
  }
}

/*
==============
GScr_GetTeamRadarStrength
==============
*/
void GScr_GetTeamRadarStrength(scrContext_t *scrContext)
{
  scr_string_t ConstString; 
  const char *v3; 
  const char *v4; 
  const char *v5; 
  const char *v6; 
  team_t outTeam; 

  ConstString = Scr_GetConstString(scrContext, 0);
  if ( Com_Teams_TeamFromString(ConstString, &outTeam) )
  {
    if ( outTeam >= TEAM_MP_NUM_TEAMS )
    {
      v5 = SL_ConvertToString(ConstString);
      v6 = j_va("Illegal team string '%s'. Must be axis, allies, team_three, team_four, team_five, team_six or none.", v5);
      Scr_ParamError(COM_ERR_3239, scrContext, 0, v6);
    }
    Scr_AddInt(scrContext, level.teamRadarStrength[outTeam]);
  }
  else
  {
    v3 = SL_ConvertToString(ConstString);
    v4 = j_va("unknown team '%s'", v3);
    Scr_Error(COM_ERR_3238, scrContext, v4);
  }
}

/*
==============
GScr_GetUAVStrengthMin
==============
*/
void GScr_GetUAVStrengthMin(scrContext_t *scrContext)
{
  const dvar_t *v1; 

  v1 = DCONST_DVARINT_bg_UAVStrengthMin;
  if ( !DCONST_DVARINT_bg_UAVStrengthMin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_UAVStrengthMin") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  Scr_AddInt(scrContext, v1->current.integer);
}

/*
==============
GScr_GetUAVStrengthMax
==============
*/
void GScr_GetUAVStrengthMax(scrContext_t *scrContext)
{
  const dvar_t *v1; 

  v1 = DCONST_DVARINT_bg_UAVStrengthMax;
  if ( !DCONST_DVARINT_bg_UAVStrengthMax && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "bg_UAVStrengthMax") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  Scr_AddInt(scrContext, v1->current.integer);
}

/*
==============
GScriptMP::ConstructMessageString
==============
*/
void GScriptMP::ConstructMessageString(GScriptMP *this, scrContext_t *scrContext, int firstParmIndex, int lastParmIndex, const char *errorContext, char *string, unsigned int stringLimit)
{
  __int64 v7; 
  int v8; 
  unsigned int v10; 
  const char *v11; 
  VariableType Type; 
  const char *IString; 
  const char *v14; 
  __int64 v15; 
  const char *v16; 
  gentity_s *Entity; 
  gclient_s *client; 
  char *v19; 
  const char *v20; 
  ComErrorCode v21; 
  const char *v22; 
  unsigned int v23; 
  const char *v24; 
  char v25; 
  const char *v26; 
  __int64 v27; 
  char v28; 
  const dvar_t *v29; 
  const dvar_t *v30; 
  bool v31; 
  const char *v32; 

  v7 = 0i64;
  v8 = firstParmIndex;
  if ( firstParmIndex <= lastParmIndex )
  {
    v10 = stringLimit;
    v11 = errorContext;
    while ( 1 )
    {
      Type = Scr_GetType(scrContext, v8);
      if ( Type == VAR_ISTRING )
      {
        IString = Scr_GetIString(scrContext, v8);
        v14 = IString;
        v15 = -1i64;
        do
          ++v15;
        while ( IString[v15] );
        Scr_ValidateLocalizedStringRef(scrContext, v8, IString, v15);
        if ( (int)v15 + (int)v7 + 1 >= v10 )
        {
          v16 = j_va("%s is too long. Max length is %i\n", v11, v10);
          Scr_ParamError(COM_ERR_2972, scrContext, v8, v16);
        }
        if ( (_DWORD)v7 )
        {
          string[v7] = 30;
          goto LABEL_41;
        }
        goto LABEL_42;
      }
      if ( Type == VAR_POINTER && Scr_GetPointerType(scrContext, v8) == VAR_ENTITY )
        break;
      v22 = Scr_GetString(scrContext, v8);
      v14 = v22;
      v15 = -1i64;
      do
        ++v15;
      while ( v22[v15] );
      v23 = 0;
      if ( (_DWORD)v15 )
      {
        v24 = v22;
        while ( 1 )
        {
          v25 = *v24;
          if ( (unsigned __int8)(*v24 - 30) <= 1u || v25 == 22 )
          {
            v26 = j_va("bad escape character (%i) present in string", (unsigned int)v25);
            Scr_ParamError(COM_ERR_2975, scrContext, v8, v26);
            v25 = *v24;
          }
          if ( isalpha(v25) )
            break;
          ++v23;
          ++v24;
          if ( v23 >= (unsigned int)v15 )
            goto LABEL_35;
        }
        v29 = DCONST_DVARBOOL_loc_warnings;
        if ( !DCONST_DVARBOOL_loc_warnings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "loc_warnings") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v29);
        if ( !v29->current.enabled )
        {
LABEL_35:
          v11 = errorContext;
          goto LABEL_36;
        }
        v30 = DCONST_DVARBOOL_loc_warningsAsErrors;
        if ( !DCONST_DVARBOOL_loc_warningsAsErrors && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "loc_warningsAsErrors") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v30);
        v31 = !v30->current.enabled;
        v11 = errorContext;
        if ( v31 )
        {
          Com_PrintWarning(17, "WARNING: Non-localized %s string is not allowed to have letters in it. Must be changed over to a localized string: \"%s\"\n", errorContext, v14);
        }
        else
        {
          v32 = j_va("non-localized %s strings are not allowed to have letters in them: \"%s\"", errorContext, v14);
          Scr_LocalizationError(scrContext, v8, v32);
        }
      }
LABEL_36:
      v10 = stringLimit;
      if ( (int)v15 + (int)v7 + 1 >= stringLimit )
      {
        v20 = j_va("%s is too long. Max length is %i\n", v11, stringLimit);
        v21 = COM_ERR_2976;
        goto LABEL_38;
      }
LABEL_39:
      if ( (_DWORD)v15 )
      {
        string[v7] = 31;
LABEL_41:
        v7 = (unsigned int)(v7 + 1);
LABEL_42:
        if ( (_DWORD)v15 )
        {
          v27 = (unsigned int)v15;
          do
          {
            v28 = *v14;
            if ( ((*v14 - 22) & 0xF6) == 0 && v28 != 23 )
              v28 = 46;
            string[v7] = v28;
            ++v14;
            v7 = (unsigned int)(v7 + 1);
            --v27;
          }
          while ( v27 );
        }
      }
      if ( ++v8 > lastParmIndex )
      {
        string[v7] = 0;
        return;
      }
    }
    Entity = GScr_GetEntity(v8);
    client = Entity->client;
    if ( !client )
    {
      Scr_ParamError(COM_ERR_2973, scrContext, v8, "Entity is not a player");
      client = Entity->client;
    }
    if ( client->sess.cs.clanAbbrev[0] )
    {
      switch ( client->sess.cs.clanTagType )
      {
        case 0u:
          v19 = j_va("[%s]%s^7", client->sess.cs.clanAbbrev, client->sess.cs.name);
LABEL_22:
          v14 = v19;
          v15 = -1i64;
          do
            ++v15;
          while ( v19[v15] );
          if ( (int)v15 + (int)v7 + 1 >= v10 )
          {
            v20 = j_va("%s is too long. Max length is %i\n", v11, v10);
            v21 = COM_ERR_2974;
LABEL_38:
            Scr_ParamError(v21, scrContext, v8, v20);
            goto LABEL_39;
          }
          goto LABEL_39;
        case 2u:
          v19 = j_va("[^3%s^7]%s^7", client->sess.cs.clanAbbrev, client->sess.cs.name);
          goto LABEL_22;
        case 3u:
          v19 = j_va("[^1%s^7]%s^7", client->sess.cs.clanAbbrev, client->sess.cs.name);
          goto LABEL_22;
      }
    }
    v19 = j_va("%s^7", client->sess.cs.name);
    goto LABEL_22;
  }
  *string = 0;
}

/*
==============
GScr_AddEntityAllowUndefined
==============
*/
void GScr_AddEntityAllowUndefined(const gentity_s *pEnt)
{
  scrContext_t *v2; 

  v2 = ScriptContext_Server();
  if ( pEnt )
    GScr_AddEntity(pEnt);
  else
    Scr_AddUndefined(v2);
}

/*
==============
GScr_GetQuestPoints_Internal
==============
*/

void __fastcall GScr_GetQuestPoints_Internal(scrContext_t *scrContext, const unsigned __int16 targetClusterId, const vec3_t *origin, double maxRadius, const float minRadius, const bool bDistance2D, const int *type)
{
  unsigned __int16 TotalQuestPointCount; 
  unsigned __int16 i; 
  unsigned __int16 QuestPointIndex; 
  unsigned __int16 pointCount; 
  SpawnGroupPoint *v19; 
  unsigned int CanonicalString; 
  unsigned int v31; 
  unsigned int v32; 
  unsigned int v33; 
  __int64 v36; 
  __int64 v37; 

  __asm
  {
    vmovss  xmm0, [rsp+88h+minRadius]
    vmovaps [rsp+88h+var_38], xmm6
  }
  _RBP = origin;
  __asm
  {
    vmovaps [rsp+88h+var_48], xmm7
    vmulss  xmm7, xmm0, xmm0
    vmulss  xmm6, xmm3, xmm3
  }
  TotalQuestPointCount = ScriptableSv_GetTotalQuestPointCount();
  Scr_MakeArray(scrContext);
  for ( i = 0; i < TotalQuestPointCount; ++i )
  {
    QuestPointIndex = ScriptableSv_GetQuestPointIndex(i);
    pointCount = cm.mapEnts->spawnGroupLoot.pointCount;
    if ( QuestPointIndex >= pointCount )
    {
      LODWORD(v37) = pointCount;
      LODWORD(v36) = QuestPointIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 13051, ASSERT_TYPE_ASSERT, "(unsigned)( pointIndex ) < (unsigned)( cm.mapEnts->spawnGroupLoot.pointCount )", "pointIndex doesn't index cm.mapEnts->spawnGroupLoot.pointCount\n\t%i not in [0, %i)", v36, v37) )
        __debugbreak();
    }
    v19 = &cm.mapEnts->spawnGroupLoot.points[QuestPointIndex];
    if ( v19->cluster != targetClusterId || type && *type && (v19->zone & *type) == 0 )
      continue;
    if ( _RBP )
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rbp+0]
        vmovss  xmm1, dword ptr [rbp+4]
        vsubss  xmm4, xmm0, dword ptr [rbx]
        vsubss  xmm2, xmm1, dword ptr [rbx+4]
        vmulss  xmm3, xmm2, xmm2
        vmulss  xmm0, xmm4, xmm4
        vaddss  xmm5, xmm3, xmm0
      }
      if ( !bDistance2D )
      {
        __asm
        {
          vmovss  xmm0, dword ptr [rbp+8]
          vsubss  xmm1, xmm0, dword ptr [rbx+8]
          vmulss  xmm2, xmm1, xmm1
          vaddss  xmm5, xmm2, xmm5
        }
      }
      __asm { vcomiss xmm5, xmm6 }
      if ( bDistance2D )
        continue;
      __asm { vcomiss xmm5, xmm7 }
    }
    Scr_MakeStruct(scrContext);
    Scr_AddInt(scrContext, QuestPointIndex);
    CanonicalString = SL_GetCanonicalString("index");
    Scr_AddStructField(scrContext, CanonicalString);
    Scr_AddVector(scrContext, v19->origin.v);
    v31 = SL_GetCanonicalString("origin");
    Scr_AddStructField(scrContext, v31);
    Scr_AddVector(scrContext, v19->angles.v);
    v32 = SL_GetCanonicalString("angles");
    Scr_AddStructField(scrContext, v32);
    Scr_AddInt(scrContext, v19->zone);
    v33 = SL_GetCanonicalString("spawnflags");
    Scr_AddStructField(scrContext, v33);
    Scr_AddArray(scrContext);
  }
  __asm
  {
    vmovaps xmm6, [rsp+88h+var_38]
    vmovaps xmm7, [rsp+88h+var_48]
  }
}

/*
==============
GScr_MainMP_LoadScripts
==============
*/
void GScr_MainMP_LoadScripts(const SvServerInitSettings *initSettings)
{
  scrContext_t *v2; 
  bool agentsEnabled; 
  bool v4; 
  int v5; 
  const char **p_label; 
  int v7; 
  const char *v8; 
  int FunctionHandle; 
  int *v10; 
  __int64 v11; 
  int v12; 
  GameModeType gamemode; 
  __int64 gamemodea; 
  __int64 botsEnabled; 
  char *outName[2]; 
  EntryLoadScriptArray loadArray; 
  char dest[128]; 

  if ( !initSettings && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 309, ASSERT_TYPE_ASSERT, "(initSettings)", (const char *)&queryFormat, "initSettings") )
    __debugbreak();
  Sys_ProfBeginNamedEvent(0xFFFFFFFF, "GScr_MainMP_LoadScripts");
  Scr_Mem_AcquireScriptLocks();
  v2 = ScriptContext_Server();
  Scr_BeginLoadScripts(v2, (const ScrThreadMode)initSettings->serverThreadStartup);
  loadArray.count = 0;
  agentsEnabled = BG_AgentSystemEnabled() != 0;
  v4 = BG_BotScriptsEnabled();
  LOBYTE(gamemode) = Com_GameMode_GetActiveGameMode();
  GScr_MainMP_LoadScripts_shared(&loadArray, MAIN, initSettings->gameType, initSettings->isFrontEnd, initSettings->mapName, gamemode, v4, agentsEnabled);
  v5 = 0;
  if ( loadArray.count > 0 )
  {
    p_label = &loadArray.entries[0].label;
    do
    {
      v7 = *((_DWORD *)p_label + 2);
      v8 = *p_label;
      if ( !Scr_LoadScript(v2, loadArray.entries[v5].scriptfile) && v7 )
        Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143FE4450, 831i64, loadArray.entries[v5].scriptfile);
      FunctionHandle = Scr_GetFunctionHandle(v2, loadArray.entries[v5].scriptfile, v8);
      if ( !FunctionHandle && v7 )
        Scr_UnknownLabel(loadArray.entries[v5].scriptfile, v8);
      v10 = (int *)*(p_label - 18);
      ++v5;
      p_label += 20;
      *v10 = FunctionHandle;
    }
    while ( v5 < loadArray.count );
  }
  v11 = 0i64;
  if ( NetConstStrings_GetNameFromIndex(NETCONSTSTRINGTYPE_AITYPE, 0, (const char **)outName) )
  {
    while ( 1 )
    {
      if ( (unsigned int)v11 >= 0x80 )
      {
        LODWORD(botsEnabled) = 128;
        LODWORD(gamemodea) = v11;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 299, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( 128 )", "index doesn't index MAX_AITYPE_SCRIPT_MP\n\t%i not in [0, %i)", gamemodea, botsEnabled) )
          __debugbreak();
      }
      Com_sprintf(dest, 0x80ui64, "aitype/%s%s", outName[0], ".gsc");
      if ( !Scr_LoadScript(v2, dest) )
        break;
      v12 = Scr_GetFunctionHandle(v2, dest, "precache");
      if ( !v12 )
      {
        Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143FE4408, 1230i64, "precache", dest);
        goto LABEL_21;
      }
LABEL_22:
      g_aiTypeScriptMP[v11].precache = v12;
      v11 = (unsigned int)(v11 + 1);
      if ( !NetConstStrings_GetNameFromIndex(NETCONSTSTRINGTYPE_AITYPE, v11, (const char **)outName) )
        goto LABEL_23;
    }
    Com_Printf(15, "Could not find script '%s'\n", dest);
LABEL_21:
    v12 = 0;
    goto LABEL_22;
  }
LABEL_23:
  Scr_PostCompileScripts(v2);
  GScr_Main_UpdateClassMap();
  GScr_Main_PostLoadScriptsCommon();
  Scr_EndLoadScripts(v2);
  Scr_Mem_ReleaseScriptLocks();
  Sys_ProfEndNamedEvent();
}

/*
==============
GScr_MainMP_PrecacheAiTypes
==============
*/
void GScr_MainMP_PrecacheAiTypes(scrContext_t *scrContext)
{
  __int64 i; 
  AITypeScriptMP *v3; 
  unsigned int v4; 
  __int64 v5; 
  __int64 v6; 
  char *outName; 

  for ( i = 0i64; NetConstStrings_GetNameFromIndex(NETCONSTSTRINGTYPE_AITYPE, i, (const char **)&outName); i = (unsigned int)(i + 1) )
  {
    if ( (unsigned int)i >= 0x80 )
    {
      LODWORD(v6) = 128;
      LODWORD(v5) = i;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 351, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( 128 )", "index doesn't index MAX_AITYPE_SCRIPT_MP\n\t%i not in [0, %i)", v5, v6) )
        __debugbreak();
    }
    v3 = &g_aiTypeScriptMP[i];
    if ( !v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 354, ASSERT_TYPE_ASSERT, "( typeScript )", (const char *)&queryFormat, "typeScript") )
      __debugbreak();
    v4 = Scr_ExecThread(scrContext, v3->precache, 0);
    Scr_FreeThread(scrContext, v4);
  }
}

/*
==============
GScr_MainMP_SetHealth
==============
*/
void GScr_MainMP_SetHealth(scrContext_t *scrContext, gentity_s *ent, int offset)
{
  int Int; 
  _DWORD *p_commandTime; 
  __int64 v7; 
  const char *v8; 
  scr_string_t targetname; 
  const char *v10; 
  const char *v11; 

  Int = Scr_GetInt(scrContext, 0);
  p_commandTime = &ent->client->ps.commandTime;
  if ( p_commandTime )
  {
    v7 = (unsigned int)p_commandTime[152];
    if ( Int > (int)v7 )
    {
      v8 = j_va("assignment of client.health: health (%i) must be less than maxHealth (%i)", (unsigned int)Int, v7);
      Scr_Error(COM_ERR_3318, scrContext, v8);
      return;
    }
    goto LABEL_10;
  }
  p_commandTime = &ent->agent->playerState.commandTime;
  if ( p_commandTime )
  {
    if ( Int > 0 )
    {
LABEL_10:
      ent->health = Int;
      p_commandTime[150] = Int;
      return;
    }
    targetname = ent->targetname;
    if ( targetname )
      v10 = SL_ConvertToString(targetname);
    else
      v10 = "<not set>";
    v11 = j_va("self.health must be greater than 0 (tried to set %i on ent %i, name %s)", (unsigned int)Int, (unsigned int)ent->s.number, v10);
    Scr_Error(COM_ERR_3319, scrContext, v11);
  }
  else
  {
    ent->maxHealth = Int;
    ent->health = Int;
  }
}

/*
==============
GScr_SetCodcasterClientMatchDataDef
==============
*/
void GScr_SetCodcasterClientMatchDataDef(scrContext_t *scrContext)
{
  SvGameGlobalsMP *SvGameGlobalsMP; 
  const DDLDef *Asset; 
  DDLContext ddlContext; 

  if ( SvPersistentGlobalsMP::IsFrontEndServer() )
    Scr_Error(COM_ERR_3125, scrContext, "Cannot use codcaster client match data for front-end server");
  SvGameGlobalsMP = SvGameGlobalsMP::GetSvGameGlobalsMP();
  if ( I_strnicmp("ddl/mp/codcasterclientmatchdata.ddl", SvGameGlobalsMP->codcasterClientMatchData.def, 0x7FFFFFFFui64) )
  {
    if ( SvGameGlobalsMP->codcasterClientMatchData.def[0] )
      Scr_Error(COM_ERR_3126, scrContext, "Already set codcaster client match data def\n");
    Core_strcpy(SvGameGlobalsMP->codcasterClientMatchData.def, 0x40ui64, "ddl/mp/codcasterclientmatchdata.ddl");
    Asset = Com_DDL_LoadAsset(SvGameGlobalsMP->codcasterClientMatchData.def);
    DDL_ResetContext(SvGameGlobalsMP->codcasterClientMatchData.data, 1614, Asset, &ddlContext, NULL, NULL);
  }
}

/*
==============
GScriptMP::GetFunction
==============
*/
unsigned int GScriptMP::GetFunction(GScriptMP *this, const char **pName, BuiltinType *type)
{
  const scrContext_t *v5; 
  unsigned int result; 

  *type = BUILTIN_ANY;
  v5 = ScriptContext_Server();
  result = Scr_GetFunctionFromTable(v5, pName, type, &g_scrGameInterfaceFunctions_Server);
  if ( !result )
  {
    result = Scr_GetFunctionFromTable(v5, pName, type, &g_scrGameInterfaceMPFunctions_Server);
    if ( !result )
    {
      result = Scr_GetFunctionFromTable(v5, pName, type, &g_scrCommonFunctions_BothServer);
      if ( !result )
      {
        result = Scr_GetFunctionFromTable(v5, pName, type, &g_scrCommonFunctions_Server);
        if ( !result )
        {
          result = Scr_GetFunctionFromTable(v5, pName, type, &g_scrPhysicsFunctions_Server);
          if ( !result )
          {
            result = Scr_GetFunctionFromTable(v5, pName, type, &g_scrObjectivesFunctions_Server);
            if ( !result )
            {
              result = Scr_GetFunctionFromTable(v5, pName, type, &g_scrSentientFunctions_Server);
              if ( !result )
              {
                result = Scr_GetFunctionFromTable(v5, pName, type, &g_scrAIFunctions_Server);
                if ( !result )
                {
                  result = Scr_GetFunctionFromTable(v5, pName, type, &g_scrWeaponFunctions_Server);
                  if ( !result )
                  {
                    result = Scr_GetFunctionFromTable(v5, pName, type, &g_scrPlayerSpawnFunctions_Server);
                    if ( !result )
                      return Scr_GetFunctionFromTable(v5, pName, type, &g_scrBuiltinMPFunctions_Server);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

/*
==============
GScriptMP::GetMethod
==============
*/
unsigned int GScriptMP::GetMethod(GScriptMP *this, const char **pName, BuiltinType *type)
{
  const scrContext_t *v5; 
  unsigned int result; 

  *type = BUILTIN_ANY;
  v5 = ScriptContext_Server();
  result = Scr_GetMethodFromTable(v5, pName, type, &g_scrGameInterfaceMethods_Server);
  if ( !result )
  {
    result = Scr_GetMethodFromTable(v5, pName, type, &g_scrGameInterfaceMPMethods_Server);
    if ( !result )
    {
      result = Scr_GetMethodFromTable(v5, pName, type, &g_scrMainMethods_Server);
      if ( !result )
      {
        result = Scr_GetMethodFromTable(v5, pName, type, &g_scrClientScrMPMethods_Server);
        if ( !result )
        {
          result = Scr_GetMethodFromTable(v5, pName, type, &g_scrPlayerCommonMethods_Server);
          if ( !result )
          {
            result = Scr_GetMethodFromTable(v5, pName, type, &g_scrAIMethods_Server);
            if ( !result )
            {
              result = Scr_GetMethodFromTable(v5, pName, type, &g_scrMoverMethods_Server);
              if ( !result )
              {
                result = Scr_GetMethodFromTable(v5, pName, type, &g_scrMoverMPMethods_Server);
                if ( !result )
                {
                  result = Scr_GetMethodFromTable(v5, pName, type, &g_scrPhysicsMethods_Server);
                  if ( !result )
                  {
                    result = Scr_GetMethodFromTable(v5, pName, type, &g_scrVehicleMethods_Server);
                    if ( !result )
                    {
                      result = Scr_GetMethodFromTable(v5, pName, type, &g_scrVehicleMPMethods_Server);
                      if ( !result )
                      {
                        result = Scr_GetMethodFromTable(v5, pName, type, &g_scrVehicleHeliMethods_Server);
                        if ( !result )
                        {
                          result = Scr_GetMethodFromTable(v5, pName, type, &g_scrHudElemMethods_Server);
                          if ( !result )
                          {
                            result = Scr_GetMethodFromTable(v5, pName, type, &g_scrSentientMethods_Server);
                            if ( !result )
                            {
                              result = Scr_GetMethodFromTable(v5, pName, type, &g_scrAnimationMethods_Server);
                              if ( !result )
                              {
                                result = Scr_GetMethodFromTable(v5, pName, type, &g_scrWeaponMethods_Server);
                                if ( !result )
                                {
                                  result = Scr_GetMethodFromTable(v5, pName, type, &g_scrPlayerSpawnMethods_Server);
                                  if ( !result )
                                  {
                                    result = Scr_GetMethodFromTable(v5, pName, type, &g_scrBuiltinMPMethods_Server);
                                    if ( !result )
                                      return Scr_GetMethodFromTable(v5, pName, type, &g_scrCalloutMarkerPingMethods_Server);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

/*
==============
GetRestedTime_Internal
==============
*/
__int64 GetRestedTime_Internal(gentity_s *playerEnt)
{
  unsigned __int8 *ClientPlayerDataBuffer; 
  unsigned __int8 *ClientPersistentDataModifiedFlags; 
  const DDLDef *DefForStatsGroup; 
  const DDLDef *v5; 
  int PlayerDataBufferSize; 
  unsigned int TimeAsSeconds; 
  unsigned int v8; 
  DDLContext ddlContext; 

  if ( BYTE1(SvGameGlobals::ms_allocatedType) != 2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server_mp\\sv_persistent_globals_mp.h", 166, ASSERT_TYPE_ASSERT, "( ms_allocatedType == ALLOCATION_TYPE )", (const char *)&queryFormat, "ms_allocatedType == ALLOCATION_TYPE") )
    __debugbreak();
  if ( !SvPersistentGlobals::ms_svPersistent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server\\sv_persistent_globals.h", 72, ASSERT_TYPE_ASSERT, "(ms_svPersistent)", "%s\n\tAttempting to access server static data outside of an active server context", "ms_svPersistent") )
    __debugbreak();
  if ( !BYTE1(SvGameGlobals::ms_allocatedType) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\server\\sv_persistent_globals.h", 73, ASSERT_TYPE_ASSERT, "(ms_allocatedType != GameModeType::NONE)", "%s\n\tAttempting to access server static data outside of an active server context", "ms_allocatedType != GameModeType::NONE") )
    __debugbreak();
  if ( BYTE2(SvPersistentGlobals::ms_svPersistent[4].m_skelMemSize) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 8521, ASSERT_TYPE_ASSERT, "( !SvPersistentGlobalsMP::IsFrontEndServer() )", (const char *)&queryFormat, "!SvPersistentGlobalsMP::IsFrontEndServer()") )
    __debugbreak();
  ClientPlayerDataBuffer = SV_ClientMP_GetClientPlayerDataBuffer(playerEnt->s.number, STATSGROUP_COMMON);
  ClientPersistentDataModifiedFlags = SV_ClientMP_GetClientPersistentDataModifiedFlags(playerEnt->s.number);
  if ( !ClientPlayerDataBuffer && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 8525, ASSERT_TYPE_ASSERT, "(data)", (const char *)&queryFormat, "data") )
    __debugbreak();
  DefForStatsGroup = Com_PlayerData_GetDefForStatsGroup(STATSGROUP_COMMON);
  s_callbackData.modifiedFlags = ClientPersistentDataModifiedFlags;
  v5 = DefForStatsGroup;
  s_callbackData.baseOffset = Com_PlayerData_GetStatsGroupOffset(STATSGROUP_COMMON) + 4;
  PlayerDataBufferSize = LiveStorage_GetPlayerDataBufferSize(STATSGROUP_COMMON);
  Com_DDL_CreateContext(ClientPlayerDataBuffer, PlayerDataBufferSize, v5, &ddlContext, DDLAccessCB, &s_callbackData);
  TimeAsSeconds = Sys_GetTimeAsSeconds();
  v8 = LiveStorage_GetAndResetLastPlayTime(&ddlContext);
  SV_ClientMP_SetClientPersistentDataModified(playerEnt->s.number);
  if ( v8 )
    return TimeAsSeconds - v8;
  else
    return 0i64;
}

/*
==============
LogMatchDataDeathWeaponHelper
==============
*/
void LogMatchDataDeathWeaponHelper(scrContext_t *scrContext, const Weapon *r_weapon, bool isAlternate, unsigned int attachmentsArrayCount, unsigned int attachmentsArrayId, unsigned int weaponStringHash, unsigned int weaponAltModeHash, unsigned int attachmentsStringHash, DDLState *lifeState, DDLContext *buffer)
{
  int v14; 
  const WeaponDef *v16; 
  weapClass_t WeaponClass; 
  int inventoryType; 
  char *v19; 
  unsigned int v21; 
  unsigned int i; 
  unsigned int ArrayVariable; 
  scr_string_t *VariableValueAddress; 
  unsigned int RawHash; 
  DDLState toState; 
  unsigned int v27; 
  char *src; 
  DDLState fromState; 
  char dest[1024]; 

  __asm { vpxor   xmm0, xmm0, xmm0 }
  v14 = 0;
  v27 = attachmentsArrayCount;
  toState.isValid = 0;
  toState.offset = 0;
  toState.arrayIndex = -1;
  __asm { vmovdqu xmmword ptr [rsp+4C0h+toState.member], xmm0 }
  src = (char *)BG_GetWeaponBaseName(r_weapon, isAlternate);
  if ( I_strncmp(src, "destructible", 0xBui64) )
  {
    v16 = BG_WeaponDef(r_weapon, isAlternate);
    if ( v16 )
    {
      WeaponClass = BG_GetWeaponClass(r_weapon, isAlternate);
      if ( isAlternate )
        inventoryType = 3;
      else
        inventoryType = v16->inventoryType;
      v19 = src;
      if ( !src )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7356, ASSERT_TYPE_ASSERT, "( baseWeaponName )", (const char *)&queryFormat, "baseWeaponName", *(_QWORD *)&toState.isValid, *(_QWORD *)&toState.arrayIndex, toState.member, toState.ddlDef) )
          __debugbreak();
        v19 = src;
      }
      Core_strcpy(dest, 0x400ui64, v19);
      if ( !inventoryType || inventoryType > 0 && inventoryType > 2 && inventoryType == 3 )
      {
        DDL_MoveToNameByHash(lifeState, &toState, weaponStringHash, NULL);
        DDL_SetEnum(&toState, buffer, dest);
        if ( (unsigned int)WeaponClass <= WEAPCLASS_ROCKETLAUNCHER || WeaponClass == WEAPCLASS_BEAM )
        {
          __asm { vpxor   xmm0, xmm0, xmm0 }
          fromState.isValid = 0;
          fromState.offset = 0;
          __asm { vmovdqu xmmword ptr [rsp+4C0h+fromState.member], xmm0 }
          fromState.arrayIndex = -1;
          DDL_MoveToNameByHash(lifeState, &toState, weaponAltModeHash, NULL);
          DDL_SetBool(&toState, buffer, isAlternate);
          if ( !DDL_MoveToNameByHash(lifeState, &fromState, attachmentsStringHash, NULL) )
            Scr_Error(COM_ERR_3175, scrContext, "Invalid match data definition specified. The attachments field must be an indexed array of enumerations");
          v21 = v27;
          for ( i = 0; i < v21; ++i )
          {
            ArrayVariable = GetArrayVariable(scrContext, attachmentsArrayId, i);
            if ( GetValueType(scrContext, ArrayVariable) != VAR_STRING )
              Scr_Error(COM_ERR_3176, scrContext, "All elements need to be strings.");
            VariableValueAddress = (scr_string_t *)GetVariableValueAddress(scrContext, ArrayVariable);
            RawHash = j_SL_GetRawHash(*VariableValueAddress);
            if ( !DDL_MoveToIndex(&fromState, &toState, i) )
              Scr_Error(COM_ERR_3177, scrContext, "Invalid match data definition specified. The attachments field must be an indexed array of enumerations");
            DDL_SetEnumByHash(&toState, buffer, RawHash);
            if ( ++v14 >= 6 )
              break;
          }
        }
      }
      else
      {
        DDL_MoveToNameByHash(lifeState, &toState, weaponStringHash, NULL);
        DDL_SetEnum(&toState, buffer, dest);
      }
    }
    else
    {
      DDL_MoveToNameByHash(lifeState, &toState, weaponStringHash, NULL);
      DDL_SetEnum(&toState, buffer, "none");
    }
  }
  else
  {
    DDL_MoveToNameByHash(lifeState, &toState, weaponStringHash, NULL);
    DDL_SetEnum(&toState, buffer, "destructible");
  }
}

/*
==============
LogMatchDataDeathWhileReloadingHelper
==============
*/
void LogMatchDataDeathWhileReloadingHelper(scrContext_t *scrContext, DDLState *lifeState, DDLContext *buffer, const gentity_s *victim)
{
  gclient_s *client; 
  int v11; 
  GWeaponMap *Instance; 
  bool v14; 
  PlayerHandIndex v15; 
  PlayerHandIndex v16; 
  int *p_weaponState; 
  unsigned int RawHash; 
  const Weapon *Weapon; 
  bool v20; 
  unsigned int v32; 
  WeaponSlot *p_slot; 
  BgWeaponHandle *weaponsEquipped; 
  const Weapon *v35; 
  unsigned int v37; 
  bool inAltMode; 
  __int64 v48; 
  __int64 v49; 
  DDLState toState; 

  __asm { vmovaps [rsp+0A8h+var_48], xmm6 }
  if ( !victim && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7248, ASSERT_TYPE_ASSERT, "( victim )", (const char *)&queryFormat, "victim") )
    __debugbreak();
  if ( !victim->client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7249, ASSERT_TYPE_ASSERT, "( victim->client )", (const char *)&queryFormat, "victim->client") )
    __debugbreak();
  client = victim->client;
  v11 = 0;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  toState.offset = 0;
  __asm { vmovdqu xmmword ptr [rsp+0A8h+toState.member], xmm0 }
  toState.isValid = 0;
  toState.arrayIndex = -1;
  Instance = GWeaponMap::GetInstance();
  if ( !Instance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 7256, ASSERT_TYPE_ASSERT, "( weaponMap )", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  v14 = 0;
  v15 = WEAPON_HAND_DEFAULT;
  v16 = WEAPON_HAND_DEFAULT;
  if ( BG_PlayerLastWeaponHand(Instance, &client->ps) >= WEAPON_HAND_DEFAULT )
  {
    p_weaponState = &client->ps.weapState[0].weaponState;
    while ( (unsigned int)(*p_weaponState - 18) > 3 )
    {
      ++v16;
      p_weaponState += 20;
      if ( v16 > BG_PlayerLastWeaponHand(Instance, &client->ps) )
        goto LABEL_16;
    }
    v14 = 1;
    v15 = v16;
  }
LABEL_16:
  RawHash = j_SL_GetRawHash(scr_const.diedWhileReloading);
  DDL_MoveToNameByHash(lifeState, &toState, RawHash, NULL);
  DDL_SetBool(&toState, buffer, v14);
  if ( !Instance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 885, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
    __debugbreak();
  if ( !client && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 886, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  Weapon = BgWeaponMap::GetWeapon(Instance, client->ps.weapCommon.weaponHandle);
  v20 = !GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&client->ps.weapCommon.weapFlags, ACTIVE, 0x22u) && (GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&client->ps.weapCommon.weapFlags, ACTIVE, 0x11u) || GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&client->ps.weapCommon.weapFlags, ACTIVE, 0x1Bu));
  BG_GetAmmoInClip(&client->ps, Weapon, v20, v15);
  if ( BG_GetClipSize(&client->ps, Weapon, v20) <= 0 )
  {
    __asm { vxorps  xmm2, xmm2, xmm2 }
  }
  else
  {
    __asm
    {
      vxorps  xmm1, xmm1, xmm1
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm1, xmm1, esi
      vcvtsi2ss xmm0, xmm0, eax
      vdivss  xmm2, xmm1, xmm0
    }
  }
  __asm
  {
    vmovss  xmm6, cs:__real@42c80000
    vmulss  xmm1, xmm2, xmm6
    vxorps  xmm0, xmm0, xmm0
    vroundss xmm0, xmm0, xmm1, 1; val
    vxorps  xmm1, xmm1, xmm1; min
    vmovaps xmm2, xmm6; max
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm { vcvttss2si ebx, xmm0 }
  v32 = j_SL_GetRawHash(scr_const.clipRemainingPercentCurrent);
  DDL_MoveToNameByHash(lifeState, &toState, v32, NULL);
  DDL_SetByte(&toState, buffer, _EBX);
  p_slot = &client->ps.weapEquippedData[0].slot;
  weaponsEquipped = client->ps.weaponsEquipped;
  while ( 1 )
  {
    if ( weaponsEquipped->m_mapEntryId )
    {
      if ( !Instance && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 839, ASSERT_TYPE_ASSERT, "(weaponMap)", (const char *)&queryFormat, "weaponMap") )
        __debugbreak();
      if ( (unsigned int)v11 >= 0xF )
      {
        LODWORD(v49) = 15;
        LODWORD(v48) = v11;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_weapons.h", 841, ASSERT_TYPE_ASSERT, "(unsigned)( equippedIndex ) < (unsigned)( 15 )", "equippedIndex doesn't index MAX_EQUIPPED_WEAPONS\n\t%i not in [0, %i)", v48, v49) )
          __debugbreak();
      }
      v35 = BgWeaponMap::GetWeapon(Instance, client->ps.weaponsEquipped[v11]);
      if ( memcmp_0(Weapon, v35, 0x3Cui64) )
      {
        if ( *p_slot == WEAPON_SLOT_PRIMARY )
          break;
      }
    }
    ++v11;
    ++weaponsEquipped;
    p_slot += 4;
    if ( v11 >= 15 )
    {
      LOBYTE(_EBX) = 0;
      goto LABEL_42;
    }
  }
  inAltMode = client->ps.weapEquippedData[v11].inAltMode;
  BG_GetAmmoInClip(&client->ps, v35, inAltMode, WEAPON_HAND_DEFAULT);
  if ( BG_GetClipSize(&client->ps, v35, inAltMode) <= 0 )
  {
    __asm { vxorps  xmm2, xmm2, xmm2 }
  }
  else
  {
    __asm
    {
      vxorps  xmm1, xmm1, xmm1
      vxorps  xmm0, xmm0, xmm0
      vcvtsi2ss xmm1, xmm1, edi
      vcvtsi2ss xmm0, xmm0, eax
      vdivss  xmm2, xmm1, xmm0
    }
  }
  __asm
  {
    vmulss  xmm3, xmm2, xmm6
    vxorps  xmm0, xmm0, xmm0
    vroundss xmm0, xmm0, xmm3, 1; val
    vmovaps xmm2, xmm6; max
    vxorps  xmm1, xmm1, xmm1; min
  }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm { vcvttss2si ebx, xmm0 }
LABEL_42:
  v37 = j_SL_GetRawHash(scr_const.clipRemainingPercentOther);
  DDL_MoveToNameByHash(lifeState, &toState, v37, NULL);
  DDL_SetByte(&toState, buffer, _EBX);
  __asm { vmovaps xmm6, [rsp+0A8h+var_48] }
}

/*
==============
NormalizePosition
==============
*/
void NormalizePosition(scrContext_t *scrContext, const vec3_t *position, vec2_t *result)
{
  __asm { vmovaps [rsp+58h+var_18], xmm6 }
  _RDI = result;
  __asm { vmovaps [rsp+58h+var_28], xmm7 }
  _RBX = position;
  __asm
  {
    vmovaps [rsp+58h+var_38], xmm8
    vmovss  xmm8, dword ptr cs:?level@@3Ulevel_locals_t@@A.compassMapWorldSize; level_locals_t level
    vxorps  xmm0, xmm0, xmm0
    vcomiss xmm8, xmm0
    vmovss  xmm5, dword ptr cs:?level@@3Ulevel_locals_t@@A.compassMapWorldSize+4; level_locals_t level
    vcomiss xmm5, xmm0
    vmovss  xmm0, dword ptr [rbx]
    vsubss  xmm4, xmm0, dword ptr cs:?level@@3Ulevel_locals_t@@A.compassMapUpperLeft; level_locals_t level
    vmovss  xmm1, dword ptr [rbx+4]
    vsubss  xmm3, xmm1, dword ptr cs:?level@@3Ulevel_locals_t@@A.compassMapUpperLeft+4; level_locals_t level
    vmulss  xmm1, xmm3, dword ptr cs:?level@@3Ulevel_locals_t@@A.compassNorth; level_locals_t level
    vmulss  xmm7, xmm3, dword ptr cs:?level@@3Ulevel_locals_t@@A.compassNorth+4; level_locals_t level
    vmulss  xmm2, xmm4, dword ptr cs:?level@@3Ulevel_locals_t@@A.compassNorth+4; level_locals_t level
    vmulss  xmm6, xmm4, dword ptr cs:?level@@3Ulevel_locals_t@@A.compassNorth; level_locals_t level
    vmovss  xmm0, cs:__real@3f800000
    vdivss  xmm5, xmm0, xmm5
    vsubss  xmm0, xmm2, xmm1
    vdivss  xmm3, xmm0, xmm8
    vmulss  xmm1, xmm3, cs:__real@437f0000
    vxorps  xmm0, xmm7, cs:__xmm@80000000800000008000000080000000
    vmovaps xmm7, [rsp+58h+var_28]
    vmovaps xmm8, [rsp+58h+var_38]
    vsubss  xmm2, xmm0, xmm6
    vmovaps xmm6, [rsp+58h+var_18]
    vmovss  dword ptr [rdi], xmm1
    vmulss  xmm1, xmm2, xmm5
    vmulss  xmm3, xmm1, cs:__real@437f0000
    vmovss  dword ptr [rdi+4], xmm3
  }
}

/*
==============
ScrCmd_PlaySoundAtPosInternal
==============
*/
gentity_s *ScrCmd_PlaySoundAtPosInternal(scrContext_t *scrContext, const vec3_t *pos, const char *soundName)
{
  const SndAliasList *Alias; 
  const char *v7; 
  const char *v8; 
  unsigned __int16 v9; 
  const char *v10; 
  gentity_s *result; 

  Alias = SND_FindAlias(soundName);
  if ( !Alias )
  {
    v7 = j_va("unknown sound alias '%s'", soundName);
    Scr_ParamError(COM_ERR_2997, scrContext, 0, v7);
  }
  if ( Com_IsSoundAliasLooping(Alias) )
  {
    v8 = j_va("'%s' is a looping alias, use 'playloopsound' instead", soundName);
    Scr_ParamError(COM_ERR_2998, scrContext, 0, v8);
  }
  v9 = G_CStringMP_SoundAliasIndex(soundName);
  if ( (unsigned __int16)(v9 - 1) > 0x7FFFu )
  {
    v10 = j_va("'%s' does has not have a valid index (%i)", soundName, v9);
    Scr_ParamError(COM_ERR_2999, scrContext, 0, v10);
  }
  result = G_Utils_SpawnEventEntity(pos, 3);
  result->s.eventParm2 = 0;
  result->s.eventParm = v9;
  return result;
}

/*
==============
Scr_AgentAdded
==============
*/
void Scr_AgentAdded(gentity_s *self)
{
  GameScriptDataMP *GameScriptDataMP; 
  scrContext_t *v3; 
  unsigned int v4; 

  GameScriptDataMP = GameScriptDataMP::GetGameScriptDataMP();
  v3 = ScriptContext_Server();
  v4 = GScr_ExecEntThread(self, GameScriptDataMP->agentAdded, 0);
  Scr_FreeThread(v3, v4);
}

/*
==============
Scr_AgentDamage
==============
*/
void Scr_AgentDamage(gentity_s *self, const gentity_s *inflictor, gentity_s *attacker, int damage, int dflags, int meansOfDeath, const Weapon *r_weapon, bool isAlternate, const vec3_t *vPoint, const vec3_t *vDir, const hitLocation_t hitLoc, int timeOffset, int modelIndex, scr_string_t partName)
{
  scrContext_t *v18; 
  scrContext_t *v19; 
  scr_string_t HitLocationString; 
  scrContext_t *v21; 
  scrContext_t *v22; 
  GameScriptDataMP *GameScriptDataMP; 
  unsigned int v24; 

  v18 = ScriptContext_Server();
  v19 = v18;
  if ( partName )
    Scr_AddConstString(v18, partName);
  else
    Scr_AddUndefined(v18);
  Scr_AddInt(v19, modelIndex);
  Scr_AddInt(v19, timeOffset);
  HitLocationString = G_Combat_GetHitLocationString(hitLoc);
  Scr_AddConstString(v19, HitLocationString);
  if ( vDir )
    Scr_AddVector(v19, vDir->v);
  else
    Scr_AddUndefined(v19);
  if ( vPoint )
    Scr_AddVector(v19, vPoint->v);
  else
    Scr_AddUndefined(v19);
  GScr_Weapon_AddParam(v19, r_weapon, isAlternate);
  if ( (unsigned int)meansOfDeath > 0x18 )
    Scr_AddString(v19, "badMOD");
  else
    Scr_AddConstString(v19, *g_combat_modNames[meansOfDeath]);
  Scr_AddInt(v19, dflags);
  Scr_AddInt(v19, damage);
  v21 = ScriptContext_Server();
  if ( attacker )
    GScr_AddEntity(attacker);
  else
    Scr_AddUndefined(v21);
  v22 = ScriptContext_Server();
  if ( inflictor )
    GScr_AddEntity(inflictor);
  else
    Scr_AddUndefined(v22);
  GameScriptDataMP = GameScriptDataMP::GetGameScriptDataMP();
  v24 = GScr_ExecEntThread(self, GameScriptDataMP->agentDamaged, 0xCu);
  Scr_FreeThread(v19, v24);
}

/*
==============
Scr_AgentGameTypeMain
==============
*/
void Scr_AgentGameTypeMain(void)
{
  GameScriptDataMP *GameScriptDataMP; 
  scrContext_t *v1; 
  unsigned int v2; 

  GameScriptDataMP = GameScriptDataMP::GetGameScriptDataMP();
  if ( GameScriptDataMP->agentGameTypeMain )
  {
    v1 = ScriptContext_Server();
    v2 = Scr_ExecThread(v1, GameScriptDataMP->agentGameTypeMain, 0);
    Scr_FreeThread(v1, v2);
  }
}

/*
==============
Scr_AgentKilled
==============
*/
void Scr_AgentKilled(gentity_s *self, const gentity_s *inflictor, gentity_s *attacker, int damage, int damageFlags, int meansOfDeath, const Weapon *r_weapon, bool isAlternate, const vec3_t *vDir, const hitLocation_t hitLoc, int psTimeOffset, int deathAnimDuration)
{
  scrContext_t *v16; 
  scr_string_t HitLocationString; 
  scrContext_t *v18; 
  scrContext_t *v19; 
  GameScriptDataMP *GameScriptDataMP; 
  unsigned int v21; 

  v16 = ScriptContext_Server();
  Scr_AddInt(v16, deathAnimDuration);
  Scr_AddInt(v16, psTimeOffset);
  HitLocationString = G_Combat_GetHitLocationString(hitLoc);
  Scr_AddConstString(v16, HitLocationString);
  if ( vDir )
    Scr_AddVector(v16, vDir->v);
  else
    Scr_AddUndefined(v16);
  GScr_Weapon_AddParam(v16, r_weapon, isAlternate);
  if ( (unsigned int)meansOfDeath > 0x18 )
    Scr_AddString(v16, "badMOD");
  else
    Scr_AddConstString(v16, *g_combat_modNames[meansOfDeath]);
  Scr_AddInt(v16, damageFlags);
  Scr_AddInt(v16, damage);
  v18 = ScriptContext_Server();
  if ( attacker )
    GScr_AddEntity(attacker);
  else
    Scr_AddUndefined(v18);
  v19 = ScriptContext_Server();
  if ( inflictor )
    GScr_AddEntity(inflictor);
  else
    Scr_AddUndefined(v19);
  GameScriptDataMP = GameScriptDataMP::GetGameScriptDataMP();
  v21 = GScr_ExecEntThread(self, GameScriptDataMP->agentKilled, 0xAu);
  Scr_FreeThread(v16, v21);
}

/*
==============
Scr_AgentMain
==============
*/
void Scr_AgentMain(void)
{
  GameScriptDataMP *GameScriptDataMP; 
  scrContext_t *v1; 
  unsigned int v2; 

  GameScriptDataMP = GameScriptDataMP::GetGameScriptDataMP();
  if ( !GameScriptDataMP->agentMain && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 12685, ASSERT_TYPE_ASSERT, "(gScrData->agentMain)", (const char *)&queryFormat, "gScrData->agentMain") )
    __debugbreak();
  v1 = ScriptContext_Server();
  v2 = Scr_ExecThread(v1, GameScriptDataMP->agentMain, 0);
  Scr_FreeThread(v1, v2);
}

/*
==============
Scr_BotGameTypeMain
==============
*/
void Scr_BotGameTypeMain(void)
{
  GameScriptDataMP *GameScriptDataMP; 
  scrContext_t *v1; 
  unsigned int v2; 

  GameScriptDataMP = GameScriptDataMP::GetGameScriptDataMP();
  if ( GameScriptDataMP->botGameTypeMain )
  {
    v1 = ScriptContext_Server();
    v2 = Scr_ExecThread(v1, GameScriptDataMP->botGameTypeMain, 0);
    Scr_FreeThread(v1, v2);
  }
}

/*
==============
Scr_BotMain
==============
*/
void Scr_BotMain(void)
{
  GameScriptDataMP *GameScriptDataMP; 
  scrContext_t *v1; 
  unsigned int v2; 

  GameScriptDataMP = GameScriptDataMP::GetGameScriptDataMP();
  if ( !GameScriptDataMP->botMain && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 12659, ASSERT_TYPE_ASSERT, "(gScrData->botMain)", (const char *)&queryFormat, "gScrData->botMain") )
    __debugbreak();
  v1 = ScriptContext_Server();
  v2 = Scr_ExecThread(v1, GameScriptDataMP->botMain, 0);
  Scr_FreeThread(v1, v2);
}

/*
==============
Scr_HostMigration
==============
*/
void Scr_HostMigration(void)
{
  GameScriptDataMP *GameScriptDataMP; 
  scrContext_t *v1; 
  unsigned int v2; 

  GameScriptDataMP = GameScriptDataMP::GetGameScriptDataMP();
  v1 = ScriptContext_Server();
  v2 = Scr_ExecThread(v1, GameScriptDataMP->gametype.hostmigration, 0);
  Scr_FreeThread(v1, v2);
}

/*
==============
Scr_LeaderDialog
==============
*/
void Scr_LeaderDialog(gentity_s *self, const scr_string_t dialog, const vec3_t *location)
{
  GameScriptDataMP *GameScriptDataMP; 
  scrContext_t *v7; 
  unsigned int v8; 

  GameScriptDataMP = GameScriptDataMP::GetGameScriptDataMP();
  if ( GameScriptDataMP->leaderDialog )
  {
    v7 = ScriptContext_Server();
    Scr_AddVector(v7, location->v);
    Scr_AddConstString(v7, dialog);
    v8 = GScr_ExecEntThread(self, GameScriptDataMP->leaderDialog, 2u);
    Scr_FreeThread(v7, v8);
  }
}

/*
==============
Scr_LoadGameType
==============
*/
void Scr_LoadGameType(void)
{
  const dvar_t *v0; 
  GameScriptDataMP *GameScriptDataMP; 
  scrContext_t *v2; 
  unsigned int v3; 

  v0 = DVARBOOL_bot_spawnControlledByDvar;
  if ( !DVARBOOL_bot_spawnControlledByDvar && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar_api.h", 759, ASSERT_TYPE_ASSERT, "( dvar )", "Dvar accessed after deregistration") )
    __debugbreak();
  Dvar_Reset(v0, DVAR_SOURCE_INTERNAL);
  level.teammode = TEAMMODE_AXIS_ALLIES;
  GameScriptDataMP = GameScriptDataMP::GetGameScriptDataMP();
  if ( !GameScriptDataMP && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 12645, ASSERT_TYPE_ASSERT, "(gScrData)", (const char *)&queryFormat, "gScrData") )
    __debugbreak();
  if ( !GameScriptDataMP->gametype.main && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 12646, ASSERT_TYPE_ASSERT, "(gScrData->gametype.main != 0)", (const char *)&queryFormat, "gScrData->gametype.main != 0") )
    __debugbreak();
  v2 = ScriptContext_Server();
  v3 = Scr_ExecThread(v2, GameScriptDataMP->gametype.main, 0);
  Scr_FreeThread(v2, v3);
}

/*
==============
Scr_LoadRead
==============
*/
void *Scr_LoadRead(int len)
{
  return 0i64;
}

/*
==============
Scr_PlayerActive
==============
*/
void Scr_PlayerActive(gentity_s *self)
{
  int playeractive; 
  scrContext_t *v3; 
  unsigned int v4; 

  playeractive = GameScriptDataMP::GetGameScriptDataMP()->gametype.playeractive;
  v3 = ScriptContext_Server();
  v4 = GScr_ExecEntThread(self, playeractive, 0);
  Scr_FreeThread(v3, v4);
}

/*
==============
Scr_PlayerConnect
==============
*/
void Scr_PlayerConnect(gentity_s *self)
{
  int playerconnect; 
  scrContext_t *v3; 
  unsigned int v4; 

  playerconnect = GameScriptDataMP::GetGameScriptDataMP()->gametype.playerconnect;
  v3 = ScriptContext_Server();
  v4 = GScr_ExecEntThread(self, playerconnect, 0);
  Scr_FreeThread(v3, v4);
}

/*
==============
Scr_PlayerDamage
==============
*/
void Scr_PlayerDamage(gentity_s *self, const gentity_s *inflictor, gentity_s *attacker, int damage, int dflags, int meansOfDeath, const Weapon *r_weapon, bool isAlternate, const vec3_t *vPoint, const vec3_t *vDir, const hitLocation_t hitLoc, int timeOffset, int modelIndex, scr_string_t partName, const GExtraDamageParams *extraParams, int unscaledDamage)
{
  scrContext_t *v20; 
  scr_string_t HitLocationString; 
  scrContext_t *v22; 
  scrContext_t *v23; 
  GameScriptDataMP *GameScriptDataMP; 
  unsigned int v25; 

  v20 = ScriptContext_Server();
  Scr_AddInt(v20, unscaledDamage);
  Scr_AddBool(v20, extraParams->m_isHitScanBulletDamage);
  if ( partName )
    Scr_AddConstString(v20, partName);
  else
    Scr_AddUndefined(v20);
  Scr_AddInt(v20, modelIndex);
  Scr_AddInt(v20, timeOffset);
  HitLocationString = G_Combat_GetHitLocationString(hitLoc);
  Scr_AddConstString(v20, HitLocationString);
  if ( vDir )
    Scr_AddVector(v20, vDir->v);
  else
    Scr_AddUndefined(v20);
  if ( vPoint )
    Scr_AddVector(v20, vPoint->v);
  else
    Scr_AddUndefined(v20);
  GScr_Weapon_AddParam(v20, r_weapon, isAlternate);
  if ( (unsigned int)meansOfDeath > 0x18 )
    Scr_AddString(v20, "badMOD");
  else
    Scr_AddConstString(v20, *g_combat_modNames[meansOfDeath]);
  Scr_AddInt(v20, dflags);
  Scr_AddInt(v20, damage);
  v22 = ScriptContext_Server();
  if ( attacker )
    GScr_AddEntity(attacker);
  else
    Scr_AddUndefined(v22);
  v23 = ScriptContext_Server();
  if ( inflictor )
    GScr_AddEntity(inflictor);
  else
    Scr_AddUndefined(v23);
  GameScriptDataMP = GameScriptDataMP::GetGameScriptDataMP();
  v25 = GScr_ExecEntThread(self, GameScriptDataMP->gametype.playerdamage, 0xEu);
  Scr_FreeThread(v20, v25);
}

/*
==============
Scr_PlayerDisconnect
==============
*/
void Scr_PlayerDisconnect(gentity_s *self, const char *reason)
{
  scrContext_t *v4; 
  char *v5; 
  GameScriptDataMP *GameScriptDataMP; 
  unsigned int v7; 
  char dest[32]; 

  v4 = ScriptContext_Server();
  if ( reason )
  {
    Core_strcpy_truncate(dest, 0x1Aui64, reason);
    v5 = dest;
  }
  else
  {
    v5 = "NULL";
  }
  Scr_AddString(v4, v5);
  GameScriptDataMP = GameScriptDataMP::GetGameScriptDataMP();
  v7 = GScr_ExecEntThread(self, GameScriptDataMP->gametype.playerdisconnect, 1u);
  Scr_FreeThread(v4, v7);
}

/*
==============
Scr_PlayerKilled
==============
*/
void Scr_PlayerKilled(gentity_s *self, const gentity_s *inflictor, gentity_s *attacker, int damage, int damageFlags, int meansOfDeath, const Weapon *r_weapon, bool isAlternate, const vec3_t *vDir, const hitLocation_t hitLoc, int psTimeOffset, int deathAnimDuration)
{
  scrContext_t *v16; 
  scr_string_t HitLocationString; 
  scrContext_t *v18; 
  scrContext_t *v19; 
  GameScriptDataMP *GameScriptDataMP; 
  unsigned int v21; 

  v16 = ScriptContext_Server();
  Scr_AddInt(v16, deathAnimDuration);
  Scr_AddInt(v16, psTimeOffset);
  HitLocationString = G_Combat_GetHitLocationString(hitLoc);
  Scr_AddConstString(v16, HitLocationString);
  if ( vDir )
    Scr_AddVector(v16, vDir->v);
  else
    Scr_AddUndefined(v16);
  GScr_Weapon_AddParam(v16, r_weapon, isAlternate);
  if ( (unsigned int)meansOfDeath > 0x18 )
    Scr_AddString(v16, "badMOD");
  else
    Scr_AddConstString(v16, *g_combat_modNames[meansOfDeath]);
  Scr_AddInt(v16, damageFlags);
  Scr_AddInt(v16, damage);
  v18 = ScriptContext_Server();
  if ( attacker )
    GScr_AddEntity(attacker);
  else
    Scr_AddUndefined(v18);
  v19 = ScriptContext_Server();
  if ( inflictor )
    GScr_AddEntity(inflictor);
  else
    Scr_AddUndefined(v19);
  GameScriptDataMP = GameScriptDataMP::GetGameScriptDataMP();
  v21 = GScr_ExecEntThread(self, GameScriptDataMP->gametype.playerkilled, 0xAu);
  Scr_FreeThread(v16, v21);
}

/*
==============
Scr_PlayerLastStand
==============
*/
bool Scr_PlayerLastStand(gentity_s *self, gentity_s *inflictor, gentity_s *attacker, int damage, int meansOfDeath, const Weapon *r_weapon, bool isAlternate, const vec3_t *vDir, const hitLocation_t hitLoc, int psTimeOffset)
{
  scrContext_t *v14; 
  scr_string_t HitLocationString; 
  scrContext_t *v16; 
  scrContext_t *v17; 
  GameScriptDataMP *GameScriptDataMP; 
  unsigned int v19; 
  int outReturnValue; 

  v14 = ScriptContext_Server();
  Scr_AddInt(v14, 0);
  Scr_AddInt(v14, psTimeOffset);
  HitLocationString = G_Combat_GetHitLocationString(hitLoc);
  Scr_AddConstString(v14, HitLocationString);
  Scr_AddVector(v14, vDir->v);
  GScr_Weapon_AddParam(v14, r_weapon, isAlternate);
  if ( (unsigned int)meansOfDeath > 0x18 )
    Scr_AddString(v14, "badMOD");
  else
    Scr_AddConstString(v14, *g_combat_modNames[meansOfDeath]);
  Scr_AddInt(v14, damage);
  v16 = ScriptContext_Server();
  if ( attacker )
    GScr_AddEntity(attacker);
  else
    Scr_AddUndefined(v16);
  v17 = ScriptContext_Server();
  if ( inflictor )
    GScr_AddEntity(inflictor);
  else
    Scr_AddUndefined(v17);
  GameScriptDataMP = GameScriptDataMP::GetGameScriptDataMP();
  v19 = GScr_ExecEntThreadWithReturnValue(self, GameScriptDataMP->gametype.playerlaststand, 9u, Scr_ExecThreadCallback_Unsigned, NULL, &outReturnValue);
  Scr_FreeThread(v14, v19);
  return outReturnValue != 0;
}

/*
==============
Scr_PlayerMigrated
==============
*/
void Scr_PlayerMigrated(gentity_s *self)
{
  GameScriptDataMP *GameScriptDataMP; 
  scrContext_t *v3; 
  unsigned int v4; 

  GameScriptDataMP = GameScriptDataMP::GetGameScriptDataMP();
  v3 = ScriptContext_Server();
  v4 = GScr_ExecEntThread(self, GameScriptDataMP->gametype.playermigrated, 0);
  Scr_FreeThread(v3, v4);
}

/*
==============
Scr_PlayerVote
==============
*/
void Scr_PlayerVote(gentity_s *self, char *option)
{
  scrContext_t *v4; 

  v4 = ScriptContext_Server();
  Scr_AddString(v4, option);
  GScr_Notify(self, scr_const.vote, 1u);
}

/*
==============
Scr_SpawnFXInternal
==============
*/
gentity_s *Scr_SpawnFXInternal(scrContext_t *scrContext, int fxId, const vec3_t *pos, int givenAxisCount, tmat33_t<vec3_t> *axis)
{
  gentity_s *v9; 
  __int64 v11; 
  int v12; 
  int v13; 

  if ( fxId <= 0 )
    goto LABEL_17;
  if ( !BgDynamicLimits::IsValidGameMode() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_dynamic_limits.h", 98, ASSERT_TYPE_ASSERT, "(IsValidGameMode())", "%s\n\tAccessing BgDynamicLimits during invalid game mode", "IsValidGameMode()") )
    __debugbreak();
  if ( fxId >= BgDynamicLimits::ms_data.m_effectNamesCount )
  {
LABEL_17:
    if ( !BgDynamicLimits::IsValidGameMode() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_dynamic_limits.h", 98, ASSERT_TYPE_ASSERT, "(IsValidGameMode())", "%s\n\tAccessing BgDynamicLimits during invalid game mode", "IsValidGameMode()") )
      __debugbreak();
    v13 = BgDynamicLimits::ms_data.m_effectNamesCount - 1;
    v12 = fxId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 10635, ASSERT_TYPE_ASSERT, "(FX_IsValidFxId( fxId ))", "%s\n\tInvalid fxId %d. Max effect ID is %d", "FX_IsValidFxId( fxId )", v12, v13) )
      __debugbreak();
  }
  Sys_ProfBeginNamedEvent(0xFFFF0000, "Scr_SpawnFXInternal");
  v9 = G_Utils_SpawnEntity();
  v9->s.eType = ET_FX;
  v9->s.staticState.general.xmodel = fxId;
  G_SetOrigin(v9, pos, 1, 1);
  Scr_SetFxAngles(scrContext, givenAxisCount, axis, &v9->s.lerp.apos.trBase, fxId);
  if ( v9->s.time2 )
  {
    LODWORD(v11) = v9->s.time2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 10646, ASSERT_TYPE_SANITY, "( ( ent->s.time2 == 0 ) )", "( ent->s.time2 ) = %i", v11) )
      __debugbreak();
  }
  SV_LinkEntity(v9);
  Sys_ProfEndNamedEvent();
  return v9;
}

/*
==============
Scr_StartupGameType
==============
*/
void Scr_StartupGameType(void)
{
  GameScriptDataMP *GameScriptDataMP; 
  scrContext_t *v1; 
  unsigned int v2; 

  GameScriptDataMP = GameScriptDataMP::GetGameScriptDataMP();
  if ( !GameScriptDataMP->gametype.startupgametype && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 12815, ASSERT_TYPE_ASSERT, "(gScrData->gametype.startupgametype != 0)", (const char *)&queryFormat, "gScrData->gametype.startupgametype != 0") )
    __debugbreak();
  v1 = ScriptContext_Server();
  v2 = Scr_ExecThread(v1, GameScriptDataMP->gametype.startupgametype, 0);
  Scr_FreeThread(v1, v2);
}

/*
==============
Scr_VisionSetForPlayer_Internal
==============
*/
void Scr_VisionSetForPlayer_Internal(scrContext_t *scrContext, scr_entref_t entref, visionSetMode_t visMode)
{
  __int64 v5; 
  unsigned int entnum; 
  gentity_s *v8; 
  const char *v9; 
  int number; 
  const char *v11; 
  unsigned int v13; 
  scr_string_t ConstLowercaseString; 
  const char *v21; 
  const char *v22; 
  const char *v23; 
  const char *v24; 
  const char *v25; 
  SvClient *CommonClient; 
  int outControllingClientNum[10]; 
  unsigned int outVisionSetIndex; 

  v5 = visMode;
  entnum = entref.entnum;
  if ( entref.entclass )
  {
    Scr_ObjectError(COM_ERR_3678, scrContext, "not an entity");
    v8 = NULL;
  }
  else
  {
    if ( entref.entnum >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5031, ASSERT_TYPE_ASSERT, "(entref.entnum < ( 2048 ))", (const char *)&queryFormat, "entref.entnum < MAX_GENTITIES") )
      __debugbreak();
    v8 = &g_entities[entnum];
    if ( !v8->client && !v8->agent )
    {
      v9 = j_va("entity %i is not a player or agent", entnum);
      Scr_ObjectError(COM_ERR_3677, scrContext, v9);
    }
  }
  number = v8->s.number;
  outControllingClientNum[0] = number;
  if ( SV_IsAgent(number) && !SV_GetAgentControlledByPlayerNum(outControllingClientNum[0], outControllingClientNum) )
  {
    v11 = j_va("entity %i is not a player or player-controlled agent", entnum);
    Scr_ObjectError(COM_ERR_3095, scrContext, v11);
    return;
  }
  _ESI = 1000;
  v13 = Scr_GetNumParam(scrContext) - 1;
  if ( v13 )
  {
    if ( v13 != 1 )
    {
      Scr_Error(COM_ERR_3096, scrContext, "USAGE: <player> VisionSetForPlayer( <visionset name>, <transition time> )\n");
      return;
    }
    *(double *)&_XMM0 = Scr_GetFloat(scrContext, 1u);
    __asm
    {
      vmulss  xmm1, xmm0, cs:__real@447a0000
      vaddss  xmm3, xmm1, cs:__real@3f000000
      vxorps  xmm2, xmm2, xmm2
      vmovss  xmm4, xmm2, xmm3
      vxorps  xmm0, xmm0, xmm0
      vroundss xmm1, xmm0, xmm4, 1
      vcvttss2si esi, xmm1
    }
  }
  ConstLowercaseString = Scr_GetConstLowercaseString(scrContext, 0);
  v21 = SL_ConvertToString(ConstLowercaseString);
  v22 = v21;
  if ( *v21 )
  {
    if ( !NetConstStrings_GetVisionSetIndex(v21, &outVisionSetIndex) )
    {
      v23 = j_va("visionset %s has not been precached, include with precache_vision", v22);
      Scr_Error(COM_ERR_3097, scrContext, v23);
    }
    if ( !outVisionSetIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game_mp\\g_scr_main_mp.cpp", 5066, ASSERT_TYPE_ASSERT, "( visionIndex != 0 )", (const char *)&queryFormat, "visionIndex != 0") )
      __debugbreak();
  }
  else
  {
    outVisionSetIndex = 0;
  }
  v24 = j_va("%c %d %i", (unsigned int)MY_CMDS[v5], outVisionSetIndex, _ESI);
  v25 = v24;
  if ( outControllingClientNum[0] == -1 )
  {
    SV_Game_BroadcastServerCommand(SV_CMD_RELIABLE, v24);
  }
  else
  {
    CommonClient = SvClient::GetCommonClient(outControllingClientNum[0]);
    CommonClient->SendServerCommand(CommonClient, SV_CMD_RELIABLE, v25);
  }
}

/*
==============
Scr_VoteCalled
==============
*/
void Scr_VoteCalled(gentity_s *self, char *command, char *param1, char *param2)
{
  scrContext_t *v8; 

  v8 = ScriptContext_Server();
  Scr_AddString(v8, param2);
  Scr_AddString(v8, param1);
  Scr_AddString(v8, command);
  GScr_Notify(self, scr_const.call_vote, 3u);
}

