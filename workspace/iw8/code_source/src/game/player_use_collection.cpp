/*
==============
UsableEntityDenseGrid_Allocate
==============
*/

void __fastcall UsableEntityDenseGrid_Allocate(HunkUser *hunkUser)
{
  ?UsableEntityDenseGrid_Allocate@@YAXPEAUHunkUser@@@Z(hunkUser);
}

/*
==============
UsableScriptableDenseGrid_Read
==============
*/

void __fastcall UsableScriptableDenseGrid_Read(MemoryFile *memFile)
{
  ?UsableScriptableDenseGrid_Read@@YAXPEAUMemoryFile@@@Z(memFile);
}

/*
==============
PlayerUseDataMap_Get
==============
*/

PlayerUseDataMap *__fastcall PlayerUseDataMap_Get()
{
  return ?PlayerUseDataMap_Get@@YAPEAUPlayerUseDataMap@@XZ();
}

/*
==============
PlayerUseDataMap_GetAllocationSize
==============
*/

unsigned int __fastcall PlayerUseDataMap_GetAllocationSize()
{
  return ?PlayerUseDataMap_GetAllocationSize@@YAIXZ();
}

/*
==============
PlayerUseDataMap_InitPlayerData_Scriptable::InitPlayerUseData
==============
*/

void __fastcall PlayerUseDataMap_InitPlayerData_Scriptable::InitPlayerUseData(PlayerUseDataMap_InitPlayerData_Scriptable *this, PlayerUseData *const outPlayerUseData)
{
  ?InitPlayerUseData@PlayerUseDataMap_InitPlayerData_Scriptable@@QEBAXQEAUPlayerUseData@@@Z(this, outPlayerUseData);
}

/*
==============
UsableWorld_InitLimits
==============
*/

void UsableWorld_InitLimits(void)
{
  ?UsableWorld_InitLimits@@YAXXZ();
}

/*
==============
UsableClientMaskCollection_Free
==============
*/

void UsableClientMaskCollection_Free(void)
{
  ?UsableClientMaskCollection_Free@@YAXXZ();
}

/*
==============
UsableEntityDenseGrid_GetAllocationSize
==============
*/

unsigned int __fastcall UsableEntityDenseGrid_GetAllocationSize()
{
  return ?UsableEntityDenseGrid_GetAllocationSize@@YAIXZ();
}

/*
==============
UsableScriptableDenseGrid_Get
==============
*/

DenseGrid *__fastcall UsableScriptableDenseGrid_Get()
{
  return ?UsableScriptableDenseGrid_Get@@YAAEAVDenseGrid@@XZ();
}

/*
==============
PlayerUseDataMap_GetEntityData
==============
*/

const PlayerUseData *__fastcall PlayerUseDataMap_GetEntityData(PlayerUseDataMap *const map, const unsigned int *key, const gentity_s *const ent)
{
  return ?PlayerUseDataMap_GetEntityData@@YAPEBUPlayerUseData@@QEAUPlayerUseDataMap@@AEBIQEBUgentity_s@@@Z(map, key, ent);
}

/*
==============
UsableScriptableDenseGrid_Write
==============
*/

void __fastcall UsableScriptableDenseGrid_Write(MemoryFile *memFile)
{
  ?UsableScriptableDenseGrid_Write@@YAXPEAUMemoryFile@@@Z(memFile);
}

/*
==============
UsableEntityDenseGrid_Write
==============
*/

void __fastcall UsableEntityDenseGrid_Write(MemoryFile *memFile)
{
  ?UsableEntityDenseGrid_Write@@YAXPEAUMemoryFile@@@Z(memFile);
}

/*
==============
UsableWorldCollection_Free
==============
*/

void UsableWorldCollection_Free(void)
{
  ?UsableWorldCollection_Free@@YAXXZ();
}

/*
==============
UsableClientMaskCollection_GetAllocationSize
==============
*/

unsigned int __fastcall UsableClientMaskCollection_GetAllocationSize()
{
  return ?UsableClientMaskCollection_GetAllocationSize@@YAIXZ();
}

/*
==============
UsableWorldCollection_Allocate
==============
*/

void __fastcall UsableWorldCollection_Allocate(HunkUser *hunkUser)
{
  ?UsableWorldCollection_Allocate@@YAXPEAUHunkUser@@@Z(hunkUser);
}

/*
==============
UsableScriptableDenseGrid_Allocate
==============
*/

void __fastcall UsableScriptableDenseGrid_Allocate(HunkUser *hunkUser)
{
  ?UsableScriptableDenseGrid_Allocate@@YAXPEAUHunkUser@@@Z(hunkUser);
}

/*
==============
UsableClientMaskCollection_Get
==============
*/

ntl::vector_map<unsigned int,ClientBits,NtlHunkUserAllocator<ntl::pair<unsigned int,ClientBits> >,ntl::less<unsigned int,unsigned int> > *__fastcall UsableClientMaskCollection_Get()
{
  return ?UsableClientMaskCollection_Get@@YAPEAV?$vector_map@IUClientBits@@V?$NtlHunkUserAllocator@U?$pair@IUClientBits@@@ntl@@@@U?$less@II@ntl@@@ntl@@XZ();
}

/*
==============
UsableWorld_SetLootHidden
==============
*/

void __fastcall UsableWorld_SetLootHidden(bool hidden)
{
  ?UsableWorld_SetLootHidden@@YAX_N@Z(hidden);
}

/*
==============
PlayerUseDataMap_Free
==============
*/

void PlayerUseDataMap_Free(void)
{
  ?PlayerUseDataMap_Free@@YAXXZ();
}

/*
==============
UsableWorldCollection_GetAllocationSize
==============
*/

unsigned int __fastcall UsableWorldCollection_GetAllocationSize()
{
  return ?UsableWorldCollection_GetAllocationSize@@YAIXZ();
}

/*
==============
UsableWorld_GetUsableLimit
==============
*/

unsigned int __fastcall UsableWorld_GetUsableLimit()
{
  return ?UsableWorld_GetUsableLimit@@YAIXZ();
}

/*
==============
UsableScriptableDenseGrid_Free
==============
*/

void UsableScriptableDenseGrid_Free(void)
{
  ?UsableScriptableDenseGrid_Free@@YAXXZ();
}

/*
==============
UsableScriptableDenseGrid_GetAllocationSize
==============
*/

unsigned int __fastcall UsableScriptableDenseGrid_GetAllocationSize()
{
  return ?UsableScriptableDenseGrid_GetAllocationSize@@YAIXZ();
}

/*
==============
UsableEntityDenseGrid_Read
==============
*/

void __fastcall UsableEntityDenseGrid_Read(MemoryFile *memFile)
{
  ?UsableEntityDenseGrid_Read@@YAXPEAUMemoryFile@@@Z(memFile);
}

/*
==============
PlayerUseDataMap_GetScriptableData
==============
*/

const PlayerUseData *__fastcall PlayerUseDataMap_GetScriptableData(PlayerUseDataMap *const map, const unsigned int *key, const UsableRef *ref)
{
  return ?PlayerUseDataMap_GetScriptableData@@YAPEBUPlayerUseData@@QEAUPlayerUseDataMap@@AEBIAEBUUsableRef@@@Z(map, key, ref);
}

/*
==============
UsableEntityDenseGrid_Get
==============
*/

DenseGrid *__fastcall UsableEntityDenseGrid_Get()
{
  return ?UsableEntityDenseGrid_Get@@YAAEAVDenseGrid@@XZ();
}

/*
==============
PlayerUseDataMap_Allocate
==============
*/

void __fastcall PlayerUseDataMap_Allocate(HunkUser *hunkUser)
{
  ?PlayerUseDataMap_Allocate@@YAXPEAUHunkUser@@@Z(hunkUser);
}

/*
==============
UsableEntityDenseGrid_Free
==============
*/

void UsableEntityDenseGrid_Free(void)
{
  ?UsableEntityDenseGrid_Free@@YAXXZ();
}

/*
==============
UsableWorldCollection_Get
==============
*/

ntl::vector_map<unsigned int,UsableRef,NtlHunkUserAllocator<ntl::pair<unsigned int,UsableRef> >,ntl::less<unsigned int,unsigned int> > *__fastcall UsableWorldCollection_Get()
{
  return ?UsableWorldCollection_Get@@YAPEAV?$vector_map@IUUsableRef@@V?$NtlHunkUserAllocator@U?$pair@IUUsableRef@@@ntl@@@@U?$less@II@ntl@@@ntl@@XZ();
}

/*
==============
UsableClientMaskCollection_Allocate
==============
*/

void __fastcall UsableClientMaskCollection_Allocate(HunkUser *hunkUser)
{
  ?UsableClientMaskCollection_Allocate@@YAXPEAUHunkUser@@@Z(hunkUser);
}

/*
==============
PlayerUseDataMap_Clear
==============
*/

void __fastcall PlayerUseDataMap_Clear(PlayerUseDataMap *const map)
{
  ?PlayerUseDataMap_Clear@@YAXQEAUPlayerUseDataMap@@@Z(map);
}

/*
==============
PlayerUseDataMap_InitPlayerData_Scriptable::InitPlayerUseData
==============
*/
void PlayerUseDataMap_InitPlayerData_Scriptable::InitPlayerUseData(PlayerUseDataMap_InitPlayerData_Scriptable *this, PlayerUseData *const outPlayerUseData)
{
  __int64 v4; 
  const ScriptableStateUsableDef *PartStateUsableDef; 
  vec3_t *p_m_usePos; 
  unsigned int useData; 
  const ScriptableDef *def; 
  bool v9; 
  ntl::vector_map<unsigned int,ClientBits,NtlHunkUserAllocator<ntl::pair<unsigned int,ClientBits> >,ntl::less<unsigned int,unsigned int> > *v10; 
  __int64 m_size; 
  ntl::pair<unsigned int,ClientBits> *m_buffer; 
  const unsigned int *key; 
  ntl::pair<unsigned int,ClientBits> *v14; 
  __int64 v15; 
  __int64 v16; 
  ntl::pair<unsigned int,ClientBits> *v17; 
  const ClientBits *p_second; 
  float *outDisplayFOV; 
  bool *outUse2DFOV; 
  vec3_t out_useAnglesOptional; 

  if ( !this->ref && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\player_use_collection.cpp", 550, ASSERT_TYPE_ASSERT, "( ref != nullptr )", (const char *)&queryFormat, "ref != nullptr") )
    __debugbreak();
  if ( !outPlayerUseData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\player_use_collection.cpp", 551, ASSERT_TYPE_ASSERT, "( outPlayerUseData != nullptr )", (const char *)&queryFormat, "outPlayerUseData != nullptr") )
    __debugbreak();
  v4 = *(_DWORD *)this->ref;
  if ( ScriptableSv_GetPartStateType(this->ref->useIndex, this->ref->useData) != Scriptable_StateType_Usable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\player_use_collection.cpp", 555, ASSERT_TYPE_ASSERT, "( ScriptableSv_GetPartStateType( scriptableIndex, ref->useData ) == Scriptable_StateType_Usable )", (const char *)&queryFormat, "ScriptableSv_GetPartStateType( scriptableIndex, ref->useData ) == Scriptable_StateType_Usable") )
    __debugbreak();
  PartStateUsableDef = ScriptableSv_GetPartStateUsableDef(v4, this->ref->useData);
  UsableScriptableStatePartDef_GetRadiusFov(PartStateUsableDef, &outPlayerUseData->m_useRadius, &outPlayerUseData->m_useFOV, &outPlayerUseData->m_faceFOV, &outPlayerUseData->m_displayRadius, &outPlayerUseData->m_displayFOV, &outPlayerUseData->m_use2DFOV);
  p_m_usePos = &outPlayerUseData->m_usePos;
  useData = this->ref->useData;
  if ( outPlayerUseData->m_faceFOV <= 0.0 )
  {
    ScriptableSv_GetPartUsePositionAndAngles(v4, useData, p_m_usePos, NULL);
  }
  else
  {
    ScriptableSv_GetPartUsePositionAndAngles(v4, useData, p_m_usePos, &out_useAnglesOptional);
    AngleVectors(&out_useAnglesOptional, &outPlayerUseData->m_useForward, NULL, NULL);
  }
  if ( s_usableWorldLootHidden )
  {
    if ( !g_scriptableSv_instanceContexts && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\scriptable\\scriptable_server_utility.h", 81, ASSERT_TYPE_ASSERT, "( g_scriptableSv_instanceContexts )", (const char *)&queryFormat, "g_scriptableSv_instanceContexts") )
      __debugbreak();
    ScriptableCommon_AssertCountsInitialized();
    if ( (unsigned int)v4 >= g_scriptableWorldCounts.serverInstanceCount )
    {
      ScriptableCommon_AssertCountsInitialized();
      LODWORD(outUse2DFOV) = g_scriptableWorldCounts.serverInstanceCount;
      LODWORD(outDisplayFOV) = v4;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\scriptable\\scriptable_server_utility.h", 82, ASSERT_TYPE_ASSERT, "(unsigned)( scriptableIndex ) < (unsigned)( ScriptableCommon_GetServerInstanceCount() )", "scriptableIndex doesn't index ScriptableCommon_GetServerInstanceCount()\n\t%i not in [0, %i)", outDisplayFOV, outUse2DFOV) )
        __debugbreak();
    }
    def = g_scriptableSv_instanceContexts[v4].commonContext.def;
    if ( !def && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\player_use_collection.cpp", 576, ASSERT_TYPE_ASSERT, "(def)", (const char *)&queryFormat, "def") )
      __debugbreak();
    v9 = (def->flags & 0x20000) != 0;
  }
  else
  {
    v9 = 0;
  }
  outPlayerUseData->m_disabled = v9;
  v10 = s_usableClientMasks;
  if ( !s_usableClientMasks )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\player_use_collection.cpp", 318, ASSERT_TYPE_ASSERT, "( ( s_usableClientMasks != nullptr ) )", "%s\n\t( s_usableClientMasks ) = %p", "( s_usableClientMasks != nullptr )", NULL) )
      __debugbreak();
    v10 = s_usableClientMasks;
  }
  m_size = v10->m_size;
  m_buffer = v10->m_data.m_buffer;
  key = this->key;
  v14 = v10->m_data.m_buffer;
  v15 = m_size;
  while ( v15 > 0 )
  {
    v16 = v15 >> 1;
    if ( v14[v16].first >= *key )
    {
      v15 >>= 1;
    }
    else
    {
      v14 = (ntl::pair<unsigned int,ClientBits> *)((char *)v14 + v16 * 32 + 32);
      v15 += -1 - (v15 >> 1);
    }
  }
  v17 = &m_buffer[m_size];
  if ( v14 != v17 && *key < v14->first )
    v14 = &m_buffer[m_size];
  p_second = &v14->second;
  if ( v14 == v17 )
    p_second = NULL;
  outPlayerUseData->m_clientMask = p_second;
}

/*
==============
PlayerUseDataMap_Allocate
==============
*/
void PlayerUseDataMap_Allocate(HunkUser *hunkUser)
{
  __int64 v1; 
  int v2; 

  v1 = (int)s_usableWorldLimit;
  v2 = 0xFFFF;
  if ( (((int)(4 * s_usableWorldLimit) / 3) | 1) < 0xFFFF )
    v2 = ((int)(4 * s_usableWorldLimit) / 3) | 1;
  if ( s_playerUseDataMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\player_use_collection.cpp", 339, ASSERT_TYPE_ASSERT, "( ( s_playerUseDataMap == nullptr ) )", "%s\n\t( s_playerUseDataMap ) = %p", "( s_playerUseDataMap == nullptr )", s_playerUseDataMap) )
    __debugbreak();
  s_playerUseDataMap = (PlayerUseDataMap *)Mem_HunkUser_AllocInternal(hunkUser, 0x28ui64, 8ui64, "PlayerUseDataMap_Allocate");
  if ( !s_playerUseDataMap && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\player_use_collection.cpp", 341, ASSERT_TYPE_ASSERT, "( ( s_playerUseDataMap != nullptr ) )", "%s\n\t( s_playerUseDataMap ) = %p", "( s_playerUseDataMap != nullptr )", NULL) )
    __debugbreak();
  s_playerUseDataMap->entry = (PlayerUseData *)Mem_HunkUser_AllocInternal(hunkUser, v1 << 6, 8ui64, "PlayerUseDataMap_Allocate");
  s_playerUseDataMap->key = (unsigned int *)Mem_HunkUser_AllocInternal(hunkUser, 4 * v1, 4ui64, "PlayerUseDataMap_Allocate");
  s_playerUseDataMap->next = (unsigned __int16 *)Mem_HunkUser_AllocInternal(hunkUser, 2 * v1, 2ui64, "PlayerUseDataMap_Allocate");
  s_playerUseDataMap->bucket = (volatile int *)Mem_HunkUser_AllocInternal(hunkUser, 4i64 * v2, 4ui64, "PlayerUseDataMap_Allocate");
  s_playerUseDataMap->maxEntryCount = truncate_cast<unsigned short,int>(v1);
  s_playerUseDataMap->maxBucketCount = truncate_cast<unsigned short,int>(v2);
}

/*
==============
PlayerUseDataMap_AllocateEntry
==============
*/
char PlayerUseDataMap_AllocateEntry(PlayerUseDataMap *const map, unsigned __int16 *entryIndex)
{
  volatile int *p_free; 
  __int64 v3; 
  signed __int32 v6; 
  unsigned __int16 v7; 
  unsigned __int16 v8; 
  unsigned __int16 v9; 
  unsigned __int16 maxEntryCount; 
  int v11; 
  __int64 v13; 
  __int64 v14; 

  p_free = &map->free;
  v3 = ((_BYTE)map + 32) & 3;
  while ( 1 )
  {
    if ( v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 141, ASSERT_TYPE_ASSERT, "( ( IsAligned( addr, sizeof( volatile_int32 ) ) ) )", "( addr ) = %p", (const void *)p_free) )
      __debugbreak();
    v6 = *p_free;
    v7 = truncate_cast<unsigned short,int>((unsigned __int16)*p_free);
    *entryIndex = v7;
    if ( v7 == 0xFFFF )
      break;
    v8 = truncate_cast<unsigned short,int>(v6 >> 16) + 1;
    v9 = truncate_cast<unsigned short,int>((unsigned __int16)v6);
    maxEntryCount = map->maxEntryCount;
    if ( v9 >= maxEntryCount )
    {
      LODWORD(v14) = maxEntryCount;
      LODWORD(v13) = v9;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\player_use_collection.cpp", 432, ASSERT_TYPE_ASSERT, "(unsigned)( entryIndex ) < (unsigned)( map->maxEntryCount )", "entryIndex doesn't index map->maxEntryCount\n\t%i not in [0, %i)", v13, v14) )
        __debugbreak();
    }
    v11 = (v8 << 16) | map->next[v9];
    if ( v3 )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", (const void *)p_free) )
        __debugbreak();
    }
    if ( v6 == _InterlockedCompareExchange(p_free, v11, v6) )
      return 1;
  }
  return 0;
}

/*
==============
PlayerUseDataMap_Clear
==============
*/
void PlayerUseDataMap_Clear(PlayerUseDataMap *const map)
{
  int v1; 
  unsigned __int16 i; 
  __int64 v4; 
  int maxEntryCount; 
  unsigned __int16 v6; 
  __int64 v7; 

  LOWORD(v1) = 0;
  for ( i = 0; i < map->maxBucketCount; map->bucket[v4] = 0xFFFF )
    v4 = i++;
  maxEntryCount = map->maxEntryCount;
  map->free = 0;
  if ( maxEntryCount - 1 > 0 )
  {
    do
    {
      v6 = v1 + 1;
      v7 = (unsigned __int16)v1;
      v1 = (unsigned __int16)(v1 + 1);
      map->next[v7] = v6;
      maxEntryCount = map->maxEntryCount;
    }
    while ( v1 < maxEntryCount - 1 );
  }
  map->next[(unsigned __int16)maxEntryCount - 1] = -1;
}

/*
==============
PlayerUseDataMap_FindEntry
==============
*/
char PlayerUseDataMap_FindEntry(const PlayerUseDataMap *const map, const unsigned int *key, const unsigned __int16 bucketIndex, unsigned __int16 *outEntryIndex)
{
  unsigned __int16 maxBucketCount; 
  unsigned __int16 v9; 
  unsigned __int16 v10; 
  unsigned __int16 maxEntryCount; 
  __int64 v12; 
  __int64 v14; 
  __int64 v15; 

  if ( !map && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\player_use_collection.cpp", 500, ASSERT_TYPE_ASSERT, "( map != nullptr )", (const char *)&queryFormat, "map != nullptr") )
    __debugbreak();
  if ( !outEntryIndex && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\player_use_collection.cpp", 501, ASSERT_TYPE_ASSERT, "( outEntryIndex != nullptr )", (const char *)&queryFormat, "outEntryIndex != nullptr") )
    __debugbreak();
  maxBucketCount = map->maxBucketCount;
  if ( bucketIndex >= maxBucketCount )
  {
    LODWORD(v14) = bucketIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\player_use_collection.cpp", 502, ASSERT_TYPE_ASSERT, "(unsigned)( bucketIndex ) < (unsigned)( map->maxBucketCount )", "bucketIndex doesn't index map->maxBucketCount\n\t%i not in [0, %i)", v14, maxBucketCount) )
      __debugbreak();
  }
  v9 = truncate_cast<unsigned short,int>((unsigned __int16)map->bucket[bucketIndex]);
  *outEntryIndex = v9;
  v10 = v9;
  if ( v9 == 0xFFFF )
    return 0;
  while ( 1 )
  {
    maxEntryCount = map->maxEntryCount;
    if ( v10 >= maxEntryCount )
    {
      LODWORD(v15) = maxEntryCount;
      LODWORD(v14) = v10;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\player_use_collection.cpp", 507, ASSERT_TYPE_ASSERT, "(unsigned)( *outEntryIndex ) < (unsigned)( map->maxEntryCount )", "*outEntryIndex doesn't index map->maxEntryCount\n\t%i not in [0, %i)", v14, v15) )
        __debugbreak();
    }
    v12 = *outEntryIndex;
    if ( map->key[v12] == *key )
      break;
    v10 = map->next[v12];
    *outEntryIndex = v10;
    if ( v10 == 0xFFFF )
      return 0;
  }
  return 1;
}

/*
==============
PlayerUseDataMap_Free
==============
*/
void PlayerUseDataMap_Free(void)
{
  s_playerUseDataMap = NULL;
}

/*
==============
PlayerUseDataMap_FreeEntry
==============
*/
void PlayerUseDataMap_FreeEntry(PlayerUseDataMap *const map, const unsigned __int16 entryIndex)
{
  unsigned __int16 maxEntryCount; 
  volatile int *p_free; 
  signed __int32 v6; 
  signed __int32 ListHead_Push; 
  __int64 v8; 

  if ( !map && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\player_use_collection.cpp", 481, ASSERT_TYPE_ASSERT, "( map != nullptr )", (const char *)&queryFormat, "map != nullptr") )
    __debugbreak();
  maxEntryCount = map->maxEntryCount;
  if ( entryIndex >= maxEntryCount )
  {
    LODWORD(v8) = entryIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\player_use_collection.cpp", 482, ASSERT_TYPE_ASSERT, "(unsigned)( entryIndex ) < (unsigned)( map->maxEntryCount )", "entryIndex doesn't index map->maxEntryCount\n\t%i not in [0, %i)", v8, maxEntryCount) )
      __debugbreak();
  }
  p_free = &map->free;
  do
  {
    if ( (((_BYTE)map + 32) & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 141, ASSERT_TYPE_ASSERT, "( ( IsAligned( addr, sizeof( volatile_int32 ) ) ) )", "( addr ) = %p", &map->free) )
      __debugbreak();
    v6 = *p_free;
    ListHead_Push = PlayerUseDataMap_NextListHead_Push(map, *p_free, entryIndex);
    if ( (((_BYTE)map + 32) & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 121, ASSERT_TYPE_ASSERT, "( ( IsAligned( target, sizeof( volatile_int32 ) ) ) )", "( target ) = %p", &map->free) )
      __debugbreak();
  }
  while ( v6 != _InterlockedCompareExchange(p_free, ListHead_Push, v6) );
}

/*
==============
PlayerUseDataMap_Get
==============
*/
PlayerUseDataMap *PlayerUseDataMap_Get()
{
  PlayerUseDataMap *result; 

  result = s_playerUseDataMap;
  if ( !s_playerUseDataMap )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\player_use_collection.cpp", 408, ASSERT_TYPE_ASSERT, "( ( s_playerUseDataMap != nullptr ) )", "%s\n\t( s_playerUseDataMap ) = %p", "( s_playerUseDataMap != nullptr )", s_playerUseDataMap) )
      __debugbreak();
    return s_playerUseDataMap;
  }
  return result;
}

/*
==============
PlayerUseDataMap_GetAllocationSize
==============
*/
__int64 PlayerUseDataMap_GetAllocationSize()
{
  int v0; 
  __int64 v1; 
  unsigned __int64 v2; 
  unsigned __int64 v3; 

  v0 = 0xFFFF;
  if ( (((int)(4 * s_usableWorldLimit) / 3) | 1) < 0xFFFF )
    v0 = ((int)(4 * s_usableWorldLimit) / 3) | 1;
  v1 = 4i64 * v0;
  v2 = (((__int64)(int)s_usableWorldLimit << 6) + 43) & 0xFFFFFFFFFFFFFFFCui64;
  v3 = v1 + ((v2 + 6i64 * (int)s_usableWorldLimit + 3) & 0xFFFFFFFFFFFFFFFCui64);
  if ( v3 > 0xFFFFFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_assert.h", 385, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "%s (SmallType) %s 0x%jx == (BigType) %s 0x%jx", "unsigned int __cdecl truncate_cast_impl<unsigned int,unsigned __int64>(unsigned __int64)", "unsigned", (unsigned int)v3, "unsigned", v1 + ((v2 + 6i64 * (int)s_usableWorldLimit + 3) & 0xFFFFFFFFFFFFFFFCui64)) )
    __debugbreak();
  return (unsigned int)v3;
}

/*
==============
PlayerUseDataMap_GetBucket
==============
*/
unsigned __int16 PlayerUseDataMap_GetBucket(const PlayerUseDataMap *const map, const unsigned int *key)
{
  if ( !map && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\player_use_collection.cpp", 415, ASSERT_TYPE_ASSERT, "( map != nullptr )", (const char *)&queryFormat, "map != nullptr") )
    __debugbreak();
  return truncate_cast<unsigned short,unsigned int>(*key % map->maxBucketCount);
}

/*
==============
PlayerUseDataMap_GetEntityData
==============
*/
PlayerUseData *PlayerUseDataMap_GetEntityData(PlayerUseDataMap *const map, const unsigned int *key, const gentity_s *const ent)
{
  unsigned __int16 Bucket; 
  unsigned __int16 maxEntryCount; 
  unsigned __int16 v8; 
  __int64 v10; 
  unsigned __int16 outEntryIndex; 
  PlayerUseDataMap_InitPlayerData_Entity initFunc; 

  if ( !map && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\player_use_collection.cpp", 672, ASSERT_TYPE_ASSERT, "( map != nullptr )", (const char *)&queryFormat, "map != nullptr") )
    __debugbreak();
  if ( !ent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\player_use_collection.cpp", 673, ASSERT_TYPE_ASSERT, "( ent != nullptr )", (const char *)&queryFormat, "ent != nullptr") )
    __debugbreak();
  Bucket = PlayerUseDataMap_GetBucket(map, key);
  initFunc.ent = ent;
  if ( !PlayerUseDataMap_InsertEntry_PlayerUseDataMap_InitPlayerData_Entity_(map, key, &initFunc, Bucket, &outEntryIndex) )
    return 0i64;
  maxEntryCount = map->maxEntryCount;
  v8 = outEntryIndex;
  if ( outEntryIndex >= maxEntryCount )
  {
    LODWORD(v10) = outEntryIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\player_use_collection.cpp", 681, ASSERT_TYPE_ASSERT, "(unsigned)( entryIndex ) < (unsigned)( map->maxEntryCount )", "entryIndex doesn't index map->maxEntryCount\n\t%i not in [0, %i)", v10, maxEntryCount) )
      __debugbreak();
  }
  return &map->entry[(unsigned __int64)v8];
}

/*
==============
PlayerUseDataMap_GetScriptableData
==============
*/
PlayerUseData *PlayerUseDataMap_GetScriptableData(PlayerUseDataMap *const map, const unsigned int *key, const UsableRef *ref)
{
  unsigned __int16 Bucket; 
  unsigned __int16 maxEntryCount; 
  unsigned __int16 v8; 
  __int64 v10; 
  PlayerUseDataMap_InitPlayerData_Scriptable initFunc; 
  unsigned __int16 outEntryIndex; 

  if ( !map && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\player_use_collection.cpp", 694, ASSERT_TYPE_ASSERT, "( map != nullptr )", (const char *)&queryFormat, "map != nullptr") )
    __debugbreak();
  Bucket = PlayerUseDataMap_GetBucket(map, key);
  initFunc.ref = ref;
  initFunc.key = key;
  if ( !PlayerUseDataMap_InsertEntry_PlayerUseDataMap_InitPlayerData_Scriptable_(map, key, &initFunc, Bucket, &outEntryIndex) )
    return 0i64;
  maxEntryCount = map->maxEntryCount;
  v8 = outEntryIndex;
  if ( outEntryIndex >= maxEntryCount )
  {
    LODWORD(v10) = outEntryIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\player_use_collection.cpp", 703, ASSERT_TYPE_ASSERT, "(unsigned)( entryIndex ) < (unsigned)( map->maxEntryCount )", "entryIndex doesn't index map->maxEntryCount\n\t%i not in [0, %i)", v10, maxEntryCount) )
      __debugbreak();
  }
  return &map->entry[(unsigned __int64)v8];
}

/*
==============
PlayerUseDataMap_NextListHead_Push
==============
*/
__int64 PlayerUseDataMap_NextListHead_Push(PlayerUseDataMap *const map, const int listHead, const unsigned __int16 entryIndex)
{
  unsigned __int16 maxEntryCount; 
  unsigned __int16 v7; 
  int v9; 
  int v10; 

  maxEntryCount = map->maxEntryCount;
  if ( entryIndex >= maxEntryCount )
  {
    v10 = maxEntryCount;
    v9 = entryIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\player_use_collection.cpp", 440, ASSERT_TYPE_ASSERT, "(unsigned)( entryIndex ) < (unsigned)( map->maxEntryCount )", "entryIndex doesn't index map->maxEntryCount\n\t%i not in [0, %i)", v9, v10) )
      __debugbreak();
  }
  v7 = truncate_cast<unsigned short,int>(listHead >> 16) + 1;
  map->next[entryIndex] = truncate_cast<unsigned short,int>((unsigned __int16)listHead);
  return entryIndex | (v7 << 16);
}

/*
==============
UsableClientMaskCollection_Allocate
==============
*/
void UsableClientMaskCollection_Allocate(HunkUser *hunkUser)
{
  ntl::vector_map<unsigned int,ClientBits,NtlHunkUserAllocator<ntl::pair<unsigned int,ClientBits> >,ntl::less<unsigned int,unsigned int> > *v2; 

  v2 = (ntl::vector_map<unsigned int,ClientBits,NtlHunkUserAllocator<ntl::pair<unsigned int,ClientBits> >,ntl::less<unsigned int,unsigned int> > *)Mem_HunkUser_AllocInternal(hunkUser, 0x20ui64, 8ui64, "UsableClientMaskCollection_Allocate");
  if ( !v2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\player_use_collection.cpp", 280, ASSERT_TYPE_ASSERT, "( ( ptr != nullptr ) )", "%s\n\t( ptr ) = %p", "( ptr != nullptr )", NULL) )
    __debugbreak();
  if ( s_usableClientMasks && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\player_use_collection.cpp", 281, ASSERT_TYPE_ASSERT, "( ( s_usableClientMasks == nullptr ) )", "%s\n\t( s_usableClientMasks ) = %p", "( s_usableClientMasks == nullptr )", s_usableClientMasks) )
    __debugbreak();
  v2->m_data.m_buffer = NULL;
  v2->m_data.m_size = 0i64;
  v2->m_size = 0i64;
  s_usableClientMasks = v2;
  if ( !hunkUser )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\player_use_collection.h", 33, ASSERT_TYPE_ASSERT, "( ( hunkUser != nullptr ) )", "%s\n\t( hunkUser ) = %p", "( hunkUser != nullptr )", NULL) )
      __debugbreak();
    v2 = s_usableClientMasks;
  }
  NtlHunkUserAllocator<ntl::pair<unsigned int,ClientBits>>::ms_hunkUser = hunkUser;
  if ( v2->m_data.m_buffer && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\vector\\vector.h", 162, ASSERT_TYPE_ASSERT, "( ( m_data.begin() == 0 ) || ( memory_block_type::is_fixed_memory_block::value ) )", "Reallocation is not supported") )
    __debugbreak();
  v2->m_data.m_buffer = (ntl::pair<unsigned int,ClientBits> *)NtlHunkUserAllocator<ntl::pair<unsigned int,ClientBits>>::allocate(v2, 0xFA000ui64);
  v2->m_data.m_size = 32000i64;
  NtlHunkUserAllocator<ntl::pair<unsigned int,ClientBits>>::ms_hunkUser = NULL;
}

/*
==============
UsableClientMaskCollection_Free
==============
*/
void UsableClientMaskCollection_Free(void)
{
  ntl::vector_map<unsigned int,ClientBits,NtlHunkUserAllocator<ntl::pair<unsigned int,ClientBits> >,ntl::less<unsigned int,unsigned int> > *v0; 
  unsigned __int64 v1; 
  __int64 v2; 

  v2 = -2i64;
  v0 = s_usableClientMasks;
  if ( s_usableClientMasks )
  {
    v1 = 0i64;
    if ( s_usableClientMasks->m_size )
    {
      do
      {
        if ( v1 >= v0->m_data.m_size && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\memory_block\\buffer_memory_block.h", 121, ASSERT_TYPE_ASSERT, "( index < m_size )", (const char *)&queryFormat, "index < m_size", v2) )
          __debugbreak();
        ++v1;
      }
      while ( v1 < v0->m_size );
    }
    v0->m_size = 0i64;
    if ( v0->m_data.m_buffer )
    {
      v0->m_data.m_buffer = NULL;
      v0->m_data.m_size = 0i64;
    }
    s_usableClientMasks = NULL;
  }
}

/*
==============
UsableClientMaskCollection_Get
==============
*/
ntl::vector_map<unsigned int,ClientBits,NtlHunkUserAllocator<ntl::pair<unsigned int,ClientBits> >,ntl::less<unsigned int,unsigned int> > *UsableClientMaskCollection_Get()
{
  ntl::vector_map<unsigned int,ClientBits,NtlHunkUserAllocator<ntl::pair<unsigned int,ClientBits> >,ntl::less<unsigned int,unsigned int> > *result; 

  result = s_usableClientMasks;
  if ( !s_usableClientMasks )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\player_use_collection.cpp", 318, ASSERT_TYPE_ASSERT, "( ( s_usableClientMasks != nullptr ) )", "%s\n\t( s_usableClientMasks ) = %p", "( s_usableClientMasks != nullptr )", s_usableClientMasks) )
      __debugbreak();
    return s_usableClientMasks;
  }
  return result;
}

/*
==============
UsableClientMaskCollection_GetAllocationSize
==============
*/
__int64 UsableClientMaskCollection_GetAllocationSize()
{
  return 32032i64;
}

/*
==============
UsableEntityDenseGrid_Allocate
==============
*/
void UsableEntityDenseGrid_Allocate(HunkUser *hunkUser)
{
  char ActiveGameMode; 
  __int128 v3; 
  DenseGridConfig config; 

  *(_QWORD *)((char *)&v3 + 4) = *(_QWORD *)cm.broadphaseMin.v;
  HIDWORD(v3) = LODWORD(cm.broadphaseMax.v[0]);
  LODWORD(v3) = 2048;
  *(_OWORD *)&config.populationMax = v3;
  config.worldMax.v[1] = cm.broadphaseMax.v[1];
  ActiveGameMode = Com_GameMode_GetActiveGameMode();
  DenseGrid::Init(&s_playerUseEntityDenseGrid, &config, ActiveGameMode == 1, hunkUser);
}

/*
==============
UsableEntityDenseGrid_Free
==============
*/
void UsableEntityDenseGrid_Free(void)
{
  DenseGrid::Destroy(&s_playerUseEntityDenseGrid);
}

/*
==============
UsableEntityDenseGrid_Get
==============
*/
DenseGrid *UsableEntityDenseGrid_Get()
{
  return &s_playerUseEntityDenseGrid;
}

/*
==============
UsableEntityDenseGrid_GetAllocationSize
==============
*/
unsigned int UsableEntityDenseGrid_GetAllocationSize()
{
  char ActiveGameMode; 
  __int128 v2; 
  DenseGridConfig config; 

  *(_QWORD *)((char *)&v2 + 4) = *(_QWORD *)cm.broadphaseMin.v;
  HIDWORD(v2) = LODWORD(cm.broadphaseMax.v[0]);
  LODWORD(v2) = 2048;
  *(_OWORD *)&config.populationMax = v2;
  config.worldMax.v[1] = cm.broadphaseMax.v[1];
  ActiveGameMode = Com_GameMode_GetActiveGameMode();
  return DenseGrid::GetAllocationSize(&config, ActiveGameMode == 1);
}

/*
==============
UsableEntityDenseGrid_Read
==============
*/
void UsableEntityDenseGrid_Read(MemoryFile *memFile)
{
  DenseGrid::Read(&s_playerUseEntityDenseGrid, memFile);
}

/*
==============
UsableEntityDenseGrid_Write
==============
*/
void UsableEntityDenseGrid_Write(MemoryFile *memFile)
{
  DenseGrid::Write(&s_playerUseEntityDenseGrid, memFile);
}

/*
==============
UsableScriptableDenseGrid_Allocate
==============
*/
void UsableScriptableDenseGrid_Allocate(HunkUser *hunkUser)
{
  char ActiveGameMode; 
  DenseGridConfig v3; 
  DenseGridConfig config; 

  v3.worldMin = *(vec2_t *)cm.broadphaseMin.v;
  v3.worldMax = *(vec2_t *)cm.broadphaseMax.v;
  v3.populationMax = ScriptableSv_GetTotalReplicatedPartsLimit();
  config = v3;
  ActiveGameMode = Com_GameMode_GetActiveGameMode();
  DenseGrid::Init(&s_playerUseScriptableDenseGrid, &config, ActiveGameMode == 1, hunkUser);
}

/*
==============
UsableScriptableDenseGrid_Free
==============
*/
void UsableScriptableDenseGrid_Free(void)
{
  DenseGrid::Destroy(&s_playerUseScriptableDenseGrid);
}

/*
==============
UsableScriptableDenseGrid_Get
==============
*/
DenseGrid *UsableScriptableDenseGrid_Get()
{
  return &s_playerUseScriptableDenseGrid;
}

/*
==============
UsableScriptableDenseGrid_GetAllocationSize
==============
*/
unsigned int UsableScriptableDenseGrid_GetAllocationSize()
{
  char ActiveGameMode; 
  DenseGridConfig v2; 
  DenseGridConfig config; 

  v2.worldMin = *(vec2_t *)cm.broadphaseMin.v;
  v2.worldMax = *(vec2_t *)cm.broadphaseMax.v;
  v2.populationMax = ScriptableSv_GetTotalReplicatedPartsLimit();
  config = v2;
  ActiveGameMode = Com_GameMode_GetActiveGameMode();
  return DenseGrid::GetAllocationSize(&config, ActiveGameMode == 1);
}

/*
==============
UsableScriptableDenseGrid_Read
==============
*/
void UsableScriptableDenseGrid_Read(MemoryFile *memFile)
{
  DenseGrid::Read(&s_playerUseScriptableDenseGrid, memFile);
}

/*
==============
UsableScriptableDenseGrid_Write
==============
*/
void UsableScriptableDenseGrid_Write(MemoryFile *memFile)
{
  DenseGrid::Write(&s_playerUseScriptableDenseGrid, memFile);
}

/*
==============
UsableWorldCollection_Allocate
==============
*/
void UsableWorldCollection_Allocate(HunkUser *hunkUser)
{
  ntl::vector_map<unsigned int,UsableRef,NtlHunkUserAllocator<ntl::pair<unsigned int,UsableRef> >,ntl::less<unsigned int,unsigned int> > *v2; 
  __int64 v3; 

  v2 = (ntl::vector_map<unsigned int,UsableRef,NtlHunkUserAllocator<ntl::pair<unsigned int,UsableRef> >,ntl::less<unsigned int,unsigned int> > *)Mem_HunkUser_AllocInternal(hunkUser, 0x20ui64, 8ui64, "UsableWorldCollection_Allocate");
  if ( !v2 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\player_use_collection.cpp", 224, ASSERT_TYPE_ASSERT, "( ( ptr != nullptr ) )", "%s\n\t( ptr ) = %p", "( ptr != nullptr )", NULL) )
    __debugbreak();
  v2->m_data.m_buffer = NULL;
  v2->m_data.m_size = 0i64;
  v2->m_size = 0i64;
  s_usableWorld = v2;
  if ( !hunkUser )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\player_use_collection.h", 33, ASSERT_TYPE_ASSERT, "( ( hunkUser != nullptr ) )", "%s\n\t( hunkUser ) = %p", "( hunkUser != nullptr )", NULL) )
      __debugbreak();
    v2 = s_usableWorld;
  }
  NtlHunkUserAllocator<ntl::pair<unsigned int,UsableRef>>::ms_hunkUser = hunkUser;
  v3 = 12i64 * s_usableWorldLimit;
  if ( v2->m_data.m_buffer && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\vector\\vector.h", 162, ASSERT_TYPE_ASSERT, "( ( m_data.begin() == 0 ) || ( memory_block_type::is_fixed_memory_block::value ) )", "Reallocation is not supported") )
    __debugbreak();
  v2->m_data.m_buffer = (ntl::pair<unsigned int,UsableRef> *)NtlHunkUserAllocator<ntl::pair<unsigned int,UsableRef>>::allocate(v2, 12 * v3);
  v2->m_data.m_size = v3;
  NtlHunkUserAllocator<ntl::pair<unsigned int,UsableRef>>::ms_hunkUser = NULL;
}

/*
==============
UsableWorldCollection_Free
==============
*/
void UsableWorldCollection_Free(void)
{
  ntl::vector_map<unsigned int,UsableRef,NtlHunkUserAllocator<ntl::pair<unsigned int,UsableRef> >,ntl::less<unsigned int,unsigned int> > *v0; 
  unsigned __int64 v1; 
  __int64 v2; 

  v2 = -2i64;
  v0 = s_usableWorld;
  if ( s_usableWorld )
  {
    v1 = 0i64;
    if ( s_usableWorld->m_size )
    {
      do
      {
        if ( v1 >= v0->m_data.m_size && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\allocator\\memory_block\\buffer_memory_block.h", 121, ASSERT_TYPE_ASSERT, "( index < m_size )", (const char *)&queryFormat, "index < m_size", v2) )
          __debugbreak();
        ++v1;
      }
      while ( v1 < v0->m_size );
    }
    v0->m_size = 0i64;
    if ( v0->m_data.m_buffer )
    {
      v0->m_data.m_buffer = NULL;
      v0->m_data.m_size = 0i64;
    }
    s_usableWorld = NULL;
  }
}

/*
==============
UsableWorldCollection_Get
==============
*/
ntl::vector_map<unsigned int,UsableRef,NtlHunkUserAllocator<ntl::pair<unsigned int,UsableRef> >,ntl::less<unsigned int,unsigned int> > *UsableWorldCollection_Get()
{
  ntl::vector_map<unsigned int,UsableRef,NtlHunkUserAllocator<ntl::pair<unsigned int,UsableRef> >,ntl::less<unsigned int,unsigned int> > *result; 

  result = s_usableWorld;
  if ( !s_usableWorld )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\player_use_collection.cpp", 270, ASSERT_TYPE_ASSERT, "( ( s_usableWorld != nullptr ) )", "%s\n\t( s_usableWorld ) = %p", "( s_usableWorld != nullptr )", s_usableWorld) )
      __debugbreak();
    return s_usableWorld;
  }
  return result;
}

/*
==============
UsableWorldCollection_GetAllocationSize
==============
*/
__int64 UsableWorldCollection_GetAllocationSize()
{
  return 12 * s_usableWorldLimit + 32;
}

/*
==============
UsableWorld_GetUsableLimit
==============
*/
__int64 UsableWorld_GetUsableLimit()
{
  return s_usableWorldLimit;
}

/*
==============
UsableWorld_InitLimits
==============
*/
void UsableWorld_InitLimits(void)
{
  if ( !cm.mapEnts && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\game\\player_use_collection.cpp", 196, ASSERT_TYPE_ASSERT, "( ( cm.mapEnts != nullptr ) )", "%s\n\t( cm.mapEnts ) = %p", "( cm.mapEnts != nullptr )", NULL) )
    __debugbreak();
  s_usableWorldLimit = ScriptableSv_GetReplicatedInstanceLimit() + cm.mapEnts->scriptableMapEnts.serverUsablePartCount + 2048;
  if ( s_usableWorldLimit > 0xFDE8 )
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_143D91E20, 585i64);
}

/*
==============
UsableWorld_SetLootHidden
==============
*/
void UsableWorld_SetLootHidden(bool hidden)
{
  s_usableWorldLootHidden = hidden;
}

