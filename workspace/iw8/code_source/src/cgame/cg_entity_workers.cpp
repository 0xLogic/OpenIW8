/*
==============
CG_EntityWorkers_EnterCriticalSection_WithFallback<86>
==============
*/

void __fastcall CG_EntityWorkers_EnterCriticalSection_WithFallback<86>(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  ??$CG_EntityWorkers_EnterCriticalSection_WithFallback@$0FG@@@YAXW4CGEntityWorkersLegacyFallbackMode@@@Z(fallbackMode);
}

/*
==============
CG_EntityWorkers_RegisterDars
==============
*/

void CG_EntityWorkers_RegisterDars(void)
{
  ?CG_EntityWorkers_RegisterDars@@YAXXZ();
}

/*
==============
SetSecureWorkerOrigin
==============
*/

void __fastcall SetSecureWorkerOrigin(const vec3_t *from, vec3_t *to, const unsigned int xorValue)
{
  ?SetSecureWorkerOrigin@@YAXAEBTvec3_t@@AEAT1@I@Z(from, to, xorValue);
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityScriptableSpatialUpdate>::~CgEntityWorkersOutputBuilder<CgEntityScriptableSpatialUpdate>
==============
*/

void __fastcall CgEntityWorkersOutputBuilder<CgEntityScriptableSpatialUpdate>::~CgEntityWorkersOutputBuilder<CgEntityScriptableSpatialUpdate>(CgEntityWorkersOutputBuilder<CgEntityScriptableSpatialUpdate> *this)
{
  ??1?$CgEntityWorkersOutputBuilder@UCgEntityScriptableSpatialUpdate@@@@QEAA@XZ(this);
}

/*
==============
CG_EntityWorkers_TryAddStopSoundOnEntChannelRequest
==============
*/

bool __fastcall CG_EntityWorkers_TryAddStopSoundOnEntChannelRequest(const int entityIndex, const int entChannelIndex)
{
  return ?CG_EntityWorkers_TryAddStopSoundOnEntChannelRequest@@YA_NHH@Z(entityIndex, entChannelIndex);
}

/*
==============
CG_EntityWorkers_TryAddScriptableStateEventLightUpdate
==============
*/

bool __fastcall CG_EntityWorkers_TryAddScriptableStateEventLightUpdate(const unsigned int lightIndex, const Scriptable_EventLight_Data *const data, const ScriptableEventLightDef *const light, const ComPrimaryLight *const rawLight)
{
  return ?CG_EntityWorkers_TryAddScriptableStateEventLightUpdate@@YA_NIQEBUScriptable_EventLight_Data@@QEBUScriptableEventLightDef@@QEBUComPrimaryLight@@@Z(lightIndex, data, light, rawLight);
}

/*
==============
CG_EntityWorkers_LeaveCriticalSection_ReflectionProbe
==============
*/

void __fastcall CG_EntityWorkers_LeaveCriticalSection_ReflectionProbe(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  ?CG_EntityWorkers_LeaveCriticalSection_ReflectionProbe@@YAXW4CGEntityWorkersLegacyFallbackMode@@@Z(fallbackMode);
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityTurretBarrelSpinSoundRequest>::~CgEntityWorkersOutputBuilder<CgEntityTurretBarrelSpinSoundRequest>
==============
*/

void __fastcall CgEntityWorkersOutputBuilder<CgEntityTurretBarrelSpinSoundRequest>::~CgEntityWorkersOutputBuilder<CgEntityTurretBarrelSpinSoundRequest>(CgEntityWorkersOutputBuilder<CgEntityTurretBarrelSpinSoundRequest> *this)
{
  ??1?$CgEntityWorkersOutputBuilder@UCgEntityTurretBarrelSpinSoundRequest@@@@QEAA@XZ(this);
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityBModelUpdateBoundsRequest>::~CgEntityWorkersOutputBuilder<CgEntityBModelUpdateBoundsRequest>
==============
*/

void __fastcall CgEntityWorkersOutputBuilder<CgEntityBModelUpdateBoundsRequest>::~CgEntityWorkersOutputBuilder<CgEntityBModelUpdateBoundsRequest>(CgEntityWorkersOutputBuilder<CgEntityBModelUpdateBoundsRequest> *this)
{
  ??1?$CgEntityWorkersOutputBuilder@UCgEntityBModelUpdateBoundsRequest@@@@QEAA@XZ(this);
}

/*
==============
CG_EntityWorkers_TryAddDObjDrawRequest
==============
*/

bool __fastcall CG_EntityWorkers_TryAddDObjDrawRequest(const int entityIndex, unsigned int renderFlags, unsigned int materialData, float materialTime, const vec3_t *lightingOrigin, const GfxSceneHudOutlineInfo *hudOutlineInfo, const shaderOverride_t *shaderOverride)
{
  return ?CG_EntityWorkers_TryAddDObjDrawRequest@@YA_NHIIMAEBTvec3_t@@PEBUGfxSceneHudOutlineInfo@@PEBUshaderOverride_t@@@Z(entityIndex, renderFlags, materialData, materialTime, lightingOrigin, hudOutlineInfo, shaderOverride);
}

/*
==============
CG_EntityWorkers_ExecutePostPlayerStateThread
==============
*/

void __fastcall CG_EntityWorkers_ExecutePostPlayerStateThread(const LocalClientNum_t localClientNum, CgEntityWork *workerData, CgEventSystem *eventSystem)
{
  ?CG_EntityWorkers_ExecutePostPlayerStateThread@@YAXW4LocalClientNum_t@@PEAUCgEntityWork@@PEAVCgEventSystem@@@Z(localClientNum, workerData, eventSystem);
}

/*
==============
CG_EntityWorkers_EnterCriticalSection_VehicleGetFx
==============
*/

void CG_EntityWorkers_EnterCriticalSection_VehicleGetFx(void)
{
  ?CG_EntityWorkers_EnterCriticalSection_VehicleGetFx@@YAXXZ();
}

/*
==============
CG_EntityWorkers_InitBuilderCmd
==============
*/

void __fastcall CG_EntityWorkers_InitBuilderCmd(const LocalClientNum_t localClientNum, const int serverTime, CgEntityWork *work, CgEntityWorkBuilder *workBuilder, CgEntityWorkBuilderCmd *outBuildWorkers)
{
  ?CG_EntityWorkers_InitBuilderCmd@@YAXW4LocalClientNum_t@@HPEAUCgEntityWork@@PEAUCgEntityWorkBuilder@@PEAUCgEntityWorkBuilderCmd@@@Z(localClientNum, serverTime, work, workBuilder, outBuildWorkers);
}

/*
==============
CG_EntityWorkers_EnterCriticalSection
==============
*/

void CG_EntityWorkers_EnterCriticalSection(void)
{
  ?CG_EntityWorkers_EnterCriticalSection@@YAXXZ();
}

/*
==============
CgEntityPlayerPostUpdate_GetPoseOrigin
==============
*/

void __fastcall CgEntityPlayerPostUpdate_GetPoseOrigin(const CgEntityPlayerPostUpdate *update, vec3_t *poseOrigin)
{
  ?CgEntityPlayerPostUpdate_GetPoseOrigin@@YAXPEBUCgEntityPlayerPostUpdate@@AEATvec3_t@@@Z(update, poseOrigin);
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityScriptableEventSunUpdate>::~CgEntityWorkersOutputBuilder<CgEntityScriptableEventSunUpdate>
==============
*/

void __fastcall CgEntityWorkersOutputBuilder<CgEntityScriptableEventSunUpdate>::~CgEntityWorkersOutputBuilder<CgEntityScriptableEventSunUpdate>(CgEntityWorkersOutputBuilder<CgEntityScriptableEventSunUpdate> *this)
{
  ??1?$CgEntityWorkersOutputBuilder@UCgEntityScriptableEventSunUpdate@@@@QEAA@XZ(this);
}

/*
==============
CG_EntityWorkers_TryAddDObjBoundsUpdate
==============
*/

bool __fastcall CG_EntityWorkers_TryAddDObjBoundsUpdate(const int entityIndex)
{
  return ?CG_EntityWorkers_TryAddDObjBoundsUpdate@@YA_NH@Z(entityIndex);
}

/*
==============
CG_EntityWorkers_LeaveCriticalSection_ViewModel
==============
*/

void __fastcall CG_EntityWorkers_LeaveCriticalSection_ViewModel(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  ?CG_EntityWorkers_LeaveCriticalSection_ViewModel@@YAXW4CGEntityWorkersLegacyFallbackMode@@@Z(fallbackMode);
}

/*
==============
CG_EntityWorkers_ValidateEntityWorkers
==============
*/

void __fastcall CG_EntityWorkers_ValidateEntityWorkers(const CgEntityWorkBuilderCmd *workerCmd)
{
  ?CG_EntityWorkers_ValidateEntityWorkers@@YAXPEBUCgEntityWorkBuilderCmd@@@Z(workerCmd);
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityScriptableSpatialUpdate>::Submit
==============
*/

void __fastcall CgEntityWorkersOutputBuilder<CgEntityScriptableSpatialUpdate>::Submit(CgEntityWorkersOutputBuilder<CgEntityScriptableSpatialUpdate> *this)
{
  ?Submit@?$CgEntityWorkersOutputBuilder@UCgEntityScriptableSpatialUpdate@@@@QEAAXXZ(this);
}

/*
==============
CG_EntityWorkers_LeaveCriticalSection_LegacyOnly
==============
*/

void CG_EntityWorkers_LeaveCriticalSection_LegacyOnly(void)
{
  ?CG_EntityWorkers_LeaveCriticalSection_LegacyOnly@@YAXXZ();
}

/*
==============
CG_EntityWorkers_TryAddBModelDrawRequest
==============
*/

bool __fastcall CG_EntityWorkers_TryAddBModelDrawRequest(const int entityIndex, unsigned int renderFlags)
{
  return ?CG_EntityWorkers_TryAddBModelDrawRequest@@YA_NHI@Z(entityIndex, renderFlags);
}

/*
==============
CG_EntityWorkers_TryAddNoteTrackNotification
==============
*/

bool __fastcall CG_EntityWorkers_TryAddNoteTrackNotification(const unsigned int entityIndex, const XAnimNotifyHandle notifyHandle)
{
  return ?CG_EntityWorkers_TryAddNoteTrackNotification@@YA_NIVXAnimNotifyHandle@@@Z(entityIndex, notifyHandle);
}

/*
==============
CG_EntityWorkers_CheckHasWriteLock_Physics
==============
*/

void CG_EntityWorkers_CheckHasWriteLock_Physics(void)
{
  ?CG_EntityWorkers_CheckHasWriteLock_Physics@@YAXXZ();
}

/*
==============
CG_EntityWorkers_TryAddFxMarksDetachAllRequest
==============
*/

bool __fastcall CG_EntityWorkers_TryAddFxMarksDetachAllRequest(const LocalClientNum_t localClientNum, const int entIndex)
{
  return ?CG_EntityWorkers_TryAddFxMarksDetachAllRequest@@YA_NW4LocalClientNum_t@@H@Z(localClientNum, entIndex);
}

/*
==============
CG_EntityWorkers_EnterCriticalSection_WithFallback<85>
==============
*/

void __fastcall CG_EntityWorkers_EnterCriticalSection_WithFallback<85>(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  ??$CG_EntityWorkers_EnterCriticalSection_WithFallback@$0FF@@@YAXW4CGEntityWorkersLegacyFallbackMode@@@Z(fallbackMode);
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityBModelDrawRequest>::Submit
==============
*/

void __fastcall CgEntityWorkersOutputBuilder<CgEntityBModelDrawRequest>::Submit(CgEntityWorkersOutputBuilder<CgEntityBModelDrawRequest> *this)
{
  ?Submit@?$CgEntityWorkersOutputBuilder@UCgEntityBModelDrawRequest@@@@QEAAXXZ(this);
}

/*
==============
CG_EntityWorkers_EnterCriticalSection_VFX
==============
*/

void __fastcall CG_EntityWorkers_EnterCriticalSection_VFX(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  ?CG_EntityWorkers_EnterCriticalSection_VFX@@YAXW4CGEntityWorkersLegacyFallbackMode@@@Z(fallbackMode);
}

/*
==============
CG_EntityWorkers_LeaveCriticalSection_Mayhem
==============
*/

void __fastcall CG_EntityWorkers_LeaveCriticalSection_Mayhem(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  ?CG_EntityWorkers_LeaveCriticalSection_Mayhem@@YAXW4CGEntityWorkersLegacyFallbackMode@@@Z(fallbackMode);
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityScriptableEventSunUpdate>::Submit
==============
*/

void __fastcall CgEntityWorkersOutputBuilder<CgEntityScriptableEventSunUpdate>::Submit(CgEntityWorkersOutputBuilder<CgEntityScriptableEventSunUpdate> *this)
{
  ?Submit@?$CgEntityWorkersOutputBuilder@UCgEntityScriptableEventSunUpdate@@@@QEAAXXZ(this);
}

/*
==============
CG_EntityWorkers_ExecuteWorkerThread
==============
*/

void __fastcall CG_EntityWorkers_ExecuteWorkerThread(const void *const cmd)
{
  ?CG_EntityWorkers_ExecuteWorkerThread@@YAXQEBX@Z(cmd);
}

/*
==============
CG_EntityWorkers_EnterCriticalSection_WithFallback<87>
==============
*/

void __fastcall CG_EntityWorkers_EnterCriticalSection_WithFallback<87>(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  ??$CG_EntityWorkers_EnterCriticalSection_WithFallback@$0FH@@@YAXW4CGEntityWorkersLegacyFallbackMode@@@Z(fallbackMode);
}

/*
==============
CG_EntityWorkers_EnterCriticalSection_LegacyOnly
==============
*/

void CG_EntityWorkers_EnterCriticalSection_LegacyOnly(void)
{
  ?CG_EntityWorkers_EnterCriticalSection_LegacyOnly@@YAXXZ();
}

/*
==============
CG_EntityWorkers_TryAddStopSoundOnEntRequest
==============
*/

bool __fastcall CG_EntityWorkers_TryAddStopSoundOnEntRequest(const int entityIndex)
{
  return ?CG_EntityWorkers_TryAddStopSoundOnEntRequest@@YA_NH@Z(entityIndex);
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityFxMarkDetachAllRequest>::~CgEntityWorkersOutputBuilder<CgEntityFxMarkDetachAllRequest>
==============
*/

void __fastcall CgEntityWorkersOutputBuilder<CgEntityFxMarkDetachAllRequest>::~CgEntityWorkersOutputBuilder<CgEntityFxMarkDetachAllRequest>(CgEntityWorkersOutputBuilder<CgEntityFxMarkDetachAllRequest> *this)
{
  ??1?$CgEntityWorkersOutputBuilder@UCgEntityFxMarkDetachAllRequest@@@@QEAA@XZ(this);
}

/*
==============
CG_EntityWorkers_LeaveCriticalSection_Compass
==============
*/

void __fastcall CG_EntityWorkers_LeaveCriticalSection_Compass(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  ?CG_EntityWorkers_LeaveCriticalSection_Compass@@YAXW4CGEntityWorkersLegacyFallbackMode@@@Z(fallbackMode);
}

/*
==============
CG_EntityWorkers_ShutdownWorkerOutput
==============
*/

void CG_EntityWorkers_ShutdownWorkerOutput(void)
{
  ?CG_EntityWorkers_ShutdownWorkerOutput@@YAXXZ();
}

/*
==============
CG_EntityWorkers_TryAddScriptableEventSunUpdate
==============
*/

bool __fastcall CG_EntityWorkers_TryAddScriptableEventSunUpdate(const float interpolation, const ScriptableEventDef *const event, const Scriptable_EventSun_Data *const data)
{
  return ?CG_EntityWorkers_TryAddScriptableEventSunUpdate@@YA_NMQEBUScriptableEventDef@@QEBUScriptable_EventSun_Data@@@Z(interpolation, event, data);
}

/*
==============
CG_EntityWorkers_EnterCriticalSection_Unverified
==============
*/

void CG_EntityWorkers_EnterCriticalSection_Unverified(void)
{
  ?CG_EntityWorkers_EnterCriticalSection_Unverified@@YAXXZ();
}

/*
==============
CG_EntityWorkers_LeaveCriticalSection_VFX
==============
*/

void __fastcall CG_EntityWorkers_LeaveCriticalSection_VFX(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  ?CG_EntityWorkers_LeaveCriticalSection_VFX@@YAXW4CGEntityWorkersLegacyFallbackMode@@@Z(fallbackMode);
}

/*
==============
CG_EntityWorkers_TryAddSurfaceSoundRequest
==============
*/

bool __fastcall CG_EntityWorkers_TryAddSurfaceSoundRequest(const int entityIndex, const vec3_t *soundOrigin, const SndAliasList *aliasList, int surfaceType, float volumeScale, float pitch, int fadeTime)
{
  return ?CG_EntityWorkers_TryAddSurfaceSoundRequest@@YA_NHAEBTvec3_t@@PEBUSndAliasList@@HMMH@Z(entityIndex, soundOrigin, aliasList, surfaceType, volumeScale, pitch, fadeTime);
}

/*
==============
CG_EntityWorkers_TryAddScriptableSpatialUpdate
==============
*/

bool __fastcall CG_EntityWorkers_TryAddScriptableSpatialUpdate(const LocalClientNum_t localClientNum, const unsigned int scriptableIndex, const unsigned int markerIndex, const unsigned int partitionIndex)
{
  return ?CG_EntityWorkers_TryAddScriptableSpatialUpdate@@YA_NW4LocalClientNum_t@@III@Z(localClientNum, scriptableIndex, markerIndex, partitionIndex);
}

/*
==============
CG_EntityWorkers_LeaveCriticalSection_Ragdoll
==============
*/

void __fastcall CG_EntityWorkers_LeaveCriticalSection_Ragdoll(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  ?CG_EntityWorkers_LeaveCriticalSection_Ragdoll@@YAXW4CGEntityWorkersLegacyFallbackMode@@@Z(fallbackMode);
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityDObjUpdateBoundsRequest>::~CgEntityWorkersOutputBuilder<CgEntityDObjUpdateBoundsRequest>
==============
*/

void __fastcall CgEntityWorkersOutputBuilder<CgEntityDObjUpdateBoundsRequest>::~CgEntityWorkersOutputBuilder<CgEntityDObjUpdateBoundsRequest>(CgEntityWorkersOutputBuilder<CgEntityDObjUpdateBoundsRequest> *this)
{
  ??1?$CgEntityWorkersOutputBuilder@UCgEntityDObjUpdateBoundsRequest@@@@QEAA@XZ(this);
}

/*
==============
CG_EntityWorkers_CreateRWLock_Physics
==============
*/

void CG_EntityWorkers_CreateRWLock_Physics(void)
{
  ?CG_EntityWorkers_CreateRWLock_Physics@@YAXXZ();
}

/*
==============
CG_EntityWorkers_CloseRWLock_Physics
==============
*/

void CG_EntityWorkers_CloseRWLock_Physics(void)
{
  ?CG_EntityWorkers_CloseRWLock_Physics@@YAXXZ();
}

/*
==============
CG_EntityWorkers_AcquireReadLock_Physics
==============
*/

void __fastcall CG_EntityWorkers_AcquireReadLock_Physics(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  ?CG_EntityWorkers_AcquireReadLock_Physics@@YAXW4CGEntityWorkersLegacyFallbackMode@@@Z(fallbackMode);
}

/*
==============
CG_EntityWorkers_InitWorkerOutput
==============
*/

void __fastcall CG_EntityWorkers_InitWorkerOutput(MpscStream<524288> *workerOutputStream)
{
  ?CG_EntityWorkers_InitWorkerOutput@@YAXAEAV?$MpscStream@$0IAAAA@@@@Z(workerOutputStream);
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityScriptableEventLightUpdate>::Begin
==============
*/

CgEntityScriptableEventLightUpdate *__fastcall CgEntityWorkersOutputBuilder<CgEntityScriptableEventLightUpdate>::Begin(CgEntityWorkersOutputBuilder<CgEntityScriptableEventLightUpdate> *this, const CgEntityWorkerOutputType requestType)
{
  return ?Begin@?$CgEntityWorkersOutputBuilder@UCgEntityScriptableEventLightUpdate@@@@QEAAAEAUCgEntityScriptableEventLightUpdate@@W4CgEntityWorkerOutputType@@@Z(this, requestType);
}

/*
==============
CG_EntityWorkers_TryAddUpdateVehicleSound
==============
*/

bool __fastcall CG_EntityWorkers_TryAddUpdateVehicleSound(const int entityIndex, const vec3_t *soundOrigin, const SndAliasList *aliasList, const float throttle, const float brake, const float rpm, const float speed, const int gear, const float distanceScale)
{
  return ?CG_EntityWorkers_TryAddUpdateVehicleSound@@YA_NHAEBTvec3_t@@PEBUSndAliasList@@MMMMHM@Z(entityIndex, soundOrigin, aliasList, throttle, brake, rpm, speed, gear, distanceScale);
}

/*
==============
CG_EntityWorkers_TryAddScriptableEventLightUpdate
==============
*/

bool __fastcall CG_EntityWorkers_TryAddScriptableEventLightUpdate(const float interpolation, const unsigned int lightIndex, const Scriptable_EventLight_Data *const data, const ScriptableEventDef *const event)
{
  return ?CG_EntityWorkers_TryAddScriptableEventLightUpdate@@YA_NMIQEBUScriptable_EventLight_Data@@QEBUScriptableEventDef@@@Z(interpolation, lightIndex, data, event);
}

/*
==============
CG_EntityWorkers_GetProfileData
==============
*/

const CgEntityWorkerProfileHistory *__fastcall CG_EntityWorkers_GetProfileData(const LocalClientNum_t localClientNum)
{
  return ?CG_EntityWorkers_GetProfileData@@YAAEBUCgEntityWorkerProfileHistory@@W4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_EntityWorkers_ExecuteBuilder
==============
*/

void __fastcall CG_EntityWorkers_ExecuteBuilder(const void *const cmd)
{
  ?CG_EntityWorkers_ExecuteBuilder@@YAXQEBX@Z(cmd);
}

/*
==============
CG_EntityWorkers_TryAddPlayExplosionSoundRequest
==============
*/

bool __fastcall CG_EntityWorkers_TryAddPlayExplosionSoundRequest(const int entityIndex, const vec3_t *soundOrigin, const SndAliasList *aliasList, int surfaceType, unsigned int reflectionClass)
{
  return ?CG_EntityWorkers_TryAddPlayExplosionSoundRequest@@YA_NHAEBTvec3_t@@PEBUSndAliasList@@HI@Z(entityIndex, soundOrigin, aliasList, surfaceType, reflectionClass);
}

/*
==============
CG_EntityWorkers_EnterCriticalSection_Ragdoll
==============
*/

void __fastcall CG_EntityWorkers_EnterCriticalSection_Ragdoll(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  ?CG_EntityWorkers_EnterCriticalSection_Ragdoll@@YAXW4CGEntityWorkersLegacyFallbackMode@@@Z(fallbackMode);
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntitySoundRequest>::Begin
==============
*/

CgEntitySoundRequest *__fastcall CgEntityWorkersOutputBuilder<CgEntitySoundRequest>::Begin(CgEntityWorkersOutputBuilder<CgEntitySoundRequest> *this, const CgEntityWorkerOutputType requestType)
{
  return ?Begin@?$CgEntityWorkersOutputBuilder@UCgEntitySoundRequest@@@@QEAAAEAUCgEntitySoundRequest@@W4CgEntityWorkerOutputType@@@Z(this, requestType);
}

/*
==============
CG_EntityWorkers_EnterCriticalSection_ScriptableCl
==============
*/

void __fastcall CG_EntityWorkers_EnterCriticalSection_ScriptableCl(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  ?CG_EntityWorkers_EnterCriticalSection_ScriptableCl@@YAXW4CGEntityWorkersLegacyFallbackMode@@@Z(fallbackMode);
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityDObjDrawRequest>::~CgEntityWorkersOutputBuilder<CgEntityDObjDrawRequest>
==============
*/

void __fastcall CgEntityWorkersOutputBuilder<CgEntityDObjDrawRequest>::~CgEntityWorkersOutputBuilder<CgEntityDObjDrawRequest>(CgEntityWorkersOutputBuilder<CgEntityDObjDrawRequest> *this)
{
  ??1?$CgEntityWorkersOutputBuilder@UCgEntityDObjDrawRequest@@@@QEAA@XZ(this);
}

/*
==============
CG_EntityWorkers_LeaveCriticalSection
==============
*/

void CG_EntityWorkers_LeaveCriticalSection(void)
{
  ?CG_EntityWorkers_LeaveCriticalSection@@YAXXZ();
}

/*
==============
CG_EntityWorkers_TryAddScriptableStateEventSunUpdate
==============
*/

bool __fastcall CG_EntityWorkers_TryAddScriptableStateEventSunUpdate(const ScriptableEventSunDef *const sun, const float intensity, const vec3_t *const direction)
{
  return ?CG_EntityWorkers_TryAddScriptableStateEventSunUpdate@@YA_NQEBUScriptableEventSunDef@@MQEBTvec3_t@@@Z(sun, intensity, direction);
}

/*
==============
CG_EntityWorkers_LeaveCriticalSection_VehicleGetFx
==============
*/

void CG_EntityWorkers_LeaveCriticalSection_VehicleGetFx(void)
{
  ?CG_EntityWorkers_LeaveCriticalSection_VehicleGetFx@@YAXXZ();
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntitySoundRequest>::Submit
==============
*/

void __fastcall CgEntityWorkersOutputBuilder<CgEntitySoundRequest>::Submit(CgEntityWorkersOutputBuilder<CgEntitySoundRequest> *this)
{
  ?Submit@?$CgEntityWorkersOutputBuilder@UCgEntitySoundRequest@@@@QEAAXXZ(this);
}

/*
==============
CG_EntityWorkers_SetPlayerWorkersEnabled
==============
*/

void __fastcall CG_EntityWorkers_SetPlayerWorkersEnabled(const LocalClientNum_t localClientNum, const bool isEnabled)
{
  ?CG_EntityWorkers_SetPlayerWorkersEnabled@@YAXW4LocalClientNum_t@@_N@Z(localClientNum, isEnabled);
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityScriptableEventLightUpdate>::~CgEntityWorkersOutputBuilder<CgEntityScriptableEventLightUpdate>
==============
*/

void __fastcall CgEntityWorkersOutputBuilder<CgEntityScriptableEventLightUpdate>::~CgEntityWorkersOutputBuilder<CgEntityScriptableEventLightUpdate>(CgEntityWorkersOutputBuilder<CgEntityScriptableEventLightUpdate> *this)
{
  ??1?$CgEntityWorkersOutputBuilder@UCgEntityScriptableEventLightUpdate@@@@QEAA@XZ(this);
}

/*
==============
CG_EntityWorkers_EnterCriticalSection_ReflectionProbe
==============
*/

void __fastcall CG_EntityWorkers_EnterCriticalSection_ReflectionProbe(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  ?CG_EntityWorkers_EnterCriticalSection_ReflectionProbe@@YAXW4CGEntityWorkersLegacyFallbackMode@@@Z(fallbackMode);
}

/*
==============
CG_EntityWorkers_LeaveCriticalSection_ScriptableCl
==============
*/

void __fastcall CG_EntityWorkers_LeaveCriticalSection_ScriptableCl(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  ?CG_EntityWorkers_LeaveCriticalSection_ScriptableCl@@YAXW4CGEntityWorkersLegacyFallbackMode@@@Z(fallbackMode);
}

/*
==============
CgEntityPlayerPostUpdate_SetPoseOrigin
==============
*/

void __fastcall CgEntityPlayerPostUpdate_SetPoseOrigin(CgEntityPlayerPostUpdate *update, const vec3_t *poseOrigin)
{
  ?CgEntityPlayerPostUpdate_SetPoseOrigin@@YAXPEAUCgEntityPlayerPostUpdate@@AEBTvec3_t@@@Z(update, poseOrigin);
}

/*
==============
CG_EntityWorkers_SetMissileWorkersEnabled
==============
*/

void __fastcall CG_EntityWorkers_SetMissileWorkersEnabled(const LocalClientNum_t localClientNum, const bool isEnabled)
{
  ?CG_EntityWorkers_SetMissileWorkersEnabled@@YAXW4LocalClientNum_t@@_N@Z(localClientNum, isEnabled);
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityDObjDrawRequest>::Submit
==============
*/

void __fastcall CgEntityWorkersOutputBuilder<CgEntityDObjDrawRequest>::Submit(CgEntityWorkersOutputBuilder<CgEntityDObjDrawRequest> *this)
{
  ?Submit@?$CgEntityWorkersOutputBuilder@UCgEntityDObjDrawRequest@@@@QEAAXXZ(this);
}

/*
==============
CG_EntityWorkers_TryAddPlayBlendedSoundAliasRequest
==============
*/

bool __fastcall CG_EntityWorkers_TryAddPlayBlendedSoundAliasRequest(const int entityIndex, const vec3_t *soundOrigin, const SndAliasList *aliasList0, const SndAliasList *aliasList1, float lerp, float volumeScale, float pitch)
{
  return ?CG_EntityWorkers_TryAddPlayBlendedSoundAliasRequest@@YA_NHAEBTvec3_t@@PEBUSndAliasList@@1MMM@Z(entityIndex, soundOrigin, aliasList0, aliasList1, lerp, volumeScale, pitch);
}

/*
==============
CG_EntityWorkers_TryAddPostPlayerUpdate
==============
*/

bool __fastcall CG_EntityWorkers_TryAddPostPlayerUpdate(const unsigned int entityIndex, const unsigned int clientIndex, const vec3_t *poseOrg)
{
  return ?CG_EntityWorkers_TryAddPostPlayerUpdate@@YA_NIIAEBTvec3_t@@@Z(entityIndex, clientIndex, poseOrg);
}

/*
==============
CG_EntityWorkers_LeaveCriticalSection_WithFallback<85>
==============
*/

void __fastcall CG_EntityWorkers_LeaveCriticalSection_WithFallback<85>(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  ??$CG_EntityWorkers_LeaveCriticalSection_WithFallback@$0FF@@@YAXW4CGEntityWorkersLegacyFallbackMode@@@Z(fallbackMode);
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityNotetrackRequest>::Submit
==============
*/

void __fastcall CgEntityWorkersOutputBuilder<CgEntityNotetrackRequest>::Submit(CgEntityWorkersOutputBuilder<CgEntityNotetrackRequest> *this)
{
  ?Submit@?$CgEntityWorkersOutputBuilder@UCgEntityNotetrackRequest@@@@QEAAXXZ(this);
}

/*
==============
CG_EntityWorkers_ReleaseWriteLock_Physics
==============
*/

void __fastcall CG_EntityWorkers_ReleaseWriteLock_Physics(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  ?CG_EntityWorkers_ReleaseWriteLock_Physics@@YAXW4CGEntityWorkersLegacyFallbackMode@@@Z(fallbackMode);
}

/*
==============
CG_EntityWorkers_EnterCriticalSection_Compass
==============
*/

void __fastcall CG_EntityWorkers_EnterCriticalSection_Compass(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  ?CG_EntityWorkers_EnterCriticalSection_Compass@@YAXW4CGEntityWorkersLegacyFallbackMode@@@Z(fallbackMode);
}

/*
==============
CG_EntityWorkers_ExecuteMainThread
==============
*/

void __fastcall CG_EntityWorkers_ExecuteMainThread(const LocalClientNum_t localClientNum, CgEntityWork *workerData)
{
  ?CG_EntityWorkers_ExecuteMainThread@@YAXW4LocalClientNum_t@@PEAUCgEntityWork@@@Z(localClientNum, workerData);
}

/*
==============
CG_EntityWorkers_TryAddSurfaceSoundOnSndEntRequest
==============
*/

bool __fastcall CG_EntityWorkers_TryAddSurfaceSoundOnSndEntRequest(const int entityIndex, const vec3_t *soundOrigin, const unsigned __int64 sndEntHandle, const SndAliasList *aliasList, int surfaceType, float volumeScale, float pitch, int fadeTime)
{
  return ?CG_EntityWorkers_TryAddSurfaceSoundOnSndEntRequest@@YA_NHAEBTvec3_t@@_KPEBUSndAliasList@@HMMH@Z(entityIndex, soundOrigin, sndEntHandle, aliasList, surfaceType, volumeScale, pitch, fadeTime);
}

/*
==============
CG_EntityWorkers_LeaveCriticalSection_WithFallback<86>
==============
*/

void __fastcall CG_EntityWorkers_LeaveCriticalSection_WithFallback<86>(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  ??$CG_EntityWorkers_LeaveCriticalSection_WithFallback@$0FG@@@YAXW4CGEntityWorkersLegacyFallbackMode@@@Z(fallbackMode);
}

/*
==============
CG_EntityWorkers_LeaveCriticalSection_WithFallback<87>
==============
*/

void __fastcall CG_EntityWorkers_LeaveCriticalSection_WithFallback<87>(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  ??$CG_EntityWorkers_LeaveCriticalSection_WithFallback@$0FH@@@YAXW4CGEntityWorkersLegacyFallbackMode@@@Z(fallbackMode);
}

/*
==============
CG_EntityWorkers_EnterCriticalSection_ViewModel
==============
*/

void __fastcall CG_EntityWorkers_EnterCriticalSection_ViewModel(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  ?CG_EntityWorkers_EnterCriticalSection_ViewModel@@YAXW4CGEntityWorkersLegacyFallbackMode@@@Z(fallbackMode);
}

/*
==============
CgEntityDObjDrawRequest_GetLightingOrigin
==============
*/

void __fastcall CgEntityDObjDrawRequest_GetLightingOrigin(const CgEntityDObjDrawRequest *request, vec3_t *lightingOrigin)
{
  ?CgEntityDObjDrawRequest_GetLightingOrigin@@YAXPEBUCgEntityDObjDrawRequest@@AEATvec3_t@@@Z(request, lightingOrigin);
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityBModelUpdateBoundsRequest>::Submit
==============
*/

void __fastcall CgEntityWorkersOutputBuilder<CgEntityBModelUpdateBoundsRequest>::Submit(CgEntityWorkersOutputBuilder<CgEntityBModelUpdateBoundsRequest> *this)
{
  ?Submit@?$CgEntityWorkersOutputBuilder@UCgEntityBModelUpdateBoundsRequest@@@@QEAAXXZ(this);
}

/*
==============
CG_EntityWorkers_CheckHasAnyLock_Physics
==============
*/

void CG_EntityWorkers_CheckHasAnyLock_Physics(void)
{
  ?CG_EntityWorkers_CheckHasAnyLock_Physics@@YAXXZ();
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityScriptableEventLightUpdate>::Submit
==============
*/

void __fastcall CgEntityWorkersOutputBuilder<CgEntityScriptableEventLightUpdate>::Submit(CgEntityWorkersOutputBuilder<CgEntityScriptableEventLightUpdate> *this)
{
  ?Submit@?$CgEntityWorkersOutputBuilder@UCgEntityScriptableEventLightUpdate@@@@QEAAXXZ(this);
}

/*
==============
CgEntityDObjDrawRequest_SetLightingOrigin
==============
*/

void __fastcall CgEntityDObjDrawRequest_SetLightingOrigin(CgEntityDObjDrawRequest *request, const vec3_t *lightingOrigin)
{
  ?CgEntityDObjDrawRequest_SetLightingOrigin@@YAXPEAUCgEntityDObjDrawRequest@@AEBTvec3_t@@@Z(request, lightingOrigin);
}

/*
==============
CG_EntityWorkers_TryAddStopSoundAliasRequest
==============
*/

bool __fastcall CG_EntityWorkers_TryAddStopSoundAliasRequest(const int entityIndex, SndAliasLookup *sndAliasLookup)
{
  return ?CG_EntityWorkers_TryAddStopSoundAliasRequest@@YA_NHAEAUSndAliasLookup@@@Z(entityIndex, sndAliasLookup);
}

/*
==============
GetSecureWorkerOrigin
==============
*/

void __fastcall GetSecureWorkerOrigin(const vec3_t *from, vec3_t *to, const unsigned int xorValue)
{
  ?GetSecureWorkerOrigin@@YAXAEBTvec3_t@@AEAT1@I@Z(from, to, xorValue);
}

/*
==============
CG_EntityWorkers_LeaveCriticalSection_Unverified
==============
*/

void CG_EntityWorkers_LeaveCriticalSection_Unverified(void)
{
  ?CG_EntityWorkers_LeaveCriticalSection_Unverified@@YAXXZ();
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityTurretBarrelSpinSoundRequest>::Submit
==============
*/

void __fastcall CgEntityWorkersOutputBuilder<CgEntityTurretBarrelSpinSoundRequest>::Submit(CgEntityWorkersOutputBuilder<CgEntityTurretBarrelSpinSoundRequest> *this)
{
  ?Submit@?$CgEntityWorkersOutputBuilder@UCgEntityTurretBarrelSpinSoundRequest@@@@QEAAXXZ(this);
}

/*
==============
CG_EntityWorkers_SetAgentWorkersEnabled
==============
*/

void __fastcall CG_EntityWorkers_SetAgentWorkersEnabled(const LocalClientNum_t localClientNum, const bool isEnabled)
{
  ?CG_EntityWorkers_SetAgentWorkersEnabled@@YAXW4LocalClientNum_t@@_N@Z(localClientNum, isEnabled);
}

/*
==============
CG_EntityWorkers_TryAddTurretBarrelSpinSoundRequest
==============
*/

bool __fastcall CG_EntityWorkers_TryAddTurretBarrelSpinSoundRequest(const LocalClientNum_t localClientNum, const unsigned int entIndex)
{
  return ?CG_EntityWorkers_TryAddTurretBarrelSpinSoundRequest@@YA_NW4LocalClientNum_t@@I@Z(localClientNum, entIndex);
}

/*
==============
CG_EntityWorkers_EnterCriticalSection_Mayhem
==============
*/

void __fastcall CG_EntityWorkers_EnterCriticalSection_Mayhem(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  ?CG_EntityWorkers_EnterCriticalSection_Mayhem@@YAXW4CGEntityWorkersLegacyFallbackMode@@@Z(fallbackMode);
}

/*
==============
CG_EntityWorkers_TryAddPlaySoundAliasScaledRequest
==============
*/

bool __fastcall CG_EntityWorkers_TryAddPlaySoundAliasScaledRequest(const int entityIndex, const vec3_t *soundOrigin, const SndAliasList *aliasList, float volumeScale, float pitch, int timeshift)
{
  return ?CG_EntityWorkers_TryAddPlaySoundAliasScaledRequest@@YA_NHAEBTvec3_t@@PEBUSndAliasList@@MMH@Z(entityIndex, soundOrigin, aliasList, volumeScale, pitch, timeshift);
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntitySoundRequest>::~CgEntityWorkersOutputBuilder<CgEntitySoundRequest>
==============
*/

void __fastcall CgEntityWorkersOutputBuilder<CgEntitySoundRequest>::~CgEntityWorkersOutputBuilder<CgEntitySoundRequest>(CgEntityWorkersOutputBuilder<CgEntitySoundRequest> *this)
{
  ??1?$CgEntityWorkersOutputBuilder@UCgEntitySoundRequest@@@@QEAA@XZ(this);
}

/*
==============
CG_EntityWorkers_ProcessWorkerOutput
==============
*/

bool __fastcall CG_EntityWorkers_ProcessWorkerOutput(const LocalClientNum_t localClientNum, CgEntityWork *work, MpscStream<524288> *workerOutput)
{
  return ?CG_EntityWorkers_ProcessWorkerOutput@@YA_NW4LocalClientNum_t@@AEAUCgEntityWork@@AEAV?$MpscStream@$0IAAAA@@@@Z(localClientNum, work, workerOutput);
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityBModelDrawRequest>::~CgEntityWorkersOutputBuilder<CgEntityBModelDrawRequest>
==============
*/

void __fastcall CgEntityWorkersOutputBuilder<CgEntityBModelDrawRequest>::~CgEntityWorkersOutputBuilder<CgEntityBModelDrawRequest>(CgEntityWorkersOutputBuilder<CgEntityBModelDrawRequest> *this)
{
  ??1?$CgEntityWorkersOutputBuilder@UCgEntityBModelDrawRequest@@@@QEAA@XZ(this);
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityFxMarkDetachAllRequest>::Submit
==============
*/

void __fastcall CgEntityWorkersOutputBuilder<CgEntityFxMarkDetachAllRequest>::Submit(CgEntityWorkersOutputBuilder<CgEntityFxMarkDetachAllRequest> *this)
{
  ?Submit@?$CgEntityWorkersOutputBuilder@UCgEntityFxMarkDetachAllRequest@@@@QEAAXXZ(this);
}

/*
==============
CG_EntityWorkers_ReleaseReadLock_Physics
==============
*/

void __fastcall CG_EntityWorkers_ReleaseReadLock_Physics(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  ?CG_EntityWorkers_ReleaseReadLock_Physics@@YAXW4CGEntityWorkersLegacyFallbackMode@@@Z(fallbackMode);
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityPlayerPostUpdate>::Submit
==============
*/

void __fastcall CgEntityWorkersOutputBuilder<CgEntityPlayerPostUpdate>::Submit(CgEntityWorkersOutputBuilder<CgEntityPlayerPostUpdate> *this)
{
  ?Submit@?$CgEntityWorkersOutputBuilder@UCgEntityPlayerPostUpdate@@@@QEAAXXZ(this);
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityDObjUpdateBoundsRequest>::Submit
==============
*/

void __fastcall CgEntityWorkersOutputBuilder<CgEntityDObjUpdateBoundsRequest>::Submit(CgEntityWorkersOutputBuilder<CgEntityDObjUpdateBoundsRequest> *this)
{
  ?Submit@?$CgEntityWorkersOutputBuilder@UCgEntityDObjUpdateBoundsRequest@@@@QEAAXXZ(this);
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityPlayerPostUpdate>::~CgEntityWorkersOutputBuilder<CgEntityPlayerPostUpdate>
==============
*/

void __fastcall CgEntityWorkersOutputBuilder<CgEntityPlayerPostUpdate>::~CgEntityWorkersOutputBuilder<CgEntityPlayerPostUpdate>(CgEntityWorkersOutputBuilder<CgEntityPlayerPostUpdate> *this)
{
  ??1?$CgEntityWorkersOutputBuilder@UCgEntityPlayerPostUpdate@@@@QEAA@XZ(this);
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityNotetrackRequest>::~CgEntityWorkersOutputBuilder<CgEntityNotetrackRequest>
==============
*/

void __fastcall CgEntityWorkersOutputBuilder<CgEntityNotetrackRequest>::~CgEntityWorkersOutputBuilder<CgEntityNotetrackRequest>(CgEntityWorkersOutputBuilder<CgEntityNotetrackRequest> *this)
{
  ??1?$CgEntityWorkersOutputBuilder@UCgEntityNotetrackRequest@@@@QEAA@XZ(this);
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityScriptableEventSunUpdate>::Begin
==============
*/

CgEntityScriptableEventSunUpdate *__fastcall CgEntityWorkersOutputBuilder<CgEntityScriptableEventSunUpdate>::Begin(CgEntityWorkersOutputBuilder<CgEntityScriptableEventSunUpdate> *this, const CgEntityWorkerOutputType requestType)
{
  return ?Begin@?$CgEntityWorkersOutputBuilder@UCgEntityScriptableEventSunUpdate@@@@QEAAAEAUCgEntityScriptableEventSunUpdate@@W4CgEntityWorkerOutputType@@@Z(this, requestType);
}

/*
==============
CG_EntityWorkers_AcquireWriteLock_Physics
==============
*/

void __fastcall CG_EntityWorkers_AcquireWriteLock_Physics(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  ?CG_EntityWorkers_AcquireWriteLock_Physics@@YAXW4CGEntityWorkersLegacyFallbackMode@@@Z(fallbackMode);
}

/*
==============
CG_EntityWorkers_TryAddBModelBoundsUpdate
==============
*/

bool __fastcall CG_EntityWorkers_TryAddBModelBoundsUpdate(const int entityIndex)
{
  return ?CG_EntityWorkers_TryAddBModelBoundsUpdate@@YA_NH@Z(entityIndex);
}

/*
==============
CG_EntityWorkers_InitProfileFrameData
==============
*/

void __fastcall CG_EntityWorkers_InitProfileFrameData(CgEntityWork *entityWork)
{
  ?CG_EntityWorkers_InitProfileFrameData@@YAXAEAUCgEntityWork@@@Z(entityWork);
}

/*
==============
CG_EntityWorkers_EnterCriticalSection_WithFallback<85>
==============
*/
void CG_EntityWorkers_EnterCriticalSection_WithFallback<85>(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  if ( CG_EntityWorkers_CriticalSection_CheckKillswitch_Enter(fallbackMode, 1) )
    Sys_EnterCriticalSection(CRITSECT_ENTITY_WORKER_LOCK);
}

/*
==============
CG_EntityWorkers_EnterCriticalSection_WithFallback<86>
==============
*/
void CG_EntityWorkers_EnterCriticalSection_WithFallback<86>(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  if ( CG_EntityWorkers_CritSecLegacyMode() )
  {
    if ( fallbackMode == BASE )
    {
      Sys_EnterCriticalSection(CRITSECT_ENTITY_WORKER_LOCK);
    }
    else if ( *(_BYTE *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1664i64) && !Sys_InCriticalSection(CRITSECT_ENTITY_WORKER_LOCK) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 415, ASSERT_TYPE_ASSERT, "(!CG_EntityWorkers_IsProcessingEntityWorker() || Sys_InCriticalSection( CRITSECT_ENTITY_WORKER_LOCK ))", (const char *)&queryFormat, "!CG_EntityWorkers_IsProcessingEntityWorker() || Sys_InCriticalSection( CRITSECT_ENTITY_WORKER_LOCK )") )
    {
      __debugbreak();
    }
  }
  else
  {
    Sys_EnterCriticalSection(CRITSECT_ENTITY_WORKER_VEHICLE_GETFX);
  }
}

/*
==============
CG_EntityWorkers_EnterCriticalSection_WithFallback<87>
==============
*/
void CG_EntityWorkers_EnterCriticalSection_WithFallback<87>(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  if ( CG_EntityWorkers_CritSecLegacyMode() )
  {
    if ( fallbackMode == BASE )
    {
      Sys_EnterCriticalSection(CRITSECT_ENTITY_WORKER_LOCK);
    }
    else if ( *(_BYTE *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1664i64) && !Sys_InCriticalSection(CRITSECT_ENTITY_WORKER_LOCK) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 415, ASSERT_TYPE_ASSERT, "(!CG_EntityWorkers_IsProcessingEntityWorker() || Sys_InCriticalSection( CRITSECT_ENTITY_WORKER_LOCK ))", (const char *)&queryFormat, "!CG_EntityWorkers_IsProcessingEntityWorker() || Sys_InCriticalSection( CRITSECT_ENTITY_WORKER_LOCK )") )
    {
      __debugbreak();
    }
  }
  else
  {
    Sys_EnterCriticalSection(CRITSECT_ENTITY_WORKER_LOCK_SCRIPTABLECL);
  }
}

/*
==============
CG_EntityWorkers_LeaveCriticalSection_WithFallback<85>
==============
*/
void CG_EntityWorkers_LeaveCriticalSection_WithFallback<85>(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  if ( CG_EntityWorkers_CriticalSection_CheckKillswitch_Leave(fallbackMode, 1) )
    Sys_LeaveCriticalSection(CRITSECT_ENTITY_WORKER_LOCK);
}

/*
==============
CG_EntityWorkers_LeaveCriticalSection_WithFallback<86>
==============
*/
void CG_EntityWorkers_LeaveCriticalSection_WithFallback<86>(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  if ( CG_EntityWorkers_CritSecLegacyMode() )
  {
    if ( fallbackMode == BASE )
    {
      Sys_LeaveCriticalSection(CRITSECT_ENTITY_WORKER_LOCK);
    }
    else if ( *(_BYTE *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1664i64) && !Sys_InCriticalSection(CRITSECT_ENTITY_WORKER_LOCK) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 445, ASSERT_TYPE_ASSERT, "(!CG_EntityWorkers_IsProcessingEntityWorker() || Sys_InCriticalSection( CRITSECT_ENTITY_WORKER_LOCK ))", (const char *)&queryFormat, "!CG_EntityWorkers_IsProcessingEntityWorker() || Sys_InCriticalSection( CRITSECT_ENTITY_WORKER_LOCK )") )
    {
      __debugbreak();
    }
  }
  else
  {
    Sys_LeaveCriticalSection(CRITSECT_ENTITY_WORKER_VEHICLE_GETFX);
  }
}

/*
==============
CG_EntityWorkers_LeaveCriticalSection_WithFallback<87>
==============
*/
void CG_EntityWorkers_LeaveCriticalSection_WithFallback<87>(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  if ( CG_EntityWorkers_CritSecLegacyMode() )
  {
    if ( fallbackMode == BASE )
    {
      Sys_LeaveCriticalSection(CRITSECT_ENTITY_WORKER_LOCK);
    }
    else if ( *(_BYTE *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1664i64) && !Sys_InCriticalSection(CRITSECT_ENTITY_WORKER_LOCK) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 445, ASSERT_TYPE_ASSERT, "(!CG_EntityWorkers_IsProcessingEntityWorker() || Sys_InCriticalSection( CRITSECT_ENTITY_WORKER_LOCK ))", (const char *)&queryFormat, "!CG_EntityWorkers_IsProcessingEntityWorker() || Sys_InCriticalSection( CRITSECT_ENTITY_WORKER_LOCK )") )
    {
      __debugbreak();
    }
  }
  else
  {
    Sys_LeaveCriticalSection(CRITSECT_ENTITY_WORKER_LOCK_SCRIPTABLECL);
  }
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityBModelDrawRequest>::~CgEntityWorkersOutputBuilder<CgEntityBModelDrawRequest>
==============
*/
void CgEntityWorkersOutputBuilder<CgEntityBModelDrawRequest>::~CgEntityWorkersOutputBuilder<CgEntityBModelDrawRequest>(CgEntityWorkersOutputBuilder<CgEntityBModelDrawRequest> *this)
{
  if ( !this->m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2383, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder was created but is missing its Begin() call") )
    __debugbreak();
  if ( !this->m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2384, ASSERT_TYPE_ASSERT, "( m_submitCalled )", "Entity Worker Output Builder was created but is missing its Submit() call") )
    __debugbreak();
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityBModelUpdateBoundsRequest>::~CgEntityWorkersOutputBuilder<CgEntityBModelUpdateBoundsRequest>
==============
*/
void CgEntityWorkersOutputBuilder<CgEntityBModelUpdateBoundsRequest>::~CgEntityWorkersOutputBuilder<CgEntityBModelUpdateBoundsRequest>(CgEntityWorkersOutputBuilder<CgEntityBModelUpdateBoundsRequest> *this)
{
  if ( !this->m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2383, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder was created but is missing its Begin() call") )
    __debugbreak();
  if ( !this->m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2384, ASSERT_TYPE_ASSERT, "( m_submitCalled )", "Entity Worker Output Builder was created but is missing its Submit() call") )
    __debugbreak();
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityDObjDrawRequest>::~CgEntityWorkersOutputBuilder<CgEntityDObjDrawRequest>
==============
*/
void CgEntityWorkersOutputBuilder<CgEntityDObjDrawRequest>::~CgEntityWorkersOutputBuilder<CgEntityDObjDrawRequest>(CgEntityWorkersOutputBuilder<CgEntityDObjDrawRequest> *this)
{
  if ( !this->m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2383, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder was created but is missing its Begin() call") )
    __debugbreak();
  if ( !this->m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2384, ASSERT_TYPE_ASSERT, "( m_submitCalled )", "Entity Worker Output Builder was created but is missing its Submit() call") )
    __debugbreak();
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityDObjUpdateBoundsRequest>::~CgEntityWorkersOutputBuilder<CgEntityDObjUpdateBoundsRequest>
==============
*/
void CgEntityWorkersOutputBuilder<CgEntityDObjUpdateBoundsRequest>::~CgEntityWorkersOutputBuilder<CgEntityDObjUpdateBoundsRequest>(CgEntityWorkersOutputBuilder<CgEntityDObjUpdateBoundsRequest> *this)
{
  if ( !this->m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2383, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder was created but is missing its Begin() call") )
    __debugbreak();
  if ( !this->m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2384, ASSERT_TYPE_ASSERT, "( m_submitCalled )", "Entity Worker Output Builder was created but is missing its Submit() call") )
    __debugbreak();
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityFxMarkDetachAllRequest>::~CgEntityWorkersOutputBuilder<CgEntityFxMarkDetachAllRequest>
==============
*/
void CgEntityWorkersOutputBuilder<CgEntityFxMarkDetachAllRequest>::~CgEntityWorkersOutputBuilder<CgEntityFxMarkDetachAllRequest>(CgEntityWorkersOutputBuilder<CgEntityFxMarkDetachAllRequest> *this)
{
  if ( !this->m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2383, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder was created but is missing its Begin() call") )
    __debugbreak();
  if ( !this->m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2384, ASSERT_TYPE_ASSERT, "( m_submitCalled )", "Entity Worker Output Builder was created but is missing its Submit() call") )
    __debugbreak();
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityNotetrackRequest>::~CgEntityWorkersOutputBuilder<CgEntityNotetrackRequest>
==============
*/
void CgEntityWorkersOutputBuilder<CgEntityNotetrackRequest>::~CgEntityWorkersOutputBuilder<CgEntityNotetrackRequest>(CgEntityWorkersOutputBuilder<CgEntityNotetrackRequest> *this)
{
  if ( !this->m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2383, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder was created but is missing its Begin() call") )
    __debugbreak();
  if ( !this->m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2384, ASSERT_TYPE_ASSERT, "( m_submitCalled )", "Entity Worker Output Builder was created but is missing its Submit() call") )
    __debugbreak();
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityPlayerPostUpdate>::~CgEntityWorkersOutputBuilder<CgEntityPlayerPostUpdate>
==============
*/
void CgEntityWorkersOutputBuilder<CgEntityPlayerPostUpdate>::~CgEntityWorkersOutputBuilder<CgEntityPlayerPostUpdate>(CgEntityWorkersOutputBuilder<CgEntityPlayerPostUpdate> *this)
{
  if ( !this->m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2383, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder was created but is missing its Begin() call") )
    __debugbreak();
  if ( !this->m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2384, ASSERT_TYPE_ASSERT, "( m_submitCalled )", "Entity Worker Output Builder was created but is missing its Submit() call") )
    __debugbreak();
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityScriptableEventLightUpdate>::~CgEntityWorkersOutputBuilder<CgEntityScriptableEventLightUpdate>
==============
*/
void CgEntityWorkersOutputBuilder<CgEntityScriptableEventLightUpdate>::~CgEntityWorkersOutputBuilder<CgEntityScriptableEventLightUpdate>(CgEntityWorkersOutputBuilder<CgEntityScriptableEventLightUpdate> *this)
{
  if ( !this->m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2383, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder was created but is missing its Begin() call") )
    __debugbreak();
  if ( !this->m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2384, ASSERT_TYPE_ASSERT, "( m_submitCalled )", "Entity Worker Output Builder was created but is missing its Submit() call") )
    __debugbreak();
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityScriptableEventSunUpdate>::~CgEntityWorkersOutputBuilder<CgEntityScriptableEventSunUpdate>
==============
*/
void CgEntityWorkersOutputBuilder<CgEntityScriptableEventSunUpdate>::~CgEntityWorkersOutputBuilder<CgEntityScriptableEventSunUpdate>(CgEntityWorkersOutputBuilder<CgEntityScriptableEventSunUpdate> *this)
{
  if ( !this->m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2383, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder was created but is missing its Begin() call") )
    __debugbreak();
  if ( !this->m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2384, ASSERT_TYPE_ASSERT, "( m_submitCalled )", "Entity Worker Output Builder was created but is missing its Submit() call") )
    __debugbreak();
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityScriptableSpatialUpdate>::~CgEntityWorkersOutputBuilder<CgEntityScriptableSpatialUpdate>
==============
*/
void CgEntityWorkersOutputBuilder<CgEntityScriptableSpatialUpdate>::~CgEntityWorkersOutputBuilder<CgEntityScriptableSpatialUpdate>(CgEntityWorkersOutputBuilder<CgEntityScriptableSpatialUpdate> *this)
{
  if ( !this->m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2383, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder was created but is missing its Begin() call") )
    __debugbreak();
  if ( !this->m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2384, ASSERT_TYPE_ASSERT, "( m_submitCalled )", "Entity Worker Output Builder was created but is missing its Submit() call") )
    __debugbreak();
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntitySoundRequest>::~CgEntityWorkersOutputBuilder<CgEntitySoundRequest>
==============
*/
void CgEntityWorkersOutputBuilder<CgEntitySoundRequest>::~CgEntityWorkersOutputBuilder<CgEntitySoundRequest>(CgEntityWorkersOutputBuilder<CgEntitySoundRequest> *this)
{
  if ( !this->m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2383, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder was created but is missing its Begin() call") )
    __debugbreak();
  if ( !this->m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2384, ASSERT_TYPE_ASSERT, "( m_submitCalled )", "Entity Worker Output Builder was created but is missing its Submit() call") )
    __debugbreak();
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityTurretBarrelSpinSoundRequest>::~CgEntityWorkersOutputBuilder<CgEntityTurretBarrelSpinSoundRequest>
==============
*/
void CgEntityWorkersOutputBuilder<CgEntityTurretBarrelSpinSoundRequest>::~CgEntityWorkersOutputBuilder<CgEntityTurretBarrelSpinSoundRequest>(CgEntityWorkersOutputBuilder<CgEntityTurretBarrelSpinSoundRequest> *this)
{
  if ( !this->m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2383, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder was created but is missing its Begin() call") )
    __debugbreak();
  if ( !this->m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2384, ASSERT_TYPE_ASSERT, "( m_submitCalled )", "Entity Worker Output Builder was created but is missing its Submit() call") )
    __debugbreak();
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityScriptableEventLightUpdate>::Begin
==============
*/
CgEntityWorkersOutputBuilder<CgEntityScriptableEventLightUpdate> *CgEntityWorkersOutputBuilder<CgEntityScriptableEventLightUpdate>::Begin(CgEntityWorkersOutputBuilder<CgEntityScriptableEventLightUpdate> *this, const CgEntityWorkerOutputType requestType)
{
  char v2; 

  v2 = requestType;
  if ( !Sys_IsMainThreadEntityWorker() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2390, ASSERT_TYPE_ASSERT, "(CG_EntityWorkers_WorkersCurrentlyActive())", (const char *)&queryFormat, "CG_EntityWorkers_WorkersCurrentlyActive()") )
    __debugbreak();
  if ( this->m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2392, ASSERT_TYPE_ASSERT, "( !m_beginCalled )", "Entity Worker Output Builder called Begin() more than once") )
    __debugbreak();
  if ( this->m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2393, ASSERT_TYPE_ASSERT, "( !m_submitCalled )", "Entity Worker Output Builder must call Begin() before Submit") )
    __debugbreak();
  this->m_beginCalled = 1;
  this->m_requestType[0] = v2;
  DebugWipe(this, 0x18ui64);
  return this;
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityScriptableEventSunUpdate>::Begin
==============
*/
CgEntityWorkersOutputBuilder<CgEntityScriptableEventSunUpdate> *CgEntityWorkersOutputBuilder<CgEntityScriptableEventSunUpdate>::Begin(CgEntityWorkersOutputBuilder<CgEntityScriptableEventSunUpdate> *this, const CgEntityWorkerOutputType requestType)
{
  char v2; 

  v2 = requestType;
  if ( !Sys_IsMainThreadEntityWorker() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2390, ASSERT_TYPE_ASSERT, "(CG_EntityWorkers_WorkersCurrentlyActive())", (const char *)&queryFormat, "CG_EntityWorkers_WorkersCurrentlyActive()") )
    __debugbreak();
  if ( this->m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2392, ASSERT_TYPE_ASSERT, "( !m_beginCalled )", "Entity Worker Output Builder called Begin() more than once") )
    __debugbreak();
  if ( this->m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2393, ASSERT_TYPE_ASSERT, "( !m_submitCalled )", "Entity Worker Output Builder must call Begin() before Submit") )
    __debugbreak();
  this->m_beginCalled = 1;
  this->m_requestType[0] = v2;
  DebugWipe(this, 0x20ui64);
  return this;
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntitySoundRequest>::Begin
==============
*/
CgEntityWorkersOutputBuilder<CgEntitySoundRequest> *CgEntityWorkersOutputBuilder<CgEntitySoundRequest>::Begin(CgEntityWorkersOutputBuilder<CgEntitySoundRequest> *this, const CgEntityWorkerOutputType requestType)
{
  char v2; 

  v2 = requestType;
  if ( !Sys_IsMainThreadEntityWorker() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2390, ASSERT_TYPE_ASSERT, "(CG_EntityWorkers_WorkersCurrentlyActive())", (const char *)&queryFormat, "CG_EntityWorkers_WorkersCurrentlyActive()") )
    __debugbreak();
  if ( this->m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2392, ASSERT_TYPE_ASSERT, "( !m_beginCalled )", "Entity Worker Output Builder called Begin() more than once") )
    __debugbreak();
  if ( this->m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2393, ASSERT_TYPE_ASSERT, "( !m_submitCalled )", "Entity Worker Output Builder must call Begin() before Submit") )
    __debugbreak();
  this->m_beginCalled = 1;
  this->m_requestType[0] = v2;
  DebugWipe(this, 0x38ui64);
  return this;
}

/*
==============
CG_EntityWorkers_AcquireReadLock_Physics
==============
*/
void CG_EntityWorkers_AcquireReadLock_Physics(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  const dvar_t *v1; 
  __int64 v3; 

  v1 = DVARBOOL_cg_entityWorkers;
  if ( !DVARBOOL_cg_entityWorkers && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkers") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  if ( v1->current.enabled )
  {
    v3 = 8i64 * tls_index;
    if ( *(_BYTE *)(*(_QWORD *)((char *)NtCurrentTeb()->Reserved1[11] + v3) + 1664i64) )
    {
      if ( CG_EntityWorkers_CritSecLegacyMode() )
      {
        if ( fallbackMode == BASE )
        {
          Sys_EnterCriticalSection(CRITSECT_ENTITY_WORKER_LOCK);
        }
        else if ( *(_BYTE *)(*(_QWORD *)((char *)NtCurrentTeb()->Reserved1[11] + v3) + 1664i64) && !Sys_InCriticalSection(CRITSECT_ENTITY_WORKER_LOCK) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 415, ASSERT_TYPE_ASSERT, "(!CG_EntityWorkers_IsProcessingEntityWorker() || Sys_InCriticalSection( CRITSECT_ENTITY_WORKER_LOCK ))", (const char *)&queryFormat, "!CG_EntityWorkers_IsProcessingEntityWorker() || Sys_InCriticalSection( CRITSECT_ENTITY_WORKER_LOCK )") )
        {
          __debugbreak();
        }
      }
      else
      {
        Sys_CheckAcquireLock(&ms_entityWorkRWLockPhysics);
        AcquireSRWLockShared((PSRWLOCK)&ms_entityWorkRWLockPhysics);
      }
    }
  }
}

/*
==============
CG_EntityWorkers_AcquireWriteLock_Physics
==============
*/
void CG_EntityWorkers_AcquireWriteLock_Physics(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  const dvar_t *v1; 
  __int64 v3; 
  bool v4; 

  v1 = DVARBOOL_cg_entityWorkers;
  if ( !DVARBOOL_cg_entityWorkers && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkers") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  if ( v1->current.enabled )
  {
    v3 = 8i64 * tls_index;
    if ( *(_BYTE *)(*(_QWORD *)((char *)NtCurrentTeb()->Reserved1[11] + v3) + 1664i64) )
    {
      if ( !CG_EntityWorkers_CritSecLegacyMode() )
      {
        Sys_CheckAcquireLock(&ms_entityWorkRWLockPhysics);
        AcquireSRWLockExclusive((PSRWLOCK)&ms_entityWorkRWLockPhysics);
        ms_entityWorkRWLockPhysics.writeThreadId = Sys_GetCurrentThreadId();
        if ( ms_entityWorkRWLockPhysics.writeThreadId )
          return;
        v4 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_rwlock.h", 177, ASSERT_TYPE_ASSERT, "( lock->writeThreadId ) != ( INVALID_THREAD_ID )", "%s != %s\n\t%i, %i", "lock->writeThreadId", "INVALID_THREAD_ID", 0, 0i64);
        goto LABEL_14;
      }
      if ( fallbackMode == BASE )
      {
        Sys_EnterCriticalSection(CRITSECT_ENTITY_WORKER_LOCK);
        return;
      }
      if ( *(_BYTE *)(*(_QWORD *)((char *)NtCurrentTeb()->Reserved1[11] + v3) + 1664i64) && !Sys_InCriticalSection(CRITSECT_ENTITY_WORKER_LOCK) )
      {
        v4 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 415, ASSERT_TYPE_ASSERT, "(!CG_EntityWorkers_IsProcessingEntityWorker() || Sys_InCriticalSection( CRITSECT_ENTITY_WORKER_LOCK ))", (const char *)&queryFormat, "!CG_EntityWorkers_IsProcessingEntityWorker() || Sys_InCriticalSection( CRITSECT_ENTITY_WORKER_LOCK )");
LABEL_14:
        if ( v4 )
          __debugbreak();
      }
    }
  }
}

/*
==============
CG_EntityWorkers_AddChainToDistributedWorker
==============
*/
void CG_EntityWorkers_AddChainToDistributedWorker(const CgEntityWorkBuilder *buildWorkers, const unsigned __int16 chainIndex, unsigned __int16 *workerPriorityQueue, CgEntityWork *work)
{
  unsigned __int16 workerMaxCount; 
  unsigned __int16 v9; 
  bool IsCostBalancingEnabled; 
  __int64 v11; 
  __int64 v12; 
  __int64 v13; 

  if ( !buildWorkers && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1259, ASSERT_TYPE_ASSERT, "(buildWorkers)", (const char *)&queryFormat, "buildWorkers") )
    __debugbreak();
  if ( !work && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1260, ASSERT_TYPE_ASSERT, "(work)", (const char *)&queryFormat, "work") )
    __debugbreak();
  workerMaxCount = work->workerMaxCount;
  if ( workerMaxCount > 0x100u && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1261, ASSERT_TYPE_ASSERT, "( work->workerMaxCount ) <= ( (256) )", "%s <= %s\n\t%i, %i", "work->workerMaxCount", "MAX_ENTITY_WORKERS", workerMaxCount, 256) )
    __debugbreak();
  if ( chainIndex >= 0x800u )
  {
    LODWORD(v13) = 2048;
    LODWORD(v12) = chainIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1263, ASSERT_TYPE_ASSERT, "(unsigned)( chainIndex ) < (unsigned)( ( sizeof( *array_counter( buildWorkers->chainEntityHead ) ) + 0 ) )", "chainIndex doesn't index ARRAY_COUNT( buildWorkers->chainEntityHead )\n\t%i not in [0, %i)", v12, v13) )
      __debugbreak();
  }
  if ( buildWorkers->chainEntityHead[chainIndex] == 2047 )
  {
    LODWORD(v12) = chainIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1264, ASSERT_TYPE_ASSERT, "( ( buildWorkers->chainEntityHead[chainIndex] != ENTITYNUM_NONE ) )", "( chainIndex ) = %i", v12) )
      __debugbreak();
  }
  if ( buildWorkers->chainEntityTail[chainIndex] == 2047 )
  {
    LODWORD(v12) = chainIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1265, ASSERT_TYPE_ASSERT, "( ( buildWorkers->chainEntityTail[chainIndex] != ENTITYNUM_NONE ) )", "( chainIndex ) = %i", v12) )
      __debugbreak();
  }
  if ( !buildWorkers->chainEntityCount[chainIndex] )
  {
    LODWORD(v12) = chainIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1266, ASSERT_TYPE_ASSERT, "( ( buildWorkers->chainEntityCount[chainIndex] > 0 ) )", "( chainIndex ) = %i", v12) )
      __debugbreak();
  }
  if ( !buildWorkers->chainEntityCost[chainIndex] )
  {
    LODWORD(v12) = chainIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1267, ASSERT_TYPE_ASSERT, "( ( buildWorkers->chainEntityCost[chainIndex] > 0 ) )", "( chainIndex ) = %i", v12) )
      __debugbreak();
  }
  v9 = work->workerMaxCount;
  if ( !v9 )
  {
    LODWORD(v13) = 0;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1272, ASSERT_TYPE_ASSERT, "(unsigned)( workerQueueItem ) < (unsigned)( workerMaxCount )", "workerQueueItem doesn't index workerMaxCount\n\t%i not in [0, %i)", 0i64, v13) )
      __debugbreak();
  }
  CG_EntityWorkers_AddChainToWorker(buildWorkers, chainIndex, work, *workerPriorityQueue);
  IsCostBalancingEnabled = CG_EntityWorkers_IsCostBalancingEnabled();
  v11 = 1046i64;
  if ( IsCostBalancingEnabled )
    v11 = 1558i64;
  CG_EntityWorkers_SortWorkerPriorityQueue((const unsigned __int16 *)((char *)work + v11), 0, v9, workerPriorityQueue);
}

/*
==============
CG_EntityWorkers_AddChainToMainThreadWorker
==============
*/
void CG_EntityWorkers_AddChainToMainThreadWorker(const CgEntityWorkBuilder *buildWorkers, const unsigned __int16 chainIndex, CgEntityWork *work)
{
  __int64 v6; 
  unsigned __int16 mainEntityTail; 
  unsigned __int16 *v8; 
  __int64 v9; 
  __int64 v10; 

  if ( !buildWorkers && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1293, ASSERT_TYPE_ASSERT, "(buildWorkers)", (const char *)&queryFormat, "buildWorkers") )
    __debugbreak();
  if ( !work && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1294, ASSERT_TYPE_ASSERT, "(work)", (const char *)&queryFormat, "work") )
    __debugbreak();
  if ( chainIndex >= 0x800u )
  {
    LODWORD(v9) = chainIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1296, ASSERT_TYPE_ASSERT, "(unsigned)( chainIndex ) < (unsigned)( ( sizeof( *array_counter( buildWorkers->chainEntityHead ) ) + 0 ) )", "chainIndex doesn't index ARRAY_COUNT( buildWorkers->chainEntityHead )\n\t%i not in [0, %i)", v9, 2048) )
      __debugbreak();
  }
  v6 = chainIndex;
  if ( buildWorkers->chainEntityHead[chainIndex] == 2047 )
  {
    LODWORD(v9) = chainIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1297, ASSERT_TYPE_ASSERT, "( ( buildWorkers->chainEntityHead[chainIndex] != ENTITYNUM_NONE ) )", "( chainIndex ) = %i", v9) )
      __debugbreak();
  }
  if ( buildWorkers->chainEntityTail[chainIndex] == 2047 )
  {
    LODWORD(v9) = chainIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1298, ASSERT_TYPE_ASSERT, "( ( buildWorkers->chainEntityTail[chainIndex] != ENTITYNUM_NONE ) )", "( chainIndex ) = %i", v9) )
      __debugbreak();
  }
  if ( !buildWorkers->chainEntityCount[chainIndex] )
  {
    LODWORD(v9) = chainIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1299, ASSERT_TYPE_ASSERT, "( ( buildWorkers->chainEntityCount[chainIndex] > 0 ) )", "( chainIndex ) = %i", v9) )
      __debugbreak();
  }
  if ( !buildWorkers->chainEntityCost[chainIndex] )
  {
    LODWORD(v9) = chainIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1300, ASSERT_TYPE_ASSERT, "( ( buildWorkers->chainEntityCost[chainIndex] > 0 ) )", "( chainIndex ) = %i", v9) )
      __debugbreak();
  }
  mainEntityTail = work->mainEntityTail;
  if ( work->mainEntityHead == 2047 )
  {
    if ( mainEntityTail != 2047 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1304, ASSERT_TYPE_ASSERT, "(work->mainEntityTail == ENTITYNUM_NONE)", (const char *)&queryFormat, "work->mainEntityTail == ENTITYNUM_NONE") )
      __debugbreak();
    work->mainEntityHead = buildWorkers->chainEntityHead[v6];
    work->mainEntityTail = buildWorkers->chainEntityTail[v6];
    work->mainEntityCount = buildWorkers->chainEntityCount[v6];
    work->mainEntityCost = buildWorkers->chainEntityCost[v6];
  }
  else
  {
    if ( mainEntityTail >= 0x7FEu )
    {
      LODWORD(v10) = 2046;
      LODWORD(v9) = mainEntityTail;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1314, ASSERT_TYPE_ASSERT, "(unsigned)( tailEntityIndex ) < (unsigned)( ENTITYNUM_ORDINARY_END )", "tailEntityIndex doesn't index ENTITYNUM_ORDINARY_END\n\t%i not in [0, %i)", v9, v10) )
        __debugbreak();
    }
    v8 = &work->entityNext[mainEntityTail];
    if ( *v8 != 2047 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1315, ASSERT_TYPE_ASSERT, "(work->entityNext[tailEntityIndex] == ENTITYNUM_NONE)", (const char *)&queryFormat, "work->entityNext[tailEntityIndex] == ENTITYNUM_NONE") )
      __debugbreak();
    *v8 = buildWorkers->chainEntityHead[v6];
    work->mainEntityTail = buildWorkers->chainEntityTail[v6];
    work->mainEntityCount += buildWorkers->chainEntityCount[v6];
    work->mainEntityCost += buildWorkers->chainEntityCost[v6];
  }
}

/*
==============
CG_EntityWorkers_AddChainToPostPlayerstateWorker
==============
*/
void CG_EntityWorkers_AddChainToPostPlayerstateWorker(const CgEntityWorkBuilder *buildWorkers, const unsigned __int16 chainIndex, CgEntityWork *work)
{
  __int64 v6; 
  unsigned __int16 postPsEntityTail; 
  unsigned __int16 *v8; 
  __int64 v9; 
  __int64 v10; 

  if ( !buildWorkers && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1327, ASSERT_TYPE_ASSERT, "(buildWorkers)", (const char *)&queryFormat, "buildWorkers") )
    __debugbreak();
  if ( !work && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1328, ASSERT_TYPE_ASSERT, "(work)", (const char *)&queryFormat, "work") )
    __debugbreak();
  if ( chainIndex >= 0x800u )
  {
    LODWORD(v9) = chainIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1330, ASSERT_TYPE_ASSERT, "(unsigned)( chainIndex ) < (unsigned)( ( sizeof( *array_counter( buildWorkers->chainEntityHead ) ) + 0 ) )", "chainIndex doesn't index ARRAY_COUNT( buildWorkers->chainEntityHead )\n\t%i not in [0, %i)", v9, 2048) )
      __debugbreak();
  }
  v6 = chainIndex;
  if ( buildWorkers->chainEntityHead[chainIndex] == 2047 )
  {
    LODWORD(v9) = chainIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1331, ASSERT_TYPE_ASSERT, "( ( buildWorkers->chainEntityHead[chainIndex] != ENTITYNUM_NONE ) )", "( chainIndex ) = %i", v9) )
      __debugbreak();
  }
  if ( buildWorkers->chainEntityTail[chainIndex] == 2047 )
  {
    LODWORD(v9) = chainIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1332, ASSERT_TYPE_ASSERT, "( ( buildWorkers->chainEntityTail[chainIndex] != ENTITYNUM_NONE ) )", "( chainIndex ) = %i", v9) )
      __debugbreak();
  }
  if ( !buildWorkers->chainEntityCount[chainIndex] )
  {
    LODWORD(v9) = chainIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1333, ASSERT_TYPE_ASSERT, "( ( buildWorkers->chainEntityCount[chainIndex] > 0 ) )", "( chainIndex ) = %i", v9) )
      __debugbreak();
  }
  if ( !buildWorkers->chainEntityCost[chainIndex] )
  {
    LODWORD(v9) = chainIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1334, ASSERT_TYPE_ASSERT, "( ( buildWorkers->chainEntityCost[chainIndex] > 0 ) )", "( chainIndex ) = %i", v9) )
      __debugbreak();
  }
  postPsEntityTail = work->postPsEntityTail;
  if ( work->postPsEntityHead == 2047 )
  {
    if ( postPsEntityTail != 2047 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1338, ASSERT_TYPE_ASSERT, "(work->postPsEntityTail == ENTITYNUM_NONE)", (const char *)&queryFormat, "work->postPsEntityTail == ENTITYNUM_NONE") )
      __debugbreak();
    work->postPsEntityHead = buildWorkers->chainEntityHead[v6];
    work->postPsEntityTail = buildWorkers->chainEntityTail[v6];
    work->postPsEntityCount = buildWorkers->chainEntityCount[v6];
    work->postPsEntityCost = buildWorkers->chainEntityCost[v6];
  }
  else
  {
    if ( postPsEntityTail >= 0x7FEu )
    {
      LODWORD(v10) = 2046;
      LODWORD(v9) = postPsEntityTail;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1348, ASSERT_TYPE_ASSERT, "(unsigned)( tailEntityIndex ) < (unsigned)( ENTITYNUM_ORDINARY_END )", "tailEntityIndex doesn't index ENTITYNUM_ORDINARY_END\n\t%i not in [0, %i)", v9, v10) )
        __debugbreak();
    }
    v8 = &work->entityNext[postPsEntityTail];
    if ( *v8 != 2047 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1349, ASSERT_TYPE_ASSERT, "(work->entityNext[tailEntityIndex] == ENTITYNUM_NONE)", (const char *)&queryFormat, "work->entityNext[tailEntityIndex] == ENTITYNUM_NONE") )
      __debugbreak();
    *v8 = buildWorkers->chainEntityHead[v6];
    work->postPsEntityTail = buildWorkers->chainEntityTail[v6];
    work->postPsEntityCount += buildWorkers->chainEntityCount[v6];
    work->postPsEntityCost += buildWorkers->chainEntityCost[v6];
  }
}

/*
==============
CG_EntityWorkers_AddChainToWorker
==============
*/
void CG_EntityWorkers_AddChainToWorker(const CgEntityWorkBuilder *buildWorkers, const unsigned __int16 chainIndex, CgEntityWork *work, const unsigned __int16 workerIndex)
{
  unsigned __int16 workerMaxCount; 
  unsigned __int16 v9; 
  unsigned __int16 *v10; 
  __int64 v11; 
  __int64 v12; 

  if ( !buildWorkers && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1196, ASSERT_TYPE_ASSERT, "(buildWorkers)", (const char *)&queryFormat, "buildWorkers") )
    __debugbreak();
  if ( !work && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1197, ASSERT_TYPE_ASSERT, "(work)", (const char *)&queryFormat, "work") )
    __debugbreak();
  workerMaxCount = work->workerMaxCount;
  if ( workerIndex >= workerMaxCount )
  {
    LODWORD(v11) = workerIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1198, ASSERT_TYPE_ASSERT, "(unsigned)( workerIndex ) < (unsigned)( work->workerMaxCount )", "workerIndex doesn't index work->workerMaxCount\n\t%i not in [0, %i)", v11, workerMaxCount) )
      __debugbreak();
  }
  if ( buildWorkers->chainEntityHead[chainIndex] == 2047 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1200, ASSERT_TYPE_ASSERT, "(buildWorkers->chainEntityHead[chainIndex] != ENTITYNUM_NONE)", (const char *)&queryFormat, "buildWorkers->chainEntityHead[chainIndex] != ENTITYNUM_NONE") )
    __debugbreak();
  if ( buildWorkers->chainEntityTail[chainIndex] == 2047 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1201, ASSERT_TYPE_ASSERT, "(buildWorkers->chainEntityTail[chainIndex] != ENTITYNUM_NONE)", (const char *)&queryFormat, "buildWorkers->chainEntityTail[chainIndex] != ENTITYNUM_NONE") )
    __debugbreak();
  v9 = work->workerTail[workerIndex];
  if ( work->workerHead[workerIndex] == 2047 )
  {
    if ( v9 != 2047 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1205, ASSERT_TYPE_ASSERT, "(work->workerTail[workerIndex] == ENTITYNUM_NONE)", (const char *)&queryFormat, "work->workerTail[workerIndex] == ENTITYNUM_NONE") )
      __debugbreak();
    work->workerHead[workerIndex] = buildWorkers->chainEntityHead[chainIndex];
    work->workerTail[workerIndex] = buildWorkers->chainEntityTail[chainIndex];
    work->workerSize[workerIndex] = buildWorkers->chainEntityCount[chainIndex];
    work->workerCost[workerIndex] = buildWorkers->chainEntityCost[chainIndex];
  }
  else
  {
    if ( v9 >= 0x7FEu )
    {
      LODWORD(v12) = 2046;
      LODWORD(v11) = v9;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1215, ASSERT_TYPE_ASSERT, "(unsigned)( tailEntityIndex ) < (unsigned)( ENTITYNUM_ORDINARY_END )", "tailEntityIndex doesn't index ENTITYNUM_ORDINARY_END\n\t%i not in [0, %i)", v11, v12) )
        __debugbreak();
    }
    v10 = &work->entityNext[v9];
    if ( *v10 != 2047 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1216, ASSERT_TYPE_ASSERT, "(work->entityNext[tailEntityIndex] == ENTITYNUM_NONE)", (const char *)&queryFormat, "work->entityNext[tailEntityIndex] == ENTITYNUM_NONE") )
      __debugbreak();
    *v10 = buildWorkers->chainEntityHead[chainIndex];
    work->workerTail[workerIndex] = buildWorkers->chainEntityTail[chainIndex];
    work->workerSize[workerIndex] += buildWorkers->chainEntityCount[chainIndex];
    work->workerCost[workerIndex] += buildWorkers->chainEntityCost[chainIndex];
  }
}

/*
==============
CG_EntityWorkers_AddToWorkChain
==============
*/
__int64 CG_EntityWorkers_AddToWorkChain(const unsigned __int16 entityIndex, const CgEntityWorkData *workData, const CgEntityWorkBuilderCmd *workerCmd)
{
  CgEntityWorkBuilder *workBuilder; 
  unsigned __int16 nextChain; 
  __int64 result; 
  __int64 v9; 
  __int64 v10; 

  if ( entityIndex >= 0x7FEu && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1066, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ENTITYNUM_ORDINARY_END )", "entityIndex doesn't index ENTITYNUM_ORDINARY_END\n\t%i not in [0, %i)", entityIndex, 2046) )
    __debugbreak();
  if ( !workerCmd && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1067, ASSERT_TYPE_ASSERT, "(workerCmd)", (const char *)&queryFormat, "workerCmd") )
    __debugbreak();
  workBuilder = workerCmd->workBuilder;
  if ( !workBuilder && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1070, ASSERT_TYPE_ASSERT, "(buildWorkers)", (const char *)&queryFormat, "buildWorkers") )
    __debugbreak();
  nextChain = workBuilder->nextChain;
  if ( workBuilder->nextChain >= 0x800u )
  {
    LODWORD(v10) = 2048;
    LODWORD(v9) = nextChain;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1074, ASSERT_TYPE_ASSERT, "(unsigned)( chainIndex ) < (unsigned)( ( sizeof( *array_counter( buildWorkers->chainEntityHead ) ) + 0 ) )", "chainIndex doesn't index ARRAY_COUNT( buildWorkers->chainEntityHead )\n\t%i not in [0, %i)", v9, v10) )
      __debugbreak();
  }
  if ( workBuilder->chainEntityHead[nextChain] != 2047 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1075, ASSERT_TYPE_ASSERT, "(buildWorkers->chainEntityHead[chainIndex] == ENTITYNUM_NONE)", "%s\n\tCould not find an empty chain for entity", "buildWorkers->chainEntityHead[chainIndex] == ENTITYNUM_NONE") )
    __debugbreak();
  if ( workBuilder->chainEntityTail[nextChain] != 2047 )
  {
    LODWORD(v9) = nextChain;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1076, ASSERT_TYPE_ASSERT, "( ( buildWorkers->chainEntityTail[chainIndex] == ENTITYNUM_NONE ) )", "( chainIndex ) = %i", v9) )
      __debugbreak();
  }
  if ( workBuilder->chainEntityCount[nextChain] )
  {
    LODWORD(v9) = nextChain;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1077, ASSERT_TYPE_ASSERT, "( ( buildWorkers->chainEntityCount[chainIndex] == 0 ) )", "( chainIndex ) = %i", v9) )
      __debugbreak();
  }
  if ( workBuilder->chainEntityCost[nextChain] )
  {
    LODWORD(v9) = nextChain;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1078, ASSERT_TYPE_ASSERT, "( ( buildWorkers->chainEntityCost[chainIndex] == 0 ) )", "( chainIndex ) = %i", v9) )
      __debugbreak();
  }
  workBuilder->chainEntityHead[nextChain] = entityIndex;
  workBuilder->chainEntityTail[nextChain] = entityIndex;
  workBuilder->chainEntityFlags[nextChain] = workData->flags;
  workBuilder->chainEntityCost[nextChain] = workData->cost;
  workBuilder->chainEntityCount[nextChain] = 1;
  if ( ++workBuilder->nextChain > 0x800u )
  {
    LODWORD(v10) = 2048;
    LODWORD(v9) = workBuilder->nextChain;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1088, ASSERT_TYPE_ASSERT, "( buildWorkers->nextChain ) <= ( ( sizeof( *array_counter( buildWorkers->chainEntityHead ) ) + 0 ) )", "buildWorkers->nextChain not in [0, ARRAY_COUNT( buildWorkers->chainEntityHead )]\n\t%u not in [0, %u]", v9, v10) )
      __debugbreak();
  }
  result = nextChain;
  workBuilder->chainIndex[entityIndex] = nextChain;
  return result;
}

/*
==============
CG_EntityWorkers_AppendWorkChain
==============
*/
void CG_EntityWorkers_AppendWorkChain(const unsigned __int16 destChainIndex, const unsigned __int16 srcChainIndex, const CgEntityWorkBuilderCmd *workerCmd)
{
  CgEntityWork *workerData; 
  CgEntityWorkBuilder *workBuilder; 
  __int64 v8; 
  __int64 v9; 
  unsigned __int16 v10; 
  unsigned __int16 v11; 
  unsigned __int16 *chainIndex; 
  __int64 v13; 
  __int64 v14; 
  __int64 v15; 
  __int64 v16; 
  __int64 v17; 
  __int64 v18; 

  if ( !workerCmd && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 977, ASSERT_TYPE_ASSERT, "(workerCmd)", (const char *)&queryFormat, "workerCmd") )
    __debugbreak();
  workerData = workerCmd->workerData;
  if ( !workerData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 980, ASSERT_TYPE_ASSERT, "(work)", (const char *)&queryFormat, "work") )
    __debugbreak();
  workBuilder = workerCmd->workBuilder;
  if ( !workBuilder && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 983, ASSERT_TYPE_ASSERT, "(buildWorkers)", (const char *)&queryFormat, "buildWorkers") )
    __debugbreak();
  if ( destChainIndex >= 0x800u )
  {
    LODWORD(v14) = destChainIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 985, ASSERT_TYPE_ASSERT, "(unsigned)( destChainIndex ) < (unsigned)( ( sizeof( *array_counter( buildWorkers->chainEntityHead ) ) + 0 ) )", "destChainIndex doesn't index ARRAY_COUNT( buildWorkers->chainEntityHead )\n\t%i not in [0, %i)", v14, 2048) )
      __debugbreak();
  }
  v18 = destChainIndex;
  if ( workBuilder->chainEntityHead[destChainIndex] == 2047 )
  {
    LODWORD(v14) = destChainIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 986, ASSERT_TYPE_ASSERT, "( ( buildWorkers->chainEntityHead[destChainIndex] != ENTITYNUM_NONE ) )", "( destChainIndex ) = %i", v14) )
      __debugbreak();
  }
  if ( workBuilder->chainEntityTail[destChainIndex] == 2047 )
  {
    LODWORD(v14) = destChainIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 987, ASSERT_TYPE_ASSERT, "( ( buildWorkers->chainEntityTail[destChainIndex] != ENTITYNUM_NONE ) )", "( destChainIndex ) = %i", v14) )
      __debugbreak();
  }
  if ( !workBuilder->chainEntityCount[destChainIndex] )
  {
    LODWORD(v14) = destChainIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 988, ASSERT_TYPE_ASSERT, "( ( buildWorkers->chainEntityCount[destChainIndex] != 0 ) )", "( destChainIndex ) = %i", v14) )
      __debugbreak();
  }
  if ( !workBuilder->chainEntityCost[destChainIndex] )
  {
    LODWORD(v14) = destChainIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 989, ASSERT_TYPE_ASSERT, "( ( buildWorkers->chainEntityCost[destChainIndex] != 0 ) )", "( destChainIndex ) = %i", v14) )
      __debugbreak();
  }
  if ( srcChainIndex >= 0x800u )
  {
    LODWORD(v15) = 2048;
    LODWORD(v14) = srcChainIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 991, ASSERT_TYPE_ASSERT, "(unsigned)( srcChainIndex ) < (unsigned)( ( sizeof( *array_counter( buildWorkers->chainEntityHead ) ) + 0 ) )", "srcChainIndex doesn't index ARRAY_COUNT( buildWorkers->chainEntityHead )\n\t%i not in [0, %i)", v14, v15) )
      __debugbreak();
  }
  v8 = srcChainIndex;
  if ( workBuilder->chainEntityHead[srcChainIndex] == 2047 )
  {
    LODWORD(v14) = srcChainIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 992, ASSERT_TYPE_ASSERT, "( ( buildWorkers->chainEntityHead[srcChainIndex] != ENTITYNUM_NONE ) )", "( srcChainIndex ) = %i", v14) )
      __debugbreak();
  }
  if ( workBuilder->chainEntityTail[srcChainIndex] == 2047 )
  {
    LODWORD(v14) = srcChainIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 993, ASSERT_TYPE_ASSERT, "( ( buildWorkers->chainEntityTail[srcChainIndex] != ENTITYNUM_NONE ) )", "( srcChainIndex ) = %i", v14) )
      __debugbreak();
  }
  if ( !workBuilder->chainEntityCount[srcChainIndex] )
  {
    LODWORD(v14) = srcChainIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 994, ASSERT_TYPE_ASSERT, "( ( buildWorkers->chainEntityCount[srcChainIndex] != 0 ) )", "( srcChainIndex ) = %i", v14) )
      __debugbreak();
  }
  if ( !workBuilder->chainEntityCost[srcChainIndex] )
  {
    LODWORD(v14) = srcChainIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 995, ASSERT_TYPE_ASSERT, "( ( buildWorkers->chainEntityCost[srcChainIndex] != 0 ) )", "( srcChainIndex ) = %i", v14) )
      __debugbreak();
  }
  if ( srcChainIndex != destChainIndex )
  {
    v9 = workBuilder->chainEntityTail[destChainIndex] + 1293i64;
    if ( *((_WORD *)&workerData->serverTime + v9) != 2047 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1002, ASSERT_TYPE_ASSERT, "(work->entityNext[tailEntityIndex] == ENTITYNUM_NONE)", (const char *)&queryFormat, "work->entityNext[tailEntityIndex] == ENTITYNUM_NONE") )
      __debugbreak();
    *((_WORD *)&workerData->serverTime + v9) = workBuilder->chainEntityHead[srcChainIndex];
    workBuilder->chainEntityTail[destChainIndex] = workBuilder->chainEntityTail[srcChainIndex];
    v10 = workBuilder->chainEntityHead[srcChainIndex];
    if ( v10 != 2047 )
    {
      do
      {
        if ( v10 >= 0x800u )
        {
          LODWORD(v15) = 2048;
          LODWORD(v14) = v10;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1011, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ( sizeof( *array_counter( buildWorkers->chainIndex ) ) + 0 ) )", "entityIndex doesn't index buildWorkers->chainIndex\n\t%i not in [0, %i)", v14, v15) )
            __debugbreak();
        }
        v11 = workBuilder->chainIndex[v10];
        if ( v11 != srcChainIndex )
        {
          LODWORD(v17) = srcChainIndex;
          LODWORD(v16) = v11;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1012, ASSERT_TYPE_ASSERT, "( buildWorkers->chainIndex[entityIndex] ) == ( srcChainIndex )", "%s == %s\n\t%i, %i", "buildWorkers->chainIndex[entityIndex]", "srcChainIndex", v16, v17) )
            __debugbreak();
        }
        workBuilder->chainIndex[v10] = destChainIndex;
        v10 = workerData->entityNext[v10];
      }
      while ( v10 != 2047 );
      v8 = srcChainIndex;
    }
    chainIndex = workBuilder->chainIndex;
    v13 = 2046i64;
    do
    {
      if ( *chainIndex == srcChainIndex )
      {
        LODWORD(v17) = srcChainIndex;
        LODWORD(v16) = *chainIndex;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1021, ASSERT_TYPE_ASSERT, "( buildWorkers->chainIndex[entityIndex] ) != ( srcChainIndex )", "%s != %s\n\t%i, %i", "buildWorkers->chainIndex[entityIndex]", "srcChainIndex", v16, v17) )
          __debugbreak();
      }
      ++chainIndex;
      --v13;
    }
    while ( v13 );
    workBuilder->chainEntityCount[v18] += workBuilder->chainEntityCount[v8];
    workBuilder->chainEntityCost[v18] += workBuilder->chainEntityCost[v8];
    workBuilder->chainEntityFlags[v18] |= workBuilder->chainEntityFlags[v8];
    workBuilder->chainEntityHead[v8] = 2047;
    workBuilder->chainEntityTail[v8] = 2047;
    workBuilder->chainEntityCount[v8] = 0;
    workBuilder->chainEntityCost[v8] = 0;
  }
}

/*
==============
CG_EntityWorkers_BuildWorkers
==============
*/
void CG_EntityWorkers_BuildWorkers(const LocalClientNum_t localClientNum, const int serverTime, const CgEntityWorkBuilder *buildWorkers, CgEntityWork *work)
{
  const CgEntityWorkBuilder *v5; 
  unsigned __int16 workerMaxCount; 
  unsigned __int16 v8; 
  __int64 v9; 
  unsigned __int16 v10; 
  unsigned __int16 *chainEntityHead; 
  __int64 v12; 
  unsigned __int8 v13; 
  __int64 v14; 
  int v15; 
  char *i; 
  unsigned __int16 v17; 
  unsigned __int16 v18; 
  unsigned __int16 *v19; 
  unsigned __int16 v20; 
  unsigned __int16 v21; 
  unsigned __int16 v22; 
  __int64 v23; 
  __int64 v24; 
  __int64 v25; 
  char v27[2]; 
  unsigned __int16 mem[256]; 

  v5 = buildWorkers;
  if ( !buildWorkers && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1395, ASSERT_TYPE_ASSERT, "(buildWorkers)", (const char *)&queryFormat, "buildWorkers") )
    __debugbreak();
  if ( !work && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1396, ASSERT_TYPE_ASSERT, "(work)", (const char *)&queryFormat, "work") )
    __debugbreak();
  work->serverTime = serverTime;
  work->workerMaxCount = 16;
  *(_QWORD *)&work->mainEntityHead = 134154239i64;
  *(_QWORD *)&work->postPsEntityHead = 134154239i64;
  DebugWipe(mem, 0x200ui64);
  workerMaxCount = work->workerMaxCount;
  v8 = 0;
  if ( workerMaxCount )
  {
    do
    {
      v9 = v8;
      if ( v8 >= (unsigned int)workerMaxCount )
      {
        LODWORD(v24) = workerMaxCount;
        LODWORD(v23) = v8;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1183, ASSERT_TYPE_ASSERT, "(unsigned)( workerIndex ) < (unsigned)( work->workerMaxCount )", "workerIndex doesn't index work->workerMaxCount\n\t%i not in [0, %i)", v23, v24) )
          __debugbreak();
      }
      work->workerSize[v8] = 0;
      work->workerCost[v8] = 0;
      work->workerHead[v8] = 2047;
      mem[v8] = v8;
      ++v8;
      work->workerTail[v9] = 2047;
      workerMaxCount = work->workerMaxCount;
    }
    while ( v8 < workerMaxCount );
    v5 = buildWorkers;
  }
  v10 = 0;
  chainEntityHead = v5->chainEntityHead;
  v12 = 0i64;
  do
  {
    if ( *chainEntityHead != 2047 )
    {
      v13 = v5->chainEntityFlags[v12];
      if ( (v13 & 2) != 0 )
      {
        CG_EntityWorkers_AddChainToPostPlayerstateWorker(v5, v10, work);
      }
      else if ( (v13 & 1) != 0 )
      {
        CG_EntityWorkers_AddChainToMainThreadWorker(v5, v10, work);
      }
      else
      {
        CG_EntityWorkers_AddChainToDistributedWorker(v5, v10, mem, work);
      }
    }
    ++v10;
    ++v12;
    ++chainEntityHead;
  }
  while ( v10 < 0x800u );
  v14 = work->workerMaxCount;
  work->workerActiveCount = 0;
  v15 = v14 - 1;
  if ( (int)v14 - 1 >= 0 )
  {
    for ( i = &v27[2 * v14]; ; i -= 2 )
    {
      if ( v15 >= (unsigned int)work->workerMaxCount )
      {
        LODWORD(v24) = work->workerMaxCount;
        LODWORD(v23) = v15;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1454, ASSERT_TYPE_ASSERT, "(unsigned)( priorityQueueIndex ) < (unsigned)( work->workerMaxCount )", "priorityQueueIndex doesn't index work->workerMaxCount\n\t%i not in [0, %i)", v23, v24) )
          __debugbreak();
      }
      v17 = *(_WORD *)i;
      v18 = work->workerMaxCount;
      if ( *(_WORD *)i >= v18 )
      {
        LODWORD(v24) = v18;
        LODWORD(v23) = v17;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1457, ASSERT_TYPE_ASSERT, "(unsigned)( workerIndex ) < (unsigned)( work->workerMaxCount )", "workerIndex doesn't index work->workerMaxCount\n\t%i not in [0, %i)", v23, v24) )
          __debugbreak();
      }
      if ( !work->workerSize[v17] )
        break;
      work->workerExecuteOrder[work->workerActiveCount++] = v17;
      if ( --v15 < 0 )
        return;
    }
    v19 = &mem[v15];
    do
    {
      if ( v15 >= (unsigned int)work->workerMaxCount )
      {
        LODWORD(v24) = work->workerMaxCount;
        LODWORD(v23) = v15;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1472, ASSERT_TYPE_ASSERT, "(unsigned)( priorityQueueIndex ) < (unsigned)( work->workerMaxCount )", "priorityQueueIndex doesn't index work->workerMaxCount\n\t%i not in [0, %i)", v23, v24) )
          __debugbreak();
      }
      v20 = *v19;
      v21 = work->workerMaxCount;
      if ( *v19 >= v21 )
      {
        LODWORD(v24) = v21;
        LODWORD(v23) = v20;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1474, ASSERT_TYPE_ASSERT, "(unsigned)( workerIndex ) < (unsigned)( work->workerMaxCount )", "workerIndex doesn't index work->workerMaxCount\n\t%i not in [0, %i)", v23, v24) )
          __debugbreak();
      }
      v22 = work->workerSize[v20];
      if ( v22 )
      {
        LODWORD(v25) = v22;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1475, ASSERT_TYPE_ASSERT, "( work->workerSize[workerIndex] ) == ( 0 )", "%s == %s\n\t%i, %i", "work->workerSize[workerIndex]", "0", v25, 0i64) )
          __debugbreak();
      }
      --v19;
      --v15;
    }
    while ( v15 >= 0 );
  }
}

/*
==============
CG_EntityWorkers_CheckHasAnyLock_Physics
==============
*/
void CG_EntityWorkers_CheckHasAnyLock_Physics(void)
{
  const dvar_t *v0; 
  bool v1; 
  const dvar_t *v2; 
  ThreadContext CurrentThreadContext; 
  const char *ThreadContextName; 

  v0 = DVARBOOL_cg_entityWorkers;
  if ( !DVARBOOL_cg_entityWorkers && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkers") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v0);
  if ( !v0->current.enabled )
  {
    if ( !Sys_IsMainThreadEntityWorker() )
      return;
    v1 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 3341, ASSERT_TYPE_ASSERT, "(!CG_EntityWorkers_WorkersCurrentlyActive())", (const char *)&queryFormat, "!CG_EntityWorkers_WorkersCurrentlyActive()");
    goto LABEL_25;
  }
  if ( !*(_BYTE *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1664i64) )
  {
    if ( !Sys_IsMainThreadEntityWorker() )
      return;
    v1 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 3347, ASSERT_TYPE_ASSERT, "(!CG_EntityWorkers_WorkersCurrentlyActive())", (const char *)&queryFormat, "!CG_EntityWorkers_WorkersCurrentlyActive()");
    goto LABEL_25;
  }
  v2 = DCONST_DVARBOOL_cg_entityWorkersPhysicsCheckLocks;
  if ( !DCONST_DVARBOOL_cg_entityWorkersPhysicsCheckLocks && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkersPhysicsCheckLocks") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  if ( v2->current.enabled )
  {
    if ( CG_EntityWorkers_CritSecLegacyMode() )
    {
      if ( Sys_InCriticalSection(CRITSECT_ENTITY_WORKER_LOCK) )
        return;
      v1 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 3358, ASSERT_TYPE_ASSERT, "(Sys_InCriticalSection( CRITSECT_ENTITY_WORKER_LOCK ))", (const char *)&queryFormat, "Sys_InCriticalSection( CRITSECT_ENTITY_WORKER_LOCK )");
      goto LABEL_25;
    }
    if ( ms_entityWorkRWLockPhysics.initialized != -1412623820 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_rwlock.h", 98, ASSERT_TYPE_ASSERT, "( lock->initialized == RWLOCK_INITIALIZED_SENTINEL )", "RWLock needs to be initialized first via Sys_CreateReadWriteLock") )
      __debugbreak();
    CurrentThreadContext = Sys_GetCurrentThreadContext();
    if ( (CurrentThreadContext & 0x1F) != CurrentThreadContext && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_rwlock.h", 105, ASSERT_TYPE_ASSERT, "((context & 31) == context)", "%s\n\tToo many thread contexts for acquireLock. The acquireLock bitfield needs to be wider to support more than 32 thread contexts", "(context & 31) == context") )
      __debugbreak();
    if ( ((1 << CurrentThreadContext) & ms_entityWorkRWLockPhysics.acquireLock) != 1 << CurrentThreadContext )
    {
      ThreadContextName = Sys_GetThreadContextName(CurrentThreadContext);
      v1 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_rwlock.h", 109, ASSERT_TYPE_ASSERT, "( ( lock->acquireLock & contextMask ) == contextMask )", "Failed requested lock check on thread %s", ThreadContextName);
LABEL_25:
      if ( v1 )
        __debugbreak();
    }
  }
}

/*
==============
CG_EntityWorkers_CheckHasWriteLock_Physics
==============
*/
void CG_EntityWorkers_CheckHasWriteLock_Physics(void)
{
  const dvar_t *v0; 
  bool v1; 
  const dvar_t *v2; 
  threadId_t writeThreadId; 
  threadId_t CurrentThreadId; 

  v0 = DVARBOOL_cg_entityWorkers;
  if ( !DVARBOOL_cg_entityWorkers && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkers") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v0);
  if ( !v0->current.enabled )
  {
    if ( !Sys_IsMainThreadEntityWorker() )
      return;
    v1 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 3309, ASSERT_TYPE_ASSERT, "(!CG_EntityWorkers_WorkersCurrentlyActive())", (const char *)&queryFormat, "!CG_EntityWorkers_WorkersCurrentlyActive()");
LABEL_19:
    if ( v1 )
      __debugbreak();
    return;
  }
  if ( !*(_BYTE *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1664i64) )
  {
    if ( !Sys_IsMainThreadEntityWorker() )
      return;
    v1 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 3315, ASSERT_TYPE_ASSERT, "(!CG_EntityWorkers_WorkersCurrentlyActive())", (const char *)&queryFormat, "!CG_EntityWorkers_WorkersCurrentlyActive()");
    goto LABEL_19;
  }
  v2 = DCONST_DVARBOOL_cg_entityWorkersPhysicsCheckLocks;
  if ( !DCONST_DVARBOOL_cg_entityWorkersPhysicsCheckLocks && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkersPhysicsCheckLocks") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  if ( v2->current.enabled )
  {
    if ( CG_EntityWorkers_CritSecLegacyMode() )
    {
      if ( Sys_InCriticalSection(CRITSECT_ENTITY_WORKER_LOCK) )
        return;
      v1 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 3326, ASSERT_TYPE_ASSERT, "(Sys_InCriticalSection( CRITSECT_ENTITY_WORKER_LOCK ))", (const char *)&queryFormat, "Sys_InCriticalSection( CRITSECT_ENTITY_WORKER_LOCK )");
    }
    else
    {
      if ( ms_entityWorkRWLockPhysics.writeThreadId == Sys_GetCurrentThreadId() )
        return;
      CurrentThreadId = Sys_GetCurrentThreadId();
      writeThreadId = ms_entityWorkRWLockPhysics.writeThreadId;
      v1 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_rwlock.h", 234, ASSERT_TYPE_ASSERT, "( lock->writeThreadId ) == ( Sys_GetCurrentThreadId() )", "%s == %s\n\t%i, %i", "lock->writeThreadId", "Sys_GetCurrentThreadId()", writeThreadId, CurrentThreadId);
    }
    goto LABEL_19;
  }
}

/*
==============
CG_EntityWorkers_CloseRWLock_Physics
==============
*/
void CG_EntityWorkers_CloseRWLock_Physics(void)
{
  __int64 v0; 
  volatile int acquireLock; 

  ms_entityWorkRWLockPhysics.initialized = 0;
  if ( ms_entityWorkRWLockPhysics.acquireLock )
  {
    acquireLock = ms_entityWorkRWLockPhysics.acquireLock;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_rwlock.h", 138, ASSERT_TYPE_ASSERT, "( lock->acquireLock ) == ( 0 )", "%s == %s\n\t%i, %i", "lock->acquireLock", "0", acquireLock, 0i64) )
      __debugbreak();
  }
  if ( ms_entityWorkRWLockPhysics.writeThreadId )
  {
    LODWORD(v0) = ms_entityWorkRWLockPhysics.writeThreadId;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_rwlock.h", 139, ASSERT_TYPE_ASSERT, "( lock->writeThreadId ) == ( INVALID_THREAD_ID )", "%s == %s\n\t%i, %i", "lock->writeThreadId", "INVALID_THREAD_ID", v0, 0i64) )
      __debugbreak();
  }
  ms_entityWorkRWLockPhysics.lock = NULL;
}

/*
==============
CG_EntityWorkers_CreateRWLock_Physics
==============
*/
void CG_EntityWorkers_CreateRWLock_Physics(void)
{
  InitializeSRWLock((PSRWLOCK)&ms_entityWorkRWLockPhysics);
  ms_entityWorkRWLockPhysics.initialized = -1412623820;
  ms_entityWorkRWLockPhysics.acquireLock = 0;
  ms_entityWorkRWLockPhysics.writeThreadId = 0;
}

/*
==============
CG_EntityWorkers_CritSecLegacyMode
==============
*/
__int64 CG_EntityWorkers_CritSecLegacyMode()
{
  const dvar_t *v0; 

  v0 = DCONST_DVARBOOL_cg_entityWorkersCritSecLegacyMode;
  if ( !DCONST_DVARBOOL_cg_entityWorkersCritSecLegacyMode && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkersCritSecLegacyMode") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v0);
  return v0->current.color[0];
}

/*
==============
CG_EntityWorkers_CriticalSection_CheckKillswitch_Enter
==============
*/
char CG_EntityWorkers_CriticalSection_CheckKillswitch_Enter(const CGEntityWorkersLegacyFallbackMode fallbackMode, const bool lockIsLegacy)
{
  int v5; 

  if ( (unsigned __int8)CG_EntityWorkers_CritSecLegacyMode() )
  {
    if ( fallbackMode == BASE )
    {
      Sys_EnterCriticalSection(CRITSECT_ENTITY_WORKER_LOCK);
      return 0;
    }
    if ( !*(_BYTE *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1664i64) || Sys_InCriticalSection(CRITSECT_ENTITY_WORKER_LOCK) )
      return 0;
    v5 = 415;
    goto LABEL_12;
  }
  if ( lockIsLegacy && fallbackMode == NONE_UNVERIFIED )
  {
    if ( !*(_BYTE *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1664i64) || Sys_InCriticalSection(CRITSECT_ENTITY_WORKER_LOCK) )
      return 0;
    v5 = 426;
LABEL_12:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", v5, ASSERT_TYPE_ASSERT, "(!CG_EntityWorkers_IsProcessingEntityWorker() || Sys_InCriticalSection( CRITSECT_ENTITY_WORKER_LOCK ))", (const char *)&queryFormat, "!CG_EntityWorkers_IsProcessingEntityWorker() || Sys_InCriticalSection( CRITSECT_ENTITY_WORKER_LOCK )") )
      __debugbreak();
    return 0;
  }
  return 1;
}

/*
==============
CG_EntityWorkers_CriticalSection_CheckKillswitch_Leave
==============
*/
char CG_EntityWorkers_CriticalSection_CheckKillswitch_Leave(const CGEntityWorkersLegacyFallbackMode fallbackMode, const bool lockIsLegacy)
{
  int v5; 

  if ( (unsigned __int8)CG_EntityWorkers_CritSecLegacyMode() )
  {
    if ( fallbackMode == BASE )
    {
      Sys_LeaveCriticalSection(CRITSECT_ENTITY_WORKER_LOCK);
      return 0;
    }
    if ( !*(_BYTE *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1664i64) || Sys_InCriticalSection(CRITSECT_ENTITY_WORKER_LOCK) )
      return 0;
    v5 = 445;
    goto LABEL_12;
  }
  if ( lockIsLegacy && fallbackMode == NONE_UNVERIFIED )
  {
    if ( !*(_BYTE *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1664i64) || Sys_InCriticalSection(CRITSECT_ENTITY_WORKER_LOCK) )
      return 0;
    v5 = 453;
LABEL_12:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", v5, ASSERT_TYPE_ASSERT, "(!CG_EntityWorkers_IsProcessingEntityWorker() || Sys_InCriticalSection( CRITSECT_ENTITY_WORKER_LOCK ))", (const char *)&queryFormat, "!CG_EntityWorkers_IsProcessingEntityWorker() || Sys_InCriticalSection( CRITSECT_ENTITY_WORKER_LOCK )") )
      __debugbreak();
    return 0;
  }
  return 1;
}

/*
==============
CG_EntityWorkers_EnterCriticalSection
==============
*/
void CG_EntityWorkers_EnterCriticalSection(void)
{
  const dvar_t *v0; 

  v0 = DVARBOOL_cg_entityWorkers;
  if ( !DVARBOOL_cg_entityWorkers && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkers") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v0);
  if ( v0->current.enabled )
    Sys_EnterCriticalSection(CRITSECT_ENTITY_WORKER_LOCK);
}

/*
==============
CG_EntityWorkers_EnterCriticalSection_Compass
==============
*/
void CG_EntityWorkers_EnterCriticalSection_Compass(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  const dvar_t *v1; 

  v1 = DVARBOOL_cg_entityWorkers;
  if ( !DVARBOOL_cg_entityWorkers && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkers") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  if ( v1->current.enabled )
  {
    if ( CG_EntityWorkers_CriticalSection_CheckKillswitch_Enter(fallbackMode, 1) )
      Sys_EnterCriticalSection(CRITSECT_ENTITY_WORKER_LOCK);
  }
}

/*
==============
CG_EntityWorkers_EnterCriticalSection_LegacyOnly
==============
*/
void CG_EntityWorkers_EnterCriticalSection_LegacyOnly(void)
{
  const dvar_t *v0; 

  v0 = DVARBOOL_cg_entityWorkers;
  if ( !DVARBOOL_cg_entityWorkers && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkers") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v0);
  if ( v0->current.enabled )
  {
    if ( (unsigned __int8)CG_EntityWorkers_CritSecLegacyMode() )
      Sys_EnterCriticalSection(CRITSECT_ENTITY_WORKER_LOCK);
  }
}

/*
==============
CG_EntityWorkers_EnterCriticalSection_Mayhem
==============
*/
void CG_EntityWorkers_EnterCriticalSection_Mayhem(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  const dvar_t *v1; 

  v1 = DVARBOOL_cg_entityWorkers;
  if ( !DVARBOOL_cg_entityWorkers && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkers") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  if ( v1->current.enabled )
  {
    if ( CG_EntityWorkers_CriticalSection_CheckKillswitch_Enter(fallbackMode, 1) )
      Sys_EnterCriticalSection(CRITSECT_ENTITY_WORKER_LOCK);
  }
}

/*
==============
CG_EntityWorkers_EnterCriticalSection_Ragdoll
==============
*/
void CG_EntityWorkers_EnterCriticalSection_Ragdoll(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  const dvar_t *v1; 

  v1 = DVARBOOL_cg_entityWorkers;
  if ( !DVARBOOL_cg_entityWorkers && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkers") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  if ( v1->current.enabled )
  {
    if ( CG_EntityWorkers_CriticalSection_CheckKillswitch_Enter(fallbackMode, 1) )
      Sys_EnterCriticalSection(CRITSECT_ENTITY_WORKER_LOCK);
  }
}

/*
==============
CG_EntityWorkers_EnterCriticalSection_ReflectionProbe
==============
*/
void CG_EntityWorkers_EnterCriticalSection_ReflectionProbe(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  const dvar_t *v1; 

  v1 = DVARBOOL_cg_entityWorkers;
  if ( !DVARBOOL_cg_entityWorkers && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkers") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  if ( v1->current.enabled )
  {
    if ( CG_EntityWorkers_CriticalSection_CheckKillswitch_Enter(fallbackMode, 1) )
      Sys_EnterCriticalSection(CRITSECT_ENTITY_WORKER_LOCK);
  }
}

/*
==============
CG_EntityWorkers_EnterCriticalSection_ScriptableCl
==============
*/
void CG_EntityWorkers_EnterCriticalSection_ScriptableCl(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  const dvar_t *v1; 

  v1 = DVARBOOL_cg_entityWorkers;
  if ( !DVARBOOL_cg_entityWorkers && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkers") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  if ( v1->current.enabled )
  {
    if ( (unsigned __int8)CG_EntityWorkers_CritSecLegacyMode() )
    {
      if ( fallbackMode == BASE )
      {
        Sys_EnterCriticalSection(CRITSECT_ENTITY_WORKER_LOCK);
      }
      else if ( *(_BYTE *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1664i64) && !Sys_InCriticalSection(CRITSECT_ENTITY_WORKER_LOCK) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 415, ASSERT_TYPE_ASSERT, "(!CG_EntityWorkers_IsProcessingEntityWorker() || Sys_InCriticalSection( CRITSECT_ENTITY_WORKER_LOCK ))", (const char *)&queryFormat, "!CG_EntityWorkers_IsProcessingEntityWorker() || Sys_InCriticalSection( CRITSECT_ENTITY_WORKER_LOCK )") )
      {
        __debugbreak();
      }
    }
    else
    {
      Sys_EnterCriticalSection(CRITSECT_ENTITY_WORKER_LOCK_SCRIPTABLECL);
    }
  }
}

/*
==============
CG_EntityWorkers_EnterCriticalSection_Unverified
==============
*/
void CG_EntityWorkers_EnterCriticalSection_Unverified(void)
{
  const dvar_t *v0; 

  v0 = DVARBOOL_cg_entityWorkers;
  if ( !DVARBOOL_cg_entityWorkers && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkers") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v0);
  if ( v0->current.enabled )
    Sys_EnterCriticalSection(CRITSECT_ENTITY_WORKER_LOCK);
}

/*
==============
CG_EntityWorkers_EnterCriticalSection_VFX
==============
*/
void CG_EntityWorkers_EnterCriticalSection_VFX(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  const dvar_t *v1; 

  v1 = DVARBOOL_cg_entityWorkers;
  if ( !DVARBOOL_cg_entityWorkers && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkers") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  if ( v1->current.enabled )
  {
    if ( CG_EntityWorkers_CriticalSection_CheckKillswitch_Enter(fallbackMode, 1) )
      Sys_EnterCriticalSection(CRITSECT_ENTITY_WORKER_LOCK);
  }
}

/*
==============
CG_EntityWorkers_EnterCriticalSection_VehicleGetFx
==============
*/
void CG_EntityWorkers_EnterCriticalSection_VehicleGetFx(void)
{
  const dvar_t *v0; 
  __int64 v1; 

  v0 = DVARBOOL_cg_entityWorkers;
  if ( !DVARBOOL_cg_entityWorkers && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkers") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v0);
  if ( v0->current.enabled )
  {
    v1 = 8i64 * tls_index;
    if ( *(_BYTE *)(*(_QWORD *)((char *)NtCurrentTeb()->Reserved1[11] + v1) + 1664i64) )
    {
      if ( (unsigned __int8)CG_EntityWorkers_CritSecLegacyMode() )
      {
        if ( *(_BYTE *)(*(_QWORD *)((char *)NtCurrentTeb()->Reserved1[11] + v1) + 1664i64) && !Sys_InCriticalSection(CRITSECT_ENTITY_WORKER_LOCK) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 415, ASSERT_TYPE_ASSERT, "(!CG_EntityWorkers_IsProcessingEntityWorker() || Sys_InCriticalSection( CRITSECT_ENTITY_WORKER_LOCK ))", (const char *)&queryFormat, "!CG_EntityWorkers_IsProcessingEntityWorker() || Sys_InCriticalSection( CRITSECT_ENTITY_WORKER_LOCK )") )
          __debugbreak();
      }
      else
      {
        Sys_EnterCriticalSection(CRITSECT_ENTITY_WORKER_VEHICLE_GETFX);
      }
    }
  }
}

/*
==============
CG_EntityWorkers_EnterCriticalSection_ViewModel
==============
*/
void CG_EntityWorkers_EnterCriticalSection_ViewModel(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  const dvar_t *v1; 

  v1 = DVARBOOL_cg_entityWorkers;
  if ( !DVARBOOL_cg_entityWorkers && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkers") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  if ( v1->current.enabled )
  {
    if ( CG_EntityWorkers_CriticalSection_CheckKillswitch_Enter(fallbackMode, 1) )
      Sys_EnterCriticalSection(CRITSECT_ENTITY_WORKER_LOCK);
  }
}

/*
==============
CG_EntityWorkers_ExecuteBuilder
==============
*/
void CG_EntityWorkers_ExecuteBuilder(const void *const cmd)
{
  cg_t *LocalClientGlobals; 
  CgEntityWork *v3; 
  CgEntityWorkBuilder *v4; 
  unsigned __int16 v5; 
  unsigned __int16 *entityNext; 
  __int64 v7; 
  unsigned __int16 *chainEntityCost; 
  __int64 v9; 
  cg_t *v10; 
  CgEntitySystem *EntitySystem; 
  const centity_t *v12; 
  int number; 
  unsigned __int8 EntityWorkFlags; 
  bool v15; 
  const dvar_t *v16; 
  __int16 eType; 
  unsigned __int16 v18; 
  cg_t *cgameGlob; 
  CgEntityWork *work; 
  CgEntityWorkBuilder *buildWorkers; 

  if ( !cmd && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1550, ASSERT_TYPE_ASSERT, "(workerCmd)", (const char *)&queryFormat, "workerCmd") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)*(_DWORD *)cmd);
  v3 = (CgEntityWork *)*((_QWORD *)cmd + 1);
  cgameGlob = LocalClientGlobals;
  work = v3;
  if ( !v3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1555, ASSERT_TYPE_ASSERT, "(work)", (const char *)&queryFormat, "work") )
    __debugbreak();
  v4 = (CgEntityWorkBuilder *)*((_QWORD *)cmd + 2);
  buildWorkers = v4;
  if ( !v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1558, ASSERT_TYPE_ASSERT, "(workBuilder)", (const char *)&queryFormat, "workBuilder") )
    __debugbreak();
  v5 = 0;
  entityNext = v3->entityNext;
  v4->nextChain = 0;
  v7 = 2046i64;
  do
  {
    *(unsigned __int16 *)((char *)entityNext + (char *)v4 - (char *)v3 + 15848) = -1;
    *entityNext++ = 2047;
    --v7;
  }
  while ( v7 );
  chainEntityCost = v4->chainEntityCost;
  v9 = 2048i64;
  do
  {
    *(chainEntityCost - 6144) = 0;
    *chainEntityCost = 0;
    *(chainEntityCost - 4096) = 2047;
    *(chainEntityCost - 2048) = 2047;
    ++chainEntityCost;
    --v9;
  }
  while ( v9 );
  Sys_ProfBeginNamedEvent(0xFF0A0B0D, "Build Chains");
  v10 = cgameGlob;
  do
  {
    EntitySystem = CgEntitySystem::GetEntitySystem((const LocalClientNum_t)*(_DWORD *)cmd);
    v12 = &EntitySystem->m_entities[v5];
    if ( (EntitySystem->m_entities[v5].flags & 1) != 0 && EntitySystem->m_entities[v5].nextState.eType < ET_EVENTS )
    {
      number = EntitySystem->m_entities[v5].nextState.number;
      if ( v10 == (cg_t *)-8i64 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_local.h", 128, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
          __debugbreak();
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2296, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
          __debugbreak();
      }
      if ( GameModeFlagValues::ms_mpValue == ACTIVE && !GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&v10->predictedPlayerState.otherFlags, ACTIVE, 0x22u) )
      {
        if ( v10 == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2308, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
          __debugbreak();
        if ( !Com_GameMode_SupportsFeature(WEAPON_RAISING_ALTSWITCH_ADS) || !GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&v10->predictedPlayerState.otherFlags, GameModeFlagValues::ms_mpValue, 0x29u) )
        {
          if ( v10 == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2275, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
            __debugbreak();
          if ( !GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&v10->predictedPlayerState.otherFlags, GameModeFlagValues::ms_mpValue, 0x21u) )
            goto LABEL_53;
        }
      }
      if ( number != v10->predictedPlayerState.clientNum )
      {
LABEL_53:
        if ( (EntitySystem->m_entities[v5].flags & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1381, ASSERT_TYPE_ASSERT, "(CENextValid( cent ))", (const char *)&queryFormat, "CENextValid( cent )") )
          __debugbreak();
        EntityWorkFlags = CG_EntityWorkers_GetEntityWorkFlags(*(const LocalClientNum_t *)cmd, v10, v12);
        v15 = (EntitySystem->m_entities[v5].flags & 1) == 0;
        LOBYTE(cgameGlob) = EntityWorkFlags;
        if ( v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 609, ASSERT_TYPE_ASSERT, "(CENextValid( cent ))", (const char *)&queryFormat, "CENextValid( cent )") )
          __debugbreak();
        if ( !Com_GameMode_SupportsFeature(WEAPON_OFFHAND_PREPARE) )
          goto LABEL_47;
        v16 = DCONST_DVARBOOL_cg_entityWorkersCostBalancing;
        if ( !DCONST_DVARBOOL_cg_entityWorkersCostBalancing && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkersCostBalancing") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v16);
        if ( v16->current.enabled && (eType = EntitySystem->m_entities[v5].nextState.eType, eType < 29) )
          v18 = ENTITY_WORKERS_TYPE_COST[eType];
        else
LABEL_47:
          v18 = 10;
        WORD1(cgameGlob) = v18;
        CG_EntityWorkers_SetEntityWorkChain_r((const CgEntityWorkBuilderCmd *)cmd, v12, (const CgEntityWorkData *)&cgameGlob);
      }
    }
    ++v5;
  }
  while ( v5 < 0x7FEu );
  Sys_ProfEndNamedEvent();
  Sys_ProfBeginNamedEvent(0xFFA0B0D0, "Bucket Chains");
  CG_EntityWorkers_BuildWorkers(*(const LocalClientNum_t *)cmd, *((_DWORD *)cmd + 1), buildWorkers, work);
  Sys_ProfEndNamedEvent();
  CG_EntityWorkers_ValidateEntityWorkers((const CgEntityWorkBuilderCmd *)cmd);
}

/*
==============
CG_EntityWorkers_ExecuteMainThread
==============
*/
void CG_EntityWorkers_ExecuteMainThread(const LocalClientNum_t localClientNum, CgEntityWork *workerData)
{
  CgEntitySystem *EntitySystem; 
  CgAntiLag *Instance; 
  unsigned __int16 mainEntityHead; 
  unsigned __int16 *v7; 
  __int64 v8; 

  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2259, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  if ( !workerData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2260, ASSERT_TYPE_ASSERT, "(workerData)", (const char *)&queryFormat, "workerData") )
    __debugbreak();
  if ( (unsigned int)localClientNum >= LODWORD(cl_maxLocalClients) )
  {
    LODWORD(v8) = localClientNum;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2261, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( (cl_maxLocalClients) )", "localClientNum doesn't index MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v8, cl_maxLocalClients) )
      __debugbreak();
  }
  if ( Sys_IsMainThreadEntityWorker() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2262, ASSERT_TYPE_ASSERT, "(!CG_EntityWorkers_WorkersCurrentlyActive())", "%s\n\tThe main thread entity work does not defer scene processing", "!CG_EntityWorkers_WorkersCurrentlyActive()") )
    __debugbreak();
  EntitySystem = CgEntitySystem::GetEntitySystem(localClientNum);
  if ( CgAntiLag::IsDisabledForMigration(localClientNum) )
    Instance = NULL;
  else
    Instance = CgAntiLag::GetInstance(localClientNum);
  Sys_ProfBeginNamedEvent(0xFFE0FFFF, "exec ent worker main");
  mainEntityHead = workerData->mainEntityHead;
  if ( mainEntityHead != 2047 )
  {
    do
    {
      CG_EntityWorkers_ProcessEntity(EntitySystem, Instance, mainEntityHead, workerData->contextKey);
      v7 = &workerData->entityNext[mainEntityHead];
      if ( *v7 == 2047 && mainEntityHead != workerData->mainEntityTail && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2272, ASSERT_TYPE_ASSERT, "(workerData->entityNext[entityIndex] != ENTITYNUM_NONE || entityIndex == workerData->mainEntityTail)", "%s\n\tWe hit the end of the main thread entity list without hitting the tail. The list was built incorrectly.", "workerData->entityNext[entityIndex] != ENTITYNUM_NONE || entityIndex == workerData->mainEntityTail") )
        __debugbreak();
      mainEntityHead = *v7;
    }
    while ( *v7 != 2047 );
  }
  Sys_ProfEndNamedEvent();
}

/*
==============
CG_EntityWorkers_ExecutePostPlayerStateThread
==============
*/
void CG_EntityWorkers_ExecutePostPlayerStateThread(const LocalClientNum_t localClientNum, CgEntityWork *workerData, CgEventSystem *eventSystem)
{
  CgEntitySystem *EntitySystem; 
  CgAntiLag *Instance; 
  unsigned __int16 postPsEntityHead; 
  unsigned __int16 *v9; 
  __int64 v10; 
  __int64 v11; 

  if ( !Sys_IsMainThread() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2228, ASSERT_TYPE_ASSERT, "(Sys_IsMainThread())", (const char *)&queryFormat, "Sys_IsMainThread()") )
    __debugbreak();
  if ( !workerData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2229, ASSERT_TYPE_ASSERT, "(workerData)", (const char *)&queryFormat, "workerData") )
    __debugbreak();
  if ( !eventSystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2230, ASSERT_TYPE_ASSERT, "(eventSystem)", (const char *)&queryFormat, "eventSystem") )
    __debugbreak();
  if ( (unsigned int)localClientNum >= LODWORD(cl_maxLocalClients) )
  {
    LODWORD(v10) = localClientNum;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2231, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( (cl_maxLocalClients) )", "localClientNum doesn't index MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v10, cl_maxLocalClients) )
      __debugbreak();
  }
  if ( Sys_IsMainThreadEntityWorker() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2232, ASSERT_TYPE_ASSERT, "( !CG_EntityWorkers_WorkersCurrentlyActive() )", "The post player state thread entity work does not defer scene processing") )
    __debugbreak();
  EntitySystem = CgEntitySystem::GetEntitySystem(localClientNum);
  if ( CgAntiLag::IsDisabledForMigration(localClientNum) )
    Instance = NULL;
  else
    Instance = CgAntiLag::GetInstance(localClientNum);
  Sys_ProfBeginNamedEvent(0xFFE0FFFF, "exec post ps ent worker main");
  postPsEntityHead = workerData->postPsEntityHead;
  if ( postPsEntityHead != 2047 )
  {
    do
    {
      CG_EntityWorkers_ProcessEntity(EntitySystem, Instance, postPsEntityHead, workerData->contextKey);
      if ( g_processEvents )
      {
        if ( postPsEntityHead >= 0x800u )
        {
          LODWORD(v11) = 2048;
          LODWORD(v10) = postPsEntityHead;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 518, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( (( 2048 ) + 0) )", "entityIndex doesn't index MAX_LOCAL_CENTITIES\n\t%i not in [0, %i)", v10, v11) )
            __debugbreak();
        }
        CgEventSystem::CheckEntityEvents(eventSystem, &EntitySystem->m_entities[postPsEntityHead], 0);
      }
      v9 = &workerData->entityNext[postPsEntityHead];
      if ( *v9 == 2047 && postPsEntityHead != workerData->postPsEntityTail && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2248, ASSERT_TYPE_ASSERT, "( workerData->entityNext[entityIndex] != ENTITYNUM_NONE || entityIndex == workerData->postPsEntityTail )", "We hit the end of the main thread entity list without hitting the tail. The list was built incorrectly.") )
        __debugbreak();
      postPsEntityHead = *v9;
    }
    while ( *v9 != 2047 );
  }
  Sys_ProfEndNamedEvent();
}

/*
==============
CG_EntityWorkers_ExecuteWorkerThread
==============
*/
void CG_EntityWorkers_ExecuteWorkerThread(const void *const cmd)
{
  __int64 v6; 
  __int64 v7; 
  volatile signed __int32 *v8; 
  __int64 v9; 
  bool v10; 
  __int64 v11; 
  __int64 v12; 
  __int64 v13; 
  __int64 v14; 
  __int64 v15; 
  unsigned __int16 entityCount; 
  const char *v18; 
  unsigned __int16 v19; 
  unsigned __int16 entityCurrentType; 
  unsigned __int16 entityCurrentSubType; 
  const dvar_t *v27; 
  int v28; 
  unsigned int v29; 
  _QWORD *v34; 
  __int64 v37; 
  char *fmt; 
  __int64 v39; 
  __int64 v40; 
  __int64 v41; 
  __int64 v42; 
  CgAntiLag *antiLag; 
  __int64 v44; 
  CgEntitySystem *entitySystem; 
  __int64 v46; 
  char data[2048]; 
  int length; 
  void *retaddr; 

  _R11 = &retaddr;
  __asm { vmovaps xmmword ptr [r11-48h], xmm7 }
  if ( !cmd && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2306, ASSERT_TYPE_ASSERT, "(worker)", (const char *)&queryFormat, "worker") )
    __debugbreak();
  v6 = *((int *)cmd + 1);
  if ( (unsigned int)v6 >= LODWORD(cl_maxLocalClients) )
  {
    LODWORD(v39) = *((_DWORD *)cmd + 1);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2309, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( (cl_maxLocalClients) )", "localClientNum doesn't index MAX_LOCAL_CLIENTS\n\t%i not in [0, %i)", v39, cl_maxLocalClients) )
      __debugbreak();
  }
  v7 = *((_QWORD *)cmd + 1);
  if ( !v7 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2312, ASSERT_TYPE_ASSERT, "(workerData)", (const char *)&queryFormat, "workerData") )
    __debugbreak();
  v8 = (volatile signed __int32 *)(v7 + 6684);
  if ( !*(_DWORD *)(v7 + 6684) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2313, ASSERT_TYPE_ASSERT, "(workerData->workersPendingCount != 0)", (const char *)&queryFormat, "workerData->workersPendingCount != 0") )
    __debugbreak();
  v9 = *(unsigned int *)cmd;
  if ( (unsigned int)v9 >= *(unsigned __int16 *)(v7 + 2582) )
  {
    LODWORD(v40) = *(unsigned __int16 *)(v7 + 2582);
    LODWORD(v39) = *(_DWORD *)cmd;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2316, ASSERT_TYPE_ASSERT, "(unsigned)( workerIndex ) < (unsigned)( workerData->workerMaxCount )", "workerIndex doesn't index workerData->workerMaxCount\n\t%i not in [0, %i)", v39, v40) )
      __debugbreak();
  }
  entitySystem = CgEntitySystem::GetEntitySystem((const LocalClientNum_t)v6);
  if ( CgAntiLag::IsDisabledForMigration((const LocalClientNum_t)v6) )
    antiLag = NULL;
  else
    antiLag = CgAntiLag::GetInstance((const LocalClientNum_t)v6);
  v10 = (_BYTE)CgStatic::ms_allocatedType == NONE;
  v11 = tls_index;
  v12 = *((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index);
  v46 = *(_QWORD *)(v12 + 272);
  *(_QWORD *)(v12 + 272) = 0i64;
  if ( v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_static.h", 85, ASSERT_TYPE_ASSERT, "(ms_allocatedType != GameModeType::NONE)", "%s\n\tTrying to set the active bgs to the client game static but the allocated type is not known.", "ms_allocatedType != GameModeType::NONE") )
    __debugbreak();
  if ( (unsigned int)v6 >= LODWORD(CgStatic::ms_allocatedCount) )
  {
    *(float *)&v40 = CgStatic::ms_allocatedCount;
    LODWORD(v39) = v6;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_static.h", 86, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( ms_allocatedCount )", "localClientNum doesn't index ms_allocatedCount\n\t%i not in [0, %i)", v39, v40) )
      __debugbreak();
  }
  v13 = v6;
  if ( !CgStatic::ms_cgameStaticsArray[v6] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_static.h", 87, ASSERT_TYPE_ASSERT, "(ms_cgameStaticsArray[localClientNum] != 0)", "%s\n\tTrying to set the active bgs to the client game static but the client game static has not been allocated", "ms_cgameStaticsArray[localClientNum] != NULL") )
    __debugbreak();
  v14 = v9;
  v44 = v9;
  v15 = *((_QWORD *)NtCurrentTeb()->Reserved1[11] + v11);
  *(_QWORD *)(v15 + 272) = CgStatic::ms_cgameStaticsArray[v6];
  *(_QWORD *)(v15 + 1672) = data;
  _RDI = (CgEntityWorkerOutProfile *)(200 * v9 + v7 + 6688);
  entityCount = _RDI->entityCount;
  if ( entityCount && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1949, ASSERT_TYPE_ASSERT, "( profileData.entityCount ) == ( 0 )", "%s == %s\n\t%i, %i", "profileData.entityCount", "0", entityCount, 0i64) )
    __debugbreak();
  _RDI->workerStartTimer = __rdtsc();
  v18 = j_va("exec ent worker %d", *(unsigned int *)cmd);
  Sys_ProfBeginNamedEvent(0xFFE0FFFF, v18);
  v19 = *(_WORD *)(v7 + 2 * v14 + 22);
  __asm { vmovsd  xmm7, cs:__real@43f0000000000000 }
  if ( v19 != 2047 )
  {
    __asm { vmovaps [rsp+8E8h+var_38], xmm6 }
    do
    {
      length = 0;
      CG_EntityWorkers_ProfileEntityBegin((const LocalClientNum_t)v6, entitySystem, v19, _RDI);
      CG_EntityWorkers_ProcessEntity(entitySystem, antiLag, v19, *(_BYTE *)(v7 + 4));
      if ( !entitySystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1984, ASSERT_TYPE_ASSERT, "(entitySystem)", (const char *)&queryFormat, "entitySystem") )
        __debugbreak();
      ++_RDI->entityCount;
      __asm
      {
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2sd xmm0, xmm0, rax
      }
      if ( (__int64)(__rdtsc() - _RDI->entityStartTimer) < 0 )
        __asm { vaddsd  xmm0, xmm0, xmm7 }
      entityCurrentType = _RDI->entityCurrentType;
      __asm
      {
        vmulsd  xmm0, xmm0, cs:?msecPerRawTimerTick@@3NA; double msecPerRawTimerTick
        vcvtsd2ss xmm6, xmm0, xmm0
      }
      if ( entityCurrentType >= 0x1Du )
      {
        LODWORD(v40) = 29;
        LODWORD(v39) = entityCurrentType;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1990, ASSERT_TYPE_ASSERT, "(unsigned)( profileData.entityCurrentType ) < (unsigned)( ( sizeof( *array_counter( profileData.entityTypeTime ) ) + 0 ) )", "profileData.entityCurrentType doesn't index profileData.entityTypeTime\n\t%i not in [0, %i)", v39, v40) )
          __debugbreak();
      }
      entityCurrentSubType = _RDI->entityCurrentSubType;
      if ( entityCurrentSubType )
      {
        LODWORD(v40) = 1;
        LODWORD(v39) = entityCurrentSubType;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1991, ASSERT_TYPE_ASSERT, "(unsigned)( profileData.entityCurrentSubType ) < (unsigned)( ( sizeof( *array_counter( profileData.entityTypeTime[profileData.entityCurrentType] ) ) + 0 ) )", "profileData.entityCurrentSubType doesn't index profileData.entityTypeTime[profileData.entityCurrentType]\n\t%i not in [0, %i)", v39, v40) )
          __debugbreak();
      }
      _RCX = _RDI->entityCurrentType + (unsigned __int64)_RDI->entityCurrentSubType;
      __asm { vmovss  dword ptr [rdi+rcx*4+54h], xmm6 }
      v10 = s_entityWorkers_outputStream == NULL;
      _RDI->entityCurrentType = 29;
      if ( v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2280, ASSERT_TYPE_ASSERT, "(s_entityWorkers_outputStream != nullptr)", (const char *)&queryFormat, "s_entityWorkers_outputStream != nullptr") )
        __debugbreak();
      if ( length )
      {
        v27 = DCONST_DVARBOOL_cg_entityWorkersBufferedOutput;
        if ( !DCONST_DVARBOOL_cg_entityWorkersBufferedOutput && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkersBufferedOutput") )
          __debugbreak();
        Dvar_CheckFrontendServerThread(v27);
        if ( !v27->current.enabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2287, ASSERT_TYPE_ASSERT, "(Dvar_GetBool_Internal_DebugName( DCONST_DVARBOOL_cg_entityWorkersBufferedOutput, \"cg_entityWorkersBufferedOutput\" ))", (const char *)&queryFormat, "Dconst_GetBool( cg_entityWorkersBufferedOutput )") )
          __debugbreak();
        v28 = length;
        if ( (unsigned int)length > 0x800 )
        {
          LODWORD(v42) = 2048;
          LODWORD(v41) = length;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2288, ASSERT_TYPE_ASSERT, "( entityOutputBuffer.requestBufferCurSize ) <= ( sizeof( entityOutputBuffer.requestBuffer ) )", "%s <= %s\n\t%i, %i", "entityOutputBuffer.requestBufferCurSize", "sizeof( entityOutputBuffer.requestBuffer )", v41, v42) )
            __debugbreak();
          v28 = length;
        }
        v29 = MpscStream<524288>::Write(s_entityWorkers_outputStream, data, v28);
        if ( v29 != length )
        {
          LODWORD(fmt) = length;
          Com_PrintError(14, "CgEntityWorkers: Failed to submit tasks for entity %d (result = %d, expected %d)\n", v19, v29, fmt);
          LODWORD(v41) = length;
          LODWORD(v40) = v29;
          LODWORD(v39) = v19;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2293, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "CgEntityWorkers: Failed to submit tasks for entity %d (result = %d, expected %d)", v39, v40, v41) )
            __debugbreak();
        }
      }
      if ( *(_WORD *)(v7 + 2i64 * v19 + 2586) == 2047 && v19 != *(_WORD *)(v7 + 2 * v44 + 534) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2350, ASSERT_TYPE_ASSERT, "(workerData->entityNext[entityIndex] != ENTITYNUM_NONE || entityIndex == workerData->workerTail[workerIndex])", "%s\n\tWe hit the end of the worker thread entity list without hitting the tail. The list was built incorrectly.", "workerData->entityNext[entityIndex] != ENTITYNUM_NONE || entityIndex == workerData->workerTail[workerIndex]") )
        __debugbreak();
      v19 = *(_WORD *)(v7 + 2i64 * v19 + 2586);
    }
    while ( v19 != 2047 );
    v8 = (volatile signed __int32 *)(v7 + 6684);
    v13 = v6;
    LODWORD(v11) = tls_index;
    __asm { vmovaps xmm6, [rsp+8E8h+var_38] }
  }
  Sys_ProfEndNamedEvent();
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2sd xmm0, xmm0, rax
  }
  if ( (__int64)(__rdtsc() - _RDI->workerStartTimer) < 0 )
    __asm { vaddsd  xmm0, xmm0, xmm7 }
  __asm { vmulsd  xmm0, xmm0, cs:?msecPerRawTimerTick@@3NA; double msecPerRawTimerTick }
  v34 = NtCurrentTeb()->Reserved1[11];
  __asm
  {
    vmovaps xmm7, [rsp+8E8h+var_48]
    vcvtsd2ss xmm1, xmm0, xmm0
    vmovss  dword ptr [rdi+50h], xmm1
  }
  _RDI->workerStartTimer = 0i64;
  v10 = (_BYTE)CgStatic::ms_allocatedType == NONE;
  *(_QWORD *)(v34[(unsigned int)v11] + 1672i64) = 0i64;
  if ( v10 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_static.h", 96, ASSERT_TYPE_ASSERT, "(ms_allocatedType != GameModeType::NONE)", "%s\n\tTrying to clear the active bgs from the client game statics but the allocated type is not known.", "ms_allocatedType != GameModeType::NONE") )
    __debugbreak();
  if ( (unsigned int)v6 >= LODWORD(CgStatic::ms_allocatedCount) )
  {
    *(float *)&v40 = CgStatic::ms_allocatedCount;
    LODWORD(v39) = v6;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_static.h", 97, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( ms_allocatedCount )", "localClientNum doesn't index ms_allocatedCount\n\t%i not in [0, %i)", v39, v40) )
      __debugbreak();
  }
  if ( !CgStatic::ms_cgameStaticsArray[v13] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_static.h", 98, ASSERT_TYPE_ASSERT, "(ms_cgameStaticsArray[localClientNum] != 0)", "%s\n\tTrying to clear the active bgs from the client game statics but the client game static has not been allocated", "ms_cgameStaticsArray[localClientNum] != NULL") )
    __debugbreak();
  v37 = *((_QWORD *)NtCurrentTeb()->Reserved1[11] + (unsigned int)v11);
  if ( *(CgStatic **)(v37 + 272) != CgStatic::ms_cgameStaticsArray[v13] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_static.h", 99, ASSERT_TYPE_ASSERT, "( ( ms_activeBgs == ms_cgameStaticsArray[localClientNum] ) )", "( ms_activeBgs ) = %p", *(const void **)(v37 + 272)) )
    __debugbreak();
  *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + (unsigned int)v11) + 272i64) = v46;
  if ( ((unsigned __int8)v8 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 44, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", (const void *)v8) )
    __debugbreak();
  _InterlockedDecrement(v8);
}

/*
==============
CG_EntityWorkers_GetEntityWorkCost
==============
*/
__int64 CG_EntityWorkers_GetEntityWorkCost(const LocalClientNum_t localClientNum, const centity_t *cent)
{
  entityType_s eType; 

  if ( !cent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 608, ASSERT_TYPE_ASSERT, "(cent)", (const char *)&queryFormat, "cent") )
    __debugbreak();
  if ( (cent->flags & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 609, ASSERT_TYPE_ASSERT, "(CENextValid( cent ))", (const char *)&queryFormat, "CENextValid( cent )") )
    __debugbreak();
  if ( CG_EntityWorkers_IsCostBalancingEnabled() && (eType = cent->nextState.eType, eType < ET_EVENTS) )
    return ENTITY_WORKERS_TYPE_COST[eType];
  else
    return 10i64;
}

/*
==============
CG_EntityWorkers_GetEntityWorkFlags
==============
*/
__int64 CG_EntityWorkers_GetEntityWorkFlags(const LocalClientNum_t localClientNum, const cg_t *cgameGlob, const centity_t *cent)
{
  entityType_s eType; 
  CgEntitySystem *EntitySystem; 
  unsigned __int8 v8; 
  __int16 scriptMoverType; 
  bool v10; 
  __int64 v12; 

  if ( !cent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 679, ASSERT_TYPE_ASSERT, "(cent)", (const char *)&queryFormat, "cent") )
    __debugbreak();
  if ( (cent->flags & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 680, ASSERT_TYPE_ASSERT, "(CENextValid( cent ))", (const char *)&queryFormat, "CENextValid( cent )") )
    __debugbreak();
  eType = cent->nextState.eType;
  if ( (unsigned __int16)eType >= ET_EVENTS )
  {
    LODWORD(v12) = eType;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 681, ASSERT_TYPE_ASSERT, "(unsigned)( cent->nextState.eType ) < (unsigned)( ET_EVENTS )", "cent->nextState.eType doesn't index ET_EVENTS\n\t%i not in [0, %i)", v12, 29) )
      __debugbreak();
  }
  EntitySystem = CgEntitySystem::GetEntitySystem(localClientNum);
  v10 = EntitySystem->ShouldDelayEntityPacketPostPS(EntitySystem, cgameGlob, cent) == PPSD_NOT_DELAYED;
  v8 = 1;
  if ( !v10 )
    v8 = 3;
  switch ( cent->nextState.eType )
  {
    case ET_FIRST:
    case ET_ITEM:
    case ET_TURRET:
    case ET_HELICOPTER:
    case ET_VEHICLE:
    case ET_VEHICLE_CORPSE:
      goto $LN20_94;
    case ET_PLAYER:
    case ET_PLAYER_CORPSE:
      v10 = !s_entityWorkers_playersEnabled;
      goto LABEL_26;
    case ET_MISSILE:
      v10 = !s_entityWorkers_missilesEnabled;
      goto LABEL_26;
    case ET_SCRIPTMOVER:
      scriptMoverType = cent->nextState.un.scriptMoverType;
      if ( scriptMoverType != 3 && (scriptMoverType != 6 || !Com_GameMode_SupportsFeature((Com_GameMode_Feature)144)) && (cent->nextState.un.scriptMoverType != 4 || !Com_GameMode_SupportsFeature((Com_GameMode_Feature)144)) && (cent->nextState.un.scriptMoverType != 5 || !Com_GameMode_SupportsFeature((Com_GameMode_Feature)144)) && !GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&cent->nextState.lerp.eFlags, GameModeFlagValues::ms_mpValue, 0x14u) && !GameModeFlagContainer<enum EntityStateFlagsCommon,enum EntityStateFlagsSP,enum EntityStateFlagsMP,32>::TestFlagInternal(&cent->nextState.lerp.eFlags, GameModeFlagValues::ms_mpValue, 0x15u) )
        goto $LN20_94;
      return v8;
    case ET_AGENT:
    case ET_AGENT_CORPSE:
      v10 = !s_entityWorkers_agentsEnabled;
LABEL_26:
      if ( !v10 )
$LN20_94:
        v8 &= ~1u;
      break;
    default:
      return v8;
  }
  return v8;
}

/*
==============
CG_EntityWorkers_GetEntityWorkParents
==============
*/
__int64 CG_EntityWorkers_GetEntityWorkParents(const LocalClientNum_t localClientNum, const centity_t *cent, const CgEntityWorkData *workData, unsigned __int16 *outParents, CgEntityWorkData *outParentWorkData, unsigned int maxOutParents)
{
  const CgEntityWorkData *v7; 
  CgEntityWorkData *v10; 
  __int64 v11; 
  unsigned __int16 v12; 
  const centity_t *LinkToParent; 
  unsigned __int16 v14; 
  __int16 v15; 
  centity_t *v16; 
  const CgEntityWorkData *v17; 
  __int16 Parent; 
  centity_t *v19; 
  __int16 lookAtEntityNum; 
  centity_t *v21; 
  int v22; 
  __int16 otherEntityNum; 
  centity_t *Entity; 
  const CgEntityWorkData *v25; 
  cg_t *LocalClientGlobals; 
  __int64 clientNum; 
  cg_t *v28; 
  const characterInfo_t *CharacterInfo; 
  int moverId; 
  centity_t *v31; 
  unsigned int m_mapEntryId; 
  centity_t *v33; 
  int ActiveRagdollHandle; 
  centity_t *v35; 
  __int64 parentCount; 
  __int64 v38; 

  v7 = workData;
  if ( !cent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 833, ASSERT_TYPE_ASSERT, "(cent)", (const char *)&queryFormat, "cent") )
    __debugbreak();
  if ( !outParents && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 834, ASSERT_TYPE_ASSERT, "(outParents)", (const char *)&queryFormat, "outParents") )
    __debugbreak();
  v10 = outParentWorkData;
  if ( !outParentWorkData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 835, ASSERT_TYPE_ASSERT, "(outParentWorkData)", (const char *)&queryFormat, "outParentWorkData") )
    __debugbreak();
  if ( (cent->flags & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 836, ASSERT_TYPE_ASSERT, "(CENextValid( cent ))", (const char *)&queryFormat, "CENextValid( cent )") )
    __debugbreak();
  v11 = 0i64;
  v12 = 0;
  LinkToParent = CG_Entity_GetLinkToParent(localClientNum, cent);
  v14 = maxOutParents;
  if ( LinkToParent )
    v12 = CG_Entity_AddEntityParent(localClientNum, v7, LinkToParent, outParents, v10, 0, maxOutParents);
  switch ( cent->nextState.eType )
  {
    case ET_PLAYER:
    case ET_PHYSICS_CHILD:
      otherEntityNum = cent->nextState.otherEntityNum;
      if ( otherEntityNum == 2047 )
      {
        v25 = workData;
      }
      else
      {
        Entity = CG_GetEntity(localClientNum, otherEntityNum);
        v25 = workData;
        if ( (Entity->flags & 1) != 0 )
          v12 = CG_Entity_AddEntityParent(localClientNum, workData, Entity, outParents, v10, v12, v14);
      }
      LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
      clientNum = cent->nextState.clientNum;
      v28 = LocalClientGlobals;
      if ( LocalClientGlobals->HasCharacterInfo(LocalClientGlobals, clientNum) )
      {
        if ( v28->IsMP(v28) )
        {
          if ( (unsigned int)clientNum >= v28[1].predictedPlayerState.rxvOmnvars[64].timeModified )
          {
            LODWORD(v38) = v28[1].predictedPlayerState.rxvOmnvars[64].timeModified;
            LODWORD(parentCount) = clientNum;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame_mp\\cg_globals_mp_inline.h", 19, ASSERT_TYPE_ASSERT, "(unsigned)( characterIndex ) < (unsigned)( static_cast<int>( m_characterInfoCount ) )", "characterIndex doesn't index static_cast<int>( m_characterInfoCount )\n\t%i not in [0, %i)", parentCount, v38) )
              __debugbreak();
          }
          CharacterInfo = (const characterInfo_t *)(*(_QWORD *)&v28[1].predictedPlayerState.rxvOmnvars[62] + 14792 * clientNum);
        }
        else
        {
          CharacterInfo = CgGlobalsSP::GetCharacterInfo((CgGlobalsSP *)v28, clientNum);
        }
        if ( CharacterInfo )
        {
          moverId = CharacterInfo->nextMoverOffset.moverId;
          if ( moverId )
          {
            v31 = CG_GetEntity(localClientNum, moverId);
            if ( (v31->flags & 1) != 0 )
              v12 = CG_Entity_AddEntityParent(localClientNum, v25, v31, outParents, v10, v12, v14);
          }
        }
      }
      break;
    case ET_PLAYER_CORPSE:
      goto $LN49_24;
    case ET_MISSILE:
      if ( BgTrajectory::IsTrackingTrajectory(&cent->nextState.lerp.pos) || BgTrajectory::IsTrackingTrajectory(&cent->nextState.lerp.apos) )
      {
        v22 = cent->nextState.lerp.u.anonymous.data[5];
        if ( v22 != 2047 )
        {
          v21 = CG_GetEntity(localClientNum, v22);
          if ( (v21->flags & 1) != 0 )
            goto LABEL_26;
        }
      }
      break;
    case ET_SCRIPTMOVER:
      if ( (cent->nextState.lerp.u.anonymous.data[2] & 0x100) == 0 || (v15 = cent->nextState.otherEntityNum, v15 == 2047) )
      {
        v17 = workData;
      }
      else
      {
        v16 = CG_GetEntity(localClientNum, v15);
        v17 = workData;
        if ( (v16->flags & 1) != 0 )
          v12 = CG_Entity_AddEntityParent(localClientNum, workData, v16, outParents, v10, v12, v14);
      }
      Parent = CG_Train_GetParent(localClientNum, cent);
      if ( Parent != 2047 )
      {
        v19 = CG_GetEntity(localClientNum, Parent);
        if ( (v19->flags & 1) != 0 )
          v12 = CG_Entity_AddEntityParent(localClientNum, v17, v19, outParents, v10, v12, v14);
      }
      break;
    case ET_TURRET:
      m_mapEntryId = cent->nextState.staticState.player.stowedWeaponHandle.m_mapEntryId;
      if ( m_mapEntryId == 2047 )
      {
        v7 = workData;
      }
      else
      {
        v33 = CG_GetEntity(localClientNum, m_mapEntryId);
        v7 = workData;
        if ( (v33->flags & 1) != 0 )
          v12 = CG_Entity_AddEntityParent(localClientNum, workData, v33, outParents, v10, v12, v14);
      }
$LN49_24:
      ActiveRagdollHandle = CG_Pose_GetActiveRagdollHandle(&cent->pose);
      if ( ActiveRagdollHandle )
      {
        maxOutParents = 0;
        Ragdoll_GetAssociatedMovers(ActiveRagdollHandle, (__int16 *)&outParentWorkData, &maxOutParents);
        if ( maxOutParents )
        {
          do
          {
            v35 = CG_GetEntity(localClientNum, *((__int16 *)&outParentWorkData + v11));
            if ( (v35->flags & 1) != 0 )
              v12 = CG_Entity_AddEntityParent(localClientNum, v7, v35, outParents, v10, v12, v14);
            v11 = (unsigned int)(v11 + 1);
          }
          while ( (unsigned int)v11 < maxOutParents );
        }
      }
      break;
    case ET_ACTOR:
    case ET_ACTOR_CORPSE:
      lookAtEntityNum = cent->nextState.lerp.u.actor.lookAtEntityNum;
      if ( lookAtEntityNum != 2047 )
      {
        v21 = CG_GetEntity(localClientNum, lookAtEntityNum);
        if ( (v21->flags & 1) != 0 )
LABEL_26:
          v12 = CG_Entity_AddEntityParent(localClientNum, workData, v21, outParents, v10, v12, v14);
      }
      break;
    default:
      break;
  }
  if ( v12 > v14 )
  {
    LODWORD(v38) = v14;
    LODWORD(parentCount) = v12;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 970, ASSERT_TYPE_ASSERT, "( parentCount ) <= ( maxOutParents )", "parentCount not in [0, maxOutParents]\n\t%u not in [0, %u]", parentCount, v38) )
      __debugbreak();
  }
  return v12;
}

/*
==============
CG_EntityWorkers_GetProfileData
==============
*/
CgEntityWorkerProfileHistory *CG_EntityWorkers_GetProfileData(const LocalClientNum_t localClientNum)
{
  __int64 v1; 
  int v4; 

  v1 = localClientNum;
  if ( (unsigned int)localClientNum >= LOCAL_CLIENT_COUNT )
  {
    v4 = 2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1932, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( ( sizeof( *array_counter( s_entityWorkers_profileHistory ) ) + 0 ) )", "localClientNum doesn't index s_entityWorkers_profileHistory\n\t%i not in [0, %i)", localClientNum, v4) )
      __debugbreak();
  }
  return &s_entityWorkers_profileHistory[v1];
}

/*
==============
CG_EntityWorkers_InitBuilderCmd
==============
*/
void CG_EntityWorkers_InitBuilderCmd(const LocalClientNum_t localClientNum, const int serverTime, CgEntityWork *work, CgEntityWorkBuilder *workBuilder, CgEntityWorkBuilderCmd *outBuildWorkers)
{
  if ( !work && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1361, ASSERT_TYPE_ASSERT, "(work)", (const char *)&queryFormat, "work") )
    __debugbreak();
  if ( !outBuildWorkers && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1362, ASSERT_TYPE_ASSERT, "(outBuildWorkers)", (const char *)&queryFormat, "outBuildWorkers") )
    __debugbreak();
  DebugWipe(outBuildWorkers, 0x18ui64);
  DebugWipe(work, 0xE6E8ui64);
  DebugWipe(workBuilder, 0x5802ui64);
  outBuildWorkers->workBuilder = workBuilder;
  outBuildWorkers->serverTime = serverTime;
  outBuildWorkers->localClientNum = localClientNum;
  outBuildWorkers->workerData = work;
}

/*
==============
CG_EntityWorkers_InitProfileFrameData
==============
*/
void CG_EntityWorkers_InitProfileFrameData(CgEntityWork *entityWork)
{
  memset_0(entityWork->profileWorkers, 0, 0xCCC8ui64);
  entityWork->profileFrame.minWorkerTime = 3.4028235e38;
  entityWork->profileFrame.maxWorkerTime = 1.1754944e-38;
}

/*
==============
CG_EntityWorkers_InitWorkerOutput
==============
*/
void CG_EntityWorkers_InitWorkerOutput(MpscStream<524288> *workerOutputStream)
{
  if ( s_entityWorkers_outputStream && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1610, ASSERT_TYPE_ASSERT, "(s_entityWorkers_outputStream == nullptr)", (const char *)&queryFormat, "s_entityWorkers_outputStream == nullptr") )
    __debugbreak();
  workerOutputStream->m_readOffset = 0;
  workerOutputStream->m_writeOffset = 0;
  workerOutputStream->m_reserveOffset = 0;
  DebugWipe(&workerOutputStream->m_buffer, 0x80000ui64);
  s_entityWorkers_outputStream = workerOutputStream;
}

/*
==============
CG_EntityWorkers_IsCostBalancingEnabled
==============
*/
bool CG_EntityWorkers_IsCostBalancingEnabled()
{
  const dvar_t *v0; 

  if ( !Com_GameMode_SupportsFeature(WEAPON_OFFHAND_PREPARE) )
    return 0;
  v0 = DCONST_DVARBOOL_cg_entityWorkersCostBalancing;
  if ( !DCONST_DVARBOOL_cg_entityWorkersCostBalancing && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkersCostBalancing") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v0);
  return v0->current.enabled;
}

/*
==============
CG_EntityWorkers_LeaveCriticalSection
==============
*/
void CG_EntityWorkers_LeaveCriticalSection(void)
{
  const dvar_t *v0; 

  v0 = DVARBOOL_cg_entityWorkers;
  if ( !DVARBOOL_cg_entityWorkers && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkers") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v0);
  if ( v0->current.enabled )
    Sys_LeaveCriticalSection(CRITSECT_ENTITY_WORKER_LOCK);
}

/*
==============
CG_EntityWorkers_LeaveCriticalSection_Compass
==============
*/
void CG_EntityWorkers_LeaveCriticalSection_Compass(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  const dvar_t *v1; 

  v1 = DVARBOOL_cg_entityWorkers;
  if ( !DVARBOOL_cg_entityWorkers && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkers") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  if ( v1->current.enabled )
  {
    if ( CG_EntityWorkers_CriticalSection_CheckKillswitch_Leave(fallbackMode, 1) )
      Sys_LeaveCriticalSection(CRITSECT_ENTITY_WORKER_LOCK);
  }
}

/*
==============
CG_EntityWorkers_LeaveCriticalSection_LegacyOnly
==============
*/
void CG_EntityWorkers_LeaveCriticalSection_LegacyOnly(void)
{
  const dvar_t *v0; 

  v0 = DVARBOOL_cg_entityWorkers;
  if ( !DVARBOOL_cg_entityWorkers && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkers") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v0);
  if ( v0->current.enabled )
  {
    if ( (unsigned __int8)CG_EntityWorkers_CritSecLegacyMode() )
      Sys_LeaveCriticalSection(CRITSECT_ENTITY_WORKER_LOCK);
  }
}

/*
==============
CG_EntityWorkers_LeaveCriticalSection_Mayhem
==============
*/
void CG_EntityWorkers_LeaveCriticalSection_Mayhem(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  const dvar_t *v1; 

  v1 = DVARBOOL_cg_entityWorkers;
  if ( !DVARBOOL_cg_entityWorkers && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkers") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  if ( v1->current.enabled )
  {
    if ( CG_EntityWorkers_CriticalSection_CheckKillswitch_Leave(fallbackMode, 1) )
      Sys_LeaveCriticalSection(CRITSECT_ENTITY_WORKER_LOCK);
  }
}

/*
==============
CG_EntityWorkers_LeaveCriticalSection_Ragdoll
==============
*/
void CG_EntityWorkers_LeaveCriticalSection_Ragdoll(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  const dvar_t *v1; 

  v1 = DVARBOOL_cg_entityWorkers;
  if ( !DVARBOOL_cg_entityWorkers && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkers") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  if ( v1->current.enabled )
  {
    if ( CG_EntityWorkers_CriticalSection_CheckKillswitch_Leave(fallbackMode, 1) )
      Sys_LeaveCriticalSection(CRITSECT_ENTITY_WORKER_LOCK);
  }
}

/*
==============
CG_EntityWorkers_LeaveCriticalSection_ReflectionProbe
==============
*/
void CG_EntityWorkers_LeaveCriticalSection_ReflectionProbe(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  const dvar_t *v1; 

  v1 = DVARBOOL_cg_entityWorkers;
  if ( !DVARBOOL_cg_entityWorkers && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkers") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  if ( v1->current.enabled )
  {
    if ( CG_EntityWorkers_CriticalSection_CheckKillswitch_Leave(fallbackMode, 1) )
      Sys_LeaveCriticalSection(CRITSECT_ENTITY_WORKER_LOCK);
  }
}

/*
==============
CG_EntityWorkers_LeaveCriticalSection_ScriptableCl
==============
*/
void CG_EntityWorkers_LeaveCriticalSection_ScriptableCl(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  const dvar_t *v1; 

  v1 = DVARBOOL_cg_entityWorkers;
  if ( !DVARBOOL_cg_entityWorkers && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkers") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  if ( v1->current.enabled )
  {
    if ( (unsigned __int8)CG_EntityWorkers_CritSecLegacyMode() )
    {
      if ( fallbackMode == BASE )
      {
        Sys_LeaveCriticalSection(CRITSECT_ENTITY_WORKER_LOCK);
      }
      else if ( *(_BYTE *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1664i64) && !Sys_InCriticalSection(CRITSECT_ENTITY_WORKER_LOCK) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 445, ASSERT_TYPE_ASSERT, "(!CG_EntityWorkers_IsProcessingEntityWorker() || Sys_InCriticalSection( CRITSECT_ENTITY_WORKER_LOCK ))", (const char *)&queryFormat, "!CG_EntityWorkers_IsProcessingEntityWorker() || Sys_InCriticalSection( CRITSECT_ENTITY_WORKER_LOCK )") )
      {
        __debugbreak();
      }
    }
    else
    {
      Sys_LeaveCriticalSection(CRITSECT_ENTITY_WORKER_LOCK_SCRIPTABLECL);
    }
  }
}

/*
==============
CG_EntityWorkers_LeaveCriticalSection_Unverified
==============
*/
void CG_EntityWorkers_LeaveCriticalSection_Unverified(void)
{
  const dvar_t *v0; 

  v0 = DVARBOOL_cg_entityWorkers;
  if ( !DVARBOOL_cg_entityWorkers && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkers") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v0);
  if ( v0->current.enabled )
    Sys_LeaveCriticalSection(CRITSECT_ENTITY_WORKER_LOCK);
}

/*
==============
CG_EntityWorkers_LeaveCriticalSection_VFX
==============
*/
void CG_EntityWorkers_LeaveCriticalSection_VFX(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  const dvar_t *v1; 

  v1 = DVARBOOL_cg_entityWorkers;
  if ( !DVARBOOL_cg_entityWorkers && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkers") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  if ( v1->current.enabled )
  {
    if ( CG_EntityWorkers_CriticalSection_CheckKillswitch_Leave(fallbackMode, 1) )
      Sys_LeaveCriticalSection(CRITSECT_ENTITY_WORKER_LOCK);
  }
}

/*
==============
CG_EntityWorkers_LeaveCriticalSection_VehicleGetFx
==============
*/
void CG_EntityWorkers_LeaveCriticalSection_VehicleGetFx(void)
{
  const dvar_t *v0; 
  __int64 v1; 

  v0 = DVARBOOL_cg_entityWorkers;
  if ( !DVARBOOL_cg_entityWorkers && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkers") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v0);
  if ( v0->current.enabled )
  {
    v1 = 8i64 * tls_index;
    if ( *(_BYTE *)(*(_QWORD *)((char *)NtCurrentTeb()->Reserved1[11] + v1) + 1664i64) )
    {
      if ( (unsigned __int8)CG_EntityWorkers_CritSecLegacyMode() )
      {
        if ( *(_BYTE *)(*(_QWORD *)((char *)NtCurrentTeb()->Reserved1[11] + v1) + 1664i64) && !Sys_InCriticalSection(CRITSECT_ENTITY_WORKER_LOCK) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 445, ASSERT_TYPE_ASSERT, "(!CG_EntityWorkers_IsProcessingEntityWorker() || Sys_InCriticalSection( CRITSECT_ENTITY_WORKER_LOCK ))", (const char *)&queryFormat, "!CG_EntityWorkers_IsProcessingEntityWorker() || Sys_InCriticalSection( CRITSECT_ENTITY_WORKER_LOCK )") )
          __debugbreak();
      }
      else
      {
        Sys_LeaveCriticalSection(CRITSECT_ENTITY_WORKER_VEHICLE_GETFX);
      }
    }
  }
}

/*
==============
CG_EntityWorkers_LeaveCriticalSection_ViewModel
==============
*/
void CG_EntityWorkers_LeaveCriticalSection_ViewModel(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  const dvar_t *v1; 

  v1 = DVARBOOL_cg_entityWorkers;
  if ( !DVARBOOL_cg_entityWorkers && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkers") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  if ( v1->current.enabled )
  {
    if ( CG_EntityWorkers_CriticalSection_CheckKillswitch_Leave(fallbackMode, 1) )
      Sys_LeaveCriticalSection(CRITSECT_ENTITY_WORKER_LOCK);
  }
}

/*
==============
CG_EntityWorkers_ProcessEntity
==============
*/
void CG_EntityWorkers_ProcessEntity(CgEntitySystem *entitySystem, CgAntiLag *antiLag, const unsigned __int16 entityIndex, const bool contextKey)
{
  entityType_s eType; 
  __int64 v9; 
  __int64 v10; 
  __int64 v11; 

  if ( !entitySystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2187, ASSERT_TYPE_ASSERT, "(entitySystem)", (const char *)&queryFormat, "entitySystem") )
    __debugbreak();
  if ( entityIndex >= 0x7FEu )
  {
    LODWORD(v10) = entityIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2188, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ENTITYNUM_ORDINARY_END )", "entityIndex doesn't index ENTITYNUM_ORDINARY_END\n\t%i not in [0, %i)", v10, 2046) )
      __debugbreak();
  }
  if ( entityIndex >= 0x800u )
  {
    LODWORD(v11) = 2048;
    LODWORD(v10) = entityIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 518, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( (( 2048 ) + 0) )", "entityIndex doesn't index MAX_LOCAL_CENTITIES\n\t%i not in [0, %i)", v10, v11) )
      __debugbreak();
  }
  if ( (entitySystem->m_entities[entityIndex].flags & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2191, ASSERT_TYPE_ASSERT, "(CENextValid( cent ))", (const char *)&queryFormat, "CENextValid( cent )") )
    __debugbreak();
  eType = entitySystem->m_entities[entityIndex].nextState.eType;
  if ( (unsigned __int16)eType >= ET_EVENTS )
  {
    LODWORD(v11) = 29;
    LODWORD(v10) = eType;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2192, ASSERT_TYPE_ASSERT, "(unsigned)( cent->nextState.eType ) < (unsigned)( ET_EVENTS )", "cent->nextState.eType doesn't index ET_EVENTS\n\t%i not in [0, %i)", v10, v11) )
      __debugbreak();
  }
  CG_Entity_SetUpdateFlagEnabled(contextKey, &entitySystem->m_entities[entityIndex]);
  if ( (entitySystem->m_entities[entityIndex].flags & 0x4000) == 0 )
  {
    v9 = 8i64 * tls_index;
    *(_BYTE *)(*(_QWORD *)((char *)NtCurrentTeb()->Reserved1[11] + v9) + 1664i64) = 1;
    if ( (unsigned __int16)(entitySystem->m_entities[entityIndex].nextState.eType - 8) > 1u )
    {
      CgEntitySystem::CacheEntityData(entitySystem, &entitySystem->m_entities[entityIndex]);
      entitySystem->AddPacketEntity(entitySystem, entityIndex);
      if ( antiLag )
        CgAntiLag::ArchiveEntity(antiLag, &entitySystem->m_entities[entityIndex], 0);
    }
    else
    {
      entitySystem->AddPacketFxEntity(entitySystem, entityIndex);
    }
    *(_BYTE *)(*(_QWORD *)((char *)NtCurrentTeb()->Reserved1[11] + v9) + 1664i64) = 0;
  }
}

/*
==============
CG_EntityWorkers_ProcessFxMarkDetachAllRequests
==============
*/
void CG_EntityWorkers_ProcessFxMarkDetachAllRequests(const LocalClientNum_t localClientNum, const CgEntityFxMarkDetachAllRequest *detactAllRequest)
{
  FX_MarkEntDetachAll(detactAllRequest->localClientNum, detactAllRequest->entIndex);
}

/*
==============
CG_EntityWorkers_ProcessNoteTrackNotifyUpdate
==============
*/
void CG_EntityWorkers_ProcessNoteTrackNotifyUpdate(const LocalClientNum_t localClientNum, const CgEntityNotetrackRequest *request)
{
  CgEntitySystem *EntitySystem; 
  unsigned int entityIndex; 
  int v6; 

  if ( request->entityIndex >= 0x7FE )
  {
    v6 = 2046;
    entityIndex = request->entityIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1837, ASSERT_TYPE_ASSERT, "(unsigned)( request.entityIndex ) < (unsigned)( ENTITYNUM_ORDINARY_END )", "request.entityIndex doesn't index ENTITYNUM_ORDINARY_END\n\t%i not in [0, %i)", entityIndex, v6) )
      __debugbreak();
  }
  if ( request->notifyHandle.m_notifyIndex == 0xFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1838, ASSERT_TYPE_ASSERT, "(request.notifyHandle.IsValid())", (const char *)&queryFormat, "request.notifyHandle.IsValid()") )
    __debugbreak();
  EntitySystem = CgEntitySystem::GetEntitySystem(localClientNum);
  ((void (__fastcall *)(CgEntitySystem *, _QWORD, _QWORD))EntitySystem->ProcessNoteTracks)(EntitySystem, request->entityIndex, request->notifyHandle.m_notifyIndex);
}

/*
==============
CG_EntityWorkers_ProcessPlayerPostUpdate
==============
*/
void CG_EntityWorkers_ProcessPlayerPostUpdate(const LocalClientNum_t localClientNum, const CgEntityPlayerPostUpdate *plrUpdate)
{
  vec3_t to; 

  GetSecureWorkerOrigin(&plrUpdate->poseOrigin.origin, &to, ~plrUpdate->entityIndex);
  CG_PlayersMP_ProcessPlayerPostUpdate(localClientNum, plrUpdate->entityIndex, plrUpdate->clientIndex, &to);
  memset(&to, 0, sizeof(to));
}

/*
==============
CG_EntityWorkers_ProcessScriptableEventLightUpdate
==============
*/
void CG_EntityWorkers_ProcessScriptableEventLightUpdate(const LocalClientNum_t localClientNum, const CgEntityScriptableEventLightUpdate *lightUpdate)
{
  GfxWorld *world; 
  float *p_type; 
  __int64 v5; 
  unsigned int primaryLightCount; 

  world = rgp.world;
  if ( !rgp.world && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1875, ASSERT_TYPE_ASSERT, "(curGfxWorld)", (const char *)&queryFormat, "curGfxWorld") )
    __debugbreak();
  if ( lightUpdate->lightIndex >= world->primaryLightCount )
  {
    primaryLightCount = world->primaryLightCount;
    LODWORD(v5) = lightUpdate->lightIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1877, ASSERT_TYPE_ASSERT, "(unsigned)( lightUpdate.lightIndex ) < (unsigned)( curGfxWorld->primaryLightCount )", "lightUpdate.lightIndex doesn't index curGfxWorld->primaryLightCount\n\t%i not in [0, %i)", v5, primaryLightCount) )
      __debugbreak();
  }
  p_type = (float *)&world->primaryLights[lightUpdate->lightIndex].type;
  p_type[17] = lightUpdate->radius;
  p_type[4] = lightUpdate->intensity;
  p_type[5] = lightUpdate->colorLinearSrgb.v[0];
  p_type[6] = lightUpdate->colorLinearSrgb.v[1];
  p_type[7] = lightUpdate->colorLinearSrgb.v[2];
}

/*
==============
CG_EntityWorkers_ProcessScriptableEventSunUpdate
==============
*/
void CG_EntityWorkers_ProcessScriptableEventSunUpdate(const LocalClientNum_t localCleintNum, const CgEntityScriptableEventSunUpdate *request)
{
  _RBX = request;
  if ( request->useColor )
    R_SetSunColorOverride(&request->colorLinearSrgb);
  if ( _RBX->useIntensity )
  {
    __asm { vmovss  xmm0, dword ptr [rbx+0Ch]; sunIntensity }
    R_SetSunIntensityOverride(*(const float *)&_XMM0);
  }
  if ( _RBX->useDirection )
    R_SetSunDirectionOverride(&_RBX->direction, 0);
}

/*
==============
CG_EntityWorkers_ProcessScriptableSpatialUpdate
==============
*/
void CG_EntityWorkers_ProcessScriptableSpatialUpdate(const LocalClientNum_t localClientNum, const CgEntityScriptableSpatialUpdate *spatialUpdate)
{
  ScriptableCl_Spatial_UpdateMarkerPartition(localClientNum, spatialUpdate->scriptableIndex, spatialUpdate->markerIndex, spatialUpdate->partitionIndex);
}

/*
==============
CG_EntityWorkers_ProcessTurretBarrelSpinSoundRequests
==============
*/
void CG_EntityWorkers_ProcessTurretBarrelSpinSoundRequests(const LocalClientNum_t localClientNum, const CgEntityTurretBarrelSpinSoundRequest *request)
{
  CG_Turret_UpdateBarrelSpinSoundPlayback(localClientNum, request->entIndex);
}

/*
==============
CG_EntityWorkers_ProcessWorkeBModelDrawRequest
==============
*/
void CG_EntityWorkers_ProcessWorkeBModelDrawRequest(const LocalClientNum_t localClientNum, const CgEntityBModelDrawRequest *bmodelDrawRequest)
{
  unsigned int entnum; 
  centity_t *Entity; 
  const GfxBrushModel *BrushModel; 
  unsigned int renderFlags; 
  void (__fastcall *FunctionPointer_prevOrigin)(const vec4_t *, vec3_t *); 
  vec3_t outOrigin; 
  vec3_t prevOrigin; 

  entnum = bmodelDrawRequest->entityIndex;
  if ( bmodelDrawRequest->entityIndex >= 0x7FE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1794, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ENTITYNUM_ORDINARY_END )", "entityIndex doesn't index ENTITYNUM_ORDINARY_END\n\t%i not in [0, %i)", bmodelDrawRequest->entityIndex, 2046) )
    __debugbreak();
  Entity = CG_GetEntity(localClientNum, entnum);
  if ( (Entity->flags & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1797, ASSERT_TYPE_ASSERT, "(CENextValid( cent ))", (const char *)&queryFormat, "CENextValid( cent )") )
    __debugbreak();
  BrushModel = R_GetBrushModel(Entity->nextState.index.brushModel);
  if ( !BrushModel && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1800, ASSERT_TYPE_ASSERT, "(brushModel)", (const char *)&queryFormat, "brushModel") )
    __debugbreak();
  renderFlags = bmodelDrawRequest->renderFlags;
  if ( !Entity->pose.prevOrigin.Get_prevOrigin && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_pose.h", 568, ASSERT_TYPE_ASSERT, "(pose->prevOrigin.Get_prevOrigin)", (const char *)&queryFormat, "pose->prevOrigin.Get_prevOrigin") )
    __debugbreak();
  FunctionPointer_prevOrigin = ObfuscateGetFunctionPointer_prevOrigin(Entity->pose.prevOrigin.Get_prevOrigin, &Entity->pose);
  FunctionPointer_prevOrigin(&Entity->pose.prevOrigin.prevOrigin, &prevOrigin);
  CG_GetPoseOrigin(&Entity->pose, &outOrigin);
  R_AddBrushModelToSceneFromAngles(BrushModel, &outOrigin, &Entity->pose.angles, &prevOrigin, &Entity->pose.prevAngles, entnum, renderFlags);
  memset(&outOrigin, 0, sizeof(outOrigin));
  memset(&prevOrigin, 0, sizeof(prevOrigin));
}

/*
==============
CG_EntityWorkers_ProcessWorkerBModelBoundsUpdate
==============
*/
void CG_EntityWorkers_ProcessWorkerBModelBoundsUpdate(const LocalClientNum_t localClientNum, const CgEntityBModelUpdateBoundsRequest *bmodelUpdateReq)
{
  unsigned __int16 entityIndex; 
  centity_t *Entity; 
  int v5; 
  int v6; 

  entityIndex = bmodelUpdateReq->entityIndex;
  if ( bmodelUpdateReq->entityIndex >= 0x7FEu )
  {
    v6 = 2046;
    v5 = entityIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1654, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ENTITYNUM_ORDINARY_END )", "entityIndex doesn't index ENTITYNUM_ORDINARY_END\n\t%i not in [0, %i)", v5, v6) )
      __debugbreak();
  }
  Entity = CG_GetEntity(localClientNum, entityIndex);
  if ( (Entity->flags & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1659, ASSERT_TYPE_ASSERT, "(CENextValid( cent ))", (const char *)&queryFormat, "CENextValid( cent )") )
    __debugbreak();
  CG_Entity_UpdateBModelWorldBounds(localClientNum, Entity, 0);
}

/*
==============
CG_EntityWorkers_ProcessWorkerDObjBoundsUpdate
==============
*/
void CG_EntityWorkers_ProcessWorkerDObjBoundsUpdate(const LocalClientNum_t localClientNum, const CgEntityDObjUpdateBoundsRequest *dobjUpdateReq)
{
  unsigned __int16 entityIndex; 
  centity_t *Entity; 
  const DObj *ClientDObj; 
  const DObj *v9; 
  unsigned int v12; 
  float fmt; 
  int v15; 
  int v16; 
  vec3_t outOrigin; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm { vmovaps xmmword ptr [rax-18h], xmm6 }
  entityIndex = dobjUpdateReq->entityIndex;
  if ( dobjUpdateReq->entityIndex >= 0x7FEu )
  {
    v16 = 2046;
    v15 = entityIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1629, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ENTITYNUM_ORDINARY_END )", "entityIndex doesn't index ENTITYNUM_ORDINARY_END\n\t%i not in [0, %i)", v15, v16) )
      __debugbreak();
  }
  Entity = CG_GetEntity(localClientNum, entityIndex);
  if ( (Entity->flags & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1634, ASSERT_TYPE_ASSERT, "(CENextValid( cent ))", (const char *)&queryFormat, "CENextValid( cent )") )
    __debugbreak();
  ClientDObj = Com_GetClientDObj(entityIndex, localClientNum);
  v9 = ClientDObj;
  if ( ClientDObj )
  {
    *(double *)&_XMM0 = DObjGetRadius(ClientDObj);
    __asm { vaddss  xmm6, xmm0, cs:__real@41800000 }
    CG_GetPoseOrigin(&Entity->pose, &outOrigin);
    __asm { vmovaps xmm3, xmm6; radius }
    v12 = R_LinkDObjEntity(localClientNum, entityIndex, &outOrigin, *(float *)&_XMM3);
    Entity->flags |= 0x80000u;
    __asm { vmovss  dword ptr [rsp+78h+fmt], xmm6 }
    CG_Entity_CheckLightCount(entityIndex, v9, v12, &outOrigin, fmt);
    memset(&outOrigin, 0, sizeof(outOrigin));
  }
  __asm { vmovaps xmm6, [rsp+78h+var_18] }
}

/*
==============
CG_EntityWorkers_ProcessWorkerDObjDrawRequest
==============
*/
void CG_EntityWorkers_ProcessWorkerDObjDrawRequest(const LocalClientNum_t localClientNum, const CgEntityDObjDrawRequest *dobjDrawRequest)
{
  unsigned int entityIndex; 
  DObj *ClientDObj; 
  unsigned int lightingOrigin; 
  int materialTime; 
  float materialTimea; 
  float materialTimeb; 
  vec3_t to; 
  __int64 v29; 
  shaderOverride_t v30; 
  GfxSceneHudOutlineInfo v31; 
  GfxSceneEntityMutableShaderData v32; 
  GfxSceneEntityMutableShaderData entityMutableShaderData; 

  v29 = -2i64;
  _RSI = dobjDrawRequest;
  entityIndex = dobjDrawRequest->entityIndex;
  if ( dobjDrawRequest->entityIndex >= 0x7FE )
  {
    materialTime = 2046;
    lightingOrigin = dobjDrawRequest->entityIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1760, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ENTITYNUM_ORDINARY_END )", "entityIndex doesn't index ENTITYNUM_ORDINARY_END\n\t%i not in [0, %i)", lightingOrigin, materialTime) )
      __debugbreak();
  }
  _R14 = CG_GetEntity(localClientNum, entityIndex);
  if ( (_R14->flags & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1763, ASSERT_TYPE_ASSERT, "(CENextValid( cent ))", (const char *)&queryFormat, "CENextValid( cent )") )
    __debugbreak();
  ClientDObj = Com_GetClientDObj(entityIndex, localClientNum);
  if ( ClientDObj )
  {
    CG_LocalEntity_PreAddDObjUpdate(localClientNum, entityIndex);
    __asm
    {
      vmovups ymm0, ymmword ptr [rsi+40h]
      vmovups [rsp+248h+var_1E8], ymm0
    }
    v30.atlasTime = _RSI->shaderOverride.atlasTime;
    __asm
    {
      vmovups ymm0, ymmword ptr [rsi+1Ch]
      vmovups [rsp+248h+var_1B8], ymm0
    }
    v31.characterEVOffset = _RSI->hudOutlineInfo.characterEVOffset;
    __asm
    {
      vmovss  xmm0, dword ptr [r14+2E8h]
      vmovss  [rsp+248h+materialTime], xmm0
    }
    _RAX = CG_Entity_GetMutableShaderData(&v32, localClientNum, ClientDObj, _RSI->materialData, &v31, &v30, materialTimea);
    _RCX = &entityMutableShaderData;
    __asm
    {
      vmovups xmm0, xmmword ptr [rax]
      vmovups xmmword ptr [rcx], xmm0
      vmovups xmm1, xmmword ptr [rax+10h]
      vmovups xmmword ptr [rcx+10h], xmm1
      vmovups xmm0, xmmword ptr [rax+20h]
      vmovups xmmword ptr [rcx+20h], xmm0
      vmovups xmm1, xmmword ptr [rax+30h]
      vmovups xmmword ptr [rcx+30h], xmm1
      vmovups xmm0, xmmword ptr [rax+40h]
      vmovups xmmword ptr [rcx+40h], xmm0
      vmovups xmm1, xmmword ptr [rax+50h]
      vmovups xmmword ptr [rcx+50h], xmm1
      vmovups xmm0, xmmword ptr [rax+60h]
      vmovups xmmword ptr [rcx+60h], xmm0
      vmovups xmm0, xmmword ptr [rax+70h]
      vmovups xmmword ptr [rcx+70h], xmm0
      vmovups xmm1, xmmword ptr [rax+80h]
      vmovups xmmword ptr [rcx+80h], xmm1
      vmovups xmm0, xmmword ptr [rax+90h]
      vmovups xmmword ptr [rcx+90h], xmm0
      vmovups xmm1, xmmword ptr [rax+0A0h]
      vmovups xmmword ptr [rcx+0A0h], xmm1
    }
    CG_Entity_UpdateCharacterEvOffset(localClientNum, entityIndex, &entityMutableShaderData.hudOutlineInfo);
    GetSecureWorkerOrigin(&_RSI->lightingOrigin.origin, &to, ~_RSI->entityIndex);
    __asm
    {
      vmovss  xmm0, dword ptr [rsi+0Ch]
      vmovss  [rsp+248h+materialTime], xmm0
    }
    R_AddDObjToScene(ClientDObj, &_R14->pose, entityIndex, _RSI->renderFlags, &entityMutableShaderData, &to, materialTimeb);
    if ( (ClientDObj->flags & 4) != 0 )
      R_EntityHasSkinningAnimation(localClientNum, entityIndex);
    memset(&to, 0, sizeof(to));
  }
}

/*
==============
CG_EntityWorkers_ProcessWorkerOutput
==============
*/

__int64 __fastcall CG_EntityWorkers_ProcessWorkerOutput(const LocalClientNum_t localClientNum, CgEntityWork *work, MpscStream<524288> *workerOutput, double _XMM3_8)
{
  CgEntityWork *v6; 
  __int64 v7; 
  volatile int *p_workersPendingCount; 
  unsigned __int8 v9; 
  int v10; 
  bool v11; 
  unsigned int i; 
  unsigned __int16 workerCount; 
  __int64 v16; 
  CgEntityWorkerProfileHistory *v30; 
  __int64 v32; 
  int v45; 
  __int64 v47; 
  __int64 v48; 
  __int64 v49; 
  __int64 v50; 
  unsigned __int8 buffer; 
  unsigned __int8 v52; 
  CgEntityDObjUpdateBoundsRequest dobjUpdateReq; 
  CgEntityBModelUpdateBoundsRequest bmodelUpdateReq; 
  unsigned int entNum; 
  LocalClientNum_t localClientNuma[2]; 
  CgEntityBModelDrawRequest bmodelDrawRequest; 
  CgEntityNotetrackRequest request; 
  CgEntityWork *v59; 
  vec3_t to; 
  __int64 v61; 
  unsigned int scriptableIndex[4]; 
  unsigned int entityIndex[2]; 
  vec3_t from; 
  vec3_t sunColorLinearSrgb; 
  vec3_t sunDir; 
  char v68; 
  char v69; 
  char v70; 
  CgEntityScriptableEventLightUpdate lightUpdate; 
  CgEntitySoundRequest r_soundRequest; 
  CgEntityDObjDrawRequest dobjDrawRequest; 

  v61 = -2i64;
  v6 = work;
  v59 = work;
  v7 = localClientNum;
  p_workersPendingCount = &work->workersPendingCount;
  if ( (((_BYTE)work + 28) & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 141, ASSERT_TYPE_ASSERT, "( ( IsAligned( addr, sizeof( volatile_int32 ) ) ) )", "( addr ) = %p", &work->workersPendingCount) )
    __debugbreak();
  v9 = *p_workersPendingCount == 0;
  v52 = v9;
  if ( (signed int)(workerOutput->m_writeOffset - workerOutput->m_readOffset) > 0 )
  {
    Sys_ProfBeginNamedEvent(0xFF102030, "proc worker output");
    do
    {
      buffer = 12;
      if ( MpscStream<524288>::Read(workerOutput, &buffer, 1) != 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2105, ASSERT_TYPE_ASSERT, "(workerOutput.Read( &outputType, sizeof( outputType ) ) == sizeof( outputType ))", (const char *)&queryFormat, "workerOutput.Read( &outputType, sizeof( outputType ) ) == sizeof( outputType )") )
        __debugbreak();
      switch ( buffer )
      {
        case 0u:
          if ( (signed int)(workerOutput->m_writeOffset - workerOutput->m_readOffset) < 100 )
          {
            LODWORD(v50) = workerOutput->m_writeOffset - workerOutput->m_readOffset;
            LODWORD(v49) = 100;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2076, ASSERT_TYPE_ASSERT, "( dataSize ) <= ( workerOutput.Size() )", "%s <= %s\n\t%i, %i", "dataSize", "workerOutput.Size()", v49, v50) )
              __debugbreak();
          }
          v10 = MpscStream<524288>::Read(workerOutput, &dobjDrawRequest, 100);
          if ( v10 != 100 )
          {
            LODWORD(v48) = 100;
            goto LABEL_16;
          }
          CG_EntityWorkers_ProcessWorkerDObjDrawRequest((const LocalClientNum_t)v7, &dobjDrawRequest);
          break;
        case 1u:
          if ( (signed int)(workerOutput->m_writeOffset - workerOutput->m_readOffset) < 8 )
          {
            LODWORD(v50) = workerOutput->m_writeOffset - workerOutput->m_readOffset;
            LODWORD(v49) = 8;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2076, ASSERT_TYPE_ASSERT, "( dataSize ) <= ( workerOutput.Size() )", "%s <= %s\n\t%i, %i", "dataSize", "workerOutput.Size()", v49, v50) )
              __debugbreak();
          }
          v10 = MpscStream<524288>::Read(workerOutput, &bmodelDrawRequest, 8);
          if ( v10 != 8 )
            goto LABEL_22;
          CG_EntityWorkers_ProcessWorkeBModelDrawRequest((const LocalClientNum_t)v7, &bmodelDrawRequest);
          break;
        case 2u:
          if ( (signed int)(workerOutput->m_writeOffset - workerOutput->m_readOffset) < 2 )
          {
            LODWORD(v50) = workerOutput->m_writeOffset - workerOutput->m_readOffset;
            LODWORD(v49) = 2;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2076, ASSERT_TYPE_ASSERT, "( dataSize ) <= ( workerOutput.Size() )", "%s <= %s\n\t%i, %i", "dataSize", "workerOutput.Size()", v49, v50) )
              __debugbreak();
          }
          v10 = MpscStream<524288>::Read(workerOutput, &dobjUpdateReq, 2);
          if ( v10 != 2 )
            goto LABEL_28;
          CG_EntityWorkers_ProcessWorkerDObjBoundsUpdate((const LocalClientNum_t)v7, &dobjUpdateReq);
          break;
        case 3u:
          if ( (signed int)(workerOutput->m_writeOffset - workerOutput->m_readOffset) < 2 )
          {
            LODWORD(v50) = workerOutput->m_writeOffset - workerOutput->m_readOffset;
            LODWORD(v49) = 2;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2076, ASSERT_TYPE_ASSERT, "( dataSize ) <= ( workerOutput.Size() )", "%s <= %s\n\t%i, %i", "dataSize", "workerOutput.Size()", v49, v50) )
              __debugbreak();
          }
          v10 = MpscStream<524288>::Read(workerOutput, &bmodelUpdateReq, 2);
          if ( v10 != 2 )
          {
LABEL_28:
            LODWORD(v48) = 2;
            goto LABEL_16;
          }
          CG_EntityWorkers_ProcessWorkerBModelBoundsUpdate((const LocalClientNum_t)v7, &bmodelUpdateReq);
          break;
        case 4u:
          if ( (signed int)(workerOutput->m_writeOffset - workerOutput->m_readOffset) < 20 )
          {
            LODWORD(v50) = workerOutput->m_writeOffset - workerOutput->m_readOffset;
            LODWORD(v49) = 20;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2076, ASSERT_TYPE_ASSERT, "( dataSize ) <= ( workerOutput.Size() )", "%s <= %s\n\t%i, %i", "dataSize", "workerOutput.Size()", v49, v50) )
              __debugbreak();
          }
          v10 = MpscStream<524288>::Read(workerOutput, entityIndex, 20);
          if ( v10 != 20 )
          {
            LODWORD(v48) = 20;
            goto LABEL_16;
          }
          GetSecureWorkerOrigin(&from, &to, ~entityIndex[0]);
          CG_PlayersMP_ProcessPlayerPostUpdate((LocalClientNum_t)v7, entityIndex[0], entityIndex[1], &to);
          memset(&to, 0, sizeof(to));
          break;
        case 5u:
          if ( (signed int)(workerOutput->m_writeOffset - workerOutput->m_readOffset) < 56 )
          {
            LODWORD(v50) = workerOutput->m_writeOffset - workerOutput->m_readOffset;
            LODWORD(v49) = 56;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2076, ASSERT_TYPE_ASSERT, "( dataSize ) <= ( workerOutput.Size() )", "%s <= %s\n\t%i, %i", "dataSize", "workerOutput.Size()", v49, v50) )
              __debugbreak();
          }
          v10 = MpscStream<524288>::Read(workerOutput, &r_soundRequest, 56);
          if ( v10 != 56 )
          {
            LODWORD(v48) = 56;
            goto LABEL_16;
          }
          CG_EntityWorkers_ProcessWorkerSoundRequest((const LocalClientNum_t)v7, &r_soundRequest);
          break;
        case 6u:
          if ( (signed int)(workerOutput->m_writeOffset - workerOutput->m_readOffset) < 4 )
          {
            LODWORD(v50) = workerOutput->m_writeOffset - workerOutput->m_readOffset;
            LODWORD(v49) = 4;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2076, ASSERT_TYPE_ASSERT, "( dataSize ) <= ( workerOutput.Size() )", "%s <= %s\n\t%i, %i", "dataSize", "workerOutput.Size()", v49, v50) )
              __debugbreak();
          }
          v10 = MpscStream<524288>::Read(workerOutput, &entNum, 4);
          if ( v10 != 4 )
          {
            LODWORD(v48) = 4;
            goto LABEL_16;
          }
          CG_Turret_UpdateBarrelSpinSoundPlayback((LocalClientNum_t)v7, entNum);
          break;
        case 7u:
          if ( (signed int)(workerOutput->m_writeOffset - workerOutput->m_readOffset) < 8 )
          {
            LODWORD(v50) = workerOutput->m_writeOffset - workerOutput->m_readOffset;
            LODWORD(v49) = 8;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2076, ASSERT_TYPE_ASSERT, "( dataSize ) <= ( workerOutput.Size() )", "%s <= %s\n\t%i, %i", "dataSize", "workerOutput.Size()", v49, v50) )
              __debugbreak();
          }
          v10 = MpscStream<524288>::Read(workerOutput, &request, 8);
          if ( v10 != 8 )
            goto LABEL_22;
          CG_EntityWorkers_ProcessNoteTrackNotifyUpdate((const LocalClientNum_t)v7, &request);
          break;
        case 8u:
          if ( (signed int)(workerOutput->m_writeOffset - workerOutput->m_readOffset) < 32 )
          {
            LODWORD(v50) = workerOutput->m_writeOffset - workerOutput->m_readOffset;
            LODWORD(v49) = 32;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2076, ASSERT_TYPE_ASSERT, "( dataSize ) <= ( workerOutput.Size() )", "%s <= %s\n\t%i, %i", "dataSize", "workerOutput.Size()", v49, v50) )
              __debugbreak();
          }
          v10 = MpscStream<524288>::Read(workerOutput, &sunColorLinearSrgb, 32);
          if ( v10 != 32 )
          {
            LODWORD(v48) = 32;
            goto LABEL_16;
          }
          if ( v68 )
            R_SetSunColorOverride(&sunColorLinearSrgb);
          if ( v69 )
          {
            __asm { vmovss  xmm0, [rbp+0E0h+var_114]; sunIntensity }
            R_SetSunIntensityOverride(*(const float *)&_XMM0);
          }
          if ( v70 )
            R_SetSunDirectionOverride(&sunDir, 0);
          break;
        case 9u:
          if ( (signed int)(workerOutput->m_writeOffset - workerOutput->m_readOffset) < 24 )
          {
            LODWORD(v50) = workerOutput->m_writeOffset - workerOutput->m_readOffset;
            LODWORD(v49) = 24;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2076, ASSERT_TYPE_ASSERT, "( dataSize ) <= ( workerOutput.Size() )", "%s <= %s\n\t%i, %i", "dataSize", "workerOutput.Size()", v49, v50) )
              __debugbreak();
          }
          v10 = MpscStream<524288>::Read(workerOutput, &lightUpdate, 24);
          if ( v10 != 24 )
          {
            LODWORD(v48) = 24;
            goto LABEL_16;
          }
          CG_EntityWorkers_ProcessScriptableEventLightUpdate((const LocalClientNum_t)v7, &lightUpdate);
          break;
        case 0xAu:
          if ( (signed int)(workerOutput->m_writeOffset - workerOutput->m_readOffset) < 12 )
          {
            LODWORD(v50) = workerOutput->m_writeOffset - workerOutput->m_readOffset;
            LODWORD(v49) = 12;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2076, ASSERT_TYPE_ASSERT, "( dataSize ) <= ( workerOutput.Size() )", "%s <= %s\n\t%i, %i", "dataSize", "workerOutput.Size()", v49, v50) )
              __debugbreak();
          }
          v10 = MpscStream<524288>::Read(workerOutput, scriptableIndex, 12);
          if ( v10 != 12 )
          {
            LODWORD(v48) = 12;
            goto LABEL_16;
          }
          ScriptableCl_Spatial_UpdateMarkerPartition((const LocalClientNum_t)v7, scriptableIndex[0], scriptableIndex[1], scriptableIndex[2]);
          break;
        case 0xBu:
          if ( (signed int)(workerOutput->m_writeOffset - workerOutput->m_readOffset) < 8 )
          {
            LODWORD(v50) = workerOutput->m_writeOffset - workerOutput->m_readOffset;
            LODWORD(v49) = 8;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2076, ASSERT_TYPE_ASSERT, "( dataSize ) <= ( workerOutput.Size() )", "%s <= %s\n\t%i, %i", "dataSize", "workerOutput.Size()", v49, v50) )
              __debugbreak();
          }
          v10 = MpscStream<524288>::Read(workerOutput, localClientNuma, 8);
          if ( v10 != 8 )
          {
LABEL_22:
            LODWORD(v48) = 8;
LABEL_16:
            LODWORD(v47) = v10;
            v11 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2085, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Entity Workers Payload Read failed. Got %d, expected %d", v47, v48);
            goto LABEL_86;
          }
          FX_MarkEntDetachAll(localClientNuma[0], localClientNuma[1]);
          break;
        default:
          LODWORD(v47) = buffer;
          v11 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2158, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Unhandled Worker Output Type %d", v47);
LABEL_86:
          if ( v11 )
            __debugbreak();
          break;
      }
    }
    while ( (signed int)(workerOutput->m_writeOffset - workerOutput->m_readOffset) > 0 );
    Sys_ProfEndNamedEvent();
    v6 = v59;
    v9 = v52;
  }
  if ( v9 )
  {
    for ( i = 0; i < v6->workerMaxCount; CG_EntityWorkers_ProcessWorkerProfileData(v6, i++) )
      ;
    _RDI = &v6->profileFrame;
    workerCount = v6->profileFrame.workerCount;
    if ( workerCount )
    {
      v16 = workerCount;
      __asm
      {
        vxorps  xmm1, xmm1, xmm1
        vcvtsi2ss xmm1, xmm1, ecx
        vmovss  xmm0, cs:__real@3f800000
        vdivss  xmm5, xmm0, xmm1
        vmulss  xmm4, xmm5, dword ptr [rdi+440h]
        vmovss  dword ptr [rdi+4B8h], xmm4
      }
      v6->profileFrame.stdDeviation = 0.0;
      __asm { vxorps  xmm3, xmm3, xmm3 }
      _RAX = v6->profileFrame.workerTimes;
      do
      {
        __asm
        {
          vmovss  xmm0, dword ptr [rax]
          vsubss  xmm1, xmm0, xmm4
          vmulss  xmm2, xmm1, xmm1
          vaddss  xmm3, xmm2, xmm3
          vmovss  dword ptr [rdi+4C4h], xmm3
        }
        ++_RAX;
        --v16;
      }
      while ( v16 );
      __asm
      {
        vmulss  xmm0, xmm3, xmm5
        vsqrtss xmm1, xmm0, xmm0
        vmovss  dword ptr [rdi+4C4h], xmm1
      }
    }
    if ( (unsigned int)v7 >= 2 )
    {
      LODWORD(v48) = 2;
      LODWORD(v47) = v7;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2059, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( ( sizeof( *array_counter( s_entityWorkers_profileHistory ) ) + 0 ) )", "localClientNum doesn't index s_entityWorkers_profileHistory\n\t%i not in [0, %i)", v47, v48) )
        __debugbreak();
    }
    v30 = &s_entityWorkers_profileHistory[v7];
    if ( v30->frameIndex >= 0x258 )
    {
      LODWORD(v48) = 600;
      LODWORD(v47) = v30->frameIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2062, ASSERT_TYPE_ASSERT, "(unsigned)( history.frameIndex ) < (unsigned)( ( sizeof( *array_counter( history.frames ) ) + 0 ) )", "history.frameIndex doesn't index history.frames\n\t%i not in [0, %i)", v47, v48) )
        __debugbreak();
    }
    _RDX = &v30->frames[v30->frameIndex];
    v32 = 9i64;
    do
    {
      __asm
      {
        vmovups xmm0, xmmword ptr [rdi]
        vmovups xmmword ptr [rdx], xmm0
        vmovups xmm1, xmmword ptr [rdi+10h]
        vmovups xmmword ptr [rdx+10h], xmm1
        vmovups xmm0, xmmword ptr [rdi+20h]
        vmovups xmmword ptr [rdx+20h], xmm0
        vmovups xmm1, xmmword ptr [rdi+30h]
        vmovups xmmword ptr [rdx+30h], xmm1
        vmovups xmm0, xmmword ptr [rdi+40h]
        vmovups xmmword ptr [rdx+40h], xmm0
        vmovups xmm1, xmmword ptr [rdi+50h]
        vmovups xmmword ptr [rdx+50h], xmm1
        vmovups xmm0, xmmword ptr [rdi+60h]
        vmovups xmmword ptr [rdx+60h], xmm0
      }
      _RDX = (CgEntityWorkerFrameProfile *)((char *)_RDX + 128);
      __asm
      {
        vmovups xmm1, xmmword ptr [rdi+70h]
        vmovups xmmword ptr [rdx-10h], xmm1
      }
      _RDI = (CgEntityWorkerFrameProfile *)((char *)_RDI + 128);
      --v32;
    }
    while ( v32 );
    __asm
    {
      vmovups xmm0, xmmword ptr [rdi]
      vmovups xmmword ptr [rdx], xmm0
      vmovups xmm1, xmmword ptr [rdi+10h]
      vmovups xmmword ptr [rdx+10h], xmm1
      vmovups xmm0, xmmword ptr [rdi+20h]
      vmovups xmmword ptr [rdx+20h], xmm0
      vmovups xmm1, xmmword ptr [rdi+30h]
      vmovups xmmword ptr [rdx+30h], xmm1
    }
    *(_QWORD *)_RDX->workerTimes = *(_QWORD *)_RDI->workerTimes;
    v30->frameIndex = (v30->frameIndex + 1) % 0x258;
    v45 = v30->frameCount + 1;
    if ( v45 > 600 )
      v45 = 600;
    v30->frameCount = v45;
  }
  return v9;
}

/*
==============
CG_EntityWorkers_ProcessWorkerProfileData
==============
*/
void CG_EntityWorkers_ProcessWorkerProfileData(CgEntityWork *work, const unsigned int workerIndex)
{
  __int64 v2; 
  CgEntityWorkerOutProfile *v4; 
  unsigned __int16 v6; 
  float *p_workerTotalTime; 
  unsigned __int16 workerCount; 
  unsigned __int16 (*entityTypeCount)[1]; 
  __int64 v12; 
  __int64 v21; 
  __int64 v22; 

  v2 = workerIndex;
  if ( workerIndex >= 0x100 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2001, ASSERT_TYPE_ASSERT, "(unsigned)( workerIndex ) < (unsigned)( ( sizeof( *array_counter( work.profileWorkers ) ) + 0 ) )", "workerIndex doesn't index work.profileWorkers\n\t%i not in [0, %i)", workerIndex, 256) )
    __debugbreak();
  v4 = &work->profileWorkers[v2];
  if ( work->profileWorkers[v2].entityCount )
  {
    _RBX = &work->profileFrame;
    if ( (unsigned int)v2 >= 0x100 )
    {
      LODWORD(v22) = 256;
      LODWORD(v21) = v2;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2008, ASSERT_TYPE_ASSERT, "(unsigned)( workerIndex ) < (unsigned)( ( sizeof( *array_counter( work.workerSize ) ) + 0 ) )", "workerIndex doesn't index work.workerSize\n\t%i not in [0, %i)", v21, v22) )
        __debugbreak();
    }
    if ( !work->workerSize[v2] )
    {
      LODWORD(v21) = v2;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2009, ASSERT_TYPE_ASSERT, "( ( work.workerSize[workerIndex] > 0 ) )", "( workerIndex ) = %i", v21) )
        __debugbreak();
    }
    if ( (unsigned int)v2 >= 0x100 )
    {
      LODWORD(v22) = 256;
      LODWORD(v21) = v2;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2011, ASSERT_TYPE_ASSERT, "(unsigned)( workerIndex ) < (unsigned)( ( sizeof( *array_counter( work.workerSize ) ) + 0 ) )", "workerIndex doesn't index work.workerSize\n\t%i not in [0, %i)", v21, v22) )
        __debugbreak();
    }
    v6 = work->workerSize[v2];
    p_workerTotalTime = &work->profileWorkers[v2].workerTotalTime;
    work->profileFrame.entCount += v6;
    __asm { vmovss  xmm0, dword ptr [rbx+440h] }
    workerCount = _RBX->workerCount;
    __asm
    {
      vaddss  xmm1, xmm0, dword ptr [rsi]
      vmovss  dword ptr [rbx+440h], xmm1
    }
    if ( workerCount >= 0x100u )
    {
      LODWORD(v22) = 256;
      LODWORD(v21) = workerCount;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2016, ASSERT_TYPE_ASSERT, "(unsigned)( frameProfile.workerCount ) < (unsigned)( ( sizeof( *array_counter( frameProfile.workerTimes ) ) + 0 ) )", "frameProfile.workerCount doesn't index frameProfile.workerTimes\n\t%i not in [0, %i)", v21, v22) )
        __debugbreak();
    }
    entityTypeCount = work->profileFrame.entityTypeCount;
    v12 = 29i64;
    _RBX->workerTimes[_RBX->workerCount] = *p_workerTotalTime;
    _RCX = work->profileFrame.entityTypeTime;
    ++_RBX->workerCount;
    _RDI = (char *)v4 - (char *)_RBX;
    do
    {
      ++_RCX;
      **entityTypeCount += *(unsigned __int16 *)((char *)&(*entityTypeCount)[9] + _RDI);
      ++entityTypeCount;
      __asm
      {
        vmovss  xmm0, dword ptr [rdi+rcx-3F4h]
        vaddss  xmm1, xmm0, dword ptr [rcx-4]
        vmovss  dword ptr [rcx-4], xmm1
      }
      --v12;
    }
    while ( v12 );
    __asm
    {
      vmovss  xmm0, dword ptr [rbx+4BCh]
      vminss  xmm1, xmm0, dword ptr [rsi]
      vmovss  xmm0, dword ptr [rbx+4C0h]
      vmovss  dword ptr [rbx+4BCh], xmm1
      vmaxss  xmm1, xmm0, dword ptr [rsi]
      vmovss  dword ptr [rbx+4C0h], xmm1
    }
  }
  else
  {
    if ( (unsigned int)v2 >= 0x100 )
    {
      LODWORD(v22) = 256;
      LODWORD(v21) = v2;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2035, ASSERT_TYPE_ASSERT, "(unsigned)( workerIndex ) < (unsigned)( ( sizeof( *array_counter( work.workerSize ) ) + 0 ) )", "workerIndex doesn't index work.workerSize\n\t%i not in [0, %i)", v21, v22) )
        __debugbreak();
    }
    if ( work->workerSize[v2] )
    {
      LODWORD(v21) = v2;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2036, ASSERT_TYPE_ASSERT, "( ( work.workerSize[workerIndex] == 0 ) )", "( workerIndex ) = %i", v21) )
        __debugbreak();
    }
  }
}

/*
==============
CG_EntityWorkers_ProcessWorkerSoundRequest
==============
*/
void CG_EntityWorkers_ProcessWorkerSoundRequest(const LocalClientNum_t localClientNum, const CgEntitySoundRequest *r_soundRequest)
{
  __int64 v3; 
  CgSoundSystem *v4; 
  int fmt; 
  int fmta; 
  __int64 v21; 
  int v22; 
  int v23; 
  int v24; 
  int v25; 
  __int64 v26; 
  int v28; 
  int v29; 
  int v30; 
  int v31; 
  int v32; 
  int v33; 
  int v34; 
  int v35; 

  _RBX = r_soundRequest;
  v3 = localClientNum;
  if ( !(_BYTE)CgSoundSystem::ms_allocatedType && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_sound.h", 179, ASSERT_TYPE_ASSERT, "(ms_allocatedType != GameModeType::NONE)", "%s\n\tTrying to access the sound system for localClientNum %d but the sound system type is not known\n", "ms_allocatedType != GameModeType::NONE", localClientNum) )
    __debugbreak();
  if ( (unsigned int)v3 >= CgSoundSystem::ms_allocatedCount )
  {
    LODWORD(v26) = CgSoundSystem::ms_allocatedCount;
    LODWORD(v21) = v3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_sound.h", 180, ASSERT_TYPE_ASSERT, "(unsigned)( localClientNum ) < (unsigned)( ms_allocatedCount )", "localClientNum doesn't index ms_allocatedCount\n\t%i not in [0, %i)", v21, v26) )
      __debugbreak();
  }
  if ( !CgSoundSystem::ms_soundSystemArray[v3] )
  {
    LODWORD(v26) = v3;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_sound.h", 181, ASSERT_TYPE_ASSERT, "(ms_soundSystemArray[localClientNum])", "%s\n\tTrying to access unallocated sound system for localClientNum %d\n", "ms_soundSystemArray[localClientNum]", v26) )
      __debugbreak();
  }
  v4 = CgSoundSystem::ms_soundSystemArray[v3];
  switch ( _RBX->type )
  {
    case PlaySurface:
      __asm
      {
        vmovss  xmm0, dword ptr [rbx+28h]
        vmovss  xmm1, dword ptr [rbx+24h]
        vmovss  dword ptr [rsp+58h+var_28], xmm0
        vmovss  dword ptr [rsp+58h+var_30], xmm1
      }
      ((void (__fastcall *)(CgSoundSystem *, _QWORD, vec3_t *, const SndAliasList *, int, int, int, int))v4->PlaySurfaceSoundAsync)(CgSoundSystem::ms_soundSystemArray[v3], _RBX->u.playSurface.entityIndex, &_RBX->u.playExplosion.soundOrigin, _RBX->u.playSurface.soundAlias, _RBX->u.playSurface.surfaceType, v22, v28, _RBX->u.playSurface.fadeTime);
      break;
    case PlaySurfaceOnSndEnt:
      __asm
      {
        vmovss  xmm0, dword ptr [rbx+30h]
        vmovss  xmm1, dword ptr [rbx+2Ch]
        vmovss  [rsp+58h+var_20], xmm0
        vmovss  dword ptr [rsp+58h+var_28], xmm1
      }
      ((void (__fastcall *)(CgSoundSystem *, _QWORD, float *, unsigned __int64, const SndAliasList *, int, int, int, int))v4->PlaySurfaceSoundOnSndEntAsync)(CgSoundSystem::ms_soundSystemArray[v3], _RBX->u.playSurfaceOnSndEnt.entityIndex, &_RBX->u.vehicleUpdate.soundOrigin.z, _RBX->u.playSurfaceOnSndEnt.sndEntHandle, _RBX->u.playSurfaceOnSndEnt.soundAlias, _RBX->u.playSurfaceOnSndEnt.surfaceType, v29, v32, _RBX->u.playSurfaceOnSndEnt.fadeTime);
      break;
    case PlayExplosion:
      v4->PlayExplosionSoundAsync(CgSoundSystem::ms_soundSystemArray[v3], _RBX->u.playSurface.entityIndex, &_RBX->u.playSurface.soundOrigin, _RBX->u.playSurface.soundAlias, _RBX->u.playSurface.surfaceType, _RBX->u.playExplosion.reflectionClass);
      break;
    case PlayScaled:
      __asm
      {
        vmovss  xmm0, dword ptr [rbx+24h]
        vmovss  xmm1, dword ptr [rbx+20h]
        vmovss  dword ptr [rsp+58h+var_30], xmm0
        vmovss  dword ptr [rsp+58h+fmt], xmm1
      }
      ((void (__fastcall *)(CgSoundSystem *, _QWORD, vec3_t *, const SndAliasList *, int, int, int))v4->PlaySoundAliasScaledAsync)(CgSoundSystem::ms_soundSystemArray[v3], _RBX->u.playSurface.entityIndex, &_RBX->u.playExplosion.soundOrigin, _RBX->u.playSurface.soundAlias, fmt, v23, _RBX->u.playSurfaceOnSndEnt.surfaceType);
      break;
    case StopEntity:
      CgSoundSystem::StopSoundsOnEnt(CgSoundSystem::ms_soundSystemArray[v3], _RBX->u.playSurface.entityIndex);
      break;
    case StopEntityChannel:
      CgSoundSystem::StopSoundChannelOnEnt(CgSoundSystem::ms_soundSystemArray[v3], _RBX->u.playSurface.entityIndex, _RBX->u.stopOnEntityChannel.entSndChannel);
      break;
    case StopEntityAlias:
      CgSoundSystem::StopSoundAlias(CgSoundSystem::ms_soundSystemArray[v3], _RBX->u.playSurface.entityIndex, _RBX->u.stopAlias.sndAliasLookup);
      break;
    case PlayBlended:
      __asm
      {
        vmovss  xmm0, dword ptr [rbx+30h]; jumptable 0000000141CB963B case 7
        vmovss  xmm1, dword ptr [rbx+2Ch]
        vmovss  [rsp+58h+var_20], xmm0
        vmovss  xmm0, dword ptr [rbx+28h]
        vmovss  dword ptr [rsp+58h+var_28], xmm1
        vmovss  dword ptr [rsp+58h+var_30], xmm0
      }
      ((void (__fastcall *)(CgSoundSystem *, _QWORD, vec3_t *, const SndAliasList *, const SndAliasList *, int, int, int))v4->PlayBlendedSoundAliasAsync)(CgSoundSystem::ms_soundSystemArray[v3], _RBX->u.playSurface.entityIndex, &_RBX->u.playExplosion.soundOrigin, _RBX->u.playSurface.soundAlias, _RBX->u.playSurfaceOnSndEnt.soundAlias, v24, v30, v33);
      break;
    case VehicleUpdate:
      __asm
      {
        vmovss  xmm0, dword ptr [rbx+34h]; jumptable 0000000141CB963B case 8
        vmovss  xmm1, dword ptr [rbx+2Ch]
        vmovss  [rsp+58h+var_10], xmm0
        vmovss  xmm0, dword ptr [rbx+20h]
        vmovss  [rsp+58h+var_20], xmm0
        vmovss  xmm0, dword ptr [rbx+28h]
        vmovss  dword ptr [rsp+58h+var_28], xmm1
        vmovss  xmm1, dword ptr [rbx+24h]
        vmovss  dword ptr [rsp+58h+var_30], xmm0
        vmovss  dword ptr [rsp+58h+fmt], xmm1
      }
      ((void (__fastcall *)(CgSoundSystem *, _QWORD, vec3_t *, const SndAliasList *, int, int, int, int, int, int))v4->UpdateVehicleSound)(CgSoundSystem::ms_soundSystemArray[v3], _RBX->u.playSurface.entityIndex, &_RBX->u.playExplosion.soundOrigin, _RBX->u.playSurface.soundAlias, fmta, v25, v31, v34, _RBX->u.vehicleUpdate.gear, v35);
      break;
    default:
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1748, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "Unknown sound request type") )
        __debugbreak();
      break;
  }
}

/*
==============
CG_EntityWorkers_ProfileEntityBegin
==============
*/
void CG_EntityWorkers_ProfileEntityBegin(const LocalClientNum_t localClientNum, CgEntitySystem *entitySystem, const unsigned int entityIndex, CgEntityWorkerOutProfile *profileData)
{
  __int64 v4; 
  char *v7; 
  unsigned __int16 v8; 
  unsigned __int16 entityCurrentType; 
  unsigned __int64 v10; 
  __int64 v11; 
  __int64 v12; 

  v4 = (int)entityIndex;
  if ( !entitySystem && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1964, ASSERT_TYPE_ASSERT, "(entitySystem)", (const char *)&queryFormat, "entitySystem") )
    __debugbreak();
  if ( (unsigned int)v4 >= 0x800 )
  {
    LODWORD(v11) = v4;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 518, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( (( 2048 ) + 0) )", "entityIndex doesn't index MAX_LOCAL_CENTITIES\n\t%i not in [0, %i)", v11, 2048) )
      __debugbreak();
  }
  v7 = (char *)entitySystem + 760 * v4;
  if ( (v7[664] & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1967, ASSERT_TYPE_ASSERT, "(CENextValid( cent ))", (const char *)&queryFormat, "CENextValid( cent )") )
    __debugbreak();
  v8 = *((_WORD *)v7 + 212);
  profileData->entityCurrentType = v8;
  if ( v8 >= 0x1Du )
  {
    LODWORD(v12) = 29;
    LODWORD(v11) = v8;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1970, ASSERT_TYPE_ASSERT, "(unsigned)( profileData.entityCurrentType ) < (unsigned)( ET_EVENTS )", "profileData.entityCurrentType doesn't index ET_EVENTS\n\t%i not in [0, %i)", v11, v12) )
      __debugbreak();
  }
  if ( (v7[664] & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1940, ASSERT_TYPE_ASSERT, "(CENextValid( cent ))", (const char *)&queryFormat, "CENextValid( cent )") )
    __debugbreak();
  profileData->entityCurrentSubType = 0;
  entityCurrentType = profileData->entityCurrentType;
  if ( entityCurrentType >= 0x1Du )
  {
    LODWORD(v12) = 29;
    LODWORD(v11) = entityCurrentType;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1975, ASSERT_TYPE_ASSERT, "(unsigned)( profileData.entityCurrentType ) < (unsigned)( ( sizeof( *array_counter( profileData.entityTypeCount ) ) + 0 ) )", "profileData.entityCurrentType doesn't index profileData.entityTypeCount\n\t%i not in [0, %i)", v11, v12) )
      __debugbreak();
  }
  v10 = profileData->entityCurrentSubType + (unsigned __int64)profileData->entityCurrentType;
  ++profileData->entityTypeCount[v10][0];
  profileData->entityStartTimer = __rdtsc();
}

/*
==============
CG_EntityWorkers_RegisterDars
==============
*/
void CG_EntityWorkers_RegisterDars(void)
{
  DVARBOOL_cg_entityWorkers = Dvar_RegisterBool("MTLOPLPKKS", 1, 0, "Enabled distributed entity processing across worker commands");
  DCONST_DVARBOOL_cg_entityWorkersCritSecLegacyMode = Dvar_RegisterBool("cg_entityWorkersCritSecLegacyMode", 0, 0x40004u, "Disables the new entity worker critical sections and falls back to the old critical sections.");
  DCONST_DVARBOOL_cg_entityWorkersCostBalancing = Dvar_RegisterBool("cg_entityWorkersCostBalancing", 1, 0x40004u, "Set to enable entity workers cost-based load balancing. Enabled for multiplayer only (ENTITY_WORKER_LOAD_BALANCING)");
  DCONST_DVARBOOL_cg_entityWorkersPhysicsCheckLocks = Dvar_RegisterBool("cg_entityWorkersPhysicsCheckLocks", 1, 0x40004u, "Sets whether to use the physics Lock Check mode. Enables asserts.");
  DCONST_DVARBOOL_cg_entityWorkersBufferedOutput = Dvar_RegisterBool("cg_entityWorkersBufferedOutput", 1, 0x40004u, "Enable to turn on entity buffered worker requests");
}

/*
==============
CG_EntityWorkers_ReleaseReadLock_Physics
==============
*/
void CG_EntityWorkers_ReleaseReadLock_Physics(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  const dvar_t *v1; 
  __int64 v3; 

  v1 = DVARBOOL_cg_entityWorkers;
  if ( !DVARBOOL_cg_entityWorkers && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkers") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  if ( v1->current.enabled )
  {
    v3 = 8i64 * tls_index;
    if ( *(_BYTE *)(*(_QWORD *)((char *)NtCurrentTeb()->Reserved1[11] + v3) + 1664i64) )
    {
      if ( (unsigned __int8)CG_EntityWorkers_CritSecLegacyMode() )
      {
        if ( fallbackMode == BASE )
        {
          Sys_LeaveCriticalSection(CRITSECT_ENTITY_WORKER_LOCK);
        }
        else if ( *(_BYTE *)(*(_QWORD *)((char *)NtCurrentTeb()->Reserved1[11] + v3) + 1664i64) && !Sys_InCriticalSection(CRITSECT_ENTITY_WORKER_LOCK) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 445, ASSERT_TYPE_ASSERT, "(!CG_EntityWorkers_IsProcessingEntityWorker() || Sys_InCriticalSection( CRITSECT_ENTITY_WORKER_LOCK ))", (const char *)&queryFormat, "!CG_EntityWorkers_IsProcessingEntityWorker() || Sys_InCriticalSection( CRITSECT_ENTITY_WORKER_LOCK )") )
        {
          __debugbreak();
        }
      }
      else
      {
        ReleaseSRWLockShared((PSRWLOCK)&ms_entityWorkRWLockPhysics);
        Sys_CheckReleaseLock(&ms_entityWorkRWLockPhysics);
      }
    }
  }
}

/*
==============
CG_EntityWorkers_ReleaseWriteLock_Physics
==============
*/
void CG_EntityWorkers_ReleaseWriteLock_Physics(const CGEntityWorkersLegacyFallbackMode fallbackMode)
{
  const dvar_t *v1; 
  __int64 v3; 

  v1 = DVARBOOL_cg_entityWorkers;
  if ( !DVARBOOL_cg_entityWorkers && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkers") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v1);
  if ( v1->current.enabled )
  {
    v3 = 8i64 * tls_index;
    if ( *(_BYTE *)(*(_QWORD *)((char *)NtCurrentTeb()->Reserved1[11] + v3) + 1664i64) )
    {
      if ( (unsigned __int8)CG_EntityWorkers_CritSecLegacyMode() )
      {
        if ( fallbackMode == BASE )
        {
          Sys_LeaveCriticalSection(CRITSECT_ENTITY_WORKER_LOCK);
        }
        else if ( *(_BYTE *)(*(_QWORD *)((char *)NtCurrentTeb()->Reserved1[11] + v3) + 1664i64) && !Sys_InCriticalSection(CRITSECT_ENTITY_WORKER_LOCK) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 445, ASSERT_TYPE_ASSERT, "(!CG_EntityWorkers_IsProcessingEntityWorker() || Sys_InCriticalSection( CRITSECT_ENTITY_WORKER_LOCK ))", (const char *)&queryFormat, "!CG_EntityWorkers_IsProcessingEntityWorker() || Sys_InCriticalSection( CRITSECT_ENTITY_WORKER_LOCK )") )
        {
          __debugbreak();
        }
      }
      else
      {
        ms_entityWorkRWLockPhysics.writeThreadId = 0;
        ReleaseSRWLockExclusive((PSRWLOCK)&ms_entityWorkRWLockPhysics);
        Sys_CheckReleaseLock(&ms_entityWorkRWLockPhysics);
      }
    }
  }
}

/*
==============
CG_EntityWorkers_SetAgentWorkersEnabled
==============
*/
void CG_EntityWorkers_SetAgentWorkersEnabled(const LocalClientNum_t localClientNum, const bool isEnabled)
{
  s_entityWorkers_agentsEnabled = isEnabled;
}

/*
==============
CG_EntityWorkers_SetEntityWorkChain_r
==============
*/
__int64 CG_EntityWorkers_SetEntityWorkChain_r(const CgEntityWorkBuilderCmd *workerCmd, const centity_t *cent, const CgEntityWorkData *workData)
{
  CgEntityWorkBuilder *workBuilder; 
  unsigned __int16 v7; 
  unsigned __int16 v8; 
  unsigned __int16 EntityWorkParents; 
  unsigned __int16 v10; 
  CgEntityWorkData *p_workDataa; 
  unsigned __int16 *p_outParents; 
  __int64 v13; 
  CgEntitySystem *EntitySystem; 
  __int64 v15; 
  unsigned __int16 v16; 
  unsigned __int16 v17; 
  const unsigned __int16 *v18; 
  __int64 v19; 
  unsigned __int16 v20; 
  unsigned __int16 v21; 
  __int64 maxOutParents; 
  __int64 v24; 
  const unsigned __int16 *v25; 
  CgEntityWorkData workDataa; 
  unsigned __int16 v27; 
  _BYTE v28[6]; 
  unsigned __int16 outParents; 

  if ( !workerCmd && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1130, ASSERT_TYPE_ASSERT, "(workerCmd)", (const char *)&queryFormat, "workerCmd") )
    __debugbreak();
  if ( !cent && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1131, ASSERT_TYPE_ASSERT, "(cent)", (const char *)&queryFormat, "cent") )
    __debugbreak();
  if ( (cent->flags & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1132, ASSERT_TYPE_ASSERT, "(CENextValid( cent ))", (const char *)&queryFormat, "CENextValid( cent )") )
    __debugbreak();
  workBuilder = workerCmd->workBuilder;
  if ( !workBuilder && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1135, ASSERT_TYPE_ASSERT, "(buildWorkers)", (const char *)&queryFormat, "buildWorkers") )
    __debugbreak();
  v7 = truncate_cast<unsigned short,short>(cent->nextState.number);
  if ( v7 >= 0x7FEu )
  {
    LODWORD(maxOutParents) = v7;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1138, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ENTITYNUM_ORDINARY_END )", "entityIndex doesn't index ENTITYNUM_ORDINARY_END\n\t%i not in [0, %i)", maxOutParents, 2046) )
      __debugbreak();
  }
  v8 = workBuilder->chainIndex[v7];
  v25 = &workBuilder->chainIndex[v7];
  if ( v8 == 0xFFFF )
  {
    v8 = CG_EntityWorkers_AddToWorkChain(v7, workData, workerCmd);
    if ( v8 >= 0x800u )
    {
      LODWORD(v24) = 2048;
      LODWORD(maxOutParents) = v8;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1146, ASSERT_TYPE_ASSERT, "(unsigned)( chainIndex ) < (unsigned)( ( sizeof( *array_counter( buildWorkers->chainEntityHead ) ) + 0 ) )", "chainIndex doesn't index ARRAY_COUNT( buildWorkers->chainEntityHead )\n\t%i not in [0, %i)", maxOutParents, v24) )
        __debugbreak();
    }
    LOWORD(maxOutParents) = 4;
    EntityWorkParents = CG_EntityWorkers_GetEntityWorkParents((const LocalClientNum_t)workerCmd->localClientNum, cent, workData, &outParents, &workDataa, maxOutParents);
    if ( EntityWorkParents )
    {
      v10 = 0;
      p_workDataa = &workDataa;
      p_outParents = &outParents;
      do
      {
        v13 = *p_outParents;
        EntitySystem = CgEntitySystem::GetEntitySystem((const LocalClientNum_t)workerCmd->localClientNum);
        if ( (unsigned int)v13 >= 0x800 )
        {
          LODWORD(v24) = 2048;
          LODWORD(maxOutParents) = v13;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity.h", 518, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( (( 2048 ) + 0) )", "entityIndex doesn't index MAX_LOCAL_CENTITIES\n\t%i not in [0, %i)", maxOutParents, v24) )
            __debugbreak();
        }
        v15 = (__int64)&EntitySystem->m_entities[v13];
        if ( (*(_BYTE *)(v15 + 648) & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1111, ASSERT_TYPE_ASSERT, "(CENextValid( parentEnt ))", (const char *)&queryFormat, "CENextValid( parentEnt )") )
          __debugbreak();
        v16 = CG_EntityWorkers_SetEntityWorkChain_r(workerCmd, (const centity_t *)v15, p_workDataa);
        *(_WORD *)&v28[2 * v10 - 2] = v16;
        if ( v16 == 0xFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1114, ASSERT_TYPE_ASSERT, "(outParentChains[parentChainCount] != INVALID_WORK_CHAIN)", (const char *)&queryFormat, "outParentChains[parentChainCount] != INVALID_WORK_CHAIN") )
          __debugbreak();
        ++v10;
        ++p_outParents;
        ++p_workDataa;
      }
      while ( v10 < EntityWorkParents );
      if ( v10 >= 4u )
      {
        LODWORD(v24) = 4;
        LODWORD(maxOutParents) = v10;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1154, ASSERT_TYPE_ASSERT, "(unsigned)( workChainCount ) < (unsigned)( ( sizeof( *array_counter( workChains ) ) + 0 ) )", "workChainCount doesn't index ARRAY_COUNT( workChains )\n\t%i not in [0, %i)", maxOutParents, v24) )
          __debugbreak();
      }
      v8 = -1;
      if ( v10 )
      {
        v17 = v27;
        v8 = v27;
        if ( v10 > 1u )
        {
          v18 = (const unsigned __int16 *)v28;
          v19 = (unsigned __int16)(v10 - 1);
          do
          {
            CG_EntityWorkers_AppendWorkChain(v17, *v18++, workerCmd);
            --v19;
          }
          while ( v19 );
        }
      }
      if ( v8 >= 0x800u )
      {
        LODWORD(v24) = 2048;
        LODWORD(maxOutParents) = v8;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1158, ASSERT_TYPE_ASSERT, "(unsigned)( chainIndex ) < (unsigned)( ( sizeof( *array_counter( buildWorkers->chainEntityHead ) ) + 0 ) )", "chainIndex doesn't index ARRAY_COUNT( buildWorkers->chainEntityHead )\n\t%i not in [0, %i)", maxOutParents, v24) )
          __debugbreak();
      }
      if ( *v25 != v8 )
      {
        CG_EntityWorkers_AppendWorkChain(v8, *v25, workerCmd);
        if ( v8 != *v25 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1165, ASSERT_TYPE_ASSERT, "( chainIndex ) == ( buildWorkers->chainIndex[entityIndex] )", "%s == %s\n\t%i, %i", "chainIndex", "buildWorkers->chainIndex[entityIndex]", v8, *v25) )
          __debugbreak();
      }
    }
  }
  if ( v8 >= 0x800u )
  {
    LODWORD(v24) = 2048;
    LODWORD(maxOutParents) = v8;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1170, ASSERT_TYPE_ASSERT, "(unsigned)( chainIndex ) < (unsigned)( ( sizeof( *array_counter( buildWorkers->chainEntityHead ) ) + 0 ) )", "chainIndex doesn't index buildWorkers->chainEntityHead\n\t%i not in [0, %i)", maxOutParents, v24) )
      __debugbreak();
  }
  if ( !workBuilder->chainEntityCount[v8] )
  {
    LODWORD(maxOutParents) = v8;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1171, ASSERT_TYPE_ASSERT, "( ( buildWorkers->chainEntityCount[chainIndex] != 0 ) )", "( chainIndex ) = %i", maxOutParents) )
      __debugbreak();
  }
  if ( !workBuilder->chainEntityCost[v8] )
  {
    LODWORD(maxOutParents) = v8;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1172, ASSERT_TYPE_ASSERT, "( ( buildWorkers->chainEntityCost[chainIndex] != 0 ) )", "( chainIndex ) = %i", maxOutParents) )
      __debugbreak();
  }
  v20 = workBuilder->chainEntityHead[v8];
  if ( v20 >= 0x7FEu )
  {
    LODWORD(v24) = 2046;
    LODWORD(maxOutParents) = v20;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1173, ASSERT_TYPE_ASSERT, "(unsigned)( buildWorkers->chainEntityHead[chainIndex] ) < (unsigned)( ENTITYNUM_ORDINARY_END )", "buildWorkers->chainEntityHead[chainIndex] doesn't index ENTITYNUM_ORDINARY_END\n\t%i not in [0, %i)", maxOutParents, v24) )
      __debugbreak();
  }
  v21 = workBuilder->chainEntityTail[v8];
  if ( v21 >= 0x7FEu )
  {
    LODWORD(v24) = 2046;
    LODWORD(maxOutParents) = v21;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1174, ASSERT_TYPE_ASSERT, "(unsigned)( buildWorkers->chainEntityTail[chainIndex] ) < (unsigned)( ENTITYNUM_ORDINARY_END )", "buildWorkers->chainEntityTail[chainIndex] doesn't index ENTITYNUM_ORDINARY_END\n\t%i not in [0, %i)", maxOutParents, v24) )
      __debugbreak();
  }
  return v8;
}

/*
==============
CG_EntityWorkers_SetMissileWorkersEnabled
==============
*/
void CG_EntityWorkers_SetMissileWorkersEnabled(const LocalClientNum_t localClientNum, const bool isEnabled)
{
  s_entityWorkers_missilesEnabled = isEnabled;
}

/*
==============
CG_EntityWorkers_SetPlayerWorkersEnabled
==============
*/
void CG_EntityWorkers_SetPlayerWorkersEnabled(const LocalClientNum_t localClientNum, const bool isEnabled)
{
  s_entityWorkers_playersEnabled = isEnabled;
}

/*
==============
CG_EntityWorkers_ShutdownWorkerOutput
==============
*/
void CG_EntityWorkers_ShutdownWorkerOutput(void)
{
  unsigned int v0; 

  if ( !s_entityWorkers_outputStream && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1619, ASSERT_TYPE_ASSERT, "(s_entityWorkers_outputStream != nullptr)", (const char *)&queryFormat, "s_entityWorkers_outputStream != nullptr") )
    __debugbreak();
  if ( s_entityWorkers_outputStream->m_writeOffset != s_entityWorkers_outputStream->m_readOffset )
  {
    v0 = s_entityWorkers_outputStream->m_writeOffset - s_entityWorkers_outputStream->m_readOffset;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1620, ASSERT_TYPE_ASSERT, "( s_entityWorkers_outputStream->Size() ) == ( 0 )", "%s == %s\n\t%i, %i", "s_entityWorkers_outputStream->Size()", "0", v0, 0i64) )
      __debugbreak();
  }
  s_entityWorkers_outputStream = NULL;
}

/*
==============
CG_EntityWorkers_SortWorkerPriorityQueue
==============
*/
void CG_EntityWorkers_SortWorkerPriorityQueue(const unsigned __int16 *workSortValues, const unsigned __int16 priorityQueueIndex, const unsigned __int16 workerMaxCount, unsigned __int16 *workerPriorityQueue)
{
  __int64 v8; 
  unsigned __int16 v9; 
  __int64 v10; 
  unsigned __int16 v11; 
  __int64 v12; 
  __int64 v13; 
  __int64 v14; 
  __int64 v15; 

  if ( !workSortValues && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1228, ASSERT_TYPE_ASSERT, "(workSortValues)", (const char *)&queryFormat, "workSortValues") )
    __debugbreak();
  if ( !workerPriorityQueue && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1229, ASSERT_TYPE_ASSERT, "(workerPriorityQueue)", (const char *)&queryFormat, "workerPriorityQueue") )
    __debugbreak();
  if ( workerMaxCount > 0x100u && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1230, ASSERT_TYPE_ASSERT, "( workerMaxCount ) <= ( (256) )", "%s <= %s\n\t%i, %i", "workerMaxCount", "MAX_ENTITY_WORKERS", workerMaxCount, 256) )
    __debugbreak();
  if ( priorityQueueIndex >= workerMaxCount )
  {
    LODWORD(v15) = workerMaxCount;
    LODWORD(v14) = priorityQueueIndex;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1231, ASSERT_TYPE_ASSERT, "(unsigned)( priorityQueueIndex ) < (unsigned)( workerMaxCount )", "priorityQueueIndex doesn't index workerMaxCount\n\t%i not in [0, %i)", v14, v15) )
      __debugbreak();
  }
  v8 = priorityQueueIndex;
  v9 = priorityQueueIndex + 1;
  v10 = workerPriorityQueue[v8];
  v11 = workSortValues[v10];
  if ( v9 >= workerMaxCount )
  {
LABEL_16:
    v12 = workerMaxCount;
  }
  else
  {
    while ( 1 )
    {
      v12 = v9;
      v13 = workerPriorityQueue[v9];
      if ( workSortValues[v13] > v11 )
        break;
      ++v9;
      workerPriorityQueue[v12 - 1] = v13;
      if ( v9 >= workerMaxCount )
        goto LABEL_16;
    }
  }
  workerPriorityQueue[v12 - 1] = v10;
}

/*
==============
CG_EntityWorkers_TryAddBModelBoundsUpdate
==============
*/
char CG_EntityWorkers_TryAddBModelBoundsUpdate(const int entityIndex)
{
  const dvar_t *VarByName; 
  CgEntityWorkersOutputBuilder<CgEntityBModelUpdateBoundsRequest> mem; 

  if ( (unsigned int)entityIndex >= 0x7FE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2491, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ENTITYNUM_ORDINARY_END )", "entityIndex doesn't index ENTITYNUM_ORDINARY_END\n\t%i not in [0, %i)", entityIndex, 2046) )
    __debugbreak();
  VarByName = Dvar_FindVarByName("NSRTNRNQKR");
  if ( VarByName && VarByName->current.enabled || !Sys_IsMainThreadEntityWorker() )
    return 0;
  *(_WORD *)&mem.m_beginCalled = 0;
  if ( !Sys_IsMainThreadEntityWorker() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2390, ASSERT_TYPE_ASSERT, "(CG_EntityWorkers_WorkersCurrentlyActive())", (const char *)&queryFormat, "CG_EntityWorkers_WorkersCurrentlyActive()") )
    __debugbreak();
  if ( mem.m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2392, ASSERT_TYPE_ASSERT, "( !m_beginCalled )", "Entity Worker Output Builder called Begin() more than once") )
    __debugbreak();
  if ( mem.m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2393, ASSERT_TYPE_ASSERT, "( !m_submitCalled )", "Entity Worker Output Builder must call Begin() before Submit") )
    __debugbreak();
  *(_WORD *)mem.m_requestType = 259;
  DebugWipe(&mem, 2ui64);
  mem.m_requestPayload.entityIndex = truncate_cast<unsigned short,int>(entityIndex);
  CgEntityWorkersOutputBuilder<CgEntityBModelUpdateBoundsRequest>::Submit(&mem);
  if ( !mem.m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2383, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder was created but is missing its Begin() call") )
    __debugbreak();
  if ( !mem.m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2384, ASSERT_TYPE_ASSERT, "( m_submitCalled )", "Entity Worker Output Builder was created but is missing its Submit() call") )
    __debugbreak();
  return 1;
}

/*
==============
CG_EntityWorkers_TryAddBModelDrawRequest
==============
*/
char CG_EntityWorkers_TryAddBModelDrawRequest(const int entityIndex, unsigned int renderFlags)
{
  const dvar_t *VarByName; 
  CgEntityWorkersOutputBuilder<CgEntityBModelDrawRequest> mem[2]; 

  if ( (unsigned int)entityIndex >= 0x7FE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2550, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ENTITYNUM_ORDINARY_END )", "entityIndex doesn't index ENTITYNUM_ORDINARY_END\n\t%i not in [0, %i)", entityIndex, 2046) )
    __debugbreak();
  VarByName = Dvar_FindVarByName("NSRTNRNQKR");
  if ( VarByName && VarByName->current.enabled || !Sys_IsMainThreadEntityWorker() )
    return 0;
  *(_WORD *)&mem[0].m_beginCalled = 0;
  if ( !Sys_IsMainThreadEntityWorker() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2390, ASSERT_TYPE_ASSERT, "(CG_EntityWorkers_WorkersCurrentlyActive())", (const char *)&queryFormat, "CG_EntityWorkers_WorkersCurrentlyActive()") )
    __debugbreak();
  *(_WORD *)mem[0].m_requestType = 257;
  DebugWipe(mem, 8ui64);
  mem[0].m_requestPayload.entityIndex = entityIndex;
  mem[0].m_requestPayload.renderFlags = renderFlags;
  CgEntityWorkersOutputBuilder<CgEntityBModelDrawRequest>::Submit(mem);
  if ( !mem[0].m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2383, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder was created but is missing its Begin() call") )
    __debugbreak();
  if ( !mem[0].m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2384, ASSERT_TYPE_ASSERT, "( m_submitCalled )", "Entity Worker Output Builder was created but is missing its Submit() call") )
    __debugbreak();
  return 1;
}

/*
==============
CG_EntityWorkers_TryAddDObjBoundsUpdate
==============
*/
char CG_EntityWorkers_TryAddDObjBoundsUpdate(const int entityIndex)
{
  CgEntityWorkersOutputBuilder<CgEntityDObjUpdateBoundsRequest> mem; 

  if ( (unsigned int)entityIndex >= 0x800 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2469, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( (( 2048 ) + 0) )", "entityIndex doesn't index MAX_LOCAL_CENTITIES\n\t%i not in [0, %i)", entityIndex, 2048) )
    __debugbreak();
  if ( !Sys_IsMainThreadEntityWorker() )
    return 0;
  *(_WORD *)&mem.m_beginCalled = 0;
  if ( !Sys_IsMainThreadEntityWorker() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2390, ASSERT_TYPE_ASSERT, "(CG_EntityWorkers_WorkersCurrentlyActive())", (const char *)&queryFormat, "CG_EntityWorkers_WorkersCurrentlyActive()") )
    __debugbreak();
  if ( mem.m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2392, ASSERT_TYPE_ASSERT, "( !m_beginCalled )", "Entity Worker Output Builder called Begin() more than once") )
    __debugbreak();
  if ( mem.m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2393, ASSERT_TYPE_ASSERT, "( !m_submitCalled )", "Entity Worker Output Builder must call Begin() before Submit") )
    __debugbreak();
  *(_WORD *)mem.m_requestType = 258;
  DebugWipe(&mem, 2ui64);
  mem.m_requestPayload.entityIndex = truncate_cast<unsigned short,int>(entityIndex);
  CgEntityWorkersOutputBuilder<CgEntityDObjUpdateBoundsRequest>::Submit(&mem);
  if ( !mem.m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2383, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder was created but is missing its Begin() call") )
    __debugbreak();
  if ( !mem.m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2384, ASSERT_TYPE_ASSERT, "( m_submitCalled )", "Entity Worker Output Builder was created but is missing its Submit() call") )
    __debugbreak();
  return 1;
}

/*
==============
CG_EntityWorkers_TryAddDObjDrawRequest
==============
*/

bool __fastcall CG_EntityWorkers_TryAddDObjDrawRequest(const int entityIndex, unsigned int renderFlags, unsigned int materialData, double materialTime, const vec3_t *lightingOrigin, const GfxSceneHudOutlineInfo *hudOutlineInfo, const shaderOverride_t *shaderOverride)
{
  bool result; 
  __int64 v20; 
  CgEntityWorkersOutputBuilder<CgEntityDObjDrawRequest> mem; 
  char v22; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-28h], xmm6
    vmovaps xmm6, xmm3
  }
  _RSI = hudOutlineInfo;
  _RDI = shaderOverride;
  if ( !hudOutlineInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2519, ASSERT_TYPE_ASSERT, "(hudOutlineInfo)", (const char *)&queryFormat, "hudOutlineInfo") )
    __debugbreak();
  if ( !shaderOverride && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2520, ASSERT_TYPE_ASSERT, "(shaderOverride)", (const char *)&queryFormat, "shaderOverride") )
    __debugbreak();
  if ( Sys_IsMainThreadEntityWorker() )
  {
    if ( (unsigned int)entityIndex >= 0x7FE )
    {
      LODWORD(v20) = entityIndex;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2524, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ENTITYNUM_ORDINARY_END )", "entityIndex doesn't index ENTITYNUM_ORDINARY_END\n\t%i not in [0, %i)", v20, 2046) )
        __debugbreak();
    }
    *(_WORD *)&mem.m_beginCalled = 0;
    if ( !Sys_IsMainThreadEntityWorker() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2390, ASSERT_TYPE_ASSERT, "(CG_EntityWorkers_WorkersCurrentlyActive())", (const char *)&queryFormat, "CG_EntityWorkers_WorkersCurrentlyActive()") )
      __debugbreak();
    *(_WORD *)mem.m_requestType = 256;
    DebugWipe(&mem, 0x64ui64);
    mem.m_requestPayload.entityIndex = entityIndex;
    mem.m_requestPayload.renderFlags = renderFlags;
    mem.m_requestPayload.materialData = materialData;
    __asm { vmovss  [rsp+0F8h+var_9C], xmm6 }
    SetSecureWorkerOrigin(lightingOrigin, &mem.m_requestPayload.lightingOrigin.origin, ~entityIndex);
    __asm
    {
      vmovups ymm0, ymmword ptr [rsi]
      vmovups [rsp+0F8h+var_8C], ymm0
    }
    mem.m_requestPayload.hudOutlineInfo.characterEVOffset = hudOutlineInfo->characterEVOffset;
    __asm
    {
      vmovups ymm0, ymmword ptr [rdi]
      vmovups [rsp+0F8h+var_68], ymm0
    }
    mem.m_requestPayload.shaderOverride.atlasTime = shaderOverride->atlasTime;
    CgEntityWorkersOutputBuilder<CgEntityDObjDrawRequest>::Submit(&mem);
    if ( !mem.m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2383, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder was created but is missing its Begin() call") )
      __debugbreak();
    if ( !mem.m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2384, ASSERT_TYPE_ASSERT, "( m_submitCalled )", "Entity Worker Output Builder was created but is missing its Submit() call") )
      __debugbreak();
    result = 1;
  }
  else
  {
    result = 0;
  }
  _R11 = &v22;
  __asm { vmovaps xmm6, xmmword ptr [r11-10h] }
  return result;
}

/*
==============
CG_EntityWorkers_TryAddFxMarksDetachAllRequest
==============
*/
char CG_EntityWorkers_TryAddFxMarksDetachAllRequest(const LocalClientNum_t localClientNum, const int entIndex)
{
  CgEntityWorkersOutputBuilder<CgEntityFxMarkDetachAllRequest> mem[2]; 

  if ( !Sys_IsMainThreadEntityWorker() )
    return 0;
  *(_WORD *)&mem[0].m_beginCalled = 0;
  if ( !Sys_IsMainThreadEntityWorker() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2390, ASSERT_TYPE_ASSERT, "(CG_EntityWorkers_WorkersCurrentlyActive())", (const char *)&queryFormat, "CG_EntityWorkers_WorkersCurrentlyActive()", -2i64) )
    __debugbreak();
  *(_WORD *)mem[0].m_requestType = 267;
  DebugWipe(mem, 8ui64);
  mem[0].m_requestPayload.localClientNum = localClientNum;
  mem[0].m_requestPayload.entIndex = entIndex;
  CgEntityWorkersOutputBuilder<CgEntityFxMarkDetachAllRequest>::Submit(mem);
  if ( !mem[0].m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2383, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder was created but is missing its Begin() call") )
    __debugbreak();
  if ( !mem[0].m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2384, ASSERT_TYPE_ASSERT, "( m_submitCalled )", "Entity Worker Output Builder was created but is missing its Submit() call") )
    __debugbreak();
  return 1;
}

/*
==============
CG_EntityWorkers_TryAddNoteTrackNotification
==============
*/
char CG_EntityWorkers_TryAddNoteTrackNotification(const unsigned int entityIndex, const XAnimNotifyHandle notifyHandle)
{
  CgEntityWorkersOutputBuilder<CgEntityNotetrackRequest> mem[2]; 

  if ( entityIndex >= 0x7FE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2851, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ENTITYNUM_ORDINARY_END )", "entityIndex doesn't index ENTITYNUM_ORDINARY_END\n\t%i not in [0, %i)", entityIndex, 2046) )
    __debugbreak();
  if ( notifyHandle.m_notifyIndex == 0xFFFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2852, ASSERT_TYPE_ASSERT, "(notifyHandle.IsValid())", (const char *)&queryFormat, "notifyHandle.IsValid()") )
    __debugbreak();
  if ( !Sys_IsMainThreadEntityWorker() )
    return 0;
  *(_WORD *)&mem[0].m_beginCalled = 0;
  if ( !Sys_IsMainThreadEntityWorker() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2390, ASSERT_TYPE_ASSERT, "(CG_EntityWorkers_WorkersCurrentlyActive())", (const char *)&queryFormat, "CG_EntityWorkers_WorkersCurrentlyActive()") )
    __debugbreak();
  *(_WORD *)mem[0].m_requestType = 263;
  DebugWipe(mem, 8ui64);
  mem[0].m_requestPayload.entityIndex = entityIndex;
  mem[0].m_requestPayload.notifyHandle = notifyHandle;
  CgEntityWorkersOutputBuilder<CgEntityNotetrackRequest>::Submit(mem);
  if ( !mem[0].m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2383, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder was created but is missing its Begin() call") )
    __debugbreak();
  if ( !mem[0].m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2384, ASSERT_TYPE_ASSERT, "( m_submitCalled )", "Entity Worker Output Builder was created but is missing its Submit() call") )
    __debugbreak();
  return 1;
}

/*
==============
CG_EntityWorkers_TryAddPlayBlendedSoundAliasRequest
==============
*/
char CG_EntityWorkers_TryAddPlayBlendedSoundAliasRequest(const int entityIndex, const vec3_t *soundOrigin, const SndAliasList *aliasList0, const SndAliasList *aliasList1, float lerp, float volumeScale, float pitch)
{
  CgEntityWorkerOutputType v11; 
  CgEntityWorkersOutputBuilder<CgEntitySoundRequest> v19; 

  _RBX = soundOrigin;
  if ( !Sys_IsMainThreadEntityWorker() )
    return 0;
  *(_WORD *)&v19.m_beginCalled = 0;
  LOBYTE(v11) = 5;
  _RAX = CgEntityWorkersOutputBuilder<CgEntitySoundRequest>::Begin(&v19, v11);
  _RAX->type = PlayBlended;
  _RAX->u.playSurface.entityIndex = entityIndex;
  _RAX->u.playSurface.soundAlias = aliasList0;
  _RAX->u.playSurfaceOnSndEnt.soundAlias = aliasList1;
  __asm
  {
    vmovss  xmm0, [rsp+98h+lerp]
    vmovss  dword ptr [rax+28h], xmm0
    vmovss  xmm1, [rsp+98h+volumeScale]
    vmovss  dword ptr [rax+2Ch], xmm1
    vmovss  xmm0, [rsp+98h+pitch]
    vmovss  dword ptr [rax+30h], xmm0
  }
  _RAX->u.stopOnEntityChannel.entSndChannel = LODWORD(_RBX->v[0]);
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vmovss  dword ptr [rax+10h], xmm0
    vmovss  xmm1, dword ptr [rbx+8]
    vmovss  dword ptr [rax+14h], xmm1
  }
  CgEntityWorkersOutputBuilder<CgEntitySoundRequest>::Submit(&v19);
  if ( !v19.m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2383, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder was created but is missing its Begin() call") )
    __debugbreak();
  if ( !v19.m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2384, ASSERT_TYPE_ASSERT, "( m_submitCalled )", "Entity Worker Output Builder was created but is missing its Submit() call") )
    __debugbreak();
  return 1;
}

/*
==============
CG_EntityWorkers_TryAddPlayExplosionSoundRequest
==============
*/
char CG_EntityWorkers_TryAddPlayExplosionSoundRequest(const int entityIndex, const vec3_t *soundOrigin, const SndAliasList *aliasList, int surfaceType, unsigned int reflectionClass)
{
  CgEntityWorkerOutputType v9; 
  CgEntityWorkersOutputBuilder<CgEntitySoundRequest> v14; 

  _RBX = soundOrigin;
  if ( !Sys_IsMainThreadEntityWorker() )
    return 0;
  *(_WORD *)&v14.m_beginCalled = 0;
  LOBYTE(v9) = 5;
  _RAX = CgEntityWorkersOutputBuilder<CgEntitySoundRequest>::Begin(&v14, v9);
  _RAX->type = PlayExplosion;
  _RAX->u.playSurface.entityIndex = entityIndex;
  _RAX->u.playSurface.soundAlias = aliasList;
  _RAX->u.playSurface.surfaceType = surfaceType;
  _RAX->u.playExplosion.reflectionClass = reflectionClass;
  _RAX->u.stopOnEntityChannel.entSndChannel = LODWORD(_RBX->v[0]);
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vmovss  dword ptr [rax+10h], xmm0
    vmovss  xmm1, dword ptr [rbx+8]
    vmovss  dword ptr [rax+14h], xmm1
  }
  CgEntityWorkersOutputBuilder<CgEntitySoundRequest>::Submit(&v14);
  if ( !v14.m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2383, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder was created but is missing its Begin() call") )
    __debugbreak();
  if ( !v14.m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2384, ASSERT_TYPE_ASSERT, "( m_submitCalled )", "Entity Worker Output Builder was created but is missing its Submit() call") )
    __debugbreak();
  return 1;
}

/*
==============
CG_EntityWorkers_TryAddPlaySoundAliasScaledRequest
==============
*/

bool __fastcall CG_EntityWorkers_TryAddPlaySoundAliasScaledRequest(const int entityIndex, const vec3_t *soundOrigin, const SndAliasList *aliasList, double volumeScale, float pitch, int timeshift)
{
  CgEntityWorkerOutputType v12; 
  bool result; 
  CgEntityWorkersOutputBuilder<CgEntitySoundRequest> v20; 
  char v21; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-18h], xmm6
    vmovaps xmm6, xmm3
  }
  _RBX = soundOrigin;
  if ( Sys_IsMainThreadEntityWorker() )
  {
    *(_WORD *)&v20.m_beginCalled = 0;
    LOBYTE(v12) = 5;
    _RAX = CgEntityWorkersOutputBuilder<CgEntitySoundRequest>::Begin(&v20, v12);
    _RAX->type = PlayScaled;
    _RAX->u.playSurface.entityIndex = entityIndex;
    _RAX->u.playSurface.soundAlias = aliasList;
    __asm
    {
      vmovss  dword ptr [rax+20h], xmm6
      vmovss  xmm0, [rsp+0A8h+pitch]
      vmovss  dword ptr [rax+24h], xmm0
    }
    _RAX->u.playSurfaceOnSndEnt.surfaceType = timeshift;
    _RAX->u.stopOnEntityChannel.entSndChannel = LODWORD(_RBX->v[0]);
    __asm
    {
      vmovss  xmm0, dword ptr [rbx+4]
      vmovss  dword ptr [rax+10h], xmm0
      vmovss  xmm1, dword ptr [rbx+8]
      vmovss  dword ptr [rax+14h], xmm1
    }
    CgEntityWorkersOutputBuilder<CgEntitySoundRequest>::Submit(&v20);
    if ( !v20.m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2383, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder was created but is missing its Begin() call") )
      __debugbreak();
    if ( !v20.m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2384, ASSERT_TYPE_ASSERT, "( m_submitCalled )", "Entity Worker Output Builder was created but is missing its Submit() call") )
      __debugbreak();
    result = 1;
  }
  else
  {
    result = 0;
  }
  _R11 = &v21;
  __asm { vmovaps xmm6, xmmword ptr [r11-10h] }
  return result;
}

/*
==============
CG_EntityWorkers_TryAddPostPlayerUpdate
==============
*/
char CG_EntityWorkers_TryAddPostPlayerUpdate(const unsigned int entityIndex, const unsigned int clientIndex, const vec3_t *poseOrg)
{
  CgEntityWorkersOutputBuilder<CgEntityPlayerPostUpdate> mem; 

  if ( !Sys_IsMainThreadEntityWorker() )
    return 0;
  if ( !s_entityWorkers_playersEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2829, ASSERT_TYPE_ASSERT, "(s_entityWorkers_playersEnabled)", (const char *)&queryFormat, "s_entityWorkers_playersEnabled", -2i64) )
    __debugbreak();
  *(_WORD *)&mem.m_beginCalled = 0;
  if ( !Sys_IsMainThreadEntityWorker() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2390, ASSERT_TYPE_ASSERT, "(CG_EntityWorkers_WorkersCurrentlyActive())", (const char *)&queryFormat, "CG_EntityWorkers_WorkersCurrentlyActive()") )
    __debugbreak();
  *(_WORD *)mem.m_requestType = 260;
  DebugWipe(&mem, 0x14ui64);
  mem.m_requestPayload.entityIndex = entityIndex;
  mem.m_requestPayload.clientIndex = clientIndex;
  SetSecureWorkerOrigin(poseOrg, &mem.m_requestPayload.poseOrigin.origin, ~entityIndex);
  CgEntityWorkersOutputBuilder<CgEntityPlayerPostUpdate>::Submit(&mem);
  if ( !mem.m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2383, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder was created but is missing its Begin() call") )
    __debugbreak();
  if ( !mem.m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2384, ASSERT_TYPE_ASSERT, "( m_submitCalled )", "Entity Worker Output Builder was created but is missing its Submit() call") )
    __debugbreak();
  return 1;
}

/*
==============
CG_EntityWorkers_TryAddScriptableEventLightUpdate
==============
*/

bool __fastcall CG_EntityWorkers_TryAddScriptableEventLightUpdate(double interpolation, const unsigned int lightIndex, const Scriptable_EventLight_Data *const data, const ScriptableEventDef *const event)
{
  __int64 v7; 
  CgEntityWorkerOutputType v9; 
  const dvar_t *v12; 
  bool result; 
  __int64 v41; 
  CgEntityWorkersOutputBuilder<CgEntityScriptableEventLightUpdate> v42; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm { vmovaps xmmword ptr [rax-28h], xmm6 }
  _R14 = event;
  v7 = lightIndex;
  __asm { vmovaps xmm6, xmm0 }
  if ( (unsigned __int8)CG_EntityWorkers_CritSecLegacyMode() || !Sys_IsMainThreadEntityWorker() )
  {
    result = 0;
  }
  else
  {
    *(_WORD *)&v42.m_beginCalled = 0;
    LOBYTE(v9) = 9;
    _RDI = CgEntityWorkersOutputBuilder<CgEntityScriptableEventLightUpdate>::Begin(&v42, v9);
    _RDI->lightIndex = v7;
    if ( !comWorld.isInUse && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_bsp_api.h", 49, ASSERT_TYPE_ASSERT, "(comWorld.isInUse)", (const char *)&queryFormat, "comWorld.isInUse") )
      __debugbreak();
    if ( (unsigned int)v7 >= comWorld.primaryLightCount )
    {
      LODWORD(v41) = v7;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\com_bsp_api.h", 50, ASSERT_TYPE_ASSERT, "(unsigned)( primaryLightIndex ) < (unsigned)( comWorld.primaryLightCount )", "primaryLightIndex doesn't index comWorld.primaryLightCount\n\t%i not in [0, %i)", v41, comWorld.primaryLightCount) )
        __debugbreak();
    }
    _RBX = &comWorld.primaryLights[v7];
    v12 = DVARBOOL_scriptable_light_radiusscale;
    if ( !DVARBOOL_scriptable_light_radiusscale && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "scriptable_light_radiusscale") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v12);
    if ( v12->current.enabled )
    {
      __asm
      {
        vmovss  xmm0, cs:__real@3f800000
        vsubss  xmm3, xmm0, xmm6
        vmulss  xmm1, xmm3, dword ptr [rsi+1Ch]
        vmulss  xmm0, xmm6, dword ptr [rsi+20h]
        vaddss  xmm1, xmm1, xmm0
        vmaxss  xmm2, xmm1, cs:__real@3f8147ae
        vmovss  dword ptr [rdi+4], xmm2
      }
    }
    else
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rbx+50h]
        vmaxss  xmm1, xmm0, cs:__real@3f8147ae
        vmovss  dword ptr [rdi+4], xmm1
        vmovss  xmm2, cs:__real@3f800000
        vsubss  xmm3, xmm2, xmm6
      }
    }
    __asm
    {
      vmulss  xmm1, xmm3, dword ptr [rsi+14h]
      vmulss  xmm0, xmm6, dword ptr [rsi+18h]
      vaddss  xmm1, xmm1, xmm0
      vmovss  dword ptr [rdi+8], xmm1
    }
    if ( _R14->data.anonymous.buffer[16] )
    {
      __asm
      {
        vmovss  xmm0, dword ptr [r14+34h]
        vsubss  xmm1, xmm0, dword ptr [rsi+8]
        vmulss  xmm2, xmm1, xmm6
        vaddss  xmm3, xmm2, dword ptr [rsi+8]
        vmovss  dword ptr [rdi+0Ch], xmm3
        vmovss  xmm0, dword ptr [r14+38h]
        vsubss  xmm1, xmm0, dword ptr [rsi+0Ch]
        vmulss  xmm2, xmm1, xmm6
        vaddss  xmm3, xmm2, dword ptr [rsi+0Ch]
        vmovss  dword ptr [rdi+10h], xmm3
        vmovss  xmm0, dword ptr [r14+3Ch]
        vsubss  xmm1, xmm0, dword ptr [rsi+10h]
        vmulss  xmm2, xmm1, xmm6
        vaddss  xmm3, xmm2, dword ptr [rsi+10h]
        vmovss  dword ptr [rdi+14h], xmm3
      }
    }
    else
    {
      _RDI->colorLinearSrgb.v[0] = _RBX->colorLinearSrgb.v[0];
      __asm
      {
        vmovss  xmm0, dword ptr [rbx+24h]
        vmovss  dword ptr [rdi+10h], xmm0
        vmovss  xmm1, dword ptr [rbx+28h]
        vmovss  dword ptr [rdi+14h], xmm1
      }
    }
    CgEntityWorkersOutputBuilder<CgEntityScriptableEventLightUpdate>::Submit(&v42);
    if ( !v42.m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2383, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder was created but is missing its Begin() call") )
      __debugbreak();
    if ( !v42.m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2384, ASSERT_TYPE_ASSERT, "( m_submitCalled )", "Entity Worker Output Builder was created but is missing its Submit() call") )
      __debugbreak();
    result = 1;
  }
  __asm { vmovaps xmm6, [rsp+98h+var_28] }
  return result;
}

/*
==============
CG_EntityWorkers_TryAddScriptableEventSunUpdate
==============
*/

bool __fastcall CG_EntityWorkers_TryAddScriptableEventSunUpdate(double interpolation, const ScriptableEventDef *const event, const Scriptable_EventSun_Data *const data)
{
  CgEntityWorkerOutputType v9; 
  bool result; 
  vec3_t angles; 
  CgEntityWorkersOutputBuilder<CgEntityScriptableEventSunUpdate> v62; 
  char v63; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-28h], xmm7
    vmovaps xmmword ptr [rax-38h], xmm10
  }
  _RDI = data;
  _RBX = event;
  __asm { vmovaps xmm10, xmm0 }
  if ( !event && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2875, ASSERT_TYPE_ASSERT, "( event ) != ( nullptr )", "%s != %s\n\t%p, %p", "event", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2876, ASSERT_TYPE_ASSERT, "( data ) != ( nullptr )", "%s != %s\n\t%p, %p", "data", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( (unsigned __int8)CG_EntityWorkers_CritSecLegacyMode() || !Sys_IsMainThreadEntityWorker() )
  {
    result = 0;
  }
  else
  {
    *(_WORD *)&v62.m_beginCalled = 0;
    LOBYTE(v9) = 8;
    _RAX = CgEntityWorkersOutputBuilder<CgEntityScriptableEventSunUpdate>::Begin(&v62, v9);
    _RDX = _RAX;
    _RAX->useColor = _RBX->data.hideShowBone.hide;
    if ( _RBX->data.anonymous.buffer[12] )
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rbx+30h]
        vsubss  xmm1, xmm0, dword ptr [rdi+8]
        vmulss  xmm2, xmm1, xmm10
        vaddss  xmm3, xmm2, dword ptr [rdi+8]
        vmovss  dword ptr [rax], xmm3
        vmovss  xmm0, dword ptr [rbx+34h]
        vsubss  xmm1, xmm0, dword ptr [rdi+0Ch]
        vmulss  xmm2, xmm1, xmm10
        vaddss  xmm3, xmm2, dword ptr [rdi+0Ch]
        vmovss  dword ptr [rax+4], xmm3
        vmovss  xmm0, dword ptr [rbx+38h]
        vsubss  xmm1, xmm0, dword ptr [rdi+10h]
        vmulss  xmm2, xmm1, xmm10
        vaddss  xmm3, xmm2, dword ptr [rdi+10h]
        vmovss  dword ptr [rax+8], xmm3
      }
    }
    _RAX->useIntensity = _RBX->data.spawnDynent.stateful;
    if ( _RBX->data.anonymous.buffer[0] )
    {
      __asm
      {
        vmovss  xmm0, cs:__real@3f800000
        vsubss  xmm1, xmm0, xmm10
        vmulss  xmm2, xmm1, dword ptr [rdi+14h]
        vmulss  xmm0, xmm10, dword ptr [rdi+18h]
        vaddss  xmm1, xmm2, xmm0
        vmovss  dword ptr [rdx+0Ch], xmm1
      }
    }
    _RAX->useDirection = _RBX->data.particleFX.oneshotLooping;
    if ( _RBX->data.anonymous.buffer[60] )
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rdi+28h]
        vsubss  xmm1, xmm0, dword ptr [rdi+1Ch]
        vmulss  xmm3, xmm1, cs:__real@3b360b61
        vaddss  xmm2, xmm3, cs:__real@3f000000
        vxorps  xmm7, xmm7, xmm7
        vroundss xmm0, xmm7, xmm2, 1
        vsubss  xmm0, xmm3, xmm0
        vmulss  xmm0, xmm0, cs:__real@43b40000
        vmulss  xmm1, xmm0, xmm10
        vaddss  xmm2, xmm1, dword ptr [rdi+1Ch]
        vmovss  dword ptr [rsp+0D8h+angles], xmm2
        vmovss  xmm0, dword ptr [rdi+2Ch]
        vsubss  xmm0, xmm0, dword ptr [rdi+20h]
        vmulss  xmm4, xmm0, cs:__real@3b360b61
        vaddss  xmm2, xmm4, cs:__real@3f000000
        vroundss xmm3, xmm7, xmm2, 1
        vsubss  xmm0, xmm4, xmm3
        vmulss  xmm1, xmm0, cs:__real@43b40000
        vmulss  xmm2, xmm1, xmm10
        vaddss  xmm3, xmm2, dword ptr [rdi+20h]
        vmovss  dword ptr [rsp+0D8h+angles+4], xmm3
        vmovss  xmm0, dword ptr [rdi+30h]
        vsubss  xmm0, xmm0, dword ptr [rdi+24h]
        vmulss  xmm4, xmm0, cs:__real@3b360b61
        vaddss  xmm2, xmm4, cs:__real@3f000000
        vroundss xmm3, xmm7, xmm2, 1
        vsubss  xmm0, xmm4, xmm3
        vmulss  xmm1, xmm0, cs:__real@43b40000
        vmulss  xmm2, xmm1, xmm10
        vaddss  xmm3, xmm2, dword ptr [rdi+24h]
        vmovss  dword ptr [rsp+0D8h+angles+8], xmm3
      }
      AngleVectors(&angles, &_RAX->direction, NULL, NULL);
    }
    CgEntityWorkersOutputBuilder<CgEntityScriptableEventSunUpdate>::Submit(&v62);
    if ( !v62.m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2383, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder was created but is missing its Begin() call") )
      __debugbreak();
    if ( !v62.m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2384, ASSERT_TYPE_ASSERT, "( m_submitCalled )", "Entity Worker Output Builder was created but is missing its Submit() call") )
      __debugbreak();
    result = 1;
  }
  _R11 = &v63;
  __asm
  {
    vmovaps xmm7, xmmword ptr [r11-10h]
    vmovaps xmm10, xmmword ptr [r11-20h]
  }
  return result;
}

/*
==============
CG_EntityWorkers_TryAddScriptableSpatialUpdate
==============
*/
char CG_EntityWorkers_TryAddScriptableSpatialUpdate(const LocalClientNum_t localClientNum, const unsigned int scriptableIndex, const unsigned int markerIndex, const unsigned int partitionIndex)
{
  CgEntityWorkersOutputBuilder<CgEntityScriptableSpatialUpdate> mem; 

  if ( !Sys_IsMainThreadEntityWorker() )
    return 0;
  *(_WORD *)&mem.m_beginCalled = 0;
  if ( !Sys_IsMainThreadEntityWorker() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2390, ASSERT_TYPE_ASSERT, "(CG_EntityWorkers_WorkersCurrentlyActive())", (const char *)&queryFormat, "CG_EntityWorkers_WorkersCurrentlyActive()", -2i64) )
    __debugbreak();
  *(_WORD *)mem.m_requestType = 266;
  DebugWipe(&mem, 0xCui64);
  mem.m_requestPayload.scriptableIndex = scriptableIndex;
  mem.m_requestPayload.markerIndex = markerIndex;
  mem.m_requestPayload.partitionIndex = partitionIndex;
  CgEntityWorkersOutputBuilder<CgEntityScriptableSpatialUpdate>::Submit(&mem);
  if ( !mem.m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2383, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder was created but is missing its Begin() call") )
    __debugbreak();
  if ( !mem.m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2384, ASSERT_TYPE_ASSERT, "( m_submitCalled )", "Entity Worker Output Builder was created but is missing its Submit() call") )
    __debugbreak();
  return 1;
}

/*
==============
CG_EntityWorkers_TryAddScriptableStateEventLightUpdate
==============
*/
char CG_EntityWorkers_TryAddScriptableStateEventLightUpdate(const unsigned int lightIndex, const Scriptable_EventLight_Data *const data, const ScriptableEventLightDef *const light, const ComPrimaryLight *const rawLight)
{
  CgEntityWorkerOutputType v8; 
  CgEntityWorkersOutputBuilder<CgEntityScriptableEventLightUpdate> v16; 

  _RDI = rawLight;
  _RBX = light;
  if ( !data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2985, ASSERT_TYPE_ASSERT, "( data ) != ( nullptr )", "%s != %s\n\t%p, %p", "data", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2986, ASSERT_TYPE_ASSERT, "( light ) != ( nullptr )", "%s != %s\n\t%p, %p", "light", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( !_RDI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2987, ASSERT_TYPE_ASSERT, "( rawLight ) != ( nullptr )", "%s != %s\n\t%p, %p", "rawLight", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( (unsigned __int8)CG_EntityWorkers_CritSecLegacyMode() || !Sys_IsMainThreadEntityWorker() )
    return 0;
  *(_WORD *)&v16.m_beginCalled = 0;
  LOBYTE(v8) = 9;
  _RAX = CgEntityWorkersOutputBuilder<CgEntityScriptableEventLightUpdate>::Begin(&v16, v8);
  _RDX = _RAX;
  _RAX->lightIndex = lightIndex;
  _RAX->radius = data->targetRadius;
  _RAX->intensity = data->targetIntensity;
  if ( _RBX->useColor )
  {
    _RAX->colorLinearSrgb.v[0] = _RBX->colorLinearSrgb.v[0];
    __asm
    {
      vmovss  xmm0, dword ptr [rbx+20h]
      vmovss  dword ptr [rax+10h], xmm0
      vmovss  xmm1, dword ptr [rbx+24h]
      vmovss  dword ptr [rax+14h], xmm1
    }
  }
  else
  {
    _RAX->colorLinearSrgb.v[0] = _RDI->colorLinearSrgb.v[0];
    __asm
    {
      vmovss  xmm0, dword ptr [rdi+24h]
      vmovss  dword ptr [rdx+10h], xmm0
      vmovss  xmm1, dword ptr [rdi+28h]
      vmovss  dword ptr [rdx+14h], xmm1
    }
  }
  CgEntityWorkersOutputBuilder<CgEntityScriptableEventLightUpdate>::Submit(&v16);
  if ( !v16.m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2383, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder was created but is missing its Begin() call") )
    __debugbreak();
  if ( !v16.m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2384, ASSERT_TYPE_ASSERT, "( m_submitCalled )", "Entity Worker Output Builder was created but is missing its Submit() call") )
    __debugbreak();
  return 1;
}

/*
==============
CG_EntityWorkers_TryAddScriptableStateEventSunUpdate
==============
*/

bool __fastcall CG_EntityWorkers_TryAddScriptableStateEventSunUpdate(const ScriptableEventSunDef *const sun, double intensity, const vec3_t *const direction)
{
  CgEntityWorkerOutputType v7; 
  bool result; 
  CgEntityWorkersOutputBuilder<CgEntityScriptableEventSunUpdate> v15; 

  __asm { vmovaps [rsp+88h+var_18], xmm6 }
  _RDI = direction;
  __asm { vmovaps xmm6, xmm1 }
  _RBX = sun;
  if ( (unsigned __int8)CG_EntityWorkers_CritSecLegacyMode() || !Sys_IsMainThreadEntityWorker() )
  {
    result = 0;
  }
  else
  {
    *(_WORD *)&v15.m_beginCalled = 0;
    LOBYTE(v7) = 8;
    _RAX = CgEntityWorkersOutputBuilder<CgEntityScriptableEventSunUpdate>::Begin(&v15, v7);
    _RAX->colorLinearSrgb.v[0] = _RBX->colorLinearSrgb.v[0];
    __asm
    {
      vmovss  xmm0, dword ptr [rbx+1Ch]
      vmovss  dword ptr [rax+4], xmm0
      vmovss  xmm1, dword ptr [rbx+20h]
      vmovss  dword ptr [rax+8], xmm1
      vmovss  dword ptr [rax+0Ch], xmm6
    }
    _RAX->direction.v[0] = _RDI->v[0];
    __asm
    {
      vmovss  xmm0, dword ptr [rdi+4]
      vmovss  dword ptr [rax+14h], xmm0
      vmovss  xmm1, dword ptr [rdi+8]
      vmovss  dword ptr [rax+18h], xmm1
    }
    _RAX->useColor = _RBX->useColor;
    _RAX->useIntensity = _RBX->useIntensity;
    _RAX->useDirection = _RBX->useDirection;
    CgEntityWorkersOutputBuilder<CgEntityScriptableEventSunUpdate>::Submit(&v15);
    if ( !v15.m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2383, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder was created but is missing its Begin() call") )
      __debugbreak();
    if ( !v15.m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2384, ASSERT_TYPE_ASSERT, "( m_submitCalled )", "Entity Worker Output Builder was created but is missing its Submit() call") )
      __debugbreak();
    result = 1;
  }
  __asm { vmovaps xmm6, [rsp+88h+var_18] }
  return result;
}

/*
==============
CG_EntityWorkers_TryAddStopSoundAliasRequest
==============
*/
char CG_EntityWorkers_TryAddStopSoundAliasRequest(const int entityIndex, SndAliasLookup *sndAliasLookup)
{
  CgEntityWorkerOutputType v4; 
  CgEntitySoundRequest *v5; 
  CgEntityWorkersOutputBuilder<CgEntitySoundRequest> v7; 

  if ( !Sys_IsMainThreadEntityWorker() )
    return 0;
  *(_WORD *)&v7.m_beginCalled = 0;
  LOBYTE(v4) = 5;
  v5 = CgEntityWorkersOutputBuilder<CgEntitySoundRequest>::Begin(&v7, v4);
  v5->type = StopEntityAlias;
  v5->u.playSurface.entityIndex = entityIndex;
  v5->u.stopAlias.sndAliasLookup = (SndAliasLookup)sndAliasLookup->name;
  CgEntityWorkersOutputBuilder<CgEntitySoundRequest>::Submit(&v7);
  if ( !v7.m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2383, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder was created but is missing its Begin() call") )
    __debugbreak();
  if ( !v7.m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2384, ASSERT_TYPE_ASSERT, "( m_submitCalled )", "Entity Worker Output Builder was created but is missing its Submit() call") )
    __debugbreak();
  return 1;
}

/*
==============
CG_EntityWorkers_TryAddStopSoundOnEntChannelRequest
==============
*/
char CG_EntityWorkers_TryAddStopSoundOnEntChannelRequest(const int entityIndex, const int entChannelIndex)
{
  CgEntityWorkerOutputType v4; 
  CgEntitySoundRequest *v5; 
  CgEntityWorkersOutputBuilder<CgEntitySoundRequest> v7; 

  if ( !Sys_IsMainThreadEntityWorker() )
    return 0;
  *(_WORD *)&v7.m_beginCalled = 0;
  LOBYTE(v4) = 5;
  v5 = CgEntityWorkersOutputBuilder<CgEntitySoundRequest>::Begin(&v7, v4);
  v5->type = StopEntityChannel;
  v5->u.playSurface.entityIndex = entityIndex;
  v5->u.stopOnEntityChannel.entSndChannel = entChannelIndex;
  CgEntityWorkersOutputBuilder<CgEntitySoundRequest>::Submit(&v7);
  if ( !v7.m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2383, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder was created but is missing its Begin() call") )
    __debugbreak();
  if ( !v7.m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2384, ASSERT_TYPE_ASSERT, "( m_submitCalled )", "Entity Worker Output Builder was created but is missing its Submit() call") )
    __debugbreak();
  return 1;
}

/*
==============
CG_EntityWorkers_TryAddStopSoundOnEntRequest
==============
*/
char CG_EntityWorkers_TryAddStopSoundOnEntRequest(const int entityIndex)
{
  CgEntityWorkerOutputType v2; 
  CgEntitySoundRequest *v3; 
  CgEntityWorkersOutputBuilder<CgEntitySoundRequest> v5; 

  if ( !Sys_IsMainThreadEntityWorker() )
    return 0;
  *(_WORD *)&v5.m_beginCalled = 0;
  LOBYTE(v2) = 5;
  v3 = CgEntityWorkersOutputBuilder<CgEntitySoundRequest>::Begin(&v5, v2);
  v3->type = StopEntity;
  v3->u.playSurface.entityIndex = entityIndex;
  CgEntityWorkersOutputBuilder<CgEntitySoundRequest>::Submit(&v5);
  if ( !v5.m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2383, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder was created but is missing its Begin() call") )
    __debugbreak();
  if ( !v5.m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2384, ASSERT_TYPE_ASSERT, "( m_submitCalled )", "Entity Worker Output Builder was created but is missing its Submit() call") )
    __debugbreak();
  return 1;
}

/*
==============
CG_EntityWorkers_TryAddSurfaceSoundOnSndEntRequest
==============
*/
char CG_EntityWorkers_TryAddSurfaceSoundOnSndEntRequest(const int entityIndex, const vec3_t *soundOrigin, const unsigned __int64 sndEntHandle, const SndAliasList *aliasList, int surfaceType, float volumeScale, float pitch, int fadeTime)
{
  CgEntityWorkerOutputType v12; 
  CgEntityWorkersOutputBuilder<CgEntitySoundRequest> v19; 

  _RBX = soundOrigin;
  if ( !Sys_IsMainThreadEntityWorker() )
    return 0;
  *(_WORD *)&v19.m_beginCalled = 0;
  LOBYTE(v12) = 5;
  _RAX = CgEntityWorkersOutputBuilder<CgEntitySoundRequest>::Begin(&v19, v12);
  _RAX->type = PlaySurfaceOnSndEnt;
  _RAX->u.playSurfaceOnSndEnt.sndEntHandle = sndEntHandle;
  _RAX->u.playSurfaceOnSndEnt.entityIndex = entityIndex;
  _RAX->u.playSurfaceOnSndEnt.soundAlias = aliasList;
  _RAX->u.playSurfaceOnSndEnt.surfaceType = surfaceType;
  __asm
  {
    vmovss  xmm0, [rsp+98h+volumeScale]
    vmovss  dword ptr [rax+2Ch], xmm0
    vmovss  xmm1, [rsp+98h+pitch]
    vmovss  dword ptr [rax+30h], xmm1
  }
  _RAX->u.playSurfaceOnSndEnt.fadeTime = fadeTime;
  _RAX->u.playSurface.soundOrigin.v[2] = _RBX->v[0];
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vmovss  dword ptr [rax+18h], xmm0
    vmovss  xmm1, dword ptr [rbx+8]
    vmovss  dword ptr [rax+1Ch], xmm1
  }
  CgEntityWorkersOutputBuilder<CgEntitySoundRequest>::Submit(&v19);
  if ( !v19.m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2383, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder was created but is missing its Begin() call") )
    __debugbreak();
  if ( !v19.m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2384, ASSERT_TYPE_ASSERT, "( m_submitCalled )", "Entity Worker Output Builder was created but is missing its Submit() call") )
    __debugbreak();
  return 1;
}

/*
==============
CG_EntityWorkers_TryAddSurfaceSoundRequest
==============
*/
char CG_EntityWorkers_TryAddSurfaceSoundRequest(const int entityIndex, const vec3_t *soundOrigin, const SndAliasList *aliasList, int surfaceType, float volumeScale, float pitch, int fadeTime)
{
  CgEntityWorkerOutputType v11; 
  CgEntityWorkersOutputBuilder<CgEntitySoundRequest> v18; 

  _RBX = soundOrigin;
  if ( !Sys_IsMainThreadEntityWorker() )
    return 0;
  *(_WORD *)&v18.m_beginCalled = 0;
  LOBYTE(v11) = 5;
  _RAX = CgEntityWorkersOutputBuilder<CgEntitySoundRequest>::Begin(&v18, v11);
  _RAX->type = PlaySurface;
  _RAX->u.playSurface.entityIndex = entityIndex;
  _RAX->u.playSurface.soundAlias = aliasList;
  _RAX->u.playSurface.surfaceType = surfaceType;
  __asm
  {
    vmovss  xmm0, [rsp+98h+volumeScale]
    vmovss  dword ptr [rax+24h], xmm0
    vmovss  xmm1, [rsp+98h+pitch]
    vmovss  dword ptr [rax+28h], xmm1
  }
  _RAX->u.playSurface.fadeTime = fadeTime;
  _RAX->u.stopOnEntityChannel.entSndChannel = LODWORD(_RBX->v[0]);
  __asm
  {
    vmovss  xmm0, dword ptr [rbx+4]
    vmovss  dword ptr [rax+10h], xmm0
    vmovss  xmm1, dword ptr [rbx+8]
    vmovss  dword ptr [rax+14h], xmm1
  }
  CgEntityWorkersOutputBuilder<CgEntitySoundRequest>::Submit(&v18);
  if ( !v18.m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2383, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder was created but is missing its Begin() call") )
    __debugbreak();
  if ( !v18.m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2384, ASSERT_TYPE_ASSERT, "( m_submitCalled )", "Entity Worker Output Builder was created but is missing its Submit() call") )
    __debugbreak();
  return 1;
}

/*
==============
CG_EntityWorkers_TryAddTurretBarrelSpinSoundRequest
==============
*/
char CG_EntityWorkers_TryAddTurretBarrelSpinSoundRequest(const LocalClientNum_t localClientNum, const unsigned int entIndex)
{
  CgEntityWorkersOutputBuilder<CgEntityTurretBarrelSpinSoundRequest> mem; 

  if ( entIndex >= 0x7FE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 3067, ASSERT_TYPE_ASSERT, "(unsigned)( entIndex ) < (unsigned)( ENTITYNUM_ORDINARY_END )", "entIndex doesn't index ENTITYNUM_ORDINARY_END\n\t%i not in [0, %i)", entIndex, 2046) )
    __debugbreak();
  if ( !Sys_IsMainThreadEntityWorker() )
    return 0;
  *(_WORD *)&mem.m_beginCalled = 0;
  if ( !Sys_IsMainThreadEntityWorker() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2390, ASSERT_TYPE_ASSERT, "(CG_EntityWorkers_WorkersCurrentlyActive())", (const char *)&queryFormat, "CG_EntityWorkers_WorkersCurrentlyActive()") )
    __debugbreak();
  if ( mem.m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2392, ASSERT_TYPE_ASSERT, "( !m_beginCalled )", "Entity Worker Output Builder called Begin() more than once") )
    __debugbreak();
  if ( mem.m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2393, ASSERT_TYPE_ASSERT, "( !m_submitCalled )", "Entity Worker Output Builder must call Begin() before Submit") )
    __debugbreak();
  *(_WORD *)mem.m_requestType = 262;
  DebugWipe(&mem, 4ui64);
  mem.m_requestPayload.entIndex = entIndex;
  CgEntityWorkersOutputBuilder<CgEntityTurretBarrelSpinSoundRequest>::Submit(&mem);
  if ( !mem.m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2383, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder was created but is missing its Begin() call") )
    __debugbreak();
  if ( !mem.m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2384, ASSERT_TYPE_ASSERT, "( m_submitCalled )", "Entity Worker Output Builder was created but is missing its Submit() call") )
    __debugbreak();
  return 1;
}

/*
==============
CG_EntityWorkers_TryAddUpdateVehicleSound
==============
*/

bool __fastcall CG_EntityWorkers_TryAddUpdateVehicleSound(const int entityIndex, const vec3_t *soundOrigin, const SndAliasList *aliasList, double throttle, const float brake, const float rpm, const float speed, const int gear, const float distanceScale)
{
  CgEntityWorkerOutputType v15; 
  bool result; 
  CgEntityWorkersOutputBuilder<CgEntitySoundRequest> v26; 
  char v27; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-18h], xmm6
    vmovaps xmm6, xmm3
  }
  _RBX = soundOrigin;
  if ( Sys_IsMainThreadEntityWorker() )
  {
    *(_WORD *)&v26.m_beginCalled = 0;
    LOBYTE(v15) = 5;
    _RDX = CgEntityWorkersOutputBuilder<CgEntitySoundRequest>::Begin(&v26, v15);
    _RDX->type = VehicleUpdate;
    _RDX->u.playSurface.entityIndex = entityIndex;
    _RDX->u.playSurface.soundAlias = aliasList;
    __asm
    {
      vmovss  xmm0, [rsp+0A8h+speed]
      vmovss  dword ptr [rax+20h], xmm0
      vmovss  dword ptr [rax+24h], xmm6
      vmovss  xmm1, [rsp+0A8h+brake]
      vmovss  dword ptr [rax+28h], xmm1
      vmovss  xmm0, [rsp+0A8h+rpm]
      vmovss  dword ptr [rax+2Ch], xmm0
    }
    _RDX->u.vehicleUpdate.gear = gear;
    __asm
    {
      vmovss  xmm0, [rsp+0A8h+distanceScale]
      vmovss  dword ptr [rax+34h], xmm0
    }
    _RDX->u.stopOnEntityChannel.entSndChannel = LODWORD(_RBX->v[0]);
    __asm
    {
      vmovss  xmm0, dword ptr [rbx+4]
      vmovss  dword ptr [rdx+10h], xmm0
      vmovss  xmm1, dword ptr [rbx+8]
      vmovss  dword ptr [rdx+14h], xmm1
    }
    CgEntityWorkersOutputBuilder<CgEntitySoundRequest>::Submit(&v26);
    if ( !v26.m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2383, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder was created but is missing its Begin() call") )
      __debugbreak();
    if ( !v26.m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2384, ASSERT_TYPE_ASSERT, "( m_submitCalled )", "Entity Worker Output Builder was created but is missing its Submit() call") )
      __debugbreak();
    result = 1;
  }
  else
  {
    result = 0;
  }
  _R11 = &v27;
  __asm { vmovaps xmm6, xmmword ptr [r11-10h] }
  return result;
}

/*
==============
CG_EntityWorkers_ValidateEntityWorkers
==============
*/
void CG_EntityWorkers_ValidateEntityWorkers(const CgEntityWorkBuilderCmd *workerCmd)
{
  const CgEntityWorkBuilderCmd *v1; 
  CgEntityWork *workerData; 
  unsigned __int16 workerMaxCount; 
  cg_t *LocalClientGlobals; 
  unsigned __int16 mainEntityHead; 
  cg_t *v6; 
  unsigned __int64 v7; 
  char v8; 
  unsigned __int16 postPsEntityHead; 
  unsigned __int64 v10; 
  char v11; 
  unsigned __int16 v12; 
  unsigned __int16 v13; 
  unsigned __int64 v14; 
  char v15; 
  unsigned __int16 i; 
  __int16 *v17; 
  int v18; 
  unsigned __int64 v19; 
  unsigned __int64 v20; 
  unsigned __int16 v21; 
  unsigned __int64 v22; 
  __int64 v23; 
  __int64 v24; 
  __int64 v25; 
  unsigned __int16 v26; 
  cg_t *v28; 
  __int64 v29[32]; 

  v1 = workerCmd;
  if ( !workerCmd && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1488, ASSERT_TYPE_ASSERT, "(workerCmd)", (const char *)&queryFormat, "workerCmd") )
    __debugbreak();
  workerData = v1->workerData;
  if ( !workerData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1491, ASSERT_TYPE_ASSERT, "(work)", (const char *)&queryFormat, "work") )
    __debugbreak();
  workerMaxCount = workerData->workerMaxCount;
  if ( workerMaxCount > 0x100u && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1492, ASSERT_TYPE_ASSERT, "( work->workerMaxCount ) <= ( (256) )", "%s <= %s\n\t%i, %i", "work->workerMaxCount", "MAX_ENTITY_WORKERS", workerMaxCount, 256) )
    __debugbreak();
  memset_0(v29, 0, sizeof(v29));
  LocalClientGlobals = CG_GetLocalClientGlobals((const LocalClientNum_t)v1->localClientNum);
  mainEntityHead = workerData->mainEntityHead;
  v28 = LocalClientGlobals;
  v6 = LocalClientGlobals;
  if ( mainEntityHead != 2047 )
  {
    do
    {
      if ( mainEntityHead >= 0x7FEu )
      {
        LODWORD(v24) = 2046;
        LODWORD(v23) = mainEntityHead;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1500, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ENTITYNUM_ORDINARY_END )", "entityIndex doesn't index ENTITYNUM_ORDINARY_END\n\t%i not in [0, %i)", v23, v24) )
          __debugbreak();
      }
      if ( mainEntityHead >= 0x7FEui64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 181, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      v7 = mainEntityHead;
      v8 = mainEntityHead;
      mainEntityHead = workerData->entityNext[mainEntityHead];
      v29[v7 >> 6] |= 0x8000000000000000ui64 >> (v8 & 0x3F);
    }
    while ( mainEntityHead != 2047 );
    v1 = workerCmd;
    v6 = v28;
  }
  postPsEntityHead = workerData->postPsEntityHead;
  if ( postPsEntityHead != 2047 )
  {
    do
    {
      if ( postPsEntityHead >= 0x7FEu )
      {
        LODWORD(v24) = 2046;
        LODWORD(v23) = postPsEntityHead;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1506, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ENTITYNUM_ORDINARY_END )", "entityIndex doesn't index ENTITYNUM_ORDINARY_END\n\t%i not in [0, %i)", v23, v24) )
          __debugbreak();
      }
      if ( postPsEntityHead >= 0x7FEui64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 181, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
        __debugbreak();
      v10 = postPsEntityHead;
      v11 = postPsEntityHead;
      postPsEntityHead = workerData->entityNext[postPsEntityHead];
      v29[v10 >> 6] |= 0x8000000000000000ui64 >> (v11 & 0x3F);
    }
    while ( postPsEntityHead != 2047 );
    v1 = workerCmd;
    v6 = v28;
  }
  v12 = 0;
  v26 = 0;
  if ( workerData->workerMaxCount )
  {
    do
    {
      v13 = workerData->workerHead[v12];
      if ( v13 != 2047 )
      {
        do
        {
          if ( v13 >= 0x7FEu )
          {
            LODWORD(v24) = 2046;
            LODWORD(v23) = v13;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1514, ASSERT_TYPE_ASSERT, "(unsigned)( entityIndex ) < (unsigned)( ENTITYNUM_ORDINARY_END )", "entityIndex doesn't index ENTITYNUM_ORDINARY_END\n\t%i not in [0, %i)", v23, v24) )
              __debugbreak();
          }
          if ( v13 >= 0x7FEui64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 181, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
            __debugbreak();
          v14 = v13;
          v15 = v13;
          v13 = workerData->entityNext[v13];
          v29[v14 >> 6] |= 0x8000000000000000ui64 >> (v15 & 0x3F);
        }
        while ( v13 != 2047 );
        v12 = v26;
      }
      v26 = ++v12;
    }
    while ( v12 < workerData->workerMaxCount );
    v1 = workerCmd;
    v6 = v28;
  }
  for ( i = 0; i < 0x7FEu; ++i )
  {
    v17 = (__int16 *)((char *)CgEntitySystem::GetEntitySystem((const LocalClientNum_t)v1->localClientNum) + 760 * i);
    if ( (v17[332] & 1) != 0 && v17[212] < 29 )
    {
      v18 = v17[208];
      if ( v6 == (cg_t *)-8i64 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_local.h", 128, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
          __debugbreak();
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2296, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
          __debugbreak();
      }
      if ( GameModeFlagValues::ms_mpValue == ACTIVE && !GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&v6->predictedPlayerState.otherFlags, ACTIVE, 0x22u) )
      {
        if ( v6 == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2308, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
          __debugbreak();
        if ( !Com_GameMode_SupportsFeature(WEAPON_RAISING_ALTSWITCH_ADS) || !GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&v6->predictedPlayerState.otherFlags, GameModeFlagValues::ms_mpValue, 0x29u) )
        {
          if ( v6 == (cg_t *)-8i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2275, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
            __debugbreak();
          if ( !GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&v6->predictedPlayerState.otherFlags, GameModeFlagValues::ms_mpValue, 0x21u) )
            goto LABEL_60;
        }
      }
      if ( v18 != v6->predictedPlayerState.clientNum )
      {
LABEL_60:
        v19 = v17[208];
        if ( v19 >= 0x7FE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
          __debugbreak();
        if ( ((0x8000000000000000ui64 >> (v19 & 0x3F)) & v29[v19 >> 6]) == 0 )
        {
          LODWORD(v25) = v17[212];
          LODWORD(v24) = v17[208];
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1531, ASSERT_TYPE_ASSERT, "(entitiesFound.at( cent->nextState.number ))", "%s\n\tSnapshot contains entity %d (type:%d) that was not found in the entity workers\n", "entitiesFound.at( cent->nextState.number )", v24, v25) )
            __debugbreak();
        }
        v20 = v17[208];
        if ( v20 >= 0x7FE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 209, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
          __debugbreak();
        v29[v20 >> 6] &= ~(0x8000000000000000ui64 >> (v20 & 0x3F));
      }
    }
  }
  v21 = 0;
  v22 = 0i64;
  do
  {
    if ( v22 >= 0x7FE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\libs\\ntl\\ntl\\bitset\\bitset.h", 238, ASSERT_TYPE_ASSERT, "( pos < num_bits )", (const char *)&queryFormat, "pos < num_bits") )
      __debugbreak();
    if ( ((0x8000000000000000ui64 >> (v22 & 0x3F)) & v29[v22 >> 6]) != 0 )
    {
      LODWORD(v24) = v21;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 1537, ASSERT_TYPE_ASSERT, "(!entitiesFound.at( entityIndex ))", "%s\n\tEntity workers contain entity %d that was not found in the snapshot\n", "!entitiesFound.at( entityIndex )", v24) )
        __debugbreak();
    }
    ++v21;
    ++v22;
  }
  while ( v21 < 0x7FEu );
}

/*
==============
CG_Entity_AddEntityParent
==============
*/
__int64 CG_Entity_AddEntityParent(const LocalClientNum_t localClientNum, const CgEntityWorkData *childWorkData, const centity_t *parentEntity, unsigned __int16 *outParents, CgEntityWorkData *outParentWorkData, const unsigned __int16 parentCount)
{
  cg_t *LocalClientGlobals; 
  unsigned __int8 EntityWorkFlags; 
  unsigned __int16 EntityWorkCost; 
  __int64 result; 
  __int64 v13; 

  if ( !parentEntity && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 799, ASSERT_TYPE_ASSERT, "(parentEntity)", (const char *)&queryFormat, "parentEntity") )
    __debugbreak();
  if ( !outParents && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 800, ASSERT_TYPE_ASSERT, "(outParents)", (const char *)&queryFormat, "outParents") )
    __debugbreak();
  if ( !outParentWorkData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 801, ASSERT_TYPE_ASSERT, "(outParentWorkData)", (const char *)&queryFormat, "outParentWorkData") )
    __debugbreak();
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( CG_IsPlayerEntityNumber(&LocalClientGlobals->predictedPlayerState, parentEntity->nextState.number) )
    return parentCount;
  if ( (parentEntity->flags & 1) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 809, ASSERT_TYPE_ASSERT, "(CENextValid( parentEntity ))", (const char *)&queryFormat, "CENextValid( parentEntity )") )
    __debugbreak();
  if ( parentEntity->nextState.eType >= ET_EVENTS )
    return parentCount;
  EntityWorkFlags = CG_EntityWorkers_GetEntityWorkFlags(localClientNum, LocalClientGlobals, parentEntity);
  EntityWorkCost = CG_EntityWorkers_GetEntityWorkCost(localClientNum, parentEntity);
  if ( parentCount >= 4u )
  {
    LODWORD(v13) = parentCount;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 817, ASSERT_TYPE_ASSERT, "(unsigned)( parentCount ) < (unsigned)( (4) )", "parentCount doesn't index MAX_ENTITY_PARENTS\n\t%i not in [0, %i)", v13, 4) )
      __debugbreak();
  }
  outParents[parentCount] = truncate_cast<unsigned short,short>(parentEntity->nextState.number);
  result = (unsigned int)parentCount + 1;
  outParentWorkData[parentCount].cost = EntityWorkCost;
  outParentWorkData[parentCount].flags = EntityWorkFlags;
  return result;
}

/*
==============
CgEntityDObjDrawRequest_GetLightingOrigin
==============
*/
void CgEntityDObjDrawRequest_GetLightingOrigin(const CgEntityDObjDrawRequest *request, vec3_t *lightingOrigin)
{
  GetSecureWorkerOrigin(&request->lightingOrigin.origin, lightingOrigin, ~request->entityIndex);
}

/*
==============
CgEntityDObjDrawRequest_SetLightingOrigin
==============
*/
void CgEntityDObjDrawRequest_SetLightingOrigin(CgEntityDObjDrawRequest *request, const vec3_t *lightingOrigin)
{
  SetSecureWorkerOrigin(lightingOrigin, &request->lightingOrigin.origin, ~request->entityIndex);
}

/*
==============
CgEntityPlayerPostUpdate_GetPoseOrigin
==============
*/
void CgEntityPlayerPostUpdate_GetPoseOrigin(const CgEntityPlayerPostUpdate *update, vec3_t *poseOrigin)
{
  GetSecureWorkerOrigin(&update->poseOrigin.origin, poseOrigin, ~update->entityIndex);
}

/*
==============
CgEntityPlayerPostUpdate_SetPoseOrigin
==============
*/
void CgEntityPlayerPostUpdate_SetPoseOrigin(CgEntityPlayerPostUpdate *update, const vec3_t *poseOrigin)
{
  SetSecureWorkerOrigin(poseOrigin, &update->poseOrigin.origin, ~update->entityIndex);
}

/*
==============
GetSecureWorkerOrigin
==============
*/
void GetSecureWorkerOrigin(const vec3_t *from, vec3_t *to, const unsigned int xorValue)
{
  unsigned int v3; 
  float v4; 
  __int64 v8; 
  int v9; 

  v3 = xorValue ^ LODWORD(from->v[1]);
  v4 = from->v[2];
  LODWORD(to->v[0]) = xorValue ^ LODWORD(from->v[0]);
  LODWORD(to->v[1]) = v3;
  LODWORD(to->v[2]) = xorValue ^ LODWORD(v4);
  __asm { vmovss  xmm0, dword ptr [rdx] }
  memset(&v8, 0, sizeof(v8));
  __asm { vmovss  [rsp+38h+arg_10], xmm0 }
  if ( (v9 & 0x7F800000) == 2139095040 )
    goto LABEL_8;
  __asm
  {
    vmovss  xmm0, dword ptr [rdx+4]
    vmovss  [rsp+38h+arg_10], xmm0
  }
  if ( (v9 & 0x7F800000) == 2139095040 )
    goto LABEL_8;
  __asm
  {
    vmovss  xmm0, dword ptr [rdx+8]
    vmovss  [rsp+38h+arg_10], xmm0
  }
  if ( (v9 & 0x7F800000) == 2139095040 )
  {
LABEL_8:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 523, ASSERT_TYPE_SANITY, "( !IS_NAN( ( to )[0] ) && !IS_NAN( ( to )[1] ) && !IS_NAN( ( to )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( to )[0] ) && !IS_NAN( ( to )[1] ) && !IS_NAN( ( to )[2] )") )
      __debugbreak();
  }
}

/*
==============
SetSecureWorkerOrigin
==============
*/
void SetSecureWorkerOrigin(const vec3_t *from, vec3_t *to, const unsigned int xorValue)
{
  const vec3_t *v6; 
  unsigned int v9; 
  unsigned int v10; 
  __int64 v11; 
  int v12; 

  __asm
  {
    vmovss  xmm0, dword ptr [rcx]
    vmovss  [rsp+38h+arg_10], xmm0
  }
  v6 = from;
  if ( (v12 & 0x7F800000) == 2139095040 )
    goto LABEL_9;
  __asm
  {
    vmovss  xmm0, dword ptr [rcx+4]
    vmovss  [rsp+38h+arg_10], xmm0
  }
  if ( (v12 & 0x7F800000) == 2139095040 )
    goto LABEL_9;
  __asm
  {
    vmovss  xmm0, dword ptr [rcx+8]
    vmovss  [rsp+38h+arg_10], xmm0
  }
  if ( (v12 & 0x7F800000) == 2139095040 )
  {
LABEL_9:
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 491, ASSERT_TYPE_SANITY, "( !IS_NAN( ( from )[0] ) && !IS_NAN( ( from )[1] ) && !IS_NAN( ( from )[2] ) )", (const char *)&queryFormat, "!IS_NAN( ( from )[0] ) && !IS_NAN( ( from )[1] ) && !IS_NAN( ( from )[2] )") )
      __debugbreak();
  }
  v9 = xorValue ^ LODWORD(v6->v[0]);
  v10 = xorValue ^ LODWORD(v6->v[1]);
  LODWORD(to->v[2]) = xorValue ^ LODWORD(v6->v[2]);
  LODWORD(to->v[0]) = v9;
  LODWORD(to->v[1]) = v10;
  memset(&v11, 0, sizeof(v11));
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityBModelDrawRequest>::Submit
==============
*/
void CgEntityWorkersOutputBuilder<CgEntityBModelDrawRequest>::Submit(CgEntityWorkersOutputBuilder<CgEntityBModelDrawRequest> *this)
{
  const dvar_t *v2; 
  __int64 v3; 
  unsigned int v5; 
  bool v8; 
  unsigned int v10; 
  unsigned int v11; 
  char *fmt; 
  __int64 v13; 
  __int64 v14; 
  int v15; 
  char data; 

  _RDI = this;
  if ( !Sys_IsMainThreadEntityWorker() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2405, ASSERT_TYPE_ASSERT, "(CG_EntityWorkers_WorkersCurrentlyActive())", (const char *)&queryFormat, "CG_EntityWorkers_WorkersCurrentlyActive()") )
    __debugbreak();
  if ( !_RDI->m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2407, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder must call Begin() before Submit()") )
    __debugbreak();
  if ( _RDI->m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2408, ASSERT_TYPE_ASSERT, "( !m_submitCalled )", "Entity Worker Output Builder called Submit() more than once") )
    __debugbreak();
  _RDI->m_submitCalled = 1;
  v2 = DCONST_DVARBOOL_cg_entityWorkersBufferedOutput;
  if ( !DCONST_DVARBOOL_cg_entityWorkersBufferedOutput && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkersBufferedOutput") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  if ( v2->current.enabled )
  {
    v3 = tls_index;
    if ( !*(_QWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1672i64) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2415, ASSERT_TYPE_ASSERT, "( s_threadLocalEntityOutput != nullptr )", "s_threadLocalEntityOutput was not set while processing entity workers") )
      __debugbreak();
    _RBX = *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + v3) + 1672i64);
    v5 = *(_DWORD *)(_RBX + 2048);
    if ( v5 + 9 <= 0x800 )
    {
      if ( v5 >= 0x800 )
      {
        LODWORD(v14) = 2048;
        LODWORD(v13) = *(_DWORD *)(_RBX + 2048);
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2422, ASSERT_TYPE_ASSERT, "(unsigned)( output.requestBufferCurSize ) < (unsigned)( ( sizeof( *array_counter( output.requestBuffer ) ) + 0 ) )", "output.requestBufferCurSize doesn't index output.requestBuffer\n\t%i not in [0, %i)", v13, v14) )
          __debugbreak();
      }
      *(_BYTE *)((unsigned int)(*(_DWORD *)(_RBX + 2048))++ + _RBX) = _RDI->m_requestType[0];
      if ( *(_DWORD *)(_RBX + 2048) >= 0x800u )
      {
        LODWORD(v14) = 2048;
        LODWORD(v13) = *(_DWORD *)(_RBX + 2048);
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2426, ASSERT_TYPE_ASSERT, "(unsigned)( output.requestBufferCurSize ) < (unsigned)( ( sizeof( *array_counter( output.requestBuffer ) ) + 0 ) )", "output.requestBufferCurSize doesn't index output.requestBuffer\n\t%i not in [0, %i)", v13, v14) )
          __debugbreak();
      }
      _RAX = *(unsigned int *)(_RBX + 2048);
      __asm
      {
        vmovsd  xmm0, qword ptr [rdi]
        vmovsd  qword ptr [rax+rbx], xmm0
      }
      *(_DWORD *)(_RBX + 2048) += 8;
      return;
    }
    Com_PrintError(14, "CgEntityWorkers: Failed to submit task (%d). Can't store %d more bytes.\n", (unsigned __int8)_RDI->m_requestType[0], 9i64);
    LODWORD(v14) = 9;
    LODWORD(v13) = (unsigned __int8)_RDI->m_requestType[0];
    v8 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2433, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "CgEntityWorkers: Failed to write task (%d). Can't store %d more bytes.", v13, v14);
    goto LABEL_31;
  }
  if ( !s_entityWorkers_outputStream && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2439, ASSERT_TYPE_ASSERT, "( s_entityWorkers_outputStream != nullptr )", "s_entityWorkers_outputStream was not set while processing entity workers") )
    __debugbreak();
  __asm { vmovsd  xmm0, qword ptr [rdi] }
  data = _RDI->m_requestType[0];
  __asm { vmovsd  [rsp+68h+var_27], xmm0 }
  v10 = MpscStream<524288>::Write(s_entityWorkers_outputStream, &data, 9);
  v11 = v10;
  if ( v10 != 9 )
  {
    LODWORD(fmt) = 9;
    Com_PrintError(14, "CgEntityWorkers: Failed to write task of type %d (result = %d, expected %d)\n", (unsigned __int8)_RDI->m_requestType[0], v10, fmt);
    v15 = 9;
    LODWORD(v14) = v11;
    LODWORD(v13) = (unsigned __int8)_RDI->m_requestType[0];
    v8 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2451, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "CgEntityWorkers: Failed to write task of type %d (result = %d, expected %d)\n", v13, v14, v15);
LABEL_31:
    if ( v8 )
      __debugbreak();
  }
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityBModelUpdateBoundsRequest>::Submit
==============
*/
void CgEntityWorkersOutputBuilder<CgEntityBModelUpdateBoundsRequest>::Submit(CgEntityWorkersOutputBuilder<CgEntityBModelUpdateBoundsRequest> *this)
{
  const dvar_t *v2; 
  __int64 v3; 
  __int64 v4; 
  unsigned int v5; 
  bool v6; 
  unsigned int v7; 
  unsigned int v8; 
  char *fmt; 
  __int64 v10; 
  __int64 v11; 
  int v12; 
  char data; 
  unsigned __int16 entityIndex; 

  if ( !Sys_IsMainThreadEntityWorker() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2405, ASSERT_TYPE_ASSERT, "(CG_EntityWorkers_WorkersCurrentlyActive())", (const char *)&queryFormat, "CG_EntityWorkers_WorkersCurrentlyActive()") )
    __debugbreak();
  if ( !this->m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2407, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder must call Begin() before Submit()") )
    __debugbreak();
  if ( this->m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2408, ASSERT_TYPE_ASSERT, "( !m_submitCalled )", "Entity Worker Output Builder called Submit() more than once") )
    __debugbreak();
  this->m_submitCalled = 1;
  v2 = DCONST_DVARBOOL_cg_entityWorkersBufferedOutput;
  if ( !DCONST_DVARBOOL_cg_entityWorkersBufferedOutput && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkersBufferedOutput") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  if ( v2->current.enabled )
  {
    v3 = tls_index;
    if ( !*(_QWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1672i64) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2415, ASSERT_TYPE_ASSERT, "( s_threadLocalEntityOutput != nullptr )", "s_threadLocalEntityOutput was not set while processing entity workers") )
      __debugbreak();
    v4 = *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + v3) + 1672i64);
    v5 = *(_DWORD *)(v4 + 2048);
    if ( v5 + 3 <= 0x800 )
    {
      if ( v5 >= 0x800 )
      {
        LODWORD(v11) = 2048;
        LODWORD(v10) = *(_DWORD *)(v4 + 2048);
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2422, ASSERT_TYPE_ASSERT, "(unsigned)( output.requestBufferCurSize ) < (unsigned)( ( sizeof( *array_counter( output.requestBuffer ) ) + 0 ) )", "output.requestBufferCurSize doesn't index output.requestBuffer\n\t%i not in [0, %i)", v10, v11) )
          __debugbreak();
      }
      *(_BYTE *)((unsigned int)(*(_DWORD *)(v4 + 2048))++ + v4) = this->m_requestType[0];
      if ( *(_DWORD *)(v4 + 2048) >= 0x800u )
      {
        LODWORD(v11) = 2048;
        LODWORD(v10) = *(_DWORD *)(v4 + 2048);
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2426, ASSERT_TYPE_ASSERT, "(unsigned)( output.requestBufferCurSize ) < (unsigned)( ( sizeof( *array_counter( output.requestBuffer ) ) + 0 ) )", "output.requestBufferCurSize doesn't index output.requestBuffer\n\t%i not in [0, %i)", v10, v11) )
          __debugbreak();
      }
      *(_WORD *)(*(unsigned int *)(v4 + 2048) + v4) = this->m_requestPayload.entityIndex;
      *(_DWORD *)(v4 + 2048) += 2;
      return;
    }
    Com_PrintError(14, "CgEntityWorkers: Failed to submit task (%d). Can't store %d more bytes.\n", (unsigned __int8)this->m_requestType[0], 3i64);
    LODWORD(v11) = 3;
    LODWORD(v10) = (unsigned __int8)this->m_requestType[0];
    v6 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2433, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "CgEntityWorkers: Failed to write task (%d). Can't store %d more bytes.", v10, v11);
    goto LABEL_31;
  }
  if ( !s_entityWorkers_outputStream && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2439, ASSERT_TYPE_ASSERT, "( s_entityWorkers_outputStream != nullptr )", "s_entityWorkers_outputStream was not set while processing entity workers") )
    __debugbreak();
  data = this->m_requestType[0];
  entityIndex = this->m_requestPayload.entityIndex;
  v7 = MpscStream<524288>::Write(s_entityWorkers_outputStream, &data, 3);
  v8 = v7;
  if ( v7 != 3 )
  {
    LODWORD(fmt) = 3;
    Com_PrintError(14, "CgEntityWorkers: Failed to write task of type %d (result = %d, expected %d)\n", (unsigned __int8)this->m_requestType[0], v7, fmt);
    v12 = 3;
    LODWORD(v11) = v8;
    LODWORD(v10) = (unsigned __int8)this->m_requestType[0];
    v6 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2451, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "CgEntityWorkers: Failed to write task of type %d (result = %d, expected %d)\n", v10, v11, v12);
LABEL_31:
    if ( v6 )
      __debugbreak();
  }
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityDObjDrawRequest>::Submit
==============
*/
void CgEntityWorkersOutputBuilder<CgEntityDObjDrawRequest>::Submit(CgEntityWorkersOutputBuilder<CgEntityDObjDrawRequest> *this)
{
  const dvar_t *v2; 
  __int64 v3; 
  __int64 v4; 
  unsigned int v5; 
  bool v10; 
  char v12; 
  int atlasTime_low; 
  unsigned int v16; 
  unsigned int v17; 
  char *fmt; 
  __int64 v19; 
  __int64 v20; 
  int v21; 
  char data; 
  int v26; 

  _RBX = this;
  if ( !Sys_IsMainThreadEntityWorker() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2405, ASSERT_TYPE_ASSERT, "(CG_EntityWorkers_WorkersCurrentlyActive())", (const char *)&queryFormat, "CG_EntityWorkers_WorkersCurrentlyActive()") )
    __debugbreak();
  if ( !_RBX->m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2407, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder must call Begin() before Submit()") )
    __debugbreak();
  if ( _RBX->m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2408, ASSERT_TYPE_ASSERT, "( !m_submitCalled )", "Entity Worker Output Builder called Submit() more than once") )
    __debugbreak();
  _RBX->m_submitCalled = 1;
  v2 = DCONST_DVARBOOL_cg_entityWorkersBufferedOutput;
  if ( !DCONST_DVARBOOL_cg_entityWorkersBufferedOutput && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkersBufferedOutput") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  if ( v2->current.enabled )
  {
    v3 = tls_index;
    if ( !*(_QWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1672i64) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2415, ASSERT_TYPE_ASSERT, "( s_threadLocalEntityOutput != nullptr )", "s_threadLocalEntityOutput was not set while processing entity workers") )
      __debugbreak();
    v4 = *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + v3) + 1672i64);
    v5 = *(_DWORD *)(v4 + 2048);
    if ( v5 + 101 <= 0x800 )
    {
      if ( v5 >= 0x800 )
      {
        LODWORD(v20) = 2048;
        LODWORD(v19) = *(_DWORD *)(v4 + 2048);
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2422, ASSERT_TYPE_ASSERT, "(unsigned)( output.requestBufferCurSize ) < (unsigned)( ( sizeof( *array_counter( output.requestBuffer ) ) + 0 ) )", "output.requestBufferCurSize doesn't index output.requestBuffer\n\t%i not in [0, %i)", v19, v20) )
          __debugbreak();
      }
      *(_BYTE *)((unsigned int)(*(_DWORD *)(v4 + 2048))++ + v4) = _RBX->m_requestType[0];
      if ( *(_DWORD *)(v4 + 2048) >= 0x800u )
      {
        LODWORD(v20) = 2048;
        LODWORD(v19) = *(_DWORD *)(v4 + 2048);
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2426, ASSERT_TYPE_ASSERT, "(unsigned)( output.requestBufferCurSize ) < (unsigned)( ( sizeof( *array_counter( output.requestBuffer ) ) + 0 ) )", "output.requestBufferCurSize doesn't index output.requestBuffer\n\t%i not in [0, %i)", v19, v20) )
          __debugbreak();
      }
      __asm { vmovups ymm0, ymmword ptr [rbx] }
      _RCX = v4 + *(unsigned int *)(v4 + 2048);
      __asm
      {
        vmovups ymmword ptr [rcx], ymm0
        vmovups ymm1, ymmword ptr [rbx+20h]
        vmovups ymmword ptr [rcx+20h], ymm1
        vmovups ymm0, ymmword ptr [rbx+40h]
        vmovups ymmword ptr [rcx+40h], ymm0
      }
      *(float *)(_RCX + 96) = _RBX->m_requestPayload.shaderOverride.atlasTime;
      *(_DWORD *)(v4 + 2048) += 100;
      return;
    }
    Com_PrintError(14, "CgEntityWorkers: Failed to submit task (%d). Can't store %d more bytes.\n", (unsigned __int8)_RBX->m_requestType[0], 101i64);
    LODWORD(v20) = 101;
    LODWORD(v19) = (unsigned __int8)_RBX->m_requestType[0];
    v10 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2433, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "CgEntityWorkers: Failed to write task (%d). Can't store %d more bytes.", v19, v20);
    goto LABEL_31;
  }
  if ( !s_entityWorkers_outputStream && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2439, ASSERT_TYPE_ASSERT, "( s_entityWorkers_outputStream != nullptr )", "s_entityWorkers_outputStream was not set while processing entity workers") )
    __debugbreak();
  __asm { vmovups ymm0, ymmword ptr [rbx] }
  v12 = _RBX->m_requestType[0];
  __asm
  {
    vmovups ymm1, ymmword ptr [rbx+20h]
    vmovups [rsp+0C8h+var_87], ymm0
    vmovups ymm0, ymmword ptr [rbx+40h]
  }
  data = v12;
  atlasTime_low = LODWORD(_RBX->m_requestPayload.shaderOverride.atlasTime);
  __asm
  {
    vmovups [rsp+0C8h+var_47], ymm0
    vmovups [rsp+0C8h+var_67], ymm1
  }
  v26 = atlasTime_low;
  v16 = MpscStream<524288>::Write(s_entityWorkers_outputStream, &data, 101);
  v17 = v16;
  if ( v16 != 101 )
  {
    LODWORD(fmt) = 101;
    Com_PrintError(14, "CgEntityWorkers: Failed to write task of type %d (result = %d, expected %d)\n", (unsigned __int8)_RBX->m_requestType[0], v16, fmt);
    v21 = 101;
    LODWORD(v20) = v17;
    LODWORD(v19) = (unsigned __int8)_RBX->m_requestType[0];
    v10 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2451, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "CgEntityWorkers: Failed to write task of type %d (result = %d, expected %d)\n", v19, v20, v21);
LABEL_31:
    if ( v10 )
      __debugbreak();
  }
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityDObjUpdateBoundsRequest>::Submit
==============
*/
void CgEntityWorkersOutputBuilder<CgEntityDObjUpdateBoundsRequest>::Submit(CgEntityWorkersOutputBuilder<CgEntityDObjUpdateBoundsRequest> *this)
{
  const dvar_t *v2; 
  __int64 v3; 
  __int64 v4; 
  unsigned int v5; 
  bool v6; 
  unsigned int v7; 
  unsigned int v8; 
  char *fmt; 
  __int64 v10; 
  __int64 v11; 
  int v12; 
  char data; 
  unsigned __int16 entityIndex; 

  if ( !Sys_IsMainThreadEntityWorker() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2405, ASSERT_TYPE_ASSERT, "(CG_EntityWorkers_WorkersCurrentlyActive())", (const char *)&queryFormat, "CG_EntityWorkers_WorkersCurrentlyActive()") )
    __debugbreak();
  if ( !this->m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2407, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder must call Begin() before Submit()") )
    __debugbreak();
  if ( this->m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2408, ASSERT_TYPE_ASSERT, "( !m_submitCalled )", "Entity Worker Output Builder called Submit() more than once") )
    __debugbreak();
  this->m_submitCalled = 1;
  v2 = DCONST_DVARBOOL_cg_entityWorkersBufferedOutput;
  if ( !DCONST_DVARBOOL_cg_entityWorkersBufferedOutput && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkersBufferedOutput") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  if ( v2->current.enabled )
  {
    v3 = tls_index;
    if ( !*(_QWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1672i64) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2415, ASSERT_TYPE_ASSERT, "( s_threadLocalEntityOutput != nullptr )", "s_threadLocalEntityOutput was not set while processing entity workers") )
      __debugbreak();
    v4 = *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + v3) + 1672i64);
    v5 = *(_DWORD *)(v4 + 2048);
    if ( v5 + 3 <= 0x800 )
    {
      if ( v5 >= 0x800 )
      {
        LODWORD(v11) = 2048;
        LODWORD(v10) = *(_DWORD *)(v4 + 2048);
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2422, ASSERT_TYPE_ASSERT, "(unsigned)( output.requestBufferCurSize ) < (unsigned)( ( sizeof( *array_counter( output.requestBuffer ) ) + 0 ) )", "output.requestBufferCurSize doesn't index output.requestBuffer\n\t%i not in [0, %i)", v10, v11) )
          __debugbreak();
      }
      *(_BYTE *)((unsigned int)(*(_DWORD *)(v4 + 2048))++ + v4) = this->m_requestType[0];
      if ( *(_DWORD *)(v4 + 2048) >= 0x800u )
      {
        LODWORD(v11) = 2048;
        LODWORD(v10) = *(_DWORD *)(v4 + 2048);
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2426, ASSERT_TYPE_ASSERT, "(unsigned)( output.requestBufferCurSize ) < (unsigned)( ( sizeof( *array_counter( output.requestBuffer ) ) + 0 ) )", "output.requestBufferCurSize doesn't index output.requestBuffer\n\t%i not in [0, %i)", v10, v11) )
          __debugbreak();
      }
      *(_WORD *)(*(unsigned int *)(v4 + 2048) + v4) = this->m_requestPayload.entityIndex;
      *(_DWORD *)(v4 + 2048) += 2;
      return;
    }
    Com_PrintError(14, "CgEntityWorkers: Failed to submit task (%d). Can't store %d more bytes.\n", (unsigned __int8)this->m_requestType[0], 3i64);
    LODWORD(v11) = 3;
    LODWORD(v10) = (unsigned __int8)this->m_requestType[0];
    v6 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2433, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "CgEntityWorkers: Failed to write task (%d). Can't store %d more bytes.", v10, v11);
    goto LABEL_31;
  }
  if ( !s_entityWorkers_outputStream && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2439, ASSERT_TYPE_ASSERT, "( s_entityWorkers_outputStream != nullptr )", "s_entityWorkers_outputStream was not set while processing entity workers") )
    __debugbreak();
  data = this->m_requestType[0];
  entityIndex = this->m_requestPayload.entityIndex;
  v7 = MpscStream<524288>::Write(s_entityWorkers_outputStream, &data, 3);
  v8 = v7;
  if ( v7 != 3 )
  {
    LODWORD(fmt) = 3;
    Com_PrintError(14, "CgEntityWorkers: Failed to write task of type %d (result = %d, expected %d)\n", (unsigned __int8)this->m_requestType[0], v7, fmt);
    v12 = 3;
    LODWORD(v11) = v8;
    LODWORD(v10) = (unsigned __int8)this->m_requestType[0];
    v6 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2451, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "CgEntityWorkers: Failed to write task of type %d (result = %d, expected %d)\n", v10, v11, v12);
LABEL_31:
    if ( v6 )
      __debugbreak();
  }
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityFxMarkDetachAllRequest>::Submit
==============
*/
void CgEntityWorkersOutputBuilder<CgEntityFxMarkDetachAllRequest>::Submit(CgEntityWorkersOutputBuilder<CgEntityFxMarkDetachAllRequest> *this)
{
  const dvar_t *v2; 
  __int64 v3; 
  unsigned int v5; 
  bool v8; 
  unsigned int v10; 
  unsigned int v11; 
  char *fmt; 
  __int64 v13; 
  __int64 v14; 
  int v15; 
  char data; 

  _RDI = this;
  if ( !Sys_IsMainThreadEntityWorker() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2405, ASSERT_TYPE_ASSERT, "(CG_EntityWorkers_WorkersCurrentlyActive())", (const char *)&queryFormat, "CG_EntityWorkers_WorkersCurrentlyActive()") )
    __debugbreak();
  if ( !_RDI->m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2407, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder must call Begin() before Submit()") )
    __debugbreak();
  if ( _RDI->m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2408, ASSERT_TYPE_ASSERT, "( !m_submitCalled )", "Entity Worker Output Builder called Submit() more than once") )
    __debugbreak();
  _RDI->m_submitCalled = 1;
  v2 = DCONST_DVARBOOL_cg_entityWorkersBufferedOutput;
  if ( !DCONST_DVARBOOL_cg_entityWorkersBufferedOutput && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkersBufferedOutput") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  if ( v2->current.enabled )
  {
    v3 = tls_index;
    if ( !*(_QWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1672i64) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2415, ASSERT_TYPE_ASSERT, "( s_threadLocalEntityOutput != nullptr )", "s_threadLocalEntityOutput was not set while processing entity workers") )
      __debugbreak();
    _RBX = *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + v3) + 1672i64);
    v5 = *(_DWORD *)(_RBX + 2048);
    if ( v5 + 9 <= 0x800 )
    {
      if ( v5 >= 0x800 )
      {
        LODWORD(v14) = 2048;
        LODWORD(v13) = *(_DWORD *)(_RBX + 2048);
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2422, ASSERT_TYPE_ASSERT, "(unsigned)( output.requestBufferCurSize ) < (unsigned)( ( sizeof( *array_counter( output.requestBuffer ) ) + 0 ) )", "output.requestBufferCurSize doesn't index output.requestBuffer\n\t%i not in [0, %i)", v13, v14) )
          __debugbreak();
      }
      *(_BYTE *)((unsigned int)(*(_DWORD *)(_RBX + 2048))++ + _RBX) = _RDI->m_requestType[0];
      if ( *(_DWORD *)(_RBX + 2048) >= 0x800u )
      {
        LODWORD(v14) = 2048;
        LODWORD(v13) = *(_DWORD *)(_RBX + 2048);
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2426, ASSERT_TYPE_ASSERT, "(unsigned)( output.requestBufferCurSize ) < (unsigned)( ( sizeof( *array_counter( output.requestBuffer ) ) + 0 ) )", "output.requestBufferCurSize doesn't index output.requestBuffer\n\t%i not in [0, %i)", v13, v14) )
          __debugbreak();
      }
      _RAX = *(unsigned int *)(_RBX + 2048);
      __asm
      {
        vmovsd  xmm0, qword ptr [rdi]
        vmovsd  qword ptr [rax+rbx], xmm0
      }
      *(_DWORD *)(_RBX + 2048) += 8;
      return;
    }
    Com_PrintError(14, "CgEntityWorkers: Failed to submit task (%d). Can't store %d more bytes.\n", (unsigned __int8)_RDI->m_requestType[0], 9i64);
    LODWORD(v14) = 9;
    LODWORD(v13) = (unsigned __int8)_RDI->m_requestType[0];
    v8 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2433, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "CgEntityWorkers: Failed to write task (%d). Can't store %d more bytes.", v13, v14);
    goto LABEL_31;
  }
  if ( !s_entityWorkers_outputStream && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2439, ASSERT_TYPE_ASSERT, "( s_entityWorkers_outputStream != nullptr )", "s_entityWorkers_outputStream was not set while processing entity workers") )
    __debugbreak();
  __asm { vmovsd  xmm0, qword ptr [rdi] }
  data = _RDI->m_requestType[0];
  __asm { vmovsd  [rsp+68h+var_27], xmm0 }
  v10 = MpscStream<524288>::Write(s_entityWorkers_outputStream, &data, 9);
  v11 = v10;
  if ( v10 != 9 )
  {
    LODWORD(fmt) = 9;
    Com_PrintError(14, "CgEntityWorkers: Failed to write task of type %d (result = %d, expected %d)\n", (unsigned __int8)_RDI->m_requestType[0], v10, fmt);
    v15 = 9;
    LODWORD(v14) = v11;
    LODWORD(v13) = (unsigned __int8)_RDI->m_requestType[0];
    v8 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2451, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "CgEntityWorkers: Failed to write task of type %d (result = %d, expected %d)\n", v13, v14, v15);
LABEL_31:
    if ( v8 )
      __debugbreak();
  }
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityNotetrackRequest>::Submit
==============
*/
void CgEntityWorkersOutputBuilder<CgEntityNotetrackRequest>::Submit(CgEntityWorkersOutputBuilder<CgEntityNotetrackRequest> *this)
{
  const dvar_t *v2; 
  __int64 v3; 
  unsigned int v5; 
  bool v8; 
  unsigned int v10; 
  unsigned int v11; 
  char *fmt; 
  __int64 v13; 
  __int64 v14; 
  int v15; 
  char data; 

  _RDI = this;
  if ( !Sys_IsMainThreadEntityWorker() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2405, ASSERT_TYPE_ASSERT, "(CG_EntityWorkers_WorkersCurrentlyActive())", (const char *)&queryFormat, "CG_EntityWorkers_WorkersCurrentlyActive()") )
    __debugbreak();
  if ( !_RDI->m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2407, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder must call Begin() before Submit()") )
    __debugbreak();
  if ( _RDI->m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2408, ASSERT_TYPE_ASSERT, "( !m_submitCalled )", "Entity Worker Output Builder called Submit() more than once") )
    __debugbreak();
  _RDI->m_submitCalled = 1;
  v2 = DCONST_DVARBOOL_cg_entityWorkersBufferedOutput;
  if ( !DCONST_DVARBOOL_cg_entityWorkersBufferedOutput && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkersBufferedOutput") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  if ( v2->current.enabled )
  {
    v3 = tls_index;
    if ( !*(_QWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1672i64) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2415, ASSERT_TYPE_ASSERT, "( s_threadLocalEntityOutput != nullptr )", "s_threadLocalEntityOutput was not set while processing entity workers") )
      __debugbreak();
    _RBX = *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + v3) + 1672i64);
    v5 = *(_DWORD *)(_RBX + 2048);
    if ( v5 + 9 <= 0x800 )
    {
      if ( v5 >= 0x800 )
      {
        LODWORD(v14) = 2048;
        LODWORD(v13) = *(_DWORD *)(_RBX + 2048);
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2422, ASSERT_TYPE_ASSERT, "(unsigned)( output.requestBufferCurSize ) < (unsigned)( ( sizeof( *array_counter( output.requestBuffer ) ) + 0 ) )", "output.requestBufferCurSize doesn't index output.requestBuffer\n\t%i not in [0, %i)", v13, v14) )
          __debugbreak();
      }
      *(_BYTE *)((unsigned int)(*(_DWORD *)(_RBX + 2048))++ + _RBX) = _RDI->m_requestType[0];
      if ( *(_DWORD *)(_RBX + 2048) >= 0x800u )
      {
        LODWORD(v14) = 2048;
        LODWORD(v13) = *(_DWORD *)(_RBX + 2048);
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2426, ASSERT_TYPE_ASSERT, "(unsigned)( output.requestBufferCurSize ) < (unsigned)( ( sizeof( *array_counter( output.requestBuffer ) ) + 0 ) )", "output.requestBufferCurSize doesn't index output.requestBuffer\n\t%i not in [0, %i)", v13, v14) )
          __debugbreak();
      }
      _RAX = *(unsigned int *)(_RBX + 2048);
      __asm
      {
        vmovsd  xmm0, qword ptr [rdi]
        vmovsd  qword ptr [rax+rbx], xmm0
      }
      *(_DWORD *)(_RBX + 2048) += 8;
      return;
    }
    Com_PrintError(14, "CgEntityWorkers: Failed to submit task (%d). Can't store %d more bytes.\n", (unsigned __int8)_RDI->m_requestType[0], 9i64);
    LODWORD(v14) = 9;
    LODWORD(v13) = (unsigned __int8)_RDI->m_requestType[0];
    v8 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2433, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "CgEntityWorkers: Failed to write task (%d). Can't store %d more bytes.", v13, v14);
    goto LABEL_31;
  }
  if ( !s_entityWorkers_outputStream && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2439, ASSERT_TYPE_ASSERT, "( s_entityWorkers_outputStream != nullptr )", "s_entityWorkers_outputStream was not set while processing entity workers") )
    __debugbreak();
  __asm { vmovsd  xmm0, qword ptr [rdi] }
  data = _RDI->m_requestType[0];
  __asm { vmovsd  [rsp+68h+var_27], xmm0 }
  v10 = MpscStream<524288>::Write(s_entityWorkers_outputStream, &data, 9);
  v11 = v10;
  if ( v10 != 9 )
  {
    LODWORD(fmt) = 9;
    Com_PrintError(14, "CgEntityWorkers: Failed to write task of type %d (result = %d, expected %d)\n", (unsigned __int8)_RDI->m_requestType[0], v10, fmt);
    v15 = 9;
    LODWORD(v14) = v11;
    LODWORD(v13) = (unsigned __int8)_RDI->m_requestType[0];
    v8 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2451, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "CgEntityWorkers: Failed to write task of type %d (result = %d, expected %d)\n", v13, v14, v15);
LABEL_31:
    if ( v8 )
      __debugbreak();
  }
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityPlayerPostUpdate>::Submit
==============
*/
void CgEntityWorkersOutputBuilder<CgEntityPlayerPostUpdate>::Submit(CgEntityWorkersOutputBuilder<CgEntityPlayerPostUpdate> *this)
{
  const dvar_t *v2; 
  __int64 v3; 
  unsigned int v5; 
  bool v8; 
  unsigned int v10; 
  unsigned int v11; 
  char *fmt; 
  __int64 v13; 
  __int64 v14; 
  int v15; 
  char data; 
  float v18; 

  _RBX = this;
  if ( !Sys_IsMainThreadEntityWorker() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2405, ASSERT_TYPE_ASSERT, "(CG_EntityWorkers_WorkersCurrentlyActive())", (const char *)&queryFormat, "CG_EntityWorkers_WorkersCurrentlyActive()") )
    __debugbreak();
  if ( !_RBX->m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2407, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder must call Begin() before Submit()") )
    __debugbreak();
  if ( _RBX->m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2408, ASSERT_TYPE_ASSERT, "( !m_submitCalled )", "Entity Worker Output Builder called Submit() more than once") )
    __debugbreak();
  _RBX->m_submitCalled = 1;
  v2 = DCONST_DVARBOOL_cg_entityWorkersBufferedOutput;
  if ( !DCONST_DVARBOOL_cg_entityWorkersBufferedOutput && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkersBufferedOutput") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  if ( v2->current.enabled )
  {
    v3 = tls_index;
    if ( !*(_QWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1672i64) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2415, ASSERT_TYPE_ASSERT, "( s_threadLocalEntityOutput != nullptr )", "s_threadLocalEntityOutput was not set while processing entity workers") )
      __debugbreak();
    _RDI = *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + v3) + 1672i64);
    v5 = *(_DWORD *)(_RDI + 2048);
    if ( v5 + 21 <= 0x800 )
    {
      if ( v5 >= 0x800 )
      {
        LODWORD(v14) = 2048;
        LODWORD(v13) = *(_DWORD *)(_RDI + 2048);
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2422, ASSERT_TYPE_ASSERT, "(unsigned)( output.requestBufferCurSize ) < (unsigned)( ( sizeof( *array_counter( output.requestBuffer ) ) + 0 ) )", "output.requestBufferCurSize doesn't index output.requestBuffer\n\t%i not in [0, %i)", v13, v14) )
          __debugbreak();
      }
      *(_BYTE *)((unsigned int)(*(_DWORD *)(_RDI + 2048))++ + _RDI) = _RBX->m_requestType[0];
      if ( *(_DWORD *)(_RDI + 2048) >= 0x800u )
      {
        LODWORD(v14) = 2048;
        LODWORD(v13) = *(_DWORD *)(_RDI + 2048);
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2426, ASSERT_TYPE_ASSERT, "(unsigned)( output.requestBufferCurSize ) < (unsigned)( ( sizeof( *array_counter( output.requestBuffer ) ) + 0 ) )", "output.requestBufferCurSize doesn't index output.requestBuffer\n\t%i not in [0, %i)", v13, v14) )
          __debugbreak();
      }
      _RCX = *(unsigned int *)(_RDI + 2048);
      __asm
      {
        vmovups xmm0, xmmword ptr [rbx]
        vmovups xmmword ptr [rcx+rdi], xmm0
      }
      *(float *)(_RCX + _RDI + 16) = _RBX->m_requestPayload.poseOrigin.origin.v[2];
      *(_DWORD *)(_RDI + 2048) += 20;
      return;
    }
    Com_PrintError(14, "CgEntityWorkers: Failed to submit task (%d). Can't store %d more bytes.\n", (unsigned __int8)_RBX->m_requestType[0], 21i64);
    LODWORD(v14) = 21;
    LODWORD(v13) = (unsigned __int8)_RBX->m_requestType[0];
    v8 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2433, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "CgEntityWorkers: Failed to write task (%d). Can't store %d more bytes.", v13, v14);
    goto LABEL_31;
  }
  if ( !s_entityWorkers_outputStream && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2439, ASSERT_TYPE_ASSERT, "( s_entityWorkers_outputStream != nullptr )", "s_entityWorkers_outputStream was not set while processing entity workers") )
    __debugbreak();
  __asm { vmovups xmm0, xmmword ptr [rbx] }
  data = _RBX->m_requestType[0];
  v18 = _RBX->m_requestPayload.poseOrigin.origin.v[2];
  __asm { vmovups [rsp+68h+var_27], xmm0 }
  v10 = MpscStream<524288>::Write(s_entityWorkers_outputStream, &data, 21);
  v11 = v10;
  if ( v10 != 21 )
  {
    LODWORD(fmt) = 21;
    Com_PrintError(14, "CgEntityWorkers: Failed to write task of type %d (result = %d, expected %d)\n", (unsigned __int8)_RBX->m_requestType[0], v10, fmt);
    v15 = 21;
    LODWORD(v14) = v11;
    LODWORD(v13) = (unsigned __int8)_RBX->m_requestType[0];
    v8 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2451, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "CgEntityWorkers: Failed to write task of type %d (result = %d, expected %d)\n", v13, v14, v15);
LABEL_31:
    if ( v8 )
      __debugbreak();
  }
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityScriptableEventLightUpdate>::Submit
==============
*/
void CgEntityWorkersOutputBuilder<CgEntityScriptableEventLightUpdate>::Submit(CgEntityWorkersOutputBuilder<CgEntityScriptableEventLightUpdate> *this)
{
  const dvar_t *v2; 
  __int64 v3; 
  unsigned int v5; 
  bool v9; 
  unsigned int v12; 
  unsigned int v13; 
  char *fmt; 
  __int64 v15; 
  __int64 v16; 
  int v17; 
  char data; 

  _RBX = this;
  if ( !Sys_IsMainThreadEntityWorker() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2405, ASSERT_TYPE_ASSERT, "(CG_EntityWorkers_WorkersCurrentlyActive())", (const char *)&queryFormat, "CG_EntityWorkers_WorkersCurrentlyActive()") )
    __debugbreak();
  if ( !_RBX->m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2407, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder must call Begin() before Submit()") )
    __debugbreak();
  if ( _RBX->m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2408, ASSERT_TYPE_ASSERT, "( !m_submitCalled )", "Entity Worker Output Builder called Submit() more than once") )
    __debugbreak();
  _RBX->m_submitCalled = 1;
  v2 = DCONST_DVARBOOL_cg_entityWorkersBufferedOutput;
  if ( !DCONST_DVARBOOL_cg_entityWorkersBufferedOutput && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkersBufferedOutput") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  if ( v2->current.enabled )
  {
    v3 = tls_index;
    if ( !*(_QWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1672i64) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2415, ASSERT_TYPE_ASSERT, "( s_threadLocalEntityOutput != nullptr )", "s_threadLocalEntityOutput was not set while processing entity workers") )
      __debugbreak();
    _RDI = *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + v3) + 1672i64);
    v5 = *(_DWORD *)(_RDI + 2048);
    if ( v5 + 25 <= 0x800 )
    {
      if ( v5 >= 0x800 )
      {
        LODWORD(v16) = 2048;
        LODWORD(v15) = *(_DWORD *)(_RDI + 2048);
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2422, ASSERT_TYPE_ASSERT, "(unsigned)( output.requestBufferCurSize ) < (unsigned)( ( sizeof( *array_counter( output.requestBuffer ) ) + 0 ) )", "output.requestBufferCurSize doesn't index output.requestBuffer\n\t%i not in [0, %i)", v15, v16) )
          __debugbreak();
      }
      *(_BYTE *)((unsigned int)(*(_DWORD *)(_RDI + 2048))++ + _RDI) = _RBX->m_requestType[0];
      if ( *(_DWORD *)(_RDI + 2048) >= 0x800u )
      {
        LODWORD(v16) = 2048;
        LODWORD(v15) = *(_DWORD *)(_RDI + 2048);
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2426, ASSERT_TYPE_ASSERT, "(unsigned)( output.requestBufferCurSize ) < (unsigned)( ( sizeof( *array_counter( output.requestBuffer ) ) + 0 ) )", "output.requestBufferCurSize doesn't index output.requestBuffer\n\t%i not in [0, %i)", v15, v16) )
          __debugbreak();
      }
      _RAX = *(unsigned int *)(_RDI + 2048);
      __asm
      {
        vmovups xmm0, xmmword ptr [rbx]
        vmovups xmmword ptr [rax+rdi], xmm0
        vmovsd  xmm1, qword ptr [rbx+10h]
        vmovsd  qword ptr [rax+rdi+10h], xmm1
      }
      *(_DWORD *)(_RDI + 2048) += 24;
      return;
    }
    Com_PrintError(14, "CgEntityWorkers: Failed to submit task (%d). Can't store %d more bytes.\n", (unsigned __int8)_RBX->m_requestType[0], 25i64);
    LODWORD(v16) = 25;
    LODWORD(v15) = (unsigned __int8)_RBX->m_requestType[0];
    v9 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2433, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "CgEntityWorkers: Failed to write task (%d). Can't store %d more bytes.", v15, v16);
    goto LABEL_31;
  }
  if ( !s_entityWorkers_outputStream && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2439, ASSERT_TYPE_ASSERT, "( s_entityWorkers_outputStream != nullptr )", "s_entityWorkers_outputStream was not set while processing entity workers") )
    __debugbreak();
  __asm
  {
    vmovups xmm0, xmmword ptr [rbx]
    vmovsd  xmm1, qword ptr [rbx+10h]
  }
  data = _RBX->m_requestType[0];
  __asm
  {
    vmovups [rsp+78h+var_37], xmm0
    vmovsd  [rsp+78h+var_27], xmm1
  }
  v12 = MpscStream<524288>::Write(s_entityWorkers_outputStream, &data, 25);
  v13 = v12;
  if ( v12 != 25 )
  {
    LODWORD(fmt) = 25;
    Com_PrintError(14, "CgEntityWorkers: Failed to write task of type %d (result = %d, expected %d)\n", (unsigned __int8)_RBX->m_requestType[0], v12, fmt);
    v17 = 25;
    LODWORD(v16) = v13;
    LODWORD(v15) = (unsigned __int8)_RBX->m_requestType[0];
    v9 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2451, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "CgEntityWorkers: Failed to write task of type %d (result = %d, expected %d)\n", v15, v16, v17);
LABEL_31:
    if ( v9 )
      __debugbreak();
  }
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityScriptableEventSunUpdate>::Submit
==============
*/
void CgEntityWorkersOutputBuilder<CgEntityScriptableEventSunUpdate>::Submit(CgEntityWorkersOutputBuilder<CgEntityScriptableEventSunUpdate> *this)
{
  const dvar_t *v2; 
  __int64 v3; 
  unsigned int v5; 
  bool v8; 
  unsigned int v10; 
  unsigned int v11; 
  char *fmt; 
  __int64 v13; 
  __int64 v14; 
  int v15; 
  char data; 

  _RDI = this;
  if ( !Sys_IsMainThreadEntityWorker() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2405, ASSERT_TYPE_ASSERT, "(CG_EntityWorkers_WorkersCurrentlyActive())", (const char *)&queryFormat, "CG_EntityWorkers_WorkersCurrentlyActive()") )
    __debugbreak();
  if ( !_RDI->m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2407, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder must call Begin() before Submit()") )
    __debugbreak();
  if ( _RDI->m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2408, ASSERT_TYPE_ASSERT, "( !m_submitCalled )", "Entity Worker Output Builder called Submit() more than once") )
    __debugbreak();
  _RDI->m_submitCalled = 1;
  v2 = DCONST_DVARBOOL_cg_entityWorkersBufferedOutput;
  if ( !DCONST_DVARBOOL_cg_entityWorkersBufferedOutput && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkersBufferedOutput") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  if ( v2->current.enabled )
  {
    v3 = tls_index;
    if ( !*(_QWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1672i64) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2415, ASSERT_TYPE_ASSERT, "( s_threadLocalEntityOutput != nullptr )", "s_threadLocalEntityOutput was not set while processing entity workers") )
      __debugbreak();
    _RBX = *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + v3) + 1672i64);
    v5 = *(_DWORD *)(_RBX + 2048);
    if ( v5 + 33 <= 0x800 )
    {
      if ( v5 >= 0x800 )
      {
        LODWORD(v14) = 2048;
        LODWORD(v13) = *(_DWORD *)(_RBX + 2048);
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2422, ASSERT_TYPE_ASSERT, "(unsigned)( output.requestBufferCurSize ) < (unsigned)( ( sizeof( *array_counter( output.requestBuffer ) ) + 0 ) )", "output.requestBufferCurSize doesn't index output.requestBuffer\n\t%i not in [0, %i)", v13, v14) )
          __debugbreak();
      }
      *(_BYTE *)((unsigned int)(*(_DWORD *)(_RBX + 2048))++ + _RBX) = _RDI->m_requestType[0];
      if ( *(_DWORD *)(_RBX + 2048) >= 0x800u )
      {
        LODWORD(v14) = 2048;
        LODWORD(v13) = *(_DWORD *)(_RBX + 2048);
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2426, ASSERT_TYPE_ASSERT, "(unsigned)( output.requestBufferCurSize ) < (unsigned)( ( sizeof( *array_counter( output.requestBuffer ) ) + 0 ) )", "output.requestBufferCurSize doesn't index output.requestBuffer\n\t%i not in [0, %i)", v13, v14) )
          __debugbreak();
      }
      _RAX = *(unsigned int *)(_RBX + 2048);
      __asm
      {
        vmovups ymm0, ymmword ptr [rdi]
        vmovups ymmword ptr [rax+rbx], ymm0
      }
      *(_DWORD *)(_RBX + 2048) += 32;
      return;
    }
    Com_PrintError(14, "CgEntityWorkers: Failed to submit task (%d). Can't store %d more bytes.\n", (unsigned __int8)_RDI->m_requestType[0], 33i64);
    LODWORD(v14) = 33;
    LODWORD(v13) = (unsigned __int8)_RDI->m_requestType[0];
    v8 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2433, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "CgEntityWorkers: Failed to write task (%d). Can't store %d more bytes.", v13, v14);
    goto LABEL_31;
  }
  if ( !s_entityWorkers_outputStream && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2439, ASSERT_TYPE_ASSERT, "( s_entityWorkers_outputStream != nullptr )", "s_entityWorkers_outputStream was not set while processing entity workers") )
    __debugbreak();
  __asm { vmovups ymm0, ymmword ptr [rdi] }
  data = _RDI->m_requestType[0];
  __asm { vmovups [rsp+78h+var_37], ymm0 }
  v10 = MpscStream<524288>::Write(s_entityWorkers_outputStream, &data, 33);
  v11 = v10;
  if ( v10 != 33 )
  {
    LODWORD(fmt) = 33;
    Com_PrintError(14, "CgEntityWorkers: Failed to write task of type %d (result = %d, expected %d)\n", (unsigned __int8)_RDI->m_requestType[0], v10, fmt);
    v15 = 33;
    LODWORD(v14) = v11;
    LODWORD(v13) = (unsigned __int8)_RDI->m_requestType[0];
    v8 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2451, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "CgEntityWorkers: Failed to write task of type %d (result = %d, expected %d)\n", v13, v14, v15);
LABEL_31:
    if ( v8 )
      __debugbreak();
  }
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityScriptableSpatialUpdate>::Submit
==============
*/
void CgEntityWorkersOutputBuilder<CgEntityScriptableSpatialUpdate>::Submit(CgEntityWorkersOutputBuilder<CgEntityScriptableSpatialUpdate> *this)
{
  const dvar_t *v2; 
  __int64 v3; 
  unsigned int v5; 
  bool v8; 
  unsigned int v10; 
  unsigned int v11; 
  char *fmt; 
  __int64 v13; 
  __int64 v14; 
  int v15; 
  char data; 
  unsigned int partitionIndex; 

  _RBX = this;
  if ( !Sys_IsMainThreadEntityWorker() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2405, ASSERT_TYPE_ASSERT, "(CG_EntityWorkers_WorkersCurrentlyActive())", (const char *)&queryFormat, "CG_EntityWorkers_WorkersCurrentlyActive()") )
    __debugbreak();
  if ( !_RBX->m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2407, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder must call Begin() before Submit()") )
    __debugbreak();
  if ( _RBX->m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2408, ASSERT_TYPE_ASSERT, "( !m_submitCalled )", "Entity Worker Output Builder called Submit() more than once") )
    __debugbreak();
  _RBX->m_submitCalled = 1;
  v2 = DCONST_DVARBOOL_cg_entityWorkersBufferedOutput;
  if ( !DCONST_DVARBOOL_cg_entityWorkersBufferedOutput && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkersBufferedOutput") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  if ( v2->current.enabled )
  {
    v3 = tls_index;
    if ( !*(_QWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1672i64) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2415, ASSERT_TYPE_ASSERT, "( s_threadLocalEntityOutput != nullptr )", "s_threadLocalEntityOutput was not set while processing entity workers") )
      __debugbreak();
    _RDI = *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + v3) + 1672i64);
    v5 = *(_DWORD *)(_RDI + 2048);
    if ( v5 + 13 <= 0x800 )
    {
      if ( v5 >= 0x800 )
      {
        LODWORD(v14) = 2048;
        LODWORD(v13) = *(_DWORD *)(_RDI + 2048);
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2422, ASSERT_TYPE_ASSERT, "(unsigned)( output.requestBufferCurSize ) < (unsigned)( ( sizeof( *array_counter( output.requestBuffer ) ) + 0 ) )", "output.requestBufferCurSize doesn't index output.requestBuffer\n\t%i not in [0, %i)", v13, v14) )
          __debugbreak();
      }
      *(_BYTE *)((unsigned int)(*(_DWORD *)(_RDI + 2048))++ + _RDI) = _RBX->m_requestType[0];
      if ( *(_DWORD *)(_RDI + 2048) >= 0x800u )
      {
        LODWORD(v14) = 2048;
        LODWORD(v13) = *(_DWORD *)(_RDI + 2048);
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2426, ASSERT_TYPE_ASSERT, "(unsigned)( output.requestBufferCurSize ) < (unsigned)( ( sizeof( *array_counter( output.requestBuffer ) ) + 0 ) )", "output.requestBufferCurSize doesn't index output.requestBuffer\n\t%i not in [0, %i)", v13, v14) )
          __debugbreak();
      }
      _RCX = *(unsigned int *)(_RDI + 2048);
      __asm
      {
        vmovsd  xmm0, qword ptr [rbx]
        vmovsd  qword ptr [rcx+rdi], xmm0
      }
      *(_DWORD *)(_RCX + _RDI + 8) = _RBX->m_requestPayload.partitionIndex;
      *(_DWORD *)(_RDI + 2048) += 12;
      return;
    }
    Com_PrintError(14, "CgEntityWorkers: Failed to submit task (%d). Can't store %d more bytes.\n", (unsigned __int8)_RBX->m_requestType[0], 13i64);
    LODWORD(v14) = 13;
    LODWORD(v13) = (unsigned __int8)_RBX->m_requestType[0];
    v8 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2433, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "CgEntityWorkers: Failed to write task (%d). Can't store %d more bytes.", v13, v14);
    goto LABEL_31;
  }
  if ( !s_entityWorkers_outputStream && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2439, ASSERT_TYPE_ASSERT, "( s_entityWorkers_outputStream != nullptr )", "s_entityWorkers_outputStream was not set while processing entity workers") )
    __debugbreak();
  __asm { vmovsd  xmm0, qword ptr [rbx] }
  data = _RBX->m_requestType[0];
  partitionIndex = _RBX->m_requestPayload.partitionIndex;
  __asm { vmovsd  [rsp+68h+var_27], xmm0 }
  v10 = MpscStream<524288>::Write(s_entityWorkers_outputStream, &data, 13);
  v11 = v10;
  if ( v10 != 13 )
  {
    LODWORD(fmt) = 13;
    Com_PrintError(14, "CgEntityWorkers: Failed to write task of type %d (result = %d, expected %d)\n", (unsigned __int8)_RBX->m_requestType[0], v10, fmt);
    v15 = 13;
    LODWORD(v14) = v11;
    LODWORD(v13) = (unsigned __int8)_RBX->m_requestType[0];
    v8 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2451, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "CgEntityWorkers: Failed to write task of type %d (result = %d, expected %d)\n", v13, v14, v15);
LABEL_31:
    if ( v8 )
      __debugbreak();
  }
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntitySoundRequest>::Submit
==============
*/
void CgEntityWorkersOutputBuilder<CgEntitySoundRequest>::Submit(CgEntityWorkersOutputBuilder<CgEntitySoundRequest> *this)
{
  const dvar_t *v2; 
  __int64 v3; 
  unsigned int v5; 
  bool v10; 
  char v12; 
  unsigned int v15; 
  unsigned int v16; 
  char *fmt; 
  __int64 v18; 
  __int64 v19; 
  int v20; 
  char data; 

  _RBX = this;
  if ( !Sys_IsMainThreadEntityWorker() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2405, ASSERT_TYPE_ASSERT, "(CG_EntityWorkers_WorkersCurrentlyActive())", (const char *)&queryFormat, "CG_EntityWorkers_WorkersCurrentlyActive()") )
    __debugbreak();
  if ( !_RBX->m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2407, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder must call Begin() before Submit()") )
    __debugbreak();
  if ( _RBX->m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2408, ASSERT_TYPE_ASSERT, "( !m_submitCalled )", "Entity Worker Output Builder called Submit() more than once") )
    __debugbreak();
  _RBX->m_submitCalled = 1;
  v2 = DCONST_DVARBOOL_cg_entityWorkersBufferedOutput;
  if ( !DCONST_DVARBOOL_cg_entityWorkersBufferedOutput && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkersBufferedOutput") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  if ( v2->current.enabled )
  {
    v3 = tls_index;
    if ( !*(_QWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1672i64) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2415, ASSERT_TYPE_ASSERT, "( s_threadLocalEntityOutput != nullptr )", "s_threadLocalEntityOutput was not set while processing entity workers") )
      __debugbreak();
    _RDI = *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + v3) + 1672i64);
    v5 = *(_DWORD *)(_RDI + 2048);
    if ( v5 + 57 <= 0x800 )
    {
      if ( v5 >= 0x800 )
      {
        LODWORD(v19) = 2048;
        LODWORD(v18) = *(_DWORD *)(_RDI + 2048);
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2422, ASSERT_TYPE_ASSERT, "(unsigned)( output.requestBufferCurSize ) < (unsigned)( ( sizeof( *array_counter( output.requestBuffer ) ) + 0 ) )", "output.requestBufferCurSize doesn't index output.requestBuffer\n\t%i not in [0, %i)", v18, v19) )
          __debugbreak();
      }
      *(_BYTE *)((unsigned int)(*(_DWORD *)(_RDI + 2048))++ + _RDI) = _RBX->m_requestType[0];
      if ( *(_DWORD *)(_RDI + 2048) >= 0x800u )
      {
        LODWORD(v19) = 2048;
        LODWORD(v18) = *(_DWORD *)(_RDI + 2048);
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2426, ASSERT_TYPE_ASSERT, "(unsigned)( output.requestBufferCurSize ) < (unsigned)( ( sizeof( *array_counter( output.requestBuffer ) ) + 0 ) )", "output.requestBufferCurSize doesn't index output.requestBuffer\n\t%i not in [0, %i)", v18, v19) )
          __debugbreak();
      }
      __asm { vmovups ymm0, ymmword ptr [rbx] }
      _RAX = *(unsigned int *)(_RDI + 2048);
      __asm
      {
        vmovups ymmword ptr [rax+rdi], ymm0
        vmovups xmm1, xmmword ptr [rbx+20h]
        vmovups xmmword ptr [rax+rdi+20h], xmm1
        vmovsd  xmm0, qword ptr [rbx+30h]
        vmovsd  qword ptr [rax+rdi+30h], xmm0
      }
      *(_DWORD *)(_RDI + 2048) += 56;
      return;
    }
    Com_PrintError(14, "CgEntityWorkers: Failed to submit task (%d). Can't store %d more bytes.\n", (unsigned __int8)_RBX->m_requestType[0], 57i64);
    LODWORD(v19) = 57;
    LODWORD(v18) = (unsigned __int8)_RBX->m_requestType[0];
    v10 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2433, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "CgEntityWorkers: Failed to write task (%d). Can't store %d more bytes.", v18, v19);
    goto LABEL_31;
  }
  if ( !s_entityWorkers_outputStream && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2439, ASSERT_TYPE_ASSERT, "( s_entityWorkers_outputStream != nullptr )", "s_entityWorkers_outputStream was not set while processing entity workers") )
    __debugbreak();
  __asm { vmovups ymm0, ymmword ptr [rbx] }
  v12 = _RBX->m_requestType[0];
  __asm
  {
    vmovups xmm1, xmmword ptr [rbx+20h]
    vmovups [rsp+98h+var_57], ymm0
    vmovsd  xmm0, qword ptr [rbx+30h]
    vmovsd  [rsp+98h+var_27], xmm0
  }
  data = v12;
  __asm { vmovups [rsp+98h+var_37], xmm1 }
  v15 = MpscStream<524288>::Write(s_entityWorkers_outputStream, &data, 57);
  v16 = v15;
  if ( v15 != 57 )
  {
    LODWORD(fmt) = 57;
    Com_PrintError(14, "CgEntityWorkers: Failed to write task of type %d (result = %d, expected %d)\n", (unsigned __int8)_RBX->m_requestType[0], v15, fmt);
    v20 = 57;
    LODWORD(v19) = v16;
    LODWORD(v18) = (unsigned __int8)_RBX->m_requestType[0];
    v10 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2451, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "CgEntityWorkers: Failed to write task of type %d (result = %d, expected %d)\n", v18, v19, v20);
LABEL_31:
    if ( v10 )
      __debugbreak();
  }
}

/*
==============
CgEntityWorkersOutputBuilder<CgEntityTurretBarrelSpinSoundRequest>::Submit
==============
*/
void CgEntityWorkersOutputBuilder<CgEntityTurretBarrelSpinSoundRequest>::Submit(CgEntityWorkersOutputBuilder<CgEntityTurretBarrelSpinSoundRequest> *this)
{
  const dvar_t *v2; 
  __int64 v3; 
  __int64 v4; 
  unsigned int v5; 
  bool v6; 
  unsigned int v7; 
  unsigned int v8; 
  char *fmt; 
  __int64 v10; 
  __int64 v11; 
  int v12; 
  char data; 
  unsigned int entIndex; 

  if ( !Sys_IsMainThreadEntityWorker() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2405, ASSERT_TYPE_ASSERT, "(CG_EntityWorkers_WorkersCurrentlyActive())", (const char *)&queryFormat, "CG_EntityWorkers_WorkersCurrentlyActive()") )
    __debugbreak();
  if ( !this->m_beginCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2407, ASSERT_TYPE_ASSERT, "( m_beginCalled )", "Entity Worker Output Builder must call Begin() before Submit()") )
    __debugbreak();
  if ( this->m_submitCalled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2408, ASSERT_TYPE_ASSERT, "( !m_submitCalled )", "Entity Worker Output Builder called Submit() more than once") )
    __debugbreak();
  this->m_submitCalled = 1;
  v2 = DCONST_DVARBOOL_cg_entityWorkersBufferedOutput;
  if ( !DCONST_DVARBOOL_cg_entityWorkersBufferedOutput && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_entityWorkersBufferedOutput") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  if ( v2->current.enabled )
  {
    v3 = tls_index;
    if ( !*(_QWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1672i64) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2415, ASSERT_TYPE_ASSERT, "( s_threadLocalEntityOutput != nullptr )", "s_threadLocalEntityOutput was not set while processing entity workers") )
      __debugbreak();
    v4 = *(_QWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + v3) + 1672i64);
    v5 = *(_DWORD *)(v4 + 2048);
    if ( v5 + 5 <= 0x800 )
    {
      if ( v5 >= 0x800 )
      {
        LODWORD(v11) = 2048;
        LODWORD(v10) = *(_DWORD *)(v4 + 2048);
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2422, ASSERT_TYPE_ASSERT, "(unsigned)( output.requestBufferCurSize ) < (unsigned)( ( sizeof( *array_counter( output.requestBuffer ) ) + 0 ) )", "output.requestBufferCurSize doesn't index output.requestBuffer\n\t%i not in [0, %i)", v10, v11) )
          __debugbreak();
      }
      *(_BYTE *)((unsigned int)(*(_DWORD *)(v4 + 2048))++ + v4) = this->m_requestType[0];
      if ( *(_DWORD *)(v4 + 2048) >= 0x800u )
      {
        LODWORD(v11) = 2048;
        LODWORD(v10) = *(_DWORD *)(v4 + 2048);
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2426, ASSERT_TYPE_ASSERT, "(unsigned)( output.requestBufferCurSize ) < (unsigned)( ( sizeof( *array_counter( output.requestBuffer ) ) + 0 ) )", "output.requestBufferCurSize doesn't index output.requestBuffer\n\t%i not in [0, %i)", v10, v11) )
          __debugbreak();
      }
      *(_DWORD *)(*(unsigned int *)(v4 + 2048) + v4) = this->m_requestPayload.entIndex;
      *(_DWORD *)(v4 + 2048) += 4;
      return;
    }
    Com_PrintError(14, "CgEntityWorkers: Failed to submit task (%d). Can't store %d more bytes.\n", (unsigned __int8)this->m_requestType[0], 5i64);
    LODWORD(v11) = 5;
    LODWORD(v10) = (unsigned __int8)this->m_requestType[0];
    v6 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2433, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "CgEntityWorkers: Failed to write task (%d). Can't store %d more bytes.", v10, v11);
    goto LABEL_31;
  }
  if ( !s_entityWorkers_outputStream && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2439, ASSERT_TYPE_ASSERT, "( s_entityWorkers_outputStream != nullptr )", "s_entityWorkers_outputStream was not set while processing entity workers") )
    __debugbreak();
  data = this->m_requestType[0];
  entIndex = this->m_requestPayload.entIndex;
  v7 = MpscStream<524288>::Write(s_entityWorkers_outputStream, &data, 5);
  v8 = v7;
  if ( v7 != 5 )
  {
    LODWORD(fmt) = 5;
    Com_PrintError(14, "CgEntityWorkers: Failed to write task of type %d (result = %d, expected %d)\n", (unsigned __int8)this->m_requestType[0], v7, fmt);
    v12 = 5;
    LODWORD(v11) = v8;
    LODWORD(v10) = (unsigned __int8)this->m_requestType[0];
    v6 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_entity_workers.cpp", 2451, ASSERT_TYPE_ASSERT, (const char *)&queryFormat.fmt + 3, "CgEntityWorkers: Failed to write task of type %d (result = %d, expected %d)\n", v10, v11, v12);
LABEL_31:
    if ( v6 )
      __debugbreak();
  }
}

