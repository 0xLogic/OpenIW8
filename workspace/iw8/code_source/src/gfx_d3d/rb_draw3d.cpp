/*
==============
RB_Draw2D_BeforePostFX
==============
*/

void __fastcall RB_Draw2D_BeforePostFX(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RB_Draw2D_BeforePostFX@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, viewInfo, data);
}

/*
==============
RB_Draw2D_Hud
==============
*/

void __fastcall RB_Draw2D_Hud(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RB_Draw2D_Hud@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, viewInfo, data);
}

/*
==============
R_Draw2D_BackupScopeReticle
==============
*/

void __fastcall R_Draw2D_BackupScopeReticle(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, const GfxImage *sceneSrc, const GfxImage *scopeBuffer)
{
  ?R_Draw2D_BackupScopeReticle@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@PEBUGfxImage@@3@Z(gfxContext, viewInfo, data, sceneSrc, scopeBuffer);
}

/*
==============
RB_DrawUmbraOverlays
==============
*/

void __fastcall RB_DrawUmbraOverlays(GfxCmdBufContext *gfxContext)
{
  ?RB_DrawUmbraOverlays@@YAXUGfxCmdBufContext@@@Z(gfxContext);
}

/*
==============
R_WaitSkippedDrawWorkerCmds
==============
*/

void __fastcall R_WaitSkippedDrawWorkerCmds(const GfxBackEndData *data)
{
  ?R_WaitSkippedDrawWorkerCmds@@YAXPEBUGfxBackEndData@@@Z(data);
}

/*
==============
RB_DecommitSpotShadowRTs
==============
*/

void __fastcall RB_DecommitSpotShadowRTs(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo)
{
  ?RB_DecommitSpotShadowRTs@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@@Z(gfxContext, viewInfo);
}

/*
==============
R_WaitDrawWorkerCmdsOfType
==============
*/

void __fastcall R_WaitDrawWorkerCmdsOfType(const GfxBackEndData *data, const GfxDrawListType drawListType)
{
  ?R_WaitDrawWorkerCmdsOfType@@YAXPEBUGfxBackEndData@@W4GfxDrawListType@@@Z(data, drawListType);
}

/*
==============
R_Draw2D_BeforePostFX_IsValid
==============
*/

bool __fastcall R_Draw2D_BeforePostFX_IsValid(const GfxViewInfo *viewInfo)
{
  return ?R_Draw2D_BeforePostFX_IsValid@@YA_NPEBUGfxViewInfo@@@Z(viewInfo);
}

/*
==============
R_SetPersistentTables
==============
*/

void __fastcall R_SetPersistentTables(GfxCmdBufContext *ctx, const GfxBackEndData *data, GfxPersistentDescriptorTables table)
{
  ?R_SetPersistentTables@@YAXAEAUGfxCmdBufContext@@PEBUGfxBackEndData@@W4GfxPersistentDescriptorTables@@@Z(ctx, data, table);
}

/*
==============
R_Draw2D_ReceivePostFXLite_IsValid
==============
*/

bool __fastcall R_Draw2D_ReceivePostFXLite_IsValid(const GfxViewInfo *viewInfo)
{
  return ?R_Draw2D_ReceivePostFXLite_IsValid@@YA_NPEBUGfxViewInfo@@@Z(viewInfo);
}

/*
==============
RB_UploadPackedLightData
==============
*/

void __fastcall RB_UploadPackedLightData(const GfxBackEndData *data, const GfxViewInfo *viewInfo)
{
  ?RB_UploadPackedLightData@@YAXPEBUGfxBackEndData@@PEBUGfxViewInfo@@@Z(data, viewInfo);
}

/*
==============
R_Draw2D_ReceivePostFXComposite_IsValid
==============
*/

bool __fastcall R_Draw2D_ReceivePostFXComposite_IsValid(const GfxViewInfo *viewInfo)
{
  return ?R_Draw2D_ReceivePostFXComposite_IsValid@@YA_NPEBUGfxViewInfo@@@Z(viewInfo);
}

/*
==============
R_UpdatePackedSceneLightConstants
==============
*/

void __fastcall R_UpdatePackedSceneLightConstants(GfxBackEndData *data, const GfxViewInfo *viewInfo)
{
  ?R_UpdatePackedSceneLightConstants@@YAXPEAUGfxBackEndData@@PEBUGfxViewInfo@@@Z(data, viewInfo);
}

/*
==============
RB_InitClient2DContext_ReceivePostFXLite
==============
*/

void __fastcall RB_InitClient2DContext_ReceivePostFXLite(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, R_RT_ColorHandle *sceneRt, const GfxImage *packedStencil, const GfxImage *scopeBuffer)
{
  ?RB_InitClient2DContext_ReceivePostFXLite@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@VR_RT_ColorHandle@@PEBUGfxImage@@4@Z(gfxContext, viewInfo, data, sceneRt, packedStencil, scopeBuffer);
}

/*
==============
RB_PreOpaque_MapMeshes
==============
*/

void __fastcall RB_PreOpaque_MapMeshes(const GfxBackEndData *data)
{
  ?RB_PreOpaque_MapMeshes@@YAXPEBUGfxBackEndData@@@Z(data);
}

/*
==============
R_UpdatePackedLightData
==============
*/

void __fastcall R_UpdatePackedLightData(GfxBackEndData *data, const GfxViewInfo *viewInfo)
{
  ?R_UpdatePackedLightData@@YAXPEAUGfxBackEndData@@PEBUGfxViewInfo@@@Z(data, viewInfo);
}

/*
==============
R_InitDrawCallOutput
==============
*/

void __fastcall R_InitDrawCallOutput(const GfxBackEndData *data, GfxDrawCallOutput *drawOutput)
{
  ?R_InitDrawCallOutput@@YAXPEBUGfxBackEndData@@PEAUGfxDrawCallOutput@@@Z(data, drawOutput);
}

/*
==============
R_PostLitResolve0_Active
==============
*/

bool __fastcall R_PostLitResolve0_Active(const GfxViewInfo *viewInfo)
{
  return ?R_PostLitResolve0_Active@@YA_NPEBUGfxViewInfo@@@Z(viewInfo);
}

/*
==============
R_ShowTris_Draw
==============
*/

void __fastcall R_ShowTris_Draw(const GfxViewInfo *viewInfo, const GfxBackEndData *data, const R_RT_Group *rtGroup, R_SHOW_TRIS showTris)
{
  ?R_ShowTris_Draw@@YAXPEBUGfxViewInfo@@PEBUGfxBackEndData@@PEBUR_RT_Group@@W4R_SHOW_TRIS@@@Z(viewInfo, data, rtGroup, showTris);
}

/*
==============
R_BlitDebugOverlay
==============
*/

void __fastcall R_BlitDebugOverlay(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, R_RT_ColorHandle *outputRt, R_RT_ColorHandle *debugOverlayRt)
{
  ?R_BlitDebugOverlay@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@VR_RT_ColorHandle@@2@Z(gfxContext, viewInfo, outputRt, debugOverlayRt);
}

/*
==============
RB_FinishComputeCmds
==============
*/

void __fastcall RB_FinishComputeCmds(GfxCmdBufContext *gfxContext, const GfxBackEndData *data)
{
  ?RB_FinishComputeCmds@@YAXUGfxCmdBufContext@@PEBUGfxBackEndData@@@Z(gfxContext, data);
}

/*
==============
R_DrawDebug3D_Enabled
==============
*/

bool __fastcall R_DrawDebug3D_Enabled(const GfxViewInfo *viewInfo)
{
  return ?R_DrawDebug3D_Enabled@@YA_NPEBUGfxViewInfo@@@Z(viewInfo);
}

/*
==============
R_ProfBeginDrawListImmediate
==============
*/

void __fastcall R_ProfBeginDrawListImmediate(const GfxDrawListType drawListType)
{
  ?R_ProfBeginDrawListImmediate@@YAXW4GfxDrawListType@@@Z(drawListType);
}

/*
==============
R_Draw2D_RestoreScopeReticle
==============
*/

void __fastcall R_Draw2D_RestoreScopeReticle(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, const GfxImage *sceneBackup, const GfxImage *scopeBuffer)
{
  ?R_Draw2D_RestoreScopeReticle@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@PEBUGfxImage@@3@Z(gfxContext, viewInfo, data, sceneBackup, scopeBuffer);
}

/*
==============
RB_StartDraw3DScene
==============
*/

void __fastcall RB_StartDraw3DScene(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RB_StartDraw3DScene@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, viewInfo, data);
}

/*
==============
RB_InitClient2DContext
==============
*/

void __fastcall RB_InitClient2DContext(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, R_RT_ColorHandle *colorRt, R_RT_Handle *packedStencil, const GfxImage *universalClut, const GfxImage *resolvedScene, const GfxWrappedBuffer *exposureBuffer)
{
  ?RB_InitClient2DContext@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@VR_RT_ColorHandle@@VR_RT_Handle@@PEBUGfxImage@@5PEBUGfxWrappedBuffer@@@Z(gfxContext, viewInfo, data, colorRt, packedStencil, universalClut, resolvedScene, exposureBuffer);
}

/*
==============
R_Draw2D_Hud
==============
*/

void __fastcall R_Draw2D_Hud(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, R_RT_ColorHandle *colorRt, R_RT_Handle *packedStencil, const GfxImage *universalClut, const GfxImage *resolvedScene, const GfxWrappedBuffer *exposureBuffer)
{
  ?R_Draw2D_Hud@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@VR_RT_ColorHandle@@VR_RT_Handle@@PEBUGfxImage@@5PEBUGfxWrappedBuffer@@@Z(gfxContext, viewInfo, data, colorRt, packedStencil, universalClut, resolvedScene, exposureBuffer);
}

/*
==============
R_DebugPrimitivesValid
==============
*/

bool __fastcall R_DebugPrimitivesValid()
{
  return ?R_DebugPrimitivesValid@@YA_NXZ();
}

/*
==============
RB_DisableMSEmissive
==============
*/

void __fastcall RB_DisableMSEmissive(GfxCmdBufContext *context, const GfxViewInfo *viewInfo)
{
  ?RB_DisableMSEmissive@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@@Z(context, viewInfo);
}

/*
==============
R_DrawDebugPrimitives
==============
*/

void __fastcall R_DrawDebugPrimitives(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo)
{
  ?R_DrawDebugPrimitives@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@@Z(gfxContext, viewInfo);
}

/*
==============
R_FontCache_DebugDisplay
==============
*/

void R_FontCache_DebugDisplay(void)
{
  ?R_FontCache_DebugDisplay@@YAXXZ();
}

/*
==============
R_HalfRes_Upsample
==============
*/

void __fastcall R_HalfRes_Upsample(GfxCmdBufContext *context, R_RT_Handle *halfResColor, R_RT_Handle *halfResAlpha, R_RT_Handle *halfResDepth, R_RT_Handle *fullResDepth, const GfxViewport *viewport)
{
  ?R_HalfRes_Upsample@@YAXUGfxCmdBufContext@@VR_RT_Handle@@111PEBUGfxViewport@@@Z(context, halfResColor, halfResAlpha, halfResDepth, fullResDepth, viewport);
}

/*
==============
RB_Draw3DScene
==============
*/

void __fastcall RB_Draw3DScene(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RB_Draw3DScene@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, viewInfo, data);
}

/*
==============
R_RunDrawListCommandBuffer
==============
*/

bool __fastcall R_RunDrawListCommandBuffer(const GfxBackEndData *data, const GfxDrawListType drawListType)
{
  return ?R_RunDrawListCommandBuffer@@YA_NPEBUGfxBackEndData@@W4GfxDrawListType@@@Z(data, drawListType);
}

/*
==============
R_UpdatePackedSpotShadowConstants
==============
*/

void __fastcall R_UpdatePackedSpotShadowConstants(GfxBackEndData *data, const GfxViewInfo *viewInfo)
{
  ?R_UpdatePackedSpotShadowConstants@@YAXPEAUGfxBackEndData@@PEBUGfxViewInfo@@@Z(data, viewInfo);
}

/*
==============
R_PostLitResolve1_Active
==============
*/

bool __fastcall R_PostLitResolve1_Active(const GfxViewInfo *viewInfo)
{
  return ?R_PostLitResolve1_Active@@YA_NPEBUGfxViewInfo@@@Z(viewInfo);
}

/*
==============
RB_DrawFogSplineOverlap_GetImage
==============
*/

const GfxImage *__fastcall RB_DrawFogSplineOverlap_GetImage(const GfxViewInfo *viewInfo, int fogSplineBlendIndex)
{
  return ?RB_DrawFogSplineOverlap_GetImage@@YAPEBUGfxImage@@PEBUGfxViewInfo@@H@Z(viewInfo, fogSplineBlendIndex);
}

/*
==============
R_Draw2D_ReceivePostFXLite
==============
*/

void __fastcall R_Draw2D_ReceivePostFXLite(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, R_RT_ColorHandle *sceneRt, const GfxImage *packedStencil, const GfxImage *scopeBuffer)
{
  ?R_Draw2D_ReceivePostFXLite@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@VR_RT_ColorHandle@@PEBUGfxImage@@4@Z(gfxContext, viewInfo, data, sceneRt, packedStencil, scopeBuffer);
}

/*
==============
RB_RunDrawList
==============
*/

void __fastcall RB_RunDrawList(const GfxViewInfo *viewInfo, const GfxBackEndData *data, const R_RT_Group *rtGroup, GfxDrawListType drawListID)
{
  ?RB_RunDrawList@@YAXPEBUGfxViewInfo@@PEBUGfxBackEndData@@PEBUR_RT_Group@@W4GfxDrawListType@@@Z(viewInfo, data, rtGroup, drawListID);
}

/*
==============
RB_ClearDepthForScopeStencil
==============
*/

void __fastcall RB_ClearDepthForScopeStencil(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RB_ClearDepthForScopeStencil@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, viewInfo, data);
}

/*
==============
RB_Draw3DScene_FreeRts
==============
*/

void RB_Draw3DScene_FreeRts(void)
{
  ?RB_Draw3DScene_FreeRts@@YAXXZ();
}

/*
==============
RB_DrawEmissive_MapMeshes
==============
*/

void __fastcall RB_DrawEmissive_MapMeshes(const GfxBackEndData *data)
{
  ?RB_DrawEmissive_MapMeshes@@YAXPEBUGfxBackEndData@@@Z(data);
}

/*
==============
R_ShowTris_GetShowTris
==============
*/

R_SHOW_TRIS __fastcall R_ShowTris_GetShowTris()
{
  return ?R_ShowTris_GetShowTris@@YA?AW4R_SHOW_TRIS@@XZ();
}

/*
==============
RB_Draw3DOverlays
==============
*/

void __fastcall RB_Draw3DOverlays(GfxCmdBufContext *gfxContext, const GfxBackEndData *data)
{
  ?RB_Draw3DOverlays@@YAXUGfxCmdBufContext@@PEBUGfxBackEndData@@@Z(gfxContext, data);
}

/*
==============
R_HalfRes_DownsampleDepth
==============
*/

void __fastcall R_HalfRes_DownsampleDepth(GfxCmdBufContext *context, R_RT_Handle *fullResDepth, const GfxViewport *viewport)
{
  ?R_HalfRes_DownsampleDepth@@YAXUGfxCmdBufContext@@VR_RT_Handle@@PEBUGfxViewport@@@Z(context, fullResDepth, viewport);
}

/*
==============
RB_AddComputeCmdsTransitions
==============
*/

void __fastcall RB_AddComputeCmdsTransitions(GfxCmdBufState *gfxState, const GfxBackEndData *data, bool begin)
{
  ?RB_AddComputeCmdsTransitions@@YAXPEAUGfxCmdBufState@@PEBUGfxBackEndData@@_N@Z(gfxState, data, begin);
}

/*
==============
RB_InitClient2D_RTT
==============
*/

void __fastcall RB_InitClient2D_RTT(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RB_InitClient2D_RTT@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, viewInfo, data);
}

/*
==============
R_Draw2D_BeforePostFX
==============
*/

void __fastcall R_Draw2D_BeforePostFX(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, R_RT_ColorHandle *sceneRt, R_RT_DepthHandle *depthRt, const GfxImage *universalClut)
{
  ?R_Draw2D_BeforePostFX@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@VR_RT_ColorHandle@@VR_RT_DepthHandle@@PEBUGfxImage@@@Z(gfxContext, viewInfo, data, sceneRt, depthRt, universalClut);
}

/*
==============
RB_DrawScreenshot2DHud
==============
*/

void __fastcall RB_DrawScreenshot2DHud(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, R_RT_Handle *packedStencil, const GfxImage *universalClut, const GfxImage *resolvedScene, const GfxWrappedBuffer *exposureBuffer)
{
  ?RB_DrawScreenshot2DHud@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@VR_RT_Handle@@PEBUGfxImage@@4PEBUGfxWrappedBuffer@@@Z(gfxContext, viewInfo, data, packedStencil, universalClut, resolvedScene, exposureBuffer);
}

/*
==============
R_Umbra_ShowOcclusion
==============
*/

void __fastcall R_Umbra_ShowOcclusion(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, const GfxImage *umbraFloatZ)
{
  ?R_Umbra_ShowOcclusion@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@PEBUGfxImage@@@Z(gfxContext, viewInfo, data, umbraFloatZ);
}

/*
==============
RB_PreOpaque_UnmapMeshes
==============
*/

void __fastcall RB_PreOpaque_UnmapMeshes(const GfxBackEndData *data)
{
  ?RB_PreOpaque_UnmapMeshes@@YAXPEBUGfxBackEndData@@@Z(data);
}

/*
==============
RB_InitClient2DContext_CopyScopeReticle
==============
*/

void __fastcall RB_InitClient2DContext_CopyScopeReticle(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RB_InitClient2DContext_CopyScopeReticle@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, viewInfo, data);
}

/*
==============
RB_InitClient2DReceivePPFXContext
==============
*/

void __fastcall RB_InitClient2DReceivePPFXContext(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, R_RT_ColorHandle *sceneRt, R_RT_DepthHandle *depthRt, const GfxImage *universalClut)
{
  ?RB_InitClient2DReceivePPFXContext@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@VR_RT_ColorHandle@@VR_RT_DepthHandle@@PEBUGfxImage@@@Z(gfxContext, viewInfo, data, sceneRt, depthRt, universalClut);
}

/*
==============
R_Draw2D_RTT
==============
*/

void __fastcall R_Draw2D_RTT(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?R_Draw2D_RTT@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, viewInfo, data);
}

/*
==============
R_Draw2D_RTT_Overlay
==============
*/

void __fastcall R_Draw2D_RTT_Overlay(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?R_Draw2D_RTT_Overlay@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, viewInfo, data);
}

/*
==============
RB_PerformVolumeLightScatter
==============
*/

void __fastcall RB_PerformVolumeLightScatter(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RB_PerformVolumeLightScatter@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, viewInfo, data);
}

/*
==============
R_Draw2D_ReceivePostFXComposite
==============
*/

void __fastcall R_Draw2D_ReceivePostFXComposite(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, R_RT_ColorHandle *sceneRt, const GfxImage *packedStencil, const GfxImage *scopeBuffer)
{
  ?R_Draw2D_ReceivePostFXComposite@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@VR_RT_ColorHandle@@PEBUGfxImage@@4@Z(gfxContext, viewInfo, data, sceneRt, packedStencil, scopeBuffer);
}

/*
==============
RB_UpdatePersistentTables
==============
*/

void __fastcall RB_UpdatePersistentTables(const GfxViewInfo *viewInfo, const GfxBackEndData *data, GfxPersistentDescriptorTables table)
{
  ?RB_UpdatePersistentTables@@YAXPEBUGfxViewInfo@@PEBUGfxBackEndData@@W4GfxPersistentDescriptorTables@@@Z(viewInfo, data, table);
}

/*
==============
R_WaveWaterFloatZ_Active
==============
*/

bool __fastcall R_WaveWaterFloatZ_Active(const GfxViewInfo *viewInfo)
{
  return ?R_WaveWaterFloatZ_Active@@YA_NPEBUGfxViewInfo@@@Z(viewInfo);
}

/*
==============
RB_DrawFogSplineOverlap
==============
*/

void __fastcall RB_DrawFogSplineOverlap(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, int drawFogSpline)
{
  ?RB_DrawFogSplineOverlap@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@H@Z(gfxContext, viewInfo, drawFogSpline);
}

/*
==============
RB_DrawEmissive_UnmapMeshes
==============
*/

void __fastcall RB_DrawEmissive_UnmapMeshes(const GfxBackEndData *data)
{
  ?RB_DrawEmissive_UnmapMeshes@@YAXPEBUGfxBackEndData@@@Z(data);
}

/*
==============
R_Shadow_DrawOverlay
==============
*/

void __fastcall R_Shadow_DrawOverlay(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, int overlayStyle, const R_RT_Handle *shadowCascades, unsigned int cascadeCount, const R_RT_Handle *viewmodelShadowCascade, const R_RT_ColorHandle *spotshadowsStaleCacheRt, const R_RT_DepthHandle *sunshadowCacheRt, R_RT_BufferHandle *compressedSunCascades, R_RT_BufferHandle *csmPrepass, const R_RT_ColorHandle *sunshadowTranslucentMask)
{
  ?R_Shadow_DrawOverlay@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@HPEBVR_RT_Handle@@IV3@VR_RT_ColorHandle@@VR_RT_DepthHandle@@PEAVR_RT_BufferHandle@@V6@4@Z(gfxContext, viewInfo, overlayStyle, shadowCascades, cascadeCount, viewmodelShadowCascade, spotshadowsStaleCacheRt, sunshadowCacheRt, compressedSunCascades, csmPrepass, sunshadowTranslucentMask);
}

/*
==============
R_ProfEndDrawListImmediate
==============
*/

void R_ProfEndDrawListImmediate(void)
{
  ?R_ProfEndDrawListImmediate@@YAXXZ();
}

/*
==============
RB_EnableMSEmissive
==============
*/

void __fastcall RB_EnableMSEmissive(GfxCmdBufContext *context, const GfxViewInfo *viewInfo)
{
  ?RB_EnableMSEmissive@@YAXUGfxCmdBufContext@@PEBUGfxViewInfo@@@Z(context, viewInfo);
}

/*
==============
RB_AddComputeCmdsTransitions
==============
*/
void RB_AddComputeCmdsTransitions(GfxCmdBufState *gfxState, const GfxBackEndData *data, bool begin)
{
  D3D12_RESOURCE_STATES v6; 
  const GfxWrappedRWBuffer *ClusterBuffer; 
  _BOOL8 v9; 
  _BOOL8 v10; 
  D3D12_RESOURCE_STATES v11; 
  D3D12_RESOURCE_STATES after; 
  const GfxWrappedBuffer *ReactiveMotionPivotsBuffer; 
  D3D12_RESOURCE_STATES before; 
  D3D12_RESOURCE_STATES v15[4]; 
  int v16; 
  D3D12_RESOURCE_STATES v17[4]; 
  D3D12_RESOURCE_STATES v18[2]; 

  if ( data->frameCount || (v6 = D3D12_RESOURCE_STATE_GENERIC_READ, !begin) )
    v6 = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
  __asm
  {
    vmovdqu xmm0, cs:__xmm@000000080000008100000008000000c0
    vmovdqu xmmword ptr [rsp+0A8h+var_74], xmm0
  }
  before = v6;
  v16 = 1;
  v17[0] = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
  v17[1] = D3D12_RESOURCE_STATE_PREDICATION|D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_INDEX_BUFFER;
  v17[2] = v6;
  v17[3] = D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER;
  v18[0] = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
  v18[1] = D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER;
  ClusterBuffer = R_ReflectionProbe_GetClusterBuffer();
  v9 = begin;
  v10 = !begin;
  R_HW_AddResourceTransition(gfxState, ClusterBuffer, 0xFFFFFFFF, v15[v10 - 1], v15[v9 - 1], D3D12_RESOURCE_BARRIER_FLAG_NONE);
  v11 = v15[v10 + 1];
  after = v15[v9 + 1];
  R_HW_AddResourceTransition(gfxState, &data->skinnedCacheVb->buffer, 0xFFFFFFFF, v11, after, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  R_HW_AddResourceTransition(gfxState, &data->subdivCacheVb->buffer, 0xFFFFFFFF, v11, after, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  R_HW_AddResourceTransition(gfxState, &data->subdivCacheVbPrevFrame->buffer, 0xFFFFFFFF, v11, after, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  R_HW_AddResourceTransition(gfxState, &data->skinnedCacheVbPrevFrame->buffer, 0xFFFFFFFF, v11, after, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  ReactiveMotionPivotsBuffer = R_GetReactiveMotionPivotsBuffer(data->reactiveMotionIndex);
  R_HW_AddResourceTransition(gfxState, ReactiveMotionPivotsBuffer, 0xFFFFFFFF, v11, after, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  R_HW_AddResourceTransition(gfxState, &data->tessFactorsBuffer->wrappedBuffer, 0xFFFFFFFF, v17[v10], v17[v9], D3D12_RESOURCE_BARRIER_FLAG_NONE);
  R_HW_AddResourceTransition(gfxState, &data->mayhemChannelsVb->buffer, 0xFFFFFFFF, v18[v10], v18[v9], D3D12_RESOURCE_BARRIER_FLAG_NONE);
}

/*
==============
RB_Async2D_ExecCmdBuf
==============
*/
bool RB_Async2D_ExecCmdBuf(GfxCmdBuf *cmdBuf, const bool renderFailed)
{
  bool result; 
  GfxDevice *device; 

  if ( cmdBuf->device )
  {
    if ( !renderFailed )
    {
      R_FlushImmediateContext();
      device = cmdBuf->device;
      ((void (__fastcall *)(ID3D12CommandQueue *, __int64, GfxDevice **))g_dx.immediateCommandQueue.commandQueue->m_pFunction[3].AddRef)(g_dx.immediateCommandQueue.commandQueue, 1i64, &device);
      result = 1;
      cmdBuf->device = NULL;
      return result;
    }
    cmdBuf->device = NULL;
  }
  return 0;
}

/*
==============
RB_Async2D_Finished
==============
*/
char RB_Async2D_Finished(void *userData)
{
  __int64 v1; 

  v1 = *(_QWORD *)userData;
  if ( !*(_QWORD *)userData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 2093, ASSERT_TYPE_ASSERT, "(data)", (const char *)&queryFormat, "data") )
    __debugbreak();
  if ( !*(_BYTE *)(v1 + 904193) )
    return 1;
  RB_CheckSkipRemoteScreenUpdate();
  return 0;
}

/*
==============
RB_Async2D_ReceivePPFXFinished
==============
*/
char RB_Async2D_ReceivePPFXFinished(void *userData)
{
  __int64 v1; 

  v1 = *(_QWORD *)userData;
  if ( !*(_QWORD *)userData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 2077, ASSERT_TYPE_ASSERT, "(data)", (const char *)&queryFormat, "data") )
    __debugbreak();
  if ( !*(_BYTE *)(v1 + 904194) )
    return 1;
  RB_CheckSkipRemoteScreenUpdate();
  return 0;
}

/*
==============
RB_BlitDebugOverlay
==============
*/

void __fastcall RB_BlitDebugOverlay(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, double _XMM2_8, double _XMM3_8)
{
  bool v13; 
  GfxCmdBufSourceState *source; 
  const char *m_location; 
  GfxCmdBufState *state; 
  unsigned int height; 
  const R_RT_Surface *Surface; 
  R_RT_Image *p_m_image; 
  __int64 v43; 
  float fmt; 
  float v53; 
  float v54; 
  float v55; 
  float v56; 
  float v57; 
  float v58; 
  float v59; 
  R_RT_Handle v60; 
  R_RT_Handle v61; 
  R_RT_Handle result; 
  R_RT_Group v63; 
  GfxViewport viewport[2]; 
  R_RT_Group v65; 

  _RDI = &viewInfo->debugOverlay;
  _R14 = gfxContext;
  _R13 = viewInfo;
  if ( R_RT_Handle::IsValid(&viewInfo->debugOverlay) )
  {
    __asm
    {
      vmovups ymm0, ymmword ptr [rdi]
      vmovaps [rsp+2E0h+var_40], xmm6
      vmovups ymmword ptr [rbp+1E0h+var_250.m_surfaceID], ymm0
    }
    _RAX = R_RT_GetGlobal(&result, R_RENDERTARGET_DISPLAY_BUFFER);
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovd   eax, xmm0
      vmovups ymmword ptr [rbp+1E0h+viewport.x], ymm0
      vmovups ymmword ptr [rsp+2E0h+var_270.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v60);
      if ( (R_RT_Handle::GetSurface(&v60)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm { vmovups ymm0, ymmword ptr [rsp+2E0h+var_270.m_surfaceID] }
        __debugbreak();
      }
      else
      {
        __asm { vmovups ymm0, ymmword ptr [rsp+2E0h+var_270.m_surfaceID] }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v13 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        __asm { vmovups ymm0, ymmword ptr [rbp+1E0h+viewport.x] }
        if ( v13 )
          __debugbreak();
      }
    }
    __asm { vmovups ymmword ptr [rsp+2E0h+var_270.m_surfaceID], ymm0 }
    R_RT_Group::AssignColor(&v63, (R_RT_ColorHandle *)&v60);
    source = _R14->source;
    _RCX = &v65;
    _RAX = &v63;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovups ymm1, ymmword ptr [rax+80h]
      vmovups ymmword ptr [rcx], ymm0
      vmovups ymm0, ymmword ptr [rax+20h]
      vmovups ymmword ptr [rcx+20h], ymm0
      vmovups ymm0, ymmword ptr [rax+40h]
      vmovups ymmword ptr [rcx+40h], ymm0
      vmovups ymm0, ymmword ptr [rax+60h]
      vmovups ymmword ptr [rcx+60h], ymm0
      vmovups ymmword ptr [rcx+80h], ymm1
      vmovups ymm1, ymmword ptr [rax+0A0h]
    }
    m_location = v63.m_vrsRt.m_tracking.m_location;
    __asm { vmovups ymmword ptr [rcx+0A0h], ymm1 }
    v65.m_vrsRt.m_tracking.m_location = m_location;
    R_InitCmdBufSourceState(source, &_R13->input);
    state = _R14->state;
    R_InitLocalCmdBufState(state, &source->input);
    R_ProfBeginNamedEvent(state, "Debug Overlay");
    _RAX = R_RT_Group::GetValidRt(&v65, &result);
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovups ymmword ptr [rsp+2E0h+var_270.m_surfaceID], ymm0
    }
    height = R_RT_Handle::GetSurface(&v60)->m_image.m_base.height;
    Surface = R_RT_Handle::GetSurface(&v60);
    R_SetRenderTargetSize(source, Surface->m_image.m_base.width, height, GFX_USE_VIEWPORT_FOR_VIEW);
    R_BeginViewInternal(source, &_R13->sceneDef, (const GfxViewParms *)_R13, &_R13->viewParmsSet.frames[1].viewParms);
    __asm
    {
      vmovups xmm0, xmmword ptr [r14]
      vmovups xmmword ptr [rbp+1E0h+viewport.x], xmm0
    }
    R_SetRenderTargetsInternal((GfxCmdBufContext *)viewport, &v65, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1052)");
    __asm
    {
      vmovups ymm0, ymmword ptr [rbp+1E0h+var_250.m_surfaceID]
      vmovups xmm6, xmmword ptr [r14]
      vmovups ymmword ptr [rbp+1E0h+var_250.m_surfaceID], ymm0
      vmovups xmm0, xmmword ptr [r13+4B0h]
      vmovq   rbx, xmm6
      vmovups xmmword ptr [rbp+1E0h+viewport.x], xmm0
    }
    R_SetViewportStruct((GfxCmdBufSourceState *)_RBX, viewport);
    R_Set2D((GfxCmdBufSourceState *)_RBX);
    __asm
    {
      vmovss  xmm0, dword ptr cs:?colorWhite@@3Tvec4_t@@B; vec4_t const colorWhite
      vmovss  dword ptr [rbx+0AB0h], xmm0
      vmovss  xmm1, dword ptr cs:?colorWhite@@3Tvec4_t@@B+4; vec4_t const colorWhite
      vmovss  dword ptr [rbx+0AB4h], xmm1
      vmovss  xmm0, dword ptr cs:?colorWhite@@3Tvec4_t@@B+8; vec4_t const colorWhite
      vmovss  dword ptr [rbx+0AB8h], xmm0
      vmovss  xmm1, dword ptr cs:?colorWhite@@3Tvec4_t@@B+0Ch; vec4_t const colorWhite
      vmovss  dword ptr [rbx+0ABCh], xmm1
    }
    ++*(_WORD *)(_RBX + 10282);
    __asm
    {
      vmovss  xmm0, dword ptr cs:?colorBlackBlank@@3Tvec4_t@@B; vec4_t const colorBlackBlank
      vmovss  dword ptr [rbx+0AC0h], xmm0
      vmovss  xmm1, dword ptr cs:?colorBlackBlank@@3Tvec4_t@@B+4; vec4_t const colorBlackBlank
      vmovss  dword ptr [rbx+0AC4h], xmm1
      vmovss  xmm0, dword ptr cs:?colorBlackBlank@@3Tvec4_t@@B+8; vec4_t const colorBlackBlank
      vmovss  dword ptr [rbx+0AC8h], xmm0
      vmovss  xmm1, dword ptr cs:?colorBlackBlank@@3Tvec4_t@@B+0Ch; vec4_t const colorBlackBlank
      vmovss  dword ptr [rbx+0ACCh], xmm1
    }
    ++*(_WORD *)(_RBX + 10284);
    *(_QWORD *)(_RBX + 2772) = 2139095039i64;
    *(_DWORD *)(_RBX + 2768) = 0;
    *(_DWORD *)(_RBX + 2780) = 0;
    ++*(_WORD *)(_RBX + 10286);
    p_m_image = &R_RT_Handle::GetSurface(&v61)->m_image;
    v43 = _RBX + 1792;
    if ( !v43 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
      __debugbreak();
    __asm
    {
      vmovss  xmm0, cs:__real@3f800000
      vxorps  xmm1, xmm1, xmm1
      vxorps  xmm3, xmm3, xmm3
      vcvtsi2ss xmm3, xmm3, rax
      vxorps  xmm2, xmm2, xmm2
      vcvtsi2ss xmm2, xmm2, rax
    }
    *(_QWORD *)(v43 + 6176) = p_m_image;
    __asm
    {
      vmovss  [rsp+2E0h+var_288], xmm0
      vmovss  [rsp+2E0h+var_290], xmm0
      vmovss  [rsp+2E0h+var_298], xmm1
      vmovss  [rsp+2E0h+var_2A0], xmm1
      vmovss  [rsp+2E0h+var_2A8], xmm3
      vmovss  [rsp+2E0h+var_2B0], xmm2
      vmovss  dword ptr [rsp+2E0h+var_2B8], xmm1
      vmovss  dword ptr [rsp+2E0h+fmt], xmm1
      vmovdqa xmmword ptr [rsp+2E0h+var_270.m_surfaceID], xmm6
    }
    RB_ViewportFilterDirectInternal((GfxCmdBufContext *)&v60, rgp.feedbackBlendBackbufferMaterial, 0xFFFFFFFF, viewport, fmt, v53, v54, v55, v56, v57, v58, v59, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1032)");
    R_ProfEndNamedEvent(state);
    R_ShutdownLocalCmdBufState(state, &source->input);
    __asm
    {
      vmovups ymm0, ymmword ptr [rdi]
      vmovups ymmword ptr [rbp+1E0h+var_250.m_surfaceID], ymm0
      vmovups xmmword ptr [rsp+2E0h+var_270.m_surfaceID], xmm6
    }
    R_RT_Destroy((GfxCmdBufContext *)&v60, (R_RT_ColorHandle *)&v61);
    __asm { vmovaps xmm6, [rsp+2E0h+var_40] }
    _RDI->m_surfaceID = 0;
    _RDI->m_tracking.m_allocCounter = 0;
    _RDI->m_tracking.m_name = NULL;
    _RDI->m_tracking.m_location = NULL;
  }
}

/*
==============
RB_ClearDepthForScopeStencil
==============
*/
void RB_ClearDepthForScopeStencil(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  bool v8; 
  GfxCmdBufSourceState *source; 
  GfxCmdBufState *state; 
  const GfxViewport *p_sceneViewport; 
  unsigned int height; 
  const R_RT_Surface *Surface; 
  float v26; 
  float v27; 
  float v28; 
  float v29; 
  float v30; 
  float v31; 
  float v32; 
  float v33; 
  R_RT_Handle v34; 
  R_RT_DepthHandle v35; 
  R_RT_ColorHandle v36; 

  _RBX = viewInfo;
  _R15 = gfxContext;
  if ( data->scope.scopeUseDualFov )
  {
    v8 = !data->scope.adsSmoothFade;
    __asm
    {
      vmovaps [rsp+0F8h+var_28], xmm6
      vxorps  xmm6, xmm6, xmm6
    }
    if ( !v8 )
      __asm { vucomiss xmm6, dword ptr [r8+75A870h] }
    source = gfxContext->source;
    R_InitCmdBufSourceState(gfxContext->source, &viewInfo->input);
    state = _R15->state;
    R_InitLocalCmdBufState(state, &source->input);
    R_ProfBeginNamedEvent(state, "Scope Depth Clear");
    R_BeginViewInternal(source, &_RBX->sceneDef, (const GfxViewParms *)_RBX, &_RBX->viewParmsSet.frames[1].viewParms);
    p_sceneViewport = &_RBX->sceneViewport;
    R_SetViewportStruct(source, &_RBX->sceneViewport);
    __asm
    {
      vmovups ymm0, ymmword ptr [rbx+31A0h]
      vmovups ymm1, ymmword ptr [rbx+3140h]
      vmovups [rsp+0F8h+var_68], ymm0
      vmovups xmm0, xmmword ptr [r15]
      vmovups xmmword ptr [rsp+0F8h+var_88.m_surfaceID], xmm0
      vmovups [rsp+0F8h+var_48], ymm1
    }
    R_SetRenderTargetsInternal_ColorDepth((GfxCmdBufContext *)&v34, &v36, &v35, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(5500)");
    __asm
    {
      vmovups ymm0, ymmword ptr [rbx+30C0h]
      vmovups ymmword ptr [rsp+0F8h+var_88.m_surfaceID], ymm0
    }
    height = R_RT_Handle::GetSurface(&v34)->m_image.m_base.height;
    Surface = R_RT_Handle::GetSurface(&v34);
    R_SetRenderTargetSize(source, Surface->m_image.m_base.width, height, GFX_USE_VIEWPORT_FOR_VIEW);
    __asm
    {
      vmovups xmm0, xmmword ptr [r15]
      vxorps  xmm2, xmm2, xmm2
      vcvtsi2ss xmm2, xmm2, rax
      vxorps  xmm1, xmm1, xmm1
      vcvtsi2ss xmm1, xmm1, rax
      vmovups xmmword ptr [rsp+0F8h+var_88.m_surfaceID], xmm0
      vmovss  xmm0, cs:__real@3f800000
      vmovss  [rsp+0F8h+var_A0], xmm0
      vmovss  [rsp+0F8h+var_A8], xmm0
      vmovss  [rsp+0F8h+var_B0], xmm6
      vmovss  [rsp+0F8h+var_B8], xmm6
      vmovss  [rsp+0F8h+var_C0], xmm2
      vmovss  [rsp+0F8h+var_C8], xmm1
      vmovss  [rsp+0F8h+var_D0], xmm6
      vmovss  [rsp+0F8h+var_D8], xmm6
    }
    RB_ViewportFilterDirectInternal((GfxCmdBufContext *)&v34, rgp.scopeUIDepthClear, 0xFFFFFFFF, p_sceneViewport, v26, v27, v28, v29, v30, v31, v32, v33, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(5504)");
    R_ProfEndNamedEvent(state);
    R_ShutdownLocalCmdBufState(state, &source->input);
    __asm { vmovaps xmm6, [rsp+0F8h+var_28] }
  }
}

/*
==============
RB_DecommitEmissiveRTs
==============
*/
void RB_DecommitEmissiveRTs(GfxCmdBufContext *gfxContext, const GfxBackEndData *data, const GfxViewInfo *viewInfo)
{
  GfxCmdBufContext v21; 
  R_RT_ColorHandle v22; 

  _RBX = viewInfo;
  _RDI = gfxContext;
  R_LockGfxImmediateContext();
  if ( rg.vrsEmissiveOnly )
  {
    __asm
    {
      vmovups ymm0, ymmword ptr [rbx+31C0h]
      vmovups xmm1, xmmword ptr [rdi]
      vmovups [rbp+var_20], ymm0
      vmovups [rbp+var_30], xmm1
    }
    R_RT_Destroy(&v21, &v22);
    __asm { vmovups xmm1, xmmword ptr [rdi] }
    _RBX->sceneRtInput.m_msaaSceneColorRt.m_surfaceID = 0;
    _RBX->sceneRtInput.m_msaaSceneColorRt.m_tracking.m_allocCounter = 0;
    _RBX->sceneRtInput.m_msaaSceneColorRt.m_tracking.m_name = NULL;
    _RBX->sceneRtInput.m_msaaSceneColorRt.m_tracking.m_location = NULL;
    __asm
    {
      vmovups ymm0, ymmword ptr [rbx+31E0h]
      vmovups [rbp+var_20], ymm0
      vmovups [rbp+var_30], xmm1
    }
    R_RT_Destroy(&v21, &v22);
    __asm { vmovups xmm1, xmmword ptr [rdi] }
    _RBX->sceneRtInput.m_msaaSceneAlphaRt.m_surfaceID = 0;
    _RBX->sceneRtInput.m_msaaSceneAlphaRt.m_tracking.m_allocCounter = 0;
    _RBX->sceneRtInput.m_msaaSceneAlphaRt.m_tracking.m_name = NULL;
    _RBX->sceneRtInput.m_msaaSceneAlphaRt.m_tracking.m_location = NULL;
    __asm
    {
      vmovups ymm0, ymmword ptr [rbx+3200h]
      vmovups [rbp+var_20], ymm0
      vmovups [rbp+var_30], xmm1
    }
    R_RT_Destroy(&v21, (R_RT_DepthHandle *)&v22);
    _RBX->sceneRtInput.m_msaaSceneDepthRt.m_surfaceID = 0;
    _RBX->sceneRtInput.m_msaaSceneDepthRt.m_tracking.m_allocCounter = 0;
    _RBX->sceneRtInput.m_msaaSceneDepthRt.m_tracking.m_name = NULL;
    _RBX->sceneRtInput.m_msaaSceneDepthRt.m_tracking.m_location = NULL;
  }
  if ( rg.halfResEmissive )
  {
    __asm
    {
      vmovups ymm0, ymmword ptr [rbx+3220h]
      vmovups xmm1, xmmword ptr [rdi]
      vmovups [rbp+var_20], ymm0
      vmovups [rbp+var_30], xmm1
    }
    R_RT_Destroy(&v21, &v22);
    __asm { vmovups xmm1, xmmword ptr [rdi] }
    _RBX->sceneRtInput.m_halfSceneColorRt.m_surfaceID = 0;
    _RBX->sceneRtInput.m_halfSceneColorRt.m_tracking.m_allocCounter = 0;
    _RBX->sceneRtInput.m_halfSceneColorRt.m_tracking.m_name = NULL;
    _RBX->sceneRtInput.m_halfSceneColorRt.m_tracking.m_location = NULL;
    __asm
    {
      vmovups ymm0, ymmword ptr [rbx+3240h]
      vmovups [rbp+var_20], ymm0
      vmovups [rbp+var_30], xmm1
    }
    R_RT_Destroy(&v21, &v22);
    __asm { vmovups xmm1, xmmword ptr [rdi] }
    _RBX->sceneRtInput.m_halfSceneAlphaRt.m_surfaceID = 0;
    _RBX->sceneRtInput.m_halfSceneAlphaRt.m_tracking.m_allocCounter = 0;
    _RBX->sceneRtInput.m_halfSceneAlphaRt.m_tracking.m_name = NULL;
    _RBX->sceneRtInput.m_halfSceneAlphaRt.m_tracking.m_location = NULL;
    __asm
    {
      vmovups ymm0, ymmword ptr [rbx+3260h]
      vmovups [rbp+var_20], ymm0
      vmovups [rbp+var_30], xmm1
    }
    R_RT_Destroy(&v21, (R_RT_DepthHandle *)&v22);
    _RBX->sceneRtInput.m_halfSceneDepthRt.m_surfaceID = 0;
    _RBX->sceneRtInput.m_halfSceneDepthRt.m_tracking.m_allocCounter = 0;
    _RBX->sceneRtInput.m_halfSceneDepthRt.m_tracking.m_name = NULL;
    _RBX->sceneRtInput.m_halfSceneDepthRt.m_tracking.m_location = NULL;
  }
  if ( rg.debugTextureOverlay != 11 )
  {
    __asm
    {
      vmovups ymm0, ymmword ptr [rbx+3428h]
      vmovups xmm1, xmmword ptr [rdi]
      vmovups [rbp+var_20], ymm0
      vmovups [rbp+var_30], xmm1
    }
    R_RT_Destroy(&v21, &v22);
    _RBX->sceneRtInput.m_ssrRt.m_surfaceID = 0;
    _RBX->sceneRtInput.m_ssrRt.m_tracking.m_allocCounter = 0;
    _RBX->sceneRtInput.m_ssrRt.m_tracking.m_name = NULL;
    _RBX->sceneRtInput.m_ssrRt.m_tracking.m_location = NULL;
  }
  __asm
  {
    vmovups ymm0, ymmword ptr [rbx+3448h]
    vmovups xmm1, xmmword ptr [rdi]
    vmovups [rbp+var_20], ymm0
    vmovups [rbp+var_30], xmm1
  }
  R_RT_Destroy(&v21, &v22);
  _RBX->sceneRtInput.m_ssrMaskRt.m_surfaceID = 0;
  _RBX->sceneRtInput.m_ssrMaskRt.m_tracking.m_allocCounter = 0;
  _RBX->sceneRtInput.m_ssrMaskRt.m_tracking.m_name = NULL;
  _RBX->sceneRtInput.m_ssrMaskRt.m_tracking.m_location = NULL;
  R_FlushImmediateContext();
  R_UnlockGfxImmediateContext();
}

/*
==============
RB_DecommitSceneRTs
==============
*/
void RB_DecommitSceneRTs(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo)
{
  unsigned int debugTextureOverlay; 
  GfxCmdBufContext v27; 
  R_RT_ColorHandle v28; 

  _RBX = viewInfo;
  _RDI = gfxContext;
  R_LockGfxImmediateContext();
  __asm
  {
    vmovups xmm0, xmmword ptr [rdi]
    vmovups [rbp+var_30], xmm0
  }
  RB_ReProjFloatZ_RotateRTs(&v27, _RBX);
  __asm
  {
    vmovups ymm0, ymmword ptr [rbx+33A0h]
    vmovups xmm1, xmmword ptr [rdi]
    vmovups [rbp+var_20], ymm0
    vmovups [rbp+var_30], xmm1
  }
  R_RT_Destroy(&v27, &v28);
  __asm { vmovups xmm1, xmmword ptr [rdi] }
  _RBX->sceneRtInput.m_waterFloatZRt.m_surfaceID = 0;
  _RBX->sceneRtInput.m_waterFloatZRt.m_tracking.m_allocCounter = 0;
  _RBX->sceneRtInput.m_waterFloatZRt.m_tracking.m_name = NULL;
  _RBX->sceneRtInput.m_waterFloatZRt.m_tracking.m_location = NULL;
  __asm
  {
    vmovups ymm0, ymmword ptr [rbx+3140h]
    vmovups [rbp+var_20], ymm0
    vmovups [rbp+var_30], xmm1
  }
  R_RT_Destroy(&v27, &v28);
  __asm { vmovups xmm1, xmmword ptr [rdi] }
  _RBX->sceneRtInput.m_mainSceneEntityIDVelocityRt.m_surfaceID = 0;
  _RBX->sceneRtInput.m_mainSceneEntityIDVelocityRt.m_tracking.m_allocCounter = 0;
  _RBX->sceneRtInput.m_mainSceneEntityIDVelocityRt.m_tracking.m_name = NULL;
  _RBX->sceneRtInput.m_mainSceneEntityIDVelocityRt.m_tracking.m_location = NULL;
  __asm
  {
    vmovups ymm0, ymmword ptr [rbx+3160h]
    vmovups [rbp+var_20], ymm0
    vmovups [rbp+var_30], xmm1
  }
  R_RT_Destroy(&v27, &v28);
  __asm { vmovups xmm1, xmmword ptr [rdi] }
  _RBX->sceneRtInput.m_mainSceneTangentFrameRt.m_surfaceID = 0;
  _RBX->sceneRtInput.m_mainSceneTangentFrameRt.m_tracking.m_allocCounter = 0;
  _RBX->sceneRtInput.m_mainSceneTangentFrameRt.m_tracking.m_name = NULL;
  _RBX->sceneRtInput.m_mainSceneTangentFrameRt.m_tracking.m_location = NULL;
  __asm
  {
    vmovups ymm0, ymmword ptr [rbx+30C0h]
    vmovups [rbp+var_20], ymm0
    vmovups [rbp+var_30], xmm1
  }
  R_RT_Destroy(&v27, &v28);
  __asm { vmovups xmm1, xmmword ptr [rdi] }
  _RBX->sceneRtInput.m_mainSceneColorRt.m_surfaceID = 0;
  _RBX->sceneRtInput.m_mainSceneColorRt.m_tracking.m_allocCounter = 0;
  _RBX->sceneRtInput.m_mainSceneColorRt.m_tracking.m_name = NULL;
  _RBX->sceneRtInput.m_mainSceneColorRt.m_tracking.m_location = NULL;
  __asm
  {
    vmovups ymm0, ymmword ptr [rbx+30E0h]
    vmovups [rbp+var_20], ymm0
    vmovups [rbp+var_30], xmm1
  }
  R_RT_Destroy(&v27, &v28);
  __asm { vmovups xmm1, xmmword ptr [rdi] }
  _RBX->sceneRtInput.m_mainSceneAlphaRt.m_surfaceID = 0;
  _RBX->sceneRtInput.m_mainSceneAlphaRt.m_tracking.m_allocCounter = 0;
  _RBX->sceneRtInput.m_mainSceneAlphaRt.m_tracking.m_name = NULL;
  _RBX->sceneRtInput.m_mainSceneAlphaRt.m_tracking.m_location = NULL;
  __asm
  {
    vmovups ymm0, ymmword ptr [rbx+3180h]
    vmovups [rbp+var_20], ymm0
    vmovups [rbp+var_30], xmm1
  }
  R_RT_Destroy(&v27, &v28);
  __asm { vmovups xmm1, xmmword ptr [rdi] }
  _RBX->sceneRtInput.m_mainSceneOverdrawRt.m_surfaceID = 0;
  _RBX->sceneRtInput.m_mainSceneOverdrawRt.m_tracking.m_allocCounter = 0;
  _RBX->sceneRtInput.m_mainSceneOverdrawRt.m_tracking.m_name = NULL;
  _RBX->sceneRtInput.m_mainSceneOverdrawRt.m_tracking.m_location = NULL;
  __asm
  {
    vmovups ymm0, ymmword ptr [rbx+3648h]
    vmovups [rbp+var_20], ymm0
    vmovups [rbp+var_30], xmm1
  }
  R_RT_Destroy(&v27, &v28);
  __asm { vmovups xmm1, xmmword ptr [rdi] }
  _RBX->sceneRtInput.m_halfVelocityMBlurRt.m_surfaceID = 0;
  _RBX->sceneRtInput.m_halfVelocityMBlurRt.m_tracking.m_allocCounter = 0;
  _RBX->sceneRtInput.m_halfVelocityMBlurRt.m_tracking.m_name = NULL;
  _RBX->sceneRtInput.m_halfVelocityMBlurRt.m_tracking.m_location = NULL;
  __asm
  {
    vmovups ymm0, ymmword ptr [rbx+3668h]
    vmovups [rbp+var_20], ymm0
    vmovups [rbp+var_30], xmm1
  }
  R_RT_Destroy(&v27, &v28);
  _RBX->sceneRtInput.m_dofTile0Handle.m_surfaceID = 0;
  _RBX->sceneRtInput.m_dofTile0Handle.m_tracking.m_allocCounter = 0;
  _RBX->sceneRtInput.m_dofTile0Handle.m_tracking.m_name = NULL;
  _RBX->sceneRtInput.m_dofTile0Handle.m_tracking.m_location = NULL;
  debugTextureOverlay = rg.debugTextureOverlay;
  if ( rg.debugTextureOverlay == 10 )
  {
    __asm
    {
      vmovups xmm0, xmmword ptr [rdi]
      vmovups [rbp+var_30], xmm0
    }
    RB_SSAO_DecommitRTs(&v27, _RBX);
    debugTextureOverlay = rg.debugTextureOverlay;
  }
  if ( debugTextureOverlay == 11 )
  {
    __asm
    {
      vmovups ymm0, ymmword ptr [rbx+3428h]
      vmovups xmm1, xmmword ptr [rdi]
      vmovups [rbp+var_20], ymm0
      vmovups [rbp+var_30], xmm1
    }
    R_RT_Destroy(&v27, &v28);
    _RBX->sceneRtInput.m_ssrRt.m_surfaceID = 0;
    _RBX->sceneRtInput.m_ssrRt.m_tracking.m_allocCounter = 0;
    _RBX->sceneRtInput.m_ssrRt.m_tracking.m_name = NULL;
    _RBX->sceneRtInput.m_ssrRt.m_tracking.m_location = NULL;
    debugTextureOverlay = rg.debugTextureOverlay;
  }
  if ( debugTextureOverlay == 14 )
  {
    __asm
    {
      vmovups ymm0, ymmword ptr [rbx+3770h]
      vmovups xmm1, xmmword ptr [rdi]
      vmovups [rbp+var_20], ymm0
      vmovups [rbp+var_30], xmm1
    }
    R_RT_Destroy(&v27, &v28);
    _RBX->sceneRtInput.m_transMask.m_surfaceID = 0;
    _RBX->sceneRtInput.m_transMask.m_tracking.m_allocCounter = 0;
    _RBX->sceneRtInput.m_transMask.m_tracking.m_name = NULL;
    _RBX->sceneRtInput.m_transMask.m_tracking.m_location = NULL;
  }
  R_FlushImmediateContext();
  R_UnlockGfxImmediateContext();
}

/*
==============
RB_DecommitSpotShadowRTs
==============
*/
void RB_DecommitSpotShadowRTs(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo)
{
  __int64 v5; 
  unsigned __int16 v6; 
  bool v10; 
  int v12; 
  __m256i v14; 
  R_RT_Handle v15; 
  R_RT_Handle v16; 

  _RBP = gfxContext;
  R_LockGfxImmediateContext();
  _RBX = &viewInfo->sceneRtInput.m_spotShadowRts[0].m_tracking;
  v5 = 8i64;
  do
  {
    v6 = (__int64)_RBX[-1].m_location & 0x7FFF;
    if ( !v6 )
      v6 = 0;
    v15.m_surfaceID = v6;
    __asm
    {
      vmovups xmm0, xmmword ptr [rbx]
      vmovsd  xmm1, qword ptr [rbx+10h]
      vmovups xmmword ptr [rsp+0B8h+var_68.m_tracking.m_allocCounter], xmm0
      vmovsd  [rsp+0B8h+var_68.m_tracking.m_location], xmm1
      vmovups ymm0, ymmword ptr [rsp+0B8h+var_68.m_surfaceID]
      vmovups [rsp+0B8h+var_88], ymm0
      vmovups ymmword ptr [rsp+0B8h+var_48.m_surfaceID], ymm0
    }
    if ( v6 )
    {
      R_RT_Handle::GetSurface(&v16);
      if ( (R_RT_Handle::GetSurface(&v16)->m_rtFlagsInternal & 0x10) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 277, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsDepth())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsDepth()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+0B8h+var_48.m_surfaceID]
          vmovups [rsp+0B8h+var_88], ymm0
        }
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+0B8h+var_48.m_surfaceID]
          vmovups [rsp+0B8h+var_88], ymm0
        }
        __debugbreak();
      }
    }
    else if ( v15.m_tracking.m_allocCounter )
    {
      v10 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, [rsp+0B8h+var_88] }
      if ( v10 )
        __debugbreak();
    }
    LOWORD(_RBX[-1].m_location) = 0;
    __asm { vmovd   eax, xmm0 }
    v12 = (unsigned __int16)_EAX;
    _RBX->m_allocCounter = 0;
    _RBX->m_name = NULL;
    _RBX->m_location = NULL;
    __asm { vmovups ymmword ptr [rsp+0B8h+var_68.m_surfaceID], ymm0 }
    if ( (_WORD)_EAX )
    {
      R_RT_Handle::GetSurface(&v15);
    }
    else
    {
      if ( !v16.m_tracking.m_allocCounter )
        goto LABEL_18;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    __asm { vmovups ymm0, [rsp+0B8h+var_88] }
LABEL_18:
    if ( v12 )
    {
      __asm
      {
        vmovups ymmword ptr [rsp+0B8h+var_48.m_surfaceID], ymm0
        vmovups xmm0, xmmword ptr [rbp+0]
        vmovups xmmword ptr [rsp+0B8h+var_88], xmm0
      }
      R_RT_Destroy((GfxCmdBufContext *)&v14, (R_RT_DepthHandle *)&v16);
    }
    _RBX = (R_RT_Tracking_HandleInfo *)((char *)_RBX + 32);
    --v5;
  }
  while ( v5 );
  R_FlushImmediateContext();
  R_UnlockGfxImmediateContext();
}

/*
==============
RB_DecommitSunShadowRTs
==============
*/
void RB_DecommitSunShadowRTs(GfxCmdBufContext *gfxContext, const GfxBackEndData *data, const GfxViewInfo *viewInfo)
{
  unsigned int v6; 
  GfxCmdBufState *state; 
  ComputeCmdBufState *GfxComputeCmdBufState; 
  unsigned int i; 
  R_RT_ColorHandle v24; 
  R_RT_DepthHandle v25; 
  R_RT_DepthHandle result; 

  _RSI = viewInfo;
  _R14 = gfxContext;
  R_LockGfxImmediateContext();
  R_SunShadowMapDebug_CreateRTDraw3D();
  if ( (unsigned int)(sm_showOverlay->current.integer - 1) <= 3 && (*((_BYTE *)&_RSI->viewportFeatures + 44) & 4) != 0 )
  {
    v6 = 0;
    if ( data->sunShadow.opaqueCascadeCount )
    {
      state = _R14->state;
      do
      {
        _RAX = 32 * (v6 + 404i64);
        __asm
        {
          vmovups ymm0, ymmword ptr [rax+rsi]
          vmovups [rsp+0B8h+var_78], ymm0
        }
        R_SunShadowMapDebug_GetRTDraw3D(&result, v6);
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+0B8h+result.baseclass_0.m_surfaceID]
          vmovups [rsp+0B8h+var_98], ymm0
        }
        GfxComputeCmdBufState = R_GetGfxComputeCmdBufState(state);
        __asm
        {
          vmovups ymm0, [rsp+0B8h+var_78]
          vmovups [rsp+0B8h+var_78], ymm0
          vmovups ymm0, [rsp+0B8h+var_98]
          vmovups [rsp+0B8h+var_98], ymm0
        }
        R_CopyDepthStencilRT(GfxComputeCmdBufState, (R_RT_DepthHandle *)&v24, &v25);
        ++v6;
      }
      while ( v6 < data->sunShadow.opaqueCascadeCount );
    }
  }
  for ( i = 0; i < data->sunShadow.opaqueCascadeCount; _RBX->m_tracking.m_location = NULL )
  {
    __asm { vmovups xmm1, xmmword ptr [r14] }
    _RBX = &_RSI->sceneRtInput.m_sunShadowCascades[i];
    __asm
    {
      vmovups xmmword ptr [rsp+0B8h+result.baseclass_0.m_surfaceID], xmm1
      vmovups ymm0, ymmword ptr [rbx]
      vmovups [rsp+0B8h+var_98], ymm0
    }
    R_RT_Destroy((GfxCmdBufContext *)&result, (R_RT_DepthHandle *)&v24);
    _RBX->m_surfaceID = 0;
    ++i;
    _RBX->m_tracking.m_allocCounter = 0;
    _RBX->m_tracking.m_name = NULL;
  }
  __asm
  {
    vmovups ymm0, ymmword ptr [rsi+32E0h]
    vmovups xmm1, xmmword ptr [r14]
    vmovups [rsp+0B8h+var_98], ymm0
    vmovups xmmword ptr [rsp+0B8h+result.baseclass_0.m_surfaceID], xmm1
  }
  R_RT_Destroy((GfxCmdBufContext *)&result, (R_RT_DepthHandle *)&v24);
  __asm { vmovups xmm1, xmmword ptr [r14] }
  _RSI->sceneRtInput.m_sunShadowCascade0ForViewmodel.m_surfaceID = 0;
  _RSI->sceneRtInput.m_sunShadowCascade0ForViewmodel.m_tracking.m_allocCounter = 0;
  _RSI->sceneRtInput.m_sunShadowCascade0ForViewmodel.m_tracking.m_name = NULL;
  _RSI->sceneRtInput.m_sunShadowCascade0ForViewmodel.m_tracking.m_location = NULL;
  __asm
  {
    vmovups ymm0, ymmword ptr [rsi+3320h]
    vmovups [rsp+0B8h+var_98], ymm0
    vmovups xmmword ptr [rsp+0B8h+result.baseclass_0.m_surfaceID], xmm1
  }
  R_RT_Destroy((GfxCmdBufContext *)&result, &v24);
  __asm { vmovups xmm1, xmmword ptr [r14] }
  _RSI->sceneRtInput.m_sunVisibilityRt.m_surfaceID = 0;
  _RSI->sceneRtInput.m_sunVisibilityRt.m_tracking.m_allocCounter = 0;
  _RSI->sceneRtInput.m_sunVisibilityRt.m_tracking.m_name = NULL;
  _RSI->sceneRtInput.m_sunVisibilityRt.m_tracking.m_location = NULL;
  __asm
  {
    vmovups ymm0, ymmword ptr [rsi+3300h]
    vmovups [rsp+0B8h+var_98], ymm0
    vmovups xmmword ptr [rsp+0B8h+result.baseclass_0.m_surfaceID], xmm1
  }
  R_RT_Destroy((GfxCmdBufContext *)&result, &v24);
  _RSI->sceneRtInput.m_translucentShadowRt.m_surfaceID = 0;
  _RSI->sceneRtInput.m_translucentShadowRt.m_tracking.m_allocCounter = 0;
  _RSI->sceneRtInput.m_translucentShadowRt.m_tracking.m_name = NULL;
  _RSI->sceneRtInput.m_translucentShadowRt.m_tracking.m_location = NULL;
  R_FlushImmediateContext();
  R_UnlockGfxImmediateContext();
}

/*
==============
RB_DisableMSEmissive
==============
*/
void RB_DisableMSEmissive(GfxCmdBufContext *context, const GfxViewInfo *viewInfo)
{
  char v4[128]; 

  __asm
  {
    vmovups xmm0, xmmword ptr [rcx]
    vpextrq rbx, xmm0, 1
  }
  if ( !R_IsLockedIfGfxImmediateContext(*(const GfxDevice **)(_RBX + 1360)) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_immediate_context_lock.h", 29, ASSERT_TYPE_ASSERT, "(R_IsLockedIfGfxImmediateContext( device ))", (const char *)&queryFormat, "R_IsLockedIfGfxImmediateContext( device )") )
    __debugbreak();
  memset_0(v4, 0, sizeof(v4));
  (*(void (__fastcall **)(_QWORD, char *, void *, void *))(**(_QWORD **)(_RBX + 1360) + 640i64))(*(_QWORD *)(_RBX + 1360), v4, &`R_HW_DisableMultiSample'::`2'::s_samplePriorities1xMS, &`R_HW_DisableMultiSample'::`2'::s_eqaa1xMS);
  (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(_RBX + 1360) + 512i64))(*(_QWORD *)(_RBX + 1360), 0i64);
}

/*
==============
RB_Draw2D_BeforePostFX
==============
*/
void RB_Draw2D_BeforePostFX(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufSourceState *source; 
  GfxCmdBufState *state; 
  GfxCmdBufInput *p_input; 
  const GfxImage *Image; 
  const GfxBackEndData *v10; 
  const void *v14; 
  GfxCmdBufContext v15; 
  GfxCmdBufContext v16; 
  R_RT_DepthHandle v17; 
  R_RT_ColorHandle v18; 
  const GfxBackEndData *v19; 
  const GfxBackEndData *timeoutUserData; 
  GfxDevice *device; 

  timeoutUserData = data;
  _RDI = viewInfo;
  _R14 = gfxContext;
  if ( viewInfo->displayCmds[0] )
  {
    Sys_ProfBeginNamedEvent(0xFFFFA500, "wait hud2D ready");
    Sys_ProcessWorkerCmdsWithTimeout(RB_IsHud2DReady, &timeoutUserData);
    Sys_ProfEndNamedEvent();
    if ( !timeoutUserData->abortReady )
    {
      if ( _RDI->displayCmds[3] )
      {
        Sys_ProfBeginNamedEvent(0xFFFFD700, "exec cmds before postFX");
        source = _R14->source;
        R_InitCmdBufSourceState(_R14->source, &_RDI->input);
        state = _R14->state;
        p_input = &source->input;
        R_InitLocalCmdBufState(state, &source->input);
        R_ProfBeginNamedEvent(state, "2D (before postFX)");
        R_GPU_BeginTimer(GPU_TIMER_2D);
        Image = R_UniversalClut_GetImage(_RDI->clientIndex, MOVEMENT);
        __asm { vmovups ymm0, ymmword ptr [rdi+31A0h] }
        v10 = timeoutUserData;
        __asm
        {
          vmovups ymm1, ymmword ptr [rdi+30C0h]
          vmovups [rsp+0B8h+var_68], ymm0
          vmovups xmm0, xmmword ptr [r14]
          vmovups [rsp+0B8h+var_88], xmm0
          vmovups [rsp+0B8h+var_48], ymm1
        }
        RB_InitClient2DReceivePPFXContext(&v15, _RDI, timeoutUserData, &v18, &v17, Image);
        if ( v10->async2D.renderReceivePPFXPending )
        {
          v19 = v10;
          Sys_ProfBeginNamedEvent(0xFF008008, "wait LUI render");
          R_UnlockGfxImmediateContext();
          Sys_ProcessWorkerCmdsWithTimeout((bool (__fastcall *)(void *))RB_Async2D_ReceivePPFXFinished, &v19);
          R_LockGfxImmediateContext();
          Sys_ProfEndNamedEvent();
        }
        if ( v10->async2D.receivePPFXCmdBuf.device )
        {
          if ( !v10->async2D.renderFailed )
          {
            R_FlushImmediateContext();
            device = v10->async2D.receivePPFXCmdBuf.device;
            ((void (__fastcall *)(ID3D12CommandQueue *, __int64, GfxDevice **))g_dx.immediateCommandQueue.commandQueue->m_pFunction[3].AddRef)(g_dx.immediateCommandQueue.commandQueue, 1i64, &device);
            v10->async2D.receivePPFXCmdBuf.device = NULL;
LABEL_11:
            R_GPU_EndTimer();
            R_ProfEndNamedEvent(state);
            R_ShutdownLocalCmdBufState(state, p_input);
            Sys_ProfEndNamedEvent();
            return;
          }
          v10->async2D.receivePPFXCmdBuf.device = NULL;
        }
        __asm { vmovups xmm0, xmmword ptr [r14] }
        v14 = _RDI->displayCmds[3];
        __asm { vmovups [rsp+0B8h+var_78], xmm0 }
        RB_ExecuteRenderCommandsLoop(&v16, v14, NULL);
        goto LABEL_11;
      }
    }
  }
}

/*
==============
RB_Draw2D_Hud
==============
*/
void RB_Draw2D_Hud(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufSourceState *source; 
  const GfxImage *Image; 
  const GfxImage *v16; 
  R_RT_Image *p_m_image; 
  const GfxWrappedBuffer *ConstantBuffer; 
  R_RT_Handle v24; 
  R_RT_ColorHandle v25; 
  R_RT_Handle result; 

  _RSI = viewInfo;
  _R14 = gfxContext;
  if ( viewInfo->displayCmds[0] )
  {
    Sys_ProfBeginNamedEvent(0xFFFFD700, "exec cmds display");
    source = _R14->source;
    R_InitCmdBufSourceState(_R14->source, &_RSI->input);
    R_InitLocalCmdBufState(_R14->state, &source->input);
    R_ProfBeginNamedEvent(_R14->state, "2D (View)");
    R_GPU_BeginTimer(GPU_TIMER_2D);
    _RAX = R_RT_GetGlobal(&result, R_RENDERTARGET_DISPLAY_BUFFER);
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovd   eax, xmm0
      vmovups [rsp+0B8h+var_58], ymm0
      vmovups ymmword ptr [rsp+0B8h+var_78.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v24);
      if ( (R_RT_Handle::GetSurface(&v24)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+0B8h+var_78.m_surfaceID]
          vmovups [rsp+0B8h+var_58], ymm0
        }
        __debugbreak();
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+0B8h+var_78.m_surfaceID]
          vmovups [rsp+0B8h+var_58], ymm0
        }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    Image = R_UniversalClut_GetImage(_RSI->clientIndex, MOVEMENT);
    __asm
    {
      vmovups ymm0, ymmword ptr [rsi+33E0h]
      vmovd   r8d, xmm0
    }
    v16 = Image;
    __asm { vmovups ymmword ptr [rsp+0B8h+var_78.m_surfaceID], ymm0 }
    if ( (_WORD)_ER8 )
    {
      R_RT_Handle::GetSurface(&v24);
      p_m_image = &R_RT_Handle::GetSurface(&v24)->m_image;
    }
    else
    {
      if ( v24.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
      p_m_image = (R_RT_Image *)rgp.blackImage;
    }
    ConstantBuffer = R_Tonemap_GetConstantBuffer(_RSI);
    __asm
    {
      vmovups ymm0, ymmword ptr [rsi+33C0h]
      vmovups ymm1, [rsp+0B8h+var_58]
      vmovups ymmword ptr [rsp+0B8h+result.m_surfaceID], ymm0
      vmovups xmm0, xmmword ptr [r14]
      vmovups xmmword ptr [rsp+0B8h+var_78.m_surfaceID], xmm0
      vmovups [rsp+0B8h+var_58], ymm1
    }
    R_Draw2D_Hud((GfxCmdBufContext *)&v24, _RSI, data, &v25, &result, v16, &p_m_image->m_base, ConstantBuffer);
    R_GPU_EndTimer();
    R_ProfEndNamedEvent(_R14->state);
    R_ShutdownLocalCmdBufState(_R14->state, &_R14->source->input);
    Sys_ProfEndNamedEvent();
  }
  __asm
  {
    vmovups ymm0, ymmword ptr [rsi+33C0h]
    vmovups xmm1, xmmword ptr [r14]
    vmovups ymmword ptr [rsp+0B8h+result.m_surfaceID], ymm0
    vmovups xmmword ptr [rsp+0B8h+var_78.m_surfaceID], xmm1
  }
  R_RT_Destroy((GfxCmdBufContext *)&v24, (R_RT_ColorHandle *)&result);
}

/*
==============
RB_Draw3DOverlays
==============
*/
void RB_Draw3DOverlays(GfxCmdBufContext *gfxContext, const GfxBackEndData *data)
{
  int integer; 
  char v7; 
  unsigned int v8; 
  bool v12; 
  int v13; 
  int IsOverlayEnabled; 
  int v15; 
  GfxCmdBufSourceState *source; 
  GfxCmdBufSourceState *v20; 
  unsigned int height; 
  const R_RT_Surface *Surface; 
  GfxCmdBufSourceState *v38; 
  const char *m_location; 
  GfxImage *umbraOcclusionScene; 
  __int64 v63; 
  unsigned int reflectionProbeFrameIndex; 
  GfxCmdBufSourceState *v84; 
  bool v88; 
  unsigned int v89; 
  const R_RT_Surface *v90; 
  GfxCmdBufSourceState *v91; 
  const char *v101; 
  float fmt; 
  __int64 v116; 
  float v117; 
  float v118; 
  float v119; 
  float v120; 
  float v121; 
  bool enabled; 
  __m256i v123; 
  R_RT_Handle v124; 
  int v125; 
  int v126; 
  R_RT_Handle v127; 
  signed int v128; 
  int v129; 
  int v130; 
  R_RT_BufferHandle v131; 
  R_RT_Group v132; 
  R_RT_DepthHandle result; 
  R_RT_ColorHandle v134; 
  R_RT_DepthHandle v135; 
  R_RT_Group v136; 
  R_RT_Group v137; 
  R_RT_Handle v138[3]; 

  _RSI = gfxContext;
  integer = sm_showOverlay->current.integer;
  v7 = integer != 0;
  if ( data->viewInfoCount )
    v7 &= ~BYTE1(*((_DWORD *)&data->viewInfo[data->viewInfoIndex].viewportFeatures + 11));
  if ( v7 )
  {
    v8 = 0;
    _RDI = v138;
    do
    {
      _RAX = R_SunShadowMapDebug_GetRTDraw3D(&result, v8++);
      ++_RDI;
      __asm
      {
        vmovups ymm0, ymmword ptr [rax]
        vmovups ymmword ptr [rdi-20h], ymm0
      }
    }
    while ( v8 < 3 );
  }
  __asm { vmovaps [rsp+490h+var_40], xmm6 }
  enabled = r_umbraShowOverlay->current.enabled;
  v12 = Physics_RenderDebugEnabled();
  v13 = r_decalVolumesShowAtlas->current.integer;
  v129 = v13;
  v125 = r_showHeightmap->current.integer;
  v126 = r_showFogSpline->current.integer;
  IsOverlayEnabled = RB_ReflectionProbe_IsOverlayEnabled();
  v130 = IsOverlayEnabled;
  v15 = r_showLightmap->current.integer;
  v128 = v15;
  if ( data->viewInfoCount )
  {
    _R13 = &data->viewInfo[data->viewInfoIndex];
    if ( v7 || enabled || v12 || r_showPIPTexture->current.enabled || v15 >= 0 || v125 || v13 > 0 || v126 >= 0 || IsOverlayEnabled >= 0 )
    {
      _RDI = _RSI->state;
      _RDX = &v137;
      source = _RSI->source;
      v20 = _RSI->source;
      __asm
      {
        vmovups xmm0, xmmword ptr [rdi+0A28h]
        vmovups xmmword ptr [rdx], xmm0
        vmovups xmm1, xmmword ptr [rdi+0A38h]
        vmovups xmmword ptr [rdx+10h], xmm1
        vmovups xmm0, xmmword ptr [rdi+0A48h]
        vmovups xmmword ptr [rdx+20h], xmm0
        vmovups xmm1, xmmword ptr [rdi+0A58h]
        vmovups xmmword ptr [rdx+30h], xmm1
        vmovups xmm0, xmmword ptr [rdi+0A68h]
        vmovups xmmword ptr [rdx+40h], xmm0
        vmovups xmm1, xmmword ptr [rdi+0A78h]
        vmovups xmmword ptr [rdx+50h], xmm1
        vmovups xmm0, xmmword ptr [rdi+0A88h]
        vmovups xmmword ptr [rdx+60h], xmm0
        vmovups xmm1, xmmword ptr [rdi+0A98h]
        vmovups xmmword ptr [rdx+70h], xmm1
        vmovups xmm0, xmmword ptr [rdi+0AA8h]
        vmovups xmmword ptr [rdx+80h], xmm0
        vmovups xmm1, xmmword ptr [rdi+0AB8h]
        vmovups xmmword ptr [rdx+90h], xmm1
        vmovups xmm0, xmmword ptr [rdi+0AC8h]
        vmovups xmmword ptr [rdx+0A0h], xmm0
        vmovups xmm1, xmmword ptr [rdi+0AD8h]
        vmovups xmmword ptr [rdx+0B0h], xmm1
      }
      v137.m_vrsRt.m_tracking.m_location = _RDI->rtGroup.m_vrsRt.m_tracking.m_location;
      R_InitCmdBufSourceState(v20, &_R13->input);
      R_InitLocalCmdBufState(_RDI, &source->input);
      _RAX = R_RT_GetGlobal(&result, R_RENDERTARGET_DISPLAY_BUFFER);
      __asm
      {
        vmovups ymm0, ymmword ptr [rax]
        vmovd   eax, xmm0
        vmovups [rsp+490h+var_420], ymm0
        vmovups ymmword ptr [rbp+390h+var_400.m_surfaceID], ymm0
      }
      if ( (_WORD)_RAX )
      {
        R_RT_Handle::GetSurface(&v124);
        if ( (R_RT_Handle::GetSurface(&v124)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
        {
          __asm
          {
            vmovups ymm0, ymmword ptr [rbp+390h+var_400.m_surfaceID]
            vmovups [rsp+490h+var_420], ymm0
          }
          __debugbreak();
        }
        else
        {
          __asm
          {
            vmovups ymm0, ymmword ptr [rbp+390h+var_400.m_surfaceID]
            vmovups [rsp+490h+var_420], ymm0
          }
        }
      }
      else
      {
        __asm { vpextrd rax, xmm0, 2 }
        if ( (_DWORD)_RAX )
        {
          __asm { vmovups ymm0, [rsp+490h+var_420] }
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
            __debugbreak();
        }
      }
      __asm { vmovups ymmword ptr [rbp+390h+var_400.m_surfaceID], ymm0 }
      height = R_RT_Handle::GetSurface(&v124)->m_image.m_base.height;
      Surface = R_RT_Handle::GetSurface(&v124);
      v38 = _RSI->source;
      R_SetRenderTargetSize(_RSI->source, Surface->m_image.m_base.width, height, GFX_USE_VIEWPORT_FOR_VIEW);
      __asm
      {
        vmovups ymm0, [rsp+490h+var_420]
        vmovups ymmword ptr [rbp+390h+var_3D0.m_surfaceID], ymm0
      }
      R_RT_Group::AssignColor(&v132, (R_RT_ColorHandle *)&v127);
      _RCX = &v136;
      _RAX = &v132;
      __asm
      {
        vmovups ymm0, ymmword ptr [rax]
        vmovups ymmword ptr [rcx], ymm0
        vmovups ymm0, ymmword ptr [rax+20h]
        vmovups ymmword ptr [rcx+20h], ymm0
        vmovups ymm0, ymmword ptr [rax+40h]
        vmovups ymmword ptr [rcx+40h], ymm0
        vmovups ymm0, ymmword ptr [rax+60h]
        vmovups ymmword ptr [rcx+60h], ymm0
        vmovups ymm0, ymmword ptr [rax+80h]
        vmovups ymmword ptr [rcx+80h], ymm0
        vmovups ymm0, ymmword ptr [rax+0A0h]
      }
      m_location = v132.m_vrsRt.m_tracking.m_location;
      __asm
      {
        vmovups ymmword ptr [rcx+0A0h], ymm0
        vmovups xmm0, xmmword ptr [rsi]
      }
      v136.m_vrsRt.m_tracking.m_location = m_location;
      __asm { vmovups xmmword ptr [rsp+490h+var_420], xmm0 }
      R_SetRenderTargetsInternal((GfxCmdBufContext *)&v123, &v136, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(5353)");
      R_BeginViewInternal(v38, &_R13->sceneDef, (const GfxViewParms *)_R13, &_R13->viewParmsSet.frames[1].viewParms);
      R_SetViewportStruct(v38, &_R13->displayViewport);
      R_Set2D(v38);
      if ( v7 )
      {
        __asm { vpxor   xmm0, xmm0, xmm0 }
        v124.m_surfaceID = 0;
        v124.m_tracking.m_allocCounter = 0;
        __asm { vmovdqu xmmword ptr [rbp+390h+var_400.m_tracking.m_name], xmm0 }
        v123.m256i_i16[0] = 0;
        v123.m256i_i32[2] = 0;
        __asm { vmovdqu xmmword ptr [rbp+390h+var_420+10h], xmm0 }
        _RAX = R_SunShadowCache_GetDepthArrayRtDraw3D(&v135);
        __asm
        {
          vmovups ymm0, ymmword ptr [rax]
          vmovups ymmword ptr [rbp+390h+result.baseclass_0.m_surfaceID], ymm0
        }
        _RAX = R_SpotShadow_StaleCacheEntry::GetColorArrayRtDraw3D(&v134);
        __asm
        {
          vmovups ymm2, [rbp+390h+var_B0]
          vmovups xmm6, xmmword ptr [rsi]
          vmovups ymmword ptr [rbp+390h+var_3D0.m_surfaceID], ymm2
          vmovups ymm1, ymmword ptr [rax]
          vmovups [rbp+390h+var_3A0], ymm1
        }
        if ( (unsigned int)(integer - 1) > 6 )
        {
          LODWORD(v116) = integer;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 4818, ASSERT_TYPE_ASSERT, "( ( overlayStyle >= GFX_SM_OVERLAY_SUN && overlayStyle < GFX_SM_OVERLAY_COUNT ) )", "( overlayStyle ) = %i", v116) )
            __debugbreak();
          __asm
          {
            vmovups ymm2, ymmword ptr [rbp+390h+var_3D0.m_surfaceID]
            vmovups ymm1, [rbp+390h+var_3A0]
          }
        }
        if ( integer > 4 )
        {
          __asm
          {
            vmovups ymm0, ymmword ptr [r13+6420h]
            vmovups ymmword ptr [rbp+390h+result.baseclass_0.m_surfaceID], ymm0
            vmovups ymmword ptr [rbp+390h+var_3D0.m_surfaceID], ymm1
            vmovdqa xmmword ptr [rsp+490h+var_420], xmm6
          }
          R_SpotShadow_DrawOverlay((GfxCmdBufContext *)&v123, integer, (const R_RT_ColorHandle *)&v127, &result);
        }
        else
        {
          __asm
          {
            vmovups ymm0, ymmword ptr [rbp+390h+var_400.m_surfaceID]
            vmovups ymm1, ymmword ptr [rbp+390h+result.baseclass_0.m_surfaceID]
            vmovups ymmword ptr [rbp+390h+var_3D0.m_surfaceID], ymm0
            vmovups ymm0, [rsp+490h+var_420]
            vmovups [rbp+390h+var_3A0], ymm0
            vmovups ymmword ptr [rbp+390h+result.baseclass_0.m_surfaceID], ymm1
            vmovups ymmword ptr [rbp+390h+var_400.m_surfaceID], ymm2
            vmovdqa xmmword ptr [rsp+490h+var_420], xmm6
          }
          R_Sunshadow_DrawOverlay((GfxCmdBufContext *)&v123, _R13, integer, v138, 3u, &v124, &result, NULL, &v131, &v127);
        }
      }
      if ( enabled )
      {
        __asm { vmovups xmm6, xmmword ptr [rsi] }
        umbraOcclusionScene = rgp.umbraOcclusionScene;
        __asm { vmovq   rbx, xmm6 }
        if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
          __debugbreak();
        v63 = _RBX + 1792;
        if ( !v63 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
          __debugbreak();
        *(_QWORD *)(v63 + 6176) = umbraOcclusionScene;
        _RAX = r_umbraShowOverlayDisplaySizeScale;
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vmovss  xmm2, dword ptr [rax+28h]
          vcvtsi2ss xmm0, xmm0, eax
          vmulss  xmm4, xmm0, xmm2
          vmovss  xmm0, cs:__real@3f800000
          vxorps  xmm1, xmm1, xmm1
          vcvtsi2ss xmm1, xmm1, eax
          vmulss  xmm3, xmm1, xmm2
          vmovss  xmm2, cs:__real@42800000
          vxorps  xmm1, xmm1, xmm1
          vmovss  dword ptr [rsp+490h+var_448], xmm1
          vmovss  dword ptr [rsp+490h+var_450], xmm0
          vmovss  dword ptr [rsp+490h+var_458], xmm0
          vmovss  dword ptr [rsp+490h+var_460], xmm1
          vmovss  dword ptr [rsp+490h+var_468], xmm4
          vmovss  dword ptr [rsp+490h+fmt], xmm3
          vmovaps xmm3, xmm2
          vmovdqa xmmword ptr [rsp+490h+var_420], xmm6
        }
        RB_DrawStretchPic((GfxCmdBufContext *)&v123, rgp.feedbackReplaceBackbufferMaterial, *(float *)&_XMM2, *(float *)&_XMM3, fmt, v117, v118, v119, v120, v121, 0xFFFFFFFF, GFX_PRIM_STATS_HUD);
        __asm { vmovdqa xmmword ptr [rsp+490h+var_420], xmm6 }
        RB_EndTessSurfaceInternal((GfxCmdBufContext *)&v123, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(4771)");
      }
      __asm
      {
        vmovups xmm0, xmmword ptr [rsi]
        vmovups xmmword ptr [rsp+490h+var_420], xmm0
      }
      Physics_RenderDebugOverlays((GfxCmdBufContext *)&v123);
      if ( v128 >= 0 )
      {
        __asm
        {
          vmovups xmm0, xmmword ptr [rsi]
          vmovups xmmword ptr [rsp+490h+var_420], xmm0
        }
        RB_DrawLightmapOverlap((GfxCmdBufContext *)&v123, data, v128);
      }
      if ( v125 )
      {
        __asm
        {
          vmovups xmm0, xmmword ptr [rsi]
          vmovups xmmword ptr [rsp+490h+var_420], xmm0
        }
        RB_DrawHeightmapOverlay((GfxCmdBufContext *)&v123);
      }
      if ( v129 )
      {
        __asm
        {
          vmovups xmm0, xmmword ptr [rsi]
          vmovups xmmword ptr [rsp+490h+var_420], xmm0
        }
        RB_DecalVolumes_ShowAtlas((GfxCmdBufContext *)&v123, v129);
      }
      if ( v126 >= 0 )
      {
        __asm
        {
          vmovups xmm0, xmmword ptr [rsi]
          vmovups xmmword ptr [rsp+490h+var_420], xmm0
        }
        RB_DrawFogSplineOverlap((GfxCmdBufContext *)&v123, _R13, v126);
      }
      if ( v130 >= 0 )
      {
        __asm { vmovups xmm0, xmmword ptr [rsi] }
        reflectionProbeFrameIndex = data->reflectionProbeFrameIndex;
        __asm { vmovups xmmword ptr [rsp+490h+var_420], xmm0 }
        RB_ReflectionProbe_Overlay((GfxCmdBufContext *)&v123, reflectionProbeFrameIndex, v130);
      }
      __asm
      {
        vmovups xmm0, xmmword ptr [rsi]
        vmovups xmmword ptr [rsp+490h+var_420], xmm0
      }
      R_SetRenderTargetsInternal((GfxCmdBufContext *)&v123, &v137, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(5417)");
      R_ShutdownLocalCmdBufState(_RSI->state, &_RSI->source->input);
    }
  }
  if ( data->pipInfoCount )
  {
    _R15 = data->viewInfo;
    v84 = _RSI->source;
    R_InitCmdBufSourceState(_RSI->source, &_R15[5].input);
    R_InitLocalCmdBufState(_RSI->state, &v84->input);
    _RAX = R_RT_GetGlobal(&v134, R_RENDERTARGET_DISPLAY_BUFFER);
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovd   eax, xmm0
      vmovups [rsp+490h+var_420], ymm0
      vmovups ymmword ptr [rbp+390h+var_400.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v124);
      if ( (R_RT_Handle::GetSurface(&v124)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rbp+390h+var_400.m_surfaceID]
          vmovups [rsp+490h+var_420], ymm0
        }
        __debugbreak();
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rbp+390h+var_400.m_surfaceID]
          vmovups [rsp+490h+var_420], ymm0
        }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v88 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        __asm { vmovups ymm0, [rsp+490h+var_420] }
        if ( v88 )
          __debugbreak();
      }
    }
    __asm { vmovups ymmword ptr [rbp+390h+var_3D0.m_surfaceID], ymm0 }
    v89 = R_RT_Handle::GetSurface(&v127)->m_image.m_base.height;
    v90 = R_RT_Handle::GetSurface(&v127);
    v91 = _RSI->source;
    R_SetRenderTargetSize(_RSI->source, v90->m_image.m_base.width, v89, GFX_USE_VIEWPORT_FOR_VIEW);
    __asm
    {
      vmovups ymm0, [rsp+490h+var_420]
      vmovups ymmword ptr [rbp+390h+result.baseclass_0.m_surfaceID], ymm0
    }
    R_RT_Group::AssignColor(&v137, (R_RT_ColorHandle *)&result);
    _RCX = &v136;
    _RAX = &v137;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovups ymmword ptr [rcx], ymm0
      vmovups ymm0, ymmword ptr [rax+20h]
      vmovups ymmword ptr [rcx+20h], ymm0
      vmovups ymm0, ymmword ptr [rax+40h]
      vmovups ymmword ptr [rcx+40h], ymm0
      vmovups ymm0, ymmword ptr [rax+60h]
      vmovups ymmword ptr [rcx+60h], ymm0
      vmovups ymm0, ymmword ptr [rax+80h]
      vmovups ymmword ptr [rcx+80h], ymm0
      vmovups ymm0, ymmword ptr [rax+0A0h]
    }
    v101 = v137.m_vrsRt.m_tracking.m_location;
    __asm
    {
      vmovups ymmword ptr [rcx+0A0h], ymm0
      vmovups xmm0, xmmword ptr [rsi]
    }
    v136.m_vrsRt.m_tracking.m_location = v101;
    __asm { vmovups xmmword ptr [rsp+490h+var_420], xmm0 }
    R_SetRenderTargetsInternal((GfxCmdBufContext *)&v123, &v136, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(5432)");
    R_BeginViewInternal(v91, &_R15[5].sceneDef, (const GfxViewParms *)&_R15[5], &_R15[5].viewParmsSet.frames[1].viewParms);
    R_SetViewportStruct(v91, &_R15[5].displayViewport);
    R_Set2D(v91);
    if ( v7 )
    {
      __asm { vpxor   xmm0, xmm0, xmm0 }
      v124.m_surfaceID = 0;
      __asm
      {
        vmovdqu xmmword ptr [rbp+390h+var_400.m_tracking.m_name], xmm0
        vmovdqu xmmword ptr [rbp+390h+var_420+10h], xmm0
      }
      v124.m_tracking.m_allocCounter = 0;
      v123.m256i_i16[0] = 0;
      v123.m256i_i32[2] = 0;
      _RAX = R_SunShadowCache_GetDepthArrayRtDraw3D((R_RT_DepthHandle *)&v134);
      __asm
      {
        vmovups ymm0, ymmword ptr [rax]
        vmovups ymmword ptr [rbp+390h+result.baseclass_0.m_surfaceID], ymm0
      }
      _RAX = R_SpotShadow_StaleCacheEntry::GetColorArrayRtDraw3D((const R_RT_ColorHandle *)&v135);
      __asm
      {
        vmovups ymm2, [rbp+390h+var_B0]
        vmovups xmm6, xmmword ptr [rsi]
        vmovups [rbp+390h+var_3A0], ymm2
        vmovups ymm1, ymmword ptr [rax]
        vmovups ymmword ptr [rbp+390h+var_3D0.m_surfaceID], ymm1
      }
      if ( integer < 1 || integer >= 8 )
      {
        LODWORD(v116) = integer;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 4818, ASSERT_TYPE_ASSERT, "( ( overlayStyle >= GFX_SM_OVERLAY_SUN && overlayStyle < GFX_SM_OVERLAY_COUNT ) )", "( overlayStyle ) = %i", v116) )
          __debugbreak();
        __asm
        {
          vmovups ymm2, [rbp+390h+var_3A0]
          vmovups ymm1, ymmword ptr [rbp+390h+var_3D0.m_surfaceID]
        }
      }
      if ( integer > 4 )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [r15+25AF0h]
          vmovups ymmword ptr [rbp+390h+result.baseclass_0.m_surfaceID], ymm0
          vmovups ymmword ptr [rbp+390h+var_3D0.m_surfaceID], ymm1
          vmovdqa xmmword ptr [rsp+490h+var_420], xmm6
        }
        R_SpotShadow_DrawOverlay((GfxCmdBufContext *)&v123, integer, (const R_RT_ColorHandle *)&v127, &result);
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rbp+390h+var_400.m_surfaceID]
          vmovups ymm1, ymmword ptr [rbp+390h+result.baseclass_0.m_surfaceID]
          vmovups ymmword ptr [rbp+390h+var_3D0.m_surfaceID], ymm0
          vmovups ymm0, [rsp+490h+var_420]
          vmovups [rbp+390h+var_3A0], ymm0
          vmovups ymmword ptr [rbp+390h+result.baseclass_0.m_surfaceID], ymm1
          vmovups ymmword ptr [rbp+390h+var_400.m_surfaceID], ymm2
          vmovdqa xmmword ptr [rsp+490h+var_420], xmm6
        }
        R_Sunshadow_DrawOverlay((GfxCmdBufContext *)&v123, _R15 + 5, integer, v138, 3u, &v124, &result, NULL, &v131, &v127);
      }
    }
    R_ShutdownLocalCmdBufState(_RSI->state, &v91->input);
  }
  __asm { vmovaps xmm6, [rsp+490h+var_40] }
}

/*
==============
RB_Draw3DScene
==============
*/
void RB_Draw3DScene(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, double a4)
{
  signed __int64 v4; 
  void *v7; 
  const GfxBackEndData *v11; 
  GfxCmdBufState *v14; 
  int v20; 
  GfxBackEndData *v36; 
  GfxCmdBufState *v43; 
  __int64 v56; 
  GfxBackEndData *v74; 
  char v80; 
  const dvar_t *v83; 
  R_RT_Flags v84; 
  unsigned int height; 
  const R_RT_Surface *Surface; 
  bool v90; 
  ComputeCmdBufState *GfxComputeCmdBufState; 
  GfxCmdBufSourceState *v96; 
  GfxCmdBufState *v102; 
  bool v110; 
  GfxCmdBufSourceState *v162; 
  GfxCmdBufState *v163; 
  const GfxImage *Image; 
  GfxBackEndData *v166; 
  const void *v170; 
  GfxCmdBufState *v173; 
  char v184; 
  GfxBackEndData *v196; 
  volatile int *p_inCmdCount; 
  int *cmdBufValid; 
  __int64 rtFlagsInternal; 
  GfxBackEndData *dataa; 
  bool v202; 
  GfxBackEndData *timeoutUserData; 
  GfxBackEndData *v204; 
  GfxCmdBufInput *input; 
  GfxImage *extinction; 
  GfxImage *scattering; 
  __m256i v208; 
  ID3D12Resource *buffers; 
  GfxBackEndData *v210; 
  ID3D12Resource *buffer; 
  ID3D12Resource *v212; 
  ID3D12Resource *v213; 
  ID3D12Resource *v214; 
  ID3D12Resource *v215; 
  GfxBackEndData *v216; 
  GfxDevice *device; 
  GfxCmdBufSourceState *source[2]; 
  __m256i v219; 
  R_RT_Handle v220; 
  R_RT_Handle v221; 
  __m256i v222; 
  __m256i v223; 
  GfxImage *visibility; 
  GfxCmdBufContext v225; 
  GfxCmdBufContext v226; 
  GfxCmdBufContext v227; 
  GfxCmdBufContext v228; 
  GfxCmdBufContext v229; 
  GfxCmdBufContext v230; 
  GfxCmdBufContext v231; 
  GfxCmdBufContext v232; 
  GfxCmdBufContext v233; 
  GfxCmdBufContext v234; 
  GfxCmdBufContext v235; 
  GfxCmdBufContext v236; 
  GfxCmdBufContext v237; 
  GfxCmdBufContext v238; 
  GfxCmdBufContext v239; 
  GfxCmdBufContext v240; 
  GfxCmdBufContext v241; 
  GfxCmdBufContext v242; 
  GfxCmdBufContext v243; 
  GfxCmdBufContext v244; 
  GfxCmdBufContext v245; 
  GfxCmdBufContext v246; 
  GfxCmdBufContext v247; 
  GfxCmdBufContext v248; 
  GfxCmdBufContext v249; 
  GfxCmdBufContext v250; 
  GfxCmdBufContext v251; 
  GfxCmdBufContext v252; 
  GfxCmdBufContext v253; 
  GfxCmdBufContext v254; 
  GfxCmdBufContext v255; 
  GfxCmdBufContext v256; 
  GfxCmdBufContext v257; 
  GfxCmdBufContext v258; 
  GfxCmdBufContext v259; 
  GfxCmdBufContext v260; 
  GfxCmdBufContext v261; 
  GfxCmdBufContext v262; 
  GfxCmdBufContext v263; 
  GfxCmdBufContext v264; 
  GfxCmdBufContext v265; 
  GfxCmdBufContext v266; 
  GfxCmdBufContext v267; 
  GfxCmdBufContext v268; 
  GfxCmdBufContext v269; 
  GfxCmdBufContext v270; 
  GfxCmdBufContext v271; 
  GfxCmdBufContext v272; 
  GfxCmdBufContext v273; 
  GfxCmdBufContext v274; 
  GfxCmdBufContext v275; 
  GfxCmdBufContext v276; 
  GfxCmdBufContext v277; 
  GfxCmdBufContext v278; 
  GfxCmdBufContext v279; 
  GfxCmdBufContext v280; 
  GfxCmdBufContext v281; 
  GfxCmdBufContext v282; 
  GfxCmdBufContext v283; 
  GfxCmdBufContext v284; 
  GfxCmdBufContext v285; 
  GfxCmdBufContext v286; 
  __m256i v287; 
  __m256i v288; 
  R_RT_Handle v289; 
  R_RT_ColorHandle v290; 
  R_RT_BufferHandle v291; 
  R_RT_BufferHandle v292; 
  R_RT_ColorHandle v293; 
  R_RT_ColorHandle v294; 
  R_RT_ColorHandle v295; 
  R_RT_ColorHandle v296; 
  R_RT_DepthHandle v297; 
  R_RT_BufferHandle v298; 
  R_RT_ColorHandle v299; 
  R_RT_ColorHandle v300; 
  R_RT_ColorHandle v301; 
  R_RT_DepthHandle v302; 
  R_RT_ColorHandle v303; 
  R_RT_DepthHandle v304; 
  R_RT_BufferHandle v305; 
  R_RT_BufferHandle v306; 
  R_RT_BufferHandle v307; 
  R_RT_BufferHandle v308; 
  R_RT_BufferHandle v309; 
  R_RT_BufferHandle v310; 
  R_RT_BufferHandle v311; 
  R_RT_BufferHandle v312; 
  R_RT_ColorHandle v313; 
  R_RT_ColorHandle v314; 
  R_RT_ColorHandle v315; 
  R_RT_ColorHandle v316; 
  R_RT_ColorHandle v317; 
  R_RT_ColorHandle v318; 
  R_RT_ColorHandle v319; 
  R_RT_ColorHandle v320; 
  R_RT_ColorHandle v321; 
  R_RT_ColorHandle v322; 
  R_RT_ColorHandle v323; 
  R_RT_ColorHandle v324; 
  R_RT_ColorHandle v325; 
  R_RT_ColorHandle v326; 
  R_RT_ColorHandle v327; 
  R_RT_ColorHandle v328; 
  R_RT_ColorHandle v329; 
  R_RT_ColorHandle v330; 
  R_RT_ColorHandle v331; 
  R_RT_DepthHandle v332; 
  R_RT_DepthHandle v333; 
  R_RT_ColorHandle v334; 
  __m256i v335; 
  R_RT_Handle v336; 
  R_RT_ColorHandle v337; 
  R_RT_ColorHandle v338; 
  R_RT_DepthHandle v339; 
  R_RT_ColorHandle v340; 
  R_RT_DepthHandle v341; 
  R_RT_ColorHandle v342; 
  R_RT_ColorHandle v343; 
  R_RT_DepthHandle v344; 
  R_RT_Handle v345; 
  R_RT_Handle v346; 
  GfxGPConfig v347; 
  GfxGPConfig v348; 
  GfxGPConfig v349; 
  R_RT_BufferHandle result; 
  R_RT_BufferHandle v351; 
  R_RT_BufferHandle v352; 
  R_RT_BufferHandle v353; 
  R_RT_BufferHandle v354; 
  R_RT_BufferHandle v355; 
  R_RT_BufferHandle v356; 
  R_RT_BufferHandle v357; 
  R_RT_Group rtGroup; 
  ComputeCmdBufState state; 
  ComputeCmdBufState v360; 
  ComputeCmdBufState computeState; 
  ComputeCmdBufState v362; 
  ComputeCmdBufState v363; 
  ComputeCmdBufState v364; 

  v7 = alloca(v4);
  __asm { vmovaps [rsp+4B60h+var_40], xmm6 }
  _RSI = gfxContext;
  dataa = (GfxBackEndData *)data;
  _RDI = viewInfo;
  R_RT_BackendPassBegin(viewInfo->sceneRtInput.m_pass);
  __asm { vmovups xmm6, xmmword ptr [rsi] }
  timeoutUserData = dataa;
  Profile2_UpdateEntry(48);
  if ( ((unsigned __int8)&dword_14FDE8090 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE8090) )
    __debugbreak();
  _InterlockedIncrement(&dword_14FDE8090);
  v11 = timeoutUserData;
  if ( !timeoutUserData->compute.smpEnabled )
  {
    Sys_ProfBeginNamedEvent(0xFFFFA500, "wait compute ready");
    Sys_ProcessWorkerCmdsWithTimeout(RB_IsComputeReady, &timeoutUserData);
    Sys_WaitWorkerCmdsOfType(WRKCMD_UGB_MAKE_XSURFS_RESIDENT_DISPATCH);
    Sys_WaitWorkerCmdsOfType(WRKCMD_INIT_UGB_BACKEND);
    Sys_ProfEndNamedEvent();
    v11 = timeoutUserData;
  }
  __asm { vmovdqa [rbp+4A40h+var_4950], xmm6 }
  R_FinishComputeCmdList(&v225, v11);
  Profile2_UpdateEntry(48);
  if ( ((unsigned __int64)&dword_14FDE8090 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 44, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE8090) )
    __debugbreak();
  _InterlockedDecrement(&dword_14FDE8090);
  Profile_BeginCSV(23);
  __asm
  {
    vmovups xmm0, xmmword ptr [rsi]
    vmovups [rbp+4A40h+var_4940], xmm0
  }
  RB_StartDraw3DScene(&v226, _RDI, dataa);
  __asm
  {
    vmovups xmm0, xmmword ptr [rsi]
    vmovups [rbp+4A40h+var_4930], xmm0
  }
  R_ClearGlobalRTsAsRequired(&v227, _RDI);
  v14 = _RSI->state;
  RB_AddComputeCmdsTransitions(v14, dataa, 1);
  __asm
  {
    vmovups ymm0, ymmword ptr [rdi+30C0h]
    vmovups [rbp+4A40h+var_44B0], ymm0
  }
  R_AddRenderTargetTransition(v14, &v293, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  __asm
  {
    vmovups ymm0, ymmword ptr [rdi+30E0h]
    vmovups [rbp+4A40h+var_4490], ymm0
  }
  R_AddRenderTargetTransition(v14, &v294, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  __asm
  {
    vmovups ymm0, ymmword ptr [rdi+3140h]
    vmovups [rbp+4A40h+var_4470], ymm0
  }
  R_AddRenderTargetTransition(v14, &v295, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  __asm
  {
    vmovups ymm0, ymmword ptr [rdi+3160h]
    vmovups [rbp+4A40h+var_4450], ymm0
  }
  R_AddRenderTargetTransition(v14, &v296, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  __asm
  {
    vmovups ymm0, ymmword ptr [rdi+31A0h]
    vmovups [rbp+4A40h+var_4430], ymm0
  }
  R_AddDepthStencilTransition(v14, &v297, DEPTHSTENCIL_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  R_FlushResourceTransitions(v14);
  v20 = 0;
  _RAX = R_RT_CreateBufferInternal(&result, 4u, 0x4001u, GFX_DATA_FORMAT_R32_UINT, R_RT_Flag_BufferRaw|R_RT_Flag_RWView, R_RT_FlagInternal_None, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, "Batch SubMesh Offsets Buffer", 0, NULL, NULL, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(3993)");
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovups ymmword ptr [rdi+3548h], ymm0
  }
  _RAX = R_RT_CreateBufferInternal(&v351, 4u, 0x10000u, GFX_DATA_FORMAT_R32_UINT, R_RT_Flag_BufferRaw|R_RT_Flag_RWView, R_RT_FlagInternal_None, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, "SubMesh Workgroup Args Buffer", 0, NULL, NULL, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(3994)");
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovups ymmword ptr [rdi+3568h], ymm0
  }
  _RAX = R_RT_CreateBufferInternal(&v352, 4u, 1u, GFX_DATA_FORMAT_R32_UINT, R_RT_Flag_BufferRaw|R_RT_Flag_RWView, R_RT_FlagInternal_None, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, "SubMesh Count Buffer", 0, NULL, NULL, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(3995)");
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovups ymmword ptr [rdi+3588h], ymm0
  }
  _RAX = R_RT_CreateBufferInternal(&v353, 0xCu, 1u, GFX_DATA_FORMAT_R32_UINT, R_RT_Flag_BufferIndirectArgs|R_RT_Flag_BufferRaw|R_RT_Flag_RWView, R_RT_FlagInternal_None, D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT, "Cluster Pass Indirect Args Buffer", 0, NULL, NULL, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(3996)");
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovups ymmword ptr [rdi+35A8h], ymm0
  }
  _RAX = R_RT_CreateBufferInternal(&v354, 0xCu, 1u, GFX_DATA_FORMAT_R32_UINT, R_RT_Flag_BufferIndirectArgs|R_RT_Flag_BufferRaw|R_RT_Flag_RWView, R_RT_FlagInternal_None, D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT, "Cluster Pass PPSum Indirect Args Buffer", 0, NULL, NULL, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(3997)");
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovups ymmword ptr [rdi+35C8h], ymm0
  }
  _RAX = R_RT_CreateBufferInternal(&v355, 8u, 0x10000u, GFX_DATA_FORMAT_R32_UINT, R_RT_Flag_BufferStructured|R_RT_Flag_RWView, R_RT_FlagInternal_None, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, "Prev Culled SubMesh Buffer", 0, NULL, NULL, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(3998)");
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovups ymmword ptr [rdi+35E8h], ymm0
  }
  _RAX = R_RT_CreateBufferInternal(&v356, 4u, 0x10001u, GFX_DATA_FORMAT_R32_UINT, R_RT_Flag_BufferRaw|R_RT_Flag_RWView, R_RT_FlagInternal_None, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, "Prev SubMesh Cluster Offsets Buffer", 0, NULL, NULL, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(3999)");
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovups ymmword ptr [rdi+3608h], ymm0
  }
  _RAX = R_RT_CreateBufferInternal(&v357, 8u, 0x40000u, GFX_DATA_FORMAT_R32_UINT, R_RT_Flag_BufferStructured|R_RT_Flag_RWView, R_RT_FlagInternal_None, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, "Prev Culled Tri Cluster Buffer", 0, NULL, NULL, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(4000)");
  v36 = dataa;
  v349.passIndex = GFX_GP_PASS_SHADOWS;
  *(_WORD *)&v349.occlusionPass = 0;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovups ymmword ptr [rdi+3628h], ymm0
    vmovups xmm0, xmmword ptr [rsi]
    vmovups [rbp+4A40h+var_4920], xmm0
  }
  v349.reusePrepassVisData = 0;
  RB_GP_ProcessSurfs(&v228, _RDI, v36, &v349);
  R_InitComputeCmdBufState(&state, dataa, COMPUTE_CONTEXT_TYPE_ASYNC_BACKEND);
  buffers = dataa->globalSceneConstantBuffer->buffer;
  R_SetComputeConstantBuffers(&state, 7, 1, &buffers);
  R_ComputeWaitForGraphics(&state, v14);
  RB_VOL_EvaluateLightgrid(&state, _RDI, dataa);
  RB_ReflectionProbe_ProcessView(&state, _RDI, dataa);
  if ( rg.useLightGridVolumes )
    RB_LGV_SampleLighting(&state, dataa, _RDI);
  R_LockGfxImmediateContext();
  R_ComputeWaitForCompute(&state, PIPE_FLUSH_PARTIAL);
  RB_ReProjFloatZ_Resources(&state, _RDI);
  RB_VOL_Cluster(&state, _RDI, dataa);
  RB_UniversalClut_Generate(&state, _RDI, dataa);
  R_UnlockGfxImmediateContext();
  R_ShutdownComputeCmdBufState(&state);
  __asm
  {
    vmovups xmm0, xmmword ptr [rsi]
    vmovups [rbp+4A40h+var_4910], xmm0
  }
  RB_StandardDrawCommands_Shadows(&v229, _RDI, dataa);
  R_InitCmdBufSourceState(_RSI->source, &_RDI->input);
  __asm
  {
    vmovups xmm0, xmmword ptr [rsi]
    vmovups [rbp+4A40h+var_4900], xmm0
  }
  R_SetAndClearSceneTarget(&v230, _RDI);
  v210 = dataa;
  Profile2_UpdateEntry(51);
  if ( ((unsigned __int8)&dword_14FDE809C & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE809C) )
    __debugbreak();
  _InterlockedIncrement(&dword_14FDE809C);
  Sys_ProfBeginNamedEvent(0xFFFFA500, "wait opaque ready");
  Sys_ProcessWorkerCmdsWithTimeout(RB_IsOpaqueReady, &v210);
  Sys_ProfEndNamedEvent();
  Profile2_UpdateEntry(51);
  if ( ((unsigned __int64)&dword_14FDE809C & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 44, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE809C) )
    __debugbreak();
  _InterlockedDecrement(&dword_14FDE809C);
  __asm
  {
    vmovups xmm0, xmmword ptr [rsi]
    vmovups [rbp+4A40h+var_48F0], xmm0
  }
  RB_SetupFrustumLights(&v231, _RDI, dataa);
  __asm
  {
    vmovups xmm0, xmmword ptr [rsi]
    vmovups [rbp+4A40h+var_48E0], xmm0
  }
  RB_RenderFrustumLightsCluster(&v232, _RDI, dataa);
  v43 = _RSI->state;
  R_WaitAsyncCompute(v43, dataa, COMPUTE_CONTEXT_TYPE_ASYNC_BACKEND, 0);
  __asm { vmovups xmm0, xmmword ptr [rsi] }
  v348.passIndex = GFX_GP_PASS_CAMERA;
  *(_WORD *)&v348.occlusionPass = 0;
  __asm { vmovups [rbp+4A40h+var_48D0], xmm0 }
  v348.reusePrepassVisData = 0;
  RB_GP_ProcessSurfs(&v233, _RDI, dataa, &v348);
  R_InitComputeCmdBufState(&computeState, dataa, COMPUTE_CONTEXT_TYPE_ASYNC_BACKEND);
  buffer = dataa->globalSceneConstantBuffer->buffer;
  R_SetComputeConstantBuffers(&computeState, 7, 1, &buffer);
  R_LockGfxImmediateContext();
  R_ComputeWaitForCompute(&computeState, PIPE_FLUSH_PARTIAL);
  R_ComputeWaitForGraphics(&computeState, v43);
  if ( R_GetSSAOMode(_RDI) )
  {
    __asm
    {
      vmovups ymm0, ymmword ptr [rdi+3408h]
      vmovups [rbp+4A40h+var_4510], ymm0
    }
    R_ClearColorTargetAsync(&computeState, &v290);
  }
  if ( (R_GetSSAOMode(_RDI) & 2) != 0 )
  {
    __asm
    {
      vmovups ymm0, ymmword ptr [rdi+3488h]
      vmovups [rbp+4A40h+var_43F0], ymm0
    }
    R_ClearColorTargetAsync(&computeState, &v299);
  }
  RB_LightSensor_Process(&computeState, _RDI, dataa);
  R_UnlockGfxImmediateContext();
  R_ShutdownComputeCmdBufState(&computeState);
  Sys_ProfBeginNamedEvent(0xFFFFD700, "exec cmds opaque");
  Profile2_UpdateEntry(52);
  input = (GfxCmdBufInput *)((unsigned __int64)&dword_14FDE80A0 & 3);
  if ( ((unsigned __int8)&dword_14FDE80A0 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE80A0) )
  {
    __debugbreak();
    v43 = _RSI->state;
  }
  _InterlockedIncrement(&dword_14FDE80A0);
  __asm
  {
    vmovups xmm0, xmmword ptr [rsi]
    vmovups [rbp+4A40h+var_48C0], xmm0
  }
  RB_DrawPrepass(&v234, _RDI, dataa);
  R_LockGfxImmediateContext();
  __asm
  {
    vmovups xmm0, xmmword ptr [rsi]
    vmovups [rbp+4A40h+var_48B0], xmm0
  }
  RB_ResolveFloatZFull(&v235, _RDI);
  __asm
  {
    vmovups ymm0, ymmword ptr [rdi+3160h]
    vmovups [rbp+4A40h+var_43D0], ymm0
  }
  R_AddRenderTargetTransition(v43, &v300, RENDERTARGET_TRANSITION_MODE_READ, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  __asm
  {
    vmovups ymm0, ymmword ptr [rdi+3140h]
    vmovups [rbp+4A40h+var_43B0], ymm0
  }
  R_AddRenderTargetTransition(v43, &v301, RENDERTARGET_TRANSITION_MODE_READ, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  __asm
  {
    vmovups ymm0, ymmword ptr [rdi+31A0h]
    vmovups [rbp+4A40h+var_4390], ymm0
  }
  R_AddDepthStencilTransition(v43, &v302, DEPTHSTENCIL_TRANSITION_MODE_READ_PRESERVE_DEPTH_COMPRESSION, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  R_FlushResourceTransitions(v43);
  R_UnlockGfxImmediateContext();
  if ( (R_GetSSAOMode(_RDI) & 2) != 0 )
  {
    __asm
    {
      vmovups ymm0, ymmword ptr [rdi+3488h]
      vmovups xmm1, xmmword ptr [rsi]
      vmovups [rbp+4A40h+var_4370], ymm0
      vmovups [rbp+4A40h+var_48A0], xmm1
    }
    RB_MDAO_DrawVolumeOccluders(&v236, _RDI, dataa, &v303);
  }
  R_InitComputeCmdBufState(&v360, dataa, COMPUTE_CONTEXT_TYPE_ASYNC_BACKEND);
  v212 = dataa->globalSceneConstantBuffer->buffer;
  R_SetComputeConstantBuffers(&v360, 7, 1, &v212);
  R_LockGfxImmediateContext();
  R_ComputeWaitForGraphics(&v360, v43);
  RB_VOL_EvaluateVolumetricsScattering(&v360, _RDI, dataa);
  RB_CompositeStaticVelocity(&v360, _RDI);
  if ( (R_GetSSAOMode(_RDI) & 2) != 0 )
    RB_MDAO_Generate(&v360, _RDI, dataa);
  if ( (R_GetSSAOMode(_RDI) & 1) != 0 )
    RB_SSAO_Generate(&v360, _RDI, dataa, _RDI->ssao.splitZones ? SSAO_ZONE_SCENE : SSAO_ZONE_ALL);
  if ( !_RDI->ssao.splitZones )
  {
    __asm
    {
      vmovups xmm0, xmmword ptr [rsi]
      vmovups [rbp+4A40h+var_4890], xmm0
    }
    RB_SSAO_RotateRTs(&v237, _RDI);
  }
  RB_MayhemSelfVis_UpdateAnimBuffer(&v360, dataa);
  if ( (unsigned __int8)R_GetSSRMode(_RDI) >= GFX_SSR_DEFERRED_LQ )
    RB_SSR_DeferredTrace(&v360, _RDI, dataa);
  R_UnlockGfxImmediateContext();
  R_ShutdownComputeCmdBufState(&v360);
  __asm { vmovups ymm0, ymmword ptr [rdi+31A0h] }
  v56 = 3i64;
  __asm { vmovups [rbp+4A40h+var_4350], ymm0 }
  R_AddDepthStencilTransition(v43, &v304, DEPTHSTENCIL_TRANSITION_MODE_WRITE_PRESERVE_DEPTH_COMPRESSION, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  R_FlushResourceTransitions(v43);
  if ( rg.gpuCullOcclusion )
  {
    __asm { vmovups xmm0, xmmword ptr [rsi] }
    v347.reusePrepassVisData = rg.gpuCullReusePrepassVisData;
    __asm { vmovups [rbp+4A40h+var_4880], xmm0 }
    v347.passIndex = GFX_GP_PASS_CAMERA;
    *(_WORD *)&v347.occlusionPass = 257;
    RB_GP_ProcessSurfs(&v238, _RDI, dataa, &v347);
  }
  __asm
  {
    vmovups ymm0, ymmword ptr [rdi+3548h]
    vmovups xmm1, xmmword ptr [rsi]
    vmovups [rbp+4A40h+var_4330], ymm0
    vmovups [rbp+4A40h+var_4870], xmm1
  }
  R_RT_Destroy(&v239, &v305);
  __asm
  {
    vmovups ymm0, ymmword ptr [rdi+3568h]
    vmovups xmm1, xmmword ptr [rsi]
    vmovups [rbp+4A40h+var_4310], ymm0
    vmovups [rbp+4A40h+var_4860], xmm1
  }
  R_RT_Destroy(&v240, &v306);
  __asm
  {
    vmovups ymm0, ymmword ptr [rdi+3588h]
    vmovups xmm1, xmmword ptr [rsi]
    vmovups [rbp+4A40h+var_4410], ymm0
    vmovups [rbp+4A40h+var_4850], xmm1
  }
  R_RT_Destroy(&v241, &v298);
  __asm
  {
    vmovups ymm0, ymmword ptr [rdi+35A8h]
    vmovups xmm1, xmmword ptr [rsi]
    vmovups [rbp+4A40h+var_42D0], ymm0
    vmovups [rbp+4A40h+var_4840], xmm1
  }
  R_RT_Destroy(&v242, &v308);
  __asm
  {
    vmovups ymm0, ymmword ptr [rdi+35C8h]
    vmovups xmm1, xmmword ptr [rsi]
    vmovups [rbp+4A40h+var_42B0], ymm0
    vmovups [rbp+4A40h+var_4830], xmm1
  }
  R_RT_Destroy(&v243, &v309);
  __asm
  {
    vmovups ymm0, ymmword ptr [rdi+35E8h]
    vmovups xmm1, xmmword ptr [rsi]
    vmovups [rbp+4A40h+var_4290], ymm0
    vmovups [rbp+4A40h+var_4820], xmm1
  }
  R_RT_Destroy(&v244, &v310);
  __asm
  {
    vmovups ymm0, ymmword ptr [rdi+3608h]
    vmovups xmm1, xmmword ptr [rsi]
    vmovups [rbp+4A40h+var_4270], ymm0
    vmovups [rbp+4A40h+var_4810], xmm1
  }
  R_RT_Destroy(&v245, &v311);
  __asm
  {
    vmovups ymm0, ymmword ptr [rdi+3628h]
    vmovups xmm1, xmmword ptr [rsi]
    vmovups [rbp+4A40h+var_4250], ymm0
    vmovups [rbp+4A40h+var_4800], xmm1
  }
  R_RT_Destroy(&v246, &v312);
  v74 = dataa;
  if ( dataa->activePrimarySunLight && (*((_BYTE *)&_RDI->viewportFeatures + 44) & 4) != 0 )
  {
    __asm
    {
      vmovups xmm0, xmmword ptr [rsi]
      vmovups [rbp+4A40h+var_47F0], xmm0
    }
    RB_SunShadow_GenerateFullScreenVisibility(&v247, _RDI, dataa);
    v74 = dataa;
  }
  __asm
  {
    vmovups xmm0, xmmword ptr [rsi]
    vmovups [rbp+4A40h+var_47E0], xmm0
  }
  RB_FillFrustumGrid(&v248, _RDI, v74);
  __asm
  {
    vmovups xmm0, xmmword ptr [rsi]
    vmovups [rbp+4A40h+var_47D0], xmm0
  }
  RB_DecalVolumes_UpdateAtlas(&v249, dataa);
  __asm
  {
    vmovups xmm0, xmmword ptr [rsi]
    vmovups [rbp+4A40h+var_47C0], xmm0
  }
  RB_RenderFrustumLightsTile(&v250, _RDI, dataa);
  R_WaitAsyncCompute(v43, dataa, COMPUTE_CONTEXT_TYPE_ASYNC_BACKEND, 0);
  __asm { vpxor   xmm0, xmm0, xmm0 }
  v202 = R_SSS_Enabled(_RDI);
  __asm { vmovdqu xmmword ptr [rbp+4A40h+var_4A80+10h], xmm0 }
  v80 = v202;
  v208.m256i_i16[0] = 0;
  v208.m256i_i32[2] = 0;
  R_InitComputeCmdBufState(&v362, dataa, COMPUTE_CONTEXT_TYPE_ASYNC_BACKEND);
  v213 = dataa->globalSceneConstantBuffer->buffer;
  R_SetComputeConstantBuffers(&v362, 7, 1, &v213);
  R_LockGfxImmediateContext();
  R_ComputeWaitForGraphics(&v362, v43);
  R_SetComputeLimitsAbsolute(&v362, COMPUTECMD_SIMD_WALK_DEFAULT, 0, 5u, 0);
  if ( _RDI->ssao.splitZones )
  {
    if ( (R_GetSSAOMode(_RDI) & 1) != 0 )
      RB_SSAO_Generate(&v362, _RDI, dataa, SSAO_ZONE_VIEW_MODEL);
    __asm
    {
      vmovups xmm0, xmmword ptr [rsi]
      vmovups [rbp+4A40h+var_47B0], xmm0
    }
    RB_SSAO_RotateRTs(&v251, _RDI);
  }
  if ( (R_GetSSAOMode(_RDI) & 2) != 0 )
  {
    __asm
    {
      vmovups ymm0, ymmword ptr [rdi+3488h]
      vmovups xmm1, xmmword ptr [rsi]
      vmovups [rbp+4A40h+var_4230], ymm0
      vmovups [rbp+4A40h+var_47A0], xmm1
    }
    R_RT_Destroy(&v252, &v313);
  }
  if ( v202 )
  {
    if ( Dvar_GetBool_Internal(r_deviceDebug) )
      goto LABEL_51;
    v83 = DCONST_DVARBOOL_r_esramPostFX;
    if ( !DCONST_DVARBOOL_r_esramPostFX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "r_esramPostFX") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v83);
    v84 = R_RT_Flag_RWView|R_RT_Flag_RTView|R_RT_Flag_PreferESRAM;
    if ( !v83->current.enabled )
LABEL_51:
      v84 = R_RT_Flag_RWView|R_RT_Flag_RTView;
    height = R_RT_Handle::GetSurface(&_RDI->sceneRtInput.m_mainSceneColorRt)->m_image.m_base.height;
    Surface = R_RT_Handle::GetSurface(&_RDI->sceneRtInput.m_mainSceneColorRt);
    _RAX = R_RT_CreateInternal(&v345, Surface->m_image.m_base.width, height, Surface->m_image.m_base.width, height, 1u, 1u, 1u, g_R_RT_renderTargetFmts[3], v84, R_RT_FlagInternal_None, &colorBlack, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, "ssss ping pong", 0, NULL, NULL, NULL, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(4346)");
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovd   eax, xmm0
      vmovups [rbp+4A40h+var_4A80], ymm0
      vmovups ymmword ptr [rbp+4A40h+var_49C0.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v221);
      if ( (R_RT_Handle::GetSurface(&v221)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm { vmovups ymm0, ymmword ptr [rbp+4A40h+var_49C0.m_surfaceID] }
        __debugbreak();
      }
      else
      {
        __asm { vmovups ymm0, ymmword ptr [rbp+4A40h+var_49C0.m_surfaceID] }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v90 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        __asm { vmovups ymm0, [rbp+4A40h+var_4A80] }
        if ( v90 )
          __debugbreak();
      }
    }
    __asm
    {
      vmovups [rbp+4A40h+var_4A80], ymm0
      vmovups [rbp+4A40h+var_4210], ymm0
    }
    R_ClearColorTargetAsync(&v362, &v314);
    v43 = _RSI->state;
    v80 = v202;
  }
  R_UnlockGfxImmediateContext();
  R_ShutdownComputeCmdBufState(&v362);
  if ( v80 )
  {
    __asm
    {
      vmovups ymm0, ymmword ptr [rdi+3100h]
      vmovups [rbp+4A40h+var_41F0], ymm0
    }
    R_AddRenderTargetTransition(v43, &v315, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    __asm
    {
      vmovups ymm0, ymmword ptr [rdi+3120h]
      vmovups [rbp+4A40h+var_41D0], ymm0
    }
    R_AddRenderTargetTransition(v43, &v316, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    R_FlushResourceTransitions(v43);
  }
  __asm
  {
    vmovups xmm0, xmmword ptr [rsi]
    vmovups [rbp+4A40h+var_4790], xmm0
  }
  RB_DrawForward_Opaque(&v253, _RDI, dataa);
  __asm
  {
    vmovups xmm0, xmmword ptr [rsi]
    vmovups [rbp+4A40h+var_4780], xmm0
  }
  R_DecalVolumes_Show3DDebug2(&v254, _RDI, dataa);
  R_LockGfxImmediateContext();
  if ( rg.debugTextureOverlay != 10 )
  {
    __asm
    {
      vmovups xmm0, xmmword ptr [rsi]
      vmovups [rbp+4A40h+var_4770], xmm0
    }
    RB_SSAO_DecommitRTs(&v255, _RDI);
  }
  R_FlushImmediateContext();
  R_UnlockGfxImmediateContext();
  GfxComputeCmdBufState = R_GetGfxComputeCmdBufState(v43);
  RB_ReflectionProbeRelighting_Update(GfxComputeCmdBufState, _RDI, dataa);
  v96 = _RSI->source;
  R_InitCmdBufSourceState(_RSI->source, &_RDI->input);
  R_InitLocalCmdBufState(v43, &v96->input);
  __asm
  {
    vmovups ymm0, ymmword ptr [rdi+30C0h]
    vmovups xmm1, xmmword ptr [rsi]
    vmovups [rbp+4A40h+var_41B0], ymm0
    vmovups [rbp+4A40h+var_4760], xmm1
  }
  R_Resolve_EliminateFastClear(&v256, &v317, 0);
  __asm
  {
    vmovups ymm0, ymmword ptr [rdi+30E0h]
    vmovups xmm1, xmmword ptr [rsi]
    vmovups [rbp+4A40h+var_4190], ymm0
    vmovups [rbp+4A40h+var_4750], xmm1
  }
  R_Resolve_EliminateFastClear(&v257, &v318, 1);
  R_ShutdownLocalCmdBufState(v43, &v96->input);
  Profile2_UpdateEntry(52);
  if ( input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 44, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE80A0) )
    __debugbreak();
  _InterlockedDecrement(&dword_14FDE80A0);
  Sys_ProfEndNamedEvent();
  Profile2_UpdateEntry(57);
  if ( ((unsigned int)&dword_14FDE80B4 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE80B4) )
    __debugbreak();
  _InterlockedIncrement(&dword_14FDE80B4);
  R_InitCmdBufSourceState(_RSI->source, &_RDI->input);
  if ( v202 )
  {
    __asm { vmovups ymm0, ymmword ptr [rdi+3100h] }
    v102 = _RSI->state;
    __asm { vmovups [rbp+4A40h+var_4170], ymm0 }
    R_AddRenderTargetTransition(v102, &v319, RENDERTARGET_TRANSITION_MODE_READ, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    __asm
    {
      vmovups ymm0, ymmword ptr [rdi+3120h]
      vmovups [rbp+4A40h+var_4150], ymm0
    }
    R_AddRenderTargetTransition(v102, &v320, RENDERTARGET_TRANSITION_MODE_READ, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    R_FlushResourceTransitions(v102);
    R_WaitAsyncCompute(v102, dataa, COMPUTE_CONTEXT_TYPE_ASYNC_BACKEND, 0);
    __asm
    {
      vmovups ymm0, [rbp+4A40h+var_4A80]
      vmovups [rbp+4A40h+var_4130], ymm0
      vmovups xmm0, xmmword ptr [rsi]
      vmovups [rbp+4A40h+var_4740], xmm0
    }
    RB_SSS_Apply(&v258, dataa, _RDI, &v321);
    __asm
    {
      vmovups ymm0, [rbp+4A40h+var_4A80]
      vmovups [rbp+4A40h+var_4110], ymm0
      vmovups xmm0, xmmword ptr [rsi]
      vmovups [rbp+4A40h+var_4730], xmm0
    }
    R_RT_Destroy(&v259, &v322);
  }
  R_InitComputeCmdBufState(&v363, dataa, COMPUTE_CONTEXT_TYPE_ASYNC_BACKEND);
  v214 = dataa->globalSceneConstantBuffer->buffer;
  R_SetComputeConstantBuffers(&v363, 7, 1, &v214);
  R_LockGfxImmediateContext();
  R_ComputeWaitForGraphics(&v363, _RSI->state);
  R_VOL_GetAccumImages(_RDI, (const GfxImage **)&scattering, (const GfxImage **)&extinction, (const GfxImage **)&visibility);
  if ( R_PostAAHasTemporalSupersampling(_RDI->postAA.mode) && _RDI->postAA.smaaTransMask )
  {
    _RAX = R_RT_CreateInternal(&v346, _RDI->sceneRtInput.sceneRtWidth >> 2, _RDI->sceneRtInput.sceneRtHeight >> 2, _RDI->sceneRtInput.maxSceneRtWidth >> 2, _RDI->sceneRtInput.maxSceneRtHeight >> 2, 1u, 1u, 1u, g_R_RT_renderTargetFmts[58], R_RT_Flag_RWView|R_RT_Flag_RTView, R_RT_FlagInternal_None, &colorBlack, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, "Post Opaque Luma", 0, NULL, NULL, NULL, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(4464)");
    __asm
    {
      vmovups ymm2, ymmword ptr [rax]
      vmovd   eax, xmm2
      vmovups [rbp+4A40h+var_4A00], ymm2
      vmovups ymmword ptr [rbp+4A40h+var_49E0.m_surfaceID], ymm2
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v220);
      if ( (R_RT_Handle::GetSurface(&v220)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm { vmovups ymm2, ymmword ptr [rbp+4A40h+var_49E0.m_surfaceID] }
        __debugbreak();
      }
      else
      {
        __asm { vmovups ymm2, ymmword ptr [rbp+4A40h+var_49E0.m_surfaceID] }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm2, 2 }
      if ( (_DWORD)_RAX )
      {
        v110 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        __asm { vmovups ymm2, [rbp+4A40h+var_4A00] }
        if ( v110 )
          __debugbreak();
      }
    }
    __asm
    {
      vmovups ymm1, ymmword ptr [rdi+3340h]
      vpxor   xmm0, xmm0, xmm0
      vmovups ymmword ptr [rdi+3750h], ymm2
      vmovdqu xmmword ptr [rbp+4A40h+var_4570+10h], xmm0
      vmovups [rbp+4A40h+var_40F0], ymm1
      vmovups ymm1, ymmword ptr [rdi+30C0h]
    }
    v287.m256i_i16[0] = 0;
    v287.m256i_i32[2] = 0;
    __asm
    {
      vmovups ymm0, [rbp+4A40h+var_4570]
      vmovups [rbp+4A40h+var_40D0], ymm0
      vmovups [rbp+4A40h+var_40B0], ymm1
      vmovups [rbp+4A40h+var_4090], ymm2
    }
    R_RunPostOpaqueProcessesLuma(&v363, _RDI, &v326, &v325, &v324, &v323, scattering, extinction, rgp.blackImage);
  }
  else
  {
    __asm
    {
      vmovups ymm1, ymmword ptr [rdi+3340h]
      vpxor   xmm0, xmm0, xmm0
      vmovdqu xmmword ptr [rbp+4A40h+var_4550+10h], xmm0
      vmovups [rbp+4A40h+var_4070], ymm1
      vmovups ymm1, ymmword ptr [rdi+30C0h]
    }
    v288.m256i_i16[0] = 0;
    v288.m256i_i32[2] = 0;
    __asm
    {
      vmovups ymm0, [rbp+4A40h+var_4550]
      vmovups [rbp+4A40h+var_4050], ymm0
      vmovups [rbp+4A40h+var_4030], ymm1
    }
    R_RunPostOpaqueProcesses(&v363, _RDI, &v329, &v328, &v327, scattering, extinction, rgp.blackImage);
  }
  R_UnlockGfxImmediateContext();
  R_ShutdownComputeCmdBufState(&v363);
  R_LockGfxImmediateContext();
  __asm
  {
    vmovups ymm0, ymmword ptr [rdi+3100h]
    vmovups xmm1, xmmword ptr [rsi]
    vmovups [rbp+4A40h+var_4010], ymm0
    vmovups [rbp+4A40h+var_4720], xmm1
  }
  R_RT_Destroy(&v260, &v330);
  __asm { vmovups xmm1, xmmword ptr [rsi] }
  _RDI->sceneRtInput.m_mainSceneSSSAlbedoRt.m_surfaceID = 0;
  _RDI->sceneRtInput.m_mainSceneSSSAlbedoRt.m_tracking.m_allocCounter = 0;
  _RDI->sceneRtInput.m_mainSceneSSSAlbedoRt.m_tracking.m_name = NULL;
  _RDI->sceneRtInput.m_mainSceneSSSAlbedoRt.m_tracking.m_location = NULL;
  __asm
  {
    vmovups ymm0, ymmword ptr [rdi+3120h]
    vmovups [rbp+4A40h+var_3FF0], ymm0
    vmovups [rbp+4A40h+var_4710], xmm1
  }
  R_RT_Destroy(&v261, &v331);
  _RDI->sceneRtInput.m_mainSceneSSSDiffuseRt.m_surfaceID = 0;
  _RDI->sceneRtInput.m_mainSceneSSSDiffuseRt.m_tracking.m_allocCounter = 0;
  _RDI->sceneRtInput.m_mainSceneSSSDiffuseRt.m_tracking.m_name = NULL;
  _RDI->sceneRtInput.m_mainSceneSSSDiffuseRt.m_tracking.m_location = NULL;
  R_FlushImmediateContext();
  R_UnlockGfxImmediateContext();
  __asm
  {
    vmovups xmm0, xmmword ptr [rsi]
    vmovups [rbp+4A40h+var_4700], xmm0
  }
  RB_DrawForward_Trans(&v262, _RDI, dataa);
  if ( _RDI->ssrWaterTrace )
  {
    R_InitComputeCmdBufState(&v364, dataa, COMPUTE_CONTEXT_TYPE_ASYNC_BACKEND);
    v215 = dataa->globalSceneConstantBuffer->buffer;
    R_SetComputeConstantBuffers(&v364, 7, 1, &v215);
    R_LockGfxImmediateContext();
    R_ComputeWaitForGraphics(&v364, _RSI->state);
    if ( (unsigned __int8)R_GetSSRMode(_RDI) >= GFX_SSR_DEFERRED_LQ )
      RB_SSR_DeferredWaterTrace(&v364, _RDI, dataa);
    R_UnlockGfxImmediateContext();
    R_ShutdownComputeCmdBufState(&v364);
  }
  __asm
  {
    vmovups xmm0, xmmword ptr [rsi]
    vmovups xmmword ptr [rbp+4A40h+var_4A00], xmm0
  }
  R_SSR_RotateRTs((GfxCmdBufContext *)&v219, _RDI);
  if ( RB_HaveAnyOcclusionQueries(_RDI->clientIndex) && (*((_DWORD *)&_RDI->viewportFeatures + 10) & 0x10000) != 0 )
  {
    R_GPU_BeginTimer(GPU_TIMER_OCCLUSION_QUERIES);
    __asm
    {
      vmovups xmm0, xmmword ptr [rsi]
      vmovups [rbp+4A40h+var_46F0], xmm0
    }
    RB_StandardDrawCommands_PreDrawOcclusionQueriesAndSun(&v263, _RDI, "OccQueries");
    __asm
    {
      vmovups ymm0, ymmword ptr [rdi+31A0h]
      vmovups xmm1, xmmword ptr [rsi]
      vmovups [rbp+4A40h+var_3FD0], ymm0
      vmovups [rbp+4A40h+var_46E0], xmm1
    }
    R_SetRenderTargetsInternal_DepthOnly(&v264, &v332, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(2322)");
    __asm
    {
      vmovups xmm0, xmmword ptr [rsi]
      vmovups [rbp+4A40h+var_46D0], xmm0
    }
    RB_DrawOcclusionQueries(&v265, _RDI);
    __asm
    {
      vmovups xmm6, xmmword ptr [rsi]
      vpextrq rbx, xmm6, 1
    }
    R_ProfEndNamedEvent(_RBX);
    __asm { vmovq   rdx, xmm6 }
    R_ShutdownLocalCmdBufState(_RBX, (GfxCmdBufInput *)(_RDX + 1792));
    R_GPU_EndTimer();
  }
  if ( RB_IsSunEnabled() )
  {
    R_GPU_BeginTimer(GPU_TIMER_SUN_QUERY);
    __asm
    {
      vmovups xmm0, xmmword ptr [rsi]
      vmovups [rbp+4A40h+var_46C0], xmm0
    }
    RB_StandardDrawCommands_PreDrawOcclusionQueriesAndSun(&v266, _RDI, "Sun");
    __asm
    {
      vmovups ymm0, ymmword ptr [rdi+31A0h]
      vmovups ymm1, ymmword ptr [rdi+30C0h]
      vmovups [rbp+4A40h+var_3FB0], ymm0
      vmovups xmm0, xmmword ptr [rsi]
      vmovups [rbp+4A40h+var_46B0], xmm0
      vmovups [rbp+4A40h+var_3F90], ymm1
    }
    R_SetRenderTargetsInternal_ColorDepth(&v267, &v334, &v333, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(2332)");
    __asm
    {
      vmovups xmm0, xmmword ptr [rsi]
      vmovups [rbp+4A40h+var_46A0], xmm0
    }
    RB_DrawSun(&v268, _RDI);
    __asm
    {
      vmovups xmm6, xmmword ptr [rsi]
      vpextrq rbx, xmm6, 1
    }
    R_ProfEndNamedEvent(_RBX);
    __asm { vmovq   rdx, xmm6 }
    R_ShutdownLocalCmdBufState(_RBX, (GfxCmdBufInput *)(_RDX + 1792));
    R_GPU_EndTimer();
  }
  Profile2_UpdateEntry(57);
  if ( ((unsigned __int64)&dword_14FDE80B4 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 44, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE80B4) )
    __debugbreak();
  _InterlockedDecrement(&dword_14FDE80B4);
  __asm
  {
    vmovups xmm0, xmmword ptr [rsi]
    vmovups [rbp+4A40h+var_4690], xmm0
  }
  RB_DrawEmissive(&v269, _RDI, dataa);
  __asm
  {
    vmovups xmm0, xmmword ptr [rsi]
    vmovups [rbp+4A40h+var_4680], xmm0
  }
  RB_DecommitEmissiveRTs(&v270, dataa, _RDI);
  __asm
  {
    vmovups ymm0, ymmword ptr [rdi+31A0h]
    vmovups ymm1, ymmword ptr [rdi+30C0h]
    vmovd   eax, xmm0
    vmovups [rbp+4A40h+var_4980], ymm0
    vmovups ymmword ptr [rbp+4A40h+var_4530.m_surfaceID], ymm0
    vmovups [rbp+4A40h+var_49A0], ymm1
    vmovups [rbp+4A40h+var_3F70], ymm1
  }
  if ( (_WORD)_EAX )
  {
    R_RT_Handle::GetSurface(&v289);
    __asm
    {
      vmovups ymm0, ymmword ptr [rbp+4A40h+var_4530.m_surfaceID]
      vmovups [rbp+4A40h+var_4980], ymm0
    }
  }
  else
  {
    __asm { vpextrd rax, xmm0, 2 }
    if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 463, ASSERT_TYPE_ASSERT, "(depthRt)", (const char *)&queryFormat, "depthRt") )
      __debugbreak();
  }
  __asm
  {
    vmovups ymm0, [rbp+4A40h+var_49A0]
    vmovd   eax, xmm0
  }
  rtGroup.m_colorRtCount = 1;
  __asm { vmovups ymmword ptr [rbp+4A40h+var_3F50.m_surfaceID], ymm0 }
  if ( (_WORD)_EAX )
  {
    R_RT_Handle::GetSurface(&v336);
  }
  else
  {
    if ( v335.m256i_i32[2] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      __debugbreak();
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 442, ASSERT_TYPE_ASSERT, "(colorRt)", (const char *)&queryFormat, "colorRt") )
      __debugbreak();
  }
  __asm
  {
    vmovups ymm0, [rbp+4A40h+var_49A0]
    vmovups ymmword ptr [rbp+4A40h+rtGroup.m_colorRts.baseclass_0.m_surfaceID], ymm0
    vmovups ymm0, [rbp+4A40h+var_4980]
    vmovups ymmword ptr [rbp+4A40h+rtGroup.m_depthRt.baseclass_0.m_surfaceID], ymm0
  }
  RB_RunDrawList(_RDI, dataa, &rtGroup, DRAWLIST_DEPTH_HACK_TRANS);
  R_LockGfxImmediateContext();
  __asm
  {
    vmovups xmm0, xmmword ptr [rsi]
    vmovups [rbp+4A40h+var_4670], xmm0
  }
  RB_StandardDrawCommands_DrawFlaresPostEmissive(&v271, _RDI, dataa);
  R_UnlockGfxImmediateContext();
  __asm
  {
    vmovups xmm0, xmmword ptr [rsi]
    vmovups [rbp+4A40h+var_4660], xmm0
  }
  RB_DecommitSunShadowRTs(&v272, dataa, _RDI);
  __asm
  {
    vmovups xmm0, xmmword ptr [rsi]
    vmovups [rbp+4A40h+var_4650], xmm0
  }
  RB_LGV_DrawProbes(&v273, _RDI);
  __asm
  {
    vmovups xmm0, xmmword ptr [rsi]
    vmovups [rbp+4A40h+var_4640], xmm0
  }
  RB_ReflectionProbe_DrawSH(&v274, _RDI);
  __asm
  {
    vmovups xmm0, xmmword ptr [rsi]
    vmovups [rbp+4A40h+var_4630], xmm0
  }
  RB_GpuLightGrid_DebugDrawVolumes(&v275, _RDI);
  R_LockGfxImmediateContext();
  __asm
  {
    vmovups ymm0, ymmword ptr [rdi+34A8h]
    vmovups xmm1, xmmword ptr [rsi]
    vmovups [rbp+4A40h+var_3F30], ymm0
    vmovups xmmword ptr [rbp+4A40h+var_4980], xmm1
  }
  R_RT_Destroy((GfxCmdBufContext *)&v223, &v337);
  __asm { vmovups xmm1, xmmword ptr [rsi] }
  _RDI->sceneRtInput.m_lightGridVolumeData3D.m_surfaceID = 0;
  _RDI->sceneRtInput.m_lightGridVolumeData3D.m_tracking.m_allocCounter = 0;
  _RDI->sceneRtInput.m_lightGridVolumeData3D.m_tracking.m_name = NULL;
  _RDI->sceneRtInput.m_lightGridVolumeData3D.m_tracking.m_location = NULL;
  __asm
  {
    vmovups ymm0, ymmword ptr [rdi+34C8h]
    vmovups [rbp+4A40h+var_3F10], ymm0
    vmovups xmmword ptr [rbp+4A40h+var_49A0], xmm1
  }
  R_RT_Destroy((GfxCmdBufContext *)&v222, &v338);
  _RDI->sceneRtInput.m_lightGridVolumeHighBandsData3D.m_surfaceID = 0;
  _RDI->sceneRtInput.m_lightGridVolumeHighBandsData3D.m_tracking.m_allocCounter = 0;
  _RDI->sceneRtInput.m_lightGridVolumeHighBandsData3D.m_tracking.m_name = NULL;
  _RDI->sceneRtInput.m_lightGridVolumeHighBandsData3D.m_tracking.m_location = NULL;
  R_FlushImmediateContext();
  R_UnlockGfxImmediateContext();
  if ( _RDI->volumeLightScatter.enabled )
  {
    __asm
    {
      vmovups xmm0, xmmword ptr [rsi]
      vmovups [rbp+4A40h+var_4620], xmm0
    }
    RB_PerformVolumeLightScatter(&v276, _RDI, dataa);
  }
  R_LockGfxImmediateContext();
  dataa->endFence = R_FlushImmediateContext();
  R_UnlockGfxImmediateContext();
  Profile2_UpdateEntry(61);
  if ( ((unsigned int)&dword_14FDE80C4 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE80C4) )
    __debugbreak();
  _InterlockedIncrement(&dword_14FDE80C4);
  Sys_ProfBeginNamedEvent(0xFFFFA500, "wait finish ready");
  Sys_ProcessWorkerCmdsWithTimeout(RB_IsFinishReady, &dataa);
  Sys_ProfEndNamedEvent();
  Profile2_UpdateEntry(61);
  if ( ((unsigned int)&dword_14FDE80C4 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 44, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE80C4) )
    __debugbreak();
  _InterlockedDecrement(&dword_14FDE80C4);
  if ( dataa->finishReady )
  {
    __asm
    {
      vmovups xmm0, xmmword ptr [rsi]
      vmovups xmmword ptr [rbp+4A40h+source], xmm0
    }
    v204 = dataa;
    if ( !_RDI->displayCmds[0] )
      goto LABEL_131;
    Sys_ProfBeginNamedEvent(0xFFFFA500, "wait hud2D ready");
    Sys_ProcessWorkerCmdsWithTimeout(RB_IsHud2DReady, &v204);
    Sys_ProfEndNamedEvent();
    if ( v204->abortReady || !_RDI->displayCmds[3] )
      goto LABEL_131;
    Sys_ProfBeginNamedEvent(0xFFFFD700, "exec cmds before postFX");
    v162 = source[0];
    R_InitCmdBufSourceState(source[0], &_RDI->input);
    v163 = (GfxCmdBufState *)source[1];
    input = &v162->input;
    R_InitLocalCmdBufState((GfxCmdBufState *)source[1], &v162->input);
    R_ProfBeginNamedEvent(v163, "2D (before postFX)");
    R_GPU_BeginTimer(GPU_TIMER_2D);
    Image = R_UniversalClut_GetImage(_RDI->clientIndex, MOVEMENT);
    __asm { vmovups ymm0, ymmword ptr [rdi+31A0h] }
    v166 = v204;
    __asm
    {
      vmovups ymm1, ymmword ptr [rdi+30C0h]
      vmovups [rbp+4A40h+var_3EF0], ymm0
      vmovups xmm0, xmmword ptr [rsi]
      vmovups [rbp+4A40h+var_4610], xmm0
      vmovups [rbp+4A40h+var_3ED0], ymm1
    }
    RB_InitClient2DReceivePPFXContext(&v277, _RDI, v204, &v340, &v339, Image);
    if ( v166->async2D.renderReceivePPFXPending )
    {
      v216 = v166;
      Sys_ProfBeginNamedEvent(0xFF008008, "wait LUI render");
      R_UnlockGfxImmediateContext();
      Sys_ProcessWorkerCmdsWithTimeout((bool (__fastcall *)(void *))RB_Async2D_ReceivePPFXFinished, &v216);
      R_LockGfxImmediateContext();
      Sys_ProfEndNamedEvent();
    }
    if ( v166->async2D.receivePPFXCmdBuf.device )
    {
      if ( !v166->async2D.renderFailed )
      {
        R_FlushImmediateContext();
        device = v166->async2D.receivePPFXCmdBuf.device;
        ((void (__fastcall *)(ID3D12CommandQueue *, __int64, GfxDevice **))g_dx.immediateCommandQueue.commandQueue->m_pFunction[3].AddRef)(g_dx.immediateCommandQueue.commandQueue, 1i64, &device);
        v166->async2D.receivePPFXCmdBuf.device = NULL;
LABEL_130:
        R_GPU_EndTimer();
        R_ProfEndNamedEvent(v163);
        R_ShutdownLocalCmdBufState(v163, input);
        Sys_ProfEndNamedEvent();
LABEL_131:
        Sys_ProfBeginNamedEvent(0xFFFFD700, "exec post3d");
        Profile2_UpdateEntry(62);
        if ( ((unsigned int)&dword_14FDE80C8 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE80C8) )
          __debugbreak();
        _InterlockedIncrement(&dword_14FDE80C8);
        __asm
        {
          vmovups xmm0, xmmword ptr [rsi]
          vmovups [rbp+4A40h+var_45F0], xmm0
        }
        RB_DrawDebugPrimitives(&v279, _RDI);
        __asm { vmovups ymm0, ymmword ptr [rdi+31A0h] }
        v173 = _RSI->state;
        __asm { vmovups [rbp+4A40h+var_3EB0], ymm0 }
        R_AddDepthStencilTransition(v173, &v341, DEPTHSTENCIL_TRANSITION_MODE_READ_PRESERVE_DEPTH_COMPRESSION, D3D12_RESOURCE_BARRIER_FLAG_NONE);
        __asm
        {
          vmovups ymm0, ymmword ptr [rdi+30C0h]
          vmovups [rbp+4A40h+var_3E90], ymm0
        }
        R_AddRenderTargetTransition(v173, &v342, RENDERTARGET_TRANSITION_MODE_READ, D3D12_RESOURCE_BARRIER_FLAG_NONE);
        __asm
        {
          vmovups ymm0, ymmword ptr [rdi+30E0h]
          vmovups [rbp+4A40h+var_3E70], ymm0
        }
        R_AddRenderTargetTransition(v173, &v343, RENDERTARGET_TRANSITION_MODE_READ, D3D12_RESOURCE_BARRIER_FLAG_NONE);
        R_FlushResourceTransitions(v173);
        R_LockGfxImmediateContext();
        __asm
        {
          vmovups ymm0, ymmword ptr [rdi+31A0h]
          vmovups xmm1, xmmword ptr [rsi]
          vmovups [rbp+4A40h+var_3E50], ymm0
          vmovups [rbp+4A40h+var_45E0], xmm1
        }
        R_RT_Destroy(&v280, &v344);
        __asm { vmovups xmm1, xmmword ptr [rsi] }
        _RDI->sceneRtInput.m_mainSceneDepthRt.m_surfaceID = 0;
        _RDI->sceneRtInput.m_mainSceneDepthRt.m_tracking.m_allocCounter = 0;
        _RDI->sceneRtInput.m_mainSceneDepthRt.m_tracking.m_name = NULL;
        _RDI->sceneRtInput.m_mainSceneDepthRt.m_tracking.m_location = NULL;
        __asm
        {
          vmovups ymm0, ymmword ptr [rdi+34E8h]
          vmovups [rbp+4A40h+var_44F0], ymm0
          vmovups [rbp+4A40h+var_45D0], xmm1
        }
        R_RT_Destroy(&v281, &v291);
        __asm { vmovups xmm1, xmmword ptr [rsi] }
        _RDI->sceneRtInput.m_gpIndexBuffer.m_surfaceID = 0;
        _RDI->sceneRtInput.m_gpIndexBuffer.m_tracking.m_allocCounter = 0;
        _RDI->sceneRtInput.m_gpIndexBuffer.m_tracking.m_name = NULL;
        _RDI->sceneRtInput.m_gpIndexBuffer.m_tracking.m_location = NULL;
        __asm
        {
          vmovups ymm0, ymmword ptr [rdi+3508h]
          vmovups [rbp+4A40h+var_44D0], ymm0
          vmovups [rbp+4A40h+var_45C0], xmm1
        }
        R_RT_Destroy(&v282, &v292);
        __asm { vmovups xmm1, xmmword ptr [rsi] }
        _RDI->sceneRtInput.m_gpIndirectArgsBuffer.m_surfaceID = 0;
        _RDI->sceneRtInput.m_gpIndirectArgsBuffer.m_tracking.m_allocCounter = 0;
        _RDI->sceneRtInput.m_gpIndirectArgsBuffer.m_tracking.m_name = NULL;
        _RDI->sceneRtInput.m_gpIndirectArgsBuffer.m_tracking.m_location = NULL;
        __asm
        {
          vmovups ymm0, ymmword ptr [rdi+3528h]
          vmovups [rbp+4A40h+var_42F0], ymm0
          vmovups [rbp+4A40h+var_45B0], xmm1
        }
        R_RT_Destroy(&v283, &v307);
        _RDI->sceneRtInput.m_gpPerSurfDataBuffer.m_surfaceID = 0;
        _RDI->sceneRtInput.m_gpPerSurfDataBuffer.m_tracking.m_allocCounter = 0;
        _RDI->sceneRtInput.m_gpPerSurfDataBuffer.m_tracking.m_name = NULL;
        _RDI->sceneRtInput.m_gpPerSurfDataBuffer.m_tracking.m_location = NULL;
        R_FlushImmediateContext();
        R_UnlockGfxImmediateContext();
        R_WaitAsyncCompute(v173, dataa, COMPUTE_CONTEXT_TYPE_ASYNC_BACKEND, 0);
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vucomiss xmm0, dword ptr [rdi+168h]
        }
        if ( !v184 )
          goto LABEL_136;
        __asm { vucomiss xmm0, dword ptr [rdi+16Ch] }
        if ( !v184 )
        {
LABEL_136:
          _RAX = _RDI;
          _RCX = &_RDI->viewParmsSet.frames[2].viewParms;
          do
          {
            _RAX = (const GfxViewInfo *)((char *)_RAX + 128);
            __asm
            {
              vmovups ymm0, ymmword ptr [rcx]
              vmovups xmm1, xmmword ptr [rcx+70h]
            }
            _RCX = (GfxViewParms *)((char *)_RCX + 128);
            __asm
            {
              vmovups ymmword ptr [rax-80h], ymm0
              vmovups ymm0, ymmword ptr [rcx-60h]
              vmovups ymmword ptr [rax-60h], ymm0
              vmovups ymm0, ymmword ptr [rcx-40h]
              vmovups ymmword ptr [rax-40h], ymm0
              vmovups xmm0, xmmword ptr [rcx-20h]
              vmovups xmmword ptr [rax-20h], xmm0
              vmovups xmmword ptr [rax-10h], xmm1
            }
            --v56;
          }
          while ( v56 );
        }
        __asm
        {
          vmovups xmm0, xmmword ptr [rsi]
          vmovups [rbp+4A40h+var_45A0], xmm0
        }
        RB_ApplyPostEffects(&v284, _RDI, dataa);
        __asm
        {
          vmovups xmm0, xmmword ptr [rsi]
          vmovups [rbp+4A40h+var_4590], xmm0
        }
        RB_BlitDebugOverlay(&v285, _RDI, *(double *)&_XMM2, a4);
        __asm
        {
          vmovups xmm0, xmmword ptr [rsi]
          vmovups [rbp+4A40h+var_4580], xmm0
        }
        RB_DecommitSceneRTs(&v286, _RDI);
        RB_AddComputeCmdsTransitions(v173, dataa, 0);
        R_FlushResourceTransitions(v173);
        v196 = dataa;
        Sys_ProfBeginNamedEvent(0xFFFFA500, "wait skipped draw workers");
        p_inCmdCount = &v196->drawOutput[0].inCmdCount;
        cmdBufValid = v196->cmdBufValid;
        do
        {
          if ( *cmdBufValid && *((_DWORD *)p_inCmdCount - 1) )
          {
            if ( *p_inCmdCount )
            {
              LODWORD(rtFlagsInternal) = v20;
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 1283, ASSERT_TYPE_ASSERT, "( ( !data->drawOutput[drawListType].inCmdCount ) )", "( drawListType ) = %i", rtFlagsInternal) )
                __debugbreak();
            }
            R_WaitDrawWorkerCmdsOfType(v196, (const GfxDrawListType)v20);
          }
          ++v20;
          ++cmdBufValid;
          p_inCmdCount += 2284;
        }
        while ( v20 < 89 );
        Sys_ProfEndNamedEvent();
        Profile2_UpdateEntry(62);
        if ( ((unsigned __int64)&dword_14FDE80C8 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 44, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE80C8) )
          __debugbreak();
        _InterlockedDecrement(&dword_14FDE80C8);
        Sys_ProfEndNamedEvent();
        goto LABEL_150;
      }
      v166->async2D.receivePPFXCmdBuf.device = NULL;
    }
    __asm { vmovups xmm0, xmmword ptr [rsi] }
    v170 = _RDI->displayCmds[3];
    __asm { vmovups [rbp+4A40h+var_4600], xmm0 }
    RB_ExecuteRenderCommandsLoop(&v278, v170, NULL);
    goto LABEL_130;
  }
LABEL_150:
  Profile_EndCSV(23);
  __asm { vmovaps xmm6, [rsp+4B60h+var_40] }
}

/*
==============
RB_Draw3DScene_FreeRts
==============
*/
void RB_Draw3DScene_FreeRts(void)
{
  RB_PostEffects_FreeTemporalRts();
  R_Velocity_FreeTemporalRts();
  R_SSAO_FreeTemporalRts();
  R_VRS_FreeRts();
  R_LGV_FreeSamplingBuffers();
  R_EffectLighting_FreeRts();
  R_VOL_FreeRts();
  R_FrustumLights_FreeRts();
  R_UniversalClut_FreeRts();
  R_SSR_FreeTemporalRts();
  R_SunShadowCache_FreeRts();
  R_SunShadowMapDebug_DestroyRTDraw3D();
  R_SpotShadow_FreeRts();
  R_ReProjFloatZ_FreeTemporalRTs();
}

/*
==============
RB_DrawDebugPrimitives
==============
*/

void __fastcall RB_DrawDebugPrimitives(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, __int64 a3, double _XMM3_8)
{
  const dvar_t *v6; 
  GfxCmdBufSourceState *source; 
  GfxCmdBufState *state; 
  __int64 v28; 
  bool v30; 
  unsigned int height; 
  const R_RT_Surface *Surface; 
  bool v39; 
  const char *v55; 
  GfxCmdBufState *v57; 
  unsigned int v60; 
  const R_RT_Surface *v61; 
  GfxCmdBufSourceState *v62; 
  R_RT_Handle v67; 
  R_RT_Handle v68; 
  R_RT_Handle v69; 
  R_RT_Handle result; 
  R_RT_Handle v71; 
  char v72; 
  __m256i v73; 
  const char *v75; 
  char v76; 
  __m256i v77; 
  __int64 v78; 
  R_RT_Group v79; 

  v6 = DCONST_DVARINT_developer;
  _R14 = viewInfo;
  _R15 = gfxContext;
  if ( !DCONST_DVARINT_developer && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "developer") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v6);
  if ( v6->current.integer && (Physics_RenderDebugEnabled() || CG_Edge_DrawDebugEnabled() || RB_Stream_TreeDebugDrawEnabled() || RB_Stream_XModelTreeDebugDrawEnabled() || RB_NeedDrawDebug()) )
  {
    source = _R15->source;
    R_InitCmdBufSourceState(_R15->source, &_R14->input);
    state = _R15->state;
    R_InitLocalCmdBufState(state, &source->input);
    R_ProfBeginNamedEvent(state, "Debug");
    __asm
    {
      vmovups ymm0, ymmword ptr [r14+31A0h]
      vmovups ymm1, ymmword ptr [r14+30C0h]
      vmovd   eax, xmm0
      vmovups ymmword ptr [rbp+2D0h+var_350.m_surfaceID], ymm0
      vmovups ymmword ptr [rbp+2D0h+var_330.m_surfaceID], ymm0
      vmovups ymmword ptr [rbp+2D0h+var_310.m_surfaceID], ymm1
      vmovups ymmword ptr [rbp+2D0h+var_2D0.m_surfaceID], ymm1
    }
    if ( (_WORD)_EAX )
    {
      R_RT_Handle::GetSurface(&v68);
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+2D0h+var_330.m_surfaceID]
        vmovups ymmword ptr [rbp+2D0h+var_350.m_surfaceID], ymm0
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 463, ASSERT_TYPE_ASSERT, "(depthRt)", (const char *)&queryFormat, "depthRt") )
        __debugbreak();
      __asm { vmovups ymm0, ymmword ptr [rbp+2D0h+var_350.m_surfaceID] }
    }
    __asm
    {
      vmovups ymmword ptr [rbp+2D0h+result.m_surfaceID], ymm0
      vmovups ymm0, ymmword ptr [rbp+2D0h+var_310.m_surfaceID]
      vmovd   eax, xmm0
    }
    v72 = 1;
    __asm { vmovups ymmword ptr [rbp+2D0h+var_330.m_surfaceID], ymm0 }
    if ( (_WORD)_EAX )
    {
      R_RT_Handle::GetSurface(&v68);
    }
    else
    {
      if ( v71.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 442, ASSERT_TYPE_ASSERT, "(colorRt)", (const char *)&queryFormat, "colorRt") )
        __debugbreak();
    }
    _RAX = &v72;
    _RCX = &v76;
    __asm
    {
      vmovups ymm3, ymmword ptr [rbp+2D0h+var_310.m_surfaceID]
      vmovups ymm2, ymmword ptr [rbp+2D0h+var_350.m_surfaceID]
      vmovups ymmword ptr [rbp+2D0h+var_2A8], ymm3
      vmovups [rbp+2D0h+var_228], ymm2
      vmovups ymm0, ymmword ptr [rax]
      vmovups ymm1, ymmword ptr [rax+80h]
      vmovups ymmword ptr [rcx], ymm0
      vmovups ymm0, ymmword ptr [rax+20h]
      vmovups ymmword ptr [rcx+20h], ymm0
      vmovups ymm0, ymmword ptr [rax+40h]
      vmovups ymmword ptr [rcx+40h], ymm0
      vmovups ymm0, ymmword ptr [rax+60h]
      vmovups ymmword ptr [rcx+60h], ymm0
      vmovups ymmword ptr [rcx+80h], ymm1
      vmovups ymm1, ymmword ptr [rax+0A0h]
    }
    v28 = (__int64)v75;
    __asm { vmovups ymmword ptr [rcx+0A0h], ymm1 }
    v78 = v28;
    __asm
    {
      vmovd   eax, xmm3
      vmovups ymmword ptr [rbp+2D0h+var_350.m_surfaceID], ymm3
    }
    if ( (_WORD)_EAX )
    {
      R_RT_Handle::GetSurface(&v67);
      if ( (R_RT_Handle::GetSurface(&v67)->m_rtFlagsInternal & 0x18) != 0 )
      {
        v30 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 396, ASSERT_TYPE_ASSERT, "(!colorRt.IsValid() || colorRt.IsColor())", (const char *)&queryFormat, "!colorRt.IsValid() || colorRt.IsColor()");
LABEL_30:
        if ( v30 )
          __debugbreak();
      }
    }
    else if ( v73.m256i_i32[2] )
    {
      v30 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", (unsigned __int16)_EAX + 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      goto LABEL_30;
    }
    __asm
    {
      vmovups ymm0, ymmword ptr [rbp+2D0h+var_350.m_surfaceID]
      vmovups ymmword ptr [rbp+2D0h+var_2D0.m_surfaceID], ymm0
    }
    _RAX = &v71;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovups ymmword ptr [rbp+2D0h+var_310.m_surfaceID], ymm0
    }
    height = R_RT_Handle::GetSurface(&v69)->m_image.m_base.height;
    Surface = R_RT_Handle::GetSurface(&v69);
    _RAX = R_RT_CreateInternal(&result, Surface->m_image.m_base.width, height, Surface->m_image.m_base.width, height, 1u, 1u, 1u, g_R_RT_renderTargetFmts[1], R_RT_Flag_RTView, R_RT_FlagInternal_None, &colorBlackBlank, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, "Debug Overlay", 0, NULL, NULL, NULL, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(975)");
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovd   eax, xmm0
      vmovups ymmword ptr [rbp+2D0h+var_350.m_surfaceID], ymm0
      vmovups ymmword ptr [rbp+2D0h+var_330.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v68);
      if ( (R_RT_Handle::GetSurface(&v68)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rbp+2D0h+var_330.m_surfaceID]
          vmovups ymmword ptr [rbp+2D0h+var_350.m_surfaceID], ymm0
        }
        __debugbreak();
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rbp+2D0h+var_330.m_surfaceID]
          vmovups ymmword ptr [rbp+2D0h+var_350.m_surfaceID], ymm0
        }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v39 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        __asm { vmovups ymm0, ymmword ptr [rbp+2D0h+var_350.m_surfaceID] }
        if ( v39 )
          __debugbreak();
      }
    }
    __asm
    {
      vmovups ymm1, ymmword ptr [rbp+2D0h+var_158]
      vmovd   eax, xmm1
      vmovups ymmword ptr [rbp+2D0h+var_330.m_surfaceID], ymm1
      vmovups ymmword ptr [rbp+2D0h+var_310.m_surfaceID], ymm1
      vmovups ymmword ptr [rbp+2D0h+result.m_surfaceID], ymm0
    }
    if ( (_WORD)_EAX )
    {
      R_RT_Handle::GetSurface(&v69);
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+2D0h+var_310.m_surfaceID]
        vmovups ymmword ptr [rbp+2D0h+var_330.m_surfaceID], ymm0
      }
    }
    else
    {
      if ( v77.m256i_i32[2] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 463, ASSERT_TYPE_ASSERT, "(depthRt)", (const char *)&queryFormat, "depthRt") )
        __debugbreak();
    }
    __asm
    {
      vmovups ymm0, ymmword ptr [rbp+2D0h+var_350.m_surfaceID]
      vmovd   eax, xmm0
    }
    v72 = 1;
    __asm { vmovups ymmword ptr [rbp+2D0h+var_2D0.m_surfaceID], ymm0 }
    if ( (_WORD)_EAX )
    {
      R_RT_Handle::GetSurface(&v71);
    }
    else
    {
      if ( result.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 442, ASSERT_TYPE_ASSERT, "(colorRt)", (const char *)&queryFormat, "colorRt") )
        __debugbreak();
    }
    __asm
    {
      vmovups ymm0, ymmword ptr [rbp+2D0h+var_350.m_surfaceID]
      vmovups ymm1, ymmword ptr [rbp+2D0h+var_330.m_surfaceID]
      vmovups ymmword ptr [rbp+2D0h+var_2A8], ymm0
      vmovups [rbp+2D0h+var_228], ymm1
    }
    _RCX = &v79;
    _RAX = &v72;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovups ymmword ptr [rcx], ymm0
      vmovups ymm0, ymmword ptr [rax+20h]
      vmovups ymmword ptr [rcx+20h], ymm0
      vmovups ymm0, ymmword ptr [rax+40h]
      vmovups ymmword ptr [rcx+40h], ymm0
      vmovups ymm0, ymmword ptr [rax+60h]
      vmovups ymmword ptr [rcx+60h], ymm0
      vmovups ymm0, ymmword ptr [rax+80h]
      vmovups ymmword ptr [rcx+80h], ymm0
      vmovups ymm0, ymmword ptr [rax+0A0h]
    }
    v55 = v75;
    __asm { vmovups ymmword ptr [rcx+0A0h], ymm0 }
    v79.m_vrsRt.m_tracking.m_location = v55;
    if ( R_RT_Handle::IsValid(&_R14->debugOverlay) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 978, ASSERT_TYPE_ASSERT, "(!viewInfo->debugOverlay)", (const char *)&queryFormat, "!viewInfo->debugOverlay") )
      __debugbreak();
    __asm { vmovups ymm0, ymmword ptr [rbp+2D0h+var_350.m_surfaceID] }
    v57 = _R15->state;
    __asm
    {
      vmovups ymmword ptr [r14+3790h], ymm0
      vmovups ymmword ptr [rbp+2D0h+result.m_surfaceID], ymm0
    }
    R_AddRenderTargetTransition(v57, (R_RT_ColorHandle *)&result, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    R_FlushResourceTransitions(v57);
    _RAX = R_RT_Group::GetValidRt(&v79, &result);
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovups ymmword ptr [rbp+2D0h+var_310.m_surfaceID], ymm0
    }
    v60 = R_RT_Handle::GetSurface(&v69)->m_image.m_base.height;
    v61 = R_RT_Handle::GetSurface(&v69);
    v62 = _R15->source;
    R_SetRenderTargetSize(_R15->source, v61->m_image.m_base.width, v60, GFX_USE_VIEWPORT_FOR_VIEW);
    __asm
    {
      vmovups xmm0, xmmword ptr [r15]
      vmovups xmmword ptr [rbp+2D0h+var_330.m_surfaceID], xmm0
    }
    R_SetRenderTargetsInternal((GfxCmdBufContext *)&v68, &v79, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(985)");
    R_ClearScreen(v57, 0xFu, 0);
    __asm
    {
      vmovups xmm0, xmmword ptr [r15]
      vmovups xmmword ptr [rbp+2D0h+var_330.m_surfaceID], xmm0
    }
    RB_UniversalClut_SetParameters((const GfxCmdBufContext *)&v68, _R14);
    R_BeginViewInternal(v62, &_R14->sceneDef, &_R14->viewParmsSet.frames[2].viewParms, NULL);
    R_SetViewportStruct(v62, &_R14->sceneViewport);
    R_Set3D(v62);
    __asm
    {
      vmovups xmm0, xmmword ptr [r15]
      vmovups xmmword ptr [rbp+2D0h+var_330.m_surfaceID], xmm0
    }
    RB_DrawDebug((GfxCmdBufContext *)&v68, &v62->viewParms, _R14);
    __asm
    {
      vmovups ymm0, ymmword ptr [rbp+2D0h+var_350.m_surfaceID]
      vmovups ymmword ptr [rbp+2D0h+result.m_surfaceID], ymm0
    }
    R_AddRenderTargetTransition(v57, (R_RT_ColorHandle *)&result, RENDERTARGET_TRANSITION_MODE_READ, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    R_FlushResourceTransitions(v57);
    R_ProfEndNamedEvent(v57);
    R_ShutdownLocalCmdBufState(v57, &v62->input);
  }
}

/*
==============
RB_DrawEmissive
==============
*/
void RB_DrawEmissive(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufState *v6; 
  ComputeContextType v8; 
  GfxCmdBufInput *p_input; 
  const GfxBackEndData *v13; 
  int integer; 
  const GfxBackEndData *v37; 
  GfxBackEndData *timeoutUserData; 
  ID3D12Resource *buffers; 
  GfxCmdBufInput *input[2]; 
  GfxCmdBufContext v50; 
  GfxCmdBufContext v51; 
  GfxCmdBufContext v52; 
  GfxCmdBufContext v53; 
  GfxCmdBufContext v54; 
  GfxCmdBufContext v55; 
  GfxCmdBufContext v56; 
  R_RT_Handle v57; 
  R_RT_ColorHandle v60; 
  R_RT_ColorHandle v61; 
  R_RT_DepthHandle v62; 
  R_RT_DepthHandle v63; 
  R_RT_DepthHandle v64; 
  R_RT_DepthHandle v65; 
  R_RT_DepthHandle v66; 
  R_RT_ColorHandle v67; 
  R_RT_ColorHandle v68; 
  R_RT_ColorHandle v69; 
  R_RT_ColorHandle v70; 
  R_RT_ColorHandle v71; 
  R_RT_ColorHandle v72; 
  __m256i v73; 
  R_RT_Handle v74; 
  R_RT_Group v75; 
  char v76[128]; 
  R_RT_Group rtGroup; 
  R_RT_Group v78; 
  ComputeCmdBufState state; 

  _RSI = viewInfo;
  _R14 = gfxContext;
  timeoutUserData = (GfxBackEndData *)data;
  Profile2_UpdateEntry(58);
  if ( ((unsigned __int8)&dword_14FDE80B8 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE80B8) )
    __debugbreak();
  _InterlockedIncrement(&dword_14FDE80B8);
  Sys_ProfBeginNamedEvent(0xFFFFA500, "wait emissive ready");
  Sys_ProcessWorkerCmdsWithTimeout(RB_IsEmissiveReady, &timeoutUserData);
  Sys_ProfEndNamedEvent();
  Profile2_UpdateEntry(58);
  if ( ((unsigned __int64)&dword_14FDE80B8 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 44, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE80B8) )
    __debugbreak();
  _InterlockedDecrement(&dword_14FDE80B8);
  v6 = _R14->state;
  R_LockIfGfxImmediateContext(v6->device);
  __asm
  {
    vmovups xmm0, xmmword ptr [r14]
    vmovups [rsp+1030h+var_FE0], xmm0
  }
  RB_StandardDrawCommands_DrawSunPost(&v50, _RSI, timeoutUserData);
  Sys_ProfBeginNamedEvent(0xFFFFD700, "exec cmds emissive");
  Profile2_UpdateEntry(60);
  if ( ((unsigned __int8)&dword_14FDE80C0 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE80C0) )
    __debugbreak();
  _InterlockedIncrement(&dword_14FDE80C0);
  v8 = COMPUTE_CONTEXT_TYPE_GFX;
  if ( r_effectLightingAsync->current.enabled )
    v8 = COMPUTE_CONTEXT_TYPE_ASYNC_BACKEND;
  R_InitComputeCmdBufState(&state, v6, timeoutUserData, v8);
  buffers = timeoutUserData->globalSceneConstantBuffer->buffer;
  R_SetComputeConstantBuffers(&state, 7, 1, &buffers);
  RB_EffectLighting(&state, _RSI);
  R_ShutdownComputeCmdBufState(&state);
  if ( r_effectLightingAsync->current.enabled )
    R_WaitAsyncCompute(v6, timeoutUserData, COMPUTE_CONTEXT_TYPE_ASYNC_BACKEND, 0);
  __asm { vmovaps [rsp+1030h+var_40], xmm6 }
  if ( rg.vrsEmissiveOnly )
  {
    __asm { vmovups xmm6, xmmword ptr [r14] }
    R_GPU_BeginTimer(GPU_TIMER_EMISSIVE_COPY);
    __asm { vmovq   rbx, xmm6 }
    R_InitCmdBufSourceState(_RBX, &_RSI->input);
    p_input = &_RBX->input;
    __asm { vpextrq rbx, xmm6, 1 }
    R_InitLocalCmdBufState(_RBX, p_input);
    v13 = _RSI->input.data;
    __asm { vmovups [rsp+1030h+var_FD0], xmm6 }
    R_HW_EnableMultiSample(&v51, v13->frameCount);
    __asm
    {
      vmovups ymm0, ymmword ptr [rsi+31C0h]
      vmovups [rbp+0F30h+var_F10], ymm0
    }
    R_AddRenderTargetTransition(_RBX, &v60, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    __asm
    {
      vmovups ymm0, ymmword ptr [rsi+31E0h]
      vmovups [rbp+0F30h+var_EF0], ymm0
    }
    R_AddRenderTargetTransition(_RBX, &v61, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    __asm
    {
      vmovups ymm0, ymmword ptr [rsi+3200h]
      vmovups [rbp+0F30h+var_ED0], ymm0
    }
    R_AddDepthStencilTransition(_RBX, &v62, DEPTHSTENCIL_TRANSITION_MODE_WRITE_PRESERVE_COMPRESSION, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    R_FlushResourceTransitions(_RBX);
    if ( r_halfResEmissivePSCopy->current.enabled )
    {
      R_ProfBeginNamedEvent(_RBX, "R_Resolve_CopyDepthTo4xMS");
      __asm
      {
        vmovups ymm0, ymmword ptr [rsi+3200h]
        vmovups ymm1, ymmword ptr [rsi+31A0h]
        vmovups [rbp+0F30h+var_EB0], ymm0
        vmovups [rbp+0F30h+var_E90], ymm1
        vmovups [rsp+1030h+var_FC0], xmm6
      }
      R_Resolve_CopyDepthTo4xMS(&v52, &v64, &v63);
      R_ProfEndNamedEvent(_RBX);
    }
    R_ShutdownLocalCmdBufState(_RBX, p_input);
    R_GPU_EndTimer();
  }
  else if ( rg.halfResEmissive )
  {
    __asm
    {
      vmovups xmm0, xmmword ptr [r14]
      vmovups [rbp+0F30h+var_FB0], xmm0
    }
    RB_HalfResEmissive_DownsampleDepth(&v53, _RSI);
  }
  R_UnlockIfGfxImmediateContext(v6->device);
  if ( !rg.debugShaderEnabled )
  {
    R_Draw_GetRtGroup(_RSI, DRAWLIST_PREPASS_COUNT, &rtGroup);
    RB_RunDrawList(_RSI, timeoutUserData, &rtGroup, DRAWLIST_PREPASS_COUNT);
    RB_RunDrawList(_RSI, timeoutUserData, &rtGroup, DRAWLIST_DEPTH_HACK_EMISSIVE);
  }
  R_LockIfGfxImmediateContext(v6->device);
  integer = 5;
  if ( rg.vrsEmissiveOnly )
  {
    __asm
    {
      vmovups xmm6, xmmword ptr [r14]
      vpextrq r12, xmm6, 1
    }
    R_GPU_BeginTimer(GPU_TIMER_EMISSIVE_COPY);
    __asm { vmovq   rbx, xmm6 }
    R_InitCmdBufSourceState(_RBX, &_RSI->input);
    input[0] = &_RBX->input;
    R_InitLocalCmdBufState(_R12, &_RBX->input);
    __asm
    {
      vmovups ymm0, ymmword ptr [rsi+3200h]
      vmovups [rbp+0F30h+var_E70], ymm0
    }
    R_AddDepthStencilTransition(_R12, &v65, DEPTHSTENCIL_TRANSITION_MODE_READ_PRESERVE_COMPRESSION, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    __asm { vpextrq rbx, xmm6, 1 }
    if ( !R_IsLockedIfGfxImmediateContext(*(const GfxDevice **)(_RBX + 1360)) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_immediate_context_lock.h", 29, ASSERT_TYPE_ASSERT, "(R_IsLockedIfGfxImmediateContext( device ))", (const char *)&queryFormat, "R_IsLockedIfGfxImmediateContext( device )") )
    {
      __debugbreak();
      v6 = _R14->state;
    }
    memset_0(v76, 0, sizeof(v76));
    (*(void (__fastcall **)(_QWORD, char *, void *, void *))(**(_QWORD **)(_RBX + 1360) + 640i64))(*(_QWORD *)(_RBX + 1360), v76, &`R_HW_DisableMultiSample'::`2'::s_samplePriorities1xMS, &`R_HW_DisableMultiSample'::`2'::s_eqaa1xMS);
    (*(void (__fastcall **)(_QWORD, _QWORD))(**(_QWORD **)(_RBX + 1360) + 512i64))(*(_QWORD *)(_RBX + 1360), 0i64);
    R_ProfBeginNamedEvent(_R12, "R_Resolve_CopyFrom4xMS");
    __asm
    {
      vmovups ymm0, ymmword ptr [rsi+31A0h]
      vmovups ymm1, ymmword ptr [rsi+30E0h]
      vmovups [rbp+0F30h+var_E50], ymm0
      vmovups ymm0, ymmword ptr [rsi+30C0h]
      vmovups [rbp+0F30h+var_E10], ymm0
      vmovups ymm0, ymmword ptr [rsi+31C0h]
      vmovups [rbp+0F30h+var_E30], ymm1
      vmovups ymm1, ymmword ptr [rsi+31E0h]
      vmovups [rbp+0F30h+var_DD0], ymm0
      vmovups [rbp+0F30h+var_DF0], ymm1
      vmovdqa [rbp+0F30h+var_FA0], xmm6
    }
    RB_Resolve_CopyFrom4xMS(&v54, &v70, &v69, &v68, &v67, &v66);
    R_ProfEndNamedEvent(_R12);
    R_ShutdownLocalCmdBufState(_R12, input[0]);
    R_GPU_EndTimer();
  }
  else if ( rg.halfResEmissive )
  {
    __asm
    {
      vmovups xmm0, xmmword ptr [r14]
      vmovups [rbp+0F30h+var_F90], xmm0
    }
    RB_HalfRes_Upsample(&v55, _RSI);
  }
  __asm { vmovaps xmm6, [rsp+1030h+var_40] }
  if ( (_RSI->matRenderFeatures & 2) != 0 )
  {
    R_GPU_BeginTimer(GPU_TIMER_RESOLVE_DISTORTION_1);
    __asm
    {
      vmovups ymm0, ymmword ptr [rsi+30C0h]
      vmovups [rbp+0F30h+var_DB0], ymm0
    }
    R_AddRenderTargetTransition(v6, &v71, RENDERTARGET_TRANSITION_MODE_READ, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    R_FlushResourceTransitions(v6);
    __asm
    {
      vmovups xmm0, xmmword ptr [r14]
      vmovups [rbp+0F30h+var_F80], xmm0
    }
    RB_ResolveDistortion(&v56, _RSI);
    __asm
    {
      vmovups ymm0, ymmword ptr [rsi+30C0h]
      vmovups [rbp+0F30h+var_D90], ymm0
    }
    R_AddRenderTargetTransition(v6, &v72, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    R_FlushResourceTransitions(v6);
    R_GPU_EndTimer();
  }
  R_UnlockIfGfxImmediateContext(v6->device);
  if ( !rg.debugShaderEnabled )
  {
    R_Draw_GetRtGroup(_RSI, DRAWLIST_DISTORT_EMISSIVE, &v78);
    RB_RunDrawList(_RSI, timeoutUserData, &v78, DRAWLIST_DISTORT_EMISSIVE);
  }
  R_LockIfGfxImmediateContext(v6->device);
  __asm
  {
    vmovups xmm0, xmmword ptr [r14]
    vmovups xmmword ptr [rsp+1030h+input], xmm0
  }
  RB_FL_RenderDebugProxies((GfxCmdBufContext *)input, _RSI);
  v37 = timeoutUserData;
  if ( particle_show_tris->current.enabled || (integer = r_showTris->current.integer) != 0 )
  {
    __asm
    {
      vmovups ymm0, ymmword ptr [rsi+31A0h]
      vmovups ymm1, ymmword ptr [rsi+30C0h]
      vmovd   eax, xmm0
      vmovups [rbp+0F30h+var_F30], ymm0
      vmovups ymmword ptr [rbp+0F30h+var_F70.m_surfaceID], ymm0
      vmovups [rbp+0F30h+var_F50], ymm1
      vmovups [rbp+0F30h+var_D70], ymm1
    }
    if ( (_WORD)_EAX )
    {
      R_RT_Handle::GetSurface(&v57);
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+0F30h+var_F70.m_surfaceID]
        vmovups [rbp+0F30h+var_F30], ymm0
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 463, ASSERT_TYPE_ASSERT, "(depthRt)", (const char *)&queryFormat, "depthRt") )
        __debugbreak();
    }
    __asm
    {
      vmovups ymm0, [rbp+0F30h+var_F50]
      vmovd   eax, xmm0
    }
    v75.m_colorRtCount = 1;
    __asm { vmovups ymmword ptr [rbp+0F30h+var_D50.m_surfaceID], ymm0 }
    if ( (_WORD)_EAX )
    {
      R_RT_Handle::GetSurface(&v74);
    }
    else
    {
      if ( v73.m256i_i32[2] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 442, ASSERT_TYPE_ASSERT, "(colorRt)", (const char *)&queryFormat, "colorRt") )
        __debugbreak();
    }
    __asm
    {
      vmovups ymm0, [rbp+0F30h+var_F50]
      vmovups ymmword ptr [rbp+0F30h+var_D30.m_colorRts.baseclass_0.m_surfaceID], ymm0
      vmovups ymm0, [rbp+0F30h+var_F30]
      vmovups ymmword ptr [rbp+0F30h+var_D30.m_depthRt.baseclass_0.m_surfaceID], ymm0
    }
    R_ShowTris_Draw(_RSI, v37, &v75, (R_SHOW_TRIS)integer);
  }
  R_UnlockIfGfxImmediateContext(_R14->state->device);
  Profile2_UpdateEntry(60);
  if ( ((unsigned __int64)&dword_14FDE80C0 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 44, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE80C0) )
    __debugbreak();
  _InterlockedDecrement(&dword_14FDE80C0);
  Sys_ProfEndNamedEvent();
}

/*
==============
RB_DrawEmissive_MapMeshes
==============
*/
void RB_DrawEmissive_MapMeshes(const GfxBackEndData *data)
{
  ;
}

/*
==============
RB_DrawEmissive_UnmapMeshes
==============
*/
void RB_DrawEmissive_UnmapMeshes(const GfxBackEndData *data)
{
  ;
}

/*
==============
RB_DrawFogSplineOverlap
==============
*/
void RB_DrawFogSplineOverlap(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, int drawFogSpline)
{
  int v17; 
  int v18; 
  GfxFogSplineBlendEntry *v21; 
  __int64 v23; 
  GfxImage *zero1DImage; 
  GfxCmdBufSourceState *source; 
  GfxCmdBufInput *p_input; 
  GfxFont *debugFont; 
  const char *v43; 
  float fmt; 
  float fmta; 
  float v65; 
  float v66; 
  float v67; 
  float v68; 
  float v69; 
  GfxCmdBufContext v70; 
  char v81; 

  __asm
  {
    vmovaps [rsp+138h+var_78], xmm10
    vmovaps [rsp+138h+var_88], xmm11
  }
  _R12 = gfxContext;
  v17 = -1;
  if ( drawFogSpline >= 2 )
    v17 = drawFogSpline - 2;
  v18 = 8;
  if ( drawFogSpline != 1 )
    v18 = v17 + 1;
  __asm
  {
    vxorps  xmm10, xmm10, xmm10
    vxorps  xmm11, xmm11, xmm11
  }
  if ( v17 < (__int64)v18 )
  {
    __asm { vmovaps [rsp+138h+var_58], xmm8 }
    v21 = &viewInfo->fog.fogSplineBlendEntry[v17];
    __asm
    {
      vmovss  xmm8, cs:__real@41400000
      vmovaps [rsp+138h+var_68], xmm9
    }
    v23 = v18 - (__int64)v17;
    __asm
    {
      vmovss  xmm9, cs:__real@41c00000
      vmovaps [rsp+138h+var_98], xmm12
      vmovss  xmm12, cs:__real@41000000
      vmovaps [rsp+138h+var_A8], xmm13
      vmovss  xmm13, cs:__real@3f800000
      vmovaps [rsp+138h+var_B8], xmm14
      vmovss  xmm14, cs:__real@3f400000
      vmovaps [rsp+138h+var_C8], xmm15
      vmovss  xmm15, cs:__real@41800000
      vmovaps [rsp+138h+var_38], xmm6
      vmovaps [rsp+138h+var_48], xmm7
    }
    while ( v17 >= 0 && (unsigned int)v17 < 8 )
    {
      if ( v17 < viewInfo->fog.fogSplineBlendCount )
      {
        zero1DImage = rgp.zero1DImage;
        if ( v21->image )
          zero1DImage = (GfxImage *)v21->image;
        goto LABEL_14;
      }
LABEL_22:
      ++v17;
      ++v21;
      if ( !--v23 )
      {
        __asm
        {
          vmovaps xmm15, [rsp+138h+var_C8]
          vmovaps xmm14, [rsp+138h+var_B8]
          vmovaps xmm13, [rsp+138h+var_A8]
          vmovaps xmm12, [rsp+138h+var_98]
          vmovaps xmm9, [rsp+138h+var_68]
          vmovaps xmm8, [rsp+138h+var_58]
          vmovaps xmm7, [rsp+138h+var_48]
          vmovaps xmm6, [rsp+138h+var_38]
        }
        goto LABEL_24;
      }
    }
    zero1DImage = (GfxImage *)RB_FogSpline_GetImage(&viewInfo->fog, viewInfo->clientIndex);
LABEL_14:
    if ( zero1DImage )
    {
      source = _R12->source;
      __asm
      {
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm0, xmm0, eax
        vxorps  xmm1, xmm1, xmm1
        vcvtsi2ss xmm1, xmm1, eax
        vmulss  xmm6, xmm1, xmm9
        vmulss  xmm7, xmm0, xmm8
      }
      if ( !_R12->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
        __debugbreak();
      p_input = &source->input;
      if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
        __debugbreak();
      __asm
      {
        vmovups xmm0, xmmword ptr [r12]
        vmovss  [rsp+138h+var_F0], xmm13
        vmovss  [rsp+138h+var_F8], xmm13
        vmovss  [rsp+138h+var_100], xmm10
        vmovss  [rsp+138h+var_108], xmm10
      }
      p_input->codeImages[4] = zero1DImage;
      __asm
      {
        vmovss  dword ptr [rsp+138h+var_110], xmm6
        vaddss  xmm3, xmm11, xmm12
        vmovaps xmm2, xmm12
        vmovss  dword ptr [rsp+138h+fmt], xmm7
        vmovups [rsp+138h+var_D8], xmm0
      }
      RB_DrawStretchPic(&v70, rgp.feedbackReplaceBackbufferMaterial, *(float *)&_XMM2, *(float *)&_XMM3, fmt, v65, v66, v67, v68, v69, 0xFFFFFFFF, GFX_PRIM_STATS_HUD);
      __asm
      {
        vmovups xmm0, xmmword ptr [r12]
        vmovups [rsp+138h+var_D8], xmm0
      }
      RB_EndTessSurfaceInternal(&v70, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(5255)");
      debugFont = backEnd.debugFont;
      v43 = j_va((const char *)&queryFormat, zero1DImage->name);
      __asm
      {
        vmovups xmm0, xmmword ptr [r12]
        vmulss  xmm1, xmm6, xmm14
        vaddss  xmm2, xmm1, xmm11
        vmovups [rsp+138h+var_D8], xmm0
        vaddss  xmm0, xmm2, xmm12
        vaddss  xmm3, xmm7, xmm15
        vmovss  dword ptr [rsp+138h+fmt], xmm0
      }
      RB_DrawText(&v70, v43, debugFont, *(float *)&_XMM3, fmta, (const GfxColor)-1);
      __asm
      {
        vmovups xmm0, xmmword ptr [r12]
        vmovups [rsp+138h+var_D8], xmm0
      }
      RB_EndTessSurfaceInternal(&v70, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(5258)");
      __asm
      {
        vmovss  xmm1, cs:__real@40c00000
        vcmpeqss xmm0, xmm11, xmm10
        vblendvps xmm2, xmm11, xmm1, xmm0
        vaddss  xmm1, xmm6, cs:__real@40400000
        vaddss  xmm11, xmm2, xmm1
      }
    }
    goto LABEL_22;
  }
LABEL_24:
  _R11 = &v81;
  __asm
  {
    vmovaps xmm10, xmmword ptr [r11-58h]
    vmovaps xmm11, xmmword ptr [r11-68h]
  }
}

/*
==============
RB_DrawFogSplineOverlap_GetImage
==============
*/
GfxImage *RB_DrawFogSplineOverlap_GetImage(const GfxViewInfo *viewInfo, int fogSplineBlendIndex)
{
  const GfxImage *image; 
  GfxImage *result; 

  if ( fogSplineBlendIndex < 0 || (unsigned int)fogSplineBlendIndex >= 8 )
    return (GfxImage *)RB_FogSpline_GetImage(&viewInfo->fog, viewInfo->clientIndex);
  if ( fogSplineBlendIndex >= viewInfo->fog.fogSplineBlendCount )
    return 0i64;
  image = viewInfo->fog.fogSplineBlendEntry[fogSplineBlendIndex].image;
  result = rgp.zero1DImage;
  if ( image )
    return (GfxImage *)image;
  return result;
}

/*
==============
RB_DrawForward_Opaque
==============
*/
void RB_DrawForward_Opaque(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxDrawListType v6; 
  R_RT_Group rtGroup; 
  R_RT_Group v8; 

  Profile2_UpdateEntry(56);
  if ( ((unsigned __int8)&dword_14FDE80B0 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE80B0) )
    __debugbreak();
  _InterlockedIncrement(&dword_14FDE80B0);
  v6 = DRAWLIST_LIT_OPAQUE;
  R_Draw_GetRtGroup(viewInfo, DRAWLIST_LIT_OPAQUE, &rtGroup);
  R_Draw_GetRtGroup(viewInfo, DRAWLIST_LIT_OPAQUE_END, &v8);
  RB_RunDrawList(viewInfo, data, &rtGroup, DRAWLIST_PRE_OPAQUE);
  RB_RunDrawList(viewInfo, data, &v8, DRAWLIST_PRE_SSS);
  if ( (*((_BYTE *)&viewInfo->input + 7920) & 2) != 0 )
  {
    do
      RB_RunDrawList(viewInfo, data, &rtGroup, v6++);
    while ( v6 != DRAWLIST_LIT_OPAQUE_END );
  }
  else
  {
    RB_RunDrawList(viewInfo, data, &rtGroup, DRAWLIST_LIT_OPAQUE);
  }
  RB_RunDrawList(viewInfo, data, &v8, DRAWLIST_LIT_OPAQUE_END);
  if ( viewInfo->ssao.splitZones )
    R_WaitAsyncCompute(gfxContext->state, data, COMPUTE_CONTEXT_TYPE_ASYNC_BACKEND, 0);
  RB_RunDrawList(viewInfo, data, &rtGroup, DRAWLIST_FIRST);
  RB_RunDrawList(viewInfo, data, &v8, DRAWLIST_DEPTH_HACK_SSS);
  RB_RunDrawList(viewInfo, data, &rtGroup, DRAWLIST_LIT_OPAQUE_GLASS);
  RB_RunDrawList(viewInfo, data, &rtGroup, DRAWLIST_LIT_DECAL);
  Profile2_UpdateEntry(56);
  if ( ((unsigned __int64)&dword_14FDE80B0 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 44, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE80B0) )
    __debugbreak();
  _InterlockedDecrement(&dword_14FDE80B0);
}

/*
==============
RB_DrawForward_Trans
==============
*/
void RB_DrawForward_Trans(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufState *state; 
  const R_RT_Surface *Surface; 
  const GfxTexture *Resident; 
  const char *m_location; 
  D3D12_RESOURCE_STATES v23; 
  const R_RT_Surface *v25; 
  const GfxTexture *v26; 
  GfxCmdBufContext v30; 
  __m256i v31; 
  R_RT_Handle v32; 
  R_RT_ColorHandle v33; 
  R_RT_ColorHandle v34; 
  R_RT_ColorHandle v35; 
  R_RT_Handle v36; 
  R_RT_ColorHandle v37; 
  R_RT_ColorHandle v38; 
  R_RT_Group v39; 
  R_RT_Group rtGroup; 
  R_RT_Group v41; 

  _RBX = viewInfo;
  _R15 = gfxContext;
  if ( &data->viewInfo[data->viewInfoIndex] != viewInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 5640, ASSERT_TYPE_ASSERT, "(&data->viewInfo[data->viewInfoIndex] == viewInfo)", (const char *)&queryFormat, "&data->viewInfo[data->viewInfoIndex] == viewInfo") )
    __debugbreak();
  __asm { vmovups ymm0, ymmword ptr [rbx+30C0h] }
  state = _R15->state;
  __asm { vmovups [rbp+300h+var_370], ymm0 }
  R_AddRenderTargetTransition(state, &v33, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  __asm
  {
    vmovups ymm0, ymmword ptr [rbx+30E0h]
    vmovups [rbp+300h+var_350], ymm0
  }
  R_AddRenderTargetTransition(state, &v34, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  R_FlushResourceTransitions(state);
  R_Draw_GetRtGroup(_RBX, DRAWLIST_LIT_TRANS, &rtGroup);
  __asm
  {
    vmovups ymm0, ymmword ptr [rbx+33A0h]
    vmovups [rsp+400h+var_3B0], ymm0
    vmovups ymmword ptr [rsp+400h+var_390.m_surfaceID], ymm0
  }
  Surface = R_RT_Handle::GetSurface(&v32);
  Resident = R_Texture_GetResident(Surface->m_image.m_base.textureId);
  R_HW_AddResourceTransition(state, Resident, 0xFFFFFFFF, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  R_FlushResourceTransitions(state);
  __asm
  {
    vmovups ymm0, [rsp+400h+var_3B0]
    vmovups [rbp+300h+var_330], ymm0
  }
  R_RT_Group::AssignColor(&v39, &v35);
  _RCX = &v41;
  _RAX = &v39;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovups ymm1, ymmword ptr [rax+80h]
    vmovups ymmword ptr [rcx], ymm0
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovups ymmword ptr [rcx+20h], ymm0
    vmovups ymm0, ymmword ptr [rax+40h]
    vmovups ymmword ptr [rcx+40h], ymm0
    vmovups ymm0, ymmword ptr [rax+60h]
    vmovups ymmword ptr [rcx+60h], ymm0
    vmovups xmm0, xmmword ptr [r15]
    vmovups ymmword ptr [rcx+80h], ymm1
    vmovups ymm1, ymmword ptr [rax+0A0h]
  }
  m_location = v39.m_vrsRt.m_tracking.m_location;
  __asm { vmovups ymmword ptr [rcx+0A0h], ymm1 }
  v41.m_vrsRt.m_tracking.m_location = m_location;
  __asm { vmovups [rsp+400h+var_3C0], xmm0 }
  R_ClearRenderTarget(&v30, &v41, 0xFu, 0);
  v23 = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
  if ( (_RBX->matRenderFeatures & 4) != 0 )
  {
    __asm
    {
      vmovups ymm0, ymmword ptr [rsp+400h+var_390.m_surfaceID]
      vmovups [rbp+300h+var_310], ymm0
    }
    R_HW_AddResourceTransition(state, &v36, 0xFFFFFFFF, D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    R_FlushResourceTransitions(state);
  }
  RB_RunDrawList(_RBX, data, &rtGroup, DRAWLIST_LIT_TRANS);
  if ( (_RBX->matRenderFeatures & 4) == 0 )
    v23 = D3D12_RESOURCE_STATE_RENDER_TARGET;
  v25 = R_RT_Handle::GetSurface(&v32);
  v26 = R_Texture_GetResident(v25->m_image.m_base.textureId);
  R_HW_AddResourceTransition(state, v26, 0xFFFFFFFF, v23, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  R_FlushResourceTransitions(state);
  if ( (_RBX->matRenderFeatures & 1) != 0 )
  {
    R_GPU_BeginTimer(GPU_TIMER_RESOLVE_DISTORTION_0);
    __asm
    {
      vmovups ymm0, ymmword ptr [rbx+30C0h]
      vmovups [rbp+300h+var_2F0], ymm0
    }
    R_AddRenderTargetTransition(state, &v37, RENDERTARGET_TRANSITION_MODE_READ, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    R_FlushResourceTransitions(state);
    __asm
    {
      vmovups xmm0, xmmword ptr [r15]
      vmovups xmmword ptr [rsp+400h+var_3B0], xmm0
    }
    RB_ResolveDistortion((GfxCmdBufContext *)&v31, _RBX);
    __asm
    {
      vmovups ymm0, ymmword ptr [rbx+30C0h]
      vmovups [rbp+300h+var_2D0], ymm0
    }
    R_AddRenderTargetTransition(state, &v38, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    R_FlushResourceTransitions(state);
    R_GPU_EndTimer();
  }
  RB_RunDrawList(_RBX, data, &rtGroup, DRAWLIST_LIT_TRANS1);
}

/*
==============
RB_DrawHeightmapOverlay
==============
*/
void RB_DrawHeightmapOverlay(GfxCmdBufContext *gfxContext)
{
  __int64 viewInfoIndex; 
  GfxViewInfo *viewInfo; 
  __int64 voxelTreeZoneIndex; 
  GfxWorld *world; 
  char v40; 
  char v41; 
  char v66; 
  char v67; 
  GfxFont *debugFont; 
  const char *v91; 
  const char *v95; 
  GfxFont *v96; 
  const char *v97; 
  float v106; 
  double v107; 
  float v108; 
  float v109; 
  float v110; 
  double v111; 
  float v112; 
  double v113; 
  float v114; 
  double v115; 
  float v116; 
  float v117; 
  GfxCmdBufContext v118; 
  vec4_t out; 
  void *retaddr; 

  _R11 = &retaddr;
  _RDI = gfxContext;
  viewInfoIndex = backEndData->viewInfoIndex;
  viewInfo = backEndData->viewInfo;
  voxelTreeZoneIndex = (int)viewInfo[viewInfoIndex].input.voxelTreeZoneIndex;
  if ( (int)voxelTreeZoneIndex >= 0 )
  {
    world = rgp.world;
    if ( (int)voxelTreeZoneIndex < rgp.world->heightfieldCount )
    {
      __asm
      {
        vmovaps xmmword ptr [r11-18h], xmm6
        vmovaps xmmword ptr [r11-28h], xmm7
        vmovaps xmmword ptr [r11-38h], xmm8
        vmovaps xmmword ptr [r11-48h], xmm9
        vmovaps xmmword ptr [r11-58h], xmm10
        vmovaps xmmword ptr [r11-68h], xmm11
        vmovaps xmmword ptr [r11-78h], xmm12
        vmovaps xmmword ptr [r11-88h], xmm13
        vmovaps xmmword ptr [r11-98h], xmm14
      }
      _RBP = (__int64)&world->heightfields[voxelTreeZoneIndex];
      __asm { vmovaps xmmword ptr [r11-0A8h], xmm15 }
      MatrixTransformPos44(&viewInfo[viewInfoIndex].viewParmsSet.frames[0].viewParms.camera.origin, (const tmat44_t<vec4_t> *)(_RBP + 24), &out);
      _RBX = _RDI->source;
      __asm
      {
        vmovss  xmm2, dword ptr [rsp+138h+out+8]
        vmovss  xmm1, dword ptr [rsp+138h+out+4]
        vmovss  xmm0, dword ptr [rsp+138h+out]
        vmovss  xmm8, cs:__real@3f800000
        vmovss  xmm12, cs:__real@40000000
        vmovss  dword ptr [rbx+960h], xmm0
        vmovss  dword ptr [rbx+964h], xmm1
        vmovss  dword ptr [rbx+968h], xmm2
      }
      _RBX->input.consts[38].v[3] = 0.0;
      ++_RBX->constVersions[38];
      __asm
      {
        vxorps  xmm13, xmm13, xmm13
        vdivss  xmm6, xmm8, dword ptr [rax+28h]
        vsubss  xmm0, xmm8, xmm6
        vmulss  xmm14, xmm0, dword ptr [rsp+138h+out+4]
        vmulss  xmm15, xmm0, dword ptr [rsp+138h+out]
        vaddss  xmm1, xmm14, xmm6
        vaddss  xmm0, xmm15, xmm6
        vmovss  [rsp+138h+var_C4], xmm0
        vmovss  xmm0, dword ptr [rbp+10h]
        vdivss  xmm11, xmm0, dword ptr [rbp+0Ch]
        vmovss  [rsp+138h+var_C8], xmm1
        vmovss  xmm1, dword ptr [rbx+2CE8h]
        vmulss  xmm2, xmm1, cs:__real@40490fdb
        vcvtsi2ss xmm13, xmm13, rax
        vmulss  xmm0, xmm13, cs:__real@3e000000
        vmaxss  xmm10, xmm0, cs:__real@43800000
        vmulss  xmm0, xmm2, xmm12
        vmulss  xmm0, xmm0, xmm12; X
      }
      *(float *)&_XMM0 = sinf_0(*(float *)&_XMM0);
      __asm
      {
        vcomiss xmm11, xmm8
        vmovss  xmm9, cs:__real@41000000
        vaddss  xmm1, xmm0, xmm8
        vmulss  xmm3, xmm1, cs:__real@3f000000
        vsubss  xmm0, xmm8, xmm3
        vmulss  xmm1, xmm0, cs:__real@3f000000
        vaddss  xmm4, xmm1, xmm3
        vdivss  xmm0, xmm9, xmm10
        vmulss  xmm1, xmm4, xmm0
        vmulss  xmm3, xmm1, xmm6
        vmovaps xmm6, xmm10
        vmovaps xmm7, xmm10
        vmulss  xmm2, xmm10, xmm11
      }
      if ( v40 | v41 )
      {
        __asm
        {
          vmulss  xmm0, xmm13, cs:__real@3f400000
          vcomiss xmm2, xmm0
          vmovaps xmm7, xmm2
        }
        if ( !(v40 | v41) )
        {
          __asm
          {
            vmovaps xmm7, xmm0
            vdivss  xmm0, xmm0, xmm2
            vmulss  xmm6, xmm0, xmm10
          }
        }
        __asm { vmovss  dword ptr [rbx+970h], xmm11 }
        _RBX->input.consts[39].v[1] = 1.0;
      }
      else
      {
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, rax
          vmulss  xmm1, xmm0, cs:__real@3f400000
          vcomiss xmm2, xmm1
          vmovaps xmm6, xmm2
        }
        if ( !(v40 | v41) )
        {
          __asm
          {
            vdivss  xmm0, xmm1, xmm2
            vmulss  xmm7, xmm0, xmm10
            vmovaps xmm6, xmm1
          }
        }
        __asm { vmovss  dword ptr [rbx+974h], xmm11 }
        _RBX->input.consts[39].v[0] = 1.0;
      }
      __asm { vmovss  dword ptr [rbx+978h], xmm3 }
      _RBX->input.consts[39].v[3] = 0.0;
      ++_RBX->constVersions[39];
      R_SetCodeImageTextureInternal(_RBX, 4u, *(const GfxImage **)(_RBP + 88), "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(5079)");
      __asm
      {
        vmovups xmm0, xmmword ptr [rdi]
        vmovss  xmm1, [rsp+138h+var_C4]
        vmovups [rsp+138h+var_D8], xmm0
        vmovss  xmm0, [rsp+138h+var_C8]
        vmovss  [rsp+138h+var_F0], xmm0
        vmovss  [rsp+138h+var_F8], xmm1
        vmovss  dword ptr [rsp+138h+var_100], xmm14
        vmovss  dword ptr [rsp+138h+var_108], xmm15
        vmovss  dword ptr [rsp+138h+var_110], xmm6
        vmovaps xmm3, xmm9
        vmovaps xmm2, xmm9
        vmovss  dword ptr [rsp+138h+var_118], xmm7
      }
      RB_DrawStretchPic(&v118, rgp.showHeightmap, *(float *)&_XMM2, *(float *)&_XMM3, v106, v110, v112, v114, v116, v117, 0xFFFFFFFF, GFX_PRIM_STATS_HUD);
      __asm
      {
        vmovups xmm0, xmmword ptr [rdi]
        vmovups [rsp+138h+var_D8], xmm0
      }
      RB_EndTessSurfaceInternal(&v118, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(5081)");
      __asm
      {
        vmovss  xmm1, dword ptr [rsp+138h+out]
        vmovaps xmm15, [rsp+138h+var_A8]
        vmovaps xmm14, [rsp+138h+var_98]
        vmovaps xmm13, [rsp+138h+var_88]
        vmovaps xmm11, [rsp+138h+var_68]
        vmovaps xmm10, [rsp+138h+var_58]
        vmovaps xmm7, [rsp+138h+var_28]
        vxorps  xmm0, xmm0, xmm0
        vcomiss xmm1, xmm0
      }
      if ( v66 )
        goto LABEL_17;
      __asm { vcomiss xmm1, xmm8 }
      if ( !(v66 | v67) )
        goto LABEL_17;
      __asm
      {
        vmovss  xmm1, dword ptr [rsp+138h+out+4]
        vcomiss xmm1, xmm0
        vcomiss xmm1, xmm8
      }
      if ( !(v66 | v67) )
        goto LABEL_17;
      __asm
      {
        vmovss  xmm1, dword ptr [rsp+138h+out+8]
        vcomiss xmm1, xmm0
        vcomiss xmm1, xmm8
      }
      if ( v66 | v67 )
      {
        __asm
        {
          vmovss  xmm0, dword ptr [rbp+0Ch]
          vmovss  xmm1, dword ptr [rbp+10h]
        }
        _RAX = r_showHeightmapScale;
        debugFont = backEnd.debugFont;
        __asm
        {
          vmulss  xmm5, xmm0, xmm12
          vmovss  xmm0, dword ptr [rbp+14h]
          vmulss  xmm2, xmm0, xmm12
          vmovss  xmm0, dword ptr [rax+28h]
          vmulss  xmm3, xmm1, xmm12
          vcvtss2sd xmm0, xmm0, xmm0
          vmovsd  [rsp+138h+var_100], xmm0
          vcvtss2sd xmm1, xmm2, xmm2
          vmovsd  [rsp+138h+var_108], xmm1
          vcvtss2sd xmm4, xmm3, xmm3
          vcvtss2sd xmm5, xmm5, xmm5
          vmovsd  [rsp+138h+var_110], xmm4
          vmovsd  [rsp+138h+var_118], xmm5
        }
        v91 = j_va("zone%d image=%dx%d bound=%3.0fx%3.0fx%3.0f zoom=%4.1f", (unsigned int)voxelTreeZoneIndex, *(unsigned __int16 *)(*(_QWORD *)(_RBP + 88) + 36i64), *(unsigned __int16 *)(*(_QWORD *)(_RBP + 88) + 38i64), v107, v111, v113, v115);
        __asm
        {
          vmovups xmm0, xmmword ptr [rdi]
          vaddss  xmm1, xmm6, cs:__real@41e00000
          vmovaps xmm3, xmm9
          vmovss  dword ptr [rsp+138h+var_118], xmm1
          vmovups [rsp+138h+var_D8], xmm0
        }
        RB_DrawText(&v118, v91, debugFont, *(float *)&_XMM3, v108, (const GfxColor)-1);
        v95 = "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(5095)";
      }
      else
      {
LABEL_17:
        v96 = backEnd.debugFont;
        v97 = j_va("camera is outside zone%d heightmap coverage", (unsigned int)voxelTreeZoneIndex);
        __asm
        {
          vmovups xmm0, xmmword ptr [rdi]
          vaddss  xmm1, xmm6, cs:__real@41e00000
          vmovaps xmm3, xmm9
          vmovss  dword ptr [rsp+138h+var_118], xmm1
          vmovups [rsp+138h+var_D8], xmm0
        }
        RB_DrawText(&v118, v97, v96, *(float *)&_XMM3, v109, (const GfxColor)-16776961);
        v95 = "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(5103)";
      }
      __asm
      {
        vmovups xmm0, xmmword ptr [rdi]
        vmovups [rsp+138h+var_D8], xmm0
      }
      RB_EndTessSurfaceInternal(&v118, v95);
      __asm
      {
        vmovaps xmm9, [rsp+138h+var_48]
        vmovaps xmm8, [rsp+138h+var_38]
        vmovaps xmm6, [rsp+138h+var_18]
        vmovaps xmm12, [rsp+138h+var_78]
      }
    }
  }
}

/*
==============
RB_DrawLightmapOverlap
==============
*/
void RB_DrawLightmapOverlap(GfxCmdBufContext *gfxContext, const GfxBackEndData *data, unsigned int drawLightmap)
{
  signed __int64 v3; 
  void *v15; 
  GfxLightmapType lightmapType; 
  unsigned int v21; 
  unsigned int v33; 
  const GfxImage *LightmapAtlasTexture; 
  __int64 *v43; 
  int v45; 
  signed int v46; 
  const GfxImage *v53; 
  GfxFont *debugFont; 
  const char *v68; 
  GfxFont *v71; 
  const char *v81; 
  unsigned int LightmapAtlasLightmapsCount; 
  XZoneHandleUnique *p_worldIndex; 
  unsigned int v91; 
  unsigned __int16 *p_m_zoneIndex; 
  __int64 v93; 
  const char *ZoneNameFromIndex; 
  GfxFont *v95; 
  const char *v96; 
  GfxFont *v99; 
  unsigned int v104; 
  const char *v105; 
  const char *v106; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float fmtc; 
  float fmtd; 
  float fmte; 
  float fmtf; 
  float worldIndex; 
  float zone; 
  float v121; 
  float v122; 
  float v123; 
  GfxCmdBufContext v124; 
  RB_DrawLightmapOverlap::__l2::<lambda_4b68385f17aa2fbc2ee34f13383fa2c0> v125; 
  unsigned int v126; 
  unsigned int NumLightmapAtlasSlices; 
  GfxCmdBufContext *v128; 
  __int64 v129; 
  RB_DrawLightmapOverlap::__l2::DebugLightmapDesc _Last[1024]; 

  v15 = alloca(v3);
  __asm
  {
    vmovaps [rsp+4170h+var_40], xmm6
    vmovaps [rsp+4170h+var_50], xmm7
  }
  _R15 = gfxContext;
  lightmapType = g_worldDraw->lightmapType;
  __asm
  {
    vmovaps [rsp+4170h+var_60], xmm8
    vmovaps [rsp+4170h+var_70], xmm9
  }
  v128 = gfxContext;
  __asm
  {
    vmovaps [rsp+4170h+var_90], xmm11
    vmovaps [rsp+4170h+var_C0], xmm14
    vmovss  xmm8, cs:__real@3f800000
    vmovss  xmm14, cs:__real@41000000
  }
  v21 = 0;
  NumLightmapAtlasSlices = RB_GetNumLightmapAtlasSlices(data, lightmapType);
  v126 = 0;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rcx
    vdivss  xmm0, xmm8, xmm0
    vminss  xmm2, xmm0, cs:__real@3e4ccccd
    vxorps  xmm1, xmm1, xmm1
    vcvtsi2ss xmm1, xmm1, rcx
    vmulss  xmm9, xmm2, xmm1
    vmovaps xmm11, xmm14
  }
  if ( NumLightmapAtlasSlices )
  {
    __asm
    {
      vmovaps [rsp+4170h+var_80], xmm10
      vmovaps [rsp+4170h+var_A0], xmm12
      vmovaps [rsp+4170h+var_B0], xmm13
      vaddss  xmm12, xmm9, xmm8
      vxorps  xmm10, xmm10, xmm10
    }
    do
    {
      __asm { vmovups xmm7, xmmword ptr [r15] }
      v33 = 0;
      __asm
      {
        vxorps  xmm13, xmm13, xmm13
        vmovups [rsp+4170h+var_4110], xmm7
      }
      _RBX = v124.source;
      __asm
      {
        vmovaps xmm6, xmm14
        vcvtsi2ss xmm13, xmm13, rax
      }
      do
      {
        LightmapAtlasTexture = R_GetLightmapAtlasTexture(data, g_worldDraw->lightmapType, v33);
        if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
          __debugbreak();
        if ( _RBX == (GfxCmdBufSourceState *)-1792i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
          __debugbreak();
        __asm
        {
          vmovss  [rsp+4170h+var_4128], xmm8
          vmovss  [rsp+4170h+var_4130], xmm8
          vmovss  [rsp+4170h+var_4138], xmm10
          vmovss  dword ptr [rbx+1050h], xmm13
        }
        _RBX->input.codeImages[4] = LightmapAtlasTexture;
        *(_QWORD *)&_RBX->input.consts[149].xyz.y = 0i64;
        _RBX->input.consts[149].v[3] = 0.0;
        ++_RBX->constVersions[149];
        __asm
        {
          vmovss  dword ptr [rsp+4170h+zone], xmm10
          vmovss  dword ptr [rsp+4170h+worldIndex], xmm9
          vmovaps xmm3, xmm6
          vmovaps xmm2, xmm11
          vmovss  dword ptr [rsp+4170h+fmt], xmm9
          vmovdqa [rsp+4170h+var_4110], xmm7
        }
        RB_DrawStretchPic(&v124, rgp.lightmapAtlasDebugMaterial, *(float *)&_XMM2, *(float *)&_XMM3, fmt, worldIndex, zone, v121, v122, v123, 0xFFFFFFFF, GFX_PRIM_STATS_HUD);
        __asm { vmovdqa [rsp+4170h+var_4110], xmm7 }
        RB_EndTessSurfaceInternal(&v124, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(4883)");
        ++v33;
        __asm { vaddss  xmm6, xmm6, xmm12 }
      }
      while ( v33 < 3 );
      _R15 = v128;
      __asm { vaddss  xmm11, xmm11, xmm12 }
      ++v126;
    }
    while ( v126 < NumLightmapAtlasSlices );
    __asm
    {
      vmovaps xmm13, [rsp+4170h+var_B0]
      vmovaps xmm12, [rsp+4170h+var_A0]
      vmovaps xmm10, [rsp+4170h+var_80]
    }
  }
  v43 = &v129;
  __asm { vmovaps xmm9, [rsp+4170h+var_70] }
  v45 = 0;
  v46 = 0;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, dword ptr [rax+8]
    vaddss  xmm6, xmm0, xmm14
    vmovaps xmm14, [rsp+4170h+var_C0]
    vaddss  xmm7, xmm11, xmm8
    vmovaps xmm11, [rsp+4170h+var_90]
  }
  do
  {
    v53 = R_GetLightmapAtlasTexture(data, g_worldDraw->lightmapType, v46++);
    *v43++ = (__int64)v53;
    v45 += v53->totalSize;
  }
  while ( v46 < 3 );
  __asm
  {
    vmovups xmm0, xmmword ptr [r15]
    vmovaps xmm3, xmm7
    vmovups [rsp+4170h+var_4110], xmm0
    vmovss  dword ptr [rsp+4170h+fmt], xmm6
  }
  RB_DrawText(&v124, "Lightmap atlas stats", backEnd.debugFont, *(float *)&_XMM3, fmta, (const GfxColor)-1);
  __asm
  {
    vmovups xmm1, xmmword ptr [r15]
    vmovss  xmm8, cs:__real@40400000
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, dword ptr [r8+8]
    vaddss  xmm0, xmm0, xmm8
    vaddss  xmm6, xmm6, xmm0
    vmovaps xmm3, xmm7
    vmovss  dword ptr [rsp+4170h+fmt], xmm6
    vmovups [rsp+4170h+var_4110], xmm1
  }
  RB_DrawText(&v124, "--------------------", backEnd.debugFont, *(float *)&_XMM3, fmtb, (const GfxColor)-1);
  debugFont = backEnd.debugFont;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, dword ptr [rbx+8]
    vaddss  xmm1, xmm0, xmm8
    vaddss  xmm6, xmm6, xmm1
  }
  v68 = j_va("Size: %dx%d, num slices %d", *(unsigned __int16 *)(v129 + 36), *(unsigned __int16 *)(v129 + 38), NumLightmapAtlasSlices);
  __asm
  {
    vmovups xmm0, xmmword ptr [r15]
    vmovaps xmm3, xmm7
    vmovups [rsp+4170h+var_4110], xmm0
    vmovss  dword ptr [rsp+4170h+fmt], xmm6
  }
  RB_DrawText(&v124, v68, debugFont, *(float *)&_XMM3, fmtc, (const GfxColor)-1);
  v71 = backEnd.debugFont;
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, dword ptr [rbx+8]
    vaddss  xmm1, xmm0, xmm8
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, rax
    vaddss  xmm6, xmm6, xmm1
    vmulss  xmm1, xmm0, cs:__real@35800000
    vcvtss2sd xmm2, xmm1, xmm1
    vmovq   r8, xmm2
  }
  v81 = j_va("Setup type: %s, atlas memory %.2f MB", lightmapTypeNames[g_worldDraw->lightmapType], _R8);
  __asm
  {
    vmovups xmm0, xmmword ptr [r15]
    vmovaps xmm3, xmm7
    vmovups [rsp+4170h+var_4110], xmm0
    vmovss  dword ptr [rsp+4170h+fmt], xmm6
  }
  RB_DrawText(&v124, v81, v71, *(float *)&_XMM3, fmtd, (const GfxColor)-1);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, dword ptr [rax+8]
    vaddss  xmm1, xmm0, xmm8
    vaddss  xmm6, xmm6, xmm1
  }
  LightmapAtlasLightmapsCount = RB_Debug_GetLightmapAtlasLightmapsCount(data, g_worldDraw->lightmapType);
  if ( LightmapAtlasLightmapsCount > 0x400 )
    LightmapAtlasLightmapsCount = 1024;
  if ( LightmapAtlasLightmapsCount )
  {
    p_worldIndex = (XZoneHandleUnique *)&_Last[0].worldIndex;
    do
    {
      RB_Debug_GetLightmapAtlasLightmapDesc(data, g_worldDraw->lightmapType, v21++, &p_worldIndex[-2].m_packed, &p_worldIndex[-1].m_packed, &p_worldIndex->m_packed, p_worldIndex + 1);
      p_worldIndex += 4;
    }
    while ( v21 < LightmapAtlasLightmapsCount );
  }
  std::_Sort_unchecked__RB_DrawLightmapOverlap_::_2_::DebugLightmapDesc____lambda_4b68385f17aa2fbc2ee34f13383fa2c0___(_Last, &_Last[LightmapAtlasLightmapsCount], LightmapAtlasLightmapsCount, v125);
  _R12 = v128;
  v91 = 20;
  if ( LightmapAtlasLightmapsCount < 0x14 )
    v91 = LightmapAtlasLightmapsCount;
  if ( v91 )
  {
    p_m_zoneIndex = &_Last[0].zone.m_zoneIndex;
    v93 = v91;
    do
    {
      if ( DB_Zones_IsValidZoneIndex(*p_m_zoneIndex) )
        ZoneNameFromIndex = DB_Zones_GetZoneNameFromIndex(*p_m_zoneIndex);
      else
        ZoneNameFromIndex = "<unloading>";
      v95 = backEnd.debugFont;
      v96 = j_va("Lightmap %03d, %dx%d, zone %s", *(unsigned int *)(p_m_zoneIndex - 3), *(unsigned int *)(p_m_zoneIndex - 7), *(unsigned int *)(p_m_zoneIndex - 5), ZoneNameFromIndex);
      __asm
      {
        vmovups xmm0, xmmword ptr [r12]
        vmovaps xmm3, xmm7
        vmovups [rsp+4170h+var_4110], xmm0
        vmovss  dword ptr [rsp+4170h+fmt], xmm6
      }
      RB_DrawText(&v124, v96, v95, *(float *)&_XMM3, fmte, (const GfxColor)-1);
      v99 = backEnd.debugFont;
      p_m_zoneIndex += 8;
      __asm
      {
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm0, xmm0, dword ptr [rbx+8]
        vaddss  xmm1, xmm0, xmm8
        vaddss  xmm6, xmm6, xmm1
      }
      --v93;
    }
    while ( v93 );
  }
  else
  {
    v99 = backEnd.debugFont;
  }
  __asm { vmovaps xmm8, [rsp+4170h+var_60] }
  if ( v91 < LightmapAtlasLightmapsCount )
  {
    v104 = LightmapAtlasLightmapsCount - v91;
    v105 = "s";
    if ( v104 == 1 )
      v105 = (char *)&queryFormat.fmt + 3;
    v106 = j_va("...and %d more, smaller one%s", v104, v105);
    __asm
    {
      vmovups xmm0, xmmword ptr [r12]
      vmovaps xmm3, xmm7
      vmovups [rsp+4170h+var_4110], xmm0
      vmovss  dword ptr [rsp+4170h+fmt], xmm6
    }
    RB_DrawText(&v124, v106, v99, *(float *)&_XMM3, fmtf, (const GfxColor)-1);
  }
  __asm
  {
    vmovups xmm0, xmmword ptr [r12]
    vmovups [rsp+4170h+var_4110], xmm0
  }
  RB_EndTessSurfaceInternal(&v124, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(5016)");
  __asm
  {
    vmovaps xmm6, [rsp+4170h+var_40]
    vmovaps xmm7, [rsp+4170h+var_50]
  }
}

/*
==============
RB_DrawPrepass
==============
*/
void RB_DrawPrepass(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  unsigned __int16 m_surfaceID; 
  __int16 v10; 
  __int16 v11; 
  bool v15; 
  __int64 v17; 
  unsigned __int64 v24; 
  unsigned int height; 
  const R_RT_Surface *Surface; 
  const R_RT_Surface *v43; 
  const GfxTexture *Resident; 
  CmdBufState *state; 
  const char *m_location; 
  GfxDrawListType i; 
  float fmt; 
  float flag; 
  float v61; 
  float v62; 
  float v63; 
  float v64; 
  float v65; 
  float v66; 
  GfxCmdBufSourceState *source[4]; 
  unsigned __int64 v69; 
  GfxCmdBufContext v70; 
  GfxCmdBufContext v71; 
  GfxCmdBufContext v72; 
  R_RT_Handle v73; 
  R_RT_Handle v74; 
  R_RT_Handle v76; 
  R_RT_DepthHandle v77; 
  R_RT_ColorHandle v78; 
  R_RT_ColorHandle v79; 
  R_RT_Handle v80; 
  R_RT_Group v81; 
  R_RT_Group rtGroup; 
  R_RT_Group v83; 

  _R12 = data;
  _R13 = viewInfo;
  Profile2_UpdateEntry(54);
  v69 = (unsigned __int64)&dword_14FDE80A8 & 3;
  if ( ((unsigned __int8)&dword_14FDE80A8 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE80A8) )
    __debugbreak();
  _InterlockedIncrement(&dword_14FDE80A8);
  m_surfaceID = _R13->sceneRtInput.m_mainSceneDepthRt.m_surfaceID;
  __asm
  {
    vmovups ymm0, ymmword ptr [r13+3140h]
    vmovups ymm1, ymmword ptr [r13+3160h]
    vmovups [rbp+3E0h+var_90], ymm0
    vmovups [rbp+3E0h+var_70], ymm1
  }
  v10 = m_surfaceID & 0x7FFF;
  if ( v10 )
    v11 = v10 | 0x8000;
  else
    v11 = 0;
  LOWORD(source[0]) = v11;
  __asm
  {
    vmovups xmm0, xmmword ptr [r13+31A8h]
    vmovsd  xmm1, qword ptr [r13+31B8h]
    vmovups xmmword ptr [rbp+3E0h+source+8], xmm0
    vmovsd  [rbp+3E0h+source+18h], xmm1
    vmovups ymm0, ymmword ptr [rbp+3E0h+source]
    vmovups ymmword ptr [rbp+3E0h+var_400.m_surfaceID], ymm0
  }
  if ( v11 )
  {
    R_RT_Handle::GetSurface(&v73);
    if ( (R_RT_Handle::GetSurface(&v73)->m_rtFlagsInternal & 0x10) != 0 )
      goto LABEL_14;
    v15 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 277, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsDepth())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsDepth()");
  }
  else
  {
    if ( !LODWORD(source[1]) )
      goto LABEL_14;
    v15 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
  }
  if ( v15 )
    __debugbreak();
LABEL_14:
  _RBX = 0i64;
  rtGroup.m_colorRtCount = 2;
  v17 = 2i64;
  do
  {
    __asm
    {
      vmovups ymm0, [rbp+rbx+3E0h+var_90]
      vmovd   eax, xmm0
      vmovups ymmword ptr [rbp+3E0h+var_3A0.m_surfaceID], ymm0
    }
    if ( (_WORD)_EAX )
    {
      R_RT_Handle::GetSurface(&v76);
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 442, ASSERT_TYPE_ASSERT, "(colorRt)", (const char *)&queryFormat, "colorRt") )
        __debugbreak();
    }
    __asm
    {
      vmovups ymm0, [rbp+rbx+3E0h+var_90]
      vmovups ymmword ptr [rbp+rbx+3E0h+rtGroup.m_colorRts.baseclass_0.m_surfaceID], ymm0
    }
    _RBX += 32i64;
    --v17;
  }
  while ( v17 );
  __asm
  {
    vmovups ymm0, ymmword ptr [rbp+3E0h+var_400.m_surfaceID]
    vmovups ymmword ptr [rbp+3E0h+rtGroup.m_depthRt.baseclass_0.m_surfaceID], ymm0
  }
  RB_RunDrawList(_R13, _R12, &rtGroup, (GfxDrawListType)((unsigned __int8)v17 + 65));
  RB_RunDrawList(_R13, _R12, &rtGroup, (GfxDrawListType)((unsigned __int8)v17 + 66));
  _R14 = gfxContext;
  v24 = v69;
  __asm
  {
    vmovups xmm0, xmmword ptr [r14]
    vmovups xmmword ptr [rbp+3E0h+source], xmm0
  }
  if ( _R12->scope.scopeUseDualFov != (_BYTE)v17 )
  {
    __asm
    {
      vmovaps [rsp+4E0h+var_48+8], xmm6
      vxorps  xmm6, xmm6, xmm6
    }
    if ( !_R12->scope.adsSmoothFade )
      goto LABEL_26;
    __asm { vucomiss xmm6, dword ptr [r12+75A870h] }
    if ( _R12->scope.adsSmoothFade )
    {
LABEL_26:
      R_InitCmdBufSourceState(source[0], &_R13->input);
      R_InitLocalCmdBufState((GfxCmdBufState *)source[1], &source[0]->input);
      R_ProfBeginNamedEvent((CmdBufState *)source[1], "Scope Depth Clear");
      R_BeginViewInternal(source[0], &_R13->sceneDef, (const GfxViewParms *)_R13, &_R13->viewParmsSet.frames[1].viewParms);
      R_SetViewportStruct(source[0], &_R13->sceneViewport);
      __asm { vmovups ymm0, ymmword ptr [r13+31A0h] }
      _RAX = gfxContext;
      __asm
      {
        vmovups ymm1, ymmword ptr [r13+3140h]
        vmovups [rbp+3E0h+var_380], ymm0
        vmovups xmm0, xmmword ptr [rax]
        vmovups [rbp+3E0h+var_430], xmm0
        vmovups [rbp+3E0h+var_360], ymm1
      }
      R_SetRenderTargetsInternal_ColorDepth(&v70, &v78, &v77, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(5500)");
      __asm
      {
        vmovups ymm0, ymmword ptr [r13+30C0h]
        vmovups ymmword ptr [rbp+3E0h+var_3E0.m_surfaceID], ymm0
      }
      height = R_RT_Handle::GetSurface(&v74)->m_image.m_base.height;
      Surface = R_RT_Handle::GetSurface(&v74);
      R_SetRenderTargetSize(source[0], Surface->m_image.m_base.width, height, GFX_USE_VIEWPORT_FOR_VIEW);
      _RAX = gfxContext;
      __asm
      {
        vxorps  xmm2, xmm2, xmm2
        vxorps  xmm1, xmm1, xmm1
        vmovups xmm0, xmmword ptr [rax]
        vcvtsi2ss xmm2, xmm2, rax
        vcvtsi2ss xmm1, xmm1, rax
        vmovups [rbp+3E0h+var_420], xmm0
        vmovss  xmm0, cs:__real@3f800000
        vmovss  [rsp+4E0h+var_488], xmm0
        vmovss  [rsp+4E0h+var_490], xmm0
        vmovss  [rsp+4E0h+var_498], xmm6
        vmovss  [rsp+4E0h+var_4A0], xmm6
        vmovss  [rsp+4E0h+var_4A8], xmm2
        vmovss  [rsp+4E0h+var_4B0], xmm1
        vmovss  [rsp+4E0h+flag], xmm6
        vmovss  dword ptr [rsp+4E0h+fmt], xmm6
      }
      RB_ViewportFilterDirectInternal(&v71, rgp.scopeUIDepthClear, 0xFFFFFFFF, &_R13->sceneViewport, fmt, flag, v61, v62, v63, v64, v65, v66, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(5504)");
      R_ProfEndNamedEvent((CmdBufState *)source[1]);
      R_ShutdownLocalCmdBufState((GfxCmdBufState *)source[1], &source[0]->input);
      v24 = v69;
      _R14 = gfxContext;
    }
    __asm { vmovaps xmm6, [rsp+4E0h+var_48+8] }
  }
  RB_RunDrawList(_R13, _R12, &rtGroup, DRAWLIST_PREPASS_PRE_OPAQUE);
  RB_RunDrawList(_R13, _R12, &rtGroup, DRAWLIST_PREPASS_PRE_SSS);
  __asm
  {
    vmovups ymm0, ymmword ptr [r13+3448h]
    vmovd   eax, xmm0
    vmovups [rbp+3E0h+var_3C0], ymm0
    vmovups ymmword ptr [rbp+3E0h+source], ymm0
  }
  if ( (_WORD)_EAX )
  {
    R_RT_Handle::GetSurface((R_RT_Handle *)source);
    v43 = R_RT_Handle::GetSurface((R_RT_Handle *)source);
    Resident = R_Texture_GetResident(v43->m_image.m_base.textureId);
    state = _R14->state;
    R_HW_AddResourceTransition(state, Resident, 0xFFFFFFFF, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    R_FlushResourceTransitions(state);
    __asm
    {
      vmovups ymm0, [rbp+3E0h+var_3C0]
      vmovups [rbp+3E0h+var_340], ymm0
    }
    R_RT_Group::AssignColor(&v81, &v79);
    _RCX = &v83;
    _RAX = &v81;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovups ymm1, ymmword ptr [rax+80h]
      vmovups ymmword ptr [rcx], ymm0
      vmovups ymm0, ymmword ptr [rax+20h]
      vmovups ymmword ptr [rcx+20h], ymm0
      vmovups ymm0, ymmword ptr [rax+40h]
      vmovups ymmword ptr [rcx+40h], ymm0
      vmovups ymm0, ymmword ptr [rax+60h]
      vmovups ymmword ptr [rcx+60h], ymm0
      vmovups xmm0, xmmword ptr [r14]
      vmovups ymmword ptr [rcx+80h], ymm1
      vmovups ymm1, ymmword ptr [rax+0A0h]
    }
    m_location = v81.m_vrsRt.m_tracking.m_location;
    __asm { vmovups ymmword ptr [rcx+0A0h], ymm1 }
    v83.m_vrsRt.m_tracking.m_location = m_location;
    __asm { vmovups [rbp+3E0h+var_410], xmm0 }
    R_ClearRenderTarget(&v72, &v83, 0xFu, 0);
    __asm
    {
      vmovups ymm0, [rbp+3E0h+var_3C0]
      vmovups [rbp+3E0h+var_320], ymm0
    }
    R_HW_AddResourceTransition(state, &v80, 0xFFFFFFFF, D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    R_FlushResourceTransitions(state);
  }
  else if ( LODWORD(source[1]) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
  {
    __debugbreak();
  }
  if ( (*((_BYTE *)&_R13->input + 7920) & 2) != 0 )
  {
    for ( i = DRAWLIST_PREPASS_LIT_OPAQUE; i != DRAWLIST_PREPASS_LIT_OPAQUE_END; ++i )
      RB_RunDrawList(_R13, _R12, &rtGroup, i);
  }
  else
  {
    RB_RunDrawList(_R13, _R12, &rtGroup, DRAWLIST_PREPASS_LIT_OPAQUE);
  }
  RB_RunDrawList(_R13, _R12, &rtGroup, DRAWLIST_PREPASS_LIT_OPAQUE_END);
  RB_RunDrawList(_R13, _R12, &rtGroup, DRAWLIST_PREPASS_EID_ONLY);
  RB_RunDrawList(_R13, _R12, &rtGroup, DRAWLIST_PREPASS_LIT_OPAQUE_GLASS);
  RB_RunDrawList(_R13, _R12, &rtGroup, DRAWLIST_PREPASS_LIT_DECAL);
  RB_RunDrawList(_R13, _R12, &rtGroup, DRAWLIST_PREPASS_LIT_TRANS);
  RB_RunDrawList(_R13, _R12, &rtGroup, DRAWLIST_PREPASS_LIT_TRANS1);
  RB_RunDrawList(_R13, _R12, &rtGroup, DRAWLIST_PREPASS_DEPTH_HACK_TRANS);
  Profile2_UpdateEntry(54);
  if ( v24 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 44, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE80A8) )
    __debugbreak();
  _InterlockedDecrement(&dword_14FDE80A8);
}

/*
==============
RB_DrawRttOverlay
==============
*/

void __fastcall RB_DrawRttOverlay(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, unsigned int drawRttOverlay, double _XMM3_8)
{
  const GfxBackEndData *v12; 
  __int64 v13; 
  unsigned int v14; 
  LocalClientNum_t clientIndex; 
  __int64 v18; 
  unsigned int v19; 
  __int64 v20; 
  unsigned int v22; 
  __int64 v23; 
  unsigned int UpdateCount; 
  const GfxImage *v34; 
  const char *v35; 
  unsigned int v36; 
  const GfxImage *Image; 
  GfxImage *blackImage; 
  const char *Name; 
  unsigned int v52; 
  unsigned int v56; 
  float v72; 
  float v73; 
  float v74; 
  float v75; 
  float v76; 
  float v77; 
  float v78; 
  float v79; 
  float v80; 
  float v81; 
  GfxCmdBufContext v82[2]; 
  char v86; 
  void *retaddr; 
  int v90; 

  _RAX = &retaddr;
  v12 = backEndData;
  v13 = 0i64;
  __asm { vmovaps xmmword ptr [rax-58h], xmm7 }
  v14 = drawRttOverlay;
  __asm { vmovaps [rsp+0E8h+var_88], xmm10 }
  if ( v12->viewInfoCount )
    clientIndex = v12->viewInfo[v12->viewInfoIndex].clientIndex;
  else
    clientIndex = LOCAL_CLIENT_0;
  __asm
  {
    vmovss  xmm10, cs:__real@41000000
    vmovaps xmm7, xmm10
    vmovaps [rsp+0E8h+var_48], xmm6
  }
  v18 = clientIndex;
  v90 = Sys_MillisecondsRaw();
  v19 = 1;
  v20 = 8i64;
  if ( v90 - s_timeUpdated[clientIndex] > 1000 )
  {
    __asm { vmovss  xmm6, cs:__real@4479ffff }
    v22 = 1;
    v23 = 8i64;
    _RBX = 8i64 * (int)clientIndex;
    _R15 = 0x140000000ui64;
    do
    {
      if ( RB_RTT_GetImage(clientIndex, v22) )
      {
        RB_RTT_GetUpdateCount(clientIndex, v22);
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vxorps  xmm1, xmm1, xmm1
          vcvtsi2ss xmm0, xmm0, r13d
          vdivss  xmm0, xmm6, xmm0
          vcvtsi2ss xmm1, xmm1, eax
          vmulss  xmm1, xmm1, xmm0
          vmovss  dword ptr [rbx+r15+14496880h], xmm1
        }
        UpdateCount = RB_RTT_GetUpdateCount(clientIndex, v22);
      }
      else
      {
        s_fps[0][_RBX] = 0.0;
        UpdateCount = 0;
      }
      s_updateCount[0][_RBX] = UpdateCount;
      ++v22;
      ++_RBX;
      --v23;
    }
    while ( v23 );
    v14 = drawRttOverlay;
    v20 = 8i64;
    v18 = clientIndex;
    s_timeUpdated[clientIndex] = v90;
  }
  if ( v14 )
  {
    if ( v14 <= 8 )
    {
      Image = RB_RTT_GetImage(clientIndex, v14);
      blackImage = rgp.blackImage;
      if ( Image )
        blackImage = (GfxImage *)Image;
      Name = R_RTT_GetName(v14);
      v52 = RB_RTT_GetUpdateCount(clientIndex, v14);
      _RDX = 0x140000000ui64;
      __asm { vmovss  xmm0, cs:__real@43800000 }
      _R13 = gfxContext;
      v56 = v52;
      __asm
      {
        vxorps  xmm3, xmm3, xmm3
        vcvtsi2ss xmm3, xmm3, ecx
        vdivss  xmm1, xmm0, xmm3
        vmaxss  xmm2, xmm1, cs:__real@3f800000
        vmovups xmm0, xmmword ptr [r13+0]
        vmovups [rsp+0E8h+var_98], xmm0
        vxorps  xmm1, xmm1, xmm1
        vcvtsi2ss xmm1, xmm1, ecx
        vmulss  xmm0, xmm1, xmm2
        vmovss  [rsp+0E8h+var_A8], xmm0
      }
      _RAX = v14 - 1 + 8 * v18;
      __asm
      {
        vmovss  xmm0, rva s_fps[rdx+rax*4]
        vmulss  xmm3, xmm3, xmm2
        vmovss  [rsp+0E8h+var_B0], xmm3
        vmovss  [rsp+0E8h+var_B8], xmm10
        vmovss  [rsp+0E8h+var_C0], xmm10
        vmovss  [rsp+0E8h+var_C8], xmm0
      }
      RB_DrawRttOverlaySingle(v82, Name, blackImage, v56, v73, v75, v77, v79, v81);
    }
  }
  else
  {
    _R13 = gfxContext;
    __asm
    {
      vmovaps [rsp+0E8h+var_68], xmm8
      vmovss  xmm8, cs:__real@43800000
      vmovaps [rsp+0E8h+var_78], xmm9
      vmovss  xmm9, cs:__real@40000000
    }
    do
    {
      v34 = RB_RTT_GetImage(clientIndex, v19);
      if ( v34 )
      {
        v35 = s_rttAlias_0[v13];
        v36 = RB_RTT_GetUpdateCount(clientIndex, v19);
        _RDX = 0x140000000ui64;
        __asm
        {
          vxorps  xmm0, xmm0, xmm0
          vcvtsi2ss xmm0, xmm0, ecx
          vdivss  xmm2, xmm8, xmm0
          vmulss  xmm6, xmm0, xmm2
          vmovups xmm0, xmmword ptr [r13+0]
          vmovups [rsp+0E8h+var_98], xmm0
          vxorps  xmm1, xmm1, xmm1
          vcvtsi2ss xmm1, xmm1, ecx
          vmulss  xmm0, xmm1, xmm2
          vmovss  [rsp+0E8h+var_A8], xmm0
          vmovss  [rsp+0E8h+var_B0], xmm6
        }
        _RCX = v13 + 8 * v18;
        __asm
        {
          vmovss  xmm0, rva s_fps[rdx+rcx*4]
          vmovss  [rsp+0E8h+var_B8], xmm10
          vmovss  [rsp+0E8h+var_C0], xmm7
          vmovss  [rsp+0E8h+var_C8], xmm0
        }
        RB_DrawRttOverlaySingle(v82, v35, v34, v36, v72, v74, v76, v78, v80);
        __asm
        {
          vaddss  xmm0, xmm6, xmm9
          vaddss  xmm7, xmm7, xmm0
        }
      }
      ++v19;
      ++v13;
      --v20;
    }
    while ( v20 );
    __asm
    {
      vmovaps xmm9, [rsp+0E8h+var_78]
      vmovaps xmm8, [rsp+0E8h+var_68]
    }
  }
  __asm { vmovaps xmm6, [rsp+0E8h+var_48] }
  _R11 = &v86;
  __asm
  {
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm10, xmmword ptr [r11-50h]
  }
}

/*
==============
RB_DrawRttOverlaySingle
==============
*/
void RB_DrawRttOverlaySingle(GfxCmdBufContext *gfxContext, const char *name, const GfxImage *image, const unsigned int updateCount, float fps, float x0, float y0, float w, float h)
{
  GfxCmdBufSourceState *source; 
  GfxCmdBufInput *p_input; 
  GfxFont *debugFont; 
  const char *v38; 
  GfxFont *v43; 
  const char *v44; 
  GfxFont *v48; 
  const char *v49; 
  GfxFont *v54; 
  const char *v57; 
  float fmt; 
  float fmta; 
  float fmtb; 
  float fmtc; 
  float fmtd; 
  float fmte; 
  float v73; 
  float v74; 
  float v75; 
  float v76; 
  float v77; 
  GfxCmdBufContext v78[5]; 
  char v79; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovups xmm0, xmmword ptr [rcx]
    vmovaps xmmword ptr [rax-28h], xmm6
  }
  _RDI = gfxContext;
  __asm
  {
    vmovaps xmmword ptr [rax-38h], xmm7
    vmovaps xmmword ptr [rax-48h], xmm8
    vmovaps xmmword ptr [rax-58h], xmm10
    vmovups xmmword ptr [rax-68h], xmm0
  }
  RB_SetUIColorimetryParams(v78);
  __asm
  {
    vmovups xmm0, xmmword ptr [rdi]
    vmovss  xmm6, [rsp+0C8h+arg_40]
    vmovss  xmm10, [rsp+0C8h+arg_38]
    vmovss  xmm8, [rsp+0C8h+arg_30]
    vmovss  xmm7, [rsp+0C8h+arg_28]
    vmovups [rsp+0C8h+var_68], xmm0
    vaddss  xmm0, xmm6, cs:__real@42a00000
    vmovaps xmm3, xmm10
    vmovaps xmm2, xmm8
    vmovaps xmm1, xmm7
    vmovss  dword ptr [rsp+0C8h+fmt], xmm0
  }
  RB_DrawRect2D(v78, *(float *)&_XMM1, *(float *)&_XMM2, *(float *)&_XMM3, fmt, (const GfxColor)-8355712);
  __asm
  {
    vmovups xmm0, xmmword ptr [rdi]
    vmovups [rsp+0C8h+var_68], xmm0
  }
  RB_EndTessSurfaceInternal(v78, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(5120)");
  source = _RDI->source;
  if ( !_RDI->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  p_input = &source->input;
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  __asm
  {
    vmovups xmm0, xmmword ptr [rdi]
    vxorps  xmm1, xmm1, xmm1
    vmovups [rsp+0C8h+var_68], xmm0
    vmovss  xmm0, cs:__real@3f800000
    vmovss  [rsp+0C8h+var_80], xmm0
    vmovss  [rsp+0C8h+var_88], xmm0
    vmovss  [rsp+0C8h+var_90], xmm1
    vmovss  [rsp+0C8h+var_98], xmm1
  }
  p_input->codeImages[4] = image;
  __asm
  {
    vmovss  dword ptr [rsp+0C8h+var_A0], xmm6
    vmovaps xmm3, xmm8
    vmovaps xmm2, xmm7
    vmovss  dword ptr [rsp+0C8h+fmt], xmm10
  }
  RB_DrawStretchPic(v78, rgp.iconMaterial, *(float *)&_XMM2, *(float *)&_XMM3, fmta, v73, v74, v75, v76, v77, 0xFFFFFFFF, GFX_PRIM_STATS_HUD);
  __asm
  {
    vmovups xmm0, xmmword ptr [rdi]
    vmovups [rsp+0C8h+var_68], xmm0
  }
  RB_EndTessSurfaceInternal(v78, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(5125)");
  debugFont = backEnd.debugFont;
  v38 = j_va((const char *)&queryFormat, name);
  __asm
  {
    vmovups xmm0, xmmword ptr [rdi]
    vaddss  xmm6, xmm8, xmm6
    vaddss  xmm1, xmm6, cs:__real@41a00000
    vmovaps xmm3, xmm7
    vmovss  dword ptr [rsp+0C8h+fmt], xmm1
    vmovups [rsp+0C8h+var_68], xmm0
  }
  RB_DrawText(v78, v38, debugFont, *(float *)&_XMM3, fmtb, (const GfxColor)-1);
  v43 = backEnd.debugFont;
  v44 = j_va("%dx%d", image->width, image->height);
  __asm
  {
    vmovups xmm0, xmmword ptr [rdi]
    vaddss  xmm1, xmm6, cs:__real@42200000
    vmovaps xmm3, xmm7
    vmovss  dword ptr [rsp+0C8h+fmt], xmm1
    vmovups [rsp+0C8h+var_68], xmm0
  }
  RB_DrawText(v78, v44, v43, *(float *)&_XMM3, fmtc, (const GfxColor)-1);
  v48 = backEnd.debugFont;
  v49 = j_va("updated:%d", updateCount);
  __asm
  {
    vmovups xmm0, xmmword ptr [rdi]
    vaddss  xmm1, xmm6, cs:__real@42700000
    vmovaps xmm3, xmm7
    vmovss  dword ptr [rsp+0C8h+fmt], xmm1
    vmovups [rsp+0C8h+var_68], xmm0
  }
  RB_DrawText(v78, v49, v48, *(float *)&_XMM3, fmtd, (const GfxColor)-1);
  __asm { vmovss  xmm1, [rsp+0C8h+arg_20] }
  v54 = backEnd.debugFont;
  __asm
  {
    vcvtss2sd xmm1, xmm1, xmm1
    vmovq   rdx, xmm1
  }
  v57 = j_va("fps:%.2f", _RDX);
  __asm
  {
    vmovups xmm0, xmmword ptr [rdi]
    vaddss  xmm1, xmm6, cs:__real@42a00000
    vmovss  dword ptr [rsp+0C8h+fmt], xmm1
    vmovups [rsp+0C8h+var_68], xmm0
    vmovaps xmm3, xmm7
  }
  RB_DrawText(v78, v57, v54, *(float *)&_XMM3, fmte, (const GfxColor)-1);
  __asm
  {
    vmovups xmm0, xmmword ptr [rdi]
    vmovups [rsp+0C8h+var_68], xmm0
  }
  RB_EndTessSurfaceInternal(v78, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(5134)");
  _R11 = &v79;
  __asm
  {
    vmovaps xmm6, xmmword ptr [r11-10h]
    vmovaps xmm7, xmmword ptr [r11-20h]
    vmovaps xmm8, xmmword ptr [r11-30h]
    vmovaps xmm10, xmmword ptr [r11-40h]
  }
}

/*
==============
RB_DrawScreenshot2DHud
==============
*/
void RB_DrawScreenshot2DHud(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, R_RT_Handle *packedStencil)
{
  ;
}

/*
==============
RB_DrawUmbraOverlays
==============
*/

void __fastcall RB_DrawUmbraOverlays(GfxCmdBufContext *gfxContext, double _XMM1_8)
{
  GfxCmdBufSourceState *source; 
  GfxImage *umbraOcclusionScene; 
  GfxCmdBufInput *p_input; 
  float fmt; 
  float v21; 
  float v22; 
  float v23; 
  float v24; 
  float v25; 
  GfxCmdBufContext v26; 

  source = gfxContext->source;
  umbraOcclusionScene = rgp.umbraOcclusionScene;
  _RDI = gfxContext;
  if ( !gfxContext->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  p_input = &source->input;
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  __asm { vmovups xmm0, xmmword ptr [rdi] }
  p_input->codeImages[4] = umbraOcclusionScene;
  _RAX = r_umbraShowOverlayDisplaySizeScale;
  __asm
  {
    vmovups [rsp+78h+var_18], xmm0
    vmovss  xmm2, dword ptr [rax+28h]
    vxorps  xmm1, xmm1, xmm1
    vcvtsi2ss xmm1, xmm1, eax
    vmulss  xmm4, xmm1, xmm2
    vxorps  xmm0, xmm0, xmm0
    vcvtsi2ss xmm0, xmm0, eax
    vmulss  xmm3, xmm0, xmm2
    vmovss  xmm0, cs:__real@3f800000
    vmovss  xmm2, cs:__real@42800000
    vxorps  xmm1, xmm1, xmm1
    vmovss  [rsp+78h+var_30], xmm1
    vmovss  [rsp+78h+var_38], xmm0
    vmovss  [rsp+78h+var_40], xmm0
    vmovss  [rsp+78h+var_48], xmm1
    vmovss  dword ptr [rsp+78h+var_50], xmm4
    vmovss  dword ptr [rsp+78h+fmt], xmm3
    vmovaps xmm3, xmm2
  }
  RB_DrawStretchPic(&v26, rgp.feedbackReplaceBackbufferMaterial, *(float *)&_XMM2, *(float *)&_XMM3, fmt, v21, v22, v23, v24, v25, 0xFFFFFFFF, GFX_PRIM_STATS_HUD);
  __asm
  {
    vmovups xmm0, xmmword ptr [rdi]
    vmovups [rsp+78h+var_18], xmm0
  }
  RB_EndTessSurfaceInternal(&v26, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(4771)");
}

/*
==============
RB_EnableMSEmissive
==============
*/
void RB_EnableMSEmissive(GfxCmdBufContext *context, const GfxViewInfo *viewInfo)
{
  const GfxBackEndData *data; 
  GfxCmdBufContext v4; 

  __asm { vmovups xmm0, xmmword ptr [rcx] }
  data = viewInfo->input.data;
  __asm { vmovups xmmword ptr [rsp+38h+var_18.source], xmm0 }
  R_HW_EnableMultiSample(&v4, data->frameCount);
}

/*
==============
RB_FinishComputeCmds
==============
*/
void RB_FinishComputeCmds(GfxCmdBufContext *gfxContext, const GfxBackEndData *data)
{
  const GfxBackEndData *v3; 
  GfxCmdBufContext v5; 
  const GfxBackEndData *timeoutUserData; 

  timeoutUserData = data;
  _RDI = gfxContext;
  Profile2_UpdateEntry(48);
  if ( ((unsigned __int8)&dword_14FDE8090 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE8090) )
    __debugbreak();
  _InterlockedIncrement(&dword_14FDE8090);
  v3 = timeoutUserData;
  if ( !timeoutUserData->compute.smpEnabled )
  {
    Sys_ProfBeginNamedEvent(0xFFFFA500, "wait compute ready");
    Sys_ProcessWorkerCmdsWithTimeout(RB_IsComputeReady, &timeoutUserData);
    Sys_WaitWorkerCmdsOfType(WRKCMD_UGB_MAKE_XSURFS_RESIDENT_DISPATCH);
    Sys_WaitWorkerCmdsOfType(WRKCMD_INIT_UGB_BACKEND);
    Sys_ProfEndNamedEvent();
    v3 = timeoutUserData;
  }
  __asm
  {
    vmovups xmm0, xmmword ptr [rdi]
    vmovups xmmword ptr [rsp+48h+var_18.source], xmm0
  }
  R_FinishComputeCmdList(&v5, v3);
  Profile2_UpdateEntry(48);
  if ( ((unsigned __int64)&dword_14FDE8090 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 44, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE8090) )
    __debugbreak();
  _InterlockedDecrement(&dword_14FDE8090);
}

/*
==============
RB_HalfResEmissive_DownsampleDepth
==============
*/

void __fastcall RB_HalfResEmissive_DownsampleDepth(GfxCmdBufContext *context, const GfxViewInfo *viewInfo, double _XMM2_8, double _XMM3_8)
{
  GfxCmdBufSourceState *source; 
  GfxCmdBufState *state; 
  unsigned int height; 
  const R_RT_Surface *Surface; 
  R_RT_Image *p_m_image; 
  R_RT_Image *v29; 
  float fmt; 
  __int64 v35; 
  float v36; 
  float v37; 
  float v38; 
  float v39; 
  float v40; 
  float v41; 
  float v42; 
  R_RT_Handle v43; 
  R_RT_Handle v44; 
  char v45; 
  void *retaddr; 

  _RAX = &retaddr;
  source = context->source;
  _RDI = context;
  state = context->state;
  _RBP = viewInfo;
  __asm { vmovaps xmmword ptr [rax-38h], xmm6 }
  R_GPU_BeginTimer(GPU_TIMER_EMISSIVE_COPY);
  R_InitCmdBufSourceState(source, &_RBP->input);
  R_InitLocalCmdBufState(state, &source->input);
  R_ProfBeginNamedEvent(state, "downsample depth");
  __asm
  {
    vmovups ymm0, ymmword ptr [rbp+3260h]
    vmovups ymmword ptr [rsp+0E8h+var_78.m_surfaceID], ymm0
  }
  R_AddDepthStencilTransition(state, (R_RT_DepthHandle *)&v43, DEPTHSTENCIL_TRANSITION_MODE_WRITE_PRESERVE_COMPRESSION, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  R_FlushResourceTransitions(state);
  __asm
  {
    vmovups ymm0, ymmword ptr [rbp+3260h]
    vmovups ymmword ptr [rsp+0E8h+var_78.m_surfaceID], ymm0
  }
  height = R_RT_Handle::GetSurface(&v43)->m_image.m_base.height;
  Surface = R_RT_Handle::GetSurface(&v43);
  R_SetRenderTargetSize(source, Surface->m_image.m_base.width, height, GFX_USE_VIEWPORT_FOR_VIEW);
  R_BeginViewInternal(source, &_RBP->sceneDef, (const GfxViewParms *)_RBP, &_RBP->viewParmsSet.frames[1].viewParms);
  R_SetViewportStruct(source, &_RBP->sceneEmissiveViewport);
  __asm
  {
    vmovups ymm0, ymmword ptr [rbp+31A0h]
    vmovups xmm1, xmmword ptr [rdi]
    vmovups ymmword ptr [rsp+0E8h+var_58.m_surfaceID], ymm0
    vmovups xmmword ptr [rsp+0E8h+var_78.m_surfaceID], xmm1
  }
  R_SetRenderTargetsInternal_DepthOnly((GfxCmdBufContext *)&v43, (R_RT_DepthHandle *)&v44, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(3036)");
  __asm
  {
    vmovups xmm0, xmmword ptr [rdi]
    vmovups xmmword ptr [rsp+0E8h+var_78.m_surfaceID], xmm0
  }
  R_ResolveDepth((GfxCmdBufContext *)&v43);
  __asm
  {
    vmovups ymm0, ymmword ptr [rbp+3260h]
    vmovups xmm1, xmmword ptr [rdi]
    vmovups ymmword ptr [rsp+0E8h+var_58.m_surfaceID], ymm0
    vmovups xmmword ptr [rsp+0E8h+var_78.m_surfaceID], xmm1
  }
  R_SetRenderTargetsInternal_DepthOnly((GfxCmdBufContext *)&v43, (R_RT_DepthHandle *)&v44, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(3039)");
  __asm
  {
    vmovups ymm0, ymmword ptr [rbp+31A0h]
    vmovups xmm6, xmmword ptr [rdi]
    vmovups ymmword ptr [rsp+0E8h+var_58.m_surfaceID], ymm0
    vmovq   rbx, xmm6
  }
  p_m_image = &R_RT_Handle::GetSurface(&v44)->m_image;
  if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  if ( _RBX == -1792 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  *(_QWORD *)(_RBX + 7936) = p_m_image;
  R_Set2D((GfxCmdBufSourceState *)_RBX);
  if ( *(_DWORD *)(_RBX + 11488) != 2 )
  {
    LODWORD(v35) = *(_DWORD *)(_RBX + 11488);
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 2990, ASSERT_TYPE_ASSERT, "( ( source->viewMode == VIEW_MODE_2D ) )", "( source->viewMode ) = %i", v35) )
      __debugbreak();
  }
  __asm
  {
    vmovss  xmm0, cs:__real@3f800000
    vxorps  xmm1, xmm1, xmm1
    vxorps  xmm3, xmm3, xmm3
    vcvtsi2ss xmm3, xmm3, rax
    vxorps  xmm2, xmm2, xmm2
    vcvtsi2ss xmm2, xmm2, rax
    vmovss  [rsp+0E8h+var_90], xmm0
    vmovss  [rsp+0E8h+var_98], xmm0
    vmovss  [rsp+0E8h+var_A0], xmm1
    vmovss  [rsp+0E8h+var_A8], xmm1
    vmovss  [rsp+0E8h+var_B0], xmm3
    vmovss  [rsp+0E8h+var_B8], xmm2
    vmovss  dword ptr [rsp+0E8h+var_C0], xmm1
    vmovss  dword ptr [rsp+0E8h+fmt], xmm1
    vmovdqa xmmword ptr [rsp+0E8h+var_78.m_surfaceID], xmm6
  }
  RB_ViewportFilterDirectInternal((GfxCmdBufContext *)&v43, rgp.floatZWriteDepthDownsampleMaterial, 0xFFFFFFFF, &_RBP->sceneEmissiveViewport, fmt, v36, v37, v38, v39, v40, v41, v42, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(2992)");
  v29 = &R_RT_Handle::GetSurface(&_RBP->sceneRtInput.m_floatZFullRt)->m_image;
  if ( !source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  if ( source == (GfxCmdBufSourceState *)-1792i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  source->input.codeImages[0] = &v29->m_base;
  __asm
  {
    vmovups ymm0, ymmword ptr [rbp+31A0h]
    vmovups ymmword ptr [rsp+0E8h+var_58.m_surfaceID], ymm0
  }
  R_AddDepthStencilTransition(state, (R_RT_DepthHandle *)&v44, DEPTHSTENCIL_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  __asm
  {
    vmovups ymm0, ymmword ptr [rbp+3260h]
    vmovups ymmword ptr [rsp+0E8h+var_58.m_surfaceID], ymm0
  }
  R_AddDepthStencilTransition(state, (R_RT_DepthHandle *)&v44, DEPTHSTENCIL_TRANSITION_MODE_READ_PRESERVE_COMPRESSION, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  R_FlushResourceTransitions(state);
  R_ProfEndNamedEvent(state);
  R_ShutdownLocalCmdBufState(state, &source->input);
  _R11 = &v45;
  __asm { vmovaps xmm6, xmmword ptr [r11-10h] }
  R_GPU_EndTimer();
}

/*
==============
RB_HalfRes_Upsample
==============
*/
void RB_HalfRes_Upsample(GfxCmdBufContext *context, const GfxViewInfo *viewInfo)
{
  bool v12; 
  __int16 v13; 
  __int16 v14; 
  bool v18; 
  GfxCmdBufSourceState *source; 
  GfxCmdBufSourceState *v21; 
  unsigned int height; 
  const R_RT_Surface *Surface; 
  __int64 v32; 
  GfxCmdBufSourceState *v40; 
  GfxCmdBufState *state; 
  __int64 v47; 
  R_RT_Handle v48; 
  __m256i v49; 
  R_RT_Handle v50; 
  R_RT_Handle v51; 
  R_RT_Handle v52; 
  R_RT_Handle v53; 
  R_RT_Handle v54; 
  R_RT_Group v55; 

  __asm
  {
    vmovups ymm0, ymmword ptr [rdx+3220h]
    vmovups [rbp+160h+var_190], ymm0
    vmovups ymm0, ymmword ptr [rdx+3240h]
    vmovups [rbp+160h+var_1B0], ymm0
    vmovups ymm0, ymmword ptr [rdx+3340h]
  }
  _R14 = viewInfo;
  _R13 = context;
  __asm { vmovups ymmword ptr [rsp+260h+var_1F0.m_surfaceID], ymm0 }
  _RAX = R_RT_GetViewInternal(&v51, &v50, 0, 1);
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   ebx, xmm0
    vmovups ymmword ptr [rsp+260h+var_1F0.m_surfaceID], ymm0
    vmovups ymmword ptr [rsp+260h+var_230.m_surfaceID], ymm0
  }
  if ( (_WORD)_EBX )
  {
    R_RT_Handle::GetSurface(&v48);
    if ( (R_RT_Handle::GetSurface(&v48)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      LODWORD(_RDI) = v48.m_tracking.m_allocCounter;
      LOWORD(_EBX) = v48.m_surfaceID;
      __asm { vmovups ymm0, ymmword ptr [rsp+260h+var_230.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      LODWORD(_RDI) = v48.m_tracking.m_allocCounter;
      LOWORD(_EBX) = v48.m_surfaceID;
      __asm { vmovups ymm0, ymmword ptr [rsp+260h+var_230.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rdi, xmm0, 2 }
    if ( (_DWORD)_RDI )
    {
      v12 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, ymmword ptr [rsp+260h+var_1F0.m_surfaceID] }
      if ( v12 )
        __debugbreak();
    }
  }
  __asm { vmovups ymmword ptr [rbp+160h+var_170.m_surfaceID], ymm0 }
  v13 = _EBX & 0x7FFF;
  if ( v13 )
  {
    v14 = v13 | 0x8000;
    v49.m256i_i16[0] = v14;
  }
  else
  {
    v14 = 0;
    v49.m256i_i16[0] = 0;
  }
  __asm
  {
    vmovups xmm0, xmmword ptr [rsp+260h+var_230.m_tracking.m_allocCounter]
    vmovsd  xmm1, [rsp+260h+var_230.m_tracking.m_location]
    vmovups xmmword ptr [rsp+260h+var_210+8], xmm0
    vmovsd  qword ptr [rsp+260h+var_210+18h], xmm1
    vmovups ymm0, [rsp+260h+var_210]
    vmovups ymmword ptr [rsp+260h+var_1F0.m_surfaceID], ymm0
  }
  if ( v14 )
  {
    R_RT_Handle::GetSurface(&v50);
    if ( (R_RT_Handle::GetSurface(&v50)->m_rtFlagsInternal & 0x18) == 0 )
      goto LABEL_19;
    v18 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()");
  }
  else
  {
    if ( !(_DWORD)_RDI )
      goto LABEL_19;
    v18 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
  }
  if ( v18 )
    __debugbreak();
LABEL_19:
  __asm { vmovups ymm0, ymmword ptr [r14+3340h] }
  source = _R13->source;
  v21 = _R13->source;
  __asm { vmovups [rbp+160h+var_1D0], ymm0 }
  R_InitCmdBufSourceState(v21, &_R14->input);
  R_InitLocalCmdBufState(_R13->state, &source->input);
  R_GPU_BeginTimer(GPU_TIMER_EMISSIVE_COPY);
  R_ProfBeginNamedEvent(_R13->state, "upsample half res");
  __asm
  {
    vmovups ymm0, ymmword ptr [r14+3220h]
    vmovups xmm1, xmmword ptr [r13+0]
    vmovups ymmword ptr [rsp+260h+var_230.m_surfaceID], ymm0
    vmovups xmmword ptr [rsp+260h+var_210], xmm1
  }
  R_Resolve_EliminateFastClear((GfxCmdBufContext *)&v49, (R_RT_ColorHandle *)&v48, 0);
  __asm
  {
    vmovups ymm0, ymmword ptr [r14+3240h]
    vmovups xmm1, xmmword ptr [r13+0]
    vmovups ymmword ptr [rsp+260h+var_230.m_surfaceID], ymm0
    vmovups xmmword ptr [rsp+260h+var_210], xmm1
  }
  R_Resolve_EliminateFastClear((GfxCmdBufContext *)&v49, (R_RT_ColorHandle *)&v48, 1);
  __asm
  {
    vmovups ymm0, ymmword ptr [r14+30C0h]
    vmovups ymmword ptr [rsp+260h+var_230.m_surfaceID], ymm0
  }
  height = R_RT_Handle::GetSurface(&v48)->m_image.m_base.height;
  Surface = R_RT_Handle::GetSurface(&v48);
  R_SetRenderTargetSize(source, Surface->m_image.m_base.width, height, GFX_USE_VIEWPORT_FOR_VIEW);
  R_BeginViewInternal(source, &_R14->sceneDef, (const GfxViewParms *)_R14, &_R14->viewParmsSet.frames[1].viewParms);
  v49.m256i_i64[0] = (__int64)&_R14->sceneViewport;
  R_SetViewportStruct(source, &_R14->sceneViewport);
  __asm
  {
    vmovups ymm0, ymmword ptr [r14+30C0h]
    vmovups ymm1, ymmword ptr [r14+30E0h]
  }
  v55.m_colorRtCount = 2;
  __asm
  {
    vmovups [rbp+160h+var_80], ymm0
    vpxor   xmm0, xmm0, xmm0
    vmovdqu xmmword ptr [rsp+260h+var_230.m_tracking.m_name], xmm0
  }
  v32 = 2i64;
  v48.m_surfaceID = 0;
  __asm { vmovups [rbp+160h+var_60], ymm1 }
  v48.m_tracking.m_allocCounter = 0;
  _RDI = 0i64;
  do
  {
    __asm
    {
      vmovups ymm0, [rbp+rdi+160h+var_80]
      vmovd   eax, xmm0
      vmovups ymmword ptr [rbp+160h+var_170.m_surfaceID], ymm0
    }
    if ( (_WORD)_EAX )
    {
      R_RT_Handle::GetSurface(&v54);
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 442, ASSERT_TYPE_ASSERT, "(colorRt)", (const char *)&queryFormat, "colorRt") )
        __debugbreak();
    }
    __asm
    {
      vmovups ymm0, [rbp+rdi+160h+var_80]
      vmovups [rbp+rdi+160h+var_148], ymm0
    }
    _RDI += 32i64;
    --v32;
  }
  while ( v32 );
  __asm
  {
    vmovups ymm0, ymmword ptr [rsp+260h+var_230.m_surfaceID]
    vmovups [rbp+160h+var_C8], ymm0
    vmovups xmm0, xmmword ptr [r13+0]
    vmovups xmmword ptr [rsp+260h+var_230.m_surfaceID], xmm0
  }
  R_SetRenderTargetsInternal((GfxCmdBufContext *)&v48, &v55, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(3088)");
  v40 = _R13->source;
  R_Set2D(_R13->source);
  state = _R13->state;
  if ( v40->viewMode != VIEW_MODE_2D )
  {
    LODWORD(v47) = v40->viewMode;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 3092, ASSERT_TYPE_ASSERT, "( ( source->viewMode == VIEW_MODE_2D ) )", "( source->viewMode ) = %i", v47) )
      __debugbreak();
  }
  __asm
  {
    vmovups ymm0, [rbp+160h+var_1D0]
    vmovups ymm1, [rbp+160h+var_1B0]
    vmovups [rbp+160h+var_1D0], ymm0
    vmovups ymm0, ymmword ptr [rsp+260h+var_1F0.m_surfaceID]
    vmovups ymmword ptr [rbp+160h+var_170.m_surfaceID], ymm0
    vmovups ymm0, [rbp+160h+var_190]
    vmovups [rbp+160h+var_190], ymm0
    vmovups xmm0, xmmword ptr [r13+0]
    vmovups xmmword ptr [rsp+260h+var_230.m_surfaceID], xmm0
    vmovups [rbp+160h+var_1B0], ymm1
  }
  R_HalfRes_Upsample((GfxCmdBufContext *)&v48, &v53, &v52, &v54, &v51, (const GfxViewport *)v49.m256i_i64[0]);
  if ( v40 == (GfxCmdBufSourceState *)-1792i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  v40->input.codeImages[22] = NULL;
  if ( v40 == (GfxCmdBufSourceState *)-1792i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  v40->input.codeImages[23] = NULL;
  if ( v40 == (GfxCmdBufSourceState *)-1792i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  v40->input.codeImages[24] = NULL;
  if ( v40 == (GfxCmdBufSourceState *)-1792i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  v40->input.codeImages[25] = NULL;
  R_ProfEndNamedEvent(state);
  R_GPU_EndTimer();
  R_ShutdownLocalCmdBufState(state, &v40->input);
}

/*
==============
RB_InitClient2DContext
==============
*/
void RB_InitClient2DContext(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, R_RT_ColorHandle *colorRt, R_RT_Handle *packedStencil, const GfxImage *universalClut, const GfxImage *resolvedScene, const GfxWrappedBuffer *exposureBuffer)
{
  unsigned int height; 
  const R_RT_Surface *Surface; 
  GfxCmdBufSourceState *source; 
  const char *m_location; 
  R_RT_Image *p_m_image; 
  GfxCmdBufInput *p_input; 
  GfxImage *blackImage; 
  GfxCmdBufSourceState *v40; 
  GfxCmdBufInput *v41; 
  GfxCmdBufSourceState *v42; 
  GfxImage *v43; 
  GfxCmdBufInput *v44; 
  GfxCmdBufSourceState *v45; 
  __int64 v47; 
  GfxWrappedBuffer *p_dummyBuffer; 
  GfxImage *Image; 
  GfxCmdBufInput *v54; 
  const GfxImage *v56; 
  R_RT_Handle v61; 
  const GfxImage *v62; 
  R_RT_Group v63; 
  GfxViewport viewport; 
  R_RT_Group v65; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-58h], xmm6
    vmovaps xmmword ptr [rax-68h], xmm7
  }
  _R14 = gfxContext;
  __asm { vmovups ymm0, ymmword ptr [r9] }
  _RSI = packedStencil;
  v62 = universalClut;
  _RDI = colorRt;
  __asm { vmovups ymmword ptr [rsp+270h+var_248.m_tracking.m_allocCounter], ymm0 }
  _R13 = viewInfo;
  height = R_RT_Handle::GetSurface(&v61)->m_image.m_base.height;
  Surface = R_RT_Handle::GetSurface(&v61);
  source = _R14->source;
  R_SetRenderTargetSize(_R14->source, Surface->m_image.m_base.width, height, GFX_USE_VIEWPORT_FOR_VIEW);
  __asm
  {
    vmovups ymm0, ymmword ptr [rdi]
    vmovups ymmword ptr [rsp+270h+var_248.m_tracking.m_allocCounter], ymm0
  }
  R_RT_Group::AssignColor(&v63, (R_RT_ColorHandle *)&v61);
  _RCX = &v65;
  _RAX = &v63;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovups ymm1, ymmword ptr [rax+80h]
    vmovups ymmword ptr [rcx], ymm0
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovups ymmword ptr [rcx+20h], ymm0
    vmovups ymm0, ymmword ptr [rax+40h]
    vmovups ymmword ptr [rcx+40h], ymm0
    vmovups ymm0, ymmword ptr [rax+60h]
    vmovups ymmword ptr [rcx+60h], ymm0
    vmovups xmm0, xmmword ptr [r14]
    vmovups ymmword ptr [rcx+80h], ymm1
    vmovups ymm1, ymmword ptr [rax+0A0h]
  }
  m_location = v63.m_vrsRt.m_tracking.m_location;
  __asm { vmovups ymmword ptr [rcx+0A0h], ymm1 }
  v65.m_vrsRt.m_tracking.m_location = m_location;
  __asm { vmovups xmmword ptr [rsp+270h+var_248.m_tracking.m_allocCounter], xmm0 }
  R_SetRenderTargetsInternal((GfxCmdBufContext *)&v61, &v65, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(2134)");
  __asm
  {
    vmovups ymm0, ymmword ptr [rsi]
    vmovd   eax, xmm0
    vmovups ymmword ptr [rsp+270h+var_248.m_tracking.m_allocCounter], ymm0
  }
  if ( (_WORD)_EAX )
  {
    R_RT_Handle::GetSurface(&v61);
    R_RT_Handle::GetSurface(&v61);
    R_RT_Handle::GetSurface(&v61);
    p_m_image = &R_RT_Handle::GetSurface(&v61)->m_image;
  }
  else
  {
    if ( v61.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v61.m_surfaceID) )
      __debugbreak();
    p_m_image = (R_RT_Image *)rgp.blackImage;
  }
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vxorps  xmm7, xmm7, xmm7
    vcvtsi2ss xmm6, xmm6, rcx
    vcvtsi2ss xmm7, xmm7, rdx
  }
  if ( !source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  p_input = &source->input;
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codeImages[79] = &p_m_image->m_base;
  blackImage = rgp.blackImage;
  v40 = _R14->source;
  if ( resolvedScene )
    blackImage = (GfxImage *)resolvedScene;
  if ( !v40 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  v41 = &v40->input;
  if ( !v41 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  v41->codeImages[6] = blackImage;
  v42 = _R14->source;
  v43 = rgp.blackImage;
  if ( !_R14->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  v44 = &v42->input;
  if ( !v44 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  v44->codeImages[80] = v43;
  v45 = _R14->source;
  _RDI = _R14->source;
  v47 = (__int64)&_R14->source->input;
  if ( _R14->source == (GfxCmdBufSourceState *)-1792i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1494, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  __asm { vmovss  xmm1, cs:__real@3f800000 }
  p_dummyBuffer = &gfxBuf.dummyBuffer;
  __asm
  {
    vdivss  xmm0, xmm1, xmm6
    vdivss  xmm1, xmm1, xmm7
  }
  if ( exposureBuffer )
    p_dummyBuffer = (GfxWrappedBuffer *)exposureBuffer;
  *(_QWORD *)(v47 + 7424) = p_dummyBuffer;
  __asm
  {
    vmovss  dword ptr [rdi+750h], xmm6
    vmovss  dword ptr [rdi+754h], xmm7
    vmovss  dword ptr [rdi+758h], xmm0
    vmovss  dword ptr [rdi+75Ch], xmm1
  }
  ++_RDI->constVersions[5];
  __asm { vmovss  xmm1, cs:?vidConfig@@3UvidConfig_t@@A.windowAspectRatio; aspect }
  R_SetRenderTargetAspect(_RDI, *(float *)&_XMM1);
  Image = FontCache_GetImage();
  v54 = &_RDI->input;
  if ( !v54 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
  {
    __debugbreak();
    v45 = _R14->source;
  }
  __asm { vmovups xmm0, xmmword ptr [r14] }
  v56 = v62;
  v54->codeImages[32] = Image;
  __asm { vmovups xmmword ptr [rsp+270h+var_248.m_tracking.m_allocCounter], xmm0 }
  RB_SetDefaultUIState((GfxCmdBufContext *)&v61, data, v56);
  __asm
  {
    vmovups xmm0, xmmword ptr [r14]
    vmovups xmmword ptr [rsp+270h+var_248.m_tracking.m_allocCounter], xmm0
  }
  RB_SetupUIWhiteBalanceParams((GfxCmdBufContext *)&v61, _R13);
  R_SetMovieImages(&v45->input);
  R_BeginViewInternal(v45, &_R13->sceneDef, (const GfxViewParms *)_R13, &_R13->viewParmsSet.frames[1].viewParms);
  __asm
  {
    vmovups xmm0, xmmword ptr [r13+4B0h]
    vmovups xmmword ptr [rbp+170h+viewport.x], xmm0
  }
  R_SetViewportStruct(v45, &viewport);
  R_SetViewportAndScissorSeparate(_R14->state, &viewport, &viewport);
  __asm
  {
    vmovaps xmm6, xmmword ptr [rsp+270h+var_58+8]
    vmovaps xmm7, [rsp+270h+var_68+8]
  }
}

/*
==============
RB_InitClient2DContext_CopyScopeReticle
==============
*/
void RB_InitClient2DContext_CopyScopeReticle(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  unsigned int height; 
  const R_RT_Surface *Surface; 
  GfxImage *Image; 
  R_RT_Handle v25; 
  R_RT_Handle v26; 
  GfxViewport viewport; 

  __asm { vmovaps [rsp+0D8h+var_48], xmm6 }
  _RBX = gfxContext->state;
  _RDI = gfxContext;
  if ( _RBX->rtGroup.m_colorRtCount != 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 559, ASSERT_TYPE_ASSERT, "(this->m_colorRtCount == 1)", (const char *)&queryFormat, "this->m_colorRtCount == 1") )
    __debugbreak();
  __asm
  {
    vmovups ymm0, ymmword ptr [rbx+0A30h]
    vmovups ymmword ptr [rsp+0D8h+var_88.m_surfaceID], ymm0
    vmovups ymmword ptr [rsp+0D8h+var_A8.m_surfaceID], ymm0
  }
  height = R_RT_Handle::GetSurface(&v25)->m_image.m_base.height;
  Surface = R_RT_Handle::GetSurface(&v25);
  _RSI = _RDI->source;
  R_SetRenderTargetSize(_RDI->source, Surface->m_image.m_base.width, height, GFX_USE_VIEWPORT_FOR_VIEW);
  R_RT_Handle::GetSurface(&v26);
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vcvtsi2ss xmm6, xmm6, ecx
  }
  R_RT_Handle::GetSurface(&v26);
  __asm
  {
    vmovss  xmm1, cs:__real@3f800000
    vdivss  xmm0, xmm1, xmm6
    vxorps  xmm2, xmm2, xmm2
    vcvtsi2ss xmm2, xmm2, ecx
    vdivss  xmm1, xmm1, xmm2
    vmovss  dword ptr [rsi+75Ch], xmm1
    vmovss  dword ptr [rsi+750h], xmm6
    vmovss  dword ptr [rsi+754h], xmm2
    vmovss  dword ptr [rsi+758h], xmm0
  }
  ++_RSI->constVersions[5];
  __asm { vmovss  xmm1, cs:?vidConfig@@3UvidConfig_t@@A.windowAspectRatio; aspect }
  R_SetRenderTargetAspect(_RSI, *(float *)&_XMM1);
  Image = FontCache_GetImage();
  if ( !_RSI && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  if ( _RSI == (GfxCmdBufSourceState *)-1792i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  __asm { vmovups xmm0, xmmword ptr [rdi] }
  _RSI->input.codeImages[32] = Image;
  __asm { vmovups xmmword ptr [rsp+0D8h+var_A8.m_surfaceID], xmm0 }
  RB_SetDefaultUIState((GfxCmdBufContext *)&v25, data, NULL);
  __asm
  {
    vmovups xmm0, xmmword ptr [rdi]
    vmovups xmmword ptr [rsp+0D8h+var_A8.m_surfaceID], xmm0
  }
  RB_SetupUIWhiteBalanceParams((GfxCmdBufContext *)&v25, viewInfo);
  *(_QWORD *)&viewport.x = 0i64;
  viewport.width = R_RT_Handle::GetSurface(&v26)->m_image.m_base.width;
  viewport.height = R_RT_Handle::GetSurface(&v26)->m_image.m_base.height;
  R_SetViewportStruct(_RSI, &viewport);
  R_Set2D(_RSI);
  __asm { vmovaps xmm6, [rsp+0D8h+var_48] }
}

/*
==============
RB_InitClient2DContext_ReceivePostFXLite
==============
*/
void RB_InitClient2DContext_ReceivePostFXLite(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, R_RT_ColorHandle *sceneRt, const GfxImage *packedStencil, const GfxImage *scopeBuffer)
{
  R_RT_ColorHandle *v10; 
  unsigned int height; 
  const R_RT_Surface *Surface; 
  GfxCmdBufSourceState *source; 
  GfxImage *Image; 
  GfxCmdBufInput *p_input; 
  GfxCmdBufInput *v29; 
  GfxCmdBufSourceState *v30; 
  GfxCmdBufInput *v31; 
  const R_RT_Surface *v32; 
  GfxCmdBufSourceState *v33; 
  R_RT_Handle v35; 
  GfxViewport viewport; 

  __asm
  {
    vmovaps [rsp+0C8h+var_58], xmm6
    vmovups ymm0, ymmword ptr [r9]
  }
  _RDI = gfxContext;
  v10 = sceneRt;
  __asm { vmovups ymmword ptr [rsp+0C8h+var_98.m_surfaceID], ymm0 }
  height = R_RT_Handle::GetSurface(&v35)->m_image.m_base.height;
  Surface = R_RT_Handle::GetSurface(&v35);
  source = _RDI->source;
  R_SetRenderTargetSize(_RDI->source, Surface->m_image.m_base.width, height, GFX_USE_VIEWPORT_FOR_VIEW);
  Image = FontCache_GetImage();
  if ( !source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  p_input = &source->input;
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  __asm { vmovups xmm0, xmmword ptr [rdi] }
  p_input->codeImages[32] = Image;
  __asm { vmovups xmmword ptr [rsp+0C8h+var_98.m_surfaceID], xmm0 }
  RB_SetDefaultUIState((GfxCmdBufContext *)&v35, data, rgp.blackImage3D);
  __asm
  {
    vmovups xmm0, xmmword ptr [rdi]
    vmovups xmmword ptr [rsp+0C8h+var_98.m_surfaceID], xmm0
  }
  RB_SetupUIWhiteBalanceParams((GfxCmdBufContext *)&v35, viewInfo);
  R_RT_Handle::GetSurface(v10);
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vcvtsi2ss xmm6, xmm6, ecx
  }
  R_RT_Handle::GetSurface(v10);
  _RBX = _RDI->source;
  __asm
  {
    vmovss  xmm1, cs:__real@3f800000
    vdivss  xmm0, xmm1, xmm6
    vmovss  dword ptr [rbx+750h], xmm6
    vmovss  dword ptr [rbx+758h], xmm0
    vxorps  xmm2, xmm2, xmm2
    vcvtsi2ss xmm2, xmm2, ecx
    vdivss  xmm1, xmm1, xmm2
    vmovss  dword ptr [rbx+75Ch], xmm1
    vmovss  dword ptr [rbx+754h], xmm2
  }
  ++_RBX->constVersions[5];
  __asm { vmovss  xmm1, cs:?vidConfig@@3UvidConfig_t@@A.windowAspectRatio; aspect }
  R_SetRenderTargetAspect(_RBX, *(float *)&_XMM1);
  if ( !_RBX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  v29 = &_RBX->input;
  if ( !v29 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  v29->codeImages[79] = packedStencil;
  v30 = _RDI->source;
  if ( !_RDI->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  v31 = &v30->input;
  if ( !v31 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  v31->codeImages[80] = scopeBuffer;
  *(_QWORD *)&viewport.x = 0i64;
  viewport.width = R_RT_Handle::GetSurface(v10)->m_image.m_base.width;
  v32 = R_RT_Handle::GetSurface(v10);
  v33 = _RDI->source;
  viewport.height = v32->m_image.m_base.height;
  R_SetViewportStruct(v33, &viewport);
  R_Set2D(v33);
  R_ForceSet2D(v33, &viewInfo->displayViewport);
  __asm { vmovaps xmm6, [rsp+0C8h+var_58] }
}

/*
==============
RB_InitClient2DReceivePPFXContext
==============
*/
void RB_InitClient2DReceivePPFXContext(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, R_RT_ColorHandle *sceneRt, R_RT_DepthHandle *depthRt, const GfxImage *universalClut)
{
  unsigned int height; 
  const R_RT_Surface *Surface; 
  GfxImage *blackImage; 
  GfxImage *Image; 
  GfxCmdBufSourceState *source; 
  GfxImage *v32; 
  GfxCmdBufInput *p_input; 
  R_RT_Handle v38; 
  R_RT_DepthHandle v39; 
  R_RT_ColorHandle v40; 
  char v41; 
  void *retaddr; 

  _R11 = &retaddr;
  __asm { vmovups ymm1, ymmword ptr [r9] }
  _RAX = depthRt;
  _RDI = sceneRt;
  __asm { vmovaps xmmword ptr [r11-38h], xmm6 }
  _RSI = gfxContext;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovups [rsp+0C8h+var_78], ymm0
    vmovups xmm0, xmmword ptr [rcx]
    vmovups xmmword ptr [rsp+0C8h+var_98.m_surfaceID], xmm0
    vmovups ymmword ptr [rsp+0C8h+var_58.baseclass_0.m_surfaceID], ymm1
  }
  R_SetRenderTargetsInternal_ColorDepth((GfxCmdBufContext *)&v38, &v40, &v39, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(3572)");
  _R14 = _RSI->source;
  R_SetViewportStruct(_RSI->source, &viewInfo->sceneGeoViewport);
  __asm
  {
    vmovups ymm0, ymmword ptr [rdi]
    vmovups ymmword ptr [rsp+0C8h+var_98.m_surfaceID], ymm0
  }
  height = R_RT_Handle::GetSurface(&v38)->m_image.m_base.height;
  Surface = R_RT_Handle::GetSurface(&v38);
  R_SetRenderTargetSize(_R14, Surface->m_image.m_base.width, height, GFX_USE_VIEWPORT_FOR_VIEW);
  R_BeginViewInternal(_R14, &viewInfo->sceneDef, (const GfxViewParms *)viewInfo, &viewInfo->viewParmsSet.frames[1].viewParms);
  R_RT_Handle::GetSurface(_RDI);
  __asm
  {
    vxorps  xmm6, xmm6, xmm6
    vcvtsi2ss xmm6, xmm6, ecx
  }
  R_RT_Handle::GetSurface(_RDI);
  __asm
  {
    vmovss  xmm1, cs:__real@3f800000
    vdivss  xmm0, xmm1, xmm6
    vxorps  xmm2, xmm2, xmm2
    vcvtsi2ss xmm2, xmm2, ecx
    vdivss  xmm1, xmm1, xmm2
    vmovss  dword ptr [r14+75Ch], xmm1
    vmovss  dword ptr [r14+750h], xmm6
    vmovss  dword ptr [r14+754h], xmm2
    vmovss  dword ptr [r14+758h], xmm0
  }
  ++_R14->constVersions[5];
  __asm { vmovss  xmm1, cs:?vidConfig@@3UvidConfig_t@@A.windowAspectRatio; aspect }
  R_SetRenderTargetAspect(_R14, *(float *)&_XMM1);
  blackImage = rgp.blackImage;
  if ( !_R14 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  if ( _R14 == (GfxCmdBufSourceState *)-1792i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  _R14->input.codeImages[80] = blackImage;
  Image = FontCache_GetImage();
  source = _RSI->source;
  v32 = Image;
  if ( !_RSI->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  p_input = &source->input;
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  __asm { vmovups xmm0, xmmword ptr [rsi] }
  p_input->codeImages[32] = v32;
  __asm { vmovups xmmword ptr [rsp+0C8h+var_98.m_surfaceID], xmm0 }
  RB_SetDefaultUIState((GfxCmdBufContext *)&v38, data, universalClut);
  __asm
  {
    vmovups xmm0, xmmword ptr [rsi]
    vmovups xmmword ptr [rsp+0C8h+var_98.m_surfaceID], xmm0
  }
  RB_SetupUIWhiteBalanceParams((GfxCmdBufContext *)&v38, viewInfo);
  R_Set2D(_RSI->source);
  _R11 = &v41;
  __asm { vmovaps xmm6, xmmword ptr [r11-10h] }
  R_ForceSet2D(_RSI->source, &viewInfo->displayViewport);
}

/*
==============
RB_InitClient2D_RTT
==============
*/
void RB_InitClient2D_RTT(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufSourceState *source; 
  GfxImage *blackImage; 
  GfxCmdBufInput *p_input; 
  GfxImage *Image; 
  GfxCmdBufSourceState *v10; 
  GfxImage *v11; 
  GfxCmdBufInput *v12; 
  GfxCmdBufSourceState *v15; 
  GfxCmdBufContext v16[3]; 

  source = gfxContext->source;
  blackImage = rgp.blackImage;
  _RBX = gfxContext;
  if ( !gfxContext->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  p_input = &source->input;
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codeImages[80] = blackImage;
  Image = FontCache_GetImage();
  v10 = _RBX->source;
  v11 = Image;
  if ( !_RBX->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  v12 = &v10->input;
  if ( !v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  __asm { vmovups xmm0, xmmword ptr [rbx] }
  v12->codeImages[32] = v11;
  __asm { vmovups [rsp+68h+var_38], xmm0 }
  RB_SetDefaultUIState(v16, data, NULL);
  __asm
  {
    vmovups xmm0, xmmword ptr [rbx]
    vmovups [rsp+68h+var_38], xmm0
  }
  RB_SetupUIWhiteBalanceParams(v16, viewInfo);
  v15 = _RBX->source;
  R_Set2D(v15);
  R_ForceSet2D(v15, &viewInfo->displayViewport);
}

/*
==============
RB_IsComputeReady
==============
*/
char RB_IsComputeReady(void *userData)
{
  __int64 v1; 

  v1 = *(_QWORD *)userData;
  if ( !*(_QWORD *)userData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 2420, ASSERT_TYPE_ASSERT, "(data)", (const char *)&queryFormat, "data") )
    __debugbreak();
  if ( *(_DWORD *)(v1 + 927428) )
    return 1;
  RB_CheckSkipRemoteScreenUpdate();
  return 0;
}

/*
==============
RB_IsEmissiveReady
==============
*/
char RB_IsEmissiveReady(void *userData)
{
  __int64 v1; 

  v1 = *(_QWORD *)userData;
  if ( !*(_QWORD *)userData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 2469, ASSERT_TYPE_ASSERT, "(data)", (const char *)&queryFormat, "data") )
    __debugbreak();
  if ( *(_DWORD *)(v1 + 927440) )
    return 1;
  RB_CheckSkipRemoteScreenUpdate();
  return 0;
}

/*
==============
RB_IsHud2DReady
==============
*/
char RB_IsHud2DReady(void *userData)
{
  __int64 v1; 

  v1 = *(_QWORD *)userData;
  if ( !*(_QWORD *)userData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 2485, ASSERT_TYPE_ASSERT, "(data)", (const char *)&queryFormat, "data") )
    __debugbreak();
  if ( *(_DWORD *)(v1 + 927444) || *(_DWORD *)(v1 + 927452) )
    return 1;
  RB_CheckSkipRemoteScreenUpdate();
  return 0;
}

/*
==============
RB_IsOpaqueReady
==============
*/
char RB_IsOpaqueReady(void *userData)
{
  __int64 v1; 

  v1 = *(_QWORD *)userData;
  if ( !*(_QWORD *)userData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 2453, ASSERT_TYPE_ASSERT, "(data)", (const char *)&queryFormat, "data") )
    __debugbreak();
  if ( *(_DWORD *)(v1 + 927436) )
    return 1;
  RB_CheckSkipRemoteScreenUpdate();
  return 0;
}

/*
==============
RB_IsShadowReady
==============
*/
char RB_IsShadowReady(void *userData)
{
  __int64 v1; 

  v1 = *(_QWORD *)userData;
  if ( !*(_QWORD *)userData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 2438, ASSERT_TYPE_ASSERT, "(data)", (const char *)&queryFormat, "data") )
    __debugbreak();
  if ( *(_DWORD *)(v1 + 927432) )
    return 1;
  RB_CheckSkipRemoteScreenUpdate();
  return 0;
}

/*
==============
RB_PerformVolumeLightScatter
==============
*/
void RB_PerformVolumeLightScatter(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  bool v14; 
  const char *v97; 
  GfxCmdBufState *state; 
  unsigned int v101; 
  unsigned int height; 
  unsigned int v103; 
  int v104; 
  int v105; 
  int rtFlags; 
  bool v110; 
  bool v114; 
  GfxCmdBufState *v147; 
  unsigned int v166; 
  const R_RT_Surface *Surface; 
  const R_RT_Surface *v172; 
  const GfxImage *p_m_base; 
  unsigned int v178; 
  const R_RT_Surface *v179; 
  Material *feedbackReplaceScenebufferMaterial; 
  const char *v182; 
  unsigned int v185; 
  const R_RT_Surface *v186; 
  const R_RT_Surface *v191; 
  const GfxImage *v193; 
  unsigned int v196; 
  const R_RT_Surface *v197; 
  unsigned int v201; 
  const R_RT_Surface *v202; 
  unsigned int v210; 
  const R_RT_Surface *v211; 
  int integer; 
  char v214; 
  char v219; 
  R_RT_Handle v239; 
  unsigned int v240; 
  R_RT_Handle v241; 
  R_RT_Handle result; 
  unsigned int width; 
  GfxCmdBufInput *input; 
  R_RT_ColorHandle v252; 
  R_RT_Handle v253; 
  char v254; 
  const char *v257; 
  R_RT_Group v258; 
  void *retaddr; 

  _R11 = &retaddr;
  v14 = (*((_BYTE *)&viewInfo->viewportFeatures + 40) & 0x40) == 0;
  _RSI = viewInfo;
  _R14 = gfxContext;
  if ( (*((_BYTE *)&viewInfo->viewportFeatures + 40) & 0x40) != 0 )
  {
    _RAX = rgp.world;
    __asm
    {
      vmovaps xmmword ptr [r11-48h], xmm6
      vmovaps xmmword ptr [r11-0A8h], xmm12
      vxorps  xmm12, xmm12, xmm12
      vmovss  xmm5, dword ptr [rax+3ADCh]
      vmulss  xmm1, xmm5, dword ptr [rdx+110h]
      vmovss  xmm4, dword ptr [rax+3AD8h]
      vmulss  xmm0, xmm4, dword ptr [rdx+10Ch]
      vmovss  xmm6, dword ptr [rax+3AE0h]
      vaddss  xmm2, xmm1, xmm0
      vmulss  xmm1, xmm6, dword ptr [rdx+114h]
      vaddss  xmm0, xmm2, xmm1
      vcomiss xmm0, xmm12
    }
    if ( !v14 )
    {
      __asm
      {
        vmulss  xmm1, xmm4, dword ptr [rdx+8Ch]
        vmulss  xmm0, xmm5, dword ptr [rdx+9Ch]
        vaddss  xmm2, xmm1, xmm0
        vmulss  xmm1, xmm6, dword ptr [rdx+0ACh]
        vaddss  xmm0, xmm2, xmm1
        vmulss  xmm1, xmm5, dword ptr [rdx+90h]
        vmovaps xmmword ptr [r11-58h], xmm7
        vmovaps xmmword ptr [r11-68h], xmm8
        vmovaps xmmword ptr [r11-88h], xmm10
        vmovss  xmm10, cs:__real@3f800000
        vdivss  xmm3, xmm10, xmm0
        vmulss  xmm0, xmm4, dword ptr [rdx+80h]
        vaddss  xmm2, xmm1, xmm0
        vmulss  xmm1, xmm6, dword ptr [rdx+0A0h]
        vaddss  xmm0, xmm2, xmm1
        vmulss  xmm1, xmm4, dword ptr [rdx+84h]
        vmulss  xmm8, xmm0, xmm3
        vmulss  xmm0, xmm5, dword ptr [rdx+94h]
        vaddss  xmm2, xmm1, xmm0
        vmulss  xmm1, xmm6, dword ptr [rdx+0A4h]
        vmovss  xmm6, dword ptr cs:__xmm@7fffffff7fffffff7fffffff7fffffff
        vaddss  xmm0, xmm2, xmm1
        vmulss  xmm7, xmm0, xmm3
        vandps  xmm0, xmm8, xmm6
        vcomiss xmm0, xmm10
      }
      if ( v14 )
      {
        __asm
        {
          vandps  xmm0, xmm7, xmm6
          vcomiss xmm0, xmm10
        }
        if ( v14 )
        {
          if ( data->activePrimarySunLight )
          {
            __asm
            {
              vmovaps xmmword ptr [r11-78h], xmm9
              vmovaps xmmword ptr [r11-98h], xmm11
              vmovaps xmmword ptr [r11-0B8h], xmm13
              vmovaps xmmword ptr [r11-0C8h], xmm14
              vmovaps xmmword ptr [r11-0D8h], xmm15
            }
            Sys_ProfBeginNamedEvent(0xFFFF7F50, "VolumeLightScatter");
            __asm
            {
              vmovss  xmm11, cs:__real@3f000000
              vmovss  xmm3, dword ptr [rsi+2E58h]
              vmulss  xmm2, xmm8, xmm11
              vaddss  xmm0, xmm2, xmm11
              vmovss  [rbp+300h+var_2EC], xmm0
              vandps  xmm2, xmm2, xmm6
              vmulss  xmm0, xmm7, xmm11
              vsubss  xmm4, xmm11, xmm0
              vmovss  xmm0, dword ptr [rsi+2E64h]
              vmaxss  xmm1, xmm0, cs:__real@34000000
              vdivss  xmm0, xmm10, xmm1
              vmovss  [rbp+300h+var_2E4], xmm0
              vsubss  xmm1, xmm11, xmm3
              vsubss  xmm0, xmm4, xmm11
              vandps  xmm0, xmm0, xmm6
              vmaxss  xmm0, xmm0, xmm2
              vsubss  xmm2, xmm0, xmm3
              vdivss  xmm0, xmm2, xmm1
              vmaxss  xmm3, xmm0, xmm12
              vmulss  xmm1, xmm3, cs:__real@40000000
              vmovss  xmm0, cs:__real@40400000
              vsubss  xmm2, xmm0, xmm1
              vmulss  xmm1, xmm3, xmm3
              vmulss  xmm3, xmm2, xmm1
              vsubss  xmm0, xmm10, xmm3
              vmulss  xmm0, xmm0, dword ptr [rax+28h]
              vmulss  xmm2, xmm0, dword ptr [rcx+rbx+53A010h]
              vmulss  xmm0, xmm2, dword ptr [rsi+2E44h]
              vmulss  xmm0, xmm0, dword ptr [rcx+rbx+53A014h]
              vmulss  xmm1, xmm2, dword ptr [rsi+2E48h]
              vmovss  [rbp+300h+var_2E0], xmm0
              vmulss  xmm0, xmm1, dword ptr [rcx+rbx+53A018h]
              vmovups ymm1, ymmword ptr [rsi+30C0h]
              vmovss  [rbp+300h+var_2DC], xmm0
              vmulss  xmm0, xmm2, dword ptr [rsi+2E4Ch]
              vmulss  xmm0, xmm0, dword ptr [rcx+rbx+53A01Ch]
              vmovss  [rbp+300h+var_2D8], xmm0
              vmovups ymm0, ymmword ptr [rsi+31A0h]
              vmovd   eax, xmm0
              vmovss  [rbp+300h+var_2E8], xmm4
              vmovups ymmword ptr [rbp+300h+var_380.m_surfaceID], ymm0
              vmovups ymmword ptr [rbp+300h+var_350.m_surfaceID], ymm0
              vmovups [rbp+300h+var_330], ymm1
              vmovups [rbp+300h+var_2C0], ymm1
            }
            if ( (_WORD)_EAX )
            {
              R_RT_Handle::GetSurface(&v241);
              __asm
              {
                vmovups ymm0, ymmword ptr [rbp+300h+var_350.m_surfaceID]
                vmovups ymmword ptr [rbp+300h+var_380.m_surfaceID], ymm0
              }
            }
            else
            {
              __asm { vpextrd rax, xmm0, 2 }
              if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
                __debugbreak();
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 463, ASSERT_TYPE_ASSERT, "(depthRt)", (const char *)&queryFormat, "depthRt") )
                __debugbreak();
            }
            __asm
            {
              vmovups ymm0, [rbp+300h+var_330]
              vmovd   eax, xmm0
            }
            v254 = 1;
            __asm { vmovups ymmword ptr [rbp+300h+var_350.m_surfaceID], ymm0 }
            if ( (_WORD)_EAX )
            {
              R_RT_Handle::GetSurface(&v241);
            }
            else
            {
              if ( v252.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
                __debugbreak();
              if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 442, ASSERT_TYPE_ASSERT, "(colorRt)", (const char *)&queryFormat, "colorRt") )
                __debugbreak();
            }
            __asm
            {
              vmovups ymm0, [rbp+300h+var_330]
              vmovups [rbp+300h+var_278], ymm0
              vmovups ymm0, ymmword ptr [rbp+300h+var_380.m_surfaceID]
            }
            _RCX = &v258;
            __asm { vmovups [rbp+300h+var_1F8], ymm0 }
            _RAX = &v254;
            __asm
            {
              vmovups ymm0, ymmword ptr [rax]
              vmovups ymm1, ymmword ptr [rax+80h]
              vmovups ymmword ptr [rcx], ymm0
              vmovups ymm0, ymmword ptr [rax+20h]
              vmovups ymmword ptr [rcx+20h], ymm0
              vmovups ymm0, ymmword ptr [rax+40h]
              vmovups ymmword ptr [rcx+40h], ymm0
              vmovups ymm0, ymmword ptr [rax+60h]
              vmovups ymmword ptr [rcx+60h], ymm0
              vmovups ymmword ptr [rcx+80h], ymm1
              vmovups ymm1, ymmword ptr [rax+0A0h]
            }
            v97 = v257;
            __asm { vmovups ymmword ptr [rcx+0A0h], ymm1 }
            v258.m_vrsRt.m_tracking.m_location = v97;
            R_GPU_BeginTimer(GPU_TIMER_VOLUME_LIGHT_SCATTER);
            _RDI = _R14->source;
            R_InitCmdBufSourceState(_R14->source, &_RSI->input);
            state = _R14->state;
            input = &_RDI->input;
            R_InitLocalCmdBufState(state, &_RDI->input);
            if ( v258.m_colorRtCount != 1 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 559, ASSERT_TYPE_ASSERT, "(this->m_colorRtCount == 1)", (const char *)&queryFormat, "this->m_colorRtCount == 1") )
              __debugbreak();
            __asm
            {
              vmovups ymm0, ymmword ptr [rbp+300h+var_1B0.m_colorRts.baseclass_0.m_surfaceID]
              vmovups ymmword ptr [rbp+300h+var_350.m_surfaceID], ymm0
            }
            width = R_RT_Handle::GetSurface(&v241)->m_image.m_base.width;
            v101 = width >> 1;
            height = R_RT_Handle::GetSurface(&v241)->m_image.m_base.height;
            if ( !v101 )
              v101 = 1;
            v240 = height;
            v103 = height >> 1;
            if ( !(height >> 1) )
              v103 = 1;
            if ( Dvar_GetBool_Internal(r_deviceDebug) || (v104 = 64, !Dvar_GetBool_Internal_DebugName(DCONST_DVARBOOL_r_esramPostFX, "r_esramPostFX")) )
              v104 = 0;
            v105 = 2048;
            if ( Dvar_GetInt_Internal_DebugName(DCONST_DVARINT_r_dccPostFX, "r_dccPostFX") == 1 )
              v105 = 2056;
            rtFlags = v104 | v105;
            _RAX = R_RT_CreateInternal(&result, v101, v103, v101, v103, 1u, 1u, 1u, g_R_RT_renderTargetFmts[27], (R_RT_Flags)rtFlags, R_RT_FlagInternal_None, &colorBlack, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, "R_RENDERTARGET_DEPTH_BLUR_0", 0, NULL, NULL, NULL, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1139)");
            __asm
            {
              vmovups ymm0, ymmword ptr [rax]
              vmovd   eax, xmm0
              vmovups [rbp+300h+var_330], ymm0
              vmovups ymmword ptr [rbp+300h+var_350.m_surfaceID], ymm0
            }
            if ( (_WORD)_RAX )
            {
              R_RT_Handle::GetSurface(&v241);
              if ( (R_RT_Handle::GetSurface(&v241)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
              {
                __asm
                {
                  vmovups ymm0, ymmword ptr [rbp+300h+var_350.m_surfaceID]
                  vmovups [rbp+300h+var_330], ymm0
                }
                __debugbreak();
              }
              else
              {
                __asm
                {
                  vmovups ymm0, ymmword ptr [rbp+300h+var_350.m_surfaceID]
                  vmovups [rbp+300h+var_330], ymm0
                }
              }
            }
            else
            {
              __asm { vpextrd rax, xmm0, 2 }
              if ( (_DWORD)_RAX )
              {
                v110 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
                __asm { vmovups ymm0, [rbp+300h+var_330] }
                if ( v110 )
                  __debugbreak();
              }
            }
            __asm { vmovups ymmword ptr [rbp+300h+var_2A0.m_surfaceID], ymm0 }
            _RAX = R_RT_CreateInternal(&result, v101, v103, v101, v103, 1u, 1u, 1u, g_R_RT_renderTargetFmts[27], (R_RT_Flags)rtFlags, R_RT_FlagInternal_None, &colorBlack, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, "R_RENDERTARGET_DEPTH_BLUR_1", 0, NULL, NULL, NULL, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1140)");
            __asm
            {
              vmovups ymm0, ymmword ptr [rax]
              vmovd   eax, xmm0
              vmovups ymmword ptr [rbp+300h+var_350.m_surfaceID], ymm0
              vmovups ymmword ptr [rbp+300h+var_380.m_surfaceID], ymm0
            }
            if ( (_WORD)_RAX )
            {
              R_RT_Handle::GetSurface(&v239);
              if ( (R_RT_Handle::GetSurface(&v239)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
              {
                __asm
                {
                  vmovups ymm0, ymmword ptr [rbp+300h+var_380.m_surfaceID]
                  vmovups ymmword ptr [rbp+300h+var_350.m_surfaceID], ymm0
                }
                __debugbreak();
              }
              else
              {
                __asm
                {
                  vmovups ymm0, ymmword ptr [rbp+300h+var_380.m_surfaceID]
                  vmovups ymmword ptr [rbp+300h+var_350.m_surfaceID], ymm0
                }
              }
            }
            else
            {
              __asm { vpextrd rax, xmm0, 2 }
              if ( (_DWORD)_RAX )
              {
                v114 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
                __asm { vmovups ymm0, ymmword ptr [rbp+300h+var_350.m_surfaceID] }
                if ( v114 )
                  __debugbreak();
              }
            }
            __asm
            {
              vmovups ymmword ptr [rbp+300h+result.m_surfaceID], ymm0
              vxorps  xmm0, xmm0, xmm0
              vcvtsi2ss xmm0, xmm0, rax
              vdivss  xmm3, xmm10, xmm0
              vxorps  xmm0, xmm0, xmm0
              vcvtsi2ss xmm0, xmm0, r8
              vxorps  xmm1, xmm1, xmm1
              vcvtsi2ss xmm1, xmm1, r13
              vdivss  xmm2, xmm10, xmm1
              vaddss  xmm1, xmm0, xmm11
              vxorps  xmm0, xmm0, xmm0
              vcvtsi2ss xmm0, xmm0, r9
              vmulss  xmm9, xmm1, xmm2
              vaddss  xmm1, xmm0, xmm11
              vxorps  xmm0, xmm0, xmm0
              vmulss  xmm8, xmm1, xmm3
              vcvtsi2ss xmm0, xmm0, rax
              vsubss  xmm1, xmm0, xmm11
              vxorps  xmm0, xmm0, xmm0
              vmulss  xmm7, xmm1, xmm2
              vcvtsi2ss xmm0, xmm0, rcx
              vsubss  xmm1, xmm0, xmm11
              vxorps  xmm0, xmm0, xmm0
              vmulss  xmm6, xmm1, xmm3
              vxorps  xmm1, xmm1, xmm1
              vcvtsi2ss xmm0, xmm0, rcx
              vdivss  xmm3, xmm10, xmm0
              vcvtsi2ss xmm1, xmm1, rcx
              vxorps  xmm0, xmm0, xmm0
              vcvtsi2ss xmm0, xmm0, rcx
              vdivss  xmm2, xmm10, xmm1
              vaddss  xmm1, xmm0, xmm11
              vxorps  xmm0, xmm0, xmm0
            }
            v147 = _R14->state;
            __asm
            {
              vmulss  xmm13, xmm1, xmm2
              vcvtsi2ss xmm0, xmm0, rcx
              vaddss  xmm1, xmm0, xmm11
              vxorps  xmm0, xmm0, xmm0
              vcvtsi2ss xmm0, xmm0, rcx
              vmulss  xmm14, xmm1, xmm3
              vsubss  xmm1, xmm0, xmm11
              vxorps  xmm0, xmm0, xmm0
              vcvtsi2ss xmm0, xmm0, rcx
              vmulss  xmm15, xmm1, xmm2
              vsubss  xmm1, xmm0, xmm11
              vmulss  xmm11, xmm1, xmm3
            }
            R_ProfBeginNamedEvent(v147, "VolumeLightScatter");
            __asm
            {
              vmovss  xmm0, dword ptr [rsi+2E50h]
              vmovss  xmm1, [rbp+300h+var_2EC]
              vmovss  xmm2, [rbp+300h+var_2E4]
              vmovss  dword ptr [rdi+0D40h], xmm1
              vmovss  xmm1, [rbp+300h+var_2E8]
              vmovss  dword ptr [rdi+0D4Ch], xmm0
              vmovups ymm0, [rbp+300h+var_330]
              vmovss  dword ptr [rdi+0D44h], xmm1
              vmovss  dword ptr [rdi+0D48h], xmm2
            }
            ++_RDI->constVersions[100];
            __asm
            {
              vmovss  dword ptr [rdi+0D50h], xmm9
              vmovss  dword ptr [rdi+0D54h], xmm8
              vmovss  dword ptr [rdi+0D58h], xmm7
              vmovss  dword ptr [rdi+0D5Ch], xmm6
            }
            ++_RDI->constVersions[101];
            __asm { vmovups [rbp+300h+var_2C0], ymm0 }
            R_AddRenderTargetTransition(v147, &v252, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
            R_FlushResourceTransitions(v147);
            R_SetViewportStruct(_RDI, &_RSI->sceneViewport);
            __asm
            {
              vmovups ymm0, [rbp+300h+var_330]
              vmovups ymmword ptr [rbp+300h+var_380.m_surfaceID], ymm0
            }
            v166 = R_RT_Handle::GetSurface(&v239)->m_image.m_base.height;
            Surface = R_RT_Handle::GetSurface(&v239);
            R_SetRenderTargetSize(_RDI, Surface->m_image.m_base.width, v166, GFX_USE_VIEWPORT_FULL);
            __asm
            {
              vmovups ymm0, [rbp+300h+var_330]
              vmovups [rbp+300h+var_2C0], ymm0
              vmovups xmm0, xmmword ptr [r14]
              vmovups xmmword ptr [rbp+300h+var_380.m_surfaceID], xmm0
            }
            R_SetRenderTargetsInternal_ColorOnly((GfxCmdBufContext *)&v239, &v252, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1160)");
            __asm
            {
              vmovups xmm0, xmmword ptr [r14]
              vmovups xmmword ptr [rbp+300h+var_380.m_surfaceID], xmm0
            }
            RB_FullScreenFilterInternal((GfxCmdBufContext *)&v239, rgp.volumeLightScatterBlur0Material, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1161)");
            __asm
            {
              vmovups ymm0, [rbp+300h+var_330]
              vmovups [rbp+300h+var_2C0], ymm0
            }
            R_AddRenderTargetTransition(v147, &v252, RENDERTARGET_TRANSITION_MODE_READ, D3D12_RESOURCE_BARRIER_FLAG_NONE);
            R_FlushResourceTransitions(v147);
            v172 = R_RT_Handle::GetSurface(&v253);
            __asm
            {
              vmovups xmm0, xmmword ptr [r14]
              vmovups xmmword ptr [rbp+300h+var_380.m_surfaceID], xmm0
            }
            p_m_base = &v172->m_image.m_base;
            R_Resolve((GfxCmdBufContext *)&v239, &v172->m_image.m_base);
            __asm { vmovaps xmm9, [rsp+420h+var_78+8] }
            if ( r_volumeLightScatterDebug->current.integer == 1 )
            {
              _RAX = R_RT_Group::GetValidRt(&v258, &result);
              __asm
              {
                vmovups ymm0, ymmword ptr [rax]
                vmovups ymmword ptr [rbp+300h+var_380.m_surfaceID], ymm0
              }
              v178 = R_RT_Handle::GetSurface(&v239)->m_image.m_base.height;
              v179 = R_RT_Handle::GetSurface(&v239);
              R_SetRenderTargetSize(_RDI, v179->m_image.m_base.width, v178, GFX_USE_VIEWPORT_FOR_VIEW);
              __asm
              {
                vmovups xmm0, xmmword ptr [r14]
                vmovups xmmword ptr [rbp+300h+var_380.m_surfaceID], xmm0
              }
              R_SetRenderTargetsInternal((GfxCmdBufContext *)&v239, &v258, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1173)");
              R_SetCodeImageTextureInternal(_RDI, 4u, p_m_base, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1174)");
              feedbackReplaceScenebufferMaterial = rgp.feedbackReplaceScenebufferMaterial;
              v182 = "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1175)";
            }
            else
            {
              __asm
              {
                vmovups ymm0, ymmword ptr [rbp+300h+var_350.m_surfaceID]
                vmovups ymmword ptr [rbp+300h+var_2A0.m_surfaceID], ymm0
              }
              R_AddRenderTargetTransition(v147, (R_RT_ColorHandle *)&v253, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
              R_FlushResourceTransitions(v147);
              R_SetCodeImageTextureInternal(_RDI, 0x1Bu, p_m_base, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1183)");
              __asm
              {
                vmovups ymm0, ymmword ptr [rbp+300h+var_350.m_surfaceID]
                vmovss  dword ptr [rdi+0D50h], xmm13
                vmovss  dword ptr [rdi+0D54h], xmm14
                vmovss  dword ptr [rdi+0D58h], xmm15
                vmovss  dword ptr [rdi+0D5Ch], xmm11
              }
              ++_RDI->constVersions[101];
              __asm { vmovups ymmword ptr [rbp+300h+var_380.m_surfaceID], ymm0 }
              v185 = R_RT_Handle::GetSurface(&v239)->m_image.m_base.height;
              v186 = R_RT_Handle::GetSurface(&v239);
              R_SetRenderTargetSize(_RDI, v186->m_image.m_base.width, v185, GFX_USE_VIEWPORT_FULL);
              __asm
              {
                vmovups ymm0, ymmword ptr [rbp+300h+var_350.m_surfaceID]
                vmovups ymmword ptr [rbp+300h+var_2A0.m_surfaceID], ymm0
                vmovups xmm0, xmmword ptr [r14]
                vmovups xmmword ptr [rbp+300h+var_380.m_surfaceID], xmm0
              }
              R_SetRenderTargetsInternal_ColorOnly((GfxCmdBufContext *)&v239, (R_RT_ColorHandle *)&v253, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1186)");
              __asm
              {
                vmovups xmm0, xmmword ptr [r14]
                vmovups xmmword ptr [rbp+300h+var_380.m_surfaceID], xmm0
              }
              RB_FullScreenFilterInternal((GfxCmdBufContext *)&v239, rgp.volumeLightScatterBlur1Material, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1187)");
              __asm
              {
                vmovups ymm0, ymmword ptr [rbp+300h+var_350.m_surfaceID]
                vmovups ymmword ptr [rbp+300h+var_2A0.m_surfaceID], ymm0
              }
              R_AddRenderTargetTransition(v147, (R_RT_ColorHandle *)&v253, RENDERTARGET_TRANSITION_MODE_READ, D3D12_RESOURCE_BARRIER_FLAG_NONE);
              R_FlushResourceTransitions(v147);
              v191 = R_RT_Handle::GetSurface(&result);
              __asm
              {
                vmovups xmm0, xmmword ptr [r14]
                vmovups xmmword ptr [rbp+300h+var_380.m_surfaceID], xmm0
              }
              v193 = &v191->m_image.m_base;
              R_Resolve((GfxCmdBufContext *)&v239, &v191->m_image.m_base);
              if ( r_volumeLightScatterDebug->current.integer == 2 )
              {
                _RAX = R_RT_Group::GetValidRt(&v258, &result);
                __asm
                {
                  vmovups ymm0, ymmword ptr [rax]
                  vmovups ymmword ptr [rbp+300h+var_380.m_surfaceID], ymm0
                }
                v196 = R_RT_Handle::GetSurface(&v239)->m_image.m_base.height;
                v197 = R_RT_Handle::GetSurface(&v239);
                R_SetRenderTargetSize(_RDI, v197->m_image.m_base.width, v196, GFX_USE_VIEWPORT_FOR_VIEW);
                __asm
                {
                  vmovups xmm0, xmmword ptr [r14]
                  vmovups xmmword ptr [rbp+300h+var_380.m_surfaceID], xmm0
                }
                R_SetRenderTargetsInternal((GfxCmdBufContext *)&v239, &v258, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1199)");
                R_SetCodeImageTextureInternal(_RDI, 4u, v193, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1200)");
                feedbackReplaceScenebufferMaterial = rgp.feedbackReplaceScenebufferMaterial;
                v182 = "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1201)";
              }
              else
              {
                __asm
                {
                  vmovups ymm0, [rbp+300h+var_330]
                  vmovups ymmword ptr [rbp+300h+result.m_surfaceID], ymm0
                }
                R_AddRenderTargetTransition(v147, (R_RT_ColorHandle *)&result, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
                R_FlushResourceTransitions(v147);
                R_SetCodeImageTextureInternal(_RDI, 0x1Cu, v193, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1210)");
                __asm
                {
                  vmovups ymm0, [rbp+300h+var_330]
                  vmovups ymmword ptr [rbp+300h+var_380.m_surfaceID], ymm0
                }
                v201 = R_RT_Handle::GetSurface(&v239)->m_image.m_base.height;
                v202 = R_RT_Handle::GetSurface(&v239);
                R_SetRenderTargetSize(_RDI, v202->m_image.m_base.width, v201, GFX_USE_VIEWPORT_FULL);
                __asm
                {
                  vmovups ymm0, [rbp+300h+var_330]
                  vmovups ymmword ptr [rbp+300h+result.m_surfaceID], ymm0
                  vmovups xmm0, xmmword ptr [r14]
                  vmovups xmmword ptr [rbp+300h+var_380.m_surfaceID], xmm0
                }
                R_SetRenderTargetsInternal_ColorOnly((GfxCmdBufContext *)&v239, (R_RT_ColorHandle *)&result, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1212)");
                __asm
                {
                  vmovups xmm0, xmmword ptr [r14]
                  vmovups xmmword ptr [rbp+300h+var_380.m_surfaceID], xmm0
                }
                RB_FullScreenFilterInternal((GfxCmdBufContext *)&v239, rgp.volumeLightScatterBlur2Material, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1213)");
                __asm
                {
                  vmovups ymm0, [rbp+300h+var_330]
                  vmovups ymmword ptr [rbp+300h+result.m_surfaceID], ymm0
                }
                R_AddRenderTargetTransition(v147, (R_RT_ColorHandle *)&result, RENDERTARGET_TRANSITION_MODE_READ, D3D12_RESOURCE_BARRIER_FLAG_NONE);
                R_FlushResourceTransitions(v147);
                __asm
                {
                  vmovups xmm0, xmmword ptr [r14]
                  vmovups xmmword ptr [rbp+300h+var_380.m_surfaceID], xmm0
                }
                R_Resolve((GfxCmdBufContext *)&v239, p_m_base);
                _RAX = R_RT_Group::GetValidRt(&v258, &result);
                __asm
                {
                  vmovups ymm0, ymmword ptr [rax]
                  vmovups ymmword ptr [rbp+300h+var_380.m_surfaceID], ymm0
                }
                v210 = R_RT_Handle::GetSurface(&v239)->m_image.m_base.height;
                v211 = R_RT_Handle::GetSurface(&v239);
                R_SetRenderTargetSize(_RDI, v211->m_image.m_base.width, v210, GFX_USE_VIEWPORT_FOR_VIEW);
                __asm
                {
                  vmovups xmm0, xmmword ptr [r14]
                  vmovups xmmword ptr [rbp+300h+var_380.m_surfaceID], xmm0
                }
                R_SetRenderTargetsInternal((GfxCmdBufContext *)&v239, &v258, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1221)");
                integer = r_volumeLightScatterDebug->current.integer;
                if ( integer == 3 )
                {
                  R_SetCodeImageTextureInternal(_RDI, 4u, p_m_base, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1225)");
                  feedbackReplaceScenebufferMaterial = rgp.feedbackReplaceScenebufferMaterial;
                  v182 = "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1226)";
                }
                else
                {
                  if ( integer == 4 )
                    R_ClearScreen(v147, 0xFu, 0);
                  R_SetCodeImageTextureInternal(_RDI, 0x1Bu, p_m_base, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1236)");
                  __asm
                  {
                    vmovss  xmm0, dword ptr [rsi+2E54h]
                    vmovss  xmm1, [rbp+300h+var_2E0]
                    vmovss  xmm2, [rbp+300h+var_2DC]
                    vmovss  xmm3, [rbp+300h+var_2D8]
                    vmovss  dword ptr [rdi+0D50h], xmm1
                    vmovss  dword ptr [rdi+0D54h], xmm2
                    vmovss  dword ptr [rdi+0D58h], xmm3
                    vmovss  dword ptr [rdi+0D5Ch], xmm0
                  }
                  v219 = v214 | (_RDI->constVersions[101]++ == 0xFFFF);
                  __asm
                  {
                    vmovss  xmm2, dword ptr [rsi+2E5Ch]
                    vmovss  xmm0, dword ptr [rsi+2E60h]
                    vmaxss  xmm1, xmm0, xmm2
                    vcomiss xmm1, xmm12
                  }
                  if ( v219 )
                    goto LABEL_59;
                  __asm { vcomiss xmm0, xmm2 }
                  if ( v214 )
                  {
LABEL_59:
                    feedbackReplaceScenebufferMaterial = rgp.volumeLightScatterApplyMaterial;
                    v182 = "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1248)";
                  }
                  else
                  {
                    __asm
                    {
                      vsubss  xmm0, xmm0, xmm2
                      vdivss  xmm1, xmm10, xmm0
                    }
                    v182 = "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1244)";
                    *(_QWORD *)&_RDI->input.consts[102].xyz.z = 0i64;
                    __asm
                    {
                      vmovss  dword ptr [rdi+0D60h], xmm2
                      vmovss  dword ptr [rdi+0D64h], xmm1
                    }
                    ++_RDI->constVersions[102];
                    feedbackReplaceScenebufferMaterial = rgp.volumeLightScatterApplyWithDepthAttenMaterial;
                  }
                }
              }
            }
            __asm
            {
              vmovups xmm0, xmmword ptr [r14]
              vmovups xmmword ptr [rbp+300h+var_380.m_surfaceID], xmm0
            }
            RB_FullScreenFilterInternal((GfxCmdBufContext *)&v239, feedbackReplaceScenebufferMaterial, v182);
            __asm
            {
              vmovups ymm0, ymmword ptr [rbp+300h+var_350.m_surfaceID]
              vmovups ymmword ptr [rbp+300h+result.m_surfaceID], ymm0
              vmovups xmm0, xmmword ptr [r14]
              vmovups xmmword ptr [rbp+300h+var_380.m_surfaceID], xmm0
            }
            R_RT_Destroy((GfxCmdBufContext *)&v239, (R_RT_ColorHandle *)&result);
            __asm
            {
              vmovups ymm0, [rbp+300h+var_330]
              vmovups ymmword ptr [rbp+300h+result.m_surfaceID], ymm0
              vmovups xmm0, xmmword ptr [r14]
              vmovups xmmword ptr [rbp+300h+var_380.m_surfaceID], xmm0
            }
            R_RT_Destroy((GfxCmdBufContext *)&v239, (R_RT_ColorHandle *)&result);
            R_GPU_EndTimer();
            R_ProfEndNamedEvent(v147);
            R_ShutdownLocalCmdBufState(v147, input);
            Sys_ProfEndNamedEvent();
            __asm
            {
              vmovaps xmm15, [rsp+420h+var_D8+8]
              vmovaps xmm14, [rsp+420h+var_C8+8]
              vmovaps xmm13, [rsp+420h+var_B8+8]
              vmovaps xmm11, [rsp+420h+var_98+8]
            }
          }
        }
      }
      __asm
      {
        vmovaps xmm8, [rsp+420h+var_68+8]
        vmovaps xmm7, [rsp+420h+var_58+8]
        vmovaps xmm10, [rsp+420h+var_88+8]
      }
    }
    __asm
    {
      vmovaps xmm6, [rsp+420h+var_48+8]
      vmovaps xmm12, [rsp+420h+var_A8+8]
    }
  }
}

/*
==============
RB_PreOpaque_MapMeshes
==============
*/
void RB_PreOpaque_MapMeshes(const GfxBackEndData *data)
{
  ;
}

/*
==============
RB_PreOpaque_UnmapMeshes
==============
*/
void RB_PreOpaque_UnmapMeshes(const GfxBackEndData *data)
{
  ;
}

/*
==============
RB_ResolveDistortion
==============
*/
void RB_ResolveDistortion(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo)
{
  GfxCmdBufSourceState *source; 
  GfxCmdBufContext v8; 
  R_RT_ColorHandle v9; 
  R_RT_ColorHandle v10; 

  source = gfxContext->source;
  _RBX = gfxContext;
  _RBP = viewInfo;
  Profile2_UpdateEntry(59);
  if ( ((unsigned __int8)&dword_14FDE80BC & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE80BC) )
    __debugbreak();
  _InterlockedIncrement(&dword_14FDE80BC);
  R_InitCmdBufSourceState(source, &_RBP->input);
  R_InitLocalCmdBufState(_RBX->state, &source->input);
  Profile_Begin(104);
  R_ProfBeginNamedEvent(_RBX->state, "Resolve Distortion");
  __asm
  {
    vmovups ymm0, ymmword ptr [rbp+33E0h]
    vmovups ymm1, ymmword ptr [rbp+30C0h]
    vmovups [rsp+98h+var_58], ymm0
    vmovups xmm0, xmmword ptr [rbx]
    vmovups [rsp+98h+var_68], xmm0
    vmovups [rsp+98h+var_38], ymm1
  }
  RB_Perceptual_ScatterBlurScene(&v8, _RBP, &v10, &v9, 1);
  R_ProfEndNamedEvent(_RBX->state);
  Profile_EndInternal(NULL);
  Profile2_UpdateEntry(59);
  if ( ((unsigned __int64)&dword_14FDE80BC & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 44, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE80BC) )
    __debugbreak();
  _InterlockedDecrement(&dword_14FDE80BC);
  R_ShutdownLocalCmdBufState(_RBX->state, &source->input);
}

/*
==============
RB_ResolveFloatZFull
==============
*/
void RB_ResolveFloatZFull(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo)
{
  GfxCmdBufState *state; 
  bool v14; 
  __int16 v15; 
  unsigned __int16 v16; 
  bool v20; 
  bool v26; 
  __int16 v27; 
  unsigned __int16 v28; 
  const char *v32; 
  int v33; 
  const char *v34; 
  bool v40; 
  __int16 v41; 
  unsigned __int16 v42; 
  const char *v46; 
  int v47; 
  const char *v48; 
  GfxCmdBufSourceState *source; 
  const R_RT_Surface *Surface; 
  const GfxTexture *Resident; 
  const R_RT_Surface *v54; 
  const GfxTexture *v55; 
  ComputeCmdBufState *GfxComputeCmdBufState; 
  ComputeCmdBufState *v61; 
  unsigned int v67; 
  unsigned int levelCount; 
  const R_RT_Surface *v71; 
  const GfxTexture *v72; 
  const R_RT_Surface *v73; 
  const GfxTexture *v74; 
  R_RT_Handle v76; 
  R_RT_Handle v77; 
  R_RT_Handle v78; 
  R_RT_Handle v79; 
  R_RT_Handle v80; 
  R_RT_ColorHandle v82; 
  R_RT_ColorHandle v83; 
  R_RT_DepthHandle v84; 
  R_RT_Handle v87; 
  R_RT_ColorHandle v88; 

  __asm { vmovups ymm0, ymmword ptr [rdx+31A0h] }
  state = gfxContext->state;
  _R13 = viewInfo;
  __asm
  {
    vmovups [rbp+140h+var_140], ymm0
    vmovups ymm0, ymmword ptr [rdx+3340h]
    vmovups [rbp+140h+var_A0], ymm0
    vmovups ymmword ptr [rbp+140h+var_80.m_surfaceID], ymm0
    vmovups ymm0, ymmword ptr [rdx+3360h]
    vmovups [rbp+140h+var_C0], ymm0
    vmovups ymm0, ymmword ptr [rdx+3340h]
    vmovups ymmword ptr [rbp+140h+var_180.m_surfaceID], ymm0
  }
  _RAX = R_RT_GetViewInternal(&v80, &v79, 0, 1);
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   ebx, xmm0
    vmovups ymmword ptr [rbp+140h+var_180.m_surfaceID], ymm0
    vmovups ymmword ptr [rsp+240h+var_1E0.m_surfaceID], ymm0
  }
  if ( (_WORD)_EBX )
  {
    R_RT_Handle::GetSurface(&v76);
    if ( (R_RT_Handle::GetSurface(&v76)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      LODWORD(_RDI) = v76.m_tracking.m_allocCounter;
      LOWORD(_EBX) = v76.m_surfaceID;
      __asm { vmovups ymm0, ymmword ptr [rsp+240h+var_1E0.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      LODWORD(_RDI) = v76.m_tracking.m_allocCounter;
      LOWORD(_EBX) = v76.m_surfaceID;
      __asm { vmovups ymm0, ymmword ptr [rsp+240h+var_1E0.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rdi, xmm0, 2 }
    if ( (_DWORD)_RDI )
    {
      v14 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, ymmword ptr [rbp+140h+var_180.m_surfaceID] }
      if ( v14 )
        __debugbreak();
    }
  }
  __asm { vmovups [rbp+140h+var_60], ymm0 }
  v15 = _EBX & 0x7FFF;
  if ( v15 )
  {
    v16 = v15 | 0x8000;
    v77.m_surfaceID = v16;
  }
  else
  {
    v16 = 0;
    v77.m_surfaceID = 0;
  }
  __asm
  {
    vmovups xmm0, xmmword ptr [rsp+240h+var_1E0.m_tracking.m_allocCounter]
    vmovsd  xmm1, [rsp+240h+var_1E0.m_tracking.m_location]
    vmovups xmmword ptr [rbp+140h+var_1C0.m_tracking.m_allocCounter], xmm0
    vmovsd  [rbp+140h+var_1C0.m_tracking.m_location], xmm1
    vmovups ymm0, ymmword ptr [rbp+140h+var_1C0.m_surfaceID]
    vmovups ymmword ptr [rbp+140h+var_180.m_surfaceID], ymm0
  }
  if ( v16 )
  {
    R_RT_Handle::GetSurface(&v79);
    if ( (R_RT_Handle::GetSurface(&v79)->m_rtFlagsInternal & 0x18) == 0 )
      goto LABEL_19;
    v20 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()");
  }
  else
  {
    if ( !(_DWORD)_RDI )
      goto LABEL_19;
    v20 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
  }
  if ( v20 )
    __debugbreak();
LABEL_19:
  __asm
  {
    vmovups ymm0, ymmword ptr [r13+3340h]
    vmovups ymmword ptr [rbp+140h+var_1A0.m_surfaceID], ymm0
  }
  _RAX = R_RT_GetViewInternal(&v80, &v78, 0, 2);
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   ebx, xmm0
    vmovups ymmword ptr [rbp+140h+var_1A0.m_surfaceID], ymm0
    vmovups ymmword ptr [rsp+240h+var_1E0.m_surfaceID], ymm0
  }
  if ( (_WORD)_EBX )
  {
    R_RT_Handle::GetSurface(&v76);
    if ( (R_RT_Handle::GetSurface(&v76)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      LODWORD(_RDI) = v76.m_tracking.m_allocCounter;
      LOWORD(_EBX) = v76.m_surfaceID;
      __asm { vmovups ymm0, ymmword ptr [rsp+240h+var_1E0.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      LODWORD(_RDI) = v76.m_tracking.m_allocCounter;
      LOWORD(_EBX) = v76.m_surfaceID;
      __asm { vmovups ymm0, ymmword ptr [rsp+240h+var_1E0.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rdi, xmm0, 2 }
    if ( (_DWORD)_RDI )
    {
      v26 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, ymmword ptr [rbp+140h+var_1A0.m_surfaceID] }
      if ( v26 )
        __debugbreak();
    }
  }
  __asm { vmovups [rbp+140h+var_60], ymm0 }
  v27 = _EBX & 0x7FFF;
  if ( v27 )
  {
    v28 = v27 | 0x8000;
    v77.m_surfaceID = v28;
  }
  else
  {
    v28 = 0;
    v77.m_surfaceID = 0;
  }
  __asm
  {
    vmovups xmm0, xmmword ptr [rsp+240h+var_1E0.m_tracking.m_allocCounter]
    vmovsd  xmm1, [rsp+240h+var_1E0.m_tracking.m_location]
    vmovups xmmword ptr [rbp+140h+var_1C0.m_tracking.m_allocCounter], xmm0
    vmovsd  [rbp+140h+var_1C0.m_tracking.m_location], xmm1
    vmovups ymm0, ymmword ptr [rbp+140h+var_1C0.m_surfaceID]
    vmovups ymmword ptr [rbp+140h+var_1A0.m_surfaceID], ymm0
  }
  if ( v28 )
  {
    R_RT_Handle::GetSurface(&v78);
    if ( (R_RT_Handle::GetSurface(&v78)->m_rtFlagsInternal & 0x18) == 0 )
      goto LABEL_37;
    v32 = "!unionHandle.IsValid() || unionHandle.IsColor()";
    v33 = 217;
    v34 = "(!unionHandle.IsValid() || unionHandle.IsColor())";
  }
  else
  {
    if ( !(_DWORD)_RDI )
      goto LABEL_37;
    v32 = "!this->m_tracking.m_allocCounter";
    v33 = 100;
    v34 = "(!this->m_tracking.m_allocCounter)";
  }
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", v33, ASSERT_TYPE_ASSERT, v34, (const char *)&queryFormat, v32) )
    __debugbreak();
LABEL_37:
  __asm
  {
    vmovups ymm0, ymmword ptr [r13+3340h]
    vmovups ymmword ptr [rbp+140h+var_1C0.m_surfaceID], ymm0
  }
  _RAX = R_RT_GetViewInternal(&v80, &v77, 0, 3);
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovd   ebx, xmm0
    vmovups ymmword ptr [rbp+140h+var_1C0.m_surfaceID], ymm0
    vmovups ymmword ptr [rsp+240h+var_1E0.m_surfaceID], ymm0
  }
  if ( (_WORD)_EBX )
  {
    R_RT_Handle::GetSurface(&v76);
    if ( (R_RT_Handle::GetSurface(&v76)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
    {
      LODWORD(_RDI) = v76.m_tracking.m_allocCounter;
      LOWORD(_EBX) = v76.m_surfaceID;
      __asm { vmovups ymm0, ymmword ptr [rsp+240h+var_1E0.m_surfaceID] }
      __debugbreak();
    }
    else
    {
      LODWORD(_RDI) = v76.m_tracking.m_allocCounter;
      LOWORD(_EBX) = v76.m_surfaceID;
      __asm { vmovups ymm0, ymmword ptr [rsp+240h+var_1E0.m_surfaceID] }
    }
  }
  else
  {
    __asm { vpextrd rdi, xmm0, 2 }
    if ( (_DWORD)_RDI )
    {
      v40 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, ymmword ptr [rbp+140h+var_1C0.m_surfaceID] }
      if ( v40 )
        __debugbreak();
    }
  }
  __asm { vmovups [rbp+140h+var_60], ymm0 }
  v41 = _EBX & 0x7FFF;
  if ( v41 )
  {
    v42 = v41 | 0x8000;
    v77.m_surfaceID = v42;
  }
  else
  {
    v42 = 0;
    v77.m_surfaceID = 0;
  }
  __asm
  {
    vmovups xmm0, xmmword ptr [rsp+240h+var_1E0.m_tracking.m_allocCounter]
    vmovsd  xmm1, [rsp+240h+var_1E0.m_tracking.m_location]
    vmovups xmmword ptr [rbp+140h+var_1C0.m_tracking.m_allocCounter], xmm0
    vmovsd  [rbp+140h+var_1C0.m_tracking.m_location], xmm1
    vmovups ymm0, ymmword ptr [rbp+140h+var_1C0.m_surfaceID]
    vmovups ymmword ptr [rbp+140h+var_1C0.m_surfaceID], ymm0
  }
  if ( v42 )
  {
    R_RT_Handle::GetSurface(&v77);
    if ( (R_RT_Handle::GetSurface(&v77)->m_rtFlagsInternal & 0x18) == 0 )
      goto LABEL_55;
    v46 = "!unionHandle.IsValid() || unionHandle.IsColor()";
    v47 = 217;
    v48 = "(!unionHandle.IsValid() || unionHandle.IsColor())";
  }
  else
  {
    if ( !(_DWORD)_RDI )
      goto LABEL_55;
    v46 = "!this->m_tracking.m_allocCounter";
    v47 = 100;
    v48 = "(!this->m_tracking.m_allocCounter)";
  }
  if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", v47, ASSERT_TYPE_ASSERT, v48, (const char *)&queryFormat, v46) )
    __debugbreak();
LABEL_55:
  __asm { vmovups ymm0, ymmword ptr [r13+33C0h] }
  source = gfxContext->source;
  __asm
  {
    vmovups [rbp+140h+var_100], ymm0
    vmovups ymmword ptr [rsp+240h+var_1E0.m_surfaceID], ymm0
    vmovups ymm0, ymmword ptr [r13+3200h]
    vmovups [rbp+140h+var_E0], ymm0
  }
  R_InitLocalCmdBufState(state, &source->input);
  R_ProfBeginNamedEvent(state, "Resolve FloatZ");
  R_GPU_BeginTimer(GPU_TIMER_RESOLVE_FLOAT_Z_MULTI);
  Surface = R_RT_Handle::GetSurface(&v87);
  Resident = R_Texture_GetResident(Surface->m_image.m_base.textureId);
  R_HW_AddResourceTransition(state, Resident, 0xFFFFFFFF, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  v54 = R_RT_Handle::GetSurface(&v76);
  v55 = R_Texture_GetResident(v54->m_image.m_base.textureId);
  R_HW_AddResourceTransition(state, v55, 0xFFFFFFFF, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  __asm
  {
    vmovups ymm0, [rbp+140h+var_140]
    vmovups [rbp+140h+var_120], ymm0
  }
  R_AddDepthStencilTransition(state, (R_RT_DepthHandle *)&v82, DEPTHSTENCIL_TRANSITION_MODE_READ_PRESERVE_COMPRESSION, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  R_HW_FlushResourceTransitions(state);
  GfxComputeCmdBufState = R_GetGfxComputeCmdBufState(state);
  __asm
  {
    vmovups ymm0, [rbp+140h+var_100]
    vmovups ymm1, [rbp+140h+var_C0]
    vmovups [rbp+140h+var_100], ymm0
    vmovups ymm0, [rbp+140h+var_E0]
  }
  v61 = GfxComputeCmdBufState;
  __asm
  {
    vmovups [rbp+140h+var_E0], ymm0
    vmovups ymm0, ymmword ptr [rbp+140h+var_1C0.m_surfaceID]
    vmovups ymmword ptr [rbp+140h+var_1C0.m_surfaceID], ymm0
    vmovups ymm0, ymmword ptr [rbp+140h+var_1A0.m_surfaceID]
    vmovups ymmword ptr [rbp+140h+var_1A0.m_surfaceID], ymm0
    vmovups ymm0, ymmword ptr [rbp+140h+var_180.m_surfaceID]
    vmovups ymmword ptr [rbp+140h+var_180.m_surfaceID], ymm0
    vmovups ymm0, [rbp+140h+var_A0]
    vmovups [rbp+140h+var_60], ymm0
    vmovups ymm0, [rbp+140h+var_140]
    vmovups [rbp+140h+var_160], ymm0
    vmovups [rbp+140h+var_120], ymm1
  }
  R_ResolveFloatZDownsample(GfxComputeCmdBufState, _R13, (R_RT_DepthHandle *)&v80, &v88, (R_RT_ColorHandle *)&v79, (R_RT_ColorHandle *)&v78, (R_RT_ColorHandle *)&v77, &v82, &v84, &v83, NULL);
  R_ComputeWaitForCompute(v61, PIPE_FLUSH_PARTIAL);
  v67 = 4;
  levelCount = R_RT_Handle::GetSurface(&_R13->sceneRtInput.m_floatZFullRt)->m_image.m_base.levelCount;
  if ( levelCount > 4 )
  {
    do
    {
      __asm
      {
        vmovups ymm0, [rbp+140h+var_C0]
        vmovups [rbp+140h+var_160], ymm0
        vmovups ymm0, [rbp+140h+var_A0]
        vmovups [rbp+140h+var_60], ymm0
      }
      R_ResolveFloatZDownsampleCS(v61, &v88, (R_RT_ColorHandle *)&v80, v67 - 1, 0, 0);
      v67 += 4;
    }
    while ( v67 < levelCount );
  }
  v71 = R_RT_Handle::GetSurface(&v87);
  v72 = R_Texture_GetResident(v71->m_image.m_base.textureId);
  R_HW_AddResourceTransition(state, v72, 0xFFFFFFFF, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  v73 = R_RT_Handle::GetSurface(&v76);
  v74 = R_Texture_GetResident(v73->m_image.m_base.textureId);
  R_HW_AddResourceTransition(state, v74, 0xFFFFFFFF, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  __asm
  {
    vmovups ymm0, [rbp+140h+var_140]
    vmovups [rbp+140h+var_160], ymm0
  }
  R_AddDepthStencilTransition(state, (R_RT_DepthHandle *)&v80, DEPTHSTENCIL_TRANSITION_MODE_WRITE_PRESERVE_COMPRESSION, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  R_HW_FlushResourceTransitions(state);
  R_HW_FlushResourceTransitions(state);
  R_GPU_EndTimer();
  R_ProfEndNamedEvent(state);
  R_ShutdownLocalCmdBufState(state, &source->input);
}

/*
==============
RB_RunDrawList
==============
*/
void RB_RunDrawList(const GfxViewInfo *viewInfo, const GfxBackEndData *data, const R_RT_Group *rtGroup, GfxDrawListType drawListID)
{
  const char *DrawListTypeName; 
  GfxDrawCallOutput cmdBuf; 

  if ( R_RunDrawListCommandBuffer(data, drawListID) )
  {
    R_LockGfxImmediateContext();
    cmdBuf.empty = 0;
    R_InitContext(data, &cmdBuf.cmdBuf);
    R_GPU_BeginRunDrawListTimer(drawListID);
    DrawListTypeName = R_GetDrawListTypeName(drawListID);
    R_ProfBeginNamedEventImmediateContext(DrawListTypeName);
    R_DrawCamera(viewInfo, data, rtGroup, &cmdBuf, drawListID);
    R_ProfEndNamedEventImmediateContext();
    R_GPU_EndTimer();
    R_UnlockGfxImmediateContext();
  }
}

/*
==============
RB_StandardDrawCommands_DrawFlaresPostEmissive
==============
*/
void RB_StandardDrawCommands_DrawFlaresPostEmissive(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufSourceState *source; 
  unsigned int height; 
  const R_RT_Surface *Surface; 
  GfxImage *blackImage; 
  GfxCmdBufSourceState *v14; 
  GfxImage *v15; 
  GfxCmdBufInput *p_input; 
  GfxCmdBufSourceState *v17; 
  GfxImage *defaultFogLightmapImage; 
  GfxCmdBufInput *v19; 
  R_RT_Handle v21; 
  R_RT_DepthHandle v22; 
  R_RT_ColorHandle v23; 

  _RSI = viewInfo;
  _RDI = gfxContext;
  if ( r_flareDrawOrder->current.integer )
  {
    Sys_ProfBeginNamedEvent(0xFFFFD700, "exec cmds flares post emissive");
    source = _RDI->source;
    R_InitCmdBufSourceState(_RDI->source, &_RSI->input);
    R_InitLocalCmdBufState(_RDI->state, &source->input);
    __asm
    {
      vmovups ymm0, ymmword ptr [rsi+30C0h]
      vmovups ymmword ptr [rsp+0B8h+var_88.m_surfaceID], ymm0
    }
    height = R_RT_Handle::GetSurface(&v21)->m_image.m_base.height;
    Surface = R_RT_Handle::GetSurface(&v21);
    R_SetRenderTargetSize(source, Surface->m_image.m_base.width, height, GFX_USE_VIEWPORT_FOR_VIEW);
    R_BeginViewInternal(source, &_RSI->sceneDef, (const GfxViewParms *)_RSI, &_RSI->viewParmsSet.frames[1].viewParms);
    R_SetViewportStruct(source, &_RSI->sceneViewport);
    __asm
    {
      vmovups ymm0, ymmword ptr [rsi+31A0h]
      vmovups ymm1, ymmword ptr [rsi+30C0h]
      vmovups [rsp+0B8h+var_68], ymm0
      vmovups xmm0, xmmword ptr [rdi]
      vmovups xmmword ptr [rsp+0B8h+var_88.m_surfaceID], xmm0
      vmovups [rsp+0B8h+var_48], ymm1
    }
    R_SetRenderTargetsInternal_ColorDepth((GfxCmdBufContext *)&v21, &v23, &v22, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(2390)");
    blackImage = rgp.blackImage;
    if ( !source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
      __debugbreak();
    if ( source == (GfxCmdBufSourceState *)-1792i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
      __debugbreak();
    source->input.codeImages[36] = blackImage;
    v14 = _RDI->source;
    v15 = rgp.blackImage;
    if ( !_RDI->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
      __debugbreak();
    p_input = &v14->input;
    if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
      __debugbreak();
    p_input->codeImages[37] = v15;
    v17 = _RDI->source;
    defaultFogLightmapImage = rgp.defaultFogLightmapImage;
    if ( !_RDI->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
      __debugbreak();
    v19 = &v17->input;
    if ( !v19 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
      __debugbreak();
    __asm { vmovups xmm0, xmmword ptr [rdi] }
    v19->codeImages[38] = defaultFogLightmapImage;
    __asm { vmovups xmmword ptr [rsp+0B8h+var_88.m_surfaceID], xmm0 }
    RB_Flare_Draw((GfxCmdBufContext *)&v21, _RSI, data);
    R_ShutdownLocalCmdBufState(_RDI->state, &_RDI->source->input);
    Sys_ProfEndNamedEvent();
  }
}

/*
==============
RB_StandardDrawCommands_DrawSunPost
==============
*/
void RB_StandardDrawCommands_DrawSunPost(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufSourceState *source; 
  GfxImage *blackImage; 
  GfxCmdBufInput *p_input; 
  GfxCmdBufSourceState *v13; 
  GfxImage *v14; 
  GfxCmdBufInput *v15; 
  GfxCmdBufSourceState *v16; 
  GfxImage *defaultFogLightmapImage; 
  GfxCmdBufInput *v18; 
  GfxCmdBufContext v23; 
  R_RT_DepthHandle v24; 
  R_RT_ColorHandle v25; 

  _RBP = viewInfo;
  _RDI = gfxContext;
  Sys_ProfBeginNamedEvent(0xFFFFD700, "exec cmds sunpost");
  __asm
  {
    vmovups xmm0, xmmword ptr [rdi]
    vmovups [rsp+0A8h+var_78], xmm0
  }
  RB_StandardDrawCommands_PreDrawOcclusionQueriesAndSun(&v23, _RBP, "SunPost");
  __asm
  {
    vmovups ymm0, ymmword ptr [rbp+31A0h]
    vmovups ymm1, ymmword ptr [rbp+30C0h]
    vmovups [rsp+0A8h+var_68], ymm0
    vmovups xmm0, xmmword ptr [rdi]
    vmovups [rsp+0A8h+var_78], xmm0
    vmovups [rsp+0A8h+var_48], ymm1
  }
  R_SetRenderTargetsInternal_ColorDepth(&v23, &v25, &v24, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(2345)");
  source = _RDI->source;
  blackImage = rgp.blackImage;
  if ( !_RDI->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  p_input = &source->input;
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codeImages[36] = blackImage;
  v13 = _RDI->source;
  v14 = rgp.blackImage;
  if ( !_RDI->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  v15 = &v13->input;
  if ( !v15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  v15->codeImages[37] = v14;
  v16 = _RDI->source;
  defaultFogLightmapImage = rgp.defaultFogLightmapImage;
  if ( !_RDI->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  v18 = &v16->input;
  if ( !v18 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  v18->codeImages[38] = defaultFogLightmapImage;
  if ( RB_IsSunEnabled() )
  {
    R_GPU_BeginTimer(GPU_TIMER_SUN_POST);
    __asm
    {
      vmovups xmm0, xmmword ptr [rdi]
      vmovups [rsp+0A8h+var_78], xmm0
    }
    RB_DrawSunPostEffects(&v23, _RBP);
    R_GPU_EndTimer();
  }
  if ( !r_flareDrawOrder->current.integer )
  {
    __asm
    {
      vmovups xmm0, xmmword ptr [rdi]
      vmovups [rsp+0A8h+var_78], xmm0
    }
    RB_Flare_Draw(&v23, _RBP, data);
  }
  __asm
  {
    vmovups xmm0, xmmword ptr [rdi]
    vpextrq rbx, xmm0, 1
  }
  R_ProfEndNamedEvent(_RBX);
  R_ShutdownLocalCmdBufState(_RBX, &_RDI->source->input);
  Sys_ProfEndNamedEvent();
}

/*
==============
RB_StandardDrawCommands_PreDrawOcclusionQueriesAndSun
==============
*/
void RB_StandardDrawCommands_PreDrawOcclusionQueriesAndSun(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const char *pass)
{
  GfxCmdBufSourceState *source; 
  GfxCmdBufState *state; 
  const R_RT_Surface *Surface; 
  R_RT_Handle v10; 

  _RBP = viewInfo;
  Sys_ProfBeginNamedEvent(0xFFFFD700, "exec cmds occqueries sun");
  source = gfxContext->source;
  R_InitCmdBufSourceState(gfxContext->source, &_RBP->input);
  state = gfxContext->state;
  R_InitLocalCmdBufState(state, &source->input);
  R_ProfBeginNamedEvent(state, pass);
  __asm
  {
    vmovups ymm0, ymmword ptr [rbp+30C0h]
    vmovups ymmword ptr [rsp+48h+var_28.m_surfaceID], ymm0
  }
  LODWORD(state) = R_RT_Handle::GetSurface(&v10)->m_image.m_base.height;
  Surface = R_RT_Handle::GetSurface(&v10);
  R_SetRenderTargetSize(source, Surface->m_image.m_base.width, (unsigned int)state, GFX_USE_VIEWPORT_FOR_VIEW);
  R_BeginViewInternal(source, &_RBP->sceneDef, (const GfxViewParms *)_RBP, &_RBP->viewParmsSet.frames[1].viewParms);
  R_SetViewportStruct(source, &_RBP->sceneViewport);
  Sys_ProfEndNamedEvent();
}

/*
==============
RB_StandardDrawCommands_Shadows
==============
*/
void RB_StandardDrawCommands_Shadows(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufState *state; 
  GfxCmdBufState *v8; 
  unsigned int i; 
  GfxCmdBufState *v14; 
  unsigned int v15; 
  __int64 v23; 
  unsigned __int16 v24; 
  bool v28; 
  int v30; 
  GfxCmdBufState *v31; 
  R_RT_DepthHandle v33; 
  R_RT_Handle v34; 
  R_RT_Handle v35; 
  GfxCmdBufContext v36; 
  GfxCmdBufContext v37; 
  GfxCmdBufContext v38; 
  R_RT_DepthHandle v39; 
  R_RT_DepthHandle v40; 
  R_RT_ColorHandle v41; 
  R_RT_DepthHandle v42; 
  R_RT_ColorHandle v43; 
  void *retaddr; 
  const GfxBackEndData *timeoutUserData; 

  _RAX = &retaddr;
  timeoutUserData = data;
  _R13 = gfxContext;
  __asm { vmovaps xmmword ptr [rax-48h], xmm6 }
  _RBX = viewInfo;
  Profile2_UpdateEntry(49);
  if ( ((unsigned __int8)&dword_14FDE8094 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE8094) )
    __debugbreak();
  _InterlockedIncrement(&dword_14FDE8094);
  Sys_ProfBeginNamedEvent(0xFFFFA500, "wait shadow ready");
  Sys_ProcessWorkerCmdsWithTimeout((bool (__fastcall *)(void *))RB_IsShadowReady, &timeoutUserData);
  Sys_ProfEndNamedEvent();
  Profile2_UpdateEntry(49);
  if ( ((unsigned __int64)&dword_14FDE8094 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 44, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE8094) )
    __debugbreak();
  _InterlockedDecrement(&dword_14FDE8094);
  Sys_ProfBeginNamedEvent(0xFFFFD700, "exec cmds shadow");
  state = _R13->state;
  R_ProfBeginNamedEvent(state, "exec cmds shadow");
  Profile2_UpdateEntry(50);
  v8 = state;
  if ( ((unsigned __int8)&dword_14FDE8098 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 37, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE8098) )
    __debugbreak();
  _InterlockedIncrement(&dword_14FDE8098);
  if ( (*((_BYTE *)&_RBX->viewportFeatures + 44) & 4) != 0 )
  {
    for ( i = 0; i < timeoutUserData->sunShadow.opaqueCascadeCount; ++i )
    {
      _RAX = 32 * (i + 404i64);
      __asm
      {
        vmovups ymm0, ymmword ptr [rax+rbx]
        vmovups [rbp+0A0h+var_E0], ymm0
      }
      R_AddDepthStencilTransition(state, &v39, DEPTHSTENCIL_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    }
    __asm
    {
      vmovups ymm0, ymmword ptr [rbx+32E0h]
      vmovups [rbp+0A0h+var_C0], ymm0
    }
    R_AddDepthStencilTransition(state, &v40, DEPTHSTENCIL_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    v8 = state;
    if ( rg.useTransSunShadow )
    {
      __asm
      {
        vmovups ymm0, ymmword ptr [rbx+3300h]
        vmovups [rbp+0A0h+var_A0], ymm0
      }
      R_AddRenderTargetTransition(state, &v41, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    }
  }
  v14 = v8;
  if ( timeoutUserData->spotShadowUpdateCount )
  {
    v15 = 0;
    do
    {
      _RAX = 32 * (v15 + 382i64);
      __asm
      {
        vmovups ymm0, ymmword ptr [rax+rbx]
        vmovups [rbp+0A0h+var_80], ymm0
      }
      R_AddDepthStencilTransition(v8, &v42, DEPTHSTENCIL_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
      ++v15;
    }
    while ( v15 < timeoutUserData->spotShadowUpdateCount );
    v14 = state;
  }
  R_FlushResourceTransitions(v14);
  if ( (*((_BYTE *)&_RBX->viewportFeatures + 44) & 4) != 0 )
  {
    __asm
    {
      vmovups xmm0, xmmword ptr [r13+0]
      vmovups [rbp+0A0h+var_110], xmm0
    }
    RB_DrawSunshadow(&v36, timeoutUserData, _RBX);
  }
  if ( timeoutUserData->spotShadowUpdateCount )
  {
    __asm
    {
      vmovups xmm0, xmmword ptr [r13+0]
      vmovups [rbp+0A0h+var_100], xmm0
    }
    RB_SpotShadowMaps(&v37, timeoutUserData, _RBX);
  }
  if ( (*((_BYTE *)&_RBX->viewportFeatures + 44) & 4) != 0 && rg.useTransSunShadow )
  {
    __asm
    {
      vmovups ymm0, ymmword ptr [rbx+3300h]
      vmovups [rbp+0A0h+var_60], ymm0
    }
    R_AddRenderTargetTransition(v14, &v43, RENDERTARGET_TRANSITION_MODE_READ, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    R_FlushResourceTransitions(v14);
  }
  __asm { vmovups xmm6, xmmword ptr [r13+0] }
  R_LockGfxImmediateContext();
  _RBX = &_RBX->sceneRtInput.m_spotShadowRts[0].m_tracking;
  v23 = 8i64;
  do
  {
    v24 = (__int64)_RBX[-1].m_location & 0x7FFF;
    if ( !v24 )
      v24 = 0;
    v34.m_surfaceID = v24;
    __asm
    {
      vmovups xmm0, xmmword ptr [rbx]
      vmovsd  xmm1, qword ptr [rbx+10h]
      vmovups xmmword ptr [rsp+1A0h+var_150.m_tracking.m_allocCounter], xmm0
      vmovsd  [rsp+1A0h+var_150.m_tracking.m_location], xmm1
      vmovups ymm0, ymmword ptr [rsp+1A0h+var_150.m_surfaceID]
      vmovups [rsp+1A0h+var_170], ymm0
      vmovups ymmword ptr [rsp+1A0h+var_130.m_surfaceID], ymm0
    }
    if ( v24 )
    {
      R_RT_Handle::GetSurface(&v35);
      if ( (R_RT_Handle::GetSurface(&v35)->m_rtFlagsInternal & 0x10) != 0 || !CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 277, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsDepth())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsDepth()") )
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+1A0h+var_130.m_surfaceID]
          vmovups [rsp+1A0h+var_170], ymm0
        }
      }
      else
      {
        __asm
        {
          vmovups ymm0, ymmword ptr [rsp+1A0h+var_130.m_surfaceID]
          vmovups [rsp+1A0h+var_170], ymm0
        }
        __debugbreak();
      }
    }
    else if ( v34.m_tracking.m_allocCounter )
    {
      v28 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
      __asm { vmovups ymm0, [rsp+1A0h+var_170] }
      if ( v28 )
        __debugbreak();
    }
    LOWORD(_RBX[-1].m_location) = 0;
    __asm { vmovd   eax, xmm0 }
    v30 = (unsigned __int16)_EAX;
    _RBX->m_allocCounter = 0;
    _RBX->m_name = NULL;
    _RBX->m_location = NULL;
    __asm { vmovups ymmword ptr [rsp+1A0h+var_150.m_surfaceID], ymm0 }
    if ( (_WORD)_EAX )
    {
      R_RT_Handle::GetSurface(&v34);
    }
    else
    {
      if ( !v35.m_tracking.m_allocCounter )
        goto LABEL_43;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
    }
    __asm { vmovups ymm0, [rsp+1A0h+var_170] }
LABEL_43:
    if ( v30 )
    {
      __asm
      {
        vmovups [rsp+1A0h+var_170], ymm0
        vmovdqa [rbp+0A0h+var_F0], xmm6
      }
      R_RT_Destroy(&v38, &v33);
    }
    _RBX = (R_RT_Tracking_HandleInfo *)((char *)_RBX + 32);
    --v23;
  }
  while ( v23 );
  R_FlushImmediateContext();
  R_UnlockGfxImmediateContext();
  Profile2_UpdateEntry(50);
  if ( ((unsigned __int64)&dword_14FDE8098 & 3) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\qcommon\\threads_interlock_pc.h", 44, ASSERT_TYPE_ASSERT, "( ( IsAligned( addend, sizeof( volatile_int32 ) ) ) )", "( addend ) = %p", &dword_14FDE8098) )
    __debugbreak();
  v31 = gfxContext->state;
  _InterlockedDecrement(&dword_14FDE8098);
  R_ProfEndNamedEvent(v31);
  Sys_ProfEndNamedEvent();
  __asm { vmovaps xmm6, [rsp+1A0h+var_40] }
}

/*
==============
RB_StartDraw3DScene
==============
*/
void RB_StartDraw3DScene(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  unsigned int maxSpotShadowIndex; 
  __int64 voxelTreeZoneIndex; 
  GfxCmdBufState *state; 
  GfxCmdBufContext v10; 

  _R14 = gfxContext;
  if ( data != backEndData && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 3495, ASSERT_TYPE_ASSERT, "(data == backEndData)", (const char *)&queryFormat, "data == backEndData") )
    __debugbreak();
  __asm
  {
    vmovups xmm0, xmmword ptr [r14]
    vmovups xmmword ptr [rsp+48h+var_18.source], xmm0
  }
  if ( !RB_IsBackendCmdBufContext(&v10) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 3496, ASSERT_TYPE_ASSERT, "(RB_IsBackendCmdBufContext( gfxContext ))", (const char *)&queryFormat, "RB_IsBackendCmdBufContext( gfxContext )") )
    __debugbreak();
  _R14->source->input.data = data;
  Physics_SetDebugCameras(viewInfo);
  Profile_Begin(110);
  R_LockGfxImmediateContext();
  maxSpotShadowIndex = data->maxSpotShadowIndex;
  R_UpdateGfxWrappedBuffer(data->globalLightConstantBuffer, data->packedSceneLights, 96 * data->sceneLightCount);
  R_UpdateGfxWrappedBuffer(data->globalShadowConstantBuffer, data->packedShadowLights, 32 * (3 * maxSpotShadowIndex + 3));
  if ( rgp.world && rgp.world->voxelTreeCount )
  {
    voxelTreeZoneIndex = viewInfo->input.voxelTreeZoneIndex;
    R_UpdateGfxWrappedBuffer(&deviceGlobals.voxelInternalNodeDynamicLightList[voxelTreeZoneIndex][data->dynamicLightListBufferIndex], &rgp.world->voxelTree[voxelTreeZoneIndex].voxelInternalNodeDynamicLightListCPU[data->dynamicLightListBufferIndex * rgp.world->voxelTree[voxelTreeZoneIndex].voxelInternalNodeCount], 4 * rgp.world->voxelTree[voxelTreeZoneIndex].voxelInternalNodeCount);
  }
  R_UnlockGfxImmediateContext();
  Profile_EndInternal(NULL);
  RB_CG_Wind_UpdateWindGridBuffers();
  state = _R14->state;
  RB_UploadReactiveMotionData(state, data);
  RB_UpdateSceneConstantBuffer(data, viewInfo);
  RB_UpdatePersistentTables(viewInfo, data, PERSISTENT_TABLE_SCENE);
  RB_ModelIndirectionData_Upload(state, data);
  RB_GpuLightGrid_Update(state, viewInfo, data);
  RB_ST_UpdateFrameDataResources(state, data);
  R_LockGfxImmediateContext();
  if ( !data->bspIndirectArgs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 3537, ASSERT_TYPE_ASSERT, "(data->bspIndirectArgs != nullptr)", (const char *)&queryFormat, "data->bspIndirectArgs != nullptr") )
    __debugbreak();
  R_EndWrappedBufferDataWrite(data->bspIndirectArgsBuffer);
  R_UnlockGfxImmediateContext();
  RB_FogSpline_ProcessBlend(state, viewInfo, data);
  RB_UpdateFallbackProbeData(state, data, viewInfo);
  RB_UpdateEntityDataBuffer(viewInfo, data);
  RB_RTT_DeleteSlots(viewInfo->clientIndex, &data->rttContext);
}

/*
==============
RB_UpdatePersistentTables
==============
*/
void RB_UpdatePersistentTables(const GfxViewInfo *viewInfo, const GfxBackEndData *data, GfxPersistentDescriptorTables table)
{
  GfxDescriptorTable *v5; 
  int v6; 
  int v7; 
  __int64 v8; 
  const GfxImage **codePersistentImages; 
  GfxImage *blackImage; 
  const GfxTexture *v11; 
  unsigned int m_usedSize; 
  GfxDescriptorTable *v13; 
  const GfxWrappedBuffer **codePersistentBuffers; 
  __int64 v15; 
  GfxWrappedBuffer *p_dummyBuffer; 
  unsigned int v17; 
  __int64 v18; 
  __int64 v19; 
  __int64 v21; 

  v5 = &data->globalPersistentTextureTable[table];
  v21 = table;
  R_ResetGfxDescriptorTable(v5);
  v6 = 0;
  v7 = 0;
  v8 = 0i64;
  codePersistentImages = viewInfo->input.codePersistentImages;
  do
  {
    blackImage = (GfxImage *)*codePersistentImages;
    if ( !*codePersistentImages )
      blackImage = rgp.blackImage;
    v11 = R_Texture_Get(data, blackImage->textureId);
    if ( v7 >= v5->m_size )
    {
      LODWORD(v19) = v5->m_size;
      LODWORD(v18) = v7;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_setstate_d3d.h", 1212, ASSERT_TYPE_ASSERT, "(unsigned)( startApiSlot + apiSlotCount - 1 ) < (unsigned)( table->m_size )", "startApiSlot + apiSlotCount - 1 doesn't index table->m_size\n\t%i not in [0, %i)", v18, v19) )
        __debugbreak();
    }
    ++v7;
    v5->m_descriptors[v8] = v11->shaderView.view;
    m_usedSize = v7;
    if ( (signed int)v5->m_usedSize > v7 )
      m_usedSize = v5->m_usedSize;
    ++codePersistentImages;
    ++v8;
    v5->m_usedSize = m_usedSize;
  }
  while ( v7 < 42 );
  R_FlushDescriptorTable(v5);
  v13 = &data->globalPersistentBufferTable[v21];
  R_ResetGfxDescriptorTable(v13);
  codePersistentBuffers = viewInfo->input.codePersistentBuffers;
  v15 = 0i64;
  do
  {
    p_dummyBuffer = &gfxBuf.dummyBuffer;
    if ( *codePersistentBuffers )
      p_dummyBuffer = (GfxWrappedBuffer *)*codePersistentBuffers;
    if ( v6 >= v13->m_size )
    {
      LODWORD(v19) = v13->m_size;
      LODWORD(v18) = v6;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_setstate_d3d.h", 1222, ASSERT_TYPE_ASSERT, "(unsigned)( startApiSlot + apiSlotCount - 1 ) < (unsigned)( table->m_size )", "startApiSlot + apiSlotCount - 1 doesn't index table->m_size\n\t%i not in [0, %i)", v18, v19) )
        __debugbreak();
    }
    ++v6;
    v13->m_descriptors[v15] = p_dummyBuffer->view.view;
    v17 = v6;
    if ( (signed int)v13->m_usedSize > v6 )
      v17 = v13->m_usedSize;
    ++codePersistentBuffers;
    ++v15;
    v13->m_usedSize = v17;
  }
  while ( v6 < 41 );
  R_FlushDescriptorTable(v13);
}

/*
==============
RB_UploadPackedLightData
==============
*/
void RB_UploadPackedLightData(const GfxBackEndData *data, const GfxViewInfo *viewInfo)
{
  unsigned int maxSpotShadowIndex; 
  __int64 voxelTreeZoneIndex; 

  Profile_Begin(110);
  R_LockGfxImmediateContext();
  maxSpotShadowIndex = data->maxSpotShadowIndex;
  R_UpdateGfxWrappedBuffer(data->globalLightConstantBuffer, data->packedSceneLights, 96 * data->sceneLightCount);
  R_UpdateGfxWrappedBuffer(data->globalShadowConstantBuffer, data->packedShadowLights, 32 * (3 * maxSpotShadowIndex + 3));
  if ( rgp.world && rgp.world->voxelTreeCount )
  {
    voxelTreeZoneIndex = viewInfo->input.voxelTreeZoneIndex;
    R_UpdateGfxWrappedBuffer(&deviceGlobals.voxelInternalNodeDynamicLightList[voxelTreeZoneIndex][data->dynamicLightListBufferIndex], &rgp.world->voxelTree[voxelTreeZoneIndex].voxelInternalNodeDynamicLightListCPU[data->dynamicLightListBufferIndex * rgp.world->voxelTree[voxelTreeZoneIndex].voxelInternalNodeCount], 4 * rgp.world->voxelTree[voxelTreeZoneIndex].voxelInternalNodeCount);
  }
  R_UnlockGfxImmediateContext();
  Profile_EndInternal(NULL);
}

/*
==============
R_BlitDebugOverlay
==============
*/
void R_BlitDebugOverlay(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, R_RT_ColorHandle *outputRt, R_RT_ColorHandle *debugOverlayRt)
{
  R_RT_Image *p_m_image; 
  GfxCmdBufInput *p_input; 
  float fmt; 
  float v29; 
  float v30; 
  float v31; 
  float v32; 
  float v33; 
  float v34; 
  float v35; 
  GfxCmdBufContext v36; 
  GfxViewport v37; 

  __asm { vmovups xmm0, xmmword ptr [rdx+4B0h] }
  _RDX = &v37;
  _RSI = gfxContext;
  _RBX = gfxContext->source;
  __asm { vmovups xmmword ptr [r11-38h], xmm0 }
  R_SetViewportStruct(_RBX, &v37);
  R_Set2D(_RBX);
  __asm
  {
    vmovss  xmm0, dword ptr cs:?colorWhite@@3Tvec4_t@@B; vec4_t const colorWhite
    vmovss  dword ptr [rbx+0AB0h], xmm0
    vmovss  xmm1, dword ptr cs:?colorWhite@@3Tvec4_t@@B+4; vec4_t const colorWhite
    vmovss  dword ptr [rbx+0AB4h], xmm1
    vmovss  xmm0, dword ptr cs:?colorWhite@@3Tvec4_t@@B+8; vec4_t const colorWhite
    vmovss  dword ptr [rbx+0AB8h], xmm0
    vmovss  xmm1, dword ptr cs:?colorWhite@@3Tvec4_t@@B+0Ch; vec4_t const colorWhite
    vmovss  dword ptr [rbx+0ABCh], xmm1
  }
  ++_RBX->constVersions[59];
  __asm
  {
    vmovss  xmm0, dword ptr cs:?colorBlackBlank@@3Tvec4_t@@B; vec4_t const colorBlackBlank
    vmovss  dword ptr [rbx+0AC0h], xmm0
    vmovss  xmm1, dword ptr cs:?colorBlackBlank@@3Tvec4_t@@B+4; vec4_t const colorBlackBlank
    vmovss  dword ptr [rbx+0AC4h], xmm1
    vmovss  xmm0, dword ptr cs:?colorBlackBlank@@3Tvec4_t@@B+8; vec4_t const colorBlackBlank
    vmovss  dword ptr [rbx+0AC8h], xmm0
    vmovss  xmm1, dword ptr cs:?colorBlackBlank@@3Tvec4_t@@B+0Ch; vec4_t const colorBlackBlank
    vmovss  dword ptr [rbx+0ACCh], xmm1
  }
  ++_RBX->constVersions[60];
  _RBX->input.consts[61].v[0] = 0.0;
  *(_QWORD *)&_RBX->input.consts[61].xyz.y = 2139095039i64;
  _RBX->input.consts[61].v[3] = 0.0;
  ++_RBX->constVersions[61];
  p_m_image = &R_RT_Handle::GetSurface(debugOverlayRt)->m_image;
  p_input = &_RBX->input;
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  __asm
  {
    vmovups xmm0, xmmword ptr [rsi]
    vxorps  xmm1, xmm1, xmm1
  }
  p_input->codeImages[4] = &p_m_image->m_base;
  __asm
  {
    vxorps  xmm3, xmm3, xmm3
    vcvtsi2ss xmm3, xmm3, rax
    vxorps  xmm2, xmm2, xmm2
    vcvtsi2ss xmm2, xmm2, rax
    vmovups [rsp+0B8h+var_48], xmm0
    vmovss  xmm0, cs:__real@3f800000
    vmovss  [rsp+0B8h+var_60], xmm0
    vmovss  [rsp+0B8h+var_68], xmm0
    vmovss  [rsp+0B8h+var_70], xmm1
    vmovss  [rsp+0B8h+var_78], xmm1
    vmovss  [rsp+0B8h+var_80], xmm3
    vmovss  [rsp+0B8h+var_88], xmm2
    vmovss  dword ptr [rsp+0B8h+var_90], xmm1
    vmovss  dword ptr [rsp+0B8h+fmt], xmm1
  }
  RB_ViewportFilterDirectInternal(&v36, rgp.feedbackBlendBackbufferMaterial, 0xFFFFFFFF, &v37, fmt, v29, v30, v31, v32, v33, v34, v35, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1032)");
}

/*
==============
R_ClearColorTargetAsync
==============
*/
void R_ClearColorTargetAsync(ComputeCmdBufState *state, R_RT_ColorHandle *colorRt)
{
  const R_RT_Surface *Surface; 
  const GfxTexture *Resident; 
  unsigned int height; 
  unsigned int width; 
  const R_RT_Surface *v8; 
  const R_RT_Surface *v9; 
  const GfxTexture *v10; 
  const R_RT_Surface *v11; 
  const GfxTexture *v12; 

  R_ProfBeginNamedEvent(state, "R_ClearColorTargetAsync");
  R_GPU_BeginTimer(GPU_TIMER_CLEAR_SCREEN);
  if ( (R_RT_Handle::GetSurface(colorRt)->m_rtFlags & 1) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 1386, ASSERT_TYPE_ASSERT, "(!(colorRt.GetFlags() & R_RT_Flag_FastClear))", "%s\n\teliminate fast clear not implemented for R_ClearColorTargetAsync", "!(colorRt.GetFlags() & R_RT_Flag_FastClear)") )
    __debugbreak();
  if ( (R_RT_Handle::GetSurface(colorRt)->m_rtFlags & 0x1000) == 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 1388, ASSERT_TYPE_ASSERT, "(colorRt.GetFlags() & R_RT_Flag_RWView)", "%s\n\tRWView needed for R_ClearColorTargetAsync", "colorRt.GetFlags() & R_RT_Flag_RWView") )
    __debugbreak();
  Surface = R_RT_Handle::GetSurface(colorRt);
  Resident = R_Texture_GetResident(Surface->m_image.m_base.textureId);
  R_HW_AddResourceTransition(state, Resident, 0xFFFFFFFF, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  R_FlushResourceTransitions(state);
  height = R_RT_Handle::GetSurface(colorRt)->m_image.m_base.height;
  width = R_RT_Handle::GetSurface(colorRt)->m_image.m_base.width;
  v8 = R_RT_Handle::GetSurface(colorRt);
  if ( (v8->m_rtFlagsInternal & 0x10) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_manager.h", 324, ASSERT_TYPE_ASSERT, "(!( surface->m_rtFlagsInternal & R_RT_FlagInternal_Depth ))", (const char *)&queryFormat, "!( surface->m_rtFlagsInternal & R_RT_FlagInternal_Depth )") )
    __debugbreak();
  v9 = R_RT_Handle::GetSurface(colorRt);
  v10 = R_Texture_GetResident(v9->m_image.m_base.textureId);
  R_SetTextureRect(state, v10, &v8->m_color.m_clearColor, 0, 0, width, height);
  v11 = R_RT_Handle::GetSurface(colorRt);
  v12 = R_Texture_GetResident(v11->m_image.m_base.textureId);
  R_HW_AddResourceTransition(state, v12, 0xFFFFFFFF, D3D12_RESOURCE_STATE_UNORDERED_ACCESS, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
  R_FlushResourceTransitions(state);
  R_GPU_EndTimer();
  R_ProfEndNamedEvent(state);
}

/*
==============
R_ClearGlobalRTsAsRequired
==============
*/
void R_ClearGlobalRTsAsRequired(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo)
{
  GfxCmdBufSourceState *source; 
  int i; 
  unsigned __int16 m_surfaceID; 
  const char *LastKnownName; 
  unsigned __int16 v12; 
  GfxCmdBufState *state; 
  bool v21; 
  const char *m_location; 
  bool v36; 
  __int64 v37; 
  __int64 v38; 
  R_RT_Handle v39; 
  R_RT_Handle v40; 
  const GfxViewInfo *v41; 
  R_RT_Group v42; 
  R_RT_Group v43; 

  v41 = viewInfo;
  _R15 = gfxContext;
  Sys_ProfBeginNamedEvent(0xFF800000, "R_ClearGlobalRTsAsRequired");
  source = _R15->source;
  R_InitCmdBufSourceState(_R15->source, &viewInfo->input);
  R_InitLocalCmdBufState(_R15->state, &source->input);
  R_ProfBeginNamedEvent(_R15->state, "R_ClearGlobalRTsAsRequired");
  R_GPU_BeginTimer(GPU_TIMER_CLEAR_SCREEN);
  for ( i = 0; i != 10; ++i )
  {
    if ( (unsigned __int8)i >= 0xAu )
    {
      LODWORD(v38) = 10;
      LODWORD(v37) = (unsigned __int8)i;
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_globals.h", 65, ASSERT_TYPE_ASSERT, "(unsigned)( static_cast<uint>( rtId ) ) < (unsigned)( ( sizeof( *array_counter( g_R_RT_globals ) ) + 0 ) )", "static_cast<uint>( rtId ) doesn't index ARRAY_COUNT( g_R_RT_globals )\n\t%i not in [0, %i)", v37, v38) )
        __debugbreak();
    }
    _RDI = &g_R_RT_globals[(unsigned __int8)i];
    if ( R_RT_Handle::IsValid(_RDI) )
    {
      if ( (unsigned __int8)i >= 0xAu )
      {
        LODWORD(v38) = 10;
        LODWORD(v37) = (unsigned __int8)i;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_globals.h", 72, ASSERT_TYPE_ASSERT, "(unsigned)( static_cast<uint>( rtId ) ) < (unsigned)( ( sizeof( *array_counter( g_R_RT_globals ) ) + 0 ) )", "static_cast<uint>( rtId ) doesn't index ARRAY_COUNT( g_R_RT_globals )\n\t%i not in [0, %i)", v37, v38) )
          __debugbreak();
      }
      m_surfaceID = _RDI->m_surfaceID;
      if ( _RDI->m_surfaceID )
      {
        R_RT_Handle::GetSurface(_RDI);
      }
      else if ( _RDI->m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
      {
        __debugbreak();
      }
      if ( !m_surfaceID )
      {
        LastKnownName = R_RT_Handle::DebugGetLastKnownName(_RDI);
        LODWORD(v38) = (unsigned __int8)i;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_globals.h", 73, ASSERT_TYPE_ASSERT, "(g_R_RT_globals[rtId].IsValid())", "%s\n\trtId=%u(%s), last-known name=%s", "g_R_RT_globals[rtId].IsValid()", v38, g_R_RT_globalSlotNames[(unsigned __int8)i], LastKnownName) )
          __debugbreak();
      }
      __asm
      {
        vmovups ymm0, ymmword ptr [rdi]
        vmovd   eax, xmm0
        vmovups [rsp+270h+var_200], ymm0
      }
      v12 = _EAX & 0x7FFF;
      if ( !v12 )
        v12 = 0;
      __asm
      {
        vmovups xmm0, xmmword ptr [rsp+270h+var_200+8]
        vmovsd  xmm1, qword ptr [rbp+170h+var_200+18h]
        vmovups xmmword ptr [rsp+270h+var_220.m_tracking.m_allocCounter], xmm0
        vmovsd  [rsp+270h+var_220.m_tracking.m_location], xmm1
        vmovups xmm1, xmmword ptr [r15]
      }
      v39.m_surfaceID = v12;
      __asm
      {
        vmovups ymm0, ymmword ptr [rsp+270h+var_220.m_surfaceID]
        vmovups [rsp+270h+var_200], ymm0
        vmovups xmmword ptr [rsp+270h+var_220.m_surfaceID], xmm1
      }
      R_SetAndClearIfRequired((GfxCmdBufContext *)&v39, &v40);
    }
  }
  _R13 = v41;
  state = _R15->state;
  if ( v41->sceneRtInput.m_resolvedSceneRtNeedsClear )
  {
    __asm
    {
      vmovups ymm0, ymmword ptr [r13+33E0h]
      vmovd   eax, xmm0
      vmovups [rsp+270h+var_200], ymm0
      vmovups ymmword ptr [rsp+270h+var_220.m_surfaceID], ymm0
    }
    if ( (_WORD)_EAX )
    {
      R_RT_Handle::GetSurface(&v39);
      if ( (R_RT_Handle::GetSurface(&v39)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm { vmovups ymm0, ymmword ptr [rsp+270h+var_220.m_surfaceID] }
        __debugbreak();
      }
      else
      {
        __asm { vmovups ymm0, ymmword ptr [rsp+270h+var_220.m_surfaceID] }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v21 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        __asm { vmovups ymm0, [rsp+270h+var_200] }
        if ( v21 )
          __debugbreak();
      }
    }
    __asm { vmovups [rsp+270h+var_200], ymm0 }
    R_AddRenderTargetTransition(state, (R_RT_ColorHandle *)&v40, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    R_FlushResourceTransitions(state);
    __asm
    {
      vmovups ymm0, ymmword ptr [r13+33E0h]
      vmovups [rsp+270h+var_200], ymm0
    }
    R_RT_Group::AssignColor(&v42, (R_RT_ColorHandle *)&v40);
    _RDX = &v43;
    _RAX = &v42;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovups ymm1, ymmword ptr [rax+80h]
      vmovups ymmword ptr [rdx], ymm0
      vmovups ymm0, ymmword ptr [rax+20h]
      vmovups ymmword ptr [rdx+20h], ymm0
      vmovups ymm0, ymmword ptr [rax+40h]
      vmovups ymmword ptr [rdx+40h], ymm0
      vmovups ymm0, ymmword ptr [rax+60h]
      vmovups ymmword ptr [rdx+60h], ymm0
      vmovups xmm0, xmmword ptr [r15]
      vmovups ymmword ptr [rdx+80h], ymm1
      vmovups ymm1, ymmword ptr [rax+0A0h]
    }
    m_location = v42.m_vrsRt.m_tracking.m_location;
    __asm { vmovups ymmword ptr [rdx+0A0h], ymm1 }
    v43.m_vrsRt.m_tracking.m_location = m_location;
    __asm { vmovups xmmword ptr [rsp+270h+var_220.m_surfaceID], xmm0 }
    R_SetRenderTargetsInternal((GfxCmdBufContext *)&v39, &v43, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(495)");
    R_ClearScreen(state, 0xFu, 0);
    __asm
    {
      vmovups ymm0, ymmword ptr [r13+33E0h]
      vmovd   eax, xmm0
      vmovups [rsp+270h+var_200], ymm0
      vmovups ymmword ptr [rsp+270h+var_220.m_surfaceID], ymm0
    }
    if ( (_WORD)_EAX )
    {
      R_RT_Handle::GetSurface(&v39);
      if ( (R_RT_Handle::GetSurface(&v39)->m_rtFlagsInternal & 0x18) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 217, ASSERT_TYPE_ASSERT, "(!unionHandle.IsValid() || unionHandle.IsColor())", (const char *)&queryFormat, "!unionHandle.IsValid() || unionHandle.IsColor()") )
      {
        __asm { vmovups ymm0, ymmword ptr [rsp+270h+var_220.m_surfaceID] }
        __debugbreak();
      }
      else
      {
        __asm { vmovups ymm0, ymmword ptr [rsp+270h+var_220.m_surfaceID] }
      }
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX )
      {
        v36 = CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter");
        __asm { vmovups ymm0, [rsp+270h+var_200] }
        if ( v36 )
          __debugbreak();
      }
    }
    __asm { vmovups [rsp+270h+var_200], ymm0 }
    R_AddRenderTargetTransition(state, (R_RT_ColorHandle *)&v40, RENDERTARGET_TRANSITION_MODE_READ, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    R_FlushResourceTransitions(state);
    R_FlushImmediateContext();
  }
  R_ResetRenderTargets(state);
  R_FlushImmediateContext();
  R_GPU_EndTimer();
  R_ProfEndNamedEvent(state);
  R_ShutdownLocalCmdBufState(state, &_R15->source->input);
  Sys_ProfEndNamedEvent();
}

/*
==============
R_ClearRenderTarget
==============
*/
void R_ClearRenderTarget(GfxCmdBufContext *gfxContext, const R_RT_Group *rtGroup, unsigned __int8 whichToClear, unsigned __int8 stencil)
{
  GfxCmdBufSourceState *source; 
  GfxCmdBufState *state; 
  unsigned int height; 
  const R_RT_Surface *Surface; 
  R_RT_Handle v15; 
  R_RT_Handle result; 

  source = gfxContext->source;
  state = gfxContext->state;
  _RSI = gfxContext;
  R_InitLocalCmdBufState(state, &gfxContext->source->input);
  R_ProfBeginNamedEvent(state, "R_ClearRenderTarget");
  _RAX = R_RT_Group::GetValidRt((R_RT_Group *)rtGroup, &result);
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovups ymmword ptr [rsp+88h+var_68.m_surfaceID], ymm0
  }
  height = R_RT_Handle::GetSurface(&v15)->m_image.m_base.height;
  Surface = R_RT_Handle::GetSurface(&v15);
  R_SetRenderTargetSize(source, Surface->m_image.m_base.width, height, GFX_USE_VIEWPORT_FOR_VIEW);
  __asm
  {
    vmovups xmm0, xmmword ptr [rsi]
    vmovups xmmword ptr [rsp+88h+var_68.m_surfaceID], xmm0
  }
  R_SetRenderTargetsInternal((GfxCmdBufContext *)&v15, rtGroup, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1368)");
  R_GPU_BeginTimer(GPU_TIMER_CLEAR_SCREEN);
  R_ClearScreen(state, whichToClear, stencil);
  R_GPU_EndTimer();
  R_ProfEndNamedEvent(state);
  R_ShutdownLocalCmdBufState(state, &source->input);
}

/*
==============
R_DebugPrimitivesValid
==============
*/
bool R_DebugPrimitivesValid()
{
  const dvar_t *v0; 

  v0 = DCONST_DVARINT_developer;
  if ( !DCONST_DVARINT_developer && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "developer") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v0);
  return v0->current.integer && (Physics_RenderDebugEnabled() || CG_Edge_DrawDebugEnabled() || RB_Stream_TreeDebugDrawEnabled() || RB_Stream_XModelTreeDebugDrawEnabled() || RB_NeedDrawDebug());
}

/*
==============
R_Draw2D_BackupScopeReticle
==============
*/
void R_Draw2D_BackupScopeReticle(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, const GfxImage *sceneSrc, const GfxImage *scopeBuffer)
{
  GfxCmdBufContext v6; 

  __asm
  {
    vmovups xmm0, xmmword ptr [rcx]
    vmovups xmmword ptr [rsp+48h+var_18.source], xmm0
  }
  R_Draw2D_CopyScopeReticle(&v6, viewInfo, data, sceneSrc, scopeBuffer);
}

/*
==============
R_Draw2D_BeforePostFX
==============
*/
void R_Draw2D_BeforePostFX(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, R_RT_ColorHandle *sceneRt, R_RT_DepthHandle *depthRt, const GfxImage *universalClut)
{
  const void *v14; 
  GfxCmdBufContext v15; 
  GfxCmdBufContext v16; 
  R_RT_DepthHandle v17; 
  R_RT_ColorHandle v18; 
  GfxDevice *device; 

  __asm { vmovups ymm1, ymmword ptr [r9] }
  _RAX = depthRt;
  _RSI = gfxContext;
  __asm
  {
    vmovups [rsp+98h+var_28], ymm1
    vmovups ymm0, ymmword ptr [rax]
    vmovups [rsp+98h+var_48], ymm0
    vmovups xmm0, xmmword ptr [rcx]
    vmovups [rsp+98h+var_68], xmm0
  }
  RB_InitClient2DReceivePPFXContext(&v15, viewInfo, data, &v18, &v17, universalClut);
  if ( data->async2D.renderReceivePPFXPending )
  {
    depthRt = (R_RT_DepthHandle *)data;
    Sys_ProfBeginNamedEvent(0xFF008008, "wait LUI render");
    R_UnlockGfxImmediateContext();
    Sys_ProcessWorkerCmdsWithTimeout((bool (__fastcall *)(void *))RB_Async2D_ReceivePPFXFinished, &depthRt);
    R_LockGfxImmediateContext();
    Sys_ProfEndNamedEvent();
  }
  if ( data->async2D.receivePPFXCmdBuf.device )
  {
    if ( !data->async2D.renderFailed )
    {
      R_FlushImmediateContext();
      device = data->async2D.receivePPFXCmdBuf.device;
      ((void (__fastcall *)(ID3D12CommandQueue *, __int64, GfxDevice **))g_dx.immediateCommandQueue.commandQueue->m_pFunction[3].AddRef)(g_dx.immediateCommandQueue.commandQueue, 1i64, &device);
      data->async2D.receivePPFXCmdBuf.device = NULL;
      return;
    }
    data->async2D.receivePPFXCmdBuf.device = NULL;
  }
  __asm { vmovups xmm0, xmmword ptr [rsi] }
  v14 = viewInfo->displayCmds[3];
  __asm { vmovups [rsp+98h+var_58], xmm0 }
  RB_ExecuteRenderCommandsLoop(&v16, v14, NULL);
}

/*
==============
R_Draw2D_BeforePostFX_IsValid
==============
*/
bool R_Draw2D_BeforePostFX_IsValid(const GfxViewInfo *viewInfo)
{
  return viewInfo->displayCmds[3] != NULL;
}

/*
==============
R_Draw2D_CopyScopeReticle
==============
*/
void R_Draw2D_CopyScopeReticle(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, const GfxImage *sceneSrc, const GfxImage *scopeBuffer)
{
  GfxCmdBufSourceState *source; 
  GfxCmdBufInput *p_input; 
  GfxCmdBufSourceState *v11; 
  GfxCmdBufInput *v12; 
  GfxCmdBufSourceState *v13; 
  const void *v15; 
  GfxCmdBufContext v16[2]; 

  _RBX = gfxContext;
  if ( viewInfo->displayCmds[4] )
  {
    __asm
    {
      vmovups xmm0, xmmword ptr [rcx]
      vmovups [rsp+58h+var_28], xmm0
    }
    RB_InitClient2DContext_CopyScopeReticle(v16, viewInfo, data);
    source = _RBX->source;
    if ( !_RBX->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
      __debugbreak();
    p_input = &source->input;
    if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
      __debugbreak();
    p_input->codeImages[80] = scopeBuffer;
    v11 = _RBX->source;
    if ( !_RBX->source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
      __debugbreak();
    v12 = &v11->input;
    if ( !v12 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
      __debugbreak();
    v12->codeImages[24] = sceneSrc;
    v13 = _RBX->source;
    R_ForceSet2D(_RBX->source, &viewInfo->displayViewport);
    __asm { vmovups xmm0, xmmword ptr [rbx] }
    v15 = viewInfo->displayCmds[4];
    __asm { vmovups [rsp+58h+var_28], xmm0 }
    RB_ExecuteRenderCommandsLoop(v16, v15, rgp.reticleCopyScreen);
    if ( !v13 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
      __debugbreak();
    if ( v13 == (GfxCmdBufSourceState *)-1792i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
      __debugbreak();
    v13->input.codeImages[24] = NULL;
  }
}

/*
==============
R_Draw2D_Hud
==============
*/
void R_Draw2D_Hud(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, R_RT_ColorHandle *colorRt, R_RT_Handle *packedStencil, const GfxImage *universalClut, const GfxImage *resolvedScene, const GfxWrappedBuffer *exposureBuffer)
{
  const void *v18; 
  _WORD *v19; 
  bool v20; 
  const char *LastKnownName; 
  GfxCmdBufSourceState *source; 
  const void *v27; 
  const void *v29; 
  __int64 v30; 
  GfxCmdBufContext v31; 
  GfxCmdBufContext v32; 
  GfxCmdBufContext v33; 
  GfxCmdBufContext v34; 
  GfxCmdBufContext v35; 
  R_RT_Handle v36; 
  R_RT_ColorHandle v37; 
  R_RT_Handle v38; 
  R_RT_ColorHandle v39; 
  void *retaddr; 
  const GfxBackEndData *timeoutUserData; 

  _RAX = &retaddr;
  _R12 = colorRt;
  _R15 = gfxContext;
  if ( viewInfo->displayCmds[0] )
  {
    __asm { vmovups ymm1, ymmword ptr [r9] }
    _R13 = packedStencil;
    __asm
    {
      vmovups ymmword ptr [rax-88h], ymm1
      vmovups ymm0, ymmword ptr [r13+0]
      vmovups ymmword ptr [rax-0A8h], ymm0
      vmovups xmm0, xmmword ptr [rcx]
      vmovups [rsp+148h+var_F8], xmm0
    }
    RB_InitClient2DContext(&v31, viewInfo, data, &v37, &v36, universalClut, resolvedScene, exposureBuffer);
    __asm { vmovups xmm0, xmmword ptr [r15] }
    v18 = viewInfo->displayCmds[0];
    __asm { vmovups [rsp+148h+var_E8], xmm0 }
    RB_ExecuteRenderCommandsLoop(&v32, v18, NULL);
    v19 = viewInfo->displayCmds[2];
    v20 = v19 && *v19;
    if ( viewInfo->displayCmds[1] )
    {
      if ( g_R_RT_globals[0].m_surfaceID )
      {
        R_RT_Handle::GetSurface(g_R_RT_globals);
      }
      else
      {
        if ( g_R_RT_globals[0].m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
          __debugbreak();
        LastKnownName = R_RT_Handle::DebugGetLastKnownName(g_R_RT_globals);
        LODWORD(v30) = 0;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_globals.h", 73, ASSERT_TYPE_ASSERT, "(g_R_RT_globals[rtId].IsValid())", "%s\n\trtId=%u(%s), last-known name=%s", "g_R_RT_globals[rtId].IsValid()", v30, g_R_RT_globalSlotNames[0], LastKnownName) )
          __debugbreak();
      }
      if ( ((g_R_RT_globals[0].m_surfaceID ^ (unsigned __int16)*(_DWORD *)&data->displayRtDebug.m_surfaceID) & 0xFFFF7FFF) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 2193, ASSERT_TYPE_ASSERT, "(data->displayRtDebug == R_RT_GetGlobal( R_RENDERTARGET_DISPLAY_BUFFER ))", (const char *)&queryFormat, "data->displayRtDebug == R_RT_GetGlobal( R_RENDERTARGET_DISPLAY_BUFFER )") )
        __debugbreak();
      if ( data->async2D.renderPending )
      {
        timeoutUserData = data;
        Sys_ProfBeginNamedEvent(0xFF008008, "wait LUI render");
        R_UnlockGfxImmediateContext();
        Sys_ProcessWorkerCmdsWithTimeout((bool (__fastcall *)(void *))RB_Async2D_Finished, &timeoutUserData);
        R_LockGfxImmediateContext();
        Sys_ProfEndNamedEvent();
      }
      if ( RB_Async2D_ExecCmdBuf(&data->async2D.cmdBuf, data->async2D.renderFailed) )
      {
        if ( !v20 )
          return;
        source = _R15->source;
        R_ShutdownLocalCmdBufState(_R15->state, &_R15->source->input);
        R_InitLocalCmdBufState(_R15->state, &source->input);
        __asm
        {
          vmovups ymm0, ymmword ptr [r13+0]
          vmovups ymm1, ymmword ptr [r12]
          vmovups [rsp+148h+var_68], ymm0
          vmovups xmm0, xmmword ptr [r15]
          vmovups [rsp+148h+var_48], ymm1
          vmovups [rsp+148h+var_D8], xmm0
        }
        RB_InitClient2DContext(&v33, viewInfo, data, &v39, &v38, universalClut, resolvedScene, exposureBuffer);
      }
      else
      {
        __asm { vmovups xmm0, xmmword ptr [r15] }
        v27 = viewInfo->displayCmds[1];
        __asm { vmovups [rsp+148h+var_C8], xmm0 }
        RB_ExecuteRenderCommandsLoop(&v34, v27, NULL);
      }
    }
    if ( v20 )
    {
      __asm { vmovups xmm0, xmmword ptr [r15] }
      v29 = viewInfo->displayCmds[2];
      __asm { vmovups [rsp+148h+var_B8], xmm0 }
      RB_ExecuteRenderCommandsLoop(&v35, v29, NULL);
    }
  }
}

/*
==============
R_Draw2D_RTT
==============
*/
void R_Draw2D_RTT(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  unsigned int v7; 
  const void **v8; 
  __int64 v9; 
  const char *Name; 
  const void *v12; 
  GfxCmdBufContext v13; 
  R_RT_ColorHandle result; 

  _R15 = gfxContext;
  if ( !data && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 3826, ASSERT_TYPE_ASSERT, "(data)", (const char *)&queryFormat, "data") )
    __debugbreak();
  __asm
  {
    vmovups xmm0, xmmword ptr [r15]
    vmovups [rsp+98h+var_68], xmm0
  }
  RB_InitClient2D_RTT(&v13, viewInfo, data);
  v7 = 1;
  v8 = &viewInfo->displayCmds[8];
  v9 = 8i64;
  do
  {
    if ( *v8 )
    {
      RB_RTT_GetSurface(&result, viewInfo->clientIndex, &data->rttContext, v7);
      if ( (result.m_surfaceID & 0x7FFF) != 0 )
      {
        __asm { vmovups xmm0, xmmword ptr [r15] }
        v12 = *v8;
        __asm { vmovups [rsp+98h+var_68], xmm0 }
        RB_ExecuteRenderCommandsLoop(&v13, v12, NULL);
      }
      else
      {
        Name = R_RTT_GetName(v7);
        Com_Printf(8, "ERROR: RTT %s is not allocated, skipping update\n", Name);
      }
    }
    ++v8;
    ++v7;
    --v9;
  }
  while ( v9 );
}

/*
==============
R_Draw2D_RTT_Overlay
==============
*/
void R_Draw2D_RTT_Overlay(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, double a4)
{
  unsigned int unsignedInt; 
  GfxCmdBufContext v9; 

  __asm { vmovups xmm0, xmmword ptr [rcx] }
  _RDI = gfxContext;
  __asm { vmovups xmmword ptr [rsp+38h+var_18.source], xmm0 }
  unsignedInt = r_rtt_showOverlay->current.unsignedInt;
  RB_InitClient2D_RTT(&v9, viewInfo, data);
  if ( unsignedInt <= 8 )
  {
    __asm
    {
      vmovups xmm0, xmmword ptr [rdi]
      vmovups xmmword ptr [rsp+38h+var_18.source], xmm0
    }
    RB_DrawRttOverlay(&v9, viewInfo, unsignedInt, a4);
  }
}

/*
==============
R_Draw2D_ReceivePostFXComposite
==============
*/
void R_Draw2D_ReceivePostFXComposite(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, R_RT_ColorHandle *sceneRt, const GfxImage *packedStencil, const GfxImage *scopeBuffer)
{
  const void *v11; 
  GfxCmdBufContext v12; 
  R_RT_ColorHandle v13; 

  _RDI = gfxContext;
  if ( viewInfo->displayCmds[5] )
  {
    __asm
    {
      vmovups ymm0, ymmword ptr [r9]
      vmovups xmm1, xmmword ptr [rcx]
      vmovups ymmword ptr [rsp+68h+var_28.baseclass_0.m_surfaceID], ymm0
      vmovups [rsp+68h+var_38], xmm1
    }
    RB_InitClient2DContext_ReceivePostFXLite(&v12, viewInfo, data, &v13, packedStencil, scopeBuffer);
    __asm { vmovups xmm0, xmmword ptr [rdi] }
    v11 = viewInfo->displayCmds[5];
    __asm { vmovups [rsp+68h+var_38], xmm0 }
    RB_ExecuteRenderCommandsLoop(&v12, v11, NULL);
  }
}

/*
==============
R_Draw2D_ReceivePostFXComposite_IsValid
==============
*/
bool R_Draw2D_ReceivePostFXComposite_IsValid(const GfxViewInfo *viewInfo)
{
  return viewInfo->displayCmds[5] != NULL;
}

/*
==============
R_Draw2D_ReceivePostFXLite
==============
*/
void R_Draw2D_ReceivePostFXLite(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, R_RT_ColorHandle *sceneRt, const GfxImage *packedStencil, const GfxImage *scopeBuffer)
{
  const void *v11; 
  GfxCmdBufContext v12; 
  R_RT_ColorHandle v13; 

  _RDI = gfxContext;
  if ( viewInfo->displayCmds[4] )
  {
    __asm
    {
      vmovups ymm0, ymmword ptr [r9]
      vmovups xmm1, xmmword ptr [rcx]
      vmovups ymmword ptr [rsp+68h+var_28.baseclass_0.m_surfaceID], ymm0
      vmovups [rsp+68h+var_38], xmm1
    }
    RB_InitClient2DContext_ReceivePostFXLite(&v12, viewInfo, data, &v13, packedStencil, scopeBuffer);
    __asm { vmovups xmm0, xmmword ptr [rdi] }
    v11 = viewInfo->displayCmds[4];
    __asm { vmovups [rsp+68h+var_38], xmm0 }
    RB_ExecuteRenderCommandsLoop(&v12, v11, NULL);
  }
}

/*
==============
R_Draw2D_ReceivePostFXLite_IsValid
==============
*/
bool R_Draw2D_ReceivePostFXLite_IsValid(const GfxViewInfo *viewInfo)
{
  return viewInfo->displayCmds[4] != NULL;
}

/*
==============
R_Draw2D_RestoreScopeReticle
==============
*/
void R_Draw2D_RestoreScopeReticle(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, const GfxImage *sceneBackup, const GfxImage *scopeBuffer)
{
  GfxCmdBufContext v6; 

  __asm
  {
    vmovups xmm0, xmmword ptr [rcx]
    vmovups xmmword ptr [rsp+48h+var_18.source], xmm0
  }
  R_Draw2D_CopyScopeReticle(&v6, viewInfo, data, sceneBackup, scopeBuffer);
}

/*
==============
R_DrawDebug3D_Enabled
==============
*/
bool R_DrawDebug3D_Enabled(const GfxViewInfo *viewInfo)
{
  bool result; 

  if ( R_LGV_DrawProbes_Enabled(viewInfo) )
    return 1;
  if ( R_ReflectionProbe_DrawSH_Enabled(viewInfo) )
    return 1;
  if ( R_FL_RenderDebugProxies_Enabled(viewInfo) )
    return 1;
  if ( r_umbraShowOverlayNDC->current.integer >= 1 )
    return 1;
  result = R_GpuLightGrid_DebugDrawEnabled();
  if ( result )
    return 1;
  return result;
}

/*
==============
R_DrawDebugPrimitives
==============
*/
void R_DrawDebugPrimitives(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo)
{
  GfxCmdBufSourceState *source; 
  GfxCmdBufContext v6; 

  source = gfxContext->source;
  _RBX = gfxContext;
  R_BeginViewInternal(gfxContext->source, &viewInfo->sceneDef, &viewInfo->viewParmsSet.frames[2].viewParms, NULL);
  R_SetViewportStruct(source, &viewInfo->sceneViewport);
  R_Set3D(source);
  __asm
  {
    vmovups xmm0, xmmword ptr [rbx]
    vmovups xmmword ptr [rsp+38h+var_18.source], xmm0
  }
  RB_DrawDebug(&v6, &source->viewParms, viewInfo);
}

/*
==============
R_DrawWorkerCmdsFinished
==============
*/
bool R_DrawWorkerCmdsFinished(void *data)
{
  return *(_DWORD *)data == 0;
}

/*
==============
R_FontCache_DebugDisplay
==============
*/

void R_FontCache_DebugDisplay(void)
{
  FontCache_RenderDebug();
}

/*
==============
R_HalfRes_DownsampleDepth
==============
*/

void __fastcall R_HalfRes_DownsampleDepth(GfxCmdBufContext *context, R_RT_Handle *fullResDepth, const GfxViewport *viewport, double _XMM3_8)
{
  GfxCmdBufSourceState *source; 
  R_RT_Image *p_m_image; 
  float fmt; 
  __int64 v18; 
  float v19; 
  float v20; 
  float v21; 
  float v22; 
  float v23; 
  float v24; 
  float v25; 
  GfxCmdBufContext v26; 

  source = context->source;
  _R14 = context;
  p_m_image = &R_RT_Handle::GetSurface(fullResDepth)->m_image;
  if ( !source && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1577, ASSERT_TYPE_ASSERT, "(source)", (const char *)&queryFormat, "source") )
    __debugbreak();
  if ( source == (GfxCmdBufSourceState *)-1792i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  source->input.codeImages[0] = &p_m_image->m_base;
  R_Set2D(source);
  if ( source->viewMode != VIEW_MODE_2D )
  {
    LODWORD(v18) = source->viewMode;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 2990, ASSERT_TYPE_ASSERT, "( ( source->viewMode == VIEW_MODE_2D ) )", "( source->viewMode ) = %i", v18) )
      __debugbreak();
  }
  __asm
  {
    vmovups xmm0, xmmword ptr [r14]
    vxorps  xmm1, xmm1, xmm1
    vxorps  xmm3, xmm3, xmm3
    vcvtsi2ss xmm3, xmm3, rax
    vxorps  xmm2, xmm2, xmm2
    vcvtsi2ss xmm2, xmm2, rax
    vmovups [rsp+98h+var_28], xmm0
    vmovss  xmm0, cs:__real@3f800000
    vmovss  [rsp+98h+var_40], xmm0
    vmovss  [rsp+98h+var_48], xmm0
    vmovss  [rsp+98h+var_50], xmm1
    vmovss  [rsp+98h+var_58], xmm1
    vmovss  [rsp+98h+var_60], xmm3
    vmovss  [rsp+98h+var_68], xmm2
    vmovss  dword ptr [rsp+98h+var_70], xmm1
    vmovss  dword ptr [rsp+98h+fmt], xmm1
  }
  RB_ViewportFilterDirectInternal(&v26, rgp.floatZWriteDepthDownsampleMaterial, 0xFFFFFFFF, viewport, fmt, v19, v20, v21, v22, v23, v24, v25, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(2992)");
}

/*
==============
R_HalfRes_Upsample
==============
*/
void R_HalfRes_Upsample(GfxCmdBufContext *context, R_RT_Handle *halfResColor, R_RT_Handle *halfResAlpha, R_RT_Handle *halfResDepth, R_RT_Handle *fullResDepth, const GfxViewport *viewport)
{
  GfxCmdBufSourceState *source; 
  R_RT_Image *p_m_image; 
  GfxCmdBufInput *p_input; 
  R_RT_Image *v16; 
  R_RT_Image *v17; 
  R_RT_Image *v18; 
  float fmt; 
  float v27; 
  float v28; 
  float v29; 
  float v30; 
  float v31; 
  float v32; 
  float v33; 
  GfxCmdBufContext v34; 

  source = context->source;
  _R14 = context;
  R_Set2D(context->source);
  if ( source->viewMode != VIEW_MODE_2D && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 3002, ASSERT_TYPE_ASSERT, "( ( source->viewMode == VIEW_MODE_2D ) )", "( source->viewMode ) = %i", source->viewMode) )
    __debugbreak();
  p_m_image = &R_RT_Handle::GetSurface(halfResColor)->m_image;
  p_input = &source->input;
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codeImages[22] = &p_m_image->m_base;
  v16 = &R_RT_Handle::GetSurface(halfResAlpha)->m_image;
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codeImages[23] = &v16->m_base;
  v17 = &R_RT_Handle::GetSurface(halfResDepth)->m_image;
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  p_input->codeImages[24] = &v17->m_base;
  v18 = &R_RT_Handle::GetSurface(fullResDepth)->m_image;
  if ( !p_input && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
    __debugbreak();
  __asm
  {
    vmovups xmm0, xmmword ptr [r14]
    vxorps  xmm1, xmm1, xmm1
  }
  p_input->codeImages[25] = &v18->m_base;
  __asm
  {
    vxorps  xmm3, xmm3, xmm3
    vcvtsi2ss xmm3, xmm3, rax
    vxorps  xmm2, xmm2, xmm2
    vcvtsi2ss xmm2, xmm2, rax
    vmovups [rsp+98h+var_28], xmm0
    vmovss  xmm0, cs:__real@3f800000
    vmovss  [rsp+98h+var_40], xmm0
    vmovss  [rsp+98h+var_48], xmm0
    vmovss  [rsp+98h+var_50], xmm1
    vmovss  [rsp+98h+var_58], xmm1
    vmovss  [rsp+98h+var_60], xmm3
    vmovss  [rsp+98h+var_68], xmm2
    vmovss  dword ptr [rsp+98h+var_70], xmm1
    vmovss  dword ptr [rsp+98h+fmt], xmm1
  }
  RB_ViewportFilterDirectInternal(&v34, rgp.bilateralUpsampleMaterial, 0xFFFFFFFF, viewport, fmt, v27, v28, v29, v30, v31, v32, v33, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(3009)");
}

/*
==============
R_InitDrawCallOutput
==============
*/
void R_InitDrawCallOutput(const GfxBackEndData *data, GfxDrawCallOutput *drawOutput)
{
  drawOutput->empty = 0;
  R_InitContext(data, &drawOutput->cmdBuf);
}

/*
==============
R_PostLitResolve0_Active
==============
*/
bool R_PostLitResolve0_Active(const GfxViewInfo *viewInfo)
{
  return viewInfo->matRenderFeatures & 1;
}

/*
==============
R_PostLitResolve1_Active
==============
*/
bool R_PostLitResolve1_Active(const GfxViewInfo *viewInfo)
{
  return (viewInfo->matRenderFeatures & 2) != 0;
}

/*
==============
R_ProfBeginDrawListImmediate
==============
*/
void R_ProfBeginDrawListImmediate(const GfxDrawListType drawListType)
{
  const char *DrawListTypeName; 

  DrawListTypeName = R_GetDrawListTypeName(drawListType);
  R_ProfBeginNamedEventImmediateContext(DrawListTypeName);
}

/*
==============
R_ProfEndDrawListImmediate
==============
*/

void R_ProfEndDrawListImmediate(void)
{
  R_ProfEndNamedEventImmediateContext();
}

/*
==============
R_RunDrawListCommandBuffer
==============
*/
bool R_RunDrawListCommandBuffer(const GfxBackEndData *data, const GfxDrawListType drawListType)
{
  __int64 v4; 
  const char *DrawListTypeName; 
  const char *v6; 
  const dvar_t *v7; 
  char *v8; 
  __int64 v9; 
  unsigned __int64 v10; 
  unsigned __int64 integer; 
  __int64 v12; 
  GfxDrawCallOutput *v14; 
  const char *v15; 
  ID3D12CommandList *cmdLists; 

  v4 = drawListType;
  if ( !data->cmdBufValid[drawListType] )
    return 1;
  DrawListTypeName = R_GetDrawListTypeName(drawListType);
  v6 = j_va("run cmdbuf: %s", DrawListTypeName);
  Sys_ProfBeginNamedEvent(0xFFDAA520, v6);
  v7 = r_cmdbuf_handoff;
  ++backEnd.cmdbufHandoffStats[backEndData->frameCount & 1][0];
  if ( !v7->current.enabled )
  {
    R_WaitDrawWorkerCmdsOfType(data, drawListType);
    goto LABEL_15;
  }
  v8 = (char *)data + 9136 * v4;
  if ( !*((_DWORD *)v8 + 10258) )
    goto LABEL_15;
  v9 = backEndData->frameCount & 1;
  ++backEnd.cmdbufHandoffStats[v9][1];
  if ( Sys_InterlockedCompareExchange((volatile int *)v8 + 10259, 0, 1) )
  {
    Sys_ProfEndNamedEvent();
    return 1;
  }
  R_SetHandoffDrawListIter(&data->drawListIter[v4]);
  Sys_ProfBeginNamedEvent(0xFFFFA500, "wait");
  v10 = Sys_Microseconds();
  if ( *((_DWORD *)v8 + 10258) )
  {
    integer = r_cmdbuf_wait_us->current.integer;
    while ( Sys_Microseconds() - v10 < integer )
    {
      if ( !*((_DWORD *)v8 + 10258) )
        goto LABEL_11;
    }
    v12 = backEndData->frameCount & 1;
    ++backEnd.cmdbufHandoffStats[v12][2];
    Sys_ProfBeginNamedEvent(0xFFFF0000, "slow wait");
    R_WaitDrawWorkerCmdsOfType(data, drawListType);
    Sys_ProfEndNamedEvent();
  }
LABEL_11:
  Sys_ProfEndNamedEvent();
  R_SetHandoffDrawListIter(NULL);
LABEL_15:
  v14 = &data->drawOutput[v4];
  if ( data->drawOutput[v4].empty )
  {
    v14->cmdBuf.device = NULL;
  }
  else if ( v14->cmdBuf.device )
  {
    R_LockGfxImmediateContext();
    cmdLists = v14->cmdBuf.device;
    R_ProfBeginNamedEventImmediateContext(DrawListTypeName);
    R_GPU_BeginRunDrawListTimer(drawListType);
    R_FlushImmediateContext();
    v15 = j_va("ExecuteCommandList %s", "(partial)");
    Sys_ProfBeginNamedEvent(0xFFFFD700, v15);
    R_ExecuteCommandListsOnQueue(&g_dx.immediateCommandQueue, 1u, &cmdLists);
    Sys_ProfEndNamedEvent();
    if ( r_deviceDebug->current.enabled )
      g_dx.immediateCommandQueue.commandQueue->m_pFunction[8].AddRef(g_dx.immediateCommandQueue.commandQueue);
    R_GPU_EndTimer();
    R_ProfEndNamedEventImmediateContext();
    v14->cmdBuf.device = NULL;
    R_UnlockGfxImmediateContext();
  }
  Sys_ProfEndNamedEvent();
  return data->drawListIter[v4].iteratorCount != 0;
}

/*
==============
R_SetAndClearSceneTarget
==============
*/
void R_SetAndClearSceneTarget(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo)
{
  GfxCmdBufState *state; 
  __int64 v10; 
  unsigned int v16; 
  GfxCmdBufState *v19; 
  unsigned int height; 
  const R_RT_Surface *Surface; 
  unsigned int i; 
  __int64 v38; 
  unsigned int v43; 
  GfxCmdBufState *v46; 
  unsigned int v54; 
  const R_RT_Surface *v55; 
  unsigned int j; 
  unsigned int v69; 
  const R_RT_Surface *v70; 
  __int64 v76; 
  unsigned int v90; 
  const R_RT_Surface *v91; 
  float fmt; 
  R_RT_Handle result; 
  R_RT_Handle v97; 
  const GfxViewInfo *v98; 
  R_RT_Group v99; 
  vec4_t unpackedRgba; 

  v98 = viewInfo;
  _R13 = viewInfo;
  if ( !viewInfo && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 1423, ASSERT_TYPE_ASSERT, "(viewInfo)", (const char *)&queryFormat, "viewInfo") )
    __debugbreak();
  R_LockGfxImmediateContext();
  state = gfxContext->state;
  R_ProfBeginNamedEvent(state, "R_SetAndClearSceneTarget");
  R_ResetRenderTargets(state);
  _R12 = 0i64;
  if ( rg.vrsEmissiveOnly )
  {
    __asm
    {
      vmovups ymm0, ymmword ptr [r13+31C0h]
      vmovups ymm1, ymmword ptr [r13+31E0h]
      vmovups [rbp+160h+var_100], ymm0
      vmovups ymm0, ymmword ptr [r13+3200h]
      vmovups ymmword ptr [rsp+260h+result.m_surfaceID], ymm0
      vmovups [rbp+160h+var_E0], ymm1
    }
    v99.m_colorRtCount = 2;
    v10 = 2i64;
    _RBX = 0i64;
    do
    {
      __asm
      {
        vmovups ymm0, [rbp+rbx+160h+var_100]
        vmovd   eax, xmm0
        vmovups ymmword ptr [rsp+260h+var_200.m_surfaceID], ymm0
      }
      if ( (_WORD)_EAX )
      {
        R_RT_Handle::GetSurface(&v97);
      }
      else
      {
        __asm { vpextrd rax, xmm0, 2 }
        if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
          __debugbreak();
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 442, ASSERT_TYPE_ASSERT, "(colorRt)", (const char *)&queryFormat, "colorRt") )
          __debugbreak();
      }
      __asm
      {
        vmovups ymm0, [rbp+rbx+160h+var_100]
        vmovups ymmword ptr [rbp+rbx+160h+var_1D0.m_colorRts.baseclass_0.m_surfaceID], ymm0
      }
      _RBX += 32i64;
      --v10;
    }
    while ( v10 );
    v16 = 0;
    _RSI = gfxContext;
    __asm
    {
      vmovups ymm0, ymmword ptr [rsp+260h+result.m_surfaceID]
      vmovups ymmword ptr [rbp+160h+var_1D0.m_depthRt.baseclass_0.m_surfaceID], ymm0
    }
    if ( v99.m_colorRtCount )
    {
      v19 = gfxContext->state;
      do
      {
        _RAX = 32i64 * v16;
        __asm
        {
          vmovups ymm0, ymmword ptr [rbp+rax+160h+var_1D0.m_colorRts.baseclass_0.m_surfaceID]
          vmovups ymmword ptr [rsp+260h+result.m_surfaceID], ymm0
        }
        R_AddRenderTargetTransition(v19, (R_RT_ColorHandle *)&result, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
        ++v16;
      }
      while ( v16 < v99.m_colorRtCount );
      __asm { vmovups ymm0, ymmword ptr [rbp+160h+var_1D0.m_depthRt.baseclass_0.m_surfaceID] }
    }
    state = gfxContext->state;
    __asm { vmovups ymmword ptr [rsp+260h+result.m_surfaceID], ymm0 }
    R_AddDepthStencilTransition(state, (R_RT_DepthHandle *)&result, DEPTHSTENCIL_TRANSITION_MODE_WRITE_PRESERVE_COMPRESSION, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    R_FlushResourceTransitions(state);
    __asm
    {
      vmovups xmm0, xmmword ptr [rsi]
      vmovq   rdi, xmm0
      vpextrq rsi, xmm0, 1
    }
    R_InitLocalCmdBufState(_RSI, &_RDI->input);
    R_ProfBeginNamedEvent(_RSI, "R_ClearRenderTarget");
    _RAX = R_RT_Group::GetValidRt(&v99, &result);
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovups ymmword ptr [rsp+260h+var_200.m_surfaceID], ymm0
    }
    height = R_RT_Handle::GetSurface(&v97)->m_image.m_base.height;
    Surface = R_RT_Handle::GetSurface(&v97);
    R_SetRenderTargetSize(_RDI, Surface->m_image.m_base.width, height, GFX_USE_VIEWPORT_FOR_VIEW);
    _RAX = gfxContext;
    __asm
    {
      vmovups xmm0, xmmword ptr [rax]
      vmovups xmmword ptr [rsp+260h+var_200.m_surfaceID], xmm0
    }
    R_SetRenderTargetsInternal((GfxCmdBufContext *)&v97, &v99, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1368)");
    R_GPU_BeginTimer(GPU_TIMER_CLEAR_SCREEN);
    R_ClearScreen(_RSI, 0x3Fu, 0);
    R_GPU_EndTimer();
    R_ProfEndNamedEvent(_RSI);
    R_ShutdownLocalCmdBufState(_RSI, &_RDI->input);
    for ( i = 0; i < v99.m_colorRtCount; ++i )
    {
      _RAX = 32i64 * i;
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+rax+160h+var_1D0.m_colorRts.baseclass_0.m_surfaceID]
        vmovups ymmword ptr [rsp+260h+result.m_surfaceID], ymm0
      }
      R_AddRenderTargetTransition(state, (R_RT_ColorHandle *)&result, RENDERTARGET_TRANSITION_MODE_READ, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    }
    __asm
    {
      vmovups ymm0, ymmword ptr [rbp+160h+var_1D0.m_depthRt.baseclass_0.m_surfaceID]
      vmovups ymmword ptr [rsp+260h+result.m_surfaceID], ymm0
    }
    R_AddDepthStencilTransition(state, (R_RT_DepthHandle *)&result, DEPTHSTENCIL_TRANSITION_MODE_READ_PRESERVE_COMPRESSION, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    R_FlushResourceTransitions(state);
  }
  if ( rg.halfResEmissive )
  {
    __asm
    {
      vmovups ymm0, ymmword ptr [r13+3220h]
      vmovups ymm1, ymmword ptr [r13+3240h]
      vmovups [rbp+160h+var_100], ymm0
      vmovups ymm0, ymmword ptr [r13+3260h]
      vmovups ymmword ptr [rsp+260h+var_200.m_surfaceID], ymm0
      vmovups [rbp+160h+var_E0], ymm1
    }
    v99.m_colorRtCount = 2;
    _RBX = 0i64;
    v38 = 2i64;
    do
    {
      __asm
      {
        vmovups ymm0, [rbp+rbx+160h+var_100]
        vmovd   eax, xmm0
        vmovups ymmword ptr [rsp+260h+result.m_surfaceID], ymm0
      }
      if ( (_WORD)_EAX )
      {
        R_RT_Handle::GetSurface(&result);
      }
      else
      {
        __asm { vpextrd rax, xmm0, 2 }
        if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
          __debugbreak();
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 442, ASSERT_TYPE_ASSERT, "(colorRt)", (const char *)&queryFormat, "colorRt") )
          __debugbreak();
      }
      __asm
      {
        vmovups ymm0, [rbp+rbx+160h+var_100]
        vmovups ymmword ptr [rbp+rbx+160h+var_1D0.m_colorRts.baseclass_0.m_surfaceID], ymm0
      }
      _RBX += 32i64;
      --v38;
    }
    while ( v38 );
    v43 = 0;
    _R13 = v98;
    __asm { vmovups ymm0, ymmword ptr [rsp+260h+var_200.m_surfaceID] }
    _RSI = gfxContext;
    __asm { vmovups ymmword ptr [rbp+160h+var_1D0.m_depthRt.baseclass_0.m_surfaceID], ymm0 }
    if ( v99.m_colorRtCount )
    {
      v46 = gfxContext->state;
      do
      {
        _RAX = 32i64 * v43;
        __asm
        {
          vmovups ymm0, ymmword ptr [rbp+rax+160h+var_1D0.m_colorRts.baseclass_0.m_surfaceID]
          vmovups ymmword ptr [rsp+260h+result.m_surfaceID], ymm0
        }
        R_AddRenderTargetTransition(v46, (R_RT_ColorHandle *)&result, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
        ++v43;
      }
      while ( v43 < v99.m_colorRtCount );
      __asm { vmovups ymm0, ymmword ptr [rbp+160h+var_1D0.m_depthRt.baseclass_0.m_surfaceID] }
    }
    state = gfxContext->state;
    __asm { vmovups ymmword ptr [rsp+260h+result.m_surfaceID], ymm0 }
    R_AddDepthStencilTransition(state, (R_RT_DepthHandle *)&result, DEPTHSTENCIL_TRANSITION_MODE_WRITE_PRESERVE_COMPRESSION, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    R_FlushResourceTransitions(state);
    __asm
    {
      vmovups xmm0, xmmword ptr [rsi]
      vmovq   rdi, xmm0
      vpextrq rsi, xmm0, 1
    }
    R_InitLocalCmdBufState(_RSI, &_RDI->input);
    R_ProfBeginNamedEvent(_RSI, "R_ClearRenderTarget");
    _RAX = R_RT_Group::GetValidRt(&v99, &result);
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovups ymmword ptr [rsp+260h+var_200.m_surfaceID], ymm0
    }
    v54 = R_RT_Handle::GetSurface(&v97)->m_image.m_base.height;
    v55 = R_RT_Handle::GetSurface(&v97);
    R_SetRenderTargetSize(_RDI, v55->m_image.m_base.width, v54, GFX_USE_VIEWPORT_FOR_VIEW);
    _RAX = gfxContext;
    __asm
    {
      vmovups xmm0, xmmword ptr [rax]
      vmovups xmmword ptr [rsp+260h+var_200.m_surfaceID], xmm0
    }
    R_SetRenderTargetsInternal((GfxCmdBufContext *)&v97, &v99, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1368)");
    R_GPU_BeginTimer(GPU_TIMER_CLEAR_SCREEN);
    R_ClearScreen(_RSI, 0x3Fu, 0);
    R_GPU_EndTimer();
    R_ProfEndNamedEvent(_RSI);
    R_ShutdownLocalCmdBufState(_RSI, &_RDI->input);
    for ( j = 0; j < v99.m_colorRtCount; ++j )
    {
      _RAX = 32i64 * j;
      __asm
      {
        vmovups ymm0, ymmword ptr [rbp+rax+160h+var_1D0.m_colorRts.baseclass_0.m_surfaceID]
        vmovups ymmword ptr [rsp+260h+result.m_surfaceID], ymm0
      }
      R_AddRenderTargetTransition(state, (R_RT_ColorHandle *)&result, RENDERTARGET_TRANSITION_MODE_READ, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    }
    __asm
    {
      vmovups ymm0, ymmword ptr [rbp+160h+var_1D0.m_depthRt.baseclass_0.m_surfaceID]
      vmovups ymmword ptr [rsp+260h+result.m_surfaceID], ymm0
    }
    R_AddDepthStencilTransition(state, (R_RT_DepthHandle *)&result, DEPTHSTENCIL_TRANSITION_MODE_READ_PRESERVE_COMPRESSION, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    R_FlushResourceTransitions(state);
  }
  if ( rg.debugOverdrawOverlay )
  {
    __asm
    {
      vmovups ymm0, ymmword ptr [r13+3180h]
      vmovups ymmword ptr [rsp+260h+result.m_surfaceID], ymm0
    }
    R_AddRenderTargetTransition(state, (R_RT_ColorHandle *)&result, RENDERTARGET_TRANSITION_MODE_WRITE, D3D12_RESOURCE_BARRIER_FLAG_NONE);
    R_FlushResourceTransitions(state);
    __asm
    {
      vmovups ymm0, ymmword ptr [r13+3180h]
      vmovups ymmword ptr [rsp+260h+result.m_surfaceID], ymm0
    }
    R_RT_Group::AssignColor(&v99, (R_RT_ColorHandle *)&result);
    _R15 = gfxContext;
    __asm
    {
      vmovups xmm0, xmmword ptr [r15]
      vmovq   rdi, xmm0
      vpextrq rsi, xmm0, 1
    }
    R_InitLocalCmdBufState(_RSI, &_RDI->input);
    R_ProfBeginNamedEvent(_RSI, "R_ClearRenderTarget");
    _RAX = R_RT_Group::GetValidRt(&v99, &result);
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovups ymmword ptr [rsp+260h+var_200.m_surfaceID], ymm0
    }
    v69 = R_RT_Handle::GetSurface(&v97)->m_image.m_base.height;
    v70 = R_RT_Handle::GetSurface(&v97);
    R_SetRenderTargetSize(_RDI, v70->m_image.m_base.width, v69, GFX_USE_VIEWPORT_FOR_VIEW);
    __asm
    {
      vmovups xmm0, xmmword ptr [r15]
      vmovups xmmword ptr [rsp+260h+var_200.m_surfaceID], xmm0
    }
    R_SetRenderTargetsInternal((GfxCmdBufContext *)&v97, &v99, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1368)");
    R_GPU_BeginTimer(GPU_TIMER_CLEAR_SCREEN);
    R_ClearScreen(_RSI, 0xFu, 0);
    R_GPU_EndTimer();
    R_ProfEndNamedEvent(_RSI);
    R_ShutdownLocalCmdBufState(_RSI, &_RDI->input);
  }
  __asm
  {
    vmovups ymm0, ymmword ptr [r13+30C0h]
    vmovups ymm1, ymmword ptr [r13+30E0h]
    vmovups [rbp+160h+var_100], ymm0
    vmovups ymm0, ymmword ptr [r13+3140h]
    vmovups [rbp+160h+var_C0], ymm0
    vmovups ymm0, ymmword ptr [r13+31A0h]
    vmovups [rbp+160h+var_E0], ymm1
    vmovups ymm1, ymmword ptr [r13+3160h]
    vmovups ymmword ptr [rsp+260h+var_200.m_surfaceID], ymm0
    vmovups [rbp+160h+var_A0], ymm1
  }
  v99.m_colorRtCount = 4;
  v76 = 4i64;
  do
  {
    __asm
    {
      vmovups ymm0, [rbp+r12+160h+var_100]
      vmovd   eax, xmm0
      vmovups ymmword ptr [rsp+260h+result.m_surfaceID], ymm0
    }
    if ( (_WORD)_EAX )
    {
      R_RT_Handle::GetSurface(&result);
    }
    else
    {
      __asm { vpextrd rax, xmm0, 2 }
      if ( (_DWORD)_RAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter") )
        __debugbreak();
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 442, ASSERT_TYPE_ASSERT, "(colorRt)", (const char *)&queryFormat, "colorRt") )
        __debugbreak();
    }
    __asm
    {
      vmovups ymm0, [rbp+r12+160h+var_100]
      vmovups ymmword ptr [rbp+r12+160h+var_1D0.m_colorRts.baseclass_0.m_surfaceID], ymm0
    }
    _R12 += 32i64;
    --v76;
  }
  while ( v76 );
  __asm
  {
    vmovups ymm0, ymmword ptr [rsp+260h+var_200.m_surfaceID]
    vmovups ymmword ptr [rbp+160h+var_1D0.m_depthRt.baseclass_0.m_surfaceID], ymm0
  }
  R_GetClearColor(_R13, &unpackedRgba);
  __asm { vmovups xmm0, xmmword ptr cs:?colorZero@@3Tvec4_t@@B; vec4_t const colorZero }
  _R15 = gfxContext;
  __asm
  {
    vinsertf128 ymm0, ymm0, xmm0, 1
    vmovups [rbp+160h+var_70], ymm0
    vmovups [rbp+160h+var_50], xmm0
    vmovups xmm1, xmmword ptr [r15]
    vmovq   rdi, xmm1
    vpextrq rsi, xmm1, 1
  }
  R_InitLocalCmdBufState(_RSI, &_RDI->input);
  R_ProfBeginNamedEvent(_RSI, "R_ClearRenderTargetLegacySlow");
  _RAX = R_RT_Group::GetValidRt(&v99, &result);
  __asm
  {
    vmovups ymm0, ymmword ptr [rax]
    vmovups ymmword ptr [rsp+260h+var_200.m_surfaceID], ymm0
  }
  v90 = R_RT_Handle::GetSurface(&v97)->m_image.m_base.height;
  v91 = R_RT_Handle::GetSurface(&v97);
  R_SetRenderTargetSize(_RDI, v91->m_image.m_base.width, v90, GFX_USE_VIEWPORT_FOR_VIEW);
  __asm
  {
    vmovups xmm0, xmmword ptr [r15]
    vmovups xmmword ptr [rsp+260h+var_200.m_surfaceID], xmm0
  }
  R_SetRenderTargetsInternal((GfxCmdBufContext *)&v97, &v99, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(1410)");
  R_GPU_BeginTimer(GPU_TIMER_CLEAR_SCREEN);
  __asm
  {
    vxorps  xmm0, xmm0, xmm0
    vmovss  dword ptr [rsp+260h+fmt], xmm0
  }
  R_ClearScreenLegacySlow(_RSI, 0x3Fu, &unpackedRgba, 4u, fmt, 0);
  R_GPU_EndTimer();
  R_ProfEndNamedEvent(_RSI);
  R_ShutdownLocalCmdBufState(_RSI, &_RDI->input);
  R_ProfEndNamedEvent(gfxContext->state);
  R_UnlockGfxImmediateContext();
}

/*
==============
R_SetPersistentTables
==============
*/
void R_SetPersistentTables(GfxCmdBufContext *ctx, const GfxBackEndData *data, GfxPersistentDescriptorTables table)
{
  __int64 v5; 

  v5 = table;
  R_SetGfxDescriptorTable(ctx->state, &data->globalPersistentBufferTable[v5], 0xBu);
  R_SetGfxDescriptorTable(ctx->state, &data->globalPersistentTextureTable[v5], 0xCu);
}

/*
==============
R_Shadow_DrawOverlay
==============
*/
void R_Shadow_DrawOverlay(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, int overlayStyle, const R_RT_Handle *shadowCascades, unsigned int cascadeCount, const R_RT_Handle *viewmodelShadowCascade, const R_RT_ColorHandle *spotshadowsStaleCacheRt, const R_RT_DepthHandle *sunshadowCacheRt, R_RT_BufferHandle *compressedSunCascades, R_RT_BufferHandle *csmPrepass, const R_RT_ColorHandle *sunshadowTranslucentMask)
{
  GfxCmdBufContext v29; 
  R_RT_ColorHandle v30; 
  R_RT_Handle v31; 
  R_RT_Handle v32; 
  R_RT_BufferHandle v33; 

  _RDI = viewInfo;
  _RSI = gfxContext;
  if ( (unsigned int)(overlayStyle - 1) > 6 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 4818, ASSERT_TYPE_ASSERT, "( ( overlayStyle >= GFX_SM_OVERLAY_SUN && overlayStyle < GFX_SM_OVERLAY_COUNT ) )", "( overlayStyle ) = %i", overlayStyle) )
    __debugbreak();
  if ( overlayStyle > 4 )
  {
    __asm { vmovups ymm0, ymmword ptr [rdi+6420h] }
    _RAX = spotshadowsStaleCacheRt;
    __asm
    {
      vmovups [rsp+0E8h+var_68], ymm0
      vmovups xmm0, xmmword ptr [rsi]
      vmovups ymm1, ymmword ptr [rax]
      vmovups [rsp+0E8h+var_88], ymm1
      vmovups [rsp+0E8h+var_98], xmm0
    }
    R_SpotShadow_DrawOverlay(&v29, overlayStyle, &v30, (const R_RT_DepthHandle *)&v31);
  }
  else
  {
    _RAX = sunshadowTranslucentMask;
    __asm { vmovups ymm0, ymmword ptr [rax] }
    _RAX = csmPrepass;
    __asm
    {
      vmovups [rsp+0E8h+var_48], ymm0
      vmovups ymm1, ymmword ptr [rax]
    }
    _RAX = sunshadowCacheRt;
    __asm
    {
      vmovups [rsp+0E8h+var_28], ymm1
      vmovups ymm0, ymmword ptr [rax]
    }
    _RAX = viewmodelShadowCascade;
    __asm
    {
      vmovups [rsp+0E8h+var_88], ymm0
      vmovups xmm0, xmmword ptr [rsi]
      vmovups [rsp+0E8h+var_98], xmm0
      vmovups ymm1, ymmword ptr [rax]
      vmovups [rsp+0E8h+var_68], ymm1
    }
    R_Sunshadow_DrawOverlay(&v29, _RDI, overlayStyle, shadowCascades, cascadeCount, &v31, (const R_RT_DepthHandle *)&v30, compressedSunCascades, &v33, &v32);
  }
}

/*
==============
R_ShouldDrawWireframe
==============
*/
bool R_ShouldDrawWireframe(GfxDrawListType drawlistIndex, R_SHOW_TRIS showTris)
{
  int v2; 
  bool result; 
  bool v4; 
  __int32 v5; 
  __int32 v6; 
  bool v7; 

  switch ( 0x40000000u )
  {
    case 1u:
    case 2u:
    case 7u:
    case 8u:
      if ( (unsigned int)drawlistIndex > DRAWLIST_DISTORT_EMISSIVE )
        goto $LN25_104;
      v2 = 8927236;
      if ( !_bittest(&v2, drawlistIndex) )
        goto $LN25_104;
      goto $LN81_13;
    case 3u:
$LN25_104:
      switch ( drawlistIndex )
      {
        case DRAWLIST_FIRST:
        case DRAWLIST_DEPTH_HACK_SSS:
        case DRAWLIST_LIT_OPAQUE:
        case DRAWLIST_LIT_OPAQUE_END:
        case DRAWLIST_LIT_OPAQUE_GLASS:
        case DRAWLIST_PRE_OPAQUE:
        case DRAWLIST_PRE_SSS:
        case DRAWLIST_EID_ONLY:
          goto $LN81_13;
        default:
          goto $LN2_10;
      }
    case 4u:
      if ( drawlistIndex == DRAWLIST_DEPTH_HACK_TRANS || (unsigned int)(drawlistIndex - 11) <= 2 )
        goto $LN81_13;
      return 0;
    case 5u:
      v4 = ((drawlistIndex - 19) & 0xFFFFFFFB) == 0;
      goto LABEL_9;
    case 6u:
      v5 = drawlistIndex - 1;
      if ( !v5 )
        goto $LN81_13;
      v6 = v5 - 8;
      if ( !v6 )
        goto $LN81_13;
      v4 = v6 == 8;
LABEL_9:
      if ( !v4 )
        goto $LN2_10;
      goto $LN81_13;
    case 9u:
      v7 = (unsigned int)(drawlistIndex - 24) <= 0x14;
      goto LABEL_22;
    case 0xAu:
      v7 = (unsigned int)(drawlistIndex - 24) <= 4;
      goto LABEL_22;
    case 0xBu:
      return ((drawlistIndex - 24) & 0xFFFFFFFB) == 0;
    case 0xCu:
      return drawlistIndex == DRAWLIST_SUNSHADOW_1;
    case 0xDu:
      return drawlistIndex == DRAWLIST_SUNSHADOW_2;
    case 0xEu:
      return drawlistIndex == DRAWLIST_SUNSHADOW_END;
    case 0xFu:
      v7 = (unsigned int)(drawlistIndex - 29) <= 0xF;
      goto LABEL_22;
    case 0x10u:
      v7 = (unsigned int)(drawlistIndex - 37) <= 3;
LABEL_22:
      if ( !v7 )
        goto $LN2_10;
$LN81_13:
      result = 1;
      break;
    case 0x11u:
      return ((drawlistIndex - 29) & 0xFFFFFFF7) == 0;
    case 0x12u:
      return ((drawlistIndex - 30) & 0xFFFFFFF7) == 0;
    case 0x13u:
      return ((drawlistIndex - 31) & 0xFFFFFFF7) == 0;
    case 0x14u:
      return ((drawlistIndex - 32) & 0xFFFFFFF7) == 0;
    case 0x15u:
      return ((drawlistIndex - 33) & 0xFFFFFFF7) == 0;
    case 0x16u:
      return ((drawlistIndex - 34) & 0xFFFFFFF7) == 0;
    case 0x17u:
      return ((drawlistIndex - 35) & 0xFFFFFFF7) == 0;
    case 0x18u:
      return ((drawlistIndex - 36) & 0xFFFFFFF7) == 0;
    default:
$LN2_10:
      result = 0;
      break;
  }
  return result;
}

/*
==============
R_ShowTris_Draw
==============
*/
void R_ShowTris_Draw(const GfxViewInfo *viewInfo, const GfxBackEndData *data, const R_RT_Group *rtGroup, R_SHOW_TRIS showTris)
{
  signed __int64 v4; 
  void *v6; 
  unsigned int height; 
  const R_RT_Surface *Surface; 
  unsigned int mtlFlagsFilter; 
  GfxDrawListType i; 
  unsigned int v19; 
  R_RT_Handle v21; 
  __int64 v22; 
  R_RT_Handle result; 
  GfxDrawListIter drawListIter; 
  GfxCmdBufStateLocal state; 
  GfxCmdBufSourceStateLocal v26; 
  GfxDrawCallOutput cmdBuf; 

  v6 = alloca(v4);
  v22 = -2i64;
  __asm { vmovaps [rsp+7730h+var_30], xmm6 }
  if ( showTris == R_SHOW_TRIS_NONE && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 777, ASSERT_TYPE_ASSERT, "(showTris != R_SHOW_TRIS_NONE)", (const char *)&queryFormat, "showTris != R_SHOW_TRIS_NONE") )
    __debugbreak();
  Sys_ProfBeginNamedEvent(0xFFC0C0C0, "ShowTris");
  cmdBuf.empty = 0;
  R_InitContext(data, &cmdBuf.cmdBuf);
  GfxCmdBufSourceStateLocal::GfxCmdBufSourceStateLocal(&v26);
  GfxCmdBufStateLocal::GfxCmdBufStateLocal(&state);
  if ( R_DrawListStart(&state, &v26, viewInfo, (const GfxViewParms *)viewInfo, &viewInfo->viewParmsSet.frames[1].viewParms, &cmdBuf) )
  {
    *(_QWORD *)&v21.m_surfaceID = &v26;
    *(_QWORD *)&v21.m_tracking.m_allocCounter = &state;
    R_ProfBeginNamedEvent(&state, "ShowTris");
    R_GP_SetScenePassIndex(&v26, viewInfo->input.data, 0);
    v26.viewStatsTarget = GFX_VIEW_STATS_EMISSIVE;
    __asm
    {
      vmovups xmm0, cs:__xmm@3f8000003f8000003f8000003f800000
      vmovups xmmword ptr [rbp+7630h+var_51A0.baseclass_0.input.consts+0E0h], xmm0
    }
    ++v26.constVersions[14];
    __asm
    {
      vmovups xmm6, xmmword ptr [rsp+7730h+var_7700.m_surfaceID]
      vmovdqa xmmword ptr [rsp+7730h+var_7700.m_surfaceID], xmm6
    }
    R_SetRenderTargetsInternal((GfxCmdBufContext *)&v21, rtGroup, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(803)");
    _RAX = R_RT_Group::GetValidRt((R_RT_Group *)rtGroup, &result);
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovups ymmword ptr [rsp+7730h+var_7700.m_surfaceID], ymm0
    }
    height = R_RT_Handle::GetSurface(&v21)->m_image.m_base.height;
    Surface = R_RT_Handle::GetSurface(&v21);
    R_SetRenderTargetSize(&v26, Surface->m_image.m_base.width, height, GFX_USE_VIEWPORT_FOR_VIEW);
    R_SetViewportStruct(&v26, &viewInfo->sceneGeoViewport);
    R_Set3D(&v26);
    __asm { vmovdqa xmmword ptr [rsp+7730h+var_7700.m_surfaceID], xmm6 }
    R_HW_EnableScissor((GfxCmdBufContext *)&v21, &viewInfo->scissorGeoViewport);
    if ( showTris == R_SHOW_TRIS_CAMERA_NEEDS_REFRACTION )
    {
      v26.mtlFlagsFilter = 1;
    }
    else
    {
      mtlFlagsFilter = v26.mtlFlagsFilter;
      if ( showTris == R_SHOW_TRIS_CAMERA_NEEDS_SSR_FX_DISTORT )
        mtlFlagsFilter = 2;
      v26.mtlFlagsFilter = mtlFlagsFilter;
    }
    R_SetInputWorldDefaults(&v26.input);
    RB_UpdatePersistentTables(viewInfo, data, PERSISTENT_TABLE_SHOWTRIS);
    R_SetGfxDescriptorTable(&state, (const GfxDescriptorTable *)data->globalPersistentBufferTable + 1, 0xBu);
    R_SetGfxDescriptorTable(&state, (const GfxDescriptorTable *)data->globalPersistentTextureTable + 1, 0xCu);
    if ( showTris != R_SHOW_TRIS_CAMERA_DEPTHTEST && (showTris == R_SHOW_TRIS_CAMERA_ALL || (unsigned int)(showTris - 7) <= 1 || !r_showTrisDepthTest->current.enabled) )
      R_ClearScreen(&state, 0x30u, 0);
    for ( i = DRAWLIST_FIRST; (unsigned int)i < DRAWLIST_FRONTEND_COUNT; ++i )
    {
      if ( R_ShouldDrawWireframe(i, showTris) )
      {
        R_DrawListIter_Init(&viewInfo->drawList[i], &drawListIter);
        switch ( i )
        {
          case DRAWLIST_FIRST:
          case DRAWLIST_DEPTH_HACK_SSS:
          case DRAWLIST_DEPTH_HACK_TRANS:
          case DRAWLIST_HUD_OUTLINE_FIRST:
          case DRAWLIST_PRE_DEPTH_HACK_SSS:
          case DRAWLIST_DEPTH_HACK_EMISSIVE:
          case DRAWLIST_POST_BLUR_DEPTH_HACK_EMISSIVE:
          case DRAWLIST_FRONTEND_COUNT:
          case DRAWLIST_PREPASS_DEPTH_HACK_SSS:
          case DRAWLIST_PREPASS_DEPTH_HACK_TRANS:
          case DRAWLIST_PREPASS_HUD_OUTLINE_FIRST:
          case DRAWLIST_PREPASS_PRE_DEPTH_HACK_SSS:
          case DRAWLIST_PREPASS_HUD_OUTLINE_STENCIL_FIRST:
          case DRAWLIST_PREPASS_PRE_DEPTH_HACK_SSS_STENCIL:
            if ( state.depthRangeType != GFX_DEPTH_RANGE_VIEWMODEL )
              R_ChangeDepthRange(&state, GFX_DEPTH_RANGE_VIEWMODEL);
            v19 = 1;
            break;
          default:
            if ( state.depthRangeType )
              R_ChangeDepthRange(&state, GFX_DEPTH_RANGE_SCENE);
            v19 = 0;
            break;
        }
        R_ChangeDepthHackNearClip(&v26, v19);
        __asm { vmovdqa xmmword ptr [rsp+7730h+var_7700.m_surfaceID], xmm6 }
        R_DrawSurfs_Unsorted((GfxCmdBufContext *)&v21, &drawListIter, TECHNIQUE_WIREFRAME_SOLID, i);
      }
    }
    R_HW_DisableScissor(&state);
    R_ProfEndNamedEvent(&state);
    __asm { vmovdqa xmmword ptr [rsp+7730h+var_7700.m_surfaceID], xmm6 }
    R_DrawListEnd((GfxCmdBufContext *)&v21, &cmdBuf);
  }
  Sys_ProfEndNamedEvent();
  GfxCmdBufStateLocal::~GfxCmdBufStateLocal(&state);
  GfxCmdBufSourceStateLocal::~GfxCmdBufSourceStateLocal(&v26);
  __asm { vmovaps xmm6, [rsp+7730h+var_30] }
}

/*
==============
R_ShowTris_GetShowTris
==============
*/
__int64 R_ShowTris_GetShowTris()
{
  if ( particle_show_tris->current.enabled )
    return 5i64;
  else
    return r_showTris->current.unsignedInt;
}

/*
==============
R_Umbra_ShowOcclusion
==============
*/
void R_Umbra_ShowOcclusion(GfxCmdBufContext *gfxContext, const GfxViewInfo *viewInfo, const GfxBackEndData *data, const GfxImage *umbraFloatZ)
{
  CmdBufState *state; 
  __int64 v24; 
  float fmt; 
  float v32; 
  float v33; 
  float v34; 
  float v35; 
  float v36; 
  GfxCmdBufContext v37; 

  _RSI = viewInfo;
  _RDI = gfxContext;
  if ( r_umbraShowOverlayNDC->current.integer >= 1 && R_Umbra_GetOcclusionImageCameraView(data) )
  {
    state = _RDI->state;
    __asm
    {
      vmovaps [rsp+0A8h+var_18], xmm6
      vmovaps [rsp+0A8h+var_28], xmm7
      vmovaps [rsp+0A8h+var_38], xmm8
    }
    R_ProfBeginNamedEvent(state, "Umbra Occlusion");
    __asm
    {
      vmovss  xmm2, dword ptr [rsi+148h]
      vmovss  xmm3, dword ptr [rsi+14Ch]
      vmovups xmm6, xmmword ptr [rdi]
      vmovq   rdx, xmm6
      vxorps  xmm0, xmm0, xmm0
      vxorps  xmm7, xmm7, xmm7
      vcvtsi2ss xmm7, xmm7, rax
      vxorps  xmm8, xmm8, xmm8
      vcvtsi2ss xmm8, xmm8, rax
    }
    *(_QWORD *)(_RDX + 4180) = 0i64;
    *(_DWORD *)(_RDX + 4188) = 1061158912;
    __asm
    {
      vcvtsi2ss xmm0, xmm0, ecx
      vmovss  dword ptr [rdx+1050h], xmm0
    }
    ++*(_WORD *)(_RDX + 10462);
    __asm
    {
      vmovss  xmm1, dword ptr [rsi+134h]
      vmovss  xmm0, dword ptr [rsi+130h]
      vmovss  dword ptr [rdx+1068h], xmm0
      vmovss  dword ptr [rdx+106Ch], xmm1
      vmovss  dword ptr [rdx+1060h], xmm2
      vmovss  dword ptr [rdx+1064h], xmm3
    }
    ++*(_WORD *)(_RDX + 10464);
    v24 = _RDX + 1792;
    if ( _RDX == -1792 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
      __debugbreak();
    __asm
    {
      vmovss  xmm0, cs:__real@3f800000
      vmovss  [rsp+0A8h+var_60], xmm0
      vmovss  [rsp+0A8h+var_68], xmm0
      vxorps  xmm2, xmm2, xmm2
      vmovss  [rsp+0A8h+var_70], xmm2
      vmovss  [rsp+0A8h+var_78], xmm2
    }
    *(_QWORD *)(v24 + 6176) = umbraFloatZ;
    __asm
    {
      vmovss  dword ptr [rsp+0A8h+var_80], xmm8
      vxorps  xmm3, xmm3, xmm3
      vmovss  dword ptr [rsp+0A8h+fmt], xmm7
      vmovdqa [rsp+0A8h+var_48], xmm6
    }
    RB_DrawStretchPic(&v37, rgp.umbraOverlay3d, *(float *)&_XMM2, *(float *)&_XMM3, fmt, v32, v33, v34, v35, v36, 0xFFFFFFFF, GFX_PRIM_STATS_CODE);
    __asm { vmovdqa [rsp+0A8h+var_48], xmm6 }
    RB_EndTessSurfaceInternal(&v37, "c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp(4718)");
    R_ProfEndNamedEvent(state);
    __asm
    {
      vmovaps xmm8, [rsp+0A8h+var_38]
      vmovaps xmm7, [rsp+0A8h+var_28]
      vmovaps xmm6, [rsp+0A8h+var_18]
    }
  }
}

/*
==============
R_UpdatePackedLightData
==============
*/
void R_UpdatePackedLightData(GfxBackEndData *data, const GfxViewInfo *viewInfo)
{
  if ( Sys_ExistsWorkerCmdsOfType(WRKCMD_UMBRA_QUERY_STATIC_CAMERA) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 2774, ASSERT_TYPE_ASSERT, "(!Sys_ExistsWorkerCmdsOfType( WRKCMD_UMBRA_QUERY_STATIC_CAMERA ))", (const char *)&queryFormat, "!Sys_ExistsWorkerCmdsOfType( WRKCMD_UMBRA_QUERY_STATIC_CAMERA )") )
    __debugbreak();
  Profile_Begin(109);
  R_UpdatePackedSceneLightConstants(data, viewInfo);
  R_UpdatePackedSpotShadowConstants(data, viewInfo);
  Profile_EndInternal(NULL);
}

/*
==============
R_UpdatePackedSceneLightConstants
==============
*/
void R_UpdatePackedSceneLightConstants(GfxBackEndData *data, const GfxViewInfo *viewInfo)
{
  unsigned int v25; 
  GfxWorld *world; 
  char v37; 
  int v38; 
  bool v39; 
  bool IsModifiedLight; 
  unsigned int flags; 
  unsigned int type; 
  int v68; 
  unsigned int v69; 
  unsigned int v70; 
  char v71; 
  unsigned int v72; 
  unsigned __int8 v91; 
  bool v93; 
  double v121; 
  double v122; 
  char v130; 
  void *retaddr; 

  _RAX = &retaddr;
  __asm
  {
    vmovaps xmmword ptr [rax-68h], xmm9
    vmovaps xmmword ptr [rax-98h], xmm12
    vmovaps xmmword ptr [rax-0A8h], xmm13
    vmovaps xmmword ptr [rax-0B8h], xmm14
    vmovaps [rsp+138h+var_C8], xmm15
  }
  _RAX = r_lightIntensityAutoScaleMax;
  _R15 = viewInfo;
  __asm
  {
    vmovss  xmm9, cs:__real@3f800000
    vdivss  xmm0, xmm9, dword ptr [rdx+3858h]; val
  }
  _RSI = data;
  __asm { vmovss  xmm2, dword ptr [rax+28h]; max }
  _RAX = r_lightIntensityAutoScaleMin;
  __asm { vmovss  xmm1, dword ptr [rax+28h]; min }
  *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
  __asm { vmulss  xmm15, xmm0, dword ptr [rax+28h] }
  if ( !_RSI->packedSceneLightsUpdateCount )
    memset_0(_RSI->packedSceneLights, 0, 96i64 * rgp.world->primaryLightCount);
  __asm
  {
    vmovss  xmm12, dword ptr [r15+100h]
    vmovss  xmm13, dword ptr [r15+104h]
    vmovss  xmm14, dword ptr [r15+108h]
  }
  v25 = 1;
  if ( _RSI->sceneLightCount > 1 )
  {
    world = rgp.world;
    __asm
    {
      vmovaps [rsp+138h+var_38], xmm6
      vmovaps [rsp+138h+var_88], xmm11
      vmovss  xmm11, cs:__real@477fff00
      vmovaps [rsp+138h+var_48], xmm7
      vmovaps [rsp+138h+var_58], xmm8
      vmovaps [rsp+138h+var_78], xmm10
      vxorps  xmm6, xmm6, xmm6
    }
    while ( 1 )
    {
      if ( v25 >= world->firstMovingScriptablePrimaryLight && v25 < world->primaryLightCount )
        goto LABEL_47;
      _RBP = v25;
      _RDI = (__int64)&_RSI->packedSceneLights[v25];
      if ( v25 >= world->primaryLightCount || R_IsPrimaryLightLoaded(_RSI, v25) )
      {
        __asm
        {
          vmovss  xmm0, dword ptr [rsi+rbp+53A038h]
          vmovss  xmm1, dword ptr [rsi+rbp+53A03Ch]
          vsubss  xmm4, xmm0, xmm12
          vmovss  xmm0, dword ptr [rsi+rbp+53A040h]
          vmovss  dword ptr [rdi+30h], xmm4
          vsubss  xmm2, xmm0, xmm14
          vmovss  dword ptr [rdi+38h], xmm2
          vsubss  xmm3, xmm1, xmm13
          vmovss  dword ptr [rdi+34h], xmm3
        }
        *(_BYTE *)(_RDI + 28) = 0;
        v37 = 1;
        v38 = *(_DWORD *)(_RDI + 28) | 0xFF;
        *(_DWORD *)(_RDI + 28) = v38;
        v39 = v25 <= rgp.world->primaryLightCount;
        if ( v25 < rgp.world->primaryLightCount )
        {
          IsModifiedLight = R_RadiantLive_IsModifiedLight(v25);
          v39 = (v38 & 0x300) == 0;
          if ( (v38 & 0x300) == 0 || (v39 = !IsModifiedLight, IsModifiedLight) )
          {
            v37 = 1;
          }
          else
          {
            v37 = 0;
            v39 = 1;
          }
        }
        __asm
        {
          vmovss  xmm1, dword ptr [rsi+rbp+53A088h]
          vmaxss  xmm10, xmm1, cs:__real@3ae4c389
          vmovss  xmm0, dword ptr [rsi+rbp+53A050h]
          vmovss  xmm7, cs:?rg@@3Ur_globals_t@@A.diffuseColorScale; r_globals_t rg
          vmaxss  xmm8, xmm0, xmm9
          vsubss  xmm0, xmm9, xmm10
          vmulss  xmm1, xmm0, xmm0
          vmovss  xmm0, dword ptr [rsi+rbp+53A010h]
          vdivss  xmm1, xmm0, xmm1
          vmulss  xmm3, xmm1, xmm7
          vmulss  xmm1, xmm3, dword ptr [rsi+rbp+53A014h]
          vdivss  xmm0, xmm9, xmm8
          vmulss  xmm2, xmm0, xmm0
          vmulss  xmm0, xmm3, dword ptr [rsi+rbp+53A018h]
          vmulss  xmm5, xmm0, xmm2
          vmulss  xmm0, xmm3, dword ptr [rsi+rbp+53A01Ch]
          vmulss  xmm3, xmm0, xmm2
          vmovss  xmm0, dword ptr [rsi+rbp+53A070h]
          vcomiss xmm0, xmm6
          vmulss  xmm4, xmm1, xmm2
        }
        if ( !v39 )
        {
          __asm
          {
            vmulss  xmm1, xmm0, xmm15
            vsubss  xmm0, xmm9, xmm0
            vaddss  xmm2, xmm1, xmm0
            vmulss  xmm4, xmm2, xmm4
            vmulss  xmm5, xmm2, xmm5
            vmulss  xmm3, xmm2, xmm3
          }
        }
        flags = _RSI->sceneLights[_RBP].flags;
        __asm
        {
          vmulss  xmm0, xmm7, dword ptr [rsi+rbp+53A004h]
          vmulss  xmm1, xmm7, dword ptr [rsi+rbp+53A008h]
          vmovss  xmm2, dword ptr [rsi+rbp+53A00Ch]
        }
        if ( (flags & 0x10) != 0 )
        {
          __asm
          {
            vmovaps xmm4, xmm6
            vmovaps xmm5, xmm6
            vmovaps xmm3, xmm6
            vmovaps xmm0, xmm6
            vmovaps xmm1, xmm6
            vmovaps xmm2, xmm6
          }
        }
        if ( (flags & 0x4000) == 0 )
          __asm { vmulss  xmm0, xmm0, dword ptr [r15+0D6Ch] }
        __asm
        {
          vmovss  dword ptr [rdi], xmm4
          vmovss  dword ptr [rdi+4], xmm5
          vmovss  dword ptr [rdi+8], xmm3
          vmovss  dword ptr [rdi+50h], xmm0
          vmovss  dword ptr [rdi+54h], xmm1
          vmovss  dword ptr [rdi+58h], xmm2
        }
        if ( v37 )
          break;
      }
LABEL_46:
      world = rgp.world;
LABEL_47:
      if ( ++v25 >= _RSI->sceneLightCount )
      {
        __asm
        {
          vmovaps xmm11, [rsp+138h+var_88]
          vmovaps xmm10, [rsp+138h+var_78]
          vmovaps xmm8, [rsp+138h+var_58]
          vmovaps xmm7, [rsp+138h+var_48]
          vmovaps xmm6, [rsp+138h+var_38]
        }
        goto LABEL_49;
      }
    }
    type = _RSI->sceneLights[_RBP].type;
    if ( type > 3 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_light.h", 107, ASSERT_TYPE_ASSERT, "(inType <= 3)", (const char *)&queryFormat, "inType <= 3") )
      __debugbreak();
    v68 = 0;
    v69 = (type << 8) | *(_DWORD *)(_RDI + 28) & 0xFFFFFCFF;
    *(_DWORD *)(_RDI + 28) = v69;
    if ( v25 >= rgp.world->primaryLightCount )
      v68 = 0x20000000;
    v70 = v69 & 0xDFFFFFFF | v68;
    *(_DWORD *)(_RDI + 28) = v70;
    v71 = -_RSI->sceneLights[_RBP].isVolumetric;
    v72 = v70 & 0xBFFFFFFF;
    *(_DWORD *)(_RDI + 28) = v72 | (_RSI->sceneLights[_RBP].isVolumetric != 0 ? 0x40000000 : 0);
    __asm
    {
      vmovss  xmm0, dword ptr [rsi+rbp+53A044h]
      vcomiss xmm0, xmm6
    }
    if ( v72 | (v71 != 0 ? 0x40000000 : 0) )
      __asm { vdivss  xmm7, xmm9, xmm0 }
    else
      __asm { vmovaps xmm7, xmm6 }
    __asm { vucomiss xmm8, xmm6 }
    if ( !(v72 | (v71 != 0 ? 0x40000000 : 0)) && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_light.h", 126, ASSERT_TYPE_ASSERT, "(inBulbRadius != 0.0f)", (const char *)&queryFormat, "inBulbRadius != 0.0f") )
      __debugbreak();
    *(float *)(_RDI + 32) = _RSI->sceneLights[_RBP].bulbLength.v[0];
    *(float *)(_RDI + 36) = _RSI->sceneLights[_RBP].bulbLength.v[1];
    *(float *)(_RDI + 40) = _RSI->sceneLights[_RBP].bulbLength.v[2];
    __asm
    {
      vmovss  dword ptr [rdi+2Ch], xmm8
      vmovss  dword ptr [rdi+3Ch], xmm7
    }
    *(float *)(_RDI + 16) = _RSI->sceneLights[_RBP].dir.v[0];
    *(float *)(_RDI + 20) = _RSI->sceneLights[_RBP].dir.v[1];
    *(float *)(_RDI + 24) = _RSI->sceneLights[_RBP].dir.v[2];
    __asm
    {
      vmulss  xmm0, xmm10, xmm10
      vsubss  xmm0, xmm9, xmm0
      vsqrtss xmm1, xmm0, xmm0
      vmulss  xmm2, xmm10, xmm8
      vdivss  xmm2, xmm2, xmm1
      vmovss  dword ptr [rdi+0Ch], xmm2
    }
    _RAX = _RSI->sceneLights[_RBP].def;
    __asm
    {
      vmovaps xmm0, xmm6
      vmovaps xmm7, xmm6
    }
    if ( _RAX && _RAX->iesProfile )
    {
      __asm
      {
        vmovss  xmm0, dword ptr [rax+14h]
        vmovss  xmm7, dword ptr [rax+18h]
      }
    }
    __asm
    {
      vmulss  xmm0, xmm0, xmm11; val
      vmovaps xmm2, xmm11; max
      vmovaps xmm1, xmm6; min
    }
    *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
    __asm
    {
      vcvttss2si ebx, xmm0
      vmulss  xmm0, xmm7, xmm11; val
      vmovaps xmm2, xmm11; max
      vmovaps xmm1, xmm6; min
    }
    *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, *(float *)&_XMM1, *(float *)&_XMM2);
    __asm { vcvttss2si eax, xmm0 }
    *(_DWORD *)(_RDI + 92) = (unsigned __int16)_EBX | ((unsigned __int16)_EAX << 16);
    v91 = _RSI->sceneLights[_RBP].type;
    __asm
    {
      vxorps  xmm0, xmm0, xmm0
      vmovups [rsp+138h+var_E8], xmm0
    }
    v93 = v91 <= 2u;
    if ( v91 == 2 )
      goto LABEL_40;
    if ( v91 != 3 )
    {
      __asm
      {
        vmovss  xmm1, dword ptr [rsp+138h+var_E8+0Ch]
        vmovss  xmm0, dword ptr [rsp+138h+var_E8+8]
        vmovss  xmm5, dword ptr [rsp+138h+var_E8+4]
        vmovss  xmm4, dword ptr [rsp+138h+var_E8]
      }
LABEL_45:
      __asm
      {
        vmovss  dword ptr [rdi+40h], xmm4
        vmovss  dword ptr [rdi+44h], xmm5
        vmovss  dword ptr [rdi+48h], xmm0
        vmovss  dword ptr [rdi+4Ch], xmm1
      }
      goto LABEL_46;
    }
    v93 = _RSI->sceneLights[_RBP].canUseShadowMap == 0;
    if ( _RSI->sceneLights[_RBP].canUseShadowMap )
    {
LABEL_40:
      __asm
      {
        vmovss  xmm1, dword ptr [rsi+rbp+53A064h]
        vmovss  xmm0, dword ptr [rsi+rbp+53A060h]
        vcomiss xmm1, xmm0
      }
      if ( v93 )
      {
        __asm
        {
          vcvtss2sd xmm0, xmm0, xmm0
          vmovsd  [rsp+138h+var_F8], xmm0
          vcvtss2sd xmm1, xmm1, xmm1
          vmovsd  [rsp+138h+var_100], xmm1
        }
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 2694, ASSERT_TYPE_ASSERT, "( gfxLight->cosHalfFovInner ) > ( gfxLight->cosHalfFovOuter )", "%s > %s\n\t%g, %g", "gfxLight->cosHalfFovInner", "gfxLight->cosHalfFovOuter", v121, v122) )
          __debugbreak();
      }
      __asm
      {
        vmovss  xmm3, dword ptr [rsi+rbp+53A060h]
        vmovss  xmm0, dword ptr [rsi+rbp+53A064h]
        vmulss  xmm2, xmm3, dword ptr [rsi+rbp+53A050h]
        vsubss  xmm1, xmm0, xmm3
        vdivss  xmm4, xmm9, xmm1
        vmulss  xmm0, xmm4, xmm3
        vxorps  xmm5, xmm0, cs:__xmm@80000000800000008000000080000000
        vmulss  xmm0, xmm3, xmm3
        vsubss  xmm0, xmm9, xmm0
        vsqrtss xmm1, xmm0, xmm0
        vdivss  xmm0, xmm2, xmm1
      }
    }
    else
    {
      __asm
      {
        vmovaps xmm4, xmm6
        vmovaps xmm5, xmm6
        vmovaps xmm0, xmm6
      }
    }
    __asm { vdivss  xmm1, xmm9, dword ptr [rsi+rbp+53A084h] }
    goto LABEL_45;
  }
LABEL_49:
  ++_RSI->packedSceneLightsUpdateCount;
  _R11 = &v130;
  __asm
  {
    vmovaps xmm9, xmmword ptr [r11-48h]
    vmovaps xmm12, xmmword ptr [r11-78h]
    vmovaps xmm13, xmmword ptr [r11-88h]
    vmovaps xmm14, xmmword ptr [r11-98h]
    vmovaps xmm15, [rsp+138h+var_C8]
  }
}

/*
==============
R_UpdatePackedSpotShadowConstants
==============
*/
void R_UpdatePackedSpotShadowConstants(GfxBackEndData *data, const GfxViewInfo *viewInfo)
{
  __int64 v19; 
  __int64 sceneLightIndex; 
  __int64 cacheIndex; 
  __int64 v27; 
  __int64 v28; 
  unsigned int maxSpotShadowIndex; 
  char v44; 
  __int64 v82; 
  double v83; 
  __int64 v84; 
  float4 result; 
  tmat44_t<vec4_t> in; 
  tmat44_t<vec4_t> out; 

  __asm
  {
    vmovaps [rsp+1B8h+var_98], xmm12
    vmovaps [rsp+1B8h+var_B8], xmm14
  }
  _RDI = r_spotLightShadowsPolygonOffset;
  _RSI = viewInfo;
  _RBX = data;
  if ( !r_spotLightShadowsPolygonOffset && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 648, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar accessed after deregistration", "dvar") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(_RDI);
  __asm
  {
    vmovss  xmm0, dword ptr [rdi+28h]
    vmulss  xmm12, xmm0, cs:__real@3a83126f
    vmovups xmm0, xmmword ptr [rsi+100h]
    vinsertps xmm14, xmm0, dword ptr cs:__xmm@3f8000003f8000003f8000003f800000+0Ch, 30h ; '0'
  }
  v19 = 0i64;
  _RBX->maxSpotShadowIndex = 0;
  if ( _RBX->spotShadowCount )
  {
    __asm
    {
      vmovaps [rsp+1B8h+var_38], xmm6
      vmovaps [rsp+1B8h+var_48], xmm7
      vmovaps [rsp+1B8h+var_58], xmm8
      vmovaps [rsp+1B8h+var_68], xmm9
      vmovss  xmm9, cs:__real@3f800000
      vmovaps [rsp+1B8h+var_78], xmm10
      vmovaps [rsp+1B8h+var_88], xmm11
      vmovaps [rsp+1B8h+var_A8], xmm13
      vmovss  xmm13, cs:__real@34000000
      vmovaps [rsp+1B8h+var_C8], xmm15
      vmovss  xmm15, dword ptr cs:__xmm@80000000800000008000000080000000
      vxorps  xmm11, xmm11, xmm11
    }
    do
    {
      _RSI = (__int64)&_RBX->spotShadows[v19];
      sceneLightIndex = _RBX->spotShadows[v19].sceneLightIndex;
      if ( (unsigned int)sceneLightIndex >= _RBX->sceneLightCount )
      {
        LODWORD(v84) = _RBX->sceneLightCount;
        LODWORD(v82) = _RBX->spotShadows[v19].sceneLightIndex;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 2732, ASSERT_TYPE_ASSERT, "(unsigned)( sceneLightIndex ) < (unsigned)( data->sceneLightCount )", "sceneLightIndex doesn't index data->sceneLightCount\n\t%i not in [0, %i)", v82, v84) )
          __debugbreak();
      }
      cacheIndex = _RBX->spotShadows[v19].cacheIndex;
      v27 = sceneLightIndex;
      v28 = sceneLightIndex;
      if ( (unsigned int)cacheIndex > 0xFF && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_light.h", 79, ASSERT_TYPE_ASSERT, "(inIndex <= 0xff)", (const char *)&queryFormat, "inIndex <= 0xff") )
        __debugbreak();
      LOBYTE(_RBX->packedSceneLights[v28].packed) = 0;
      _RBX->packedSceneLights[v28].packed |= cacheIndex;
      maxSpotShadowIndex = cacheIndex;
      __asm { vshufps xmm2, xmm14, xmm14, 0 }
      if ( _RBX->maxSpotShadowIndex > (unsigned int)cacheIndex )
        maxSpotShadowIndex = _RBX->maxSpotShadowIndex;
      _RBX->maxSpotShadowIndex = maxSpotShadowIndex;
      __asm
      {
        vmovups ymm0, ymmword ptr [rsi]
        vmovups ymm1, ymmword ptr [rsi+20h]
        vmovups ymmword ptr [rsp+1B8h+in+20h], ymm1
      }
      in.row2 = *(vec4_t *)_RT0.m256i_i8;
      __asm
      {
        vmulps  xmm1, xmm2, xmmword ptr [rsi]
        vmovups ymmword ptr [rsp+1B8h+in], ymm0
        vshufps xmm4, xmm14, xmm14, 0AAh ; ''
        vmulps  xmm0, xmm4, xmmword ptr [rsi+20h]
        vaddps  xmm2, xmm0, xmm1
        vshufps xmm3, xmm14, xmm14, 55h ; 'U'
        vmulps  xmm3, xmm3, xmmword ptr [rsi+10h]
        vshufps xmm5, xmm14, xmm14, 0FFh
        vmulps  xmm0, xmm5, xmmword ptr [rsi+30h]
        vaddps  xmm1, xmm0, xmm3
        vaddps  xmm2, xmm1, xmm2
        vmovups xmmword ptr [rsp+1B8h+in+30h], xmm2
      }
      MatrixTranspose44Aligned(&in, &out);
      _RAX = 152 * v27;
      __asm
      {
        vmovss  xmm0, dword ptr [rax+rbx+53A044h]
        vcomiss xmm0, xmm11
        vmovss  xmm8, dword ptr [rax+rbx+53A078h]
        vmovss  xmm10, dword ptr [rax+rbx+53A07Ch]
      }
      if ( ((unsigned __int128)(152 * (__int128)v27) >> 64 != 0) | v44 )
        __asm { vmovaps xmm7, xmm11 }
      else
        __asm { vdivss  xmm7, xmm12, xmm0 }
      R_SpotShadow_GetAtlasUVOffsetAndScale(&result, &_RBX->spotShadows[v19]);
      __asm { vmovups ymm0, ymmword ptr [rsp+1B8h+out] }
      _RDI = 96 * cacheIndex;
      __asm
      {
        vmovups ymmword ptr [rdi+rbx+759028h], ymm0
        vmovups ymm1, ymmword ptr [rsp+1B8h+out+20h]
        vmovups ymmword ptr [rdi+rbx+759048h], ymm1
        vmovss  xmm6, dword ptr [rsi+50h]
        vcomiss xmm6, xmm13
      }
      if ( __CFSHL__(3 * cacheIndex, 5) )
      {
        __asm
        {
          vcvtss2sd xmm0, xmm6, xmm6
          vmovsd  [rsp+1B8h+var_190], xmm0
        }
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_light.h", 196, ASSERT_TYPE_ASSERT, "( ( zNear >= 1.192092896e-07F ) )", "( zNear ) = %g", v83) )
          __debugbreak();
      }
      __asm
      {
        vdivss  xmm0, xmm9, xmm6
        vmovss  dword ptr [rdi+rbx+759024h], xmm0
        vsubss  xmm1, xmm9, xmm8
        vmulss  xmm0, xmm1, cs:__real@42b00000
        vaddss  xmm2, xmm0, xmm8
        vmovss  dword ptr [rdi+rbx+759018h], xmm2
        vsubss  xmm0, xmm9, xmm10
        vdivss  xmm1, xmm9, xmm0
        vmovss  dword ptr [rdi+rbx+75901Ch], xmm1
        vmulss  xmm0, xmm1, xmm10
        vxorps  xmm1, xmm0, xmm15
        vmovss  dword ptr [rdi+rbx+759020h], xmm1
        vmovss  dword ptr [rdi+rbx+759008h], xmm7
        vmovups xmm7, xmmword ptr [rsp+1B8h+result.v]
        vshufps xmm8, xmm7, xmm7, 0AAh ; ''
        vshufps xmm6, xmm7, xmm7, 55h ; 'U'
      }
      R_SpotShadow_GetMapSize();
      __asm
      {
        vmovss  dword ptr [rdi+rbx+75900Ch], xmm7
        vxorps  xmm0, xmm0, xmm0
        vcvtsi2ss xmm0, xmm0, eax
        vaddss  xmm1, xmm0, xmm6
        vmovss  dword ptr [rdi+rbx+759010h], xmm1
        vxorps  xmm2, xmm2, xmm2
        vcvtsi2ss xmm2, xmm2, ecx
        vaddss  xmm0, xmm2, xmm8
      }
      v19 = (unsigned int)(v19 + 1);
      __asm { vmovss  dword ptr [rdi+rbx+759014h], xmm0 }
    }
    while ( (unsigned int)v19 < _RBX->spotShadowCount );
    __asm
    {
      vmovaps xmm15, [rsp+1B8h+var_C8]
      vmovaps xmm13, [rsp+1B8h+var_A8]
      vmovaps xmm11, [rsp+1B8h+var_88]
      vmovaps xmm10, [rsp+1B8h+var_78]
      vmovaps xmm9, [rsp+1B8h+var_68]
      vmovaps xmm8, [rsp+1B8h+var_58]
      vmovaps xmm7, [rsp+1B8h+var_48]
      vmovaps xmm6, [rsp+1B8h+var_38]
    }
  }
  __asm
  {
    vmovaps xmm12, [rsp+1B8h+var_98]
    vmovaps xmm14, [rsp+1B8h+var_B8]
  }
}

/*
==============
R_WaitDrawWorkerCmdsOfType
==============
*/
void R_WaitDrawWorkerCmdsOfType(const GfxBackEndData *data, const GfxDrawListType drawListType)
{
  __int64 v2; 
  const char *DrawListTypeName; 
  const char *v5; 
  bool IsLockedGfxImmediateContext; 

  v2 = drawListType;
  DrawListTypeName = R_GetDrawListTypeName(drawListType);
  v5 = j_va("wait drawlist %s", DrawListTypeName);
  Sys_ProfBeginNamedEvent(0xFFFFA500, v5);
  IsLockedGfxImmediateContext = R_IsLockedGfxImmediateContext();
  if ( R_IsLockedGfxImmediateContext() )
  {
    R_UnlockGfxImmediateContext();
    if ( R_IsLockedGfxImmediateContext() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_immediate_context_lock.h", 23, ASSERT_TYPE_ASSERT, "(!R_IsLockedGfxImmediateContext())", (const char *)&queryFormat, "!R_IsLockedGfxImmediateContext()") )
      __debugbreak();
  }
  Sys_ProcessWorkerCmdsWithTimeout(R_DrawWorkerCmdsFinished, (void *)&data->drawOutput[v2].cmdCount);
  if ( IsLockedGfxImmediateContext )
  {
    if ( R_IsLockedGfxImmediateContext() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_immediate_context_lock.h", 23, ASSERT_TYPE_ASSERT, "(!R_IsLockedGfxImmediateContext())", (const char *)&queryFormat, "!R_IsLockedGfxImmediateContext()") )
      __debugbreak();
    R_LockGfxImmediateContext();
  }
  Sys_ProfEndNamedEvent();
}

/*
==============
R_WaitSkippedDrawWorkerCmds
==============
*/
void R_WaitSkippedDrawWorkerCmds(const GfxBackEndData *data)
{
  int v2; 
  volatile int *p_inCmdCount; 
  int *cmdBufValid; 
  volatile int *p_cmdCount; 
  const char *DrawListTypeName; 
  const char *v7; 
  bool IsLockedGfxImmediateContext; 
  __int64 v9; 

  Sys_ProfBeginNamedEvent(0xFFFFA500, "wait skipped draw workers");
  v2 = 0;
  p_inCmdCount = &data->drawOutput[0].inCmdCount;
  cmdBufValid = data->cmdBufValid;
  p_cmdCount = &data->drawOutput[0].cmdCount;
  do
  {
    if ( *cmdBufValid && *((_DWORD *)p_inCmdCount - 1) )
    {
      if ( *p_inCmdCount )
      {
        LODWORD(v9) = v2;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\rb_draw3d.cpp", 1283, ASSERT_TYPE_ASSERT, "( ( !data->drawOutput[drawListType].inCmdCount ) )", "( drawListType ) = %i", v9) )
          __debugbreak();
      }
      DrawListTypeName = R_GetDrawListTypeName((GfxDrawListType)v2);
      v7 = j_va("wait drawlist %s", DrawListTypeName);
      Sys_ProfBeginNamedEvent(0xFFFFA500, v7);
      IsLockedGfxImmediateContext = R_IsLockedGfxImmediateContext();
      if ( R_IsLockedGfxImmediateContext() )
      {
        R_UnlockGfxImmediateContext();
        if ( R_IsLockedGfxImmediateContext() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_immediate_context_lock.h", 23, ASSERT_TYPE_ASSERT, "(!R_IsLockedGfxImmediateContext())", (const char *)&queryFormat, "!R_IsLockedGfxImmediateContext()") )
          __debugbreak();
      }
      Sys_ProcessWorkerCmdsWithTimeout(R_DrawWorkerCmdsFinished, (void *)p_cmdCount);
      if ( IsLockedGfxImmediateContext )
      {
        if ( R_IsLockedGfxImmediateContext() && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_immediate_context_lock.h", 23, ASSERT_TYPE_ASSERT, "(!R_IsLockedGfxImmediateContext())", (const char *)&queryFormat, "!R_IsLockedGfxImmediateContext()") )
          __debugbreak();
        R_LockGfxImmediateContext();
      }
      Sys_ProfEndNamedEvent();
    }
    ++v2;
    p_cmdCount += 2284;
    ++cmdBufValid;
    p_inCmdCount += 2284;
  }
  while ( v2 < 89 );
  Sys_ProfEndNamedEvent();
}

/*
==============
R_WaveWaterFloatZ_Active
==============
*/
bool R_WaveWaterFloatZ_Active(const GfxViewInfo *viewInfo)
{
  return (viewInfo->matRenderFeatures & 4) != 0;
}

