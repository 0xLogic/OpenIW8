/*
==============
RBTD_ShowEmissiveOverdraw
==============
*/

void __fastcall RBTD_ShowEmissiveOverdraw(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBTD_ShowEmissiveOverdraw@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cUtil_CreateRelativeColorAlpha4xMS<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cUtil_CreateRelativeColorAlpha4xMS<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  return ??$cUtil_CreateRelativeColorAlpha4xMS@UR_TG_Handle@@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11@Z(context, <args_0>, <args_1>, <args_2>);
}

/*
==============
cRBT_HalfRes_Upsample<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_HalfRes_Upsample<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>)
{
  return ??$cRBT_HalfRes_Upsample@UR_TG_Handle@@U1@U1@U1@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11111@Z(context, <args_0>, <args_1>, <args_2>, <args_3>, <args_4>, <args_5>);
}

/*
==============
RBT_DrawEmissivePostBlur
==============
*/

void __fastcall RBT_DrawEmissivePostBlur(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DrawEmissivePostBlur@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RBT_DrawEmissiveCommon
==============
*/

void __fastcall RBT_DrawEmissiveCommon(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DrawEmissiveCommon@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RTD_DrawEmissiveOverdrawSetup
==============
*/

void __fastcall RTD_DrawEmissiveOverdrawSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  ?RTD_DrawEmissiveOverdrawSetup@@YAXPEBUGfxTaskInfo@@PEAUGfxViewInfo@@@Z(taskInfo, viewInfo);
}

/*
==============
cRBT_HalfRes_DownsampleDepth<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBT_HalfRes_DownsampleDepth<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cRBT_HalfRes_DownsampleDepth@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
RBTD_DrawEmissiveOverdraw
==============
*/

void __fastcall RBTD_DrawEmissiveOverdraw(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBTD_DrawEmissiveOverdraw@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBTD_ShowEmissiveOverdraw<R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cRBTD_ShowEmissiveOverdraw<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  return ??$cRBTD_ShowEmissiveOverdraw@UR_TG_Handle@@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@1@Z(context, <args_0>, <args_1>);
}

/*
==============
RBT_HalfRes_DownsampleDepth
==============
*/

void __fastcall RBT_HalfRes_DownsampleDepth(const GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_HalfRes_DownsampleDepth@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RT_DrawEmissiveSetup
==============
*/

void __fastcall RT_DrawEmissiveSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  ?RT_DrawEmissiveSetup@@YAXPEBUGfxTaskInfo@@PEAUGfxViewInfo@@@Z(taskInfo, viewInfo);
}

/*
==============
RBT_DrawEmissive
==============
*/

void __fastcall RBT_DrawEmissive(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_DrawEmissive@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
RT_DrawEmissiveCommonSetup
==============
*/

void __fastcall RT_DrawEmissiveCommonSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo, R_RT_Handle *lmapColor, R_RT_Handle *lmapSH, R_RT_Handle *lmapFog, R_RT_Handle *packedStencil)
{
  ?RT_DrawEmissiveCommonSetup@@YAXPEBUGfxTaskInfo@@PEAUGfxViewInfo@@VR_RT_Handle@@222@Z(taskInfo, viewInfo, lmapColor, lmapSH, lmapFog, packedStencil);
}

/*
==============
cUtil_CreateHalfRelativeColorAlpha<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/

unsigned int __fastcall cUtil_CreateHalfRelativeColorAlpha<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  return ??$cUtil_CreateHalfRelativeColorAlpha@UR_TG_Handle@@U1@U1@@@YAIPEAUR_TG_Script@@AEBUR_TG_Handle@@11@Z(context, <args_0>, <args_1>, <args_2>);
}

/*
==============
RBT_HalfRes_Upsample
==============
*/

void __fastcall RBT_HalfRes_Upsample(const GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  ?RBT_HalfRes_Upsample@@YAXUGfxCmdBufContext@@PEBUGfxTaskInfo@@PEBUGfxViewInfo@@PEBUGfxBackEndData@@@Z(gfxContext, taskInfo, viewInfo, data);
}

/*
==============
cRBTD_ShowEmissiveOverdraw<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBTD_ShowEmissiveOverdraw<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBTD_ShowEmissiveOverdraw.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_HalfRes_DownsampleDepth<R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_HalfRes_DownsampleDepth<R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_HalfRes_DownsampleDepth.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cRBT_HalfRes_Upsample<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cRBT_HalfRes_Upsample<R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>, const R_TG_Handle *<args_3>, const R_TG_Handle *<args_4>, const R_TG_Handle *<args_5>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v13; 
  unsigned int v14; 
  unsigned int v15; 
  unsigned int v16; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_RBT_HalfRes_Upsample.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v13 = stack.handleArgCount + 1;
  stack.handleArgCount = v13;
  if ( (unsigned int)v13 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v13 = stack.handleArgCount;
  }
  stack.handleArgs[v13] = &<args_2>->index;
  v14 = stack.handleArgCount + 1;
  stack.handleArgCount = v14;
  if ( v14 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v14 = stack.handleArgCount;
  }
  stack.handleArgs[v14] = &<args_3>->index;
  v15 = stack.handleArgCount + 1;
  stack.handleArgCount = v15;
  if ( v15 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v15 = stack.handleArgCount;
  }
  stack.handleArgs[v15] = &<args_4>->index;
  v16 = stack.handleArgCount + 1;
  stack.handleArgCount = v16;
  if ( v16 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v16 = stack.handleArgCount;
  }
  stack.handleArgs[v16] = &<args_5>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cUtil_CreateHalfRelativeColorAlpha<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cUtil_CreateHalfRelativeColorAlpha<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v10; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_Util_CreateHalfRelativeColorAlpha.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v10 = stack.handleArgCount + 1;
  stack.handleArgCount = v10;
  if ( (unsigned int)v10 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v10 = stack.handleArgCount;
  }
  stack.handleArgs[v10] = &<args_2>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
cUtil_CreateRelativeColorAlpha4xMS<R_TG_Handle,R_TG_Handle,R_TG_Handle>
==============
*/
unsigned int cUtil_CreateRelativeColorAlpha4xMS<R_TG_Handle,R_TG_Handle,R_TG_Handle>(R_TG_Script *context, const R_TG_Handle *<args_0>, const R_TG_Handle *<args_1>, const R_TG_Handle *<args_2>)
{
  unsigned int m_index; 
  __int64 handleArgCount; 
  __int64 v10; 
  R_TG_AddTaskStack stack; 

  memset_0(&stack, 0, sizeof(stack));
  m_index = g_R_TG_Def_Util_CreateRelativeColorAlpha4xMS.m_index;
  handleArgCount = stack.handleArgCount + 1;
  stack.handleArgs[0] = &<args_0>->index;
  stack.handleArgCount = handleArgCount;
  if ( (unsigned int)handleArgCount >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    handleArgCount = stack.handleArgCount;
  }
  stack.handleArgs[handleArgCount] = &<args_1>->index;
  v10 = stack.handleArgCount + 1;
  stack.handleArgCount = v10;
  if ( (unsigned int)v10 >= 0x1E )
  {
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_taskgraph_def.h", 122, ASSERT_TYPE_ASSERT, "(arguments->handleArgCount < arguments->handleArgLimit)", (const char *)&queryFormat, "arguments->handleArgCount < arguments->handleArgLimit") )
      __debugbreak();
    v10 = stack.handleArgCount;
  }
  stack.handleArgs[v10] = &<args_2>->index;
  ++stack.handleArgCount;
  return R_TG_AddTask(context, m_index, &stack);
}

/*
==============
RBTD_DrawEmissiveOverdraw
==============
*/
void RBTD_DrawEmissiveOverdraw(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufContext v5; 

  __asm
  {
    vmovups xmm0, xmmword ptr [rcx]
    vmovups xmmword ptr [rsp+38h+var_18.source], xmm0
  }
  RBT_DrawEmissiveCommon(&v5, taskInfo, viewInfo, data);
}

/*
==============
RBTD_ShowEmissiveOverdraw
==============
*/
void RBTD_ShowEmissiveOverdraw(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufContext v7; 
  R_RT_Handle v8; 

  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups xmm1, xmmword ptr [rcx]
    vmovups ymm0, ymmword ptr [rax]
    vmovups ymmword ptr [rsp+58h+var_28.m_surfaceID], ymm0
    vmovups [rsp+58h+var_38], xmm1
  }
  R_ShowOverdrawOverlay(&v7, viewInfo, &v8);
}

/*
==============
RBT_DrawEmissive
==============
*/
void RBT_DrawEmissive(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufContext v5; 

  __asm
  {
    vmovups xmm0, xmmword ptr [rcx]
    vmovups xmmword ptr [rsp+38h+var_18.source], xmm0
  }
  RBT_DrawEmissiveCommon(&v5, taskInfo, viewInfo, data);
}

/*
==============
RBT_DrawEmissiveCommon
==============
*/
void RBT_DrawEmissiveCommon(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  __int64 v7; 
  unsigned int *p_count; 
  const R_TG_DrawListGroup *v9; 
  __int64 v10; 
  unsigned int taskFlags; 

  RB_DrawEmissive_UnmapMeshes(data);
  if ( !rg.debugShaderEnabled )
  {
    v7 = 0i64;
    p_count = &g_R_TG_emissiveGroups[*taskInfo->pTaskData].count;
    if ( *p_count )
    {
      v9 = &g_R_TG_emissiveGroups[*taskInfo->pTaskData];
      do
      {
        v10 = (__int64)&v9->drawLists[v7];
        if ( (unsigned int)(*(_DWORD *)v10 - 19) > 4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_world_emissive.h", 95, ASSERT_TYPE_ASSERT, "(drawList.type == DRAWLIST_EMISSIVE || drawList.type == DRAWLIST_DEPTH_HACK_EMISSIVE || drawList.type == DRAWLIST_DISTORT_EMISSIVE || drawList.type == DRAWLIST_POST_BLUR_DEPTH_HACK_EMISSIVE || drawList.type == DRAWLIST_POST_BLUR_EMISSIVE)", (const char *)&queryFormat, "drawList.type == DRAWLIST_EMISSIVE || drawList.type == DRAWLIST_DEPTH_HACK_EMISSIVE || drawList.type == DRAWLIST_DISTORT_EMISSIVE || drawList.type == DRAWLIST_POST_BLUR_DEPTH_HACK_EMISSIVE || drawList.type == DRAWLIST_POST_BLUR_EMISSIVE") )
          __debugbreak();
        taskFlags = taskInfo->pGraphInfo->taskFlags;
        if ( (taskFlags & *(_DWORD *)(v10 + 4)) == *(_DWORD *)(v10 + 4) && (taskFlags & *(_DWORD *)(v10 + 8)) == 0 )
          RB_RunDrawList(viewInfo, data, &taskInfo->rtGroup, *(GfxDrawListType *)v10);
        v7 = (unsigned int)(v7 + 1);
      }
      while ( (unsigned int)v7 < *p_count );
    }
  }
}

/*
==============
RBT_DrawEmissivePostBlur
==============
*/
void RBT_DrawEmissivePostBlur(GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufContext v5; 

  __asm
  {
    vmovups xmm0, xmmword ptr [rcx]
    vmovups xmmword ptr [rsp+38h+var_18.source], xmm0
  }
  RBT_DrawEmissiveCommon(&v5, taskInfo, viewInfo, data);
}

/*
==============
RBT_HalfRes_DownsampleDepth
==============
*/
void RBT_HalfRes_DownsampleDepth(const GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxCmdBufContext v7; 
  R_RT_Handle v8; 

  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups xmm1, xmmword ptr [rcx]
    vmovups ymm0, ymmword ptr [rax]
    vmovups ymmword ptr [rsp+58h+var_28.m_surfaceID], ymm0
    vmovups [rsp+58h+var_38], xmm1
  }
  R_HalfRes_DownsampleDepth(&v7, &v8, &viewInfo->sceneEmissiveViewport);
}

/*
==============
RBT_HalfRes_Upsample
==============
*/
void RBT_HalfRes_Upsample(const GfxCmdBufContext *gfxContext, const GfxTaskInfo *taskInfo, const GfxViewInfo *viewInfo, const GfxBackEndData *data)
{
  GfxViewport *p_sceneViewport; 
  GfxCmdBufContext v13; 
  R_RT_Handle v14; 
  R_RT_Handle v15; 
  R_RT_Handle v16; 
  R_RT_Handle v17; 
  void *retaddr; 

  _R11 = &retaddr;
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+60h]
    vmovups ymm1, ymmword ptr [rax+40h]
    vmovups [rsp+0C8h+var_88], ymm0
    vmovups ymm0, ymmword ptr [rax+20h]
    vmovups [rsp+0C8h+var_68], ymm1
    vmovups ymm1, ymmword ptr [rax]
  }
  p_sceneViewport = &viewInfo->sceneViewport;
  _R8 = &v16;
  __asm
  {
    vmovups ymmword ptr [r11-48h], ymm0
    vmovups xmm0, xmmword ptr [rcx]
    vmovups ymmword ptr [r11-28h], ymm1
    vmovups [rsp+0C8h+var_98], xmm0
  }
  R_HalfRes_Upsample(&v13, &v17, &v16, &v15, &v14, p_sceneViewport);
}

/*
==============
RTD_DrawEmissiveOverdrawSetup
==============
*/
void RTD_DrawEmissiveOverdrawSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  R_RT_Handle v8; 
  R_RT_Handle v9; 
  R_RT_Handle v10; 
  R_RT_Handle v11; 

  __asm { vpxor   xmm0, xmm0, xmm0 }
  v8.m_surfaceID = 0;
  v8.m_tracking.m_allocCounter = 0;
  __asm
  {
    vmovdqu xmmword ptr [rbp+57h+var_80+10h], xmm0
    vmovups ymm1, [rbp+57h+var_80]
  }
  v9.m_surfaceID = 0;
  v9.m_tracking.m_allocCounter = 0;
  v10.m_surfaceID = 0;
  v10.m_tracking.m_allocCounter = 0;
  __asm { vmovdqu xmmword ptr [rbp+57h+var_40+10h], xmm0 }
  v11.m_surfaceID = 0;
  v11.m_tracking.m_allocCounter = 0;
  __asm
  {
    vmovdqu xmmword ptr [rbp+57h+var_60+10h], xmm0
    vmovdqu xmmword ptr [rbp+57h+var_20+10h], xmm0
    vmovups ymm0, [rbp+57h+var_60]
    vmovups [rbp+57h+var_80], ymm1
    vmovups ymm1, [rbp+57h+var_40]
    vmovups [rbp+57h+var_60], ymm0
    vmovups ymm0, [rbp+57h+var_20]
    vmovups [rbp+57h+var_40], ymm1
    vmovups [rbp+57h+var_20], ymm0
  }
  RT_DrawEmissiveCommonSetup(taskInfo, viewInfo, &v11, &v10, &v9, &v8);
}

/*
==============
RT_DrawEmissiveCommonSetup
==============
*/
void RT_DrawEmissiveCommonSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo, R_RT_Handle *lmapColor, R_RT_Handle *lmapSH, R_RT_Handle *lmapFog, R_RT_Handle *packedStencil)
{
  R_RT_Image *defaultWaveWaterFloatZImage; 
  R_RT_Image *whiteImage; 
  R_RT_Image *p_m_image; 
  R_RT_Image *defaultFogLightmapImage; 
  bool enabled; 
  R_RT_Image *blackImage; 
  __int64 v27; 
  unsigned int *p_count; 
  const R_TG_DrawListGroup *v29; 
  __int64 v30; 
  unsigned int taskFlags; 
  R_RT_Handle v32; 

  _R14 = lmapSH;
  _RSI = lmapColor;
  if ( !rg.debugShaderEnabled )
  {
    _RAX = taskInfo->attachments;
    defaultWaveWaterFloatZImage = (R_RT_Image *)rgp.defaultWaveWaterFloatZImage;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovd   eax, xmm0
      vmovups ymmword ptr [rsp+78h+var_48.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v32);
      defaultWaveWaterFloatZImage = &R_RT_Handle::GetSurface(&v32)->m_image;
    }
    else if ( v32.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v32.m_surfaceID) )
    {
      __debugbreak();
    }
    if ( viewInfo == (GfxViewInfo *)-3760i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1482, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
      __debugbreak();
    __asm
    {
      vmovups ymm0, ymmword ptr [rsi]
      vmovd   eax, xmm0
    }
    viewInfo->input.codePersistentImages[15] = &defaultWaveWaterFloatZImage->m_base;
    whiteImage = (R_RT_Image *)rgp.whiteImage;
    __asm { vmovups ymmword ptr [rsp+78h+var_48.m_surfaceID], ymm0 }
    if ( (_WORD)_EAX )
    {
      R_RT_Handle::GetSurface(&v32);
      whiteImage = &R_RT_Handle::GetSurface(&v32)->m_image;
    }
    else if ( v32.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v32.m_surfaceID) )
    {
      __debugbreak();
    }
    if ( viewInfo == (GfxViewInfo *)-3760i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
      __debugbreak();
    __asm
    {
      vmovups ymm0, ymmword ptr [r14]
      vmovd   eax, xmm0
    }
    viewInfo->input.codeImages[36] = &whiteImage->m_base;
    p_m_image = (R_RT_Image *)rgp.whiteImage;
    __asm { vmovups ymmword ptr [rsp+78h+var_48.m_surfaceID], ymm0 }
    if ( (_WORD)_EAX )
    {
      R_RT_Handle::GetSurface(&v32);
      p_m_image = &R_RT_Handle::GetSurface(&v32)->m_image;
    }
    else if ( v32.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v32.m_surfaceID) )
    {
      __debugbreak();
    }
    if ( viewInfo == (GfxViewInfo *)-3760i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
      __debugbreak();
    _RAX = lmapFog;
    viewInfo->input.codeImages[37] = &p_m_image->m_base;
    defaultFogLightmapImage = (R_RT_Image *)rgp.defaultFogLightmapImage;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovups ymmword ptr [rsp+78h+var_48.m_surfaceID], ymm0
    }
    enabled = fx_gpu_deferred_fog->current.enabled;
    __asm { vmovd   eax, xmm0 }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v32);
      if ( enabled )
        defaultFogLightmapImage = &R_RT_Handle::GetSurface(&v32)->m_image;
    }
    else if ( v32.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v32.m_surfaceID) )
    {
      __debugbreak();
    }
    if ( viewInfo == (GfxViewInfo *)-3760i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
      __debugbreak();
    _RAX = packedStencil;
    viewInfo->input.codeImages[38] = &defaultFogLightmapImage->m_base;
    blackImage = (R_RT_Image *)rgp.blackImage;
    __asm
    {
      vmovups ymm0, ymmword ptr [rax]
      vmovd   eax, xmm0
      vmovups ymmword ptr [rsp+78h+var_48.m_surfaceID], ymm0
    }
    if ( (_WORD)_RAX )
    {
      R_RT_Handle::GetSurface(&v32);
      blackImage = &R_RT_Handle::GetSurface(&v32)->m_image;
    }
    else if ( v32.m_tracking.m_allocCounter && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_rt_handle.h", 100, ASSERT_TYPE_ASSERT, "(!this->m_tracking.m_allocCounter)", (const char *)&queryFormat, "!this->m_tracking.m_allocCounter", *(_QWORD *)&v32.m_surfaceID) )
    {
      __debugbreak();
    }
    if ( viewInfo == (GfxViewInfo *)-3760i64 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\r_state.h", 1470, ASSERT_TYPE_ASSERT, "(input)", (const char *)&queryFormat, "input") )
      __debugbreak();
    viewInfo->input.codeImages[79] = &blackImage->m_base;
    v27 = 0i64;
    p_count = &g_R_TG_emissiveGroups[*taskInfo->pTaskData].count;
    if ( *p_count )
    {
      v29 = &g_R_TG_emissiveGroups[*taskInfo->pTaskData];
      do
      {
        v30 = (__int64)&v29->drawLists[v27];
        if ( (unsigned int)(*(_DWORD *)v30 - 19) > 4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\gfx_d3d\\taskgraph\\tasks\\r_tgt_world_emissive.h", 72, ASSERT_TYPE_ASSERT, "(drawList.type == DRAWLIST_EMISSIVE || drawList.type == DRAWLIST_DEPTH_HACK_EMISSIVE || drawList.type == DRAWLIST_DISTORT_EMISSIVE || drawList.type == DRAWLIST_POST_BLUR_DEPTH_HACK_EMISSIVE || drawList.type == DRAWLIST_POST_BLUR_EMISSIVE)", (const char *)&queryFormat, "drawList.type == DRAWLIST_EMISSIVE || drawList.type == DRAWLIST_DEPTH_HACK_EMISSIVE || drawList.type == DRAWLIST_DISTORT_EMISSIVE || drawList.type == DRAWLIST_POST_BLUR_DEPTH_HACK_EMISSIVE || drawList.type == DRAWLIST_POST_BLUR_EMISSIVE") )
          __debugbreak();
        taskFlags = taskInfo->pGraphInfo->taskFlags;
        if ( (taskFlags & *(_DWORD *)(v30 + 4)) == *(_DWORD *)(v30 + 4) && (taskFlags & *(_DWORD *)(v30 + 8)) == 0 )
          R_AddDrawCall(viewInfo, &taskInfo->rtGroup, *(GfxDrawListType *)v30, 0x5Du);
        v27 = (unsigned int)(v27 + 1);
      }
      while ( (unsigned int)v27 < *p_count );
    }
  }
}

/*
==============
RT_DrawEmissiveSetup
==============
*/
void RT_DrawEmissiveSetup(const GfxTaskInfo *taskInfo, GfxViewInfo *viewInfo)
{
  R_RT_Handle v8; 
  R_RT_Handle v9; 
  R_RT_Handle v10; 
  R_RT_Handle v11; 
  void *retaddr; 

  _R11 = &retaddr;
  _RAX = taskInfo->attachments;
  __asm
  {
    vmovups ymm0, ymmword ptr [rax+240h]
    vmovups ymm1, ymmword ptr [rax+100h]
    vmovups [rsp+0B8h+var_88], ymm0
    vmovups ymm0, ymmword ptr [rax+0E0h]
    vmovups [rsp+0B8h+var_68], ymm1
    vmovups ymm1, ymmword ptr [rax+0C0h]
    vmovups [rsp+0B8h+var_48], ymm0
    vmovups ymmword ptr [r11-28h], ymm1
  }
  RT_DrawEmissiveCommonSetup(taskInfo, viewInfo, &v11, &v10, &v9, &v8);
}

