/*
==============
CG_ViewMotion_InitCinematicMotionAssets
==============
*/

void CG_ViewMotion_InitCinematicMotionAssets(void)
{
  ?CG_ViewMotion_InitCinematicMotionAssets@@YAXXZ();
}

/*
==============
AdvancedSwayDeadzone::DebugDrawText
==============
*/

void __fastcall AdvancedSwayDeadzone::DebugDrawText(AdvancedSwayDeadzone *this, const LocalClientNum_t localClientNum, DebugDrawState *debugDraw)
{
  ?DebugDrawText@AdvancedSwayDeadzone@@QEBAXW4LocalClientNum_t@@PEAUDebugDrawState@@@Z(this, localClientNum, debugDraw);
}

/*
==============
DebugDrawDisplacementLine
==============
*/

void __fastcall DebugDrawDisplacementLine(const cg_t *const cgameGlob, const vec3_t *angles, const vec3_t *drawAxis, const vec4_t *color)
{
  ?DebugDrawDisplacementLine@@YAXQEBVcg_t@@AEBTvec3_t@@1AEBTvec4_t@@@Z(cgameGlob, angles, drawAxis, color);
}

/*
==============
CG_ViewMotion_MyChanges
==============
*/

void CG_ViewMotion_MyChanges(void)
{
  ?CG_ViewMotion_MyChanges@@YAXXZ();
}

/*
==============
AdvancedSwayState::AdvancedSwayState
==============
*/

void __fastcall AdvancedSwayState::AdvancedSwayState(AdvancedSwayState *this)
{
  ??0AdvancedSwayState@@QEAA@XZ(this);
}

/*
==============
CG_ViewMotion_ClearCinematicMotionAssets
==============
*/

void CG_ViewMotion_ClearCinematicMotionAssets(void)
{
  ?CG_ViewMotion_ClearCinematicMotionAssets@@YAXXZ();
}

/*
==============
AdvancedSwaySprings::Reset
==============
*/

void __fastcall AdvancedSwaySprings::Reset(AdvancedSwaySprings *this)
{
  ?Reset@AdvancedSwaySprings@@QEAAXXZ(this);
}

/*
==============
AdvancedSwaySprings::GetAnglesOffset
==============
*/

void __fastcall AdvancedSwaySprings::GetAnglesOffset(AdvancedSwaySprings *this, vec3_t *outAnglesOffset)
{
  ?GetAnglesOffset@AdvancedSwaySprings@@QEBAXAEATvec3_t@@@Z(this, outAnglesOffset);
}

/*
==============
ViewMotionSpring::ViewMotionSpring
==============
*/

void __fastcall ViewMotionSpring::ViewMotionSpring(ViewMotionSpring *this)
{
  ??0ViewMotionSpring@@QEAA@XZ(this);
}

/*
==============
CG_ViewMotion_LocalOffsetToLocalAngles
==============
*/

void __fastcall CG_ViewMotion_LocalOffsetToLocalAngles(const playerState_s *ps, const ViewMotionSpring *spring, const vec3_t *localOffset, vec3_t *outLocalAngles)
{
  ?CG_ViewMotion_LocalOffsetToLocalAngles@@YAXPEBUplayerState_s@@AEBUViewMotionSpring@@AEBTvec3_t@@AEAT3@@Z(ps, spring, localOffset, outLocalAngles);
}

/*
==============
CG_ViewMotion_GetSpringOffset
==============
*/

void __fastcall CG_ViewMotion_GetSpringOffset(const playerState_s *ps, const float adsFraction, const ViewMotionSpring *spring, const vec3_t *viewAngles, vec3_t *outLocalOffset, vec3_t *outWorldOffset)
{
  ?CG_ViewMotion_GetSpringOffset@@YAXPEBUplayerState_s@@MAEBUViewMotionSpring@@AEBTvec3_t@@PEAT3@3@Z(ps, adsFraction, spring, viewAngles, outLocalOffset, outWorldOffset);
}

/*
==============
AdvancedSwaySprings::AdvancedSwaySprings
==============
*/

void __fastcall AdvancedSwaySprings::AdvancedSwaySprings(AdvancedSwaySprings *this)
{
  ??0AdvancedSwaySprings@@QEAA@XZ(this);
}

/*
==============
AdvancedSwayGunDir::Reset
==============
*/

void __fastcall AdvancedSwayGunDir::Reset(AdvancedSwayGunDir *this)
{
  ?Reset@AdvancedSwayGunDir@@QEAAXXZ(this);
}

/*
==============
AngularSmoothing::AngularSmoothing
==============
*/

void __fastcall AngularSmoothing::AngularSmoothing(AngularSmoothing *this)
{
  ??0AngularSmoothing@@QEAA@XZ(this);
}

/*
==============
AdvancedSwaySprings::Update
==============
*/

void __fastcall AdvancedSwaySprings::Update(AdvancedSwaySprings *this, const bool enabled, const vec2_t *massConst, const vec2_t *springConst, const vec2_t *damperConst, const vec3_t *goalAnglesOffset, float frametimeSecScaled)
{
  ?Update@AdvancedSwaySprings@@QEAAX_NAEBTvec2_t@@11AEBTvec3_t@@M@Z(this, enabled, massConst, springConst, damperConst, goalAnglesOffset, frametimeSecScaled);
}

/*
==============
AdvancedSwayGunDir::AdvancedSwayGunDir
==============
*/

void __fastcall AdvancedSwayGunDir::AdvancedSwayGunDir(AdvancedSwayGunDir *this)
{
  ??0AdvancedSwayGunDir@@QEAA@XZ(this);
}

/*
==============
AdvancedSwayState::GetBlendspaceParams
==============
*/

void __fastcall AdvancedSwayState::GetBlendspaceParams(AdvancedSwayState *this, vec2_t *outBsParams)
{
  ?GetBlendspaceParams@AdvancedSwayState@@QEBAXAEATvec2_t@@@Z(this, outBsParams);
}

/*
==============
AdvancedSwayState::DebugDraw
==============
*/

void __fastcall AdvancedSwayState::DebugDraw(AdvancedSwayState *this, const LocalClientNum_t localClientNum)
{
  ?DebugDraw@AdvancedSwayState@@QEBAXW4LocalClientNum_t@@@Z(this, localClientNum);
}

/*
==============
CG_ViewMotion_DebugDrawGraph
==============
*/

void __fastcall CG_ViewMotion_DebugDrawGraph(const ScreenPlacement *const scrPlace, float drawX, float drawY, const RumbleGraph *const nonLinearGraph, const vec4_t *colorGraph, float normValueX_0, const vec4_t *color0, float normValueX_1, const vec4_t *color1)
{
  ?CG_ViewMotion_DebugDrawGraph@@YAXQEBUScreenPlacement@@MMQEBURumbleGraph@@AEBTvec4_t@@M2M2@Z(scrPlace, drawX, drawY, nonLinearGraph, colorGraph, normValueX_0, color0, normValueX_1, color1);
}

/*
==============
AdvancedSwayDeadzone::Reset
==============
*/

void __fastcall AdvancedSwayDeadzone::Reset(AdvancedSwayDeadzone *this)
{
  ?Reset@AdvancedSwayDeadzone@@QEAAXXZ(this);
}

/*
==============
AdvancedSwayDeadzone::GetAnglesOffset
==============
*/

void __fastcall AdvancedSwayDeadzone::GetAnglesOffset(AdvancedSwayDeadzone *this, vec3_t *outGoalAnglesOffset)
{
  ?GetAnglesOffset@AdvancedSwayDeadzone@@QEBAXAEATvec3_t@@@Z(this, outGoalAnglesOffset);
}

/*
==============
CG_ViewMotion_Update
==============
*/

void __fastcall CG_ViewMotion_Update(const LocalClientNum_t localClientNum)
{
  ?CG_ViewMotion_Update@@YAXW4LocalClientNum_t@@@Z(localClientNum);
}

/*
==============
CG_ViewMotion_Impact
==============
*/

void __fastcall CG_ViewMotion_Impact(const LocalClientNum_t localClientNum, const int time)
{
  ?CG_ViewMotion_Impact@@YAXW4LocalClientNum_t@@H@Z(localClientNum, time);
}

/*
==============
AdvancedSwayDeadzone::AdvancedSwayDeadzone
==============
*/

void __fastcall AdvancedSwayDeadzone::AdvancedSwayDeadzone(AdvancedSwayDeadzone *this)
{
  ??0AdvancedSwayDeadzone@@QEAA@XZ(this);
}

/*
==============
AdvancedSwayState::DebugDrawText
==============
*/

void __fastcall AdvancedSwayState::DebugDrawText(AdvancedSwayState *this, const LocalClientNum_t localClientNum)
{
  ?DebugDrawText@AdvancedSwayState@@QEBAXW4LocalClientNum_t@@@Z(this, localClientNum);
}

/*
==============
AdvancedSwayDeadzone::DebugDraw
==============
*/

void __fastcall AdvancedSwayDeadzone::DebugDraw(AdvancedSwayDeadzone *this, const LocalClientNum_t localClientNum, const vec4_t *color)
{
  ?DebugDraw@AdvancedSwayDeadzone@@QEBAXW4LocalClientNum_t@@AEBTvec4_t@@@Z(this, localClientNum, color);
}

/*
==============
CG_ViewMotion_GetCinematicMotionIndexForPtr
==============
*/

unsigned int __fastcall CG_ViewMotion_GetCinematicMotionIndexForPtr(const CinematicMotionDef *const def)
{
  return ?CG_ViewMotion_GetCinematicMotionIndexForPtr@@YAIQEBUCinematicMotionDef@@@Z(def);
}

/*
==============
AdvancedSwayGunDir::GetAnglesOffset
==============
*/

void __fastcall AdvancedSwayGunDir::GetAnglesOffset(AdvancedSwayGunDir *this, vec3_t *outAnglesOffset)
{
  ?GetAnglesOffset@AdvancedSwayGunDir@@QEBAXAEATvec3_t@@@Z(this, outAnglesOffset);
}

/*
==============
ViewMotionSpring::Reset
==============
*/

void __fastcall ViewMotionSpring::Reset(ViewMotionSpring *this, const float4 *playerOrigin)
{
  ?Reset@ViewMotionSpring@@QEAAXAEBUfloat4@@@Z(this, playerOrigin);
}

/*
==============
AdvancedSwayState::GetAngleOffsets
==============
*/

void __fastcall AdvancedSwayState::GetAngleOffsets(AdvancedSwayState *this, vec3_t *outTorsoAngleOffsets, vec3_t *outGunAngleOffsets, vec3_t *outGunPivotOffset)
{
  ?GetAngleOffsets@AdvancedSwayState@@QEBAXAEATvec3_t@@00@Z(this, outTorsoAngleOffsets, outGunAngleOffsets, outGunPivotOffset);
}

/*
==============
AdvancedSwayGunDir::DebugDrawText
==============
*/

void __fastcall AdvancedSwayGunDir::DebugDrawText(AdvancedSwayGunDir *this, const LocalClientNum_t localClientNum, float yawToRollScale, DebugDrawState *debugDraw)
{
  ?DebugDrawText@AdvancedSwayGunDir@@QEBAXW4LocalClientNum_t@@MPEAUDebugDrawState@@@Z(this, localClientNum, yawToRollScale, debugDraw);
}

/*
==============
CG_ViewMotion_GetCinematicMotionDef
==============
*/

const CinematicMotionDef *__fastcall CG_ViewMotion_GetCinematicMotionDef(unsigned int index)
{
  return ?CG_ViewMotion_GetCinematicMotionDef@@YAPEBUCinematicMotionDef@@I@Z(index);
}

/*
==============
AdvancedSwaySprings::GetAnglesVelocity
==============
*/

void __fastcall AdvancedSwaySprings::GetAnglesVelocity(AdvancedSwaySprings *this, vec3_t *outAnglesVelocity)
{
  ?GetAnglesVelocity@AdvancedSwaySprings@@QEBAXAEATvec3_t@@@Z(this, outAnglesVelocity);
}

/*
==============
AdvancedSwayDeadzone::Update
==============
*/

void __fastcall AdvancedSwayDeadzone::Update(AdvancedSwayDeadzone *this, const AdvancedHipSwaySettings *const swayDef, const vec3_t *viewAngles, float frametimeSecScaled, const vec3_t *viewAngleVelocityScaled, float adsFraction, float fireFraction)
{
  ?Update@AdvancedSwayDeadzone@@QEAAXQEBUAdvancedHipSwaySettings@@AEBTvec3_t@@M1MM@Z(this, swayDef, viewAngles, frametimeSecScaled, viewAngleVelocityScaled, adsFraction, fireFraction);
}

/*
==============
AdvancedSwayState::Update
==============
*/

void __fastcall AdvancedSwayState::Update(AdvancedSwayState *this, const cg_t *const cgameGlob, const vec3_t *viewmodelAngles)
{
  ?Update@AdvancedSwayState@@QEAAXQEBVcg_t@@AEBTvec3_t@@@Z(this, cgameGlob, viewmodelAngles);
}

/*
==============
AngularSmoothing::Update
==============
*/

void __fastcall AngularSmoothing::Update(AngularSmoothing *this, const cg_t *const cgameGlob, const float adsFrac, const float frametime, const float speed, vec3_t *inOutAngles)
{
  ?Update@AngularSmoothing@@QEAAXQEBVcg_t@@MMMAEATvec3_t@@@Z(this, cgameGlob, adsFrac, frametime, speed, inOutAngles);
}

/*
==============
AngularSmoothing::Reset
==============
*/

void __fastcall AngularSmoothing::Reset(AngularSmoothing *this)
{
  ?Reset@AngularSmoothing@@QEAAXXZ(this);
}

/*
==============
AdvancedSwayGunDir::Update
==============
*/

void __fastcall AdvancedSwayGunDir::Update(AdvancedSwayGunDir *this, const AdvancedHipSwaySettings *const swayDef, const vec3_t *offsetAngles, const vec3_t *offsetVelocity, float frametimeSecScaled, const vec3_t *angleVelocityWorldScaled, float fireFraction)
{
  ?Update@AdvancedSwayGunDir@@QEAAXQEBUAdvancedHipSwaySettings@@AEBTvec3_t@@1M1M@Z(this, swayDef, offsetAngles, offsetVelocity, frametimeSecScaled, angleVelocityWorldScaled, fireFraction);
}

/*
==============
AdvancedSwayDeadzone::AdvancedSwayDeadzone
==============
*/
void AdvancedSwayDeadzone::AdvancedSwayDeadzone(AdvancedSwayDeadzone *this)
{
  this->m_isInitialized = 0;
}

/*
==============
AdvancedSwayGunDir::AdvancedSwayGunDir
==============
*/
void AdvancedSwayGunDir::AdvancedSwayGunDir(AdvancedSwayGunDir *this)
{
  this->m_isInitialized = 0;
}

/*
==============
AdvancedSwaySprings::AdvancedSwaySprings
==============
*/
void AdvancedSwaySprings::AdvancedSwaySprings(AdvancedSwaySprings *this)
{
  this->m_isInitialized = 0;
}

/*
==============
AdvancedSwayState::AdvancedSwayState
==============
*/
void AdvancedSwayState::AdvancedSwayState(AdvancedSwayState *this)
{
  this->m_smoothing.m_initialized = 0;
  this->m_torsoGoal.m_isInitialized = 0;
  this->m_torsoSprings.m_isInitialized = 0;
  this->m_gunGoal.m_isInitialized = 0;
  this->m_gunSprings.m_isInitialized = 0;
  this->m_isInitialized = 0;
}

/*
==============
AngularSmoothing::AngularSmoothing
==============
*/
void AngularSmoothing::AngularSmoothing(AngularSmoothing *this)
{
  this->m_initialized = 0;
}

/*
==============
ViewMotionSpring::ViewMotionSpring
==============
*/
void ViewMotionSpring::ViewMotionSpring(ViewMotionSpring *this)
{
  *(_QWORD *)&this->motionIndex = 31i64;
  *(_QWORD *)&this->motionIndexBlendDuration = 0i64;
  this->isLockingSpring = 0;
  *(__m256i *)this->massPos.v.m128_f32 = (__m256i)0i64;
  *(__m256i *)this->anchorPos.v.m128_f32 = (__m256i)0i64;
  *(__m256i *)this->prevPsOrigin.v.m128_f32 = (__m256i)0i64;
  *(__m256i *)this->velocityScale.v.m128_f32 = (__m256i)0i64;
  *(__m256i *)this->dampingConstant.v.m128_f32 = (__m256i)0i64;
  this->offsetAngles.x = (float4)g_1000.v;
  this->offsetAngles.y = (float4)g_0100.v;
  this->offsetAngles.z = (float4)g_0010.v;
  this->offsetAngles.w = (float4)g_0001.v;
  this->isInitialized = 0;
}

/*
==============
CG_ViewMotion_AssertFloat3Normalized
==============
*/
void CG_ViewMotion_AssertFloat3Normalized(const float4 *vec)
{
  float v5; 

  _XMM1 = _mm128_mul_ps(vec->v, vec->v);
  __asm
  {
    vinsertps xmm2, xmm1, xmm1, 8
    vhaddps xmm0, xmm2, xmm2
    vhaddps xmm0, xmm0, xmm0
  }
  v5 = _mm_sqrt_ps(_XMM0).m128_f32[0];
  if ( v5 <= 0.99900001 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 1472, ASSERT_TYPE_ASSERT, "( (1.0f - 0.001f) ) < ( Float4ExtractX( len ) )", "%s < %s\n\t%g, %g", "(1.0f - EQUAL_EPSILON)", "Float4ExtractX( len )", DOUBLE_0_9990000128746033, v5) )
    __debugbreak();
  if ( v5 >= 1.001 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 1473, ASSERT_TYPE_ASSERT, "( Float4ExtractX( len ) ) < ( (1.0f + 0.001f) )", "%s < %s\n\t%g, %g", "Float4ExtractX( len )", "(1.0f + EQUAL_EPSILON)", v5, DOUBLE_1_001000046730042) )
    __debugbreak();
}

/*
==============
CG_ViewMotion_CheckSpringTeleport
==============
*/
void CG_ViewMotion_CheckSpringTeleport(const cg_t *const cgameGlob, const float4 *curPsOrigin, ViewMotionSpring *spring)
{
  char v5; 
  __m128 v6; 

  v5 = cgameGlob->playerTeleported || !spring->isInitialized;
  if ( !BG_IsInAir(&cgameGlob->predictedPlayerState, 0) )
  {
    v6 = _mm128_sub_ps(curPsOrigin->v, spring->prevPsOrigin.v);
    _XMM2 = _mm128_mul_ps(v6, v6);
    __asm
    {
      vhaddps xmm0, xmm2, xmm2
      vhaddps xmm1, xmm0, xmm0
    }
    v5 |= *(float *)&_XMM1 >= teleportThresholdDistSq;
  }
  if ( v5 )
  {
    *(__m256i *)spring->massPos.v.m128_f32 = (__m256i)0i64;
    *(__m256i *)spring->anchorPos.v.m128_f32 = (__m256i)0i64;
    spring->unlockTime = 0;
    spring->prevPsOrigin = (float4)curPsOrigin->v;
    *(__m256i *)spring->velocitySmoothingSec.v.m128_f32 = (__m256i)0i64;
    *(__m256i *)spring->springConstant.v.m128_f32 = (__m256i)0i64;
    spring->maxOffset = 0i64;
    spring->isLockingSpring = 0;
    *(_QWORD *)&spring->motionIndex = 31i64;
    spring->motionIndexBlendDuration = 0;
    spring->offsetAngles.x = (float4)g_1000.v;
    spring->offsetAngles.y = (float4)g_0100.v;
    spring->offsetAngles.z = (float4)g_0010.v;
    spring->offsetAngles.w = (float4)g_0001.v;
    spring->isInitialized = 1;
  }
}

/*
==============
CG_ViewMotion_ClearCinematicMotionAssets
==============
*/
void CG_ViewMotion_ClearCinematicMotionAssets(void)
{
  s_cgCinematicMotionDefsInitialized = 0;
  memset_0(s_cgCinematicMotionDefs, 0, sizeof(s_cgCinematicMotionDefs));
}

/*
==============
CG_ViewMotion_DebugDrawGraph
==============
*/
void CG_ViewMotion_DebugDrawGraph(const ScreenPlacement *const scrPlace, float drawX, float drawY, const RumbleGraph *const nonLinearGraph, const vec4_t *colorGraph, float normValueX_0, const vec4_t *color0, float normValueX_1, const vec4_t *color1)
{
  __int64 i; 
  float v12; 
  double ValueFromFraction; 
  float v14; 
  float v15; 
  double v16; 
  double v17; 
  __int64 numDataEntries; 
  float data[32]; 

  if ( !nonLinearGraph && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 707, ASSERT_TYPE_ASSERT, "( nonLinearGraph ) != ( nullptr )", "%s != %s\n\t%p, %p", "nonLinearGraph", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( !nonLinearGraph->knotCount )
  {
    LODWORD(numDataEntries) = 0;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 708, ASSERT_TYPE_ASSERT, "( 0 ) < ( nonLinearGraph->knotCount )", "%s < %s\n\t%i, %i", "0", "nonLinearGraph->knotCount", 0i64, numDataEntries) )
      __debugbreak();
  }
  for ( i = 0i64; (unsigned __int64)i < 0x20; ++i )
  {
    v12 = (float)i;
    ValueFromFraction = GraphGetValueFromFraction(nonLinearGraph->knotCount, nonLinearGraph->knots, v12 * 0.032258064);
    data[i] = *(float *)&ValueFromFraction;
  }
  v14 = drawY + 240.0;
  v15 = drawX + 320.0;
  CG_DebugGraphs_DrawAxes(scrPlace, (float)(drawX + 320.0) + graphAdjustX_1, (float)(drawY + 240.0) + graphAdjustY_1, VMMOTION_DEBUG_GRAPH_WIDTH, VMMOTION_DEBUG_GRAPH_HEIGHT, &colorWhite);
  CG_DebugGraphs_DrawGraphData(scrPlace, (float)(drawX + 320.0) + graphAdjustX_1, (float)(drawY + 240.0) + graphAdjustY_1, VMMOTION_DEBUG_GRAPH_WIDTH, VMMOTION_DEBUG_GRAPH_HEIGHT, 0.0, 1.0, data, 0x20u, 0, colorGraph);
  if ( normValueX_0 >= 0.0 && normValueX_0 <= 1.0 )
  {
    v16 = GraphGetValueFromFraction(nonLinearGraph->knotCount, nonLinearGraph->knots, normValueX_0);
    CG_DebugGraphs_DrawGraphDatapoint(scrPlace, v15 + graphAdjustX_1, v14 + graphAdjustY_1, VMMOTION_DEBUG_GRAPH_WIDTH, VMMOTION_DEBUG_GRAPH_HEIGHT, normValueX_0, *(float *)&v16, color0);
  }
  if ( normValueX_1 >= 0.0 && normValueX_1 <= 1.0 )
  {
    v17 = GraphGetValueFromFraction(nonLinearGraph->knotCount, nonLinearGraph->knots, normValueX_1);
    CG_DebugGraphs_DrawGraphDatapoint(scrPlace, v15 + graphAdjustX_1, v14 + graphAdjustY_1, VMMOTION_DEBUG_GRAPH_WIDTH, VMMOTION_DEBUG_GRAPH_HEIGHT, normValueX_1, *(float *)&v17, color1);
  }
}

/*
==============
CG_ViewMotion_Enabled
==============
*/
bool CG_ViewMotion_Enabled(const playerState_s *ps)
{
  bool v2; 
  const dvar_t *v3; 

  v2 = GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&ps->pm_flags, ACTIVE, 5u) && (ps->mantleState.flags & 0x800) != 0;
  v3 = DCONST_DVARMPBOOL_cg_viewmotion_spring_enable;
  if ( !DCONST_DVARMPBOOL_cg_viewmotion_spring_enable && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmotion_spring_enable") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v3);
  return v3->current.enabled && !ps->vehicleAnimState.seat && !v2;
}

/*
==============
CG_ViewMotion_GetCinematicMotionDef
==============
*/
CinematicMotionDef *CG_ViewMotion_GetCinematicMotionDef(unsigned int index)
{
  __int64 v1; 

  v1 = index;
  if ( !s_cgCinematicMotionDefsInitialized )
    return 0i64;
  if ( index >= 0x20 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 523, ASSERT_TYPE_ASSERT, "(unsigned)( index ) < (unsigned)( ( sizeof( *array_counter( s_cgCinematicMotionDefs ) ) + 0 ) )", "index doesn't index ARRAY_COUNT( s_cgCinematicMotionDefs )\n\t%i not in [0, %i)", index, 32) )
    __debugbreak();
  return s_cgCinematicMotionDefs[v1];
}

/*
==============
CG_ViewMotion_GetCinematicMotionIndexForPtr
==============
*/
__int64 CG_ViewMotion_GetCinematicMotionIndexForPtr(const CinematicMotionDef *const def)
{
  __int64 result; 

  if ( !def )
    return 31i64;
  result = 0i64;
  while ( s_cgCinematicMotionDefs[result] != def )
  {
    if ( (unsigned __int64)++result >= 0x20 )
      return 31i64;
  }
  return result;
}

/*
==============
CG_ViewMotion_GetSpringOffset
==============
*/

void __fastcall CG_ViewMotion_GetSpringOffset(const playerState_s *ps, double adsFraction, const ViewMotionSpring *spring, const vec3_t *viewAngles, vec3_t *outLocalOffset, vec3_t *outWorldOffset)
{
  const float4 *v10; 
  float4 *v11; 
  __m128 v12; 
  __m128 v13; 
  __m128 v14; 
  __m128 v; 
  __int128 v18; 
  __m128 v21; 
  const float4 *v22; 
  vector3 *v23; 
  __int128 v25; 

  _RBX = outLocalOffset;
  _RDI = outWorldOffset;
  if ( CG_ViewMotion_Enabled(ps) && spring->isInitialized )
  {
    v12 = _mm128_sub_ps(spring->massPos.v, spring->anchorPos.v);
    v13 = _mm128_sub_ps((__m128)0i64, v12);
    v14 = _mm_shuffle_ps(*(__m128 *)&adsFraction, *(__m128 *)&adsFraction, 0);
    _XMM6 = _mm128_add_ps(_mm128_mul_ps(v13, v14), v12);
    if ( outLocalOffset )
    {
      outLocalOffset->v[0] = _XMM6.m128_f32[0];
      __asm
      {
        vextractps dword ptr [rbx+4], xmm6, 1
        vextractps dword ptr [rbx+8], xmm6, 2
      }
    }
    if ( outWorldOffset )
    {
      v = g_0001.v;
      HIDWORD(v25) = 0;
      v18 = v25;
      *(float *)&v18 = viewAngles->v[0];
      _XMM3 = v18;
      __asm
      {
        vinsertps xmm3, xmm3, dword ptr [rbp+4], 10h
        vinsertps xmm3, xmm3, dword ptr [rbp+8], 20h ; ' '
      }
      v21 = _mm128_mul_ps(_XMM3, g_degreeToRadian.v);
      Float4RadianToQuat(v11, v10);
      Float4UnitQuatToAxis(v23, v22);
      _XMM3 = _mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(_XMM6, _XMM6, 255), v), _mm128_mul_ps(v14, _mm_shuffle_ps(_XMM6, _XMM6, 85))), _mm128_add_ps(_mm128_mul_ps(v13, _mm_shuffle_ps(_XMM6, _XMM6, 170)), _mm128_mul_ps(v21, _mm_shuffle_ps(_XMM6, _XMM6, 0))));
      outWorldOffset->v[0] = _XMM3.m128_f32[0];
      __asm
      {
        vextractps dword ptr [rdi+4], xmm3, 1
        vextractps dword ptr [rdi+8], xmm3, 2
      }
    }
  }
  else
  {
    if ( outLocalOffset )
    {
      *(_QWORD *)outLocalOffset->v = 0i64;
      outLocalOffset->v[2] = 0.0;
    }
    if ( outWorldOffset )
    {
      *(_QWORD *)outWorldOffset->v = 0i64;
      outWorldOffset->v[2] = 0.0;
    }
  }
}

/*
==============
CG_ViewMotion_Impact
==============
*/
void CG_ViewMotion_Impact(const LocalClientNum_t localClientNum, const int time)
{
  cg_t *LocalClientGlobals; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 408, ASSERT_TYPE_ASSERT, "( cgameGlob ) != ( nullptr )", "%s != %s\n\t%p, %p", "cgameGlob", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( (LocalClientGlobals->predictedPlayerState.slideState.flags & 0x20) == 0 && !GameModeFlagContainer<enum PMoveFlagsCommon,enum PMoveFlagsSP,enum PMoveFlagsMP,64>::TestFlagInternal(&LocalClientGlobals->predictedPlayerState.pm_flags, ACTIVE, 0x1Du) )
    LocalClientGlobals->viewSpring.unlockTime = time;
}

/*
==============
CG_ViewMotion_InitCinematicMotionAssets
==============
*/
void CG_ViewMotion_InitCinematicMotionAssets(void)
{
  if ( s_cgCinematicMotionDefsInitialized )
  {
    NetConstStrings_CallForAllCinematicMotionStrings(CG_ViewMotion_Validate_Callback);
  }
  else
  {
    NetConstStrings_CallForAllCinematicMotionStrings(CG_ViewMotion_LoadCache_Callback);
    s_cgCinematicMotionDefsInitialized = 1;
  }
}

/*
==============
CG_ViewMotion_IntegrateSpring
==============
*/
void CG_ViewMotion_IntegrateSpring(int serverTime, const float4 *frametime4, const float4 *anchorVelocityLocal, ViewMotionSpring *springData)
{
  __int128 v4; 
  __m128 v; 
  double v6; 
  __m128 v11; 
  __m128 v12; 
  bool v20; 
  __m128 v21; 
  __m128 v22; 
  __m128 v27; 
  float4 *p_anchorPos; 
  float4 *p_massVelocity; 
  __m128 v37; 
  int v39; 
  __int128 v40; 
  float v44; 
  __m128 v45; 
  __m128 v46; 
  __m128 v47; 
  float4 anchorVelocity; 
  float4 mass; 
  __int128 v56; 

  v = frametime4->v;
  v6 = COERCE_FLOAT(*frametime4);
  if ( v6 < 0.000001 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 83, ASSERT_TYPE_ASSERT, "( 1.0E-6 ) <= ( frametime )", "%s <= %s\n\t%g, %g", "ZERO_EPSILON", "frametime", DOUBLE_9_999999974752427eN7, v6) )
    __debugbreak();
  if ( !springData->isInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 84, ASSERT_TYPE_ASSERT, "(springData.isInitialized)", (const char *)&queryFormat, "springData.isInitialized") )
    __debugbreak();
  v11 = (__m128)LODWORD(FLOAT_1_0);
  v12 = (__m128)LODWORD(FLOAT_1_0);
  v12.m128_f32[0] = 1.0 / v.m128_f32[0];
  _XMM4 = _mm128_mul_ps(_mm_shuffle_ps(v12, v12, 0), springData->velocitySmoothingSec.v);
  __asm { vrcpps  xmm3, xmm4 }
  _XMM3 = _mm128_add_ps(_mm128_mul_ps(_XMM3, anchorVelocityLocal->v), _mm128_sub_ps(springData->anchorVelocitySmooth.v, _mm128_mul_ps(_XMM3, springData->anchorVelocitySmooth.v)));
  __asm
  {
    vcmpleps xmm0, xmm4, xmmword ptr cs:?g_one@@3Ufloat4@@B.v; float4 const g_one
    vblendvps xmm2, xmm3, xmm1, xmm0
    vcmpneqps xmm0, xmm2, xmm2
    vmovmskps eax, xmm0
  }
  springData->anchorVelocitySmooth = (float4)_XMM2.v;
  if ( _EAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 90, ASSERT_TYPE_SANITY, "( !Float4IsNaN( springData.anchorVelocitySmooth ) )", (const char *)&queryFormat, "!Float4IsNaN( springData.anchorVelocitySmooth )") )
    __debugbreak();
  v20 = !springData->isLockingSpring;
  v21 = _mm128_mul_ps(springData->velocityScale.v, springData->anchorVelocitySmooth.v);
  anchorVelocity.v = v21;
  if ( !v20 && unlockDurationMs + unlockDurationBlendOutMs + springData->unlockTime <= serverTime )
    goto LABEL_12;
  v22 = _mm128_sub_ps(springData->massPos.v, springData->anchorPos.v);
  _XMM2 = _mm128_mul_ps(v22, v22);
  __asm
  {
    vinsertps xmm0, xmm2, xmm2, 8
    vhaddps xmm1, xmm0, xmm0
    vhaddps xmm2, xmm1, xmm1
  }
  if ( *(float *)&_XMM2 >= springRestingThreshold )
    goto LABEL_15;
  v27 = _mm128_sub_ps(springData->massVelocity.v, v21);
  _XMM2 = _mm128_mul_ps(v27, v27);
  __asm
  {
    vinsertps xmm0, xmm2, xmm2, 8
    vhaddps xmm1, xmm0, xmm0
    vhaddps xmm2, xmm1, xmm1
  }
  if ( *(float *)&_XMM2 >= springRestingThreshold )
  {
LABEL_15:
    p_anchorPos = &springData->anchorPos;
    _XMM2.v = _mm128_add_ps(_mm128_mul_ps(v21, frametime4->v), springData->anchorPos.v);
    __asm
    {
      vcmpneqps xmm0, xmm2, xmm2
      vmovmskps eax, xmm0
    }
    v56 = v4;
    springData->anchorPos = (float4)_XMM2.v;
    if ( _EAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 127, ASSERT_TYPE_SANITY, "( !Float4IsNaN( springData.anchorPos ) )", (const char *)&queryFormat, "!Float4IsNaN( springData.anchorPos )") )
      __debugbreak();
    p_massVelocity = &springData->massVelocity;
    mass.v = (__m128)_xmm;
    Float4IntegrateDampedSpring(frametime4, &mass, &springData->springConstant, &springData->dampingConstant, &springData->anchorPos, &anchorVelocity, &springData->massPos, &springData->massVelocity);
    v37 = _mm128_sub_ps(springData->massPos.v, p_anchorPos->v);
    _XMM1.v = (__m128)springData->massPos;
    v39 = springData->unlockTime + unlockDurationMs;
    v20 = !springData->isLockingSpring;
    v40 = *(_OWORD *)&v37 & *(_OWORD *)&g_negativeZero.v | _xmm;
    _mm128_mul_ps((__m128)v40, v37);
    _mm128_add_ps(_mm128_mul_ps((__m128)v40, springData->maxOffset.v), p_anchorPos->v);
    _XMM0.v = (__m128)springData->maxOffset;
    __asm
    {
      vcmpleps xmm0, xmm0, xmm4
      vblendvps xmm1, xmm1, xmm2, xmm0
    }
    springData->massPos = (float4)_XMM1.v;
    if ( !v20 && v39 < serverTime )
    {
      v44 = (float)(v39 + unlockDurationBlendOutMs - serverTime) * 0.001;
      if ( v44 > 0.000001 )
      {
        v45.m128_u64[1] = v.m128_u64[1];
        *(double *)v45.m128_u64 = I_fclamp(v.m128_f32[0] / v44, 0.0, 1.0);
        v11 = v45;
      }
      v46 = _mm_shuffle_ps(v11, v11, 0);
      v47 = _mm128_mul_ps(_mm128_sub_ps(v21, p_massVelocity->v), v46);
      springData->massPos.v = _mm128_add_ps(_mm128_mul_ps(_mm128_sub_ps(p_anchorPos->v, springData->massPos.v), v46), springData->massPos.v);
      p_massVelocity->v = _mm128_add_ps(v47, p_massVelocity->v);
    }
    _XMM0.v = (__m128)springData->massPos;
    __asm
    {
      vcmpneqps xmm0, xmm0, xmm0
      vmovmskps eax, xmm0
    }
    if ( _EAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 161, ASSERT_TYPE_SANITY, "( !Float4IsNaN( springData.massPos ) )", (const char *)&queryFormat, "!Float4IsNaN( springData.massPos )") )
      __debugbreak();
    _XMM0 = p_massVelocity->v;
    __asm
    {
      vcmpneqps xmm0, xmm0, xmm0
      vmovmskps eax, xmm0
    }
    if ( _EAX )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 162, ASSERT_TYPE_SANITY, "( !Float4IsNaN( springData.massVelocity ) )", (const char *)&queryFormat, "!Float4IsNaN( springData.massVelocity )") )
        __debugbreak();
    }
  }
  else
  {
LABEL_12:
    springData->massPos = 0i64;
    springData->anchorPos = 0i64;
    springData->massVelocity.v = v21;
  }
}

/*
==============
CG_ViewMotion_LoadCache_Callback
==============
*/
void CG_ViewMotion_LoadCache_Callback(const unsigned int cinematicMotionDefIndex, const char *cinematicMotionName)
{
  CinematicMotionDef *v2; 
  __int64 v3; 

  v2 = NULL;
  v3 = cinematicMotionDefIndex;
  if ( !cinematicMotionName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 488, ASSERT_TYPE_ASSERT, "(cinematicMotionName)", (const char *)&queryFormat, "cinematicMotionName") )
    __debugbreak();
  if ( (unsigned int)v3 >= 0x1F )
    Com_Error_impl(ERR_DROP, (const ObfuscateErrorText)&stru_1442D43B0, 1231i64);
  if ( *cinematicMotionName )
    v2 = CinematicMotion_Register(cinematicMotionName);
  s_cgCinematicMotionDefs[v3] = v2;
}

/*
==============
CG_ViewMotion_LocalOffsetToLocalAngles
==============
*/
void CG_ViewMotion_LocalOffsetToLocalAngles(const playerState_s *ps, const ViewMotionSpring *spring, const vec3_t *localOffset, vec3_t *outLocalAngles)
{
  __int128 v8; 
  __int128 v12; 

  _RBX = outLocalAngles;
  if ( CG_ViewMotion_Enabled(ps) )
  {
    HIDWORD(v12) = 0;
    v8 = v12;
    *(float *)&v8 = localOffset->v[0];
    _XMM5 = v8;
    __asm
    {
      vinsertps xmm5, xmm5, dword ptr [rsi+4], 10h
      vinsertps xmm5, xmm5, dword ptr [rsi+8], 20h ; ' '
    }
    _XMM3 = _mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(_XMM5, _XMM5, 255), spring->offsetAngles.w.v), _mm128_mul_ps(_mm_shuffle_ps(_XMM5, _XMM5, 85), spring->offsetAngles.y.v)), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(_XMM5, _XMM5, 170), spring->offsetAngles.z.v), _mm128_mul_ps(_mm_shuffle_ps(_XMM5, _XMM5, 0), spring->offsetAngles.x.v)));
    _RBX->v[0] = _XMM3.m128_f32[0];
    __asm
    {
      vextractps dword ptr [rbx+4], xmm3, 1
      vextractps dword ptr [rbx+8], xmm3, 2
    }
  }
  else
  {
    *(_QWORD *)_RBX->v = 0i64;
    _RBX->v[2] = 0.0;
  }
}

/*
==============
CG_ViewMotion_MyChanges
==============
*/
void CG_ViewMotion_MyChanges(void)
{
  s_cgCinematicMotionDefsInitialized = 0;
  memset_0(s_cgCinematicMotionDefs, 0, sizeof(s_cgCinematicMotionDefs));
  if ( NetConstStrings_AreStringsLoaded() )
  {
    if ( s_cgCinematicMotionDefsInitialized )
    {
      NetConstStrings_CallForAllCinematicMotionStrings(CG_ViewMotion_Validate_Callback);
    }
    else
    {
      NetConstStrings_CallForAllCinematicMotionStrings(CG_ViewMotion_LoadCache_Callback);
      s_cgCinematicMotionDefsInitialized = 1;
    }
  }
}

/*
==============
CG_ViewMotion_SmoothBlend
==============
*/
void CG_ViewMotion_SmoothBlend(float lerp, float frametime, const float4 *up, float speed, vector4 *prevAxis, vector4 *goalAxis, vector4 *outCurAxis)
{
  __m256i v12; 
  float v17; 
  int v18; 
  __m128 v19; 
  __m128 v20; 
  int v21; 
  unsigned int v22; 
  __int64 v23; 
  __m128 v24; 
  __int64 v25; 
  __m128 v26; 
  double v27; 
  float v28; 
  float v29; 
  const dvar_t *v30; 
  __int128 unsignedInt; 
  __m128 v33; 
  float v38; 
  __m128 v39; 
  __m128 v40; 
  __m128 v42; 
  const float4 *v43; 
  __m128 v46; 
  __m128 v47; 
  __m128 v48; 
  __m128 v49; 
  __m128 v50; 
  __m128 v59; 
  __m128 v64; 
  __m128 v69; 
  float4 v74; 
  __int128 v79; 
  float4 *p_z; 
  __m128 v81; 
  __int128 v90; 
  float4 v92; 
  const float4 *v95; 
  __m128 v98; 
  __m128 v99; 
  __m128 v100; 
  __m128 v101; 
  __m128 v102; 
  __m128 v107; 
  float4 v112; 
  __m128 v113; 
  __m256i v118; 
  float4 v119; 
  float4 v120; 

  _XMM9 = 0i64;
  if ( frametime > 0.0 )
  {
    CG_ViewMotion_AssertFloat3Normalized(&prevAxis->x);
    CG_ViewMotion_AssertFloat3Normalized(&prevAxis->y);
    CG_ViewMotion_AssertFloat3Normalized(&prevAxis->z);
    CG_ViewMotion_AssertFloat3Normalized(&goalAxis->x);
    CG_ViewMotion_AssertFloat3Normalized(&goalAxis->y);
    CG_ViewMotion_AssertFloat3Normalized(&goalAxis->z);
    _XMM1 = _mm128_mul_ps(goalAxis->x.v, prevAxis->x.v);
    __asm
    {
      vinsertps xmm2, xmm1, xmm1, 8
      vhaddps xmm0, xmm2, xmm2
      vhaddps xmm0, xmm0, xmm0; val
    }
    *(double *)_XMM0.m128_u64 = I_fclamp(_XMM0.m128_f32[0], -1.0, 1.0);
    if ( (float)(1.0 - COERCE_FLOAT(_XMM0.m128_i32[0] & _xmm)) < dotEpsilon )
      goto LABEL_22;
    _XMM0.m128_f32[0] = acosf_0(_XMM0.m128_f32[0]);
    v17 = microStepSecInit;
    v18 = (int)(float)(frametime / microStepSecInit);
    v19 = _XMM0;
    v20 = _XMM0;
    if ( microStepMax < v18 )
    {
      v17 = frametime / (float)microStepMax;
      v18 = microStepMax;
    }
    v21 = 0;
    if ( v18 >= 8 )
    {
      v22 = ((unsigned int)(v18 - 8) >> 3) + 1;
      v23 = v22;
      v21 = 8 * v22;
      do
      {
        v24 = v20;
        v24.m128_f32[0] = (float)(v20.m128_f32[0] - (float)((float)(v20.m128_f32[0] * speed) * v17)) - (float)((float)((float)(v20.m128_f32[0] - (float)((float)(v20.m128_f32[0] * speed) * v17)) * speed) * v17);
        v24.m128_f32[0] = (float)(v24.m128_f32[0] - (float)((float)(v24.m128_f32[0] * speed) * v17)) - (float)((float)((float)(v24.m128_f32[0] - (float)((float)(v24.m128_f32[0] * speed) * v17)) * speed) * v17);
        v24.m128_f32[0] = (float)(v24.m128_f32[0] - (float)((float)(v24.m128_f32[0] * speed) * v17)) - (float)((float)((float)(v24.m128_f32[0] - (float)((float)(v24.m128_f32[0] * speed) * v17)) * speed) * v17);
        v24.m128_f32[0] = (float)(v24.m128_f32[0] - (float)((float)(v24.m128_f32[0] * speed) * v17)) - (float)((float)((float)(v24.m128_f32[0] - (float)((float)(v24.m128_f32[0] * speed) * v17)) * speed) * v17);
        v20 = v24;
        --v23;
      }
      while ( v23 );
    }
    if ( v21 < v18 )
    {
      v25 = (unsigned int)(v18 - v21);
      do
      {
        v26 = v20;
        v26.m128_f32[0] = v20.m128_f32[0] - (float)((float)(v20.m128_f32[0] * speed) * v17);
        v20 = v26;
        --v25;
      }
      while ( v25 );
    }
    v27 = I_fclamp(v20.m128_f32[0], 0.0, _XMM0.m128_f32[0]);
    v28 = *(float *)&v27;
    v29 = frametime - (float)((float)v18 * v17);
    if ( v29 >= 0.0 )
      I_fclamp(v28 - (float)((float)(v28 * speed) * v29), 0.0, v19.m128_f32[0]);
    v30 = DCONST_DVARFLT_smoothClampAngle;
    if ( !DCONST_DVARFLT_smoothClampAngle && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 720, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "smoothClampAngle") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v30);
    unsignedInt = v30->current.unsignedInt;
    *(float *)&unsignedInt = v30->current.value * 0.017453292;
    _XMM7 = unsignedInt;
    v33 = _mm128_sub_ps(_mm128_mul_ps(_mm_shuffle_ps(prevAxis->x.v, prevAxis->x.v, 201), _mm_shuffle_ps(goalAxis->x.v, goalAxis->x.v, 210)), _mm128_mul_ps(_mm_shuffle_ps(prevAxis->x.v, prevAxis->x.v, 210), _mm_shuffle_ps(goalAxis->x.v, goalAxis->x.v, 201)));
    _XMM1 = _mm128_mul_ps(v33, v33);
    __asm
    {
      vinsertps xmm0, xmm1, xmm1, 8
      vhaddps xmm2, xmm0, xmm0
      vhaddps xmm0, xmm2, xmm2
    }
    v38 = _mm_sqrt_ps(_XMM0).m128_f32[0];
    if ( v38 <= 0.000001 )
    {
LABEL_22:
      v118 = *(__m256i *)goalAxis->z.v.m128_f32;
      *(__m256i *)outCurAxis->x.v.m128_f32 = *(__m256i *)goalAxis->x.v.m128_f32;
      *(__m256i *)outCurAxis->z.v.m128_f32 = v118;
    }
    else
    {
      v39 = (__m128)LODWORD(FLOAT_1_0);
      v39.m128_f32[0] = 1.0 / v38;
      v40 = _mm128_mul_ps(_mm_shuffle_ps(v39, v39, 0), v33);
      v119.v = v40;
      CG_ViewMotion_AssertFloat3Normalized(&v119);
      __asm { vminss  xmm0, xmm7, xmm10 }
      v42 = v19;
      v42.m128_f32[0] = (float)((float)(v19.m128_f32[0] - *(float *)&_XMM0) * lerp) + (float)((float)(1.0 - lerp) * v19.m128_f32[0]);
      _mm128_mul_ps(_mm_shuffle_ps(v42, v42, 0), g_oneHalf.v);
      Float4SinCos(v43, &v119, &v120);
      _XMM1 = _mm128_mul_ps(v40, v119.v);
      __asm { vblendps xmm2, xmm1, [rsp+108h+var_B8], arg_0 }
      v46 = _mm_shuffle_ps(_XMM2, _XMM2, 201);
      v47 = _mm_shuffle_ps(_XMM2, _XMM2, 210);
      v48 = _mm128_sub_ps(_mm128_mul_ps(_mm_shuffle_ps(prevAxis->x.v, prevAxis->x.v, 210), v46), _mm128_mul_ps(_mm_shuffle_ps(prevAxis->x.v, prevAxis->x.v, 201), v47));
      v49 = _mm128_add_ps(v48, v48);
      v50 = _mm128_add_ps(_mm128_sub_ps(_mm128_mul_ps(_mm_shuffle_ps(v49, v49, 210), v46), _mm128_mul_ps(_mm_shuffle_ps(v49, v49, 201), v47)), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(_XMM2, _XMM2, 255), v49), prevAxis->x.v));
      _XMM0 = _mm128_mul_ps(v50, v50);
      __asm
      {
        vinsertps xmm1, xmm0, xmm0, 8
        vhaddps xmm2, xmm1, xmm1
        vhaddps xmm0, xmm2, xmm2
      }
      outCurAxis->x.v = _mm128_div_ps(v50, _mm_sqrt_ps(_XMM0));
      CG_ViewMotion_AssertFloat3Normalized(&outCurAxis->x);
      CG_ViewMotion_AssertFloat3Normalized(&outCurAxis->x);
      _XMM1 = _mm128_mul_ps(up->v, goalAxis->x.v);
      __asm
      {
        vinsertps xmm2, xmm1, xmm1, 8
        vhaddps xmm0, xmm2, xmm2
        vhaddps xmm0, xmm0, xmm0
      }
      v59 = _mm128_add_ps(_mm128_mul_ps(_mm128_sub_ps((__m128)0i64, _XMM0), goalAxis->x.v), up->v);
      _XMM0 = _mm128_mul_ps(v59, v59);
      __asm
      {
        vinsertps xmm1, xmm0, xmm0, 8
        vhaddps xmm2, xmm1, xmm1
        vhaddps xmm0, xmm2, xmm2
      }
      v64 = _mm128_div_ps(v59, _mm_sqrt_ps(_XMM0));
      _XMM1 = _mm128_mul_ps(up->v, outCurAxis->x.v);
      __asm
      {
        vinsertps xmm2, xmm1, xmm1, 8
        vhaddps xmm0, xmm2, xmm2
        vhaddps xmm0, xmm0, xmm0
      }
      v69 = _mm128_add_ps(_mm128_mul_ps(_mm128_sub_ps((__m128)0i64, _XMM0), outCurAxis->x.v), up->v);
      _XMM0 = _mm128_mul_ps(v69, v69);
      __asm
      {
        vinsertps xmm1, xmm0, xmm0, 8
        vhaddps xmm2, xmm1, xmm1
        vhaddps xmm0, xmm2, xmm2
      }
      v74.v = _mm128_div_ps(v69, _mm_sqrt_ps(_XMM0));
      _XMM2 = _mm128_mul_ps(v64, goalAxis->z.v);
      __asm
      {
        vinsertps xmm3, xmm2, xmm2, 8
        vhaddps xmm0, xmm3, xmm3
        vhaddps xmm0, xmm0, xmm0; val
      }
      *(double *)&_XMM0 = I_fclamp(*(float *)&_XMM0, -1.0, 1.0);
      v79 = _XMM0;
      if ( (float)(1.0 - dotEpsilon) > COERCE_FLOAT(_XMM0 & _xmm) )
      {
        v81 = _mm128_sub_ps(_mm128_mul_ps(_mm_shuffle_ps(goalAxis->z.v, goalAxis->z.v, 201), _mm_shuffle_ps(v64, v64, 210)), _mm128_mul_ps(_mm_shuffle_ps(goalAxis->z.v, goalAxis->z.v, 210), _mm_shuffle_ps(v64, v64, 201)));
        _XMM1 = _mm128_mul_ps(v81, v81);
        __asm
        {
          vinsertps xmm0, xmm1, xmm1, 8
          vhaddps xmm2, xmm0, xmm0
          vhaddps xmm0, xmm2, xmm2
        }
        _XMM1 = _mm128_mul_ps(_mm128_div_ps(v81, _mm_sqrt_ps(_XMM0)), goalAxis->x.v);
        __asm
        {
          vinsertps xmm2, xmm1, xmm1, 8
          vhaddps xmm0, xmm2, xmm2
          vhaddps xmm6, xmm0, xmm0
        }
        v90 = v79;
        *(float *)&v90 = acosf_0(*(float *)&v79);
        _XMM2 = v90 ^ _xmm;
        v92.v = (__m128)outCurAxis->x;
        __asm
        {
          vcmpless xmm1, xmm9, xmm6
          vblendvps xmm0, xmm2, xmm0, xmm1
        }
        _mm128_mul_ps(_mm_shuffle_ps((__m128)(_XMM0 ^ _xmm), (__m128)(_XMM0 ^ _xmm), 0), g_oneHalf.v);
        Float4SinCos(v95, &v120, &v119);
        _XMM1 = _mm128_mul_ps(v92.v, v120.v);
        __asm { vblendps xmm2, xmm1, xmmword ptr [rsp+108h+var_C8.v], arg_0 }
        v98 = _mm_shuffle_ps(_XMM2, _XMM2, 201);
        v99 = _mm_shuffle_ps(_XMM2, _XMM2, 210);
        v100 = _mm128_sub_ps(_mm128_mul_ps(_mm_shuffle_ps(v74.v, v74.v, 210), v98), _mm128_mul_ps(_mm_shuffle_ps(v74.v, v74.v, 201), v99));
        v101 = _mm128_add_ps(v100, v100);
        v102 = _mm128_add_ps(_mm128_sub_ps(_mm128_mul_ps(_mm_shuffle_ps(v101, v101, 210), v98), _mm128_mul_ps(_mm_shuffle_ps(v101, v101, 201), v99)), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(_XMM2, _XMM2, 255), v101), v74.v));
        _XMM0 = _mm128_mul_ps(v102, v102);
        __asm
        {
          vinsertps xmm1, xmm0, xmm0, 8
          vhaddps xmm2, xmm1, xmm1
          vhaddps xmm0, xmm2, xmm2
        }
        p_z = &outCurAxis->z;
        outCurAxis->z.v = _mm128_div_ps(v102, _mm_sqrt_ps(_XMM0));
      }
      else
      {
        p_z = &outCurAxis->z;
        outCurAxis->z = (float4)v74.v;
      }
      CG_ViewMotion_AssertFloat3Normalized(p_z);
      v107 = _mm128_sub_ps(_mm128_mul_ps(_mm_shuffle_ps(p_z->v, p_z->v, 201), _mm_shuffle_ps(outCurAxis->x.v, outCurAxis->x.v, 210)), _mm128_mul_ps(_mm_shuffle_ps(p_z->v, p_z->v, 210), _mm_shuffle_ps(outCurAxis->x.v, outCurAxis->x.v, 201)));
      _XMM0 = _mm128_mul_ps(v107, v107);
      __asm
      {
        vinsertps xmm1, xmm0, xmm0, 8
        vhaddps xmm2, xmm1, xmm1
        vhaddps xmm0, xmm2, xmm2
      }
      v112.v = _mm128_div_ps(v107, _mm_sqrt_ps(_XMM0));
      v113 = _mm128_sub_ps(_mm128_mul_ps(_mm_shuffle_ps(outCurAxis->x.v, outCurAxis->x.v, 201), _mm_shuffle_ps(v112.v, v112.v, 210)), _mm128_mul_ps(_mm_shuffle_ps(outCurAxis->x.v, outCurAxis->x.v, 210), _mm_shuffle_ps(v112.v, v112.v, 201)));
      _XMM0 = _mm128_mul_ps(v113, v113);
      __asm
      {
        vinsertps xmm1, xmm0, xmm0, 8
        vhaddps xmm2, xmm1, xmm1
        vhaddps xmm0, xmm2, xmm2
      }
      p_z->v = _mm128_div_ps(v113, _mm_sqrt_ps(_XMM0));
      outCurAxis->y = (float4)v112.v;
      CG_ViewMotion_AssertFloat3Normalized(&outCurAxis->x);
      CG_ViewMotion_AssertFloat3Normalized(&outCurAxis->y);
      CG_ViewMotion_AssertFloat3Normalized(p_z);
    }
  }
  else
  {
    v12 = *(__m256i *)prevAxis->z.v.m128_f32;
    *(__m256i *)outCurAxis->x.v.m128_f32 = *(__m256i *)prevAxis->x.v.m128_f32;
    *(__m256i *)outCurAxis->z.v.m128_f32 = v12;
  }
}

/*
==============
CG_ViewMotion_Update
==============
*/

void __fastcall CG_ViewMotion_Update(const LocalClientNum_t localClientNum, __int64 a2, double a3)
{
  cg_t *LocalClientGlobals; 
  float v4; 
  __m128 v; 
  const float4 *v9; 
  float4 *v10; 
  __m128 v11; 
  __m128 v12; 
  __m128 v13; 
  __m128 v15; 
  __m128 v16; 
  __m128 v18; 
  float v20; 
  __m128 v21; 
  __m128 v22; 
  __m128 v24; 
  __m128 v27; 
  const float4 *v28; 
  vector3 *v29; 
  __m128 v30; 
  __m128 v31; 
  __m128 v32; 
  __m128 v33; 
  float4 frametime4; 
  float4 curPsOrigin; 

  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 339, ASSERT_TYPE_ASSERT, "( cgameGlob ) != ( nullptr )", "%s != %s\n\t%p, %p", "cgameGlob", "nullptr", NULL, NULL) )
    __debugbreak();
  if ( CG_ViewMotion_Enabled(&LocalClientGlobals->predictedPlayerState) )
  {
    v4 = LocalClientGlobals->predictedPlayerState.origin.v[0];
    curPsOrigin.v.m128_i32[3] = 0;
    v = curPsOrigin.v;
    v.m128_f32[0] = v4;
    _XMM12 = v;
    __asm
    {
      vinsertps xmm12, xmm12, dword ptr [rbx+3Ch], 10h
      vinsertps xmm12, xmm12, dword ptr [rbx+40h], 20h ; ' '
    }
    curPsOrigin.v = _XMM12;
    if ( GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&LocalClientGlobals->predictedPlayerState.otherFlags, ACTIVE, 0x1Fu) || GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&LocalClientGlobals->predictedPlayerState.otherFlags, ACTIVE, 0x20u) || LocalClientGlobals->predictedPlayerState.pm_type == 5 && !GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&LocalClientGlobals->predictedPlayerState.otherFlags, GameModeFlagValues::ms_mpValue, 0x21u) )
    {
      *(__m256i *)LocalClientGlobals->viewSpring.springConstant.v.m128_f32 = (__m256i)0i64;
      *(__m256i *)LocalClientGlobals->viewSpring.velocitySmoothingSec.v.m128_f32 = (__m256i)0i64;
      LocalClientGlobals->viewSpring.prevPsOrigin.v = _XMM12;
      *(_QWORD *)&LocalClientGlobals->viewSpring.motionIndexBlendDuration = 0i64;
      *(__m256i *)LocalClientGlobals->viewSpring.anchorPos.v.m128_f32 = (__m256i)0i64;
      *(__m256i *)LocalClientGlobals->viewSpring.massPos.v.m128_f32 = (__m256i)0i64;
      LocalClientGlobals->viewSpring.maxOffset = 0i64;
      LocalClientGlobals->viewSpring.isLockingSpring = 0;
      *(_QWORD *)&LocalClientGlobals->viewSpring.motionIndex = 31i64;
      LocalClientGlobals->viewSpring.offsetAngles.x = (float4)g_1000.v;
      LocalClientGlobals->viewSpring.offsetAngles.y = (float4)g_0100.v;
      LocalClientGlobals->viewSpring.offsetAngles.z = (float4)g_0010.v;
      LocalClientGlobals->viewSpring.offsetAngles.w = (float4)g_0001.v;
      LocalClientGlobals->viewSpring.isInitialized = 1;
      *(__m256i *)LocalClientGlobals->viewmodelSpring.massPos.v.m128_f32 = (__m256i)0i64;
      *(__m256i *)LocalClientGlobals->viewmodelSpring.anchorPos.v.m128_f32 = (__m256i)0i64;
      *(_QWORD *)&LocalClientGlobals->viewmodelSpring.motionIndexBlendDuration = 0i64;
      LocalClientGlobals->viewmodelSpring.prevPsOrigin.v = _XMM12;
      *(__m256i *)LocalClientGlobals->viewmodelSpring.velocitySmoothingSec.v.m128_f32 = (__m256i)0i64;
      *(__m256i *)LocalClientGlobals->viewmodelSpring.springConstant.v.m128_f32 = (__m256i)0i64;
      LocalClientGlobals->viewmodelSpring.maxOffset = 0i64;
      LocalClientGlobals->viewmodelSpring.isLockingSpring = 0;
      *(_QWORD *)&LocalClientGlobals->viewmodelSpring.motionIndex = 31i64;
      LocalClientGlobals->viewmodelSpring.offsetAngles.x = (float4)g_1000.v;
      LocalClientGlobals->viewmodelSpring.offsetAngles.y = (float4)g_0100.v;
      LocalClientGlobals->viewmodelSpring.offsetAngles.z = (float4)g_0010.v;
      LocalClientGlobals->viewmodelSpring.offsetAngles.w = (float4)g_0001.v;
      LocalClientGlobals->viewmodelSpring.isInitialized = 1;
    }
    else
    {
      CG_ViewMotion_CheckSpringTeleport(LocalClientGlobals, &curPsOrigin, &LocalClientGlobals->viewSpring);
      CG_ViewMotion_CheckSpringTeleport(LocalClientGlobals, &curPsOrigin, &LocalClientGlobals->viewmodelSpring);
      CG_ViewMotion_UpdateSpringControls(LocalClientGlobals, 1, &LocalClientGlobals->viewSpring);
      CG_ViewMotion_UpdateSpringControls(LocalClientGlobals, 0, &LocalClientGlobals->viewmodelSpring);
      if ( !LocalClientGlobals && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 168, ASSERT_TYPE_ASSERT, "( cgameGlob ) != ( nullptr )", "%s != %s\n\t%p, %p", "cgameGlob", "nullptr", NULL, NULL) )
        __debugbreak();
      if ( BG_IsPlayerLinked(&LocalClientGlobals->predictedPlayerState) )
      {
        v11 = 0i64;
        v11.m128_f32[0] = (float)LocalClientGlobals->frametime * 0.001;
        v12 = v11;
        *(double *)v11.m128_u64 = v11.m128_f32[0];
        v13 = v11;
        if ( *(double *)v11.m128_u64 > 0.000001 )
        {
          *(__m128 *)&a3 = _mm128_sub_ps(_XMM12, LocalClientGlobals->viewSpring.prevPsOrigin.v);
          v15 = (__m128)LODWORD(FLOAT_1_0);
          v15.m128_f32[0] = 1.0 / v12.m128_f32[0];
          v13 = _mm_shuffle_ps(v15, v15, 0);
          _XMM10 = _mm128_mul_ps(*(__m128 *)&a3, v13);
        }
        else
        {
          _XMM10 = 0i64;
        }
      }
      else
      {
        v13 = (__m128)LODWORD(LocalClientGlobals->predictedPlayerState.velocity.v[0]);
        v16 = 0i64;
        v16.m128_f32[0] = (float)cls.frametime * 0.001;
        v12 = v16;
        curPsOrigin.v.m128_i32[3] = 0;
        v18 = curPsOrigin.v;
        v18.m128_f32[0] = v13.m128_f32[0];
        _XMM10 = v18;
        __asm
        {
          vinsertps xmm10, xmm10, dword ptr [rbx+48h], 10h
          vinsertps xmm10, xmm10, dword ptr [rbx+4Ch], 20h ; ' '
        }
        curPsOrigin.v = _XMM10;
      }
      v20 = LocalClientGlobals->predictedPlayerState.viewangles.v[0];
      v21 = g_0001.v;
      v22 = v12;
      curPsOrigin.v.m128_i32[3] = 0;
      v24 = curPsOrigin.v;
      v24.m128_f32[0] = v20;
      _XMM3 = v24;
      __asm
      {
        vinsertps xmm3, xmm3, dword ptr [rbx+1E4h], 10h
        vinsertps xmm3, xmm3, dword ptr [rbx+1E8h], 20h ; ' '
      }
      v27 = _mm128_mul_ps(_XMM3, g_degreeToRadian.v);
      frametime4.v = _mm_shuffle_ps(v22, v22, 0);
      curPsOrigin.v = _XMM3;
      Float4RadianToQuat(v10, v9);
      Float4UnitQuatToAxis(v29, v28);
      v30 = _mm_shuffle_ps(v27, v13, 68);
      v31 = _mm_shuffle_ps(v27, v13, 238);
      v32 = _mm_shuffle_ps(*(__m128 *)&a3, v21, 68);
      v33 = _mm_shuffle_ps(*(__m128 *)&a3, v21, 238);
      curPsOrigin.v = _mm128_add_ps(_mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(_XMM10, _XMM10, 255), _mm_shuffle_ps(v31, v33, 221)), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(_XMM10, _XMM10, 85), _mm_shuffle_ps(v30, v32, 221)), g_negativeZero.v)), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(_XMM10, _XMM10, 170), _mm_shuffle_ps(v31, v33, 136)), _mm128_add_ps(_mm128_mul_ps(_mm_shuffle_ps(_XMM10, _XMM10, 0), _mm_shuffle_ps(v30, v32, 136)), g_negativeZero.v)));
      if ( frametime4.v.m128_f32[0] > 0.000001 )
      {
        CG_ViewMotion_IntegrateSpring(LocalClientGlobals->time, &frametime4, &curPsOrigin, &LocalClientGlobals->viewSpring);
        CG_ViewMotion_IntegrateSpring(LocalClientGlobals->time, &frametime4, &curPsOrigin, &LocalClientGlobals->viewmodelSpring);
      }
      LocalClientGlobals->viewSpring.prevPsOrigin.v = _XMM12;
      LocalClientGlobals->viewmodelSpring.prevPsOrigin.v = _XMM12;
    }
  }
}

/*
==============
CG_ViewMotion_UpdateSpringControls
==============
*/
void CG_ViewMotion_UpdateSpringControls(const cg_t *const cgameGlob, bool isCameraSpring, ViewMotionSpring *spring)
{
  int integer; 
  __int64 localClientNum; 
  CinematicMotionDef *CinematicMotionDef; 
  CinematicMotionDef *v8; 
  __int64 v9; 
  const CinematicMotionDef *v10; 
  unsigned int cinematicMotionOverride; 
  unsigned int motionIndex; 
  const dvar_t *v13; 
  bool v17; 
  __int128 v24; 
  __m128 v27; 
  __m128 v30; 
  __m128 v33; 
  __m128 v36; 
  __int128 v39; 
  __m128 v42; 
  __m128 v45; 
  __m128 v48; 
  __m128 v51; 
  __m128 v54; 
  __m128 v57; 
  __m128 v60; 
  int v62; 
  int time; 
  int v64; 
  __m128 v65; 
  __m128 v66; 
  __m128 v67; 
  float4 v68; 
  __m128 v69; 
  __int64 v70; 
  __int64 v71; 
  __m256i v73; 
  __m256i v74; 
  __int128 v75; 
  __m128 v; 
  __m128 v77; 
  __m128 v78; 
  __m128 v79; 
  __m128 v80; 
  __m128 v81; 
  __m128 v82; 
  __m128 v83; 
  __m128 v84; 
  __m128 v85; 
  __m128 v86; 

  integer = 0;
  if ( !cgameGlob && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 227, ASSERT_TYPE_ASSERT, "( cgameGlob ) != ( nullptr )", "%s != %s\n\t%p, %p", "cgameGlob", "nullptr", NULL, NULL) )
    __debugbreak();
  localClientNum = cgameGlob->localClientNum;
  if ( !CgWeaponMap::ms_instance[localClientNum] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  CinematicMotionDef = (CinematicMotionDef *)BG_Suit_GetCinematicMotionDef(&cgameGlob->predictedPlayerState, CgWeaponMap::ms_instance[localClientNum]);
  v8 = CinematicMotionDef;
  if ( CinematicMotionDef )
  {
    v9 = 0i64;
    while ( s_cgCinematicMotionDefs[v9] != CinematicMotionDef )
    {
      if ( (unsigned __int64)++v9 >= 0x20 )
        goto LABEL_11;
    }
  }
  else
  {
LABEL_11:
    LODWORD(v9) = 31;
  }
  v10 = CG_Skydive_GetCinematicMotionDef((const LocalClientNum_t)cgameGlob->localClientNum, &cgameGlob->predictedPlayerState);
  if ( v10 )
  {
    if ( v8 )
    {
      v9 = 0i64;
      while ( s_cgCinematicMotionDefs[v9] != v8 )
      {
        if ( (unsigned __int64)++v9 >= 0x20 )
        {
          LODWORD(v9) = 31;
          v8 = (CinematicMotionDef *)v10;
          goto LABEL_25;
        }
      }
      v8 = (CinematicMotionDef *)v10;
    }
    else
    {
      LODWORD(v9) = 31;
      v8 = (CinematicMotionDef *)v10;
    }
  }
  else
  {
    cinematicMotionOverride = cgameGlob->predictedPlayerState.cinematicMotionOverride;
    if ( cinematicMotionOverride != 31 )
    {
      v9 = cinematicMotionOverride;
      if ( cinematicMotionOverride >= 0x20 )
      {
        LODWORD(v71) = 32;
        LODWORD(v70) = cgameGlob->predictedPlayerState.cinematicMotionOverride;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 244, ASSERT_TYPE_ASSERT, "(unsigned)( motionIndex ) < (unsigned)( ( sizeof( *array_counter( s_cgCinematicMotionDefs ) ) + 0 ) )", "motionIndex doesn't index ARRAY_COUNT( s_cgCinematicMotionDefs )\n\t%i not in [0, %i)", v70, v71) )
          __debugbreak();
      }
      v8 = s_cgCinematicMotionDefs[v9];
    }
  }
LABEL_25:
  if ( (_DWORD)v9 != 31 && !s_cgCinematicMotionDefsInitialized && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 251, ASSERT_TYPE_ASSERT, "(s_cgCinematicMotionDefsInitialized)", "%s\n\tAttempting to locate a Cinematic Motion asset def by index, but NetConstStrings have not yet been processed for this asset.", "s_cgCinematicMotionDefsInitialized") )
    __debugbreak();
  motionIndex = spring->motionIndex;
  if ( (_DWORD)v9 != motionIndex )
  {
    spring->motionIndex = v9;
    spring->motionIndexBlendTime = cgameGlob->time;
    if ( motionIndex != 31 )
    {
      v13 = DCONST_DVARMPINT_cg_viewmotion_spring_blendDurationMs;
      if ( !DCONST_DVARMPINT_cg_viewmotion_spring_blendDurationMs && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 699, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "cg_viewmotion_spring_blendDurationMs") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v13);
      integer = v13->current.integer;
    }
    spring->motionIndexBlendDuration = integer;
  }
  _XMM11 = g_1000.v;
  _XMM12 = g_0100.v;
  _XMM13 = g_0010.v;
  v17 = 0;
  _XMM6.v = 0i64;
  _XMM7.v = 0i64;
  _XMM8.v = 0i64;
  _XMM9.v = 0i64;
  _XMM10.v = 0i64;
  *(float4 *)v73.m256i_i8 = (float4)g_1000.v;
  *(float4 *)&v73.m256i_u64[2] = (float4)g_0100.v;
  *(float4 *)v74.m256i_i8 = (float4)g_0010.v;
  *(float4 *)&v74.m256i_u64[2] = (float4)g_0001.v;
  if ( v8 )
  {
    HIDWORD(v75) = 0;
    if ( isCameraSpring )
    {
      v24 = v75;
      *(float *)&v24 = v8->camera_spring_velocitySmoothingSec.v[0];
      _XMM6 = v24;
      __asm
      {
        vinsertps xmm6, xmm6, dword ptr [rdi+0Ch], 10h
        vinsertps xmm6, xmm6, dword ptr [rdi+10h], 20h ; ' '
      }
      v = _XMM6.v;
      v.m128_i32[3] = 0;
      v27 = v;
      v27.m128_f32[0] = v8->camera_spring_velocityScale.v[0];
      _XMM7 = v27;
      __asm
      {
        vinsertps xmm7, xmm7, dword ptr [rdi+18h], 10h
        vinsertps xmm7, xmm7, dword ptr [rdi+1Ch], 20h ; ' '
      }
      v77 = _XMM7.v;
      v77.m128_i32[3] = 0;
      v30 = v77;
      v30.m128_f32[0] = v8->camera_spring_springConstant.v[0];
      _XMM8 = v30;
      __asm
      {
        vinsertps xmm8, xmm8, dword ptr [rdi+24h], 10h
        vinsertps xmm8, xmm8, dword ptr [rdi+28h], 20h ; ' '
      }
      v78 = _XMM8.v;
      v78.m128_i32[3] = 0;
      v33 = v78;
      v33.m128_f32[0] = v8->camera_spring_damperConstant.v[0];
      _XMM9 = v33;
      __asm
      {
        vinsertps xmm9, xmm9, dword ptr [rdi+30h], 10h
        vinsertps xmm9, xmm9, dword ptr [rdi+34h], 20h ; ' '
      }
      v79 = _XMM9.v;
      v79.m128_i32[3] = 0;
      v36 = v79;
      v36.m128_f32[0] = v8->camera_spring_maxOffset.v[0];
      _XMM10 = v36;
      __asm
      {
        vinsertps xmm10, xmm10, dword ptr [rdi+3Ch], 10h
        vinsertps xmm10, xmm10, dword ptr [rdi+40h], 20h ; ' '
      }
      v17 = !BG_IsPlayerLinked(&cgameGlob->predictedPlayerState);
    }
    else
    {
      v39 = v75;
      *(float *)&v39 = v8->viewmodel_spring_velocitySmoothingSec.v[0];
      _XMM6 = v39;
      __asm
      {
        vinsertps xmm6, xmm6, dword ptr [rdi+48h], 10h
        vinsertps xmm6, xmm6, dword ptr [rdi+4Ch], 20h ; ' '
      }
      v80 = _XMM6.v;
      v80.m128_i32[3] = 0;
      v17 = 0;
      v42 = v80;
      v42.m128_f32[0] = v8->viewmodel_spring_velocityScale.v[0];
      _XMM7 = v42;
      __asm
      {
        vinsertps xmm7, xmm7, dword ptr [rdi+54h], 10h
        vinsertps xmm7, xmm7, dword ptr [rdi+58h], 20h ; ' '
      }
      v81 = _XMM7.v;
      v81.m128_i32[3] = 0;
      v45 = v81;
      v45.m128_f32[0] = v8->viewmodel_spring_springConstant.v[0];
      _XMM8 = v45;
      __asm
      {
        vinsertps xmm8, xmm8, dword ptr [rdi+60h], 10h
        vinsertps xmm8, xmm8, dword ptr [rdi+64h], 20h ; ' '
      }
      v82 = _XMM8.v;
      v82.m128_i32[3] = 0;
      v48 = v82;
      v48.m128_f32[0] = v8->viewmodel_spring_damperConstant.v[0];
      _XMM9 = v48;
      __asm
      {
        vinsertps xmm9, xmm9, dword ptr [rdi+6Ch], 10h
        vinsertps xmm9, xmm9, dword ptr [rdi+70h], 20h ; ' '
      }
      v83 = _XMM9.v;
      v83.m128_i32[3] = 0;
      v51 = v83;
      v51.m128_f32[0] = v8->viewmodel_spring_maxOffset.v[0];
      _XMM10 = v51;
      __asm
      {
        vinsertps xmm10, xmm10, dword ptr [rdi+78h], 10h
        vinsertps xmm10, xmm10, dword ptr [rdi+7Ch], 20h ; ' '
      }
      v84 = _XMM10.v;
      v84.m128_i32[3] = 0;
      v54 = v84;
      v54.m128_f32[0] = v8->viewmodel_spring_offsetToAnglesX.v[0];
      _XMM11 = v54;
      __asm
      {
        vinsertps xmm11, xmm11, dword ptr [rdi+84h], 10h
        vinsertps xmm11, xmm11, dword ptr [rdi+88h], 20h ; ' '
      }
      v85 = _XMM11;
      v85.m128_i32[3] = 0;
      v57 = v85;
      v57.m128_f32[0] = v8->viewmodel_spring_offsetToAnglesY.v[0];
      _XMM12 = v57;
      __asm
      {
        vinsertps xmm12, xmm12, dword ptr [rdi+90h], 10h
        vinsertps xmm12, xmm12, dword ptr [rdi+94h], 20h ; ' '
      }
      v86 = _XMM12;
      v86.m128_i32[3] = 0;
      v60 = v86;
      v60.m128_f32[0] = v8->viewmodel_spring_offsetToAnglesZ.v[0];
      _XMM13 = v60;
      __asm
      {
        vinsertps xmm13, xmm13, dword ptr [rdi+9Ch], 10h
        vinsertps xmm13, xmm13, dword ptr [rdi+0A0h], 20h ; ' '
      }
      *(__m128 *)v74.m256i_i8 = _XMM13;
      *(__m128 *)v73.m256i_i8 = _XMM11;
      *(__m128 *)&v73.m256i_u64[2] = _XMM12;
    }
  }
  v62 = spring->motionIndexBlendTime + spring->motionIndexBlendDuration;
  time = cgameGlob->time;
  if ( time >= v62 )
  {
    *(__m256i *)spring->offsetAngles.x.v.m128_f32 = v73;
    *(__m256i *)spring->offsetAngles.z.v.m128_f32 = v74;
    spring->velocitySmoothingSec = (float4)_XMM6.v;
    spring->velocityScale = (float4)_XMM7.v;
    spring->springConstant = (float4)_XMM8.v;
    spring->dampingConstant = (float4)_XMM9.v;
    spring->maxOffset = (float4)_XMM10.v;
  }
  else
  {
    v64 = v62 - time;
    if ( v64 > 0 )
    {
      v65.m128_u64[1] = 0i64;
      *(double *)v65.m128_u64 = I_fclamp((float)cgameGlob->frametime / (float)v64, 0.0, 1.0);
    }
    else
    {
      v65 = (__m128)LODWORD(FLOAT_1_0);
    }
    v66 = _mm_shuffle_ps(v65, v65, 0);
    v67 = _mm128_sub_ps(_XMM7.v, spring->velocityScale.v);
    spring->velocitySmoothingSec.v = _mm128_add_ps(_mm128_mul_ps(_mm128_sub_ps(_XMM6.v, spring->velocitySmoothingSec.v), v66), spring->velocitySmoothingSec.v);
    v68.v = _mm128_add_ps(_mm128_mul_ps(v67, v66), spring->velocityScale.v);
    v69 = _mm128_sub_ps(_XMM8.v, spring->springConstant.v);
    spring->velocityScale = (float4)v68.v;
    spring->springConstant.v = _mm128_add_ps(_mm128_mul_ps(v69, v66), spring->springConstant.v);
    spring->dampingConstant.v = _mm128_add_ps(_mm128_mul_ps(_mm128_sub_ps(_XMM9.v, spring->dampingConstant.v), v66), spring->dampingConstant.v);
    spring->maxOffset.v = _mm128_add_ps(_mm128_mul_ps(_mm128_sub_ps(_XMM10.v, spring->maxOffset.v), v66), spring->maxOffset.v);
    spring->offsetAngles.x.v = _mm128_add_ps(_mm128_mul_ps(_mm128_sub_ps(_XMM11, spring->offsetAngles.x.v), v66), spring->offsetAngles.x.v);
    spring->offsetAngles.y.v = _mm128_add_ps(_mm128_mul_ps(_mm128_sub_ps(_XMM12, spring->offsetAngles.y.v), v66), spring->offsetAngles.y.v);
    spring->offsetAngles.z.v = _mm128_add_ps(_mm128_mul_ps(_mm128_sub_ps(_XMM13, spring->offsetAngles.z.v), v66), spring->offsetAngles.z.v);
  }
  spring->isLockingSpring = v17;
}

/*
==============
CG_ViewMotion_Validate_Callback
==============
*/
void CG_ViewMotion_Validate_Callback(const unsigned int cinematicMotionDefIndex, const char *cinematicMotionName)
{
  __int64 v2; 
  const char *v3; 
  CinematicMotionDef **v4; 
  __int64 v5; 
  const char *name; 
  signed __int64 v7; 
  int v8; 
  __int64 v9; 
  int v10; 
  int v11; 
  int v12; 
  __int64 v13; 

  v2 = cinematicMotionDefIndex;
  v3 = cinematicMotionName;
  if ( !cinematicMotionName && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 507, ASSERT_TYPE_ASSERT, "(cinematicMotionName)", (const char *)&queryFormat, "cinematicMotionName") )
    __debugbreak();
  if ( (unsigned int)v2 >= 0x1F )
  {
    LODWORD(v13) = v2;
    if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 508, ASSERT_TYPE_ASSERT, "(unsigned)( cinematicMotionDefIndex ) < (unsigned)( ((1<<5)-1) )", "cinematicMotionDefIndex doesn't index INVALID_CINEMATICMOTION_DEF\n\t%i not in [0, %i)", v13, 31) )
      __debugbreak();
  }
  v4 = &s_cgCinematicMotionDefs[v2];
  if ( !*v4 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 510, ASSERT_TYPE_ASSERT, "(s_cgCinematicMotionDefs[cinematicMotionDefIndex])", (const char *)&queryFormat, "s_cgCinematicMotionDefs[cinematicMotionDefIndex]") )
    __debugbreak();
  v5 = 0x7FFFFFFFi64;
  name = (*v4)->name;
  if ( !name && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 212, ASSERT_TYPE_SANITY, "( s0 )", (const char *)&queryFormat, "s0") )
    __debugbreak();
  if ( !v3 && CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_string.h", 213, ASSERT_TYPE_SANITY, "( s1 )", (const char *)&queryFormat, "s1") )
    __debugbreak();
  v7 = name - v3;
  do
  {
    v8 = (unsigned __int8)v3[v7];
    v9 = v5;
    v10 = *(unsigned __int8 *)v3++;
    --v5;
    if ( !v9 )
      break;
    if ( v8 != v10 )
    {
      v11 = v8 + 32;
      if ( (unsigned int)(v8 - 65) > 0x19 )
        v11 = v8;
      v8 = v11;
      v12 = v10 + 32;
      if ( (unsigned int)(v10 - 65) > 0x19 )
        v12 = v10;
      if ( v8 != v12 )
      {
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 511, ASSERT_TYPE_ASSERT, "(!I_stricmp( s_cgCinematicMotionDefs[cinematicMotionDefIndex]->name, cinematicMotionName ))", "%s\n\tInvalid CinematicMotion asset mapping", "!I_stricmp( s_cgCinematicMotionDefs[cinematicMotionDefIndex]->name, cinematicMotionName )") )
          __debugbreak();
        return;
      }
    }
  }
  while ( v8 );
}

/*
==============
AdvancedSwayDeadzone::DebugDraw
==============
*/
void AdvancedSwayDeadzone::DebugDraw(AdvancedSwayDeadzone *this, const LocalClientNum_t localClientNum, const vec4_t *color)
{
  cg_t *LocalClientGlobals; 
  const dvar_t *v5; 
  float v6; 
  float v7; 
  vec3_t outOrg; 
  __int64 v13; 
  vec3_t forward; 
  vec3_t center; 
  vec3_t v16; 

  v13 = -2i64;
  LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
  v5 = DCONST_DVARBOOL_advancedSwayDebug;
  if ( !DCONST_DVARBOOL_advancedSwayDebug && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "advancedSwayDebug") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v5);
  if ( v5->current.enabled )
  {
    RefdefView_GetOrg(&LocalClientGlobals->refdef.view, &outOrg);
    AngleVectors(&this->m_prevViewAngles, &forward, NULL, NULL);
    center.v[0] = (float)(debugDrawDist * forward.v[0]) + outOrg.v[0];
    center.v[1] = (float)(debugDrawDist * forward.v[1]) + outOrg.v[1];
    center.v[2] = (float)(debugDrawDist * forward.v[2]) + outOrg.v[2];
    CG_DebugSphere(&center, 0.5 * radius_2, &colorWhite, 0, 0);
    v6 = this->m_prevViewAnglesOffset.v[1] + this->m_prevViewAngles.v[1];
    v7 = this->m_prevViewAnglesOffset.v[2] + this->m_prevViewAngles.v[2];
    _XMM6 = 0i64;
    __asm { vroundss xmm0, xmm6, xmm1, 1 }
    center.v[0] = (float)((float)((float)(this->m_prevViewAnglesOffset.v[0] + this->m_prevViewAngles.v[0]) * 0.0027777778) - *(float *)&_XMM0) * 360.0;
    __asm { vroundss xmm3, xmm6, xmm1, 1 }
    center.v[1] = (float)((float)(v6 * 0.0027777778) - *(float *)&_XMM3) * 360.0;
    __asm { vroundss xmm3, xmm6, xmm2, 1 }
    center.v[2] = (float)((float)(v7 * 0.0027777778) - *(float *)&_XMM3) * 360.0;
    AngleVectors(&center, &forward, NULL, NULL);
    v16.v[0] = (float)(debugDrawDist * forward.v[0]) + outOrg.v[0];
    v16.v[1] = (float)(debugDrawDist * forward.v[1]) + outOrg.v[1];
    v16.v[2] = (float)(debugDrawDist * forward.v[2]) + outOrg.v[2];
    CG_DebugSphere(&v16, radius_2, &colorRed, 0, 0);
    DebugDrawRange(&outOrg, &this->m_prevViewAngles, &this->m_deadzoneGoal, &colorOrange);
    DebugDrawRange(&outOrg, &this->m_prevViewAngles, &this->m_deadzone, &colorRed);
    memset(&outOrg, 0, sizeof(outOrg));
  }
}

/*
==============
AdvancedSwayState::DebugDraw
==============
*/
void AdvancedSwayState::DebugDraw(AdvancedSwayState *this, const LocalClientNum_t localClientNum)
{
  const dvar_t *v4; 
  cg_t *LocalClientGlobals; 
  __m128 v6; 
  float v7; 
  float v10; 
  float v12; 
  float v14; 
  float v15; 
  float v16; 
  __m128 v17; 
  float v19; 
  float v21; 
  float v23; 
  __m128 v24; 
  float v25; 
  float v26; 
  float v27; 
  float v28; 
  const dvar_t *v32; 
  float v33; 
  float v34; 
  float v35; 
  const dvar_t *v36; 
  __m128 v37; 
  const dvar_t *v41; 
  float v45; 
  float v46; 
  float v47; 
  float v48; 
  vec3_t forward; 
  vec3_t center; 
  vec3_t v51; 
  vec3_t angles; 
  vec3_t outOrg; 
  vec3_t v54; 
  vec3_t v55; 

  v4 = DCONST_DVARBOOL_advancedSwayDebug;
  if ( !DCONST_DVARBOOL_advancedSwayDebug && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "advancedSwayDebug") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v4);
  if ( v4->current.enabled )
  {
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    v6 = (__m128)*(unsigned __int64 *)this->m_torsoGoal.m_prevViewAnglesOffset.v;
    outOrg.v[2] = this->m_torsoGoal.m_prevViewAnglesOffset.v[2];
    v7 = v6.m128_f32[0] + this->m_prevViewmodelAnglesSmoothed.v[0];
    *(double *)outOrg.v = *(double *)v6.m128_u64;
    _XMM12 = 0i64;
    __asm { vroundss xmm0, xmm12, xmm2, 1 }
    v10 = (float)((float)(v7 * 0.0027777778) - *(float *)&_XMM0) * 360.0;
    __asm { vroundss xmm3, xmm12, xmm2, 1 }
    v12 = (float)((float)((float)(_mm_shuffle_ps(v6, v6, 85).m128_f32[0] + this->m_prevViewmodelAnglesSmoothed.v[1]) * 0.0027777778) - *(float *)&_XMM3) * 360.0;
    v48 = v12;
    __asm { vroundss xmm3, xmm12, xmm1, 1 }
    outOrg.v[2] = (float)((float)((float)(outOrg.v[2] + this->m_prevViewmodelAnglesSmoothed.v[2]) * 0.0027777778) - *(float *)&_XMM3) * 360.0;
    if ( this->m_isInitialized )
    {
      v17 = (__m128)*(unsigned __int64 *)this->m_torsoSprings.m_prevSpringOffset.v;
      v51.v[2] = this->m_torsoSprings.m_prevSpringOffset.v[2];
      __asm { vroundss xmm3, xmm12, xmm2, 1 }
      v19 = (float)((float)(v17.m128_f32[0] * 0.0027777778) - *(float *)&_XMM3) * 360.0;
      *(double *)v51.v = *(double *)v17.m128_u64;
      __asm { vroundss xmm3, xmm12, xmm1, 1 }
      v21 = (float)((float)(_mm_shuffle_ps(v17, v17, 85).m128_f32[0] * 0.0027777778) - *(float *)&_XMM3) * 360.0;
      __asm { vroundss xmm3, xmm12, xmm2, 1 }
      v23 = *(float *)&_XMM3 * -360.0;
      v24 = (__m128)*(unsigned __int64 *)this->m_gunSprings.m_prevSpringOffset.v;
      v51.v[2] = this->m_gunSprings.m_prevSpringOffset.v[2];
      v25 = _mm_shuffle_ps(v24, v24, 85).m128_f32[0];
      *(double *)v51.v = *(double *)v24.m128_u64;
      v26 = v25 * this->m_yawToRollScale;
      *(double *)v24.m128_u64 = I_fclamp(1.0 - this->m_prevAdsFraction, 0.0, 1.0);
      v14 = v19 * v24.m128_f32[0];
      v15 = v21 * v24.m128_f32[0];
      v16 = v23 * v24.m128_f32[0];
      v45 = v24.m128_f32[0] * v51.v[0];
      v46 = v25 * v24.m128_f32[0];
      v47 = v26 * v24.m128_f32[0];
      forward = this->m_pivotPoint;
      v12 = v48;
    }
    else
    {
      v14 = 0.0;
      v15 = 0.0;
      v16 = 0.0;
      v45 = 0.0;
      v46 = 0.0;
      v47 = 0.0;
      forward.v[0] = 0.0;
      forward.v[1] = 0.0;
      forward.v[2] = 0.0;
    }
    v27 = v15 + this->m_prevViewmodelAngles.v[1];
    v28 = v16 + this->m_prevViewmodelAngles.v[2];
    __asm { vroundss xmm3, xmm12, xmm2, 1 }
    angles.v[0] = (float)((float)((float)(v14 + this->m_prevViewmodelAngles.v[0]) * 0.0027777778) - *(float *)&_XMM3) * 360.0;
    __asm { vroundss xmm3, xmm12, xmm1, 1 }
    angles.v[1] = (float)((float)(v27 * 0.0027777778) - *(float *)&_XMM3) * 360.0;
    __asm { vroundss xmm3, xmm12, xmm2, 1 }
    angles.v[2] = (float)((float)(v28 * 0.0027777778) - *(float *)&_XMM3) * 360.0;
    AdvancedSwayDeadzone::DebugDraw(&this->m_torsoGoal, localClientNum, &colorRed);
    RefdefView_GetOrg(&LocalClientGlobals->refdef.view, &outOrg);
    v32 = DCONST_DVARBOOL_advancedSwayGunTorsoSpringDamperEnabled;
    if ( !DCONST_DVARBOOL_advancedSwayGunTorsoSpringDamperEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "advancedSwayGunTorsoSpringDamperEnabled") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v32);
    v33 = outOrg.v[2];
    v34 = outOrg.v[1];
    v35 = outOrg.v[0];
    if ( v32->current.enabled )
    {
      AngleVectors(&angles, &forward, NULL, NULL);
      center.v[0] = (float)(debugDrawDist_0 * forward.v[0]) + v35;
      center.v[1] = (float)(debugDrawDist_0 * forward.v[1]) + v34;
      center.v[2] = (float)(debugDrawDist_0 * forward.v[2]) + v33;
      CG_DebugSphere(&center, radius_3, &colorOrange, 0, 0);
      forward = angles;
      forward.v[0] = v10;
      DebugDrawDisplacementLine(LocalClientGlobals, &forward, &LocalClientGlobals->refdef.view.axis.m[2], &colorOrange);
      forward = angles;
      forward.v[1] = v12;
      DebugDrawDisplacementLine(LocalClientGlobals, &forward, &LocalClientGlobals->refdef.view.axis.m[1], &colorOrange);
    }
    v36 = DCONST_DVARBOOL_advancedSwayGunDirEnabled;
    if ( !DCONST_DVARBOOL_advancedSwayGunDirEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "advancedSwayGunDirEnabled") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v36);
    if ( v36->current.enabled )
    {
      v37 = (__m128)*(unsigned __int64 *)this->m_gunGoal.m_gunAnglesOffset.v;
      v51.v[2] = this->m_gunGoal.m_gunAnglesOffset.v[2];
      *(double *)v51.v = *(double *)v37.m128_u64;
      __asm { vroundss xmm3, xmm12, xmm2, 1 }
      forward.v[0] = (float)((float)((float)(v37.m128_f32[0] + angles.v[0]) * 0.0027777778) - *(float *)&_XMM3) * 360.0;
      __asm { vroundss xmm3, xmm12, xmm1, 1 }
      forward.v[1] = (float)((float)((float)(_mm_shuffle_ps(v37, v37, 85).m128_f32[0] + angles.v[1]) * 0.0027777778) - *(float *)&_XMM3) * 360.0;
      __asm { vroundss xmm3, xmm12, xmm2, 1 }
      forward.v[2] = (float)((float)((float)(v51.v[2] + angles.v[2]) * 0.0027777778) - *(float *)&_XMM3) * 360.0;
      AngleVectors(&forward, &center, NULL, NULL);
      v54.v[0] = (float)(debugDrawDist_0 * center.v[0]) + v35;
      v54.v[1] = (float)(debugDrawDist_0 * center.v[1]) + v34;
      v54.v[2] = (float)(debugDrawDist_0 * center.v[2]) + v33;
      CG_DebugSphere(&v54, radius_3, &colorBlue, 0, 0);
      v41 = DCONST_DVARBOOL_advancedSwayGunDirSpringDamperEnabled;
      if ( !DCONST_DVARBOOL_advancedSwayGunDirSpringDamperEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "advancedSwayGunDirSpringDamperEnabled") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v41);
      if ( v41->current.enabled )
      {
        __asm { vroundss xmm3, xmm12, xmm1, 1 }
        center.v[0] = (float)((float)((float)(angles.v[0] + v45) * 0.0027777778) - *(float *)&_XMM3) * 360.0;
        __asm { vroundss xmm3, xmm12, xmm2, 1 }
        center.v[1] = (float)((float)((float)(angles.v[1] + v46) * 0.0027777778) - *(float *)&_XMM3) * 360.0;
        __asm { vroundss xmm3, xmm12, xmm2, 1 }
        center.v[2] = (float)((float)((float)(angles.v[2] + v47) * 0.0027777778) - *(float *)&_XMM3) * 360.0;
        AngleVectors(&center, &v54, NULL, NULL);
        v55.v[0] = (float)(debugDrawDist_0 * v54.v[0]) + v35;
        v55.v[1] = (float)(debugDrawDist_0 * v54.v[1]) + v34;
        v55.v[2] = (float)(debugDrawDist_0 * v54.v[2]) + v33;
        CG_DebugSphere(&v55, radius_3, &colorCyan, 0, 0);
        v51 = center;
        v51.v[0] = forward.v[0];
        DebugDrawDisplacementLine(LocalClientGlobals, &v51, &LocalClientGlobals->refdef.view.axis.m[2], &colorCyan);
        v51 = center;
        v51.v[1] = forward.v[1];
        DebugDrawDisplacementLine(LocalClientGlobals, &v51, &LocalClientGlobals->refdef.view.axis.m[1], &colorCyan);
      }
    }
    memset(&outOrg, 0, sizeof(outOrg));
  }
}

/*
==============
DebugDrawDisplacementLine
==============
*/
void DebugDrawDisplacementLine(const cg_t *const cgameGlob, const vec3_t *angles, const vec3_t *drawAxis, const vec4_t *color)
{
  float v8; 
  float v9; 
  float v10; 
  float v11; 
  vec3_t outOrg; 
  __int64 v13; 
  vec3_t forward; 
  vec3_t start; 
  vec3_t end; 

  v13 = -2i64;
  if ( dword_1512F37D0 > *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->Reserved1[11] + tls_index) + 1772i64) )
  {
    j__Init_thread_header(&dword_1512F37D0);
    if ( dword_1512F37D0 == -1 )
    {
      drawHalfAngle = drawHalfAngleDeg * 0.017453292;
      j__Init_thread_footer(&dword_1512F37D0);
    }
  }
  v8 = tanf_0(drawHalfAngle) * drawDist_0;
  AngleVectors(angles, &forward, NULL, NULL);
  RefdefView_GetOrg(&cgameGlob->refdef.view, &outOrg);
  v9 = (float)(drawDist_0 * forward.v[0]) + outOrg.v[0];
  v10 = (float)(drawDist_0 * forward.v[1]) + outOrg.v[1];
  v11 = (float)(drawDist_0 * forward.v[2]) + outOrg.v[2];
  start.v[0] = (float)(v8 * drawAxis->v[0]) + v9;
  start.v[1] = (float)(v8 * drawAxis->v[1]) + v10;
  start.v[2] = (float)(v8 * drawAxis->v[2]) + v11;
  end.v[0] = (float)(COERCE_FLOAT(LODWORD(v8) ^ _xmm) * drawAxis->v[0]) + v9;
  end.v[1] = (float)(COERCE_FLOAT(LODWORD(v8) ^ _xmm) * drawAxis->v[1]) + v10;
  end.v[2] = (float)(COERCE_FLOAT(LODWORD(v8) ^ _xmm) * drawAxis->v[2]) + v11;
  CG_DebugLine(&start, &end, color, 0, 0);
  memset(&outOrg, 0, sizeof(outOrg));
}

/*
==============
DebugDrawRange
==============
*/
void DebugDrawRange(const vec3_t *viewOrigin, const vec3_t *viewAngles, const vec2_t *angleRange, const vec4_t *color)
{
  float v8; 
  float v9; 
  float *v10; 
  unsigned int v11; 
  float v12; 
  float v13; 
  float v14; 
  float v15; 
  float v16; 
  __int64 v17; 
  float v18; 
  float v19; 
  float v20; 
  vec3_t end; 
  vec3_t start; 
  tmat33_t<vec3_t> axis; 
  __m256i v24; 

  v8 = tanf_0(0.017453292 * angleRange->v[0]) * drawDist;
  v9 = tanf_0(0.017453292 * angleRange->v[1]) * drawDist;
  v20 = v9;
  v24 = _ymm;
  AnglesToAxis(viewAngles, &axis);
  v10 = (float *)&v24.m256i_i32[1];
  v11 = 0;
  do
  {
    v12 = (float)(drawDist * axis.m[0].v[0]) + viewOrigin->v[0];
    v13 = (float)(drawDist * axis.m[0].v[1]) + viewOrigin->v[1];
    v14 = (float)(drawDist * axis.m[0].v[2]) + viewOrigin->v[2];
    v15 = v9 * *(v10 - 1);
    v16 = v8 * *v10;
    start.v[0] = (float)((float)(v15 * axis.m[1].v[0]) + v12) + (float)(v16 * axis.m[2].v[0]);
    start.v[1] = (float)((float)(v15 * axis.m[1].v[1]) + v13) + (float)(v16 * axis.m[2].v[1]);
    start.v[2] = (float)((float)(v15 * axis.m[1].v[2]) + v14) + (float)(v16 * axis.m[2].v[2]);
    v17 = ++v11 & 3;
    v18 = v20 * *(float *)&v24.m256i_i32[2 * v17];
    v19 = v8 * *(float *)&v24.m256i_i32[2 * v17 + 1];
    end.v[0] = (float)((float)(v18 * axis.m[1].v[0]) + v12) + (float)(v19 * axis.m[2].v[0]);
    end.v[1] = (float)((float)(v18 * axis.m[1].v[1]) + v13) + (float)(v19 * axis.m[2].v[1]);
    end.v[2] = (float)((float)(v18 * axis.m[1].v[2]) + v14) + (float)(v19 * axis.m[2].v[2]);
    CG_DebugLine(&start, &end, color, 0, 0);
    v10 += 2;
    v9 = v20;
  }
  while ( v11 < 4 );
}

/*
==============
AdvancedSwayDeadzone::DebugDrawText
==============
*/
void AdvancedSwayDeadzone::DebugDrawText(AdvancedSwayDeadzone *this, const LocalClientNum_t localClientNum, DebugDrawState *debugDraw)
{
  bool m_isAlternate; 
  cg_t *LocalClientGlobals; 
  CgWeaponMap *Instance; 
  cg_t *v9; 
  const dvar_t *v10; 
  const ScreenPlacement *ActivePlacement; 
  GfxFont *FontHandle; 
  RumbleGraph *torsoGoalViewSpeedToMaxDeadzone_graph; 
  double v14; 
  float v15; 
  double v16; 
  SwaySettings outSwaySettings; 
  char dest[6144]; 

  if ( this->m_isInitialized )
  {
    m_isAlternate = debugDraw->m_isAlternate;
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    Instance = CgWeaponMap::GetInstance(localClientNum);
    BG_GetSwaySettings(Instance, &LocalClientGlobals->predictedPlayerState, &debugDraw->m_weapon, m_isAlternate, &outSwaySettings);
    v9 = CG_GetLocalClientGlobals(localClientNum);
    if ( !BG_ProceduralGunMotionDisabled(&v9->predictedPlayerState) )
    {
      v10 = DCONST_DVARBOOL_advancedSwayEnabled;
      if ( !DCONST_DVARBOOL_advancedSwayEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "advancedSwayEnabled") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v10);
      if ( v10->current.enabled && outSwaySettings.adv.enabled )
      {
        memset_0(dest, 0, sizeof(dest));
        ActivePlacement = ScrPlace_GetActivePlacement((const LocalClientNum_t)debugDraw->m_localClientNum);
        FontHandle = UI_GetFontHandle(ActivePlacement, VMMOTION_DEBUG_FONT_TYPE, VMMOTION_DEBUG_FONT_SCALE);
        Com_sprintf(dest, 0x1800ui64, "^7=== TORSO DEADZONE ===\n");
        UI_DrawText(ActivePlacement, dest, 6144, FontHandle, debugDraw->m_drawX, debugDraw->m_drawY, 2, 2, VMMOTION_DEBUG_FONT_SCALE, &colorWhite, 3);
        torsoGoalViewSpeedToMaxDeadzone_graph = outSwaySettings.adv.torsoGoalViewSpeedToMaxDeadzone_graph;
        debugDraw->m_drawY = debugDraw->m_drawY + 12.0;
        v14 = I_fclamp(COERCE_FLOAT(LODWORD(this->m_viewVelocityScaled.v[0]) & _xmm) / outSwaySettings.adv.torsoGoalViewSpeedToMaxDeadzone_viewspeed.v[0], 0.0, 1.0);
        v15 = *(float *)&v14;
        v16 = I_fclamp(COERCE_FLOAT(LODWORD(this->m_viewVelocityScaled.v[1]) & _xmm) / outSwaySettings.adv.torsoGoalViewSpeedToMaxDeadzone_viewspeed.v[1], 0.0, 1.0);
        CG_ViewMotion_DebugDrawGraph(ActivePlacement, debugDraw->m_drawX, debugDraw->m_drawY, torsoGoalViewSpeedToMaxDeadzone_graph, &colorRed, v15, &colorGreen, *(float *)&v16, &colorPurple);
        debugDraw->m_drawX = textOffsetX_0 + debugDraw->m_drawX;
        Com_sprintf(dest, 0x1800ui64, "^7IN View Speed: (^2%.0f^7, ^6%.0f^7)\n^7OUT Deadzone Goal: (^2%.1f^7, ^6%.1f^7)\n^7Deadzone Current: (^2%.1f^7, ^6%.1f^7)\n", this->m_viewVelocityScaled.v[0], this->m_viewVelocityScaled.v[1], this->m_deadzoneGoal.v[0], this->m_deadzoneGoal.v[1], this->m_deadzone.v[0], this->m_deadzone.v[1]);
        UI_DrawText(ActivePlacement, dest, 6144, FontHandle, debugDraw->m_drawX, debugDraw->m_drawY, 2, 2, VMMOTION_DEBUG_FONT_SCALE, &colorWhite, 3);
      }
    }
  }
}

/*
==============
AdvancedSwayGunDir::DebugDrawText
==============
*/
void AdvancedSwayGunDir::DebugDrawText(AdvancedSwayGunDir *this, const LocalClientNum_t localClientNum, float yawToRollScale, DebugDrawState *debugDraw)
{
  signed __int64 v4; 
  void *v5; 
  bool m_isAlternate; 
  cg_t *LocalClientGlobals; 
  CgWeaponMap *Instance; 
  cg_t *v12; 
  const dvar_t *v13; 
  const ScreenPlacement *ActivePlacement; 
  GfxFont *FontHandle; 
  RumbleGraph *gunGoalViewSpeedToOffset_graph; 
  float v17; 
  double v18; 
  SwaySettings outSwaySettings; 
  char dest[6144]; 

  v5 = alloca(v4);
  if ( this->m_isInitialized )
  {
    m_isAlternate = debugDraw->m_isAlternate;
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    Instance = CgWeaponMap::GetInstance(localClientNum);
    BG_GetSwaySettings(Instance, &LocalClientGlobals->predictedPlayerState, &debugDraw->m_weapon, m_isAlternate, &outSwaySettings);
    v12 = CG_GetLocalClientGlobals(localClientNum);
    if ( !BG_ProceduralGunMotionDisabled(&v12->predictedPlayerState) )
    {
      v13 = DCONST_DVARBOOL_advancedSwayEnabled;
      if ( !DCONST_DVARBOOL_advancedSwayEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "advancedSwayEnabled") )
        __debugbreak();
      Dvar_CheckFrontendServerThread(v13);
      if ( v13->current.enabled && outSwaySettings.adv.enabled )
      {
        memset_0(dest, 0, sizeof(dest));
        ActivePlacement = ScrPlace_GetActivePlacement((const LocalClientNum_t)debugDraw->m_localClientNum);
        FontHandle = UI_GetFontHandle(ActivePlacement, VMMOTION_DEBUG_FONT_TYPE, VMMOTION_DEBUG_FONT_SCALE);
        Com_sprintf(dest, 0x1800ui64, "^7=== GUN OFFSET ANGLES ===\n");
        UI_DrawText(ActivePlacement, dest, 6144, FontHandle, debugDraw->m_drawX, debugDraw->m_drawY, 2, 2, VMMOTION_DEBUG_FONT_SCALE, &colorWhite, 3);
        gunGoalViewSpeedToOffset_graph = outSwaySettings.adv.gunGoalViewSpeedToOffset_graph;
        debugDraw->m_drawY = debugDraw->m_drawY + 12.0;
        v17 = COERCE_FLOAT(LODWORD(this->m_smoothedWorldVelocity.v[0]) & _xmm) / outSwaySettings.adv.gunGoalViewSpeedToOffset_viewspeed.v[0];
        I_fclamp(v17, 0.0, 1.0);
        v18 = I_fclamp(COERCE_FLOAT(LODWORD(this->m_smoothedWorldVelocity.v[1]) & _xmm) / outSwaySettings.adv.gunGoalViewSpeedToOffset_viewspeed.v[1], 0.0, 1.0);
        CG_ViewMotion_DebugDrawGraph(ActivePlacement, debugDraw->m_drawX, debugDraw->m_drawY, gunGoalViewSpeedToOffset_graph, &colorBlue, v17, &colorGreen, *(float *)&v18, &colorPurple);
        debugDraw->m_drawX = textOffsetX_1 + debugDraw->m_drawX;
        Com_sprintf(dest, 0x1800ui64, "^7IN View Speed: (^2%.0f^7, ^6%.0f^7)\n^7OUT Offset: (^2%.1f^7, ^6%.1f^7, ^5%.1f)\n", this->m_smoothedWorldVelocity.v[0], this->m_smoothedWorldVelocity.v[1], this->m_gunAnglesOffset.v[0], this->m_gunAnglesOffset.v[1], (float)(this->m_gunAnglesOffset.v[1] * yawToRollScale));
        UI_DrawText(ActivePlacement, dest, 6144, FontHandle, debugDraw->m_drawX, debugDraw->m_drawY, 2, 2, VMMOTION_DEBUG_FONT_SCALE, &colorWhite, 3);
      }
    }
  }
}

/*
==============
AdvancedSwayState::DebugDrawText
==============
*/
void AdvancedSwayState::DebugDrawText(AdvancedSwayState *this, const LocalClientNum_t localClientNum)
{
  const dvar_t *v2; 
  const ScreenPlacement *ActivePlacement; 
  GfxFont *FontHandle; 
  int v7; 
  GfxFont *v8; 
  bool m_isAlternate; 
  double v10; 
  __int128 v11; 
  cg_t *LocalClientGlobals; 
  CgWeaponMap *Instance; 
  cg_t *v14; 
  const dvar_t *v15; 
  float m_drawY; 
  float m_yawToRollScale; 
  vec3_t v3; 
  DebugDrawState debugDraw; 
  SwaySettings outSwaySettings; 
  char dest[2048]; 

  v2 = DCONST_DVARBOOL_advancedSwayDebug;
  if ( !DCONST_DVARBOOL_advancedSwayDebug && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "advancedSwayDebug") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v2);
  if ( v2->current.enabled && this->m_isInitialized )
  {
    ActivePlacement = ScrPlace_GetActivePlacement(localClientNum);
    FontHandle = UI_GetFontHandle(ActivePlacement, VMMOTION_DEBUG_FONT_TYPE, VMMOTION_DEBUG_FONT_SCALE);
    v7 = *(_DWORD *)&this->m_weapon.weaponCamo;
    v8 = FontHandle;
    m_isAlternate = this->m_isAlternate;
    debugDraw.m_drawX = initialDrawX_0;
    *(__m256i *)&debugDraw.m_weapon.weaponIdx = *(__m256i *)&this->m_weapon.weaponIdx;
    v10 = *(double *)&this->m_weapon.attachmentVariationIndices[21];
    debugDraw.m_drawY = initialDrawY_0;
    v11 = *(_OWORD *)&this->m_weapon.attachmentVariationIndices[5];
    *(_DWORD *)&debugDraw.m_weapon.weaponCamo = v7;
    *(double *)&debugDraw.m_weapon.attachmentVariationIndices[21] = v10;
    debugDraw.m_localClientNum = localClientNum;
    *(_OWORD *)&debugDraw.m_weapon.attachmentVariationIndices[5] = v11;
    debugDraw.m_isAlternate = m_isAlternate;
    LocalClientGlobals = CG_GetLocalClientGlobals(localClientNum);
    Instance = CgWeaponMap::GetInstance(localClientNum);
    BG_GetSwaySettings(Instance, &LocalClientGlobals->predictedPlayerState, &this->m_weapon, m_isAlternate, &outSwaySettings);
    v14 = CG_GetLocalClientGlobals(localClientNum);
    if ( BG_ProceduralGunMotionDisabled(&v14->predictedPlayerState) )
      goto LABEL_13;
    v15 = DCONST_DVARBOOL_advancedSwayEnabled;
    if ( !DCONST_DVARBOOL_advancedSwayEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "advancedSwayEnabled") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v15);
    if ( v15->current.enabled && outSwaySettings.adv.enabled )
    {
      AnglesSubtract(&this->m_prevViewmodelAnglesSmoothed, &this->m_prevViewmodelAngles, &v3);
      Com_sprintf(dest, 0x800ui64, "^7=== ADVANCED SWAY ===\n^7Delta Time: ^5%.4f^7\n^7View Velocity: (^2%.1f^7, ^6%.1f^7)\n^7Smoothing Offset: (^2%.1f^7, ^6%.1f^7)\n^7Fire Fraction: ^5%.2f {%.2f}\n", this->m_frametimeSec, this->m_angularVelocity.v[0], this->m_angularVelocity.v[1], v3.v[0], v3.v[1], this->m_prevGoalFireFraction, this->m_prevFireFraction);
      UI_DrawText(ActivePlacement, dest, 2048, v8, debugDraw.m_drawX, debugDraw.m_drawY, 2, 2, VMMOTION_DEBUG_FONT_SCALE, &colorWhite, 3);
      debugDraw.m_drawY = debugDraw.m_drawY + offsetY_1;
      m_drawY = debugDraw.m_drawY;
      AdvancedSwayDeadzone::DebugDrawText(&this->m_torsoGoal, localClientNum, &debugDraw);
      m_yawToRollScale = this->m_yawToRollScale;
      debugDraw.m_drawX = debugDraw.m_drawX + graphOffsetX;
      debugDraw.m_drawY = m_drawY;
      AdvancedSwayGunDir::DebugDrawText(&this->m_gunGoal, localClientNum, m_yawToRollScale, &debugDraw);
    }
    else
    {
LABEL_13:
      Com_sprintf(dest, 0x800ui64, "^7=== ADVANCED SWAY ===\n^7DISABLED\n");
      UI_DrawText(ActivePlacement, dest, 2048, v8, debugDraw.m_drawX, debugDraw.m_drawY, 2, 2, VMMOTION_DEBUG_FONT_SCALE, &colorWhite, 3);
    }
  }
}

/*
==============
AdvancedSwayState::GetAngleOffsets
==============
*/
void AdvancedSwayState::GetAngleOffsets(AdvancedSwayState *this, vec3_t *outTorsoAngleOffsets, vec3_t *outGunAngleOffsets, vec3_t *outGunPivotOffset)
{
  float v8; 
  double v13; 
  float v14; 

  if ( this->m_isInitialized )
  {
    *outTorsoAngleOffsets = this->m_torsoSprings.m_prevSpringOffset;
    v8 = 0.0027777778 * outTorsoAngleOffsets->v[1];
    _XMM7 = 0i64;
    __asm { vroundss xmm2, xmm7, xmm1, 1 }
    outTorsoAngleOffsets->v[0] = (float)((float)(0.0027777778 * outTorsoAngleOffsets->v[0]) - *(float *)&_XMM2) * 360.0;
    __asm { vroundss xmm3, xmm7, xmm2, 1 }
    outTorsoAngleOffsets->v[1] = (float)(v8 - *(float *)&_XMM3) * 360.0;
    __asm { vroundss xmm3, xmm7, xmm2, 1 }
    outTorsoAngleOffsets->v[2] = *(float *)&_XMM3 * -360.0;
    *outGunAngleOffsets = this->m_gunSprings.m_prevSpringOffset;
    outGunAngleOffsets->v[2] = this->m_yawToRollScale * outGunAngleOffsets->v[1];
    v13 = I_fclamp(1.0 - this->m_prevAdsFraction, 0.0, 1.0);
    *(float *)&_XMM2 = *(float *)&v13 * outTorsoAngleOffsets->v[1];
    outTorsoAngleOffsets->v[0] = *(float *)&v13 * outTorsoAngleOffsets->v[0];
    outTorsoAngleOffsets->v[2] = *(float *)&v13 * outTorsoAngleOffsets->v[2];
    outTorsoAngleOffsets->v[1] = *(float *)&_XMM2;
    *(float *)&_XMM2 = *(float *)&v13 * outGunAngleOffsets->v[0];
    v14 = *(float *)&v13 * outGunAngleOffsets->v[1];
    outGunAngleOffsets->v[2] = *(float *)&v13 * outGunAngleOffsets->v[2];
    outGunAngleOffsets->v[0] = *(float *)&_XMM2;
    outGunAngleOffsets->v[1] = v14;
    *(double *)outGunPivotOffset->v = *(double *)this->m_pivotPoint.v;
    outGunPivotOffset->v[2] = this->m_pivotPoint.v[2];
  }
  else
  {
    *(_QWORD *)outTorsoAngleOffsets->v = 0i64;
    outTorsoAngleOffsets->v[2] = 0.0;
    *(_QWORD *)outGunAngleOffsets->v = 0i64;
    outGunAngleOffsets->v[2] = 0.0;
    *(_QWORD *)outGunPivotOffset->v = 0i64;
    outGunPivotOffset->v[2] = 0.0;
  }
}

/*
==============
AdvancedSwayDeadzone::GetAnglesOffset
==============
*/
void AdvancedSwayDeadzone::GetAnglesOffset(AdvancedSwayDeadzone *this, vec3_t *outGoalAnglesOffset)
{
  *outGoalAnglesOffset = this->m_prevViewAnglesOffset;
}

/*
==============
AdvancedSwayGunDir::GetAnglesOffset
==============
*/
void AdvancedSwayGunDir::GetAnglesOffset(AdvancedSwayGunDir *this, vec3_t *outAnglesOffset)
{
  *outAnglesOffset = this->m_gunAnglesOffset;
}

/*
==============
AdvancedSwaySprings::GetAnglesOffset
==============
*/
void AdvancedSwaySprings::GetAnglesOffset(AdvancedSwaySprings *this, vec3_t *outAnglesOffset)
{
  *outAnglesOffset = this->m_prevSpringOffset;
}

/*
==============
AdvancedSwaySprings::GetAnglesVelocity
==============
*/
void AdvancedSwaySprings::GetAnglesVelocity(AdvancedSwaySprings *this, vec3_t *outAnglesVelocity)
{
  *outAnglesVelocity = this->m_prevSpringVelocity;
}

/*
==============
AdvancedSwayState::GetBlendspaceParams
==============
*/
void AdvancedSwayState::GetBlendspaceParams(AdvancedSwayState *this, vec2_t *outBsParams)
{
  double v2; 
  double v4; 
  double v5; 

  v2 = *(double *)this->m_torsoSprings.m_prevSpringOffset.v;
  v4 = I_fclamp(1.0 - this->m_prevAdsFraction, 0.0, 1.0);
  v5 = v2;
  *((float *)&v5 + 1) = *(float *)&v4 * *((float *)&v5 + 1);
  *(float *)&v5 = *(float *)&v2 * *(float *)&v4;
  *(double *)outBsParams = v5;
}

/*
==============
AdvancedSwayDeadzone::Reset
==============
*/
void AdvancedSwayDeadzone::Reset(AdvancedSwayDeadzone *this)
{
  this->m_isInitialized = 0;
}

/*
==============
AdvancedSwayGunDir::Reset
==============
*/
void AdvancedSwayGunDir::Reset(AdvancedSwayGunDir *this)
{
  this->m_isInitialized = 0;
}

/*
==============
AdvancedSwaySprings::Reset
==============
*/
void AdvancedSwaySprings::Reset(AdvancedSwaySprings *this)
{
  this->m_isInitialized = 0;
}

/*
==============
AngularSmoothing::Reset
==============
*/
void AngularSmoothing::Reset(AngularSmoothing *this)
{
  this->m_initialized = 0;
}

/*
==============
ViewMotionSpring::Reset
==============
*/
void ViewMotionSpring::Reset(ViewMotionSpring *this, const float4 *playerOrigin)
{
  *(__m256i *)this->massPos.v.m128_f32 = (__m256i)0i64;
  *(__m256i *)this->anchorPos.v.m128_f32 = (__m256i)0i64;
  this->unlockTime = 0;
  this->prevPsOrigin = (float4)playerOrigin->v;
  *(__m256i *)this->velocitySmoothingSec.v.m128_f32 = (__m256i)0i64;
  *(__m256i *)this->springConstant.v.m128_f32 = (__m256i)0i64;
  this->maxOffset = 0i64;
  this->isLockingSpring = 0;
  *(_QWORD *)&this->motionIndex = 31i64;
  this->motionIndexBlendDuration = 0;
  this->offsetAngles.x = (float4)g_1000.v;
  this->offsetAngles.y = (float4)g_0100.v;
  this->offsetAngles.z = (float4)g_0010.v;
  this->offsetAngles.w = (float4)g_0001.v;
  this->isInitialized = 1;
}

/*
==============
AdvancedSwayDeadzone::Update
==============
*/
void AdvancedSwayDeadzone::Update(AdvancedSwayDeadzone *this, const AdvancedHipSwaySettings *const swayDef, const vec3_t *viewAngles, float frametimeSecScaled, const vec3_t *viewAngleVelocityScaled, float adsFraction, float fireFraction)
{
  __int128 v8; 
  __int128 v9; 
  __m128 v16; 
  __m128 v17; 
  __int128 v20; 
  __int128 v25; 
  vec2_t *p_torsoGoalViewSpeedToMaxDeadzone_viewspeed; 
  unsigned int v37; 
  signed __int64 v38; 
  bool v39; 
  float v40; 
  float v41; 
  double ValueFromFraction; 
  float v43; 
  float v44; 
  vec2_t *p_m_deadzone; 
  unsigned int v46; 
  signed __int64 v47; 
  unsigned int v48; 
  signed __int64 v49; 
  bool v50; 
  float v51; 
  float v52; 
  double v53; 
  float v54; 
  vec3_t *p_m_prevViewAnglesOffset; 
  __int64 v61; 
  __int64 v62; 
  unsigned __int64 v65; 
  vec2_t v66; 
  vec3_t v3; 
  __int128 v68; 
  __int128 v69; 
  __int128 v70; 

  if ( this->m_isInitialized )
  {
    v70 = _XMM10;
    _XMM9 = 0i64;
    v69 = v8;
    v68 = v9;
    __asm { vxorpd  xmm10, xmm10, xmm10 }
    if ( frametimeSecScaled <= 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 605, ASSERT_TYPE_ASSERT, "( 0.0f ) < ( frametimeSecScaled )", "%s < %s\n\t%g, %g", "0.0f", "frametimeSecScaled", *(double *)&_XMM10, frametimeSecScaled) )
      __debugbreak();
    v16 = 0i64;
    v16.m128_f32[0] = (float)((float)swayDef->torsoGoalViewSmoothDurationMs * 0.001) / frametimeSecScaled;
    v17 = v16;
    _R13 = &this->m_viewVelocityScaled;
    v20 = v65;
    *(float *)&v20 = viewAngleVelocityScaled->v[0];
    _XMM2 = v20;
    __asm { vinsertps xmm2, xmm2, dword ptr [rbx+4], 10h }
    _XMM0 = g_negativeZero.v;
    __asm { vandnps xmm4, xmm0, xmm2 }
    v25 = (unsigned __int64)_XMM2;
    *(float *)&v25 = this->m_viewVelocityScaled.v[0];
    _XMM2 = v25;
    __asm { vinsertps xmm2, xmm2, dword ptr [r13+4], 10h }
    _XMM5 = _mm_shuffle_ps(v17, v17, 0);
    __asm
    {
      vrcpps  xmm1, xmm5
      vcmpleps xmm0, xmm5, xmmword ptr cs:?g_one@@3Ufloat4@@B.v; float4 const g_one
    }
    _XMM3 = _mm128_add_ps(_mm128_mul_ps(_XMM4, _XMM1), _mm128_sub_ps(_XMM2, _mm128_mul_ps(_XMM1, _XMM2)));
    __asm { vblendvps xmm1, xmm3, xmm4, xmm0 }
    this->m_viewVelocityScaled.v[0] = *(float *)&_XMM1;
    __asm { vextractps dword ptr [r13+4], xmm1, 1 }
    AnglesSubtract(viewAngles, &this->m_prevViewAngles, &v3);
    _XMM3.m128_f32[0] = this->m_prevViewAnglesOffset.v[0] - v3.v[0];
    this->m_prevViewAnglesOffset.v[0] = _XMM3.m128_f32[0];
    this->m_prevViewAnglesOffset.v[1] = this->m_prevViewAnglesOffset.v[1] - v3.v[1];
    this->m_prevViewAnglesOffset.v[2] = this->m_prevViewAnglesOffset.v[2] - v3.v[2];
    _XMM8 = 0i64;
    __asm { vroundss xmm2, xmm8, xmm1, 1 }
    this->m_prevViewAnglesOffset.v[0] = (float)((float)(_XMM3.m128_f32[0] * 0.0027777778) - *(float *)&_XMM2) * 360.0;
    __asm { vroundss xmm3, xmm8, xmm2, 1 }
    this->m_prevViewAnglesOffset.v[1] = (float)((float)(0.0027777778 * this->m_prevViewAnglesOffset.v[1]) - *(float *)&_XMM3) * 360.0;
    __asm { vroundss xmm2, xmm8, xmm1, 1 }
    p_torsoGoalViewSpeedToMaxDeadzone_viewspeed = &swayDef->torsoGoalViewSpeedToMaxDeadzone_viewspeed;
    v37 = 0;
    v38 = (char *)&v66 - (char *)&swayDef->torsoGoalViewSpeedToMaxDeadzone_viewspeed;
    this->m_prevViewAnglesOffset.v[2] = (float)((float)(0.0027777778 * this->m_prevViewAnglesOffset.v[2]) - *(float *)&_XMM2) * 360.0;
    v39 = 1;
    do
    {
      if ( !v39 )
      {
        LODWORD(v62) = 2;
        LODWORD(v61) = v37;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 16, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v61, v62) )
          __debugbreak();
      }
      if ( p_torsoGoalViewSpeedToMaxDeadzone_viewspeed->v[0] <= 0.0 )
      {
        if ( v37 >= 2 )
        {
          LODWORD(v62) = 2;
          LODWORD(v61) = v37;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 16, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v61, v62) )
            __debugbreak();
        }
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 626, ASSERT_TYPE_ASSERT, "( 0.0f ) < ( swayDef->torsoGoalViewSpeedToMaxDeadzone_viewspeed[axis] )", "%s < %s\n\t%g, %g", "0.0f", "swayDef->torsoGoalViewSpeedToMaxDeadzone_viewspeed[axis]", *(double *)&_XMM10, p_torsoGoalViewSpeedToMaxDeadzone_viewspeed->v[0]) )
          __debugbreak();
      }
      if ( v37 >= 2 )
      {
        LODWORD(v62) = 2;
        LODWORD(v61) = v37;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v61, v62) )
          __debugbreak();
      }
      LODWORD(v40) = *(_DWORD *)((_BYTE *)p_torsoGoalViewSpeedToMaxDeadzone_viewspeed->v + (char *)&this->m_viewVelocityScaled - (char *)&swayDef->torsoGoalViewSpeedToMaxDeadzone_viewspeed) & _xmm;
      if ( v37 >= 2 )
      {
        LODWORD(v62) = 2;
        LODWORD(v61) = v37;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 16, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v61, v62) )
          __debugbreak();
      }
      v41 = v40 / p_torsoGoalViewSpeedToMaxDeadzone_viewspeed->v[0];
      I_fclamp(v41, 0.0, 1.0);
      ValueFromFraction = GraphGetValueFromFraction(swayDef->torsoGoalViewSpeedToMaxDeadzone_graph->knotCount, swayDef->torsoGoalViewSpeedToMaxDeadzone_graph->knots, v41);
      if ( v37 >= 2 )
      {
        LODWORD(v62) = 2;
        LODWORD(v61) = v37;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 16, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v61, v62) )
          __debugbreak();
      }
      v43 = *(float *)&ValueFromFraction * p_torsoGoalViewSpeedToMaxDeadzone_viewspeed[1].v[0];
      if ( v37 >= 2 )
      {
        LODWORD(v62) = 2;
        LODWORD(v61) = v37;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v61, v62) )
          __debugbreak();
      }
      v44 = (float)(fireFraction * swayDef->fireTorsoDeadzoneScale) + (float)(1.0 - fireFraction);
      *(float *)((char *)p_torsoGoalViewSpeedToMaxDeadzone_viewspeed->v + v38) = v43;
      if ( v37 >= 2 )
      {
        LODWORD(v62) = 2;
        LODWORD(v61) = v37;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v61, v62) )
          __debugbreak();
      }
      *(float *)((char *)p_torsoGoalViewSpeedToMaxDeadzone_viewspeed->v + v38) = v43 * v44;
      p_torsoGoalViewSpeedToMaxDeadzone_viewspeed = (vec2_t *)((char *)p_torsoGoalViewSpeedToMaxDeadzone_viewspeed + 4);
      v39 = ++v37 < 2;
    }
    while ( (int)v37 < 2 );
    p_m_deadzone = &this->m_deadzone;
    v46 = 0;
    v47 = (char *)&v66 - (char *)&this->m_deadzone;
    v48 = 0;
    v49 = (char *)&swayDef->torsoGoalDeadzoneAdjustSpeed - (char *)&v66;
    v50 = 1;
    do
    {
      if ( !v50 )
      {
        LODWORD(v62) = 2;
        LODWORD(v61) = v48;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 16, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v61, v62) )
          __debugbreak();
      }
      v51 = *(float *)((char *)p_m_deadzone->v + v47 + v49);
      if ( v48 >= 2 )
      {
        LODWORD(v62) = 2;
        LODWORD(v61) = v48;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v61, v62) )
          __debugbreak();
      }
      v52 = p_m_deadzone->v[0];
      if ( v48 >= 2 )
      {
        LODWORD(v62) = 2;
        LODWORD(v61) = v48;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v61, v62) )
          __debugbreak();
      }
      v53 = LinearTrack(*(float *)((char *)p_m_deadzone->v + v47), v52, v51, frametimeSecScaled);
      if ( v48 >= 2 )
      {
        LODWORD(v62) = 2;
        LODWORD(v61) = v48;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v61, v62) )
          __debugbreak();
      }
      p_m_deadzone->v[0] = *(float *)&v53;
      if ( v48 >= 2 )
      {
        LODWORD(v62) = 2;
        LODWORD(v61) = v48;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v61, v62) )
          __debugbreak();
      }
      v54 = (float)(1.0 - adsFraction) * p_m_deadzone->v[0];
      if ( v48 >= 2 )
      {
        LODWORD(v62) = 2;
        LODWORD(v61) = v48;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v61, v62) )
          __debugbreak();
      }
      p_m_deadzone->v[0] = v54;
      p_m_deadzone = (vec2_t *)((char *)p_m_deadzone + 4);
      v50 = ++v48 < 2;
    }
    while ( (int)v48 < 2 );
    p_m_prevViewAnglesOffset = &this->m_prevViewAnglesOffset;
    do
    {
      if ( v46 >= 3 )
      {
        LODWORD(v62) = 3;
        LODWORD(v61) = v46;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v61, v62) )
          __debugbreak();
      }
      if ( v46 >= 2 )
      {
        LODWORD(v62) = 2;
        LODWORD(v61) = v46;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 21, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v61, v62) )
          __debugbreak();
      }
      if ( v46 >= 3 )
      {
        LODWORD(v62) = 3;
        LODWORD(v61) = v46;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v61, v62) )
          __debugbreak();
      }
      _XMM0 = LODWORD(p_m_prevViewAnglesOffset->v[0]) & (unsigned __int128)(unsigned int)_xmm;
      __asm { vminss  xmm6, xmm0, xmm6 }
      if ( v46 >= 3 )
      {
        LODWORD(v62) = 3;
        LODWORD(v61) = v46;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v61, v62) )
          __debugbreak();
      }
      p_m_prevViewAnglesOffset->v[0] = *(float *)&_XMM6;
      if ( v46 >= 3 )
      {
        LODWORD(v62) = 3;
        LODWORD(v61) = v46;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v61, v62) )
          __debugbreak();
      }
      _XMM1 = LODWORD(p_m_prevViewAnglesOffset->v[0]) ^ (unsigned __int128)(unsigned int)_xmm;
      __asm
      {
        vcmpless xmm0, xmm9, xmm7
        vblendvps xmm0, xmm1, xmm2, xmm0
      }
      p_m_prevViewAnglesOffset->v[0] = *(float *)&_XMM0;
      p_m_prevViewAnglesOffset = (vec3_t *)((char *)p_m_prevViewAnglesOffset + 4);
      ++v46;
    }
    while ( (int)v46 < 2 );
    *(double *)this->m_prevViewAngles.v = *(double *)viewAngles->v;
    this->m_prevViewAngles.v[2] = viewAngles->v[2];
    this->m_deadzoneGoal = v66;
  }
  else
  {
    this->m_prevViewAngles = *viewAngles;
    this->m_prevViewAnglesOffset = vec3_origin;
    this->m_viewVelocityScaled = 0i64;
    this->m_deadzone = 0i64;
    this->m_isInitialized = 1;
  }
}

/*
==============
AdvancedSwayGunDir::Update
==============
*/
void AdvancedSwayGunDir::Update(AdvancedSwayGunDir *this, const AdvancedHipSwaySettings *const swayDef, const vec3_t *offsetAngles, const vec3_t *offsetVelocity, float frametimeSecScaled, const vec3_t *angleVelocityWorldScaled, float fireFraction)
{
  const dvar_t *v12; 
  __m128 v13; 
  __m128 v14; 
  __int128 v16; 
  vec2_t *p_gunGoalViewSpeedToOffset_viewspeed; 
  __m128 v23; 
  unsigned int v29; 
  float v30; 
  float v31; 
  double ValueFromFraction; 
  float v33; 
  float v37; 
  float v38; 
  float v39; 
  __int64 v40; 
  __int64 v41; 
  __int128 v44; 
  __m128 v45; 

  _RSI = this;
  if ( this->m_isInitialized )
  {
    _XMM7 = 0i64;
    __asm { vxorpd  xmm9, xmm9, xmm9 }
    if ( frametimeSecScaled <= 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 925, ASSERT_TYPE_ASSERT, "( 0.0f ) < ( frametimeSecScaled )", "%s < %s\n\t%g, %g", "0.0f", "frametimeSecScaled", *(double *)&_XMM9, frametimeSecScaled) )
      __debugbreak();
    v12 = DCONST_DVARBOOL_advancedSwayGunDirEnabled;
    if ( !DCONST_DVARBOOL_advancedSwayGunDirEnabled && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "advancedSwayGunDirEnabled") )
      __debugbreak();
    Dvar_CheckFrontendServerThread(v12);
    if ( v12->current.enabled )
    {
      if ( frametimeSecScaled <= 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 934, ASSERT_TYPE_ASSERT, "( 0.0f ) < ( frametimeSecScaled )", "%s < %s\n\t%g, %g", "0.0f", "frametimeSecScaled", *(double *)&_XMM9, frametimeSecScaled) )
        __debugbreak();
      v13 = 0i64;
      v13.m128_f32[0] = (float)((float)swayDef->gunGoalViewSmoothDurationMs * 0.001) / frametimeSecScaled;
      v14 = v13;
      HIDWORD(v44) = 0;
      v16 = v44;
      *(float *)&v16 = angleVelocityWorldScaled->v[0];
      _XMM4 = v16;
      __asm
      {
        vinsertps xmm4, xmm4, dword ptr [rdi+4], 10h
        vinsertps xmm4, xmm4, dword ptr [rdi+8], 20h ; ' '
      }
      v45 = _XMM4;
      _XMM5 = _mm_shuffle_ps(v14, v14, 0);
      __asm { vrcpps  xmm1, xmm5 }
      p_gunGoalViewSpeedToOffset_viewspeed = &swayDef->gunGoalViewSpeedToOffset_viewspeed;
      v45.m128_i32[3] = 0;
      v23 = v45;
      v23.m128_f32[0] = _RSI->m_smoothedWorldVelocity.v[0];
      _XMM3 = v23;
      __asm
      {
        vinsertps xmm3, xmm3, dword ptr [rsi+4], 10h
        vinsertps xmm3, xmm3, dword ptr [rsi+8], 20h ; ' '
        vcmpleps xmm0, xmm5, xmmword ptr cs:?g_one@@3Ufloat4@@B.v; float4 const g_one
      }
      _XMM3 = _mm128_add_ps(_mm128_mul_ps(_XMM4, _XMM1), _mm128_sub_ps(_XMM3, _mm128_mul_ps(_XMM1, _XMM3)));
      __asm { vblendvps xmm1, xmm3, xmm4, xmm0 }
      _RSI->m_smoothedWorldVelocity.v[0] = *(float *)&_XMM1;
      v29 = 0;
      __asm
      {
        vextractps dword ptr [rsi+4], xmm1, 1
        vextractps dword ptr [rsi+8], xmm1, 2
      }
      do
      {
        if ( v29 >= 3 )
        {
          LODWORD(v41) = 3;
          LODWORD(v40) = v29;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v40, v41) )
            __debugbreak();
        }
        if ( v29 >= 2 )
        {
          LODWORD(v41) = 2;
          LODWORD(v40) = v29;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 16, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v40, v41) )
            __debugbreak();
        }
        if ( p_gunGoalViewSpeedToOffset_viewspeed->v[0] <= 0.0 )
        {
          if ( v29 >= 2 )
          {
            LODWORD(v41) = 2;
            LODWORD(v40) = v29;
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 16, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v40, v41) )
              __debugbreak();
          }
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 946, ASSERT_TYPE_ASSERT, "( 0.0f ) < ( swayDef->gunGoalViewSpeedToOffset_viewspeed[axis] )", "%s < %s\n\t%g, %g", "0.0f", "swayDef->gunGoalViewSpeedToOffset_viewspeed[axis]", *(double *)&_XMM9, p_gunGoalViewSpeedToOffset_viewspeed->v[0]) )
            __debugbreak();
        }
        if ( v29 >= 3 )
        {
          LODWORD(v41) = 3;
          LODWORD(v40) = v29;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v40, v41) )
            __debugbreak();
        }
        LODWORD(v30) = *(_DWORD *)((_BYTE *)p_gunGoalViewSpeedToOffset_viewspeed->v + (char *)_RSI - (char *)&swayDef->gunGoalViewSpeedToOffset_viewspeed) & _xmm;
        if ( v29 >= 2 )
        {
          LODWORD(v41) = 2;
          LODWORD(v40) = v29;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 16, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v40, v41) )
            __debugbreak();
        }
        v31 = v30 / p_gunGoalViewSpeedToOffset_viewspeed->v[0];
        I_fclamp(v31, 0.0, 1.0);
        ValueFromFraction = GraphGetValueFromFraction(swayDef->gunGoalViewSpeedToOffset_graph->knotCount, swayDef->gunGoalViewSpeedToOffset_graph->knots, v31);
        v33 = *(float *)&ValueFromFraction;
        if ( v29 >= 2 )
        {
          LODWORD(v41) = 2;
          LODWORD(v40) = v29;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 16, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v40, v41) )
            __debugbreak();
        }
        _XMM1 = LODWORD(p_gunGoalViewSpeedToOffset_viewspeed[1].v[0]) ^ (unsigned __int128)(unsigned int)_xmm;
        __asm
        {
          vcmpless xmm0, xmm7, xmm8
          vblendvps xmm0, xmm1, xmm2, xmm0
        }
        if ( v29 >= 3 )
        {
          LODWORD(v41) = 3;
          LODWORD(v40) = v29;
          if ( CoreAssert_Handler("c:\\workspace\\iw8\\shared\\codware\\core\\core_vec_types.h", 53, ASSERT_TYPE_SANITY, "(unsigned)( idx ) < (unsigned)( ( sizeof( *array_counter( v ) ) + 0 ) )", "idx doesn't index ARRAY_COUNT( v )\n\t%i not in [0, %i)", v40, v41) )
            __debugbreak();
        }
        *(float *)((char *)p_gunGoalViewSpeedToOffset_viewspeed->v + (char *)&_RSI->m_gunAnglesOffset - (char *)&swayDef->gunGoalViewSpeedToOffset_viewspeed) = *(float *)&_XMM0 * v33;
        p_gunGoalViewSpeedToOffset_viewspeed = (vec2_t *)((char *)p_gunGoalViewSpeedToOffset_viewspeed + 4);
        ++v29;
      }
      while ( (int)v29 < 2 );
      this->m_gunAnglesOffset.v[2] = 0.0;
      if ( fireFraction > 0.0 )
      {
        v37 = offsetAngles->v[1];
        v38 = offsetAngles->v[2];
        v39 = swayDef->fireTorsoToGunDirScale - 1.0;
        this->m_gunAnglesOffset.v[0] = (float)((float)((float)(v39 * offsetAngles->v[0]) - this->m_gunAnglesOffset.v[0]) * fireFraction) + this->m_gunAnglesOffset.v[0];
        this->m_gunAnglesOffset.v[1] = (float)((float)((float)(v39 * v37) - this->m_gunAnglesOffset.v[1]) * fireFraction) + this->m_gunAnglesOffset.v[1];
        this->m_gunAnglesOffset.v[2] = (float)((float)((float)(v39 * v38) - this->m_gunAnglesOffset.v[2]) * fireFraction) + this->m_gunAnglesOffset.v[2];
      }
    }
    else
    {
      _RSI->m_gunAnglesOffset = vec3_origin;
    }
  }
  else
  {
    this->m_smoothedWorldVelocity = vec3_origin;
    this->m_gunAnglesOffset = vec3_origin;
    this->m_isInitialized = 1;
  }
}

/*
==============
AdvancedSwaySprings::Update
==============
*/
void AdvancedSwaySprings::Update(AdvancedSwaySprings *this, const bool enabled, const vec2_t *massConst, const vec2_t *springConst, const vec2_t *damperConst, const vec3_t *goalAnglesOffset, float frametimeSecScaled)
{
  __int128 v8; 
  __int128 v9; 
  __int128 v10; 
  __int128 v11; 
  __int128 v12; 
  __int128 v13; 
  bool v16; 
  float v21; 
  __int128 v23; 
  __int128 v26; 
  __m128 v29; 
  __m128 v33; 
  __m128 v37; 
  __m128 v41; 
  __m128 v47; 
  __m128 v52; 
  __m128 v53; 
  unsigned __int64 v60; 
  __m128 v61; 
  __m128 v62; 
  __m128 v63; 
  __m128 v64; 
  vec3_t v3; 
  __int128 v66; 
  __int128 v67; 
  __int128 v68; 
  __int128 v69; 
  __int128 v70; 
  __int128 v71; 
  __int128 v72; 

  _RBX = this;
  if ( enabled )
  {
    v16 = !this->m_isInitialized;
    v72 = _XMM8;
    v71 = v8;
    v70 = v9;
    v69 = v10;
    v68 = v11;
    v67 = v12;
    v66 = v13;
    if ( v16 )
    {
      this->m_prevSpringOffset = *goalAnglesOffset;
      *(_QWORD *)this->m_prevSpringVelocity.v = 0i64;
      this->m_prevSpringVelocity.v[2] = 0.0;
      this->m_prevSpringGoalAnglesOffset = *goalAnglesOffset;
      this->m_isInitialized = 1;
    }
    __asm { vxorpd  xmm8, xmm8, xmm8 }
    if ( frametimeSecScaled <= 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 862, ASSERT_TYPE_ASSERT, "( 0.0f ) < ( frametimeSecScaled )", "%s < %s\n\t%g, %g", "0.0f", "frametimeSecScaled", *(double *)&_XMM8, frametimeSecScaled) )
      __debugbreak();
    AnglesSubtract(goalAnglesOffset, &_RBX->m_prevSpringGoalAnglesOffset, &v3);
    if ( frametimeSecScaled <= 0.0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 867, ASSERT_TYPE_ASSERT, "( 0.0f ) < ( frametimeSecScaled )", "%s < %s\n\t%g, %g", "0.0f", "frametimeSecScaled", *(double *)&_XMM8, frametimeSecScaled) )
      __debugbreak();
    _XMM11 = _xmm;
    __asm
    {
      vinsertps xmm11, xmm11, dword ptr [r14], 0
      vinsertps xmm11, xmm11, dword ptr [r14+4], 10h
    }
    v21 = (float)(1.0 / frametimeSecScaled) * v3.v[2];
    v23 = v60;
    *(float *)&v23 = springConst->v[0];
    _XMM7 = v23;
    __asm { vinsertps xmm7, xmm7, dword ptr [r15+4], 10h }
    v26 = _XMM7.m128_u64[0];
    *(float *)&v26 = damperConst->v[0];
    _XMM10 = v26;
    __asm { vinsertps xmm10, xmm10, dword ptr [r12+4], 10h }
    v61 = _XMM10;
    v61.m128_i32[3] = 0;
    v29 = v61;
    v29.m128_f32[0] = goalAnglesOffset->v[0];
    _XMM12 = v29;
    __asm
    {
      vinsertps xmm12, xmm12, dword ptr [rdi+4], 10h
      vinsertps xmm12, xmm12, dword ptr [rdi+8], 20h ; ' '
    }
    v62 = _XMM12;
    v62.m128_i32[3] = 0;
    v33 = v62;
    v33.m128_f32[0] = (float)(1.0 / frametimeSecScaled) * v3.v[0];
    _XMM13 = v33;
    __asm
    {
      vinsertps xmm13, xmm13, xmm4, 10h
      vinsertps xmm13, xmm13, xmm15, 20h ; ' '
    }
    v63 = _XMM13;
    v63.m128_i32[3] = 0;
    v37 = v63;
    v37.m128_f32[0] = _RBX->m_prevSpringOffset.v[0];
    _XMM9 = v37;
    __asm
    {
      vinsertps xmm9, xmm9, dword ptr [rbx+4], 10h
      vinsertps xmm9, xmm9, dword ptr [rbx+8], 20h ; ' '
    }
    v64 = _XMM9;
    v64.m128_i32[3] = 0;
    v41 = v64;
    v41.m128_f32[0] = _RBX->m_prevSpringVelocity.v[0];
    _XMM14 = v41;
    __asm
    {
      vinsertps xmm14, xmm14, dword ptr [rbx+10h], 10h
      vinsertps xmm14, xmm14, dword ptr [rbx+14h], 20h ; ' '
    }
    _XMM6 = 0i64;
    __asm
    {
      vcmpltps xmm0, xmm6, xmm11
      vmovmskps eax, xmm0
    }
    v47 = _mm_shuffle_ps((__m128)LODWORD(frametimeSecScaled), (__m128)LODWORD(frametimeSecScaled), 0);
    if ( (_EAX & 0xF) != 15 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\com_vector4.h", 440, ASSERT_TYPE_ASSERT, "(!Float4AnyLe( mass, Float4Zero() ))", (const char *)&queryFormat, "!Float4AnyLe( mass, g_zero )") )
      __debugbreak();
    __asm
    {
      vcmpltps xmm0, xmm7, xmm6
      vmovmskps eax, xmm0
    }
    if ( (_EAX & 0xF) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\com_vector4.h", 441, ASSERT_TYPE_ASSERT, "(!Float4AnyLt( springConstant, Float4Zero() ))", (const char *)&queryFormat, "!Float4AnyLt( springConstant, g_zero )") )
      __debugbreak();
    __asm
    {
      vcmpltps xmm0, xmm10, xmm6
      vmovmskps eax, xmm0
    }
    if ( (_EAX & 0xF) != 0 && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\com_vector4.h", 442, ASSERT_TYPE_ASSERT, "(!Float4AnyLt( damperConstant, Float4Zero() ))", (const char *)&queryFormat, "!Float4AnyLt( damperConstant, g_zero )") )
      __debugbreak();
    v52 = _mm128_div_ps(_XMM7, _XMM11);
    v53 = _mm128_div_ps(_XMM10, _XMM11);
    _XMM7 = _mm128_div_ps(_mm128_add_ps(_mm128_mul_ps(_XMM13, _mm128_mul_ps(v47, v53)), _mm128_sub_ps(_XMM14, _mm128_mul_ps(_mm128_sub_ps(_XMM9, _XMM12), _mm128_mul_ps(v47, v52)))), _mm128_add_ps(_mm128_mul_ps(v47, v53), _mm128_add_ps(_mm128_mul_ps(v52, _mm128_mul_ps(v47, v47)), g_one.v)));
    __asm
    {
      vcmpneqps xmm1, xmm7, xmm7
      vmovmskps eax, xmm1
    }
    if ( _EAX && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\com_vector4.h", 475, ASSERT_TYPE_SANITY, "( !Float4IsNaN( inOutMassVelocity ) )", (const char *)&queryFormat, "!Float4IsNaN( inOutMassVelocity )") )
      __debugbreak();
    _XMM6 = _mm128_add_ps(_mm128_mul_ps(v47, _XMM7), _XMM9);
    __asm
    {
      vcmpneqps xmm1, xmm6, xmm6
      vmovmskps eax, xmm1
    }
    if ( _EAX )
    {
      if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\com_vector4.h", 477, ASSERT_TYPE_SANITY, "( !Float4IsNaN( inOutMassPos ) )", (const char *)&queryFormat, "!Float4IsNaN( inOutMassPos )") )
        __debugbreak();
    }
    _RBX->m_prevSpringOffset.v[0] = _XMM6.m128_f32[0];
    __asm
    {
      vextractps dword ptr [rbx+4], xmm6, 1
      vextractps dword ptr [rbx+8], xmm6, 2
    }
    _RBX->m_prevSpringVelocity.v[0] = _XMM7.m128_f32[0];
    __asm
    {
      vextractps dword ptr [rbx+10h], xmm7, 1
      vextractps dword ptr [rbx+14h], xmm7, 2
    }
    _RBX->m_prevSpringGoalAnglesOffset = *goalAnglesOffset;
    _RBX->m_prevSpringOffset.v[2] = goalAnglesOffset->v[2];
    _RBX->m_prevSpringVelocity.v[2] = v21;
  }
  else
  {
    this->m_isInitialized = 0;
  }
}

/*
==============
AdvancedSwayState::Update
==============
*/
void AdvancedSwayState::Update(AdvancedSwayState *this, const cg_t *const cgameGlob, const vec3_t *viewmodelAngles)
{
  __int128 xmm10_0; 
  __int64 localClientNum; 
  playerState_s *p_predictedPlayerState; 
  CgWeaponMap *v9; 
  float correctedWeaponPosFrac; 
  double OffhandAdsFrac; 
  float frametimeInputSec; 
  const dvar_t *v14; 
  int m_prevInputTime; 
  int commandTimeInterpolated; 
  const Weapon *ViewmodelWeapon; 
  bool v18; 
  int v19; 
  float v20; 
  int v21; 
  int WeaponHandForViewWeapon; 
  int *p_weaponFireTime; 
  __int64 v24; 
  int v25; 
  int v26; 
  float m_prevFireFraction; 
  int fireFinishBlendDurationMs; 
  __int128 v32; 
  __int128 v34; 
  __int128 v35; 
  float v36; 
  float v37; 
  __int128 v38; 
  float v39; 
  LocalClientNum_t v40; 
  bool v41; 
  __int128 v44; 
  float v45; 
  double v47; 
  float v48; 
  float v49; 
  double v50; 
  bool Bool_Internal_DebugName; 
  float v52; 
  float v53; 
  bool v54; 
  float fireFraction; 
  char v56; 
  vec3_t offsetVelocity; 
  vec3_t goalAnglesOffset; 
  vec3_t v1; 
  vec3_t v3; 
  vec3_t viewAngleVelocityScaled; 
  vec3_t v62; 
  vec3_t offsetAngles; 
  vec3_t v64; 
  SwaySettings outSwaySettings; 
  __int128 v66; 

  localClientNum = cgameGlob->localClientNum;
  p_predictedPlayerState = &cgameGlob->predictedPlayerState;
  if ( !CgWeaponMap::ms_instance[localClientNum] && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_weapon_map.h", 60, ASSERT_TYPE_ASSERT, "(ms_instance[localClientNum])", (const char *)&queryFormat, "ms_instance[localClientNum]") )
    __debugbreak();
  v9 = CgWeaponMap::ms_instance[localClientNum];
  correctedWeaponPosFrac = cgameGlob->weaponPosFracAnimData.correctedWeaponPosFrac;
  if ( BG_IsUsingOffhandGestureWeaponADSSupport(v9, p_predictedPlayerState) )
  {
    OffhandAdsFrac = BG_GetOffhandAdsFrac(p_predictedPlayerState);
    correctedWeaponPosFrac = *(float *)&OffhandAdsFrac;
  }
  this->m_prevAdsFraction = correctedWeaponPosFrac;
  if ( !p_predictedPlayerState && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\bgame\\bg_public.h", 2275, ASSERT_TYPE_ASSERT, "(ps)", (const char *)&queryFormat, "ps") )
    __debugbreak();
  _XMM8 = 0i64;
  if ( !GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&p_predictedPlayerState->otherFlags, GameModeFlagValues::ms_mpValue, 0x21u) && !CG_View_IsKillCamView((const LocalClientNum_t)cgameGlob->localClientNum) )
  {
    frametimeInputSec = cgameGlob->frametimeInputSec;
    v56 = 0;
    goto LABEL_20;
  }
  v14 = DCONST_DVARBOOL_advancedSwayEnabledSpectate;
  v56 = 1;
  if ( !DCONST_DVARBOOL_advancedSwayEnabledSpectate && CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\universal\\dvar.h", 692, ASSERT_TYPE_ASSERT, "(dvar)", "%s\n\tDvar %s accessed after deregistration", "dvar", "advancedSwayEnabledSpectate") )
    __debugbreak();
  Dvar_CheckFrontendServerThread(v14);
  if ( v14->current.enabled )
  {
    m_prevInputTime = this->m_prevInputTime;
    commandTimeInterpolated = p_predictedPlayerState->commandTimeInterpolated;
    if ( m_prevInputTime <= 0 )
      frametimeInputSec = 0.0;
    else
      frametimeInputSec = (float)(commandTimeInterpolated - m_prevInputTime) * 0.001;
    this->m_prevInputTime = commandTimeInterpolated;
LABEL_20:
    *(_QWORD *)this->m_angularVelocity.v = 0i64;
    this->m_angularVelocity.v[2] = 0.0;
    this->m_frametimeSec = frametimeInputSec;
    if ( frametimeInputSec > 0.0 )
    {
      if ( GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&p_predictedPlayerState->otherFlags, ACTIVE, 0x1Fu) || GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&p_predictedPlayerState->otherFlags, ACTIVE, 0x20u) || p_predictedPlayerState->pm_type == 5 && !GameModeFlagContainer<enum POtherFlagsCommon,enum POtherFlagsSP,enum POtherFlagsMP,64>::TestFlagInternal(&p_predictedPlayerState->otherFlags, GameModeFlagValues::ms_mpValue, 0x21u) || ((ViewmodelWeapon = BG_GetViewmodelWeapon(v9, p_predictedPlayerState), GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&p_predictedPlayerState->weapCommon.weapFlags, ACTIVE, 0x22u)) || !GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&p_predictedPlayerState->weapCommon.weapFlags, ACTIVE, 0x11u) && !GameModeFlagContainer<enum PWeaponFlagsCommon,enum PWeaponFlagsSP,enum PWeaponFlagsMP,64>::TestFlagInternal(&p_predictedPlayerState->weapCommon.weapFlags, ACTIVE, 0x1Bu) ? (v18 = 0) : (v18 = 1), (BG_GetSwaySettings(v9, p_predictedPlayerState, ViewmodelWeapon, v18, &outSwaySettings), BG_ProceduralGunMotionDisabled(p_predictedPlayerState)) || !Dvar_GetBool_Internal_DebugName(DCONST_DVARBOOL_advancedSwayEnabled, "advancedSwayEnabled") || !outSwaySettings.adv.enabled) )
      {
        this->m_isInitialized = 0;
      }
      else
      {
        *(__m256i *)&this->m_weapon.weaponIdx = *(__m256i *)&ViewmodelWeapon->weaponIdx;
        *(_OWORD *)&this->m_weapon.attachmentVariationIndices[5] = *(_OWORD *)&ViewmodelWeapon->attachmentVariationIndices[5];
        *(double *)&this->m_weapon.attachmentVariationIndices[21] = *(double *)&ViewmodelWeapon->attachmentVariationIndices[21];
        v19 = *(_DWORD *)&ViewmodelWeapon->weaponCamo;
        this->m_isAlternate = v18;
        *(_DWORD *)&this->m_weapon.weaponCamo = v19;
        if ( this->m_isInitialized )
        {
          v20 = outSwaySettings.adv.gunPivotPoint.v[2];
          *(double *)this->m_pivotPoint.v = *(double *)outSwaySettings.adv.gunPivotPoint.v;
          v21 = 0;
          this->m_yawToRollScale = outSwaySettings.adv.gunYawToRollScale;
          v66 = xmm10_0;
          this->m_pivotPoint.v[2] = v20;
          WeaponHandForViewWeapon = BG_PlayerLastWeaponHandForViewWeapon(v9, p_predictedPlayerState);
          if ( WeaponHandForViewWeapon >= 0 )
          {
            p_weaponFireTime = &p_predictedPlayerState->weapState[0].weaponFireTime;
            v24 = WeaponHandForViewWeapon + 1i64;
            do
            {
              v25 = v21;
              v21 = *p_weaponFireTime;
              p_weaponFireTime += 20;
              if ( v25 >= v21 )
                v21 = v25;
              --v24;
            }
            while ( v24 );
          }
          v26 = 0;
          m_prevFireFraction = this->m_prevFireFraction;
          if ( p_predictedPlayerState->serverTime - v21 > 0 )
            v26 = p_predictedPlayerState->serverTime - v21;
          _XMM0 = (unsigned int)(outSwaySettings.adv.fireDurationMs - v26);
          fireFinishBlendDurationMs = outSwaySettings.adv.fireFinishBlendDurationMs;
          __asm
          {
            vpcmpgtd xmm2, xmm0, xmm1
            vblendvps xmm9, xmm8, xmm6, xmm2
          }
          if ( *(float *)&_XMM9 > m_prevFireFraction )
            fireFinishBlendDurationMs = outSwaySettings.adv.fireStartBlendDurationMs;
          v32 = 0i64;
          *(float *)&v32 = (float)fireFinishBlendDurationMs * 0.001;
          _XMM1 = v32;
          v35 = LODWORD(FLOAT_1_0);
          *(float *)&v35 = 1.0 / frametimeInputSec;
          v34 = v35;
          v36 = *(float *)&_XMM1 * (float)(1.0 / frametimeInputSec);
          if ( v36 > 1.0 )
          {
            v38 = LODWORD(FLOAT_1_0);
            *(float *)&v38 = (float)(1.0 / v36) * *(float *)&_XMM9;
            _XMM1 = v38;
            v37 = (float)(m_prevFireFraction - (float)((float)(1.0 / v36) * m_prevFireFraction)) + *(float *)&v38;
          }
          else
          {
            v37 = *(float *)&_XMM9;
          }
          this->m_prevFireFraction = v37;
          v39 = viewmodelAngles->v[2];
          v40 = cgameGlob->localClientNum;
          *(_QWORD *)v1.v = *(_QWORD *)viewmodelAngles->v;
          v1.v[2] = v39;
          v41 = !CL_Input_IsGamepadEnabled(v40);
          if ( !Dvar_GetBool_Internal_DebugName(DCONST_DVARBOOL_advancedSwayViewmodelSmoothingEnabled, "advancedSwayViewmodelSmoothingEnabled") || v56 || Dvar_GetBool_Internal_DebugName(DCONST_DVARBOOL_cl_inputVelocityLogging, "cl_inputVelocityLogging") || v41 && !Dvar_GetBool_Internal_DebugName(DCONST_DVARBOOL_advancedSwayViewmodelSmoothingEnabled_mouse, "advancedSwayViewmodelSmoothingEnabled_mouse") )
            this->m_smoothing.m_initialized = 0;
          else
            AngularSmoothing::Update(&this->m_smoothing, cgameGlob, 0.0, frametimeInputSec, (float)((float)(1.0 - this->m_prevFireFraction) * outSwaySettings.adv.torsoGoalSmoothSpeed) + (float)(this->m_prevFireFraction * outSwaySettings.adv.fireTorsoGoalSmoothSpeed), &v1);
          AnglesSubtract(&v1, &this->m_prevViewmodelAnglesSmoothed, &v3);
          if ( frametimeInputSec <= 0.0 )
          {
            __asm { vxorpd  xmm1, xmm1, xmm1 }
            if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 1173, ASSERT_TYPE_ASSERT, "( 0.0f ) < ( frametimeSec )", "%s < %s\n\t%g, %g", "0.0f", "frametimeSec", *(double *)&_XMM1, frametimeInputSec) )
              __debugbreak();
          }
          v44 = v34;
          *(float *)&v44 = *(float *)&v34 * v3.v[0];
          _XMM3 = v44;
          v45 = *(float *)&v34 * v3.v[1];
          *(float *)&v44 = *(float *)&v34 * v3.v[2];
          __asm { vunpcklps xmm0, xmm3, xmm8 }
          *(double *)this->m_angularVelocity.v = *(double *)&_XMM0;
          viewAngleVelocityScaled.v[2] = *(float *)&v44;
          LODWORD(this->m_angularVelocity.v[2]) = v44;
          *(double *)viewAngleVelocityScaled.v = *(double *)&_XMM0;
          if ( Dvar_GetBool_Internal_DebugName(DCONST_DVARBOOL_cl_inputVelocityLogging, "cl_inputVelocityLogging") )
          {
            Com_Printf(0, "VM time:    %.4f\n", frametimeInputSec);
            v47 = AngleNormalize360(viewmodelAngles->v[1] - p_predictedPlayerState->delta_angles.v[1]);
            Com_Printf(0, "VM yaw:     %.4f\n", *(float *)&v47);
            Com_Printf(0, "VM yawDelt: %.4f\n", COERCE_FLOAT(LODWORD(v3.v[1]) & _xmm));
            Com_Printf(0, "VM yawRate: %.4f\n", COERCE_FLOAT(LODWORD(v45) & _xmm));
          }
          *(double *)this->m_prevViewmodelAngles.v = *(double *)viewmodelAngles->v;
          v48 = viewmodelAngles->v[2];
          *(double *)this->m_prevViewmodelAnglesSmoothed.v = *(double *)v1.v;
          v49 = this->m_prevFireFraction;
          this->m_prevViewmodelAngles.v[2] = v48;
          this->m_prevViewmodelAnglesSmoothed.v[2] = v1.v[2];
          AdvancedSwayDeadzone::Update(&this->m_torsoGoal, &outSwaySettings.adv, &v1, frametimeInputSec, &viewAngleVelocityScaled, correctedWeaponPosFrac, v49);
          v50 = *(double *)this->m_torsoGoal.m_prevViewAnglesOffset.v;
          goalAnglesOffset.v[2] = this->m_torsoGoal.m_prevViewAnglesOffset.v[2];
          *(double *)goalAnglesOffset.v = v50;
          AnglesSubtract(&this->m_prevViewmodelAnglesSmoothed, &this->m_prevViewmodelAngles, &v62);
          goalAnglesOffset.v[0] = goalAnglesOffset.v[0] + v62.v[0];
          goalAnglesOffset.v[2] = goalAnglesOffset.v[2] + v62.v[2];
          goalAnglesOffset.v[1] = goalAnglesOffset.v[1] + v62.v[1];
          Bool_Internal_DebugName = Dvar_GetBool_Internal_DebugName(DCONST_DVARBOOL_advancedSwayGunTorsoSpringDamperEnabled, "advancedSwayGunTorsoSpringDamperEnabled");
          AdvancedSwaySprings::Update(&this->m_torsoSprings, Bool_Internal_DebugName, &outSwaySettings.adv.torsoMass, &outSwaySettings.adv.torsoSpring, &outSwaySettings.adv.torsoDamper, &goalAnglesOffset, frametimeInputSec);
          v52 = this->m_torsoSprings.m_prevSpringOffset.v[2];
          *(_QWORD *)offsetAngles.v = *(_QWORD *)this->m_torsoSprings.m_prevSpringOffset.v;
          fireFraction = this->m_prevFireFraction;
          offsetAngles.v[2] = v52;
          AdvancedSwayGunDir::Update(&this->m_gunGoal, &outSwaySettings.adv, &offsetAngles, &offsetVelocity, frametimeInputSec, &viewAngleVelocityScaled, fireFraction);
          v53 = this->m_gunGoal.m_gunAnglesOffset.v[2];
          *(_QWORD *)v64.v = *(_QWORD *)this->m_gunGoal.m_gunAnglesOffset.v;
          v64.v[2] = v53;
          v54 = Dvar_GetBool_Internal_DebugName(DCONST_DVARBOOL_advancedSwayGunDirSpringDamperEnabled, "advancedSwayGunDirSpringDamperEnabled");
          AdvancedSwaySprings::Update(&this->m_gunSprings, v54, &outSwaySettings.adv.gunMass, &outSwaySettings.adv.gunSpring, &outSwaySettings.adv.gunDamper, &v64, frametimeInputSec);
          this->m_prevGoalFireFraction = *(float *)&_XMM9;
        }
        else
        {
          this->m_smoothing.m_initialized = 0;
          this->m_torsoGoal.m_isInitialized = 0;
          this->m_torsoSprings.m_isInitialized = 0;
          this->m_gunGoal.m_isInitialized = 0;
          this->m_gunSprings.m_isInitialized = 0;
          *(double *)this->m_prevViewmodelAnglesSmoothed.v = *(double *)viewmodelAngles->v;
          this->m_prevViewmodelAnglesSmoothed.v[2] = viewmodelAngles->v[2];
          this->m_prevFireFraction = 0.0;
          this->m_pivotPoint = vec3_origin;
          *(_QWORD *)&this->m_yawToRollScale = 0i64;
          this->m_prevGoalFireFraction = 0.0;
          this->m_isInitialized = 1;
        }
      }
    }
  }
}

/*
==============
AngularSmoothing::Update
==============
*/

void __fastcall AngularSmoothing::Update(AngularSmoothing *this, const cg_t *const cgameGlob, double adsFrac, const float frametime, const float speed, vec3_t *inOutAngles)
{
  __int128 v9; 
  __m128 v; 
  __m128 v15; 
  __m128 v19; 
  __m256i v24; 
  CgHandler *Handler; 
  __m128 v27; 
  __int128 v31; 
  __m256i v32; 
  __m256i v34; 
  __m256i v36; 
  vector4 v38; 
  vector4 v39; 
  vector4 v40; 
  float4 v41; 
  vec3_t outUp; 
  tmat33_t<vec3_t> axis; 
  tmat33_t<vec3_t> v44; 
  WorldUpReferenceFrame v45; 

  v9 = *(_OWORD *)&adsFrac;
  AnglesToAxis(inOutAngles, &axis);
  v41.v.m128_i32[3] = 0;
  v = v41.v;
  v.m128_f32[0] = axis.m[0].v[0];
  _XMM3 = v;
  __asm
  {
    vinsertps xmm3, xmm3, dword ptr [rsp+1F8h+axis+4], 10h
    vinsertps xmm3, xmm3, dword ptr [rsp+1F8h+axis+8], 20h
  }
  v41.v = _XMM3;
  v38.x.v = _XMM3;
  v41.v.m128_i32[3] = 0;
  v15 = v41.v;
  v15.m128_f32[0] = axis.m[1].v[0];
  _XMM3 = v15;
  __asm
  {
    vinsertps xmm3, xmm3, dword ptr [rsp+1F8h+axis+10h], 10h
    vinsertps xmm3, xmm3, dword ptr [rsp+1F8h+axis+14h], 20h
  }
  v41.v = _XMM3;
  v38.y.v = _XMM3;
  v41.v.m128_i32[3] = 0;
  v19 = v41.v;
  v19.m128_f32[0] = axis.m[2].v[0];
  _XMM3 = v19;
  __asm
  {
    vinsertps xmm3, xmm3, dword ptr [rsp+1F8h+axis+1Ch], 10h
    vinsertps xmm3, xmm3, dword ptr [rsp+1F8h+axis+20h], 20h
  }
  _XMM1 = *(_OWORD *)&g_one.v & *(_OWORD *)&g_keepW.v;
  _XMM2 = *(_OWORD *)&g_one.v & *(_OWORD *)&g_keepW.v;
  v38.w = (float4)(*(_OWORD *)&g_one.v & *(_OWORD *)&g_keepW.v);
  v41.v = _XMM3;
  v38.z.v = _XMM3;
  if ( this->m_initialized )
  {
    if ( frametime > 0.0 )
    {
      Handler = CgHandler::getHandler(cgameGlob->localClientNum);
      WorldUpReferenceFrame::WorldUpReferenceFrame(&v45, &cgameGlob->predictedPlayerState, Handler);
      WorldUpReferenceFrame::GetUpVector(&v45, &outUp);
      v41.v.m128_i32[3] = 0;
      v27 = v41.v;
      v27.m128_f32[0] = outUp.v[0];
      _XMM3 = v27;
      __asm
      {
        vinsertps xmm3, xmm3, dword ptr [rsp+1F8h+outUp+4], 10h
        vinsertps xmm3, xmm3, dword ptr [rsp+1F8h+outUp+8], 20h
      }
      v41.v = _XMM3;
      if ( *(float *)&v9 < 0.0 || *(float *)&v9 > 1.0 )
      {
        __asm { vxorpd  xmm1, xmm1, xmm1 }
        *((_QWORD *)&v31 + 1) = *((_QWORD *)&v9 + 1);
        *(double *)&v31 = *(float *)&v9;
        _XMM2 = v31;
        if ( CoreAssert_Handler("c:\\workspace\\iw8\\code_source\\src\\cgame\\cg_view_motion.cpp", 1674, ASSERT_TYPE_ASSERT, "( 0.0f ) <= ( adsFrac ) && ( adsFrac ) <= ( 1.0f )", "adsFrac not in [0.0f, 1.0f]\n\t%g not in [%g, %g]", *(float *)&v9, *(double *)&_XMM1, DOUBLE_1_0) )
          __debugbreak();
      }
      v32 = *(__m256i *)this->m_prevAxis4.z.v.m128_f32;
      _XMM3 = LODWORD(speed);
      *(__m256i *)v39.x.v.m128_f32 = *(__m256i *)v38.x.v.m128_f32;
      v34 = *(__m256i *)this->m_prevAxis4.x.v.m128_f32;
      *(__m256i *)v39.z.v.m128_f32 = *(__m256i *)v38.z.v.m128_f32;
      *(__m256i *)v38.x.v.m128_f32 = v34;
      *(__m256i *)v38.z.v.m128_f32 = v32;
      CG_ViewMotion_SmoothBlend(1.0 - *(float *)&v9, frametime, &v41, speed, &v38, &v39, &v40);
      _YMM2 = *(__m256i *)v40.x.v.m128_f32;
      v36 = *(__m256i *)v40.z.v.m128_f32;
      *(__m256i *)this->m_prevAxis4.x.v.m128_f32 = *(__m256i *)v40.x.v.m128_f32;
      v44.m[0].v[0] = *(float *)&_XMM2;
      __asm
      {
        vextractps dword ptr [rsp+1F8h+var_B0+4], xmm2, 1
        vextractps dword ptr [rsp+1F8h+var_B0+8], xmm2, 2
        vextractf128 xmm2, ymm2, 1
      }
      v44.m[1].v[0] = *(float *)&_XMM2;
      __asm
      {
        vextractps dword ptr [rsp+1F8h+var_B0+10h], xmm2, 1
        vextractps dword ptr [rsp+1F8h+var_B0+14h], xmm2, 2
      }
      v44.m[2].v[0] = speed;
      __asm
      {
        vextractps dword ptr [rsp+1F8h+var_B0+1Ch], xmm3, 1
        vextractps dword ptr [rsp+1F8h+var_B0+20h], xmm3, 2
      }
      *(__m256i *)this->m_prevAxis4.z.v.m128_f32 = v36;
      AxisToAngles(&v44, inOutAngles);
    }
  }
  else
  {
    v24 = *(__m256i *)v38.z.v.m128_f32;
    *(__m256i *)this->m_prevAxis4.x.v.m128_f32 = *(__m256i *)v38.x.v.m128_f32;
    *(__m256i *)this->m_prevAxis4.z.v.m128_f32 = v24;
    this->m_initialized = 1;
  }
}

